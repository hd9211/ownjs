<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>8ddbc2b971837fa5725033ff1d1ae3fb</guid>
<title>从需求出发设计一条开源持续部署流水线</title>
<link>https://toutiao.io/k/we8gr61</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfUr0eQ0wjgLJuZ0pJ3X4rOmh1L6GoEau989Pb9aNch7mwm3ibzCAicVVA/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1080&quot; data-cropy1=&quot;216.74740484429063&quot; data-cropy2=&quot;607.2664359861591&quot; data-ratio=&quot;0.36203703703703705&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfS5ER1nE8P23KX8ib42JxT6sxOlicH5CcHiaEIPEsN896wia7jJu4KEE1Mg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本次实践从需求出发到部署，采用大部分开源工具链Jira+GitLab+Jenkins+Spinnaker. Jira作为需求和任务管理工具，集成GitLab实现需求与代码关联，自动创建特性分支和版本分支以及合并请求的创建。GitLab代码提交触发JenkinsCI流水线，这里CI指的是Jenkins来做构建、测试、扫描、生成镜像上传镜像操作。CD由Spinnaker对各个环境部署。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详细的内容在下面PPT：本此内容已经录制成视频教程，已经购买Jenkins实践课程的同学请耐心等待，预计两天内免费更新到课程中。欢迎更多的同学一起加入DevOps课程学习！目前还有优惠哦~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该项目涉及到Jenkins共享库中的Gitlab接口，Jenkinsfile，SPinnaker Pipeline模板。仓库地址：https://github.com/zeyangli/devops-practice  欢迎点赞关注！&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfra5HNbRWt7gmG7KN7RmmnbZZ66dr2ibPVNicc6MbZYbNwYD9rYH2hTsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYf3V8nVkJvzvKmwp4g1sSgEiagu8O6tibuzEoyXnbvN5Bn1fy4CdpNlwKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYf84zhWgcQO6WEJ0XSCBnciavUvtHo0SGSzCGb2R93otHyIgDRpkmHicyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfvtxmJn23LoXA6yz4vVN0nOvcOLyCiaSvvZRR9iacP8wKIwOfjibiaUttYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYf4nxvOASLguQR3CeRebvRRG2tU2FongxbbGUiceO6MChL63PgQt02QWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYf2A7NreiacYn4sdLFAZGdcR23I7Aiam2PP2qo3zd13mib1PT8Eq2r9LK7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfxguXCsgFuVmCcklTZyXzxXugWvY2vJbIIo0e4E0lNibCwklEdyutTmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYficWM0bIOaDT1LSlDYuNRQkhEoNfJ9YqOVtfjXribVP8bZgDulNxaCWcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfZpicKNQZSL3NnI2C99tB4Tzg5nHezoSXMvnCvmwQcsy1Mh9YkkFKPlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfJDs1Rvd1kttdvEo35SibfnWHiaiazdf6pFpct8vcO8VVaTibzJekA41Ing/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfZscMRlweexoAWdtTH0Kymo1Oheiag1XZbJCwuYWoSBfMUSGH3Gr8Y8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfu8ZyDhsek9OGznM1TeqIAicCGLL9WNMu98icSuMkfsicVrSEITyUx2sdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfILjI9KeBusicAPawHIdX7hWRqUKibZIXxYicIq7cuiaMcWp5mgVxyaaFkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfJE5eJS4lU1Mvn4r5pic1SmkHJXj71jt3fDrmO850JK6XDbpM1QbwPgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfCvyUO5ib7HktXuZaDZ6J8Ub7vHnFOVGefrpHHf6Qs7zxXU4OHJicyAcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfKWs1PvYic2Qwttjd63SxoiaYNLhHQfibtfEKsvBRNMZiaEPmnEAbCibXliaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfRqSA7pzibU8zibVoxbjEsIeCRKj8OQZWxPAD2IsDTlz5lfhjyzJaPjWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfCacn2HytkP15AqSMuutFYdzr7ncyzPJzw3rOG7ibH0NXFhDwGAG9Vxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYf9OQibBJQggqx3iciccsQPS6wbHXlxKMVTo9MGWHMrrRjTuKUhWSOicPrLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYfXGRwUl6ZwutGRVveZbxlQiceKJm1tevMvpj6KrBqCibHRlJw8iaDPxSZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPXD9d39EKBw3SEXgsGibdYficasnnXktm0z0FibKul8Uz8tB9iauAzjYnFWQgu2m8z0BrJ4kb5w9Pj5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;关于我们&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;泽阳，DevOps领域实践者。专注于企业级DevOps运维开发技术实践分享，主要以新Linux运维技术、DevOps技术课程为主。丰富的一线实战经验，课程追求实用性获得多数学员认可。课程内容均来源于企业应用，在这里既学习技术又能获取热门技能，欢迎您的到来！（微信ID: devopsvip）&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-id=&quot;2765&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;a class=&quot;weapp_image_link js_weapp_entry&quot; data-miniprogram-appid=&quot;wxa2c453d902cdd452&quot; data-miniprogram-path=&quot;pages/course/course?cid=2202770&quot; data-miniprogram-nickname=&quot;腾讯课堂&quot; href=&quot;&quot; data-miniprogram-type=&quot;image&quot; data-miniprogram-servicetype=&quot;&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3333333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/U1oibTqyKuTPn3ntHUn6mrurdKQYYNbeeqzxBg8DVwNRyibicSx6y3MC2HHHuqjzrmViacQ2V8VUqQjTFdqRDnN68Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;321&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/U1oibTqyKuTMCjxUVf8T4JUicFXc750HKUIMBGIXwaPOJv7HTejgyspc4RXDSfYL7Lequhz0gu4jAfN25PenKYOw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;DevOps流水线实践课程&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;👇戳阅读原文，进入课堂&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>eea1c954513458634287fe0d16e0aaf9</guid>
<title>Java 中的映射 Map（入门篇）</title>
<link>https://toutiao.io/k/2j4xsag</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;大家好啊，我是汤圆，今天给大家带来的是《Java中的映射Map - 入门篇》，希望对大家有帮助，谢谢&lt;/p&gt;

&lt;h2&gt;简介&lt;/h2&gt;

&lt;p&gt;前面介绍了集合List，这里开始简单介绍下映射&lt;code&gt;Map&lt;/code&gt;，相关类如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/30/kTAnEyP9cv1DXai.png&quot; alt=&quot;集合&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;正文&lt;/h2&gt;

&lt;p&gt;Map是一种存储键值对的数据集合，键以散列或者树形结构进行存储；&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;为什么会设计Map接口呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;假设我们有一个员工类，里面有Id属性和姓名等其他信息，现在我们把所有员工都存到List里，然后要找出Id为001的员工，你会发现，你需要从List中遍历每个对象，然后取出Id进行比较；&lt;/p&gt;

&lt;p&gt;你会发现这种查找法效率很低，有点杀鸡用牛刀的感觉；&lt;/p&gt;

&lt;p&gt;这时如果有一个集合类，可以以键值对映射的方式的存储员工信息（Id作为键，员工信息作为值），那么就可以只遍历键列表，然后进行比较；&lt;/p&gt;

&lt;p&gt;你会发现这种查找法效率提高了很多，因为物尽其用了（比较的是Id，也只是取了Id，没有浪费）；&lt;/p&gt;

&lt;p&gt;这就是Map接口的作用，可以根据某个键去查找对应的信息，有点类似于数据库的设计。&lt;/p&gt;

&lt;h3&gt;Map的种类&lt;/h3&gt;

&lt;p&gt;Map主要有三种类型：HashMap(常用)、TreeMap（树形结构）、LinkedHashMap（前两者的结合）&lt;/p&gt;

&lt;p&gt;我们先来看一下Map接口主要的几个方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;V put(K key, V value)&lt;/code&gt;：往Map中添加键值对，其中key为键，value为值；如果key存在，则覆盖原有的值；如果不存在，则新建键值对。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;V get(Object key)&lt;/code&gt;：从Map中查找键key对应的值，如果没有，则返回null&lt;/li&gt;
&lt;li&gt;&lt;code&gt;default V getOrDefault(Object key, V defaultValue)&lt;/code&gt;：从Map中查找键key对应的值，如果没有，则返回第二个参数（设置的默认值）；这里的修饰符default是用在接口方法中，表示这个方法在接口中已经实现了，子类可以不实现（Java8开始支持）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Set&amp;lt;K&amp;gt; keySet()&lt;/code&gt;：返回Map中Key的集合；之所以返回Set，是因为Map中的key不能有重复，所以用Set最适合了&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Collection&amp;lt;V&amp;gt; values()&lt;/code&gt;：返回Map中Values的集合&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面我们简单看下三者的区别&lt;/p&gt;

&lt;table&gt;&lt;thead&gt;
&lt;tr&gt;
&lt;th/&gt;
&lt;th&gt;HashMap&lt;/th&gt;
&lt;th&gt;TreeMap&lt;/th&gt;
&lt;th&gt;LinkedHashMap&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;访问速度&lt;/td&gt;
&lt;td&gt;快&lt;/td&gt;
&lt;td&gt;慢&lt;/td&gt;
&lt;td&gt;适中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;元素是否有序&lt;/td&gt;
&lt;td&gt;无序&lt;/td&gt;
&lt;td&gt;有序，默认按key排序&lt;/td&gt;
&lt;td&gt;有序，默认按插入的顺序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;适用场景&lt;/td&gt;
&lt;td&gt;普通的插入，查询（用的最多）&lt;/td&gt;
&lt;td&gt;需要对key进行排序的场景（比如员工按年龄排序等）&lt;/td&gt;
&lt;td&gt;需要保证查询和插入顺序一致的场景（类似队列）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;接下来我们以HashMap为例，来介绍Map接口&lt;/p&gt;

&lt;h3&gt;HashMap&lt;/h3&gt;

&lt;p&gt;HashMap内部是数组+链表的结构；&lt;/p&gt;

&lt;p&gt;因为在添加键值对的时候，Key做了hash处理，然后按照hash值进行排列；&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;如果hash值没有重复，就按照数组的方式依次排列；&lt;/li&gt;
&lt;li&gt;如果hash值有重复的，就添加到已有的键值对后面（Java8以后是尾部插入），形成链表结构；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;整体结构 如下图所示&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/31/5qnM3zwZDgakGV4.png&quot; alt=&quot;HashMap结构&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里只是简单介绍，以后再深入了解&lt;/p&gt;

&lt;p&gt;下面用代码示范一下&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;// 键值对集合，键不可以重复
Map&amp;lt;String, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
// 添加：首先会检查对应的key是否存在，如果不存在，则新建键值对，然后填充；如果存在，则覆盖已有的值
map.put(&quot;a&quot;, 1); // 这里的1会自动装箱为Intege类型
// 查询
int value1 = map.get(&quot;a&quot;);
int value2 = map.get(&quot;b&quot;); 
System.out.println(map);
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;这里有个很有意思的现象，你觉得value2会是多少呢？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;答案是多少都不是，因为程序运行到这一行就出错了，报空指针异常&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/31/BoQ6x2Kzf3P8vMH.png&quot; alt=&quot;HashMap空指针异常&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;不应该返回null吗？怎么会出错？&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这里涉及到拆箱和装箱的问题，上面我们在添加put的时候，int 1自动装箱为Integer；&lt;/p&gt;

&lt;p&gt;然后在获取get的时候，对应的也是要进行拆箱的，将Integer转为int；&lt;/p&gt;

&lt;p&gt;但是由于获取的value = null，所以就相当于对null进行拆箱，结果就报错了。&lt;/p&gt;

&lt;p&gt;解决办法就是严格按照Map的类型信息进行添加和获取；&lt;/p&gt;

&lt;p&gt;将上面的代码加以修改，如下所示&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;// 键值对集合，键不可以重复
Map&amp;lt;String, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
// 添加：首先会检查对应的key是否存在，如果不存在，则新建键值对，然后填充；如果存在，则覆盖已有的值
map.put(&quot;a&quot;, 1); // 这里的1会自动装箱为Intege类型
// 查询
Integer value1 = map.get(&quot;a&quot;);
Integer value2 = map.get(&quot;b&quot;);
System.out.println(map);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;此时value2就等于null了。&lt;/p&gt;

&lt;p&gt;关于自动装箱和拆箱，网上资源很多，这里就不再细说了&lt;/p&gt;

&lt;h3&gt;TreeMap&lt;/h3&gt;

&lt;p&gt;TreeMap在插入的时候，可以按照键的顺序进行排序&lt;/p&gt;

&lt;p&gt;它适合用在排序比较多的场景，性能会比HashMap差一些&lt;/p&gt;

&lt;h3&gt;LinkedHashMap&lt;/h3&gt;

&lt;p&gt;LinkedHashMap拥有HashMap的大部分优点，且保证了插入的顺序，使得在查询的时候，可以按照插入的顺序依次读取&lt;/p&gt;

&lt;h3&gt;三者的排序比较&lt;/h3&gt;

&lt;p&gt;下面用代码演示一下，依次插入100个数，看看他们分别是怎么排序的&lt;/p&gt;

&lt;p&gt;&lt;code&gt;HashMapDemo.java&lt;/code&gt;&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class HashMapDemo {
    public static void main(String[] args) {
        // 键值对集合，键不可以重复
        Map&amp;lt;String, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        // 倒序插入100个数
        int i =100;
        while (i--&amp;gt;0){
            map.put(&quot;&quot;+i, i);
        }
        // 查询
        for (String str :
                map.keySet()) {
            // 这里会乱序输出
            System.out.println(str);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出如下所示：很乱&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/31/D4ow987uz1OPtHa.png&quot; alt=&quot;HashMap输出乱序&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;TreeMapDemo.java&lt;/code&gt;&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class MapDemo {
    public static void main(String[] args) {

        // TreeMap
        Map&amp;lt;String, Integer&amp;gt; map1 = new TreeMap&amp;lt;&amp;gt;();
        // 连续倒序插入100个数
        int k =100;
        while (k--&amp;gt;0){
            map1.put(&quot;&quot;+k, k);
        }
        // 查询
        for (String str :
                map1.keySet()) {
            // 这里会正序输出
            System.out.println(str);
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/31/Bhs86gVfPiN5d9W.png&quot; alt=&quot;TreeMap输出正序&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;细心的你们，应该会发现上面的输出有点别致&lt;/p&gt;

&lt;p&gt;那是因为这里的键key(0~99)其实不是整型，而是字符串类型，所以排序按照字符串的升序来排，才会出现如图所示的结果&lt;/p&gt;

&lt;p&gt;（建议实际场景不要这样搞，容易出事，字符串尽量不要用纯数字，而是要跟字母做拼接；）&lt;/p&gt;

&lt;p&gt;正确的做法是key=“a”+i，这种方式&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;LinkedHashMapDemo.java&lt;/code&gt;&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;public class MapDemo {
    public static void main(String[] args) {
        // LinkedHashMap
        Map&amp;lt;String, Integer&amp;gt; map2 = new LinkedHashMap&amp;lt;&amp;gt;();
        // 倒序插入100个数
        int j =100;
        while (j--&amp;gt;0){
            map2.put(&quot;a&quot;+j, j);
        }
        for (String str :
                map2.keySet()) {
            // 这里按照插入的顺序依次输出
            System.out.println(map2.get(str));
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/03/31/N2vaT4BheJn8OYp.png&quot; alt=&quot;LinkedHashMap按插入顺序输出&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;Map一般用到的有HashMap，TreeMap，LinkedHashMap，当然还有并发相关的，这里入门级别的先不涉及（比如ConcurrentHashMap）&lt;/p&gt;



&lt;h2&gt;后记&lt;/h2&gt;

&lt;p&gt;最后，感谢大家的观看，谢谢&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>47bb7924872c82d90501dd93c93e1e45</guid>
<title>浮点数，你真的懂了吗？</title>
<link>https://toutiao.io/k/343f4ae</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;h2&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;大家好，我是石头哥，最近有读者问我关于浮点的问题，大概问题就是 &lt;strong&gt;0.1 + 0.2 == 0.3 ？ 0.8-0.6 == 0.6-0.4 ？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.4111111111111112&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ZMXDhhGnYibvibUqUU51FZlFjGNvuibHeksHymf1XE8IqNBcBF9ZhRPSjbJ8vnFLIgT9EtFLlmoe8JcYSSKMRQ14w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p&gt;我给他丢了一篇我早在 2014 年写的一篇文章 —— &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3OTUzMzcwNw==&amp;amp;mid=2247483933&amp;amp;idx=1&amp;amp;sn=69b1be012cf37ccb5ce6f3a091f57f5b&amp;amp;chksm=eb4703f9dc308aef5834a6abf72255edd1767e633330531f817d7b4774c65c33f5910cd9ea75&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;一个由跨平台产生的浮点数bug | 有你意想不到的结果&lt;/a&gt;，讲述了自己在开发过程中的一个“bug”，也因浮点数的表达引起的。&lt;/p&gt;&lt;p&gt;回想，当初这篇文章投稿到了著名的 CoolShell 博主 —— 左耳朵耗子那里，因为文中的表述不太清楚，还引起了一些讨论。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.48488830486202367&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZMXDhhGnYibvibUqUU51FZlFjGNvuibHeksoibk84PBibg85TGQmG1d6BeVd4icx7qXgOfNtOBRImZsU7VicSgvR0m0kg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1522&quot;/&gt;&lt;/p&gt;&lt;p&gt;今天，我就借机会，再跟大家一起来探讨探讨关于浮点数的几个问题：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;为什么负数要用补码表示&lt;/span&gt;&lt;span&gt;？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;十进制小数怎么转成二进制？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;计算机是怎么存小数的？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;0.1 + 0.2 == 0.3 吗？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;…&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;你能清晰的回答上述的问题吗，本篇文章将为你揭晓。详细原理请看完原文（值得收藏），&lt;strong&gt;文末有精简版回答，&lt;/strong&gt;另送一份不错的计算机基础总结。&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;为什么负数要用补码表示？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;十进制转换二进制的方法相信大家都熟能生巧了，如果你说你还不知道，我觉得你还是太谦虚，可能你只是忘记了，即使你真的忘记了，不怕，贴心的小林在和你一起回忆一下。&lt;/p&gt;&lt;p&gt;十进制数转二进制采用的是&lt;strong&gt;除 2 取余法&lt;/strong&gt;，比如数字 8 转二进制的过程如下图：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6529209621993127&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFaQykyJLxmvRCukLpS8jTwf0FibicoRXxWxsZjfF0iaob0IkWVdIKl24dWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;582&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;接着，我们看看「整数类型」的数字在计算机的存储方式，这其实很简单，也很直观，就是将十进制的数字转换成二进制即可。&lt;/p&gt;&lt;p&gt;我们以 &lt;code&gt;int&lt;/code&gt; 类型的数字作为例子，int 类型是 &lt;code&gt;32&lt;/code&gt; 位的，其中&lt;strong&gt;最高位是作为「符号标志位」&lt;/strong&gt;，正数的符号位是 &lt;code&gt;0&lt;/code&gt;，负数的符号位是 &lt;code&gt;1&lt;/code&gt;，&lt;strong&gt;剩余的 31 位则表示二进制数据&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;那么，对于 int 类型的数字 1 的二进制数表示如下：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.39222042139384117&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFa3awC2B65Ed6vouKl0WxibibhapcFTDb2Csl6PtIMahia3rB7bb7y4a8BQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;617&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;而负数就比较特殊了点，负数在计算机中是以「补码」表示的，&lt;strong&gt;所谓的补码就是把正数的二进制全部取反再加 1&lt;/strong&gt;，比如 -1 的二进制是把数字 1 的二进制取反后再加 1，如下图：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.10221465076661&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFao2ibSEMGoc5vZTVTUdwBZS4EYyPfwpGVR0xVPKTqowP9QMzJdia9aEiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;587&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;不知道你有没有想过，为什么计算机要用补码的方式来表示负数？在回答这个问题前，我们假设不用补码的方式来表示负数，而只是把最高位的符号标志位变为 1 表示负数，如下图过程：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7062068965517241&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFa3rBgJkJYLibnoB49uyo2zYyFSe6ad7hKd2YYk93upkGtSmb5ChTawzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;725&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如果采用这种方式来表示负数的二进制的话，试想一下 &lt;code&gt;-2 + 1&lt;/code&gt; 的运算过程，如下图：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.4984177215189873&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFaenMriaPNOkzWMlx1E53Azgb2BPy0ocCMTlOpc8d68PZWouL5oVLJ57A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;632&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;按道理，&lt;code&gt;-2 + 1 = -1&lt;/code&gt;，但是上面的运算过程中得到结果却是 &lt;code&gt;-3&lt;/code&gt;，所可以发现，这种负数的表示方式是不能用常规的加法来计算了，就需要特殊处理，要先判断数字是否为负数，如果是负数就要把加法操作变成减法操作才可以得到正确对结果。&lt;/p&gt;&lt;p&gt;到这里，我们就可以回答前面提到的「负数为什么要用补码方式来表示」的问题了。&lt;/p&gt;&lt;p&gt;如果负数不是使用补码的方式表示，则在做基本对加减法运算的时候，&lt;strong&gt;还需要多一步操作来判断是否为负数，如果为负数，还得把加法反转成减法，或者把减法反转成加法&lt;/strong&gt;，这就非常不好了，毕竟加减法运算在计算机里是很常使用的，所以为了性能考虑，应该要尽量简化这个运算过程。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;而用了补码的表示方式，对于负数的加减法操作，实际上是和正数加减法操作一样的&lt;/strong&gt;。你可以看到下图，用补码表示的负数在运算 &lt;code&gt;-2 + 1&lt;/code&gt; 过程的时候，其结果是正确的：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.4984177215189873&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFa1Tt6Uq62YDEYvmSJHgfuX8eQ3XT1yteS97iaeaYibiaicicBLlVGL2rmySQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;632&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;十进制小数与二进制的转换&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;好了，整数十进制转二进制我们知道了，接下来看看小数是怎么转二进制的，小数部分的转换不同于整数部分，它采用的是&lt;strong&gt;乘 2 取整法&lt;/strong&gt;，将十进制中的小数部分乘以 2 作为二进制的一位，然后继续取小数部分乘以 2 作为下一位，直到不存在小数为止。&lt;/p&gt;&lt;p&gt;话不多说，我们就以 &lt;code&gt;8.625&lt;/code&gt; 转二进制作为例子，直接上图：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9325842696629213&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFa65IjFN7JSOcyJXPaSSTKpqiaYpRS0dyVDCDxNXsc4gFhN3tdI1NXn0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;801&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;最后把「整数部分 + 小数部分」结合在一起后，其结果就是 &lt;code&gt;1000.101&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;但是，并不是所有小数都可以用二进制表示，前面提到的 0.625 小数是一个特例，刚好通过乘 2 取整法的方式完整的转换成二进制，如果我们用相同的方式，来把 &lt;code&gt;0.1&lt;/code&gt; 转换成二进制，过程如下：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.3650075414781297&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFaDQGxthXkjbbZrY9xjVoLuXQdj3HkibyNiciaeTbghMP0RibibwicJiaqr7kXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;663&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;可以发现，&lt;code&gt;0.1&lt;/code&gt; 的二进制表示是无限循环的，&lt;strong&gt;由于计算机的资源是有限的，所以是没办法用二进制精确的表示 0.1，只能用「近似值」来表示，就是在有限的精度情况下，最大化接近 0.1 的二进制数，于是就会造成精度缺失的情况&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;对于二进制小数转十进制时，需要注意一点，小数点后面的指数幂是&lt;strong&gt;负数&lt;/strong&gt;，比如二进制 &lt;code&gt;0.1&lt;/code&gt; 转成十进制就是 &lt;code&gt;2^(-1)&lt;/code&gt;，也就是十进制 &lt;code&gt;0.5&lt;/code&gt;，二进制 &lt;code&gt;0.01&lt;/code&gt; 转成十进制就是 &lt;code&gt;2^-2&lt;/code&gt;，也就是十进制 &lt;code&gt;0.25&lt;/code&gt;，以此类推。&lt;/p&gt;&lt;p&gt;举个例子，二进制 &lt;code&gt;1010.101&lt;/code&gt; 转十进制的过程，如下图：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3229946524064171&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFaMxHWU7L20ll8KhNXVKWGIX1ExKgQKvHLDEpcGPkxOuQl1Pxx3nzKvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;935&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;计算机是怎么存小数的？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;1000.101&lt;/code&gt; 这种二进制小数是「定点数」形式，代表着小数点是定死的，不能移动，如果你移动了它的小数点，这个数就变了， 就不再是它原来的值了。&lt;/p&gt;&lt;p&gt;然而，计算机并不是这样存储的小数的，计算机存储小数的采用的是&lt;strong&gt;浮点数&lt;/strong&gt;，名字里的「浮点」表示小数点是可以浮动的，比如 &lt;code&gt;1000.101&lt;/code&gt; 这个二进制数，可以表示成 &lt;code&gt;1.000101 x 2^(-3)&lt;/code&gt;，类似于数学上的科学记数法。&lt;/p&gt;&lt;p&gt;既然提到了科学计数法，我再帮大家复习一下，比如有个很大的十进制数 1230000，我们可以也可以表示成 &lt;code&gt;1.23 x 10^6&lt;/code&gt;，这种方式就称为科学记数法，该方法在小数点左边只有一个数字，而且把这种整数部分没有前导 0 的数字称为&lt;strong&gt;规格化&lt;/strong&gt;，比如 &lt;code&gt;1.0 x 10^(-9)&lt;/code&gt; 是规格化的科学记数法，而 &lt;code&gt;0.1 x 10^(-9)&lt;/code&gt; 和 &lt;code&gt;10.0 x 10^(-9)&lt;/code&gt; 就不是了。&lt;/p&gt;&lt;p&gt;因此，如果二进制要用到科学记数法，同时要规范化，那么不仅要保证基数为 2，还要保证小数点左侧只有 1 位，而且必须为 1，所以通常将 &lt;code&gt;1000.101&lt;/code&gt; 这种二进制数，表示成 &lt;code&gt;1.000101 x 2^(-3)&lt;/code&gt;，其中，最为关键的是 000101 和 -3 这两个东西，它就可以包含了这个二进制小数的所有信息，&lt;code&gt;000101&lt;/code&gt; 称为&lt;strong&gt;尾数&lt;/strong&gt;，即小数点后面的数字，&lt;code&gt;-3&lt;/code&gt; 称为&lt;strong&gt;指数&lt;/strong&gt;，指定了小数点在数据中的位置。&lt;/p&gt;&lt;p&gt;现在绝大多数计算机使用的浮点数，一般采用的是 IEEE 制定的国际标准，这种标准形式如下图：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.1248303934871099&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFa09ib8nlWKVUb3TMpSUkF47m1NbL7vticrtlpohrHmxAOexrrVibicgQnZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;737&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这三个重要部分的意义如下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;符号位&lt;/em&gt;：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;指数位&lt;/em&gt;：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，&lt;strong&gt;指数位的长度越长则数值的表达范围就越大&lt;/strong&gt;；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;尾数位&lt;/em&gt;：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且&lt;strong&gt;尾数的长度决定了这个数的精度&lt;/strong&gt;，因此如果要表示精度更高的小数，则就要提高尾数位的长度；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;用 &lt;code&gt;32&lt;/code&gt; 位来表示的浮点数，则称为&lt;strong&gt;单精度浮点数&lt;/strong&gt;，也就是我们编程语言中的 &lt;code&gt;float&lt;/code&gt; 变量，而用 &lt;code&gt;64&lt;/code&gt; 位来表示的浮点数，称为&lt;strong&gt;双精度浮点数&lt;/strong&gt;，也就是 &lt;code&gt;double&lt;/code&gt; 变量，它们的结构如下：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.688135593220339&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFaIQHV8McXmNS3IibCS6vmRCsPDkvrksLwCghGHIjH068GoXlctcVb3BA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;885&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;可以看到：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;double 的尾数部分是 52 位，float 的尾数部分是 23 位，由于同时都带有一个固定隐含位（这个后面会说），所以 double 有 53 个二进制有效位，float 有 24 个二进制有效位，所以所以它们的精度在十进制中分别是 &lt;code&gt;log10(2^53)&lt;/code&gt; 约等于 &lt;code&gt;15.95&lt;/code&gt; 和 &lt;code&gt;log10(2^24)&lt;/code&gt;约等于 &lt;code&gt;7.22&lt;/code&gt; 位，因此 double 的有效数字是 &lt;code&gt;15~16&lt;/code&gt; 位，float 的有效数字是 &lt;code&gt;7~8&lt;/code&gt;位，这些是有效位是包含整数部分和小数部分；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;double 的指数部分是 11 位，而 float 的指数位是 8 位，意味着 double 相比 float 能表示更大的数值范围；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;那二进制小数，是如何转换成二进制浮点数的呢？我们就以 &lt;code&gt;10.625&lt;/code&gt; 作为例子，看看这个数字在 float 里是如何存储的。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4820017559262511&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFaPhQq13uqibpy2ShHIiagARX79mYkpicue31KXEAy7OxjKkzcw9WPQibohw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1139&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;首先，我们计算出 10.625 的二进制小数为 1010.101，然后&lt;strong&gt;把小数点，移动到第一个有效数字后面&lt;/strong&gt;，即将 1010.101 右移 &lt;code&gt;3&lt;/code&gt; 位成 &lt;code&gt;1.010101&lt;/code&gt;，右移 3 位就代表 +3，左移 3 位就是 -3，&lt;strong&gt;float 中的「指数位」就跟这里移动的位数有关系，把移动的位数再加上「偏移量」，float 的话偏移量是 127，相加后就是指数位的值了&lt;/strong&gt;，即指数位这 8 位存的是 &lt;code&gt;10000010&lt;/code&gt;（十进制 130），因此你可以认为「指数位」相当于指明了小数点在数据中的位置。&lt;/p&gt;&lt;p&gt;&lt;code&gt;1.010101&lt;/code&gt; 这&lt;strong&gt;小数点右侧的数字就是 float 里的「尾数位」&lt;/strong&gt;，由于尾数位是 23 位，则后面要补充 0，所以最终尾数位存储的数字是 &lt;code&gt;01010100000000000000000&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;在算指数的时候，你可能会有疑问为什么要加上偏移量呢？&lt;/p&gt;&lt;p&gt;前面也提到，指数可能是正数，也可能是负数，即指数是有符号的整数，而有符号整数的计算是比无符号整数麻烦的，所以为了减少不必要的麻烦，在实际存储指数的时候，需要把指数转换成&lt;strong&gt;无符号整数&lt;/strong&gt;，float 的指数部分是 8 位，IEEE 标准规定单精度浮点的指数取值范围是 &lt;code&gt;-127 ~ +128&lt;/code&gt;，于是为了把指数转换成无符号整数，就要加个&lt;strong&gt;偏移量&lt;/strong&gt;，比如 float 的指数偏移量是 &lt;code&gt;127&lt;/code&gt;，这样指数就不会出现负数了。&lt;/p&gt;&lt;p&gt;比如，指数如果是 8，则实际存储的指数是 8 + 127 = 135，即把 135 转换为二进制之后再存储，而当我们需要计算实际的十进制数的时候，再把指数减去偏移量即可。&lt;/p&gt;&lt;p&gt;细心的朋友肯定发现，移动后的小数点左侧的有效位（即 1）消失了，它并没有存储到 float 里，这是因为 IEEE 标准规定，二进制浮点数的小数点左侧只能有 1 位，并且还只能是 1，&lt;strong&gt;既然这一位永远都是 1，那就可以不用存起来了&lt;/strong&gt;，于是就让 23 位尾数只存储小数部分，电路在计算时会自动把这个 1 加上，这样就可以节约 1 位的空间，尾数就能多存一位小数，相应的精度就更高了一点。&lt;/p&gt;&lt;p&gt;那么，对于我们在从 float 的二进制浮点数转换成十进制时，要考虑到这个隐含的 1，转换公式如下：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.17773788150807898&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFabNKFDrE1CCicEZCn51csMIplPbHecKoE4xUexqOB4bFcYiclq5uEndQA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;557&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;举个例子，我们把下图这个 float 的数据转换成十进制，过程如下：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7006651884700665&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFasGrj7cJM8ehh03rZm2d2rMDN8V3HVyxpsIBfAic1tNDLkaGmk5lZjZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;902&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;0.1 + 0.2 == 0.3 ?&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;前面提到过，并不是所有小数都可以用「完整」的二进制来表示的，比如十进制 0.1 在转换成二进制小数的时候，是一串无限循环的二进制数，计算机是无法表达无限循环的二进制数的，毕竟计算机的资源是有限。&lt;/p&gt;&lt;p&gt;因此，计算机只能用「近似值」来表示该二进制，那么意味着计算机存放的小数可能不是一个真实值，现在基本都是用 IEEE 754 规范的单精度浮点类型或双精度浮点类型来存储小数的，根据精度的不同，近似值也会不同。&lt;/p&gt;&lt;p&gt;那计算机是存储 0.1 是一个怎么样的二进制浮点数呢？偷个懒，我就不自己手动算了，可以使用 binaryconvert 这个工具，将十进制 0.1 小数转换成 float 浮点数：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7208008898776418&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFaE11O6A4RYWtmyItE8Sib96oV2kojXgib5Fib1R9beBChmQp2iazE1maiaiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1798&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;可以看到，8 位指数部分是 &lt;code&gt;01111011&lt;/code&gt;，23 位的尾数部分是 &lt;code&gt;10011001100110011001101&lt;/code&gt;，可以看到尾数部分是 &lt;code&gt;0011&lt;/code&gt; 是一直循环的，只不过尾数是有长度限制的，所以只会显示一部分，所以是一个近似值，精度十分有限。&lt;/p&gt;&lt;p&gt;接下来，我们看看 0.2 的 float 浮点数：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3293492695883134&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFakic3AZa3FK0HXIjSHxJ7rsVhj4LZNAfan88ctOCohzOibpI6VrPKiaj1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1506&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;可以看到，8 位指数部分是 01111100，稍微和 0.1 的指数不同，23 位的尾数部分是 10011001100110011001101 和 0.1 的尾数部分是相同的，也是一个近似值。&lt;/p&gt;&lt;p&gt;0.1 的二进制浮点数转换成十进制的结果是 &lt;code&gt;0.100000001490116119384765625&lt;/code&gt;：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7011144883485309&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFa0Lqm6icpOeJavck0TwkIZ5nqVWDVroxqBnEvO7TQRPgakJyn1jClssg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;987&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;0.2 的二进制浮点数转换成十进制的结果是 &lt;code&gt;0.20000000298023223876953125&lt;/code&gt;：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7011144883485309&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFaCQD2EyBzBzlyDhTj1AGibBiaYJNzHbj1WDj8NplhRS2iaE4B5f6z3G2hQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;987&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这两个结果相加就是 &lt;code&gt;0.300000004470348358154296875&lt;/code&gt;：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7048387096774194&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFaK1fZJcqicS70XFyX2tjPRDpt4rQ6xLxzaicA8cW44jic4u0PJ9CvxzoBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;620&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;所以，你会看到在计算机中 0.1 + 0.2 并不等于完整的 0.3，这主要是因为有的小数无法可以用「完整」的二进制来表示，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。&lt;/p&gt;&lt;p&gt;我们在 JavaScript 里执行 0.1 + 0.2，你会得到下面这个结果：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2554347826086957&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZfA0eUSwPulvsjJBZj0MzFac5I9FfdBWfIqricsBuTfYZ2l7QEMibbhcqIXaMplpaFSibsDgLE9EY9Ig/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;184&quot; title=&quot;&quot; data-backw=&quot;304&quot; data-backh=&quot;78&quot;/&gt;&lt;/figure&gt;&lt;p&gt;结果和我们前面推到的类似，因为 JavaScript 对于数字都是使用 IEEE 754 标准下的双精度浮点类型来存储的，而我们二进制只能精准表达 2 除尽的数字 1/2, 1/4, 1/8，但是例如 0.1(1/10) 和 0.2(1/5)，在二进制中都无法精准表示时，需要根据精度舍入。&lt;/p&gt;&lt;p&gt;我们人类熟悉的十进制运算系统，可以精准表达 2 和 5 除尽的数字，例如1/2, 1/4, 1/5(0.2), 1/8, 1/10(0.1)。当然，十进制也有无法除尽的地方，例如 1/3, 1/7，也需要根据精度舍入。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;最后，再来回答开头多问题。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;为什么负数要用补码表示？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;负数之所以用补码的方式来表示，主要是为了统一和正数的加减法操作一样，毕竟数字的加减法是很常用的一个操作，就不要搞特殊化，尽量以统一的方式来运算。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;十进制小数怎么转成二进制？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;十进制整数转二进制使用的是「除 2 取余法」，十进制小数使用的是「乘 2 取整法」。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;计算机是怎么存小数的？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;计算机是以浮点数的形式存储小数的，大多数计算机都是 IEEE 754 标准定义的浮点数格式，包含三个部分：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;符号位：表示数字是正数还是负数，为 0 表示正数，为 1 表示负数；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;指数位：指定了小数点在数据中的位置，指数可以是负数，也可以是正数，指数位的长度越长则数值的表达范围就越大；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;尾数位：小数点右侧的数字，也就是小数部分，比如二进制 1.0011 x 2^(-2)，尾数部分就是 0011，而且尾数的长度决定了这个数的精度，因此如果要表示精度更高的小数，则就要提高尾数位的长度；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;用 32 位来表示的浮点数，则称为单精度浮点数，也就是我们编程语言中的 float 变量，而用 64 位来表示的浮点数，称为双精度浮点数，也就是 double 变量。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;0.1 + 0.2 == 0.3 吗？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;不是的，0.1 和 0.2 这两个数字用二进制表达会是一个一直循环的二进制数，比如 0.1 的二进制表示为 0.0 0011 0011 0011… （0011 无限循环)，对于计算机而言，0.1 无法精确表达，这是浮点数计算造成精度损失的根源。&lt;/p&gt;&lt;p&gt;因此，计算机只能用「近似值」来表示该二进制，那么意味着计算机存放的小数可能不是一个真实值。&lt;/p&gt;&lt;p&gt;0.1 + 0.2 并不等于完整的 0.3，这主要是因为这两个小数无法用「完整」的二进制来表示，所以计算机里只能采用近似数的方式来保存，那两个近似数相加，得到的必然也是一个近似数。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;后记&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;浮点数其实是计算机程序设计的基础，最近我看到一份不错的&lt;span&gt;程序员硬核基础知识整理合集。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A3ibcic1Xe0iaTo0PgEghzOx6tAM4k7X04GJdFkNaCY81iaHGk9XUBMIzNrkLXw09gZvqUznaicf4l7rWkDrBxEsfNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.8768518518518519&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一本非常经典 PDF，从 CPU 到内存、讲解什么是二进制、磁盘、压缩算法、操作系统、汇编等知识。感兴趣的同学扫码下面二维码，后台回复 “&lt;/span&gt;&lt;span&gt;计算机基础总结&lt;/span&gt;&lt;span&gt;”领取。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3649122807017544&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ZMXDhhGnYibtdnfTuDgSCe2oO6g1Y8tiaOu0G7sKEJAibWAWXcWQvteRFX8PNPKdvP4H8pa8w0SwWgCgGCS1QYicUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1710&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;扫码回复“&lt;/span&gt;&lt;span&gt;计算机基础总结&lt;/span&gt;&lt;span&gt;”领取&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a7cb8bf9f25079581fa808ebf7bd60e4</guid>
<title>Elasticsearch 第三弹之存储原理</title>
<link>https://toutiao.io/k/yyhrqlm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;181&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.32344763670064874&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpOjRJj3rEmVIcZ4cxnPGXMbOToA3HQiafTrfmjfvOVQH0fLtCJwj3DkfC1GoPIRVmLY5oTemAhXibRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1079&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;阅读本文大概需要 5 分钟。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们上文中介绍的&lt;code&gt;ES&lt;/code&gt;内部索引的写处理流程是在&lt;code&gt;ES&lt;/code&gt;的内存中执行的，而数据被分配到特定的主、副分片上之后，最终是存储到磁盘上的，这样在断电的时候就不会丢失数据。具体的存储路径可在配置文件 ../config/elasticsearch.yml 中进行设置，默认存储在安装目录的 &lt;code&gt;Data&lt;/code&gt;文件夹下。建议不要使用默认值，因为若 ES 进行了升级，则有可能导致数据全部丢失。文件配置如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;path.data: /path/to/data  //索引数据&lt;br/&gt;path.logs: /path/to/logs  //日志记录&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么&lt;code&gt;ES&lt;/code&gt;是怎么将索引从内存中同步到磁盘上的呢？今天我们就来说一下&lt;code&gt;ES&lt;/code&gt;的存储原理（搬着小板凳坐好）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先设想一下，&lt;code&gt;ES&lt;/code&gt;是否是直接调用 &lt;code&gt;Fsync&lt;/code&gt; 物理性地写入磁盘？答案是否定的，如果是直接写入磁盘，磁盘的 I/O 消耗会严重影响性能,那么当写数据量大的时候会造成 &lt;code&gt;ES&lt;/code&gt; 停顿卡死，查询也无法做到快速响应, &lt;code&gt;ES&lt;/code&gt; 就不会被称为近实时全文搜索引擎了。那么问题来了，&lt;code&gt;ES&lt;/code&gt; 是采用什么方式存储的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们先来说几个概念，然后再具体介绍下它的整个流程及细节处理，方便大家更好的理解。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;段&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;索引文档被拆分成多个子文档，则每个子文档叫作段。段提出来的原因是：在早期全文检索中为整个文档集合建立了一个很大的倒排索引，并将其写入磁盘中。如果索引有更新，就需要重新全量创建一个索引来替换原来的索引。这种方式在数据量很大时效率很低，并且由于创建一次索引的成本很高，所以对数据的更新不能过于频繁，也就不能保证时效性。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;特点&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;索引文档是以段的形式存储在磁盘上的，每一个段本身都是一个倒排索引，并且段具有不变性，一旦索引的数据被写入硬盘，就不能再修改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那么问题来了，不能修改，如何实现增删改呢？&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;新增：新增很好处理，由于数据是新的，所以只需要对当前文档新增一个段就可以了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;删除：段是不可改变的，所以既不能把文档从旧的段中移除，也不能修改旧的段来进行文档的更新。取而代之的是每个提交点（定义会在下边给出）会包含一个 .del 文件，文件中会列出这些被删除文档的段信息。当一个文档被 “删除” 时，它实际上只是在 .del 文件中被标记删除。一个被标记删除的文档仍然可以被查询匹配到，但它会在最终结果被返回前从结果集中移除。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更新：更新相当于是删除和新增这两个动作组成。当一个文档被更新时，旧版本文档被标记删除，文档的新版本被索引到一个新的段中。可能两个版本的文档都会被一个查询匹配到，但被删除的那个旧版本文档在结果集返回前就已经被移除。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;★&lt;/span&gt;&lt;p&gt;一个&lt;code&gt;Lucene&lt;/code&gt;索引会包含一个提交点和多个段，段被写入到磁盘后会生成一个提交点，提交点是一个用来记录所有提交后段信息的文件。一个段一旦拥有了提交点，就说明这个段只有读的权限，失去了写的权限。&lt;code&gt;ES&lt;/code&gt;在启动或重新打开一个索引的过程中使用这个提交点来判断哪些段隶属于当前分片。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;段的优势&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不需要锁。如果你从来不更新索引，你就不需要担心多进程同时修改数据的问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一旦索引被读入内核的文件系统缓存，便会留在那里，由于其不变性。只要文件系统缓存中还有足够的空间，那么大部分读请求会直接请求内存，而不会命中磁盘。这提供了很大的性能提升。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其它缓存(像 &lt;code&gt;Filter&lt;/code&gt; 缓存)，在索引的生命周期内始终有效。它们不需要在每次数据改变时被重建，因为数据不会变化。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写入单个大的倒排索引允许数据被压缩，减少磁盘 I/O 和需要被缓存到内存的索引的使用量。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;段的缺点&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当对旧数据进行删除时，旧数据不会马上被删除，而是在 .del 文件中被标记为删除。而旧数据只能等到段更新时才能被移除，这样会造成大量的空间浪费。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若有一条数据频繁的更新，每次更新都是新增新的标记旧的，则会有大量的空间浪费。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每次新增数据时都需要新增一个段来存储数据。当段的数量太多时，对服务器的资源例如文件句柄的消耗会非常大。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在查询的结果中包含所有的结果集，需要排除被标记删除的旧数据，这增加了查询的负担。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Refresh（刷新）&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;ES&lt;/code&gt; 中，写入和打开一个新段的轻量的过程叫做 &lt;code&gt;Refresh&lt;/code&gt; （即ES内存刷新到文件缓存系统）。&lt;code&gt;ES&lt;/code&gt;首先会将文档加载到&lt;code&gt;ES&lt;/code&gt;的内存缓冲区（当段在内存中时，就只有写的权限，而不具备读数据的权限，意味着不能被检索），当达到默认的时间（1 秒钟）或者内存的数据达到一定量时，会触发一次刷新（Refresh），这时数据就会被加载到文件缓存系统（操作系统的内存），创建新的段并将段打开以供搜索使用。这就是为什么我们说 &lt;code&gt;ES&lt;/code&gt; 是近实时搜索，因为文档的变化并不是立即对搜索可见，但会在一秒之内变为可见。这就会存在一个问题：当你索引了一个文档然后尝试搜索它，但却没有搜到。这个问题的解决办法是用 &lt;code&gt;refresh API&lt;/code&gt; 执行一次手动刷新。配置如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;POST /_refresh         //刷新（Refresh）所有的索引。&lt;br/&gt;POST /blogs/_refresh   //只刷新（Refresh） blogs 索引。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注：&lt;/strong&gt; 当写测试的时候，手动刷新很有用，但是不要在生产环境下每次索引一个文档都去手动刷新。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管刷新是比提交轻量很多的操作，它还是会有性能开销，并不是所有的情况都需要每秒刷新：当你使用 &lt;code&gt;ES&lt;/code&gt; 索引大量的日志文件时，你可能想优化索引速度而不是近实时搜索，这时可以在创建索引时在 &lt;code&gt;Settings&lt;/code&gt; 中通过调大 &lt;code&gt;refresh_interval = &quot;30s&quot;&lt;/code&gt; 的值，降低每个索引的刷新频率，设值时需要注意后面带上时间单位，否则默认是毫秒，如果是1毫秒无疑会使你的集群陷入瘫痪。当 &lt;code&gt;refresh_interval=-1&lt;/code&gt; 时表示关闭索引的自动刷新。配置如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;PUT /my_logs&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;settings&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;refresh_interval&quot;&lt;/span&gt;: &lt;span&gt;&quot;1s&quot;&lt;/span&gt;   //每秒刷新 my_logs 索引&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;★&lt;/span&gt;&lt;p&gt;refresh_interval 可以在既存索引上进行动态更新。在生产环境中，当你正在建立一个大的新索引时，可以先关闭自动刷新，待开始使用该索引时，再把它们调回来。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;段合并&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于自动刷新流程每秒会创建一个新的段，这样会导致短时间内的段数量暴增。而段数目太多会带来较大的麻烦。每一个段都会消耗文件句柄、内存和 &lt;code&gt;CPU&lt;/code&gt; 运行周期。更重要的是，每个搜索请求都必须轮流检查每个段然后合并查询结果，所以段越多，搜索也就越慢。&lt;code&gt;ES&lt;/code&gt; 通过在后台定期进行段合并来解决这个问题。小的段被合并到大的段，然后这些大的段再被合并到更大的段（这些段既可以是未提交的也可以是已提交的）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.49066666666666664&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNX3CanZrDGS46Pj4AUP4jPAC2zLTruJGeFS5Q3cXqHDB2YbqfcBo21EAgPeRiaQRFWW9697DaIKibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot; data-backw=&quot;474&quot; data-backh=&quot;233&quot;/&gt;&lt;figcaption&gt;两个提交了的段和一个未提交的段正在被合并到一个更大的段&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动段合并不需要你做任何事，进行索引和搜索时会自动进行：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、 当索引的时候，刷新（refresh）操作会创建新的段并将段打开以供搜索使用；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、 合并进程选择一小部分大小相似的段，并且在后台将它们合并到更大的段中，这并不会中断索引和搜索；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、 “一旦合并结束，老的段被删除” 说明合并完成时的活动：新的段被刷新（flush）到了磁盘，写入一个包含新段且排除旧的和较小的段的新提交点，那些旧的已删除文档从文件系统中清除，被删除的文档（或被更新文档的旧版本）不会被拷贝到新的大段中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.49066666666666664&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNX3CanZrDGS46Pj4AUP4jPzraRXbDISEuRSlaicxpDMRRDtQHIk0taRaMt4LfibJShL2qgQv5vcXdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot; data-backw=&quot;474&quot; data-backh=&quot;233&quot;/&gt;&lt;figcaption&gt;一旦合并结束，老的段被删除&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;段合并的计算量庞大，需要消耗大量的I/O和CPU资源，并会拖累写入速率，如果任其发展会影响搜索性能。&lt;code&gt;ES&lt;/code&gt; 在默认情况下会对合并流程进行资源限制，所以搜索仍然有足够的资源很好地执行。限流阈值默认是20MB/s，如果是&lt;code&gt;SSD&lt;/code&gt;，可以考虑100-200MB/s；如果是机械磁盘而非SSD，需要增加设置 &lt;code&gt;index.merge.scheduler.max_thread_count: 1&lt;/code&gt;。因为机械磁盘在并发 I/O 支持方面比较差，所以我们需要降低每个索引并发访问磁盘的线程数。这个设置允许 &lt;code&gt;max_thread_count + 2&lt;/code&gt; 个线程同时进行磁盘操作，也就是设置为 1 允许三个线程，SSD默认是 &lt;code&gt;Math.min(3, Runtime.getRuntime().availableProcessors() / 2)&lt;/code&gt;，支持很好；如果在做批量导入，不在意搜索，可以设置为none。配置如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;PUT /_cluster/settings&lt;br/&gt;{&lt;br/&gt;    &quot;persistent&quot; : {&lt;br/&gt;        &quot;indices.store.throttle.max_bytes_per_sec&quot; : &quot;100mb&quot;&lt;br/&gt;    }&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;optimize API&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;optimize API&lt;/code&gt;大可看做是强制合并 &lt;code&gt;API&lt;/code&gt;。它会将一个分片强制合并到 &lt;code&gt;max_num_segments&lt;/code&gt; 参数指定大小的段数目。这样做的意图是减少段的数量（通常减少到一个）来提升搜索性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;optimize API&lt;/code&gt;不应该被用在一个活跃的索引--一个正积极更新的索引：后台合并流程已经可以很好地完成工作，&lt;code&gt;optimizing&lt;/code&gt; 会阻碍这个进程，不要干扰它！在特定情况下，使用 &lt;code&gt;optimize API&lt;/code&gt; 颇有益处。例如在日志这种用例下，每天、每周、每月的日志被存储在一个索引中，老的索引实质上是只读的；它们也并不太可能会发生变化。在这种情况下，使用optimize优化老的索引，将每一个分片合并为一个单独的段就很有用了，这样既可以节省资源，也可以使搜索更加快速。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;POST /logstash-2014-10/_optimize?max_num_segments=1 //合并索引中的每个分片为一个单独的段&lt;/code&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;★&lt;/span&gt;&lt;p&gt;请注意，使用 &lt;code&gt;optimize API&lt;/code&gt; 触发段合并的操作不会受到任何资源上的限制。这可能会消耗掉你节点上全部的I/O资源，使其没有余力来处理搜索请求，从而有可能使集群失去响应。如果你想要对索引执行 &lt;code&gt;optimize&lt;/code&gt;，你需要先使用分片分配把索引移到一个安全的节点，再执行。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Translog&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了提升写的性能，&lt;code&gt;ES&lt;/code&gt; 并没有每新增一条数据就增加一个段到磁盘上，而是采用延迟写的策略。等文件系统中有新段生成之后，在稍后的时间里再被刷新到磁盘中并生成提交点。虽然通过延时写的策略可以减少数据往磁盘上写的次数提升了整体的写入能力，但是我们知道文件缓存系统也是内存空间，属于操作系统的内存，只要是内存都存在断电或异常情况下丢失数据的危险。为了避免丢失数据，&lt;code&gt;ES&lt;/code&gt; 添加了事务日志（Translog），事务日志记录了所有还没有持久化到磁盘的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;translog&lt;/code&gt; 默认是每5秒被 &lt;code&gt;fsync&lt;/code&gt; 刷新到硬盘，或者在每次写请求完成之后执行(index, delete, update, bulk)操作也可以刷新到磁盘。在每次请求后都执行一个 &lt;code&gt;fsync&lt;/code&gt; 会带来一些性能损失，尽管实践表明这种损失相对较小（特别是&lt;code&gt;bulk&lt;/code&gt;导入，它在一次请求中平摊了大量文档的开销）。对于一些大容量的偶尔丢失几秒数据问题也并不严重的集群，使用异步的 &lt;code&gt;fsync&lt;/code&gt; 还是比较有益的。我们可以通过设置 &lt;code&gt;durability&lt;/code&gt; 参数为 &lt;code&gt;async&lt;/code&gt; 来启用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;PUT /my_index/_settings&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;&quot;index.translog.durability&quot;&lt;/span&gt;: &lt;span&gt;&quot;async&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;index.translog.sync_interval&quot;&lt;/span&gt;: &lt;span&gt;&quot;5s&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个选项可以针对索引单独设置，并且可以动态进行修改。如果你决定使用异步 &lt;code&gt;translog&lt;/code&gt; 的话，你需要保证在发生&lt;code&gt;crash&lt;/code&gt;时，丢失掉 &lt;code&gt;sync_interval&lt;/code&gt; 时间段的数据也无所谓。如果你不确定这个行为的后果，最好是使用默认的参数（ &quot;index.translog.durability&quot;: &quot;request&quot; ）来避免数据丢失。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Flush&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行一个提交并且截断 &lt;code&gt;translog&lt;/code&gt; 的行为在&lt;code&gt;ES&lt;/code&gt;中被称作一次&lt;code&gt;flush&lt;/code&gt;。分片每30分钟被自动刷新（flush）或者在 &lt;code&gt;translog&lt;/code&gt; 太大的时候也会刷新。可以通过设置&lt;code&gt;translog&lt;/code&gt; 文档来控制这些阈值，&lt;code&gt;flush API&lt;/code&gt; 可以被用来执行一个手工的刷新（flush）:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;POST /blogs/_flush                //刷新（flush） blogs 索引。&lt;br/&gt;POST /_flush?wait_for_ongoing     //刷新（flush）所有的索引并且并且等待所有刷新在返回前完成。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后我们来说一下添加了事务日志后的整个存储的流程吧：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6185344827586207&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNX3CanZrDGS46Pj4AUP4jPn0nrHgu1EWVTVAqXVn5rT25c7RrQwseBaZJlYmoHpQ6qymyXX7B6yw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;928&quot; data-backw=&quot;474&quot; data-backh=&quot;294&quot;/&gt;&lt;figcaption&gt;ES存储流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一个新文档被索引之后，先被写入到内存中，但是为了防止数据的丢失，会追加一份数据到事务日志中。不断有新的文档被写入到内存，同时也都会记录到事务日志中（日志默认存储到文件缓存系统，每五秒刷新一下到本地磁盘，但是会导致数据丢失，也可以设置参数每个请求都同步，但是性能下降）。这时新数据还不能被检索和查询。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当达到默认的刷新时间或内存中的数据达到一定量后，会触发一次 &lt;code&gt;Refresh&lt;/code&gt;，将内存中的数据以一个新段形式刷新到文件缓存系统中并清空内存。这时虽然新段未被提交到磁盘，但是可以提供文档的检索功能且不能被修改。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;随着新文档索引不断被写入，当日志数据大小超过 &lt;code&gt;512M&lt;/code&gt; 或者时间超过 &lt;code&gt;30&lt;/code&gt; 分钟时，会触发一次 &lt;code&gt;Flush&lt;/code&gt;。内存中的数据被写入到一个新段同时被写入到文件缓存系统，文件系统缓存中数据通过 &lt;code&gt;Fsync&lt;/code&gt; 刷新到磁盘中，生成提交点，日志文件被删除，创建一个空的新日志。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过这种方式当断电或需要重启时，&lt;code&gt;ES&lt;/code&gt; 不仅要根据提交点去加载已经持久化过的段，还需要读取 &lt;code&gt;Translog&lt;/code&gt; 里的记录，把未持久化的数据重新持久化到磁盘上，避免了数据丢失的可能。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阿Q正在将ES的知识做一个系统的学习与讲解，后续还会持续输出ES的相关知识，如果你感兴趣的话，可以关注微信公众号“阿Q说”！你也可以后台留言说出你的疑惑，阿Q将会在后期的文章中为你解答。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;内容推荐&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.0040322580645162&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/55HPQyguvpPT7S5RYgFtCUAsTef19QwUcef3OposVMvMTicibTxGu35MiadwnDqqicK9CXgx7hG4nNxoDTY8Ql4BBA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;496&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;看完记得一键三连呦👇&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0c17fd5fe01847aae89d36439417962e</guid>
<title>一文学懂动态规划</title>
<link>https://toutiao.io/k/l47jh7e</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在之前的一篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIzNDQ3MzgxMw==&amp;amp;mid=2247483877&amp;amp;idx=1&amp;amp;sn=f25a9b01f89f27460519006afef1dd12&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;详解递归的正确打开方式&lt;/a&gt;中，我们详细讲解了经典的斐波那契数列问题从递归到 DP 的优化过程，&lt;/p&gt;&lt;span data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section role=&quot;presentation&quot; data-formula=&quot;f(n) = f(n-1)+f(n-2)&amp;#10;&quot; data-formula-type=&quot;block-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 11784.9 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;66&quot; d=&quot;M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(550, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(939, 0)&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1539, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2205.8, 0)&quot;&gt;&lt;path data-c=&quot;3D&quot; d=&quot;M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3261.6, 0)&quot;&gt;&lt;path data-c=&quot;66&quot; d=&quot;M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(3811.6, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(4200.6, 0)&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(5022.8, 0)&quot;&gt;&lt;path data-c=&quot;2212&quot; d=&quot;M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(6023, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(6523, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(7134.2, 0)&quot;&gt;&lt;path data-c=&quot;2B&quot; d=&quot;M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(8134.4, 0)&quot;&gt;&lt;path data-c=&quot;66&quot; d=&quot;M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(8684.4, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(9073.4, 0)&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(9895.7, 0)&quot;&gt;&lt;path data-c=&quot;2212&quot; d=&quot;M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(10895.9, 0)&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(11395.9, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/section&gt;&lt;/span&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;fib&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; N)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (N == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (N == &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; fib(N-&lt;span&gt;1&lt;/span&gt;) + fib(N-&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;体会了递归的思想，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;递归的实质是能够把一个大问题分解成比它小点的问题，然后我们拿到了小问题的解，就可以用小问题的解去构造大问题的解&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但缺点就是随着 n 值的增大，递归树 Recursion Tree 变的越来越深，相应需要计算的节点也越来越多。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5981481481481481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/og5r7PHGHoiaKTP6vlvqzWdN7yBP6Gnc6fI52T4VsIsyibC0eHnvmuW1iapghxdHFZsFK8ibk3E37eG4nRUo7qicyicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;recursion tree&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;且好多节点值进行了重复的计算，通过分析我们知道其&lt;strong&gt;时间复杂度&lt;/strong&gt;为：&lt;/p&gt;&lt;span data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section role=&quot;presentation&quot; data-formula=&quot;O(2^n)&amp;#10;&quot; data-formula-type=&quot;block-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 2515.3 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;msup&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(500, 413) scale(0.707)&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2126.3, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/section&gt;&lt;/span&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指数级别的时间复杂度对超算来说都是噩梦...&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上一篇讲递归的文章我们也给出了相应优化的方案，即用一个数组，最后只用两个变量来保存计算过的节点结果。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;fib&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; N)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; a = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; b = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(N == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; a;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(N == &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; b;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;2&lt;/span&gt;; i &amp;lt;= N; i++) {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; tmp = a + b;&lt;br/&gt;            a = b;&lt;br/&gt;            b = tmp;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; b;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样我们瞬间将时间复杂度降到了 O(n)，空间复杂度也变成了 O(1)。(具体时空复杂度分析&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIzNDQ3MzgxMw==&amp;amp;mid=2247483877&amp;amp;idx=1&amp;amp;sn=f25a9b01f89f27460519006afef1dd12&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;请戳这里&lt;/a&gt;)&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;思路分析&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么回顾一下我们怎么做的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我们将自顶向下的递归，变成了自底向上的 for loop。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我们将每次计算出来的节点值予以保存&lt;/strong&gt;，这样就不再需要重复计算一些已经计算过的节点，这也称为&lt;strong&gt;剪枝 pruning&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/og5r7PHGHoiaKTP6vlvqzWdN7yBP6Gnc6cd1X3EbvUsQyAyjGPXhNAHbHgb0t59nhRltzEVzjf8esWEff8icJyXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.18834688346883469&quot; data-w=&quot;738&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/og5r7PHGHoiaKTP6vlvqzWdN7yBP6Gnc6opYeoQCLbNfRiaGYeRFxs4DnOnsJG2vuUsVxzMFvqadN0o3SAaEqNgg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.562962962962963&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样我们便引出了&lt;strong&gt;动态规划&lt;/strong&gt;的核心思想：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;动态规划&lt;/strong&gt;（英语：Dynamic programming，简称 DP）是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。&lt;/p&gt;&lt;p&gt;动态规划常常适用于有&lt;strong&gt;重叠子问题&lt;/strong&gt;和&lt;strong&gt;最优子结构&lt;/strong&gt;性质的问题，动态规划方法所耗时间往往远少于朴素解法。&lt;/p&gt;&lt;p&gt;动态规划背后的基本思想非常简单。&lt;/p&gt;&lt;p&gt;大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。&lt;/p&gt;&lt;p&gt;通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其[记忆化存储，以便下次需要同一个子问题解之直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好多人说&lt;strong&gt;动态规划&lt;/strong&gt;是处理复杂问题优化算法的&lt;em&gt;二向箔&lt;/em&gt;，而我想说，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说的没毛病...&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小插曲：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家应该都听过 NP=?P 问题，这是美国克雷数学研究院百万美金悬赏的七个千僖数学难题之首（关于 NP 问题我之后还会详细的写文章描述）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那这跟我们今天说的动态规划有什么关系呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;动态规划有一类典型的问题叫&lt;strong&gt;背包问题&lt;/strong&gt;的题目，而&lt;strong&gt;背包问题&lt;/strong&gt;就是典型的&lt;strong&gt;NPC&lt;/strong&gt;问题（非确定性多项式完备问题 &lt;em&gt;Non-deterministic Polynomial&lt;/em&gt;），这个大家先做个了解，只是一个引子，我们提到这些，无非是要说明&lt;strong&gt;动态规划&lt;/strong&gt;作为能处理 NPC 问题的最优化算法还是属实有点东西的。（当然这跟数学证明 NP=?P 是两码事，毕竟头号千禧难题还没有被攻破...）所以大家一定先要学好动态规划呀～&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;动态规划核心&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到上文描述的动态规划定义，我们根据定义提炼出&lt;strong&gt;动态规划&lt;/strong&gt;最主要的核心，即：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;重叠子问题&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;最优子结构&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我再加个&lt;/p&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;状态转移方程&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 重叠子问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据&lt;em&gt;斐波那契数列&lt;/em&gt;的例子，我们知道，当前的数只与它前面两个数有关，即文章开头的&lt;/p&gt;&lt;span data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section role=&quot;presentation&quot; data-formula=&quot;f(n) = f(n-1)+f(n-2)&amp;#10;&quot; data-formula-type=&quot;block-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 11784.9 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;66&quot; d=&quot;M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(550, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(939, 0)&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1539, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2205.8, 0)&quot;&gt;&lt;path data-c=&quot;3D&quot; d=&quot;M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3261.6, 0)&quot;&gt;&lt;path data-c=&quot;66&quot; d=&quot;M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(3811.6, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(4200.6, 0)&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(5022.8, 0)&quot;&gt;&lt;path data-c=&quot;2212&quot; d=&quot;M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(6023, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(6523, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(7134.2, 0)&quot;&gt;&lt;path data-c=&quot;2B&quot; d=&quot;M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(8134.4, 0)&quot;&gt;&lt;path data-c=&quot;66&quot; d=&quot;M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(8684.4, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(9073.4, 0)&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(9895.7, 0)&quot;&gt;&lt;path data-c=&quot;2212&quot; d=&quot;M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(10895.9, 0)&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(11395.9, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/section&gt;&lt;/span&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们要想求出 f(n)，就得求出 f(n-1)和 f(n-2)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个就是属于重叠子问题，即：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里捎带强调一个概念：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;无后效性&lt;/strong&gt;：要求出 f(n)，只需求出 f(n-1)和 f(n-2)的值，而 f(n-1)和 f(n-2)是如何算出来的，对之后的问题没有影响，即“&lt;strong&gt;未来与过去无关&lt;/strong&gt;”，这就是无后效性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述的&lt;strong&gt;重叠子问题&lt;/strong&gt;的&lt;strong&gt;子问题&lt;/strong&gt;也必须满足无后效性这个概念。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 最优子结构&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么什么是&lt;strong&gt;最优子结构&lt;/strong&gt;呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最优即最值，&lt;em&gt;斐波那契数列&lt;/em&gt;例子里并没有提及和最值相关的字眼，故该例子严格来说并不能算完全的&lt;strong&gt;动态规划&lt;/strong&gt;问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们介绍另一个经典例题 ：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;strong&gt;&lt;em&gt;零钱兑换&lt;/em&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;给定不同面额的硬币 coins 和一个总金额 amount。计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;可以认为每种硬币的数量是无限的。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 1：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;输入：coins = [1, 2, 5], amount = 11&lt;br/&gt;输出：3&lt;br/&gt;解释：11 = 5 + 5 + 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 2：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;输入：coins = [2], amount = 3&lt;br/&gt;输出：-1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个题乍一看大概思路好像是：那我们就每次先找出最大面额的硬币试试呀，然后在总面额里减去，再依次取到较小的面额，直到凑够 amount（贪心思路）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个想法好像看似完全可行，但如果给你以下这组数据呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例 3:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;输入：coins = [1, 5, 11], amount = 15
输出：3
解释：15 = 5 + 5 + 5&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是如果我们沿用上述贪心算法&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;输出：5&lt;/p&gt;&lt;p&gt;解释：11 + 1 + 1 + 1 + 1&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而后一种得出的结果显而错误，所以我们发现贪心算法对此题不同的数据竟不是一通百通，所以说明我们这种策略不对。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那策略哪里出问题了呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;贪心只顾眼前，先找最大面额 11，而忽略了后续找 4 个 1 块硬币的代价，1 + 4 总共需要 5 枚，贪心算法在这种问题面前就有点鼠目寸光了...&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而这个题就是典型的&lt;strong&gt;动态规划&lt;/strong&gt;问题，下面我们进一步分析：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文提到，动态规划最核心的条件和性质就只有三个，我们依次按这三点开始分析。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 重叠子问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思考：要凑出 15 块钱，我们能不能先凑出 15 块钱之前（比当前问题更小的问题）的事情？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么小问题是什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们发现，面额分别为 1，5，11。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;我们可以先凑出 11 块（此时我们已经用了一枚 11 块的硬币，硬币数+1），然后再凑出 15 - 11 = 4 块。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;假设 f(n)表示凑出 n 元所需要的最少硬币数，&lt;/strong&gt; 那么这样我们凑出 15 块所需要的硬币总数为 &lt;strong&gt;f(15) = f(4) + 1&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;我们也可以先凑出 5 块，然后再凑出 15 - 5 = 10 块。&lt;/p&gt;&lt;p&gt;即 &lt;strong&gt;f(15) = f(10) + 1&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;我们也可以先凑出 1 块，然后再凑出 15 - 1 = 14 块。&lt;/p&gt;&lt;p&gt;即 &lt;strong&gt;f(15) = f(14) + 1&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们发现想要凑出一个较大数目的金额，可以先凑出较小数目的金额。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这不就是&lt;strong&gt;重叠子问题&lt;/strong&gt;吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们进一步发现，这些子问题同样满足无后效性，即我先凑出 11 块，还剩 4 块要凑，我即将凑出 4 块的策略与你已经凑出 11 块的策略并不存在半毛钱的关系。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即上文所说的：&lt;strong&gt;“未来与过去无关”&lt;/strong&gt;，这就是无后效性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.最优子结构&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由上我们发现：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;f(n)&lt;/strong&gt; 只与 &lt;strong&gt;f(n-1)&lt;/strong&gt;，&lt;strong&gt;f(n-5)&lt;/strong&gt;，&lt;strong&gt;f(n-11)&lt;/strong&gt; 的值相关。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后题目是求：问凑出金额所需&lt;strong&gt;最少&lt;/strong&gt;的硬币数量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的 &lt;strong&gt;f(n)&lt;/strong&gt; 也是这么定义的：&lt;strong&gt;f(n)&lt;/strong&gt; 表示凑出 &lt;strong&gt;n&lt;/strong&gt; 元所需要的最少硬币数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即根据 &lt;strong&gt;f(n - 1)，f(n - 5)，f(n - 11)&lt;/strong&gt; 的最优解，我们即可得到 &lt;strong&gt;f(15)&lt;/strong&gt; 的最优解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大问题的&lt;strong&gt;最优解&lt;/strong&gt;可以由小问题的&lt;strong&gt;最优解&lt;/strong&gt;得到，这不就是&lt;strong&gt;最优子结构&lt;/strong&gt;性质吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据以上我们就可以顺理成章的写出&lt;strong&gt;动态规划&lt;/strong&gt;问题里最难写出的&lt;strong&gt;状态转移方程&lt;/strong&gt;了&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.状态转移方程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;span data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section role=&quot;presentation&quot; data-formula=&quot;f(n) = min[f(n -1),f(n -5),f(n - 11)] + 1&amp;#10;&quot; data-formula-type=&quot;block-equation&quot;&gt;&lt;embed src=&quot;https://mmbiz.qlogo.cn/mmbiz_svg/UGrobmT8GcIUcH8mVoZu167IVREVBDiaezmhmj3jfUV9sSPrOpMTrbkCMs8oHrYs94KSZAXb3Asygfs6SWqAHut98de4lNIhJ/0?wx_fmt=svg&quot; data-type=&quot;svg+xml&quot;/&gt;&lt;/section&gt;&lt;/span&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;听上去高大上，实则，就这？？？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，就这。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;细心的读者会发现：这不就跟 &lt;strong&gt;&lt;em&gt;斐波那切数列&lt;/em&gt;&lt;/strong&gt; 的递推公式&lt;/p&gt;&lt;span data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section role=&quot;presentation&quot; data-formula=&quot;f(n) = f(n-1)+f(n-2)&amp;#10;&quot; data-formula-type=&quot;block-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 11784.9 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;66&quot; d=&quot;M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(550, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(939, 0)&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1539, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2205.8, 0)&quot;&gt;&lt;path data-c=&quot;3D&quot; d=&quot;M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3261.6, 0)&quot;&gt;&lt;path data-c=&quot;66&quot; d=&quot;M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(3811.6, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(4200.6, 0)&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(5022.8, 0)&quot;&gt;&lt;path data-c=&quot;2212&quot; d=&quot;M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(6023, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(6523, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(7134.2, 0)&quot;&gt;&lt;path data-c=&quot;2B&quot; d=&quot;M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(8134.4, 0)&quot;&gt;&lt;path data-c=&quot;66&quot; d=&quot;M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(8684.4, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(9073.4, 0)&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(9895.7, 0)&quot;&gt;&lt;path data-c=&quot;2212&quot; d=&quot;M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(10895.9, 0)&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(11395.9, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/section&gt;&lt;/span&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类似吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对，它们俩大体上就是一个东西，即：&lt;strong&gt;递归方程&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;递归代表着重复，重复，再重复...&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说白了计算机天生就是干重复事情的，这也是属于计算机唯一的美，&lt;strong&gt;暴力美&lt;/strong&gt;，之所以计算机看似那么“聪明”，实则是人类智慧的结晶在告诉计算机：你应该&lt;strong&gt;美&lt;/strong&gt;的暴力，&lt;strong&gt;优雅&lt;/strong&gt;的暴力，而不是直接暴力的暴力，这就是算法的力量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，当我们按部就班的分析出动态规划问题的前两个性质，写出&lt;strong&gt;状态转移方程&lt;/strong&gt;其实也不怎么难，所以也不要被任何高大上的术语吓到，盘它就完事儿了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后回忆我们前文的内容，斐波那切数列的例子，我们如何将暴力的&lt;strong&gt;递归&lt;/strong&gt;改造成优雅的&lt;strong&gt;动态规划&lt;/strong&gt;的呢？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;将自顶向下的递归，变成了自底向上的 for loop。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;将每次计算出来的节点值予以保存。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将斐波那切数列稍加改造，我们即可写出此题的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Fibonacci&lt;/strong&gt; 例子中，我们用 &lt;strong&gt;notes[n]&lt;/strong&gt; 来表示输入 &lt;strong&gt;n&lt;/strong&gt; 时的返回值答案，这里我们统一用 dp table.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即用 &lt;strong&gt;dp[amount]&lt;/strong&gt; 表示：当输入金额为 amount 时，可兑换的最少硬币数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们首先先创建一个 dp table 用来存储对应解，即：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt;[] dp = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[amount+&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么大小是amount + 1不是amount呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：因为我们 dp[amount] 的含义是当金额为amount时，凑出amount的最少硬币数量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设amount = 10，如果我们 new 一个 size 为 10 的数组，那么我们取 dp[amount] 时就越界了，故当我们要取到 dp[amount] 时，数组大小得为 int[amount + 1]。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后将&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dp[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解释：当金额为0元时，找出0个硬币。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;紧接着最主要的问题来了，也是最难写的一部分代码，前文提到说，将递归改为动态规划最显著的一个特点是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我们将自顶向下的递归，变成了自底向上的 for loop。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自顶向下很好写，因为直接递归嘛：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Fibonacci&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;fib&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; N)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (N == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (N == &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; fib(N-&lt;span&gt;1&lt;/span&gt;) + fib(N-&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们只需要在 base case 处判断，并返回相应的值，然后直接进行递归函数调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们如何转变成动态规划，自底向上呢?
这个时候就需要 &lt;strong&gt;&lt;em&gt;for&lt;/em&gt;&lt;/strong&gt; 循环（简单但又强大的 for loop）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文里我们已经得出了状态转移方程：&lt;/p&gt;&lt;span data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section role=&quot;presentation&quot; data-formula=&quot;f(n) = min[f(n -1),f(n -5),f(n - 11)] + 1&amp;#10;&quot; data-formula-type=&quot;block-equation&quot;&gt;&lt;embed src=&quot;https://mmbiz.qlogo.cn/mmbiz_svg/UGrobmT8GcIUcH8mVoZu167IVREVBDiaezmhmj3jfUV9sSPrOpMTrbkCMs8oHrYs94KSZAXb3Asygfs6SWqAHut98de4lNIhJ/0?wx_fmt=svg&quot; data-type=&quot;svg+xml&quot;/&gt;&lt;/section&gt;&lt;/span&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设一组数据是这样：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;coins = {1,2,5,7,10} amount = 14&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们建立 dp table:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt;[] dp = &lt;span&gt;int&lt;/span&gt;[&lt;span&gt;15&lt;/span&gt;];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始化 dp[0] = 0&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们考虑这样&lt;em&gt;自底向上&lt;/em&gt;写：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用变量 i 从 1 循环至 amount，依次计算金额 1 至 amount 的最优解，即 dp[amount]。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/og5r7PHGHoiaKTP6vlvqzWdN7yBP6Gnc6chJdrWGtlsazu6r7wuWUYPG1PsGjjSRMHICQmLd2kfDSOM0CEvozUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.2570145903479237&quot; data-w=&quot;891&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以写出第一层 for 循环：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;;i &amp;lt;= amount;i++){&lt;br/&gt;&lt;br/&gt;   ...&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后：对于每个金额 &lt;strong&gt;i&lt;/strong&gt;，使用变量 &lt;strong&gt;j&lt;/strong&gt; 遍历硬币面值 &lt;strong&gt;coins[]&lt;/strong&gt; 数组：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/og5r7PHGHoiaKTP6vlvqzWdN7yBP6Gnc64pxfTNPXHtpDaCibYFTcSKQT38ia6WpRSgfVgTiciaYpYL7pu2p4sibMWWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.4081381011097411&quot; data-w=&quot;811&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;对于所有小于等于 i 的面值 coins[j]，找出最小的 i - coins[j] 金额的最优解 dp[i - coins[j]]。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那么 dp[i] 的最优解即为 dp[i - coins[j]] + 1。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/og5r7PHGHoiaKTP6vlvqzWdN7yBP6Gnc6rJC2pKOL8kW4S8GQaxJFiaeFXDcUvaXUNln9icQzofCDJicCtNAg9mgyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.4017094017094017&quot; data-w=&quot;819&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如当前 &lt;strong&gt;i&lt;/strong&gt; 指向金额 &lt;strong&gt;6&lt;/strong&gt;，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;对于所有小于等于 6 的面额 coins[j]&lt;/strong&gt;，即&lt;strong&gt;coins[0]，coins[1]，coins[2] 分别为 1，2，5。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;找出最小的 6 - coins[j] 金额的最优解 dp[i - coins[j]]&lt;/strong&gt;，&lt;strong&gt;即&lt;/strong&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6 - 1 = 5 dp[5] = 1&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6 - 2 = 4 dp[4] = 2&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6 - 5 = 1 dp[1] = 1&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那么 dp[i]的最优解即为 dp[i - coins[j]] + 1&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;dp[6] = min(dp[1],dp[4],dp[5]) + 1&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由以上可知：&lt;strong&gt;dp[6] = 1 + 1 = 2&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后续依次计算...&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此，我们可以写出里层的 for 循环：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//来一个整型最大数，保证其它数第一次和这个数比较时都比这个数小&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//变量名叫min，这是对应外层i循环，即:求每个dp[i]的最优解&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; min = Integer.MAX_VALUE;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;;j &amp;lt; coins.length;j++){&lt;br/&gt; &lt;span&gt;//所有小于等于i的面值coins[j]，并且最优解小于默认最大值&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt;(coins[j] &amp;lt;= i &amp;amp;&amp;amp; dp[i - coins[j]] &amp;lt; min){&lt;br/&gt;   min = dp[i - coins[j]] + &lt;span&gt;1&lt;/span&gt;;&lt;span&gt;//更新dp&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt; dp[i] = min;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个 for 循环，这也是此题思想代码的核心。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们将两个 for 循环写一起，即写出了完整代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;coinChange&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] coins, &lt;span&gt;int&lt;/span&gt; amount)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt;(coins.length == &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;int&lt;/span&gt;[] dp = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[amount + &lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;      dp[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;;i &amp;lt;= amount;i++){&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; min = Integer.MAX_VALUE;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;;j &amp;lt; coins.length;j++){&lt;br/&gt;          &lt;span&gt;if&lt;/span&gt;(coins[j] &amp;lt;= i &amp;amp;&amp;amp; dp[i - coins[j]] &amp;lt; min){&lt;br/&gt;            min = dp[i - coins[j]] + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;          }&lt;br/&gt;        }&lt;br/&gt;        dp[i] = min;&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; dp[amount] == Integer.MAX_VALUE ? -&lt;span&gt;1&lt;/span&gt; : dp[amount];&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是&lt;strong&gt;自底向上&lt;/strong&gt;的写法，也是&lt;strong&gt;动态规划&lt;/strong&gt;的核心。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再回顾整个流程，如何尝试去处理一个&lt;strong&gt;动态规划&lt;/strong&gt;问题？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先分析这个问题符不符合&lt;strong&gt;动态规划&lt;/strong&gt;最重要的前两个性质（&lt;strong&gt;重叠子问题，最优子结构&lt;/strong&gt;）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果满足前两个性质，那么我们尝试写出&lt;strong&gt;状态转移方程&lt;/strong&gt;，也即&lt;strong&gt;递归式&lt;/strong&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;优化：将&lt;strong&gt;自顶向下&lt;/strong&gt;的递归式（&lt;em&gt;函数调用&lt;/em&gt;）改为&lt;strong&gt;自底向上&lt;/strong&gt;的&lt;strong&gt;动态规划&lt;/strong&gt;（&lt;em&gt;for loop&lt;/em&gt;）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，今天的动态规划问题到此就结束啦，当然动态规划的威力还远不止于此，关于动态规划更多的内容，我们后续再见～&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>