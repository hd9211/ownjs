<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>cfc0f11c1e9ac1ed1fd2cd4acd32d2cb</guid>
<title>前端:从零到一, 轻松把自己的网站部署到服务器</title>
<link>https://toutiao.io/k/w4mlsvi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9qXnTkZPuxe8H1QicBcbrQQVKOeKw2PsaPtbkhed7icVWmmGk0o3VgYFqKdtNwPFicT2aW803Yp7DqjdiaoFRYVX3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;54&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;跑步本身就是一件孤独的事，他人再分享再加油，要跑到终点也只能倚仗自己的体力和意志，就像生活本来的样子。&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.8&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gUVKXuw5icTuicMe1TSd3CYPJzxFcxUnzpBLmOY2lYosbSmH5Ro01bJbqOVUwZ97d098kTPyiaWWicblornticcLu9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;50&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注并将「&lt;strong&gt;趣谈前端&lt;/strong&gt;」设为星标&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每早08:30按时推送&lt;strong&gt;技术干货&lt;/strong&gt;/&lt;strong&gt;优秀开源&lt;/strong&gt;/&lt;strong&gt;技术思维&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU2Mzk1NzkwOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibpVQtdHw0UaW5glBQ3RRqy8rYolxkF0tOaAqTUGW9MXPIGvLUGAJ7jB2JicLxJd6xvvWicThNSWFgg/0?wx_fmt=png&quot; data-nickname=&quot;趣谈前端&quot; data-alias=&quot;beautifulFront&quot; data-signature=&quot;徐小夕【知乎专栏作家】掘金优秀作者，定期分享前端工程化，可视化，企业实战项目知识，深度复盘企业中经常遇到的500+技术问题解决方案。【关注趣谈前端，前端路上不迷茫】&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;p&gt;hi, 大家好, 我是徐小夕, 周末博学不打烊, 今天我们来分享点轻松且有用的知识. 作为一名前端工程师, 没有个自己的网站怎么行, 接下来我就来带大家介绍一下如何从零到一, 配置并部署自己的网站到服务器.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;你将收获:&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如何合理选购一台服务器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何将域名解析到服务器上&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务器配套软件的安装和环境配置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过命令行上传自己的网站到服务器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网站部署和运维(负载均衡等)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;接下来我们来开始fight!&lt;/p&gt;&lt;h3&gt;1. 如何合理选购一台服务器&lt;/h3&gt;&lt;p&gt;对于服务器的选择, 我们主要有以下几种选择:&lt;/p&gt;&lt;p&gt;国内用户如果没有特殊需求可以选择前三种, 这里我以阿里云举例, 当然其他服务器的配置都是相通的.&lt;/p&gt;&lt;h4&gt;1.1 服务器位置的选择&lt;/h4&gt;&lt;p&gt;我们都知道服务器的不同配置都是有讲究的, 并且一定程度上关系到我们网站的用户体验. 在选择服务器地址之前, 我们需要清楚的知道自己网站的用户群体主要集中在哪个区域:&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.49637305699481865&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibEhXUfBFTgmvtyRnd0YKYngWQsBBBwlHiaXDm526IzCYtbIFKw1v8LXTc2yvpIulLd9NFNA3ibgBXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1930&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;比如我的用户在上海, 我们在&lt;strong&gt;地域及可用区&lt;/strong&gt;选项中可以选择&lt;strong&gt;华东2(上海)&lt;/strong&gt;, 以此类推.&lt;/p&gt;&lt;h4&gt;1.2 服务器镜像的选择&lt;/h4&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2597535934291581&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibEhXUfBFTgmvtyRnd0YKYnSnlC8AKBWkLdVuy0pjNnicvNaMO8HrLLm0ibfz5W9XX3IdlZaHy2QUyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1948&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;目前我们常用的服务器镜像有:&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;centos&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;windows Server&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Ubuntu&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;根据自己的使用习惯选择即可, 我一般习惯选择 &lt;strong&gt;centos&lt;/strong&gt;, 接下来也会以 &lt;strong&gt;centos&lt;/strong&gt; 来介绍相关的配置.&lt;/p&gt;&lt;h4&gt;1.3 服务器系统盘存储的选择&lt;/h4&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15845410628019324&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibEhXUfBFTgmvtyRnd0YKYnMEpkkfFG7D25CPicNVNdaQt46uPQBBORd1rtnDuw5HGHgk3ia2xFMhIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2070&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;系统存储的选择也需要结合自身网站, 如果网站是内容很多的资源型网站(图片, 视频等), 可以选择稍微大一点的, 比如 &lt;strong&gt;100G&lt;/strong&gt; 以上. 一般个人网站或者测试站&lt;strong&gt;50G&lt;/strong&gt;足已, 毕竟一份存储一份钱.&lt;/p&gt;&lt;h4&gt;1.4 服务器带宽选择&lt;/h4&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.17482517482517482&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibEhXUfBFTgmvtyRnd0YKYnhM3U4icoOQ80Dbia2o0Lw2xvSmgHolHlYlicXl8NkjRCiaicfic2cwYfDQQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2574&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;一般为了给用户一个好的网站体验, 我们会提高带宽来降低网站加载时间. 但是一味的提高带宽会大大加大服务器的费用, 所以我们一方面需要在对网站自身做好优化, 另一方面也可以使用对象存储, 这样我们就能控制一定的带宽了, 比如目前 &lt;strong&gt;H5-Dooring&lt;/strong&gt; 的带宽在&lt;strong&gt;10M&lt;/strong&gt;左右, 一年服务器费用大概 &lt;strong&gt;1-2W&lt;/strong&gt;. 但是对一些测试型, 个人网站来说, 选择&lt;strong&gt;2-5M&lt;/strong&gt;都是一个合适的范围.&lt;/p&gt;&lt;p&gt;当然大家也可以选择按流量付费.&lt;/p&gt;&lt;h4&gt;1.5 服务器规格选择&lt;/h4&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3139635732870772&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibEhXUfBFTgmvtyRnd0YKYnafE0QLAoqX3B5lNA4xvAWV8g1Q4RER528qhch3h6YGl3uBt7jckugw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2306&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;如果你是个人使用对吞吐性能没有过多要求, 可以选择&lt;strong&gt;1核1G&lt;/strong&gt;低配版的, 不过建议个人网站最好选择&lt;strong&gt;1核2G&lt;/strong&gt;或者&lt;strong&gt;2核4G&lt;/strong&gt;的, 说不定你的网站就突然🔥了呢?&lt;/p&gt;&lt;p&gt;至于服务器的其他配置,大家都可以随意选择, 也可以直接用默认的.&lt;/p&gt;&lt;h3&gt;2. 如何将域名解析到服务器上&lt;/h3&gt;&lt;p&gt;当我们选购好一台服务器之后, 我们在控制台可以看到自己服务器的&lt;strong&gt;公网IP&lt;/strong&gt;. 这也是域名解析的关键. 域名可以在云服务平台内直接购买, 一般一个域名在&lt;strong&gt;20-60&lt;/strong&gt;¥之间, 推荐使用 &lt;code&gt;.com&lt;/code&gt;, &lt;code&gt;.cn&lt;/code&gt;的域名, 当前其他后缀的域名也可以, 取决于你对网站的定位.&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.29982517482517484&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibEhXUfBFTgmvtyRnd0YKYnfBRicmiasQet94pIia0BzI07jozlwwW7J8efWrnepRR5NtjGugH7W1I5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2288&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;我们只需要在云服务的域名管理中添加需要解析的服务器记录即可.&lt;/p&gt;&lt;p&gt;上图的&lt;strong&gt;主机记录&lt;/strong&gt;配置中常用的有 &lt;code&gt;www&lt;/code&gt; 和 &lt;code&gt;@&lt;/code&gt;, 我们选择任何一个即可. (主机记录相当于域名的前缀)&lt;/p&gt;&lt;p&gt;&lt;strong&gt;记录值&lt;/strong&gt; 就是我们服务器的IP, 也就是上面提到的&lt;strong&gt;公网IP&lt;/strong&gt;. 我们配置好之后点确认, 等待5-10分钟即可解析完成, 不过一般都在3分钟内.&lt;/p&gt;&lt;p&gt;通过以上方式, 我们的域名就成功解析到对应的服务器上了, 是不是很简单? (前提是域名必须备案, 至于如何备案, 也很简单, 可以按照云厂商指引进行操作)&lt;/p&gt;&lt;h3&gt;3. 服务器配套软件的安装和环境配置&lt;/h3&gt;&lt;p&gt;有了上面服务器的配置基础, 我们开始“倒腾”服务器. 作为一名前端程序员, 服务器上没有&lt;code&gt;nodejs&lt;/code&gt;说不过去了吧! 接下来我们开始安装&lt;code&gt;nodejs&lt;/code&gt;. 在安装之前, 我们需要先进入服务器终端:&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibEhXUfBFTgmvtyRnd0YKYn0X7zVF17FU8xAI1OP6PTABM9m6Q8LA8al2iabK8LKiaPrvUZ1KR9tHicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;密钥对一般在服务器列表的右侧更多下拉项里, 我们一般第一次使用需要重置密钥对, 在设置好密钥对之后, 我们在自己计算机的终端输入如下命令:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ssh root@你的公网IP&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;之后在终端输入完密码之后即可进入服务器.&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.18779342723004694&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibEhXUfBFTgmvtyRnd0YKYn7T5JeSTSCKSYjec5yFcIlicjMVk1Ttk11H2u6FfWAU4wqE4NDcrkOvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;852&quot;/&gt;&lt;/p&gt;&lt;p&gt;如果服务器没有wget, 我建议大家可以安装一下, 毕竟后面很多场景都会用到.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;yum install wget&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;是不是神似我们的&lt;code&gt;npm&lt;/code&gt;. 之后我们就可以开心的安装&lt;code&gt;nodejs&lt;/code&gt;了:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# 安装nodejs&lt;/span&gt;&lt;br/&gt;wget https://nodejs.org/dist/v14.15.4/node-v14.15.4-linux-x64.tar.xz&lt;br/&gt;&lt;span&gt;# 解压&lt;/span&gt;&lt;br/&gt;tar xf  node-v14.15.4-linux-x64.tar.xz &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解压完成之后我们可以手动进入 &lt;code&gt;nodejs&lt;/code&gt; 的 &lt;code&gt;bin&lt;/code&gt; 目录, 测测&lt;code&gt;nodejs&lt;/code&gt;是否可用. 但是下载下来的&lt;code&gt;nodejs&lt;/code&gt;的目录名又臭又长, 怎么办呢? 这里就要学好&lt;code&gt;linux&lt;/code&gt;了, 我这里给大家介绍一种简单的重命名文件/目录名的方法:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;mv node-v14.15.4-linux-x64 nodejs&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;mv&lt;/code&gt;是&lt;code&gt;linux&lt;/code&gt;移动文件的命令,当然如果在同一个目录下, 它也可以做重命名功能使用.&lt;/p&gt;&lt;p&gt;最后一步就是配置&lt;code&gt;nodejs&lt;/code&gt;全局环境了. 这里我们也是使用 &lt;code&gt;linux&lt;/code&gt; 的命令&lt;code&gt;ln&lt;/code&gt;.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;ln -s /...你nodejs所在的更目录/nodejs/bin/node  /usr/&lt;span&gt;local&lt;/span&gt;/bin/node&lt;br/&gt;ln -s /...你nodejs所在的更目录/nodejs/bin/npm   /usr/&lt;span&gt;local&lt;/span&gt;/bin/npm&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样我们通过软连接就实现在全局环境下使用&lt;code&gt;nodejs&lt;/code&gt;.&lt;/p&gt;&lt;h3&gt;4. 通过命令行上传自己的网站到服务器&lt;/h3&gt;&lt;p&gt;那么环境有了之后我们就可以直接上传我们的网站代码了, 因为我们选择的是 &lt;strong&gt;centos&lt;/strong&gt; 服务器, 它没有可视化的界面来操作, 而且我的电脑是 &lt;code&gt;mac&lt;/code&gt;的, 这可咋整呢? 不用担心, 继续用命令行!&lt;/p&gt;&lt;p&gt;我们可以使用命令行从本地上传文件或文件夹到服务器, 也可以从服务器下载文件到本地电脑, 这些操作无疑多亏了&lt;code&gt;scp&lt;/code&gt;. 接下来我将演示如何从本地上传文件夹到服务器.&lt;/p&gt;&lt;pre&gt;&lt;code&gt;scp -r 本地文件夹路径 root@你的公网IP:/上传到的服务器路径&lt;br/&gt;&lt;span&gt;# 如&lt;/span&gt;&lt;br/&gt;scp -r ./dist root@xxx.xxx.xxx:/website/&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中&lt;code&gt;-r&lt;/code&gt;是用来传文件夹用的, 如果你要上传的文件包含文件夹, 可以添加这个标识.&lt;/p&gt;&lt;h3&gt;5. 网站部署和运维(负载均衡等)&lt;/h3&gt;&lt;p&gt;网站可以用&lt;code&gt;nginx&lt;/code&gt;代理和做负载均衡, 网上也有很多资料介绍, 这里我带大家介绍一下&lt;code&gt;pm2&lt;/code&gt;.&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44326990838618746&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibEhXUfBFTgmvtyRnd0YKYnc5giaW5Scy3hrM9gotABUM7VM2qz3Ka19Z3zelhdyibj6TMnlKLpEWiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2838&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;PM2 是一个守护进程管理器，它将帮助我们管理和保障应用程序稳定在线. 如果你是nodejs的忠实粉丝, 那么它将是个不错的选择. 作为前端工程师, 搭建全栈的网站用&lt;code&gt;nodejs&lt;/code&gt;也是一个非常高效的选择.&lt;/p&gt;&lt;p&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;最新的 PM2 版本可以使用 NPM 或 Yarn 安装：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ npm install pm2@latest -g&lt;br/&gt;&lt;span&gt;# or&lt;/span&gt;&lt;br/&gt;$ yarn global add pm2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;启动应用&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;启动、守护和监控应用程序的最简单方法是使用以下命令行：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ pm2 start app.js&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或轻松启动任何其他应用程序：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ pm2 start bashscript.sh&lt;br/&gt;$ pm2 start python-app.py --watch&lt;br/&gt;$ pm2 start binary-file -- --port 1520&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以传递给 CLI 的一些选项：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# Specify an app name&lt;/span&gt;&lt;br/&gt;--name &amp;lt;app_name&amp;gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Watch and Restart app when files change&lt;/span&gt;&lt;br/&gt;--watch&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Set memory threshold for app reload&lt;/span&gt;&lt;br/&gt;--max-memory-restart &amp;lt;200MB&amp;gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Specify log file&lt;/span&gt;&lt;br/&gt;--&lt;span&gt;log&lt;/span&gt; &amp;lt;log_path&amp;gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Pass extra arguments to the script&lt;/span&gt;&lt;br/&gt;-- arg1 arg2 arg3&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Delay between automatic restarts&lt;/span&gt;&lt;br/&gt;--restart-delay &amp;lt;delay &lt;span&gt;in&lt;/span&gt; ms&amp;gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Prefix logs with time&lt;/span&gt;&lt;br/&gt;--time&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Do not auto restart app&lt;/span&gt;&lt;br/&gt;--no-autorestart&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Specify cron for forced restart&lt;/span&gt;&lt;br/&gt;--cron &amp;lt;cron_pattern&amp;gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Attach to application log&lt;/span&gt;&lt;br/&gt;--no-daemon&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如我们所见，有许多选项可用于使用 &lt;strong&gt;PM2&lt;/strong&gt; 管理我们的应用程序。目前&lt;strong&gt;H5-Dooring&lt;/strong&gt;也是采用这种方式部署的, 所以如果你有自己的网站, 赶紧参考这个教程部署吧~&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.77602523659306&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dFTfMt01149azIOraEibmPa8b4hib04RNf3ZNbfOxzVgibicvJBDS0DLE6ibnUtQ94MJWE0nicfDexicX2plyMnub4TnA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;634&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;h2&gt;&lt;span&gt;❤️ 看完三件事&lt;/span&gt;&lt;/h2&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如果你觉得这篇内容对你挺有启发，我想邀请你帮我三个小忙：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;点个【在看】，或者分享转发，让更多的人也能看到这篇内容&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;关注公众号【趣谈前端】，&lt;span&gt;定期分享 &lt;/span&gt;&lt;strong&gt;工程化 &lt;/strong&gt;&lt;span&gt;/ &lt;/span&gt;&lt;strong&gt;可视化&lt;/strong&gt;&lt;span&gt; / &lt;/span&gt;&lt;strong&gt;低代码&lt;/strong&gt;&lt;span&gt; / &lt;strong&gt;优秀开源&lt;/strong&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94385&quot;&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94715&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img border=&quot;0&quot; class=&quot;__bg_gif rich_pages wxw-img&quot; data-ratio=&quot;0.08658008658008658&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/usyTZ86MDicgqjLq0USF6icibfWiaLSV8bz17cBjvXylU7dz9mIMP7lUF50OE2gFrlZDQlIyWvGcUiaprq92fq8tgXg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;462&quot; data-width=&quot;100%&quot; height=&quot;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2Mzk1NzkwOA==&amp;amp;mid=2247489810&amp;amp;idx=1&amp;amp;sn=2663938569c4d361acae076bce9a9bf5&amp;amp;chksm=fc5300e9cb2489ff48db614f03093d71a81669bc6e0ccdf88b10af4a899b86ce59c6c95198b5&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;从零搭建全栈可视化大屏制作平台V6.Dooring&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2Mzk1NzkwOA==&amp;amp;mid=2247489467&amp;amp;idx=1&amp;amp;sn=be4b2a7f92f1c62e66432158212aee78&amp;amp;chksm=fc530e40cb248756193998c50b2e5e75de96dbde98170f871faa7e6ea043a50f87b7fc4468cf&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;从零设计可视化大屏搭建引擎&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2Mzk1NzkwOA==&amp;amp;mid=2247487877&amp;amp;idx=2&amp;amp;sn=770ff16d69d3e7ac2bbcd78e97ab8f32&amp;amp;chksm=fc53087ecb2481685451a50e892fa889781788ca16a4ce689ec7f7fff1ae99c91ac8b82a160d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;Dooring可视化搭建平台数据源设计剖析&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2Mzk1NzkwOA==&amp;amp;mid=2247487950&amp;amp;idx=1&amp;amp;sn=e674a2f9379b9c9b8a149498a50c17f8&amp;amp;chksm=fc530835cb2481233acc7ac2c856b30c7698dd9d2aec1514b5c2fa4165bc2728f7b261c4938f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;可视化搭建的一些思考和实践&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2Mzk1NzkwOA==&amp;amp;mid=2247486910&amp;amp;idx=2&amp;amp;sn=7ce865dd8a8f6769439f0e8eebb72212&amp;amp;chksm=fc531445cb249d534a7d8a362ad40d26bc90f2d2e867385768ee19575e32826fcbe419fcbe0b&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;基于Koa + React + TS从零开发全栈文档编辑器(进阶实战&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;点个&lt;span data-mid=&quot;&quot;&gt;在看&lt;/span&gt;你最好看&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.2&quot; data-type=&quot;png&quot; data-w=&quot;60&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/SgotVleX0gOsmNiae4tDzLaG2rHT2FWEJcEvep02gEar4acRc4Nf9cxibxFj2Ygdn3ucM4THibzD8EwmZTyv88icAQ/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                          
              &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>176b6017f18f3f02b424b078d5682236</guid>
<title>基于ES的开源分布式SQL数据库，CrateDB适用于哪些场景？</title>
<link>https://toutiao.io/k/rce7d08</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwOTIxNDQ3OA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8YRIaicYx5pzj5Cxwick8DamnOgbTJu96QTibKyHEDZt1815yOV1r27oZ6HgoYTEYWYLRz4jIV4iasHgg/0?wx_fmt=png&quot; data-nickname=&quot;dbaplus社群&quot; data-alias=&quot;dbaplus&quot; data-signature=&quot;围绕Database、BigData、AIOps的企业级专业社群。资深大咖、技术干货，每天精品原创文章推送，每周线上技术分享，每月线下技术沙龙，每季度Gdevops&amp;amp;DAMS行业大会.&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-id=&quot;7&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;本文根据许鹏&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;老师在〖deeplus直播：开源分布式数据库CrateDB在携程的最佳实践〗线上分享演讲内容整理而成。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;（文末有回放的方式，不要错过）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3992537313432836&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8Z2mTEo3ILuleeHQhL4AEBextsiaQSZEcVJdicUGR0lof8JmAvzSJAaR6aC7GjxdFQ2EcA0aMW43ajA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1072&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;许鹏&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;携程 研发总监&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;今天的分享主要包含以下几个方面的内容：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CrateDB介绍&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CrateDB在携程的实践&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CrateDB在携程的优化&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot; draggable=&quot;true&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;一、CrateDB介绍&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、CrateDB&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBXxs6PTEgyXSDKBiaZrwWw5E0PMnXyqv6vITYoYYTKPg2pjcibvBmymib3w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;CrateDB是一款基于ElasticSearch的分布式数据库，它与ElasticSearch最大的区别是提供了ANSI SQL查询访问接口。ElasticSearch在6.X版本以后，也开始提供SQL的查询，但CrateDB与ElasticSearch相比，能够支持多索引之间的关联查询，针对某些聚合函数，它返回的是精确的查询结果，而ElasticSearch返回的是近似值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、CrateDB的特性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CrateDB适用于海量时序数据存储，需要频繁更改的数据使用CrateDB存储效果较差。因为CrateDB基于ElasticSearch，频繁的删改操作会使它的性能大大受损。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CrateDB继承了ElasticSearch设计中高可靠的优点，集群较方便实现扩容，对于一些点查询或复杂度中等的查询均能够较为实时地返回结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CrateDB支持Dynamic Schema，其最新版本能够支持json数据格式，写入数据更加方便。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我认为CrateDB的初衷是用SQL的方式查询访问基于&lt;span&gt;ElasticSearch&lt;/span&gt;存储的数据。基于这一概念，我们可以看到它大概的分层（如上图所示），从外部访问从下到上依次到达最终的存储，其最外一层提供了PostgresSQL兼容的访问协议和REST API的访问协议，接下来对语句进行解析，然后执行，获取存储在各个节点上的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、海量数据存储对比&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;因为类似技术较多，这里只对比几个典型的技术，CrateDB、ElasticSearch以及MongoDB，这三者都可以归类于Nosql。下文将从7个维度对三者进行对比。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBXQm8bncggQ7OicibdzeVcIM3xmHHnf2FLQV6rmXEPkMUq8OSiaCwCNmTZg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）Schema支持类型&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这三个数据库均支持&lt;span&gt;Dynamic Schema&lt;/span&gt;。但在现实的生产环境下，我们推荐采用Struct Schema，因为&lt;span&gt;Dynamic Schema&lt;/span&gt;可能会带来种种问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;paragraph&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section label=&quot;Copyright © 2015 Yead All Rights Reserved.&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;仅代表个人观点，并非适用于所有场景。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）是否支持SQL访问&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SQL诞生四十多年，已成为非常成熟的语言，具有极强的表达能力。同时SQL具有通用性，被大家普遍接受。CrateDB基于SQL的通用性不断发展，其支持ANSI SQL，并且采用了PostgreSQL协议。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ElasticSearch起初只支持类json格式的查询语法，之后开始提供针对单索引的一些SQL语句支持函数，并不断丰富。&lt;/span&gt;&lt;span&gt;MongoDB据我所知并未直接支持SQL，如果写入SQL语句，需要通过第三方插件才能够被MongoDB识别，这在一定程度上会影响查询性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）可扩展性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从可扩展性角度出发，CrateDB和ElasticSearch采用gossip&lt;/span&gt;&lt;span&gt;协议组建集群，简单来说节点之间相应对等。在一个&lt;span&gt;ElasticSearch&lt;/span&gt;集群中，节点可分Master、Coordinator，以及承载数据的Data，一个节点可以同时扮演三个不同的角色，因此它们是对等的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MongoDB则不同，如果用它来构建一个分布式集群，最起码有三个不同的Host，分别是Config Server、Mongos以及Data，为了实现高可靠，一个分片还需要分成相应的Master或Slave。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;综上所述，从可扩展角度来看，ElasticSearch和CrateDB更好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4）对于关联分析的支持程度&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CrateDB支持跨索引之间的关联分析，而ElasticSearch则使用一些变通的方式支持此类关联查询，这意味着在写入数据时需要做相应变更。MongoDB在4.X版本时不支持关联查询，之后的版本未及时关注，如描述有误，欢迎大家指正。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5）聚合准确度&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CrateDB和MongoDB返回精确值，ElasticSearch则是返回近似值，虽然返回近似值执行速度快，但其计算的准确度会受到一定影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;6）性能&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在查询性能方面， CrateDB和ElasticSearch都能够较好地返回查询结果，上图中列出的耗时为100毫秒。对于较为简单的查询，100毫秒算是较高的消耗，事实上可以在更短的时间内返回结果。后文中会提到我们自己质量环境下的实际耗时。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;7）运维&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;引入一项新技术后，其带来的运维复杂度十分关键。CrateDB和ElasticSearch相较于MongoDB运维复杂度更低。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、CrateDB系统架构及节点类型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBXMNI3m6rnJB7cCZicGQWzgpYba0zBoiadnAoGA8NmWdAianicvXk1xxN3yA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBXDic5QKVyibUm8frFwnWibWibhReazoTfDibssUC4D1aPnlMp5c7z5HuAkuA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上文中提到在CrateDB和&lt;span&gt;ElasticSearch&lt;/span&gt;中节点之间相互对等。以&lt;span&gt;ElasticSearch&lt;/span&gt;举例，由5个节点构成的ElasticSearch集群中起码有两个不同的角色。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该角色需要负责两个方面的工作，分别是管理节点和管理索引。节点加入集群，在集群中创建了多少个不同的索引，这些索引的分片分布在哪些机器上，这些信息都由 Master来管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们创建好的索引，数据最终要落到一个具体的ElasticSearch节点上，这些最终承载数据的就是数据节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图右半部分所示为在生产上部署一个CrateDB或&lt;span&gt;ElasticSearch&lt;/span&gt;集群。&lt;/span&gt;&lt;span&gt;最上方的负载均衡部分可有可无。除上文提到的两种节点类型外，还有一种叫做Coordinator的节点类型，它既不承载具体的数据，也不扮演Master的角色，只接受外部的请求，并将外部请求路由到数据节点上做具体查询，然后在Coordinator节点做一些汇总，最后返回给应用程序。除此之外，ElasticSearch中可能还会有一个叫Ingest的节点类型，这里不进行过多阐述。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;综&lt;/span&gt;&lt;span&gt;上所述，一个CrateDB的表类似于一个ElasticSearch的索引，ElasticSearch中索引由多个不同的分片组成，每一个分片可能会落到某一个数据节点上。为了实现高可靠，一个分片又分成主分片和副本分片，即图中列出的Primary和Secondary。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5、CrateDB具体操作&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）表创建&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个操作和我们平时用PostgreSQL或MySQL创建一张表并无很大差别。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBXVuKRUmJEZqX9ZiaPwDQroFJCsLn5rhlKJKZggwqNtlic7UQBRRjAcaUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;创建一张职工的表（如上图所示），其中包括姓名、年龄、性别以及住址。这张表根据姓名来进行哈希，哈希的结果分到4个不同的分片中，with后面跟着一些针对索引层面的配置，它的配置项多达几十项。我们最主要关注以下几点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果只有主分片，replica数为0。如果在主分片之外，还有别的副本分片，增加相应的replica数即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ElasticSearch进行刷新数据会从内存刷新到磁盘，不断刷新会降低性能。为了保证更多数据留在内存中，减少刷新的次数，我们可以调节刷新间隔，具体调整根据对数据的新鲜度要求而定。数据只有被刷新后才能被搜索到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ElasticSearch采用的是write ahead log的方式，这意味着有大量的translog。translog同样将数据从内存写到磁盘，这当中有一个sync的间隔，如果调高这一间隔，可能会加快写入速度，但也有可能带来容错方面的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）乐观并发控制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CrateDB是基于ElasticSearch的数据库，其在ElasticSearch基础上进行了叫做乐观并发控制的演变。我们将数据写入到某一张表时，有两个隐藏的列，一个是sequence_number，即这一列的版本号，另一个为primary_term，二者联合使用可以实现某一版本的数据只更新一次，避免频繁更新。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBXXKmm1ZO620Jqc6SjjA8V8EbwL1YFmTU9gG4bT52EEanAEOW132M1CQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上图中的语句为例，对sequence_number等于0进行更新，当这条语句执行成功后，它的sequence_number会自动跳到1，每更新一次，这个值就会递增。如果有两个不同的进程或两个不同的外部访问，试图来更新同一条语句，那么只有一条会被执行成功，这就做到了乐观并发控制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）Partitioned Table&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBXZJsZrNCYKtVFlHD3VrWe43HgpDvIg9ibibKpODoxOjjiaySbHahcsYicgA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CrateDB与ElasticSearch不同，它引入了Partitioned Table的概念，即所谓的分区表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上文中讲到一个表存在多个分片承载数据，即ElasticSearch的一个索引有多个不同的分片，对应到&lt;span&gt;CrateDB&lt;/span&gt;中是分区，CrateDB中的分区可以与ElasticSearch中的别名相对应。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果我们要查询或写入表的数据量达几十亿或上百亿，将这些表都放到同样一个索引当中，可能会导致查询与写入的速度变慢，我们其实可以把这些数据分成多个不同的分区。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在我们实际的生产中有这样一种情况，一些坐过飞机的用户可能希望查看自己的飞行足迹，如果将所有用户的历史数据都放在同一个索引中，经过查询最后在前端展现的话，速度可能会较慢，因为这一操作对接口的要求较高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如要求在50毫秒内返回结果，如果不把这些数据做分区的话，查询会很慢。此处的慢是99%line的情况，在此情况下，我们要达到满足性能指标，其中一个变通方法就是把它拆成多个不同的分区，每个uid进入后只需要到对应的分区表查询即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在做分区的时候有一点需要注意，如果表已经创建了组件，分区的字段必须都属于组件字段的列表，因为这个组件可以由一个列或多个列组成，也可能是一种复合的组件，分区的字段必须在组件的字段列表当中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、CrateDB在携程的实践&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、实时聚合分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBXuHkDCQX3n72217ztvoXkxU3lznOEnHrOv7arMIjce97mEMxrjKddEQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;上图是我们使用CrateDB之后进行的比较，图中只比较了CrateDB和Presto，我们当时的场景如下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们有不少的表，每张表的数据量都有几千万条，有的甚至上亿条，需要对数据做比较复杂的聚合。&lt;/span&gt;&lt;span&gt;原来是用Presto查询，因为它是一个看板，每次刷新的间隔延迟较大，为了解决这个问题，我们尝试了一些方法，后来发现用CrateDB效果较好，右侧是性能对比，收益十分明显。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）具体分析场景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在性能对比方面，采用CrateDB后，我们基本上能够在1~2秒之内返回结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、海量数据存储以及实时查询&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;在我们实际的生产中有不少实时数据聚合分析的调用。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBX08uxria2sWpnu382aibuSLEriaXtvKYfzxLKo5R12suS2PnoeYee5yFLw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;起初，我们是将数据放入Redis中，每收到一次取数请求，我们都会进行相应的代码开发，把取出的数据进行相应解析，处理之后返回给调用方。这个需求虽然不复杂，但是因为我们没有办法注入数据分析的逻辑，所以不得不进行代码工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;引入CrateDB后，我们可以将分析工作采用SQL的方式来实现，对于那些用SQL分析不能完全解决掉的剩余部分，则联合一些Groovy脚本完成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于这样的理念，我们开发了一个模板，我们将SQL写入模板中，指定从哪个表中取数，如何分析，决定取完数后是否需要进行定制的后续处理，如果需要，则执行相应的Groovy的脚本，最后返回结果。这一套流程大大节省了开发的周期，提升了开发的效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBXwBHVf07YxV6mvUiaakLthctGKiboOUibhFXBRPwQ8r3KickDGkvOsoSsXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除开发周期对比外，存储方面的对比也十分显著。&lt;/span&gt;&lt;span&gt;例如数据放入到Redis中，需要200g内存，用CrateDB来存，可能只需要50g，这不仅是数据量上的减少，同时意味着成本的大大缩减。&lt;/span&gt;&lt;span&gt;在携程，有基于RocksDB的存储，它开发有Redis兼容协议，可以做到把数据存储到磁盘上，同时可以用Redis的接口访问。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们将数据存入了磁盘，分别从均线、95%line、99%line三方面对比性能。均线方面还在可以忍受的范围内，当然CrateDB不可能比Redis更快。从上图中可以看出，除99.9%line的时候差距大一点，其他均在可接受的范围内。在数据导入耗时方面，我们运用Spark将数据导入CrateDB，两者差距不是特别大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、CrateDB在携程的优化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、落地时的调优&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;当我们将CrateDB引入整体的技术方案中时，还需要进行一些调优。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBX5faibNqa2oKb65wa74ia4FWtbBoh3tZ3APY6KfgvpFGKV6KrpcwpMjpg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）磁盘空间调优&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了避免大量磁盘空间的消耗，需要对索引层面进行优化。除此之外，还可以进行聚合优化，关闭列存储。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）update操作优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了提升 update操作的性能，我们建议先insert，然后再删除已有的数据。为了达到目的，可以加上相应的版本号，每次只取最新版本的数据。对于在线更新的需求需要做转换，这也意味着采用CrateDB所能够支持的场景是有受限的,对于严格要求一致，或更新频繁的场景，CrateDB不是很好的选择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）查询优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上文中提到采用分区加多个分片的方式优化表结构的存储，使得每一次查询只需要去查尽可能少的分区或分片，查的数据越少、越精准，时间消耗就越短。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4）过期数据删除优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、Spark数据导入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;在数据导入CrateDB时，我们可能会用 Spark进行操作，此处向大家分享这一过程中的一个细节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBXoibLBqjNefs1J7pmK4dovEJouK2tPsqh3DSSQ8m3P2rK2OINibvwnppw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此处用分区举例，如果有一个十几亿或几亿的用户ID，还有一些关联数据，要把它均匀地落到每个分区上，有一种比较简单的方法。我们把 uid（一串字符）进行相应的MD5，MD5之后，取前两位或后两位，就可以得到256个分片。256分片显然太多了，可以再除以一个系数，减少分片数，就可以让这些数据均匀分布，这样可以做到分片上承载的数据量是差不多的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样做的挑战是在写Spark程序时，怎样让每一个partition当中的数据都是落入同一个分片的内容，大家可能会想到repartition函数，但repetition是对某个字段进行哈希，并不能保证落到同一个 partition的数据，这时我们就需要去制定 partition。上图右侧写出了一些伪码，我们在spark中定义一个repartition，然后重载，显示这里可能会有多少个不同的分片。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设我们刚才取前两位或取后两位，然后除以4得到64个分片的话，那么我们把传进来的数字跟64取模就对应到某一个具体的partition的位置。在Spark中有&lt;span&gt;partitionB&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;，&lt;span&gt;partitionB&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;只支持rdd算子，DataFrame中没有partitionBy的算子，所以我们需要先把DataFrame或者DataSet转成rdd，通过组成一个 key键值对的方式进行&lt;span&gt;partitionB&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;操作。之后还需要将相应的rdd转换回DataFrame，这样就可以得到一个分布很均匀的 DataFrame，再将其写入CrateDB中，就能达到很快的写入速度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、运维自动化尝试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBXJCHJnumJeOZLPicFOaNxyLqfibkQiaIWel6xh5QTKN6N83WnicZEwbfhNw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;我当时是用 Rancher、OpenEBS，以及Nginx Ingress实现了一个在K8S上的CrateDB集群，这使得我们在云环境去部署CrateDB成为一种可能，部署到云上，即便是私有云上，也可以提高硬件使用率，这也是我的初衷。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、CrateDB admin UI&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;320&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8aMM5LAR7cRG5qWJFwHMzBX1ApqGInUZCbibG5icXSNnlLlKQ0T2FLYtqhv2sXLSRZbf2GrCZLmnRAQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;CrateDB&lt;/span&gt;安装完成后，会打开上图所示的操作界面，我们能够直接写入查询语句，也可以方便地观测到整个集群的状况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、CrateDB的适用场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、CrateDB的不足&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Upsert性能较低&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;仅支持NRT查询&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;高阶SQL函数有待实现&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不支持事务&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;Q&amp;amp;A&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Q1：CrateDB有解决ES字段类型无法修改、写入性能较低和高硬件资源消耗等痛点吗？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;A1：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;首先，CrateDB支持修改字段类型，这个字段类型的修改和PostgreSQL中相同，可以将varchar改成text，但将varchar类型直接改成time stamp可能就会有问题，这时就不得不从重写或者是进行转换。&lt;/span&gt;&lt;span&gt;其次，写入性能高低分场景，如果只是单独insert的话，它的性能还是很高的，&lt;/span&gt;&lt;span&gt;如果是upsert，或delete与insert掺杂在一起的话，这种混杂这种模式的话，写入性能就会有一些问题，需要进行相应的变通。变通的方式有两种，第一种是先把新数据insert，再把老数据delete。第二种方式是新数据较小的话，可以写入一张另外的临时表中，临时表和新的表进行关联，再做相应的update。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Q2：CrateDB 相比于 Elasticsearch 和 MongoDB ，备份和恢复能力如何？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;A2：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;CrateDB和Elasticsearch在备份和恢复能力层面一样，但是和MongoDB相比，可能更加直观和容易，这是我个人的理解。恢复方面，如果你要求写入时所有数据都吐到磁盘之后才返回，那么所有数据应该都是全部无丢失的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Q3：CrateDB运行一段时间性能会明显降低，除了重启还有什么方案？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;A3：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;CrateDB在实际运维中确实会碰到一些问题，但是我没有碰到性能明显下降的情况。如果有的话，你可以进行索引级别的重建，而不是整个集群的重启，因为集群重启带来的成本较高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Q4：CrateDB日志分析能力如何，有继承ES的ELK能力吗？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;A4：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在与Logstash和Kibana搭配这一层面，还是ES能力更强。从整个生态圈的角度来看，CrateDB还是不能和&lt;span&gt;Elasticsearch&lt;/span&gt;相比的，因为&lt;span&gt;Elasticsearch&lt;/span&gt;的发展时间久，然后有Logstash和Kibana的加持，在数据的可视化还有分析展现层面确实很强，但是CrateDB可以和另外几个开源的产品搭配使用，比如说Apache Superset但是肯定没有Kibana那种原生定制的强大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Q5：如果把CrateDB部署在k8s上，数据存储应该怎么存放，是分布存储，本地存储，还是集中存储？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;A5：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;上文中提到需要和OpenEBS或Rancher结合，它是分布式处理的，你的节点要附着于相应的存储机器上面，即使Docker挂了，数据是不会丢失掉的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Q6：CrateDB贵司用在TP场景多还是AP场景多？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;A6：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我们用到的是 AP场景，实时数据的聚合返回结果的，当然每一次查询所命中的数据集并不是特别大，我们要查询的数据集可能是很大的，但是真正被查询条件所命中的还是比较少的，可能是几十万。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Q7：CrateDB 的对标竞品是什么，和大数据生态圈比如hadoop有互补吗 ？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;A7：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;rateDB不是跟Hadoop相竞争，它们两个应该在不同的层面，因为Hadoop是进行离线数据存储的，而CrateDB是做数据分析的。如果要寻找对标竞品的话，我个人认为TimescaleDB是一个很强的竞品，因为它们都号称是时序数据库，同时也提供ANSI SQL的查询标准。从现在的态势来看，可能TimescaleDB获得的用户群更多一点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;活动推荐&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2022 Gdevops全球敏捷运维峰会·广州站将于6月17日举办&lt;/strong&gt;&lt;span&gt;，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;精选数据库热门议题，共同探讨数据库走向技术融合及国产化下的挑战和突破，部分议题抢先剧透：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p draggable=&quot;true&quot;&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.37222222222222223&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ufWcjcomw8bIZLVZhXgDoRxrx4BFKmF6BGkbJzy2kvdoBt5rN7yCHCbEOolLPyamicuNCUHGCZN5exzqtmKXNibg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fc52b959f24c15259a2097db984ebee9</guid>
<title>Golang 常见设计模式之单例模式</title>
<link>https://toutiao.io/k/z2o8bzu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.11875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/OdIoEOgFgUGcibO4v5qxt8aOe6ArwX6qwM3icvwPccBDAjM1eoJTf9QbJ2WcUicIw5QkOiasIKgvNV56qWIXqTcBicg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;之前我们已经看过了 Golang 常见设计模式中的装饰和选项模式，今天要看的是 Golang 设计模式里最简单的单例模式。单例模式的作用是确保无论对象被实例化多少次，全局都只有一个实例存在。根据这一特性，我们可以将其应用到全局唯一性配置、数据库连接对象、文件访问对象等。Go 语言实现单例模式的方法有很多种，下面我们就一起来看一下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;饿汉式&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;饿汉式实现单例模式非常简单，直接看代码：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package singleton&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type singleton struct{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;var instance = &amp;amp;singleton{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func GetSingleton() *singleton {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    return instance&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;singleton 包在被导入时会自动初始化 instance 实例，使用时通过调用 singleton.GetSingleton() 函数即可获得 singleton 这个结构体的单例对象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种方式的单例对象是在包加载时立即被创建，所以这个方式叫作饿汉式。与之对应的另一种实现方式叫作懒汉式，懒汉式模式下实例会在第一次被使用时被创建。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要注意的是，尽管饿汉式实现单例模式的方式简单，但大多数情况下并不推荐。因为如果单例实例化时初始化内容过多，会造成程序加载用时较长。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;懒汉式&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;接下来我们再来看下如何通过懒汉式实现单例模式：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package singleton&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type singleton struct{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;var instance *singleton&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func GetSingleton() *singleton {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if instance == nil {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        instance = &amp;amp;singleton{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    return instance&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;相较于饿汉式的实现，懒汉式将实例化 singleton 结构体部分的代码移到了 GetSingleton() 函数内部。这样能够将对象实例化的步骤延迟到 GetSingleton() 第一次被调用时。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过通过 instance == nil 的判断来实现单例并不十分可靠，如果有多个 goroutine 同时调用 GetSingleton() 就无法保证并发安全。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;支持并发的单例&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如果你使用 Go 语言写过并发编程，应该很快能想到该如何解决懒汉式单例模式并发安全问题，比如像下面这样：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package singleton&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import &quot;sync&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type singleton struct{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;var instance *singleton&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;var mu sync.Mutex&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func GetSingleton() *singleton {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    mu.Lock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    defer mu.Unlock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if instance == nil {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        instance = &amp;amp;singleton{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    return instance&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;上面代码的修改是通过加锁机制，即在 GetSingleton() 函数最开始加了如下两行代码：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;mu.Lock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;defer mu.Unlock()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;加锁的机制可以有效保证这个实现单例模式的函数是并发安全的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过使用了锁机制也带来了一些问题，这让每次调用 GetSingleton() 时程序都会进行加锁、解锁的步骤，从而导致程序性能的下降。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;双重锁定&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;加锁会导致程序性能下降，但又不用锁又无法保证程序的并发安全。为了解决这个问题有人提出了双重锁定（Double-Check Locking）的方案：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package singleton&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import &quot;sync&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type singleton struct{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;var instance *singleton&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;var mu sync.Mutex&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func GetSingleton() *singleton {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if instance == nil {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mu.Lock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        defer mu.Unlock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        if instance == nil {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            instance = &amp;amp;singleton{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    return instance&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;通过上面的可以看到，所谓双重锁定实际上就是在程序加锁前又加了一层 instance == nil 判断，通过这种方式来兼顾性能和安全两个方面。不过这让代码看起来有些奇怪，外层已经判断了 instance == nil，但是加锁后又进行了第二次 instance == nil  判断。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实外层的 instance == nil 判断是为了提高程序的执行效率，免去原来每次调用 GetSingleton() 都上锁的操作，将加锁的粒度更加精细化。简单说就是如果 instance 已经存在，则无需进入 if 逻辑，程序直接返回 instance 即可。而内层的 instance == nil  判断则考虑了并发安全，考虑到万一在极端情况下，多个 goroutine 同时走到了加锁这一步，内层判断会在这里起到作用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;Gopher 惯用方案&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;虽然双重锁定机制兼顾和性能和并发安全，但显然代码有些丑陋，不符合广大 Gopher 的期待。好在 Go 语言在 sync 包中提供了 Once 机制能够帮助我们写出更加优雅的代码：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package singleton&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import &quot;sync&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type singleton struct{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;var instance *singleton&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;var once sync.Once&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func GetSingleton() *singleton {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    once.Do(func() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        instance = &amp;amp;singleton{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    })&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    return instance&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Once 是一个结构体，在执行 Do 方法的内部通过 atomic 操作和加锁机制来保证并发安全，且 once.Do 能够保证多个 goroutine 同时执行时 &amp;amp;singleton{} 只被创建一次。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实 Once 并不神秘，其内部实现跟上面使用的双重锁定机制非常类似，只不过把 instance == nil 换成了 atomic 操作，感兴趣的同学可以查看下其对应源码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;以上就是 Go 语言中实现单例模式的几种常用套路，经过对比可以得出结论，最推荐的方式是使用 once.Do 来实现，sync.Once 包帮我们隐藏了部分细节，却可以让代码可读性得到很大提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击↓↓查看 Golang 常见设计模式详解：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&amp;amp;mid=2653587805&amp;amp;idx=1&amp;amp;sn=f6ef4a4d432a8e041fc4db731f9ba1e5&amp;amp;chksm=bd1b1dd58a6c94c32cd8b1771e8a88364c4ffd7b522446c56a4b03cd7c9c70f9ab1099a372cc&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;‍《Golang 常见设计模式之装饰模式》‍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《Golang 常见设计模式之装饰模式》&lt;/span&gt;&lt;span/&gt;&lt;/a&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&amp;amp;mid=2653587299&amp;amp;idx=1&amp;amp;sn=84e36fdc80000f548a97f097f892f79e&amp;amp;chksm=bd1b13eb8a6c9afd3f838df28bbf3ab2c482747389e9afa2824b2ac94243acc523726b1e8785&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《Golang 常见设计模式之选项模式》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《Golang 常见设计模式之选项模式》&lt;/span&gt;&lt;span/&gt;&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;&lt;hr/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;快 来&lt;/span&gt;&lt;strong&gt;&lt;span&gt; 找 &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;又&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 小 拍&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h2&gt;&lt;h2&gt;&lt;hr/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;319&quot; data-backw=&quot;546&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;546&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;319&quot; data-fileid=&quot;506103129&quot; data-ratio=&quot;0.5833333333333334&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUFAQemPjhnJTKkl7TwPLibto5mn4m21ZrshVQSeibqIYTw6XqhicImzlLxeW0v3BE4ycJbHd84ic5Oiayg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;span&gt;推 荐 阅 读&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&amp;amp;mid=2653588146&amp;amp;idx=1&amp;amp;sn=5a194e17a5b5b5a7368a8b371dd0be1a&amp;amp;chksm=bd1b1e3a8a6c972cbd59e930c37c94bf51ea8464514c6484f6c244d382158b498e015dce648e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;273&quot; data-backw=&quot;546&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;546&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;273&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5007751937984496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUHmhFPaMrOpmxj4d4URh0AoJzsQwupWXFtmaU0NwbXvhGsqpqSyN3GyOWDNXnYgB5eXfHPkSJnJlA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;645&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&amp;amp;mid=2653588120&amp;amp;idx=1&amp;amp;sn=12b192d93118d81339dd4328fed9c554&amp;amp;chksm=bd1b1e108a6c9706ba903a5aefa87dd775b776c1aaf4a2173b4a8cd7f465256ef3551e85f37e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;273&quot; data-backw=&quot;546&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;546&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;273&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5007751937984496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUEo6xF6sojk2ZykJiap359VRAhiaXGuJwfeYN3wQ6T9onDluliaIXFZicVSoQMcicyQ7zuKL7lXPaDCic4A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;645&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODc5ODgyMw==&amp;amp;mid=2653587863&amp;amp;idx=1&amp;amp;sn=969372d21ec4a5a0928a3bed5fbf4462&amp;amp;chksm=bd1b1d1f8a6c9409f26ccb4b68ff03a1ee4c2371b8bc0215938154a7bd32a2716602092a083f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;273&quot; data-backw=&quot;546&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUElpXebXbjgibum7I6LiboCtK6KV8gcYQ1mFV2XdonnCrOhaQdtBNh71z1u0JNzcdrx5EQRg56zb0IA/0?wx_fmt=jpeg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;546&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;273&quot; data-fileid=&quot;506103128&quot; data-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUEUylg3O41wsJR8aiasuMebIJsicZ1HyIIL8XbjU22CGg8eV9ZciclQxtibdwcudh6PAicxj2D6ibG3T8mg/0?wx_fmt=jpeg&quot; data-ratio=&quot;0.5007751937984496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OdIoEOgFgUG2FudNIX0E8qYmDLIzicEIDhl1hFibB1nZLePo5lianibrhmJaGuDYlZshSAczicz8Ipjt9uoeNddNkZw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;645&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;设为星标&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;506103126&quot; data-ratio=&quot;0.9037037&quot; data-type=&quot;png&quot; data-w=&quot;135&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OdIoEOgFgUHbb6jzHdqCC83fulktKZtY2WUNN9vVlgibWSiaR7RDHYbVyTy8icCibHV04APOmEqXhdoJv7GHJDMgvg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;更新不错过&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/h2&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d87f13778a38fea21d7f7ecf790afbc2</guid>
<title>用42张图全面认识Web3；字节/华为/美团面经记录；张朝阳：初代大佬的价值归宿｜码农周刊VIP会员专属邮件周报 Vol.092</title>
<link>https://toutiao.io/k/z2l7od5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;我爱程序员&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;developerWorks&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;我们的产品：《码农周刊》 http://manong.io/ 、《开发者头条》 http://toutiao.io/&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1ed32c47beab83e7dfa96f53e3c35080</guid>
<title>前端周刊：2022-8 期</title>
<link>https://toutiao.io/k/clixoe4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;blockquote&gt;
&lt;p&gt;&quot;如果一段文字没有标签，想要改变里面某个字符的尺寸，在过去只能使用 ::first-letter 伪元素，且只能改变第一个字符的尺寸。&quot;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>