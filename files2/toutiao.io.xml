<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>6b99711f7fb94597e2daf1441fc286fb</guid>
<title>2020 年，我在编程时遇见的几个好物</title>
<link>https://toutiao.io/k/ezq0qnu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;img data-ratio=&quot;0.4255555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybwaubH1vmKJVqeribqQYVnvWZ8Rg04vE5OnWia0vGM1iahueGibVXkgqjsH5dSRN4NGgAgOa3W3qTY9wQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;年年都写年终总结，确实没什么新意，虽然今年也做了总结，但写完之后总觉得过于悲观，只是到了年底应该要有些什么表示，想着今年是该换个花样了，于是便有了这篇《2020 年，我在编程时遇到的几个好物》。&lt;/p&gt;&lt;p&gt;这篇文章介绍的，有框架，有工具，有软件，都是自己在编程时遇到的有用的，而且自己比较喜欢的，这里分享给大家。正所谓相遇即是缘，若是你有幸读到这篇文章并且觉得还不错，不妨点赞关注支持一波。&lt;/p&gt;&lt;h2&gt;Hutool&lt;/h2&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5623324396782842&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybwaubH1vmKJVqeribqQYVnvWYVQdO0ibdAYiaEoy6zTtVEw2feJfsNhlkIOqReJdYeebEnibhL4hYlDxA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1492&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;第一个要介绍的便是 Hutool，Hutool 是一个 Java 工具包，对文件、流、加密解密、转码、正则、线程、XML 等 JDK 方法进行封装，组成各种 Util 工具类。他的作用就是帮助我们简化代码，让程序员将更多的经历放在业务上而非一些无关紧要的工作上。&lt;/p&gt;&lt;p&gt;举个例子，近期我有一个很小的需求，一个大文件夹里有很多小文件夹，每个小文件夹里有一些我需要整理出来的 word 文档，如果通过界面点击的话，我可能需要点击 100 多个文件夹，所以很自然的就会想到用程序去实现这个需求，第一想法肯定是 shell 脚本或者 python 脚本，但其实借助 hutool 和 Java8 里的 lambda 表达式，同样可以很方便的实现这么一个小需求，如下所示：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Main&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;amp;&lt;span&gt;lt&lt;/span&gt;;File&amp;amp;&lt;span&gt;gt&lt;/span&gt;; files = FileUtil.loopFiles(&lt;span&gt;&quot;xxxPath&quot;&lt;/span&gt;, file -&amp;amp;&lt;span&gt;gt&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;FileUtil&lt;/span&gt;.extName(file).equalsIgnoreCase(&lt;span&gt;&quot;docx&quot;&lt;/span&gt;) || FileUtil.extName(file).equalsIgnoreCase(&lt;span&gt;&quot;doc&quot;&lt;/span&gt;)&lt;br/&gt;        );&lt;br/&gt;        &lt;span&gt;files&lt;/span&gt;&lt;span&gt;.forEach&lt;/span&gt;(&lt;span&gt;file&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&amp;amp;&lt;span&gt;gt&lt;/span&gt;; &lt;span&gt;FileUtil&lt;/span&gt;&lt;span&gt;.copyFile&lt;/span&gt;(&lt;span&gt;file&lt;/span&gt;&lt;span&gt;.getAbsolutePath&lt;/span&gt;(), &quot;&lt;span&gt;xxxxxPath&lt;/span&gt;&quot;, &lt;span&gt;StandardCopyOption&lt;/span&gt;&lt;span&gt;.REPLACE_EXISTING&lt;/span&gt;));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;使用&lt;code&gt;FileUtil.loopFiles&lt;/code&gt;就可以直接获取该路径下的所有文件，如要筛选，只需要在后面追加参数即可。这样的工具类还有很多，例如发邮件，直接使用 MailUtil.send 即可。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span&gt;MailUtil&lt;/span&gt;&lt;span&gt;.send&lt;/span&gt;(&quot;&lt;span&gt;yueyong1030&lt;/span&gt;@&lt;span&gt;outlook.com&quot;,&lt;/span&gt; &lt;span&gt;&quot;新年快乐&quot;&lt;/span&gt;, &lt;span&gt;&quot;赶紧关注「01二进制」，现在关注以后就是老粉了&quot;&lt;/span&gt;, false);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;安装方法也非常简单，Maven 安装&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;xml&quot;&gt;&lt;code&gt;&amp;amp;&lt;span&gt;lt&lt;/span&gt;;dependency&amp;amp;&lt;span&gt;gt&lt;/span&gt;;&lt;br/&gt;    &amp;amp;&lt;span&gt;lt&lt;/span&gt;;groupId&amp;amp;&lt;span&gt;gt&lt;/span&gt;;cn.hutool&amp;amp;&lt;span&gt;lt&lt;/span&gt;;&lt;span&gt;/groupId&amp;amp;gt;&lt;/span&gt;&lt;br/&gt;    &amp;amp;&lt;span&gt;lt&lt;/span&gt;;artifactId&amp;amp;&lt;span&gt;gt&lt;/span&gt;;hutool-all&amp;amp;&lt;span&gt;lt&lt;/span&gt;;&lt;span&gt;/artifactId&amp;amp;gt;&lt;/span&gt;&lt;br/&gt;    &amp;amp;&lt;span&gt;lt&lt;/span&gt;;version&amp;amp;&lt;span&gt;gt&lt;/span&gt;;&lt;span&gt;5.5&lt;/span&gt;.&lt;span&gt;6&lt;/span&gt;&amp;amp;&lt;span&gt;lt&lt;/span&gt;;&lt;span&gt;/version&amp;amp;gt;&lt;/span&gt;&lt;br/&gt;&amp;amp;&lt;span&gt;lt&lt;/span&gt;;&lt;span&gt;/dependency&amp;amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;如果你使用的是 Gradle，进行以下配置即可&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;groovy&quot;&gt;&lt;code&gt;&lt;span&gt;compile&lt;/span&gt; &lt;span&gt;&#x27;cn.hutool:hutool-all:5.5.6&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h2&gt;Flutter&lt;/h2&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5591666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybwaubH1vmKJVqeribqQYVnvWRVKqiaDrP9licE3upDZ9x733jpr9DKs1eHWGjic2SD1uAl3aA1Ivkafhw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;第二个要介绍的是一个跨平台应用开发框架——Flutter。说到 Flutter，还真是有些缘分。2018 年我开始写公众号，我的第一篇破 10w 阅读的便是发表在简书上的&lt;span&gt;《你好，Flutter》&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;。那一年，Flutter 横空出世，颇有一番要改变移动端开发的势头。因为自己本科时做过一段时间的移动端开发，在阅读其官方文档后便被其深深吸引了，期间也写过一些入门文章，只是不成体系罢了。如今虽然不做移动端开发了，但总还是在关注着 Flutter 社区的发展，今年因为要忙活毕业设计，于是便又将其重新拾起了。&lt;/p&gt;&lt;p&gt;官网说 Flutter 是 Google 开源的 UI 工具包，帮助开发者通过一套代码库高效构建多平台精美应用，支持移动、Web、桌面和嵌入式平台。简单而言就是，Flutter 是 Google 一个新的用于构建跨平台的手机 App 的 SDK。写一份代码，在 Android 和 iOS 平台上都可以运行，当然了，现在也可以运行在 web 端和桌面端，只是效果还不如移动端好。&lt;/p&gt;&lt;p&gt;虽然在 Flutter 之前，已经出现过一些跨平台方案了，比如 ReactNative、Weex 等，但仍然有很多人喜欢 Flutter，我也曾在知乎回答过&lt;span&gt;为何有人会喜欢 Flutter？- LYYYYY 的回答 - 知乎 &lt;sup&gt;[2]&lt;/sup&gt;&lt;/span&gt;。个人认为原因有以下几点：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;大厂背书，谷歌一直在推广&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;学习成本低，只要会 Java，就可以快速上手 Dart 语言&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;跨平台，这是最重要的一点，目前 Flutter 已经可以运行在 Android、iOS、MacOS、Windows、Linux 等平台上，编写一次到处运行对于一个想要快速做出成品的团队来说无疑是一个好的选择&lt;/span&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;组件丰富，Flutter 内置了许多非常好看的组件，pub.dev 上也有很多优秀的第三方组件，使用起来也很方便&lt;/span&gt;&lt;span&gt;&lt;span&gt;5.&lt;/span&gt;开发出的 App 性能足够强大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;总的来说，对于一个想要&lt;strong&gt;快速&lt;/strong&gt;做出&lt;strong&gt;跨平台 App&lt;/strong&gt;的&lt;strong&gt;人/小团队&lt;/strong&gt;来说（比如做毕业设计、初创公司等），Flutter 确实是一个很好的选择。&lt;/p&gt;&lt;h2&gt;Docker&lt;/h2&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybwaubH1vmKJVqeribqQYVnvWiaUfMysABNRGm1sbNiakZAO3tvKODvqsKWBKdmATVhEt9nq3bl4ymrbQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;660&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;第三个要说的是一个运维工具——Docker。说起 Docker 想必很多人都不陌生了，Docker 是近几年非常火的一个工具，虽然前几年就有所耳闻，但直到今年我才算是日常使用。&lt;/p&gt;&lt;p&gt;其实 Docker 的出现就是为了解决软件开发的一大难题——环境配置。每个用户的设备不一致，环境自然也是千差万别。如何保证你的代码在其他地方也可以运行？&lt;/p&gt;&lt;p&gt;用户必须保证两件事：&lt;strong&gt;操作系统的设置&lt;/strong&gt;以及&lt;strong&gt;各种库和组件的安装&lt;/strong&gt;。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。&lt;/p&gt;&lt;p&gt;那有没有一种办法，从根本上解决问题，让软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。&lt;/p&gt;&lt;p&gt;虚拟机就是一种解决方案，只是这种解决方案&lt;strong&gt;占用资源多、荣誉步骤繁杂且启动慢&lt;/strong&gt;，于是 Linux 发展出了另一种虚拟化技术：Linux 容器。&lt;strong&gt;Linux 容器不是一个完整的操作系统，而是对进程进行隔离。&lt;/strong&gt;或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。简单而言就是容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。&lt;/p&gt;&lt;p&gt;Docker 就属于&lt;strong&gt;Linux 容器的一种封装&lt;/strong&gt;，提供简单易用的容器使用接口&lt;strong&gt;。它是目前最流行的 Linux 容器解决方案。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;今年我使用 Docker 主要是为了&lt;strong&gt;提供一次性的环境&lt;/strong&gt;以及&lt;strong&gt;组建微服务架构&lt;/strong&gt;。我通过 docker-compose 整合项目中所需要的中间件，例如 MySQL、Redis、MQ 等。&lt;/p&gt;&lt;p&gt;我也曾在掘金上翻译过相关的文章，如&lt;span&gt;《【译】在几秒钟内为你的开发环境创建一个私有 PostgreSQL 数据库》&lt;sup&gt;[3]&lt;/sup&gt;&lt;/span&gt;以及&lt;span&gt;《【译】5 分钟内从单体架构迁移到微服务架构》&lt;sup&gt;[4]&lt;/sup&gt;&lt;/span&gt;等，有兴趣的小伙伴不妨点击阅读。&lt;/p&gt;&lt;h2&gt;Lambda&lt;/h2&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybwaubH1vmKJVqeribqQYVnvW968icbic06mtZ4he6OyxlzRcicwx9xtyibvOUDZWAn3FrJSyUchJfcVqDQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;第四个要介绍的既不是框架也不是工具，而是 Java8 新引入的一种特性——Lambda。说起 Lambda 表达式，就不得不说函数式编程。&lt;/p&gt;&lt;p&gt;和面向对象（OOP）一样，函数式编程也是一种&lt;strong&gt;思想&lt;/strong&gt;，一种&lt;strong&gt;理念&lt;/strong&gt;。如果说面向对象编程是对&lt;strong&gt;数据&lt;/strong&gt;的抽象，那么函数式编程就是对&lt;strong&gt;行为&lt;/strong&gt;的抽象。&lt;/p&gt;&lt;p&gt;而 Lambda 正是函数式编程这种思想的实际体现。Lambda 表达式，也可称为闭包，它允许把函数作为一个方法的参数（函数作为参数传递进方法中），可以使代码变的更加简洁紧凑。&lt;/p&gt;&lt;p&gt;说了这么多，太过空洞，举一个简单的例子。&lt;/p&gt;&lt;p&gt;下面的代码所做的事情是：为一个按钮增加一个监听事件，当点击这个按钮时，将会触发打印“button clicked”行为。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt;button.addActionListener(&lt;span&gt;new&lt;/span&gt; ActionListener() {&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;actionPerformed&lt;/span&gt;(&lt;span&gt;ActionEvent &lt;span&gt;event&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;            System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;button clicked&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;这段代码很好理解，但也侧面说明了一个问题，在 Java 支持函数式编程以前，我们如果需要传递一个行为常用的方式就是传递一个&lt;strong&gt;对象&lt;/strong&gt;，而匿名内部类正是为了方便将代码作为数据进行传递。&lt;/p&gt;&lt;p&gt;只是在 Java8 引入函数式编程后，我们可以将点击事件抽象出来，作为参数传递，示例代码如下：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt;button.addActionListener(&lt;span&gt;event&lt;/span&gt; -&amp;amp;gt; System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;button clicked&quot;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;这种方式，就被称为 Lambda 表达式。Lambda 表达式语法规则主体分为两个部分，中间用“-&amp;gt;”右箭头连接，左边代表参数，右边代表函数主体。&lt;/p&gt;&lt;p&gt;函数式编程出现已经很久了，但是我之前也只是简单的学习过，真正开始日常使用还是暑期在淘宝实习的时候，项目代码里有很多 Lambda 的身影（不排除师兄们炫技的可能），虽然一开始看起来有点烦人，不太好理解，但熟悉之后，对项目代码的精简也是有目共睹的。&lt;/p&gt;&lt;p&gt;关于 Lambda 的资料网上有很多，这里只是推荐，有兴趣的小伙伴可以搜索学习，相信了解之后你一定会对他爱不释手的。&lt;/p&gt;&lt;h2&gt;Proxyman&lt;/h2&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4315286624203822&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybwaubH1vmKJVqeribqQYVnvWN2libGULfFmHMqYYQOzUPNtAxuDCicdWEibhS4ImDVGIgPnseicGBGkfng/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1884&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;接下来要说的就都是一个软件了。第一个软件便是 Proxyman。无论是前端开发还是后端开发，尤其是爬虫工程师，抓包都是一个非常重要的技能，而一个好的抓包工具至关重要。Proxyman 是我今年无意中发现的一款抓包工具，只用了一次我就喜欢上他了。&lt;/p&gt;&lt;p&gt;选它的理由很简单，使用简单。相比 Charles，可以随意布局，可以多设备分别管理，一屏可以预览所需的关键信息。而且做移动端的抓包时，配置相较于 Charles 简单许多。最最重要的是，颜值足够高。正所谓颜值即正义，对于一个软件来说，同样如此，如果一个软件长得不好看，那也一定不是一个好软件。&lt;/p&gt;&lt;p&gt;不过这款软件只在 Mac 上有，这倒是一个遗憾。&lt;/p&gt;&lt;h2&gt;iTerm2&lt;/h2&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7119386637458927&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybwaubH1vmKJVqeribqQYVnvWNJPfvVHh1gsAl85Q3V3N7fnVYx7bia5IakWsYMtuzAZRbVMs31Azj6A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;913&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;和 Proxyman 一样，iTerm2 也是 Mac 独占的软件。可以说 iTerm2 是 MacOS 上首选的终端工具，毕竟作为一个 Coder，总是用图形化界面可不是什么好事情。虽然 MacOS 默认给我们提供了一个终端软件，但是 iTerm2 的比之强大太多，各种花里胡哨的配置网上已有很多，这里也不多说什么了。&lt;/p&gt;&lt;p&gt;这一年，我用它连接远程服务器，查看日志等信息，iTerm2 帮了我不少忙，如果你想尝试使用命令处理操作，iTerm2 会是一个很好的选择的。&lt;/p&gt;&lt;h2&gt;PPRows 或&lt;strong&gt;cloc&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3818359375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybwaubH1vmKJVqeribqQYVnvWdN5Cb7By0rr8cY2BiaSCFleqwfcvhC47C0mNyC0BVZMfuRr5XPhNg3g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;其实这两个东西的功能都是一样的，就是用来统计代码行数的，只不过一个是图形化界面，一个是终端命令，就看你更喜欢的是哪一个了，只不过 PPRows 只能在 Mac 上使用，这点可能会影响你们的选择。&lt;/p&gt;&lt;p&gt;我个人倾向使用 cloc，毕竟能用命令解决的事情为什么要用鼠标去完成呢？&lt;/p&gt;&lt;p&gt;不说了，这就去统计我的毕设有多少代码了。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6820809248554913&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybwaubH1vmKJVqeribqQYVnvWdwn89cXWbLA6wbpoPUtPsiboZaKkgWccCGuJVQDFW0dbFhwDCjDkhfA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;692&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h2&gt;uTools&lt;/h2&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7809110629067245&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybwaubH1vmKJVqeribqQYVnvWk7VrlPdOIRozZwlUCnhQJGDsnqZWjicnia4fJTISoAWTdiboG5rkfFSCQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1383&quot; title=&quot;null&quot;/&gt;只一张图，我想你一定立刻就能知道 uTools 是一个怎样的软件。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;uTools  是一个极简、插件化、跨平台的现代桌面软件。通过自由选配丰富的插件，打造你得心应手的工具集合。当你熟悉它后，能够为你节约大量时间，让你可以更加专注地改变世界。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;这是来自  uTools 官方网站的一段话，它其实是几个程序员为自己开发的一个工具，当然也适用于大部分的人。&lt;/p&gt;&lt;p&gt;阅读英文文档时，如果有些单词不太清楚，直接快捷键呼出翻译；突然要计算时，直接快捷键呼出计算器；想要查看颜色代码？想要 OCR？uTools 都可以实现。&lt;/p&gt;&lt;p&gt;相比较 Alfred，uTools 更加本土化，操作逻辑更加直观简单，最重要的是，对于非 macOS 用户来说，没有一款可以媲美 Alfred 的 Spotlight 应用，一直是一个遗憾。而 uTools 同时支持 MacOS、Linux 和 Windows。不管你换到了什么操作系统，都可以无缝体验到 uTools 给予你强大的功能支持。&lt;/p&gt;&lt;h2&gt;VSCode&lt;/h2&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.49083333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2GybwaubH1vmKJVqeribqQYVnvWWOUDjHiaKiaEDETfqXr38XLgykZtrKj4ib1jjXugibKuETFmvPAoPlI55g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;既然文章说的是在编程时遇见的好物，那一定离不开 IDE。我之所以没有介绍诸如 IDEA、WebStorm 这些主流 IDE，就是觉得太过普遍，吃饭的家伙没什么好说的。&lt;/p&gt;&lt;p&gt;但是 VSCode，今年确实给了我很大的惊喜。之前使用 VSCode，我更多是将其作为一个文本编辑器的。不过今年在任务加重的情况下，同时开了 IDEA、AndroidStudio 和 WebStorm 时，我的 16g 内存的 MacBook pro 明显感觉吃力很多，于是我便将目光转向了之前这个“文本编辑器”了。&lt;/p&gt;&lt;p&gt;他的优势很明显，插件丰富，语言支持完善，不管是前端的 Vue、React 还是 Flutter，都完美支持。配合着 LeetCode 插件，还可以直接在编辑器中做题提交。安装配置了 Java 的插件后，写 Java 代码的体验也接近 IDEA。不仅占用内存小，打开文件的速度还极快。最最关键的是，好看。想当初，众多开发者还在其与 sublime text 和 atom 中纠结，现如今，后两者不知还有多少分量了。&lt;/p&gt;&lt;p&gt;就像我之前说的，VSCode 更多是做“文本编辑器”用，这一年我用 Markdown 写博客、公众号，内容几乎都是 Typora 和 VSCode 搭配使用。不仅如此，最近我又用 VSCode 解锁了编写 Latex 的新姿势。写论文的体验又上升了。&lt;/p&gt;&lt;p&gt;不说了，这就用 VSCode 肝论文去。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;以上就是我在 2020 年编程时遇见的几个好物，写着写着都感觉自己成恰饭的了。2020 已到年尾，不知道你们对于新的一年又有什么新的计划呢？不妨拿个小本本记录下今年要做的事情哦，最后祝看到这里的读者们可以在牛年牛气冲天！&lt;/p&gt;&lt;h3&gt;References&lt;/h3&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; 《你好，Flutter》: &lt;em&gt;https://www.jianshu.com/p/8baa8ed2414d&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[2]&lt;/code&gt; 为何有人会喜欢 Flutter？- LYYYYY 的回答 - 知乎 : &lt;em&gt;https://www.zhihu.com/question/427198090/answer/1571423635&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[3]&lt;/code&gt; 《【译】在几秒钟内为你的开发环境创建一个私有 PostgreSQL 数据库》: &lt;em&gt;https://juejin.cn/post/6899674625325105159&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[4]&lt;/code&gt; 《【译】5 分钟内从单体架构迁移到微服务架构》: &lt;em&gt;https://juejin.cn/post/6900884077226917901&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>db46b097f5b8b588aaefe6ed0b484729</guid>
<title>ClickHouse 是如何批量写入的？</title>
<link>https://toutiao.io/k/eb2nnq6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;简介&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;批量写入又称为bulk write，对于单表插入多条数据的场景，可以减少插入请求数量，提高吞吐量和效率。clickhouse官方Golang驱动&lt;span&gt;clickhouse-go&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;支持该关键特性，但是文档的介绍不是很详细，只有一句：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Bulk write support : begin-&amp;gt;prepare-&amp;gt;(&lt;span&gt;in&lt;/span&gt; loop &lt;span&gt;exec&lt;/span&gt;)-&amp;gt;commit&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并没有详细介绍用法和原理，笔者在开发业务时使用的库是&lt;span&gt;sqlx&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;，sql也支持clickhouse-go驱动。参考了&lt;span&gt;官方样例代码&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;tx, err := connect.Begin()&lt;br/&gt;checkErr(err)&lt;br/&gt;stmt, err := tx.Prepare(&lt;span&gt;&quot;INSERT INTO example (country_code, os_id, browser_id, categories, action_day, action_time) VALUES (?, ?, ?, ?, ?, ?)&quot;&lt;/span&gt;)&lt;br/&gt;checkErr(err)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++ {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; _, err := stmt.Exec(&lt;br/&gt;  &lt;span&gt;&quot;RU&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;10&lt;/span&gt;+i,&lt;br/&gt;  &lt;span&gt;100&lt;/span&gt;+i,&lt;br/&gt;  []&lt;span&gt;int16&lt;/span&gt;{&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;},&lt;br/&gt;  time.Now(),&lt;br/&gt;  time.Now(),&lt;br/&gt; ); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  log.Fatal(err)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我写的bulk write类似上面的代码，但是提交给同事review时，他提出了疑问：&lt;strong&gt;stmt.Exec是每次执行都发送写请求到数据库吗&lt;/strong&gt;？这个问题其实我不敢肯定，官方文档也说得不明确。考虑到严谨性，让自己的PR更有说服力，自己去翻看了相关源代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里需要指出，如果利用编辑器里的代码跳转功能会跳到&lt;code&gt;database/sql&lt;/code&gt;库中的&lt;code&gt;Exec&lt;/code&gt;函数实现，实际上我们要看的代码是clickhouse-go中的实现，至于编辑器跳转到database/sql中的原因，书写此文时笔者也没弄清楚，&lt;strong&gt;先挖个坑吧&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;核心实现&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;stmt.Exec的&lt;span&gt;核心代码如下&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(stmt *stmt)&lt;/span&gt; &lt;span&gt;execContext&lt;/span&gt;&lt;span&gt;(ctx context.Context, args []driver.Value)&lt;/span&gt; &lt;span&gt;(driver.Result, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; stmt.isInsert {&lt;br/&gt;  stmt.counter++&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err := stmt.ch.block.AppendRow(args); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (stmt.counter % stmt.ch.blockSize) == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   stmt.ch.logf(&lt;span&gt;&quot;[exec] flush block&quot;&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err := stmt.ch.writeBlock(stmt.ch.block); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; err := stmt.ch.encoder.Flush(); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; emptyResult, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err := stmt.ch.sendQuery(stmt.bind(convertOldArgs(args))); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err := stmt.ch.process(); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; emptyResult, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码不多，非常清晰，当执行Exec时，&lt;code&gt;stmt.ch.block.AppendRow(args)&lt;/code&gt;会先把sql参数附加到本地缓存block中，然后&lt;code&gt;(stmt.counter % stmt.ch.blockSize)&lt;/code&gt;判断本地缓存大小是否到达阈值，到达则执行&lt;code&gt;Flush()&lt;/code&gt;，将数据写入远端。综上，clickhouse-go中的核心实现逻辑是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;底层维护一个缓存block，同时设置block_size控制缓存大小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行stmt.Exec时，不会直接写入远程ClickHouse中，而是将插入参数Append到block中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每次Append后，判断block的size和block_size的关系，如果正好整除，则刷新block(即写入clickhouse)&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此block_size这个参数很重要，它表示本地缓存的上限，如果很大的话，程序会占用一些内存。笔者起初设置为&lt;code&gt;100000&lt;/code&gt;，在调试日志中看不到&lt;code&gt;stmt.ch.logf(&quot;[exec] flush block&quot;)&lt;/code&gt;打印的log，设置小后就看到下面的输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;[clickhouse][connect=1][begin] tx=false, data=false&lt;br/&gt;[clickhouse][connect=1][prepare]&lt;br/&gt;[clickhouse][connect=1][read meta] &amp;lt;- data: packet=1, columns=6, rows=0&lt;br/&gt;[clickhouse][connect=1][exec] flush block&lt;br/&gt;[clickhouse][connect=1][exec] flush block&lt;br/&gt;....&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多数据库驱动都支持bulk write特性，clickhouse-go这个驱动也不例外，但是它的文档写得不是很详细，只是在文档中指明要放在begin/commit中做。再加上clickhouse不支持事务，begin/commit这种写法会让人困惑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文通过分析clickhouse-go的源代码，了解bulk write的执行过程，帮助大家梳理其具体实现。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;clickhouse-go: &lt;em&gt;https://github.com/ClickHouse/clickhouse-go&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;sqlx: &lt;em&gt;https://github.com/jmoiron/sqlx&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;官方样例代码: &lt;em&gt;https://github.com/ClickHouse/clickhouse-go/blob/master/examples/sqlx.go#L35-L51&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;核心代码如下: &lt;em&gt;https://github.com/clickhouse/clickhouse-go/blob/master/stmt.go#L44-L68&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;INSERT INTO Statement: &lt;em&gt;https://clickhouse.tech/docs/en/sql-reference/statements/insert-into/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;go-clickhouse-batchinsert: &lt;em&gt;https://github.com/MaruHyl/go-clickhouse-batchinsert/blob/master/batch.go#L349-L354&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>35e054286a3a914958e08a5033e0a504</guid>
<title>靠写作杀出一条 “血” 路：我的 2020 年终总结</title>
<link>https://toutiao.io/k/793f4p0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>64e6834eb5bcfd53273390ab4e56fe68</guid>
<title>MySQL 并发控制和事务（复习笔记）</title>
<link>https://toutiao.io/k/6aqccls</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-body&quot; itemprop=&quot;articleBody&quot;&gt;

      
      

      
        &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;/&gt;引言&lt;/h2&gt;&lt;p&gt;原文链接：&lt;a href=&quot;https://yunsonbai.top/2020/09/07/mysql-bfsw/&quot;&gt;https://yunsonbai.top/2020/09/07/mysql-bfsw/&lt;/a&gt;&lt;br/&gt;整理了一下之前学习MySQL的知识点–并发控制和事务，和大家分享。&lt;/p&gt;
&lt;a id=&quot;more&quot;/&gt;
&lt;h2 id=&quot;并发控制&quot;&gt;&lt;a href=&quot;#并发控制&quot; class=&quot;headerlink&quot; title=&quot;并发控制&quot;/&gt;并发控制&lt;/h2&gt;&lt;p&gt;无论什么时候，只要有多个线程(或进程)同一数据修改数据，就会产生并发控制问题&lt;/p&gt;
&lt;h3 id=&quot;读写锁&quot;&gt;&lt;a href=&quot;#读写锁&quot; class=&quot;headerlink&quot; title=&quot;读写锁&quot;/&gt;读写锁&lt;/h3&gt;&lt;p&gt;共享锁和排他锁(或者是读锁和写锁)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读锁: 共享的，多用户可以同时读取同一个资源，相互不干扰&lt;/li&gt;
&lt;li&gt;写锁: 排他，会阻塞其他的读锁或者写锁，只能一个用户写入&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;锁粒度&quot;&gt;&lt;a href=&quot;#锁粒度&quot; class=&quot;headerlink&quot; title=&quot;锁粒度&quot;/&gt;锁粒度&lt;/h3&gt;&lt;p&gt;尽量只锁住需要修改的内容，而不是所有资源。任何时候，在给定的资源上，锁的数量越少，冲突越少，那么系统的并发程度就越高。&lt;/p&gt;
&lt;p&gt;锁也耗资源，锁的操作包括，检查所是否已经解除，获得锁，释放锁，这些都会增加系统开销，进而影响系统性能。锁策略，就是在锁的开销和安全性之间寻求平衡。一般会采用行级锁，MySQL提供了多个选择，每种存储引擎都能实现自己的锁&lt;/p&gt;
&lt;h4 id=&quot;表锁&quot;&gt;&lt;a href=&quot;#表锁&quot; class=&quot;headerlink&quot; title=&quot;表锁&quot;/&gt;表锁&lt;/h4&gt;&lt;p&gt;MySQL中最基本的锁策略，开销最小，粗暴简单。锁住整张表，需要拿到该锁才能进行增改删，而且该锁还会阻塞其他用户的读。只有没有写锁时，多用户才能同时读取。&lt;/p&gt;
&lt;p&gt;另外MySQL会在使用alert table之类的语句中使用表锁，忽略存储引擎自己的锁&lt;/p&gt;
&lt;h4 id=&quot;行级锁&quot;&gt;&lt;a href=&quot;#行级锁&quot; class=&quot;headerlink&quot; title=&quot;行级锁&quot;/&gt;行级锁&lt;/h4&gt;&lt;p&gt;行级锁能最大程度的支持并发处理，但是也带来了最大的锁开销。在InnoDB中实现了行级锁。&lt;/p&gt;
&lt;h2 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;/&gt;事务&lt;/h2&gt;&lt;p&gt;在MySQL中，MySQL服务器不管理事务，由下层的存储引擎实现。因此混合使用存储引擎是不可靠的。&lt;br/&gt;MySQL默认采用自动提交，如果不是显式的开始一个事务的话，&lt;u&gt;&lt;strong&gt;则每个查询都被当做一个事务执行提交操作。&lt;/strong&gt;&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;事务就是一组原子行的sql查询，独立的工作单元。&lt;br/&gt;一个事务中，要么所有的语句都成功，如果有n条失败，那全部失败，都不执行。&lt;/p&gt;
&lt;p&gt;事务特性包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性：单元操作，都成或所有都不成(有一个失败就全失败)&lt;/li&gt;
&lt;li&gt;隔离性：事务之间相互隔离。&lt;/li&gt;
&lt;li&gt;持久性：改完得保存起来，不能丢。&lt;/li&gt;
&lt;li&gt;一致性：得保证最终状态一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;隔离级别&quot;&gt;&lt;a href=&quot;#隔离级别&quot; class=&quot;headerlink&quot; title=&quot;隔离级别&quot;/&gt;隔离级别&lt;/h3&gt;&lt;h4 id=&quot;未提交读&quot;&gt;&lt;a href=&quot;#未提交读&quot; class=&quot;headerlink&quot; title=&quot;未提交读&quot;/&gt;未提交读&lt;/h4&gt;&lt;p&gt;事务中的修改，即使没有提交，对其他事务可见。其他事务就产生了脏读，这样就会产生很多问题。&lt;/p&gt;
&lt;h4 id=&quot;提交读&quot;&gt;&lt;a href=&quot;#提交读&quot; class=&quot;headerlink&quot; title=&quot;提交读&quot;/&gt;提交读&lt;/h4&gt;&lt;p&gt;大多数数据库默认的隔离级别。一个事务开始时，只能看见已提交的事务所做的修改。也就是说一个事务从开始到未提交之前，其他事务都是 不可见的。也可以叫不可重复读，因为两次同样的查询可能得到不一样的结果。&lt;/p&gt;
&lt;h4 id=&quot;可重复读&quot;&gt;&lt;a href=&quot;#可重复读&quot; class=&quot;headerlink&quot; title=&quot;可重复读&quot;/&gt;可重复读&lt;/h4&gt;&lt;p&gt;保证了在同事务中多次读取同样的记录结果是一样的。但理论上还是会有幻读的情况，当某个事务读取某个范围内的记录时，另一个事务又在该范围内插入了新的记录，当前的事务再次读取该范围的数据时，会产生幻行。&lt;br/&gt;可重复读是MySQL的默认事务隔离级别，后边的过版本控制协助MySQL完成可重复读。&lt;/p&gt;
&lt;h4 id=&quot;可串行化&quot;&gt;&lt;a href=&quot;#可串行化&quot; class=&quot;headerlink&quot; title=&quot;可串行化&quot;/&gt;可串行化&lt;/h4&gt;&lt;p&gt;强制保证事务串行执行，避免了前面说的幻读问题。但会导致大量的超时和锁竞争，这种隔离级别在实际中很少用到。&lt;/p&gt;
&lt;h3 id=&quot;死锁&quot;&gt;&lt;a href=&quot;#死锁&quot; class=&quot;headerlink&quot; title=&quot;死锁&quot;/&gt;死锁&lt;/h3&gt;&lt;p&gt;两个及以上事务相互占用对方的资源，导致死锁。解开的方式是只能一个事务成功，其他事务全部回滚。&lt;/p&gt;
&lt;p&gt;事务A: 1、更新a    2、更新b&lt;br/&gt;事务B: 1、更新b    2、更新a&lt;br/&gt;恰好两个事务都执行了1，都要到了执行2，那相互之间就产生了死锁。&lt;/p&gt;
&lt;h3 id=&quot;多版本并发控制&quot;&gt;&lt;a href=&quot;#多版本并发控制&quot; class=&quot;headerlink&quot; title=&quot;多版本并发控制&quot;/&gt;多版本并发控制&lt;/h3&gt;&lt;p&gt;采用多版本来控制并发，进而实现可重复读。&lt;br/&gt;通过保存数据在某个时间点的快照来实现，每开始一个新的事物，系统版本号都会自动递增。&lt;/p&gt;
&lt;p&gt;在InnoDB中：&lt;/p&gt;


      
    &lt;/div&gt;

    
      


    

    
    
    

    
      &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8f0334f84f0ca6245504692d9496fa8d</guid>
<title>漫画：如何辨别二逼互联网公司！？</title>
<link>https://toutiao.io/k/863bgg9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>