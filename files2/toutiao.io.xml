<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>12e25819a9f9a8900a28feee83ff66ca</guid>
<title>流量复制方案对比：TCPCopy vs Goreplay</title>
<link>https://toutiao.io/k/cpf8p4q</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;「流量复制」常常应用在准生产环境的测试中，将线上的流量复制到一个准生产环境服务中，测试新功能和服务的承压能力。流量复制可以完全模拟线上的流量，对复杂的业务场景进行真实的服务测试，又不会对生产服务产生任何副作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于复杂的流量复制应用场景和需求，完全可以立项开发一套完整的复制架构，可参考字节团队自研的 &lt;span&gt;ByteCopy&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt; 项目。而对于一些简单的需求，开源的工具基本可以搞定。开源的流量复制工具有很多，常用的有 goreplay、tcpreplay、tcpcopy 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要来探讨下 tcpcopy 和 goreplay 的方案实现，废话不多说开整。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.57&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sM0hH9BhiaDcSWIdf6OZ7OWfWvYuQcJLx8CvnL8kFib9awH0CHQiaJSLt4FmAVnbCb6icYL6js1iatjyDLdCia3hu9qA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot;/&gt;&lt;figcaption&gt;目录&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;tcpcopy 方案实现&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;tcpcopy 简介&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;tcpcopy 由网易技术部&lt;span&gt;王斌&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;等开发，并于 2011 年 9 月开源的。tcpcopy 最新架构如下（来自作者王斌博客：https://blog.csdn.net/wangbin579/article/details/8949315）：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9359165424739195&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sM0hH9BhiaDcSWIdf6OZ7OWfWvYuQcJLxhf6Faic1pY8lx4YDbtxv0m21yCYmotlDHNs3IuwYcSwicWB2AxFNAPMg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;671&quot;/&gt;&lt;figcaption&gt;架构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;tcpcopy 主要有两个组件构成 tcpcopy client 和 intercept 。client 端负责复制流量和转发，intercept 负责对回应流量的拦截和 tcpcopy 的链接处理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;tcpcopy 搭建&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例环境如下，下面来阐述下整个架构的搭建过程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;192.168.33.11 生产服务器，部署 tcpcopy client&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;192.168.33.12 辅助服务器，部署 intercept&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;192.168.33.13 测试服务器&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;各组件可直接从 github 下载源码包，编译安装：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 起压机部署 tcpcopy client 192.168.33.11&lt;/span&gt;&lt;br/&gt;wget https://github.com/session-replay-tools/tcpcopy/archive/1.0.0.tar.gz&lt;br/&gt;tar xvf 1.0.0.tar.gz&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; tcpcopy-1.0.0&lt;br/&gt;./configure --prefix=/opt/tcpcopy&lt;br/&gt;make&lt;br/&gt;make install&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 辅助机部署 intercept 192.168.33.12 , 截获包需要依赖 libpcap 抓包函数库&lt;/span&gt;&lt;br/&gt;yum -y install libpcap-devel&lt;br/&gt;&lt;span&gt;# ubuntu&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# apt install -y libpcap-dev&lt;/span&gt;&lt;br/&gt;https://github.com/session-replay-tools/intercept/archive/1.0.0.tar.gz&lt;br/&gt;tar xvf 1.0.0.tar.gz&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; intercept-1.0.0&lt;br/&gt;./configure --prefix=/opt/tcpcopy/&lt;br/&gt;make&lt;br/&gt;make install&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装完之后，先启动 intercept，运行如下命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/opt/tcpcopy/sbin/intercept -i enp0s8 -F &lt;span&gt;&#x27;tcp and src port 8000&#x27;&lt;/span&gt; -d&lt;br/&gt;&lt;span&gt;# -i，指定网卡 enp0s8&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# -F，过滤，语法和pcap抓包工具一直，如tcpdump&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# -d，以domain的形式启动。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 其他参数可 -h 查看。&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动 intercept 之后，再启动 tcpcopy client 。tcpcopy 启动依赖 intercept ，启动时确保 intercept 启动成功。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;/opt/tcpcopy/sbin/tcpcopy -x 8000-192.168.33.13:8000 -s 192.168.33.12 -c 192.168.1.x -n 2 -d&lt;br/&gt;&lt;span&gt;# -x，复制本地8000端口的流量，转发到192.168.33.13机器的8000端口&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# -s，辅助服务器intercept 地址&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# -c，修改转发包的原地址为该地址段的地址，这里也可以是明确的ip。这个ip端用来伪装数据包，方便intercept做路由劫持。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# -n，流量倍数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# -d，以domain的形式运行&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在测试服务器添加拦截路由，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 测试机 192.168.33.13&lt;/span&gt;&lt;br/&gt;route add -net 192.168.1.0 netmask 255.255.255.0 gw 192.168.33.12&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该路由相当于把到 192.168.1.0 网段的包都走网关 192.168.33.12，对测试服务器的回包做伪地址拦截。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这便是 tcpcopy 的整个架构部署了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;包流向分析&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们抓包看看这个过程中包是如何流动的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我在 tcpcopy client 机器 192.168.33.11 和测试机器 192.168.33.13 使用 &lt;code&gt;python -m SimpleHTTPServer&lt;/code&gt; 分别起了一个 8000 端口的服务用来测试，从我本机 192.168.33.1 发送请求，在三台机器上抓包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;tcpcopy client 机器 192.168.33.11 包信息如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3251231527093596&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sM0hH9BhiaDcSWIdf6OZ7OWfWvYuQcJLxzTB8hE02CLOhqYsJCG2bToEArPXUuFcn8lK9MwDrD2ibwf9WiaPfMicicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1827&quot;/&gt;&lt;figcaption&gt;tcpcopy&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;红色标注块为我本机（192.168.33.1）和 tcpcopy client 机器（192.168.33.11）的正常请求交换，从三次握手，到 http 请求，到最后的断链。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;蓝色标注块则为 tcpcopy 复制的流量，可以看到为了让 intercepter 拦截回包流量，tcpcopy 已将包源 ip 地址替换为我们指定的伪网段（192.168.1.0）的地址，这样在回包时，就会根据测试服务器上的路由将回包指向辅助服务器 intercept，避免对生产流量造成影响。这也是为什么复制流量三次握手和 http 都没有回包的原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看测试服务器 192.168.33.13 的包：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1618685497012493&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sM0hH9BhiaDcSWIdf6OZ7OWfWvYuQcJLx9wt7w3pZWKVZjeFuqbr4gQLCpCcWRn6uKcHSmLUYHPI3QM33dlFEZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1841&quot;/&gt;&lt;figcaption&gt;test server&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试服务器的包和正常流量包一样，三次握手到 http 请求，最后断连。这里和测试服务器 192.168.33.13 交互的源地址 ip 已经被 tcpcopy 替换为伪 ip 192.168.1.1 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看 intercept 192.168.33.12 的包：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23268698060941828&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sM0hH9BhiaDcSWIdf6OZ7OWfWvYuQcJLxgTGadLOqQHMs6cSpdcB7FoVCOhdkbYyytKmfMr5KCIGQEGO0A2eiapg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1805&quot;/&gt;&lt;figcaption&gt;image&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到辅助服务器拦截下来的请求，标注块 1 为复制流量三次握手时的回包，标注块 2 为 http 请求的回包，这便是 intercept 的拦截功能。可以看到在标注块 1、2 之后，辅助服务器（192.168.33.12）和 tcpcopy 服务器（192.168.33.11）进行了数据交换，这部分便是 intercept 的 tcp 处理功能，它把有用的信息返回给 tcpcopy 以便能使 tcpcopy 和测试机的 tcp 链接完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据上边抓包，我们得到了和架构图一样的包流动过程，总结如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;生产流量正常请求，服务正常回应。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tcpcopy 服务在生产机器上复制流量，并修改流量包的源 ip 地址为我们指定的伪网络段(-c 参数指定)，之后将流量转发到测试服务器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;测试服务器，接受到流量，但包的源地址为伪网络段的地址，回包时根据提前配置好的伪路由，将回包导流到辅助服务器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;辅助服务器接收测试服务器的回包，但是并不转发。而是解包，只返回部分必要的信息给 tcpcopy，以便完成 tcpcopy 和测试服务器之间的 tcp 交互。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据官方文档，我们还需要注意几个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;辅助服务器不做包的转发，需要关闭内核参数 &lt;code&gt;ip_forward&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在做测试时，注意上行流量的过滤和测试数据源的隔离，防止对生产数据造成多次操作的影响。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;上边为在线实时的复制模式，tcpcopy 还支持离线方式，具体可查阅&lt;span&gt;文档&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;辅助机需要和测试机在一个网段，以便辅助机作为伪网段的网关使用。这里可以加一次代理，解除这个限制。如使用 nginx 作为测试中转机，将伪路由添加到 nginx 服务器上，测试机只需要向 nginx 注册即可，无需做其他配置。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;goreplay 方案实现&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;goreplay 简介&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Goreplay 是另一个比较常用的流量复制开源工具。与 tcpcopy 相比它的架构更简单，只有一个 gor 组件，如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5818363273453094&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sM0hH9BhiaDcSWIdf6OZ7OWfWvYuQcJLx87DlSNEEbqgdMv15OiaQRKZZxPTNunvEfx8o1d9S6PFsTNnMy6Kbusg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1002&quot;/&gt;&lt;figcaption&gt;image&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需要在生产服务器上启动一个 gor 进程，它负责所有的工作包括监听、过滤和转发。它的设计遵循 Unix 设计哲学：&lt;em&gt;一切都是由管道组成的，各种输入将数据复用为输出&lt;/em&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输入输出通常被成为插件，常见的有下面几种。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可用输入：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;--input-raw 用于捕获 HTTP 流量，您应该指定 IP 地址或接口和应用程序端口。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--input-file 接受流量输出的文件（--output-file），用来离线流量重放。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--input-tcp 如果您决定将来自多个转发器 Gor 实例的流量转发给它，则由 Gor 聚合实例使用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可用输出：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;--output-http 重放 HTTP 流量到给定的端点，接受基础 URL。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--output-file 记录传入的流量到文件。更多关于保存和从文件重播&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--output-tcp 将传入数据转发给另一个 Gor 实例，并与其一起使用--input-tcp。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--output-stdout 用于调试，输出所有数据到 stdout。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以对数据进行限速、过滤、重新，还可以重用中间件实现一些自定义逻辑处理，如私有数据的过滤、认证等个性需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他常用参数：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;--output-http &quot;http://staging.com|10&quot; 输出流量的 10%&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--http-allow-method 根据请求方式过滤。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--http-allow-url url 白名单，其他请求将会被丢弃。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--http-disallow-url 遇上一个 url 相反，黑名单，其他的请求会被捕获到。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文不对中间件做过多描述，仅讨论常用功能，对中间件有需求的可参考&lt;span&gt;中间件文档&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;goreplay 搭建&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Goreplay 是使用 golang 开发的，我们可以直接使用编译好的对应各系统的二进制文件，也可以自己编译，我们这里直接使用二进制文件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;wget https://github.com/buger/goreplay/releases/download/v1.3.0_RC1/gor_1.3_RC1_x64.tar.gz&lt;br/&gt;tar zxvf gor_1.3_RC1_x64.tar.gz&lt;br/&gt;&lt;span&gt;# 解压出二进制文件 gor&lt;/span&gt;&lt;br/&gt;gor&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，直接启动 gor 即可复制流量和转发。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;sudo ./gor --input-raw :8000 --output-http=&lt;span&gt;&quot;http://192.168.33.13:8001&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;复制本地 8000 端口的流量到 http 远端服务&lt;code&gt;http://192.168.33.13:8001&lt;/code&gt;。(复制同端口的流量时，流量会重复。这是 gor 的一个 bug，截止目前 1.3 版本仍可复现，可见&lt;span&gt;issue292&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;goreplay 的流量转发，并不是直接 tcp 包的转发，而是重新组织 http 协议级别的请求，发送到测试服务器。所以它是新的 gor 线程和测试服务器的交互，和监听线程无关，所以无需对流量进行拦截。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;包流向分析&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来看下 gor 复制的流量包的流向过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4105720492396814&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sM0hH9BhiaDcSWIdf6OZ7OWfWvYuQcJLxRibWGGxK3ibHs1cy68hGAgv6sKmyft3iaMEibHO3eqwCYRADHCV7utFcgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2762&quot;/&gt;&lt;figcaption&gt;gor&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;红色标注块为正常流量，蓝色标注块为复制的流量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到此处，你可能会有疑问，为什么 gor 不用拦截流量？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家仔细看 tcpcopy 和 gor 复制流量的端口，在生产机和测试机建立连接时，tcpcopy 虽然修改了 tcp 包的源 ip，但端口还是用的请求客户端的端口，是 tcp 数据链路层级别的流量复制。而 gor 这里严格来说并不是复制，而是重新构建了 http 请求。使用新端口来和测试机建连，相对的测试机在回包时，即使包是回到了生产机，但由于是和客户端不同的端口，也不会对生产流量造成影响。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;对比总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到此，我们对流量复制有了些基本的概念和应用了，也对 tcpcopy 和 goreplay 两款开源工具有了一定的认知。两款开源工具各有优缺点，我们来一块总结下。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;tcpcopy 部署架构相对复杂，goreplay 相对简单只需启动一个进程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tcpcopy 支持的协议比较丰富，goreplay 根据架构特点仅支持 http。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tcpcopy 和 goreplay 都支持离线和在线录制回放。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;goreplay 有个中间件模块，可自定义部分过滤逻辑。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单 http 复制 goreplay 完全可以胜任，稍复杂点或应用场景更复杂，那么推荐 tcpcopy。更复杂，要求更高的流量复制，那只能我们自己定制了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，本篇到这结束了，欢迎留言讨论，你觉着最佳流量复制方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是DeanWu，一个努力成为真正SRE的人。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;关注公众号「码农吴先生」, 可第一时间获取最新文章。回复关键字「go」「python」获取我收集的学习资料，也可回复关键字「小二」，加我wx拉你进技术交流群，聊技术聊人生~&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3287037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sM0hH9BhiaDcSWIdf6OZ7OWfWvYuQcJLxC0wYGQ9FOT7AlslkQTMzHKEYKeVjLHMW3rzldm0pRsiayvt4gPgvSmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2592&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;ByteCopy: &lt;em&gt;https://juejin.cn/post/6857688805835866126&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;王斌: &lt;em&gt;https://github.com/wangbin579&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;文档: &lt;em&gt;https://github.com/session-replay-tools/tcpcopy&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;中间件文档: &lt;em&gt;https://github.com/buger/goreplay/tree/master/middleware&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;issue292: &lt;em&gt;https://github.com/buger/goreplay/issues/292&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c90e18eece329cadc8e734178b931ae4</guid>
<title>Flink 在又拍云日志批处理中的实践</title>
<link>https://toutiao.io/k/upxcdey</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;大家好，我是来自又拍云的张召，今天主要分享又拍云多数据源日志处理选型 Flink 的考量，以及 Flink 落地过程中遇到的问题和解决方案。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;为什么用 Flink 做批处理&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在选用 Flink 前，我们对日志批处理的整个业务需求分为三步：数据源采集、日志处理、结果的保存。我们的日志量在 100G/h，单机服务处理速度慢、扩容不方便，一些相似的需求都是以编码形式完成的。另外，数据处理流程复杂，需要在多个服务间流转，迫切需要一个方案来解决问题。&lt;/p&gt;&lt;p&gt;前期我们调研了数据库，发现数据库里没有多维度的反复总结和挖掘的功能，所以我们放弃了选用数据库的方案，选用 MapReduce 里的 hadoop 这条组件。实际生产中发现它经常在写入的时候出现一些错误，导致无法做一些聚合的操作。接着我们选择了 Spark，新的问题又出现了：提交任务时，Restful API 接口的支持不全面；web 控制台中虚拟 IP 无法访问内部。&lt;/p&gt;&lt;p&gt;基于以上原因，我们需要一个更好的解决方案。通过比较之后，我们发现了 Flink。Flink 规避了前面所有的问题，后面还提供一套完整的 Restful API。不仅能够渲染出这个页面，还可以通过 Submit NewJob 直接提交任务。同时，我们对老服务升级的过程中，逐渐明白了我们日志数据的特点，以及当前我们需要挖掘日志数据的哪些方面。&lt;b&gt;在盘点了手头上可调用的资源后，我们希望部署的服务整个系统是可观测、可维护的，所以基于以上各种原因，最终我们放弃 Spark 方案，选择了 Flink 。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Flink 基础知识&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;Flink 组件栈&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如下图所示，这是一个分布式系统，整体也比较简单。最左边的 Flink Client 支持客户端现在的提交方式，后面会谈到它支持提交 Restful API 接口以及通过命令行等 5 种手段向这个 Job Manager 提交任务。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-df43a5857e0f485359ddbff80cf4e9d6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;711&quot; data-rawheight=&quot;378&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-df43a5857e0f485359ddbff80cf4e9d6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;711&quot; data-rawheight=&quot;378&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-df43a5857e0f485359ddbff80cf4e9d6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-df43a5857e0f485359ddbff80cf4e9d6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Job Manager 是分布式系统里的 master 节点，master 节点拿到数据之后会对架包进行分析，而后把相关其他信息给传送到对应的 TaskManager 节点。TaskManager 节点拿到信息后才真正执行Job，Job Manager 最主要的作用就是解析这个图以及维持整个集群，比如心跳、资源调度、HA 高可用、文件存储等，这是 Flink 提交任务 runtime 的过程。&lt;/p&gt;&lt;p&gt;接着看 Flink 静态的整体设计，底层是部署部分，稍后展开讲。中间的核心部分是 Runtime，分别封装了两个不同的 API：DataStream 是流处理，是现在 Flink 用的最多的场景；DataSet 是我们用到的批处理方式。虽然现在 Flink 号称支持流批一体处理，但是它目前版本两个接口是分开的，今年 12 月发的 1.12 版本已经不鼓励用 DataSet 相关的 API，这部分功能合到了 DataStream 里。但由于我们部署的版本还在 1.1，没有升级，所以我们还没有把这些 Job 迁到 DataStream 上去。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-4dce7c28e166e3004b769016926d090f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;755&quot; data-rawheight=&quot;454&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-4dce7c28e166e3004b769016926d090f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;755&quot; data-rawheight=&quot;454&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-4dce7c28e166e3004b769016926d090f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-4dce7c28e166e3004b769016926d090f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;接下来我们探索最上层的 tabl circle，但使用的最终效果并不好，因为无论是文档里，还是代码里写的支持限度是比较有限的。比如去执行 circle，但 circle 想把最终结果输出到 PG 里面的时候，它就出现了一个 bug，它 PG 的数据库最终拼出来的地址是错的，它的 host 和 pot 少了一个反斜线。这个 bug 非常简单，但是现在都没有修复。所以我认为最上层这部分可能测试的还不完善，也不是很稳定。所以我们最终代码的实现和业务集中编写也是放在调用的 DataSet API 这部分来做的。&lt;/p&gt;&lt;p&gt;另外我们还做了些小的工作，我们基于又拍云存储系统，扩展了它的相关功能，能够支持 Flink 的处理结果直接输出到云存储上，对整体代码起到简化作用。&lt;/p&gt;&lt;p&gt;&lt;b&gt;JobManager 和TaskManager&lt;/b&gt;&lt;/p&gt;&lt;p&gt;JobManager 的作用主要体现在里面的组件。比如 DataflowGraph 可以把 Flink 客户端提交的架包分析成一个可以执行的 graph，分发到下面的 TaskManager 节点里面去。另外一个我们比较关注的组件是 Actor System，它是由 ScadAKKA 异步网络组件实现的。我们后期部署时发现有很多 AKKA time out 这类问题，这意味着 JobManager 组件和 TaskManager 组件进行通信的时候出现了问题。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fca6b8f8434d02d934488020d090514c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;519&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-fca6b8f8434d02d934488020d090514c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;519&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-fca6b8f8434d02d934488020d090514c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-fca6b8f8434d02d934488020d090514c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;再看 TaskManager 主要关注的概念，当 TaskManager 和外界系统发生交互时，它用的不是 actor 模型，actor 模型主要是异步通信，强调的是快。它和外部通信时，TaskManager 用的是 Netty，输入数据更加的稳定。&lt;/p&gt;&lt;p&gt;这里要着重关注一下 Task Slot 概念，一些分享的最佳实践案例提到 TaskManager 里的 slot 最好和当前机器 CPU 核数保持 1：1 的设置。我们最初按照1：1 设计跑一些小的 job 的时候很好，但数据量上升时经常会出现一些 time out 的问题。原因在于 Kubernetes 提供的 CPU 只是一个 CPU 的实践片，不能等同物理机上的 CPU，当在 TaskManager 下部署多个的时候，虽然它们的内存会被分摊掉，但 CPU 却是共享的。在这种状况下，整个 TaskManager 就不是特别稳定。所以我们最终设置大概在 1：4 或 1：8。具体数据应该是从当前环境内的网络状况和经验值来确定的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Flink 部署&lt;/b&gt;&lt;/p&gt;&lt;p&gt;刚开始部署 Flink 时，我们是比较懵的，因为 Flink 部署文档里介绍了很多模式，比如部署在 standalone，Kubernetes、YARN 或者是 Mesos，还有一些应用实践都比较少的模式。虽然我们在云平台上搞一个 Kubernetes 的操作，但我们做不到直接使用 Kubernetes托管式的服务，所以最终采用的是 Standalone on Docker 模式，如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-639a9b9617c79c83a941cb0910c689fd_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;539&quot; data-rawheight=&quot;440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-639a9b9617c79c83a941cb0910c689fd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;539&quot; data-rawheight=&quot;440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-639a9b9617c79c83a941cb0910c689fd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-639a9b9617c79c83a941cb0910c689fd_b.jpg&quot;/&gt;&lt;figcaption&gt;△ Standalone on Docker 模式&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;Standalone 模式下，Master 和 TaskManager 可以运行在同一台机器或者不同的机器上；&lt;/li&gt;&lt;li&gt;Master 进程中，Standalone ResourceManager 的作用是对资源进行管理。当用户通过 Flink Cluster Client 将 JobGraph 提交给 Master 时，JobGraph 先经过 Dispatcher；&lt;/li&gt;&lt;li&gt;当 Dispatcher 收到请求，生成 JobManager。接着 JobManager 进程向 Standalone ResourceManager 申请资源，最终再启动 TaskManager；&lt;/li&gt;&lt;li&gt;TaskManager 启动后，经历注册后 JobManager 将具体的 Task 任务分发给 TaskManager 去执行。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;Flink 提交任务&lt;/b&gt;&lt;/p&gt;&lt;p&gt;Flink 提供丰富的客户端操作提交任务和与任务进行交互，包括 Flink 命令行、Scala Shell、SQL Client、Restful API 和 Web。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e7c24b194c137db5c73fdda69d4a0154_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;413&quot; data-rawheight=&quot;353&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;413&quot; data-rawheight=&quot;353&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-e7c24b194c137db5c73fdda69d4a0154_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;最重要的是命令行，其次是 SQL Client 用于提交 SQL 任务的运行，以及 Scala Shell 提交 Table API 的任务，还提供可以通过 http 方式进行调用的 Restful 服务，此外还有 Web 的方式可以提交任务。对我们非常实用的是 Restful API 功能。目前的服务里，除了拉取原始日志这块代码没有动，其他一些 go 自研组件的统计、排序等后续的操作现在统统不用了，直接调用 Flink 相关的接口。&lt;/p&gt;&lt;p&gt;Flink 是一个异步执行的过程。调用接口传递任务后，紧接着会把 taster 的ID 返还给你，后续的操作里面可以通过这个接口不断去轮循，发现当前任务的执行情况再进行下一步决策。综合来看，Flink 的 Restful API 接口，对于我们这种异构的、非 JAVA 系的团队来说还是非常方便的。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;使用批处理时遇到的问题&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;网络问题&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-05888a9e248f1a8b7d748cc8811cf714_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1032&quot; data-rawheight=&quot;397&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-05888a9e248f1a8b7d748cc8811cf714_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1032&quot; data-rawheight=&quot;397&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-05888a9e248f1a8b7d748cc8811cf714_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-05888a9e248f1a8b7d748cc8811cf714_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;当我们逐步迁移日志服务时，开始日志量比较小，Flink运行的非常好；当发现它负载不了，出现 GVM 堆错误之类的问题时也只需要把相关参数调大就可以了，毕竟云平台上资源还是比较富裕的，操作也很方便。&lt;/p&gt;&lt;p&gt;但当我们越来越信任它，一个 job 上百 G 流量时，整个 tap 图就变成一条线，网络问题就出现了。此前有心跳超时或者任务重试之类的问题，我们并不是特别在意，因为失败后Flink 支持重试，我们通过 restful 接口也能够感知到，所以失败就再试一次。但是随着后面的任务量加大，每运行一次代价就越来越大了，导致提交的越多当前整个集群就会越来越恶化。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-07af3d6249262eea71811be0c220d50e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;298&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-07af3d6249262eea71811be0c220d50e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;298&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-07af3d6249262eea71811be0c220d50e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-07af3d6249262eea71811be0c220d50e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;当这种上百 G 的日志批处理任务放进去后经常会出现三类错误：最上面红线画出的akkaTimeout 问题是前面讲的 JobManager 和 TaskManager 相互通信出现的问题；像心跳超时或链接被重置的问题也非常多。&lt;/p&gt;&lt;p&gt;为什么我们没有完全把这个问题处理掉呢？是因为我们看了一些阿里的 Flink on K8S 的经验总结。大家有兴趣也可以看一下。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-55e6cdb000864ffa9e1200b5f8beaad9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;360&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-55e6cdb000864ffa9e1200b5f8beaad9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;640&quot; data-rawheight=&quot;360&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-55e6cdb000864ffa9e1200b5f8beaad9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-55e6cdb000864ffa9e1200b5f8beaad9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这篇文章中面对同样的问题，阿里团队提出将网络放到 K8S 网络虚拟化会实现一定的性能，我们参考了这种解决方案。具体来说，需要对 Flink 配置进行一些调整，另外有一些涉及 connection reset by peer 的操作：&lt;/p&gt;&lt;p&gt;&lt;b&gt;调整 Flink 配置参数&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;调大网络容错性, 也就是配置参数中 timeout 相关的部分。比如心跳 5 秒一次超时了就调成 20 秒或者 30 秒，注意不可以完全禁掉或者调到很大；&lt;/li&gt;&lt;li&gt;开启压缩。如果是以纯文本的形式或者不是压缩包的形式上传，Flink     会并行读取文件加快处理速度，所以前期倾向上传解压后的文本；当网络开销变大后，我们就选择开启文件压缩，希望通过 CPU 的压力大一点，尽量减少网络开销。此外，TaskManager 或者是 JobManager 和 TaskManager 之间进行通信也可以开启压缩；&lt;/li&gt;&lt;li&gt;利用缓存, 如`taskmanager.memory.network.fraction` 等，参数配置比较灵活；&lt;/li&gt;&lt;li&gt;减少单个 task manager 下 task slots 的数量。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;Connection reset by peer&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;不要有异构网络环境（尽量不要跨机房访问）&lt;/li&gt;&lt;li&gt;云服务商的机器配置网卡多队列 (将实例中的网络中断分散给不同的CPU处理，从而提升性能)&lt;/li&gt;&lt;li&gt;选取云服务商提供的高性能网络插件：例如阿里云的 Terway&lt;/li&gt;&lt;li&gt;Host network，绕开 K8s 的虚拟化网络（需要一定的开发量）&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;由于 Connection reset bypeer 的方案涉及到跨部门协调，实施起来比较麻烦，所以我们目前能够缓解网络问题的方案是对 Flink 配置进行一些调整，通过这种手段，当前集群的网络问题有了很大程度的缓解。&lt;/p&gt;&lt;p&gt;&lt;b&gt;资源浪费&lt;/b&gt;&lt;/p&gt;&lt;p&gt;standlone 模式下，整个集群配置资源的总额取决于当前所有 job 里最大的 job 需要的容量。如下图所示，最下面不同任务步骤之间拷贝的数据已经达到了 150G+，能够缓解这种问题的办法是不断配置更大的参数。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-9429eb3cfe2f85acd5247f1d4ec94bf3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1060&quot; data-rawheight=&quot;400&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-9429eb3cfe2f85acd5247f1d4ec94bf3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1060&quot; data-rawheight=&quot;400&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-9429eb3cfe2f85acd5247f1d4ec94bf3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-9429eb3cfe2f85acd5247f1d4ec94bf3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;但由于 Flink 这一套后面有一个JVM 的虚拟机，JVM 虚拟机经常申请资源后并没有及时释放掉，所以一个容器一旦跑过一个任务后，内存就会飙上去。当不断拉大配置，且配置数量还那么多的情况下，如果我们的任务只是做一个小时级的日志处理，导致真正用到的资源量很少，最终的效果也不是很好，造成资源浪费。&lt;/p&gt;&lt;p&gt;&lt;b&gt;job 卡死&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在容量比较大后，我们发现会出现 job 卡死，经常会出现量大的 job 加载进行到一半的时候就卡住了。如下图所示（浅蓝色是已经完成的，鲜绿色表示正在进行的），我们试过不干预它，那么这个任务就会三五个小时甚至是八个小时的长久运行下去，直到它因为心跳超时这类的原因整体 cross 掉。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-b88154bc138893d84f6a4a5845af7313_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1015&quot; data-rawheight=&quot;369&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-b88154bc138893d84f6a4a5845af7313_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1015&quot; data-rawheight=&quot;369&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-b88154bc138893d84f6a4a5845af7313_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-b88154bc138893d84f6a4a5845af7313_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这个问题目前没有完全定位出来，所以现在能采取的措施也只是通过 restful 接口检查任务的时候，给它设置一个最大的阈值。当超过这个阈值就认为这个任务已经完全坏掉了，再通过接口把它取消掉。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Flink 带来的收益&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;下图所示是日志处理的某一环节，每一个小方块代表一个服务，整个服务的链路比较长。当有多个数据源加载一个数据时，它会先 transfer porter 放到又拍云的云存储里，由 log-merge 服务进行转换，再根据当前服务的具体业务需求，最终才会存到云存储或者存到 redis。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5e06faedb552d043b40d7105635e7348_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;619&quot; data-rawheight=&quot;509&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-5e06faedb552d043b40d7105635e7348_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;619&quot; data-rawheight=&quot;509&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-5e06faedb552d043b40d7105635e7348_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-5e06faedb552d043b40d7105635e7348_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;任务和任务之间的衔接是通过两种方式：一种是人为之间进行约定，比如我是你的下游组件，我们约定延迟 3 个小时，默认 3 个小时后你已经数据处理好，我就去运行一次；第二种是用 ASQ，我处理结束后推送消息，至于你消费不消费、消费是否成功，上游不需要关心。&lt;b&gt;虽然原本正常的情况下服务运行也很稳定，但一旦出现问题再想定位、操纵整个系统，追捕一些日志或重跑一些数据的时候就比较痛苦。这一点在我们引入到 Flink 后，整体上有非常大的改进。&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;small&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-bf19eb6d346280028a3a265a2c8344e3_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;876&quot; data-rawheight=&quot;719&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-bf19eb6d346280028a3a265a2c8344e3_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;876&quot; data-rawheight=&quot;719&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-bf19eb6d346280028a3a265a2c8344e3_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-bf19eb6d346280028a3a265a2c8344e3_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;目前只有任务管理部分是复用了之前的代码，相当于采集板块。采集好数据直接向 Flink 提交当前的 job，Flink 处理好后直接存进云存储。我们的任务管理主要分两类功能，一个是采集，另一个是动态监控当前任务的进行结果。总的来看，重构后相当于形成了一个闭环，无论是 Flink 处理出现问题，亦或是存储有问题，任务管理系统都会去重跑，相当于减少一些后期的运维工作。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;选择 standalone 系统部署一套Flink 系统，又要它处理不是太擅长的批处理，且量还比较大，这是非常有挑战性的。充满挑战的原因在于这不是 Flink 典型的应用场景，很多配置都做不到开箱即用，虽说号称支持批处理，但相关配置默认都是关闭的。这就需要调优，不过很多文档里大多会写如果遇到某类问题就去调大某类值，至于调大多少完全靠经验。&lt;/p&gt;&lt;p&gt;尽管如此，但由于当前 Flink 主推的也是流批一体化开发，我们对 Flink 后续的发展还是比较有信心的。前面也讲了 Flink1.1 版本中，dateset 批处理的 API 和 stream的 API 还是分开的，而在最新版本 1.12 中已经开始融合在一起了，并且 dateset 部分已经不建议使用了。我们相信沿着这个方向发展，跟上社区的节奏，未来可期。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;演讲视频观看及PPT下载：&lt;/b&gt;&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/opentalk/457.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic4.zhimg.com/v2-11121468cdfd0a5f2a0b5aebe4703c37_180x120.jpg&quot; data-image-width=&quot;960&quot; data-image-height=&quot;540&quot; class=&quot;LinkCard LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;Flink 在又拍云日志批处理中的实践&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.upyun.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic4.zhimg.com/v2-11121468cdfd0a5f2a0b5aebe4703c37_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b55773682bd457a6ac202de731ebbc54</guid>
<title>关于构建数据仓库的几个问题</title>
<link>https://toutiao.io/k/8894fk1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;92356&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;section data-width=&quot;97%&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.3246753246753247&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uN1LIav7oJibnXRTwzul99YfpqjjVFWoFABPTfAIWeODwwzprdQd6xO6w5PTntPoJBicOa9kS1N0jqL5dkXJAwhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;77&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;元宵节快乐&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-bgless=&quot;spin&quot; data-bglessp=&quot;120&quot;&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;p&gt;如果本文对你有所帮助，请分享、点赞、在看，想要获得更多信息，请关注我。&lt;/p&gt;&lt;p&gt;欢迎扫描文末二维码加我微信，回复【进群】，可以加入大数据技术交流群，期待与你一起交流&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;102462&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5283018867924528&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FIBZec7ucCjv9me2lz9aUeUY91fHaIhIODzyCn62XtvA8ictTjkd5ym0o2hmxRTy2K38hcANQmK9qHyic4L7ohNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;53&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;写在前面&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据仓库（Data Warehouse）是一个面向主题的（Subject Oriented）、集成的（Integrated）、相对稳定的（Non-Volatile）、反映历史变化（Time Variant）的数据集合，用于支持管理决策(Decision Making Support)。近年来，随着大数据的应用不断深入，构建企业级数据仓库成为了企业进行精细化运营的一种趋势。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从管理者的视角来看，数据仓库是赋能业务并辅助决策的一种工具，从开发者的视角来看，数据仓库是一堆数据模型的集合。数仓开发是一个系统工程，涉及数据集成、数据建模、数据开发、数据服务、任务调度、元数据管理、数据质量管理(DQC)等一系列的流程。另外，由于数据跟业务是息息相关的，所以在构建数仓的时候，需要对业务有一个非常深刻的理解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得注意的是，数仓的建设不是一蹴而就的，也没有毕其功于一役的方法，业务的不断变化决定了数仓是在不断迭代中进行完善的。从这个层面上来讲，或许永远没有完美的数仓。由于人员的流动、业务的变化以及前期的系统性建设不足，数仓总会存在这样或那样的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或许我们可以用&quot;&lt;strong&gt;是否成熟&lt;/strong&gt;&quot;描述数仓的建设，那么什么是成熟的数仓呢，我们不妨换个角度思考一下：&lt;strong&gt;什么是一个不成熟的数据仓库&lt;/strong&gt;？此时你的脑海里是否会蹦出一个词，那就是&lt;strong&gt;混乱&lt;/strong&gt;。是的，一个不成熟的数仓虽然具备了部分数仓规范，但在具体的落地实施过程中，并未能完全按照规范操作， 导致数据仓库建设比较混乱，比如数据域划分不清楚、数仓分层不明确、数据任务随意依赖、数据重复开发等等问题。迫于业务快速变化以及日常数据开发需求的压力，造成了数据开发没有太多的时间和精力去顾及这些问题，最终形成了一个不成熟的数仓。一旦出现了这些问题，后续就需要有专门的数据治理团队去规划并规范数仓的建设。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，假设你接手了一个不成熟的数仓项目，或者你觉得目前的数仓建设还不够成熟，那么不妨思考一下几个问题：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;定目标&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数仓设计目标包括数仓分层清晰，字段与模型命名规范，具备较高可复用性与可维护性，能够快速响应产品运营层面的数据分析需求，以数据驱动产品迭代与业务增长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数仓设计的过程中，坚持用户驱动与数据驱动相结合的设计理念，即一方面根据当前的业务数据的基础和质量情况，以数据源分析为出发点构建数据仓库；另一方面根据业务的方向性需求，从业务需要解决的具体问题出发，确定系统范围和需求框架。&lt;img data-ratio=&quot;0.5317919075144508&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PL10rfzHicsiaIkI19RdaNMz4TrUCPEoFl7OzFZ7iaEh4rYthJxxaAuBhIHwd15rhpnIITluAVFYSoxZPbYicrs0JQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;692&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;选技术&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据仓库是一个复杂系统，会涉及到一系列的流程，由此不可避免的会使用很多的技术框架。目前，行业中使用的常见工具主要包括：数据同步工具、数据处理工具、任务调度工具、报表工具、元数据管理工具、质量管理平台(DQC)以及大数据基础平台等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是自建的大数据平台，或者是没有一个大数据开发平台，这种情况下需要数仓开发人员具备丰富的技术栈，既要兼顾技术的集成使用，又要兼顾数仓的建设与业务需求的开发。如果使用的是已经集成好的开发套件，比如阿里云的dataworks，这样数仓的开发人员会更加聚焦数仓的建设，而不是在各种技术的集成过程中踩坑而分散过多的精力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;找问题&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前文已经提到没有完美的数仓，其实数仓的建设并没有对与错之分，只有好与坏之差。我们不能一味的使用拿来主义的方式去构建数据仓库，数据仓库建设能否成功会涉及很多的因素，数仓建设的方法论是指引我们的一个方向，万万不可迷失其中。一言以蔽之，合适就好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在接手不成熟的数仓时，需要梳理存在的一些问题，而这些问题一般情况下都大同小异，常见的一些问题主要包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数仓分层不清晰&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据域划分不明确&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模型设计不合理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码不规范&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;命名不统一&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;划主题&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主题域是业务过程的抽象集合，是在较高层次上对数据进行分类聚集的抽象，这是一个逻辑概念，主要方便数据的分类管理。业务过程就是企业经营过程中一个个不可拆分的行为事件，比如仓储管理里面有入库、出库、发货、签收，都是业务过程，抽象出来的主题域就是仓储域。主题域划分要尽量涵盖所有业务需求，保持相对稳定性，还具备一定的扩展性，新加入一个主题域，不影响已经划分的主题域的表。有了主题域之后，每个数据模型也就有了一个归属，这样数据组织会更加的清晰，同时也比较方便维护。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;识分层&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;数仓为什么要分层&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;合理的数据仓库分层一方面能够降低耦合性，提高重用性，可读性可维护性，另一方面也能提高运算的效率，影响到数据需求迭代的速度，近而影响到产品决策的及时性。建立数据分层可以提炼公共层，避免烟囱式开发，可见一个合适且合理的数仓分层是极其重要。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;通用分层设计思路&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;ODS&lt;/strong&gt;:操作型数据(Operational Data Store)，指结构与源系统基本保持一致的增量或者全量数据。作为DW数据的一个数据准备区，同时又承担基础数据记录历史变化，之所以保留原始数据和线上原始数据保持一致，方便后期数据核对需要。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;CDM&lt;/strong&gt;：通用数据模型，又称为数据中间层(Common Data Model)，包含DWD、DWS、DIM层。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;DWD&lt;/strong&gt;：数据仓库明细层数据(Data Warehouse Detail)。对ODS层数据进行清洗转化，以业务过程作为建模驱动，基于每个具体的业务过程特点，构建最细粒度的明细事实表。可以结合企业的数据使用特点，基于维度建模思想，将明细事实表的某些重要属性字段做适当冗余，也即宽表化处理，构建明细宽表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;DWS&lt;/strong&gt;：数据仓库汇总层数据(Data Warehouse Summary)，基于指标需求，构建初步汇总事实表，一般是宽表。基于上层的应用和产品的指标需求，构建公共粒度的汇总指标表。以宽表化手段物理化模型，构建命名规范、口径一致的统计指标，为上层提供公共指标。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;DIM&lt;/strong&gt;：建立一致数据分析维表，可以降低数据计算口径不统一的风险，同时可以方便进行交叉探查。以维度作为建模驱动，基于每个维度的业务含义，通过添加维度属性、关联维度等定义计算逻辑，完成属性定义的过程并建立一致的数据分析维表。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;ADS&lt;/strong&gt;：面向应用的数据服务层(Application Data Service)。整合汇总成分析某一个主题域的服务数据，面向应用逻辑的数据加工。该层主要存放数据产品个性化的统计指标数据，这一层的数据直接对接数据的消费者，是产品、运营等角色可以直接感知理解的一层，大多数这一层的表都可以直接在BI上通过图表的形式直接透出。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;分层辨析&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ODS层&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ODS层的概念主要体现在两个方面：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;操作型系统的集成，用于当前、历史以及其它细节查询(业务系统的一部分)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;为决策支持提供当前细节数据(数据仓库的一部分)&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ODS是用于支持企业日常的全局应用的数据集合，ODS的数据具有&lt;strong&gt;面向主题、集成的、可变的以及数据是当前的或是接近当前的&lt;/strong&gt;特点。同样也可以看出ODS是介于DB和DW之间的一种过渡存储。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得注意的是，Kimball所说的ODS是物理落地关系型数据库中，但是在实际生产应用中，ODS往往是物理落地在数据仓库中，比如Hive。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常来说ODS是在数据仓库中存储业务系统源数据，所以从数据粒度、数据结构、数据关系等各个方面都与业务系统的数据源保持一致。但是，也不能仅仅将ODS层看做是业务系统数据源的一个简单备份，ODS和业务系统数据源的差异主要是由于两者之间面向业务需求是不同的，业务系统是面向多并发读写同时有需要满足数据的一致性，而ODS数据通常是面向数据报表等批量数据查询需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于ODS层与业务系统DB的主要区别，体现在一下几个方面：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据存储方式方面。由于性能压力，业务DB需要对同一个逻辑表进行分表分库操作，而ODS会将业务系统中同一个逻辑表统一到一个物理实体中存储&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据存储介质方面。业务系统通常用oralce、MySQL、DB2等以事务性处理见长关系型数据库系统，ODS通常存储在以Hadoop为代表的分布式系统中，比如Hive等等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据组织形式方面。业务系统表通常需要遵循三范式，并且需要创建复杂的索引结构来提升查询效率，但是ODS层的表通常没有索引。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ODS层的数据同步通常会使用数据库直连抽取或者数据库日志抽取的方式，在设计ODS物理表时，在表命名、数据存储等方面都需要遵循一定的准则。比如：不管是表命名还是字段命名尽量和业务系统保持一致，但是需要通过额外的标识来区分增量和全量表，”_delta”来标识该表为增量表。另外，为了满足历史数据分析需求，我们需要在ODS表中加一个时间维度，这个维度通常在ODS表中作为分区字段。如果是&lt;strong&gt;增量存储&lt;/strong&gt;，则可以按天为单位使用业务日期作为分区，每个分区存放日增量的业务数据。如果是&lt;strong&gt;全量存储&lt;/strong&gt;，只可以按天为单位使用业务日期作为分区，每个分区存储截止到当前业务时间的全量快照数据。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;DWD层&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DWD层的数据一般存放明细事实表，为了提升访问便利性和访问性能，在维度模型的事实表基础上，将部分常用维度冗余到事实表，从而形成宽表模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;明细事实表的设计有五个步骤：&lt;strong&gt;选择业务过程---&amp;gt;确定粒度---&amp;gt;选择维度---&amp;gt;确定事实(度量)---&amp;gt;冗余维度&lt;/strong&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;DWS层&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以分析的主题对象作为建模驱动，基于上层的应用和产品的指标需求，构建公共粒度的汇总指标表。以宽表化手段物理化模型，构建命名规范、口径一致的统计指标，为上层提供公共指标，建立汇总宽表。如：形成日，周，月粒度汇总明细，或者基于某一个维度，如商品类目粒度的汇总日表，统计便于下一步报表数据结构的组织。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于汇总层的表建模应遵循以下的原则：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;数据公用性&lt;/strong&gt;比如，汇总的聚集表能否与他人公用？基于某个维度的聚集是否是数据分析或者报表中经常使用的？如果满足这些情况，我们就有必要把明细数据沉淀到汇总表中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;不跨数据域&lt;/strong&gt;数据域是在较高层次上对数据进行分类聚集的抽象，如交易统一划到交易域下，商品的新增、修改放到商品域下。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;区分统计周期&lt;/strong&gt;表命名上要能说明数据的统计周期，如_1d 表示最近1天，_td 截止到当天，_nd 表示最近N天。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;避免多个层级的数据&lt;/strong&gt;应该避免将不同层级的数据放在一起，比如，如果存在7天和30天的事实，我们可以选择用两列存放7天和30天的事实，但是需要在列名和字段注释上说明清楚。同时我们也可以使用两张表分别存储不同统计周期的数据加以区分。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;聚集是不跨越事实的&lt;/strong&gt;聚集是针对原始星型模型进行的汇总，为了获取和查询原始模型一致的结果，聚集的维度和度量必须与原始模型保持一致，因此聚集是不跨事实的。横向钻取(交叉探查)是针对多个事实基于一致性维度进行的分析，很多时候采用融合事实表，预先存放横向钻取的结果，从而提高查询性能。因此融合事实表是一种导出模式而不是聚集。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;DIM层&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该层主要存储一致性维度数据，数据仓库总线架构重要基石之一就是一致性维度。通过构建一致性维度我们可以轻松实现数据的交叉探查。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;维度是维度建模的基础和灵魂。维度建模中，将度量称为“事实”，将环境描述为“维度”，维度是用于分析事实所需要的多样环境。例如，在分析交易过程时，可以通过买家、卖家、商品和时间等维度描述交易发生的环境。维度所包含的表示维度的列，称为维度属性。维度属性是查询约束条件、分组和报表标签生成的基本来源，是数据易用性的关键。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ADS层&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;个性化指标加工，主要存储不具有公用性的复杂指标，比如针对某张数据报表设计的底层数据存储模型。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;分层注意点&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ODS不可以被应用层调用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CDM层任务的深度不宜过大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DWS优先调用DWD及DIM&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;避免ADS过渡引用明细层&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;理建模&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前文介绍了数据分层的概念，而数据建模更多的着眼于数据公共层处理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;好的数据建模有哪些特点&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据模型就是数据组织和存储方法，强调从业务、数据存储和数据使用角度合理存储数据。好的数据建模一般具备如下特点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;性能：能够帮助使用者快速查询所需要的数据，减少数据的I/O吞吐，提高使用数据的效率。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;成本：减少不必要的数据冗余与重复计算，实现计算结果的良好复用，从而降低存储和计算成本。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;质量：减少数据统计口径不一致性，减少数据计算错误的可能性。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;数据模型设计原则&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;高内聚和低耦合
一个逻辑和物理模型由哪些记录和字段组成，应该遵循最基本的软件设计方法论的高内聚和低耦合原则。主要从数据业务特性和访问特性两个角度来考虑：将业务相近或者相关的数据、粒度相同数据设计为一个逻辑或者物理模型；将高概率同时访问的数据放一起，将低概率同时访问的数据分开存储。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;核心模型与扩展模型分离
建立核心模型与扩展模型体系，核心模型包括的字段支持常用核心的业务，扩展模型包括的字段支持个性化或是少量应用的需要，不能让扩展字段过度侵入核心模型，破坏了核心模型的架构简洁性与可维护性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;公共处理逻辑下沉及单一
越是底层公用的处理逻辑更应该在数据调度依赖的底层进行封装与实现，不要让公共的处理逻辑暴露给应用层实现，不要让公共逻辑在多处同时存在。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;成本与性能平衡
适当的数据冗余换取查询和刷新性能，不宜过度冗余与数据复制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据可回滚
处理逻辑不变，在不同时间多次运行数据结果确定不变。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一致性
相同的字段含义在不同表中字段命名必须相同，必须使用规范定义中的名称。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;命名清晰可理解
表命名需清晰、一致，表名需易于消费者理解和使用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;典型的数据仓库建模方法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数仓建模的典型方法有：实体建模(ER模型)、维度建模法、Data Vault 模型、Anchor 模型。目前使用较多的当属维度建模，而维度建模中，又分为星型模型和雪花模型两大类，一般星型模型使用较多。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;星型模型：维度建模非常直观，紧紧围绕着业务模型，可以直观的反映出业务模型中的业务问题。不需要经过复杂的表关联，就能够拿到业务分析想要的全部数据，能够极大的提升数据仓库的处理能力，缺点则是数据冗余较多。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;雪花模型：在星型的基础上，分解维度，雪花模型的维度表可以拥有其他维度表的，虽然这种模型相比星型模型更规范一些，但是由于这种模型不太容易理解，维护成本比较高，而且性能方面需要关联多层维表，性能也比星型模型要低，普遍用的少一些。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于维度建模，主要是将数据分为了维表和事实表。维度建模中，将度量称为“事实”，将环境描述为“维度”，维度是用于分析事实所需要的多样环境。例如，在分析交易过程时，可以通过买家、卖家、商品和时间等维度描述交易发生的环境。维度所包含的表示维度的列，称为维度属性。维度属性是查询约束条件、分组和报表标签生成的基本来源，是数据易用性的关键。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;事实表&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实表作为数据仓库维度建模的核心，紧紧围绕着业务过程来设计，通过获取描述业务过程的度量来表达业务过程，包含了引用的维度和与业务过程有关的度量。事实表中一条记录所表达的业务细节程度被称为粒度。粒度通常可以通过两种方式来表述：一种是维度属性组合所表示的细节程度，一种是所表示的具体业务含义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对维度表来说，通常事实表要细长的多，行的增加速度也比维度表快很多。维度属性也可以存储到事实表中，这种存储到事实表中的维度列被称为退化维度。与其他存储在维度表中的维度一样，退化维度也可以用来作为事实表的过滤查询、实现聚合操作等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实表有三种类型：事务事实表、周期快照事实表、累积快照事实表。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;维表&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;注意问题&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;尽可能包含丰富的维度属性
丰富的维度属性可以为数据分析统计提供更多的分析角度&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;编码与文字描述共存
尽可能多给出包括一些富有意义的文字性描述，除此之外，为了保持扩展性，需要将编码code与文字描述同时保留，方便以后新增加属性时导致错误的计算。比如商品维度中的商品ID和商品标题，类目ID和类目名称等。ID一般用于不同表之前的关联，而名称一般用于报表标签。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;区分数值型的维度属性
数值型字段是作为事实还是维度属性，取决于该字段的作用。如果通常是用于查询约束条件或分组统计，则是作为维度属性；如果通常是用于参与度量的计算，则是作为事实。比如商品价格，可以用于查询约束条件或统计价格区间的商品数量，此时是作为维度属性使用；也可以用于统计某类目下商品的平均价格，此时是作为事实使用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;尽量沉淀出通用的维度属性
有些维度属性获取需要进行比较复杂的逻辑处理，有需要通过多表关联得到，也有单表的不同字段混合处理得到，或者对单表的某个字段进行解析得到。此时，需要将尽可能多的通用的维度属性进行沉淀。一方面，可以提高下游使用的方便性，减少复杂度；另一方面，避免下游使用解析时由于各自逻辑不同而导致的口径不一致。比如有些字段存储在JSON字符串中，则需要解析出来。再比如有时候无法直接获取某个维度属性，这个时候就需要进行加工判断，将其作为一个单独的属性字段。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;维度表一般是很不规范化的。实际应用中，几乎总是使用维度表的空间来换取简明性和查询性能。&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;缓慢变化维&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据仓库的重要特点之一是反应历史变化，所以如何处理维度的变化是维度设计的重要工作之一。缓慢变化维的提出是因为在现实世界中，维度的属性并不是静态的，它会随着时间的变化而发生缓慢的变化，这一现象称为缓慢变化的维度，简称缓慢变化维。与数据增长较为快速的事实表相比，维度变化相对缓慢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Kimball的理论中，有三种缓慢变化的处理方式，分别是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;type1：重写维度值。采用此种方式，不保留历史，始终取最新数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;type2：插入新的维度行。采用此种方式，保留历史，维度值变化前的事实和过去的维度值关联，维度值变化后的事实和当前的维度值关联。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;type3：添加维度列&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在Kimball的理论中，必须使用代理键作为每个维度表的主键，用于处理缓慢变化维度，这种方式在实际的操作中非常复杂，使用起来也不方便，所以一般情况下不使用代理键。&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;常用缓慢变化维的处理方式&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的方式是使用快照来处理缓慢变化维。离线数仓按T+1计算，处理维度变化的方式就是每天一份全量快照。比如商品维度，每天保留一份全量商品快照数据。任意一天的事实均可以取到当天的商品信息，也可以取到最新的商品信息，通过限定日期，采用自然键进行关联即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此方式的优势是简单而有效，开发和维护成本低，另外使用方便，理解性好。数据使用方只需要限定日期即可取到当天的快照数据。任意一天的事实快照和任意一天的维度快照通过维度的自然键进行关联即可。主要的缺点就是会造成存储资源的浪费，由于存储成本远低于CPU、内存等成本，此方法总体来说弊大于利。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;制规范&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;达成共识&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于数仓开发规范，务必要执行到位，确保大家能够达成一致的理解与认可。只有按照规范操作，才不至于使数仓最终变得越来越臃肿，越来越低效。关于规范的制定，需要经过团队人员的一致认可，具有可操作性，切不可畏手畏脚地被规范束缚，影响开发效率。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;表命名规范&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ODS层表命名规范
比如全量表：ods.s{源系统表名}
比如增量表：ods.s{源系统表名}_delta&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DIM/DWD层表命名规范
比如全量表：dwd_{数据域缩写}{自定义表命名}&lt;em&gt;df
比如增量表：dwd&lt;/em&gt;{数据域缩写}{自定义表命名}_di
比如维表：dim[{业务域缩写}]{自定义表命名}&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DWS层表命名规范
dws_{数据域缩写}{维度缩写}{自定义表命名}{数字}_{d/m/y，分别表示天、月、年}&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;最近一天      1d
最近N天      （N）d  ---N代表是一个数字
最近30天      1m
最近7天       1w
最近365天     1y
周累计至今     wtd   ----周报周（周六至周五）
月初累计至今   mtd
累计至今      td&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ADS层表命名
比如：ads_{数据域}&lt;em&gt;{统计粒度}[&lt;/em&gt;{业务限定}][&lt;em&gt;{自定义命名标签}]&lt;/em&gt;{统计周期}&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;关于表的命名需要根据具体团队的约定，一般见名知意即可，一旦规定了具体的格式，就尽量统一风格&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;开发规范&lt;span/&gt;&lt;/h4&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要介绍了构建数仓的过程中或者在接手一个不成熟的数仓之后需要注意的一些问题，主要包括7个方面，分别是定目标、选技术、找问题、划主题、识分层、理建模、制规范。这些方面只是数仓构建中的一部分，由于篇幅限制，不能一一详述，希望本文对你有所帮助。&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;93573&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;往期精彩回顾&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2ODQ3NjYyMA==&amp;amp;mid=2247484561&amp;amp;idx=1&amp;amp;sn=70af9e747e7b1ec121dbd430b4309c5d&amp;amp;chksm=fc8c1232cbfb9b24ddc803d85f940f7a4acb5b00cdcc079599f026a212da56ccf9810e713213&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;数仓开发应避免的10个陷阱&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2ODQ3NjYyMA==&amp;amp;mid=2247485606&amp;amp;idx=1&amp;amp;sn=1dfd0fba7c2c903cc887a88cd25b8211&amp;amp;chksm=fc8c1e05cbfb97134879d36808cfbcb5439feb468585d751d1e016a6c8fb2981d01585725a6f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;数仓|几种SQL隐藏的错误，你遇到过吗？&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2ODQ3NjYyMA==&amp;amp;mid=2247484865&amp;amp;idx=1&amp;amp;sn=ffcb7f1f56aa8d5df61386778491677a&amp;amp;chksm=fc8c1362cbfb9a7480c5c5a1cfa07d3d586cca75c15e4ab95eb1bf750972d87c34875a7b8eb2&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;数仓面试|四个在工作后才知道的SQL密技&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2ODQ3NjYyMA==&amp;amp;mid=2247484633&amp;amp;idx=1&amp;amp;sn=4318c44a7ba10c8f98ae17f1a13bf20f&amp;amp;chksm=fc8c127acbfb9b6cd38eb4f12e1598beb47779d8ab2085d2f100f09766fbb3cd6c05f2560e0d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;数仓|大数据时代,维度建模过时了吗?&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2ODQ3NjYyMA==&amp;amp;mid=2247484622&amp;amp;idx=1&amp;amp;sn=09a652b7ee8d03cd5581cc57931420bf&amp;amp;chksm=fc8c126dcbfb9b7b7d74d4cd7716c86d27592ac42c3e6a676880ededfff1d7f72df2dec0b4b8&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;数仓规范|使SQL更易于阅读的几个小技巧&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.2952127659574468&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PL10rfzHicsgSwyuFAHrIHib40RYaGkyQxVn7629suCCWxJO5heFibm2q46Uz3thXuFDNciaunNiaXSdoiaPC3lFPlRw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;752&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;99939&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98929&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98929&quot;&gt;&lt;section hm_fix=&quot;300:334&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.958904109589041&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PL10rfzHicshOumLmWmKppdib5dNhEeg7drFgtcqoI4kRvrW1e753UOYicDoR0WlSMwcesOE0IJw0E4MPqReicsyyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;73&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;点分享&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.9594594594594594&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PL10rfzHicshOumLmWmKppdib5dNhEeg7dJuIHmg5JR3WFRpxMhg813xnsbPpI91VI6MIuZIbYHJvwiauIVgNictBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;74&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;点收藏&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.958904109589041&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PL10rfzHicshOumLmWmKppdib5dNhEeg7dviaDhs0VOZzUVIAibLK5WmhfpGHpkgp3M4JjJRdDaYia0tlwmyO3cQnxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;73&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;点点赞&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.9594594594594594&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PL10rfzHicshOumLmWmKppdib5dNhEeg7dkCQhtZPOXw5NMlqCX0qHXiauoWdKx0nsaFGibu03yrURic1P8YlC1tQCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;74&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;点在看&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a10b0983c264fce7f6f2ad177f6eba5e</guid>
<title>从预编译的角度理解 Swift 与 Objective-C 及混编机制</title>
<link>https://toutiao.io/k/frl1lkh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;写在前面&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文涉及面广，篇幅较长，阅读完需要耗费一定的时间与精力。如果你带有较为明确的阅读目的，可以参考以下建议进行阅读：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果你对预编译的理论知识已经了解，可以直接从【原来它是这样的】的章节开始进行阅读，这会让你对预编译有一个更直观的了解。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果你对 Search Path 的工作机制感兴趣，可以直接从【关于第一个问题】的章节阅读，这会让你更深刻，更全面的了解到它们的运作机制，&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果您对 Xcode Phases 里的 Header 的设置感到迷惑，可以直接从【揭开 Public、Private、Project 的真实面目】的章节开始阅读，这会让你理解为什么说 Private 并不是真正的私有头文件&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果你想了解如何通过 hmap 技术提升编译速度，可以从【基于 hmap 优化 Search Path 的策略】的章节开始阅读，这会给你提供一种新的编译加速思路。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果你想了解如何通过 VFS 技术进行 Swift 产物的构建，可以从 【关于第二个问题】章节开始阅读，这会让你理解如何用另外一种提升构建 Swift 产物的效率。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果你想了解 Swift 和 Objective-C 是如何找寻方法声明的，可以从 【Swift 来了】的章节阅读，这会让你从原理上理解混编的核心思路和解决方案。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;概述&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;随着 Swift 的发展，国内技术社区出现了一些关于如何实现 Swift 与 Objective-C 混编的文章，这些文章的主要内容还是围绕着指导开发者进行各种操作来实现混编的效果，例如在 Build Setting 中开启某个选项，在 podspec 中增加某个字段，而鲜有文章对这些操作背后的工作机制做剖析，大部分核心概念也都是一笔带过。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;正是因为这种现状，很多开发者在面对与预期不符的行为时，亦或者遇到各种奇怪的报错时，都会无从下手，而这也是由于对其工作原理不够了解所导致的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;笔者在美团平台负责 CI/CD 相关的工作，这其中也包含了 Objective-C 与 Swift 混编的内容，出于让更多开发者能够进一步理解混编工作机制的目的，撰写了这篇技术文章。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;废话不多说，我们开始吧！&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;预编译知识指北&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#import&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的机制和缺点&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在我们使用某些系统组件的时候，我们通常会写出如下形式的代码：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#import &lt;span&gt;&amp;lt;UIKit/UIKit.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#import&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 其实是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;#include&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 语法的微小创新，它们在本质上还是十分接近的。&lt;/span&gt;&lt;code&gt;&lt;span&gt;#include&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 做的事情其实就是简单的复制粘贴，将目标 &lt;/span&gt;&lt;code&gt;&lt;span&gt;.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件中的内容一字不落地拷贝到当前文件中，并替换掉这句 &lt;/span&gt;&lt;code&gt;&lt;span&gt;#include&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，而 &lt;/span&gt;&lt;code&gt;&lt;span&gt;#import&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 实质上做的事情和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;#include&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是一样的，只不过它还多了一个能够避免头文件重复引用的能力而已。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了更好的理解后面的内容，我们这里需要展开说一下它到底是如何运行的？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从最直观的角度来看：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;MyApp.m&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件中，我们 &lt;/span&gt;&lt;code&gt;&lt;span&gt;#import&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;iAd.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件，编译器解析此文件后，开始寻找 iAd 包含的内容（&lt;/span&gt;&lt;code&gt;&lt;span&gt;ADInterstitialAd.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，&lt;/span&gt;&lt;code&gt;&lt;span&gt;ADBannerView.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt;），及这些内容包含的子内容（&lt;/span&gt;&lt;code&gt;&lt;span&gt;UIKit.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，&lt;/span&gt;&lt;code&gt;&lt;span&gt;UIController.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，&lt;/span&gt;&lt;code&gt;&lt;span&gt;UIView.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，&lt;/span&gt;&lt;code&gt;&lt;span&gt;UIResponder.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt;），并依次递归下去，最后，你会发现 &lt;/span&gt;&lt;code&gt;&lt;span&gt;#import &amp;lt;iAd/iAd.h&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 这段代码变成了对不同 SDK 的头文件依赖。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;228&quot; data-ratio=&quot;0.4381338742393509&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAywyIJCH6w8ndA44xQR7D2SV5ux8cJCcB2178ZUX8BzBmAI99TmU3Szg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1972&quot;/&gt;&lt;p&gt;&lt;span&gt;如果你觉得听起来有点费劲，或者似懂非懂，我们这里可以举一个更加详细的例子，不过请记住，对于 C 语言的预处理器而言， &lt;/span&gt;&lt;code&gt;&lt;span&gt;#import&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 就是一种特殊的复制粘贴。&lt;/span&gt;&lt;/p&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;结合前面提到的内容，在 AppDelegate 中添加 &lt;/span&gt;&lt;code&gt;&lt;span&gt;iAd.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#import &lt;span&gt;&amp;lt;iAd/iAd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;@implementation&lt;/span&gt; &lt;span&gt;AppDelegate&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然后编译器会开始查找 &lt;/span&gt;&lt;code&gt;&lt;span&gt;iAd/iAd.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 到底是哪个文件且包含何种内容，假设它的内容如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;/* iAd/iAd.h */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#import &lt;span&gt;&amp;lt;iAd/ADBannerView.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#import &lt;span&gt;&amp;lt;iAd/ADBannerView_Deprecated.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#import &lt;span&gt;&amp;lt;iAd/ADInterstitialAd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在找到上面的内容后，编译器将其复制粘贴到 AppDelegate 中：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#import &lt;span&gt;&amp;lt;iAd/ADBannerView.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#import &lt;span&gt;&amp;lt;iAd/ADBannerView_Deprecated.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#import &lt;span&gt;&amp;lt;iAd/ADInterstitialAd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;@implementation&lt;/span&gt; &lt;span&gt;AppDelegate&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在，编译器发现文件里有 3 个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;#import&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 语句 了，那么就需要继续寻找这些文件及其相应的内容，假设 &lt;/span&gt;&lt;code&gt;&lt;span&gt;ADBannerView.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的内容如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;/* iAd/ADBannerView.h */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;@interface&lt;/span&gt; &lt;span&gt;ADBannerView&lt;/span&gt; : &lt;span&gt;UIView&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@property&lt;/span&gt; (&lt;span&gt;nonatomic&lt;/span&gt;, &lt;span&gt;readonly&lt;/span&gt;) ADAdType adType;&lt;br/&gt;&lt;br/&gt;- (&lt;span&gt;id&lt;/span&gt;)initWithAdType:(ADAdType)type&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/* ... */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么编译器会继续将其内容复制粘贴到 AppDelegate 中，最终变成如下的样子：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;@interface&lt;/span&gt; &lt;span&gt;ADBannerView&lt;/span&gt; : &lt;span&gt;UIView&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@property&lt;/span&gt; (&lt;span&gt;nonatomic&lt;/span&gt;, &lt;span&gt;readonly&lt;/span&gt;) ADAdType adType;&lt;br/&gt;&lt;br/&gt;- (&lt;span&gt;id&lt;/span&gt;)initWithAdType:(ADAdType)type&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/* ... */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@end&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#import &lt;span&gt;&amp;lt;iAd/ADBannerView_Deprecated.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#import &lt;span&gt;&amp;lt;iAd/ADInterstitialAd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;@implementation&lt;/span&gt; &lt;span&gt;AppDelegate&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样的操作会一直持续到整个文件中所有 &lt;/span&gt;&lt;code&gt;&lt;span&gt;#import&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 指向的内容被替换掉，这也意味着 &lt;/span&gt;&lt;code&gt;&lt;span&gt;.m&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件最终将变得极其的冗长。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;虽然这种机制看起来是可行的，但它有两个比较明显的问题：&lt;strong&gt;健壮性&lt;/strong&gt;和&lt;strong&gt;拓展性&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;健壮性&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先这种编译模型会导致代码的健壮性变差！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里我们继续采用之前的例子，在 AppDelegate 中定义 &lt;/span&gt;&lt;code&gt;&lt;span&gt;readonly&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;0x01&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，而且这个定义的声明在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;#import&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 语句之前，那么此时又会发生什么事情呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;编译器同样会进行刚才的那些复制粘贴操作，但可怕的是，你会发现那些在属性声明中的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;readonly&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 也变成了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;0x01&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，而这会触发编译器报错！&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;@interface&lt;/span&gt; &lt;span&gt;ADBannerView&lt;/span&gt; : &lt;span&gt;UIView&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@property&lt;/span&gt; (&lt;span&gt;nonatomic&lt;/span&gt;, &lt;span&gt;0x01&lt;/span&gt;) ADAdType adType;&lt;br/&gt;&lt;br/&gt;- (&lt;span&gt;id&lt;/span&gt;)initWithAdType:(ADAdType)type&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/* ... */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@end&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;@implementation&lt;/span&gt; &lt;span&gt;AppDelegate&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;面对这种错误，你可能会说它是开发者自己的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;确实，通常我们都会在声明宏的时候带上固定的前缀来进行区分。但生活里总是有一些意外，不是么？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设某个人没有遵守这种规则，那么在不同的引入顺序下，你可能会得到不同的结果，对于这种错误的排查，还是挺闹心的。不过，这还不是最闹心的，因为还有动态宏的存在，心塞 ing。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以这种靠遵守约定来规避问题的解决方案，并不能从根本上解决问题，这也从侧面反应了编译模型的健壮性是相对较差的。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;拓展性&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;说完了健壮性的问题，我们来看看拓展性的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Apple 公司对它们的 Mail App 做过一个分析，下图是 Mail 这个项目里所有 &lt;/span&gt;&lt;code&gt;&lt;span&gt;.m&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件的排序，横轴是文件编号排序，纵轴是文件大小。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;337&quot; data-ratio=&quot;0.646875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyQMhbIY7HYMgRR0vIMVJfp74kerl5NjxYurGLVEf3zARwaEicmm70FZg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;p&gt;&lt;span&gt;可以看到这些由业务代码构成的文件大小的分布区间很广泛，最小可能有几 kb，最大的能有 200+ kb，但总的来说，可能 90% 的代码都在 50kb 这个数量级之下，甚至更少。&lt;/span&gt;&lt;/p&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果我们往该项目的某个核心文件（&lt;/span&gt;&lt;span&gt;核心文件是指其他文件可能都需要依赖的文件&lt;/span&gt;&lt;span&gt;）里添加了一个对 &lt;/span&gt;&lt;code&gt;&lt;span&gt;iAd.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件的引用，对其他文件意味着什么呢？&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;这里的核心文件是指其他文件可能都需要依赖的文件。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这意味着其他文件也会把 &lt;/span&gt;&lt;code&gt;&lt;span&gt;iAd.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 里包含的东西纳入进来，当然，好消息是，iAd 这个 SDK 自身只有 25KB 左右的大小。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;337&quot; data-ratio=&quot;0.646875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyHsfj0vNbyQUHAtT5RwpZFEr4VrV8S61zSxiaicWZROtoWH1yicpU6PxEA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但你得知道 iAd 还会依赖 UIKit 这样的组件，这可是个 400KB+ 的大家伙。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6474878444084279&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyGjibZSRpfmyv6IpCVBQ9km5EovbRPo6P0G2IdjicueFiatZ4erAFibXJLg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2468&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以，怎么说呢？&lt;/span&gt;&lt;span&gt;在 Mail App 里的所有代码都需要先涵盖这将近 425KB 的头文件内容，即使你的代码只有一行 &lt;/span&gt;&lt;code&gt;&lt;span&gt;hello world&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果你认为这已经让人很沮丧的话，那还有更打击你的消息，因为 UIKit 相比于 macOS 上的 Cocoa 系列大礼包，真的小太多了，Cocoa 系列大礼包可是 UIKit 的 29 倍......&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以如果将这个数据放到上面的图表中，你会发现真正的业务代码在Ffile Size 轴上的比重真的太微不足道了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以这就是拓展性差带来的问题之一！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;很明显，我们不可能用这样的方式引入代码，假设你有 M 个源文件且每个文件会引入 N 个头文件，按照刚才的解释，编译它们的时间就会是 M * N，这是非常可怕的！&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;备注&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：文章里提到的 iAd 组件为 25KB，UIKit 组件约为 400KB， macOS 的 Cocoa 组件是 UIKit 的 29 倍等数据，是 WWDC 2013 Session 404 Advances in Objective-C 里公布的数据，随着功能的不断迭代，以现在的眼光来看，这些数据可能已经偏小，在 WWDC 2018 Session 415 Behind the Scenes of the Xcode Build Process 中提到了 Foundation 组件，它包含的头文件数量大于 800 个，大小已经超过 9MB。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;PCH(PreCompiled Header)是一把双刃剑&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了优化前面提到的问题，一种折中的技术方案诞生了，它就是 PreCompiled Header。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们经常可以看到某些组件的头文件会频繁的出现，例如 UIKit，而这很容易让人联想到一个优化点，我们是不是可以通过某种手段，避免重复编译相同的内容呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而这就是 PCH 为预编译流程带来的改进点！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它的大体原理就是，在我们编译任意 &lt;/span&gt;&lt;code&gt;&lt;span&gt;.m&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件前, 编译器会先对 PCH 里的内容进行预编译，将其变为一种二进制的中间格式缓存起来，便于后续的使用。当开始编译 &lt;/span&gt;&lt;code&gt;&lt;span&gt;.m&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件时，如果需要 PCH 里已经编译过的内容，直接读取即可，无须再次编译。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;虽然这种技术有一定的优势，但实际应用起来，还存在不少的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，它的维护是有一定的成本的，对于大部分历史包袱沉重的组件来说，将项目中的引用关系梳理清楚就十分麻烦，而要在此基础上梳理出合理的 PCH 内容就更加麻烦，同时随着版本的不断迭代，哪些头文件需要移出 PCH，哪些头文件需要移进 PCH 将会变得越来越麻烦。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其次，PCH 会引发命名空间被污染的问题，因为 PCH 引入的头文件会出现在你代码中的每一处，而这可能会是多于的操作，比如 iAd 应当出现在一些与广告相关的代码中，它完全没必要出现在帮助相关的代码中（&lt;/span&gt;&lt;span&gt;也就是与广告无关的逻辑&lt;/span&gt;&lt;span&gt;），可是当你把它放到 PCH 中，就意味组件里的所有地方都会引入 iAd 的代码，包括帮助页面，这可能并不是我们想要的结果！&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;如果你想更深入的了解 PCH 的黑暗面，建议阅读 &lt;/span&gt;&lt;a href=&quot;https://qualitycoding.org/precompiled-header/&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;4 Ways Precompiled Headers Cripple Your Code&lt;/span&gt;&lt;/a&gt;&lt;span&gt; ，里面已经说得相当全面和透彻。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以 PCH 并不是一个完美的解决方案，它能在某些场景下提升编译速度，但也有缺陷！&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Clang Module 的来临！&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了解决前面提到的问题，Clang 提出了 Module 的概念，关于它的介绍可以在 &lt;/span&gt;&lt;a href=&quot;https://clang.llvm.org/docs/Modules.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Clang 官网&lt;/span&gt;&lt;/a&gt;&lt;span&gt; 上找到。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;简单来说，你可以把它理解为一种对组件的描述，包含了对接口（&lt;/span&gt;&lt;span&gt;API&lt;/span&gt;&lt;span&gt;）和实现（&lt;/span&gt;&lt;span&gt;dylib/a&lt;/span&gt;&lt;span&gt;）的描述，同时 Module 的产物是被独立编译出来的，不同的 Module 之间是不会影响的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在实际编译之时，编译器会创建一个全新的空间，用它来存放已经编译过的 Module 产物。如果在编译的文件中引用到某个 Module 的话，系统将优先在这个列表内查找是否存在对应的中间产物，如果能找到，则说明该文件已经被编译过，则直接使用该中间产物，如果没找到，则把引用到的头文件进行编译，并将产物添加到相应的空间中以备重复使用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在这种编译模型下，被引用到的 Module 只会被编译一次，且在运行过程中不会相互影响，这从根本上解决了健壮性和拓展性的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Module 的使用并不麻烦，同样是引用 iAd 这个组件，你只需要这样写即可。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@import&lt;/span&gt; iAd;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在使用层面上，这将等价于以前的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;#import &amp;lt;iAd/iAd.h&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 语句，但是会使用 Clang Module 的特性加载整个 iAd 组件。如果只想引入特定文件（&lt;/span&gt;&lt;span&gt;比如&lt;/span&gt;&lt;code&gt;&lt;span&gt;ADBannerView.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt;），原先的写法是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;#import &amp;lt;iAd/ADBannerView.h.h&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，现在可以写成：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@import&lt;/span&gt; iAd.ADBannerView;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过这种写法会将 iAd 这个组件的 API 导入到我们的应用中，同时这种写法也更符合语义化（&lt;/span&gt;&lt;span&gt;semanitc import&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;虽然这种引入方式和之前的写法区别不大，但它们在本质上还是有很大程度的不同，module 不会“复制粘贴”头文件里的内容，也不会让 &lt;/span&gt;&lt;code&gt;&lt;span&gt;@import&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 所暴露的 API 被开发者本地的上下文篡改，例如前面提到的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;#define readonly 0x01&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此时，如果你觉得前面关于 Clang Module 的描述还是太抽象，我们可以再进一步去探究它工作原理， 而这就会引入一个新的概念—— modulemap。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不论怎样，Module 只是一个对组件的抽象描述罢了，而 modulemap 则是这个描述的具体呈现，它对框架内的所有文件进行了结构化的描述，下面是 UIKit 的 modulemap 文件。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;framework module &lt;span&gt;UIKit&lt;/span&gt; {&lt;br/&gt;  umbrella header &lt;span&gt;&quot;UIKit.h&quot;&lt;/span&gt;&lt;br/&gt;  module * {&lt;span&gt;export&lt;/span&gt; *}&lt;br/&gt;  link framework &lt;span&gt;&quot;UIKit&quot;&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个 Module 定义了组件的 Umbrella  Header 文件（&lt;/span&gt;&lt;span&gt;UIKit.h&lt;/span&gt;&lt;span&gt;），需要导出的子 Module（&lt;/span&gt;&lt;span&gt;所有&lt;/span&gt;&lt;span&gt;），以及需要 Link 的框架名称（&lt;/span&gt;&lt;span&gt;UIKit&lt;/span&gt;&lt;span&gt;），正是通过这个文件，让编译器了解到 Module 的逻辑结构与头文件结构的关联方式。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可能又有人会好奇，为什么我从来没看到过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;@import&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的写法呢?&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这是因为 Xcode 的编译器能够将符合某种格式的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;#import&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 语句自动转换成 Module 识别的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;@import&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 语句，从而避免了开发者的手动修改。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;99&quot; data-ratio=&quot;0.19117647058823528&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyicOwgXdRkf6ZM8RdhDtiab5bcwVpZGOtYrCrleMcCoXRdupDx1BlNjyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1360&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;唯一需要开发者完成的就是开启相关的编译选项。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;189&quot; data-ratio=&quot;0.3625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAylg1KA4T2mMDUdSf490xybic7jrFf1Ty4TQ0Iv3Uw0kzzcibtdtLG3Ekg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于上面的编译选项，需要开发者注意的是:&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;Apple Clang - Language - Modules&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 里 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Enable Module&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 选项是指引用系统库的的时候，是否采用 Module 的形式。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Packaging&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 里的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Defines Module&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是指开发者编写的组件是否采用 Module 的形式。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;说了这么多，我想你应该对 &lt;/span&gt;&lt;code&gt;&lt;span&gt;#import&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、 &lt;/span&gt;&lt;code&gt;&lt;span&gt;pch&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、 &lt;/span&gt;&lt;code&gt;&lt;span&gt;@import&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 有了一定的概念。当然，如果我们深究下去，可能还会有如下的疑问：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对于未开启 Clang Module 特性的组件，Clang 是通过怎样的机制查找到头文件的呢？在查找系统头文件和非系统头文件的过程中，有什么区别么？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对于已开启 Clang Module 特性的组件，Clang 是如何决定编译当下组件的 Module 呢？另外构建的细节又是怎样的，以及如何查找这些 Module 的？还有查找系统的 Module 和非系统的 Module 有什么区别么？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了解答这些问题，我们不妨先动手实践一下，看看上面的理论知识在现实中的样子。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;原来它是这样的&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在前面的章节中，我们将重点放在了原理上的介绍，而在这个章节中，我们将动手看看这些预编译环节的实际样子。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#import&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的样子&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设我们的源码样式如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#import &lt;span&gt;&quot;SQViewController.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#import &lt;span&gt;&amp;lt;SQPod/ClassA.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;@interface&lt;/span&gt; &lt;span&gt;SQViewController&lt;/span&gt; ()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@end&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;@implementation&lt;/span&gt; &lt;span&gt;SQViewController&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;- (&lt;span&gt;void&lt;/span&gt;)viewDidLoad {&lt;br/&gt;    [&lt;span&gt;super&lt;/span&gt; viewDidLoad];&lt;br/&gt;    ClassA *a = [ClassA new];&lt;br/&gt;    &lt;span&gt;NSLog&lt;/span&gt;(&lt;span&gt;@&quot;%@&quot;&lt;/span&gt;, a);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;- (&lt;span&gt;void&lt;/span&gt;)didReceiveMemoryWarning {&lt;br/&gt;    [&lt;span&gt;super&lt;/span&gt; didReceiveMemoryWarning];&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;想要查看代码预编译后的样子，我们可以在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Navigate to Related Items&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 按钮中找到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Preprocess&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 选项。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;358&quot; data-ratio=&quot;0.6875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyDkibByHvmhEdgOdZmFwF7E6wePNteE7iayZTicRIOAKTYzR9hTVgiaCmcQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;p&gt;&lt;span&gt;既然知道了如何查看预编译后的样子，我们不妨看看代码在使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;#import&lt;/span&gt;&lt;/code&gt;&lt;span&gt;, PCH 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;@import&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 后，到底会变成什么样子？&lt;/span&gt;&lt;/p&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里我们假设被引入的头文件，即 ClassA 中的内如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;@interface&lt;/span&gt; &lt;span&gt;ClassA&lt;/span&gt; : &lt;span&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@property&lt;/span&gt; (&lt;span&gt;nonatomic&lt;/span&gt;, &lt;span&gt;strong&lt;/span&gt;) &lt;span&gt;NSString&lt;/span&gt; *name;&lt;br/&gt;- (&lt;span&gt;void&lt;/span&gt;)sayHello;&lt;br/&gt;&lt;span&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过 preprocess 可以看到代码大致如下，这里为了方便展示，将无用代码进行了删除。这里记得要将 Build Setting 中 Packaging 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Define Module&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 设置为 NO，因为其默认值为 YES，而这会导致我们开启 Clang Module 特性。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@import&lt;/span&gt; &lt;span&gt;UIKit&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;@interface&lt;/span&gt; &lt;span&gt;SQViewController&lt;/span&gt; : &lt;span&gt;UIViewController&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@end&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;@interface&lt;/span&gt; &lt;span&gt;ClassA&lt;/span&gt; : &lt;span&gt;NSObject&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@property&lt;/span&gt; (&lt;span&gt;nonatomic&lt;/span&gt;, &lt;span&gt;strong&lt;/span&gt;) &lt;span&gt;NSString&lt;/span&gt; *name;&lt;br/&gt;- (&lt;span&gt;void&lt;/span&gt;)sayHello;&lt;br/&gt;&lt;span&gt;@end&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;@interface&lt;/span&gt; &lt;span&gt;SQViewController&lt;/span&gt; ()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@end&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;@implementation&lt;/span&gt; &lt;span&gt;SQViewController&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;- (&lt;span&gt;void&lt;/span&gt;)viewDidLoad {&lt;br/&gt;    [&lt;span&gt;super&lt;/span&gt; viewDidLoad];&lt;br/&gt;    ClassA *a = [ClassA new];&lt;br/&gt;    &lt;span&gt;NSLog&lt;/span&gt;(&lt;span&gt;@&quot;%@&quot;&lt;/span&gt;, a);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;- (&lt;span&gt;void&lt;/span&gt;)didReceiveMemoryWarning {&lt;br/&gt;    [&lt;span&gt;super&lt;/span&gt; didReceiveMemoryWarning];&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这么一看，&lt;/span&gt;&lt;code&gt;&lt;span&gt;#import&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的作用还就真的是个 Copy &amp;amp; Write。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;PCH&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; 的真容&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于 CocoaPods 默认创建的组件，一般都会关闭 PCH 的相关功能，例如笔者创建的 SQPod 组件，它的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Precompile Prefix Header&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 功能默认值为 NO。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;84&quot; data-ratio=&quot;0.16015625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAye9DbU3gb5Tic7TguG1Ggh7JkHxUwOxiauFfpcXEz5M7iclSewibFauyjhA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了查看预编译的效果，我们将 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Precompile Prefix Header&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的值改为 YES，并编译整个项目，通过查看 Build Log，我们可以发现相比于 NO 的状态，在编译的过程中，增加了一个步骤，即 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Precompile SQPod-Prefix.pch&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的步骤。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;621&quot; data-ratio=&quot;1.1929824561403508&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyGUeHA4RkxBCBUF3JlBxduITvDz03fnCPzrAOLLiazXGsvbHKfdK7gxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1596&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过查看这个命令的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-o&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 参数，我们可以知道其产物是名为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SQPod-Prefix.pch.gch&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的文件。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;1&quot; data-cropselx2=&quot;522&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;142&quot; data-ratio=&quot;0.27421875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyk0rWymXVMsichgLfc9ia4n6C2np5QLdQM7yIia6MlWeETLHWLEo4xhU4A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个文件就是 PCH 预编译后的产物，同时在编译真正的代码时，会通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-include&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 参数将其引入。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;493&quot; data-ratio=&quot;0.9473684210526315&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAySXeYkB4pXHu3KRWXdhV4OITsz5ia9YI0HEZv5offfS7f8WiafdSGft2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1596&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;又见 Clang Module&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在开启 Define Module 后，系统会为我们自动创建相应的 modulemap 文件，这一点可以在 Build Log 中查找到。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;67&quot; data-ratio=&quot;0.1265625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyLWzvDs2pWr0Jun7icY2hWicXfYgOpHjGO92I8c1wFSGavNwuOh3L3NdQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它的内容如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;framework module SQPod {&lt;br/&gt;  umbrella header &lt;span&gt;&quot;SQPod-umbrella.h&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;export&lt;/span&gt; *&lt;br/&gt;  module * { &lt;span&gt;export&lt;/span&gt; * }&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然，如果系统自动生成的 modulemap 并不能满足你的诉求，我们也可以使用自己创建的文件，此时只需要在 Build Setting 的 Module Map File 选项中填写好文件路径，相应的 Clang 命令参数是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-fmodule-map-file&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;1&quot; data-cropselx2=&quot;522&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;96&quot; data-ratio=&quot;0.1841704718417047&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAy30dOqwHyV45GOFaObZcar3E4od8H7D1AEAial8ly8OgDpia73Vh9WK7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1314&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后让我们看看 Module 编译后的产物形态。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里我们构建一个名为 SQPod 的 Module ，将它提供给名为 Example 的工程使用，通过查看 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-fmodule-cache-path&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的参数，我们可以找到 Module 的缓存路径。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;543&quot; data-ratio=&quot;1.0432569974554708&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyEgYl11pNjGiaf1IEombUDMU5ua2hddYlVj1Q8PkNtAVHgOvnSoGlV7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1572&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;进入对应的路径后，我们可以看到如下的文件：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;90&quot; data-ratio=&quot;0.171875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyue61BGybj2KsLedlnLgFL9lE0j7OWiazoJfG5N1kpt9VKtFZBiaxrbEg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其中后缀名为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;pcm&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的文件就是构建出来的二进制中间产物。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在，我们不仅知道了预编译的基础理论知识，也动手查看了预编译环节在真实环境下的产物，现在我们要开始解答之前提到的两个问题了！&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;打破砂锅问到底&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关于第一个问题&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;对于未开启 Clang Module 特性的组件，Clang 是通过怎样的机制查找到头文件的呢？在查找系统头文件和非系统头文件的过程中，有什么区别么？&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在早期的 Clang 编译过程中，头文件的查找机制还是基于 Header Search Path 的，这也是大多数人所熟知的工作机制，所以我们不做赘述，只做一个简单的回顾。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;Header Search Path&lt;/span&gt; 是构建系统提供给编译器的一个重要参数，它的作用是在编译代码的时候，为编译器提供了查找相应头文件路径的信息，通过查阅 Xcode 的 Build System 信息，我们可以知道相关的设置有三处 Header Search Path、System Header Search Path、User Header Search Path。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;118&quot; data-ratio=&quot;0.22578125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyh6ao7ZElcMrhO4Be2kPVqicFs3aNkZnAyy92Wuo2iaNJPDiaVU79Fwbeg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它们的区别也很简单，System Header Search Path 是针对系统头文件的设置，通常代指 &lt;/span&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方式引入的文件，User Header Search Path 则是针对非系统头文件的设置，通常代指 &lt;/span&gt;&lt;code&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方式引入的文件，而 Header Search Path 并不会有任何限制，它普适于任何方式的头文件引用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;听起来好像很复杂，但关于引入的方式，无非是以下四种形式：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#import &lt;span&gt;&amp;lt;A/A.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#import &lt;span&gt;&quot;A/A.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#import &lt;span&gt;&amp;lt;A.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#import &lt;span&gt;&quot;A.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们可以两个维度去理解这个问题，一个是引入的符号形式，另一个是引入的内容形式。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;引入的符号形式&lt;/strong&gt;：&lt;/span&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1044360/import-using-angle-brackets-and-quote-marks&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;通常来说&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，双引号的引入方式(&lt;/span&gt;&lt;code&gt;&lt;span&gt;“A.h”&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 或者 &lt;/span&gt;&lt;code&gt;&lt;span&gt;&quot;A/A.h&quot;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;)是用于查找本地的头文件，需要指定相对路径，尖括号的引入方式(&lt;/span&gt;&lt;code&gt;&lt;span&gt;&amp;lt;A.h&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 或者 &lt;/span&gt;&lt;code&gt;&lt;span&gt;&amp;lt;A/A.h&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;)是全局的引用，其路径由编译器提供，如引用系统的库，但随着 Header Search Path 的加入，让这种区别已经被淡化了。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;引入的内容形式&lt;/strong&gt;：对于 &lt;/span&gt;&lt;code&gt;&lt;span&gt;X/X.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;X.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 这两种引入的内容形式，前者是说在对应的 Search Path 中，找到目录 A 并在 A 目录下查找 &lt;/span&gt;&lt;code&gt;&lt;span&gt;A.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，而后者是说在 Search Path 下查找 &lt;/span&gt;&lt;code&gt;&lt;span&gt;A.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件，而不一定局限在 A 目录中，至于是否递归的寻找则取决于对目录的选项是否开启了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;recursive&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 模式。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;179&quot; data-ratio=&quot;0.34271099744245526&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyR61svGkemjRyfwC9hrJf3lCxlicDBIhaUYcJgeWmEeOSXRzcko2knqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1173&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在很多工程中，尤其是基于 CocoaPods 开发的项目，我们已经不会区分 System Header Search Path 和 User Header Search Path，而是一股脑的将所有头文件路径添加到 Header Search Path 中，这就导致我们在引用某个头文件时，不会再局限于前面提到的约定，甚至在某些情况下，前面提到的四种方式都可以做到引入某个指定头文件。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Header Maps&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;随着项目的迭代和发展，原有的头文件索引机制还是受到了一些挑战，为此，Clang 官方也提出了自己的解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了理解这个东西，我们首先要在 Build Setting 中开启 Use Header Map 选项。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;83&quot; data-ratio=&quot;0.07421875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyM8rGCJWwSTd4oJrzjscLDPmS5ttGI9Cia9xgSPGatdSxprVzKXEgJeA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然后在 Build Log 里获取相应组件里对应文件的编译命令，并在最后加上 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-v&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 参数，来查看其运行的秘密：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ clang &amp;lt;list of arguments&amp;gt; -c SQViewController.m -o SQViewcontroller.o -v&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 console 的输出内容中，我们会发现一段有意思的内容：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;241&quot; data-ratio=&quot;0.4622425629290618&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAy5FQictIibJshuI5Z5ibzzFEpSFwjia3ubrgsq6Rxg15AibTcW86Tr82eCPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1748&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过上面的图，我们可以看到编译器将寻找头文件的顺序和对应路径展示出来了，而在这些路径中，我们看到了一些陌生的东西，即后缀名为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;.hmap&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的文件。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那 hmap 到底这是个什么东西呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当我们开启 Build Setting 中的 Use Header Map 选项后，会自动生成的一份头文件名和头文件路径的映射表，而这个映射表就是 hmap 文件，不过它是一种二进制格式的文件，也有人叫它为 Header Map。总之，它的核心功能就是让编译器能够找到相应头文件的位置。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了更好的理解它，我们可以通过 milend 编写的小工具 &lt;/span&gt;&lt;a href=&quot;https://github.com/milend/hmap&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;hmap&lt;/span&gt;&lt;/a&gt;&lt;span&gt; 来查其内容。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在执行相关命令（&lt;/span&gt;&lt;span&gt;即&lt;/span&gt;&lt;code&gt;&lt;span&gt;hmap print&lt;/span&gt;&lt;/code&gt;&lt;span&gt;）后，我们可以发现这些 hmap 里保存的信息结构大致如下：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;106&quot; data-ratio=&quot;0.203125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyeh7D1vicqRY8nyQlnY7HChFxbzJsiaBIDlQPlqicHwqG05z06QPqphb4A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;需要注意，映射表的键值并不是简单的文件名和绝对路径，它的内容会随着使用场景产生不同的变化，例如头文件引用是在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;&quot;...&quot;&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的形式，还是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;&amp;lt;...&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的形式，又或是在 Build Phase 里 Header 的配置情况。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;124&quot; data-ratio=&quot;0.23984375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyzZoeGDxSJwxE7ibFZdmnJoicjaso0iaZSKHOj0vPmicB6sjtfCFNwXLetA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;p&gt;&lt;span&gt;至此，我想你应该明白了，一旦开启 Use Header Map 选项后，Xcode 会优先去 hmap 映射表里寻找头文件的路径，只有在找不到的情况下，才会去 Header Search Path 中提供的路径遍历搜索。&lt;/span&gt;&lt;/p&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然这种技术也不是一个什么新鲜事儿，在 Facebook 的 &lt;/span&gt;&lt;a href=&quot;https://buck.build/&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;buck&lt;/span&gt;&lt;/a&gt;&lt;span&gt; 工具中也提供了类似的东西，只不过文件类型变成了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;HeaderMap.java&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的样子。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;查找系统库的头文件&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面的过程让我们理解了在 Header Map 技术下，编译器是如何寻找相应的头文件的，那针对系统库的文件又是如何索引的呢？例如 &lt;/span&gt;&lt;code&gt;&lt;span&gt;#import &amp;lt;Foundation/Foundation.h&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;回想一下上一节 console 的输出内容，它的形式大概如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;include &lt;span&gt;&quot;...&quot;&lt;/span&gt; search starts here:&lt;/span&gt;&lt;br/&gt;XXX-generated-files.hmap (headermap)&lt;br/&gt;XXX-project-headers.hmap (headermap)&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt;include &amp;lt;...&amp;gt; search starts here:&lt;/span&gt;&lt;br/&gt;XXX-own-target-headers.hmap (headermap)&lt;br/&gt;XXX-all-target-headers.hmap (headermap) &lt;br/&gt;Header Search Path &lt;br/&gt;DerivedSources&lt;br/&gt;Build/Products/Debug (framework directory)&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;(SDKROOT)/usr/include &lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;(SDKROOT)/System/Library/Frameworks(framework directory)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们会发现，这些路径大部分是用于查找非系统库文件的，也就是开发者自己引入的头文件，而与系统库相关的路径只有以下两个：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;include &amp;lt;...&amp;gt; search starts here:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;(SDKROOT)/usr/include &lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;(SDKROOT)/System/Library/Frameworks.(framework directory)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当我们查找 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Foundation/Foundation.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 这个文件的时候，我们会首先判断是否存在 Foundation 这个 Framework。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;SDKROOT/System/Library/Frameworks/Foundation.framework&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接着，我们会进入 Framework 的 Headers 文件夹里寻找对应的头文件。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;SDKROOT/System/Library/Frameworks/Foundation.framework/Headers/Foundation.h&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果没有找到对应的文件，索引过程会在此中断，并结束查找。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以上便是系统库的头文件搜索逻辑。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Framework Search Path&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;到现在为止，我们已经解释了如何依赖 Header Search Path、hmap 等技术寻找头文件的工作机制，也介绍了寻找系统库（&lt;/span&gt;&lt;span&gt;System Framework&lt;/span&gt;&lt;span&gt;）头文件的工作机制。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那这是全部头文件的搜索机制么？答案是否定的，其实我们还有一种头文件搜索机制，它是基于 Framework 这种文件结构进行的。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;1&quot; data-cropselx2=&quot;522&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;63&quot; data-ratio=&quot;0.121875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyeVhlb1aCkr0UeibYbibdwnldGWXZXpjDD8kWTIP2MCURhOiaO0QzSJsjg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于开发者自己的 Framework，可能会存在 &quot;private&quot; 头文件，例如在 podspec 里用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;private_header_files&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的描述文件，这些文件在构建的时候，会被放在 Framework 文件结构中的 PrivateHeaders 目录。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以针对有 PrivateHeaders 目录的 Framework 而言，Clang 在检查 Headers 目录后，会去 PrivateHeaders 目录中寻找是否存在匹配的头文件，如果这两个目录都没有，才会结束查找。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;SDKROOT/System/Library/Frameworks/Foundation.framework/PrivateHeaders/SecretClass.h&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不过也正是因为这个工作机制，会产生一个特别有意思的问题，那就是当我们使用 Framework 的方式引入某个带有 &quot;Private&quot; 头文件的组件时，我们总是可以以下面的方式引入这个头文件！&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;128&quot; data-ratio=&quot;0.24598930481283424&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyX8QkeGtVmawpKZEgDpP8Q77RvpGq7vlyoOdfljoM7903fS2tptPYlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2618&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;怎么样，是不是很神奇，这个被描述为 &quot;Private&quot; 的头文件怎么就不私有了？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;究其原因，还是由于 Clang 的工作机制，那为什么 Clang 要设计出来这种看似很奇怪的工作机制呢？&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;揭开 Public、Private、Project 的真实面目&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实你也看到，我在上一段的写作中，将所有 Private 单词标上了双引号，其实就是在暗示，我们曲解了 Private 的含义。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么这个 &quot;Private&quot; 到底是什么意思呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 Apple 官方的 &lt;/span&gt;&lt;a href=&quot;https://help.apple.com/xcode/mac/current/#/dev50bab713d&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Xcode Help - What are build phases?&lt;/span&gt;&lt;/a&gt;&lt;span&gt; 文档中，我们可以看到如下的一段解释：&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;Associates public, private, or project header files with the target. Public and private headers define API intended for use by other clients, and are copied into a product for installation. For example, public and private headers in a framework target are copied into Headers and PrivateHeaders subfolders within a product. Project headers define API used and built by a target, but not copied into a product. This phase can be used once per target.&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总的来说，我们可以知道一点，就是 Build Phases - Headers 中提到 Public 和 Private 是指可以供外界使用的头文件，且分别放在最终产物的 Headers 和 PrivateHeaders 目录中，而 Project 中的头文件是不对外使用的，也不会放在最终的产物中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果你继续翻阅一些资料，例如 &lt;/span&gt;&lt;a href=&quot;https://stackoverflow.com/questions/7439192/xcode-copy-headers-public-vs-private-vs-project&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;StackOverflow - Xcode: Copy Headers: Public vs. Private vs. Project?&lt;/span&gt;&lt;/a&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;a href=&quot;https://stackoverflow.com/questions/10584936/understanding-xcodes-copy-headers-phase/18910393#18910393&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;StackOverflow - Understanding Xcode&#x27;s Copy Headers phase&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，你会发现在早期 Xcode Help 的 Project Editor 章节里，有一段名为 Setting the Role of a Header File 的段落，里面详细记载了三个类型的区别。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Public&lt;/strong&gt;: The interface is finalized and meant to be used by your product’s clients. A public header is included in the product as readable source code without restriction.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Private&lt;/strong&gt;: The interface isn’t intended for your clients or it’s in early stages of development. A private header is included in the product, but it’s marked “private”. Thus the symbols are visible to all clients, but clients should understand that they&#x27;re not supposed to use them.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Project&lt;/strong&gt;: The interface is for use only by implementation files in the current project. A project header is not included in the target, except in object code. The symbols are not visible to clients at all, only to you.&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;至此，我们应该彻底了解了 Public、Private、Project 的区别。简而言之，Public 还是通常意义上的 Public，Private 则代表 In Progress 的含义，至于 Project 才是通常意义上的 Private 含义。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么 CocoaPods 中 Podspec 的 Syntax 里还有 &lt;/span&gt;&lt;code&gt;&lt;span&gt;public_header_files&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;private_header_files&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 两个字段，它们的真实含义是否和 Xcode 里的概念冲突呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里我们仔细阅读一下&lt;/span&gt;&lt;a href=&quot;https://guides.cocoapods.org/syntax/podspec.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;官方文档的解释&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，尤其是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;private_header_files&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 字段。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;376&quot; data-ratio=&quot;0.7203125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyBSwLKDOw9cb4akHfbynqupc2iayVIgKpjJZicNBL4ibmN8DDbXVUWGLwQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们可以看到，&lt;/span&gt;&lt;code&gt;&lt;span&gt;private_header_files&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 在这里的含义是说，它本身是相对于 Public 而言的，这些头文件本义是不希望暴露给用户使用的，而且也不会产生相关文档，但是在构建的时候，会出现在最终产物中，只有既没有被 Public 和 Private 标注的头文件，才会被认为是真正的私有头文件，且不出现在最终的产物里。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实这么看来，CocoaPods 对于 Public 和 Private 的理解是和 Xcode 中的描述一致的，两处的 Private 并非我们通常理解的 Private，它的本意更应该是开发者准备对外开放，但又没完全 Ready 的头文件，更像一个 In Progress 的含义。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以，如果你真的不想对外暴露某些头文件，请不要再使用 Headers 里的 Private 或者 podspec 里的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;private_header_files&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;至此，我想你应该彻底理解了 Search Path 的搜索机制和略显奇怪的 Public、Private、Project 设定了！&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基于 hmap 优化 Search Path 的策略&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在查找系统库的头文件的章节中，我们通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-v&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 参数看到了寻找头文件的搜索顺序：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;include &lt;span&gt;&quot;...&quot;&lt;/span&gt; search starts here:&lt;/span&gt;&lt;br/&gt;XXX-generated-files.hmap (headermap)&lt;br/&gt;XXX-project-headers.hmap (headermap)&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt;include &amp;lt;...&amp;gt; search starts here:&lt;/span&gt;&lt;br/&gt;XXX-own-target-headers.hmap (headermap)&lt;br/&gt;XXX-all-target-headers.hmap (headermap) &lt;br/&gt;Header Search Path &lt;br/&gt;DerivedSources&lt;br/&gt;Build/Products/Debug (framework directory)&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;(SDKROOT)/usr/include &lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;(SDKROOT)/System/Library/Frameworks(framework directory)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设，我们没有开启 hmap 的话，所有的搜索都会依赖 Header Search Path 或者 Framework Search Path，那这就会出现 3 种问题：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一个问题，在一些巨型项目中，假设依赖的组件有 400+，那此时的索引路径就会达到 800+ 个（&lt;span&gt;一份 Public 路径，一份 Private 路径&lt;/span&gt;），同时搜索操作可以看做是一种 IO 操作，而我们知道 IO 操作通常也是一种耗时操作，那么，这种大量的耗时操作必然会导致编译耗时增加。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二个问题，在打包的过程中，如果 Header Search Path 过多过长，会触发命令行过长的错误，进而导致命令执行失败的情况。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第三个问题，在引入系统库的头文件时，Clang 会将前面提到的目录遍历完才进入搜索系统库的路径，也就是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;$(SDKROOT)/System/Library/Frameworks(framework directory)&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，即前面的 Header Search 路径越多，耗时也会越长，这是相当不划算的。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那如果我们开启 hmap 后，是否就能解决掉所有的问题呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实际上并不能，而且在基于 CocoaPods 管理项目的状况下，又会带来新的问题。下面是一个基于 CocoaPods 构建的全源码工程项目，它的整体结构如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，Host 和 Pod 是我们的两个 Project，Pods 下的 Target 的产物类型为 Static Library。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其次，Host 底下会有一个同名的 Target，而 Pods 目录下会有 n+1 个 Target，其中 n 取决于你依赖的组件数量，而 1 是一个名为 Pods-XXX 的 Target，最后，Pods-XXX 这个 Target 的产物会被 Host 里的 Target 所依赖。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;整个结构看起来如下所示：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;320&quot; data-ratio=&quot;0.615014436958614&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyDqEmYDZmkd6WfxQicuCbkVMOP2To9iahn8FFz3eQUibic45kp8z0YAuMrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2078&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此时我们将 PodA 里的文件全部放在 Header 的 Project 类型中。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;204&quot; data-ratio=&quot;0.39296875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyJ11jZ8rRzWQyHiccgticqUlwicpVUoQeBiaGjffYqBEib6bds2ibOShsS62Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;p&gt;&lt;span&gt;在基于 Framework 的搜索机制下，我们是无法以任何方式引入到 ClassB 的，因为它既不在 Headers 目录，也不在 PrivateHeader 目录中。&lt;/span&gt;&lt;/p&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可是如果我们开启了 Use Header Map 后，由于 PodA 和 PodB 都在 Pods 这个 Project 下，满足了 Header 的 Project 定义，通过 Xcode 自动生成的 hmap 文件会带上这个路径，所以我们还可以在 PodB 中以 &lt;/span&gt;&lt;code&gt;&lt;span&gt;#import &quot;ClassB.h&quot;&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的方式引入。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而这种行为，我想应该是大多数人并不想要的结果，所以一旦开启了 Use Header Map，再结合 CocoaPods 管理工程项目的模式，我们极有可能会产生一些误用私有头文件的情况，而这个问题的本质是 Xcode 和 CocoaPods 在工程和头文件上的理念冲突造成的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;除此之外，CocoaPods 在处理头文件的问题上还有一些让人迷惑的地方，它在创建头文件产物这块的逻辑大致如下：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在构建产物为 Framework 的情况下&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;根据 podspec 里的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;public_header_files&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 字段的内容，将相应头文件设置为 Public 类型，并放在 Headers 中。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;根据 podspec 里的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;private_header_files&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 字段的内容，将相应文件设置为 Private 类型，并放在 PrivateHeader 中。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将其余未描述的头文件设置为 Project 类型，且不放入最终的产物中。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果 podspec 里未标注 Public 和 Private 的时候，会将所有文件设置为 Public 类型，并放在 Header 中。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在构建产物为 Static Library 的情况下&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;不论 podspec 里如何设置 &lt;/span&gt;&lt;code&gt;&lt;span&gt;public_header_files&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;private_header_files&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，相应的头文件都会被设置为 Project 类型。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Pods/Headers/Public&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中会保存所有被声明为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;public_header_files&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的头文件。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Pods/Headers/Private&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中会保存所有头文件，不论是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;public_header_files&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 或者 &lt;/span&gt;&lt;code&gt;&lt;span&gt;private_header_files&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 描述到，还是那些未被描述的，这个目录下是当前组件的所有头文件全集。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果 podspec 里未标注 Public 和 Private 的时候，&lt;/span&gt;&lt;code&gt;&lt;span&gt;Pods/Headers/Public&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Pods/Headers/Private&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的内容一样且会包含所有头文件。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;正是由于这种机制，还导致了另外一种有意思的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 Static Library 的状况下，一旦我们开启了 Use Header Map，结合组件里所有头文件的类型为 Project 的情况，这个 hmap 里只会包含 &lt;/span&gt;&lt;code&gt;&lt;span&gt;#import &quot;A.h&quot;&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的键值引用，也就是说只有 &lt;/span&gt;&lt;code&gt;&lt;span&gt;#import &quot;A.h&quot;&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的方式才会命中 hmap 的策略，否则都将通过 Header Search Path 寻找其相关路径。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而我们也知道，在引用其他组件的时候，通常都会采用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;#import &amp;lt;A/A.h&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的方式引入。至于为什么会用这种方式，一方面是这种写法会明确头文件的由来，避免问题，另一方面也是这种方式可以让我们在是否开启 Clang Module 中随意切换，当然还有一点就是，Apple 在 WWDC 里曾经不止一次建议开发者使用这种方式来引入头文件。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接着上面的话题来说，所以说在 Static Library 的情况下且以 &lt;/span&gt;&lt;code&gt;&lt;span&gt;#import &amp;lt;A/A.h&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 这种标准方式引入头文件时，开启 Use Header Map 并不会提升编译速度，而这同样是 Xcode 和 CocoaPods 在工程和头文件上的理念冲突造成的。&lt;/span&gt;&lt;/p&gt;&lt;span&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;176&quot; data-ratio=&quot;0.35&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyKpicjRUSbcvNhYDVAfxN02wXKEY62aIS0ylypiadH5exxdHUV5Mlgq6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/span&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样来看的话，虽然 hmap 有种种优势，但是在 CocoaPods 的世界里显得格格不入，也无法发挥自身的优势。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那这就真的没有办法解决了么？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然，问题是有办法解决的，我们完全可以自己动手做一个基于 CocoaPods 规则下的 hmap 文件。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;举一个简单的例子，通过遍历 PODS 目录里的内容去构建索引表内容，借助 &lt;/span&gt;&lt;a href=&quot;https://github.com/milend/hmap&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;hmap&lt;/span&gt;&lt;/a&gt;&lt;span&gt; 工具生成 Header Map 文件，然后将 Cocoapods 在 Header Search Path 中生成的路径删除，只添加一条指向我们自己生成的 hmap 文件路径，最后关闭 Xcode 的 Ues Header Map 功能，也就是 Xcode 自动生成 hmap 的功能，如此这般，我们就实现了一个简单的，基于 CocoaPods 的 Header Map 功能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同时在这个基础上，我们还可以借助这个功能实现不少管控手段，例如：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从根本上杜绝私有文件被暴露的可能性。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;统一头文件的引用形式。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;...&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;目前，我们已经自研了一套基于上述原理的 cocoapods 插件，它的名字叫做 cocoapods-hmap-prebuilt，是由笔者与同事共同开发的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;说了这么多，让我们看看它在实际工程中的使用效果！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;经过全源码编译的测试，我们可以看到该技术在提速上的收益较为明显，以美团和点评 App 为例，全链路时长能够提升 45% 以上，其中 Xcode 打包时间能提升 50%。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关于第二个问题&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;对于已开启 Clang Module 特性的组件，Clang 是如何决定编译当下组件的 Module 呢？另外构建的细节又是怎样的，以及如何查找这些 Module 的？还有查找系统的 Module 和非系统的 Module 有什么区别么？&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，我们来明确一个问题， Clang 是如何决定编译当下组件的 Module 呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以 &lt;/span&gt;&lt;code&gt;&lt;span&gt;#import &amp;lt;Foundation/NSString.h&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 为例，当我们遇到这个头文件的时候：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先会去 Framework 的 Headers 目录下寻找相应的头文件是否存在，然后就会到 Modules 目录下查找 modulemap 文件。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;286&quot; data-ratio=&quot;0.5477707006369427&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAysgQTSBok3yVLaicbfEJv0hxedbiaVL0KOxrQET4vr5CUbSyibsvy8DUicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;942&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此时，Clang 会去查阅 modulemap 里的内容，看看 NSString 是否为 Foundation 这个 Module 里的一部分。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Module Map - Foundation.framework/Modules/module.modulemap&lt;br/&gt;framework module Foundation [extern_c] [system] {&lt;br/&gt;    umbrella header &lt;span&gt;&quot;Foundation.h&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;export&lt;/span&gt; *&lt;br/&gt;    module * {&lt;br/&gt;        &lt;span&gt;export&lt;/span&gt; *&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    explicit module NSDebug {&lt;br/&gt;        header &lt;span&gt;&quot;NSDebug.h&quot;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;export&lt;/span&gt; *&lt;br/&gt;    }&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;很显然，这里通过 Umbrella Header，我们是可以在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Foundation.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中找到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;NSString.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;// Foundation.h&lt;/span&gt;&lt;br/&gt;…&lt;br/&gt;&lt;span&gt;#import &lt;span&gt;&amp;lt;Foundation/NSStream.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#import &lt;span&gt;&amp;lt;Foundation/NSString.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#import &lt;span&gt;&amp;lt;Foundation/NSTextCheckingResult.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;…&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;至此，Clang 会判定 &lt;/span&gt;&lt;code&gt;&lt;span&gt;NSString.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是 Foundation 这个 Module 的一部分并进行相应的编译工作，此时也就意味着 &lt;/span&gt;&lt;code&gt;&lt;span&gt;#import &amp;lt;Foundation/NSString.h&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 会从之前的 textual import 变为 module import。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Module 的构建细节&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面的内容解决了是否构建 Module，而这一块我们会详细阐述构建 Module 的过程！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在构建开始前，Clang 会创建一个完全独立的空间来构建 Module，在这个空间里会包含 Module 涉及的所有文件，除此之外不会带入其他任何文件的信息，而这也是 Module 健壮性好的关键因素之一。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不过，这并不意味着我们无法影响到 Module 的唯一性，真正能影响到其唯一性的是其构建的参数，也就是 Clang 命令后面的内容，关于这一点后面还会继续展开，这里我们先点到为止。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当我们在构建 Foundation 的时候，我们会发现 Foundation 自身要依赖一些组件，这意味着我们也需要构建被依赖组件的 Module。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;131&quot; data-ratio=&quot;0.2518568534773801&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyErP9QVerLkDdcCfdpbRaufDiczj7snVJ1bpCWyerD5kkhicTlAx0hpyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2962&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但很明显的是，我们会发现这些被依赖组件也有自己的依赖关系，在它们的这些依赖关系中，极有可能会存在重复的引用。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;214&quot; data-ratio=&quot;0.41188386225523294&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyptibycYLsAMSh50XZkY4AVFpAXAI2BDPCvTetGRZGTVo2kqtwz7bEHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2962&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此时，Module 的复用机制就体现出来优势了，我们可以复用先前构建出来的 Module，而不必一次次的创建或者引用，例如 Drawin 组件，而保存这些缓存文件的位置就是前面章节里提到的保存 &lt;/span&gt;&lt;code&gt;&lt;span&gt;pcm&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 类型文件的地方。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;先前我们提到了 Clang 命令的参数会真正影响到 Module 的唯一性，那具体的原理又是怎样的？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Clang 会将相应的编译参数进行一次 Hash，将获得的 Hash 值作为 Module 缓存文件夹的名称，这里需要注意的是，不同的参数和值会导致文件夹不同，所以想要尽可能的利用 Module 缓存，就必须保证参数不发生变化。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$ clang -fmodules —DENABLE_FEATURE=1 …&lt;br/&gt;&lt;span&gt;## 生成的目录如下&lt;/span&gt;&lt;br/&gt;98XN8P5QH5OQ/&lt;br/&gt;  CoreFoundation-2A5I5R2968COJ.pcm&lt;br/&gt;  Security-1A229VWPAK67R.pcm&lt;br/&gt;  Foundation-1RDF848B47PF4.pcm&lt;br/&gt;  &lt;br/&gt;$ clang -fmodules —DENABLE_FEATURE=2 …&lt;br/&gt;&lt;span&gt;## 生成的目录如下&lt;/span&gt;&lt;br/&gt;1GYDULU5XJRF/&lt;br/&gt;  CoreFoundation-2A5I5R2968COJ.pcm&lt;br/&gt;  Security-1A229VWPAK67R.pcm&lt;br/&gt;  Foundation-1RDF848B47PF4.pcm&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里我们大概了解了系统组件的 Module 构建机制，这也是开启 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Enable Modules(C and Objective-C)&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的核心工作原理。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;神秘的 Virtual File System（VFS）&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于系统组件，我们可以在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator14.2.sdk/System/Library/Frameworks&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 目录里找到它的身影，它的目录结构大概是这样的：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;110&quot; data-ratio=&quot;0.2109375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyn79uruoslWuX6tJ50vO7al125d36KJok7lZSiauYoibsJRUgMMCgX1jQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;也就是说，对于系统组件而言，构建 Module 的整个过程是建立在这样一个完备的文件结构上，即在 Framework 的 Modules 目录中查找 modulemap，在 Headers 目录中加载头文件。&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那对于用户自己创建的组件，Clang 又是如何构建 Module 的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通常我们的开发目录大概是下面的样子，它并没有 Modules 目录，也没有 headers 目录，更没有 modulemap 文件，看起来和 Framework 的文件结构也有着极大的区别。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;196&quot; data-ratio=&quot;0.3752012882447665&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAy37vVEKGrQc0dYCPicibjZo9Zya7ptOR9UET3cOynYhWcEYicxMrL3KzKg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1242&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在这种情况下，Clang 是没法按照前面所说的机制去构建 Module 的，因为在这种文件结构中，压根就没有 Modules 和 Headers 目录。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了解决这个问题，Clang 又提出了一个新的解决方案，叫做 Virtual File System（&lt;/span&gt;&lt;span&gt;VFS&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;简单来说，通过这个技术，Clang 可以在现有的文件结构上虚拟出来一个 Framework 文件结构，进而让 Clang 遵守前面提到的构建准则，顺利完成 Module 的编译，同时 VFS 也会记录文件的真实位置，以便在出现问题的时候，将文件的真实信息暴露给用户。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了进一步了解 VFS，我们还是从 Build Log 中查找一些细节！&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;218&quot; data-ratio=&quot;0.4176470588235294&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyoYuJpZE2twgwtiaJSalflhxicAxgsK3Zlcd4WAZDDxZhH1VvQDEkEa0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2380&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在上面的编译参数里，我们可以找到一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-ivfsoverlay&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的参数，查看 Help 说明，可以知道其作用就是向编译器传递一个 VFS 描述文件并覆盖掉真实的文件结构信息。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;-ivfsoverlay &amp;lt;value&amp;gt;    Overlay the virtual filesystem described by file over the real file system&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;顺着这个线索，我们去看看这个参数指向的文件，它是一个 yaml 格式的文件，在将内容进行了一些裁剪后，它的核心内容如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;case-sensitive&quot;:&lt;/span&gt; &lt;span&gt;&quot;false&quot;,&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;version&quot;:&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;roots&quot;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&quot;name&quot;:&lt;/span&gt; &lt;span&gt;&quot;XXX/Debug-iphonesimulator/PodA/PodA.framework/Headers&quot;,&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&quot;type&quot;:&lt;/span&gt; &lt;span&gt;&quot;directory&quot;,&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&quot;contents&quot;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;{&lt;/span&gt; &lt;span&gt;&quot;name&quot;:&lt;/span&gt; &lt;span&gt;&quot;ClassA.h&quot;,&lt;/span&gt; &lt;span&gt;&quot;type&quot;:&lt;/span&gt; &lt;span&gt;&quot;file&quot;,&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&quot;external-contents&quot;:&lt;/span&gt; &lt;span&gt;&quot;XXX/PodA/PodA/Classes/ClassA.h&quot;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;},&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;......&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;{&lt;/span&gt; &lt;span&gt;&quot;name&quot;:&lt;/span&gt; &lt;span&gt;&quot;PodA-umbrella.h&quot;,&lt;/span&gt; &lt;span&gt;&quot;type&quot;:&lt;/span&gt; &lt;span&gt;&quot;file&quot;,&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&quot;external-contents&quot;:&lt;/span&gt; &lt;span&gt;&quot;XXX/Target Support Files/PodA/PodA-umbrella.h&quot;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;},&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&quot;contents&quot;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;name&quot;:&lt;/span&gt; &lt;span&gt;&quot;XXX/Products/Debug-iphonesimulator/PodA/PodA.framework/Modules&quot;,&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&quot;type&quot;:&lt;/span&gt; &lt;span&gt;&quot;directory&quot;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;{&lt;/span&gt; &lt;span&gt;&quot;name&quot;:&lt;/span&gt; &lt;span&gt;&quot;module.modulemap&quot;,&lt;/span&gt; &lt;span&gt;&quot;type&quot;:&lt;/span&gt; &lt;span&gt;&quot;file&quot;,&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&quot;external-contents&quot;:&lt;/span&gt; &lt;span&gt;&quot;XXX/Debug-iphonesimulator/PodA.build/module.modulemap&quot;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;结合前面提到的内容，我们不难看出它在描述这样一个文件结构：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;借用一个真实存在的文件夹来模拟 Framework 里的 Headers 文件夹，在这个 Headers 文件夹里有名为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;PodA-umbrella.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;ClassA.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 等的文件，不过这几个虚拟文件与 &lt;/span&gt;&lt;code&gt;&lt;span&gt;external-contents&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 指向的真实文件相关联，同理还有 Modules 文件夹和它里面的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;module.modulemap&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过这样的形式，一个虚拟的 Framework 目录结构诞生了！此时 Clang 终于能按照前面的构建机制为用户创建 Module 了！&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Swift 来了&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;没有头文件的 Swift&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前面的章节，我们聊了很多 C 语言系的预编译知识，在这个体系下，文件的编译是分开的，当我们想引用其他文件里的内容时，就必须引入相应的头文件。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;256&quot; data-ratio=&quot;0.49140625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyx6W6ViahV9WAgPufZfpss2gbt682Qux681mnd5tVmcn4YRQQz8z0g1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而对于 Swift 这门语言来说，它并没有头文件的概念，对于开发者而言，这确实省去了写头文件的重复工作，但这也意味着，编译器会进行额外的操作来查找接口定义并需要持续关注接口的变化！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了更好的解释 Swift 和 Objective-C 是如何寻找到彼此的方法声明的，我们这里引入一个例子，在这个例子由三个部分组成：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一部分是一个 ViewController 的代码，它里面包含了一个 View，其中 PetViewController 和 PetView 都是 Swift 代码。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二部分是一个 App 的代理，它是 Objective-C 代码。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第三个部分是一段单测代码，用来测试第一个部分中的 ViewController，它是 Swift 代码。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;import&lt;/span&gt; UIKit&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PetViewController&lt;/span&gt;: &lt;span&gt;UIViewController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; view = &lt;span&gt;PetView&lt;/span&gt;(name: &lt;span&gt;&quot;Fido&quot;&lt;/span&gt;, frame: frame)&lt;br/&gt;  …&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#import &lt;span&gt;&quot;PetWall-Swift.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;@implementation&lt;/span&gt; &lt;span&gt;AppDelegate&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;…&lt;br/&gt;&lt;span&gt;@end&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;@testable&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; PetWall&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestPetViewController&lt;/span&gt;: &lt;span&gt;XCTestCase&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;它们的关系大致如下所示：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;172&quot; data-ratio=&quot;0.3297350343473994&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyAmd5Z13MdJibXjUlD2Ept3VicqibXSFXU1eryLIyK3MnQpXH8luG3qwaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2038&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了能让这些代码编译成功，编译器会面对如下 4 个场景：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先是寻找声明，这包括寻找当前 Target 内的方法声明（&lt;/span&gt;&lt;span&gt;PetView&lt;/span&gt;&lt;span&gt;），也包括来自 Objective-C 组件里的声明（&lt;/span&gt;&lt;span&gt;UIViewController 或者 PetKit&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然后是生成接口，这包括被 Objective-C 使用的接口，也包括被其他 Target (&lt;/span&gt;&lt;span&gt;Unit Test&lt;/span&gt;&lt;span&gt;）使用的 Swift 接口。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第一步 - 如何寻找 Target 内部的 Swift 方法声明&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在编译 &lt;/span&gt;&lt;code&gt;&lt;span&gt;PetViewController.swift&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 时，编译器需要知道 PetView 的初始化构造器的类型，才能检查调用是否正确。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此时，编译器会加载 &lt;/span&gt;&lt;code&gt;&lt;span&gt;PetView.swift&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件并解析其中的内容, 这么做的目的就是确保初始化构造器真的存在，并拿到相关的类型信息，以便 &lt;/span&gt;&lt;code&gt;&lt;span&gt;PetViewController.swift&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 进行验证。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;291&quot; data-ratio=&quot;0.5588235294117647&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyEQXTO5DaRmPDibgO4JbS0sDic5h1OgAyYzEuzdtbCiciaH8tlYKoeSYcqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1326&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;编译器并不会对初始化构造器的内部做检查，但它仍然会进行一些额外的操作，这是什么意思呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;与 Clang 编译器不同的是，Swiftc 编译的时候，会将相同 Target 里的其他 Swift 文件进行一次解析，用来检查其中与被编译文件关联的接口部分是否符合预期。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同时我们也知道，每个文件的编译是独立的，且不同文件的编译是可以并行开展的，所以这就意味着每编译一个文件，就需要将当前 Target 里的其余文件当做接口，重新编译一次。等于任意一个文件，在整个编译过程中，只有 1 次被作为生产 &lt;/span&gt;&lt;code&gt;&lt;span&gt;.o&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 产物的输入，其余时间会被作为接口文件反复解析。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;437&quot; data-ratio=&quot;0.8391551584077985&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyn9G5MbpVQ9LAlbWn4H1Ew0oc5DjwI90ztcBvaOkBW7qNSCcM3icktSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2462&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不过在 Xcode 10 以后，Apple 对这种编译流程进行了优化。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在尽可能保证并行的同时，将文件进行了分组编译，这样就避免了 Group 内的文件重复解析，只有不同 Group 之间的文件会有重复解析文件的情况。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;394&quot; data-ratio=&quot;0.7567765567765568&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAy4nedFMqtascJMqcfVLTR0ttE9cvSXRLEUa7LKJwq9JKJdqicAMtHszg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2730&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而这个分组操作的逻辑，就是刚才提到的一些额外操作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;至此，我们应该了解了 Target 内部是如何寻找 Swift 方法声明的了。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第二步 - 如何找到 Objective-C 组件里的方法声明&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;回到第一段代码中，我们可以看到 PetViewController 是继承自 UIViewController，而这也意味着我们的代码会与 Objective-C 代码进行交互，因为大部分系统库，例如 UIKit 等，还是使用 Objective-C 编写的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在这个问题上，Swift 采用了和其他语言不一样的方案！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通常来说，两种不同的语言在混编时需要提供一个接口映射表，例如 JavaScript 和 TypeScript 混编时候的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;.d.ts&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件，这样 TypeScript 就能够知道 JavaScript 方法在 TS 世界中的样子。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然而，Swift 不需要提供这样的接口映射表, 免去了开发者为每个 Objective-C API 声明其在 Swift 世界里样子，那它是怎么做到的呢?&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;很简单，Swift 编译器将 Clang 的大部分功能包含在其自身的代码中，这就使得我们能够以 Module 的形式，直接引用 Objective-C 的代码。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;324&quot; data-ratio=&quot;0.6235595390524968&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyo2MA6H2OpYTCEV1GK9DZvqlFf3cfVYXK7X68q6G3T7HmqF7kOGItHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1562&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;既然是通过 Module 的形式引入 Objective-C，那么 Framework 的文件结构则是最好的选择，此时编译器寻找方法声明的方式就会有下面三种场景：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;对于大部分的 Target 而言，当导入的是一个 Objective-C 类型的 Framework 时，编译器会通过 modulemap 里的 Header 信息寻找方法声明。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;对于一个既有 Objective-C，又有 Swift 代码的 Framework 而言，编译器会从当前 Framework 的 Umbrella Header 中寻找方法声明，从而解决自身的编译问题，这是因为通常情况下 modulemap 会将 Umbrella Header 作为自身的 Header 值。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;对于 App 或者 Unit Test 类型的 Target，开发者可以通过为 Target 创建 Briding Header 来导入需要的 Objective-C 头文件，进而找到需要的方法声明。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不过我们应该知道 Swift 编译器在获取 Objective-C 代码过程中，并不是原原本本的将 Objective-C 的 API 暴露给 Swift，而是会做一些 ”Swift 化” 的改动，例如下面的 Objective-C API 就会被转换成更简约的形式。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;119&quot; data-ratio=&quot;0.22868217054263565&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAytiabWmDADott9uAWJZibHmS4ILsWfxILuczR8o55WHLKDfGfDRBqbwAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;4128&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个转换过程并不是什么高深的技术，它只是在编译器上的硬编码，如果感兴趣，可以在 Swift 的开源库中的找到相应的代码 - &lt;/span&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/apple/swift/blob/main/lib/Basic/PartsOfSpeech.def&quot; data-linktype=&quot;2&quot;&gt;PartsOfSpeech.def&lt;/a&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然，编译器也给与了开发者自行定义 “API 外貌” 的权利，如果你对这一块感兴趣，不妨阅读笔者的另一篇文章 - &lt;/span&gt;&lt;a href=&quot;https://sketchk.xyz/2020/07/02/WWDC20-10680-Refine-Objective-C-frameworks-for-Swift/&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;WWDC20 10680 - Refine Objective-C frameworks for Swift&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，那里面包含了很多重塑 Objective-C API 的技巧。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不过这里还是要提一句，如果你对生成的接口有困惑，可以通过下面的方式查看编译器为 Objective-C 生成的 Swift 接口。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;444&quot; data-ratio=&quot;0.8534621578099839&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyDKHyDl4f6xR0OKs3AxUWTBn4rJbQ1WrJAjUoASctOmDLSDyF0IR7jg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1242&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第三步 - Target 内的 Swift 代码是如何为 Objective-C 提供接口的&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前面讲了 Swift 代码是如何引用 Objective-C 的 API，那么 Objective-C 又是如何引用 Swift 的 API 呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从使用层面来说，我们都知道 Swift 编译器会帮我们自动生成一个头文件，以便 Objective-C 引入相应的代码，就像第二段代码里引入的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;PetWall-Swift.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件，这种头文件通常是编译器自动生成的，名字的构成是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;组件名-Swift&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的形式。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;154&quot; data-ratio=&quot;0.29699666295884314&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyPiciaVa6EuYJdTN8jWLDLkLbMFJzdYerxiaLzsjOB61Roiax8w4wqm6LKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3596&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但它到底是怎么产生的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 Swift 中，如果某个类继承了 NSObject 类且 API 被 &lt;/span&gt;&lt;code&gt;&lt;span&gt;@objc&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 关键字标注，就意味着它将暴露给 Objective-C 代码使用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不过对于 App 和 Unit Test 类型的 Target 而言，这个自动生成的 Header 会包含访问级别为 Public 和 internal 的 API，这使得同一 Target 内的 Objective-C 代码也能访问 Swift 里 internal 类型的 API，这也是所有 Swift 代码的默认访问级别。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但对于 Framework 类型的 Target 而言，Swift 自动生成的头文件只会包含 Public 类型的 API，因为这个头文件会被作为构建产物对外使用，所以像 internal 类型的 API 是不会包含在这个文件中。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;注意，这种机制会导致在 Framework 类型的 Target 中，如果 Swift 想暴露一些 API 给内部的 Objective-C 代码使用，就意味着这些 API 也必须暴露给外界使用，即必须将其访问级别设置为 Public。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么编译器自动生成的 API 到底是什么样子，有什么特点呢？&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;150&quot; data-ratio=&quot;0.2872512103281334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyuHtzVfTpDnt2icnM8x6aNlcFVCZUNLAn1Pju2EqftOk4lIFeeAXLw5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3718&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面是截取了一段自动生成的头文件代码，左侧是原始的 Swift 代码，右侧是自动生成的 Objective-C 代码，我们可以看到在 Objective-C 的类中，有一个名为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SWIFT_CLASS&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的宏，将 Swift 与 Objective-C 中的两个类进行了关联。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果你稍加注意，就会发现关联的一段乱码中还绑定了当前的组件名（&lt;/span&gt;&lt;span&gt;PetWall&lt;/span&gt;&lt;span&gt;），这样做的目的是避免两个组件的同名类在运行时发生冲突。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然，你也可以通过向 &lt;/span&gt;&lt;code&gt;&lt;span&gt;@objc(Name)&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 关键字传递一个标识符，借由这个标识符来控制其在 Objective-C 中的名称，如果这样做的话，需要开发者确保转换后的类名不与其他类名出现冲突。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;146&quot; data-ratio=&quot;0.2792887029288703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAy7nc07w1icQU4snxKvogZ9ywxlrG6KTHnCw5Ku5uSeoIDw7x5cL8libhg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3824&quot;/&gt;&lt;p&gt;&lt;span&gt;这大体上就是 Swift 如何像 Objective-C 暴露接口的机理了，如果你想更深入的了解这个文件的由来，就需要看看第四步。&lt;/span&gt;&lt;/p&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第四步 - Swift Target 如何生成供外部 Swift 使用的接口&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Swift 采用了 Clang Module 的理念，并结合自身的语言特性进行了一系列的改进。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 Swift 中，Module 是方法声明的分发单位，如果你想引用相应的方法，就必须引入对应的 Module，之前我们也提到了 Swift 的编译器包含了 Clang 的大部分内容，所以它也是兼容 Clang Module 的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以我们可以引入 Objective-C 的 Module，例如 XCTest，也可以引入 Swift Target 生成的 Module，例如 PetWall。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;import&lt;/span&gt; XCTest&lt;br/&gt;&lt;span&gt;@testable&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; PetWall&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestPetViewController&lt;/span&gt;: &lt;span&gt;XCTestCase&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;testInitialPet&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; controller = &lt;span&gt;PetViewController&lt;/span&gt;()&lt;br/&gt;    &lt;span&gt;XCTAssertEqual&lt;/span&gt;(controller.view.name, &lt;span&gt;&quot;Fido&quot;&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在引入 Swift 的 Module 后，编译器会反序列化一个后缀名为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;.swiftmodule&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的文件，并通过这种文件里的内容来了解相关接口的信息。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例如，以下图为例，在这个单元测试中，编译器会加载 PetWall 的 Module，并在其中找寻 PetViewController 的方法声明，由此确保其创建行为是符合预期的。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;168&quot; data-ratio=&quot;0.3226987447698745&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyqicPOQpflQxQ1B56nwlr4TBDsP5wt2jWqn91CQo4QYR4ZAKRHnfkPAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3824&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这看起来很像第一步中 Target 寻找内部 Swift 方法声明的样子，只不过这里将解析 Swift 文件的步骤，换成了解析 Swiftmodule 文件而已。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不过需要注意的是，这个 Swfitmodule 文件并不是文本文件，它是一个二进制格式的内容，通常我们可以在构建产物的 Modules 文件夹里寻找到它的身影。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;99&quot; data-ratio=&quot;0.190625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAytXjiahBVezDUAAMJgEffEtq5ZibHSK1CbCGRUgsicBibFu5VThOReLKtqg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;p&gt;&lt;span&gt;在 Target 的编译的过程中，面向整个 Target 的 Swiftmodule 文件并不是一下产生的，每一个 Swift 文件都会生成一个 Swiftmodule 文件，编译器会将这些文件进行汇总，最后再生成一个完整的，代表整个 Target 的 Swiftmodule，也正是基于这个文件，编译器构造出了用于给外部使用的 Objective-C 头文件，也就是第三步里提到的头文件。&lt;/span&gt;&lt;/p&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;321&quot; data-ratio=&quot;0.61640625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAybp35b1nc94IWic8oF1cria2jec6BC1A9JczIKFaMcxY7N5DCSgicj1eSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不过随着 Swift 的发展，这一部分的工作机制也发生了些许变化。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们前面提到的 Swiftmodule 文件是一种二进制格式的文件，而这个文件格式会包含一些编译器内部的数据结构，不同编译器产生的 Swiftmodule 文件是互相不兼容的，这也就导致了不同 Xcode 构建出的产物是无法通用的，如果对这方面的细节感兴趣，可以阅读 Swift 社区里的两篇官方 Blog：&lt;/span&gt;&lt;a href=&quot;https://swift.org/blog/abi-stability-and-apple/&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Evolving Swift On Apple Platforms After ABI Stability&lt;/span&gt;&lt;/a&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;a href=&quot;https://swift.org/blog/abi-stability-and-more/&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;ABI Stability and More&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，这里就不展开讨论了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了解决这一问题，Apple 在 Xcode 11 的 Build Setting 中提供了一个新的编译参数 Build Libraries for Distribution，正如这个编译参数的名称一样，当我们开启它后，构建出来的产物不会再受编译器版本的影响，那它是怎么做到这一点的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了解决这种对编译器的版本依赖，Xcode 在构建产物上提供了一个新的产物，Swiftinterface 文件。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;99&quot; data-ratio=&quot;0.1890625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAytfHuibkXQdtT4JMHcYXOZdHMJBRGyf149tR0AqEicyBKZ9lakPcowBKg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;这个文件里的内容和 Swiftmodule 很相似，都是当前 Module 里的 API 信息，不过 Swiftinterface 是以文本的方式记录，而非 Swiftmodule 的二进制方式。&lt;/span&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这就使得 Swiftinterface 的行为和源代码一样，后续版本的 Swift 编译器也能导入之前编译器创建的 Swiftinterface 文件，像使用源码的方式一样使用它。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了更进一步了解它，我们来看看 Swiftinterface 的真实样子，下面是一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;.swift&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;.swiftinterface&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件的比对图。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;404&quot; data-ratio=&quot;0.7765625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAymYiaG9hcTm7D4kEVszKvLcruLsv6stC90eHgPDzR8nzkzWvTHJ22R1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;在 Swiftinterface 文件中，有以下点需要注意：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;文件会包含一些元信息，例如文件格式版本，编译器信息，和 Swift 编译器将其作为模块导入所需的命令行子集。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;文件只会包含 Public 的接口，而不会包含 Private 的接口，例如 currentLocation。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;文件只会包含方法声明，而不会包含方法实现，例如 Spacesship 的 init、fly 等方法。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;文件会包含所有隐式声明的方法，例如 Spacesship 的 deinit 方法 ，Speed 的 Hashable 协议。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总的来说，Swiftinterface 文件会在编译器的各个版本中保持稳定，主要原因就是这个接口文件会包含接口层面的一切信息，不需要编译器再做任何的推断或者假设。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;好了，至此我们应该了解了 Swift Target 是如何生成供外部 Swift 使用的接口了。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这四步意味着什么？&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此 Module 非彼 Module&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过上面的例子，我想大家应该能清楚的感受到 Swift Module 和 Clang Module 不完全是一个东西，虽然它们有很多相似的地方。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Clang Module 是面向 C 语言家族的一种技术，通过 modulemap 文件来组织 &lt;/span&gt;&lt;code&gt;&lt;span&gt;.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件中的接口信息，中间产物是二进制格式的 pcm 文件。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Swift Module 是面向 Swift 语言的一种技术，通过 Swiftinterface 文件来组织 &lt;/span&gt;&lt;code&gt;&lt;span&gt;.swift&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件中的接口信息，中间产物二进制格式的 Swiftmodule 文件。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;346&quot; data-ratio=&quot;0.6633663366336634&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyo2BZfwg7GdchiaLo0J5UDfZhb9TYdMQ9UpfxXaBlqcJh4dI1uMkrVkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2020&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以说理清楚这些概念和关系后，我们在构建 Swift 组件的产物时，就会知道哪些文件和参数不是必须的了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例如当你的 Swift 组件不想暴露自身的 API 给外部的 Objective-C 代码使用的话，可以将 Build Setting 中 Swift Compiler - General 里的 Install Objective-C Compatiblity Header 参数设置为 NO，其编译参数为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SWIFT_INSTALL_OBJC_HEADER&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，此时不会生成 &lt;/span&gt;&lt;code&gt;&lt;span&gt;&amp;lt;ProductModuleName&amp;gt;-Swift.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 类型的文件，也就意味着外部组件无法以 Objective-C 的方式引用组件内 Swift 代码的 API。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;1&quot; data-cropselx2=&quot;522&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;61&quot; data-ratio=&quot;0.11640625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAygYqsGqibNanUjajWAsRUw8LvUgeVcnBBAQKoUT1KtcF2hDSFIzib4Egw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而当你的组件里如果压根就没有 Objective-C 代码的时候，你可以将 Build Setting 中 Packaging 里 Defines Module 参数设置为 NO，它的编译参数为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;DEFINES_MODULE&lt;/span&gt;&lt;/code&gt;&lt;span&gt;, 此时不会生成 &lt;/span&gt;&lt;code&gt;&lt;span&gt;&amp;lt;ProductModuleName&amp;gt;.modulemap&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 类型的文件。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;51&quot; data-ratio=&quot;0.0984375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAytlgBqicXphRbdL2gMtbGCTXb1XJvwHnB0muicmG1xAjDAxJTeSX0AiaaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Swift 和 Objective-C 混编的三个“套路”&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基于刚才的例子，我们应该理解了 Swift 在编译时是如何找到其他 API 的，以及它又是如何暴露自身 API 的，而这些知识就是解决混编过程中的基础知识，为了加深影响，我们可以将其绘制成 3 个流程图。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当 Swift 和 Objective-C 文件同时在一个 App 或者 Unit Test 类型的 Target 中，不同类型文件的 API 寻找机制如下：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;309&quot; data-ratio=&quot;0.5939130434782609&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyiaiaOcAA7SGw02icv9PpulzmXBIX9Sw3eG4wEgk1n4CEzQFvNC4KXbyWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2300&quot;/&gt;&lt;p&gt;&lt;span&gt;当 Swift 和 Objective-C 文件在不同 Target 中，例如不同 Framework 中，不同类型文件的 API 寻找机制如下：&lt;/span&gt;&lt;/p&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;309&quot; data-ratio=&quot;0.5939130434782609&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyQPX3vm3ia6LWcTpGCqrz0APgBzicDsEXQiaGzfHh0wuw2PiaIKic28BLEmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2300&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当 Swift 和 Objective-C 文件同时在一个 Target 中，例如同一 Framework 中，不同类型文件的 API 寻找机制如下：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;297&quot; data-ratio=&quot;0.5701168614357263&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAygG2mGqxoNribibQeM35Ym9aicezuoqkwMfe7WCMRl9ib0LrFx1Ucs1bfFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2396&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于第三个流程图，需要做以下补充说明：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;由于 Swiftc，也就是 Swift 的编译器，包含了大部分的 Clang 功能，其中就包含了 Clang Module，借由组件内已有的 modulemap 文件，Swift 编译器就可以轻松找到相应的 Objective-C 代码。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;相比于第二个流程而言，第三个流程中的 modulemap 是组件内部的，而第二个流程中，如果想引用其他组件里的 Objective-C 代码，需要引入其他组件里的 modulemap 文件才可以。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;所以基于这个考虑，并未在流程 3 中标注 modulemap。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;构建 Swift 产物的新思路&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在前面的章节里，我们提到了 Swift 找寻 Objective-C 的方式，其中提到了，除了 App 或者 Unit Test 类型的 Target 外，其余的情况下都是通过 Framework 的 Module Map 来寻找 Objective-C 的 API，那么如果我们不想使用 Framework 的形式呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;目前来看，这个在 Xcode 中是无法直接实现的，原因很简单，Build Setting 中 Search Path 选项里并没有 modulemap 的 Search Path 配置参数。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;187&quot; data-ratio=&quot;0.35859375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAyMqV5o6aIZ4VqoBRf4gQondXUxRg22CgMHQVLxCicickjG9ZLKpibUbZ9w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么一定需要 modulemap 的 Search Path 呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基于前面了解到的内容，Swiftc 包含了 Clang 的大部分逻辑，在预编译方面，Swiftc 只包含了 Clang Module 的模式，而没有其他模式，所以 Objective-C 想要暴露自己的 API 就必须通过 modulemap 来完成。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而对于 Framework 这种标准的文件夹结构，modulemap 文件的相对路径是固定的，它就在 Modules 目录中，所以 Xcode 基于这种标准结构，直接内置了相关的逻辑，而不需要将这些配置再暴露出来。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从组件的开发者角度来看，他只需要关心 modulemap 的内容是否符合预期，以及路径是否符合规范。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从组件的使用者角度来看，他只需要正确的引入相应的 Framework 就可以使用到相应的 API。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种只需要配置 Framework 的方式，避免了配置 Header Search Path，也避免了配置 Static Library Path，可以说是一种很友好的方式，如果再将 modulemap 的配置开放出来，反而显得多此一举。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那如果我们抛开 Xcode，抛开 Framework 的限制，还有别的办法构建 Swift 产物么？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案是肯定有的，这就需要借助前面所说的 VFS 技术！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设我们的文件结构如下所示：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;├── LaunchPoint.swift&lt;br/&gt;├── README.md&lt;br/&gt;├── build&lt;br/&gt;├── repo&lt;br/&gt;│   └── MyObjcPod&lt;br/&gt;│       └── UsefulClass.h&lt;br/&gt;└── tmp&lt;br/&gt;    ├── module.modulemap&lt;br/&gt;    └── vfs-overlay.yaml&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其中 &lt;/span&gt;&lt;code&gt;&lt;span&gt;LaunchPoint.swift&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 引用了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;UsefulClass.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中的一个公开 API，并产生了依赖关系。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;另外，&lt;/span&gt;&lt;code&gt;&lt;span&gt;vfs-overlay.yaml&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件重新映射了现有的文件目录结构，其内容如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&#x27;version&#x27;:&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&#x27;roots&#x27;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;{&lt;/span&gt; &lt;span&gt;&#x27;name&#x27;:&lt;/span&gt; &lt;span&gt;&#x27;/MyObjcPod&#x27;,&lt;/span&gt; &lt;span&gt;&#x27;type&#x27;:&lt;/span&gt; &lt;span&gt;&#x27;directory&#x27;,&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&#x27;contents&#x27;:&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;{&lt;/span&gt; &lt;span&gt;&#x27;name&#x27;:&lt;/span&gt; &lt;span&gt;&#x27;module.modulemap&#x27;,&lt;/span&gt; &lt;span&gt;&#x27;type&#x27;:&lt;/span&gt; &lt;span&gt;&#x27;file&#x27;,&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&#x27;external-contents&#x27;:&lt;/span&gt; &lt;span&gt;&#x27;tmp/module.modulemap&#x27;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;},&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;{&lt;/span&gt; &lt;span&gt;&#x27;name&#x27;:&lt;/span&gt; &lt;span&gt;&#x27;UsefulClass.h&#x27;,&lt;/span&gt; &lt;span&gt;&#x27;type&#x27;:&lt;/span&gt; &lt;span&gt;&#x27;file&#x27;,&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;&#x27;external-contents&#x27;:&lt;/span&gt; &lt;span&gt;&#x27;repo/MyObjcPod/UsefulClass.h&#x27;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;]&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;至此，我们通过如下的命令，便可以获得 LaunchPoint 的 Swiftmodule、Swiftinterface 等文件，具体的示例可以查看我在 Github 上的链接 - &lt;/span&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/SketchK/manually-expose-objective-c-API-to-swift-example&quot; data-linktype=&quot;2&quot;&gt;manually-expose-objective-c-API-to-swift-example&lt;/a&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;swiftc -c LaunchPoint.swift -emit-module -emit-module-path build/LaunchPoint.swiftmodule -module-name index -whole-module-optimization -parse-as-library -o build/LaunchPoint.o -Xcc -ivfsoverlay -Xcc tmp/vfs-overlay.yaml -I /MyObjcPod&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那这意味着什么呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这就意味着，只提供相应的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;.modulemap&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 文件就可以完成 Swift 二进制产物的构建，而不再依赖 Framework 的实体。同时，对于 CI 系统来说，在构建产物时，可以避免下载无用的二进制产物（&lt;/span&gt;&lt;code&gt;&lt;span&gt;.a&lt;/span&gt;&lt;/code&gt;&lt;span&gt;文件&lt;/span&gt;&lt;span&gt;），这从某种程度上会提升编译效率。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果你没太理解上面的意思，我们可以展开说说。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例如，对于 PodA 组件而言，它自身依赖 PodB 组件，在使用原先的构建方式时，我们需要拉取 PodB 组件的完整 Framework 产物，这会包含 Headers 目录，Modules 目录里的必要内容，当然还会包含一个二进制文件（&lt;/span&gt;&lt;span&gt;PodB&lt;/span&gt;&lt;span&gt;），但在实际编译 PodA 组件的过程中，我们并不需要 B 组件里的二进制文件，而这让拉取完整的 Framework 文件显得多余了。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;183&quot; data-ratio=&quot;0.35172413793103446&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsUXugA9k4hf3lXmKE0wNcAy2IEIGclnbgCmMw5YG2KQ7070qYqPHfW505x3BLQbOEibmLCRX52On2A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;870&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而借助 VFS 技术，我们就能避免拉取多余的二进制文件，进一步提升 CI 系统的编译效率。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;感谢你的耐心阅读。至此，整篇文章终于结束了，通过这篇文章，我想你应该：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;理解 Objective-C 的三种预编译的工作机制，其中 Clang Module 做到了真正意义上的语义引入，提升了编译的健壮性和扩展性。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在 Xcode 的 Search Path 的各种技术细节使用到了 hmap 技术，通过加载映射表的方式避免了大量重复的 IO 操作，可以提升编译效率。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在处理 Framework 的头文件索引时，总是会先搜索 Headers 目录，再搜索 PrivateHeader 目录。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;理解 Xcode Phases 构建系统中，Public 代表公开头文件，Private 代表不需要使用者感知，但物理存在的文件， 而 Project 代表不应让使用者感知，且物理不存在的文件。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;不使用 Framework 的情况下且以 &lt;/span&gt;&lt;code&gt;&lt;span&gt;#import &amp;lt;A/A.h&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 这种标准方式引入头文件时，在 CocoaPods 上使用 hmap 并不会提升编译速度。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;cocoapods-hmap-built&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 插件，可以将大型项目的全链路时长节省 45% 以上，Xcode 打包环节的时长节省 50% 以上。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Clang Module 的构建机制确保了其不受上下文影响（&lt;/span&gt;&lt;span&gt;独立编译空间&lt;/span&gt;&lt;span&gt;），复用效率高（&lt;/span&gt;&lt;span&gt;依赖决议&lt;/span&gt;&lt;span&gt;），唯一性（&lt;/span&gt;&lt;span&gt;参数哈希化&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;系统组件通过已有的 Framework 文件结构实现了构建 Module 的基本条件 ，而非系统组件通过 VFS 虚拟出相似的 Framework 文件 结构，进而具备了编译的条件。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;可以粗浅的将 Clang Module 里的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;.h/m&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;.moduelmap&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;.pch&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的概念对应为 Swift Module 里的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;.swift&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;.swiftinterface&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;.swiftmodule&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的概念。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;理解三种具有普适性的 Swift 与 Objective-C 混编方法。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;同一 Target 内（&lt;/span&gt;&lt;span&gt;App 或者 Unit 类型&lt;/span&gt;&lt;span&gt;），基于 &lt;/span&gt;&lt;code&gt;&lt;span&gt;&amp;lt;PorductModuleName&amp;gt;-Swift.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;&amp;lt;PorductModuleName&amp;gt;-Bridging-Swift.h&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;同一 Target 内，基于 &lt;/span&gt;&lt;code&gt;&lt;span&gt;&amp;lt;PorductModuleName&amp;gt;-Swift.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 Clang 自身的能力&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;不同 Target 内，基于 &lt;/span&gt;&lt;code&gt;&lt;span&gt;&amp;lt;PorductModuleName&amp;gt;-Swift.h&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;module.modulemap&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;利用 VFS 机制构建，可以在构建 Swift 产物的过程中避免下载无用的二进制产物，进一步提升编译的效率。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考文档&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;思琦，笔名 &lt;/span&gt;&lt;a href=&quot;https://github.com/SketchK&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;SketchK&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，美团点评 iOS 工程师，目前负责移动端 CI/CD 方面的工作及平台内 Swift 技术相关的事宜。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;旭陶，美团 iOS 工程师，目前负责 iOS 端开发提效相关事宜。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;霜叶，2015 年加入美团，先后从事过 Hybrid 容器、iOS 基础组件、iOS 开发工具链和客户端持续集成门户系统等工作。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b557fdb90072c2a47db7b635c8d0d5de</guid>
<title>Arthas 定位 CPU 跑满问题，源头竟是 Apache Beanutils</title>
<link>https://toutiao.io/k/npjfyml</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2&gt;一、背景&lt;/h2&gt;&lt;p&gt;大早上 线上k8s 机子 某个机子 cpu 飙高，导致k8s 健康检查失败，线上环境会自动执行jstack，上传到oss 通知到 钉钉告警群，直接分析锁、cpu 高的线程。&lt;/p&gt;&lt;h2&gt;二、过程分析&lt;/h2&gt;&lt;h3&gt;2.1 排查cpu 占用最高的线程&lt;/h3&gt;&lt;p&gt;使用&lt;code&gt;jstack&lt;/code&gt; 分析:&lt;/p&gt;&lt;p&gt;发现占用CPU最高的线程栈是： &lt;code&gt;org.apache.commons.beanutils.MethodUtils#getMatchingAccessibleMethod&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;当然也可以使用arthas 的 &lt;code&gt;thread -n 10&lt;/code&gt; 命令 ，由于自动监控抓取的，省去了这一步了。&lt;/p&gt;&lt;p&gt;一般的常规操作 jstack+top ，参考：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;https://blog.csdn.net/guixunlong/article/details/8450897&lt;/span&gt;&lt;/p&gt;&lt;p&gt;jstack 、top 文件也可以使用这个网站来分析&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;https://fastthread.io/ft-index.jsp&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.38337801608579086&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0yPC72KnWlev9evHu8T3hbKLCMUVib1btx3uNxOrewmhPgEVkpLbUrWQvhian0TgWBxuYC0gk1qsjXgbhUY6dMVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;746&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;2.2 定位问题线程MethodUtils工具类&lt;/h3&gt;&lt;p&gt;在线程栈里发现 &lt;code&gt;org.apache.commons.beanutils.MethodUtils#getMatchingAccessibleMethod&lt;/code&gt; 异常代码行数和本地 比较对应不上！&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5348525469168901&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0yPC72KnWlev9evHu8T3hbKLCMUVib1btZBOW2PibTJK6iay9nyXCNceicUJaOicsFcBhUsWG9gM17vclOHxBia1Qp6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;746&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;2.3 sc -d 查看当前类来自哪个jar包&lt;/h3&gt;&lt;p&gt;使用Arthas &lt;code&gt;sc&lt;/code&gt;命令搜索发现有两个不同版本jar包，真香🤣。k8s服务器重启了也可以用&lt;code&gt;sc&lt;/code&gt;命令非常方便地定位jar冲突问题。&lt;img data-ratio=&quot;0.4959785522788204&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0yPC72KnWlev9evHu8T3hbKLCMUVib1btnnCISNTfXzLm1d8BPnFZxYebhiaiaUcXtWauXK1pQhwM8XjoJgPNXntw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;746&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h3&gt;2.4 多线程并发问题&lt;/h3&gt;&lt;p&gt;&lt;code&gt;org.apache.commons.beanutils.MethodUtils&lt;/code&gt;实际来自&lt;code&gt;apache-beanutils&lt;/code&gt;依赖：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt; &lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;apache-beanutils&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;commons-beanutils&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;  &lt;br/&gt; &lt;span&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;那么应用里两个不同版本的&lt;code&gt;apache-beanutils&lt;/code&gt;到底哪里冲突了呢？&lt;/p&gt;&lt;h3&gt;1.7 版本&lt;/h3&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt; static WeakHashMap &lt;span&gt;cache&lt;/span&gt; =  &lt;span&gt;new&lt;/span&gt;  WeakHashMap();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;1.9 版本&lt;/h3&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt; static Map&amp;lt;MethodDescriptor, Reference&amp;lt;Method&lt;span&gt;&amp;gt;&amp;gt; &lt;/span&gt;cache = Collections&lt;br/&gt;        ._synchronizedMap&lt;span&gt;_&lt;/span&gt;( new WeakHashMap&amp;lt;MethodDescriptor, Reference&amp;lt;Method&lt;span&gt;&amp;gt;&amp;gt;&lt;/span&gt;());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;那么为什么&lt;code&gt;1.7&lt;/code&gt;版本里的代码有问题呢？&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;线程在WeakHashMap的get方法里面出不来了，一直在while循环里面。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;多线程并发get和put，然后get方法内的while循环一直找不到eq的对象，循环出不来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;参考：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;https://blog.csdn.net/weixin_33693070/article/details/85952993&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;https://www.cnblogs.com/love-jishu/p/4244302.html&lt;/span&gt;&lt;/p&gt;&lt;p&gt;解决办法：排除掉低版本的&lt;code&gt;apache-beanutils&lt;/code&gt;依赖。&lt;/p&gt;&lt;h2&gt;招聘&lt;/h2&gt;&lt;p&gt;我们正在寻找小伙伴，欢迎加入。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;实习生：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MTY2MjE4OQ==&amp;amp;mid=2247484030&amp;amp;idx=1&amp;amp;sn=8c145a63dbff7c476b81e99d99b0605f&amp;amp;chksm=fc7413fccb039aea7c9f930264125d0e53c3082387314a5abfe22d208b152b9e274fe83a53ba&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;阿里云-云原生团队-2022 届春季实习⽣招聘&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;社招请查看之前文章：阿里云-云原生-中间件招聘&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>