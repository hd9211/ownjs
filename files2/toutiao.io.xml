<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>96eadc4a735d167c81cd620a3af88417</guid>
<title>这可能是最轻量高效的运维监控工具：开源 WGCLOUD</title>
<link>https://toutiao.io/k/l55l3jp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>574431334596030377dab76f757b056b</guid>
<title>徒手用 Go 写个 Redis 服务器</title>
<link>https://toutiao.io/k/t9ic9wp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.66640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNPWkD6xmM3YDpLKRk9icwRvyvo6aWc1Pz3duHADKROA748khObVndvFBt9tZwTqMfIKZ876WHEDibww/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;span&gt;作者：HDT3213&lt;br/&gt;&lt;/span&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天给大家带来的开源项目是 Godis：一个用 Go 语言实现的 Redis 服务器。支持：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;5 种数据结构（string、list、hash、set、sortedset）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自动过期（TTL）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发布订阅、地理位置、持久化等功能&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2294736842105263&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNPWkD6xmM3YDpLKRk9icwRvyyIuib3RuttVFnsljC8XwPgicGkL1zibBcKKAhTERZRwKnzEaesYZhcfXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1900&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你或许不需要自己实现 Redis 服务，但你是否厌烦了每天都是写增删改查的业务代码，想提高编程水平试图从零写个项目打开 IDE 却发现无从下手？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;动手造轮子一定是提高编程能力的好办法，下面就带大家用 Go 从零开始写一个 Redis 服务器（Godis），从中你将学到：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如何编写 Go 语言 TCP 服务器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设计并实现安全可靠的通信协议（redis 协议）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何使用 Go 语言开发高并发程序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设计和实现分布式集群以及分布式事务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;熟悉链表、哈希表、跳表以及时间轮等常用数据结构&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;千万不要担心内容太难！！虽然示例代码是 Go，但就算你不会 Go 语言也不会影响你理解 Redis 的原理和底层协议以及高性能的秘密。而且作者为了照顾到广大读者，对技术的讲解做了优化。示例代码在原项目基础上做了简化，并逐行地加了注释。如果是高级玩家，请直接访问项目阅读源码：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;https://github.com/HDT3213/godis&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面让我们一起拨开 Redis 的迷雾。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一、写个 TCP 服务器&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知 Redis 是 C/S 模型，使用 TCP 协议进行通信。接下来就从实现 TCP 服务端开始。作为广泛用于服务端的编程语言 Golang 提供了非常简洁的 TCP 接口，所以实现起来十分方便。示例代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ListenAndServe&lt;/span&gt;&lt;span&gt;(address &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 绑定监听地址&lt;/span&gt;&lt;br/&gt;    listener, err := net.Listen(&lt;span&gt;&quot;tcp&quot;&lt;/span&gt;, address)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        log.Fatal(fmt.Sprintf(&lt;span&gt;&quot;listen err: %v&quot;&lt;/span&gt;, err))&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; listener.Close()&lt;br/&gt;    log.Println(fmt.Sprintf(&lt;span&gt;&quot;bind: %s, start listening...&quot;&lt;/span&gt;, address))&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// Accept 会一直阻塞直到有新的连接建立或者listen中断才会返回&lt;/span&gt;&lt;br/&gt;        conn, err := listener.Accept()&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// 通常是由于listener被关闭无法继续监听导致的错误&lt;/span&gt;&lt;br/&gt;            log.Fatal(fmt.Sprintf(&lt;span&gt;&quot;accept err: %v&quot;&lt;/span&gt;, err))&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 开启新的 goroutine 处理该连接&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;go&lt;/span&gt; Handle(conn)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Handle&lt;/span&gt;&lt;span&gt;(conn net.Conn)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    reader := bufio.NewReader(conn)&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// ReadString 会一直阻塞直到遇到分隔符 &#x27;\n&#x27;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 遇到分隔符后 ReadString 会返回上次遇到分隔符到现在收到的所有数据&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 若在遇到分隔符之前发生异常, ReadString 会返回已收到的数据和错误信息&lt;/span&gt;&lt;br/&gt;        msg, err := reader.ReadString(&lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// 通常遇到的错误是连接中断或被关闭，用io.EOF表示&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; err == io.EOF {&lt;br/&gt;                log.Println(&lt;span&gt;&quot;connection close&quot;&lt;/span&gt;)&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                log.Println(err)&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        b := []&lt;span&gt;byte&lt;/span&gt;(msg)&lt;br/&gt;        &lt;span&gt;// 将收到的信息发送给客户端&lt;/span&gt;&lt;br/&gt;        conn.Write(b)&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    ListenAndServe(&lt;span&gt;&quot;:8000&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;👌 至此只用了 40 行代码就搞定服务端啦！启动上面的 TCP 服务后，在终端中输入 &lt;code&gt;telnet 127.0.0.1 8000&lt;/code&gt; 就可以连接到刚写好的服务器，它会将你发送的消息原样返回给你（所以请不要骂它）：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2675925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNPWkD6xmM3YDpLKRk9icwRvyuibu0TPqyuw0zws5DwMnC0m4dRic0QxoiaqrxVsC3ZxU93z9qGVx6licKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个 TCP 服务器的非常简单，主协程调用 accept 函数来监听端口，接受新连接后开启一个 Goroutine 来处理它。这种简单的阻塞 IO 模型有些类似于早期的 Tomcat/Apache 服务器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阻塞 IO 模型是使用&lt;strong&gt;一个线程处理一个连接&lt;/strong&gt;，在没有收到新数据时监听线程处于阻塞状态，直到数据就绪后线程被唤醒进行处理。因为阻塞 IO 模型需要开启大量线程并且频繁地进行上下文切换，所以它的效率很低。而 Redis 使用的 epoll 技术（IO 多路复用）用&lt;strong&gt;一个线程处理大量连接&lt;/strong&gt;，极大地提高了吞吐量。那么我们的 TCP 服务器会比 Redis 慢很多吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然不会，Golang 利用 Goroutine 调度开销远远小于线程调度开销的优势封装出 &lt;code&gt;goroutine-per-connection&lt;/code&gt; 风格的极简接口，而且 net/tcp 库将 epoll 封装成了阻塞 IO 的样子，在享受 epoll 高性能的同时避免了原生 epoll 接口所需的复杂异步代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在作者的电脑上 Redis 每秒可以响应 10.6k 个 PING 命令，而 Godis（完整代码） 的吞吐量为 9.2 kqps 相差并不大。想了解更多 Golang 高性能的㊙️密，可以搜索 &lt;code&gt;go netpoller&lt;/code&gt; 或者 &lt;code&gt;go 语言 网络轮询器&lt;/code&gt; 关键字&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，合格的 TCP 的服务器在关闭的时候不应该一停了之，而需要完成响应已接收的请求、释放 TCP 连接等必要的清理工作。这个功能我们一般称为 &lt;code&gt;优雅关闭&lt;/code&gt; 或者 &lt;code&gt;graceful shutdown&lt;/code&gt;，优雅关闭步骤：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先，关闭 listener 停止接受新连接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后，遍历所有存活连接逐个关闭&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优雅关闭的代码比较多，这里就不完整贴出了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、透视 Redis 协议&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在解决完通信后，下一步就是搞清楚 Redis 的协议，其实就是一套序列化协议类似 JSON、Protocol Buffers，你看底层其实也就是一些基础的知识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自 Redis 2.0 以后的通信统一为 RESP 协议（REdis Serialization Protocol)，该协议易于实现不仅可以高效的被程序解析，还能够被人类读懂容易调试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RESP 是一个二进制安全的文本协议，工作于 TCP 协议上。RESP 以行作为单位，客户端和服务器发送的命令或数据一律以 &lt;code&gt;\r\n&lt;/code&gt;（CRLF）作为换行符。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二进制安全是指允许协议中出现任意字符而不会导致故障。比如 C 语言的字符串以 &lt;code&gt;\0&lt;/code&gt; 作为结尾不允许字符串中间出现 &lt;code&gt;\0&lt;/code&gt;，而 Go 语言的 string 则允许出现 &lt;code&gt;\0&lt;/code&gt;，我们说 Go 语言的 string 是二进制安全的，而 C 语言字符串不是二进制安全的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RESP 的二进制安全性允许我们在 key 或者 value 中包含 &lt;code&gt;\r&lt;/code&gt; 或者 &lt;code&gt;\n&lt;/code&gt; 这样的特殊字符。在使用 Redis 存储 protobuf、msgpack 等二进制数据时，二进制安全性尤为重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RESP 定义了 5 种格式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;简单字符串（Simple String）：服务器用来返回简单的结果，比如 &quot;OK&quot; 非二进制安全，且不允许换行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;错误信息（Error）：服务器用来返回简单的错误信息，比如 &quot;ERR Invalid Synatx&quot; 非二进制安全，且不允许换行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;整数（Integer）：llen、scard 等命令的返回值，64 位有符号整数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;字符串（Bulk String）：二进制安全字符串，比如 get 等命令的返回值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数组（Array，又称 Multi Bulk Strings）：Bulk String 数组，客户端发送指令以及 lrange 等命令响应的格式&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RESP 通过第一个字符来表示格式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;简单字符串：以&quot;+&quot; 开始， 如：&quot;+OK\r\n&quot;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;错误：以&quot;-&quot; 开始，如：&quot;-ERR Invalid Synatx\r\n&quot;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;整数：以&quot;:&quot;开始，如：&quot;:1\r\n&quot;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;字符串：以 &lt;code&gt;$&lt;/code&gt; 开始&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数组：以 &lt;code&gt;*&lt;/code&gt; 开始&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面让我们通过一些实际例子来理解协议。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 字符串&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字符串（Bulk String）有两行，第一行为 &lt;code&gt;$&lt;/code&gt;+正文长度，第二行为实际内容。如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$3&lt;/span&gt;\r\nSET\r\n&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字符串（Bulk String）是二进制安全的，就是说可以在 Bulk String 内部包含 &quot;\r\n&quot; 字符（行尾的 CRLF 被隐藏）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;$4&lt;/span&gt;&lt;br/&gt;a\r\nb&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 空&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$-1&lt;/code&gt; 表示 nil，比如使用 get 命令查询一个不存在的 key 时，响应即为 &lt;code&gt;$-1&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 数组&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数组（Array）格式第一行为 &quot;*&quot;+数组长度，其后是相应数量的 字符串（Bulk String）。比如 &lt;code&gt;[&quot;foo&quot;, &quot;bar&quot;]&lt;/code&gt; 的报文（传输时的内容）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;*2&lt;br/&gt;&lt;span&gt;$3&lt;/span&gt;&lt;br/&gt;foo&lt;br/&gt;&lt;span&gt;$3&lt;/span&gt;&lt;br/&gt;bar&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端也使用 数组（Array）格式向服务端发送指令。命令本身将作为第一个参数，比如 &lt;code&gt;SET key value&lt;/code&gt; 指令的 RESP 报文：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;*3&lt;br/&gt;&lt;span&gt;$3&lt;/span&gt;&lt;br/&gt;SET&lt;br/&gt;&lt;span&gt;$3&lt;/span&gt;&lt;br/&gt;key&lt;br/&gt;&lt;span&gt;$5&lt;/span&gt;&lt;br/&gt;value&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将换行符打印出来：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$5\r\nvalue\r\n&lt;/code&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 解析预备&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道常用的 RESP 报文内容后，就可以开始着手解析了。但需要注意的是 RESP 是 &lt;code&gt;二进制安全&lt;/code&gt; 的协议，它允许在正文中使用 &lt;code&gt;\r\n&lt;/code&gt; 字符。举例来说 Redis 可以正确接收并执行 &lt;code&gt;SET &quot;a\r\nb&quot; hellogithub&lt;/code&gt; 指令，这条指令的正确报文是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;*3  &lt;br/&gt;&lt;span&gt;$3&lt;/span&gt;&lt;br/&gt;SET&lt;br/&gt;&lt;span&gt;$4&lt;/span&gt;&lt;br/&gt;a\r\nb &lt;br/&gt;&lt;span&gt;$11&lt;/span&gt;&lt;br/&gt;hellogithub&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 &lt;code&gt;ReadBytes&lt;/code&gt; 读取到第五行 &quot;a\r\nb\r\n&quot; 时会将其误认为两行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;*3  &lt;br/&gt;&lt;span&gt;$3&lt;/span&gt;&lt;br/&gt;SET&lt;br/&gt;&lt;span&gt;$4&lt;/span&gt;&lt;br/&gt;a  // 错误的分行&lt;br/&gt;b // 错误的分行&lt;br/&gt;&lt;span&gt;$11&lt;/span&gt;&lt;br/&gt;hellogithub&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此当读取到第四行 &lt;code&gt;$4&lt;/code&gt; 后，不应该继续使用 &lt;code&gt;ReadBytes(&#x27;\n&#x27;)&lt;/code&gt; 读取下一行，应使用 &lt;code&gt;io.ReadFull(reader, msg)&lt;/code&gt; 方法来读取指定长度的内容。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;msg = &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt; + &lt;span&gt;2&lt;/span&gt;) &lt;span&gt;// 正文长度4 + 换行符长度2&lt;/span&gt;&lt;br/&gt;_, err = io.ReadFull(reader, msg)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5 编写 RESP 协议解析器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决完上面内容包含 &quot;\r\n&quot; 的问题，我们就可以开始放手编写 Redis 协议解析器啦！&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Payload &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Data redis.Reply&lt;br/&gt; Err  error&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ParseStream 通过 io.Reader 读取数据并将结果通过 channel 将结果返回给调用者&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 流式处理的接口适合供客户端/服务端使用&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ParseStream&lt;/span&gt;&lt;span&gt;(reader io.Reader)&lt;/span&gt; &amp;lt;-&lt;span&gt;chan&lt;/span&gt; *&lt;span&gt;Payload&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; *Payload)&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; parse0(reader, ch)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; ch&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于解析器的代码比较多，这里只简单地介绍一下核心流程。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;parse0&lt;/span&gt;&lt;span&gt;(reader io.Reader, ch &lt;span&gt;chan&lt;/span&gt;&amp;lt;- *Payload)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// 初始化读取状态&lt;/span&gt;&lt;br/&gt;    readingMultiLine := &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    expectedArgsCount := &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; args [][]&lt;span&gt;byte&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;var&lt;/span&gt; bulkLen &lt;span&gt;int64&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 上文中我们提到 RESP 是以行为单位的&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 因为行分为简单字符串和二进制安全的 BulkString，我们需要封装一个 readLine 函数来兼容&lt;/span&gt;&lt;br/&gt;        line, err = readLine(reader, bulkLen)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; { &lt;br/&gt;            &lt;span&gt;// 处理错误&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 接下来我们对刚刚读取的行进行解析&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 我们简单的将 Reply 分为两类:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 单行: StatusReply, IntReply, ErrorReply&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 多行: BulkReply, MultiBulkReply&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; !readingMultiLine {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; isMulitBulkHeader(line) {&lt;br/&gt;                &lt;span&gt;// 我们收到了 MulitBulkReply 的第一行&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 获得 MulitBulkReply 中 BulkString 的个数&lt;/span&gt;&lt;br/&gt;                expectedArgsCount = parseMulitBulkHeader(line)&lt;br/&gt;                &lt;span&gt;// 等待 MulitBulkReply 后续行&lt;/span&gt;&lt;br/&gt;                readingMultiLine = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; isBulkHeader(line) {&lt;br/&gt;                &lt;span&gt;// 我们收到了 BulkReply 的第一行&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 获得 BulkReply 第二行的长度, 通过 bulkLen 告诉 readLine 函数下一行 BulkString 的长度&lt;/span&gt;&lt;br/&gt;                bulkLen = parseBulkHeader()&lt;br/&gt;                &lt;span&gt;// 这个 Reply 中一共有 1 个 BulkString&lt;/span&gt;&lt;br/&gt;                expectedArgsCount = &lt;span&gt;1&lt;/span&gt; &lt;br/&gt;                &lt;span&gt;// 等待 BulkReply 后续行&lt;/span&gt;&lt;br/&gt;                readingMultiLine = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;// 处理 StatusReply, IntReply, ErrorReply 等单行 Reply&lt;/span&gt;&lt;br/&gt;                reply := parseSingleLineReply(line)&lt;br/&gt;                &lt;span&gt;// 通过 ch 返回结果&lt;/span&gt;&lt;br/&gt;                emitReply(ch)&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;// 进入此分支说明我们正在等待 MulitBulkReply 或 BulkReply 的后续行&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// MulitBulkReply 的后续行有两种，BulkHeader 或者 BulkString&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; isBulkHeader(line) {&lt;br/&gt;                bulkLen = parseBulkHeader()&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;// 我们正在读取一个 BulkString, 它可能是 MulitBulkReply 或 BulkReply &lt;/span&gt;&lt;br/&gt;                args = &lt;span&gt;append&lt;/span&gt;(args, line)&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(args) == expectedArgsCount { &lt;span&gt;// 我们已经读取了所有后续行&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 通过 ch 返回结果&lt;/span&gt;&lt;br/&gt;                emitReply(ch)&lt;br/&gt;                &lt;span&gt;// 重置状态, 准备解析下一条 Reply&lt;/span&gt;&lt;br/&gt;                readingMultiLine = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;                expectedArgsCount = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;                args = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;                bulkLen = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、实现内存数据库&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此我们已经搞定数据接收和解析的部分了，剩下就是我们应该把数据存在哪里了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;抛开持久化部分，作为基于内存的 KV 数据库 Redis 的所有数据需要都存储在内存中的哈希表，而这个哈希表就是我们今天需要编写的最后一个组件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与单线程的 Redis 不同我们实现的 Redis（godis）是并行工作的，所以我们必须考虑各种并发安全问题。常见的并发安全哈希表设计有几种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;sync.map&lt;/code&gt;：Golang 官方提供的并发哈希表，适合读多写少的场景。但是在 &lt;code&gt;m.dirty&lt;/code&gt; 刚被提升后会将 &lt;code&gt;m.read&lt;/code&gt; 复制到新的 &lt;code&gt;m.dirty&lt;/code&gt; 中，在数据量较大的情况下复制操作会阻塞所有协程，存在较大的隐患。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;juc.ConcurrentHashMap&lt;/code&gt;：Java 的并发哈希表采用分段锁实现。在进行扩容时访问哈希表线程都将协助进行 rehash 操作，在 rehash 结束前所有的读写操作都会阻塞。因为缓存数据库中键值对数量巨大且对读写操作响应时间要求较高，使用 juc 的策略是不合适的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;memcached hashtable&lt;/code&gt;：在后台线程进行 rehash 操作时，主线程会判断要访问的哈希槽是否已被 rehash 从而决定操作 old_hashtable 还是操作 new_hashtable。这种设计被称为&lt;strong&gt;渐进式 rehash&lt;/strong&gt; 它的优点是 rehash 操作基本不会阻塞主线程的读写，是最理想的的方案。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但渐进式 rehash 的实现非常复杂，所以 godis 采用 Golang 社区广泛使用的分段锁策略（非上面的三种），就是将 key 分散到固定数量的 shard 中避免进行整体 rehash 操作。shard 是有锁保护的 map，当 shard 进行 rehash 时会阻塞 shard 内的读写，但不会对其他 shard 造成影响。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5855728429985856&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNPWkD6xmM3YDpLKRk9icwRvyAgDiaNQU6ny3uGJqrZIhKlT4MLibuX6BWDeHwaAN5BdbYBs7XRhhawgg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;707&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; ConcurrentDict &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    table []*Shard&lt;br/&gt;    count &lt;span&gt;int32&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Shard &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    m     &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;interface&lt;/span&gt;{}&lt;br/&gt;    mutex sync.RWMutex&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(dict *ConcurrentDict)&lt;/span&gt; &lt;span&gt;spread&lt;/span&gt;&lt;span&gt;(hashCode &lt;span&gt;uint32&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;uint32&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; tableSize := &lt;span&gt;uint32&lt;/span&gt;(&lt;span&gt;len&lt;/span&gt;(dict.table))&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; (tableSize - &lt;span&gt;1&lt;/span&gt;) &amp;amp; &lt;span&gt;uint32&lt;/span&gt;(hashCode)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(dict *ConcurrentDict)&lt;/span&gt; &lt;span&gt;getShard&lt;/span&gt;&lt;span&gt;(index &lt;span&gt;uint32&lt;/span&gt;)&lt;/span&gt; *&lt;span&gt;Shard&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; dict.table[index]&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(dict *ConcurrentDict)&lt;/span&gt; &lt;span&gt;Get&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;(val &lt;span&gt;interface&lt;/span&gt;{}, exists &lt;span&gt;bool&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; hashCode := fnv32(key)&lt;br/&gt; index := dict.spread(hashCode)&lt;br/&gt; shard := dict.getShard(index)&lt;br/&gt; shard.mutex.RLock()&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; shard.mutex.RUnlock()&lt;br/&gt; val, exists = shard.m[key]&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(dict *ConcurrentDict)&lt;/span&gt; &lt;span&gt;Put&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;, val &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;(result &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; dict == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;panic&lt;/span&gt;(&lt;span&gt;&quot;dict is nil&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt; hashCode := fnv32(key)&lt;br/&gt; index := dict.spread(hashCode)&lt;br/&gt; shard := dict.getShard(index)&lt;br/&gt; shard.mutex.Lock()&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; shard.mutex.Unlock()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; _, ok := shard.m[key]; ok {&lt;br/&gt;  shard.m[key] = val&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  shard.m[key] = val&lt;br/&gt;  dict.addCount()&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ConcurrentDict&lt;/code&gt; 可以保证对单个 key 操作的并发安全性，但是仍然无法满足并发安全的需求，举例来说：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Incr 命令需要完成：&lt;code&gt;读取 -&amp;gt; 做加法 -&amp;gt; 写入&lt;/code&gt; 三步操作，读取和写入两步操作不是原子性的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MSETNX 命令当且仅当所有给定键都不存在时所有给定键设置值，我们需要保证「检查多个key是否存在」以及「写入多个key」这两个操作的原子性&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此我们需要实现 &lt;code&gt;db.Locker&lt;/code&gt; 用于锁定一个或一组 key 直到我们完成所有操作后再释放。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现 &lt;code&gt;db.Locker&lt;/code&gt; 最直接的想法是使用一个 &lt;code&gt;map[string]*sync.RWMutex&lt;/code&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;加锁过程分为两步：初始化 mutex -&amp;gt; 加锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;解锁过程也分为两步: 解锁 -&amp;gt; 释放mutex&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么存在一个无法解决的并发问题：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;时间&lt;/th&gt;&lt;th&gt;协程A&lt;/th&gt;&lt;th&gt;协程B&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;locker[&quot;a&quot;].Unlock()&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;locker[&quot;a&quot;] = &amp;amp;sync.RWMutex{}&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;3&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;delete(locker[&quot;a&quot;])&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4&lt;/td&gt;&lt;td&gt;locker[&quot;a&quot;].Lock()&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 t3 时协程 B 释放了锁，t4 时协程 A 试图加锁会失败。若协程B在解锁时不执行 &lt;code&gt;delete(locker[&quot;a&quot;])&lt;/code&gt; 就可以避免该异常的发生，但是这样会造成严重的内存泄露。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们注意到哈希槽的数量远少于 key 的数量，反过来说多个键可以共用一个哈希槽。所以我们不再直接对 key 进行加锁而是锁定 key 所在的哈希槽也可以保证安全，另一方面哈希槽数量较少即使不释放也不会消耗太多内存。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Locks &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    table []*sync.RWMutex&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Make&lt;/span&gt;&lt;span&gt;(tableSize &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; *&lt;span&gt;Locks&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    table := &lt;span&gt;make&lt;/span&gt;([]*sync.RWMutex, tableSize)&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; tableSize; i++ {&lt;br/&gt;        table[i] = &amp;amp;sync.RWMutex{}&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &amp;amp;Locks{&lt;br/&gt;        table: table,&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(locks *Locks)&lt;/span&gt;&lt;span&gt;Lock&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    index := locks.spread(fnv32(key))&lt;br/&gt;    mu := locks.table[index]&lt;br/&gt;    mu.Lock()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(locks *Locks)&lt;/span&gt;&lt;span&gt;UnLock&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    index := locks.spread(fnv32(key))&lt;br/&gt;    mu := locks.table[index]&lt;br/&gt;    mu.Unlock()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在锁定多个 key 时需要注意，若 协程A 持有 键a 的锁试图获得 键b 的锁，此时 协程B 持有 键b 的锁试图获得 键a 的锁则会形成死锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决方法是所有协程都按照相同顺序加锁，若两个协程都想获得 键a 和 键b 的锁，那么必须先获取 键a 的锁后获取 键b 的锁，这样就可以避免循环等待。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到目前为止构建 Redis 服务器所需的基本组件已经备齐，只需要将 TCP 服务器、协议解析器与哈希表组装起来我们的 Redis 服务器就可以开始工作啦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，以上代码均简化自我写的 Godis：一个开源仅用 Go 语言实现的 Redis 服务器。期待您的关注和 Star：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;项目地址：https://github.com/HDT3213/godis&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;四、结束&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多朋友的日常工作主要是编写业务代码，对于框架、数据库、中间件这些“架构”、“底层代码” 有一些恐惧感。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但本文我们只写了 3 个组件，共计几百行代码就实现了一个基本的 Redis 服务器。所以底层的技术并不难，只要你对技术感兴趣由浅入深、从简到繁，“底层代码”也并不神秘。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA5MzYyNzQ0MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOqkqThUJBICyFBlvLvTyOCgBpibwWotSxGExfnOYFfPiaL9yn3GMUOCEVYN2RNslGCdQwgZy6ticdyA/0?wx_fmt=png&quot; data-nickname=&quot;HelloGitHub&quot; data-alias=&quot;GitHub520&quot; data-signature=&quot;分享 GitHub 上有趣、入门级的开源项目。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;兴趣是最好的老师，&lt;strong&gt;HelloGitHub&lt;/strong&gt; 发现编程的乐趣&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f1f493d211a282bb989d3d7f277ec432</guid>
<title>我用 Python 画了一盘粽子送给大家</title>
<link>https://toutiao.io/k/qsz5fkd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIq22XWicwbh9WLklk2X51zvGDY3xRkicCsOhnJT9WlCz1onvvsdWwBQoB0icZfCQh9yIRoic41IXwNWEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg3MzYzNzIxNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/IhkoHbB7IaCFYeyB7a25IMBkibiciaG1PpwH9KrrUhhJBibcWJU3cXBG7NIynR5lWE7srQ6A9Z4mmqcZtPicycxvMDQ/0?wx_fmt=png&quot; data-nickname=&quot;GitHub联盟&quot; data-alias=&quot;GitHubUN&quot; data-signature=&quot;每天分享 GitHub 上有趣、实用的开源项目。内容包括但不限于 Java、Python、Go、前端、数据分析、AI 等。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天是端午节，首先祝大家端午安康，说到端午节，粽子则是必不可少的，现在粽子的种类也是五花八门，但我还是喜欢传统的白棕子，你喜欢哪种粽子呢？在大家吃着美味粽子的同时，本文我们画一盘粽子送给大家。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;先睹为快&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来欣赏一下最终的效果图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6727664155005382&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIpbW93CXlo5rBW3icWdbsqBGUeZIC16BjSOV4kTYflNISjScdRQKpH0asbUon61fKuqhJ6peyNWib3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;929&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中我们可以看出整体分三部分组成：盘子、粽子、文字，下面我们展开来说一下相应实现。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;盘子实现&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们来画一个盘子，盘子的组成比较简单，就是一个椭圆再加上填充色，代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 画盘子&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;plate&lt;/span&gt;&lt;span&gt;(a, b, angle, steps, rotateAngle)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    minAngle = (&lt;span&gt;2&lt;/span&gt; * math.pi / &lt;span&gt;360&lt;/span&gt;) * angle / steps&lt;br/&gt;    rotateAngle = rotateAngle / &lt;span&gt;360&lt;/span&gt; * &lt;span&gt;2&lt;/span&gt; * math.pi&lt;br/&gt;    penup() &lt;span&gt;# 起笔&lt;/span&gt;&lt;br/&gt;    setpos(b * math.sin(rotateAngle), -b * math.cos(rotateAngle))&lt;br/&gt;    pendown() &lt;span&gt;# 落笔&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(steps):&lt;br/&gt;        nextPoint = [a * math.sin((i + &lt;span&gt;1&lt;/span&gt;) * minAngle), -b * math.cos((i + &lt;span&gt;1&lt;/span&gt;) * minAngle)]&lt;br/&gt;        nextPoint = [nextPoint[&lt;span&gt;0&lt;/span&gt;] * math.cos(rotateAngle) - nextPoint[&lt;span&gt;1&lt;/span&gt;] * math.sin(rotateAngle),&lt;br/&gt;                     nextPoint[&lt;span&gt;0&lt;/span&gt;] * math.sin(rotateAngle) + nextPoint[&lt;span&gt;1&lt;/span&gt;] * math.cos(rotateAngle)]&lt;br/&gt;        setpos(nextPoint)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;效果如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6702937976060935&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIpbW93CXlo5rBW3icWdbsqBG9OdIgQzziaPQG5SxMa5V4df2acC1Of8eq0Bpu5RNtA25W4ibqZDVZ8icw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;919&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;粽子实现&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着，我们看一下本文最核心的部分-粽子的实现，实现代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 画粽子&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;rice_dumpling&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    pensize(&lt;span&gt;2&lt;/span&gt;) &lt;span&gt;# 画笔宽度&lt;/span&gt;&lt;br/&gt;    pencolor(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;51&lt;/span&gt;, &lt;span&gt;12&lt;/span&gt;) &lt;span&gt;# 画笔颜色&lt;/span&gt;&lt;br/&gt;    fillcolor(&lt;span&gt;4&lt;/span&gt;, &lt;span&gt;77&lt;/span&gt;, &lt;span&gt;19&lt;/span&gt;) &lt;span&gt;# 填充色&lt;/span&gt;&lt;br/&gt;    begin_fill()&lt;br/&gt;    fd(&lt;span&gt;200&lt;/span&gt;) &lt;span&gt;# 向前&lt;/span&gt;&lt;br/&gt;    circle(&lt;span&gt;15&lt;/span&gt;, &lt;span&gt;120&lt;/span&gt;) &lt;span&gt;#画圆弧&lt;/span&gt;&lt;br/&gt;    fd(&lt;span&gt;200&lt;/span&gt;)&lt;br/&gt;    circle(&lt;span&gt;15&lt;/span&gt;, &lt;span&gt;120&lt;/span&gt;)&lt;br/&gt;    fd(&lt;span&gt;200&lt;/span&gt;)&lt;br/&gt;    circle(&lt;span&gt;15&lt;/span&gt;, &lt;span&gt;120&lt;/span&gt;)&lt;br/&gt;    fd(&lt;span&gt;200&lt;/span&gt;)&lt;br/&gt;    circle(&lt;span&gt;15&lt;/span&gt;, &lt;span&gt;60&lt;/span&gt;)&lt;br/&gt;    fd(&lt;span&gt;100&lt;/span&gt;)&lt;br/&gt;    circle(&lt;span&gt;15&lt;/span&gt;, &lt;span&gt;90&lt;/span&gt;)&lt;br/&gt;    fd(&lt;span&gt;173&lt;/span&gt;)&lt;br/&gt;    circle(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;90&lt;/span&gt;)&lt;br/&gt;    end_fill()&lt;br/&gt;    penup()&lt;br/&gt;    fd(&lt;span&gt;100&lt;/span&gt;)&lt;br/&gt;    right(&lt;span&gt;60&lt;/span&gt;)&lt;br/&gt;    back(&lt;span&gt;105&lt;/span&gt;)&lt;br/&gt;    a = pos()&lt;br/&gt;    pendown()&lt;br/&gt;    color(&lt;span&gt;60&lt;/span&gt;, &lt;span&gt;67&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;    fillcolor(&lt;span&gt;85&lt;/span&gt;, &lt;span&gt;97&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;)&lt;br/&gt;    begin_fill()&lt;br/&gt;    fd(&lt;span&gt;120&lt;/span&gt;)&lt;br/&gt;    goto(a)&lt;br/&gt;    penup()&lt;br/&gt;    back(&lt;span&gt;15&lt;/span&gt;)&lt;br/&gt;    left(&lt;span&gt;90&lt;/span&gt;)&lt;br/&gt;    fd(&lt;span&gt;20&lt;/span&gt;)&lt;br/&gt;    right(&lt;span&gt;90&lt;/span&gt;)&lt;br/&gt;    pendown()&lt;br/&gt;    fd(&lt;span&gt;150&lt;/span&gt;)&lt;br/&gt;    right(&lt;span&gt;120&lt;/span&gt;)&lt;br/&gt;    fd(&lt;span&gt;24&lt;/span&gt;)&lt;br/&gt;    right(&lt;span&gt;60&lt;/span&gt;)&lt;br/&gt;    fd(&lt;span&gt;120&lt;/span&gt;)&lt;br/&gt;    right(&lt;span&gt;60&lt;/span&gt;)&lt;br/&gt;    fd(&lt;span&gt;24&lt;/span&gt;)&lt;br/&gt;    end_fill()&lt;br/&gt;    begin_fill()&lt;br/&gt;    left(&lt;span&gt;110&lt;/span&gt;)&lt;br/&gt;    fd(&lt;span&gt;65&lt;/span&gt;)&lt;br/&gt;    left(&lt;span&gt;100&lt;/span&gt;)&lt;br/&gt;    fd(&lt;span&gt;24&lt;/span&gt;)&lt;br/&gt;    left(&lt;span&gt;80&lt;/span&gt;)&lt;br/&gt;    fd(&lt;span&gt;50&lt;/span&gt;)&lt;br/&gt;    end_fill()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;效果如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.759765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIpbW93CXlo5rBW3icWdbsqBGUeYdptJjibc5mwrLQHr8PMKQusYXfQcDGdUwesQkksbe3uic92eficscw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;512&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;文字实现&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再接着看一下如何添加文字，比如我要添加的文字是：祝大家端午安康，添加文字实现很容易，只需一行代码即可，代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;write(&lt;span&gt;&quot;祝大家端午安康&quot;&lt;/span&gt;, move=&lt;span&gt;False&lt;/span&gt;, align=&lt;span&gt;&quot;center&quot;&lt;/span&gt;, font=(&lt;span&gt;&quot;Comic Sans&quot;&lt;/span&gt;, &lt;span&gt;18&lt;/span&gt;, &lt;span&gt;&quot;bold&quot;&lt;/span&gt;))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文中全部代码已经为大家整理好了，有需要的在公众号&lt;strong&gt;&lt;span&gt;Python小二&lt;/span&gt;&lt;/strong&gt;后台回复&lt;strong&gt;&lt;span&gt;端午&lt;/span&gt;&lt;/strong&gt;即可获取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果大家觉得本文有一点帮助的话，记得随手点个赞支持一下~&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU3Mzk1ODA5OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIpUwwib3ughYzyRWGgnRezhFgwicOtsUTHoYCGlVibuic6LN0mUYjVJ3jP9W5zvwwyhdrNJEqOv8X9QSQ/0?wx_fmt=png&quot; data-nickname=&quot;Python小二&quot; data-alias=&quot;pythonXE&quot; data-signature=&quot;回复 1024 免费领取学习资料&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;分享、在看、赞是对我最大的支持&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>79b06314eac04b88114da736653a77cd</guid>
<title>一文理解 Kafka 如何消息不丢失</title>
<link>https://toutiao.io/k/rupupf1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-source-line=&quot;1&quot;&gt;本文只聚焦于Kafka系统的消息丢失，如果是生产环境出现数据丢失，排查时要先从链路上分段定位，缩小问题范围。&lt;/p&gt;&lt;p data-source-line=&quot;3&quot;&gt;如果对Kafka不了解的话，可以先看这篇博客《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyNzgyNzAwNg==&amp;amp;mid=2247484251&amp;amp;idx=1&amp;amp;sn=92d6b50c5987f4f80316313db05b56ff&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;一文快速了解Kafka&lt;/a&gt;》。&lt;/p&gt;&lt;h2 data-source-line=&quot;5&quot;&gt;数据丢失的原因&lt;/h2&gt;&lt;h3 data-source-line=&quot;7&quot;&gt;生产者丢失消息的情况&lt;/h3&gt;&lt;p data-source-line=&quot;9&quot;&gt;生产者(Producer) 调用send方法发送消息之后，消息可能因为网络问题并没有发送过去。&lt;/p&gt;&lt;p data-source-line=&quot;11&quot;&gt;解决方法：&lt;/p&gt;&lt;p data-source-line=&quot;13&quot;&gt;不能认为在调用send方法发送消息之后消息消息发送成功了。为了确定消息是发送成功，需要判断消息发送的结果。但要注意的是Kafka生产者(Producer) 使用send方法发送消息实是异步的操作，虽然可以通过get()方法获取调用结果，但降低业务服务的吞吐量。优化的方式是改为回调函数的形式。&lt;/p&gt;&lt;p data-source-line=&quot;15&quot;&gt;此外，对于一致性要求不高的业务场景，可以考虑Producer端设置&lt;code&gt;retries&lt;/code&gt;（重试次数）设置一个比较合理的值，一般是3。设置完成之后，当出现网络问题之后能够自动重试消息发送，避免消息丢失。另外，建议将重试间隔设置长一些，因为间隔时间太小，可能一次网络波动的时间重试全部结束了。&lt;/p&gt;&lt;h3 data-source-line=&quot;17&quot;&gt;消费者丢失消息的情况&lt;/h3&gt;&lt;p data-source-line=&quot;19&quot;&gt;自动提交开启会存在这样的问题：当消费者poll到这个消息，还没进行真正消费的时候，offset被自动提交的同时消费者挂掉了。&lt;/p&gt;&lt;p data-source-line=&quot;21&quot;&gt;解决办法：&lt;/p&gt;&lt;p data-source-line=&quot;23&quot;&gt;关闭自动提交offset（即：&lt;code&gt;enable.auto.commit&lt;/code&gt;为false），每次在真正消费完消息之后，手动提交offset。&lt;/p&gt;&lt;p data-source-line=&quot;25&quot;&gt;但这样还是会存在消费者刚消费完消息，还没提交offset，结果宕机了，那么这个消息理论上就会被消费两次，因此消费端幂等性是需要保证。可以查看博客《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyNzgyNzAwNg==&amp;amp;mid=2247484349&amp;amp;idx=1&amp;amp;sn=b54c0819bc100db816cda52d11476401&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;一文理解如何实现接口的幂等性&lt;/a&gt;》，有这种问题对应的解决方案&lt;/p&gt;&lt;h3 data-source-line=&quot;27&quot;&gt;Kafka系统内丢失消息的情况&lt;/h3&gt;&lt;p data-source-line=&quot;29&quot;&gt;假如leader副本所在的broker突然挂掉，那么就要从follower副本重新选出一个leader，但是leader的数据还有一些没有被follower副本的同步的话，就会造成消息丢失。&lt;/p&gt;&lt;p data-source-line=&quot;31&quot;&gt;解决方法：&lt;/p&gt;&lt;p data-source-line=&quot;33&quot;&gt;为了减少Kafka系统内丢失消息的情况，Kafka需要配置如下几个参数：&lt;/p&gt;&lt;ol data-source-line=&quot;35&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Producer端设置&lt;code&gt;acks&lt;/code&gt;=all。&lt;code&gt;acks&lt;/code&gt;的默认值为1，代表消息被leader副本接收之后就算被成功发送。当配置&lt;code&gt;acks&lt;/code&gt;=all代表则所有副本都要接收到该消息之后该消息才算真正成功被发送。（副本只是将消息存储在PageCache上的，定期flush到磁盘上的，如果出现断电或者机器故障等，PageCache上的数据就丢失了。但设置设置了&lt;code&gt;acks&lt;/code&gt;=all，出现多个副本同时挂掉的概率比Leader挂掉的概率就小很多)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;topic设置&lt;code&gt;replication.factor&lt;/code&gt;&amp;gt;=3。为了保证leader副本能有follower 副本能同步消息，一般会设置&lt;code&gt;replication.factor&lt;/code&gt;&amp;gt;=3。这样就可以保证每个分区(partition)至少有3个副本。虽然造成了数据冗余，但是带来了数据的安全性。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;设置&lt;code&gt;min.insync.replicas&lt;/code&gt;&amp;gt;1。一般情况下需要设置&lt;code&gt;min.insync.replicas&lt;/code&gt;&amp;gt;1，这样配置代表消息至少要被写入到2个副本才算是被成功发送（默认值为1）。在实际生产中应尽量避免&lt;code&gt;min.insync.replicas&lt;/code&gt;值为1，此外，为了保证整个Kafka服务的高可用性，你需要确保&lt;code&gt;replication.factor&lt;/code&gt;&amp;gt;&lt;code&gt;min.insync.replicas&lt;/code&gt;，否则有一个副本挂掉，整个分区就无法正常工作了。推荐设置成&lt;code&gt;replication.factor&lt;/code&gt;=&lt;code&gt;min.insync.replicas&lt;/code&gt;+1。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;设置&lt;code&gt;unclean.leader.election.enable&lt;/code&gt;=false。即不允许Unclean leader选举。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Producer端设置&lt;code&gt;retries&lt;/code&gt;。配合&lt;code&gt;acks&lt;/code&gt;=all，这样可以保证leader挂掉之后，Producer会重新发送消息。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-source-line=&quot;41&quot;&gt;&lt;p&gt;Unclean leader选举：Kafka把不在ISR列表中的存活副本称为“非同步副本”，这些副本中的消息远远落后于leader，如果选举这种副本作为leader的话就可能造成数据丢失。Kafka broker端提供了一个参数unclean.leader.election.enable，用于控制是否允许非同步副本参与leader选举；如果开启，则当ISR为空时就会从这些副本中选举新的leader，这个过程称为Unclean leader选举。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-source-line=&quot;43&quot;&gt;异常导致的数据丢失&lt;/h3&gt;&lt;p data-source-line=&quot;45&quot;&gt;单条数据的长度超过限制会丢失数据，报kafka.common.MessageSizeTooLargeException异常，导致生产者消息积压，内存上升。&lt;/p&gt;&lt;p data-source-line=&quot;47&quot;&gt;解决方法：&lt;/p&gt;&lt;p data-source-line=&quot;49&quot;&gt;修改Kafka Broker的配置，修改单条消息的最大长度、单条消息的最大长度等参数配置。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>55295b614fcbea228b772148b66d4e85</guid>
<title>将 Android 生物识别身份验证整合至应用中</title>
<link>https://toutiao.io/k/31et261</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;&lt;i&gt;本文是 Android 生物识别身份验证系列文章的第二篇，&lt;b&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/378815607&quot; class=&quot;internal&quot;&gt;上篇文章&lt;/a&gt;&lt;/b&gt;&lt;/i&gt; &lt;i&gt;主要通过比较传统用户名和密码的认证方式和生物识别身份认证方式的不同，以及介绍生物识别加密的不同加密方式，来向开发者展示为何需要在应用中使用生物识别身份认证技术。&lt;/i&gt;&lt;/p&gt;&lt;p&gt;为了拓展传统的登录授权流程，使其支持生物识别身份验证，您可以在用户成功登录之后提示用户启用生物识别身份验证。图 1A 展示了一个典型的登录流程，您可能已经很熟悉了。当用户点击登录按钮，且应用获取到服务器返回的 userToken 之后，再提示用户是否启用，如图 1B 所示。一旦启用，每次用户需要登录时，应用都应当自动弹出生物识别身份验证对话框，如图 2 所示。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-bad30d51c677e1b4a17742ab157b90fd_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;668&quot; data-rawheight=&quot;777&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-bad30d51c677e1b4a17742ab157b90fd_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;668&quot; data-rawheight=&quot;777&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-bad30d51c677e1b4a17742ab157b90fd_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-bad30d51c677e1b4a17742ab157b90fd_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 图 1A: 典型的登录界面&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-d6446cdb273789f0866cfea57f341ea5_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;457&quot; data-rawheight=&quot;1007&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-d6446cdb273789f0866cfea57f341ea5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;457&quot; data-rawheight=&quot;1007&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-d6446cdb273789f0866cfea57f341ea5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-d6446cdb273789f0866cfea57f341ea5_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 图 1B: 启用生物识别身份验证&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-7c4f55f7b65100bb71d57b2720819559_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;496&quot; data-rawheight=&quot;1027&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-7c4f55f7b65100bb71d57b2720819559_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;496&quot; data-rawheight=&quot;1027&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-7c4f55f7b65100bb71d57b2720819559_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-7c4f55f7b65100bb71d57b2720819559_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 图 2: 确认使用生物识别身份验证进行登录&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;在图 2 中的界面有一个确定按钮，实际上该按钮是可选的。举个例子，如果您开发的是一个餐厅的应用，建议显示该按钮，因为可以使用生物识别身份验证的方式让顾客支付用餐费用。对于敏感的交易和支付，我们建议您要求用户进行确认。若要在界面中包含此确认按钮，您可以在构建 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/androidx/biometric/BiometricPrompt.PromptInfo&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;BiometricPrompt.PromptInfo&lt;/a&gt;&lt;/b&gt; 时调用 setConfirmationRequired(true) 即可。这里要注意的是，如果您不调用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/androidx/biometric/BiometricPrompt.PromptInfo.Builder%23setConfirmationRequired%28boolean%29&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;setConfirmationRequired(true)&lt;/a&gt;&lt;/b&gt;，系统会默认将其设置为 true。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;接入生物识别的设计流程&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;示例中的代码使用了带有 CryptoObject 实例的加密版 BiometricPrompt。&lt;/p&gt;&lt;p&gt;如果您的应用需要认证，那么您就应该创建一个专门的 LoginActivity 组件作为应用的登录界面。无论应用要求进行身份验证的频率多高，只要需要验证，就应该这么做。若用户之前已认证过，那么 LoginActivity 将调用 finish() 方法，让用户继续使用。如果用户还没有进行身份验证，那么您应该检查生物识别身份验证是否启用。&lt;/p&gt;&lt;p&gt;有很多方法来检查是否启用了生物识别。与其在各种不同的替代方案中周旋，不如我们直接深入研究一个特别的方法: 直接检查自定义属性 &lt;code&gt;ciphertextWrapper&lt;/code&gt; 是否是 null。当用户在您的应用中启用生物识别身份验证后，您就可以创建一个 &lt;code&gt;CiphertextWrapper&lt;/code&gt; 数据类，来将加密后的 &lt;code&gt;userToken&lt;/code&gt; (也就是 ciphertext) 存储在 &lt;code&gt;SharedPreferences&lt;/code&gt; 或 &lt;b&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/111267510&quot; class=&quot;internal&quot;&gt;Room&lt;/a&gt;&lt;/b&gt; 这样的持久性存储中。因此，若 &lt;code&gt;ciphertextWrapper&lt;/code&gt; 不是 null，就相当于您拥有了访问远程服务所需的已加密的 &lt;code&gt;userToken&lt;/code&gt;，这也意味着当前生物识别已启用。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ciphertextWrapper&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;c1&quot;&gt;// 用户已启用了生物识别
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 生物识别未启用
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;若生物识别未被启用，则用户可以单击 (如图 1B 所示) 以启用它，这时您将向用户展示生物识别身份验证提示框，如图 3 所示。&lt;/p&gt;&lt;p&gt;如下代码示例中，&lt;code&gt;showBiometricPromptForEncryption()&lt;/code&gt; 展示了如何设置与 BiometricPrompt 关联的加密密钥。本质上，就是从一个 &lt;code&gt;String&lt;/code&gt; 初始化出一个 &lt;code&gt;Cipher&lt;/code&gt;，然后将该 &lt;code&gt;Cipher&lt;/code&gt; 传递给 &lt;code&gt;CryptoObject&lt;/code&gt;。最后再将 &lt;code&gt;CryptoObject&lt;/code&gt; 传递给 &lt;code&gt;biometricPrompt.authenticate(promptInfo, cryptoObject)&lt;/code&gt; 方法。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;&lt;span class=&quot;n&quot;&gt;binding&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;useBiometrics&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;setOnClickListener&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;showBiometricPromptForEncryption&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;....&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;showBiometricPromptForEncryption&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;canAuthenticate&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BiometricManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;applicationContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;canAuthenticate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;canAuthenticate&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BiometricManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BIOMETRIC_SUCCESS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;secretKeyName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SECRET_KEY_NAME&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;cryptographyManager&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CryptographyManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;cipher&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cryptographyManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getInitializedCipherForEncryption&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;secretKeyName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;biometricPrompt&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;BiometricPromptUtils&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createBiometricPrompt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;encryptAndStoreServerToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;promptInfo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BiometricPromptUtils&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createPromptInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;biometricPrompt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;authenticate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;promptInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BiometricPrompt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CryptoObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cipher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-15120357c3aaea87e1fb8c9e6c20b431_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;700&quot; data-rawheight=&quot;838&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-15120357c3aaea87e1fb8c9e6c20b431_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;700&quot; data-rawheight=&quot;838&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-15120357c3aaea87e1fb8c9e6c20b431_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-15120357c3aaea87e1fb8c9e6c20b431_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 图 3: 激活生物识别的提示&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;在图 2 和图 3 所示的场景下，应用只有 &lt;code&gt;userToken&lt;/code&gt; 这个数据。但是除非用户每次打开应用都要输入一次密码，否则该 &lt;code&gt;userToken&lt;/code&gt; 就需要持久化用于之后的会话。然而，如果您直接存储了未加密的 &lt;code&gt;userToken&lt;/code&gt;，那么攻击者就可能侵入设备读取明文的 &lt;code&gt;userToken&lt;/code&gt;，然后使用它从远程服务器上获取数据。因此，在将 &lt;code&gt;userToken&lt;/code&gt; 保存到本地之前，最好先将其加密，这就是图 3 中 BiometricPrompt 的作用。当用户使用生物识别验证身份后，您的目标是使用 BiometricPrompt 解锁密钥 (可以使用 &lt;i&gt;auth-per-use&lt;/i&gt; 密钥，也可使用 &lt;i&gt;time-bound&lt;/i&gt; 密钥)，然后用该密钥对服务器生成的 userToken 进行加密，再将其保存到本地。自此，当用户需要登录时，就可以使用生物识别验证身份 (即生物识别认证 -&amp;gt; 解锁密钥 -&amp;gt; 解密 userToken 进行数据访问)。&lt;/p&gt;&lt;p&gt;这里要注意区分用户是第一次启用生物识别，还是在使用生物识别进行登录。启用生物识别时，应用调用 &lt;code&gt;showBiometricPromptForEncryption()&lt;/code&gt; 方法，该方法会初始化一个 &lt;code&gt;Cipher&lt;/code&gt; 用于加密 &lt;code&gt;userToken&lt;/code&gt;。另一方面，若用户是在使用生物识别进行登录，那应该调用 &lt;code&gt;showBiometricPromptForDecryption()&lt;/code&gt; 方法，它会初始化一个用于解密的 &lt;code&gt;Cipher&lt;/code&gt;，再使用该 &lt;code&gt;Cipher&lt;/code&gt; 来解密 &lt;code&gt;userToken&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;启用生物识别之后，用户下次返回应用时，会通过生物识别身份验证对话框进行认证，如图 4 所示。请注意，由于图 4 是用于登录应用，而图 2 是用于确定交易的，所以在图 4 中没有确认按钮，因为登录行为是一个被动的、易逆向恢复的行为。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-275de074244b16d3d49ad9293f4ecebf_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;683&quot; data-rawheight=&quot;812&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-275de074244b16d3d49ad9293f4ecebf_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;683&quot; data-rawheight=&quot;812&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-275de074244b16d3d49ad9293f4ecebf_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-275de074244b16d3d49ad9293f4ecebf_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 图 4&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;若要为您的用户实现这一流程，当您的 &lt;code&gt;LoginActivity&lt;/code&gt; 完成认证过程后，使用成功通过 BiometricPrompt 认证解锁的加密对象来解密 &lt;code&gt;userToken&lt;/code&gt;，然后在 &lt;code&gt;LoginActivity&lt;/code&gt; 中调用 &lt;code&gt;finish()&lt;/code&gt; 方法。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-kotlin&quot;&gt;&lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;onResume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;k&quot;&gt;super&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;onResume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ciphertextWrapper&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SampleAppUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fakeToken&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;showBiometricPromptForDecryption&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
           &lt;span class=&quot;c1&quot;&gt;// 用户已经成功登录，因此直接进入接下来的应用流程
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;           &lt;span class=&quot;c1&quot;&gt;// 之后的就交给开发者您来完成了
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;           &lt;span class=&quot;n&quot;&gt;updateApp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;already_signedin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;....&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;showBiometricPromptForDecryption&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;ciphertextWrapper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;textWrapper&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;canAuthenticate&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BiometricManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;from&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;applicationContext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;canAuthenticate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;canAuthenticate&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BiometricManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BIOMETRIC_SUCCESS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
           &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;secretKeyName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;secret_key_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
           &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;cipher&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cryptographyManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getInitializedCipherForDecryption&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;secretKeyName&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;textWrapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;initializationVector&lt;/span&gt;
           &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                      &lt;span class=&quot;n&quot;&gt;biometricPrompt&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;BiometricPromptUtils&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createBiometricPrompt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
                   &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                   &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decryptServerTokenFromStorage&lt;/span&gt;
               &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
           &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;promptInfo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BiometricPromptUtils&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;createPromptInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;biometricPrompt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;authenticate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;promptInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BiometricPrompt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CryptoObject&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cipher&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;decryptServerTokenFromStorage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;authResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BiometricPrompt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AuthenticationResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;n&quot;&gt;ciphertextWrapper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;textWrapper&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&amp;gt;&lt;/span&gt;
       &lt;span class=&quot;n&quot;&gt;authResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cryptoObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cipher&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
           &lt;span class=&quot;k&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;plaintext&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;cryptographyManager&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;decryptData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;textWrapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ciphertext&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;SampleAppUser&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fakeToken&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;plaintext&lt;/span&gt;
           &lt;span class=&quot;c1&quot;&gt;// 现在您有了 token，就可以查询服务器上的其他数据了
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;           &lt;span class=&quot;c1&quot;&gt;// 我们之所以称这个为 fakeToken，是因为它并不是真正从服务器中获取到的
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;           &lt;span class=&quot;c1&quot;&gt;// 在真实场景下，您会在从服务器上获取到 token 数据
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;           &lt;span class=&quot;c1&quot;&gt;// 此时，它才能算是一个真正的 token
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;           &lt;span class=&quot;n&quot;&gt;updateApp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getString&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;already_signedin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
       &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
   &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;完整的蓝图&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;图 5 展示了一个完整的工程设计流程图，这也是我们所推荐的流程。既然您在实际编码过程中可能会在很多地方偏离此流程，例如，您所使用的加密解决方案中解锁密钥可能只会用于加密而不用于解密，但是在这里我们仍然希望能够通过提供这样一个完整的示例为可能需要的开发者们提供帮助。&lt;/p&gt;&lt;p&gt;凡是图中提到 &lt;b&gt;密钥&lt;/b&gt; 的地方，您都可以按照需求使用 auth-per-use 密钥或是 time-bound 密钥。另外，凡是图中提到的 &quot;应用中的存储系统&quot; 的地方，您也都可以将其理解为您所偏爱的结构化存储: &lt;b&gt;&lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/android/content/SharedPreferences&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;SharedPreferences&lt;/a&gt;&lt;/code&gt;&lt;/b&gt;、&lt;b&gt;&lt;code&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/jetpack/androidx/releases/room&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Room&lt;/a&gt;&lt;/code&gt;&lt;/b&gt; 或是任何别的存储方案。最后，对于 userToken 您可以将其理解为一个令牌，有了它就可以去服务器上访问被保护的用户数据。服务器通常会将这种令牌作为调用方已被授权的证据。&lt;/p&gt;&lt;p&gt;图中的 &quot;对 userToken 进行加密&quot; 的箭头很可能会指向 &quot;登录完成&quot;，而不是回到 &quot;LoginActivity&quot;。尽管如此，我们还是在图中让其指向了 &quot;LoginActivity&quot;，就是为了提醒大家注意，在用户点击 &quot;激活生物识别&quot; 后，可以使用一个额外的 Activity (例如 EnableBiometricAuthActivity)，使代码更加模块化，更具可读性。或者，您也可以创建带有两个 Fragment 的 LoginActivity: 一个 Fragments用于实际的认证流程，另一个用来响应用户点击 &quot;启用生物识别&quot;。&lt;/p&gt;&lt;p&gt;除了下面这个流程图之外，我们还发布了一个设计指南，您可以在设计应用时进行参考。另外，我们 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/android/security-samples/tree/master/BiometricLoginKotlin&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;在 Github 上的示例代码&lt;/a&gt;&lt;/b&gt; 希望也能够帮助您更好地理解如何使用生物识别身份验证技术。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-0dade1949ed511b2120cdf891d6d1498_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1860&quot; data-rawheight=&quot;1999&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-0dade1949ed511b2120cdf891d6d1498_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1860&quot; data-rawheight=&quot;1999&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-0dade1949ed511b2120cdf891d6d1498_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-0dade1949ed511b2120cdf891d6d1498_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 图 5: 使用生物识别同服务器获取授权的完整蓝图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在本篇文章中，我们介绍了:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如何扩展 UI 来支持生物识别身份验证；&lt;/li&gt;&lt;li&gt;针对生物识别身份验证的流程，您的应用应着重解决的关键点是什么；&lt;/li&gt;&lt;li&gt;如何设计您的代码来处理生物识别认证的不同场景；&lt;/li&gt;&lt;li&gt;登录流程的完整工程设计图。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;祝您编码愉快！&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>