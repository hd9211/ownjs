<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>7acd7b7a2498a76e2d32fa7cdd17f421</guid>
<title>值得收藏，揭秘 MySQL 多版本并发控制实现原理</title>
<link>https://toutiao.io/k/r59u142</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;▲&lt;/span&gt;&lt;span&gt;&lt;strong&gt; 点击上方“架构精进之路”&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;关注公众号&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回复&lt;/span&gt;&lt;span&gt;“01”&lt;/span&gt;&lt;span&gt;领&lt;/span&gt;&lt;span&gt;取「&lt;/span&gt;&lt;span&gt;程序员进阶大礼包&lt;/span&gt;&lt;span&gt;」&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA3MDg5MDkzOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgQmUQ0Aca9qSYNFn0tQEXQc5EibBkqQLYtibYBj1hXuagwXkNc3kVwplHxIl7KQfBIiagysgn9GDUUibw/0?wx_fmt=png&quot; data-nickname=&quot;架构精进之路&quot; data-alias=&quot;jiagou_jingjin&quot; data-signature=&quot;十年研发风雨路，大厂架构师，CSDN博客专家。专注软件架构研究，技术学习与职业成长，坚持分享接地气儿的架构技术干货文章！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;这是&lt;/span&gt;&lt;span&gt;&lt;strong&gt;「&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;架构精进之路」公众号&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的第&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;73&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;篇原创文章&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;MySQL 中多版本并发控制（MVCC），是现代数据库引擎实现中常用的处理读写冲突的手段，MVCC 作为 MySQL 高级应用特性，目的在于提高数据库高并发场景下的吞吐性能。&lt;/section&gt;&lt;h2&gt;一、MVCC出现背景是什么？&lt;/h2&gt;&lt;section&gt;事务的4个隔离级别以及对应的3种异常：&lt;br/&gt;&lt;img data-ratio=&quot;0.521412471825695&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgSWF9lHzdyW8leTRuN8I92ibzmFlVkPTnUJnF2CsFRGlCHZAdibiaeeNptfr2uEJvOMBh88mhASv5JZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1331&quot;/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;脏读：一个事务读取到了另外一个事务没有提交的数据；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不可重复读：&lt;span&gt;在同一事务中，两次读取同一数据，得到内容不同；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;幻读：&lt;/span&gt;&lt;span&gt;同一事务中，用同样的操作读取两次，得到的记录数不相同。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;在 MySQL 中，&lt;span&gt;默认的隔离级别是可重复读&lt;/span&gt;，可以解决脏读和不可重复读的问题，但不能解决幻读问题。如果我们想要解决幻读问题，就需要采用串行化的方式，也就是将隔离级别提升到最高，但这样一来就会大幅降低数据库的事务并发能力。&lt;/section&gt;&lt;section&gt;&lt;span&gt;而MVCC就是通过乐观锁的方式来解决不可重复读和幻读问题，它可以在大多数情况下替代行级锁，降低系统的开销。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;MySQL 并发事务会引起更新丢失问题，解决办法是锁，主要分两类：&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;二、什么是MVCC，它解决了什么问题？&lt;/h2&gt;&lt;section&gt;MVCC 是通过数据行的多个版本管理来实现数据库的并发控制，简单来说它的思想就是保存数据的历史版本。&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;我们可以通过比较版本号决定数据是否显示出来（具体的规则后面会介绍到），读取数据的时候不需要加锁也可以保证事务的隔离效果。&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;通过 MVCC 我们可以解决以下几个问题：&lt;/section&gt;&lt;section&gt;（1）读写之间阻塞的问题，通过 MVCC 可以让读写互相不阻塞，即读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力。&lt;/section&gt;&lt;section&gt;（2）降低了死锁的概率。这是因为 MVCC 采用了乐观锁的方式，读取数据时并不需要加锁，对于写操作，也只锁定必要的行。&lt;/section&gt;&lt;section&gt;（3）解决一致性读的问题。一致性读也被称为快照读，当我们查询数据库在某个时间点的快照时，只能看到这个时间点之前事务提交更新的结果，而不能看到这个时间点之后事务提交的更新结果。&lt;/section&gt;&lt;section&gt;解释一下可能难以理解的几个词汇：&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;三、应用举例分析&lt;/h2&gt;&lt;section&gt;为了更好地让大家理解MVCC，我们用一个示例场景来说明。&lt;/section&gt;&lt;section&gt;假设有个账户金额表 user_balance，包括三个字段，分别是 username 用户名、balance 余额和 bankcard 卡号，表数据如下所示：&lt;br/&gt;&lt;img data-ratio=&quot;0.41872791519434627&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgSWF9lHzdyW8leTRuN8I92ibparMgWpZztr8GYbIF0KBV2weALNNGj3du2UFot8MzickFkicgfhKzbOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1132&quot;/&gt;&lt;/section&gt;&lt;section&gt;用户 A 和用户 B 之间进行转账，此时数据库管理员想要查询 user_balance 表中的总金额，两个场景存在并发情况，在没有MVCC的情况下，会出现哪些问题呢。&lt;/section&gt;&lt;section&gt;&lt;span&gt;Case1&lt;/span&gt;：因为需要采用加行锁的方式，用户 A 给 B 转账时间等待很久，如下图所示。&lt;br/&gt;&lt;img data-ratio=&quot;0.46637744034707157&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgSWF9lHzdyW8leTRuN8I92ib5ianYUAjlHDGr4baraZdWU1yVJdAibJFicPBXPlvotnCNWhqzWbn6HpRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;922&quot;/&gt;&lt;br/&gt;&lt;span&gt;Case2&lt;/span&gt;：当我们读取的时候用了加行锁，可能会出现死锁的情况，如下图所示。&lt;br/&gt;&lt;img data-ratio=&quot;0.48579545454545453&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgSWF9lHzdyW8leTRuN8I92ibjic0XbLW04lLRFGYzhgv76UeZtjpFD1C24SYHkDpA40Jwgxqhf3v0WQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;704&quot;/&gt;&lt;br/&gt;比如当我们读到 A 有 1000 元的时候，此时 B 开始执行给 A 转账。&lt;/section&gt;&lt;h2&gt;四、InnoDB如何实现MVCC？&lt;/h2&gt;&lt;section&gt;当查询一条记录的时候，执行流程如下：&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;首先获取事务自己的版本号，也就是事务 ID；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;获取 Read View；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;查询得到的数据，然后与 Read View 中的事务版本号进行比较；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;最后返回符合规则的数据。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;相关概念&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1. 事务版本号&lt;/span&gt;&lt;/section&gt;&lt;section&gt;一个自增长的事务ID，用于标记事务执行的先后顺序。&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. Read View&lt;/span&gt;&lt;/section&gt;&lt;section&gt;在 MVCC 机制中，多个事务对同一个行记录进行更新会产生多个历史快照，这些历史快照保存在 Undo Log 里。如果一个事务想要查询这个行记录，需要读取哪个版本的行记录呢？&lt;/section&gt;&lt;section&gt;这时就需要用到 Read View 了，它帮我们解决了行的可见性问题。Read View 保存了当前事务开启时所有活跃（还没有提交）的事务列表，换个角度，可以理解为 Read View 保存了不应该让这个事务看到的其他的事务 ID 列表。&lt;/section&gt;&lt;section&gt;Read VIew 中的几个重要属性：&lt;br/&gt;&lt;img data-ratio=&quot;0.29342105263157897&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgSWF9lHzdyW8leTRuN8I92ibUBtWQrUzWJxh0pbutac3pia3tYtG5Wlicof8OKf0B5tLYuVEp76HttiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;760&quot;/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;up_limit_id，活跃的事务中最小的事务 ID；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;trx_ids，系统当前正在活跃的事务 ID 集合；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;low_limit_id，活跃的事务中最大的事务 ID；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;creator_trx_id，创建这个 Read View 的事务 ID。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3. 行记录的隐藏列&lt;/span&gt;&lt;/section&gt;&lt;section&gt;InnoDB 的叶子节点段存储了数据页，数据页中保存了行记录，在这些行记录中有一些重要的隐藏字段：&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4. 聚集索引&lt;/span&gt;&lt;/section&gt;&lt;section&gt;聚集索引是指数据库表行中数据的物理顺序与键值的逻辑（索引）顺序相同。一个表只能有一个聚集索引，因为一个表的物理顺序只有一种情况，所以，对应的聚集索引只能有一个。&lt;/section&gt;&lt;section&gt;&lt;span&gt;5. Undo Log&lt;/span&gt;&lt;/section&gt;&lt;section&gt;InnoDB 将行记录快照保存在 Undo Log，可以在回滚段中找到它们，主要用于记录数据被修改之前的日志，在对表信息做修改之前先会把数据拷贝到Undo Log里，当事务进行回滚时可以通过Undo Log里的日志进行数据还原。&lt;/section&gt;&lt;section&gt;回滚段中回滚指针间关联关系，如下图所示：&lt;br/&gt;&lt;img data-ratio=&quot;0.6420047732696897&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgSWF9lHzdyW8leTRuN8I92ibOgOQqJruiaTh6FAICEYgHpy9yGFvqL3joLF2yszhtMS5K6HmpxdIIVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;838&quot;/&gt;&lt;span&gt;五、InnoDB是如何解决幻读的？&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1、在读已提交的情况下，即使采用了 MVCC 方式也会出现幻读&lt;/span&gt;&lt;br/&gt;&lt;img data-ratio=&quot;0.5613425925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgSWF9lHzdyW8leTRuN8I92ib7xhCkia2PRja08oCFxSNf2UkgHo2u6KVAy3reXZd1yWRO1wbHaT5Dnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;864&quot;/&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;我们同时开启事务 A 和事务 B，先在事务 A 中进行某个条件范围的查询，读取的时候采用排它锁，在事务 B 中增加一条符合该条件范围的数据，并进行提交，然后我们在事务 A 中再次查询该条件范围的数据，就会发现结果集中多出一个符合条件的数据，这样就出现了幻读。&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;出现幻读的原因是在读已提交的情况下，InnoDB 只采用记录锁（Record Locking）。&lt;/section&gt;&lt;section&gt;InnoDB 三种行锁的方式：&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、在可重复读的情况下，InnoDB 可以通过 Next-Key 锁 +MVCC 来解决幻读问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;想插入球员艾利克斯·伦（身高 2.16 米）的时候，事务 B 会超时，无法插入该数据。&lt;/section&gt;&lt;section&gt;这是因为采用了 Next-Key 锁，会将 height&amp;gt;2.08 的范围都进行锁定，就无法插入符合这个范围的数据了。然后事务 A 重新进行条件范围的查询，就不会出现幻读的情况。&lt;img data-ratio=&quot;0.5605726872246696&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgSWF9lHzdyW8leTRuN8I92ibAmJT4ekba2QL5LExGBbztAMsPMyeJG9Kn4syOWCYdMaicTpfZnHicvmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1816&quot;/&gt;&lt;/section&gt;&lt;h2&gt;六、总结&lt;/h2&gt;&lt;p&gt;&lt;span&gt;MVCC 的核心就是 Undo Log+ Read View。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时针对不同的隔离级别，Read View 的生成策略不同，也就实现了不同的隔离级别。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;🎉&lt;/span&gt; 福利&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;关注公众号回复关键字：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;MySQL&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，即可免费获取&lt;strong&gt;《&lt;span&gt;高性能MySQL 第3版》&lt;/span&gt;一套&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;·················· &lt;/span&gt;&lt;span&gt;END&lt;/span&gt;&lt;span&gt; ··················&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关注公众号，免费领学习资料&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA3MDg5MDkzOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgQmUQ0Aca9qSYNFn0tQEXQc5EibBkqQLYtibYBj1hXuagwXkNc3kVwplHxIl7KQfBIiagysgn9GDUUibw/0?wx_fmt=png&quot; data-nickname=&quot;架构精进之路&quot; data-alias=&quot;jiagou_jingjin&quot; data-signature=&quot;十年研发风雨路，大厂架构师，CSDN博客专家。专注软件架构研究，技术学习与职业成长，坚持分享接地气儿的架构技术干货文章！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;十年研发路，大厂架构师，&lt;/span&gt;&lt;span&gt;CSDN博客专家&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;专注架构技术学习及分享，职业与认知升级&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;坚持分享接地气儿的干货，&lt;span&gt;期待与你一起成长&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;往期热文推荐：&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98311&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgTqLjdQBs7fV8zqHRaQhA2ibia13fFn6ibS5qr5PpmZoxd8nlhAyJu7d1CjLicAruicOEb7uxibEGM476xg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;87502&quot;&gt;&lt;p&gt;&lt;span&gt;「架构精进之路」专注架构研究，技术分享&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;97708&quot;&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;点“赞”和“在看”哦&lt;/span&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;1.5925925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/noz2jw2hPlWiaCrGuJxBicU5mcib3QapDLyo6eKnNVm9dPTV4Z1SicHLtrCCwOG9gblMBFlKf7p9cvwL6wIkZJvamg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;135&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3710ea4f23dcd9ac075e641311ac4367</guid>
<title>iOS 混淆工具探索</title>
<link>https://toutiao.io/k/izfw6j4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fa9d7005e91a8e974312da240e159e7d</guid>
<title>如何做到 4 天上线一个小程序？</title>
<link>https://toutiao.io/k/4w4by6z</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5472222222222223&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/XyyqpRDrAeNH25ickiaKXrlj76LWRkObnMnSl9vAghH8hS3ibsckPOfcFHicAMdiaI4UZiaETIic5uvicC5nDLsticDpGpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自 6 月 6 号上线 “黑客说” 网页版（hackertalk.net）以来吸引了很多用户，为了进一步完善终端体验，我们决定复用已有的技术栈，实现微信端小程序，前后开发仅花了4天，本文主要从技术的角度讨论我们如何快速上线小程序。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7289719626168224&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/XyyqpRDrAeNH25ickiaKXrlj76LWRkObnM3INq4SAWdibiaUbrYkFBrBztRt7sAcxxwiagq4Dxu8k1d2maGnRgibhqYA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;642&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;黑客说是什么 ？&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是我们专门为程序员群体定制的交流平台，有及时技术资讯、高质量技术问答、实用编程经验分享，还有程序员的日常生活。接近 500 个编程相关垂直话题。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.32297447280799113&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/XyyqpRDrAeNH25ickiaKXrlj76LWRkObnM1qeW3xAFHBY0aZZhm6rZpTriakpwfjIialW4xtSNIibdeEO7lbqSuIFNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;901&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个高度定制的 Markdown 编辑器：所见即所得，再也不用分屏预览了～&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4826086956521739&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/XyyqpRDrAeNH25ickiaKXrlj76LWRkObnMRJQjzwvF8ibHTBOibM0anniaFsCkjlKoibVKCv2DeWtMCWuwEXESvYibicEA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;690&quot;/&gt;&lt;figcaption&gt;网页版编辑器：插入 latex 公式&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4826086956521739&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/XyyqpRDrAeNH25ickiaKXrlj76LWRkObnMicDcDlyHvSvysZEPry2e3ibzIeNvAqbhQlvILxB2qrCFbYUFaBjNwc9Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;690&quot;/&gt;&lt;figcaption&gt;网页版编辑器：插入 markdown 文本&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;感兴趣的小伙伴可以戳下面链接直接体验小程序版本 👇👇&lt;/p&gt;&lt;p&gt;&lt;mp-miniprogram data-miniprogram-appid=&quot;wx815bfb420a5256e3&quot; data-miniprogram-path=&quot;pages/post/index?id=189392795524841472&quot; data-miniprogram-nickname=&quot;黑客说&quot; data-miniprogram-avatar=&quot;http://mmbiz.qpic.cn/mmbiz_png/UAvN7J9XxS85wcQ2kbPrpp1dEd68bUtdI9PPmbEjG8YgZ9ibtzqn7SHH0IFUotqItjqSUZVyjv6Po6hd0STEYQw/640?wx_fmt=png&amp;amp;wxfrom=200&quot; data-miniprogram-title=&quot;黑客说第一帖：Happy hacking!&quot; data-miniprogram-imageurl=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/XyyqpRDrAeNH25ickiaKXrlj76LWRkObnMJB90XF7f8vMFAknwsphO04lQXdS4H7g3D8szGSGe1uhIYZUFeBBKRw/0?wx_fmt=jpeg&quot; data-miniprogram-type=&quot;card&quot; data-miniprogram-servicetype=&quot;0&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;网页端技术栈&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了代码更好地复用和维护，我们在 Vue 和 React 中选择了 React，网页端主要技术栈如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;react + typescript + redux + immer + redux-saga + axios + tailwindcss + fakerjs&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;typescript 项目必备，极大提高代码正确性和可维护性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;immer 替代了传统的 immutablejs 方案，在 reducer 中实现类似 vue 的直接数值操作（简洁性），同时保持 immutable 数据流的优点（可维护性）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;saga 保持了API接口调用的简洁性、可调试性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;axios 封装了 http 请求，可以通过自定义 adapter 适应不同终端运行环境&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tailwindcss 通过原子化的 css 大大降低了样式文件体积，加快网页加载速度，也很大程度降低了小程序包体积（2MB 限制），更多的代码空间可以用于 UI 界面和 JS 逻辑&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;fakerjs 用于模拟数据，在开发环境中注入数据到 redux，方便调试&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小程序端技术栈&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小程序端技术栈和网页端高度重合（这也是我们能够快速上线应用的原因），其中最大的变化是由 react 变为 react + taro。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Taro 是一个开放式跨端跨框架解决方案，支持使用 React/Vue/Nerv 等框架来开发 微信 / 京东 / 百度 / 支付宝 / 字节跳动 / QQ 小程序 / H5 / RN 等应用&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小程序端开发可谓混乱至极，原生代码难以组织、难以维护，通常都需要一些框架进行封装，Taro 是我们在使用了几个不同方案后决定采纳的，和 react 高度重合，可以直接使用 hook，极大提高代码复用的可能性（这是以前积累的经验基础）。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;APP 端技术栈&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前黑客说还没有上线相关 APP，技术栈复用可以直接将 react 换为 react-native。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;代码文件组织&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;组织良好的代码是高度复用的关键，我们采用 components + containers 的代码分割方式，严格规范代码组织方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;UI 界面相关组件只能放在 components 文件夹，无状态，不能耦合任何状态管理库相关代码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据注入的容器组件只能放于 containers 文件夹，不能包含任何 UI 相关代码，比如 &lt;code&gt;div&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模块化、原子化：代码分层设计，实现组件高度复用，保持应用一致性&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文件夹布局如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;├── assets     固定资源文件：图片、文字、svg 等&lt;br/&gt;├── components 纯 UI 组件&lt;br/&gt;├── constants  全局常量&lt;br/&gt;├── containers 纯容器组件&lt;br/&gt;├── hooks      自定义 hooks&lt;br/&gt;├── layout     布局相关 UI 逻辑&lt;br/&gt;├── locales    国际化相关&lt;br/&gt;├── pages      整页逻辑&lt;br/&gt;├── services   API 接口代码&lt;br/&gt;├── store      状态管理代码&lt;br/&gt;├── styles     样式代码&lt;br/&gt;├── types      ts 类型声明&lt;br/&gt;└── utils      公共工具类&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Store 状态管理&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;├── actions&lt;br/&gt;├── reducers&lt;br/&gt;├── sagas&lt;br/&gt;├── selectors&lt;br/&gt;└── types&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;saga 调用 API 代码组织如下：调用调试非常方便&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt;* &lt;span&gt;getPostById&lt;/span&gt;(&lt;span&gt;action: ReduxAction&lt;/span&gt;): &lt;span&gt;any&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; res = &lt;span&gt;yield&lt;/span&gt; call(postApi.getPostById, action.payload);&lt;br/&gt;    &lt;span&gt;yield&lt;/span&gt; put({ &lt;span&gt;type&lt;/span&gt;: T.GET_POST_SUCCESS, payload: res.data.data });&lt;br/&gt;    action.resolve?.();&lt;br/&gt;  } &lt;span&gt;catch&lt;/span&gt; (e) {&lt;br/&gt;    action.reject?.();&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中的 postApi 来自 services 文件夹：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getPostById&lt;/span&gt;(&lt;span&gt;id: &lt;span&gt;string&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; axios.get&amp;lt;R&amp;lt;Post&amp;gt;&amp;gt;(&lt;span&gt;`/v1/posts/by_id/&lt;span&gt;${id}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小程序端特殊适配&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Cookie&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于小程序端无法支持 http cookie，无法像浏览器一样使用 cookie 机制保证安全性和维护用户登录状态，我们需要手动模拟一个 cookie 机制，这里我们推荐使用京东开源的一个方案：&lt;strong&gt;京东购物小程序cookie方案实践&lt;/strong&gt;，可以实现 cookie 过期、多 cookie 功能。其原理使用了 localstorage 替代 cookie。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Http Request&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小程序端只能使用 &lt;code&gt;wx.request&lt;/code&gt; 进行 http 请求，如果大量 API 直接使用这个接口编写，代码将难以维护和复用，我们使用 axios 的 adapter 模式封装 &lt;code&gt;wx.request&lt;/code&gt; ，请求结果和 error 都按 axios 数据格式进行加工。这样我们就能够直接在小程序端使用 axios 了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;转换请求参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;toQueryStr&lt;/span&gt;(&lt;span&gt;obj: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!obj) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; arr: &lt;span&gt;string&lt;/span&gt;[] = [];&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; p &lt;span&gt;in&lt;/span&gt; obj) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (obj.hasOwnProperty(p)) {&lt;br/&gt;      arr.push(p + &lt;span&gt;&#x27;=&#x27;&lt;/span&gt; + &lt;span&gt;encodeURIComponent&lt;/span&gt;(obj[p]));&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&#x27;?&#x27;&lt;/span&gt; + arr.join(&lt;span&gt;&#x27;&amp;amp;&#x27;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;axios 适配器模式（CookieUtil 代码参考上文京东的例子）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;axios.defaults.adapter = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;config: AxiosRequestConfig&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 请求字段拼接&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; url = &lt;span&gt;&#x27;https://api.example.com&#x27;&lt;/span&gt; + config.url;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (config.params) {&lt;br/&gt;      url += toQueryStr(config.params);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 常规请求封装&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve: (&lt;span&gt;r: AxiosResponse&lt;/span&gt;) =&amp;gt; &lt;span&gt;void&lt;/span&gt;, reject: (&lt;span&gt;e: AxiosError&lt;/span&gt;) =&amp;gt; &lt;span&gt;void&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;      wx.request({&lt;br/&gt;        url: url,&lt;br/&gt;        method: config.method,&lt;br/&gt;        data: config.data,&lt;br/&gt;        header: {&lt;br/&gt;          &lt;span&gt;&#x27;Cookie&#x27;&lt;/span&gt;: CookieUtil.getCookiesStr(),&lt;br/&gt;          &lt;span&gt;&#x27;X-XSRF-TOKEN&#x27;&lt;/span&gt;: CookieUtil.getCookie(&lt;span&gt;&#x27;XSRF-TOKEN&#x27;&lt;/span&gt;)&lt;br/&gt;        },&lt;br/&gt;        success: &lt;span&gt;(&lt;span&gt;res&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;          &lt;span&gt;const&lt;/span&gt; setCookieStr = res.header[&lt;span&gt;&#x27;Set-Cookie&#x27;&lt;/span&gt;] || res.header[&lt;span&gt;&#x27;set-cookie&#x27;&lt;/span&gt;];&lt;br/&gt;          CookieUtil.setCookieFromHeader(setCookieStr);&lt;br/&gt;&lt;br/&gt;          &lt;span&gt;const&lt;/span&gt; axiosRes: AxiosResponse = {&lt;br/&gt;            data: res.data,&lt;br/&gt;            status: res.statusCode,&lt;br/&gt;            statusText: StatusText[res.statusCode] &lt;span&gt;as&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;            headers: res.header,&lt;br/&gt;            config&lt;br/&gt;          };&lt;br/&gt;          &lt;span&gt;if&lt;/span&gt; (res.statusCode &amp;lt; &lt;span&gt;400&lt;/span&gt;) {&lt;br/&gt;            resolve(axiosRes);&lt;br/&gt;          } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;const&lt;/span&gt; axiosErr: AxiosError = {&lt;br/&gt;              name: &lt;span&gt;&#x27;&#x27;&lt;/span&gt;,&lt;br/&gt;              message: &lt;span&gt;&#x27;&#x27;&lt;/span&gt;,&lt;br/&gt;              config,&lt;br/&gt;              response: axiosRes,&lt;br/&gt;              isAxiosError: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;              toJSON: &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; res&lt;br/&gt;            };&lt;br/&gt;            reject(axiosErr);&lt;br/&gt;          }&lt;br/&gt;        },&lt;br/&gt;        fail: &lt;span&gt;(&lt;span&gt;e: &lt;span&gt;any&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;          &lt;span&gt;const&lt;/span&gt; axiosErr: AxiosError = {&lt;br/&gt;            name: &lt;span&gt;&#x27;&#x27;&lt;/span&gt;,&lt;br/&gt;            message: &lt;span&gt;&#x27;&#x27;&lt;/span&gt;,&lt;br/&gt;            config,&lt;br/&gt;            isAxiosError: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;            toJSON: &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; e&lt;br/&gt;          };&lt;br/&gt;          reject(axiosErr);&lt;br/&gt;        }&lt;br/&gt;      });&lt;br/&gt;    });&lt;br/&gt;  };&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;axios 适配完成后原先 API 相关代码无需改动一行即可直接复用。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Message&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息弹窗和 toast 不能运行在小程序端，我们通过接口兼容实现代码复用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * @author z0000&lt;br/&gt; * @version 1.0&lt;br/&gt; * message 弹窗，api 接口参考 antd，小程序向此接口兼容&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Taro &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;@tarojs/taro&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; log &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;./log&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; message = {&lt;br/&gt;  info(content: &lt;span&gt;string&lt;/span&gt;, duration = &lt;span&gt;1500&lt;/span&gt;) {&lt;br/&gt;    Taro.showToast({ title: content, icon: &lt;span&gt;&#x27;none&#x27;&lt;/span&gt;, duration })&lt;br/&gt;      .catch(&lt;span&gt;&lt;span&gt;e&lt;/span&gt; =&amp;gt;&lt;/span&gt; log.error(&lt;span&gt;&#x27;showToast error: &#x27;&lt;/span&gt;, e));&lt;br/&gt;  },&lt;br/&gt;&lt;br/&gt;  success(content: &lt;span&gt;string&lt;/span&gt;, duration = &lt;span&gt;1500&lt;/span&gt;) {&lt;br/&gt;    Taro.showToast({ title: content, icon: &lt;span&gt;&#x27;success&#x27;&lt;/span&gt;, duration })&lt;br/&gt;      .catch(&lt;span&gt;&lt;span&gt;e&lt;/span&gt; =&amp;gt;&lt;/span&gt; log.error(&lt;span&gt;&#x27;showToast error: &#x27;&lt;/span&gt;, e));&lt;br/&gt;  },&lt;br/&gt;&lt;br/&gt;  warn(content: &lt;span&gt;string&lt;/span&gt;, duration = &lt;span&gt;1500&lt;/span&gt;) {&lt;br/&gt;    Taro.showToast({ title: content, icon: &lt;span&gt;&#x27;none&#x27;&lt;/span&gt;, duration })&lt;br/&gt;      .catch(&lt;span&gt;&lt;span&gt;e&lt;/span&gt; =&amp;gt;&lt;/span&gt; log.error(&lt;span&gt;&#x27;showToast error: &#x27;&lt;/span&gt;, e));&lt;br/&gt;  },&lt;br/&gt;&lt;br/&gt;  error(content: &lt;span&gt;string&lt;/span&gt;, duration = &lt;span&gt;1500&lt;/span&gt;) {&lt;br/&gt;    Taro.showToast({ title: content, icon: &lt;span&gt;&#x27;none&#x27;&lt;/span&gt;, duration })&lt;br/&gt;      .catch(&lt;span&gt;&lt;span&gt;e&lt;/span&gt; =&amp;gt;&lt;/span&gt; log.error(&lt;span&gt;&#x27;showToast error: &#x27;&lt;/span&gt;, e));&lt;br/&gt;  },&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// eslint-disable-next-line no-unused-vars,@typescript-eslint/no-unused-vars&lt;/span&gt;&lt;br/&gt;  loading(content: &lt;span&gt;string&lt;/span&gt;, _duration = &lt;span&gt;1500&lt;/span&gt;) {&lt;br/&gt;    Taro.showLoading({ title: content })&lt;br/&gt;      .catch(&lt;span&gt;&lt;span&gt;e&lt;/span&gt; =&amp;gt;&lt;/span&gt; log.error(&lt;span&gt;&#x27;showLoading error: &#x27;&lt;/span&gt;, e));&lt;br/&gt;  },&lt;br/&gt;&lt;br/&gt;  destroy() {&lt;br/&gt;    Taro.hideLoading();&lt;br/&gt;  }&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; message;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里接口参考的 Antd 的 Message API，实现浏览器端和小程序端的兼容。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;History&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小程序端 history 机制和浏览器端不一样，为了代码复用，我们将小程序路由 API 转换适配浏览器端接口（react router 的 history 方法）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * common api 小程序向 react router 的 history 方法兼容&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Taro &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;@tarojs/taro&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; log &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;./log&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; history = {&lt;br/&gt;  &lt;span&gt;// &lt;span&gt;TODO:&lt;/span&gt; 增加query对象方法&lt;/span&gt;&lt;br/&gt;  push(path: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;    Taro.navigateTo({ url: &lt;span&gt;&#x27;/pages&#x27;&lt;/span&gt; + path }).catch(&lt;span&gt;&lt;span&gt;e&lt;/span&gt; =&amp;gt;&lt;/span&gt; log.error(&lt;span&gt;&#x27;navigateTo fail: &#x27;&lt;/span&gt;, e));&lt;br/&gt;  },&lt;br/&gt;&lt;br/&gt;  replace(path: &lt;span&gt;string&lt;/span&gt;) {&lt;br/&gt;    Taro.redirectTo({ url: path }).catch(&lt;span&gt;&lt;span&gt;e&lt;/span&gt; =&amp;gt;&lt;/span&gt; log.error(&lt;span&gt;&#x27;redirectTo fail: &#x27;&lt;/span&gt;,e));&lt;br/&gt;  },&lt;br/&gt;&lt;br/&gt;  go(n: &lt;span&gt;number&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (n &amp;gt;= &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.error(&lt;span&gt;&#x27;positive number not support in wx environment&#x27;&lt;/span&gt;);&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    Taro.navigateBack({ delta: &lt;span&gt;-1&lt;/span&gt; * n }).catch(&lt;span&gt;&lt;span&gt;e&lt;/span&gt; =&amp;gt;&lt;/span&gt; log.error(&lt;span&gt;&#x27;navigateBack fail: &#x27;&lt;/span&gt;,e));&lt;br/&gt;  },&lt;br/&gt;&lt;br/&gt;  goBack() {&lt;br/&gt;    Taro.navigateBack({ delta: &lt;span&gt;1&lt;/span&gt; }).catch(&lt;span&gt;&lt;span&gt;e&lt;/span&gt; =&amp;gt;&lt;/span&gt; log.error(&lt;span&gt;&#x27;navigateBack fail: &#x27;&lt;/span&gt;,e));&lt;br/&gt;  }&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; history;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后批量搜索代码中 &lt;code&gt;useHistory&lt;/code&gt; 相关 hook 代码，转换为上述实现即可。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Router&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小程序端不能直接使用 react-router 类似的路由管理方案，受益于代码模块化分割，大部分代码并没有耦合 react-router-dom 相关的东西，最多的就是 &lt;code&gt;&amp;lt;Link&amp;gt;&lt;/code&gt; 组件，这里我们小小改造一下 Link 组件，批量替代即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import { FC, useCallback } from &#x27;react&#x27;;&lt;br/&gt;import Taro from &#x27;@tarojs/taro&#x27;;&lt;br/&gt;import { View } from &#x27;@tarojs/components&#x27;;&lt;br/&gt;import { LinkProps } from &#x27;react-router-dom&#x27;;&lt;br/&gt;&lt;br/&gt;const Index: FC&amp;lt;LinkProps&amp;gt; = ({ to, ...props}) =&amp;gt; {&lt;br/&gt;&lt;br/&gt;  const onClick = useCallback(e =&amp;gt; {&lt;br/&gt;    e.stopPropagation();&lt;br/&gt;    Taro.navigateTo({ url: &#x27;/pages&#x27; + to as string });&lt;br/&gt;  }, [to]);&lt;br/&gt;&lt;br/&gt;  // @ts-ignore&lt;br/&gt;  return &amp;lt;View {...props} onClick={onClick}&amp;gt;{props.children}&amp;lt;/View&amp;gt;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;export default Index;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是 &lt;code&gt;Taro.navigateTo&lt;/code&gt; 不能直接跳转 Tab 页面，所有最终代码完成后需要 search + 测试覆盖检查相关问题。当然，你也可以在上面代码中检查 to 参数是否为 tab 页面，切换成 &lt;code&gt;Taro.switchTab&lt;/code&gt; 方法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Path Params&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小程序不支持类似 &lt;code&gt;/post/:id&lt;/code&gt; 的路由参数，我们需要将路由参数转换为：&lt;code&gt;/post?id=xx&lt;/code&gt;，这个转换通过 IDE 搜索，批量 replace 即可。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;CSS&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于小程序端的 rpx 单位、px 单位直接使用会有很大的复用问题，导致网页端往小程序端迁移时需要大量改造 HTML 代码，这里我们使用 sass 实现了 tailwindcss 类似的功能（针对小程序端进行改造），通过变量开关切换单位，可以做到不同设计稿代码也能兼容（375px 和 750px 或者 rpx，rem 单位都可以直接兼容）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计复用有时比代码复用更加重要，这是用户体验一致性的前提，幸运的是 tailwincss 之类的方案选型让我们很容易做到这一点，我们后续将开源小程序端 tailwindcss 代码，敬请期待。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;团队协作&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;协作也是很重要的一环，产品成功离不开高效合作，我们使用 google doc 全家桶进行协作，包括项目文档、需求、任务管理、邮件，google 全家桶最大的好处就是多端支持，这是目前支持终端最多、协作最方便的工具。linux + android + ios + ipad + windows + mac 都能无缝同步协作。方便设计师、产品经理、程序员共同工作。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;最后&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欢迎各位体验～&lt;/p&gt;&lt;p&gt;&lt;mp-miniprogram data-miniprogram-appid=&quot;wx815bfb420a5256e3&quot; data-miniprogram-path=&quot;pages/post/index?id=189392795524841472&quot; data-miniprogram-nickname=&quot;黑客说&quot; data-miniprogram-avatar=&quot;http://mmbiz.qpic.cn/mmbiz_png/UAvN7J9XxS85wcQ2kbPrpp1dEd68bUtdI9PPmbEjG8YgZ9ibtzqn7SHH0IFUotqItjqSUZVyjv6Po6hd0STEYQw/640?wx_fmt=png&amp;amp;wxfrom=200&quot; data-miniprogram-title=&quot;黑客说第一帖：Happy hacking!&quot; data-miniprogram-imageurl=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/XyyqpRDrAeNH25ickiaKXrlj76LWRkObnMJB90XF7f8vMFAknwsphO04lQXdS4H7g3D8szGSGe1uhIYZUFeBBKRw/0?wx_fmt=jpeg&quot; data-miniprogram-type=&quot;card&quot; data-miniprogram-servicetype=&quot;0&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5bb7d83e06a7f560d6f440a257610026</guid>
<title>Docker 安装 Jenkins</title>
<link>https://toutiao.io/k/rw7auj4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 部署jenkins&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1 创建jenkins的工作目录&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;//创建工作目录 &lt;br/&gt;mkdir /var/jenkins_home&lt;br/&gt;&lt;br/&gt;//赋予权限 &lt;br/&gt;chown -R 1000 /var/jenkins_home&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2 通过docker部署&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2.1 拉取镜像&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;docker pull  jenkinsci/blueocean&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2.2 生成容器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#注意：切换一行执行命令 &lt;/span&gt;&lt;br/&gt;docker run -u root -d -p 8080:8080 -p 50000:50000 &lt;br/&gt; -v /var/jenkins_home:/var/jenkins_home &lt;br/&gt; -v /usr/bin/docker:/usr/bin/docker  &lt;br/&gt; -v /var/run/docker.sock:/var/run/docker.sock  &lt;br/&gt; -v /usr/&lt;span&gt;local&lt;/span&gt;/bin/docker-compose:/usr/&lt;span&gt;local&lt;/span&gt;/bin/docker-compose &lt;br/&gt; jenkinsci/blueocean &lt;br/&gt; &lt;br/&gt; 一行显示:&lt;br/&gt;docker run -u root -d -p 8080:8080 -p 50000:50000 -v /var/jenkins_home:/var/jenkins_home  -v /usr/bin/docker:/usr/bin/docker   -v /var/run/docker.sock:/var/run/docker.sock   -v /usr/&lt;span&gt;local&lt;/span&gt;/bin/docker-compose:/usr/&lt;span&gt;local&lt;/span&gt;/bin/docker-compose  jenkinsci/blueocean &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3 通过docker-compose部署&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行docker-compose脚本&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;version: &lt;span&gt;&#x27;3.4&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;services:&lt;br/&gt;  jenkins:&lt;br/&gt;    container_name: jenkins&lt;br/&gt;    image: jenkinsci/blueocean&lt;br/&gt;    ports:&lt;br/&gt;      - &lt;span&gt;&quot;8080:8080&quot;&lt;/span&gt;&lt;br/&gt;      - &lt;span&gt;&quot;50000:50000&quot;&lt;/span&gt;&lt;br/&gt;    restart: always&lt;br/&gt;    user: root&lt;br/&gt;    volumes:&lt;br/&gt;      - &lt;span&gt;&#x27;/var/jenkins_home:/var/jenkins_home&#x27;&lt;/span&gt;&lt;br/&gt;      - &lt;span&gt;&#x27;/usr/bin/docker:/usr/bin/docker&#x27;&lt;/span&gt;&lt;br/&gt;      - &lt;span&gt;&#x27;/var/run/docker.sock:/var/run/docker.sock&#x27;&lt;/span&gt;&lt;br/&gt;      - &lt;span&gt;&#x27;/usr/local/bin/docker-compose:/usr/local/bin/docker-compose&#x27;&lt;/span&gt;&lt;br/&gt;    environment:&lt;br/&gt;      - TZ=Asia/Shanghai&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3.1 执行命令生成容器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;docker-compose -f docker-compose.yaml up --build -d jenkins&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 访问jenkins网站&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;访问地址：http://IP:8080&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5780998389694042&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gtQF7ojZDqLxLeo3bVTuM356YYGHyvj01u5QHVaEUbNPCa4iaJUmB8dDf77ApI2jM3U12fHFuRkibQ6zxH8veuEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;621&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 寻找超级管理员密码&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进入容器，然后去容器的执行目录下查找管理员的密码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;// 进入容器 &lt;br/&gt;docker &lt;span&gt;exec&lt;/span&gt; -it 容器ID bash &lt;br/&gt;// 查看密码 &lt;br/&gt;cat /var/jenkins_home/secrets/initialAdminPassword&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1523046092184369&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gtQF7ojZDqLxLeo3bVTuM356YYGHyvj0UYqlDcVHkGqdWnbIib8vzdwdsViaBEBWicyMlUibRlV3ACzr5HC7IrecoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;499&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输入找到的管理员密码然后进入系统&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 进入jenkins&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新手入门，选择安装插件的方式，这里我们直接选择安装推荐的插件然后进入系统&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：安装插件报错的话继续在执行一遍。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3 设置管理员用户密码&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建管理员用户密码&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5379061371841155&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gtQF7ojZDqLxLeo3bVTuM356YYGHyvj0KSfQ2me5FrWQAW0OZ9gNsbmjghjYM0AqSxibF6eL9Mn9zDGUmqmulibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4 系统界面&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果系统管理里面有错误，那么我们可以手动安装和修改。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.5 修改镜像源&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;插件管理-&amp;gt;高级-&amp;gt;升级站点，修改为清华大学插件源&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# 清华大学官方镜像&lt;/span&gt;&lt;br/&gt;https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3 错误&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果出现错误，那么就需要去查看控制台输出，根据错误找原因。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 IPv4 forwarding is disabled&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;意思就是linux没有开启 Ipv4 数据包转发功能&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以先尝试重启docker，如果没有作用可以修改下面配置&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# 1. 打开 sysctl.conf&lt;/span&gt;&lt;br/&gt;vim /etc/sysctl.conf&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 2.添加下面一行&lt;/span&gt;&lt;br/&gt;net.ipv4.ip_forward=1&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 3.重启 network 和 docker&lt;/span&gt;&lt;br/&gt;systemctl restart network &amp;amp;&amp;amp; systemctl restart docker&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4 参考文档&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;官方文档：https://www.jenkins.io/doc/book/installing/docker/&lt;/p&gt;&lt;p&gt;xiaoxiaotank：https://www.cnblogs.com/xiaoxiaotank/p/14762665.html&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e7a74a2f3563a8f1bbb9e62cf02f96f4</guid>
<title>刷算法，这些 API 不可不知</title>
<link>https://toutiao.io/k/wz8eh0f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是老三，最近在刷算法，发现有些api记得不熟，所以整理了一波，如果你也在刷题，赶紧&lt;code&gt;收藏&lt;/code&gt;吧！&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;集合&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在刷题中，各种数据结构是我们常常用到的，例如栈实现迭代、哈希存储键值对等等，我们来看看常用集合和相关api。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类/接口&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;th&gt;方法&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;String&lt;/td&gt;&lt;td&gt;字符串&lt;/td&gt;&lt;td&gt;charAt  toCharArray  split  substring  indexOf  lastIndexOf  replace  length&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;List&lt;/td&gt;&lt;td&gt;列表&lt;/td&gt;&lt;td&gt;add  remove  get  size  subList&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Stack&lt;/td&gt;&lt;td&gt;栈&lt;/td&gt;&lt;td&gt;push  pop  peek  isEmpty  size&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Queue&lt;/td&gt;&lt;td&gt;队列&lt;/td&gt;&lt;td&gt;offer  poll  peek  isEmpty  size&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Deque&lt;/td&gt;&lt;td&gt;双向队列&lt;/td&gt;&lt;td&gt;offerFirst  offerLast  pollFirst pollLast   peekFirst  peekLast isEmpty  size&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;PriorityQueue&lt;/td&gt;&lt;td&gt;优先队列&lt;/td&gt;&lt;td&gt;offer poll peek isEmpty size&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Set&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;add   remove   contains   isEmpty   size   first(TreeSet)   last(TreeSet)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Map&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;put   get   getOrDefault   containsKey   containsValue   keySet   values   isEmpty size&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数组&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数组就不用多说什么了，大家最熟悉的数据结构。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;Arrays&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Arrays是比较常用的数组工具类，可以完成排序、拷贝等功能。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从小到大排序：Arrays.sort(int[] arr)&lt;code/&gt;Arrays.sort(int[] arr, int fromIndex, int toIndex)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Arrays.sort(&lt;span&gt;int&lt;/span&gt;[] arr, &lt;span&gt;int&lt;/span&gt; fromIndex, &lt;span&gt;int&lt;/span&gt; toIndex, 比较器);   &lt;span&gt;//一定是需要泛型&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;Arrays.sort(arr, (o1, o2) -&amp;gt; o2 - o1);   &lt;span&gt;//数组全部 从大到小排序 跟Collections.sort()一样&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;Arrays.sort(arr, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, (o1, o2) -&amp;gt; o2 - o1);   &lt;span&gt;//从大到小排序，只排序[0, 3)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt;[] a = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[&lt;span&gt;5&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;int&lt;/span&gt;[] newA = Array.copyOf(a, &lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;列表&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;列表主要有两种实现，分别是&lt;strong&gt;顺序表&lt;/strong&gt;和&lt;strong&gt;链表&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6756756756756757&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdkFHwTZ52CGtmPON2vpU1ia34Y6OQJTD68Lickqh1r403tsJIN9Zhiak66XI4fcqtw5tV7jSkXk6dlw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;518&quot;/&gt;&lt;figcaption&gt;列表实现&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顺序表本质是一个可以动态扩容的数组，在Java中的实现是&lt;code&gt;ArrayList&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;链表是一个双向链表，Java中链表的实现为&lt;code&gt;LinkedList&lt;/code&gt;。&lt;code&gt;LinkedList&lt;/code&gt;在Java中可谓是非常强大的一个集合类，它还可以作为双向队列、栈来使用。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意，ArrayList的扩容需要将旧的数组的元素复制到新的数组，时间复杂度为O(n)。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;基本方法&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; array = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();    &lt;span&gt;// 顺序表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Set&amp;lt;Integer&amp;gt; a = new HashSet....&lt;/span&gt;&lt;br/&gt;List&amp;lt;Integer&amp;gt; b = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(a);     &lt;span&gt;//接受一个集合容器&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;get(&lt;span&gt;int&lt;/span&gt; index)    &lt;span&gt;// 返回元素位置在index的元素e --- array O(1), list O(n)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;size()    &lt;span&gt;// 返回数组/链表长度 --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;add(E e)    &lt;span&gt;// 在尾部添加一个元素e --- O(1)&lt;/span&gt;&lt;br/&gt;add(&lt;span&gt;int&lt;/span&gt; index, E e)    &lt;span&gt;// 在index位置插一个元素e --- O(n)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;.remove(&lt;span&gt;int&lt;/span&gt; index)    &lt;span&gt;// 删除位于index的元素，并返回删除元素e --- 删除最后元素为O(1)， 其余为O(n)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//删除最后元素 list.remove(list.size() - 1);&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;.subList(&lt;span&gt;int&lt;/span&gt; from, &lt;span&gt;int&lt;/span&gt; to)    &lt;span&gt;// 相当于返回原数组的一个片段,但不要对其进行改动，改动会影响原数组 --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// List&amp;lt;Integer&amp;gt; list, 对原来的list和返回的list做的“非结构性修改”(non-structural changes)，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//都会影响到彼此对方. 如果你在调用了sublist返回了子list之后，如果修改了原list的大小，那么之前产生的子list将会失效，变得不可使用&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;集合工具&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Collections是集合工具类，提供了一些操作集合的方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Collections.sort(list); 从小到大排序&lt;br/&gt;Collections.sort(list, (o1, o2) -&amp;gt; o2 - o1); 从大到小排序， 第二个参数为一个比较器&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两种实现，ArrayList利于查找，LinkedList利于增删。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大概对比如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;操作&lt;/th&gt;&lt;th&gt;ArrayList&lt;/th&gt;&lt;th&gt;LinkedList&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;get(int index)&lt;/td&gt;&lt;td&gt;O(1)&lt;/td&gt;&lt;td&gt;O(n)，平均 n / 4步&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;add(E element)&lt;/td&gt;&lt;td&gt;最坏情况（扩容）O(n)  ，平均O(1)&lt;/td&gt;&lt;td&gt;O(1)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;add(int index, E element)&lt;/td&gt;&lt;td&gt;O(n)  ,平均n / 2步&lt;/td&gt;&lt;td&gt;O(n)，平均 n / 4步&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;remove(int index)&lt;/td&gt;&lt;td&gt;O(n)    平均n /2步&lt;/td&gt;&lt;td&gt;O(n)，平均 n / 4步&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;栈&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java中定义了&lt;code&gt;Stack&lt;/code&gt;接口，实现类是&lt;code&gt;Vector&lt;/code&gt;。&lt;code&gt;Vector&lt;/code&gt;是一个祖传集合类，不推荐使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那应该用什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Deque&lt;/code&gt;接口实现了完善堆栈操作集合，它有一个我们熟悉的实现类&lt;code&gt;LinkedList&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0117302052785924&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdkFHwTZ52CGtmPON2vpU1iaG1iaEP21eoYnVB5PjiaEde8UJV1tsZNNFv3pe4S2LAoutW2gvjyIQ4VA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;341&quot;/&gt;&lt;figcaption&gt;栈&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Deque&amp;lt;Integer&amp;gt; stack=&lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;push(E e);    &lt;span&gt;// 入栈元素e， 返回值为元素e --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;.pop();    &lt;span&gt;// 出栈一个元素，返回出栈元素e --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;peek();    &lt;span&gt;// 查看栈顶元素， 返回值为栈顶元素e --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;isEmpty()    &lt;span&gt;// 若栈空返回true， 否则返回false --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;size()    &lt;span&gt;// 返回栈中元素个数 --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;队列&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;队列s是一种先进先出的结构，在Java中的接口定义是&lt;code&gt;Queue&lt;/code&gt;，具体实现还是我们的老朋友&lt;code&gt;LinkedList&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2593856655290102&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdkFHwTZ52CGtmPON2vpU1iaJtoJMREPg3icdO4Nz1Lkz4X9B29AkcTx3xZEFeWsES1TTMFXu1obiarg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;586&quot;/&gt;&lt;figcaption&gt;单向队列&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Queue&amp;lt;Integer&amp;gt; q = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;offer(E e);    &lt;span&gt;// 队尾加入元素e。 若成功入队返回值true，否则返回false --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;poll();    &lt;span&gt;// 出队头，返回出队元素e --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;peek();    &lt;span&gt;// 查看队头元素， 返回值队首元素e --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;isEmpty()    &lt;span&gt;// 若队空返回true， 否则返回false --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;size()    &lt;span&gt;// 返回队中元素个数 --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;双向队列&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Queue&lt;/code&gt;有一个子接口&lt;code&gt;Dueue&lt;/code&gt;，即双向队列，和单向队列不同，它的出队入队可以从两个方向。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.33003300330033003&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdkFHwTZ52CGtmPON2vpU1iaPIRmxK1tIeEUpuuDKzBetH63LUIatsndkibRUvguVFjXaF89QBiaziaxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;606&quot;/&gt;&lt;figcaption&gt;双向队列&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Dueue&amp;lt;Integer&amp;gt; q = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;offFirst(Object e)   &lt;span&gt;// 将指定元素添加到双端队列的头部 --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;offLast(Object e)   &lt;span&gt;//将指定元素添加到双端队列的尾部 --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;pollFirst()   &lt;span&gt;//获取并删除双端队列的第一个元素 --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;pollLast()   &lt;span&gt;//获取并删除双端队列的最后一个元素 --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;peekFirst()   &lt;span&gt;//获取但不删除双端队列的第一个元素 --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;peekLast()   &lt;span&gt;//获取但不删除双端队列的最后一个元素 --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;优先队列&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优先队列是一种比较特殊的队列，保存队列元素的顺序不是按照元素添加的顺序来保存的，而是在添加元素的时候对元素的大小排序后再保存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在队头的元素不是按照先后顺序，而是按照大小顺序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java中的实现是&lt;code&gt;PriorityQueue&lt;/code&gt;，底层是一棵树， 以小根堆为例。对于任意结点来说，该节点的值比其左右孩子的值都要小。（就是最上面的结点最小）。大根堆类似，最上面结点最大&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Queue&amp;lt;Integer&amp;gt; minH = &lt;span&gt;new&lt;/span&gt; PriorityQueue&amp;lt;&amp;gt;();    &lt;span&gt;// 小根堆，默认大小为11 相当于  new PriorityQueue&amp;lt;&amp;gt;(11)&lt;/span&gt;&lt;br/&gt;Queue&amp;lt;Integer&amp;gt; minH = &lt;span&gt;new&lt;/span&gt; PriorityQueue&amp;lt;&amp;gt;(&lt;span&gt;100&lt;/span&gt;);  &lt;span&gt;// 定义一个默认容量有100的小根堆。在当中增加元素会扩容，只是开始指定大小。不是size，是capacity&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Queue&amp;lt;Integer&amp;gt; maxH = &lt;span&gt;new&lt;/span&gt; PriorityQueue&amp;lt;&amp;gt;((i1, i2) -&amp;gt; i2 - i1);    &lt;span&gt;// 大根堆，默认大小为11 相当于  new PriorityQueue&amp;lt;&amp;gt;(11, (i1, i2) -&amp;gt; i2 - i1)&lt;/span&gt;&lt;br/&gt;Queue&amp;lt;Integer&amp;gt; maxH = &lt;span&gt;new&lt;/span&gt; PriorityQueue&amp;lt;&amp;gt;(&lt;span&gt;100&lt;/span&gt;, (i1, i2) -&amp;gt; i2 - i1);    &lt;span&gt;// 定义一个默认容量有100的大根堆。在当中增加元素会扩容，只是开始指定大小&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;offer(E e);    &lt;span&gt;// 在堆中加入元素e，并调整堆。若成功入堆返回值true，否则返回false --- O(logN)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;poll();    &lt;span&gt;// 弹出堆顶元素，并重新调整堆，返回出队元素e --- O(logN)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;peek();    &lt;span&gt;// 查看堆顶元素， 返回值堆顶元素e --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;散列表&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;散列表示一种&amp;lt;key,value&amp;gt;型的数据结构，在Java中的实现是&lt;code&gt;HashMap&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Map&amp;lt;Characters, Integer&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;put(K key, V value);    &lt;span&gt;// 在Map中加入键值对&amp;lt;key, value&amp;gt;。返回value值。如果Map中有key，则replace旧的value --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;get(K key);    &lt;span&gt;// 返回Map中key对应的value。若Map中没有该key，则返回null --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;getOrDefault(K key, V defaultValue);    &lt;span&gt;// 返回Map中key对应的value。若Map中没有该key，则返回defaultValue --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// For example:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Map&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// if (...)    // 如果发现k，则k在Map中的值加1。没一开始没有k，则从0开始加1。（相当于给了key在Map中的一个初试值）&lt;/span&gt;&lt;br/&gt;    map.put(&lt;span&gt;&#x27;k&#x27;&lt;/span&gt;, map.getOrDefault(&lt;span&gt;&#x27;k&#x27;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;) + &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;containsKey(Key key);    &lt;span&gt;// 在Map中若存在key，则返回true，否则返回false --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;get(x) == &lt;span&gt;null&lt;/span&gt; &lt;span&gt;// 可以代替改用法&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;keySet();    &lt;span&gt;// 返回一个Set,这个Set中包含Map中所有的Key --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// For example:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// We want to get all keys in Map&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Map&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (Character key : map.keySet()) {&lt;br/&gt;    &lt;span&gt;// Operate with each key&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;values();    // 返回一个Collection&amp;lt;v&amp;gt;,里面全是对应的每一个value --- O(1)&lt;br/&gt;&lt;br/&gt;// For example:&lt;br/&gt;// We want to get all values in Map&lt;br/&gt;// Map&amp;lt;Character, Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;for (Integer value : map.values()) {&lt;br/&gt;    // Operate with each values&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;isEmpty()    &lt;span&gt;// 若Map为空返回true， 否则返回false --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;.size()    &lt;span&gt;// 返回Map中中键值对&amp;lt;K, V&amp;gt;的个数 --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Set&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Set是一种没有重复元素的集合，常用的实现是&lt;code&gt;HashSet&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Set&amp;lt;Integer&amp;gt; set = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;();&lt;br/&gt;List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;....;&lt;br/&gt;Set&amp;lt;Integer&amp;gt; set = &lt;span&gt;new&lt;/span&gt; HashSet&amp;lt;&amp;gt;(list);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;.add(E e);    &lt;span&gt;// 在集合中添加元素E e， 若成功添加则返回true，若集合中有元素e则返回false --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;remove(E e);    &lt;span&gt;// 在集合中删除元素e，若删除成功返回true；若集合中没有元素e，返回false --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;contains(E e);    &lt;span&gt;// 若存在元素e，则返回true，否则返回false --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;isEmpty()    &lt;span&gt;// 若集合为空返回true， 否则返回false --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;size()    &lt;span&gt;// 返回集合中中元素个数 --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;first()    &lt;span&gt;// 返回集合里的最小值（若给了比较器从大到小则是返回最大值）&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;last()    &lt;span&gt;// 返回集合里的最大值（若给了比较器从大到小则是返回最小值）&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;字符串&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;String&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不可变量(相当于只读final修饰)，每个位置元素是个char。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3458904109589041&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdkFHwTZ52CGtmPON2vpU1iazvUSB5hPu7KOPaf6nfiaAxk2LUGIDPVHYhjSRvfsP4EveBJMHm4MxYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;292&quot;/&gt;&lt;figcaption&gt;字符串&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字符串复制初始化&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;String s = ``&lt;span&gt;&quot;abc&quot;&lt;/span&gt;``;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于另外一个字符串&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// s = &quot;abc&quot;``String s2 = ``new` `String(s);&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于char[]&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// s = &quot;abc&quot;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// char[] c = s.toCharArray();&lt;/span&gt;&lt;br/&gt;String s3 = &lt;span&gt;new&lt;/span&gt; String(c);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 可以偏移&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// public String(char value[], int offset, int count)&lt;/span&gt;&lt;br/&gt;String s4 = &lt;span&gt;new&lt;/span&gt; String(c, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;);    &lt;span&gt;// [offset, offset + count) [)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 把char[] 变成字符串&lt;/span&gt;&lt;br/&gt;&lt;span&gt;char&lt;/span&gt;[] ch = {&lt;span&gt;&#x27;a&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;b&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;c&#x27;&lt;/span&gt;};&lt;br/&gt;String.valueOf(ch);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;charAt(&lt;span&gt;int&lt;/span&gt; index);    &lt;span&gt;// 返回index位置的char --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;length();    &lt;span&gt;// 返回字符串长度 --- O(1)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;substring(&lt;span&gt;int&lt;/span&gt; beginIndex, &lt;span&gt;int&lt;/span&gt; endIndex);    &lt;span&gt;// 返回字符片段[beginIndex, endIndex) --- O(n)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;substring(&lt;span&gt;int&lt;/span&gt; beginIndex);    &lt;span&gt;// 返回字符片段[beginIndex, end_of_String) 就是从beginIndex开始后面的 ---- O(n)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;indexOf(String str)    &lt;span&gt;// 返回str第一个出现的位置(int)，没找到则返回-1。 --- O(m * n) m为原串长度， n为str长度&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// (假如要找一个字符char c，str可以表示成String.valueOf(c),然后作为参数传进去.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;s.indexOf(String str, &lt;span&gt;int&lt;/span&gt; fromIndex);    &lt;span&gt;// 同上，但从fromIndex开始找 --- O(m * n)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;lastIndexOf(String str);    &lt;span&gt;// 返回str最后出现的位置(int)，没找到则返回-1。 --- O(m * n) m为原串长度， n为str长度&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// (假如要找一个字符char c，str可以表示成String.valueOf(c),然后作为参数传进去.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;lastIndexOf(String str, &lt;span&gt;int&lt;/span&gt; fromIndex);    &lt;span&gt;// 同上，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//但从fromIndex开始从后往前找 [0 &amp;lt;- fromIndex] --- O(m * n)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;replace(&lt;span&gt;char&lt;/span&gt; oldChar, &lt;span&gt;char&lt;/span&gt; newChar);    &lt;span&gt;// 返回一个新字符串String，其oldChar全部变成newChar --- O(n)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;toCharArray();   &lt;span&gt;// 返回char[] 数组。 把String编程字符数组 --- O(n)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;trim();    &lt;span&gt;// 返回去除前后空格的新字符串 --- O(n)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;split(String regex);    &lt;span&gt;// 返回 String[]，以regex(正则表达式)分隔好的字符换数组。 ---- O(n)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// For example&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 从非&quot;/&quot;算起 若&quot;/a/c&quot; -&amp;gt; 会变成&quot;&quot; &quot;a&quot; &quot;c&quot;&lt;/span&gt;&lt;br/&gt;String[] date = str.split(&lt;span&gt;&quot;/&quot;&lt;/span&gt;);     &lt;span&gt;// date[0]:1995 date[1]:12 date[2]:18 --- O(n)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;s = s.toLowerCase();    &lt;span&gt;// 返回一个新的字符串全部转成小写 --- O(n)&lt;/span&gt;&lt;br/&gt;s = s.toUpperCase();    &lt;span&gt;// 返回一个新的字符串全部转成大写 --- O(n)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;StringBuilder&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于String是所谓的不可变类，使用 &lt;code&gt;str+&lt;/code&gt;这种形式拼接字符串实际上，是JVM帮助循环创建StringBuilder来拼接，所以拼接字符串最好用StringBuilder。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;StringBuilder sb = new StringBuilder();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;charAt(int index);    // 返回index位置的char --- O(1)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;length();    // 返回缓冲字符串长度 --- O(1)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;append(String str)   // 拼接字符串 --- O(n)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;toString();    // 返回一个与构建起或缓冲器内容相同的字符串 --- O(n)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数学&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最大最小值&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在一些题目里，需要用到最大，最小值，Java中各个数据类型的最大最小值定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;fmax = Float.MAX_VALUE;&lt;br/&gt;&lt;br/&gt;fmin = Float.MIN_VALUE;&lt;br/&gt;&lt;br/&gt;dmax = Double.MAX_VALUE;&lt;br/&gt;&lt;br/&gt;dmin = Double.MIN_VALUE;&lt;br/&gt;&lt;br/&gt;bmax = Byte.MAX_VALUE;&lt;br/&gt;&lt;br/&gt;bmin = Byte.MIN_VALUE;&lt;br/&gt;&lt;br/&gt;cmax = Character.MAX_VALUE;&lt;br/&gt;&lt;br/&gt;cmin = Character.MIN_VALUE;&lt;br/&gt;&lt;br/&gt;shmax = Short.MAX_VALUE;&lt;br/&gt;&lt;br/&gt;shmin = Short.MIN_VALUE;&lt;br/&gt;&lt;br/&gt;imax = Integer.MAX_VALUE;&lt;br/&gt;&lt;br/&gt;imin = Integer.MIN_VALUE;&lt;br/&gt;&lt;br/&gt;lmax = Long.MAX_VALUE;&lt;br/&gt;&lt;br/&gt;lmin = Long.MIN_VALUE;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Math&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Math.max(&lt;span&gt;long&lt;/span&gt; a, &lt;span&gt;long&lt;/span&gt; b);    &lt;span&gt;//返回两个参数中较大的值&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Math.sqrt(&lt;span&gt;double&lt;/span&gt; a);    &lt;span&gt;//求参数的算术平方根&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Math.abs(&lt;span&gt;double&lt;/span&gt; a);  &lt;span&gt;//返回一个类型和参数类型一致的绝对值&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Math.pow(&lt;span&gt;double&lt;/span&gt; a, &lt;span&gt;double&lt;/span&gt; b);  &lt;span&gt;//返回第一个参数的第二个参数次方。&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Math.ceil(&lt;span&gt;double&lt;/span&gt; x);   &lt;span&gt;//向上取整&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Math.floor(&lt;span&gt;double&lt;/span&gt; x);  &lt;span&gt;//向下取整&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Math.round(&lt;span&gt;double&lt;/span&gt; x);   &lt;span&gt;//四舍五入&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&quot;简单的事情重复做，重复的事情认真做，认真的事情有创造性地做！&quot;——&lt;/p&gt;&lt;p&gt;我是&lt;code&gt;三分恶&lt;/code&gt;，一个能文能武的全栈开发。&lt;/p&gt;&lt;p&gt;&lt;code&gt;点赞&lt;/code&gt;、&lt;code&gt;关注&lt;/code&gt;不迷路，咱们下期见！&lt;/p&gt;&lt;/blockquote&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;[1].[Java刷题常用API](https://www.cnblogs.com/chzhyang/p/13494554.html)&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[2].[Java 刷题集合类](https://blog.nowcoder.net/n/aeda6921b3a644509011213c8c311920)&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>