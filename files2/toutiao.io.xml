<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1e22e4414b07b7f0d29b33c0799106a1</guid>
<title>2022 年别再焦虑啦！加入我们！</title>
<link>https://toutiao.io/k/obimloc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8bc61d2ff28d2086438db8e41de144ea</guid>
<title>神器 Nginx 的学习手册 ( 建议收藏 )</title>
<link>https://toutiao.io/k/6f1qaso</link>
<content:encoded>&lt;div&gt;&lt;div&gt;

                

                
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9282af3902281b00a7a0ef58f27bb425</guid>
<title>石墨文档是如何通过 WebSocket 实现百万长连接的？</title>
<link>https://toutiao.io/k/25nkguu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxNzk1MjQ0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/YBFV3Da0Nwvv72YkFO0qPibDKicOCsfltiaE9070DOu4iahXnicYwRIHcxe9VBicAy45MkPqy8nZzLTVibugOtV0ORFcg/0?wx_fmt=png&quot; data-nickname=&quot;程序员成长指北&quot; data-alias=&quot;coder_growth&quot; data-signature=&quot;专注 Node.js 技术栈分享，从 前端 到 Node.js 再到 后端数据库，祝您成为优秀的高级 Node.js 全栈工程师。一个有趣的且乐于分享的人。座右铭：今天未完成的，明天更不会完成。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大厂技术&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;高级前端&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;Node进阶&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;点击上方 &lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(0, 128, 255)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(0, 128, 255)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(0, 128, 255)&quot;&gt;程序员成长指北&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;，关注公众号&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回复&lt;/span&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，加入高级Node交流群&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Web&lt;/code&gt; 服务端推送技术经过了长轮询、短轮询的发展，最终到 &lt;code&gt;HTML5&lt;/code&gt; 标准带来的 &lt;code&gt;WebSocket&lt;/code&gt; 规范逐步成为了目前业内主流技术方案。它使得消息推送、消息通知等功能的实现变得异常简单，那么百万级别连接下的 &lt;code&gt;Websocket&lt;/code&gt; 网关该如何实践呢？本文整理自石墨文档资深工程师杜旻翔根据石墨 &lt;code&gt;Websocket&lt;/code&gt; 重构的实践经验。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdTxYzBoRvsSWb3icArvPGCqdBKQrCVJt5g14mhYkkicjUUR0RhzLxic1GMFSMgpUBSFxlEDicATE52OsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot;/&gt;&lt;figcaption&gt;「作者：杜旻翔」infoq.cn/article/GymHAbqVRO214qo44jHD&lt;/figcaption&gt;&lt;figcaption&gt;&lt;span&gt;「编辑：&lt;/span&gt;&lt;span&gt;ConardLi&lt;/span&gt;&lt;span&gt;」&lt;/span&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1 引言&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在石墨文档的业务中，如文档分享、评论、幻灯片演示和文档表格跟随等场景，涉及多客户端数据同步和服务端批量数据推送的需求，采用短轮询或长轮询的方式无法很好的满足服务端消息推送、消息通知的业务场景，因此选择业内的主流方案：基于 &lt;code&gt;HTML5&lt;/code&gt; 标准定义的 &lt;code&gt;WebSocket&lt;/code&gt; 规范。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着石墨文档的发展，现在日连接峰值达到了百万量级，日益增长的用户连接数和停止更新的架构设计导致了内存和 CPU 使用量急剧增长，因此我们考虑对网关进行重构，以适应发展需求。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2 网关 1.0&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关 1.0 是使用 &lt;code&gt;Node.js&lt;/code&gt; 基于 &lt;code&gt;Socket.IO&lt;/code&gt; 进行修改开发的版本，很好的满足了当时用户量级下的业务场景需求。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 架构&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关 1.0 版本架构设计图：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0759878419452888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk5490xnS3lPgmdh7uGHsiaryUwFXIIzYBZUoMpibqO8GRKfnHZH72DWtTHUf9Py0LKSbn2wWb7rSzF8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;329&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关 1.0 客户端连接流程：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户通过 NGINX 连接网关，该操作被业务服务感知；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务服务感知到用户连接后，会进行相关用户数据查询，再将消息 Pub 到 Redis；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网关服务通过 Redis Sub 收到消息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;查询网关集群中的用户会话数据，向客户端进行消息推送。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 痛点&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然 1.0 版本的网关在线上运行良好，但是不能很好的支持后续业务的扩展，并且有以下几个问题需要解决：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;资源消耗：Nginx 仅使用证书，大部分请求被透传，产生了一定的资源浪费，同时之前的 Node 网关性能不好，消耗大量的 CPU、内存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;维护与观测：未接入石墨的监控体系，无法和现有监控告警联通，维护上存在一定的困难；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务耦合问题：业务服务与网关功能被集成到了同一个服务中，无法针对业务部分性能损耗进行针对性水平扩容，为了解决性能问题，以及后续的模块扩展能力，都需要进行服务解耦。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3 网关 2.0&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关 2.0 需要解决很多问题：石墨文档内部有很多组件：文档、表格、幻灯片和表单等等。在 1.0 版本中组件对网关的业务调用可以通过：Redis、Kafka 和 HTTP 接口，来源不可查，管控困难。此外，从性能优化的角度考虑也需要对原有服务进行解耦合，将 1.0 版本网关拆分为网关功能部分和业务处理部分，网关功能部分为 WS-Gateway：集成用户鉴权、TLS 证书验证和 WebSocket 连接管理等；业务处理部分为 WS-API：组件服务直接与该服务进行 gRPC 通信。可针对具体的模块进行针对性扩容；服务重构加上 Nginx 移除，整体硬件消耗显著降低；服务整合到石墨监控体系。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 整体架构&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关 2.0 版本架构设计图：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0903954802259888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk5490xnS3lPgmdh7uGHsiaryUh1GXuXlzBIgkjsEmR5H21iaibMFrTFS57kmiae0GyNpAEFgxKVxibt0Wvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;354&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关 2.0 客户端连接流程：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;客户端与 WS-Gateway 服务通过握手流程建立 WebSocket 连接；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;连接建立成功后，WS-Gateway 服务将会话进行节点存储，将连接信息映射关系缓存到 Redis 中，并通过 Kafka 向 WS-API 推送客户端上线消息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;WS-API 通过 Kafka 接收客户端上线消息及客户端上行消息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;WS-API 服务预处理及组装消息，包括从 Redis 获取消息推送的必要数据，并进行完成消息推送的过滤逻辑，然后 Pub 消息到 Kafka；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;WS-Gateway 通过 Sub Kafka 来获取服务端需要返回的消息，逐个推送消息至客户端。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 握手流程&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网络状态良好的情况下，完成如下图所示步骤 1 到步骤 6 之后，直接进入 WebSocket 流程；网络环境较差的情况下，WebSocket 的通信模式会退化成 HTTP 方式，客户端通过 POST 方式推送消息到服务端，再通过 GET 长轮询的方式从读取服务端返回数据。客户端初次请求服务端连接建立的握手流程：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.353846153846154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk5490xnS3lPgmdh7uGHsiaryUlaP7KUgE6F09U01ibZevSgXaI8aYgLGUSHk9ib0RASbBz7zkAXuq6dFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;390&quot;/&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Client 发送 GET 请求尝试建立连接；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Server 返回相关连接数据，sid 为本次连接产生的唯一 Socket ID，后续交互作为凭证；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;{&quot;sid&quot;:&quot;xxx&quot;,&quot;upgrades&quot;:[&quot;websocket&quot;],&quot;pingInterval&quot;:xxx,&quot;pingTimeout&quot;:xxx}&lt;/p&gt;&lt;/blockquote&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Client 携带步骤 2 中的 sid 参数再次请求；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Server 返回 40，表示请求接收成功；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Client 发送 POST 请求确认后期降级通路情况；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Server 返回 ok，此时第一阶段握手流程完成；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;尝试发起 WebSocket 连接，首先进行 2probe 和 3probe 的请求响应，确认通信通道畅通后，即可进行正常的 WebSocket 通信。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3 TLS 内存消耗优化&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端与服务端连接建立采用的 wss 协议，在 1.0 版本中 TLS 证书挂载在 Nginx 上，HTTPS 握手过程由 Nginx 完成，为了降低 Nginx 的机器成本，在 2.0 版本中我们将证书挂载到服务上，通过分析服务内存，如下图所示，TLS 握手过程中消耗的内存占了总内存消耗的大概 30% 左右。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43790849673202614&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk5490xnS3lPgmdh7uGHsiaryUs5nxhicy1oayiaRIv5fZC3JzcrmaPF5BggUEiaXhBPF1ibyUdOC0RfUICg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;612&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个部分的内存消耗无法避免，我们有两个选择：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;采用七层负载均衡，在七层负载上进行 TLS 证书挂载，将 TLS 握手过程移交给性能更好的工具完成；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;优化 Go 对 TLS 握手过程性能，在与业内大佬曹春晖（曹大）的交流中了解到，他最近在 Go 官方库提交的 PR https://github.com/golang/go/issues/43563 ，以及相关的性能测试数据 https://github.com/golang/go/pull/48229 。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.4 Socket ID 设计&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对每次连接必须产生一个唯一码，如果出现重复会导致串号，消息混乱推送的问题。选择 SnowFlake 算法作为唯一码生成算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;物理机场景中，对副本所在物理机进行固定编号，即可保证每个副本上的服务产生的 Socket ID 是唯一值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;K8S 场景中，这种方案不可行，于是采用注册下发的方式返回编号，WS-Gateway 所有副本启动后向数据库写入服务的启动信息，获取副本编号，以此作为参数作为 SnowFlake 算法的副本编号进行 Socket ID 生产，服务重启会继承之前已有的副本编号，有新版本下发时会根据自增 ID 下发新的副本编号。于此同时，Ws-Gateway 副本会向数据库写入心跳信息，以此作为网关服务本身的健康检查依据。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.5 集群会话管理方案：事件广播&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端完成握手流程后，会话数据在当前网关节点内存存储，部分可序列化数据存储到 Redis，存储结构说明如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;键&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;ws:user:clients:${uid}&lt;/td&gt;&lt;td&gt;存储用户和 WebSocket 连接的关系，采用有序集合方式存储&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ws:guid:clients:${guid}&lt;/td&gt;&lt;td&gt;存储文件和 WebSocket 连接的关系，采用有序结合方式存储&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ws:client:${socket.id}&lt;/td&gt;&lt;td&gt;存储当前 WebSocket 连接下的全部用户和文件关系数据，采用 Redis Hash 方式进行存储，对应 key 为 user 和 guid&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由客户端触发或组件服务触发的消息推送，通过 Redis 存储的数据结构，在 WS-API 服务查询到返回消息体的目标客户端的 Socket ID，再有 WS-Gateway 服务进行集群消费，如果 Socket ID 不在当前节点，则需要进行节点与会话关系的查询，找到客端户 Socket ID 实际对应的 WS-Gateway 节点，通常有以下两种方案：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;优点&lt;/th&gt;&lt;th&gt;缺点&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;事件广播&lt;/td&gt;&lt;td&gt;实现简单&lt;/td&gt;&lt;td&gt;消息广播数量会随着节点数量上升&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;注册中心&lt;/td&gt;&lt;td&gt;会话与节点映射关系清晰&lt;/td&gt;&lt;td&gt;注册中心强依赖，额外运维成本&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在确定使用事件广播方式进行网关节点间的消息传递后，进一步选择使用哪种具体的消息中间件，列举了三种待选的方案：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;特性&lt;/th&gt;&lt;th&gt;Redis&lt;/th&gt;&lt;th&gt;Kafka&lt;/th&gt;&lt;th&gt;RocketMQ&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;开发语言&lt;/td&gt;&lt;td&gt;C&lt;/td&gt;&lt;td&gt;Scala&lt;/td&gt;&lt;td&gt;Java&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;单机吞吐量&lt;/td&gt;&lt;td&gt;10w+&lt;/td&gt;&lt;td&gt;10w+&lt;/td&gt;&lt;td&gt;10w+&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;可用性&lt;/td&gt;&lt;td&gt;主从架构&lt;/td&gt;&lt;td&gt;分布式架构&lt;/td&gt;&lt;td&gt;分布式架构&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;特点&lt;/td&gt;&lt;td&gt;功能简单&lt;/td&gt;&lt;td&gt;吞吐量、可用性极高&lt;/td&gt;&lt;td&gt;功能丰富、定制化强，吞吐量、可用性高&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;功能特性&lt;/td&gt;&lt;td&gt;数据 10K 以内性能优异，功能简单，适用于简单业务场景&lt;/td&gt;&lt;td&gt;支持核心的 MQ 功能，不支持消息查询或消息回溯等功能&lt;/td&gt;&lt;td&gt;支持核心的 MQ 功能，扩展性强&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是对 Redis 和其他 MQ 中间件进行 100w 次的入队和出队操作，在测试过程中发现在数据小于 10K 时 Redis 性能表现十分优秀，进一步结合实际情况：广播内容的数据量大小在 1K 左右，业务场景简单固定，并且要兼容历史业务逻辑，最后选择了 Redis 进行消息广播。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后续还可以将 WS-API 与 WS-Gateway 两两互联，使用 gRPC stream 双向流通信节省内网流量。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.6 心跳机制&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;会话在节点内存与 Redis 中存储后，客户端需要通过心跳上报持续更新会话时间戳，客户端按照服务端下发的周期进行心跳上报，上报时间戳首先在内存进行更新，然后再通过另外的周期进行 Redis 同步，避免大量客户端同时进行心跳上报对 Redis 产生压力。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;客户端建立 WebSocket 连接成功后，服务端下发心跳上报参数；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端依据以上参数进行心跳包传输，服务端收到心跳后会更新会话时间戳；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端其他上行数据都会触发对应会话时间戳更新；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务端定时清理超时会话，执行主动关闭流程；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 Redis 更新的时间戳数据进行 WebSocket 连接、用户和文件之间的关系进行清理。会话数据内存以及 Redis 缓存清理逻辑：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;   select {&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; &amp;lt;-t.C:&lt;br/&gt;      var now = time.Now().Unix()&lt;br/&gt;      var clients = make([]*Connection, 0)&lt;br/&gt;      dispatcher.clients.Range(func(_, v interface{}) bool {&lt;br/&gt;         client := v.(*Connection)&lt;br/&gt;         lastTs := atomic.LoadInt64(&amp;amp;client.LastMessageTS)&lt;br/&gt;         &lt;span&gt;if&lt;/span&gt; now-lastTs &amp;gt; int64(expireTime) {&lt;br/&gt;            clients = append(clients, client)&lt;br/&gt;         } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            dispatcher.clearRedisMapping(client.Id, client.Uid, lastTs, clearTimeout)&lt;br/&gt;         }&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;      })&lt;br/&gt;      &lt;span&gt;for&lt;/span&gt; _, cli := range clients {&lt;br/&gt;         cli.WsClose()&lt;br/&gt;      }&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在已有的两级缓存刷新机制上，进一步通过动态心跳上报频率的方式降低心跳上报产生的服务端性能压力，默认场景中客户端对服务端进行间隔 1s 的心跳上报，假设目前单机承载了 50w 的连接数，当前的 QPS 为：&lt;code&gt;QPS1 = 500000/1&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从服务端性能优化的角度考虑，实现心跳正常情况下的动态间隔，每 x 次正常心跳上报，心跳间隔增加 a，增加上限为 y，动态 QPS 最小值为：&lt;code&gt;QPS2=500000/y&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;极限情况下，心跳产生的 QPS 降低 y 倍。在单次心跳超时后服务端立刻将 a 值变为 1s 进行重试。采用以上策略，在保证连接质量的同时，降低心跳对服务端产生的性能损耗。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.7 自定义 Headers&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 Kafka 自定义 Headers 的目的是避免网关层出现对消息体解码而带来的性能损耗，客户端 WebSocket 连接建立成功后，会进行一系列的业务操作，我们选择将 WS-Gateway 和 WS-API 之间的操作指令和必要的参数放到 Kafka 的 Headers 中，例如通过 X-XX-Operator 为广播，再读取 X-XX-Guid 文件编号，对该文件内的所有用户进行消息推送。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;X-ID&lt;/td&gt;&lt;td&gt;WebSocket ID&lt;/td&gt;&lt;td&gt;连接 ID&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;X-Uid&lt;/td&gt;&lt;td&gt;用户 ID&lt;/td&gt;&lt;td&gt;用户 ID&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;X-Guid&lt;/td&gt;&lt;td&gt;文件 ID&lt;/td&gt;&lt;td&gt;文件 ID&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;X-Inner&lt;/td&gt;&lt;td&gt;网关内部操作指令&lt;/td&gt;&lt;td&gt;用户加入、用户退出&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;X-Event&lt;/td&gt;&lt;td&gt;网关事件&lt;/td&gt;&lt;td&gt;Connect/Message/Disconnect&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;X-Locale&lt;/td&gt;&lt;td&gt;语言类型设置&lt;/td&gt;&lt;td&gt;语言类型设置&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;X-Operator&lt;/td&gt;&lt;td&gt;api 层操作指令&lt;/td&gt;&lt;td&gt;单播、广播、网关内部操作&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;X-Auth-Type&lt;/td&gt;&lt;td&gt;用户鉴权类型&lt;/td&gt;&lt;td&gt;SDKV2、主站、微信、移动端、桌面&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;X-Client-Version&lt;/td&gt;&lt;td&gt;客户端版本&lt;/td&gt;&lt;td&gt;客户端版本&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;X-Server-Version&lt;/td&gt;&lt;td&gt;网关版本&lt;/td&gt;&lt;td&gt;服务端版本&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;X-Push-Client-ID&lt;/td&gt;&lt;td&gt;客户端 ID&lt;/td&gt;&lt;td&gt;客户端 ID&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;X-Trace-ID&lt;/td&gt;&lt;td&gt;链路 ID&lt;/td&gt;&lt;td&gt;链路 ID&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Kafka Headers 中写入了 trace id 和 时间戳，可以追中某条消息的完整消费链路以及各阶段的时间消耗。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39869281045751637&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk5490xnS3lPgmdh7uGHsiaryUEOT2YFHRKSE3ZeVib2tVfjW1d70V4oEiaLLgo97J0BkdqFTLGlv4wjsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;612&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.8 消息接收与发送&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Packet struct {&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Connect struct {&lt;br/&gt;  *websocket.Con&lt;br/&gt;  send chan Packet&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func NewConnect(conn net.Conn) *Connect {&lt;br/&gt;  c := &amp;amp;Connect{&lt;br/&gt;    send: make(chan Packet, N),&lt;br/&gt;  }&lt;br/&gt;  go c.reader()&lt;br/&gt;  go c.writer()&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; c&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端与服务端的消息交互第一版的写法类似以上写法，对 Demo 进行压测，发现每个 WebSocket 连接都会占用 3 个 goroutine，每个 goroutine 都需要内存栈，单机承载连十分有限，主要受制于大量的内存占用，而且大部分时间 c.writer() 是闲置状态，于是考虑，是否只启用 2 个 goroutine 来完成交互。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Packet struct {&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Connect struct {&lt;br/&gt;  *websocket.Conn&lt;br/&gt;  mux sync.RWMutex&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func NewConnect(conn net.Conn) *Connect {&lt;br/&gt;  c := &amp;amp;Connect{&lt;br/&gt;    send: make(chan Packet, N),&lt;br/&gt;  }&lt;br/&gt;  go c.reader()&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; c&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (c *Connect) Write(data []byte) (err error) {&lt;br/&gt;   c.mux.Lock()&lt;br/&gt;   defer c.mux.Unlock()&lt;br/&gt;   ...&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; nil&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;保留 c.reader() 的 goroutine，如果使用轮询方式从缓冲区读取数据，可能会产生读取延迟或者锁的问题，c.writer() 操作调整为主动调用，不采用启动 goroutine 持续监听，降低内存消耗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调研了 gev 和 gnet 等基于事件驱动的轻量级高性能网络库，实测发现在大量连接场景下可能产生的消息延迟的问题，所以没有在生产环境下使用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.9 核心对象缓存&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;确定数据接收与发送逻辑后，网关部分的核心对象为 Connection 对象，围绕 Connection 进行了 run、read、write、close 等函数的开发。使用 sync.pool 来缓存该对象，减轻 GC 压力，创建连接时，通过对象资源池获取 Connection 对象，生命周期结束之后，重置 Connection 对象后 Put 回资源池。在实际编码中，建议封装 GetConn()、PutConn() 函数，收敛数据初始化、对象重置等操作。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;var ConnectionPool = sync.Pool{&lt;br/&gt;   New: func() interface{} {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &amp;amp;Connection{}&lt;br/&gt;   },&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func GetConn() *Connection {&lt;br/&gt;   cli := ConnectionPool.Get().(*Connection)&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; cli&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func PutConn(cli *Connection) {&lt;br/&gt;   cli.Reset()&lt;br/&gt;   ConnectionPool.Put(cli) // 放回连接池&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.10 数据传输过程优化&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息流转过程中，需要考虑消息体的传输效率优化，采用 MessagePack 对消息体进行序列化，压缩消息体大小。调整 MTU 值避免出现分包情况，定义 a 为探测包大小，通过如下指令，对目标服务 ip 进行 MTU 极限值探测。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; ping -s {a} {ip}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;a = 1400 时，实际传输包大小为：1428。其中 28 由 8（ICMP 回显请求和回显应答报文格式）和 20（IP 首部）构成。&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk5490xnS3lPgmdh7uGHsiaryUTqENianXjaf1aQkCiaxl4I4DKUckHDS6icGR8eS1TibDXjTzCGvKEBrJKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.1437371663244353&quot; data-w=&quot;487&quot;/&gt;如果 a 设置过大会导致应答超时，在实际环境包大小超过该值时会出现分包的情况。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2964824120603015&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk5490xnS3lPgmdh7uGHsiaryUanibVtjddpOZnDMCb6RYUFKb5MB6haVNh1aXFXNzaceWRlB3ic6bQ2lw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;398&quot;/&gt;在调试合适的 MTU 值的同时通过 MessagePack 对消息体进行序列号，进一步压缩数据包的大小，并减小 CPU 的消耗。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.11 基础设施支持&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 EGO 框架（ https://github.com/gotomicro/ego ）进行服务开发：业务日志打印，异步日志输出，动态日志级别调整等功能，方便线上问题排查提升日志打印效率；微服务监控体系，CPU、P99、内存、goroutine 等监控。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37745098039215685&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk5490xnS3lPgmdh7uGHsiaryU3mq3bRXQWOBtKqp3I9mMiaAS5ibj0vjPH9zNSMrRFCGlm1YT2I3kZtEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;612&quot;/&gt;客户端 Redis 监控：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42483660130718953&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk5490xnS3lPgmdh7uGHsiaryUQreHIl5EXia8WCFaibwKOpbFEPAILPhjSCedIH6OQSoEKVaBYAGyO3fg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;612&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端 Kafka 监控：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41830065359477125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk5490xnS3lPgmdh7uGHsiaryUTzGnJXMvAhq6w4mEZovNV9NSchQmFooLNVexkMvnrIpcsFy7IRNtLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;612&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自定义监控大盘：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5147058823529411&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk5490xnS3lPgmdh7uGHsiaryUV6aozJeoz6DODC2iaHxyDHqAorBoCjpT6Tzljt2KeOj7biaeLHmEYEHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;612&quot;/&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4 性能压测&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1 压测准备&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;选择一台配置为 4 核 8G 的虚拟机，作为服务机，目标承载 48w 连接;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;选择八台配置为 4 核 8G 的虚拟机，作为客户机，每台客户机开放 6w 个端口。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2 场景一&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户上线，50w 在线用户。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;服务&lt;/th&gt;&lt;th&gt;CPU&lt;/th&gt;&lt;th&gt;Memory&lt;/th&gt;&lt;th&gt;数量&lt;/th&gt;&lt;th&gt;CPU%&lt;/th&gt;&lt;th&gt;Mem%&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;WS-Gateway&lt;/td&gt;&lt;td&gt;16 核&lt;/td&gt;&lt;td&gt;32G&lt;/td&gt;&lt;td&gt;1 台&lt;/td&gt;&lt;td&gt;22.38%&lt;/td&gt;&lt;td&gt;70.59%&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单个 WS-Gateway 每秒建立连接数峰值为：1.6w 个/s，每个用户占用内存：47K。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.3 场景二&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试时间 15 分钟，在线用户 50w，每 5s 推送一条所有用户，用户有回执。推送内容为：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;42[&quot;message&quot;,{&quot;type&quot;:&quot;xx&quot;,&quot;data&quot;:{&quot;type&quot;:&quot;xx&quot;,&quot;clients&quot;:[{&quot;id&quot;:xx,&quot;name&quot;:&quot;xx&quot;,&quot;email&quot;:&quot;xx@xx.xx&quot;,&quot;avatar&quot;:&quot;ZgG5kEjCkT6mZla6.png&quot;,&quot;created_at&quot;:1623811084000,&quot;name_pinyin&quot;:&quot;&quot;,&quot;team_id&quot;:13,&quot;team_role&quot;:&quot;member&quot;,&quot;merged_into&quot;:0,&quot;team_time&quot;:1623811084000,&quot;mobile&quot;:&quot;+xxxx&quot;,&quot;mobile_account&quot;:&quot;&quot;,&quot;status&quot;:1,&quot;has_password&quot;:true,&quot;team&quot;:null,&quot;membership&quot;:null,&quot;is_seat&quot;:true,&quot;team_role_enum&quot;:3,&quot;register_time&quot;:1623811084000,&quot;alias&quot;:&quot;&quot;,&quot;type&quot;:&quot;anoymous&quot;}],&quot;userCount&quot;:1,&quot;from&quot;:&quot;ws&quot;}}]&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试经过 5 分钟后，服务异常重启，重启原因是内存使用量到超过限制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7352941176470589&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk5490xnS3lPgmdh7uGHsiaryUBIAFqSn4RzrqvU6zkRkIMgic7TDLQibEufcRLmK9Niaawfgl9EAVhMMEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;306&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7449664429530202&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk5490xnS3lPgmdh7uGHsiaryUZjJV7FRWMSoMgW5mhu8kEIvAiciaOVNofVgLUgSibCmPmghcjHdXWiaUZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;298&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6387959866220736&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk5490xnS3lPgmdh7uGHsiaryUeg9ictPibOgOXm31nbwjdcBCHE1PKjT6XZV1dlhjpwYrhB0SU7DZaMkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;299&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6405228758169934&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk5490xnS3lPgmdh7uGHsiaryUXgO7iagiaKQuONfQFqh7yr1uarheCYbmA7YYhV3XhGK0vmD9x28yUGUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;306&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析内存超过限制的原因：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3431372549019608&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk5490xnS3lPgmdh7uGHsiaryUdrgbicOroozelvWgkQ4xPkXMpR0zU7K6dTmqrQBMKOCZcbJiagFmzDPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;612&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新增的广播代码用掉了 9.32% 的内存。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34477124183006536&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk5490xnS3lPgmdh7uGHsiaryUia4804ez7GDs8nUSiaAmY8icg1WibiaOGfMXzmJ5y2nkbxVmicjGhWO0Ftmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;612&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接收用户回执消息的部分消耗了 10.38% 的内存。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34477124183006536&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk5490xnS3lPgmdh7uGHsiaryUvC5Ezo7LlLxOibibjfLknLzvHJ3ZJBl5OKIf0EgBCoGibKTzMSgsOZeAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;612&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进行测试规则调整，测试时间 15 分钟，在线用户 48w，每 5s 推送一条所有用户，用户有回执。推送内容为：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;42[&quot;message&quot;,{&quot;type&quot;:&quot;xx&quot;,&quot;data&quot;:{&quot;type&quot;:&quot;xx&quot;,&quot;clients&quot;:[{&quot;id&quot;:xx,&quot;name&quot;:&quot;xx&quot;,&quot;email&quot;:&quot;xx@xx.xx&quot;,&quot;avatar&quot;:&quot;ZgG5kEjCkT6mZla6.png&quot;,&quot;created_at&quot;:1623811084000,&quot;name_pinyin&quot;:&quot;&quot;,&quot;team_id&quot;:13,&quot;team_role&quot;:&quot;member&quot;,&quot;merged_into&quot;:0,&quot;team_time&quot;:1623811084000,&quot;mobile&quot;:&quot;+xxxx&quot;,&quot;mobile_account&quot;:&quot;&quot;,&quot;status&quot;:1,&quot;has_password&quot;:true,&quot;team&quot;:null,&quot;membership&quot;:null,&quot;is_seat&quot;:true,&quot;team_role_enum&quot;:3,&quot;register_time&quot;:1623811084000,&quot;alias&quot;:&quot;&quot;,&quot;type&quot;:&quot;anoymous&quot;}],&quot;userCount&quot;:1,&quot;from&quot;:&quot;ws&quot;}}]&lt;/p&gt;&lt;/blockquote&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;服务&lt;/th&gt;&lt;th&gt;CPU&lt;/th&gt;&lt;th&gt;Memory&lt;/th&gt;&lt;th&gt;数量&lt;/th&gt;&lt;th&gt;CPU%&lt;/th&gt;&lt;th&gt;Mem%&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;WS-Gateway&lt;/td&gt;&lt;td&gt;16 核&lt;/td&gt;&lt;td&gt;32G&lt;/td&gt;&lt;td&gt;1 台&lt;/td&gt;&lt;td&gt;44%&lt;/td&gt;&lt;td&gt;91.75%&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;连接数建立峰值：1w 个/s，接收数据峰值：9.6w 条/s，发送数据峰值 9.6w 条/s。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4 场景三&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试时间 15 分钟，在线用户 50w，每 5s 推送一条所有用户，用户无需回执。推送内容为：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;42[&quot;message&quot;,{&quot;type&quot;:&quot;xx&quot;,&quot;data&quot;:{&quot;type&quot;:&quot;xx&quot;,&quot;clients&quot;:[{&quot;id&quot;:xx,&quot;name&quot;:&quot;xx&quot;,&quot;email&quot;:&quot;xx@xx.xx&quot;,&quot;avatar&quot;:&quot;ZgG5kEjCkT6mZla6.png&quot;,&quot;created_at&quot;:1623811084000,&quot;name_pinyin&quot;:&quot;&quot;,&quot;team_id&quot;:13,&quot;team_role&quot;:&quot;member&quot;,&quot;merged_into&quot;:0,&quot;team_time&quot;:1623811084000,&quot;mobile&quot;:&quot;+xxxx&quot;,&quot;mobile_account&quot;:&quot;&quot;,&quot;status&quot;:1,&quot;has_password&quot;:true,&quot;team&quot;:null,&quot;membership&quot;:null,&quot;is_seat&quot;:true,&quot;team_role_enum&quot;:3,&quot;register_time&quot;:1623811084000,&quot;alias&quot;:&quot;&quot;,&quot;type&quot;:&quot;anoymous&quot;}],&quot;userCount&quot;:1,&quot;from&quot;:&quot;ws&quot;}}]&lt;/p&gt;&lt;/blockquote&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;服务&lt;/th&gt;&lt;th&gt;CPU&lt;/th&gt;&lt;th&gt;Memory&lt;/th&gt;&lt;th&gt;数量&lt;/th&gt;&lt;th&gt;CPU%&lt;/th&gt;&lt;th&gt;Mem%&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;WS-Gateway&lt;/td&gt;&lt;td&gt;16 核&lt;/td&gt;&lt;td&gt;32G&lt;/td&gt;&lt;td&gt;1 台&lt;/td&gt;&lt;td&gt;30%&lt;/td&gt;&lt;td&gt;93%&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;连接数建立峰值：1.1w 个/s，发送数据峰值 10w 条/s，出内存占用过高之外，其他没有异常情况。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7407407407407407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk5490xnS3lPgmdh7uGHsiaryUdBzb2Le4Gbca1lsB7nic7A6xOXngiaicbXHJ8pvqWaibtZAeibqhcYfQTvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;297&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7433333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk5490xnS3lPgmdh7uGHsiaryU5MgVze1v21JcLThKLwxdwPf9b5RYekZ8UzQUcicY8oick2qibg55Eu2Lg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;300&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6633663366336634&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk5490xnS3lPgmdh7uGHsiaryUIia9AWeniaeqfGrq4DKvo2BR4I4QuPjLSvkk7ibD7aCC8WPjbUETmzfYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;303&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6789297658862876&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk5490xnS3lPgmdh7uGHsiaryU6v9vtJibPpkTMzEI1BeBSyV3icPZTicoLr9pS14fY0YicRtNMow1dic1lgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;299&quot;/&gt;内存消耗极高，分析火焰图，大部分消耗在定时 5s 进行广播的操作上。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3464052287581699&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk5490xnS3lPgmdh7uGHsiaryUOOwcxOpcLxVciboXtAgP9l0jXFFf1glMgEFNicecJP3KueIyJzJecIog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;612&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.5 场景四&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试时间 15 分钟，在线用户 50w，每 5s 推送一条所有用户，用户有回执。每秒 4w 用户上下线。推送内容为：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;42[&quot;message&quot;,{&quot;type&quot;:&quot;xx&quot;,&quot;data&quot;:{&quot;type&quot;:&quot;xx&quot;,&quot;clients&quot;:[{&quot;id&quot;:xx,&quot;name&quot;:&quot;xx&quot;,&quot;email&quot;:&quot;xx@xx.xx&quot;,&quot;avatar&quot;:&quot;ZgG5kEjCkT6mZla6.png&quot;,&quot;created_at&quot;:1623811084000,&quot;name_pinyin&quot;:&quot;&quot;,&quot;team_id&quot;:13,&quot;team_role&quot;:&quot;member&quot;,&quot;merged_into&quot;:0,&quot;team_time&quot;:1623811084000,&quot;mobile&quot;:&quot;+xxxx&quot;,&quot;mobile_account&quot;:&quot;&quot;,&quot;status&quot;:1,&quot;has_password&quot;:true,&quot;team&quot;:null,&quot;membership&quot;:null,&quot;is_seat&quot;:true,&quot;team_role_enum&quot;:3,&quot;register_time&quot;:1623811084000,&quot;alias&quot;:&quot;&quot;,&quot;type&quot;:&quot;anoymous&quot;}],&quot;userCount&quot;:1,&quot;from&quot;:&quot;ws&quot;}}]&lt;/p&gt;&lt;/blockquote&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;服务&lt;/th&gt;&lt;th&gt;CPU&lt;/th&gt;&lt;th&gt;Memory&lt;/th&gt;&lt;th&gt;数量&lt;/th&gt;&lt;th&gt;CPU%&lt;/th&gt;&lt;th&gt;Mem%&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;WS-Gateway&lt;/td&gt;&lt;td&gt;16 核&lt;/td&gt;&lt;td&gt;32G&lt;/td&gt;&lt;td&gt;1 台&lt;/td&gt;&lt;td&gt;46.96%&lt;/td&gt;&lt;td&gt;65.6%&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;连接数建立峰值：18570 个/s，接收数据峰值：329949 条/s，发送数据峰值 393542 条/s，未出现异常情况。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7808219178082192&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk5490xnS3lPgmdh7uGHsiaryUES5jdDy4UdROaYT6mIqibE0FDWBVAibmkOC2WZpTrz4qkITMDRGvh9ww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;292&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7829181494661922&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk5490xnS3lPgmdh7uGHsiaryUaXkiceibHUdgiaicfNx2ex1aI4nN3UNjbgSCbRp1zd9Vb8QDX5FR2dBY2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;281&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6947368421052632&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk5490xnS3lPgmdh7uGHsiaryUkZI0MEOzjYF4aD6QFJdNZkiauV9gc5lhUIb05Lhiczuzoic9T0ibkC6bfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;285&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6949152542372882&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk5490xnS3lPgmdh7uGHsiaryU4M8ic6r3PT0stTibdpWFz2gd8f893zK5jke5datZtYiaM17jwRibrAr2PQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;295&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.6 压测总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;16C 32G&lt;/code&gt; 内存的硬件条件下，单机 &lt;code&gt;50w&lt;/code&gt; 连接数，进行以上包括用户上下线、消息回执等四个场景的压测，内存和 &lt;code&gt;CPU&lt;/code&gt; 消耗都符合预期，并且在较长时间的压测下，服务也很稳定。满足目前量级下的资源节约要求，可在此基础上继续完善功能开发。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5 总结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面临日益增加的用户量，网关服务的重构是势在必行，本次重构主要是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;对网关服务与业务服务的解耦，移除对 Nginx 的依赖，让整体架构更加清晰。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;从用户建立连接到底层业务推送消息的整体流程分析，对其中这些流程进行了具体的优化。以下各个方面让 2.0 版本的网关有了更少的资源消耗，更低的单位用户内存损耗、更加完善的监控报警体系，让网关服务本身更加可靠：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可降级的握手流程；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Socket ID 生产；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端心跳处理过程的优化；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自定义 Headers 避免了消息解码，强化了链路追踪与监控；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息的接收与发送代码结构设计上的优化；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对象资源池的使用，使用缓存降低 GC 频率；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息体的序列化压缩；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接入服务观测基础设施，保证服务稳定性。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在保证网关服务性能过关的同时，更进一步的是收敛底层组件服务对网关业务调用的方式，从以前的 HTTP、Redis、Kafka 等方式，统一为 gRPC 调用，保证了来源可查可控，为后续业务接入打下了更好的基础。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6 Q&amp;amp;A&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;收录了部分文章相关内容的讨论问题：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.1 SocketID 存在的价值&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题：按照我的理解 &lt;code&gt;socketID&lt;/code&gt; 存在的价值是 Kafka 的消费者需要根据 &lt;code&gt;socketID&lt;/code&gt; 找到对应的tcp 链接，既然你们已经有了自定义网关，那么引入 kafka 的意义是什么？消息的持久化？为什么不在网关层做负载均衡，让节点直接跟客户端通信。另外我猜测消费发送者需要根据 &lt;code&gt;socketId&lt;/code&gt; 做 hash 然后发送到对应的 partition，一旦初始 partition 过小，进行扩容时，客户端和服务端都得进行重启或则升级，不知道引入 kafka 的意义在哪里，相反还极大的增加了架构的复杂度和维护成本，扩展性也没那么好，如果是 http 短链接还能理解。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;回答：图中没画出 SLB，是有负载均衡的。我们没有采用 socket id hash 到对应 partition，kafka 的作用是在处理网关内部的不需要关心顺序和推送消息的流转，如果没有kafka，那么组件或者网关滚动更新，用户重连的过程中，就可能丢消息；对于需要顺序的消息，例如 ping pong 模式的是可以通过网关识别到 header 头里的 cmd 信息，找到对应后端，分发消息。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.2 Redis 进行消息广播的作用&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题：广播内容的数据量大小在 &lt;code&gt;1K&lt;/code&gt; 左右，业务场景简单固定，并且要兼容历史业务逻辑，最后选择了 &lt;code&gt;Redis&lt;/code&gt; 进行消息广播。&lt;code&gt;api&lt;/code&gt; 与网关交互不是通过 &lt;code&gt;kafka&lt;/code&gt; 吗，这里是什么意思呢？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;回答：网关节点对 &lt;code&gt;kafka&lt;/code&gt; 的消费是集群模式。如果 &lt;code&gt;kafka&lt;/code&gt;，在 &lt;code&gt;k8s&lt;/code&gt; 条件下，使用广播模式比较麻烦。所以老的网关是用 &lt;code&gt;redis&lt;/code&gt; 做 &lt;code&gt;pub/sub&lt;/code&gt; 的广播，为了兼容老的逻辑仍然采用 &lt;code&gt;redis&lt;/code&gt; 做广播。同时后续我们打算直接将 &lt;code&gt;api&lt;/code&gt; 和 &lt;code&gt;ws&lt;/code&gt; 做两两互联，通过 &lt;code&gt;grpc stream&lt;/code&gt; 做广播，有更好的扩展性。&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7 技术链接&lt;/span&gt;&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;微服务框架：https://github.com/gotomicro/ego&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kafka、Redis、MySQL 客户端监控 SDK：https://github.com/gotomicro/ego-component&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-darkmode-color-16057140139831=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(0,0,0)&quot; data-style=&quot;padding-right: 10px; padding-left: 10px; color: rgb(0, 0, 0); font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &amp;quot;PingFang SC&amp;quot;, Cambria, Cochin, Georgia, Times, &amp;quot;Times New Roman&amp;quot;, serif; letter-spacing: 0px; text-align: left; white-space: normal; font-size: 16px; line-height: 1.6; word-break: break-word;&quot; data-darkmode-color-16072568501583=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16072568501583=&quot;rgb(0, 0, 0)&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section label=&quot;Copyright © 2016 playhudong All Rights Reserved.&quot; donone=&quot;shifuMouseDownPayStyle(&#x27;shifu_t_042&#x27;)&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;Node 社群&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;89226&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我组建了一个氛围特别好的 Node.js 社群，里面有很多 Node.js小伙伴，如果你对Node.js学习感兴趣的话（后续有计划也可以），我们可以一起进行Node.js相关的交流、学习、共建。下方加 考拉 好友回复「Node」即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YBFV3Da0NwsF7OKB4iaaXAzQPbNstk2LybA0Zz5I1hiaiazE9W7WH2Ojt2dibDODWMVUmHqgfXCefVwt7z5ibNMWLvg/0?wx_fmt=jpeg&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;578.2649006622516&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;700.2119205298013&quot; data-fileid=&quot;100016913&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2093425605536332&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YBFV3Da0NwvFQgO67XibvUG5S2UMXwCghOuJvE8BFRzUXnCAfWXkU1qHld6Ly9xiarib3siaWicJWJ0U3lI8kSgD38w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot; data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-style=&quot;padding-top: 8px; padding-bottom: 8px; color: rgb(89, 89, 89); line-height: 26px;&quot; data-darkmode-color-16072568501583=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16072568501583=&quot;rgb(89, 89, 89)&quot;&gt;&lt;span&gt;如果你觉得这篇内容对你有帮助，我想请你帮我2个小忙：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-darkmode-color-16072568501583=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16072568501583=&quot;rgb(89, 89, 89)&quot;&gt;1. 点个&lt;/span&gt;&lt;span&gt;「在看」&lt;/span&gt;&lt;span data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-darkmode-color-16072568501583=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16072568501583=&quot;rgb(89, 89, 89)&quot;&gt;，让更多人也能看到这篇文章&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-darkmode-color-16072568501583=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16072568501583=&quot;rgb(89, 89, 89)&quot;&gt;2. 订阅官方博客 &lt;/span&gt;&lt;span&gt;www.inode.club &lt;/span&gt;&lt;span data-darkmode-color-16057140139831=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16057140139831=&quot;rgb(89, 89, 89)&quot; data-darkmode-color-16072568501583=&quot;rgb(141, 141, 141)&quot; data-darkmode-original-color-16072568501583=&quot;rgb(89, 89, 89)&quot;&gt;让我们一起成长&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bb38cf7988fdc2628ba5c128a5711ef4</guid>
<title>普通索引 PK 唯一性索引，用哪个好？</title>
<link>https://toutiao.io/k/dbupvgk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们建索引的时候，有全文索引、主键索引、唯一性索引、普通索引等，前面两个好理解好区分，大家都知道啥时候用，后面两个该如何区分呢？唯一性索引和普通索引该如何选择呢？今天我们就来聊聊这个话题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;1. 准备工作&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我有如下表：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;`user`&lt;/span&gt; (&lt;br/&gt;  &lt;span&gt;`id`&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; AUTO_INCREMENT,&lt;br/&gt;  &lt;span&gt;`username`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;COLLATE&lt;/span&gt; utf8mb4_unicode_ci &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`address`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;) &lt;span&gt;COLLATE&lt;/span&gt; utf8mb4_unicode_ci &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`age`&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;(&lt;span&gt;4&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;  PRIMARY &lt;span&gt;KEY&lt;/span&gt; (&lt;span&gt;`id`&lt;/span&gt;),&lt;br/&gt;  &lt;span&gt;UNIQUE&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt; &lt;span&gt;`username`&lt;/span&gt; (&lt;span&gt;`username`&lt;/span&gt;),&lt;br/&gt;  &lt;span&gt;KEY&lt;/span&gt; &lt;span&gt;`address`&lt;/span&gt; (&lt;span&gt;`address`&lt;/span&gt;)&lt;br/&gt;) &lt;span&gt;ENGINE&lt;/span&gt;=&lt;span&gt;InnoDB&lt;/span&gt; AUTO_INCREMENT=&lt;span&gt;100001&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;CHARSET&lt;/span&gt;=utf8mb4 &lt;span&gt;COLLATE&lt;/span&gt;=utf8mb4_unicode_ci;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这表中有 10 万条模拟数据，10 万条模拟数据大家自行创建我就不啰嗦了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看表结构，有一个 username 索引，这个索引是一个唯一性索引；还有一个 address 索引，这是一个普通索引。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;2. 查询&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2.1 普通索引查询&lt;/strong&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看看普通索引的查询。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来做一个简单的查询：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; address=&lt;span&gt;&#x27;1&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据我们前面的讲解，我们来梳理下这里的查询步骤：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;MySQL 的 server 层首先调用存储引擎定位到第一个值为 1 的 address。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;由于 address 是二级索引，二级索引的叶子结点中保存着主键值，所以还需要根据主键值去主键索引上找到完整的数据行，其实就是回表。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;存储引擎将读取到的数据行返回给 server 层。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;由于 address 是普通索引，不是唯一性索引，所以 address 为 1 的记录可能不止一条，所以还需在第一次查询的基础上，沿着叶子结点内部的单向链表继续向后扫描，扫描到新的数据后，重复 2、3 步。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当扫到 address 不为 1 的记录时，停止扫描。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上面是我们的分析，我们来看下执行计划：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5088062622309197&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYnjU9xYia9e8VQuOAnQTJicUlN1mlCz3eA8GsdibzHiabXvR6qF0xEppL6zgjTP0QQUUmw4SaBgW0T6Tw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1022&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行计划中的 type 为 ref，就说明了我们的分析是没问题的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2.2 唯一性索引查询&lt;/strong&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看看唯一性索引查询。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来看看一个 SQL：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; username=&lt;span&gt;&#x27;1&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于唯一性索引来说，username 这一列的值是唯一的，所以在查询的过程中，找到第一条 &lt;code&gt;username=&#x27;1&#x27;&lt;/code&gt; 的记录后，就不需要再找了，对比普通索引的查询步骤，相当于少了第 4、5 步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看看查询计划：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.501953125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYnjU9xYia9e8VQuOAnQTJicUlVr6JVbV0zHfwE2nmOF38sMicsRExRmhUW7zibiac2jG88nAoLBf6yj6Pg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和前面普通索引的查询计划相比，这里的查询计划 type 为 const，也侧面印证了我们的说法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2.3 PK&lt;/strong&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么从上面的描述中我们可以看出来，似乎唯一性索引在查询的时候表现更优秀？真是情况到底如何，我们再来分析下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，理论上来说，唯一性索引在查询的时候确实更优秀一些，原因很简单：唯一性索引找到满足条件的记录后就不需要再找了；而普通索引找到满足条件的记录后，还需要继续向后查找，直到遇到不满足条件的记录（address 不为 1 的记录）才停止搜索，这么看来，确实唯一性索引更胜一筹！那么这种差异很明显吗？老实说，这个优势可以忽略不计！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么呢？&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对于普通索引而言，虽然找到第一条记录之后，还需要继续找后面的，但是因为满足条件的记录是连续的，索引只需要顺着记录之间的单向链表继续向后读就行了，速度快。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;由于 InnoDB 引擎读数据的时候，不是一条一条的读，而是一页一页的读（默认每页 16KB，在什么是 MySQL 的“回表”？一文中，我有大致介绍 16KB 的问题），所以，即使继续向后读，也是内存操作，速度很快。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;也不排除个别情况，例如满足条件的记录刚好是在当前页的最后一条，此时就需要加载新的一页数据，但是这种概率比较小，可以忽略之。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上所述，唯一性索引和普通索引对搜索效率的影响可以忽略不计。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;3 插入/修改&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3.1 准备知识&lt;/strong&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.1.1 buffer pool&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一个 buffer pool 需要大家了解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小伙伴们知道，InnoDB 引擎存储数据的时候，是以页为单位的，每个数据页的大小默认是 16KB，我们可以通过如下命令来查看页的大小：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3298429319371728&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYnjU9xYia9e8VQuOAnQTJicUl2icDZY9tuyGzt2MuOUByHZc92GwNlMslT4G5cooCn63qYKA1YbOnNKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;764&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;16384/1024=16&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚好是 16KB。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算机在存储数据的时候，最小存储单元是扇区，一个扇区的大小是 512 字节，而文件系统（例如 XFS/EXT4）最小单元是块，一个块的大小是 4KB，也就是四个块组成一个 InnoDB 中的页。我们在 MySQL 中针对数据库的增删改查操作，都是操作数据页，说白了，就是操作磁盘。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是大家想想，如果每一次操作都操作磁盘，那么就会产生海量的磁盘 IO 操作，如果是传统的机械硬盘，还会涉及到很多随机 IO 操作，效率低的令人发指。这严重影响了 MySQL 的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这一问题，MySQL 引入了 buffer pool，也就是我们常说的缓冲池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;buffer pool 的主要作用就是缓存索引和表数据，以避免每一次操作都要进行磁盘 IO，通过 buffer pool 可以提高数据的访问速度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过如下命令可以查看 buffer pool 的默认大小：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31887755102040816&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYnjU9xYia9e8VQuOAnQTJicUlRUiaAc8DEnX1GlVKErZKoq4p6JjsP4wWLbnSHRGLfMo57qaA1LP6xug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;784&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;134217728/1024/1024=128&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认大小是 128MB，因为松哥这里的 MySQL 是安装在 Docker 中，所以这个分配的小一些。一般来说，如果一个服务器只是运行了一个 MySQL 服务，我们可以设置 buffer pool 的大小为服务器内存大小的 75%～80%。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.1.2 change buffer&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一个 change buffer 需要大家了解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们说的 buffer pool 虽然提高了访问速度，但是增删改的效率并没有因此提升，当涉及到增删改的时候，还是需要磁盘 IO，那么效率一样低的令人发指。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，MySQL 中引入了 change buffer。change buffer 以前并不叫这个名字，以前叫 insert buffer，即只针对 insert 操作有效，现在改名叫 change buffer 了，不仅仅针对 insert 有效，对 delete 和 update 操作也是有效的，&lt;strong&gt;change buffer 主要是对非唯一的索引有效，如果字段是唯一性索引，那么更新的时候要去检查唯一性，依然无法避免磁盘 IO。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;change buffer 就是说，当我们需要更改数据库中的数据的时候，我们把更改记录到内存中，等到将来数据被读取的时候，再将内存中的数据 merge 到 buffer pool，此时 buffer pool 中的数据和磁盘中的数据就会有差异，有差异的数据我们称之为脏页，在满足条件的时候（redo log 写满了、内存写满了、其他空闲时候），InnoDB 会把脏页刷新回磁盘。这种方式可以有效降低写操作的磁盘 IO，提升数据库的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过如下命令我们可以查看 change buffer 的大小以及哪些操作会涉及到 change buffer：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3951612903225806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYnjU9xYia9e8VQuOAnQTJicUlmAU5znhwFO5Zyt9gJz6YmNjeblTHV6VMJAQge9AKrdsY0o6jLyyypQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;744&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过 change buffer 和 buffer pool 都涉及到内存操作，数据不能持久化，那么，当存在脏页的时候，MySQL 如果突然挂了，就有可能造成数据丢失（因为内存中的数据还没写到磁盘上），但是我们在实际使用 MySQL 的时候，其实并不会有这个问题，那么问题是怎么解决的？那就得靠 redo log 了，这个松哥以后再写文章和大家介绍 redo log。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3.2 PK&lt;/strong&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看了上面 change buffer 的介绍，大家应该已经明白了：&lt;/p&gt;&lt;section&gt;&lt;span&gt;所以，很明显，在插入的时候，非唯一性索引更有优势。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;4. 小结&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么对于一个需要全局唯一的字段，到底是用普通索引还是唯一性索引呢？这个我觉得很难给大家一个放之四海而皆准的建议，因为数据库优化很多时候不是绝对的，要结合自己的实际业务来，&lt;strong&gt;所以，无论何时何地，先满足业务需求，在此基础上，再去讨论数据库优化。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你能从业务上确保该字段唯一，那么可以使用普通索引，这样可以提高插入/更新速度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而，根据墨菲定律，你要是不用唯一索引，该字段中将来大概率会出现脏值，所以你也要考虑业务上对于脏值的容忍程度。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651509762&amp;amp;idx=1&amp;amp;sn=8a47d742db6da5133f4052033f1ef9b1&amp;amp;chksm=bd25b87d8a52316bf57cd12a997b5f1556e1e607d5fc388ee09471c3cd934364c7d94030c0fb&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;删库不跑路，我含泪写下MySQL数据恢复大法&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;删库不跑路，我含泪写下MySQL数据恢复大法&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651509714&amp;amp;idx=1&amp;amp;sn=8d2338d1868103aa7de6cce2aec91a8c&amp;amp;chksm=bd25bfad8a5236bba84735740e968846dd5d51295aca3ee06a61d04ca9d7c1831a3ae1ce9ac6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;缓存和数据库一致性问题，看这篇就够了&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;缓存和数据库一致性问题，看这篇就够了&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651508382&amp;amp;idx=1&amp;amp;sn=8eb8bedf762bb2e99073896037298e98&amp;amp;chksm=bd25a2e18a522bf7d864009ebad5be93dd05bb56080bac22971beeec127bc40d58d185c84829&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;MySQL数据查询太多会OOM吗？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;MySQL数据查询太多会OOM吗？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点赞和在看就是最大的支持❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>741ca9b7ec34e4b688de13526087702e</guid>
<title>面渣逆袭：计算机网络六十二问，三万字图文详解！速收藏！</title>
<link>https://toutiao.io/k/f65mjpf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是老三，开工大吉，虎年第一篇，&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzkwODE5ODM0Ng==&amp;amp;action=getalbum&amp;amp;album_id=2041709347461709827&amp;amp;scene=173&amp;amp;from_msgid=2247489245&amp;amp;from_itemidx=1&amp;amp;count=3&amp;amp;nolastread=1#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;面渣逆袭系列&lt;/a&gt;继续！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次给大家带来了计算机网络六十二问，三万字，七十图详解，大概是全网最全的网络面试题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建议大家&lt;big&gt;&lt;strong&gt;收藏&lt;/strong&gt;&lt;/big&gt;了慢慢看，新的一年一定能够跳槽加薪，虎年“豹”富！&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODE5ODM0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdFLJg0sAOqwHB1mb24icMADUgxm1qZQft5aN3H37NAmQnOvpGB7J9JVHxC6NSiacxbBP1DYdhIAeyA/0?wx_fmt=png&quot; data-nickname=&quot;三分恶&quot; data-alias=&quot;Fighter3FullStack&quot; data-signature=&quot;CSDN博客专家、优质创作者，华为云云享专家；肝过外包、混过国企，目前在一家跨境电商搬砖；写过诗，打过拳，佛系小码农。认真讲技术，随性侃人生，关注我，我们一起走的更远。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基础&lt;/span&gt;&lt;/h1&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.说下计算机网络体系结构&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算机网络体系结构，一般有三种：OSI 七层模型、TCP/IP 四层模型、五层结构。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8288135593220339&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCou8nbuPnz9oGYibg3Kwf3Tvna7Sxe74e1p7cTGhodT0h1Cw0trOKnj0yg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1180&quot;/&gt;&lt;figcaption&gt;三种网络体系结构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单说，OSI是一个理论上的网络通信模型，TCP/IP是实际上的网络通信模型，五层结构就是为了介绍网络原理而折中的网络通信模型。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;OSI 七层模型&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OSI 七层模型是国际标准化组织（International Organization for Standardization）制定的一个用于计算机或通信系统间互联的标准体系。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;应用层：通过应用进程之间的交互来完成特定网络应用，应用层协议定义的是应用进程间通信和交互的规则，常见的协议有：&lt;strong&gt;HTTP FTP  SMTP SNMP DNS&lt;/strong&gt;.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表示层：数据的表示、安全、压缩。确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;会话层：建立、管理、终止会话，是用户应用程序和网络之间的接口。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;运输层：提供源端与目的端之间提供可靠的透明数据传输，传输层协议为不同主机上运行的进程提供逻辑通信。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网络层：将网络地址翻译成对应的物理地址，实现不同网络之间的路径选择, 协议有 &lt;strong&gt;ICMP IGMP IP 等&lt;/strong&gt;.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据链路层：在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;物理层：建立、维护、断开物理连接。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;TCP/IP 四层模型&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;应用层：对应于 OSI 参考模型的（应用层、表示层、会话层）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;传输层: 对应 OSI 的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;网际层：对应于 OSI 参考模型的网络层，主要解决主机到主机的通信问题。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;网络接口层：与 OSI 参考模型的数据链路层、物理层对应。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;五层体系结构&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;应用层：对应于 OSI 参考模型的（应用层、表示层、会话层）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;传输层：对应 OSI 参考模型的的传输层&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;网络层：对应 OSI 参考模型的的网络层&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;数据链路层：对应 OSI 参考模型的的数据链路层&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;物理层：对应 OSI 参考模型的的物理层。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.说一下每一层对应的网络协议有哪些？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一张表格总结常见网络协议：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCou3IRAoSoeurjibRbUgibxibt8XeBCibWymric3SE6ic8C3PgSUOojzevq9QYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;各层网络对应的网络协议&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.那么数据在各层之间是怎么传输的呢？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于发送方而言，从上层到下层层层包装，对于接收方而言，从下层到上层，层层解开包装。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;发送方的应用进程向接收方的应用进程传送数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AP先将数据交给本主机的应用层，应用层加上本层的控制信息H5就变成了下一层的数据单元&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;传输层收到这个数据单元后，加上本层的控制信息H4，再交给网络层，成为网络层的数据单元&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;到了数据链路层，控制信息被分成两部分，分别加到本层数据单元的首部（H2）和尾部（T2）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后的物理层，进行比特流的传输&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouYjoMVXLOEMj2ZUxmCMj217QqywXHz3wSHuHlyJNXV6iaxPHuNP3icXOw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;数据在各层之间的传输&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个过程类似写信，写一封信，每到一层，就加一个信封，写一些地址的信息。到了目的地之后，又一层层解封，传向下一个目的地。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;网络综合&lt;/span&gt;&lt;/h1&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.从浏览器地址栏输入 url 到显示主页的过程？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题，大概的过程比较简单，但是有很多点可以细挖：DNS解析、TCP三次握手、HTTP报文格式、TCP四次挥手等等。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;DNS 解析：将域名解析成对应的 IP 地址。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TCP连接：与服务器通过三次握手，建立 TCP 连接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;向服务器发送 HTTP 请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务器处理请求，返回HTTp响应&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;浏览器解析并渲染页面&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;断开连接：TCP 四次挥手，连接结束&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以输入www.baidu.com 为例：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouaMhCRLPmibgFvoEiaEfEwomW9VtwHfODf4ItvMHuqQMD3dZ07uqHDFAA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;www.baidu.comliu到显示主页&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;各个过程都使用了哪些协议？&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouqiaVicU7YLgl1ZgDXghiaz5ScgfaVfKWRN3L3urW0EiafFUxevSSXT7dRw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;www.baidu.comliu到显示主页过程使用的协议&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.说说 DNS 的解析过程？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DNS，英文全称是 &lt;strong&gt;domain name system&lt;/strong&gt;，域名解析系统，它的作用也很明确，就是域名和 IP 相互映射。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DNS 的解析过程如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCoullctdia40dvoxJ9Rv9guqYOJdUtHhCz5dzOhgzvD8S5rPouVtgacLxA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;DNS解析流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设你要查询 &lt;strong&gt;www.baidu.com&lt;/strong&gt; 的 IP 地址:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先会查找浏览器的缓存,看看是否能找到&lt;strong&gt;www.baidu.com&lt;/strong&gt;对应的IP地址，找到就直接返回；否则进行下一步。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将请求发往给本地DNS服务器，如果查找到也直接返回，否则继续进行下一步；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouE8Qtw0sO8NxUUiauUcG7M7Phbw6eJ4uEibHib0K7KK9uEcwmg2XVTuPcw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;域名服务器层级&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;本地DNS服务器向&lt;strong&gt;根域名服务器&lt;/strong&gt;发送请求，根域名服务器返回负责&lt;code&gt;com&lt;/code&gt;的顶级域名服务器的IP地址的列表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本地DNS服务器再向其中一个负责&lt;code&gt;com&lt;/code&gt;的顶级域名服务器发送一个请求，返回负责&lt;code&gt;baidu.com&lt;/code&gt;的权限域名服务器的IP地址列表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本地DNS服务器再向其中一个权限域名服务器发送一个请求，返回&lt;strong&gt;www.baidu.com&lt;/strong&gt;所对应的IP地址。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6.说说 WebSocket 与 Socket 的区别？&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Socket 其实就是等于 &lt;strong&gt;IP 地址 + 端口 + 协议&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;具体来说，Socket 是一套标准，它完成了对 TCP/IP 的高度封装，屏蔽网络细节，以方便开发者更好地进行网络编程。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;WebSocket 是一个持久化的协议，它是伴随 H5 而出的协议，用来解决 &lt;strong&gt;http 不支持持久化连接&lt;/strong&gt;的问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Socket 一个是&lt;strong&gt;网编编程的标准接口&lt;/strong&gt;，而 WebSocket 则是应用层通信协议。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7.说一下你了解的端口及对应的服务？&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCoueoicOP4l0ibK2EKuISIzFLcchppGPfI7EnkvGWfKvGv2k8FVEMD7iaHcw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;常见端口和服务&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;HTTP&lt;/span&gt;&lt;/h1&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8.说说 HTTP 常用的状态码及其含义？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP状态码首先应该知道个大概的分类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;1XX：信息性状态码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2XX：成功状态码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3XX：重定向状态码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;4XX：客户端错误状态码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;5XX：服务端错误状态码&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;几个常用的，面试之外，也应该记住：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouIywMxwYnZqLDqeyP6DAayrbGLYWz01Fu5iaiaUNWq1tPmdmFbCxnB3sw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;常见HTTP状态码&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前写过一篇：程序员五一被拉去相亲，结果彻底搞懂了HTTP常用状态码，还比较有意思，可以看看。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;说一下301和302的区别？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;301：永久性移动，请求的资源已被永久移动到新位置。服务器返回此响应时，会返回新的资源地址。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;302：临时性性移动，服务器从另外的地址响应资源，但是客户端还应该使用这个地址。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用一个比喻，301就是嫁人的新垣结衣，302就是有男朋友的长泽雅美。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;9.HTTP 有哪些请求方式？&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCounu3nDNAgYjvvYicjy677iaJbeiaDfwfKLo4l8l6ObUV7zDJFpb2b7lqcw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;HTTP请求方式1&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，POST、DELETE、PUT、GET的含义分别对应我们最熟悉的增、删、改、查。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;10.说⼀下 GET 和 POST 的区别？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以从以下几个方面来说明GET和POST的区别：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCoulHqEe98uNmf1Jcj0p5Wvj8sA2bAJeobXuPcXF7kuf9RUvuW9iabmrCA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Get和Post区别&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从 HTTP 报文层面来看，GET 请求将信息放在 URL，POST 将请求信息放在请求体中。这一点使得 GET  请求携带的数据量有限，因为 URL 本身是有长度限制的，而 POST 请求的数据存放在报文体中，因此对大小没有限制。而且从形式上看，GET  请求把数据放 URL 上不太安全，而 POST 请求把数据放在请求体里想比较而言安全一些。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从数据库层面来看，GET 符合幂等性和安全性，而 POST 请求不符合。这个其实和 GET/POST 请求的作用有关。按照 HTTP 的约定，GET 请求用于查看信息，不会改变服务器上的信息；而 POST 请求用来改变服务器上的信息。正因为 GET  请求只查看信息，不改变信息，对数据库的一次或多次操作获得的结果是一致的，认为它符合幂等性。安全性是指对数据库操作没有改变数据库中的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从其他层面来看，GET 请求能够被缓存，GET 请求能够保存在浏览器的浏览记录里，GET 请求的 URL  能够保存为浏览器书签。这些都是 POST 请求所不具备的。缓存是 GET  请求被广泛应用的根本，他能够被缓存也是因为它的幂等性和安全性，除了返回结果没有其他多余的动作，因此绝大部分的 GET 请求都被 CDN  缓存起来了，大大减少了 Web 服务器的负担。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;11.GET 的长度限制是多少？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP中的GET方法是通过URL传递数据的，但是URL本身其实并没有对数据的长度进行限制，真正限制GET长度的是浏览器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如IE浏览器对URL的最大限制是2000多个字符，大概2kb左右，像Chrome、Firefox等浏览器支持的URL字符数更多，其中FireFox中URL的最大长度限制是65536个字符，Chrome则是8182个字符。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个长度限制也不是针对数据部分，而是针对整个URL。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;12.HTTP 请求的过程与原理？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP协议定义了浏览器怎么向服务器请求文档，以及服务器怎么把文档传给浏览器。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouyM1GX66pC7rbPoc6zO42WZLVzJfafzpCygyKBF4qZEOanHicrMzToHg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;HTTP请求的过程和原理&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;每个服务器都有一个进程，它不断监听TCP的端口80，以便发现是否有浏览器向它发出连接建立请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;监听到连接请求，就会建立TCP连接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;浏览器向服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后，释放TCP连接&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在浏览器和服务器之间的请求和响应的交互，必须按照规定的格式和遵循一定的规则，这些格式和规则就是超文本传输协议HTTP。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PS:这道题和上面浏览器输入网址发生了什么那道题大差不差。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;13.说一下HTTP的报文结构？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP报文有两种，HTTP请求报文和HTTP响应报文：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouOkgEppcvrgsN1WP4FD2uWx9LuXUibwnqSLGGia0iaficnx5ItlNGqWV80Q/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;HTTP报文&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;HTTP请求报文&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 请求报文的格式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;GET / HTTP/1.1&lt;br/&gt;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)&lt;br/&gt;Accept: */*&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 请求报文的第一行叫做请求行，后面的行叫做首部行，首部行后还可以跟一个实体主体。请求首部之后有一个空行，这个空行不能省略，它用来划分首部与实体。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求行包含三个字段：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;方法字段：包括POST、GET等请方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;URL 字段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HTTP 版本字段。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;HTTP 响应报文&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 响应报文的格式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;HTTP/1.0 200 OK&lt;br/&gt;Content-Type: text/plain&lt;br/&gt;Content-Length: 137582&lt;br/&gt;Expires: Thu, 05 Dec 1997 16:00:00 GMT&lt;br/&gt;Last-Modified: Wed, 5 August 1996 15:55:28 GMT&lt;br/&gt;Server: Apache 0.84&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;Hello World&lt;span&gt;&amp;lt;/&lt;span&gt;body&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;html&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 响应报文的第一行叫做&lt;strong&gt;状态行&lt;/strong&gt;，后面的行是&lt;strong&gt;首部行&lt;/strong&gt;，最后是&lt;strong&gt;实体主体&lt;/strong&gt;。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;状态行&lt;/strong&gt;包含了三个字段：协议版本字段、状态码和相应的状态信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;实体部分&lt;/strong&gt;是报文的主要部分，它包含了所请求的对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;首部行&lt;/strong&gt;首部可以分为四种首部，请求首部、响应首部、通用首部和实体首部。通用首部和实体首部在请求报文和响应报文中都可以设置，区别在于请求首部和响应首部。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;常见的请求首部有 Accept 可接收媒体资源的类型、Accept-Charset 可接收的字符集、Host 请求的主机名。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;常见的响应首部有 ETag 资源的匹配信息，Location 客户端重定向的 URI。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;常见的通用首部有 Cache-Control 控制缓存策略、Connection 管理持久连接。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;常见的实体首部有 Content-Length 实体主体的大小、Expires 实体主体的过期时间、Last-Modified 资源的最后修改时间。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;14.URI 和 URL 有什么区别?&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouVFWeDVtlenx2aGKfoQEgwjdD6OFT0vwFMtLiaJfaLcPHHaKOAFKKnrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;URI和URL&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;URI，统一资源标识符(Uniform Resource Identifier， URI)，标识的是Web上每一种可用的资源，如 HTML文档、图像、视频片段、程序等都是由一个URI进行标识的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;URL，统一资源定位符（Uniform Resource Location)，它是URI的一种子集，主要作用是提供资源的路径。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它们的主要区别在于，URL除了提供了资源的标识，还提供了资源访问的方式。这么比喻，URI 像是身份证，可以唯一标识一个人，而 URL 更像一个住址，可以通过 URL 找到这个人——人类住址协议://地球/中国/北京市/海淀区/xx职业技术学院/14号宿舍楼/525号寝/张三.男。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;15.说下 HTTP/1.0，1.1，2.0 的区别？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关键需要记住 &lt;strong&gt;HTTP/1.0&lt;/strong&gt; 默认是短连接，可以强制开启，HTTP/1.1 默认长连接，HTTP/2.0 采用&lt;strong&gt;多路复用&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;HTTP/1.0&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;默认使用&lt;strong&gt;短连接&lt;/strong&gt;，每次请求都需要建立一个 TCP 连接。它可以设置&lt;code&gt;Connection: keep-alive&lt;/code&gt; 这个字段，强制开启长连接。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;HTTP/1.1&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;引入了持久连接，即 TCP 连接默认不关闭，可以被多个请求复用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;分块传输编码，即服务端每产生一块数据，就发送一块，用” 流模式” 取代” 缓存模式”。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;管道机制，即在同一个 TCP 连接里面，客户端可以同时发送多个请求。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;HTTP/2.0&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;二进制协议，1.1 版本的头信息是文本（ASCII 编码），数据体可以是文本或者二进制；2.0 中，头信息和数据体都是二进制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;完全多路复用，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;报头压缩，HTTP 协议不带有状态，每次请求都必须附上所有信息。Http/2.0 引入了头信息压缩机制，使用 gzip 或 compress 压缩后再发送。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务端推送，允许服务器未经请求，主动向客户端发送资源。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;16.HTTP/3了解吗？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP/3主要有两大变化，&lt;strong&gt;传输层基于UDP&lt;/strong&gt;、使用&lt;strong&gt;QUIC保证UDP可靠性&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP/2存在的一些问题，比如重传等等，都是由于TCP本身的特性导致的，所以HTTP/3在QUIC的基础上进行发展而来，QUIC（Quick UDP Connections）直译为快速UDP网络连接，底层使用UDP进行数据传输。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP/3主要有这些特点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用UDP作为传输层进行通信&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在UDP的基础上QUIC协议保证了HTTP/3的安全性，在传输的过程中就完成了TLS加密握手&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HTTPS 要建⽴⼀个连接，要花费 6 次交互，先是建⽴三次握⼿，然后是 TLS/1.3 的三次握⼿。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 &lt;strong&gt;3&lt;/strong&gt; 次，减少了交互次数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;QUIC 有⾃⼰的⼀套机制可以保证传输的可靠性的。当某个流发⽣丢包时，只会阻塞这个流，其他流不会受到影响。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们拿一张图看一下HTTP协议的变迁：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouS9ibbF3HSX0ibvApdXmfH7HesOuSSyaQyXhQJTL7Bkcd9fY6M7QeSib3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;HTTP协议变迁&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;17.HTTP 如何实现长连接？在什么时候会超时？&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;什么是 HTTP 的长连接？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;HTTP 分为长连接和短连接，&lt;strong&gt;本质上说的是 TCP 的长短连接&lt;/strong&gt;。TCP 连接是一个双向的通道，它是可以保持一段时间不关闭的，因此 TCP 连接才具有真正的长连接和短连接这一说法。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;TCP 长连接可以复用一个 TCP 连接，来发起多次的 HTTP 请求，这样就可以减少资源消耗，比如一次请求 HTML，如果是短连接的话，可能还需要请求后续的 JS/CSS。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;如何设置长连接？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过在头部（请求和响应头）设置 &lt;strong&gt;Connection&lt;/strong&gt; 字段指定为&lt;code&gt;keep-alive&lt;/code&gt;，HTTP/1.0 协议支持，但是是默认关闭的，从 HTTP/1.1 以后，连接默认都是长连接。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;在什么时候会超时呢？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;HTTP 一般会有 httpd 守护进程，里面可以设置 &lt;strong&gt;keep-alive timeout&lt;/strong&gt;，当 tcp 连接闲置超过这个时间就会关闭，也可以在 HTTP 的 header 里面设置超时时间&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;TCP 的 &lt;strong&gt;keep-alive&lt;/strong&gt; 包含三个参数，支持在系统内核的 net.ipv4 里面设置；当 TCP 连接之后，闲置了 &lt;strong&gt;tcp_keepalive_time&lt;/strong&gt;，则会发生侦测包，如果没有收到对方的 ACK，那么会每隔 tcp_keepalive_intvl 再发一次，直到发送了 &lt;strong&gt;tcp_keepalive_probes&lt;/strong&gt;，就会丢弃该连接。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;1. tcp_keepalive_intvl = 15&lt;br/&gt;2. tcp_keepalive_probes = 5&lt;br/&gt;3. tcp_keepalive_time = 1800&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;18.说说HTTP 与 HTTPS 有哪些区别？&lt;/span&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;HTTP 是超⽂本传输协议，信息是明⽂传输，存在安全⻛险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够加密传输。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;HTTP 连接建⽴相对简单， TCP 三次握⼿之后便可进⾏ HTTP 的报⽂传输。⽽ HTTPS 在 TCP 三次握⼿之后，还需进⾏ SSL/TLS 的握⼿过程，才可进⼊加密报⽂传输。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;HTTP 的端⼝号是 80，HTTPS 的端⼝号是 443。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;19.为什么要用HTTPS？解决了哪些问题？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为HTTP 是明⽂传输，存在安全上的风险：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;窃听⻛险&lt;/strong&gt;，⽐如通信链路上可以获取通信内容，用户账号被盗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;篡改⻛险&lt;/strong&gt;，⽐如强制植⼊垃圾⼴告，视觉污染。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;冒充⻛险&lt;/strong&gt;，⽐如冒充淘宝⽹站，用户金钱损失。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouesE91CPx3PBJNWna4MBTXmD3lyABJKEwquWxeicVT12o5pdfmYLzcNg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;HTTP和HTTPS&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以引入了HTTPS，HTTPS 在 HTTP 与 TCP 层之间加⼊了 SSL/TLS 协议，可以很好的解决了这些风险：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;信息加密&lt;/strong&gt;：交互信息⽆法被窃取。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;校验机制&lt;/strong&gt;：⽆法篡改通信内容，篡改了就不能正常显示。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;身份证书&lt;/strong&gt;：能证明淘宝是真淘宝。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以SSL/TLS 协议是能保证通信是安全的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;20.HTTPS工作流程是怎样的？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题有几个要点：&lt;strong&gt;公私钥、数字证书、加密、对称加密、非对称加密&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTPS 主要工作流程：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;客户端发起 HTTPS 请求，连接到服务端的 443 端口。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务端有一套数字证书（证书内容有公钥、证书颁发机构、失效日期等）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务端将自己的数字证书发送给客户端（公钥在证书里面，私钥由服务器持有）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端收到数字证书之后，会验证证书的合法性。如果证书验证通过，就会生成一个随机的对称密钥，用证书的公钥加密。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端将公钥加密后的密钥发送到服务器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务器接收到客户端发来的密文密钥之后，用自己之前保留的私钥对其进行非对称解密，解密之后就得到客户端的密钥，然后用客户端密钥对返回数据进行对称加密，酱紫传输的数据都是密文啦。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务器将加密后的密文返回到客户端。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端收到后，用自己的密钥对其进行对称解密，得到服务器返回的数据。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouUiaqBPfhW55ubmTibQ7heYmj1M5AMSZYBicOIK2aLdJkqfsqdnXuk3AOA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;https主要流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里还画了一张更详尽的图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWeP0w7dibn7l3skTzywDDCoupricIwCkIDtPbJD0L1kYJNSfjEHw3DjpI7xnFvUTVeweAeN9RSIGdtQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;figcaption&gt;https工作流程详图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;21.客户端怎么去校验证书的合法性？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，服务端的证书从哪来的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了让服务端的公钥被⼤家信任，服务端的证书都是由 CA （&lt;em&gt;Certificate Authority&lt;/em&gt;，证书认证机构）签名的，CA就是⽹络世界⾥的公安局、公证中⼼，具有极⾼的可信度，所以由它来给各个公钥签名，信任的⼀⽅签发的证书，那必然证书也是被信任的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCoumMibOlYibibmiaLMOk83TdlKDh5TBJghDeWreqewpNhdN6PWAD6tUpbSzA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;证书签名和客户端校验-来源参考[2]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CA 签发证书的过程，如上图左边部分：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;⾸先 CA 会把持有者的公钥、⽤途、颁发者、有效时间等信息打成⼀个包，然后对这些信息进⾏ Hash 计算，得到⼀个 Hash 值；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;然后 CA 会使⽤⾃⼰的私钥将该 Hash 值加密，⽣成 Certificate Signature，也就是 CA 对证书做了签名；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;最后将 Certificate Signature 添加在⽂件证书上，形成数字证书；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端校验服务端的数字证书的过程，如上图右边部分：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;⾸先客户端会使⽤同样的 Hash 算法获取该证书的 Hash 值 H1；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使⽤ CA 的公钥解密 Certificate&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Signature 内容，得到⼀个 Hash 值 H2 ；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后⽐较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如在HTTPS的通信过程中，中间人篡改了证书原文，由于他没有CA机构的私钥，所以CA公钥解密的内容就不一致。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;22.如何理解 HTTP 协议是无状态的？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个&lt;code&gt;无状态&lt;/code&gt;的的&lt;code&gt;状态&lt;/code&gt;值的是什么？是客户端的状态，所以字面意思，就是HTTP协议中服务端不会保存客户端的任何信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如当浏览器第一次发送请求给服务器时，服务器响应了；如果同个浏览器发起第二次请求给服务器时，它还是会响应，但是呢，服务器不知道你就是刚才的那个浏览器。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;那有什么办法记录状态呢？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要有两个办法，Session和Cookie。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;23.说说Session 和 Cookie 有什么联系和区别?&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来看看什么是 Session 和 Cookie ：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Cookie 是保存在客户端的一小块文本串的数据。客户端向服务器发起请求时，服务端会向客户端发送一个 Cookie，客户端就把 Cookie 保存起来。在客户端下次向同一服务器再发起请求时，Cookie 被携带发送到服务器。服务端可以根据这个Cookie判断用户的身份和状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Session 指的就是服务器和客户端一次会话的过程。它是另一种记录客户状态的机制。不同的是cookie保存在客户端浏览器中，而session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是session。客户端浏览器再次访问时只需要从该session中查找用户的状态。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouhwBVyib8fzPlpUiaNXHgxxbsR4c797WqQBwWpiaHF9wmXHmesoUNHZa5w/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Cookie和Session&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Session 和 Cookie 到底有什么不同呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储位置不一样，Cookie 保存在客户端，Session 保存在服务器端。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储数据类型不一样，Cookie 只能保存ASCII，Session可以存任意数据类型，一般情况下我们可以在 Session 中保持一些常用变量信息，比如说 UserId 等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;有效期不同，Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般有效时间较短，客户端关闭或者 Session 超时都会失效。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;隐私策略不同，Cookie 存储在客户端，比较容易遭到不法获取，早期有人将用户的登录名和密码存储在 Cookie 中导致信息被窃取；Session 存储在服务端，安全性相对 Cookie 要好一些。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储大小不同， 单个Cookie保存的数据不能超过4K，Session可存储数据远高于 Cookie。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Session 和 Cookie有什么关联呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用Cookie记录Session的标识。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouVjqflTCX87YMXnFjZe4nmODWoRKo91cRbt4wtcDt6Ib9lf1Dxjyt9w/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Session和Cookie的关联&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户第一次请求服务器时，服务器根据用户提交的信息，创建对应的 Session，请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器，浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入 Cookie 中，同时 Cookie 记录此 SessionID 是属于哪个域名。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当用户第二次访问服务器时，请求会自动判断此域名下是否存在 Cookie 信息，如果存在，则自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到，说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;分布式环境下Session怎么处理呢？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式环境下，客户端请求经过负载均衡，可能会分配到不同的服务器上，假如一个用户的请求两次没有落到同一台服务器上，那么在新的服务器上就没有记录用户状态的Session。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用Redis等分布式缓存来存储Session，在多台服务器之间共享。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouhlhrmnDC6LHBaZ6ZL5HHIvKKZuARrxycamdJpcjRRnge3004v1rbdg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;Session共享&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;客户端无法使用Cookie怎么办？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有可能客户端无法使用Cookie，比如浏览器禁用Cookie，或者客户端是安卓、IOS等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候怎么办？SessionID怎么存？怎么传给服务端呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先是SessionID的存储，可以使用客户端的本地存储，比如浏览器的sessionStorage。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来怎么传呢？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;拼接到URL里：直接把SessionID作为URL的请求参数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;放到请求头里：把SessionID放到请求的Header里，比较常用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;TCP&lt;/span&gt;&lt;/h1&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;24.详细说一下 TCP 的三次握手机制&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PS:TCP三次握手是最重要的知识点，一定要熟悉到问到即送分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP提供面向连接的服务，在传送数据前必须建立连接，TCP连接是通过三次握手建立的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCou1sEHb5H7bTqlG4c5PUM7s83X8ibE7Gur2losgCPqrbdWQqUDfEcMT3A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;TCP三次握手示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三次握手的过程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;最开始，客户端和服务端都处于CLOSE状态，服务端监听客户端的请求，进入LISTEN状态&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;客户端端发送连接请求，&lt;strong&gt;第一次握手&lt;/strong&gt; (SYN=1, seq=x)，发送完毕后，客户端就进入 SYN_SENT 状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务端确认连接，&lt;strong&gt;第二次握手&lt;/strong&gt; (SYN=1, ACK=1, seq=y, ACKnum=x+1)， 发送完毕后，服务器端就进入 SYN_RCV 状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端收到服务端的确认之后，再次向服务端确认，这就是**第三次握手 **(ACK=1，ACKnum=y+1)，发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP三次握手通俗比喻：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在二十年前的农村，电话没有普及，手机就更不用说了，所以，通信基本靠吼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老张和老王是邻居，这天老张下地了，结果家里有事，热心的邻居老王赶紧跑到村口，开始叫唤老王。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;老王：老张唉！我是老王，你能听到吗？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;老张一听，是老王的声音：老王老王，我是老张，我能听到，你能听到吗？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;老王一听，嗯，没错，是老张：老张，我听到了，我有事要跟你说。&lt;/p&gt;&lt;p&gt;&quot;你老婆要生了，赶紧回家吧！&quot;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老张风风火火地赶回家，老婆顺利地生了个带把的大胖小子。握手的故事充满了幸福和美满。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouPF3Erc6BmTx5OWWtuH3Oek8HVKosKuWuIgUkOfl9b9QKE0gQIia1Ewg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;大白话三次握手&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;25.TCP 握手为什么是三次，为什么不能是两次？不能是四次？&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;为什么不能是两次？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为了防止服务器端开启一些无用的连接增加服务器开销&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于网络传输是有延时的(要通过网络光纤和各种中间代理服务器)，在传输的过程中，比如客户端发起了 SYN=1 的第一次握手。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果服务器端就直接创建了这个连接并返回包含 SYN、ACK 和 Seq  等内容的数据包给客户端，这个数据包因为网络传输的原因丢失了，丢失之后客户端就一直没有接收到服务器返回的数据包。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有第三次握手告诉服务器端客户端收的到服务器端传输的数据的话，服务器端是不知道客户端有没有接收到服务器端返回的信息的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务端就认为这个连接是可用的，端口就一直开着，等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接。这样一来，就会有很多无效的连接端口白白地开着，导致资源的浪费。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouDN2T2Hz4icZMD52icFdCicKPDibmW6icwSJQXvrgiaqDpNSewMQkOtoDOKVg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;无三次握手导致端口占用&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一种情况是已经失效的客户端发出的请求信息，由于某种原因传输到了服务器端，服务器端以为是客户端发出的有效请求，接收后产生错误。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouAWauAFw8OzvVY6uFBVtwVfRWWd6kY5R1rvX1BNPdjbQicNpgRoMp63Q/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;响应生效请求&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们需要“第三次握手”来确认这个过程：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过第三次握手的数据告诉服务端，客户端有没有收到服务器“第二次握手”时传过去的数据，以及这个连接的序号是不是有效的。若发送的这个数据是“&lt;code&gt;收到且没有问题&lt;/code&gt;”的信息，接收后服务器就正常建立 TCP 连接，否则建立 TCP  连接失败，服务器关闭连接端口。由此减少服务器开销和接收到失效请求发生的错误。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;为什么不是四次？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单说，就是三次挥手已经足够创建可靠的连接，没有必要再多一次握手导致花费更多的时间建立连接。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;26.三次握手中每一次没收到报文会发生什么情况？&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;第一次握手服务端未收到SYN报文&lt;/p&gt;&lt;p&gt;服务端不会进行任何的动作，而客户端由于一段时间内没有收到服务端发来的确认报文，等待一段时间后会重新发送SYN报文，如果仍然没有回应，会重复这个过程，直到发送次数超过最大重传次数限制，就会返回连接建立失败。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;第二次握手客户端未收到服务端响应的ACK报文&lt;/p&gt;&lt;p&gt;客户端会继续重传，直到次数限制；而服务端此时会阻塞在accept()处，等待客户端发送ACK报文&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;第三次握手服务端为收到客户端发送过来的ACK报文&lt;/p&gt;&lt;p&gt;服务端同样会采用类似客户端的超时重传机制，如果重试次数超过限制，则accept()调用返回-1，服务端建立连接失败；而此时客户端认为自己已经建立连接成功，因此开始向服务端发送数据，但是服务端的accept()系统调用已经返回，此时不在监听状态，因此服务端接收到客户端发送来的数据时会发送RST报文给客户端，消除客户端单方面建立连接的状态。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;27.第二次握手传回了 ACK，为什么还要传回 SYN？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ACK是为了告诉客户端传来的数据已经接收无误。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而传回SYN是为了告诉客户端，服务端响应的确实是客户端发送的报文。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;28.第3次握手可以携带数据吗？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第3次握手是可以携带数据的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时客户端已经处于ESTABLISHED状态。对于客户端来说，它已经建立连接成功，并且确认服务端的接收和发送能力是正常的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次握手不能携带数据是出于安全的考虑，因为如果允许携带数据，攻击者每次在SYN报文中携带大量数据，就会导致服务端消耗更多的时间和空间去处理这些报文，会造成CPU和内存的消耗。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;29.说说半连接队列和 SYN Flood 攻击的关系？&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;什么是半连接队列？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP 进入三次握手前，服务端会从 &lt;strong&gt;CLOSED&lt;/strong&gt; 状态变为 &lt;strong&gt;LISTEN&lt;/strong&gt; 状态, 同时在内部创建了两个队列：半连接队列（SYN 队列）和全连接队列（ACCEPT 队列）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouIcNMcQdCBPnqPqEwR0kHpjPvbkIhTsCrNjbPomUVicBHRyHnC4TB73Q/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;三次握手中创建的队列&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顾名思义，半连接队列存放的是三次握手未完成的连接，全连接队列存放的是完成三次握手的连接。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;TCP 三次握手时，客户端发送 SYN 到服务端，服务端收到之后，便回复 &lt;strong&gt;ACK 和 SYN&lt;/strong&gt;，状态由 &lt;strong&gt;LISTEN 变为 SYN_RCVD&lt;/strong&gt;，此时这个连接就被推入了 &lt;strong&gt;SYN 队列&lt;/strong&gt;，即半连接队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当客户端回复 ACK, 服务端接收后，三次握手就完成了。这时连接会等待被具体的应用取走，在被取走之前，它被推入 ACCEPT 队列，即全连接队列。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;什么是SYN Flood ？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SYN Flood 是一种典型的 DDos 攻击，它在短时间内，伪造&lt;strong&gt;不存在的 IP 地址&lt;/strong&gt;, 向服务器发送大量SYN 报文。当服务器回复 SYN+ACK 报文后，不会收到 ACK 回应报文，那么SYN队列里的连接旧不会出对队，久⽽久之就会占满服务端的 &lt;strong&gt;SYN&lt;/strong&gt; 接收队列（半连接队列），使得服务器不能为正常⽤户服务。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouwBlNnPhnVPPAtmU4cgauRm0ho2MA8rMhTwbwAG2brMzI7LfGLUOHyA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;SYN攻击&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;那有什么应对方案呢？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要有 &lt;strong&gt;syn cookie&lt;/strong&gt; 和 &lt;strong&gt;SYN Proxy 防火墙&lt;/strong&gt;等。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;syn cookie&lt;/strong&gt;：在收到 SYN 包后，服务器根据一定的方法，以数据包的源地址、端口等信息为参数计算出一个 cookie 值作为自己的 SYNACK 包的序列号，回复 SYN+ACK 后，服务器并不立即分配资源进行处理，等收到发送方的 ACK 包后，重新根据数据包的源地址、端口计算该包中的确认序列号是否正确，如果正确则建立连接，否则丢弃该包。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;SYN Proxy 防火墙&lt;/strong&gt;：服务器防火墙会对收到的每一个 SYN 报文进行代理和回应，并保持半连接。等发送方将 ACK 包返回后，再重新构造 SYN 包发到服务器，建立真正的 TCP 连接。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;30.说说 TCP 四次挥手的过程？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PS：问完三次握手，常常也会顺道问问四次挥手，所以也是必须掌握知识点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouI6JQ4GAo1gnArBvuNg01tojLqbUxC4y6ubd8jJib8cYxjgV9k1ZYW6A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;TCP四次挥手&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP 四次挥手过程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;数据传输结束之后，通信双方都可以主动发起断开连接请求，这里假定客户端发起&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;客户端发送释放连接报文，&lt;strong&gt;第一次挥手&lt;/strong&gt; (FIN=1，seq=u)，发送完毕后，客户端进入 &lt;strong&gt;FIN_WAIT_1&lt;/strong&gt; 状态。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;服务端发送确认报文，&lt;strong&gt;第二次挥手&lt;/strong&gt; (ACK=1，ack=u+1,seq =v)，发送完毕后，服务器端进入 &lt;strong&gt;CLOSE_WAIT&lt;/strong&gt; 状态，客户端接收到这个确认包之后，进入 &lt;strong&gt;FIN_WAIT_2&lt;/strong&gt; 状态。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;服务端发送释放连接报文，&lt;strong&gt;第三次挥手&lt;/strong&gt; (FIN=1，ACK1,seq=w,ack=u+1)，发送完毕后，服务器端进入 &lt;strong&gt;LAST_ACK&lt;/strong&gt; 状态，等待来自客户端的最后一个 ACK。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;客户端发送确认报文，&lt;strong&gt;第四次挥手&lt;/strong&gt; (ACK=1，seq=u+1,ack=w+1)，客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT 状态，&lt;strong&gt;等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后&lt;/strong&gt;，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大白话说四次挥手：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如单身狗博主有一个女朋友—由于博主上班九九六，下班肝博客，导致没有时间陪女朋友，女朋友忍无可忍。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;女朋友：狗男人，最近你都不理我，你是不是不爱我了？你是不是外面有别的狗子了？我要和你分手？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;沙雕博主一愣，怒火攻心：分手就分手，不陪你闹了，等我把东西收拾收拾。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;沙雕博主小心翼翼地装起了自己的青轴机械键盘。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;哼，蠢女人，我已经收拾完了，我先滚为敬，再见！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;女朋友：滚，滚的远远的，越远越好，我一辈子都不想再见到你。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;挥手的故事总充满了悲伤和遗憾！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouctrO0Y2FiaXdNogP0JZrmehrCNiaicicCXoIx9IcdoKY2jwzqgmdAOYq9A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;大白话四次挥手&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;31.TCP 挥手为什么需要四次呢？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来回顾下四次挥手双方发 &lt;code&gt;FIN&lt;/code&gt; 包的过程，就能理解为什么需要四次了。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;关闭连接时，客户端向服务端发送 &lt;code&gt;FIN&lt;/code&gt; 时，仅仅表示客户端不再发送数据了但是还能接收数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务端收到客户端的 &lt;code&gt;FIN&lt;/code&gt; 报文时，先回一个 &lt;code&gt;ACK&lt;/code&gt; 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 &lt;code&gt;FIN&lt;/code&gt; 报文给客户端来表示同意现在关闭连接。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 &lt;code&gt;ACK&lt;/code&gt; 和 &lt;code&gt;FIN&lt;/code&gt; 一般都会分开发送，从而比三次握手导致多了一次。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;32.TCP 四次挥手过程中，为什么需要等待 2MSL, 才进入 CLOSED 关闭状态？&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;为什么需要等待？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1. 为了保证客户端发送的最后一个 ACK 报文段能够到达服务端。&lt;/strong&gt; 这个 ACK 报文段有可能丢失，因而使处在 &lt;strong&gt;LAST-ACK&lt;/strong&gt; 状态的服务端就收不到对已发送的 &lt;strong&gt;FIN + ACK&lt;/strong&gt; 报文段的确认。服务端会超时重传这个 FIN+ACK 报文段，而客户端就能在 2MSL 时间内（&lt;strong&gt;超时 + 1MSL 传输&lt;/strong&gt;）收到这个重传的 FIN+ACK 报文段。接着客户端重传一次确认，重新启动 2MSL 计时器。最后，客户端和服务器都正常进入到 &lt;strong&gt;CLOSED&lt;/strong&gt; 状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2. 防止已失效的连接请求报文段出现在本连接中&lt;/strong&gt;。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;为什么等待的时间是2MSL？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MSL 是 Maximum Segment Lifetime，报⽂最⼤⽣存时间，它是任何报⽂在⽹络上存在的最⻓时间，超过这个时间报⽂将被丢弃。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TIME_WAIT 等待 2 倍的 MSL，⽐较合理的解释是：⽹络中可能存在来⾃发送⽅的数据包，当这些发送⽅的数据包被接收⽅处理后⼜会向对⽅发送响应，所以⼀来⼀回需要等待 &lt;strong&gt;2&lt;/strong&gt; 倍的时间。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCousxpo9IpAP5emUvV3vXXN6ZDWVLT3icrVicuohwMZvVD5HRDtvPSKaZpw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;2MSL恰好一个来回&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;⽐如如果被动关闭⽅没有收到断开连接的最后的 ACK 报⽂，就会触发超时重发 Fin 报⽂，另⼀⽅接收到 FIN 后，会重发 ACK 给被动关闭⽅， ⼀来⼀去正好 2 个 MSL。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;33.保活计时器有什么用？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除时间等待计时器外，TCP 还有一个保活计时器（keepalive timer）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务器每收到一次客户端的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10 个探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;34.CLOSE-WAIT 和 TIME-WAIT 的状态和意义？&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;CLOSE-WAIT状态有什么意义？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务端收到客户端关闭连接的请求并确认之后，就会进入CLOSE-WAIT状态。此时服务端可能还有一些数据没有传输完成，因此不能立即关闭连接，而CLOSE-WAIT状态就是为了保证服务端在关闭连接之前将待发送的数据处理完。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;TIME-WAIT有什么意义？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TIME-WAIT状态发生在第四次挥手，当客户端向服务端发送ACK确认报文后进入TIME-WAIT状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它存在的意义主要是两个：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCou6N8I3iazVPrFl5icyMd1GJUuKV3KeUzJs8RrFSP9t3PibEMf77ORhKQzA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;TIME_WAIT状态的作用&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;防⽌旧连接的数据包&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如果客户端收到服务端的FIN报文之后立即关闭连接，但是此时服务端对应的端口并没有关闭，如果客户端在相同端口建立新的连接，可能会导致新连接收到旧连接残留的数据包，导致不可预料的异常发生。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;保证连接正确关闭&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;假设客户端最后一次发送的ACK包在传输的时候丢失了，由于TCP协议的超时重传机制，服务端将重发FIN报文，如果客户端没有维持TIME-WAIT状态而直接关闭的话，当收到服务端重新发送的FIN包时，客户端就会使用RST包来响应服务端，导致服务端以为有错误发生，然而实际关闭连接过程是正常的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;35.TIME_WAIT 状态过多会导致什么问题？怎么解决？&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;TIME_WAIT 状态过多会导致什么问题?&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果服务器有处于 TIME-WAIT 状态的 TCP，则说明是由服务器⽅主动发起的断开请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过多的 TIME-WAIT 状态主要的危害有两种：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第⼀是内存资源占⽤；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第⼆是对端⼝资源的占⽤，⼀个 TCP 连接⾄少消耗⼀个本地端⼝；&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;怎么解决TIME_WAIT 状态过多？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;服务器可以设置SO_REUSEADDR套接字来通知内核，如果端口被占用，但是TCP连接位于TIME_WAIT 状态时可以重用端口。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;还可以使用长连接的方式来减少TCP的连接和断开，在长连接的业务里往往不需要考虑TIME_WAIT状态。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;36.说说 TCP 报文首部的格式？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一下TCP报文首部的格式：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouUmoEhYgNn4rWZF3V93wYa4xWFgHeerHwjEoIH0ppM4mlpvIe9ZVcEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;TCP报文首部的格式&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;16 位端口号&lt;/strong&gt;：源端口号，主机该报文段是来自哪里；目标端口号，要传给哪个上层协议或应用程序&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;32 位序号&lt;/strong&gt;：一次 TCP 通信（从 TCP 连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;32 位确认号&lt;/strong&gt;：用作对另一方发送的 tcp 报文段的响应。其值是收到的 TCP 报文段的序号值加 1。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;4 位首部长度&lt;/strong&gt;：表示 tcp 头部有多少个 32bit 字（4 字节）。因为 4 位最大能标识 15，所以 TCP 头部最长是 60 字节。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;6 位标志位&lt;/strong&gt;：URG(紧急指针是否有效)，ACk（表示确认号是否有效），PST（缓冲区尚未填满），RST（表示要求对方重新建立连接），SYN（建立连接消息标志接），FIN（表示告知对方本端要关闭连接了）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;16 位窗口大小&lt;/strong&gt;：是 TCP 流量控制的一个手段。这里说的窗口，指的是接收通告窗口。它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;16 位校验和&lt;/strong&gt;：由发送端填充，接收端对 TCP 报文段执行 CRC 算法以检验 TCP 报文段在传输过程中是否损坏。注意，这个校验不仅包括 TCP 头部，也包括数据部分。这也是 TCP 可靠传输的一个重要保障。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;16 位紧急指针&lt;/strong&gt;：一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP 的紧急指针是发送端向接收端发送紧急数据的方法。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;37.TCP 是如何保证可靠性的？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP主要提供了检验和、序列号/确认应答、超时重传、最大消息长度、滑动窗口控制等方法实现了可靠性传输。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouj6ZMhcQibk66uUicbBEFbRwNHxMzbEuSQCdAERXStfeF5gwgibxUNwX7g/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;TCP保证可靠性的方法&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;连接管理&lt;/strong&gt;：TCP使用三次握手和四次挥手保证可靠地建立连接和释放连接，这里就不用多说了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;校验和&lt;/strong&gt;：TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果接收端的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCousLhftsy7RVV0NqLpFt6b5icSCwudYLYfzibEb6LVY07P2PPUEfR9LLww/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;TCP校验和&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;序列号/确认应答&lt;/strong&gt;：TCP 给发送的每一个包进行编号，接收方会对收到的包进行应答，发送方就会知道接收方是否收到对应的包，如果发现没有收到，就会重发，这样就能保证数据的完整性。就像老师上课，会问一句，这一章听懂了吗？没听懂再讲一遍。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCoucdsw6VBXiaib9QLBAQFNkiaYGSQqeCku9q5Raib2CyG1g1POLA2de7cBOg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;序列号/确认应答&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;**流量控制：**TCP  连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。（TCP 利用滑动窗口实现流量控制）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouGU7GEO2z9KVHt7DECXmeGFAyRu4icMgRDkicLw224NtxIcbibSMGhIlOA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;滑动窗口简图&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;5&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;最大消息长度&lt;/strong&gt;：在建立TCP连接的时候，双方约定一个最大的长度（MSS）作为发送的单位，重传的时候也是以这个单位来进行重传。理想的情况下是该长度的数据刚好不被网络层分块。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouKPalprQlFic2iabz6T9Wz6MXYA2t1Nzo5E3K050VicjhawFcoEPAPy4MQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;最大消息长度&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;6&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;**超时重传：**超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouIRyhADEiaDcicWYQTgoIdDCrg5yLt5gjaSOFLNf6sibNCMyxjiaaVFPVYw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;超时重传&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;7&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;**拥塞控制：**如果网络非常拥堵，此时再发送数据就会加重网络负担，那么发送的数据段很可能超过了最大生存时间也没有到达接收方，就会产生丢包问题。为此TCP引入慢启动机制，先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度传送数据。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouDItrAppSHLBS5ulqAUSXk5hE7MSdlrkbkWxDb5ab7KRojQFwYAQHGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;拥塞控制简略示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;38.说说 TCP 的流量控制？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP 提供了一种机制，可以让发送端根据接收端的实际接收能力控制发送的数据量，这就是&lt;strong&gt;流量控制&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP 通过&lt;strong&gt;滑动窗口&lt;/strong&gt;来控制流量，我们看下简要流程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先双方三次握手，初始化各自的窗口大小，均为 400 个字节。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWeP0w7dibn7l3skTzywDDCoudhV8NAurg9ibiaDEfZobeStybyZNHFDv0ZicK9FaL8TCRDMCMtGJRnRAA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;figcaption&gt;TCP流量控制&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;假如当前发送方给接收方发送了 200 个字节，那么，发送方的&lt;code&gt;SND.NXT&lt;/code&gt;会右移 200 个字节，也就是说当前的可用窗口减少了 200 个字节。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接受方收到后，放到缓冲队列里面，REV.WND =400-200=200 字节，所以 win=200 字节返回给发送方。接收方会在 ACK 的报文首部带上缩小后的滑动窗口 200 字节&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发送方又发送 200 字节过来，200 字节到达，继续放到缓冲队列。不过这时候，由于大量负载的原因，接受方处理不了这么多字节，只能处理 100 字节，剩余的 100 字节继续放到缓冲队列。这时候，REV.WND = 400-200-100=100 字节，即 win=100 返回发送方。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发送方继续发送 100 字节过来，这时候，接收窗口 win 变为 0。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发送方停止发送，开启一个定时任务，每隔一段时间，就去询问接受方，直到 win 大于 0，才继续开始发送。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;39.详细说说 TCP 的滑动窗口？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP 发送一个数据，如果需要收到确认应答，才会发送下一个数据。这样的话就会有个缺点：效率会比较低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“用一个比喻，我们在微信上聊天，你打完一句话，我回复一句之后，你才能打下一句。假如我没有及时回复呢？你是把话憋着不说吗？然后傻傻等到我回复之后再接着发下一句？”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，TCP 引入了&lt;strong&gt;窗口&lt;/strong&gt;，它是操作系统开辟的一个缓存空间。窗口大小值表示无需等待确认应答，而可以继续发送数据的最大值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP 头部有个字段叫 win，也即那个 &lt;strong&gt;16 位的窗口大小&lt;/strong&gt;，它告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度，从而达到&lt;strong&gt;流量控制&lt;/strong&gt;的目的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“通俗点讲，就是接受方每次收到数据包，在发送确认报文的时候，同时告诉发送方，自己的缓存区还有多少空余空间，缓冲区的空余空间，我们就称之为接受窗口大小。这就是 win。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP 滑动窗口分为两种: 发送窗口和接收窗口。&lt;strong&gt;发送端的滑动窗口&lt;/strong&gt;包含四大部分，如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;已发送且已收到 ACK 确认&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;已发送但未收到 ACK 确认&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;未发送但可以发送&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;未发送也不可以发送&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWeP0w7dibn7l3skTzywDDCouPVleyzw1oHqVxaTVicMQhbDazUNSm7D4ias6HFQLTxZdGUVvtiaBzaYPQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;figcaption&gt;发送端滑动窗口&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;深蓝色框里就是发送窗口。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;SND.WND: 表示发送窗口的大小, 上图虚线框的格子数是 10个，即发送窗口大小是 10。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;SND.NXT：下一个发送的位置，它指向未发送但可以发送的第一个字节的序列号。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;SND.UNA: 一个绝对指针，它指向的是已发送但未确认的第一个字节的序列号。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接收方的滑动窗口包含三大部分，如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;已成功接收并确认&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;未收到数据但可以接收&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;未收到数据并不可以接收的数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWeP0w7dibn7l3skTzywDDCouLXZX4PfCIOKY8OfzZQuk2pqd1CkKRZj10Lxnbmvicmg2CxUwo1Az9ng/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;figcaption&gt;接收方滑动窗口&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;蓝色框内，就是接收窗口。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;REV.WND: 表示接收窗口的大小, 上图虚线框的格子就是 9 个。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;REV.NXT: 下一个接收的位置，它指向未收到但可以接收的第一个字节的序列号。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;40.了解Nagle 算法和延迟确认吗？&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;Nagle 算法和延迟确认是干什么的？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们 TCP 报⽂的承载的数据⾮常⼩的时候，例如⼏个字节，那么整个⽹络的效率是很低的，因为每个 TCP 报⽂中都会有 20 个字节的 TCP 头部，也会有 20 个字节的 IP 头部，⽽数据只有⼏个字节，所以在整个报⽂中有效数据占有的比例就会⾮常低。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouu2bdH3p4qabQicwDlErFQ7NjJstIdqOYZaEHSUQmNIFCpibnCPd7QGiag/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;小数据情况&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就好像快递员开着⼤货⻋送⼀个⼩包裹⼀样浪费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么就出现了常⻅的两种策略，来减少⼩报⽂的传输，分别是：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;Nagle 算法&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nagle 算法：&lt;strong&gt;任意时刻，最多只能有一个未被确认的小段&lt;/strong&gt;。所谓 “小段”，指的是小于 MSS 尺寸的数据块，所谓 “未被确认”，是指一个数据块发送出去后，没有收到对方发送的 ACK 确认该数据已收到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nagle 算法的策略：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;没有已发送未确认报⽂时，⽴刻发送数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;存在未确认报⽂时，直到「没有已发送未确认报⽂」或「数据⻓度达到 MSS ⼤⼩」时，再发送数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只要没满⾜上⾯条件中的⼀条，发送⽅⼀直在囤积数据，直到满⾜上⾯的发送条件。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;延迟确认&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上当没有携带数据的 ACK，它的⽹络效率也是很低的，因为它也有 40 个字节的 IP 头 和 TCP 头，但却没有携带数据报⽂。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决 ACK 传输效率低问题，所以就衍⽣出了 &lt;strong&gt;TCP&lt;/strong&gt; 延迟确认。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP 延迟确认的策略：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当有响应数据要发送时，ACK 会随着响应数据⼀起⽴刻发送给对⽅&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当没有响应数据要发送时，ACK 将会延迟⼀段时间，以等待是否有响应数据可以⼀起发送&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果在延迟等待发送 ACK 期间，对⽅的第⼆个数据报⽂⼜到达了，这时就会⽴刻发送 ACK&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般情况下，&lt;strong&gt;Nagle 算法和延迟确认&lt;/strong&gt;不能一起使用，Nagle 算法意味着延迟发，&lt;strong&gt;延迟确认&lt;/strong&gt;意味着延迟接收，两个凑在一起就会造成更大的延迟，会产生性能问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;41.说说TCP 的拥塞控制？&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;什么是拥塞控制？不是有了流量控制吗？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前⾯的流量控制是避免发送⽅的数据填满接收⽅的缓存，但是并不知道整个⽹络之中发⽣了什么。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;⼀般来说，计算机⽹络都处在⼀个共享的环境。因此也有可能会因为其他主机之间的通信使得⽹络拥堵。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在⽹络出现拥堵时，如果继续发送⼤量数据包，可能会导致数据包时延、丢失等，这时 &lt;strong&gt;TCP&lt;/strong&gt; 就会重传数据，但是⼀重传就会导致⽹络的负担更重，于是会导致更⼤的延迟以及更多的丢包，这个情况就会进⼊恶性循环被不断地放⼤....&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，TCP 不能忽略整个网络中发⽣的事，它被设计成⼀个⽆私的协议，当⽹络发送拥塞时，TCP 会⾃我牺牲，降低发送的数据流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是，就有了拥塞控制，控制的⽬的就是避免发送⽅的数据填满整个⽹络。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就像是一个水管，不能让太多的水（数据流）流入水管，如果超过水管的承受能力，水管会被撑爆（丢包）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWeP0w7dibn7l3skTzywDDCouIb1layfPOY427zw6tphvvKiaHWMPvZ1WDyZ3OiaIU70aJn2BLsKibftMQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot;/&gt;&lt;figcaption&gt;破解的水管-图片来源网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发送方维护一个&lt;strong&gt;拥塞窗口 cwnd（congestion window）&lt;/strong&gt; 的变量，调节所要发送数据的量。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;什么是拥塞窗⼝？和发送窗⼝有什么关系呢？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拥塞窗⼝ &lt;strong&gt;cwnd&lt;/strong&gt;是发送⽅维护的⼀个的状态变量，它会根据⽹络的拥塞程度动态变化的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发送窗⼝ swnd 和接收窗⼝ rwnd 是约等于的关系，那么由于加⼊了拥塞窗⼝的概念后，此时发送窗⼝的值是swnd = min(cwnd, rwnd)，也就是拥塞窗⼝和接收窗⼝中的最⼩值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拥塞窗⼝ cwnd 变化的规则：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;只要⽹络中没有出现拥塞， cwnd 就会增⼤；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;但⽹络中出现了拥塞， cwnd 就减少；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;拥塞控制有哪些常用算法？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拥塞控制主要有这几种常用算法：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouiaFoQ0aXiaMZnpAFPu18ttb7jxxC2yjWxIJ3jEicIMpB64ibacwUeUkaaA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;拥塞控制常用算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;慢启动算法&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;慢启动算法，慢慢启动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它表示 TCP 建立连接完成后，一开始不要发送大量的数据，而是先探测一下网络的拥塞程度。由小到大逐渐增加拥塞窗口的大小，如果没有出现丢包，&lt;strong&gt;每收到一个 ACK，就将拥塞窗口 cwnd 大小就加 1（单位是 MSS）&lt;/strong&gt;。&lt;strong&gt;每轮次&lt;/strong&gt;发送窗口增加一倍，呈指数增长，如果出现丢包，拥塞窗口就减半，进入拥塞避免阶段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;连接建⽴完成后，⼀开始初始化 cwnd = 1 ，表示可以传⼀个 MSS ⼤⼩的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当收到⼀个 ACK 确认应答后，cwnd 增加 1，于是⼀次能够发送 2 个&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以⽐之前多发2 个，所以这⼀次能够发送 4 个&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以⽐之前多发4 个，所以这⼀次能够发送 8 个。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouogYS6tDkRp8hbnKt1emZqOnmnVibwOUQpu5e9wSqZoF66iaNmDLCEKvA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;慢启动算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发包的个数是指数性的增⻓。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCou1OwGTL3T9CEYNzP0jc3gia53orHbcWibVRs2bvxmoRRwzM5uw1Dk44Ow/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;慢启动呈指数型增长&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了防止 cwnd 增长过大引起网络拥塞，还需设置一个&lt;strong&gt;慢启动阀值 ssthresh&lt;/strong&gt;（slow start threshold）状态变量。当&lt;code&gt;cwnd&lt;/code&gt;到达该阀值后，就好像水管被关小了水龙头一样，减少拥塞状态。即当 &lt;strong&gt;cwnd &amp;gt;ssthresh&lt;/strong&gt; 时，进入了&lt;strong&gt;拥塞避免&lt;/strong&gt;算法。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;拥塞避免算法&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，慢启动阀值 ssthresh 是 65535 字节，&lt;code&gt;cwnd&lt;/code&gt;到达&lt;strong&gt;慢启动阀值&lt;/strong&gt;后&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;每收到一个 ACK 时，cwnd = cwnd + 1/cwnd&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当每过一个 RTT 时，cwnd = cwnd + 1&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然这是一个线性上升的算法，避免过快导致网络拥塞问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着上面慢启动的例子，假定 ssthresh 为 8 ：：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd ⼀共增加 1，于是这⼀次能够发送 9个 MSS ⼤⼩的数据，变成了线性增⻓。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouBYzdica2CoPsmY8nFIPd3sLJdhA5JRFGglbkUDCiaIuuuOw89pic2O6hg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;拥塞避免算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;拥塞发生&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当网络拥塞发生&lt;strong&gt;丢包&lt;/strong&gt;时，会有两种情况：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是发生了 &lt;strong&gt;RTO 超时重传&lt;/strong&gt;，就会使用拥塞发生算法&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;慢启动阀值 sshthresh =  cwnd /2&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cwnd 重置为 1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;进入新的慢启动过程&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCour3AhiabFAUcPcjbaXBanlaulWJ7Fx9zpKLT4dd8AKDrUNt38S88qmjA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;拥塞发生算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式就像是飙车的时候急刹车，还飞速倒车，这。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实还有更好的处理方式，就是&lt;strong&gt;快速重传&lt;/strong&gt;。发送方收到 3 个连续重复的 ACK 时，就会快速地重传，不必等待 &lt;strong&gt;RTO 超时&lt;/strong&gt;再重传。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发⽣快速重传的拥塞发⽣算法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;拥塞窗口大小 cwnd = cwnd/2&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;慢启动阀值 ssthresh = cwnd&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;进入快速恢复算法&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;快速恢复&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;快速重传和快速恢复算法一般同时使用。快速恢复算法认为，还有 3 个重复 ACK 收到，说明网络也没那么糟糕，所以没有必要像 RTO 超时那么强烈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如前面所说，进入快速恢复之前，cwnd 和 sshthresh 已被更新：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;- sshthresh = cwnd&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，进⼊快速恢复算法如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;cwnd = sshthresh  + 3&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重传重复的那几个 ACK（即丢失的那几个数据包）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果再收到重复的 ACK，那么 cwnd = cwnd +1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果收到新数据的 ACK 后, cwnd = sshthresh。因为收到新数据的 ACK，表明恢复过程已经结束，可以再次进入了拥塞避免的算法了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouM0PXh50gTB89hAQZ24nMzHj5r2jPrNcaVTqPFw7wr0CUTCFIicianicdw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;快速恢复算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;42.说说 TCP 的重传机制？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重传包括&lt;strong&gt;超时重传、快速重传、带选择确认的重传（SACK）、重复 SACK 四种&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouGsdEFVy0AZx6EnM5qtXtbXv0ST76XibRsrxQEU0MX7aCoTolqy2IToA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;TCP重传分类&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;超时重传&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;超时重传，是 TCP 协议保证数据可靠性的另一个重要机制，其原理是在发送某一个数据以后就开启一个计时器，在一定时间内如果没有得到发送的数据报的 ACK 报文，那么就重新发送数据，直到发送成功为止。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;超时时间应该设置为多少呢？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来看下什么叫 &lt;strong&gt;RTT（Round-Trip Time，往返时间）&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCourLs7w1k8zY2CMoKNR9oqaUulTFMArsQ0jFN6JXfNpySA897O0oTqAw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;RTT&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RTT 就是数据完全发送完，到收到确认信号的时间，即数据包的一次往返时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;超时重传时间，就是 RTO（Retransmission Timeout)。那么，&lt;strong&gt;RTO 到底设置多大呢？&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果 RTO 设置很大，等了很久都没重发，这样肯定就不行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果 RTO 设置很小，那很可能数据都没有丢失，就开始重发了，这会导致网络阻塞，从而恶性循环，导致更多的超时出现。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，RTO 略微大于 RTT，效果是最佳的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，RTO 有个标准方法的计算公式，也叫 &lt;strong&gt;Jacobson / Karels 算法&lt;/strong&gt;。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先计算 SRTT（即计算平滑的 RTT）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;SRTT = (1 - α) * SRTT + α * RTT  //求 SRTT 的加权平均&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;其次，计算 RTTVAR (round-trip time variation)&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;RTTVAR = (1 - β) * RTTVAR + β * (|RTT - SRTT|) //计算 SRTT 与真实值的差距&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;最后，得出最终的 RTO&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;RTO = µ * SRTT + ∂ * RTTVAR  =  SRTT + 4·RTTVAR  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Linux 下，&lt;strong&gt;α = 0.125&lt;/strong&gt;，&lt;strong&gt;β = 0.25&lt;/strong&gt;， &lt;strong&gt;μ = 1&lt;/strong&gt;，&lt;strong&gt;∂ = 4&lt;/strong&gt;。别问这些参数是怎么来的，它们是大量实践，调出的最优参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;超时重传不是十分完美的重传方案，它有这些缺点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当一个报文丢失时，会等待一定的超时周期，才重传分组，增加了端到端的时延。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当一个报文丢失时，在其等待超时的过程中，可能会出现这种情况：其后的报文段已经被接收端接收但却迟迟得不到确认，发送端会认为也丢失了，从而引起不必要的重传，既浪费资源也浪费时间。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且，对于 TCP，如果发生一次超时重传，时间间隔下次就会加倍。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;快速重传&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP 还有另外⼀种快速重传（&lt;strong&gt;Fast Retransmit&lt;/strong&gt;）机制，它不以时间为驱动，⽽是以数据驱动重传。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它不以时间驱动，而是以数据驱动。它是基于接收端的反馈信息来引发重传的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以用它来解决超时重发的时间等待问题，快速重传流程如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouwAv6VfNrFW13PwV3qWc3Pf8DZyicPsficB5XWtuK2AK1iaK2f9gibjaOfw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;快速重传流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图，发送⽅发出了 1，2，3，4，5 份数据：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;第⼀份 Seq1 先送到了，于是就 Ack 回 2；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;后⾯的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;发送端收到了三个 &lt;strong&gt;Ack = 2&lt;/strong&gt; 的确认，知道了 &lt;strong&gt;Seq2&lt;/strong&gt; 还没有收到，就会在定时器过期之前，重传丢失的 &lt;strong&gt;Seq2&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;快速重传机制只解决了⼀个问题，就是超时时间的问题，但是它依然⾯临着另外⼀个问题。就是重传的时候，是重传之前的⼀个，还是重传所有的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;⽐如对于上⾯的例⼦，是重传 Seq2 呢？还是重传 Seq2、Seq3、Seq4、Seq5 呢？因为发送端并不清楚这连续的三个 Ack 2 是谁传回来的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据 TCP 不同的实现，以上两种情况都是有可能的。可⻅，这是⼀把双刃剑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决不知道该重传哪些 TCP 报⽂，于是就有 SACK ⽅法。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;带选择确认的重传（SACK）&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决应该重传多少个包的问题? TCP 提供了&lt;strong&gt;带选择确认的重传&lt;/strong&gt;（即 SACK，Selective Acknowledgment）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;SACK 机制&lt;/strong&gt;就是，在快速重传的基础上，接收方返回最近收到报文段的序列号范围，这样发送方就知道接收方哪些数据包是没收到的。这样就很清楚应该重传哪些数据包。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCoub0FZDoDiasoxsl1SJCDicvR3HnVUwJosxlibsWBqRFPXCMhkiaqPVrP4AQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;SACK机制-来源参考[3]&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图中，发送⽅收到了三次同样的 ACK 确认报⽂，于是就会触发快速重发机制，通过 SACK 信息发现只有200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进⾏重发。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;重复 SACK（D-SACK）&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;D-SACK，英文是 Duplicate SACK，是在 SACK 的基础上做了一些扩展，主要用来告诉发送方，有哪些数据包，自己重复接受了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DSACK 的目的是帮助发送方判断，是否发生了包失序、ACK 丢失、包重复或伪重传。让 TCP 可以更好的做网络流控。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如ACK丢包导致的数据包重复：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCoub1cSkmRqf1Vsp1dcWIAWa2rW6fyfpDVdWcGWWiafT6gAnTaG4F9FF3w/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;ACK丢包-来源参考[3]&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;接收⽅发给发送⽅的两个 ACK 确认应答都丢失了，所以发送⽅超时后，重传第⼀个数据包（3000 ~&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3499）&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;于是接收⽅发现数据是重复收到的，于是回了⼀个 &lt;strong&gt;SACK = 3000~3500&lt;/strong&gt;，告诉「发送⽅」 3000~3500的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个SACK 就代表着 D-SACK 。这样发送⽅就知道了，数据没有丢，是接收⽅的 ACK 确认报⽂丢了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;43.说说TCP 的粘包和拆包？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP 的粘包和拆包更多的是业务上的概念！&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;什么是TCP粘包和拆包？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP 是面向流，没有界限的一串数据。TCP 底层并不了解上层业务数据的具体含义，它会根据 TCP 缓冲区的实际情况进行包的划分，所以在业务上认为，一&lt;strong&gt;个完整的包可能会被 TCP 拆分成多个包进行发送&lt;/strong&gt;，&lt;strong&gt;也有可能把多个小的包封装成一个大的数据包发送&lt;/strong&gt;，这就是所谓的 TCP 粘包和拆包问题。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCoua1Uzs0297Ziay3hWfNIibMEUk3HkVeardJAcE1BGKxtCECd9qJwOjDuw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;TCP 的粘包和拆包&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;为什么会产生粘包和拆包呢?&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。即 TCP 报文长度 - TCP 头部长度 &amp;gt; MSS。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;那怎么解决呢？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;发送端将每个数据包封装为固定长度&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在数据尾部增加特殊字符进行分割&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;UDP&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;UDP问的不多，基本上是被拿来和TCP比较。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;44.说说 TCP 和 UDP 的区别？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最根本区别：&lt;strong&gt;TCP 是面向连接，而 UDP 是无连接&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCoutPh5yk76jBQPkkbto7USfRz1JpbMqeyvbrWGzNe2Beib60j8x9Exd0g/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;TCP和UDP区别&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以这么形容：TCP是打电话，UDP是大喇叭。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCoutUXz62vIHmkP4ZwmYKicia9daLbYNrJ5uLVGkzP4xPOcTP68uGtGicpJg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;TCP和UDP比喻&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;说说TCP和UDP的应用场景？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;TCP应用场景：&lt;/strong&gt; 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、收发邮件、远程登录。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;UDP应用场景：&lt;/strong&gt; 效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;45.为什么QQ采用UDP协议？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PS：这是多年前的老题了，拉出来怀怀旧。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouJ6tSuaUwtT3RXfrm2gq9Tq5HIuv4QHlFib1a7qGCFUplPZqHyQ4yv1g/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;QQ使用UDP&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先，QQ并不是完全基于UDP实现。比如在使用QQ进行文件传输等活动的时候，就会使用TCP作为可靠传输的保证。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用UDP进行交互通信的好处在于，延迟较短，对数据丢失的处理比较简单。同时，TCP是一个全双工协议，需要建立连接，所以网络开销也会相对大。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果使用QQ语音和QQ视频的话，UDP的优势就更为突出了，首先延迟较小。最重要的一点是不可靠传输，这意味着如果数据丢失的话，不会有重传。因为用户一般来说可以接受图像稍微模糊一点，声音稍微不清晰一点，但是如果在几秒钟以后再出现之前丢失的画面和声音，这恐怕是很难接受的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于QQ的服务器设计容量是海量级的应用，一台服务器要同时容纳十几万的并发连接，因此服务器端只有采用UDP协议与客户端进行通讯才能保证这种超大规模的服务&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单总结一下：UDP协议是无连接方式的协议，它的效率高，速度快，占资源少，对服务器的压力比较小。但是其传输机制为不可靠传送，必须依靠辅助的算法来完成传输控制。QQ采用的通信协议以UDP为主，辅以TCP协议。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;46.UDP协议为什么不可靠？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认，提供不可靠交付。总结就以下四点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不保证消息交付：不确认，不重传，无超时&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不跟踪连接状态：不必建立连接或重启状态机&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不进行拥塞控制：不内置客户端或网络反馈机制&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;47.DNS为什么要用UDP?&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更准确地说，DNS既使用TCP又使用UDP。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用TCP，因为数据同步传送的数据量比一个请求和应答的数据量要多，而TCP允许的报文长度更长，因此为了保证数据的正确性，会使用基于可靠连接的TCP。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当客户端想DNS服务器查询域名（域名解析）的时候，一般返回的内容不会超过UDP报文的最大长度，即512字节，用UDP传输时，不需要创建连接，从而大大提高了响应速度，但这要求域名解析服务器和域名服务器都必须自己处理超时和重传从而保证可靠性。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;IP&lt;/span&gt;&lt;/h1&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;48.IP 协议的定义和作用？&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;IP协议是什么？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IP协议（Internet Protocol）又被称为互联网协议，是支持网间互联的数据包协议，工作在&lt;strong&gt;网际层&lt;/strong&gt;，主要目的就是为了提高网络的可扩展性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过&lt;strong&gt;网际协议IP&lt;/strong&gt;，可以把参与互联的，性能各异的网络&lt;strong&gt;看作一个统一的网络&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCoupDd05OJxtdJnaBf17pyqVAOtRibWtEiblBAXcGNtoo6UiawRcGz0x3iaUg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;虚拟IP网&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和传输层TCP相比，IP协议是一种无连接/不可靠、尽力而为的数据包传输服务，和TCP协议一起构成了TCP/IP协议的核心。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;IP协议有哪些作用？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IP协议主要有以下几个作用：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;寻址和路由&lt;/strong&gt;：在IP数据报中携带源IP地址和目的IP地址来表示该数据包的源主机和目标主机。IP数据报在传输过程中，每个中间节点（IP网关、路由器）只根据网络地址来进行转发，如果中间节点是路由器，则路由器会根据路由表选择合适的路径。IP协议根据路由选择协议提供的路由信息对IP数据报进行转发，直至目标主机。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;分段和重组&lt;/strong&gt;：IP数据报在传输过程中可能会经过不同的网络，在不同的网络中数据报的最大长度限制是不同的，IP协议通过给每个IP数据报分配一个标识符以及分段与组装的相关信息，使得数据报在不同的网络中能够被传输，被分段后的IP数据报可以独立地在网络中进行转发，在达到目标主机后由目标主机完成重组工作，恢复出原来的IP数据报。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;传输层协议和网络层协议有什么区别？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网络层协议负责提供主机间的逻辑通信；传输层协议负责提供进程间的逻辑通信。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;49.IP 地址有哪些分类？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个IP地址在这鞥个互联网范围内是惟一的，一般可以这么认为，IP 地址 = {&amp;lt;网络号&amp;gt;，&amp;lt;主机号&amp;gt;}。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;网络号&lt;/strong&gt;：它标志主机所连接的网络地址表示属于互联网的哪一个网络。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;主机号&lt;/strong&gt;：它标志主机地址表示其属于该网络中的哪一台主机。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IP 地址分为 A，B，C，D，E 五大类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;A 类地址 (1~126)：以 0 开头，网络号占前 8 位，主机号占后面 24 位。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;B 类地址 (128~191)：以 10 开头，网络号占前 16 位，主机号占后面 16 位。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;C 类地址 (192~223)：以 110 开头，网络号占前 24 位，主机号占后面 8 位。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;D 类地址 (224~239)：以 1110 开头，保留为多播地址。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;E 类地址 (240~255)：以 1111开头，保留位为将来使用&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouQ4oIUF1z0uia0iaibXAEl3ogfKoiaH56Q87lUb6R9araF9mHrDADtiaibfibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;IP地址分类&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;50.域名和 IP 的关系？一个 IP 可以对应多个域名吗？&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;IP地址在同一个网络中是惟一的，用来标识每一个网络上的设备，其相当于一个人的身份证号&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;域名在同一个网络中也是惟一的，就像是一个人的名字、绰号&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如你有多个不用的绰号，你的朋友可以用其中任何一个绰号叫你，但你的身份证号码却是惟一的。但同时你的绰号也可能和别人重复，假如你不在，有人叫你的绰号，其它人可能就答应了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个域名可以对应多个IP，但这种情况DNS做负载均衡的，在用户访问过程中，一个域名只能对应一个IP。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而一个IP却可以对应多个域名，是一对多的关系。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;51.IPV4 地址不够如何解决？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，IP地址有32位，可以标记2的32次方个地址，听起来很多，但是全球的网络设备数量已经远远超过这个数字，所以IPV4地址已经不够用了，那怎么解决呢？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouFcNoUP2UqetVPLkeu9JJdib3Kh8KgM2sdgMnu5TlAOJaZmGU2SBzmZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;IPV4不够解决办法&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;DHCP：动态主机配置协议，动态分配IP地址，只给接入网络的设备分配IP地址，因此同一个MAC地址的设备，每次接入互联网时，得到的IP地址不一定是相同的，该协议使得空闲的IP地址可以得到充分利用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CIDR：无类别域间路由。CIDR消除了传统的A类、B类、C类地址以及划分子网的概念，因而更加有效地分配IPv4的地址空间，但无法从根本上解决地址耗尽的问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NAT：网络地址转换协议，我们知道属于不同局域网的主机可以使用相同的IP地址，从而一定程度上缓解了IP资源枯竭的问题，然而主机在局域网中使用的IP地址是不能在公网中使用的，当局域网主机想要与公网主机进行通信时，NAT方法可以将该主机IP地址转换为全球IP地址。该协议能够有效解决IP地址不足的问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;IPv6：作为接替IPv4的下一代互联网协议，其可以实现2的128次方个地址，而这个数量级，即使给地球上每一粒沙子都分配一个IP地址也够用，该协议能够从根本上解决IPv4地址不够用的问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;52.说下 ARP 协议的工作过程？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ARP 协议，&lt;strong&gt;Address Resolution Protocol&lt;/strong&gt;，地址解析协议，它是用于实现 IP 地址到 MAC 地址的映射。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouia0iaZcRFC9gfB9OuY28ALfOtgicDfuy6xB1iaj6exPnvgM4Ect4Bq2PkA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;ARP 协议作用&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;首先，每台主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当源主机需要将一个数据包要发送到目的主机时，会首先检查自己的 ARP 列表，是否存在该 IP 地址对应的 MAC 地址；如果有﹐就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP 请求的广播包，查询此目的主机对应的 MAC 地址。此 ARP 请求的数据包里，包括源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同，就会忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;53.为什么既有IP地址，又有MAC 地址？&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;MAC地址和IP地址都有什么作用？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;MAC地址是数据链路层和物理层使用的地址，是写在网卡上的物理地址，用来定义网络设备的位置，不可变更。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;IP地址是网络层和以上各层使用的地址，是一种逻辑地址。IP地址用来区别网络上的计算机。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;为什么有了MAC地址还需要IP地址？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们只使用MAC地址进行寻址的话，我们需要路由器记住每个MAC地址属于哪个子网，不然一次路由器收到数据包都要满世界寻找目的MAC地址。而我们知道MAC地址的长度为48位，也就是最多共有2的48次方个MAC地址，这就意味着每个路由器需要256T的内存，显然是不现实的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和MAC地址不同，IP地址是和地域相关的，在一个子网中的设备，我们给其分配的IP地址前缀都是一样的，这样路由器就能根据IP地址的前缀知道这个设备属于哪个子网，剩下的寻址就交给子网内部实现，从而大大减少了路由器所需要的内存。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;为什么有了IP地址还需要MAC地址？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCoumel5vOp8WKy9kQYib8ojxf8frwP8zACCjTRUbJgCpu7H4DuYfOcCp0w/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;IP地址和MAC地址&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;只有当设备连入网络时，才能根据他进入了哪个子网来为其分配IP地址，在设备还没有IP地址的时候，或者在分配IP的过程中。我们需要MAC地址来区分不同的设备。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;IP 地址可以比作为地址，MAC 地址为收件人，在一次通信过程中，两者是缺一不可的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;54.ICMP 协议的功能？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ICMP（Internet Control Message Protocol） ，网际控制报文协议。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;ICMP 协议是一种面向无连接的协议，用于传输出错报告控制信息。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;它是一个非常重要的协议，它对于网络安全具有极其重要的意义。它属于网络层协议，主要用于在主机与路由器之间传递控制信息，包括&lt;strong&gt;报告错误、交换受限控制和状态信息&lt;/strong&gt;等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当遇到 IP 数据无法访问目标、IP 路由器无法按当前的传输速率转发数据包等情况时，会自动发送 ICMP 消息。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们日常使用得比较多的 &lt;strong&gt;ping&lt;/strong&gt;，就是基于 ICMP 的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;55.说下 ping 的原理？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ping，&lt;strong&gt;Packet Internet Groper&lt;/strong&gt;，是一种因特网包探索器，用于测试网络连接量的程序。Ping 是工作在 TCP/IP 网络体系结构中应用层的一个服务命令， 主要是向特定的目的主机发送 ICMP（Internet Control Message Protocol 因特网报文控制协议） 请求报文，测试目的站是否可达及了解其有关状态。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouVx7Dtx6jqNk3zGp2RugayVaPyIYFEmnxdfUNWIGDkowjlTibh6EabuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;ping百度&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，ping 可以用来检测网络通不通。它是基于&lt;code&gt;ICMP&lt;/code&gt;协议工作的。假设&lt;strong&gt;机器 A&lt;/strong&gt; ping &lt;strong&gt;机器 B&lt;/strong&gt;，工作过程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ping 通知系统，新建一个固定格式的 ICMP 请求数据包&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ICMP 协议，将该数据包和目标机器 B 的 IP 地址打包，一起转交给 IP 协议层&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;IP 层协议将本机 IP 地址为源地址，机器 B 的 IP 地址为目标地址，加上一些其他的控制信息，构建一个 IP 数据包&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;先获取目标机器 B 的 MAC 地址。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据链路层构建一个数据帧，目的地址是 IP 层传过来的 &lt;strong&gt;MAC 地址&lt;/strong&gt;，源地址是本机的 &lt;strong&gt;MAC 地址&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;机器 B 收到后，对比目标地址，和自己本机的 MAC 地址是否一致，符合就处理返回，不符合就丢弃。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据目的主机返回的 ICMP 回送回答报文中的时间戳，从而计算出往返时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最终显示结果有这几项：发送到目的主机的 IP 地址、发送 &amp;amp; 收到 &amp;amp; 丢失的分组数、往返时间的最小、最大 &amp;amp; 平均值&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;网络安全&lt;/span&gt;&lt;/h1&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;56.说说有哪些安全攻击？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网络安全攻击主要分为两种类型，&lt;strong&gt;被动攻击&lt;/strong&gt;和&lt;strong&gt;主动攻击&lt;/strong&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouLU4booet1KCM2ibprarGSHTc3Oj3mjVlBtnvtX0ephf16iaNTuXBiaEMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;主动攻击和被动攻击&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;被动攻击&lt;/strong&gt;：是指攻击者从网络上窃听他人的通信内容，通常把这类攻击称为截获，被动攻击主要有两种形式：消息内容泄露攻击和流量分析攻击。由于攻击者没有修改数据，使得这种攻击很难被检测到。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;主动攻击&lt;/strong&gt;：直接对现有的数据和服务造成影响，常见的主动攻击类型有：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;篡改&lt;/strong&gt;：攻击者故意篡改网络上送的报文，甚至把完全伪造的报文传送给接收方。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;恶意程序&lt;/strong&gt;：恶意程序种类繁多，包括计算机病毒、计算机蠕虫、特洛伊木马、后门入侵、流氓软件等等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;拒绝服务Dos&lt;/strong&gt;：攻击者向服务器不停地发送分组，使服务器无法提供正常服务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;57.DNS劫持了解吗？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DNS劫持即域名劫持，是通过将原域名对应的IP地址进行替换，从而使用户访问到错误的网站，或者使用户无法正常访问网站的一种攻击方式。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouRhO1vtH1vQlHQK02Dl53pic91W0pMuNh35ZYqiaR0wKtXxibicOYX5mw8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;DNS劫持示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;域名劫持往往只能在特定的网络范围内进行，范围外的DNS服务器能够返回正常的IP地址。攻击者可以冒充原域名所属机构，通过电子邮件的方式修改组织机构的域名注册信息，或者将域名转让给其它主持，并将新的域名信息保存在所指定的DNS服务器中，从而使用户无法对原域名来进行解析以访问目标地址。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;DNS劫持的步骤是什么样的？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取要劫持的域名信息：攻击者会首先访问域名查询要劫持的站点的域名信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;控制域名响应的E-Mail账号：在获取到域名信息后，攻击者通过暴力破解或者专门的方法破解公司注册域名时使用的E-mail账号所对应的密码，更高级的攻击者甚至能够直接对E-Mail进行信息窃取。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修改注册信息：当攻击者破解了E-Mail后，会利用相关的更改功能修改该域名的注册信息，包括域名拥有者信息，DNS服务器信息等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用E-Mail收发确认函：在修改完注册信息后，攻击者E-Mail在真正拥有者之前收到修改域名注册信息的相关确认信息，并回复确认修改文件，待网络公司恢复已成功修改信件后，攻击者便成功完成DNS劫持。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;怎么应对DNS劫持？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;直接通过IP地址访问网站，避开DNS劫持&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由于域名劫持往往只能在特定的网络范围内进行，因此一些高级用户可以通过网络设置让DNS指向正常的域名服务器以实现对目标网址的正常访问，例如计算机首选DNS服务器的地址固定为8.8.8.8。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;58.什么是 CSRF 攻击？如何避免？&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;什么是 CSRF 攻击？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CSRF，跨站请求伪造（英文全称是 Cross-site request forgery），是一种挟持用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;CSRF 是如何攻击的呢？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来看一个例子：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCou4E0Kf6CHZDUvqdby3bttTHS6go0kbFNVjSpbIBpY3caED99BauCbag/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;CSRF典型例子&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用户登陆银行，没有退出，浏览器包含了 用户 在银行的身份认证信息。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;攻击者将伪造的转账请求，包含在在帖子&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用户在银行网站保持登陆的情况下，浏览帖子&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;将伪造的转账请求连同身份认证信息，发送到银行网站&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;银行网站看到身份认证信息，以为就是 用户的合法操作，最后造成用户资金损失。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;怎么应对 CSRF 攻击呢？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;检查 Referer 字段&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;HTTP头中的Referer字段记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，而如果黑客要对其实施 CSRF攻击，他一般只能在他自己的网站构造请求。因此，可以通过验证Referer值来防御CSRF 攻击。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;添加校验 token&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有token或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;敏感操作多重校验&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;对一些敏感的操作，除了需要校验用户的认证信息，还可以通过邮箱确认、验证码确认这样的方式多重校验。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;59.什么是 DoS、DDoS、DRDoS 攻击？&lt;/span&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouJeibf0EBBqqar6BcyPWYDEr4S5JGCcpbItd7bRJFGYwXKtV6Q3pmrEg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;请求太多服务器着不住&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;DOS&lt;/strong&gt;: (Denial of Service), 翻译过来就是拒绝服务, 一切能引起拒绝 行为的攻击都被称为 DOS 攻击。最常见的 DoS 攻击就有&lt;strong&gt;计算机网络宽带攻击&lt;/strong&gt;、&lt;strong&gt;连通性攻击&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;DDoS&lt;/strong&gt;: (Distributed Denial of Service)，翻译过来是分布式拒绝服务。是指处于不同位置的多个攻击者同时向一个或几个目标发动攻击，或者一个攻击者控制了位于不同位置的多台机器，并利用这些机器对受害者同时实施攻击。&lt;/p&gt;&lt;p&gt;主要形式有流量攻击和资源耗尽攻击，常见的 DDoS攻击有：&lt;strong&gt;SYN Flood、Ping of Death、ACK Flood、UDP Flood&lt;/strong&gt; 等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;DRDoS&lt;/strong&gt;: (Distributed Reflection Denial of Service)，中文是分布式反射拒绝服务，该方式靠的是发送大量带有被害者 IP 地址的数据包给攻击主机，然后攻击主机对 IP 地址源做出大量回应，从而形成拒绝服务攻击。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;如何防范DDoS?&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对DDoS中的流量攻击，最直接的方法是增加带宽，理论上只要带宽大于攻击流量就可以了，但是这种方法成本非常高。在有充足带宽的前提下，我们应该尽量提升路由器、网卡、交换机等硬件设施的配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对资源耗尽攻击，我们可以升级主机服务器硬件，在网络带宽得到保证的前提下，使得服务器能够有效对抗海量的SYN攻击包。我们也可以安装专业的抗DDoS防火墙，从而对抗SYN Flood等流量型攻击。瓷碗，负载均衡，CDN等技术都能有效对抗DDos攻击。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;60.什么是 XSS 攻击，如何避免?&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;XSS 攻击也是比较常见，XSS，叫&lt;strong&gt;跨站脚本攻击（Cross-Site Scripting）&lt;/strong&gt;，因为会与层叠样式表 (Cascading Style Sheets, CSS) 的缩写混淆，因此有人将跨站脚本攻击缩写为 XSS。它指的是恶意攻击者往 Web 页面里插入恶意 html 代码，当用户浏览网页的时候，嵌入其中 Web 里面的 html 代码会被执行，从而达到恶意攻击用户的特殊目的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;XSS 攻击一般分三种类型：&lt;strong&gt;存储型 、反射型 、DOM 型 XSS&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;XSS 是如何攻击的呢？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单说，XSS的攻击方式就是想办法“教唆”用户的浏览器去执行一些这个网页中原本不存在的前端代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拿反射型举个例子吧，流程图如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;攻击者构造出特殊的 URL，其中包含恶意代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户打开带有恶意代码的 URL 时，访问正常网站服务器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行，请求恶意服务器，发送用户数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;攻击者就可以窃取用户的数据，以此冒充用户的行为，调用目标网站接口执行攻击者指定的操作。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCou9X3EbUkFpzK0jicLCjCOk7jF01RyMHO2CXQfDIZX3JDupQbIJ5ibhQsA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;一个典型的XSS&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;如何应对 XSS 攻击？&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对输入进行过滤，过滤标签等，只允许合法值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HTML 转义&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于链接跳转，如&lt;code&gt;&amp;lt;a href=&quot;xxx&quot;&lt;/code&gt; 等，要校验内容，禁止以 script 开头的非法链接。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;限制输入长度&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;61.对称加密与非对称加密有什么区别？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;对称加密&lt;/strong&gt;：指加密和解密使用同一密钥，优点是运算速度较快，缺点是如何安全将密钥传输给另一方。常见的对称加密算法有：DES、AES 等。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCouvicoTf3IZvBxsgfB2Dr3YD4ymfP7KmvQJ6DNNibmrwK0QfpIiaquC5AXw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;对称加密&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;非对称加密&lt;/strong&gt;：指的是加密和解密使用不同的密钥（即公钥和私钥）。公钥与私钥是成对存在的，如果用公钥对数据进行加密，只有对应的私钥才能解密。常见的非对称加密算法有 RSA。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeP0w7dibn7l3skTzywDDCoucDZy0n9qBHUNGz7a9tsZYwGnFcQMCDpMButD6f3MibjzbZibbEUTkpKw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;figcaption&gt;非对称加密&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;62.RSA和AES算法有什么区别？&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;RSA&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;采用非对称加密的方式，采用公钥进行加密，私钥解密的形式。其私钥长度一般较长，由于需要大数的乘幂求模等运算，其运算速度较慢，不合适大量数据文件加密。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;AES&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;采用对称加密的方式，其秘钥长度最长只有256个比特，加密和解密速度较快，易于硬件实现。由于是对称加密，通信双方在进行数据传输前需要获知加密密钥。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;big data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/big&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;span&gt;[1]. &lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3NzU5NTIwNg==&amp;amp;mid=2247492832&amp;amp;idx=1&amp;amp;sn=601fa1c340a313bc0f74bb75cdb6a95a&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;2W字！梳理50道经典计算机网络面试题（收藏版）&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[2]. 小林coding 《图解网络》&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[3].“三次握手，四次挥手”这么讲，保证你忘不了：https://juejin.cn/post/6965544021833809928&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[4]. 艾小仙 《我要进大厂》&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[5]. 《图解HTTP》&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[6]. 浅析DNS域名解析过程：https://cloud.tencent.com/developer/news/324975&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[7]. 「2021」高频前端面试题汇总之计算机网络篇：https://juejin.cn/post/6908327746473033741&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[8].计算机网络：https://juejin.cn/post/6943748667333427207&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[9]. 谢希仁编著《计算机网络》&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[10].《图解TCP/IP》&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[11].TCP的可靠性传输是如何保证的：https://zhuanlan.zhihu.com/p/112317245&lt;/span&gt;&lt;/li&gt;&lt;li&gt;&lt;span&gt;[12].前端安全系列（一）：如何防止XSS攻击？：https://tech.meituan.com/2018/09/27/fe-security.html&lt;/span&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>