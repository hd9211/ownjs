<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>d409fd0bc4fab49deb57ac16df782bae</guid>
<title>互联网：逻辑上的黑话才是真正的花里胡哨</title>
<link>https://toutiao.io/k/hk3xm6e</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote&gt;&lt;p&gt;互联网上的道理听着都对。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;01&lt;/span&gt;&lt;/p&gt;&lt;p&gt;最近这段时间，张一鸣年会发言火了，最大的亮点就是他读的一段互联网的常用&quot;黑话&quot;:&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.26953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uUIibyNXbAvB0zA65Ufly5SywsOgP1caQniaTXgKmywEvU9hibIkk4HCic9wzTiaZrmVfUoPKdib9zJqGOtwo87FE9kQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;这段内容出自其公司月会材料，被张一鸣放在年会发言，并顺带批评一波这些人不好好说话，引起大批网友共鸣。&lt;/p&gt;&lt;p&gt;随之而来的是互联网某Python大佬的一段神奇脚本，黑话生成器，也跟着火了：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.0515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uUIibyNXbAvB0zA65Ufly5SywsOgP1caQpc2XHnNIgw3Km61wzjKNGFN1vPleNCqiaibeAfrGib30RibZDW0c0I5Xyw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;(建议这个脚本作者去找个风投，目测估值奇高，市场需求和用户群都不低。)&lt;/p&gt;&lt;p&gt;当时还在公司加班的我迅速在电脑里部署了Python环境，并且运行了几次，其中两次效果如下：&lt;/p&gt;&lt;p&gt;忽然一看好像都对：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uUIibyNXbAvB0zA65Ufly5SywsOgP1caQwvq0AZuNgZqpATGumBqrPLuylktUlnDIvMFkG8vWYR5D2NSjiaFlSlw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;仔细看就看不下去:&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uUIibyNXbAvB0zA65Ufly5SywsOgP1caQv4LzW3QpWgdkswtocBtUiaBAkOToPltOoYcUQx3ibXOdjp6k5zNhKUiag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;从个别领域上说，不能一下看懂的东西可能会有价值。&lt;/p&gt;&lt;p&gt;这就是互联网黑话的最大特点，整体感觉高端大气，但是好像暗语一般非专业人士不能理解。&lt;/p&gt;&lt;p&gt;另一个特点就是，黑话集中在日报，周报，月报，PPT，各种总结上面，以及各种会议上面，像空气一样。&lt;/p&gt;&lt;p&gt;&lt;span&gt;02&lt;/span&gt;&lt;/p&gt;&lt;p&gt;曾几何时，因为周报过于简单明了，每个月都会被公司CEO点名批评。&lt;/p&gt;&lt;p&gt;每个开发的周报主流可能都是：需求评审、开发、提测上线。这对于开发而言就是实事求是，并且能说的明明白白。&lt;/p&gt;&lt;p&gt;但是在黑话型选手眼中，这就是没有用心，缺乏对业务理解和思考的表现。&lt;/p&gt;&lt;p&gt;后来的后来，被批多了心态就麻木，有时觉得自己可能是火星来的，和该系列选手三观冲突。&lt;/p&gt;&lt;p&gt;&lt;span&gt;03&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在互联网上，有意思的可不止黑话这一种现象，有些鬼才般的逻辑才是感人至深。&lt;/p&gt;&lt;p&gt;作为多年网民选手，你可能经常会听到如下的理论：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.44280442804428044&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uUIibyNXbAvB0zA65Ufly5SywsOgP1caQc2uh54mGibiaOAcYU3qweP8P6cwxNAbZxQS54BibFiaeLHmIo4LbKS2n4w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1084&quot;/&gt;&lt;/p&gt;&lt;p&gt;这样两极化的观念都跟着大批叫好的玩家，从根本上看就是在说两个人生态度：保守与激进。&lt;/p&gt;&lt;p&gt;就现实而论两种观念都没有错，虽然都不具备参考价值，但是很具有博流量的能力。&lt;/p&gt;&lt;p&gt;在风投领域里有句话：保守从短期看一定是对的，激进从长期去看一定会犯错。&lt;/p&gt;&lt;p&gt;所以不管是劝你保守，还是想教你如何激进，无非就是割流量与割付费的两种模式区别，而在两者之间最难走的路和选择依旧都要自己去摸爬滚打。&lt;/p&gt;&lt;p&gt;&lt;span&gt;04&lt;/span&gt;&lt;/p&gt;&lt;p&gt;互联网上最大的黑色幽默就是有关收入的话题：收入低的在叫苦连天，收入高的在凡尔赛文学。&lt;/p&gt;&lt;p&gt;热门视频常见，你觉得毕业五年，月收入多少合适：可能起码要3、5万吧？&lt;/p&gt;&lt;p&gt;媒体上常见收入高的，各种没时间吃喝玩乐在谈生意，然后要花费心血拍视频告诉广大网友，引来大批羡慕的和大批嘲讽的。&lt;/p&gt;&lt;p&gt;媒体上常见伴随着每年发布的平均收入，各路大神各种数据分析，平均工资很低月入过万很少，所以该吃吃该乐乐。&lt;/p&gt;&lt;p&gt;同样是两种观念平分秋色，但是角度依旧清奇，人的收入高低和自己所在的行业与城市有很大的关系。&lt;/p&gt;&lt;p&gt;尤其是在互联网行业中的选手，工作三五年之后，如果说感觉月入过万很少，我觉得你可能被生活欺骗了。&lt;/p&gt;&lt;p&gt;互联网行业工资普遍偏高，与这个行业普遍在一二线城市和付出有很大关系，996、大小周、持续学习。&lt;/p&gt;&lt;p&gt;不管是互联网或者媒体网红，这些人聚集在网上，成功带出了&quot;各种年薪百万、人在美国刚下飞机&quot;的氛围。&lt;/p&gt;&lt;p&gt;这些网络上的幽默观念并不具备什么实际参考价值，大部分的人都是在自己行业中不断挣扎努力，一步一脚印。&lt;/p&gt;&lt;p&gt;&lt;span&gt;05&lt;/span&gt;&lt;/p&gt;&lt;p&gt;当下信息时代，互联网上各种神奇理论齐飞，自律文、鸡汤文、毒奶文、佛系文、故事文，无不说的有理有据有声有色。&lt;/p&gt;&lt;p&gt;但是于自身而言，多数都是看了之后一笑了之，或者水深火热的跟风三分钟。&lt;/p&gt;&lt;p&gt;个人依旧认为互联网行业的选手，花时间不断提高自己的专业能力，拓宽认知边界才是最有价值的事情，偶尔看看媒体信息，了解世界之大无奇不有，也是生活一大乐趣。&lt;/p&gt;&lt;p&gt;作为一个将近10年的网民，现在关注最多的就是新闻频道，这里必须要强调一下我并不是老了。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;END&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4Njg0MzYwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBCuF3zfJnqPKpUia4wfn1FUtTHpxxkR5HvbicPgOjibPicX0goMOkny1NdkLAJvBaqrYh3UdwMjiaDQMA/0?wx_fmt=png&quot; data-nickname=&quot;知了一笑&quot; data-alias=&quot;cicada_smile&quot; data-signature=&quot;积累是一个孤独且枯燥的过程&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fa6c3a4edde806f7f1783ca0db07d978</guid>
<title>Redis 进阶笔记</title>
<link>https://toutiao.io/k/ti0gb8i</link>
<content:encoded>&lt;div&gt;&lt;div&gt;

                

                
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>adf7c4d257a3fa50308889a21a11e43d</guid>
<title>谈谈 Kubernetes 的问题和局限性</title>
<link>https://toutiao.io/k/0t3be9z</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;article-content&quot;&gt;&lt;p&gt;2014 年发布的 Kubernetes 在今天俨然已成为容器编排领域的事实标准，相信谈到 Kubernetes 的开发者都会一再复述上述现象。如下图所示，今天的大多数个人或者团队都会选择 Kubernetes 管理容器，而也有 75% 的人会在生产环境中使用 Kubernetes。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/kube-in-prod-2021-04-17-16186676828761.png&quot; alt=&quot;kube-in-prod&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 1 - Kubernetes 容器编排&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在这种全民学习和使用 Kubernetes 的大背景下，我们也应该非常清晰地知道 Kubernetes 有哪些局限性。虽然 Kubernetes 能够解决容器编排领域的大多数问题，但是仍然有一些场景是它很难处理、甚至无法处理的，只有对这些潜在的风险有清晰的认识，才能更好地驾驭这项技术，这篇文章将从集群管理和应用场景两个部分谈谈 Kubernetes 社区目前的发展和一些局限性。&lt;/p&gt;&lt;h2 id=&quot;集群管理&quot;&gt;集群管理&lt;/h2&gt;&lt;p&gt;集群是一组能够在一起协同工作的计算机，我们可以将集群中的所有计算机看成一个整体，所有资源调度系统都是以集群为维度进行管理的，集群中的所有机器构成了资源池，这个巨大的资源池会为待运行的容器提供资源执行计算任务，这里简单谈一谈 Kubernetes 集群管理面对的几个复杂问题。&lt;/p&gt;&lt;h3 id=&quot;水平扩展性&quot;&gt;水平扩展性&lt;/h3&gt;&lt;p&gt;集群大小是我们在评估资源管理系统时需要关注的重要指标之一，然而 Kubernetes 能够管理的集群规模远远小于业界的其他资源管理系统。集群大小为什么重要呢，我们先来看另一个同样重要的指标 — 资源利用率，很多工程师可能没有在公有云平台上申请过资源，这些资源都相当昂贵，在 AWS 上申请一个与主机差不多配置的虚拟机实例（8 CPU、16 GB）每个月大概需要 150 美金，约为 1000 人民币&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/aws-instance-pricing-2021-04-17-16186676828787.png&quot; alt=&quot;aws-instance-pricing&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 2 - AWS EC2 价格&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;大多数的集群都会使用 48 CPU 或者 64 CPU 的物理机或者虚拟机作为集群中的节点，如果我们的集群中需要包含 5,000 个节点，那么这些节点每个月大概要 8,000,000 美元，约为 50,000,000 人民币，在这样的集群中&lt;strong&gt;提升 1% 的资源利用率就相当于每个月节省了 500,000 的成本&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;多数在线任务的资源利用率都很低，更大的集群意味着能够运行更多的工作负载，而多种高峰和低谷期不同的负载部署在一起可以实现超售，这样能够显著地提高集群的资源利用率，如果单个集群的节点数足够多，我们在部署不同类型的任务时会有更合理的组合，可以完美错开不同服务的高峰期。&lt;/p&gt;&lt;p&gt;Kubernetes 社区对外宣传的是单个集群最多支持 5,000 节点，Pod 总数不超过 150,000，容器总数不超过 300,000 以及单节点 Pod 数量不超过 100 个&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;，与几万节点的 Apache Mesos 集群、50,000 节点的微软 YARN 集群&lt;sup id=&quot;fnref:4&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;相比，Kubernetes 的集群规模整整差了一个数量级。虽然阿里云的工程师也通过优化 Kubernetes 的各个组件实现了 5 位数的集群规模，但是与其他的资源管理方式相比却有比较大的差距&lt;sup id=&quot;fnref:5&quot;&gt;&lt;a href=&quot;#fn:5&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/Apache-Mesos-vs-Hadoop-YARN-2021-04-17-16186676828795.jpg&quot; alt=&quot;Apache-Mesos-vs-Hadoop-YARN&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 3 - Apache Mesos 与 Hadoop YARN&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;需要注意的是 Kubernetes 社区虽然对外宣称单集群可以支持 5,000 节点，同时社区也有各种各样的集成测试保证每个改动都不会影响它的伸缩性&lt;sup id=&quot;fnref:6&quot;&gt;&lt;a href=&quot;#fn:6&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;，但是 Kubernetes 真的非常复杂，我们没有办法保证你使用的每个功能在扩容的过程中都不出问题。而在生产环境中，我们甚至可能在集群扩容到 1000 ~ 1500 节点时遇到瓶颈。&lt;/p&gt;&lt;p&gt;每个稍具规模的大公司都想要实现更大规模的 Kubernetes 集群，但是这不是一个改几行代码就能解决的简单问题，它可能需要我们限制 Kubernetes 中一些功能的使用，在扩容的过程中，etcd、API 服务器、调度器以及控制器都有可能出现问题。社区中已经有一些开发者注意到了其中的一些问题，例如在节点上增加缓存降低 API 服务器的负载&lt;sup id=&quot;fnref:7&quot;&gt;&lt;a href=&quot;#fn:7&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;，但是要推动类似的改变还是很困难的，有志之士可以尝试在社区推动类似的项目。&lt;/p&gt;&lt;h3 id=&quot;多集群管理&quot;&gt;多集群管理&lt;/h3&gt;&lt;p&gt;单个集群的容量再大也无法解决企业面对的问题，哪怕有一天 Kubernetes 集群可以达到 50,000 节点的规模，我们仍然需要管理多个集群，多集群管理也是 Kubernetes 社区目前正在探索的方向，社区中的多集群兴趣小组（SIG Multi-Cluster）目前就在完成相关的工作&lt;sup id=&quot;fnref:8&quot;&gt;&lt;a href=&quot;#fn:8&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;8&lt;/a&gt;&lt;/sup&gt;。在作者看来，Kubernetes 的多集群会带来资源不平衡、跨集群访问困难以及提高运维和管理成本三大问题，我们在这里谈一谈目前在开源社区和业界几种可供参考和选择的解决方案。&lt;/p&gt;&lt;h4 id=&quot;kubefed&quot;&gt;kubefed&lt;/h4&gt;&lt;p&gt;首先要介绍的是 &lt;a href=&quot;https://github.com/kubernetes-sigs/kubefed&quot;&gt;kubefed&lt;/a&gt;，该项目是 Kubernetes 社区给出的解决方案，它同时提供了跨集群的资源和网络管理的功能，社区的多集群兴趣小组（SIG Multi-Cluster）负责了该项目的开发工作：&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/kubernetes-federation-2021-04-17-16186676828802.png&quot; alt=&quot;kubernetes-federation&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 4 - Kubernetes 联邦&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;kubefed 通过一个中心化的联邦控制面板管理多集群中的元数据，上层的控制面板会为管理器群中的资源创建对应的联邦对象，例如：&lt;code&gt;FederatedDeployment&lt;/code&gt;：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span&gt;kind&lt;/span&gt;: &lt;span&gt;FederatedDeployment&lt;/span&gt;
...
&lt;span&gt;spec&lt;/span&gt;:
  &lt;span&gt;...&lt;/span&gt;
  &lt;span&gt;overrides&lt;/span&gt;:
  &lt;span&gt;# Apply overrides to cluster1&lt;/span&gt;
    - &lt;span&gt;clusterName&lt;/span&gt;: &lt;span&gt;cluster1&lt;/span&gt;
      &lt;span&gt;clusterOverrides&lt;/span&gt;:
        &lt;span&gt;# Set the replicas field to 5&lt;/span&gt;
        - &lt;span&gt;path&lt;/span&gt;: &lt;span&gt;&quot;/spec/replicas&quot;&lt;/span&gt;
          &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;5&lt;/span&gt;
        &lt;span&gt;# Set the image of the first container&lt;/span&gt;
        - &lt;span&gt;path&lt;/span&gt;: &lt;span&gt;&quot;/spec/template/spec/containers/0/image&quot;&lt;/span&gt;
          &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&quot;nginx:1.17.0-alpine&quot;&lt;/span&gt;
        &lt;span&gt;# Ensure the annotation &quot;foo: bar&quot; exists&lt;/span&gt;
        - &lt;span&gt;path&lt;/span&gt;: &lt;span&gt;&quot;/metadata/annotations&quot;&lt;/span&gt;
          &lt;span&gt;op&lt;/span&gt;: &lt;span&gt;&quot;add&quot;&lt;/span&gt;
          &lt;span&gt;value&lt;/span&gt;:
            &lt;span&gt;foo&lt;/span&gt;: &lt;span&gt;bar&lt;/span&gt;
        &lt;span&gt;# Ensure an annotation with key &quot;foo&quot; does not exist&lt;/span&gt;
        - &lt;span&gt;path&lt;/span&gt;: &lt;span&gt;&quot;/metadata/annotations/foo&quot;&lt;/span&gt;
          &lt;span&gt;op&lt;/span&gt;: &lt;span&gt;&quot;remove&quot;&lt;/span&gt;
        &lt;span&gt;# Adds an argument `-q` at index 0 of the args list&lt;/span&gt;
        &lt;span&gt;# this will obviously shift the existing arguments, if any&lt;/span&gt;
        - &lt;span&gt;path&lt;/span&gt;: &lt;span&gt;&quot;/spec/template/spec/containers/0/args/0&quot;&lt;/span&gt;
          &lt;span&gt;op&lt;/span&gt;: &lt;span&gt;&quot;add&quot;&lt;/span&gt;
          &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&quot;-q&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上层的控制面板会根据联邦对象 &lt;code&gt;FederatedDeployment&lt;/code&gt; 的规格文件生成对应的 &lt;code&gt;Deployment&lt;/code&gt; 并推送到下层的集群，下层集群可以正常根据 &lt;code&gt;Deployment&lt;/code&gt; 中的定义创建特定数量的副本。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/kubernetes-federated-resources-2021-04-17-16186676828808.png&quot; alt=&quot;kubernetes-federated-resources&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 5 - 从联邦对象到普通对象&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;FederatedDeployment&lt;/code&gt; 只是一种最简单的分发策略，在生产环境中我们希望通过联邦的集群实现容灾等复杂功能，这时可以利用 &lt;code&gt;ReplicaSchedulingPreference&lt;/code&gt; 在不同集群中实现更加智能的分发策略：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span&gt;apiVersion&lt;/span&gt;: &lt;span&gt;scheduling.kubefed.io/v1alpha1&lt;/span&gt;
&lt;span&gt;kind&lt;/span&gt;: &lt;span&gt;ReplicaSchedulingPreference&lt;/span&gt;
&lt;span&gt;metadata&lt;/span&gt;:
  &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;test-deployment&lt;/span&gt;
  &lt;span&gt;namespace&lt;/span&gt;: &lt;span&gt;test-ns&lt;/span&gt;
&lt;span&gt;spec&lt;/span&gt;:
  &lt;span&gt;targetKind&lt;/span&gt;: &lt;span&gt;FederatedDeployment&lt;/span&gt;
  &lt;span&gt;totalReplicas&lt;/span&gt;: &lt;span&gt;9&lt;/span&gt;
  &lt;span&gt;clusters&lt;/span&gt;:
    &lt;span&gt;A&lt;/span&gt;:
      &lt;span&gt;minReplicas&lt;/span&gt;: &lt;span&gt;4&lt;/span&gt;
      &lt;span&gt;maxReplicas&lt;/span&gt;: &lt;span&gt;6&lt;/span&gt;
      &lt;span&gt;weight&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;
    &lt;span&gt;B&lt;/span&gt;:
      &lt;span&gt;minReplicas&lt;/span&gt;: &lt;span&gt;4&lt;/span&gt;
      &lt;span&gt;maxReplicas&lt;/span&gt;: &lt;span&gt;8&lt;/span&gt;
      &lt;span&gt;weight&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述调度的策略可以实现工作负载在不同集群之间的权重，在集群资源不足甚至出现问题时将实例迁移到其他集群，这样既能够提高服务部署的灵活性和可用性，基础架构工程师也可以更好地平衡多个集群的负载。&lt;/p&gt;&lt;p&gt;我们可以认为 kubefed 的主要作用是将多个松散的集群组成强耦合的联邦集群，并提供更加高级的网络和部署功能，这样我们可以更容易地解决集群之间资源不平衡和连通性的一些问题，然而该项目的关注点不包含集群生命周期的管理，&lt;/p&gt;&lt;h4 id=&quot;集群接口&quot;&gt;集群接口&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://cluster-api.sigs.k8s.io/&quot;&gt;Cluster API&lt;/a&gt; 也是 Kubernetes 社区中与多集群管理相关的项目，该项目由集群生命周期小组（SIG Cluster-Lifecycle）负责开发，其主要目标是通过声明式的 API 简化多集群的准备、更新和运维工作，你在该项目的 &lt;a href=&quot;https://github.com/kubernetes-sigs/cluster-api/blob/master/docs/scope-and-objectives.md&quot;&gt;设计提案&lt;/a&gt; 中能够找到它的职责范围&lt;sup id=&quot;fnref:9&quot;&gt;&lt;a href=&quot;#fn:9&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;9&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/k8s-cluster-api-concepts-2021-04-17-16186676828819.png&quot; alt=&quot;k8s-cluster-api-concepts&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 6 - Cluster API 概念&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在该项目中最重要的资源就是 &lt;code&gt;Machine&lt;/code&gt;，它表示一个 Kubernetes 集群中的节点。当该资源被创建时，特定提供商的控制器会根据机器的定义初始化并将新的节点注册到集群中，在该资源被更新或者删除时，也会执行操作达到用户的状态。&lt;/p&gt;&lt;p&gt;这种策略与阿里的多集群管理的方式有一些相似，它们都使用声明式的 API 定义机器和集群的状态，然后使用 Kubernetes 原生的 Operator 模型在更高一层的集群中管理下层集群，这能够极大降低集群的运维成本并提高集群的运行效率&lt;sup id=&quot;fnref:10&quot;&gt;&lt;a href=&quot;#fn:10&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;10&lt;/a&gt;&lt;/sup&gt;，不过类似的项目都没有考虑跨集群的资源管理和网络管理。&lt;/p&gt;&lt;h2 id=&quot;应用场景&quot;&gt;应用场景&lt;/h2&gt;&lt;p&gt;我们在这一节将谈谈 Kubernetes 中一些有趣的应用场景，其中包括应用分发方式的现状、批处理调度任务以及硬多租户在集群中的支持，这些是社区中比较关注的问题，也是 Kubernetes 目前的盲点。&lt;/p&gt;&lt;h3 id=&quot;应用分发&quot;&gt;应用分发&lt;/h3&gt;&lt;p&gt;Kubernetes 主项目提供了几种部署应用的最基本方式，分别是 &lt;code&gt;Deployment&lt;/code&gt;、&lt;code&gt;StatefulSet&lt;/code&gt; 和 &lt;code&gt;DaemonSet&lt;/code&gt;，这些资源分别适用于无状态服务、有状态服务和节点上的守护进程，这些资源能够提供最基本的策略，但是它们无法处理更加复杂的应用。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/kubernetes-basic-resources-2021-04-17-16186676828825.png&quot; alt=&quot;kubernetes-basic-resources&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 7 - Kubernetes 应用管理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;随着 CRD 的引入，目前社区的应用管理小组（SIG Apps）基本不会向 Kubernetes 主仓库引入较大的改动，大多数的改动都是在现有资源上进行的修补，很多常见的场景，例如只运行一次的 DaemonSet&lt;sup id=&quot;fnref:11&quot;&gt;&lt;a href=&quot;#fn:11&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;11&lt;/a&gt;&lt;/sup&gt; 以及金丝雀和蓝绿部署等功能，现在的资源也存在很多问题，例如 StatefulSet 在初始化容器中卡住无法回滚和更新&lt;sup id=&quot;fnref:12&quot;&gt;&lt;a href=&quot;#fn:12&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;12&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;&lt;p&gt;我们可以理解社区不想在 Kubernetes 中维护更多的基本资源，通过几个基本的资源可以覆盖 90% 的场景，剩下的各种复杂场景可以让其他社区通过 CRD 的方式实现。不过作者认为如果社区能够在上游实现更多高质量的组件，这对于整个生态都是很有价值并且很重要的工作，需要注意的是假如各位读者想要在 Kubernetes 项目中成为贡献者，SIG Apps 可能不是一个很好的选择。&lt;/p&gt;&lt;h3 id=&quot;批处理调度&quot;&gt;批处理调度&lt;/h3&gt;&lt;p&gt;机器学习、批处理任务和流式任务等工作负载的运行从 Kubernetes 诞生第一天起到今天都不是它的强项，大多数的公司都会使用 Kubernetes 运行在线服务处理用户请求，用 Yarn 管理的集群运行批处理的负载。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/hadoop-yarn-2021-04-17-16186676828831.png&quot; alt=&quot;hadoop-yarn&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 8 - Hadoop Yarn&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在线任务和离线任务往往是两种截然不同的作业，大多数的在线任务都是无状态的服务，它们可以在不同机器上进行迁移，彼此很难有极强的依赖关系；但是很多离线任务的拓扑结构都很复杂，有些任务需要多个作业一同执行，而有些任务需要按照依赖关系先后执行，这种复杂的调度场景在 Kubernetes 中比较难以处理。&lt;/p&gt;&lt;p&gt;在 Kubernetes 调度器引入调度框架之前，所有的 Pod 在调度器看来是没有任何关联的，不过有了调度框架，我们可以在调度系统中实现更加复杂的调度策略，例如保证一组 Pod 同时调度的 PodGroup&lt;sup id=&quot;fnref:13&quot;&gt;&lt;a href=&quot;#fn:13&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;13&lt;/a&gt;&lt;/sup&gt;，这对于 Spark 和 TensorFlow 任务非常有用。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span&gt;# PodGroup CRD spec&lt;/span&gt;
&lt;span&gt;apiVersion&lt;/span&gt;: &lt;span&gt;scheduling.sigs.k8s.io/v1alpha1&lt;/span&gt;
&lt;span&gt;kind&lt;/span&gt;: &lt;span&gt;PodGroup&lt;/span&gt;
&lt;span&gt;metadata&lt;/span&gt;:
  &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;nginx&lt;/span&gt;
&lt;span&gt;spec&lt;/span&gt;:
  &lt;span&gt;scheduleTimeoutSeconds&lt;/span&gt;: &lt;span&gt;10&lt;/span&gt;
  &lt;span&gt;minMember&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;
---
&lt;span&gt;# Add a label `pod-group.scheduling.sigs.k8s.io` to mark the pod belongs to a group&lt;/span&gt;
&lt;span&gt;labels&lt;/span&gt;:
  &lt;span&gt;pod-group.scheduling.sigs.k8s.io&lt;/span&gt;: &lt;span&gt;nginx&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Volcano 也是在 Kubernetes 上构建的批处理任务管理系统&lt;sup id=&quot;fnref:14&quot;&gt;&lt;a href=&quot;#fn:14&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;14&lt;/a&gt;&lt;/sup&gt;，它能够处理机器学习、深度学习以及其他大数据应用，可以支持包括 TensorFlow、Spark、PyTorch 和 MPI 在内的多个框架。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/volcano-logo-2021-04-17-16186676828837.png&quot; alt=&quot;volcano-logo&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 9 - Volcano&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;虽然 Kubernetes 能够运行一些批处理任务，但是距离在这个领域上取代 Yarn 等老牌资源管理系统上还有非常大的差距，相信在较长的一段时间内，大多数公司都会同时维护 Kubernetes 和 Yarn 两种技术栈，分别管理和运行不同类型的工作负载。&lt;/p&gt;&lt;h3 id=&quot;硬多租户&quot;&gt;硬多租户&lt;/h3&gt;&lt;p&gt;多租户是指同一个软件实例可以为不同的用户组提供服务，Kubernetes 的多租户是指多个用户或者用户组使用同一个 Kubernetes 集群，今天的 Kubernetes 还很难做到硬多租户支持，也就是同一个集群的多个租户不会相互影响，也感知不到彼此的存在。&lt;/p&gt;&lt;p&gt;硬多租户在 Kubernetes 中是一个很重要、也很困难的课题，合租公寓就是一个典型的多租户场景，多个租客共享房屋内的基础设施，硬多租户要求多个访客之间不会相互影响，你可以想象这有多么困难，Kubernetes 社区甚至有一个工作小组专门讨论和研究相关的问题&lt;sup id=&quot;fnref:15&quot;&gt;&lt;a href=&quot;#fn:15&quot; class=&quot;footnote-ref&quot; role=&quot;doc-noteref&quot;&gt;15&lt;/a&gt;&lt;/sup&gt;，然而虽然感兴趣的工程师很多，但是成果却非常有限。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.draveness.me/multi-tenant-2021-04-17-16186676828844.jpg&quot; alt=&quot;multi-tenant&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;图 10 - 多租户&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;尽管 Kubernetes 使用命名空间来划分虚拟机群，然而这也很难实现真正的多租户。多租户的支持到底有哪些作用呢，这里简单列几个多租户带来的好处：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Kubernetes 带来的额外部署成本对于小集群来说非常高昂，稳定的 Kubernetes 集群一般都需要至少三个运行 etcd 的主节点，如果大多数的集群都是小集群，这些额外的机器会带来很高的额外开销；&lt;/li&gt;&lt;li&gt;Kubernetes 中运行的容器可能需要共享物理机和虚拟机，一些开发者可能在公司内部遇到过自己的服务被其他业务影响，因为主机上容器可能隔离了 CPU 和内存资源，但是没有隔离 I/O、网络 和 CPU 缓存等资源，这些资源的隔离是相对困难的；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果 Kubernetes 能够实现硬多租户，这不仅对云服务商和小集群的使用者来说都是个福音，它还能够隔离不同容器之间的影响并防止潜在安全问题的发生，不过这在现阶段还是比较难实现的。&lt;/p&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;&lt;p&gt;每个技术都有自己的生命周期，越底层的技术生命周期会越长，而越上层的技术生命周期也就越短，虽然 Kubernetes 是当今容器界的扛把子，但是未来的事情没有人可以说的准。我们要时刻清楚手中工具的优点和缺点，花一些时间学习 Kubernetes 中设计的精髓，不过如果在未来的某一天 Kubernetes 也成为了过去，我们也应该感到喜悦，因为会有更好的工具取代它。&lt;/p&gt;&lt;section class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Kubernetes and Container Security and Adoption Trends &lt;a href=&quot;https://www.stackrox.com/kubernetes-adoption-security-and-market-share-for-containers/&quot;&gt;https://www.stackrox.com/kubernetes-adoption-security-and-market-share-for-containers/&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;AWS Pricing Calculator &lt;a href=&quot;https://calculator.aws/#/createCalculator/EC2&quot;&gt;https://calculator.aws/#/createCalculator/EC2&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Considerations for large clusters &lt;a href=&quot;https://kubernetes.io/docs/setup/best-practices/cluster-large/&quot;&gt;https://kubernetes.io/docs/setup/best-practices/cluster-large/&lt;/a&gt; &lt;a href=&quot;#fnref:3&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:4&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;How Microsoft drives exabyte analytics on the world’s largest YARN cluster &lt;a href=&quot;https://azure.microsoft.com/en-us/blog/how-microsoft-drives-exabyte-analytics-on-the-world-s-largest-yarn-cluster/&quot;&gt;https://azure.microsoft.com/en-us/blog/how-microsoft-drives-exabyte-analytics-on-the-world-s-largest-yarn-cluster/&lt;/a&gt; &lt;a href=&quot;#fnref:4&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:5&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;备战双 11！蚂蚁金服万级规模 K8s 集群管理系统如何设计？ &lt;a href=&quot;https://www.sofastack.tech/blog/ant-financial-managing-large-scale-kubernetes-clusters/&quot;&gt;https://www.sofastack.tech/blog/ant-financial-managing-large-scale-kubernetes-clusters/&lt;/a&gt; &lt;a href=&quot;#fnref:5&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:6&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;sig-scalability-kubemark dashboard &lt;a href=&quot;https://testgrid.k8s.io/sig-scalability-kubemark#kubemark-5000&quot;&gt;https://testgrid.k8s.io/sig-scalability-kubemark#kubemark-5000&lt;/a&gt; &lt;a href=&quot;#fnref:6&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:7&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Node-local API cache #84248 &lt;a href=&quot;https://github.com/kubernetes/kubernetes/issues/84248&quot;&gt;https://github.com/kubernetes/kubernetes/issues/84248&lt;/a&gt; &lt;a href=&quot;#fnref:7&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:8&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Multicluster Special Interest Group &lt;a href=&quot;https://github.com/kubernetes/community/tree/master/sig-multicluster&quot;&gt;https://github.com/kubernetes/community/tree/master/sig-multicluster&lt;/a&gt; &lt;a href=&quot;#fnref:8&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:9&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Cluster API Scope and Objectives &lt;a href=&quot;https://github.com/kubernetes-sigs/cluster-api/blob/master/docs/scope-and-objectives.md&quot;&gt;https://github.com/kubernetes-sigs/cluster-api/blob/master/docs/scope-and-objectives.md&lt;/a&gt; &lt;a href=&quot;#fnref:9&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:10&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Demystifying Kubernetes as a service – How Alibaba cloud manages 10,000s of Kubernetes clusters &lt;a href=&quot;https://www.cncf.io/blog/2019/12/12/demystifying-kubernetes-as-a-service-how-does-alibaba-cloud-manage-10000s-of-kubernetes-clusters/&quot;&gt;https://www.cncf.io/blog/2019/12/12/demystifying-kubernetes-as-a-service-how-does-alibaba-cloud-manage-10000s-of-kubernetes-clusters/&lt;/a&gt; &lt;a href=&quot;#fnref:10&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:11&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Run job on each node once to help with setup #64623 &lt;a href=&quot;https://github.com/kubernetes/kubernetes/issues/64623&quot;&gt;https://github.com/kubernetes/kubernetes/issues/64623&lt;/a&gt; &lt;a href=&quot;#fnref:11&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:12&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;StatefulSet does not upgrade to a newer version of manifests #78007 &lt;a href=&quot;https://github.com/kubernetes/kubernetes/issues/78007&quot;&gt;https://github.com/kubernetes/kubernetes/issues/78007&lt;/a&gt; &lt;a href=&quot;#fnref:12&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:13&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Coscheduling based on PodGroup CRD &lt;a href=&quot;https://github.com/kubernetes-sigs/scheduler-plugins/tree/master/kep/42-podgroup-coscheduling&quot;&gt;https://github.com/kubernetes-sigs/scheduler-plugins/tree/master/kep/42-podgroup-coscheduling&lt;/a&gt; &lt;a href=&quot;#fnref:13&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:14&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Volcano · A Kubernetes Native Batch System &lt;a href=&quot;https://github.com/volcano-sh/volcano&quot;&gt;https://github.com/volcano-sh/volcano&lt;/a&gt; &lt;a href=&quot;#fnref:14&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li id=&quot;fn:15&quot; role=&quot;doc-endnote&quot;&gt;&lt;p&gt;Kubernetes Working Group for Multi-Tenancy &lt;a href=&quot;https://github.com/kubernetes-sigs/multi-tenancy&quot;&gt;https://github.com/kubernetes-sigs/multi-tenancy&lt;/a&gt; &lt;a href=&quot;#fnref:15&quot; class=&quot;footnote-backref&quot; role=&quot;doc-backlink&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;img src=&quot;https://img.draveness.me/2020-03-11-15839264230785-wechat-qr-code.png&quot; alt=&quot;wechat-account-qrcode&quot;/&gt;&lt;h3&gt;转载申请&lt;/h3&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by/4.0/&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; src=&quot;https://img.draveness.me/creative-commons.png&quot;/&gt;&lt;/a&gt;&lt;p&gt;本作品采用&lt;/p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by/4.0/&quot;&gt;知识共享署名 4.0 国际许可协议&lt;/a&gt;&lt;p&gt;进行许可，转载时请注明原文链接，图片在使用时请保留全部内容，可适当缩放并在引用处附上图片所在的文章链接。&lt;/p&gt;&lt;h3&gt;文章图片&lt;/h3&gt;&lt;p&gt;你可以在 &lt;/p&gt;&lt;a href=&quot;/sketch-and-sketch&quot;&gt;技术文章配图指南&lt;/a&gt;&lt;p&gt; 中找到画图的方法和素材。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ea6598dcc700d7dc469775b46e34d09f</guid>
<title>面试必备常见存储引擎与锁的分类，请查收</title>
<link>https://toutiao.io/k/lyccgvn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;181&quot; data-backw=&quot;558&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.32344763670064874&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpOjRJj3rEmVIcZ4cxnPGXMbOToA3HQiafTrfmjfvOVQH0fLtCJwj3DkfC1GoPIRVmLY5oTemAhXibRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1079&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在上篇文章中提到了记录锁（行锁）、间隙锁和临键锁，后台有小伙伴催我更新一下其他的锁。拖延症又犯了，趁周末，今天我们来总结一下&lt;code&gt;MyISAM&lt;/code&gt;和&lt;code&gt;InnoDB&lt;/code&gt;引擎下锁的种类及使用方法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;MySQL的四大常见存储引擎&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;谈到&lt;code&gt;MyISAM&lt;/code&gt;和&lt;code&gt;InnoDB&lt;/code&gt;了我们先来了解一下什么是存储引擎吧。&lt;code&gt;MySQL&lt;/code&gt;中的数据用各种不同的技术存储在文件（或者内存）中，这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能，我们把这些不同的技术以及配套的相关功能称为存储引擎(也称作表类型)。MySQL默认配置了许多不同的存储引擎，我们可以选择不同的存储引擎来满足我们对数据的处理（存储、检索等）需求，以改善我们应用程序的整体功能。正因为&lt;code&gt;MySQL&lt;/code&gt;存储引擎的多样性，使得&lt;code&gt;MySQL&lt;/code&gt;深受广大开发者的垂青。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的前提条件：我用的是&lt;code&gt;5.7.24-log&lt;/code&gt;版本，可以在&lt;code&gt;Navicat&lt;/code&gt;中通过&lt;code&gt;SELECT VERSION();&lt;/code&gt;命令查看。那么&lt;code&gt;MySQL&lt;/code&gt;都有哪些存储引擎呢？我们可以使用sql命令&lt;code&gt;SHOW ENGINES;&lt;/code&gt;来查看，结果如下：&lt;img data-ratio=&quot;0.2515391380826737&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpMrMeosQsorL6KXxxpXtctC7OFj2BPStbGYKLVFM7PoE19Ttrp6t7AJpWZf6jkgBUwbGAZKwUCdmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1137&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Engine：表示储存引擎名称；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Support：表示&lt;code&gt;MySQL&lt;/code&gt;是否支持该存储引擎，&lt;code&gt;DEFAULT&lt;/code&gt;为默认的存储引擎；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Comment：是对该存储引擎的功能描述，例如：&lt;code&gt;InnoDB&lt;/code&gt;支持事务、行级锁定和外键；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Transactions：是否支持事务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;XA：存储引擎是否支持分布式事务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Savepoints：存储引擎是否支持保存点。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着让我们来说一下其中比较常见的四大存储引擎吧。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;InnoDB&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;InnoDB&lt;/code&gt;是&lt;code&gt;MySQL&lt;/code&gt;（&lt;code&gt;MySQL5.5&lt;/code&gt;以后）的默认存储引擎，支持事务、行级锁和外键，被用来处理大量短期事务。如果使用到外键、需求并发程度较高、数据一致性要求较高的话，那么通常选择&lt;code&gt;InnoDB&lt;/code&gt;引擎，这也是互联网大厂使用&lt;code&gt;InnoDB&lt;/code&gt;存储引擎的原因。除非有非常特别的原因需要使用其他的存储引擎，否则建议优先考虑&lt;code&gt;InnoDB&lt;/code&gt;。但是对比&lt;code&gt;MyISAM&lt;/code&gt;，&lt;code&gt;InnoDB&lt;/code&gt;写的处理效率会差一些，并且会占用更多的磁盘空间以保留数据和索引。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;MyISAM&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;MyISAM&lt;/code&gt;提供了大量的特性，包含全文索引、压缩、空间行数等，支持3种不同的存储格式，分别是：静态表、动态表、压缩表。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;静态表：表中的字段都是非变长字段，这样每个记录都是固定长度的。优点是存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多（因为存储时会按照列的宽度定义补足空格），在取数据的时候，默认会把字段后面的空格去掉，如果不注意会把数据本身带的空格也会忽略。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;动态表：表中的字段都是变长字段，记录不是固定长度的。这样存储的优点是占用的空间相对较少；缺点是频繁的更新、删除数据容易产生碎片，需要定期执行&lt;code&gt;OPTIMIZE TABLE&lt;/code&gt;或者&lt;code&gt;myisamchk -r&lt;/code&gt;命令来改善性能，并且出现故障的时候恢复相对比较困难。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;压缩表：压缩表由myisamchk工具创建，占据非常小的空间，因为每条记录都是被单独压缩的，所以只有非常小的访问开支。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;MyISAM&lt;/code&gt;中，数据文件和索引文件可以放置在不同的目录（在创建表的时候通过&lt;code&gt;DATA DIRECTORY&lt;/code&gt;和&lt;code&gt;INDEX DIRECTORY&lt;/code&gt;语句指定文件的绝对路径），平均分配IO，获取更快的访问速度。但是&lt;code&gt;MyISAM&lt;/code&gt;不支持事务，不支持外键，也不支持行级锁，支持表级锁，有个缺陷就是崩溃后无法恢复。如果应用程序以检索为主，只有少量的插入、更新和删除操作，并且对事物的完整性、并发程度不是很高的话，通常建议选择&lt;code&gt;MyISAM&lt;/code&gt;存储引擎。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Memory&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Memory&lt;/code&gt;存储引擎使用存在内存中的内容来创建表，所以它的访问速度非常快，并且默认使用&lt;code&gt;HASH&lt;/code&gt;索引。但是一旦服务器关闭或者&lt;code&gt;mysqld&lt;/code&gt;守护进程崩溃时，所有的&lt;code&gt;Memory&lt;/code&gt;数据都会丢失，但表还会继续存在，获得速度的同时也带来了一些缺陷。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它要求存储在&lt;code&gt;Memory&lt;/code&gt;数据表里的数据使用的是长度不变的格式，这意味着不能使用&lt;code&gt;BLOB&lt;/code&gt;和&lt;code&gt;TEXT&lt;/code&gt;这样的长度可变的数据类型，&lt;code&gt;VARCHAR&lt;/code&gt;是一种长度可变的类型，但因为它在&lt;code&gt;MySQL&lt;/code&gt;内部当做长度固定不变的&lt;code&gt;CHAR&lt;/code&gt;类型，所以可以使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务器需要足够的内存来维持在同一时间内使用的&lt;code&gt;MEMORY&lt;/code&gt;表，当不再使用&lt;code&gt;MEMORY&lt;/code&gt;表时，要释放&lt;code&gt;MEMORY&lt;/code&gt;表所占用的内存，应该执行&lt;code&gt;DELETE FROM&lt;/code&gt;或&lt;code&gt;truncate table&lt;/code&gt;或者删除整个表。每个&lt;code&gt;MEMORY&lt;/code&gt;表中放置的数据量的大小，受到&lt;code&gt;max_heap_table_size&lt;/code&gt;系统变量的约束，这个系统变量的初始值是16M，同时在创建&lt;code&gt;MEMORY&lt;/code&gt;表时可以使用&lt;code&gt;MAX_ROWS&lt;/code&gt;子句来指定表中的最大行数。它通常用于更新不太频繁的小表。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Merge&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Merge&lt;/code&gt;存储引擎是一组&lt;code&gt;MyISAM&lt;/code&gt;表的组合，这些&lt;code&gt;MyISAM&lt;/code&gt;表结构必须完全相同，&lt;code&gt;Merge&lt;/code&gt;表本身没有数据，对&lt;code&gt;Merge&lt;/code&gt;类型的表进行查询、更新、删除的操作，实际上是对内部的&lt;code&gt;MyISAM&lt;/code&gt;表进行的。Merge表在磁盘上保留两个文件，一个是&lt;code&gt;.frm&lt;/code&gt;文件存储表定义、一个是&lt;code&gt;.MRG&lt;/code&gt;文件存储&lt;code&gt;Merge&lt;/code&gt;表的组成等。&lt;code&gt;MERGE&lt;/code&gt;表的优点在于可以突破对单个&lt;code&gt;MyISAM&lt;/code&gt;表大小的限制，并且通过将不同的表分布在多个磁盘上，可以有效地改善&lt;code&gt;MERGE&lt;/code&gt;表的访问效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过&lt;code&gt;show create table 表名&lt;/code&gt; 命令来查看表使用的引擎，由以下代码可以看出&lt;code&gt;test&lt;/code&gt;表使用的是&lt;code&gt;MyISAM&lt;/code&gt;存储引擎。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CREATE TABLE `test` (&lt;br/&gt;  `id` int(1) NOT NULL AUTO_INCREMENT,&lt;br/&gt;  `name` varchar(8) DEFAULT NULL,&lt;br/&gt;  `age` int(11) DEFAULT NULL,&lt;br/&gt;  PRIMARY KEY (`id`)&lt;br/&gt;) ENGINE=MyISAM AUTO_INCREMENT=46 DEFAULT CHARSET=utf8&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对其他数据库而言，&lt;code&gt;MySQL&lt;/code&gt;的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。比如，&lt;code&gt;MyISAM&lt;/code&gt;和&lt;code&gt;MEMORY&lt;/code&gt;存储引擎采用的是表级锁（&lt;code&gt;table-level locking&lt;/code&gt;）；&lt;code&gt;BDB&lt;/code&gt;存储引擎（5.1之后就不直接支持了，因为&lt;code&gt;BDB&lt;/code&gt;被&lt;code&gt;oracle&lt;/code&gt;收购了）采用的是页面锁（&lt;code&gt;page-level locking&lt;/code&gt;），但也支持表级锁；&lt;code&gt;InnoDB&lt;/code&gt;存储引擎既支持行级锁（&lt;code&gt;row-level locking&lt;/code&gt;），也支持表级锁，但默认情况下是采用行级锁。接下来就让我们来了解一下&lt;code&gt;MyISAM&lt;/code&gt;和&lt;code&gt;InnoDB&lt;/code&gt;锁的具体分类与使用方法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;MyISAM锁&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;MyISAM&lt;/code&gt;存储引擎支持的表级锁分为表共享读锁（&lt;code&gt;Table Read Lock&lt;/code&gt;）和表独占写锁（&lt;code&gt;Table Write Lock&lt;/code&gt;），以下简称读锁和写锁。先看一下他们的特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;读锁：不会阻碍其它进程的读，但是会阻碍写，只有当读锁释放之后，才会执行其它进程的写--读锁阻塞写锁，但是不阻塞读锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写锁：会阻碍其他进程的读和写，只有当写锁释放，才会执行其它写操作--写锁阻塞读锁和写锁；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来让我们用例子来演示一下上边的结论，在演示之前，先让我们来说几个命令吧。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LOCK TABLE 表名 WRITE/READ：给表加写锁或者读锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;UNLOCK TABLES：给表解锁&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;演示一：表共享读锁&lt;/strong&gt;&lt;img data-ratio=&quot;0.3485436893203884&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpMrMeosQsorL6KXxxpXtctCzknCxmPF6KJEhk29zHWOAlibiaL8bggvg8lMkribxibGLVHt2Km53byCTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1030&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当&lt;code&gt;session1&lt;/code&gt;给表&lt;code&gt;test&lt;/code&gt;加读锁时，&lt;code&gt;session1&lt;/code&gt;只能读取当前表的数据，不可以读其他表，也不可以修改&lt;code&gt;test&lt;/code&gt;和其他表；&lt;code&gt;session2&lt;/code&gt;可以读取&lt;code&gt;test&lt;/code&gt;表数据，更新&lt;code&gt;test&lt;/code&gt;表阻塞，但是可以修改和查询其他表数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;演示二：表独占写锁&lt;/strong&gt;&lt;img data-ratio=&quot;0.30288461538461536&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpMrMeosQsorL6KXxxpXtctC9ic8A5DHUur0UWvG80EqSMgYibpH9jOq5pmhVjdE9ibh9GOWPYsKCmvKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1040&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当&lt;code&gt;session1&lt;/code&gt;给表&lt;code&gt;test&lt;/code&gt;加写锁时，可以更新&lt;code&gt;test&lt;/code&gt;表，读&lt;code&gt;test&lt;/code&gt;表阻塞，但是不可以修改和查询其他表数据；&lt;code&gt;session2&lt;/code&gt;查询和更新&lt;code&gt;test&lt;/code&gt;表阻塞，但是可以查询和更新其他表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外我们还可以使用&lt;code&gt;show open tables&lt;/code&gt;命令来查看在表缓存中当前被打开的非TEMPORARY表的锁使用情况，其中In_use表示有锁正在使用。&lt;img data-ratio=&quot;0.5845410628019324&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpMrMeosQsorL6KXxxpXtctCDs8QQxFZyPicjKgibvRd2XZKvd8S5LF0iappHKTjEu6CKGHlr0Pm96eJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;621&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以使用&lt;code&gt;show status like &#x27;table%&#x27;&lt;/code&gt;命令来查看锁的争夺情况，其中&lt;code&gt;Table_locks_waited&lt;/code&gt;为等待次数，每等待一次，值就加一，值越大，表示存在越严重的表级锁争用；&lt;code&gt;Table_locks_immediate&lt;/code&gt;为产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁，值加一。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;★&lt;/span&gt;&lt;p&gt;&lt;code&gt;MyISAM&lt;/code&gt;默认是使用&lt;code&gt;select&lt;/code&gt;语句加读锁，增删改操作加写锁。&lt;code&gt;MyISAM&lt;/code&gt;是偏读锁，读写调度写优先，不适合做写为主的表的引擎。因为写锁后，其他线程不能做任何操作，大量更新会使查询很难得到锁，从而永远阻塞。&lt;/p&gt;&lt;span&gt;”&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;InnoDB锁&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上篇文章中我们讲过了记录锁（行锁）、间隙锁和临键锁，这里就不再赘述了。接下来我们按照锁的模式讲一下&lt;code&gt;InnoDB&lt;/code&gt;里的共享锁、排他锁和意向锁，其中共享锁和排他锁属于行级锁，行级锁都是基于索引项的，如果没有索引项，则添加的是表级锁；意向锁属于表级锁。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;共享锁：Shared Locks，简称S锁&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若事务T对数据对象A加上S锁，则事务T只能读A；其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。可以通过&lt;code&gt;select ... lock in share mode&lt;/code&gt;来加共享锁，通过&lt;code&gt;Commit&lt;/code&gt;、&lt;code&gt;Rollback&lt;/code&gt;来释放锁。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;排他锁：Exclusive lock，简称X锁，也叫互斥锁&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁（排他锁不可与其他锁共存），直到T释放A上的锁。它防止任何其它事务获取资源上的锁，直到在事务的末尾将资源上的原始锁释放为止。可以通过&lt;code&gt;select ... for update&lt;/code&gt;手动加锁，也可以通过增删改操作自动加锁，通过&lt;code&gt;Commit&lt;/code&gt;、&lt;code&gt;Rollback&lt;/code&gt;来释放锁。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;意向锁：Intention Locks&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说起意向锁，大家先来考虑一下这个问题：假设存在两个事务A和B对表&lt;code&gt;test&lt;/code&gt;进行操作，首先事务A对第十行数据加了一把读锁，锁住了该行数据，让这一行只能读，不能写；然后事务B想要对该表加一把表级的写锁，那么事务B能否加锁成功呢？思考两秒钟...答案当然是否定的，即事务B无法加锁成功。如果我们假设它加锁成功的话，那么理论上它就能修改表中的任意一行，这将与事务A持有的行级锁（读锁）产生冲突。而数据库想避免这种冲突的话，就需要将事务B的加锁申请给阻塞住，直到事务A的行锁被释放。那么问题来了，数据库是怎么判断这种冲突的呢？我们可以想到两种方案：一、判断表是否已被其他事务用表锁锁表；二、判断表中的每一行是否已被行锁锁住。很显然，如果采用第二种方法的话，需要一行一行去遍历整张表，效率太慢进而造成系统消耗，所以我们选择第一种方法，这也就是意向锁是表锁的原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;意向锁是放置在资源层次结构的一个级别上的锁，以保护较低级别资源上的共享锁或排它锁，意向锁无法手动创建。如果对任一结点加锁时，必须先对它的上层结点加意向锁也就是如果对一个结点加意向锁，则说明该结点的下层结点正在被加锁。意向锁的执行流程：如果另一个任务试图在该表级别上应用共享或排它锁，则受到由第一个任务控制的表级别意向锁的阻塞，第二个任务在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁，所以意向锁不是用来给数据加锁的，而是用来判断数据有没有存在锁的标志。下面介绍两种常用的意向锁：意向共享锁（&lt;code&gt;Intent Share Lock&lt;/code&gt;，简称IS锁）、意向排它锁（&lt;code&gt;Intent Exclusive Lock&lt;/code&gt;，简称IX锁）。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;意向锁的兼容关系如下：&lt;img data-ratio=&quot;0.7116154873164219&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpMrMeosQsorL6KXxxpXtctCGOuWgxu52D7rq7W890KUNPHnxpRdtCoS03AdgQWHXibia10HkMXkdI0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;749&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;其他锁简介（了解）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;InnoDB还包含插入意向锁、自增锁和空间锁。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;插入意向锁（&lt;code&gt;Insert Intention Locks&lt;/code&gt;）：是间隙锁的一种，它的目的是为了提高插入性能。在多个事务对同一个索引中的同一个范围区间插入记录时，如果插入的位置不冲突，不会阻塞彼此，主要是不需要去申请排他锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自增锁（&lt;code&gt;AUTO-INC Locks&lt;/code&gt;）：自增锁是&lt;code&gt;MySQL&lt;/code&gt;中一种特殊的锁，如果表中存在自增字段，&lt;code&gt;MySQL&lt;/code&gt;便会自动维护一个自增锁。和自增锁相关的一个参数为（5.1.22版本之后加入）&lt;code&gt;innodb_autoinc_lock_mode&lt;/code&gt;，可以设定3个值，0：traditonal（每次都会产生表锁，可以控制插入顺序，效率低）；1：consecutive（会产生一个轻量锁，&lt;code&gt;simple insert&lt;/code&gt;会获得批量的锁，保证连续插入，默认）；2：interleaved（不会锁表，来一个处理一个，并发最高，会存在复制问题）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;MySQL&lt;/code&gt;这三种锁的特性可大致归纳如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;表级锁（偏读）：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;行级锁（偏写）：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是今天的全部内容了，如果你感兴趣的话，可以关注微信公众号“阿Q说代码”！你也可以后台留言领取&lt;code&gt;java&lt;/code&gt;干货资料:学习笔记与大厂面试题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;内容推荐&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI5MDg2NjEzNA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpMAn4Ha81WVBfsKnC9ficVemZff27LiaSoKX83JqwnNmrNhb4D4oAjW7wiaDwtkLTTCRs1A1hanfNu9g/0?wx_fmt=png&quot; data-nickname=&quot;阿Q说代码&quot; data-alias=&quot;AQ_Shuo&quot; data-signature=&quot;每天带给你不一样的精彩！&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;觉得还不错？&lt;/span&gt;&lt;span&gt;记得一键四连呦👇&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>75ee917e10a4950e48ce0ee543569538</guid>
<title>Nginx：不管正向还是反向我通通代理</title>
<link>https://toutiao.io/k/0iqkotc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;关于&lt;code&gt;Nginx&lt;/code&gt;，除了用它做正常的&lt;code&gt;Web&lt;/code&gt;服务器，还经常用它做网络代理服务器使用；来解决网络访问受限的问题。日常大家讨论最多的就是“正向代理”和&quot;反向代理&quot;。很多人，经常会弄不明白什么是&quot;正向代理&quot;，什么又是&quot;反向代理&quot;，他们之间到底有什么区别？&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实&lt;code&gt;Nginx&lt;/code&gt;只有一种代理转发功能。之所以大家经常会说正向代理或者是反向代理是因为站&lt;/span&gt;&lt;span&gt;的角度不一样。&lt;/span&gt;&lt;span&gt;我们可以想象一下80-90年代，机关大院里面负责收发信件的老大爷，把老大爷收发信件动作，想象成&lt;/span&gt;&lt;code&gt;Nginx&lt;/code&gt;&lt;span&gt;对请求的转发功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当老大爷把内部信件发往外部时，我们定义为&lt;code&gt;正向代理&lt;/code&gt;，那么当老大爷把外部发往内部的信件转发给内部每个具体的人时，就叫做&lt;code&gt;反向代理&lt;/code&gt;。但是对于老大爷来说都是代理，完成&lt;/span&gt;的&lt;span&gt;动作都是一样&lt;/span&gt;的&lt;span&gt;。&lt;/span&gt;&lt;span&gt;对于&lt;/span&gt;&lt;code&gt;Nginx&lt;/code&gt;&lt;span&gt;来说也是一样的，所有网络请求转发指令都是一样的。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;Nginx代理指令对比&lt;/span&gt;&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将内部请求转发到外部。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;upstream baidu {&lt;br/&gt;    server www.baidu.com;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;server{&lt;br/&gt;    listen 8100;&lt;br/&gt;    server_name proxy_baidu;&lt;br/&gt;    location / {&lt;br/&gt;        proxy_pass http://baidu;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;访问 &lt;code&gt;proxy_ip:8100&lt;/code&gt; 将会通过代理服务器把请求发出去。&lt;/p&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将外部请求转发到内部&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code&gt;upstream test-api {&lt;br/&gt;    ip_hash;&lt;br/&gt;    server 192.168.32.12:80;&lt;br/&gt;    server 192.168.32.13:80;&lt;br/&gt;}&lt;br/&gt;server{&lt;br/&gt;    listen 8080;&lt;br/&gt;    location / {&lt;br/&gt;      proxy_pass http://test-api;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这段配置将会把外部发往&lt;code&gt;Nginx&lt;/code&gt;请求转发给内部的&lt;code&gt;192.168.32.12&lt;/code&gt;和&lt;code&gt;192.168.32.13&lt;/code&gt;这两台服务器。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;结论&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;通过对比两段配置会发现，对于&lt;code&gt;Nginx&lt;/code&gt;来说，无论正向代理还是反向代理，指令都是一样的。所以对于&lt;code&gt;Nginx&lt;/code&gt;来说，都是代理，不分正反。最后附上一份示意图，来进一步说明&lt;code&gt;Nginx&lt;/code&gt;网络代理的角色。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6841477949940405&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/jmjNkE9L9QgsNE9GvaZPmIkuvd6uvaqaAZ2qnMDDiccdcgWBJIhZRcb2cCHsdI68PIxxsH2icEjJvys8CSiadftIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;839&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247484022&amp;amp;idx=1&amp;amp;sn=d3176ea73e48360b64c3f50e8fd622bf&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;1. Java并发编程那些事儿(十)——最后的总结&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247484105&amp;amp;idx=1&amp;amp;sn=70989cf2585e166042144b90253905e8&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;2. 该如何理解Java中的Class类&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247483893&amp;amp;idx=1&amp;amp;sn=85f6a2063048cc244aedde3172444e32&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;3. Awk这件上古神兵你会用了吗&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247483852&amp;amp;idx=1&amp;amp;sn=6efb0db3d5dff639fae2aaec978c2160&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;4. 手把手教你搭建一套ELK日志搜索运维平台&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>