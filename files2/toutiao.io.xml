<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>bcc1df8172995b2d04d8e3e5f62b74ad</guid>
<title>高并发下如何保证接口的幂等性？</title>
<link>https://toutiao.io/k/f0361xm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxODkzNTQ3Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uL371281oDFEpxenPicr7Kh8c9P0I97yVWw9JfljjPy5gVBLDiaIrWkzAGHGib09Kib4TQtyw8jpLicW3yoyibMY8yMA/0?wx_fmt=png&quot; data-nickname=&quot;苏三说技术&quot; data-alias=&quot;&quot; data-signature=&quot;「苏三说技术」 维护者目前就职于某知名互联网公司，从事开发、架构和部分管理工作。实战经验丰富，对jdk、spring、springboot、springcloud、mybatis等开源框架源码有一定研究，欢迎关注，和我一起交流。&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;前言&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;接口幂等性&lt;/code&gt;问题，对于开发人员来说，是一个跟语言无关的公共问题。本文分享了一些解决这类问题非常实用的办法，绝大部分内容我在项目中实践过的，给有需要的小伙伴一个参考。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你有没有遇到过这些场景：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;有时我们在填写某些&lt;code&gt;form表单&lt;/code&gt;时，保存按钮不小心快速点了两次，表中竟然产生了两条重复的数据，只是id不一样。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们在项目中为了解决&lt;code&gt;接口超时&lt;/code&gt;问题，通常会引入了&lt;code&gt;重试机制&lt;/code&gt;。第一次请求接口超时了，请求方没能及时获取返回结果（此时有可能已经成功了），为了避免返回错误的结果（这种情况不可能直接返回失败吧？），于是会对该请求重试几次，这样也会产生重复的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mq消费者在读取消息时，有时候会读取到&lt;code&gt;重复消息&lt;/code&gt;（至于什么原因这里先不说，有兴趣的小伙伴，可以找我私聊），如果处理不好，也会产生重复的数据。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，这些都是幂等性问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;接口幂等性&lt;/code&gt;是指用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这类问题多发于接口的：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;insert&lt;/code&gt;操作，这种情况下多次请求，可能会产生重复数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;update&lt;/code&gt;操作，如果只是单纯的更新数据，比如：&lt;code&gt;update user set status=1 where id=1&lt;/code&gt;，是没有问题的。如果还有计算，比如：&lt;code&gt;update user set status=status+1 where id=1&lt;/code&gt;，这种情况下多次请求，可能会导致数据错误。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们要如何保证接口幂等性？本文将会告诉你答案。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. insert前先select&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下，在保存数据的接口中，我们为了防止产生重复数据，一般会在&lt;code&gt;insert&lt;/code&gt;前，先根据&lt;code&gt;name&lt;/code&gt;或&lt;code&gt;code&lt;/code&gt;字段&lt;code&gt;select&lt;/code&gt;一下数据。如果该数据已存在，则执行&lt;code&gt;update&lt;/code&gt;操作，如果不存在，才执行  &lt;code&gt;insert&lt;/code&gt;操作。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0972762645914398&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEulLjl08cXVC1y0sFSlxNrFw4QIBGFicltUPsasY7lgUVEK7cVLS1GK3mibMW5Jcy4t1TvNmaBnGew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;514&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方案可能是我们平时在防止产生重复数据时，使用最多的方案。但是该方案不适用于并发场景，在并发场景中，要配合其他方案一起使用，否则同样会产生重复数据。我在这里提一下，是为了避免大家踩坑。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 加悲观锁&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在支付场景中，用户A的账号余额有150元，想转出100元，正常情况下用户A的余额只剩50元。一般情况下，sql是这样的：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;update&lt;/span&gt; user amount = amount-&lt;span class=&quot;code-snippet__number&quot;&gt;100&lt;/span&gt; where id=&lt;span class=&quot;code-snippet__number&quot;&gt;123&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果出现多次相同的请求，可能会导致用户A的余额变成负数。这种情况，用户A来可能要哭了。于此同时，系统开发人员可能也要哭了，因为这是很严重的系统bug。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，可以加悲观锁，将用户A的那行数据锁住，在同一时刻只允许一个请求获得锁，更新数据，其他的请求则等待。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下通过如下sql锁住单行数据：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;code-snippet__number&quot;&gt;123&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;update&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体流程如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9544554455445544&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEulLjl08cXVC1y0sFSlxNrlFMScuviaupFRboxZnOVWkojRVNxya7e2a0BUvnU7cwcAw9jYMLvJXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1010&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;多个请求同时根据id查询用户信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;判断余额是否不足100，如果余额不足，则直接返回余额不足。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果余额充足，则通过for update再次查询用户信息，并且尝试获取锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;只有第一个请求能获取到行锁，其余没有获取锁的请求，则等待下一次获取锁的机会。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第一个请求获取到锁之后，判断余额是否不足100，如果余额足够，则进行update操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果余额不足，说明是重复请求，则直接返回成功。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;需要特别注意的是：如果使用的是mysql数据库，存储引擎必须用innodb，因为它才支持事务。此外，这里id字段一定要是主键或者唯一索引，不然会锁住整张表。&lt;/p&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;悲观锁需要在同一个事务操作过程中锁住一行数据，如果事务耗时比较长，会造成大量的请求等待，影响接口性能&lt;/span&gt;。&lt;/section&gt;&lt;section&gt;此外，每次请求接口很难保证都有相同的返回值，所以不适合幂等性设计场景，但是在防重场景中是可以的使用的。&lt;/section&gt;&lt;section&gt;&lt;span&gt;在这里顺便说一下，&lt;/span&gt;&lt;code&gt;防重设计&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;幂等设计&lt;/code&gt;&lt;span&gt;，其实是有区别的。&lt;/span&gt;&lt;span&gt;防重设计主要为了避免产生重复数据，对接口返回没有太多要求。&lt;/span&gt;&lt;span&gt;而幂等设计除了避免产生重复数据之外，还要求每次请求都返回一样的结果。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;3. 加乐观锁&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然悲观锁有性能问题，为了提升接口性能，我们可以使用乐观锁。需要在表中增加一个&lt;code&gt;timestamp&lt;/code&gt;或者&lt;code&gt;version&lt;/code&gt;字段，这里以&lt;code&gt;version&lt;/code&gt;字段为例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在更新数据之前先查询一下数据：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt;,amount,&lt;span class=&quot;code-snippet__keyword&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;code-snippet__number&quot;&gt;123&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果数据存在，假设查到的&lt;code&gt;version&lt;/code&gt;等于&lt;code&gt;1&lt;/code&gt;，再使用&lt;code&gt;id&lt;/code&gt;和&lt;code&gt;version&lt;/code&gt;字段作为查询条件更新数据：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;update&lt;/span&gt; user set amount=amount+&lt;span class=&quot;code-snippet__number&quot;&gt;100&lt;/span&gt;,version=version+&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;where id=&lt;span class=&quot;code-snippet__number&quot;&gt;123&lt;/span&gt; and version=&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更新数据的同时&lt;code&gt;version+1&lt;/code&gt;，然后判断本次&lt;code&gt;update&lt;/code&gt;操作的影响行数，如果大于0，则说明本次更新成功，如果等于0，则说明本次更新没有让数据变更。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于第一次请求&lt;code&gt;version&lt;/code&gt;等于&lt;code&gt;1&lt;/code&gt;是可以成功的，操作成功后&lt;code&gt;version&lt;/code&gt;变成&lt;code&gt;2&lt;/code&gt;了。这时如果并发的请求过来，再执行相同的sql：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__attribute&quot;&gt;update&lt;/span&gt; user set amount=amount+&lt;span class=&quot;code-snippet__number&quot;&gt;100&lt;/span&gt;,version=version+&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;where id=&lt;span class=&quot;code-snippet__number&quot;&gt;123&lt;/span&gt; and version=&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该&lt;code&gt;update&lt;/code&gt;操作不会真正更新数据，最终sql的执行结果影响行数是&lt;code&gt;0&lt;/code&gt;，因为&lt;code&gt;version&lt;/code&gt;已经变成&lt;code&gt;2&lt;/code&gt;了，&lt;code&gt;where&lt;/code&gt;中的&lt;code&gt;version=1&lt;/code&gt;肯定无法满足条件。但为了保证接口幂等性，接口可以直接返回成功，因为&lt;code&gt;version&lt;/code&gt;值已经修改了，那么前面必定已经成功过一次，后面都是重复的请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体流程如下：&lt;img data-ratio=&quot;1.5942028985507246&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEulLjl08cXVC1y0sFSlxNrVUKwejvF2k3OTVPD2JPAiaV5diaMl16ictoclcWwgcvJsMV8mibVOartVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;552&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;先根据id查询用户信息，包含version字段&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据id和version字段值作为where条件的参数，更新用户信息，同时version+1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;判断操作影响行数，如果影响1行，则说明是一次请求，可以做其他数据操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果影响0行，说明是重复请求，则直接返回成功。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 加唯一索引&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;绝大数情况下，为了防止重复数据的产生，我们都会在表中加唯一索引，这是一个非常简单，并且有效的方案。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;alter table &lt;span class=&quot;code-snippet__string&quot;&gt;`order`&lt;/span&gt; add UNIQUE KEY &lt;span class=&quot;code-snippet__string&quot;&gt;`un_code`&lt;/span&gt; (&lt;span class=&quot;code-snippet__string&quot;&gt;`code`&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加了唯一索引之后，第一次请求数据可以插入成功。但后面的相同请求，插入数据时会报&lt;code&gt;Duplicate entry &#x27;002&#x27; for key &#x27;order.un_code&lt;/code&gt;异常，表示唯一索引有冲突。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽说抛异常对数据来说没有影响，不会造成错误数据。但是为了保证接口幂等性，我们需要对该异常进行捕获，然后返回成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是&lt;code&gt;java&lt;/code&gt;程序需要捕获：&lt;code&gt;DuplicateKeyException&lt;/code&gt;异常，如果使用了&lt;code&gt;spring&lt;/code&gt;框架还需要捕获：&lt;code&gt;MySQLIntegrityConstraintViolationException&lt;/code&gt;异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体流程图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.47766323024055&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEulLjl08cXVC1y0sFSlxNrs24WBMr0ktqAewryz7neZsASO9B8Qseqb8ict8CyLyia8lzv2YlY5LQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;582&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户通过浏览器发起请求，服务端收集数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将该数据插入mysql&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;判断是否执行成功，如果成功，则操作其他数据（可能还有其他的业务逻辑）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果执行失败，捕获唯一索引冲突异常，直接返回成功。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 建防重表&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候表中并非所有的场景都不允许产生重复的数据，只有某些特定场景才不允许。这时候，直接在表中加唯一索引，显然是不太合适的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对这种情况，我们可以通过&lt;code&gt;建防重表&lt;/code&gt;来解决问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该表可以只包含两个字段：&lt;code&gt;id&lt;/code&gt; 和 &lt;code&gt;唯一索引&lt;/code&gt;，唯一索引可以是多个字段比如：name、code等组合起来的唯一标识，例如：susan_0001。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体流程图如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.198952879581152&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEulLjl08cXVC1y0sFSlxNrbAGE1PLlnV6ibnZcTeNeyic7bv6jewYbu1Tfo7KO99iciaZcbf5icgSPovA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;764&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户通过浏览器发起请求，服务端收集数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将该数据插入mysql防重表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;判断是否执行成功，如果成功，则做mysql其他的数据操作（可能还有其他的业务逻辑）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果执行失败，捕获唯一索引冲突异常，直接返回成功。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;需要特别注意的是：防重表和业务表必须在同一个数据库中，并且操作要在同一个事务中。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6. 根据状态机&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候业务表是有状态的，比如订单表中有：1-下单、2-已支付、3-完成、4-撤销等状态。如果这些状态的值是有规律的，按照业务节点正好是从小到大，我们就能通过它来保证接口的幂等性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如id=123的订单状态是&lt;code&gt;已支付&lt;/code&gt;，现在要变成&lt;code&gt;完成&lt;/code&gt;状态。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;update&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;`order`&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;status&lt;/span&gt;=&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;code-snippet__number&quot;&gt;123&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;status&lt;/span&gt;=&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次请求时，该订单的状态是&lt;code&gt;已支付&lt;/code&gt;，值是&lt;code&gt;2&lt;/code&gt;，所以该&lt;code&gt;update&lt;/code&gt;语句可以正常更新数据，sql执行结果的影响行数是&lt;code&gt;1&lt;/code&gt;，订单状态变成了&lt;code&gt;3&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面有相同的请求过来，再执行相同的sql时，由于订单状态变成了&lt;code&gt;3&lt;/code&gt;，再用&lt;code&gt;status=2&lt;/code&gt;作为条件，无法查询出需要更新的数据，所以最终sql执行结果的影响行数是&lt;code&gt;0&lt;/code&gt;，即不会真正的更新数据。但为了保证接口幂等性，影响行数是&lt;code&gt;0&lt;/code&gt;时，接口也可以直接返回成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体流程图如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.5646551724137931&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEulLjl08cXVC1y0sFSlxNrWHME47uFVibJDCibIPILsuFib5nq3batoka8m58tN42JdX4HgKSrKiaF9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;464&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户通过浏览器发起请求，服务端收集数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据id和当前状态作为条件，更新成下一个状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;判断操作影响行数，如果影响了1行，说明当前操作成功，可以进行其他数据操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果影响了0行，说明是重复请求，直接返回成功。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;主要特别注意的是，该方案仅限于要更新的&lt;code&gt;表有状态字段&lt;/code&gt;，并且刚好要更新&lt;code&gt;状态字段&lt;/code&gt;的这种特殊情况，并非所有场景都适用。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7. 加分布式锁&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实前面介绍过的&lt;code&gt;加唯一索引&lt;/code&gt;或者&lt;code&gt;加防重表&lt;/code&gt;，本质是使用了&lt;code&gt;数据库&lt;/code&gt;的&lt;code&gt;分布式锁&lt;/code&gt;，也属于分布式锁的一种。但由于&lt;code&gt;数据库分布式锁&lt;/code&gt;的性能不太好，我们可以改用：&lt;code&gt;redis&lt;/code&gt;或&lt;code&gt;zookeeper&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;鉴于现在很多公司分布式配置中心改用&lt;code&gt;apollo&lt;/code&gt;或&lt;code&gt;nacos&lt;/code&gt;，已经很少用&lt;code&gt;zookeeper&lt;/code&gt;了，我们以&lt;code&gt;redis&lt;/code&gt;为例介绍分布式锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前主要有三种方式实现redis的分布式锁：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;setNx命令&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;set命令&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redission框架&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每种方案各有利弊，具体实现细节我就不说了，有兴趣的朋友可以加我微信找我私聊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体流程图如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.2676470588235293&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEulLjl08cXVC1y0sFSlxNrkm3ibIJnLzKpwSdxcSPGh8lfuCCGLO2QVnYp2msIvLgoLuHsyOjHdWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;680&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体步骤：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户通过浏览器发起请求，服务端会收集数据，并且生成订单号code作为唯一业务字段。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用redis的set命令，将该订单code设置到redis中，同时设置超时时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;判断是否设置成功，如果设置成功，说明是第一次请求，则进行数据操作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果设置失败，说明是重复请求，则直接返回成功。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;需要特别注意的是：分布式锁一定要设置一个合理的过期时间，如果设置过短，无法有效的防止重复请求。如果设置过长，可能会浪费&lt;code&gt;redis&lt;/code&gt;的存储空间，需要根据实际业务情况而定。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8. 获取token&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了上述方案之外，还有最后一种使用&lt;code&gt;token&lt;/code&gt;的方案。该方案跟之前的所有方案都有点不一样，需要两次请求才能完成一次业务操作。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一次请求获取&lt;code&gt;token&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二次请求带着这个&lt;code&gt;token&lt;/code&gt;，完成业务操作。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体流程图如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步，先获取token。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b2a5c87c441f92d5e15b51872ea234f1</guid>
<title>我，第一次做项目经理，干赔了</title>
<link>https://toutiao.io/k/nh6jij4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我第一次做项目经理，那是十多年前的事情了，当时给国家开发银行做一个财务风险分析的系统，这个项目：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;金额：200 万&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;周期：起初定的 8 个月做完&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;人员：10 个人左右。除了我之外还有，需求分析师 2 人；测试 1 人；Java 5 人（那时候还没有前后端分离这个词，前后端一起搞）；BI 工程师 1 人。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目启动之后，我们项目组去国开行驻场，行里给我们腾出来一间办公室，办公室不大，我们十来个人坐进去之后，满满当当的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们周围的办公室，也都被其他同行占据了，比如神州数码、用友、中软……本来 IT 行业圈子就不大，这下大家离得就更近了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;离得近了，最方便的就是挖人。A 公司看 B 公司给国开行做了一个系统不错，单子金额也挺可观，A 公司动心了，也想搞一套系统卖给其他银行。从零开始做一套系统，对 A 公司来说难度和成本都不小，现在爽了，有捷径了：B 公司的人就在自己的眼皮底下，时间长了，物色一个合适的人直接挖过来……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有点跑题，继续说我带项目的事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是我第一次带项目，第一次做项目经理。以前参加项目，我最多也就是项目的技术负责人，把技术相关的搞定就行了，主要负责搭建环境、数据库表设计、选择技术框架、制定规范、写写代码……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当了项目经理之后，我还是和以前一样，绝大部分时间就是在小屋里和大家一起闷头写代码、开发系统，除了每周和甲方开一次例会，基本上对屋子之外的事情不太关心。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;几方面原因：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;认知不够，我以为把项目按时完成，功能满足需求，让甲方正常验收了，这个项目就算做好了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;我本来就是程序员出身，对技术之外的事情没啥兴趣——这个可能是技术转管理的通病。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;国开行里领导太多，随随便便遇到个人就得称呼“张处”、“李处”、“赵局”。我也奇了怪了，总行里的领导这么多吗？本来乙方在甲方面前地位就有的低，再让我巴结这些个处长们……程序员的清高让我干不出来这个。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就这样，我们在小屋里“闭门造车”了三四个月，项目时间差不多过了一半，我要把开发的系统给国开行甲方爸爸演示汇报一次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在演示之前，我们自我感觉一切良好，进展顺利，按我们的估计，至少可以提前一个月交付项目。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果，汇报的时候翻车了，甲方爸爸一顿啪啪打脸：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;系统界面和交互设计，和银行里主流系统的风格不一致；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;账号和权限体系不能单独存在，要用银行里已有的一套方案；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;部分功能过于繁琐，使用门槛高；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;甲方对部分开源技术的稳定性存在怀疑；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;……&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总之，这些问题意味着：我们之前做的大部分工作，需要改动甚至推翻重来，整个项目的前景蒙上了一层阴影。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次暴露出来的问题，我肯定要承担主要责任。就在我被打击的迷茫和萎靡的时候，我的领导，公司的技术总监也知道了这件事，叫我回公司一趟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回去之前，我做好了最坏的打算：被批评一顿、被撸了项目经理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幸运的是，最坏的事情没有发生，领导找我长谈了一番，时间久远，谈话内容已经记不清了，大概内容就是理解我第一次从技术转管理会犯错，教了我一些带项目的方法，相信我接下来能把项目做完……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，谈话中领导的一句话，我到现在还记得清清楚楚：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;项目成功的定义是什么？一个成功的项目，就是让项目的所有涉众都满意。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;意思就是，成功的项目，是让项目中参与的各方人员都感到满意。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这句话彻底颠覆我的认知！我之前单纯的认为把项目按时做完上线，客户验收付了款，项目就算成功了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;“让项目的所有涉众都满意”&lt;/strong&gt;，那么我们项目的涉众都有谁？他们满意的标准是什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我回到项目组之后苦思了好几天，同时找银行客户、同事交流，后来基本想明白了：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;甲方爸爸&lt;/strong&gt;：毫无疑问，这是最重要的一个涉众。对甲方项目负责人来说，他们最关注的是这个项目能按时上线，而且能解决业务痛点；同时在项目过程中他们要能完全掌控项目进度。这个项目延期或者没做好，他们也不好交代。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;系统的用户&lt;/strong&gt;：对用户来说，就是要让他们用着满意，符合他们之前的工作习惯。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;公司老板&lt;/strong&gt;：对老板来说，他没有指望这个项目能挣多少钱，他的主要诉求有两个：1、通过这个项目让国开行认可我们公司，争取以后拿到更多项目；2、把这个项目沉淀成标准化的产品，将来卖给其他银行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;团队同事&lt;/strong&gt;：首先，同事们不喜欢长期驻场做项目，毕竟不是自己的地盘，最理想的是有一个标准化产品（和老板的目标一样），以后再有项目，把产品给客户短期实施就能搞定。另外，团队里大部分都是程序员，他们也需要技术提高、个人成长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;公司销售&lt;/strong&gt;：销售和老板的想法大概差不多，只不过更看重国开行眼前这个客户，希望项目一期做完至少能先签下来项目二期。所以他希望我跟他一起，多和客户吃吃饭、喝喝酒，拉近一下关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想明白这些之后，后面就该我做出改变了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，为了给银行科技处的处长汇报工作，我和销售一起在处长办公室门口站着等，经常一站就是两、三个小时。和销售一起陪银行领导吃饭聊天，给领导们解决电脑上的各种幺蛾子问题……这些更是家常便饭。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些我曾经抵触的、不屑于干的事情干多了之后，甲方对我们的脸色明显变好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再比如，为了让甲方掌控项目进度，我们一两周就迭代一个版本，主动去找甲方沟通确认。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，我发现有些事情是有关联的。我在甲方这边花的精力多了之后，在技术方面花的精力自然就少了。这就倒逼着我要把一些技术工作交给同事。随着我责任和权力的下放，对团队里优秀同事来说，他们的技术话语权变大了，空间变大了，对他们来说也是个成长的机会。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他的不细说了，最终这个项目的结果并不是特别圆满，有好有坏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;坏的是，由于之前挖坑太深，项目最终还是延期了，8 个月的项目干了 10 个月，项目小亏，大家的奖金也受损失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好的是，项目上线之后用户使用反馈比较正面，甲方项目负责人也比较满意，项目结束后，顺利拿到了二期的单子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一个好事，项目结束后没多久，我们项目组原班人马真的搞出来一个产品，这个产品为以后项目实施帮了大忙。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我第一次做项目经理的经历基本就讲完了，最后再次把这句话送给各位：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;一个成功的项目，就是让项目的所有涉众都满意。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;真的，这句话可以说是那次项目中，我收获最大的一句话。一直到现在，不管是做项目、产品，还是做其他事情，我时不时的就会想想这句话。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;希望这句话也能帮到你们。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我承认，很多时候让所有涉众都满意，是很难的。朝着这个目标努力，最终达到“让大部分涉众基本满意”，也算不错了。就像考试一样，不期望你能考满分，但是你要去奔着考满分去复习准备。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你好，我是四猿外。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一家上市公司的技术总监，管理的技术团队一百余人。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我从一名非计算机专业的毕业生，转行到程序员，一路打拼，一路成长。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我会通过公众号，&lt;br/&gt;把自己的成长故事写成文章，&lt;br/&gt;把枯燥的技术文章写成故事。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我建了一个读者交流群，里面大部分是程序员，一起聊技术、工作、八卦。欢迎加我微信，拉你入群。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9852216748768473&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6nbNnibOq5KQibCDibpTo0kqofPehQvDDibibcb3bQUELdY3Knsl4r0RcgsV9l4icr3icmZQfaBXtSFNTxmdQlAZT1OQg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;609&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;推荐阅读&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247485152&amp;amp;idx=1&amp;amp;sn=65d8fd3ce30714917dca3605428ae9c1&amp;amp;chksm=fcd8caa1cbaf43b7b7c3b4579f5eabc1a64b0bd837b42925d1594de1746913469b4a852cb0b2&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;大刘跌倒，老田吃饱——首席架构师之争&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247485134&amp;amp;idx=1&amp;amp;sn=f8c35fd83d5290e8aabf66f219ab518f&amp;amp;chksm=fcd8ca8fcbaf439945fb0dad200f948763329c8817b60af2fce333ae5e15bbd6381d265e6987&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;你们要的学Java的练手项目，来了&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247485048&amp;amp;idx=1&amp;amp;sn=53f8475521377094101aa11a6054f9d8&amp;amp;chksm=fcd8ca39cbaf432f26d8826f3a14461a2c09c1908f9bf10ea700125d9073d616376fd0f90354&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;在主动要求涨工资这事上，不要学我！&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5299e6797926c0a25bac2a698689b077</guid>
<title>数据采集组件：Flume 基础用法和 Kafka 集成</title>
<link>https://toutiao.io/k/3j6wxlw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h1&gt;&lt;span&gt;一、Flume简介&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、基础描述&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;Flume是Cloudera提供的一个高可用的，高可靠的，分布式的海量日志采集、聚合和传输的系统，Flume支持在日志系统中定制各类数据发送方，用于收集数据；&lt;/p&gt;&lt;p&gt;特点：分布式、高可用、基于流式架构，通常用来收集、聚合、搬运不同数据源的大量日志到数据仓库。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、架构模型&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3564516129032258&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDXlU8md45X3EdGYmvGZcw7jHQJF3emTKIeibrmWEgVfVOD3uUnL3w2hdDyaic08ancXS701zkYglibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;620&quot;/&gt;&lt;/p&gt;&lt;p&gt;Agent包括三个核心组成，Source、Channel、Sink。Source负责接收数据源，并兼容多种类型，Channel是数据的缓冲区，Sink处理数据输出的方式和目的地。&lt;/p&gt;&lt;p&gt;Event是Flume定义的一个数据流传输的基本单元，将数据从源头送至目的地。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.21045197740112995&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDXlU8md45X3EdGYmvGZcw7nO96tf7kBl8tEQBpRA3lGSt8ZJr2IiaIQIuHchiccv3jUzjcJtcX4Z2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;708&quot;/&gt;&lt;/p&gt;&lt;p&gt;Flume可以设置多级Agent连接的方式传输Event数据，从最初的source开始到最终sink传送的目的存储系统，如果数量过多会影响传输速率，并且传输过程中单节点故障也会影响整个传输通道。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6007751937984496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDXlU8md45X3EdGYmvGZcw7dsUEnWt0ochuDPl3oYiawNOGLnvV8AKlVibFFGW2kiaXFibGEGtmomcAfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1032&quot;/&gt;&lt;/p&gt;&lt;p&gt;Flume支持多路复用数据流到一个或多个目的地，这种模式可以将相同数据复制到多个channel中，或者将不同数据分发到不同的channel中，并且sink可以选择传送到不同的目的地。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDXlU8md45X3EdGYmvGZcw7s3xnNbkYy0nCzOANIAAabUWLjDetNcsZPt6yIkHfnFIm46GFkX2iaGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;Agent1理解为路由节点负责Channel的Event均衡到多个Sink组件，每个Sink组件分別连接到独立的Agent上，实现负载均衡和错误恢复的功能。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6758064516129032&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDXlU8md45X3EdGYmvGZcw7AcwicPL1NBMhxbPMDsDhReYl6nmfuR7ciahet0VCTfodDhZsFjFibavUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;620&quot;/&gt;&lt;/p&gt;&lt;p&gt;Flume的使用组合方式做数据聚合，每台服务器部署一个flume节点采集日志数据，再汇聚传输到存储系统，例如HDFS、Hbase等组件，高效且稳定的解决集群数据的采集。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、安装过程&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、安装包&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;apache-flume-1.7.0-bin.tar.gz&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、解压命名&lt;/span&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;[root@hop01 opt]&lt;span&gt;# pwd&lt;/span&gt;&lt;br/&gt;/opt&lt;br/&gt;[root@hop01 opt]&lt;span&gt;# tar -zxf apache-flume-1.7.0-bin.tar.gz&lt;/span&gt;&lt;br/&gt;[root@hop01 opt]&lt;span&gt;# mv apache-flume-1.7.0-bin flume1.7&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;3、配置文件&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;配置路径：/opt/flume1.7/conf&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;mv&lt;/span&gt; &lt;span&gt;flume-env&lt;/span&gt;&lt;span&gt;.sh&lt;/span&gt;&lt;span&gt;.template&lt;/span&gt; &lt;span&gt;flume-env&lt;/span&gt;&lt;span&gt;.sh&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;4、修改配置&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;添加JDK依赖&lt;/p&gt;&lt;pre&gt;&lt;code&gt;vim flume-env.sh&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; JAVA_HOME=&lt;span&gt;/opt/&lt;/span&gt;jdk1&lt;span&gt;.8&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;5、环境测试&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;安装netcat工具&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;sudo&lt;/span&gt; yum install -y nc&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建任务配置&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[root@hop01 flume1&lt;span&gt;.7&lt;/span&gt;]&lt;span&gt;# cd job/&lt;/span&gt;&lt;br/&gt;[root@hop01 job]&lt;span&gt;# vim flume-netcat-test01.conf&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;添加基础任务配置&lt;/p&gt;&lt;p&gt;注意：a1表示agent名称。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# this agent&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a1&lt;/span&gt;.sources = sr1&lt;br/&gt;&lt;span&gt;a1&lt;/span&gt;.sinks = sk1&lt;br/&gt;&lt;span&gt;a1&lt;/span&gt;.channels = sc1&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# the source&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a1&lt;/span&gt;.sources.sr1.type = netcat&lt;br/&gt;&lt;span&gt;a1&lt;/span&gt;.sources.sr1.bind = localhost&lt;br/&gt;&lt;span&gt;a1&lt;/span&gt;.sources.sr1.port = 55555&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# the sink&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a1&lt;/span&gt;.sinks.sk1.type = logger&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# events in memory&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a1&lt;/span&gt;.channels.sc1.type = memory&lt;br/&gt;&lt;span&gt;a1&lt;/span&gt;.channels.sc1.capacity = 1000&lt;br/&gt;&lt;span&gt;a1&lt;/span&gt;.channels.sc1.transactionCapacity = 100&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Bind the source and sink&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a1&lt;/span&gt;.sources.sr1.channels = sc1&lt;br/&gt;&lt;span&gt;a1&lt;/span&gt;.sinks.sk1.channel = sc1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;开启flume监听端口&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/opt/flume1.7/bin/flume-ng agent --conf /opt/flume1.7/conf/&lt;/span&gt; --name a1 --conf-file /opt/flume1&lt;span&gt;.7&lt;/span&gt;/job/flume-netcat-test01.conf -Dflume.root.logger=INFO,&lt;span&gt;console&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用netcat工具向55555端口发送数据&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[root@hop01 ~]&lt;span&gt;# nc localhost 55555&lt;/span&gt;&lt;br/&gt;hello,flume&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查看flume控制面&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.115625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDXlU8md45X3EdGYmvGZcw7tC8kqcbfYQUyzgH0DEVicbEUmVN77XcOrBAXnVcSQGmn2VKgSqcej0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、应用案例&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、案例描述&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4681724845995893&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDXlU8md45X3EdGYmvGZcw79nfQS7shOXqs9J7DSkjGGfptiazxgCDU1otXQ8cOUG47TjBfR1deXkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;974&quot;/&gt;&lt;/p&gt;&lt;p&gt;基于flume在各个集群服务进行数据采集，然后数据传到kafka服务，再考虑数据的消费策略。&lt;/p&gt;&lt;p&gt;采集：基于flume组件的便捷采集能力，如果直接使用kafka会产生大量的埋点动作不好维护。&lt;/p&gt;&lt;p&gt;消费：基于kafka容器的数据临时存储能力，避免系统高度活跃期间采集数据过大冲垮数据采集通道，并且可以基于kafka做数据隔离并针对化处理。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、创建kafka配置&lt;/span&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;[root@hop01 job]&lt;span&gt;# pwd&lt;/span&gt;&lt;br/&gt;/opt/flume1&lt;span&gt;.7&lt;/span&gt;/job&lt;br/&gt;[root@hop01 job]&lt;span&gt;# vim kafka-flume-test01.conf&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;3、修改sink配置&lt;/span&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;# the sink&lt;/span&gt;&lt;br/&gt;a1.sinks.sk1.type = org.apache.flume.sink.kafka.KafkaSink&lt;br/&gt;&lt;span&gt;# topic&lt;/span&gt;&lt;br/&gt;a1.sinks.sk1.topic = kafkatest&lt;br/&gt;&lt;span&gt;# broker地址、端口号&lt;/span&gt;&lt;br/&gt;a1.sinks.sk1.kafka.bootstrap.servers = hop01:&lt;span&gt;9092&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 序列化方式&lt;/span&gt;&lt;br/&gt;a1.sinks.sk1.serializer.&lt;span&gt;class&lt;/span&gt; = kafka.serializer.StringEncoder&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;4、创建kafka的Topic&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;上述配置文件中名称：kafkatest，下面执行创建命令之后查看topic信息。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;[root@hop01 bin]&lt;span&gt;# pwd&lt;/span&gt;&lt;br/&gt;/opt/kafka2&lt;span&gt;.11&lt;/span&gt;&lt;br/&gt;[root@hop01 kafka2&lt;span&gt;.11&lt;/span&gt;]&lt;span&gt;# bin/kafka-topics.sh --create --zookeeper hop01:2181 --replication-factor 1 --partitions 1 --topic kafkatest&lt;/span&gt;&lt;br/&gt;[root@hop01 kafka2&lt;span&gt;.11&lt;/span&gt;]&lt;span&gt;# bin/kafka-topics.sh --describe --zookeeper hop01:2181 --topic kafkatest&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;5、启动Kakfa消费&lt;/span&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;[root@hop01 kafka2&lt;span&gt;.11&lt;/span&gt;]&lt;span&gt;# bin/kafka-console-consumer.sh --bootstrap-server hop01:2181 --topic kafkatest --from-beginning&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里指定topic是kafkatest。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;6、启动flume配置&lt;/span&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/opt/flume1.7/bin/flume-ng agent --conf /opt/flume1.7/conf/&lt;/span&gt; --name a1 --conf-file /opt/flume1&lt;span&gt;.7&lt;/span&gt;/job/kafka-flume-test01.conf -Dflume.root.logger=INFO,&lt;span&gt;console&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;&lt;span&gt;四、源代码地址&lt;/span&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;GitHub·地址&lt;br/&gt;https:&lt;span&gt;//github.com/cicadasmile/big-data-parent&lt;/span&gt;&lt;br/&gt;GitEE·地址&lt;br/&gt;https:&lt;span&gt;//gitee.com/cicadasmile/big-data-parent&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4Njg0MzYwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBCuF3zfJnqPKpUia4wfn1FUtTHpxxkR5HvbicPgOjibPicX0goMOkny1NdkLAJvBaqrYh3UdwMjiaDQMA/0?wx_fmt=png&quot; data-nickname=&quot;知了一笑&quot; data-alias=&quot;cicada_smile&quot; data-signature=&quot;积累是一个孤独且枯燥的过程&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>287c84bf6764f8c370a527ea042de8c6</guid>
<title>AQS 是如何控制线程的</title>
<link>https://toutiao.io/k/3kqi349</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;Java中AQS（&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;，队列同步器）是构建JUC中锁和其他同步组件的基础组件，我们在日常开发中一般不会直接与AQS打交道。AQS核心功能就2点，通过CAS维护state状态，通过CAS维护同步队列进而控制线程的阻塞唤醒。换句话说就是：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;AQS使用一个int成员变量(&lt;code&gt;private volatile int state&lt;/code&gt;)表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作，并发包的作者（Doug Lea）期望它能够成为实现大部分同步需求的基础。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;AQS是一个抽象类，但是并没有抽象方法，只不过有些方法是会抛出&lt;code&gt;UnsupportedOperationException&lt;/code&gt;，这些方法就需要根据不同场景进行子类重写，比如可重入锁&lt;code&gt;NonReentrantLock&lt;/code&gt;就重写了方法&lt;code&gt;tryRelease、isHeldExclusively、tryAcquire&lt;/code&gt;等，子类重写这些方法可自定义对应逻辑，比如判断是否可重入、是否公平设置state等，这块具体代码参考&lt;code&gt;FairSync&lt;/code&gt;、&lt;code&gt;NonfairSync&lt;/code&gt;类源码即可。&lt;/p&gt;&lt;p&gt;目前AQS的实现类如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.23671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jOD3PUUxTibM3cQxJhUk2t7fia7oyJ6UQWGGHBSpIUIWM6F4YM2MJyoc70D6kPoL7lPIgCbfH6jKENGwgMvic9LHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;state状态更新&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;AQS实现类中，必不可少的要对同步状态state进行更改，如果想线程安全的更新数据，只有通过锁或者CAS机制来保证，由于AQS是实现锁的底层组件，因此这里只能使用CAS机制来保证，AQS确实也是这么做的。AQS提供了2个方法来更新状态，&lt;code&gt;compareAndSetState(int expect,int update)&lt;/code&gt;和&lt;code&gt;setState(int newState)&lt;/code&gt;，后者只有在当前线程是状态占用线程下才能被调用。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;子类推荐被定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLatch等）。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;AQS是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解二者之间的关系：&lt;strong&gt;锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域&lt;/strong&gt;。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;同步队列维护&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;如果线程更新状态（tryAcquire）成功，直接返回。&lt;/p&gt;&lt;p&gt;如果更细状态失败，则会初始化一个当前的Node对象，CAS设置到同步队列tail。注意队列head、tail节点是懒初始化的。&lt;/p&gt;&lt;p&gt;注意，&lt;strong&gt;添加Node对象到同步队列中还不够，因为可能这个时候之前占用状态的线程已经释放状态了，或者后续占用状态的线程释放时，应该怎么下一个节点线程呢&lt;/strong&gt;？这里就涉及到再次&lt;code&gt;tryAcquire&lt;/code&gt;或者设置当前阻塞Node前一个Node的&lt;code&gt;waitStatus&lt;/code&gt;，具体代码可参考方法&lt;code&gt;java.util.concurrent.locks.AbstractQueuedSynchronizer#acquireQueued&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jOD3PUUxTibM3cQxJhUk2t7fia7oyJ6UQWibuYDia7boSfbicviaOjqnwxpSwTafTVCx9TsjRNC5ibX36yyTdtNEKqIvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;span&gt;最后就是调用方法&lt;/span&gt;&lt;code&gt;LockSupport.park(this)&lt;/code&gt;&lt;span&gt;来阻塞当前线程。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;源码分析&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;了解了AQS的state和同步队列后，下面来以类&lt;code&gt;ReentrantLock&lt;/code&gt;中&lt;code&gt;FairSync&lt;/code&gt;为例来分析AQS流程，示例代码如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ReentrantLock lock = &lt;span&gt;new&lt;/span&gt; ReentrantLock();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;        lock.lock();&lt;br/&gt;        System.out.println(Thread.currentThread().getName() + &lt;span&gt;&quot; lock ok&quot;&lt;/span&gt;);&lt;br/&gt;        lock.unlock();&lt;br/&gt;    }, &lt;span&gt;&quot;t1&quot;&lt;/span&gt;).start();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;        lock.lock();&lt;br/&gt;        System.out.println(Thread.currentThread().getName() + &lt;span&gt;&quot; lock ok&quot;&lt;/span&gt;);&lt;br/&gt;        lock.unlock();&lt;br/&gt;    }, &lt;span&gt;&quot;t2&quot;&lt;/span&gt;).start();&lt;br/&gt;&lt;br/&gt;    LockSupport.park();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;FairSync&lt;/code&gt;源码如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    acquire(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 尝试获取状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;tryAcquire&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; acquires)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; Thread current = Thread.currentThread();&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; c = getState();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (c == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;// cas设置state&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (!hasQueuedPredecessors() &amp;amp;&amp;amp;&lt;br/&gt;            compareAndSetState(&lt;span&gt;0&lt;/span&gt;, acquires)) {&lt;br/&gt;            setExclusiveOwnerThread(current);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (current == getExclusiveOwnerThread()) {&lt;br/&gt;           &lt;span&gt;// 可重入&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; nextc = c + acquires;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (nextc &amp;lt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error(&lt;span&gt;&quot;Maximum lock count exceeded&quot;&lt;/span&gt;);&lt;br/&gt;        setState(nextc);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;lock操作&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;lock操作也就是执行&lt;code&gt;acquire(1)&lt;/code&gt;，首先尝试获取锁成功直接返回，失败初始化一个Node放入阻塞队列，然后阻塞自己。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;acquire&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 尝试获取锁成功直接返回&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 失败创建Node放入同步队列&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!tryAcquire(arg) &amp;amp;&amp;amp;&lt;br/&gt;        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))&lt;br/&gt;        selfInterrupt();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;addWaiter(Node.EXCLUSIVE)&lt;/code&gt;就是将初始化的Node CAS放到tail处，不再赘述，重点看下&lt;code&gt;acquireQueued&lt;/code&gt;逻辑。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;acquireQueued&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; Node node, &lt;span&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;boolean&lt;/span&gt; failed = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;boolean&lt;/span&gt; interrupted = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;            &lt;span&gt;// 如果pre是头节点，再次尝试获取锁&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;final&lt;/span&gt; Node p = node.predecessor();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {&lt;br/&gt;                setHead(node);&lt;br/&gt;                p.next = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;// help GC&lt;/span&gt;&lt;br/&gt;                failed = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; interrupted;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;// 否则需要变更waitStatus，然后阻塞自己，等待占用state的线程来唤醒自己&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;&lt;br/&gt;                parkAndCheckInterrupt())&lt;br/&gt;                interrupted = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (failed)&lt;br/&gt;            cancelAcquire(node);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Node的&lt;code&gt;waitStatus&lt;/code&gt;有以下几种类型，其中要注意SIGNAL时表示当前线程需要唤醒下一个阻塞的节点线程：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/** waitStatus value to indicate thread has cancelled */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CANCELLED =  &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;/** waitStatus value to indicate successor&#x27;s thread needs unparking */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SIGNAL    = -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;/** waitStatus value to indicate thread is waiting on condition */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CONDITION = -&lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * waitStatus value to indicate the next acquireShared should&lt;br/&gt; * unconditionally propagate&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PROPAGATE = -&lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;unlock操作&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;unlock操作就是lock的逆操作，相对来说比较简单，AQS的realase源码如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;release&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (tryRelease(arg)) {&lt;br/&gt;        Node h = head;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (h != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; h.waitStatus != &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;            unparkSuccessor(h);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;tryRelease(arg)就是当前state重置为0，然后判断同步队列头结点，如果非空并且&lt;code&gt;waitStatus!=0&lt;/code&gt;则进行唤醒下一个节点操作，源码如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;unparkSuccessor&lt;/span&gt;&lt;span&gt;(Node node)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; ws = node.waitStatus;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (ws &amp;lt; &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;        compareAndSetWaitStatus(node, ws, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;     * 找到下一个可以待唤醒的节点&lt;br/&gt;     * waitStatus&amp;gt;0表示当前线程已经处于唤醒状态了，比如异常或者等待超时&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    Node s = node.next;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (s == &lt;span&gt;null&lt;/span&gt; || s.waitStatus &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        s = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (Node t = tail; t != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; t != node; t = t.prev)&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (t.waitStatus &amp;lt;= &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;                s = t;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (s != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;        LockSupport.unpark(s.thread);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;最后执行unpark之后，同步队列中第一个阻塞的线程就被唤醒，可以尝试更新状态了。关于&lt;code&gt;LockSupport.unpark&lt;/code&gt;这块具体可以参考&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwNTI2ODY5OA==&amp;amp;mid=2649939162&amp;amp;idx=1&amp;amp;sn=c4425d174656adcf5b6959cfff7fe815&amp;amp;chksm=8f350f6fb84286794bf4fb19394534d00c8f47a2caf3c14c8720f4d45e2f3de0a26111faf0e4&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;为什么说LockSupport是Java并发的基石？&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9ef821e2f9e77b765d4f428c583cfd55</guid>
<title>JVM 进阶之路（六）：垃圾收集理论和算法</title>
<link>https://toutiao.io/k/65w6bft</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODE5ODM0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeFt08hV3N1706WTzfhoTNoXm5LXRV0XibppmeNR4zSNMa3QOJJ7ib4O21P5yohibwuD26Tp9ETWZAqA/0?wx_fmt=png&quot; data-nickname=&quot;三分恶&quot; data-alias=&quot;Fighter3FullStack&quot; data-signature=&quot;一个全栈开发。分享Java后端、Web前端、计算机基础知识。&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面我们了解了虚拟机如何判断对象可回收，接下来我们了解Java虚拟机垃圾收集的一些理论和算法。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、分代收集理论&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分代收集理论，是基于程序运行对象存活数量和对象年龄之间关系的一套经验法则。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3510928961748634&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdw9WYSDOhrgibnO5QllPRlfDdraYtCw9KMHjT3JGAS28bfDlJgCoGfUkJibrGAph7KiaJ3MyibyGReqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;存活对象数量与年龄的关系&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它建立在两个分代假说之上：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「弱分代假说（Weak Generational Hypothesis）」&lt;/strong&gt;：绝大多数对象都是朝生夕灭的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「强分代假说（Strong Generational Hypothesis）」&lt;/strong&gt;：熬过越多次垃圾收集过程的对象就越难以消亡。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用通俗的话总结：大部分污渍很容易擦干净，多次擦都没擦干净的无责越来越难擦干净。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于这个理论，收集器将Java堆划分出不同的区域，然后将回收对象按照年龄分配到不同的区域存储。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体来讲，就是把Java堆划分为&lt;strong&gt;「新生代 （Young Generation）&lt;strong&gt;「和」&lt;/strong&gt;老年代（Old Generation）两个区域」&lt;/strong&gt;，新生代存放存活时间短的对象，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34916201117318435&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdw9WYSDOhrgibnO5QllPRlfu2f72oeUHol1TFCbcRta35kSWDGRng9niaG1lAF62TIbStPb2dyJ7icQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;716&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Java堆内存划分&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于新生代的对象，可以只关注如何保留少量存活而不是去标记那些大量将要被回收的对象；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于老年代，可以降低垃圾收集频率，同时更加关注那些要消亡的对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了降低垃圾回收的代价，在新生代和老年代采用了不同的垃圾收集算法。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;基于分代，产生了一些垃圾收集的类型划分：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;部分收集（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、垃圾收集算法&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1、标记-清除算法&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;见名知义，&lt;code&gt;标记-清除&lt;/code&gt;（Mark-Sweep）算法分为两个阶段：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「标记」&lt;/strong&gt; : 标记出所有需要回收的对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「清除」&lt;/strong&gt;：回收所有被标记的对象&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7937158469945356&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdw9WYSDOhrgibnO5QllPRlfrd4T3yQialoOrQPpbPrPTrt3vhItsMxj1QCtVS1PLCGCGpRmEXibT9sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;标记-清除算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记-清除算法比较基础，但是主要存在两个缺点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记-清除算法主要用于老年代，因为老年代可回收的对象比较少。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2、标记-复制算法&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记-复制算法解决了标记-清除算法面对大量可回收对象时执行效率低的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过程也比较简单：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6407103825136612&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdw9WYSDOhrgibnO5QllPRlfWYNGgxOHicTggPykekVlcOlFwATKV0Y9gFlZPoHfqaCVvcssPZUSJmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;标记-复制算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种算法存在一个明显的缺点：一部分空间没有使用，存在空间的浪费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新生代垃圾收集主要采用这种算法，因为新生代的存活对象比较少，每次复制的只是少量的存活对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般虚拟机的具体实现不会采用1:1的比例划分，以HotSpot为例，HotSpot虚拟机将内存分为一块较大的Eden空间和两块较小的 Survivor空间，每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。默认Eden和Survivor的大小比例是8∶1。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.38868832731648617&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdw9WYSDOhrgibnO5QllPRlf8alIwAjmyiaf7Kc787LLiadm2E75mKxWTRXia3Bng6sWBcH2aWlvesxtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;831&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;新生代内存划分&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3、标记-整理算法&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了降低内存的消耗，引入一种针对性的算法：&lt;code&gt;标记-整理&lt;/code&gt;（Mark-Compact）算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9166666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdw9WYSDOhrgibnO5QllPRlfC3dJQEXkuG0NLlLoJ832a5aOgxdlrAplSzdvZwqIVCibWN4W237q0CQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;标记-整理算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记-整理算法主要用于老年代，在老年代这种大量对象存活的区域，移动对象是个很大的负担，而且这种对象移动操作必须全程暂停用户应用程序（Stop The World）才能进行。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;big&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【1】：周志朋编著《深入理解Java虚拟机：JVM高级特性与最佳实践》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【2】：Java 虚拟机系列二：垃圾收集机制详解，动图帮你理解&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【3】：极客时间《深入拆解Java虚拟机》&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;系列文章：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247485301&amp;amp;idx=1&amp;amp;sn=f1ffc220318c4cc4f4c93f57d726a6e2&amp;amp;chksm=c0ccefd0f7bb66c6c69d33660d9661ad71e65f4f71f41966a4a7c2fb876430eca06570793b56&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;【JVM进阶之路】一：Java虚拟机概览&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247485354&amp;amp;idx=1&amp;amp;sn=97a8f73bbeda01cbb2959aa02b391f13&amp;amp;chksm=c0ccef0ff7bb66195c15e76019478f73549ce6a9ca31ff403669d5832b21b9430e8252560ec1&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;【JVM进阶之路】二：Java内存区域&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247485367&amp;amp;idx=1&amp;amp;sn=2d8693335a5d78efe0fbeaa10afa8208&amp;amp;chksm=c0ccef12f7bb66045d459010d67f567ec11ee0499589a5ccd89d772aeaffbdd1872f1cfea238&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;【JVM进阶之路】三：探究虚拟机对象&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247485412&amp;amp;idx=1&amp;amp;sn=bcb6805623c744a37a42157d8eaa64a1&amp;amp;chksm=c0ccef41f7bb6657f8719b9d55759b2766d8fed1223699d9ec0c8655cd5d388600a5299615b3&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;【JVM进阶之路】四：直面内存溢出和内存泄漏&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247485433&amp;amp;idx=1&amp;amp;sn=d849e82b09c3831a2069a12765159c09&amp;amp;chksm=c0ccef5cf7bb664ac93bd7ee8fc14866a05f920b4f1f1184630818a318cde91121c580ea4182&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;【JVM进阶之路】五：垃圾回收概述和对象回收判定&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODE5ODM0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeFt08hV3N1706WTzfhoTNoXm5LXRV0XibppmeNR4zSNMa3QOJJ7ib4O21P5yohibwuD26Tp9ETWZAqA/0?wx_fmt=png&quot; data-nickname=&quot;三分恶&quot; data-alias=&quot;Fighter3FullStack&quot; data-signature=&quot;一个全栈开发。分享Java后端、Web前端、计算机基础知识。&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;211&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBLml8yqRnW8SzBIzu9h5RZaLdMfqqUt3mXMbX3bO0nu0FyfqotEfYm56F1xTqoqsmrQn3icGJ6Dw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>