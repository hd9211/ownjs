<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3d118c2e31438a47014e34138dfd3c44</guid>
<title>精通那么多技术，你为何还是受不到重用？| 码农周刊第 324 期</title>
<link>https://toutiao.io/k/3ininot</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;精通那么多技术，你为何还是受不到重用？| 码农周刊第 324 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第324期（2020-11-11）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3240&quot; target=&quot;_blank&quot;&gt;双十一，买它买它买它！&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3240&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_324.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;基于 Kubernetes 的云原生批量计算平台&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;对以 Transformer 为基础的序列特征提取器 (Encoder) 和自回归的序列解码器 (Decoder) 做了深度优化&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;技术雷达是 ThoughtWorks 每半年发布一次的技术趋势报告&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;这是德勤第 11 年发布技术趋势年度报告&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;个人经历&lt;/p&gt;
        
        &lt;p&gt;你知道吗？&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验总结&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;欢迎探讨&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;欢迎探讨&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;适合入门&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        
        &lt;p&gt;深入探讨&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;基于 Swift 推出的函数响应框架&lt;/p&gt;
        
        &lt;p&gt;使用 JavaScript 来自动化 iOS&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;实践总结&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;细致讲解&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;7年工作经验，技术总监&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 451915 即可&lt;/p&gt;
        
        &lt;p&gt;坚持原创，持续分享技术，包括但不限于：分布式、微服务架构，spring cloud、Dubbo微服务框架，Java核心技术，Redis缓存、Kafka消息队列中间件等。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 450130 即可&lt;/p&gt;
        
        &lt;p&gt;一个工作10年的程序猿，分享技术干货及内心的声音。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 413084 即可&lt;/p&gt;
        
        &lt;p&gt;详解数据结构与算法&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 142771 即可&lt;/p&gt;
        
        &lt;p&gt;Web前端、服务端、小程序、App、学习资料、工具、资讯&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 125297 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=20115&amp;amp;url=http%3A%2F%2Fproduct.dangdang.com%2F29132383.html&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/book_324.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;一个技术总监的忠告&lt;/p&gt;
        
        &lt;p&gt;写作不易&lt;/p&gt;
        
        &lt;p&gt;同理心&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f2aeeebad9674e92e91b58254d21afe8</guid>
<title>独立开发者因为广告拦截被优酷索赔 100 万</title>
<link>https://toutiao.io/k/z19oawm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;我是一名独立开发者，目前全职维护&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.xbext.com/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;X浏览器&lt;/a&gt;的这款产品，可能有的小伙伴使用或听说过这款小众浏览器产品。X浏览器刚刚上线的时候，就遭遇到一次灭顶之灾，参见文章&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.jianshu.com/p/d222ea914f14&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《猎豹清理大师值得我们信任吗?》&lt;/a&gt;。作为无助的独立开发者，我只能再次通过写文章为自己发声，希望得到大家的支持。&lt;/p&gt;&lt;p&gt;事情是这样的，经过几年的迭代X浏览器这款小众浏览器在圈内还算有些小口碑，作为作者我也是一直保持初心，希望能够做一款干净整洁的良心产品。却不曾想兢兢业业的维护一款良心产品却也能给自己招来巨大的麻烦。去年11月份左右，突然接到了来自海淀法院的传票和一大堆所谓X浏览器侵权的证据材料以及索赔100万的诉求。平生第一次接到法院传票，面对足厚厚的证据材料，以为经历了很多可以从容面对很多事情了，面临这样的阵式还是毫无悬念的进入了懵逼状态。（其实现在才想起来，这其实是律师代理人的一种策略，他们的目的就是提供一大堆材料抛给你，先不管有用没有但是足够吓唬人，让你失去方寸，乱了阵脚。足有一尺多厚的材料要是每页都看的话足够你啃一星期的）。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-1033c8a65e5f2890d5e13c3fc8af6032_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1512&quot; data-rawheight=&quot;2016&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-1033c8a65e5f2890d5e13c3fc8af6032_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1512&quot; data-rawheight=&quot;2016&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-1033c8a65e5f2890d5e13c3fc8af6032_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-1033c8a65e5f2890d5e13c3fc8af6032_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;毕竟无论是创业还是作为独立开发者，这几年也经历了这样那样的奇葩事件。我很快从懵逼状态中冷静了过来，俗话说不做亏心事不怕鬼敲门。我在慌什么？做产品这么几年，保持初心，没有做过有损用户利益的事情，也没有说踩着其他产品上位的行为，甚至没有说过一次竞争对手不好。安安静静的做一款好产品会有错吗？最重要的我依然相信这个世界的美好，我笃定法官和法院会做到公平公正。 &lt;/p&gt;&lt;p&gt;优酷起诉我的理由是因为浏览器的广告拦截功能，拦截了优酷视频的片前广告。违反了《反不正当竞争》法。 说实话，我是在接到来自优酷的起诉书后才知道，X浏览器竟然可以拦截优酷视频的片前广告。查明原因后才知道由于X浏览器使用了著名的&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//adblockplus.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ABP&lt;/a&gt;规则源，规则中存在对优酷视频片前广告进行拦截的规则。&lt;/p&gt;&lt;p&gt;=======================  分割线 ============================&lt;/p&gt;&lt;p&gt;您现在看的的这段是经过修改过的文字，移除了对优酷本身体验上的一些看法和主观评价。我承认一开始写文章的时候带有很多的情绪化和主观判断的语言，感谢广大网友指出我的问题，经过了一夜。我觉得确实需要理性一些，宣泄个人情绪确毫无意义。优酷无论怎样我是没有权利拦截对方的广告的。这里对优酷本身的评价和主观判断，我已经删除，并抱歉对其造成的不良影响。&lt;/p&gt;&lt;p&gt;下面是我需要澄清的一些事实以及我的想法，希望能够在这些问题上听听大家的看法和建议。以及如何把损失降到最小。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;针对广告拦截，确实X浏览器的重要功能之一，但X浏览器的定位只是要做好一个浏览器工具，尽可能的兼容网络上的一些拦截规则，并未对某个网站有针对性，所以能够拦截优酷的广告，作者事先是不知情的，直到被起诉的哪天才知道。查明原因后发现拦截优酷视频片前广告的规则来自于ABP规则源，我目前已经把优酷加入了白名单。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;2. 不同于PC浏览器作为视频网站的主要入口，X浏览器只是一个单独的移动浏览器，而在移动端优酷最大的入口是其自身的客户端产品。两个产品几乎不存在交集，能否造成不正当竞争我个人感觉还是有待商榷的。&lt;/p&gt;&lt;p&gt;3. X浏览器是一个非常小众的浏览器产品，用户数量也不多，对方代理律师在没有任何证据有用户通过X浏览器访问优酷视频服务，并对其造成了损失。这100万的诉讼请求从而来？对方代理律师仅仅通过X浏览器的下载量就可以计算这个损失吗？ X浏览器访问网站是有自身的标识的，本着谁主张谁举证的原则，优酷方本来是有能力提供X浏览器的访问证据的，不通过确凿的证据而只是一个不太能说明问题的下载量就可以索要赔款了吗？&lt;/p&gt;&lt;p&gt;4.  广告拦截几乎是所以浏览器的标配，并且很多浏览器是默认开启广告拦截的。而X浏览器是默认关闭了广告拦截功能，用户需要自行开启。  宣传广告拦截这个卖点会被定义为恶意诱导用户开启广告拦截吗？意思说可以存在这个功能，但是你宣传这个功能卖点就不对了？&lt;/p&gt;&lt;p&gt;作为被告身份，我也是大姑娘出嫁人生头一遭啊，自己也完全不知道是啥流程。于是咨询了几个律师朋友，说明情况后，律师朋友的反馈却让刚刚平静的心情些的心情又起波澜。因为参考了几个由于广告拦截导致不正当竞争的案例，浏览器方均为败诉方，胜算的可能性很小。&lt;/p&gt;&lt;p&gt;也许是来自性格的偏执，也许因为未做亏心事坦然，也许是相信法律的公正公平。我决定不委托律师亲自直面这个事情，毕竟作为浏览器作者最直接的当事人，我认为自己是可以把事实表述清楚的。&lt;/p&gt;&lt;p&gt;疫情原因，案子一直拖到最近才开始审理，事实证明，我还是把事情想的过于简单了，在法官面前无论是表达方式和讲话技巧都是有讲究的，很明显我的表现并不够好，第一次置身于法庭之上未免有些紧张，一些关键的点未能表达清楚(讲的东西过于专业，法官根本听不懂)。而对方代理律师似乎深谙此道，故意给我安了一些莫须有的行为，使用“主观恶意”，“行为恶劣”，“诱导用户开启广告拦截”等明显不属实的表述成功激怒了我。最悲催的是，在案件的审理过程中，我也明显感受到了法官针对这类案件存在明显的倾向性，因为参照过去浏览器拦截广告的案例都是以浏览器方败诉告终。&lt;/p&gt;&lt;p&gt;下午3点开庭，确认完笔录已经6点钟了。可能是由于辩论过程中情绪有些激动，导致腹部隐隐作痛。离开审判庭的时候，法院已经几乎没有人了，最尴尬的是下楼的时候电梯间只有优酷代理律师和我两个人。不知出于什么心理，律师说道，这种案件的结果可能会和你想象的完全不一样，似乎是笃定我完全没有胜诉的希望，这一刻我突然明白，律师针对这类案件是已经有了固定模式套路，人家就是要靠抓住你的漏洞来挣钱的，没有胜算的官司人家也不会打啊。最可怕的是他们一天到晚泡在法院，法官也难免不受思维定式的影响。可是 保持初心，做一款良心产品我又做错什么了呢？我依然不能相信给我的回报是这样一个结果。我收敛了一下郁闷的表情，平静而坚定的说：没有关系，我已经做好了最坏的打算，败诉了我也要继续上诉  。。。&lt;/p&gt;&lt;p&gt;接下来的过程就是等待最终的判决书，我已经做好了最坏的打算，希望您在这里留下自己的看法和建议，欢迎大家参与讨论，是非对错由大家评判。只希望我的发声能引起法官和相关从业者的更多思考，感谢您的阅读和关注，后继的进展我会继续更新。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;========================  第二次更新  ===============================&lt;/p&gt;&lt;p&gt;首先感谢，大家的支持。很多网友私信我给我这里出谋划策，还给我转发一些参考资料，在这里表示感谢，还有很多网友开始给我捐助，搞的我怪不好意思的。大家放心，不至于经过这么一个案子就我就倾家荡产了，况且即使败诉，也不至于要赔偿100万。我维护这个软件还是有收益的，纯粹靠爱发电也不可能维护这么长时间，所以我宁愿是因为软件好用捐助，而不是因为这件事情。&lt;/p&gt;&lt;p&gt;另外，看到评论中有很多骂优酷的网友，我目前倒是比较理性了，刚开始确实因为情绪的问题，写了一些不太妥当的文字（已经删除）。所以大家最好还是讨论对待此事的看法和见解吧。 有一个问题我需要说明的是，通过我的亲身经历，我发现被优酷起诉这件事未必可能是优酷本身主导。面对我的律师并非优酷内部法务团队，代理律师和优酷签订的是分成模式的合作。换句话说，就是优酷不必事先支付律师费用，而是官司打赢以后从赔款中扣除即可，剩下的钱由律师和优酷分成。从这里也就不奇怪，为啥不是先给我递送律师函要求停止拦截优酷广告，而是直接递送法院传票要求赔偿损失了。因为赔偿才是重点，我不知道这是法律圈内的行规还是什么，这样看来这个官司貌似也并非是纯粹为了维护商业秩序作为出发点。&lt;/p&gt;&lt;p&gt;广告拦截这个事情，确实是很有争议性。作者本身并不鼓励拦截所有广告，毕竟广告是互联网中最直接的变现模式，也是站长赖以生存的手段。但是哪些广告可以拦哪些广告不能栏，我也无法很好的界定，所以开发拦截功能的时候始终是围绕如何做到性能更好，更好的兼容拦截规则来进行，没有想到竟然会招惹这样的大麻烦。 优酷代理律师抓住我在官方网站上宣传”广告拦截“这个功能，说是我存在明显的主观故意诱导用户使用”广告拦截“功能。 那么问题来了，“广告拦截”这个功能到底是不是合法功能呢？说不合法，每个浏览器都存在此功能，说合法，你又无法在你的产品描述中宣传。&lt;/p&gt;&lt;p/&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>eb906a13ef6140018cdc4ebd5769dad4</guid>
<title>Java 中 9 种常见的 CMS GC 问题分析与解决</title>
<link>https://toutiao.io/k/mlyha8z</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;了解大概什么原因后，如何定位和解决就很简单了，可以 dump 快照之后通过 JProfiler 或 MAT 观察 Classes 的 Histogram（&lt;/span&gt;&lt;span&gt;直方图&lt;/span&gt;&lt;span&gt;） 即可，或者直接通过命令即可定位， jcmd 打几次 Histogram 的图，看一下具体是哪个包下的 Class 增加较多就可以定位了。不过有时候也要结合InstBytes、KlassBytes、Bytecodes、MethodAll 等几项指标综合来看下。如下图便是笔者使用 jcmd 排查到一个 Orika 的问题。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;jcmd &amp;lt;PID&amp;gt; GC.class_stats|awk &#x27;{print$13}&#x27;|sed  &#x27;s/\(.*\)\.\(.*\)/\1/g&#x27;|sort |uniq -c|sort -nrk1&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.17981072555205047&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFayJzpZjA0ibzYr9NCJMgrsx3e5tLicASAjLLflmImMgTfcmtfOicAsnAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;如果无法从整体的角度定位，可以添加 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:+TraceClassLoading&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:+TraceClassUnLoading&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 参数观察详细的类加载和卸载信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4.3.4 小结&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原理理解比较复杂，但定位和解决问题会比较简单，经常会出问题的几个点有 Orika 的 classMap、JSON 的 ASMSerializer、Groovy 动态加载类等，基本都集中在反射、Javasisit 字节码增强、CGLIB 动态代理、OSGi 自定义类加载器等的技术点上。另外就是及时给 MetaSpace 区的使用率加一个监控，如果指标有波动提前发现并解决问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.4 场景四：过早晋升 * &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4.4.1 现象&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种场景主要发生在分代的收集器上面，专业的术语称为“Premature Promotion”。90% 的对象朝生夕死，只有在 Young 区经历过几次 GC 的洗礼后才会晋升到 Old 区，每经历一次 GC 对象的 GC Age 就会增长 1，最大通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:MaxTenuringThreshold&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来控制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;过早晋升一般不会直接影响 GC，总会伴随着浮动垃圾、大对象担保失败等问题，但这些问题不是立刻发生的，我们可以观察以下几种现象来判断是否发生了过早晋升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;分配速率接近于晋升速率&lt;/strong&gt;，对象晋升年龄较小。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;GC 日志中出现“Desired survivor size 107347968 bytes, &lt;strong&gt;new threshold 1(max 6)&lt;/strong&gt;”等信息，说明此时经历过一次 GC 就会放到 Old 区。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Full GC 比较频繁&lt;/strong&gt;，且经历过一次 GC 之后 Old 区的&lt;strong&gt;变化比例非常大&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如说 Old 区触发的回收阈值是 80%，经历过一次 GC 之后下降到了 10%，这就说明 Old 区的 70% 的对象存活时间其实很短，如下图所示，Old 区大小每次 GC 后从 2.1G 回收到 300M，也就是说回收掉了 1.8G 的垃圾，只有 &lt;strong&gt;300M 的活跃对象&lt;/strong&gt;。整个 Heap 目前是 4G，活跃对象只占了不到十分之一。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3925845147219193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFHDZHUjKX9Dtz7VrxC55B3ao4SJian1pe8yf0xptDICJEzMaXYz4Ewmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;917&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;过早晋升的危害：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Young GC 频繁，总的吞吐量下降。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Full GC 频繁，可能会有较大停顿。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;4.4.2 原因&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要的原因有以下两点：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Young/Eden 区过小：&lt;/strong&gt;过小的直接后果就是 Eden 被装满的时间变短，本应该回收的对象参与了 GC 并晋升，Young GC 采用的是复制算法，由基础篇我们知道 copying 耗时远大于 mark，也就是 Young GC 耗时本质上就是 copy 的时间（&lt;/span&gt;&lt;span&gt;CMS 扫描 Card Table 或 G1 扫描 Remember Set 出问题的情况另说&lt;/span&gt;&lt;span&gt;），没来及回收的对象增大了回收的代价，所以 Young GC  时间增加，同时又无法快速释放空间，Young GC 次数也跟着增加。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;分配速率过大：&lt;/strong&gt;可以观察出问题前后 Mutator 的分配速率，如果有明显波动可以尝试观察网卡流量、存储类中间件慢查询日志等信息，看是否有大量数据被加载到内存中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;同时无法 GC 掉对象还会带来另外一个问题，引发动态年龄计算：JVM 通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:MaxTenuringThreshold&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 参数来控制晋升年龄，每经过一次 GC，年龄就会加一，达到最大年龄就可以进入 Old 区，最大值为 15（&lt;/span&gt;&lt;span&gt;因为 JVM 中使用 4 个比特来表示对象的年龄&lt;/span&gt;&lt;span&gt;）。设定固定的 MaxTenuringThreshold 值作为晋升条件：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;MaxTenuringThreshold 如果设置得过大，原本应该晋升的对象一直停留在 Survivor 区，直到 Survivor 区溢出，一旦溢出发生，Eden + Survivor 中对象将不再依据年龄全部提升到 Old 区，这样对象老化的机制就失效了。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;MaxTenuringThreshold 如果设置得过小，过早晋升即对象不能在 Young 区充分被回收，大量短期对象被晋升到 Old 区，Old 区空间迅速增长，引起频繁的 Major GC，分代回收失去了意义，严重影响 GC 性能。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;相同应用在不同时间的表现不同，特殊任务的执行或者流量成分的变化，都会导致对象的生命周期分布发生波动，那么固定的阈值设定，因为无法动态适应变化，会造成和上面问题，所以 Hotspot 会使用动态计算的方式来调整晋升的阈值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体动态计算可以看一下 Hotspot 源码，具体在 /src/hotspot/share/gc/shared/ageTable.cpp 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;compute_tenuring_threshold&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法中：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;compute_tenuring_threshold&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) {&lt;br/&gt;  &lt;span&gt;//TargetSurvivorRatio默认50，意思是：在回收之后希望survivor区的占用率达到这个比例&lt;/span&gt;&lt;br/&gt;  size_t desired_survivor_size = (size_t)((((double) survivor_capacity)*TargetSurvivorRatio)/&lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;  size_t total = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  uint age = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  assert(sizes[&lt;span&gt;0&lt;/span&gt;] == &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;no objects with age zero should be recorded&quot;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (age &amp;lt; table_size) {&lt;span&gt;//table_size=16&lt;/span&gt;&lt;br/&gt;    total += sizes[age];&lt;br/&gt;    &lt;span&gt;//如果加上这个年龄的所有对象的大小之后，占用量&amp;gt;期望的大小，就设置age为新的晋升阈值&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (total &amp;gt; desired_survivor_size) &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    age++;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  uint result = age &amp;lt; MaxTenuringThreshold ? age : MaxTenuringThreshold;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (PrintTenuringDistribution || UsePerfData) {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//打印期望的survivor的大小以及新计算出来的阈值，和设置的最大阈值&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (PrintTenuringDistribution) {&lt;br/&gt;      gclog_or_tty-&amp;gt;cr();&lt;br/&gt;      gclog_or_tty-&amp;gt;print_cr(&lt;span&gt;&quot;Desired survivor size &quot;&lt;/span&gt; SIZE_FORMAT &lt;span&gt;&quot; bytes, new threshold %u (max %u)&quot;&lt;/span&gt;,&lt;br/&gt;        desired_survivor_size*oopSize, result, (int) MaxTenuringThreshold);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    total = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    age = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (age &amp;lt; table_size) {&lt;br/&gt;      total += sizes[age];&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (sizes[age] &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (PrintTenuringDistribution) {&lt;br/&gt;          gclog_or_tty-&amp;gt;print_cr(&lt;span&gt;&quot;- age %3u: &quot;&lt;/span&gt; SIZE_FORMAT_W(&lt;span&gt;10&lt;/span&gt;) &lt;span&gt;&quot; bytes, &quot;&lt;/span&gt; SIZE_FORMAT_W(&lt;span&gt;10&lt;/span&gt;) &lt;span&gt;&quot; total&quot;&lt;/span&gt;,&lt;br/&gt;                                        age,    sizes[age]*oopSize,          total*oopSize);&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (UsePerfData) {&lt;br/&gt;        _perf_sizes[age]-&amp;gt;set_value(sizes[age]*oopSize);&lt;br/&gt;      }&lt;br/&gt;      age++;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (UsePerfData) {&lt;br/&gt;      SharedHeap* sh = SharedHeap::heap();&lt;br/&gt;      CollectorPolicy* policy = sh-&amp;gt;collector_policy();&lt;br/&gt;      GCPolicyCounters* gc_counters = policy-&amp;gt;counters();&lt;br/&gt;      gc_counters-&amp;gt;tenuring_threshold()-&amp;gt;set_value(result);&lt;br/&gt;      gc_counters-&amp;gt;desired_survivor_size()-&amp;gt;set_value(&lt;br/&gt;        desired_survivor_size*oopSize);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;可以看到 Hotspot 遍历所有对象时，从所有年龄为 0 的对象占用的空间开始累加，如果加上年龄等于 n 的所有对象的空间之后，使用 Survivor 区的条件值（&lt;/span&gt;&lt;span&gt;TargetSurvivorRatio / 100，TargetSurvivorRatio 默认值为 50&lt;/span&gt;&lt;span&gt;）进行判断，若大于这个值则结束循环，将 n 和 MaxTenuringThreshold 比较，若 n 小，则阈值为 n，若 n 大，则只能去设置最大阈值为 MaxTenuringThreshold。&lt;strong&gt;动态年龄触发后导致更多的对象进入了 Old 区，造成资源浪费&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;4.4.3 策略&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;知道问题原因后我们就有解决的方向，如果是 &lt;strong&gt;Young/Eden 区过小&lt;/strong&gt;，我们可以在总的 Heap 内存不变的情况下适当增大 Young 区，具体怎么增加？一般情况下 Old 的大小应当为活跃对象的 2~3 倍左右，考虑到浮动垃圾问题最好在 3 倍左右，剩下的都可以分给 Young 区。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;拿笔者的一次典型过早晋升优化来看，原配置为 Young 1.2G + Old 2.8G，通过观察 CMS GC 的情况找到存活对象大概为 300~400M，于是调整 Old 1.5G 左右，剩下 2.5G 分给 Young 区。仅仅调了一个 Young 区大小参数（&lt;/span&gt;&lt;code&gt;&lt;span&gt;-Xmn&lt;/span&gt;&lt;/code&gt;&lt;span&gt;），整个 JVM 一分钟 Young GC 从 26 次降低到了 11 次，单次时间也没有增加，总的 GC 时间从 1100ms 降低到了 500ms，CMS GC 次数也从 40 分钟左右一次降低到了 7 小时 30 分钟一次。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.34178610804851156&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFnxFGw7OcJ1BZEyRZ4Ax4fZrJ6pPejxEpWTp64IVvOWKVeO7H0OOc9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;br/&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3404255319148936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFxUApAYSu0ymUGRoFbgTg7ibvTDQcjzXJrtdp43F4iav07MnTIT5hy6gA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;893&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;br/&gt;&lt;span&gt;如果是分配速率过大：&lt;/span&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.4.4 小结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;过早晋升问题一般不会特别明显，但日积月累之后可能会爆发一波收集器退化之类的问题，所以我们还是要提前避免掉的，可以看看自己系统里面是否有这些现象，如果比较匹配的话，可以尝试优化一下。一行代码优化的 ROI 还是很高的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果在观察 Old 区前后比例变化的过程中，发现可以回收的比例非常小，如从 80% 只回收到了 60%，说明我们大部分对象都是存活的，Old 区的空间可以适当调大些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.4.5 加餐&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于在调整 Young 与 Old 的比例时，如何选取具体的 NewRatio 值，这里将问题抽象成为一个蓄水池模型，找到以下关键衡量指标，大家可以根据自己场景进行推算。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4410726887791108&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFibiaDbSnXafbyDCLsKbFtSdrq9sHia3DPdw9Xes7QAH09YsfBd0znO8cw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;5668&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.1702857142857143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFariatlGZPAYYT7OzuzwlVjMFk5KWCxX5QiadqyjfOS7jMzdh5Sic5Y71Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1750&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;NewRatio 的值 r 与 v&lt;sub&gt;a&lt;/sub&gt;、v&lt;sub&gt;p&lt;/sub&gt;、v&lt;sub&gt;yc&lt;/sub&gt;、v&lt;sub&gt;oc&lt;/sub&gt;、r&lt;sub&gt;s&lt;/sub&gt; 等值存在一定函数相关性（&lt;/span&gt;&lt;span&gt;r&lt;sub&gt;s&lt;/sub&gt; 越小 r 越大、r 越小 v&lt;sub&gt;p&lt;/sub&gt; 越小，…，之前尝试使用 NN 来辅助建模，但目前还没有完全算出具体的公式，有想法的同学可以在评论区给出你的答案 &lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;总停顿时间 T  为 Young GC 总时间 T&lt;sub&gt;yc&lt;/sub&gt; 和 Old GC 总时间 T&lt;sub&gt;oc&lt;/sub&gt; 之和，其中 T&lt;sub&gt;yc&lt;/sub&gt; 与 v&lt;sub&gt;yc&lt;/sub&gt; 和 v&lt;sub&gt;p&lt;/sub&gt; 相关，T&lt;sub&gt;oc&lt;/sub&gt; 与 v&lt;sub&gt;oc&lt;/sub&gt;相关。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;忽略掉 GC 时间后，两次 Young GC 的时间间隔要大于 TP9999 时间，这样尽量让对象在 Eden 区就被回收，可以减少很多停顿。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.5 场景五：CMS Old GC 频繁 *&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.5.1 现象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Old 区频繁的做 CMS GC，但是每次耗时不是特别长，整体最大 STW 也在可接受范围内，但由于 GC 太频繁导致吞吐下降比较多。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.5.2 原因&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种情况比较常见，基本都是一次 Young GC 完成后，负责处理 CMS GC 的一个后台线程 concurrentMarkSweepThread 会不断地轮询，使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;shouldConcurrentCollect()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法做一次检测，判断是否达到了回收条件。如果达到条件，使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;collect_in_background()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 启动一次 Background 模式 GC。轮询的判断是使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;sleepBeforeNextCycle()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法，间隔周期为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:CMSWaitDuration&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 决定，默认为2s。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体代码在：src/hotspot/share/gc/cms/concurrentMarkSweepThread.cpp。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;run_service()&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;void ConcurrentMarkSweepThread::run_service() {&lt;br/&gt;  assert(this == cmst(), &lt;span&gt;&quot;just checking&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (BindCMSThreadToCPU &amp;amp;&amp;amp; !os::bind_to_processor(CPUForCMSThread)) {&lt;br/&gt;    log_warning(gc)(&lt;span&gt;&quot;Couldn&#x27;t bind CMS thread to processor &quot;&lt;/span&gt; UINTX_FORMAT, CPUForCMSThread);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (!should_terminate()) {&lt;br/&gt;    sleepBeforeNextCycle();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (should_terminate()) &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    GCIdMark gc_id_mark;&lt;br/&gt;    GCCause::Cause cause = _collector-&amp;gt;_full_gc_requested ?&lt;br/&gt;      _collector-&amp;gt;_full_gc_cause : GCCause::_cms_concurrent_mark;&lt;br/&gt;    _collector-&amp;gt;collect_in_background(cause);&lt;br/&gt;  }&lt;br/&gt;  verify_ok_to_terminate();&lt;br/&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;sleepBeforeNextCycle()&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; ConcurrentMarkSweepThread::sleepBeforeNextCycle() {&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (!should_terminate()) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;CMSWaitDuration&lt;/span&gt; &amp;gt;= &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;// Wait until the next synchronous GC, a concurrent full gc&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// request or a timeout, whichever is earlier.&lt;/span&gt;&lt;br/&gt;      wait_on_cms_lock_for_scavenge(&lt;span&gt;CMSWaitDuration&lt;/span&gt;);&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// Wait until any cms_lock event or check interval not to call shouldConcurrentCollect permanently&lt;/span&gt;&lt;br/&gt;      wait_on_cms_lock(&lt;span&gt;CMSCheckInterval&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// Check if we should start a CMS collection cycle&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (_collector-&amp;gt;shouldConcurrentCollect()) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// .. collection criterion not yet met, let&#x27;s go back&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// and wait some more&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;判断是否进行回收的代码在：/src/hotspot/share/gc/cms/concurrentMarkSweepGeneration.cpp。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;shouldConcurrentCollect()&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;bool CMSCollector::shouldConcurrentCollect() {&lt;br/&gt;  LogTarget(Trace, gc) log;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (_full_gc_requested) {&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;CMSCollector: collect because of explicit  gc request (or GCLocker)&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  FreelistLocker x(this);&lt;br/&gt;  &lt;span&gt;// ------------------------------------------------------------------&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// Print out lots of information which affects the initiation of&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// a collection.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (log.is_enabled() &amp;amp;&amp;amp; stats().valid()) {&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;CMSCollector shouldConcurrentCollect: &quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    LogStream out(log);&lt;br/&gt;    stats().print_on(&amp;amp;out);&lt;br/&gt;&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;time_until_cms_gen_full %3.7f&quot;&lt;/span&gt;, stats().time_until_cms_gen_full());&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;free=&quot;&lt;/span&gt; SIZE_FORMAT, _cmsGen-&amp;gt;free());&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;contiguous_available=&quot;&lt;/span&gt; SIZE_FORMAT, _cmsGen-&amp;gt;contiguous_available());&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;promotion_rate=%g&quot;&lt;/span&gt;, stats().promotion_rate());&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;cms_allocation_rate=%g&quot;&lt;/span&gt;, stats().cms_allocation_rate());&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;occupancy=%3.7f&quot;&lt;/span&gt;, _cmsGen-&amp;gt;occupancy());&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;initiatingOccupancy=%3.7f&quot;&lt;/span&gt;, _cmsGen-&amp;gt;initiating_occupancy());&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;cms_time_since_begin=%3.7f&quot;&lt;/span&gt;, stats().cms_time_since_begin());&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;cms_time_since_end=%3.7f&quot;&lt;/span&gt;, stats().cms_time_since_end());&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;metadata initialized %d&quot;&lt;/span&gt;, MetaspaceGC::should_concurrent_collect());&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// ------------------------------------------------------------------&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!UseCMSInitiatingOccupancyOnly) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (stats().valid()) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (stats().time_until_cms_start() == &lt;span&gt;0.0&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (_cmsGen-&amp;gt;occupancy() &amp;gt;= _bootstrap_occupancy) {&lt;br/&gt;        log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot; CMSCollector: collect for bootstrapping statistics: occupancy = %f, boot occupancy = %f&quot;&lt;/span&gt;,&lt;br/&gt;                  _cmsGen-&amp;gt;occupancy(), _bootstrap_occupancy);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (_cmsGen-&amp;gt;should_concurrent_collect()) {&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;CMS old gen initiated&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// We start a collection if we believe an incremental collection may fail;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// this is not likely to be productive in practice because it&#x27;s probably too&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// late anyway.&lt;/span&gt;&lt;br/&gt;  CMSHeap* heap = CMSHeap::heap();&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (heap-&amp;gt;incremental_collection_will_fail(&lt;span&gt;true&lt;/span&gt; &lt;span&gt;/* consult_young */&lt;/span&gt;)) {&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;CMSCollector: collect because incremental collection will fail &quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (MetaspaceGC::should_concurrent_collect()) {&lt;br/&gt;    log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;CMSCollector: collect for metadata allocation &quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// CMSTriggerInterval starts a CMS cycle if enough time has passed.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (CMSTriggerInterval &amp;gt;= &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (CMSTriggerInterval == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;// Trigger always&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Check the CMS time since begin (we do not check the stats validity&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// as we want to be able to trigger the first CMS cycle as well)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (stats().cms_time_since_begin() &amp;gt;= (CMSTriggerInterval / ((double) MILLIUNITS))) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (stats().valid()) {&lt;br/&gt;        log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;CMSCollector: collect because of trigger interval (time since last begin %3.7f secs)&quot;&lt;/span&gt;,&lt;br/&gt;                  stats().cms_time_since_begin());&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        log.&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;CMSCollector: collect because of trigger interval (first collection)&quot;&lt;/span&gt;);&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;分析其中逻辑判断是否触发 GC，分为以下几种情况：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大家可以看一下源码中的日志打印，通过日志我们就可以比较清楚地知道具体的原因，然后就可以着手分析了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.5.3 策略&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们这里还是拿最常见的达到回收比例这个场景来说，与过早晋升不同的是这些对象确实存活了一段时间，Survival Time 超过了 TP9999 时间，但是又达不到长期存活，如各种数据库、网络链接，带有失效时间的缓存等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;处理这种常规内存泄漏问题基本是一个思路，主要步骤如下：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.30910543130990414&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFLmnSudH7SxmugG2SKjAHfdtLxx3ibZh6sGAaqHnLebOVNECUBU9jKicA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;7512&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;Dump Diff 和 Leak Suspects 比较直观就不介绍了，这里说下其它几个关键点：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;内存 Dump：&lt;/strong&gt;使用 jmap、arthas 等 dump 堆进行快照时记得摘掉流量，同时&lt;strong&gt;分别在 CMS GC 的发生前后分别 dump 一次&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;分析 Top Component：&lt;/strong&gt;要记得按照对象、类、类加载器、包等多个维度观察 Histogram，同时使用 outgoing 和 incoming 分析关联的对象，另外就是 Soft Reference 和 Weak Reference、Finalizer 等也要看一下。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;分析 Unreachable：&lt;/strong&gt;重点看一下这个，关注下 Shallow 和 Retained 的大小。如下图所示，笔者之前一次 GC 优化，就根据 Unreachable Objects 发现了 Hystrix 的滑动窗口问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5316901408450704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyF5HBmxianlAngaW2SwUwgkNp1PUWAkia3HX9IxIdVG7YD8zUyBEzBRSPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;852&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.5.4 小结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过整个流程下来基本就能定位问题了，不过在优化的过程中记得使用&lt;strong&gt;控制变量&lt;/strong&gt;的方法来优化，防止一些会加剧问题的改动被掩盖。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.6 场景六：单次 CMS Old GC 耗时长 *&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.6.1 现象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CMS GC 单次 STW 最大超过 1000ms，不会频繁发生，如下图所示最长达到了 8000ms。某些场景下会引起“雪崩效应”，这种场景非常危险，我们应该尽量避免出现。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3243953732912723&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFMs1zibSgpvbLOX8UOKzykYavKgurJSkFAO17CZsLg5uWCDWKPw4SgAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1902&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.6.2 原因&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CMS 在回收的过程中，STW 的阶段主要是 Init Mark 和 Final Remark 这两个阶段，也是导致 CMS Old GC 最多的原因，另外有些情况就是在 STW 前等待 Mutator 的线程到达 SafePoint 也会导致时间过长，但这种情况较少，我们在此处主要讨论前者。发生收集器退化或者碎片压缩的场景请看场景七。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;想要知道这两个阶段为什么会耗时，我们需要先看一下这两个阶段都会干什么。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;核心代码都在 /src/hotspot/share/gc/cms/concurrentMarkSweepGeneration.cpp 中，内部有个线程 ConcurrentMarkSweepThread 轮询来校验，Old 区的垃圾回收相关细节被完全封装在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CMSCollector&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中，调用入口就是 ConcurrentMarkSweepThread 调用的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CMSCollector::collect_in_background&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;ConcurrentMarkSweepGeneration&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 调用的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CMSCollector::collect&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法，此处我们讨论大多数场景的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;collect_in_background&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。整个过程中会 STW 的主要是 initial Mark 和 Final Remark，核心代码在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;VM_CMS_Initial_Mark&lt;/span&gt;&lt;/code&gt;&lt;span&gt; / &lt;/span&gt;&lt;code&gt;&lt;span&gt;VM_CMS_Final_Remark&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中，执行时需要将执行权交由 VMThread 来执行。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;CMSCollector::checkpointRootsInitialWork()&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;void CMSCollector::checkpointRootsInitialWork() {&lt;br/&gt;  assert(SafepointSynchronize::is_at_safepoint(), &lt;span&gt;&quot;world should be stopped&quot;&lt;/span&gt;);&lt;br/&gt;  assert(_collectorState == InitialMarking, &lt;span&gt;&quot;just checking&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Already have locks.&lt;/span&gt;&lt;br/&gt;  assert_lock_strong(bitMapLock());&lt;br/&gt;  assert(_markBitMap.isAllClear(), &lt;span&gt;&quot;was reset at end of previous cycle&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Setup the verification and class unloading state for this&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// CMS collection cycle.&lt;/span&gt;&lt;br/&gt;  setup_cms_unloading_and_verification_state();&lt;br/&gt;&lt;br/&gt;  GCTraceTime(Trace, gc, phases) ts(&lt;span&gt;&quot;checkpointRootsInitialWork&quot;&lt;/span&gt;, _gc_timer_cm);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Reset all the PLAB chunk arrays if necessary.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (_survivor_plab_array != &lt;span&gt;NULL&lt;/span&gt; &amp;amp;&amp;amp; !CMSPLABRecordAlways) {&lt;br/&gt;    reset_survivor_plab_arrays();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  ResourceMark rm;&lt;br/&gt;  HandleMark  hm;&lt;br/&gt;&lt;br/&gt;  MarkRefsIntoClosure notOlder(_span, &amp;amp;_markBitMap);&lt;br/&gt;  CMSHeap* heap = CMSHeap::heap();&lt;br/&gt;&lt;br/&gt;  verify_work_stacks_empty();&lt;br/&gt;  verify_overflow_empty();&lt;br/&gt;&lt;br/&gt;  heap-&amp;gt;ensure_parsability(&lt;span&gt;false&lt;/span&gt;);  &lt;span&gt;// fill TLABs, but no need to retire them&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// Update the saved marks which may affect the root scans.&lt;/span&gt;&lt;br/&gt;  heap-&amp;gt;save_marks();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// weak reference processing has not started yet.&lt;/span&gt;&lt;br/&gt;  ref_processor()-&amp;gt;set_enqueuing_is_done(&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Need to remember all newly created CLDs,&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// so that we can guarantee that the remark finds them.&lt;/span&gt;&lt;br/&gt;  ClassLoaderDataGraph::remember_new_clds(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Whenever a CLD is found, it will be claimed before proceeding to mark&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// the klasses. The claimed marks need to be cleared before marking starts.&lt;/span&gt;&lt;br/&gt;  ClassLoaderDataGraph::clear_claimed_marks();&lt;br/&gt;&lt;br/&gt;  print_eden_and_survivor_chunk_arrays();&lt;br/&gt;&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (CMSParallelInitialMarkEnabled) {&lt;br/&gt;      &lt;span&gt;// The parallel version.&lt;/span&gt;&lt;br/&gt;      WorkGang* workers = heap-&amp;gt;workers();&lt;br/&gt;      assert(workers != &lt;span&gt;NULL&lt;/span&gt;, &lt;span&gt;&quot;Need parallel worker threads.&quot;&lt;/span&gt;);&lt;br/&gt;      uint n_workers = workers-&amp;gt;active_workers();&lt;br/&gt;&lt;br/&gt;      StrongRootsScope srs(n_workers);&lt;br/&gt;&lt;br/&gt;      CMSParInitialMarkTask tsk(this, &amp;amp;srs, n_workers);&lt;br/&gt;      initialize_sequential_subtasks_for_young_gen_rescan(n_workers);&lt;br/&gt;      &lt;span&gt;// If the total workers is greater than 1, then multiple workers&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// may be used at some time and the initialization has been set&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;// such that the single threaded path cannot be used.&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (workers-&amp;gt;total_workers() &amp;gt; &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;        workers-&amp;gt;run_task(&amp;amp;tsk);&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        tsk.work(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;      }&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// The serial version.&lt;/span&gt;&lt;br/&gt;      CLDToOopClosure cld_closure(&amp;amp;notOlder, &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;      heap-&amp;gt;rem_set()-&amp;gt;prepare_for_younger_refs_iterate(&lt;span&gt;false&lt;/span&gt;); &lt;span&gt;// Not parallel.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;      StrongRootsScope srs(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;      heap-&amp;gt;cms_process_roots(&amp;amp;srs,&lt;br/&gt;                             &lt;span&gt;true&lt;/span&gt;,   &lt;span&gt;// young gen as roots&lt;/span&gt;&lt;br/&gt;                             GenCollectedHeap::ScanningOption(roots_scanning_options()),&lt;br/&gt;                             should_unload_classes(),&lt;br/&gt;                             &amp;amp;notOlder,&lt;br/&gt;                             &amp;amp;cld_closure);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Clear mod-union table; it will be dirtied in the prologue of&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// CMS generation per each young generation collection.&lt;/span&gt;&lt;br/&gt;  assert(_modUnionTable.isAllClear(),&lt;br/&gt;       &lt;span&gt;&quot;Was cleared in most recent final checkpoint phase&quot;&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;&quot; or no bits are set in the gc_prologue before the start of the next &quot;&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;&quot;subsequent marking phase.&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  assert(_ct-&amp;gt;cld_rem_set()-&amp;gt;mod_union_is_clear(), &lt;span&gt;&quot;Must be&quot;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;// Save the end of the used_region of the constituent generations&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// to be used to limit the extent of sweep in each generation.&lt;/span&gt;&lt;br/&gt;  save_sweep_limits();&lt;br/&gt;  verify_overflow_empty();&lt;br/&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;CMSParInitialMarkTask::work&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;void CMSParInitialMarkTask::work(uint worker_id) {&lt;br/&gt;  elapsedTimer _timer;&lt;br/&gt;  ResourceMark rm;&lt;br/&gt;  HandleMark   hm;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// ---------- scan from roots --------------&lt;/span&gt;&lt;br/&gt;  _timer.start();&lt;br/&gt;  CMSHeap* heap = CMSHeap::heap();&lt;br/&gt;  ParMarkRefsIntoClosure par_mri_cl(_collector-&amp;gt;_span, &amp;amp;(_collector-&amp;gt;_markBitMap));&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// ---------- young gen roots --------------&lt;/span&gt;&lt;br/&gt;  {&lt;br/&gt;    work_on_young_gen_roots(&amp;amp;par_mri_cl);&lt;br/&gt;    _timer.stop();&lt;br/&gt;    log_trace(gc, task)(&lt;span&gt;&quot;Finished young gen initial mark scan work in %dth thread: %3.3f sec&quot;&lt;/span&gt;, worker_id, _timer.seconds());&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// ---------- remaining roots --------------&lt;/span&gt;&lt;br/&gt;  _timer.reset();&lt;br/&gt;  _timer.start();&lt;br/&gt;&lt;br/&gt;  CLDToOopClosure cld_closure(&amp;amp;par_mri_cl, &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  heap-&amp;gt;cms_process_roots(_strong_roots_scope,&lt;br/&gt;                          &lt;span&gt;false&lt;/span&gt;,     &lt;span&gt;// yg was scanned above&lt;/span&gt;&lt;br/&gt;                          GenCollectedHeap::ScanningOption(_collector-&amp;gt;CMSCollector::roots_scanning_options()),&lt;br/&gt;                          _collector-&amp;gt;should_unload_classes(),&lt;br/&gt;                          &amp;amp;par_mri_cl,&lt;br/&gt;                          &amp;amp;cld_closure,&lt;br/&gt;                          &amp;amp;_par_state_string);&lt;br/&gt;&lt;br/&gt;  assert(_collector-&amp;gt;should_unload_classes()&lt;br/&gt;         || (_collector-&amp;gt;CMSCollector::roots_scanning_options() &amp;amp; GenCollectedHeap::SO_AllCodeCache),&lt;br/&gt;         &lt;span&gt;&quot;if we didn&#x27;t scan the code cache, we have to be ready to drop nmethods with expired weak oops&quot;&lt;/span&gt;);&lt;br/&gt;  _timer.stop();&lt;br/&gt;  log_trace(gc, task)(&lt;span&gt;&quot;Finished remaining root initial mark scan work in %dth thread: %3.3f sec&quot;&lt;/span&gt;, worker_id, _timer.seconds());&lt;br/&gt;}&lt;/span&gt;&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;figure&gt;&lt;br/&gt;&lt;img data-ratio=&quot;0.0594059405940594&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFv4rUSNPUSNSp2Q9IEg8EZOON11moGRwucbkEXicWYHB0ZkynuQDYEPg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;7272&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;整个过程比较简单，从 GC Root 出发标记 Old 中的对象，处理完成后借助 BitMap 处理下 Young 区对 Old 区的引用，整个过程基本都比较快，很少会有较大的停顿。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;CMSCollector::checkpointRootsFinalWork()&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;void CMSCollector::checkpointRootsFinalWork() {&lt;br/&gt;  GCTraceTime(Trace, gc, phases) tm(&lt;span&gt;&quot;checkpointRootsFinalWork&quot;&lt;/span&gt;, _gc_timer_cm);&lt;br/&gt;&lt;br/&gt;  assert(haveFreelistLocks(), &lt;span&gt;&quot;must have free list locks&quot;&lt;/span&gt;);&lt;br/&gt;  assert_lock_strong(bitMapLock());&lt;br/&gt;&lt;br/&gt;  ResourceMark rm;&lt;br/&gt;  HandleMark   hm;&lt;br/&gt;&lt;br/&gt;  CMSHeap* heap = CMSHeap::heap();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (should_unload_classes()) {&lt;br/&gt;    CodeCache::gc_prologue();&lt;br/&gt;  }&lt;br/&gt;  assert(haveFreelistLocks(), &lt;span&gt;&quot;must have free list locks&quot;&lt;/span&gt;);&lt;br/&gt;  assert_lock_strong(bitMapLock());&lt;br/&gt;&lt;br/&gt;  heap-&amp;gt;ensure_parsability(&lt;span&gt;false&lt;/span&gt;);  &lt;span&gt;// fill TLAB&#x27;s, but no need to retire them&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// Update the saved marks which may affect the root scans.&lt;/span&gt;&lt;br/&gt;  heap-&amp;gt;save_marks();&lt;br/&gt;&lt;br/&gt;  print_eden_and_survivor_chunk_arrays();&lt;br/&gt;&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (CMSParallelRemarkEnabled) {&lt;br/&gt;      GCTraceTime(Debug, gc, phases) t(&lt;span&gt;&quot;Rescan (parallel)&quot;&lt;/span&gt;, _gc_timer_cm);&lt;br/&gt;      do_remark_parallel();&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      GCTraceTime(Debug, gc, phases) t(&lt;span&gt;&quot;Rescan (non-parallel)&quot;&lt;/span&gt;, _gc_timer_cm);&lt;br/&gt;      do_remark_non_parallel();&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  verify_work_stacks_empty();&lt;br/&gt;  verify_overflow_empty();&lt;br/&gt;&lt;br/&gt;  {&lt;br/&gt;    GCTraceTime(Trace, gc, phases) ts(&lt;span&gt;&quot;refProcessingWork&quot;&lt;/span&gt;, _gc_timer_cm);&lt;br/&gt;    refProcessingWork();&lt;br/&gt;  }&lt;br/&gt;  verify_work_stacks_empty();&lt;br/&gt;  verify_overflow_empty();&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (should_unload_classes()) {&lt;br/&gt;    CodeCache::gc_epilogue();&lt;br/&gt;  }&lt;br/&gt;  JvmtiExport::gc_epilogue();&lt;br/&gt;  assert(_markStack.isEmpty(), &lt;span&gt;&quot;No grey objects&quot;&lt;/span&gt;);&lt;br/&gt;  size_t ser_ovflw = _ser_pmc_remark_ovflw + _ser_pmc_preclean_ovflw +&lt;br/&gt;                     _ser_kac_ovflw        + _ser_kac_preclean_ovflw;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (ser_ovflw &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    log_trace(gc)(&lt;span&gt;&quot;Marking stack overflow (benign) (pmc_pc=&quot;&lt;/span&gt; SIZE_FORMAT &lt;span&gt;&quot;, pmc_rm=&quot;&lt;/span&gt; SIZE_FORMAT &lt;span&gt;&quot;, kac=&quot;&lt;/span&gt; SIZE_FORMAT &lt;span&gt;&quot;, kac_preclean=&quot;&lt;/span&gt; SIZE_FORMAT &lt;span&gt;&quot;)&quot;&lt;/span&gt;,&lt;br/&gt;                         _ser_pmc_preclean_ovflw, _ser_pmc_remark_ovflw, _ser_kac_ovflw, _ser_kac_preclean_ovflw);&lt;br/&gt;    _markStack.expand();&lt;br/&gt;    _ser_pmc_remark_ovflw = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    _ser_pmc_preclean_ovflw = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    _ser_kac_preclean_ovflw = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    _ser_kac_ovflw = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (_par_pmc_remark_ovflw &amp;gt; &lt;span&gt;0&lt;/span&gt; || _par_kac_ovflw &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;     log_trace(gc)(&lt;span&gt;&quot;Work queue overflow (benign) (pmc_rm=&quot;&lt;/span&gt; SIZE_FORMAT &lt;span&gt;&quot;, kac=&quot;&lt;/span&gt; SIZE_FORMAT &lt;span&gt;&quot;)&quot;&lt;/span&gt;,&lt;br/&gt;                          _par_pmc_remark_ovflw, _par_kac_ovflw);&lt;br/&gt;     _par_pmc_remark_ovflw = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    _par_kac_ovflw = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (_markStack._hit_limit &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;     log_trace(gc)(&lt;span&gt;&quot; (benign) Hit max stack size limit (&quot;&lt;/span&gt; SIZE_FORMAT &lt;span&gt;&quot;)&quot;&lt;/span&gt;,&lt;br/&gt;                          _markStack._hit_limit);&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (_markStack._failed_double &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;     log_trace(gc)(&lt;span&gt;&quot; (benign) Failed stack doubling (&quot;&lt;/span&gt; SIZE_FORMAT &lt;span&gt;&quot;), current capacity &quot;&lt;/span&gt; SIZE_FORMAT,&lt;br/&gt;                          _markStack._failed_double, _markStack.capacity());&lt;br/&gt;   }&lt;br/&gt;  _markStack._hit_limit = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  _markStack._failed_double = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; ((VerifyAfterGC || VerifyDuringGC) &amp;amp;&amp;amp;&lt;br/&gt;      CMSHeap::heap()-&amp;gt;total_collections() &amp;gt;= VerifyGCStartAt) {&lt;br/&gt;    verify_after_remark();&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  _gc_tracer_cm-&amp;gt;report_object_count_after_gc(&amp;amp;_is_alive_closure);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// Change under the freelistLocks.&lt;/span&gt;&lt;br/&gt;  _collectorState = Sweeping;&lt;br/&gt;  &lt;span&gt;// Call isAllClear() under bitMapLock&lt;/span&gt;&lt;br/&gt;  assert(_modUnionTable.isAllClear(),&lt;br/&gt;      &lt;span&gt;&quot;Should be clear by end of the final marking&quot;&lt;/span&gt;);&lt;br/&gt;  assert(_ct-&amp;gt;cld_rem_set()-&amp;gt;mod_union_is_clear(),&lt;br/&gt;      &lt;span&gt;&quot;Should be clear by end of the final marking&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;figure&gt;&lt;br/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.04205607476635514&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFI780KrHWsqJaWv13HdIoE5ZY2Nzr2Q0Jvtw6pIAcc9YgGg322Mib64w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;10272&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;Final Remark 是最终的第二次标记，这种情况只有在 Background GC 执行了 InitialMarking 步骤的情形下才会执行，如果是 Foreground GC 执行的 InitialMarking 步骤则不需要再次执行 FinalRemark。Final Remark 的开始阶段与 Init Mark 处理的流程相同，但是后续多了 Card Table 遍历、Reference 实例的清理并将其加入到 Reference 维护的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;pend_list&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中，如果要收集元数据信息，还要清理 SystemDictionary、CodeCache、SymbolTable、StringTable 等组件中不再使用的资源。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.6.3 策略&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;知道了两个 STW 过程执行流程，我们分析解决就比较简单了，由于大部分问题都出在 Final Remark 过程，这里我们也拿这个场景来举例，主要步骤：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;2019-02-27T19:55:37.920+0800: 516952.915: [GC (CMS Final Remark) 516952.915: [ParNew516952.939: [SoftReference, 0 refs, 0.0003857 secs]516952.939: [WeakReference, 1362 refs, 0.0002415 secs]516952.940: [FinalReference, 146 refs, 0.0001233 secs]516952.940: [PhantomReference, 0 refs, 57 refs, 0.0002369 secs]516952.940: [JNI Weak Reference, 0.0000662 secs]&lt;br/&gt;[&lt;span&gt;class unloading, 0.1770490 secs&lt;/span&gt;]516953.329: [&lt;span&gt;scrub symbol table, 0.0442567 secs&lt;/span&gt;]516953.373: [&lt;span&gt;scrub string table, 0.0036072 secs&lt;/span&gt;][&lt;span&gt;1 CMS-remark: 1638504K(2048000K)&lt;/span&gt;] 1667558K(4352000K), 0.5269311 secs] [Times: user=1.20 sys=0.03, real=0.53 secs]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;CMSCollector::refProcessingWork()&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; (should_unload_classes()) {&lt;br/&gt;    {&lt;br/&gt;      GCTraceTime(Debug, gc, phases) t(&lt;span&gt;&quot;Class Unloading&quot;&lt;/span&gt;, _gc_timer_cm);&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;//&lt;/span&gt; Unload classes &lt;span&gt;and&lt;/span&gt; purge the SystemDictionary.&lt;br/&gt;      bool purged_class = SystemDictionary::do_unloading(_gc_timer_cm);&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;//&lt;/span&gt; Unload nmethods.&lt;br/&gt;      CodeCache::do_unloading(&amp;amp;_is_alive_closure, purged_class);&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;//&lt;/span&gt; Prune dead klasses from subklass/sibling/implementor lists.&lt;br/&gt;      Klass::clean_weak_klass_links(purged_class);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    {&lt;br/&gt;      GCTraceTime(Debug, gc, phases) t(&lt;span&gt;&quot;Scrub Symbol Table&quot;&lt;/span&gt;, _gc_timer_cm);&lt;br/&gt;      &lt;span&gt;//&lt;/span&gt; Clean up unreferenced symbols &lt;span&gt;in&lt;/span&gt; symbol table.&lt;br/&gt;      SymbolTable::unlink();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    {&lt;br/&gt;      GCTraceTime(Debug, gc, phases) t(&lt;span&gt;&quot;Scrub String Table&quot;&lt;/span&gt;, _gc_timer_cm);&lt;br/&gt;      &lt;span&gt;//&lt;/span&gt; Delete entries &lt;span&gt;for&lt;/span&gt; dead interned strings.&lt;br/&gt;      StringTable::unlink(&amp;amp;_is_alive_closure);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;4.6.4 小结&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正常情况进行的 Background CMS GC，出现问题基本都集中在 Reference 和 Class 等元数据处理上，在 Reference 类的问题处理方面，不管是 FinalReference，还是 SoftReference、WeakReference 核心的手段就是找准时机 dump 快照，然后用内存分析工具来分析。Class 处理方面目前除了关闭类卸载开关，没有太好的方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 G1 中同样有 Reference 的问题，可以观察日志中的 Ref Proc，处理方法与 CMS 类似。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.7 场景七：内存碎片&amp;amp;收集器退化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4.7.1 现象&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;并发的 CMS GC 算法，退化为 Foreground 单线程串行 GC 模式，STW 时间超长，有时会长达十几秒。其中 CMS 收集器退化后单线程串行 GC 算法有两种：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4.7.2 原因&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CMS 发生收集器退化主要有以下几种情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;晋升失败（Promotion Failed）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;顾名思义，晋升失败就是指在进行 Young GC 时，Survivor 放不下，对象只能放入 Old，但此时 Old 也放不下。直觉上乍一看这种情况可能会经常发生，但其实因为有 concurrentMarkSweepThread 和担保机制的存在，发生的条件是很苛刻的，除非是短时间将 Old 区的剩余空间迅速填满，例如上文中说的动态年龄判断导致的过早晋升（&lt;/span&gt;&lt;span&gt;见下文的增量收集担保失败&lt;/span&gt;&lt;span&gt;）。另外还有一种情况就是内存碎片导致的 Promotion Failed，Young GC 以为 Old 有足够的空间，结果到分配时，晋级的大对象找不到连续的空间存放。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用 CMS 作为 GC 收集器时，运行过一段时间的 Old 区如下图所示，清除算法导致内存出现多段的不连续，出现大量的内存碎片。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.30515759312320917&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFG5mFRX6WWV6XQQUetlIykPfbyXGcib33ewvQ7x2La7w6Dr91NeicwaWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1396&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;碎片带来了两个问题：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;空间分配效率较低&lt;/strong&gt;：上文已经提到过，如果是连续的空间 JVM 可以通过使用 pointer bumping 的方式来分配，而对于这种有大量碎片的空闲链表则需要逐个访问 freelist 中的项来访问，查找可以存放新建对象的地址。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;空间利用效率变低&lt;/strong&gt;：Young 区晋升的对象大小大于了连续空间的大小，那么将会触发 Promotion Failed ，即使整个 Old 区的容量是足够的，但由于其不连续，也无法存放新对象，也就是本文所说的问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;增量收集担保失败&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分配内存失败后，会判断统计得到的 Young GC 晋升到 Old 的平均大小，以及当前 Young 区已使用的大小也就是最大可能晋升的对象大小，是否大于 Old 区的剩余空间。只要 CMS 的剩余空间比前两者的任意一者大，CMS 就认为晋升还是安全的，反之，则代表不安全，不进行Young GC，直接触发Full GC。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;显式 GC&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种情况参见场景二。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;并发模式失败（Concurrent Mode Failure）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后一种情况，也是发生概率较高的一种，在 GC 日志中经常能看到 Concurrent Mode Failure 关键字。这种是由于并发 Background CMS GC 正在执行，同时又有 Young GC 晋升的对象要放入到了 Old 区中，而此时 Old 区空间不足造成的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为什么 CMS GC 正在执行还会导致收集器退化呢？主要是由于 CMS 无法处理浮动垃圾（&lt;/span&gt;&lt;span&gt;Floating Garbage&lt;/span&gt;&lt;span&gt;）引起的。CMS 的并发清理阶段，Mutator 还在运行，因此不断有新的垃圾产生，而这些垃圾不在这次清理标记的范畴里，无法在本次 GC 被清除掉，这些就是浮动垃圾，除此之外在 Remark 之前那些断开引用脱离了读写屏障控制的对象也算浮动垃圾。所以 Old 区回收的阈值不能太高，否则预留的内存空间很可能不够，从而导致 Concurrent Mode Failure 发生。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4.7.3 策略&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分析到具体原因后，我们就可以针对性解决了，具体思路还是从根因出发，具体解决策略：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;内存碎片：&lt;/strong&gt;通过配置 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:UseCMSCompactAtFullCollection=true&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来控制 Full GC的过程中是否进行空间的整理（&lt;/span&gt;&lt;span&gt;默认开启，注意是Full GC，不是普通CMS GC&lt;/span&gt;&lt;span&gt;），以及 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX: CMSFullGCsBeforeCompaction=n&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来控制多少次 Full GC 后进行一次压缩。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;增量收集：&lt;/strong&gt;降低触发 CMS GC 的阈值，即参数 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:CMSInitiatingOccupancyFraction&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的值，让 CMS GC 尽早执行，以保证有足够的连续空间，也减少 Old 区空间的使用大小，另外需要使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:+UseCMSInitiatingOccupancyOnly&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来配合使用，不然 JVM 仅在第一次使用设定值，后续则自动调整。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;浮动垃圾：&lt;/strong&gt;视情况控制每次晋升对象的大小，或者缩短每次 CMS GC 的时间，必要时可调节 NewRatio 的值。另外就是使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:+CMSScavengeBeforeRemark&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 在过程中提前触发一次 Young GC，防止后续晋升过多对象。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;4.7.4 小结&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正常情况下触发并发模式的 CMS GC，停顿非常短，对业务影响很小，但 CMS GC 退化后，影响会非常大，建议发现一次后就彻底根治。只要能定位到内存碎片、浮动垃圾、增量收集相关等具体产生原因，还是比较好解决的，关于内存碎片这块，如果 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:CMSFullGCsBeforeCompaction&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的值不好选取的话，可以使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:PrintFLSStatistics&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来观察内存碎片率情况，然后再设置具体的值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后就是在编码的时候也要避免需要连续地址空间的大对象的产生，如过长的字符串，用于存放附件、序列化或反序列化的 byte 数组等，还有就是过早晋升问题尽量在爆发问题前就避免掉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.8 场景八：堆外内存 OOM&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4.8.1 现象&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;内存使用率不断上升，甚至开始使用 SWAP 内存，同时可能出现 GC 时间飙升，线程被 Block 等现象，&lt;strong&gt;通过 top 命令发现 Java 进程的 RES 甚至超过了 &lt;/strong&gt;&lt;strong&gt;&lt;code&gt;-Xmx&lt;/code&gt; 的大小&lt;/strong&gt;。出现这些现象时，基本可以确定是出现了堆外内存泄漏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4.8.2 原因&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;JVM 的堆外内存泄漏，主要有两种的原因：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4.8.3 策略&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;哪种原因造成的堆外内存泄漏？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，我们需要确定是哪种原因导致的堆外内存泄漏。这里可以使用 NMT（&lt;/span&gt;&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;NativeMemoryTracking&lt;/span&gt;&lt;/a&gt;&lt;span&gt;） 进行分析。在项目中添加 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:NativeMemoryTracking=detail&lt;/span&gt;&lt;/code&gt;&lt;span&gt; JVM参数后重启项目（&lt;/span&gt;&lt;span&gt;需要注意的是，打开 NMT 会带来 5%~10% 的性能损耗&lt;/span&gt;&lt;span&gt;）。使用命令 &lt;/span&gt;&lt;code&gt;&lt;span&gt;jcmd pid VM.native_memory detail&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 查看内存分布。重点观察 total 中的 committed，因为 jcmd 命令显示的内存包含堆内内存、Code 区域、通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Unsafe.allocateMemory&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;DirectByteBuffer&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 申请的内存，但是不包含其他 Native Code（&lt;/span&gt;&lt;span&gt;C 代码&lt;/span&gt;&lt;span&gt;）申请的堆外内存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果 total 中的 committed 和 top 中的 RES 相差不大，则应为主动申请的堆外内存未释放造成的，如果相差较大，则基本可以确定是 JNI 调用造成的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;原因一：主动申请未释放&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;JVM 使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:MaxDirectMemorySize=size&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 参数来控制可申请的堆外内存的最大值。在 Java 8 中，如果未配置该参数，默认和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-Xmx&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 相等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;NIO 和 Netty 都会取 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:MaxDirectMemorySize&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 配置的值，来限制申请的堆外内存的大小。NIO 和 Netty 中还有一个计数器字段，用来计算当前已申请的堆外内存大小，NIO 中是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;java.nio.Bits#totalCapacity&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、Netty 中 &lt;/span&gt;&lt;code&gt;&lt;span&gt;io.netty.util.internal.PlatformDependent#DIRECT_MEMORY_COUNTER&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当申请堆外内存时，NIO 和 Netty 会比较计数器字段和最大值的大小，如果计数器的值超过了最大值的限制，会抛出 OOM 的异常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;NIO 中是：&lt;/span&gt;&lt;code&gt;&lt;span&gt;OutOfMemoryError: Direct buffer memory&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Netty 中是：&lt;/span&gt;&lt;code&gt;&lt;span&gt;OutOfDirectMemoryError: failed to allocate  capacity  byte(s) of direct memory (used: usedMemory , max: DIRECT_MEMORY_LIMIT )&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以检查代码中是如何使用堆外内存的，NIO 或者是 Netty，通过反射，获取到对应组件中的计数器字段，并在项目中对该字段的数值进行打点，即可准确地监控到这部分堆外内存的使用情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此时，可以通过 Debug 的方式确定使用堆外内存的地方是否正确执行了释放内存的代码。另外，需要检查 JVM 的参数是否有 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:+DisableExplicitGC&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 选项，如果有就去掉，因为该参数会使 System.gc 失效。（&lt;/span&gt;&lt;span&gt;场景二：显式 GC 的去与留&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;原因二：通过 JNI 调用的 Native Code 申请的内存未释放&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种情况排查起来比较困难，我们可以通过 Google perftools + Btrace 等工具，帮助我们分析出问题的代码在哪里。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;gperftools 是 Google 开发的一款非常实用的工具集，它的原理是在 Java 应用程序运行时，当调用 malloc 时换用它的 libtcmalloc.so，这样就能对内存分配情况做一些统计。我们使用 gperftools 来追踪分配内存的命令。如下图所示，通过 gperftools 发现 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Java_java_util_zip_Inflater_init&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 比较可疑。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.42979002624671914&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFC0gawic22114sP8s5ATTBGCSbqDVRoBmM5VoXdPjibqRWy2XCeJaZhGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1524&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;接下来可以使用 Btrace，尝试定位具体的调用栈。Btrace 是 Sun 推出的一款 Java 追踪、监控工具，可以在不停机的情况下对线上的 Java 程序进行监控。如下图所示，通过 Btrace 定位出项目中的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;ZipHelper&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 在频繁调用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;GZIPInputStream&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ，在堆外内存分配对象。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.43343465045592705&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFo2v6fzLUrRJfvZ3iao7PTpfY3R5jFdc0yicq5icktmV5CjVP786rJqsLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1645&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;最终定位到是，项目中对 &lt;/span&gt;&lt;code&gt;&lt;span&gt;GIPInputStream&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的使用错误，没有正确的 close()。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2718720602069614&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFmFJoNUa6jLlVCfl1sibEciaKnN7jRx5Tt6ibjkzdqDNthRh0icUXNwpToQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2126&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;除了项目本身的原因，还可能有外部依赖导致的泄漏，如 Netty 和 Spring Boot，详细情况可以学习下这两篇文章：&lt;/span&gt;&lt;span&gt;《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651750037&amp;amp;idx=2&amp;amp;sn=847fb15d4413354355c33a46a7bccf55&amp;amp;chksm=bd12a7d88a652ecea5789073973abb9545e76a8972c843968a6efd1fb3a918ef07eed8abb37e&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;疑案追踪：Spring Boot内存泄露排查记&lt;/a&gt;》、《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;amp;mid=2651749037&amp;amp;idx=2&amp;amp;sn=d1d6b0348eea5cd80e2c7a56c8a61fa9&amp;amp;chksm=bd12a3e08a652af684fd8d96e81fc0e0fded69dd847051e6b0f791f3726da0415c9552ee2615&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Netty堆外内存泄露排查盛宴&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Netty堆外内存泄露排查盛宴&lt;/a&gt;》&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4.8.4 小结&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先可以使用 NMT + jcmd 分析泄漏的堆外内存是哪里申请，确定原因后，使用不同的手段，进行原因定位。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3456913827655311&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFGGEWTylxLuu32uLTKCCE5uOSFJCbRxibJPDCDtNn68riasyJIGnH9nzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;998&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.9 场景九：JNI 引发的 GC 问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;4.9.1 现象&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 GC 日志中，出现 GC Cause 为 GCLocker Initiated GC。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;2020&lt;span&gt;-09-23T16&lt;/span&gt;&lt;span&gt;:49:09.727+0800&lt;/span&gt;: 504426&lt;span&gt;.742&lt;/span&gt;: &lt;span&gt;[GC (GCLocker Initiated GC) 504426.742: [ParNew (promotion failed): 209716K-&amp;gt;6042K(1887488K), 0.0843330 secs]&lt;/span&gt; 1449487&lt;span&gt;K-&lt;/span&gt;&amp;gt;1347626&lt;span&gt;K&lt;/span&gt;(3984640&lt;span&gt;K&lt;/span&gt;), 0&lt;span&gt;.0848963&lt;/span&gt; &lt;span&gt;secs&lt;/span&gt;] &lt;span&gt;[Times: user=0.19 sys=0.00, real=0.09 secs]&lt;/span&gt;&lt;br/&gt;2020&lt;span&gt;-09-23T16&lt;/span&gt;&lt;span&gt;:49:09.812+0800&lt;/span&gt;: 504426&lt;span&gt;.827&lt;/span&gt;: &lt;span&gt;[Full GC (GCLocker Initiated GC) 504426.827: [CMS: 1341583K-&amp;gt;419699K(2097152K), 1.8482275 secs]&lt;/span&gt; 1347626&lt;span&gt;K-&lt;/span&gt;&amp;gt;419699&lt;span&gt;K&lt;/span&gt;(3984640&lt;span&gt;K&lt;/span&gt;), &lt;span&gt;[Metaspace: 297780K-&amp;gt;297780K(1329152K)]&lt;/span&gt;, 1&lt;span&gt;.8490564&lt;/span&gt; &lt;span&gt;secs&lt;/span&gt;] &lt;span&gt;[Times: user=1.62 sys=0.20, real=1.85 secs]&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;4.9.2 原因&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;JNI（&lt;/span&gt;&lt;span&gt;Java Native Interface&lt;/span&gt;&lt;span&gt;）意为 Java 本地调用，它允许 Java 代码和其他语言写的 Native 代码进行交互。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;JNI 如果需要获取 JVM 中的 String 或者数组，有两种方式：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于 Native 代码直接使用了 JVM 堆区的指针，如果这时发生 GC，就会导致数据错误。因此，在发生此类 JNI 调用时，禁止 GC 的发生，同时阻止其他线程进入 JNI 临界区，直到最后一个线程退出临界区时触发一次 GC。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;GC Locker 实验：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;GCLockerTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ITERS = &lt;span&gt;100&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ARR_SIZE =  &lt;span&gt;10000&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; WINDOW = &lt;span&gt;10000000&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;acquire&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] arr)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;native&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;release&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] arr)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Object[] window = &lt;span&gt;new&lt;/span&gt; Object[WINDOW];&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String... args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{&lt;br/&gt;    System.loadLibrary(&lt;span&gt;&quot;GCLockerTest&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt;[] arr = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[ARR_SIZE];&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; ITERS; i++) {&lt;br/&gt;      acquire(arr);&lt;br/&gt;      System.out.println(&lt;span&gt;&quot;Acquired&quot;&lt;/span&gt;);&lt;br/&gt;      &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; c = &lt;span&gt;0&lt;/span&gt;; c &amp;lt; WINDOW; c++) {&lt;br/&gt;          window[c] = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;        }&lt;br/&gt;      } &lt;span&gt;catch&lt;/span&gt; (Throwable t) {&lt;br/&gt;        &lt;span&gt;// omit&lt;/span&gt;&lt;br/&gt;      } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Releasing&quot;&lt;/span&gt;);&lt;br/&gt;        release(arr);&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;hr/&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;jni.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&quot;GCLockerTest.h&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; jbyte* sink;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;JNIEXPORT &lt;span&gt;void&lt;/span&gt; JNICALL &lt;span&gt;Java_GCLockerTest_acquire&lt;/span&gt;&lt;span&gt;(JNIEnv* env, jclass klass, jintArray arr)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;sink = (*env)-&amp;gt;GetPrimitiveArrayCritical(env, arr, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;JNIEXPORT &lt;span&gt;void&lt;/span&gt; JNICALL &lt;span&gt;Java_GCLockerTest_release&lt;/span&gt;&lt;span&gt;(JNIEnv* env, jclass klass, jintArray arr)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;(*env)-&amp;gt;ReleasePrimitiveArrayCritical(env, arr, sink, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;运行该 JNI 程序，可以看到发生的 GC 都是 GCLocker Initiated GC，并且注意在 “Acquired” 和 “Released” 时不可能发生 GC。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.42289719626168226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFFeTUBhRYXPkib6QyGBwDSAANkTPQ2vpxVkMialIDHtkWiacZvb5Sytvbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1712&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;GC Locker 可能导致的不良后果有：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果此时是 Young 区不够 Allocation Failure 导致的 GC，由于无法进行 Young GC，会将对象直接分配至 Old 区。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果 Old 区也没有空间了，则会等待锁释放，导致线程阻塞。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可能触发额外不必要的 Young GC，JDK 有一个 Bug，有一定的几率，本来只该触发一次 GCLocker Initiated GC 的 Young GC，实际发生了一次 Allocation Failure GC 又紧接着一次 GCLocker Initiated GC。是因为 GCLocker Initiated GC 的属性被设为 full，导致两次 GC 不能收敛。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;4.9.3 策略&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;添加 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX+PrintJNIGCStalls&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 参数，可以打印出发生 JNI 调用时的线程，进一步分析，找到引发问题的 JNI 调用。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;JNI 调用需要谨慎，不一定可以提升性能，反而可能造成 GC 问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;升级 JDK 版本到 14，避免 &lt;/span&gt;&lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8048556&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;JDK-8048556&lt;/span&gt;&lt;/a&gt;&lt;span&gt; 导致的重复 GC。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.36304062909567497&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyF5cJichumdiaic5tm9H34IeT4YBmWbxEm19ibaQlfb1cWkNDf3BjagrwMcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1526&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;4.9.4 小结&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;JNI 产生的 GC 问题较难排查，需要谨慎使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5. 总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这里，我们把整个文章内容总结一下，方便大家整体地理解回顾。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.1 处理流程（SOP）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下图为整体 GC 问题普适的处理流程，重点的地方下面会单独标注，其他的基本都是标准处理流程，此处不再赘述，最后在整个问题都处理完之后有条件的话建议做一下复盘。&lt;/span&gt;&lt;/p&gt;&lt;img data-ratio=&quot;0.33172302737520126&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFMExlddOJ3WaM5BWEESfKsfpPhiczKk9KJ4wJ6XNmrKDTLd9YDJkFYQQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;7452&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;制定标准：&lt;/strong&gt;这块内容其实非常重要，但大部分系统都是缺失的，笔者过往面试的同学中只有不到一成的同学能给出自己的系统 GC 标准到底什么样，其他的都是用的统一指标模板，缺少预见性，具体指标制定可以参考 3.1 中的内容，需要结合应用系统的 TP9999 时间和延迟、吞吐量等设定具体的指标，而不是被问题驱动。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;保留现场：&lt;/strong&gt;目前线上服务基本都是分布式服务，某个节点发生问题后，如果条件允许一定不要直接操作重启、回滚等动作恢复，优先通过摘掉流量的方式来恢复，这样我们可以将堆、栈、GC 日志等关键信息保留下来，不然错过了定位根因的时机，后续解决难度将大大增加。当然除了这些，应用日志、中间件日志、内核日志、各种 Metrics 指标等对问题分析也有很大帮助。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;因果分析：&lt;/strong&gt;判断 GC 异常与其他系统指标异常的因果关系，可以参考笔者在 3.2 中介绍的时序分析、概率分析、实验分析、反证分析等 4 种因果分析法，避免在排查过程中走入误区。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;根因分析：&lt;/strong&gt;确实是 GC 的问题后，可以借助上文提到的工具并通过 5 Why 根因分析法以及跟第三节中的九种常见的场景进行逐一匹配，或者直接参考下文的根因鱼骨图，找出问题发生根因，最后再选择优化手段。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.2 根因鱼骨图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;送上一张问题根因鱼骨图，一般情况下我们在处理一个 GC 问题时，只要能定位到问题的“病灶”，有的放矢，其实就相当于解决了 80%，如果在某些场景下不太好定位，大家可以借助这种根因分析图通过&lt;strong&gt;排除法&lt;/strong&gt;去定位。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6692708333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFoVoSrZIyVnyoFyle8ZugSPicZ5lnSojiaaooxIXA6DibDjiaYK8pyLDQSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1920&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.3 调优建议&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Trade Off：&lt;/strong&gt;与 CAP 注定要缺一角一样，GC 优化要在延迟（&lt;/span&gt;&lt;span&gt;Latency&lt;/span&gt;&lt;span&gt;）、吞吐量（&lt;/span&gt;&lt;span&gt;Throughput&lt;/span&gt;&lt;span&gt;）、容量（&lt;/span&gt;&lt;span&gt;Capacity&lt;/span&gt;&lt;span&gt;）三者之间进行权衡。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;最终手段：&lt;/strong&gt;GC 发生问题不是一定要对 JVM 的 GC 参数进行调优，大部分情况下是通过 GC 的情况找出一些业务问题，切记上来就对 GC 参数进行调整，当然有明确配置错误的场景除外。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;控制变量：&lt;/strong&gt;控制变量法是在蒙特卡洛（&lt;/span&gt;&lt;span&gt;Monte Carlo&lt;/span&gt;&lt;span&gt;）方法中用于减少方差的一种技术方法，我们调优的时候尽量也要使用，每次调优过程尽可能只调整一个变量。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;善用搜索：&lt;/strong&gt;理论上 99.99% 的 GC 问题基本都被遇到了，我们要学会使用搜索引擎的高级技巧，重点关注 StackOverFlow、Github 上的 Issue、以及各种论坛博客，先看看其他人是怎么解决的，会让解决问题事半功倍。能看到这篇文章，你的搜索能力基本过关了~&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;调优重点：&lt;/strong&gt;总体上来讲，我们开发的过程中遇到的问题类型也基本都符合正态分布，太简单或太复杂的基本遇到的概率很低，笔者这里将中间最重要的三个场景添加了“*”标识，希望阅读完本文之后可以观察下自己负责的系统，是否存在上述问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;GC 参数：&lt;/strong&gt;如果堆、栈确实无法第一时间保留，一定要保留 GC 日志，这样我们最起码可以看到 GC Cause，有一个大概的排查方向。关于 GC 日志相关参数，最基本的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 等一些参数就不再提了，笔者建议添加以下参数，可以提高我们分析问题的效率。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.43371757925072046&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsXnsAxbADiam0icpM2GoDibIyFKhoF4nxicMez1ic1UJqkaZ2YRtzqO5oZXdWHSYGpaCfRkhDn9wyenibag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1388&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;6. 写在最后&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，再说笔者个人的一些小建议，遇到一些 GC 问题，如果有精力，一定要探本穷源，找出最深层次的原因。另外，在这个信息泛滥的时代，有一些被“奉为圭臬”的经验可能都是错误的，尽量养成看源码的习惯，有一句话说到“源码面前，了无秘密”，也就意味着遇到搞不懂的问题，我们可以从源码中一窥究竟，某些场景下确有奇效。但也不是只靠读源码来学习，如果硬啃源码但不理会其背后可能蕴含的理论基础，那很容易“捡芝麻丢西瓜”，“只见树木，不见森林”，让“了无秘密”变成了一句空话，我们还是要结合一些实际的业务场景去针对性地学习。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;你的时间在哪里，你的成就就会在哪里&lt;/strong&gt;。笔者也是在前两年才开始逐步地在 GC 方向上不断深入，查问题、看源码、做总结，每个 Case 形成一个小的闭环，目前初步摸到了 GC 问题处理的一些门道，同时将经验总结应用于生产环境实践，慢慢地形成一个良性循环。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本篇文章主要是介绍了 CMS GC 的一些常见场景分析，另外一些，如 CodeCache 问题导致 JIT 失效、SafePoint 就绪时间长、Card Table 扫描耗时等问题不太常见就没有花太多篇幅去讲解。Java GC 是在“分代”的思想下内卷了很多年才突破到了“分区”，目前在美团也已经开始使用 G1 来替换使用了多年的 CMS，虽然在小的堆方面 G1 还略逊色于 CMS，但这是一个趋势，短时间无法升级到 ZGC，所以未来遇到的 G1 的问题可能会逐渐增多。目前已经收集到 Remember Set 粗化、Humongous 分配、Ergonomics 异常、Mixed GC 中 Evacuation Failure 等问题，除此之外也会给出 CMS 升级到 G1 的一些建议，接下来笔者将继续完成这部分文章整理，敬请期待。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“防火”永远要胜于“救火”，&lt;strong&gt;不放过任何一个异常的小指标&lt;/strong&gt;（&lt;/span&gt;&lt;span&gt;一般来说，任何&lt;strong&gt;不平滑的曲线&lt;/strong&gt;都是值得怀疑的&lt;/span&gt;&lt;span&gt;） ，就有可能避免一次故障的发生。作为 Java 程序员基本都会遇到一些 GC 的问题，独立解决 GC 问题是我们必须迈过的一道坎。开篇中也提到过 GC 作为经典的技术，非常值得我们学习，一些 GC 的学习材料，如《The Garbage Collection Handbook》、《深入理解Java虚拟机》等也是常读常新，赶紧动起来，苦练 GC 基本功吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后的最后，再多啰嗦一句，目前所有 GC 调优相关的文章，第一句讲的就是“不要过早优化”，使得很多同学对 GC 优化望而却步。在这里笔者提出不一样的观点，熵增定律（&lt;/span&gt;&lt;span&gt;在一个孤立系统里，如果没有外力做功，其总混乱度（即熵）会不断增大&lt;/span&gt;&lt;span&gt;）在计算机系统同样适用，&lt;strong&gt;如果不主动做功使熵减，系统终究会脱离你的掌控&lt;/strong&gt;，在我们对业务系统和 GC 原理掌握得足够深的时候，可以放心大胆地做优化，因为我们基本可以预测到每一个操作的结果，放手一搏吧，少年！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;7. 参考资料&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[1]《&lt;/span&gt;&lt;a href=&quot;https://book.douban.com/subject/4881935/&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;ガベージコレクションのアルゴリズムと実装&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》中村 成洋 / 相川 光&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[2]《&lt;/span&gt;&lt;a href=&quot;https://book.douban.com/subject/6809987/&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;The Garbage Collection Handbook&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》 Richard Jones/ Antony Hosking / Eliot Moss&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[3]《&lt;/span&gt;&lt;a href=&quot;https://book.douban.com/subject/34907497/&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;深入理解Java虚拟机（第3版）&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》 周志明&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[4]《&lt;/span&gt;&lt;a href=&quot;https://docs.oracle.com/javase/9/gctuning/JSGCT.pdf&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[5]《&lt;/span&gt;&lt;a href=&quot;https://shipilev.net/&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Shipilev One Page Blog&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》 Shipilëv&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[6] &lt;/span&gt;&lt;a href=&quot;https://openjdk.java.net/projects/jdk/15/&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;https://openjdk.java.net/projects/jdk/15/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[7] &lt;/span&gt;&lt;a href=&quot;https://jcp.org/en/home/index&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;https://jcp.org/en/home/index&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[8]《&lt;/span&gt;&lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.8915&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;A Generational Mostly-concurrent Garbage Collector&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》 Tony Printezis / David Detlefs&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[9]《&lt;/span&gt;&lt;a href=&quot;https://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Java Memory Management White Paper&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[10]《&lt;/span&gt;&lt;a href=&quot;https://go.gale.com/ps/anonymous?id=GALE%7CA563359212&amp;amp;sid=googleScholar&amp;amp;v=2.1&amp;amp;it=r&amp;amp;linkaccess=abs&amp;amp;issn=00311723&amp;amp;p=AONE&amp;amp;sw=w&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Stuff Happens：Understanding Causation in Policy and Strategy&lt;/span&gt;&lt;/a&gt;&lt;span&gt;》AA Hill&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;8. 作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;新宇，2015 年加入美团，到店住宿门票业务开发工程师。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;湘铭，2018 年加入美团，到店客户平台开发工程师。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;祥璞，2018 年加入美团，到店客户平台开发工程师。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9ccbda2bb77b243e4b4043aead0664ad</guid>
<title>分布式事务方案：SAGA 模式</title>
<link>https://toutiao.io/k/5oci732</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欢迎阅读 👏&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文目的是讲清楚 SAGA 这种分布式事务解决方案的实现思路，不包括具体实现代码，具体实现推荐使用阿里的 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Nzc4MjI4MQ==&amp;amp;mid=2652403185&amp;amp;idx=1&amp;amp;sn=fdc73d943e780942a6a8982e2f1a2edf&amp;amp;chksm=8bd8f317bcaf7a0162f029c41c7bdb0a6672ea61cf5d8680200a796a23cee30350c112eb8356&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Seata&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Seata&lt;/a&gt; 框架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内容包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;分布式事务问题描述&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SAGA - Choreography 策略&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SAGA - Orchestration 策略&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;补充：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的分布式事务解决方案还包括 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Nzc4MjI4MQ==&amp;amp;mid=2652403141&amp;amp;idx=1&amp;amp;sn=1a0bfe708055a9d385557615638809ea&amp;amp;chksm=8bd8f323bcaf7a356f922f947d7b2e1564fa004cc0d42bce45858501e370ba0ef02cf6144b1b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;TCC&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;TCC&lt;/a&gt;、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Nzc4MjI4MQ==&amp;amp;mid=2652403126&amp;amp;idx=1&amp;amp;sn=92074b9b3531f65c2d1fb39d74ef6f71&amp;amp;chksm=8bd8f350bcaf7a46326b52d01cdb6859de760a997c30370d930fde83d1f5d1ac13828efcb43c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;可靠消息模式&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;可靠消息模式&lt;/a&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 分布式事务问题描述&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3837902264600715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl92X6fls7nkLXEg8ptfRRU11JSHTe0WdZ2BYdonFgibnvnq18ohDkqf8z7NpU36KL9ZBymmPKYvDw7g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1678&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如说电商系统中，用户下单了，后端需要调用：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;订单服务，创建订单&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;库存服务，改商品的库存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;物流服务，创建物流单，准备发货&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式的微服务架构中，每个服务都会有自己独立的数据库，那么，这个下单的动作就涉及到了向多个数据库中写入数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为不是在同一个数据库中，所以就不能依赖数据库的事务机制了，但是在业务逻辑中，这几个写库操作就应该是一个事务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如订单服务、库存服务中都写入成功了，但物流系统出现异常了，那么订单服务、库存服务就应该进行回滚，来保证整体数据的一致性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何在跨数据库的情况下实现事务呢？这就是分布式事务问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SAGA 就是一种老牌的分布式事务解决方案，已经有20来年了，其实现方式主要有两种：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面介绍一下各自的实现思路。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. SAGA - Choreography 策略&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.71796875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl92X6fls7nkLXEg8ptfRRU11sjVgW4CGkgNncBXYiaF8cuas8IAiaPiadV3tcQ4BUkZC1UKBMOqYKpGGQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Choreography 是编舞的意思，就是把舞者之间的动作配合都编排好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应到分布式事务，就可以把各个服务理解为舞者，SAGA 的 Choreography 策略就是要定义好先执行哪个服务，根据执行结果再触发哪些服务的执行。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.38896746817538896&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl92X6fls7nkLXEg8ptfRRU11uGACas2sNhTC2Y4LGLEbzBM4eKrP1cVdWKicMnSuGsA3qK6pdCg8Ohg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1414&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图，整体分布式事务处理流程为：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;订单服务写自己的业务数据，并在数据库中&lt;strong&gt;记录&lt;/strong&gt;一下订单的整体&lt;strong&gt;状态&lt;/strong&gt;，比如记为 &quot;已下单&quot;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;订单服务发布【订单创建成功】事件，库存服务会监听此事件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;库存服务收到事件通知后，写自己的业务数据，然后发布【库存修改成功】事件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;订单服务会监听此事件，收到事件通知后，修改订单状态，比如 &quot;待发货&quot;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;物流服务也会监听此事件，收到事件通知后，写自己的业务数据，然后发布【物流处理成功】。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;订单服务会监听此事件，收到通知后，修改订单状态，改为 &quot;已发货&quot;。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，通过事件机制，各个服务之间完成协同配合，实现了分布式事务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面看异常情况的处理，比如物流服务异常了，如下图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.38375350140056025&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl92X6fls7nkLXEg8ptfRRU11voMO5u2ukJa8ichGq9BftbLdOFbnuiaYePoickVmjeGTmicOk3uhhWDt0g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1428&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重点看异常处理流程：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;物流服务会发布事件【物流处理异常】。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;订单服务、库存服务都监听此事件，所以会收到物流异常的通知。图中（8）、（9）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;订单服务执行自己的回滚逻辑。图中（10）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;库存服务执行自己的回滚逻辑。图中（11）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就实现了分布式事务的异常处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SAGA Choreography 策略是通过【事件机制】实现的，各个服务都定义好正常、异常的处理方法，然后监听目标事件，根据不同的事件来调用不同的处理方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此策略好处是实现简单，坏处是整体事件逻辑会比较复杂，比如有10个服务参与其中，那么整体事件订阅关系就会很凌乱。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. SAGA - Orchestration&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6664285714285715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl92X6fls7nkLXEg8ptfRRU11ZV3egumMMnxye1bUzoJFNHVIyu1XlE3d2Yy0Qe6U05MHeCp6QibCkKA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1400&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Orchestration 是乐队编排的意思。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应到分布式事务，各个服务就是乐队中的各个演奏者，还需要一个【总指挥】，所以在 SAGA - Orchestration 策略中会单独创建一个此角色。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;![image-20201111184654838](/Users/a/Library/Application Support/typora-user-images/image-20201111184654838.png)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图，正常处理流程：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;订单服务写自己的业务数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;订单服务向总指挥报告自己完成了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;总指挥向库存服务发送执行指令&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;库存服务写数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;库存服务报告自己完成了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;总指挥向订单服务发送指令&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;订单服务更新订单状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;总指挥向物流服务发送指令&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;......&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面的就不细说，都是一个思路。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异常处理的思路也是一样的，还是假设物流服务异常了，那么它会向总指挥报告，总指挥就会向订单服务、库存服务发送回滚的指令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 Orchestration 策略的重点在于总指挥，需要为其定义指挥手册，以便总指挥在不同的时刻向相应的服务发送对应的指令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个总指挥实际上是通过【状态机】来实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此策略好处是服务之间没有关联了，整体结构清晰。坏处是都了一个总指挥的角色，增加了复杂度。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 小结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Choreography 策略是通过事件机制实现的，每个服务都监听自己所关心的事件，每个服务执行后会发送相应的事件，监听此事件的服务执行相应的处理逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Orchestration 是通过状态机来实现的整体控制，定义还整体的处理流程，不同状态下需要触发的动作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前 Orchestration 是主流的策略，阿里的 Seata 分布式事务框架中实现了此策略，有兴趣可以去了解下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;&lt;strong&gt;Happy Learning ヾ(￣▽￣)Bye~Bye~&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bba8739af7a9b1ae96f5e2c1a79506cb</guid>
<title>刨根问底，Kafka 消息中间件到底会不会丢消息</title>
<link>https://toutiao.io/k/17q9ijl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为避免上面类似情况的发生，除了做好补偿措施，更应该在系设计的时候充分考虑各种异常，设计一个稳定、高可用的消息系统。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;认识Kafka&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一下维基百科的定义&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Kafka是分布式发布-订阅消息系统。它最初由LinkedIn公司开发，之后成为Apache项目的一部分。&lt;/p&gt;&lt;p&gt;Kafka是一个分布式的，可划分的，冗余备份的持久性的日志服务。它主要用于处理活跃的流式数据。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;kafka架构&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka的整体架构非常简单，是显式分布式架构，主要由producer、broker（kafka）和consumer组成。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.41169590643274856&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EpVmy0ZJ4db6DicicfibajG7CcicjWevmX0FVRXZwexWyd4xPeEyiaSpXCVlqvyOhTF2lrCZmvTQd6DVicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1710&quot;/&gt;&lt;figcaption&gt;Kafka架构（精简版）&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Producer&lt;/strong&gt;（生产者）可以将数据发布到所选择的topic（主题）中。生产者负责将记录分配到topic的哪一个 partition（分区）中。可以使用循环的方式来简单地实现负载均衡，也可以根据某些语义分区函数(如记录中的key)来完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Consumer&lt;/strong&gt;（消费者）使用一个consumer group（消费组）名称来进行标识，发布到topic中的每条记录被分配给订阅消费组中的一个消费者实例。消费者实例可以分布在多个进程中或者多个机器上。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Kafka到底会不会丢失消息？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在讨论kafka是否丢消息前先来了解一下什么是&lt;strong&gt;消息传递语义&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.311614730878187&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EpVmy0ZJ4db6DicicfibajG7Cc4Rr3ibFmXY650cR6zyfKKSP5ey95z4cVvj8CkABrB3Ua4SdTOzDhJbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1412&quot;/&gt;&lt;figcaption&gt;消息传递语义&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;message delivery semantic 也就是消息传递语义，简单说就是消息传递过程中消息传递的保证性。主要分为三种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;at most once&lt;/strong&gt;：最多一次。消息可能丢失也可能被处理，但最多只会被处理一次。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;at least once&lt;/strong&gt;：至少一次。消息不会丢失，但可能被处理多次。可能重复，不会丢失。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;exactly once&lt;/strong&gt;：精确传递一次。消息被处理且只会被处理一次。不丢失不重复就一次。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理想情况下肯定是希望系统的消息传递是严格exactly once，也就是保证不丢失、只会被处理一次，但是很难做到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到主角Kafka，Kafka有三次消息传递的过程：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;生产者发消息给Kafka Broker。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kafka Broker 消息同步和持久化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kafka Broker 将消息传递给消费者。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这三步中每一步都有可能会丢失消息，下面详细分析为什么会丢消息，如何最大限度避免丢失消息。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;生产者丢失消息&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先介绍一下生产者发送消息的一般流程（部分流程与具体配置项强相关，这里先忽略）：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;生产者是与leader直接交互，所以先从集群获取topic对应分区的leader元数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取到leader分区元数据后直接将消息发给过去；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kafka Broker对应的leader分区收到消息后写入文件持久化；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Follower拉取Leader消息与Leader的数据保持一致；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Follower消息拉取完毕需要给Leader回复ACK确认消息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kafka Leader和Follower分区同步完，Leader分区会给生产者回复ACK确认消息。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3728813559322034&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EpVmy0ZJ4db6DicicfibajG7CceLDlQ1mY0LcoiakHWrS2icgKncMSb465JlMMDS2sYWJFf7HbNjBGnWfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1534&quot;/&gt;&lt;figcaption&gt;生产者发送数据流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产者采用push模式将数据发布到broker，每条消息追加到分区中，顺序写入磁盘。消息写入Leader后，Follower是主动与Leader进行同步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka消息发送有两种方式：同步（sync）和异步（async），默认是同步方式，可通过producer.type属性进行配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka通过配置request.required.acks属性来确认消息的生产：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;0表示不进行消息接收是否成功的确认；不能保证消息是否发送成功，生成环境基本不会用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;1表示当Leader接收成功时确认；只要Leader存活就可以保证不丢失，保证了吞吐量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;-1或者all表示Leader和Follower都接收成功时确认；可以最大限度保证消息不丢失，但是吞吐量低。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka producer 的参数acks 的默认值为1，所以默认的producer级别是at least once，并不能exactly once。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;敲黑板了，这里可能会丢消息的！&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果acks配置为0，发生网络抖动消息丢了，生产者不校验ACK自然就不知道丢了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果acks配置为1保证leader不丢，但是如果leader挂了，恰好选了一个没有ACK的follower，那也丢了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;all：保证leader和follower不丢，但是如果网络拥塞，没有收到ACK，会有重复发的问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Kafka Broker丢失消息&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka Broker 接收到数据后会将数据进行持久化存储，你以为是下面这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5754189944134078&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EpVmy0ZJ4db6DicicfibajG7Cc3R8l6vVib3crFZ6tY36BAx45VEdHwQmoB7MicQLPqw9A8gaia40Zt0xXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1074&quot;/&gt;&lt;figcaption&gt;消息持久化，无cache&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没想到是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7117750439367311&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EpVmy0ZJ4db6DicicfibajG7CcLTpX0ctRRzTX5eVWeh89ic9Vgx2DwQJLcIiafe4vZ9C2JPUKGgWNLMQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1138&quot;/&gt;&lt;figcaption&gt;消息持久化，有cache&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作系统本身有一层缓存，叫做 Page Cache，当往磁盘文件写入的时候，系统会先将数据流写入缓存中，至于什么时候将缓存的数据写入文件中是由操作系统自行决定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka提供了一个参数 producer.type 来控制是不是主动flush，如果Kafka写入到mmap之后就立即 flush 然后再返回 Producer 叫同步 (sync)；写入mmap之后立即返回 Producer 不调用 flush 叫异步 (async)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;敲黑板了，这里可能会丢消息的！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka通过多分区多副本机制中已经能最大限度保证数据不会丢失，如果数据已经写入系统 cache 中但是还没来得及刷入磁盘，此时突然机器宕机或者掉电那就丢了，当然这种情况很极端。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;消费者丢失消息&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者通过pull模式主动的去 kafka 集群拉取消息，与producer相同的是，消费者在拉取消息的时候也是找leader分区去拉取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多个消费者可以组成一个消费者组（consumer group），每个消费者组都有一个组id。同一个消费组者的消费者可以消费同一topic下不同分区的数据，但是不会出现多个消费者消费同一分区的数据。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4226950354609929&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EpVmy0ZJ4db6DicicfibajG7Ccd3ZE38bwHmgdr7Ih3xqFrpjuC5THTZWgZiaB0picutRgLNb3v0LO6vNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1410&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;消费者群组消费消息&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者消费的进度通过offset保存在kafka集群的__consumer_offsets这个topic中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费消息的时候主要分为两个阶段：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、标识消息已被消费，commit offset坐标；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、处理消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;敲黑板了，这里可能会丢消息的！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;场景一：先commit再处理消息。如果在处理消息的时候异常了，但是offset 已经提交了，这条消息对于该消费者来说就是丢失了，再也不会消费到了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;场景二：先处理消息再commit。如果在commit之前发生异常，下次还会消费到该消息，重复消费的问题可以通过业务保证消息幂等性来解决。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了，kafka到底会不会丢消息？答案是：会！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka可能会在三个阶段丢失消息：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）生产者发送数据；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）Kafka Broker 存储数据；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）消费者消费数据；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在生产环境中严格做到exactly once其实是难的，同时也会牺牲效率和吞吐量，最佳实践是业务侧做好补偿机制，万一出现消息丢失可以兜底。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>