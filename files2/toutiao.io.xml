<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>05752d6d8b21675d80276c60f92e4742</guid>
<title>3 分钟用 Go 写完验证码，面试官现场发 Offer</title>
<link>https://toutiao.io/k/d86s58p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100001217&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/oiccOczwQpF8Ot0ZSBRxu5SRkJVXnr4XWsq2rKrJgF3eUNQCZlSfmuiakm2NM7DJbf5JTj9dTcqVxwUPVPZeJGBQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我记得在17年那会儿网站登录注册这些随处都可以看到下面这种验证码：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100001204&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5571428571428572&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpF8Ot0ZSBRxu5SRkJVXnr4XWHciaGY6ib35zcaddeFlJuBVgV0GQ8NrsuOdGCLcaU4clK5p3OyXkEvpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;420&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是好像近些年，这种验证码消失了，出现了特别多的人机验证，如下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100001205&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7874251497005988&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpF8Ot0ZSBRxu5SRkJVXnr4XWH60Tibia4d42icIwEaXXBzPEluNW11ZC6qD05qe51GvbKE7F49rsook2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;334&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;真的是要感叹技术的发展真的不要太爽了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;人机校验&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能很多同学还不知道他的用处：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他最大的用处就是鉴别是人在操作你的产品还是机器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：最常见的注册、登录业务，如果你不上一些验证手段，可能人家就可以随便找一个工具，直接对你注册接口疯狂输出，让你分分钟拥有十几万神秘用户。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在人机验证没出来之前，人们用的最多的就是用验证码来拦截，要注册或者登录，必须输入验证码里面的内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是随着&lt;strong&gt;图片识别技术&lt;/strong&gt;的发展，这种技术几乎已经失守。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是一看价格：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100001206&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.37876506024096385&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpF8Ot0ZSBRxu5SRkJVXnr4XWToDOgJ1Gc4TTXR5nKX8vGny7V5UkIUq4lMRd2a0nezyTglWHdVIksA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1328&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100001207&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8582574772431729&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpF8Ot0ZSBRxu5SRkJVXnr4XWpvB1lGv2e6Q94LbowIe2LNfh2VVfH5fzCFib7YnmwnpUzjdOHQQvCzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;769&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上阿里和腾讯两家的价格，不算特别便宜哈。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前后端分离下实现验证码服务的逻辑&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然人机校验好处多多，但是介于价格可能很多公司或者个人还是会望而却步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实刚上的新服务，前期还是可以先使用验证码来鉴别的，到中后期再接入人机也是可以的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;验证码的逻辑&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在传统的单体服务，非前后端分离的情况下，我们可以使用 session 来存储，整个流程可以像下图这样走：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100001208&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.096774193548387&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpF8Ot0ZSBRxu5SRkJVXnr4XWhwwKqUE0156r1aOLicWfQcvia7ibqzmwx5Vhq22hsWjR5bUPicoFiadNGJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;744&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是现在都前后端分离了，请求会话都是无状态的，该怎么实现呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现方式可能有很多，但是我个人建议可以借鉴下人机交互的逻辑，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100001209&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9828850855745721&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpF8Ot0ZSBRxu5SRkJVXnr4XW8HhnEnaZ9pjCOlsV8ObrfGRLP1BM79ic5ZEnl9MAFoALrNFl0b0PQmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;818&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们把会话和验证码分离开了，只要需要用到验证码的地方，都可以去请求这个接口，在下一次请求的时候带上返回的 key 和输入的值就可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个流程其实还是有很多漏洞在里面，&lt;strong&gt;实际上生产肯定不能直接这么简单的上&lt;/strong&gt;，还要加上很多其他技术在里面，比如把生成的验证码和下一步请求的地址关联起来、签名呀这些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这已经能拦截一大批攻击者了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种做法和人机验证最大的区别在于，我们生产的验证码容易别人用工具识别出来，人机验证的他们有一套算法去防止被机器识别出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后期如果要换成人机也非常容易，因为流程是一样的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基于 Gin 实现一套验证码&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面说了那么多的理论逻辑，下面开始上代码：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整的代码可以到我们官方的 Github 库查看：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;https://github.com/GoLangStackDev/captcha-demo.git&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;使用到的库&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们处理 Gin 之外还要用到  &lt;code&gt;captcha&lt;/code&gt; 库：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方 GitHub 地址：&lt;code&gt;github.com/dchest/captcha&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个库功能非常强大，他支持生成图片验证码和音频验证码：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100001210&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4080808080808081&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpF8Ot0ZSBRxu5SRkJVXnr4XWEOdkIDEYr58IPngqCEhYYFPn7PrU4YpKWIr64mbO1RRXxic1lZlUKIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;495&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现思路一样的，代码几乎一样，只是类型不一样，我们主要以生成图片为准。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;安装库&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要安装两个库：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go get github.com/dchest/captcha&lt;br/&gt;go get github.com/gin-gonic/gin&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;先实现工具类&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个工具类我们专门用来处理验证码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Captcha 方便后期扩展&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Captcha &lt;span&gt;struct&lt;/span&gt; {}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 单例&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; captchaInstance *Captcha&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Instance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; *&lt;span&gt;Captcha&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; captchaInstance==&lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  captchaInstance = &amp;amp;Captcha{}&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; captchaInstance&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们声明了一个结构体，方便后期在 captcha 这个库上进行扩展。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// CreateImage 创建图片验证码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(this *Captcha)&lt;/span&gt; &lt;span&gt;CreateImage&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; length := captcha.DefaultLen&lt;br/&gt; captchaId := captcha.NewLen(length)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; captchaId&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建验证码也很容易，我们这里直接全部使用他默认的配置，生产6位数的数字验证码，后期有需要可以参考 captcha 库进行调整配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里会返回一个 ID 给我们，这个 ID 就是刚我画的流程图里面的 key，他关联了一个随机数，也就是图片的数字。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这里他存放在哪里的呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认是内存，所以重启程序后就可能找不到已经生成的验证码了，但你可以修改他存放在哪里。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Reload 重载&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(this *Captcha)&lt;/span&gt; &lt;span&gt;Reload&lt;/span&gt;&lt;span&gt;(captchaId &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; captcha.Reload(captchaId)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为不可能用户每次都能输对，所以有些时候用户不能识别的情况下就需要进行重新生成随机数，也就是重新生成一张图片，但是 key 也就是 ID 是不能变的，此时就要用到重载。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Verify 验证&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(this *Captcha)&lt;/span&gt; &lt;span&gt;Verify&lt;/span&gt;&lt;span&gt;(captchaId,val &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; captcha.VerifyString(captchaId, val)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是验证了，传入 ID 和 用户输入的值就可验证了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// GetImageByte 获取图片二进制流&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(this *Captcha)&lt;/span&gt; &lt;span&gt;GetImageByte&lt;/span&gt;&lt;span&gt;(captchaId &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; []&lt;span&gt;byte&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; content bytes.Buffer&lt;br/&gt; err := captcha.WriteImage(&amp;amp;content, captchaId, captcha.StdWidth, captcha.StdHeight)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err!=&lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  log.Println(err)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; content.Bytes()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后就是关键了，怎么把图片输出给用户，captcha 库他会生成一个图片的二进制流，你只需要把这个二进制流返回回去即可得到图片。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Gin部分的代码&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里都只展示关键部分的代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 创建&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 这里方便看到效果 我用的 GET 请求，实际生产最好不要用 GET&lt;/span&gt;&lt;br/&gt;r.Handle(&lt;span&gt;&quot;GET&quot;&lt;/span&gt;, &lt;span&gt;&quot;/captcha/create&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(c *gin.Context)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; imgId := captcha.Instance().CreateImage()&lt;br/&gt; c.JSON(http.StatusOK,&lt;br/&gt;  gin.H{&lt;br/&gt;   &lt;span&gt;&quot;code&quot;&lt;/span&gt;: &lt;span&gt;200&lt;/span&gt;,&lt;br/&gt;   &lt;span&gt;&quot;key&quot;&lt;/span&gt;: imgId,&lt;br/&gt;   &lt;span&gt;&quot;url&quot;&lt;/span&gt;: &lt;span&gt;&quot;/captcha/img/&quot;&lt;/span&gt;+imgId,&lt;br/&gt;  })&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先是创建的接口，这里直接调用我们工具类的 CreateImage 方法拿到 key 即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的 URL 和下面这个现实的 API 关联。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 现实图片&lt;/span&gt;&lt;br/&gt;r.Handle(&lt;span&gt;&quot;GET&quot;&lt;/span&gt;, &lt;span&gt;&quot;/captcha/img/:key&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(c *gin.Context)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; captchaId := c.Param(&lt;span&gt;&quot;key&quot;&lt;/span&gt;)&lt;br/&gt; c.Writer.Header().Set(&lt;span&gt;&quot;Cache-Control&quot;&lt;/span&gt;, &lt;span&gt;&quot;no-cache, no-store, must-revalidate&quot;&lt;/span&gt;)&lt;br/&gt; c.Writer.Header().Set(&lt;span&gt;&quot;Pragma&quot;&lt;/span&gt;, &lt;span&gt;&quot;no-cache&quot;&lt;/span&gt;)&lt;br/&gt; c.Writer.Header().Set(&lt;span&gt;&quot;Expires&quot;&lt;/span&gt;, &lt;span&gt;&quot;0&quot;&lt;/span&gt;)&lt;br/&gt; c.Writer.Header().Set(&lt;span&gt;&quot;Content-Type&quot;&lt;/span&gt;, &lt;span&gt;&quot;image/png&quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;// 重载一次&lt;/span&gt;&lt;br/&gt; captcha.Instance().Reload(captchaId)&lt;br/&gt; &lt;span&gt;// 输出图片&lt;/span&gt;&lt;br/&gt; c.Writer.Write(captcha.Instance().GetImageByte(captchaId))&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们每请求一次这个 key 就重载刷新一下他的 Code，方便前端刷新。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前端只需要在这个地址后面加上随机参数即可实现刷新验证码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最关键的地方就是要设置客户端的请求头里面不能让他缓存。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 校验&lt;/span&gt;&lt;br/&gt;r.Handle(&lt;span&gt;&quot;GET&quot;&lt;/span&gt;, &lt;span&gt;&quot;/captcha/verify/:key/:val&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(c *gin.Context)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; captchaId := c.Param(&lt;span&gt;&quot;key&quot;&lt;/span&gt;)&lt;br/&gt; val := c.Param(&lt;span&gt;&quot;val&quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; captcha.Instance().Verify(captchaId,val) {&lt;br/&gt;  c.JSON(http.StatusOK, gin.H{&lt;span&gt;&quot;code&quot;&lt;/span&gt;: &lt;span&gt;200&lt;/span&gt;})&lt;br/&gt; }&lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;  c.JSON(http.StatusOK, gin.H{&lt;span&gt;&quot;code&quot;&lt;/span&gt;: &lt;span&gt;400&lt;/span&gt;})&lt;br/&gt; }&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后就是校验了，正常来说这个接口是不能放出来了的，因为：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、 captcha 库，只要校验一次，不管成功失败他的 ID 就失效了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、我们一般都只在业务里面去校验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后来看下效果吧：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100001211&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7550644567219152&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpF8Ot0ZSBRxu5SRkJVXnr4XWYb8zfbMHskOUpkfN3t8c6ur17obRic3cTibfaZv9rOict4ic75icTMzAMqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1086&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2da0edb395d491c36b657449449a760c</guid>
<title>聊聊 SQL 优化的 15 个小技巧</title>
<link>https://toutiao.io/k/48e8g89</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sql优化是一个大家都比较关注的热门话题，无论你在面试，还是工作中，都很有可能会遇到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果某天你负责的某个线上接口，出现了性能问题，需要做优化。那么你首先想到的很有可能是优化sql语句，因为它的改造成本相对于代码来说也要小得多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何优化sql语句呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章从15个方面，分享了sql优化的一些小技巧，希望对你有所帮助。&lt;/p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4396782841823057&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEU1Oia130N2IFx8rmOZ0srhia0ZuRo37mU5cwXLjKbUTqWwNP43CVkAzJQLjMAApRIf14B3LJXF7kA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;746&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1 避免使用select *&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，我们写sql语句时，为了方便，喜欢直接使用&lt;code&gt;select *&lt;/code&gt;，一次性查出表中所有列的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;反例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际业务场景中，可能我们真正需要使用的只有其中一两列。查了很多数据，但是不用，白白浪费了数据库资源，比如：内存或者cpu。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，多查出来的数据，通过网络IO传输的过程中，也会增加数据传输的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一个最重要的问题是：&lt;code&gt;select *&lt;/code&gt;不会走&lt;code&gt;覆盖索引&lt;/code&gt;，会出现大量的&lt;code&gt;回表&lt;/code&gt;操作，而从导致查询sql的性能很低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何优化呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;正例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;name&lt;/span&gt;,age &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sql语句查询时，只查需要用到的列，多余的列根本无需查出来。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2 用union all代替union&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道sql语句使用&lt;code&gt;union&lt;/code&gt;关键字后，可以获取排重后的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而如果使用&lt;code&gt;union all&lt;/code&gt;关键字，可以获取所有数据，包含重复的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;反例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;(&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;) &lt;br/&gt;&lt;span&gt;union&lt;/span&gt; &lt;br/&gt;(&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;排重的过程需要遍历、排序和比较，它更耗时，更消耗cpu资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以如果能用union all的时候，尽量不用union。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;正例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;(&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;) &lt;br/&gt;&lt;span&gt;union&lt;/span&gt; &lt;span&gt;all&lt;/span&gt;&lt;br/&gt;(&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除非是有些特殊的场景，比如union all之后，结果集中出现了重复数据，而业务场景中是不允许产生重复数据的，这时可以使用union。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3 小表驱动大表&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小表驱动大表，也就是说用小表的数据集驱动大表的数据集。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如有order和user两张表，其中order表有10000条数据，而user表有100条数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时如果想查一下，所有有效的用户下过的订单列表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用&lt;code&gt;in&lt;/code&gt;关键字实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;order&lt;/span&gt;&lt;br/&gt;&lt;span&gt;where&lt;/span&gt; user_id &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;select&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;status&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以使用&lt;code&gt;exists&lt;/code&gt;关键字实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;order&lt;/span&gt;&lt;br/&gt;&lt;span&gt;where&lt;/span&gt; &lt;span&gt;exists&lt;/span&gt; (&lt;span&gt;select&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; order.user_id = user.id &lt;span&gt;and&lt;/span&gt; &lt;span&gt;status&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面提到的这种业务场景，使用in关键字去实现业务需求，更加合适。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为如果sql语句中包含了in关键字，则它会优先执行in里面的&lt;code&gt;子查询语句&lt;/code&gt;，然后再执行in外面的语句。如果in里面的数据量很少，作为条件查询速度更快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而如果sql语句中包含了exists关键字，它优先执行exists左边的语句（即主查询语句）。然后把它作为条件，去跟右边的语句匹配。如果匹配上，则可以查询出数据。如果匹配不上，数据就被过滤掉了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个需求中，order表有10000条数据，而user表有100条数据。order表是大表，user表是小表。如果order表在左边，则用in关键字性能更好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结一下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;in&lt;/code&gt; 适用于左边大表，右边小表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;exists&lt;/code&gt; 适用于左边小表，右边大表。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管是用in，还是exists关键字，其核心思想都是用小表驱动大表。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4 批量操作&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你有一批数据经过业务处理之后，需要插入数据，该怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;反例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt;(Order order: list){&lt;br/&gt;   orderMapper.insert(order):&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在循环中逐条插入数据。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; &lt;span&gt;order&lt;/span&gt;(&lt;span&gt;id&lt;/span&gt;,code,user_id) &lt;br/&gt;&lt;span&gt;values&lt;/span&gt;(&lt;span&gt;123&lt;/span&gt;,&lt;span&gt;&#x27;001&#x27;&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该操作需要多次请求数据库，才能完成这批数据的插入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但众所周知，我们在代码中，每次远程请求数据库，是会消耗一定性能的。而如果我们的代码需要请求多次数据库，才能完成本次业务功能，势必会消耗更多的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么如何优化呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;正例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;orderMapper.insertBatch(list):&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提供一个批量插入数据的方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt; &lt;span&gt;order&lt;/span&gt;(&lt;span&gt;id&lt;/span&gt;,code,user_id) &lt;br/&gt;&lt;span&gt;values&lt;/span&gt;(&lt;span&gt;123&lt;/span&gt;,&lt;span&gt;&#x27;001&#x27;&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;),(&lt;span&gt;124&lt;/span&gt;,&lt;span&gt;&#x27;002&#x27;&lt;/span&gt;,&lt;span&gt;100&lt;/span&gt;),(&lt;span&gt;125&lt;/span&gt;,&lt;span&gt;&#x27;003&#x27;&lt;/span&gt;,&lt;span&gt;101&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样只需要远程请求一次数据库，sql性能会得到提升，数据量越多，提升越大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但需要注意的是，不建议一次批量操作太多的数据，如果数据太多数据库响应也会很慢。批量操作需要把握一个度，建议每批数据尽量控制在500以内。如果数据多于500，则分多批次处理。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5 多用limit&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们需要查询某些数据中的第一条，比如：查询某个用户下的第一个订单，想看看他第一次的首单时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;反例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;, create_date &lt;br/&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;br/&gt;&lt;span&gt;where&lt;/span&gt; user_id=&lt;span&gt;123&lt;/span&gt; &lt;br/&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; create_date &lt;span&gt;asc&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据用户id查询订单，按下单时间排序，先查出该用户所有的订单数据，得到一个订单集合。然后在代码中，获取第一个元素的数据，即首单的数据，就能获取首单时间。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Order&amp;gt; list = orderMapper.getOrderList();&lt;br/&gt;Order order = list.get(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽说这种做法在功能上没有问题，但它的效率非常不高，需要先查询出所有的数据，有点浪费资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何优化呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;正例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;, create_date &lt;br/&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;br/&gt;&lt;span&gt;where&lt;/span&gt; user_id=&lt;span&gt;123&lt;/span&gt; &lt;br/&gt;&lt;span&gt;order&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; create_date &lt;span&gt;asc&lt;/span&gt; &lt;br/&gt;&lt;span&gt;limit&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;limit 1&lt;/code&gt;，只返回该用户下单时间最小的那一条数据即可。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;此外，在删除或者修改数据时，为了防止误操作，导致删除或修改了不相干的数据，也可以在sql语句最后加上limit。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;update&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; &lt;span&gt;status&lt;/span&gt;=&lt;span&gt;0&lt;/span&gt;,edit_time=&lt;span&gt;now&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;) &lt;br/&gt;&lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&amp;gt;=&lt;span&gt;100&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;&amp;lt;&lt;span&gt;200&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;100&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样即使误操作，比如把id搞错了，也不会对太多的数据造成影响。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6 in中值太多&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于批量查询接口，我们通常会使用&lt;code&gt;in&lt;/code&gt;关键字过滤出数据。比如：想通过指定的一些id，批量查询出用户信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sql语句如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;,&lt;span&gt;name&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;category&lt;/span&gt;&lt;br/&gt;&lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3.&lt;/span&gt;.&lt;span&gt;.100000000&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们不做任何限制，该查询语句一次性可能会查询出非常多的数据，很容易导致接口超时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时该怎么办呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;,&lt;span&gt;name&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;category&lt;/span&gt;&lt;br/&gt;&lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3.&lt;/span&gt;.&lt;span&gt;.100&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;limit&lt;/span&gt; &lt;span&gt;500&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以在sql中对数据用limit做限制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过我们更多的是要在业务代码中加限制，伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Category&amp;gt; &lt;span&gt;getCategory&lt;/span&gt;&lt;span&gt;(List&amp;lt;Long&amp;gt; ids)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt;(CollectionUtils.isEmpty(ids)) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt;(ids.size() &amp;gt; &lt;span&gt;500&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BusinessException(&lt;span&gt;&quot;一次最多允许查询500条记录&quot;&lt;/span&gt;)&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; mapper.getCategoryList(ids);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一个方案就是：如果ids超过500条记录，可以分批用多线程去查询数据。每批只查500条记录，最后把查询到的数据汇总到一起返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过这只是一个临时方案，不适合于ids实在太多的场景。因为ids太多，即使能快速查出数据，但如果返回的数据量太大了，网络传输也是非常消耗性能的，接口性能始终好不到哪里去。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7 增量查询&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们需要通过远程接口查询数据，然后同步到另外一个数据库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;反例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果直接获取所有的数据，然后同步过去。这样虽说非常方便，但是带来了一个非常大的问题，就是如果数据很多的话，查询性能会非常差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;正例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;select * from user &lt;br/&gt;where id&amp;gt;#{lastId} and create_time &amp;gt;= #{lastCreateTime} &lt;br/&gt;limit &lt;span&gt;100&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按id和时间升序，每次只同步一批数据，这一批数据只有100条记录。每次同步完成之后，保存这100条数据中最大的id和时间，给同步下一批数据的时候用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这种增量查询的方式，能够提升单次查询的效率。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8 高效的分页&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，列表页在查询数据时，为了避免一次性返回过多的数据影响接口性能，我们一般会对查询接口做分页处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在mysql中分页一般用的&lt;code&gt;limit&lt;/code&gt;关键字：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;,&lt;span&gt;name&lt;/span&gt;,age &lt;br/&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果表中数据量少，用limit关键字做分页，没啥问题。但如果表中数据量很多，用它就会出现性能问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如现在分页参数变成了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;,&lt;span&gt;name&lt;/span&gt;,age &lt;br/&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;1000000&lt;/span&gt;,&lt;span&gt;20&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mysql会查到1000020条数据，然后丢弃前面的1000000条，只查后面的20条数据，这个是非常浪费资源的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，这种海量数据该怎么分页呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优化sql：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;,&lt;span&gt;name&lt;/span&gt;,age &lt;br/&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &amp;gt; &lt;span&gt;1000000&lt;/span&gt; &lt;span&gt;limit&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先找到上次分页最大的id，然后利用id上的索引查询。不过该方案，要求id是连续的，并且有序的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还能使用&lt;code&gt;between&lt;/code&gt;优化分页。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;,&lt;span&gt;name&lt;/span&gt;,age &lt;br/&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &lt;span&gt;between&lt;/span&gt; &lt;span&gt;1000000&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;1000020&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是between要在唯一索引上分页，不然会出现每页大小不一致的问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9 用连接查询代替子查询&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mysql中如果需要从两张以上的表中查询出数据的话，一般有两种实现方式：&lt;code&gt;子查询&lt;/code&gt; 和 &lt;code&gt;连接查询&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;子查询的例子如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; &lt;span&gt;order&lt;/span&gt;&lt;br/&gt;&lt;span&gt;where&lt;/span&gt; user_id &lt;span&gt;in&lt;/span&gt; (&lt;span&gt;select&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;where&lt;/span&gt; &lt;span&gt;status&lt;/span&gt;=&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;子查询语句可以通过&lt;code&gt;in&lt;/code&gt;关键字实现，一个查询语句的条件落在另一个select语句的查询结果中。程序先运行在嵌套在最内层的语句，再运行外层的语句。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;子查询语句的优点是简单，结构化，如果涉及的表数量不多的话。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但缺点是mysql执行子查询时，需要创建临时表，查询完毕后，需要再删除这些临时表，有一些额外的性能消耗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时可以改成连接查询。具体例子如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; o.* &lt;span&gt;from&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; o&lt;br/&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; u &lt;span&gt;on&lt;/span&gt; o.user_id = u.id&lt;br/&gt;&lt;span&gt;where&lt;/span&gt; u.status=&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10 join的表不宜过多&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据阿里巴巴开发者手册的规定，join表的数量不应该超过&lt;code&gt;3&lt;/code&gt;个。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;反例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; a.name,b.name.c.name,d.name&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; a &lt;br/&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; b &lt;span&gt;on&lt;/span&gt; a.id = b.a_id&lt;br/&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; c &lt;span&gt;on&lt;/span&gt; c.b_id = b.id&lt;br/&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; d &lt;span&gt;on&lt;/span&gt; d.c_id = c.id&lt;br/&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; e &lt;span&gt;on&lt;/span&gt; e.d_id = d.id&lt;br/&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; f &lt;span&gt;on&lt;/span&gt; f.e_id = e.id&lt;br/&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; g &lt;span&gt;on&lt;/span&gt; g.f_id = f.id&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果join太多，mysql在选择索引的时候会非常复杂，很容易选错索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且如果没有命中中，nested loop join 就是分别从两个表读一行数据进行两两对比，复杂度是 n^2。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们应该尽量控制join表的数量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;正例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; a.name,b.name.c.name,a.d_name &lt;br/&gt;&lt;span&gt;from&lt;/span&gt; a &lt;br/&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; b &lt;span&gt;on&lt;/span&gt; a.id = b.a_id&lt;br/&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; c &lt;span&gt;on&lt;/span&gt; c.b_id = b.id&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果实现业务场景中需要查询出另外几张表中的数据，可以在a、b、c表中&lt;code&gt;冗余专门的字段&lt;/code&gt;，比如：在表a中冗余d_name字段，保存需要查询出的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过我之前也见过有些ERP系统，并发量不大，但业务比较复杂，需要join十几张表才能查询出数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以join表的数量要根据系统的实际情况决定，不能一概而论，尽量越少越好。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11 join时要注意&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在涉及到多张表联合查询的时候，一般会使用&lt;code&gt;join&lt;/code&gt;关键字。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而join使用最多的是left join和inner join。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;left join&lt;/code&gt;：求两个表的交集外加左表剩下的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;inner join&lt;/code&gt;：求两个表交集的数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用inner join的示例如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; o.id,o.code,u.name &lt;br/&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; o &lt;br/&gt;&lt;span&gt;inner&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; u &lt;span&gt;on&lt;/span&gt; o.user_id = u.id&lt;br/&gt;&lt;span&gt;where&lt;/span&gt; u.status=&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果两张表使用inner join关联，mysql会自动选择两张表中的小表，去驱动大表，所以性能上不会有太大的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用left join的示例如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; o.id,o.code,u.name &lt;br/&gt;&lt;span&gt;from&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; o &lt;br/&gt;&lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; u &lt;span&gt;on&lt;/span&gt; o.user_id = u.id&lt;br/&gt;&lt;span&gt;where&lt;/span&gt; u.status=&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果两张表使用left join关联，mysql会默认用left join关键字左边的表，去驱动它右边的表。如果左边的表数据很多时，就会出现性能问题。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;要特别注意的是在用left join关联查询时，左边要用小表，右边可以用大表。如果能用inner join的地方，尽量少用left join。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12 控制索引的数量&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，索引能够显著的提升查询sql的性能，但索引数量并非越多越好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为表中新增数据时，需要同时为它创建索引，而索引是需要额外的存储空间的，而且还会有一定的性能消耗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阿里巴巴的开发者手册中规定，单表的索引数量应该尽量控制在&lt;code&gt;5&lt;/code&gt;个以内，并且单个索引中的字段数不超过&lt;code&gt;5&lt;/code&gt;个。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mysql使用的B+树的结构来保存索引的，在insert、update和delete操作时，需要更新B+树索引。如果索引过多，会消耗很多额外的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，问题来了，如果表中的索引太多，超过了5个该怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题要辩证的看，如果你的系统并发量不高，表中的数据量也不多，其实超过5个也可以，只要不要超过太多就行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但对于一些高并发的系统，请务必遵守单表索引数量不要超过5的限制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，高并发系统如何优化索引数量？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;能够建联合索引，就别建单个索引，可以删除无用的单个索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将部分查询功能迁移到其他类型的数据库中，比如：Elastic Seach、HBase等，在业务表中只需要建几个关键索引即可。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13 选择合理的字段类型&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;char&lt;/code&gt;表示固定字符串类型，该类型的字段存储空间的固定的，会浪费存储空间。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;alter&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;br/&gt;&lt;span&gt;add&lt;/span&gt; &lt;span&gt;column&lt;/span&gt; code &lt;span&gt;char&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;varchar&lt;/code&gt;表示变长字符串类型，该类型的字段存储空间会根据实际数据的长度调整，不会浪费存储空间。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;alter&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;order&lt;/span&gt; &lt;br/&gt;&lt;span&gt;add&lt;/span&gt; &lt;span&gt;column&lt;/span&gt; code &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是长度固定的字段，比如用户手机号，一般都是11位的，可以定义成char类型，长度是11字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果是企业名称字段，假如定义成char类型，就有问题了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果长度定义得太长，比如定义成了200字节，而实际企业长度只有50字节，则会浪费150字节的存储空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果长度定义得太短，比如定义成了50字节，但实际企业名称有100字节，就会存储不下，而抛出异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以建议将企业名称改成varchar类型，变长字段存储空间小，可以节省存储空间，而且对于查询来说，在一个相对较小的字段内搜索效率显然要高些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在选择字段类型时，应该遵循这样的原则：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;能用数字类型，就不用字符串，因为字符的处理往往比数字要慢。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;尽可能使用小的类型，比如：用bit存布尔值，用tinyint存枚举值等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;长度固定的字符串字段，用char类型。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;长度可变的字符串字段，用varchar类型。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;金额字段用decimal，避免精度丢失问题。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有很多原则，这里就不一一列举了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;14 提升group by的效率&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们有很多业务场景需要使用&lt;code&gt;group by&lt;/code&gt;关键字，它主要的功能是去重和分组。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常它会跟&lt;code&gt;having&lt;/code&gt;一起配合使用，表示分组后再根据一定的条件过滤数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;反例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; user_id,user_name &lt;span&gt;from&lt;/span&gt; &lt;span&gt;order&lt;/span&gt;&lt;br/&gt;&lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; user_id&lt;br/&gt;&lt;span&gt;having&lt;/span&gt; user_id &amp;lt;= &lt;span&gt;200&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种写法性能不好，它先把所有的订单根据用户id分组之后，再去过滤用户id大于等于200的用户。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分组是一个相对耗时的操作，为什么我们不先缩小数据的范围之后，再分组呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;正例：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;select&lt;/span&gt; user_id,user_name &lt;span&gt;from&lt;/span&gt; &lt;span&gt;order&lt;/span&gt;&lt;br/&gt;&lt;span&gt;where&lt;/span&gt; user_id &amp;lt;= &lt;span&gt;200&lt;/span&gt;&lt;br/&gt;&lt;span&gt;group&lt;/span&gt; &lt;span&gt;by&lt;/span&gt; user_id&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用where条件在分组前，就把多余的数据过滤掉了，这样分组时效率就会更高一些。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;其实这是一种思路，不仅限于group by的优化。我们的sql语句在做一些耗时的操作之前，应尽可能缩小数据范围，这样能提升sql整体的性能。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;15 索引优化&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sql优化当中，有一个非常重要的内容就是：&lt;code&gt;索引优化&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候sql语句，走了索引，和没有走索引，执行效率差别很大。所以索引优化被作为sql优化的首选。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;索引优化的第一步是：检查sql语句有没有走索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何查看sql走了索引没？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用&lt;code&gt;explain&lt;/code&gt;命令，查看mysql的执行计划。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;explain select * from `order` where code=&lt;span&gt;&#x27;002&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.07168894289185905&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEU1Oia130N2IFx8rmOZ0srh12xmAaI6TZBZaPVU13tmEaRT9ibvoaMp0lGrvmRyV2dfCdCY5M01Ruw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1646&quot;/&gt;通过这几列可以判断索引使用情况，执行计划包含列的含义如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1130434782608696&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEU1Oia130N2IFx8rmOZ0srhRJiaf4SicPlQ725icaeYAgLlmhTz7UVFfMpPx82njv3JKUicnvuBeaKuVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;920&quot;/&gt;如果你想进一步了解explain的详细用法，可以看看我的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUxODkzNTQ3Nw==&amp;amp;mid=2247485392&amp;amp;idx=1&amp;amp;sn=a0a2728179e20ad09487f09e0a785ec2&amp;amp;chksm=f980010acef7881c0591beb4e90220de5c283a63c74e02910830f4cb99922c388ee0226e7c88&amp;amp;token=393604486&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;explain | 索引优化的这把绝世好剑，你真的会用吗？&lt;/a&gt;》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说实话，sql语句没有走索引，排除没有建索引之外，最大的可能性是索引失效了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面说说索引失效的常见原因：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7130281690140845&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEU1Oia130N2IFx8rmOZ0srhPUxuOdm28F1LkrKrHxItEX79Yey6orTlywyQEFB4JymRVOQIa3MUXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1136&quot;/&gt;如果不是上面的这些原因，则需要再进一步排查一下其他原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，你有没有遇到过这样一种情况：明明是同一条sql，只有入参不同而已。有的时候走的索引a，有的时候却走的索引b？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，有时候mysql会选错索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;必要时可以使用&lt;code&gt;force index&lt;/code&gt;来强制查询sql走某个索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于为什么mysql会选错索引，后面有专门的文章介绍的，这里先留点悬念。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>398ffc4b0606918cbbfa497e29d9e12c</guid>
<title>基于深度学习的音频编/解码的实现与落地挑战</title>
<link>https://toutiao.io/k/vnjvfv1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;今年也是基于深度学习的音频编解码的元年，各家公司都发布了一些编解码器。声网在今年也公布了自研的 AI-Codec 技术——Silver。在本场大会上，声网Agora 音频算法专家冯建元分享了基于深度学习的音频编解码器的研究，以及落地挑战。关注本文标签「RTE 技术分享」，我们将陆续更新更多演讲干货。以下为演讲实录。&lt;/span&gt;&lt;/em&gt;&lt;span/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5Fdmibt2lwubxrTWdicSIsXj7K8Pg0NzPIoyibsXQLrQQgcDQ4kEw2bmjt95eg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;▲图：声网Agora 音频算法专家 冯建元&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5Fdmibaicj3nqyHtEB3cHrL6gryWzNw2z3sXlH5QguPicvAWLSibiaXffGk197gg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;冯建元认为目前市面上主流的基于深度学习的音频编码解码器主要有 Silver、Lyra、Satin、LPCnet、SoundStream 这几种，他们分别有各自的优缺点，于是乎整理了一张表格，显示得更佳直观。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibAGrQVa6Hl4hn9zQVibC3PQ2zsg4EJ01CxF8SiaYxzl4Za6wQayW8uSDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以从这张表格中很清楚的看到 Silver 和 Satin 支持的比特率是最高的，LPCnet 支持的比特率是最低的，其它几个 AI codec 则相差无几，同时只有 SoundStream 是支持音乐的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibgrlVT4OTb2WLGqYxrQWrbGp1tzLDL4Y7Qkk4omrk6LiawUoBF8nYL4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;冯建元讲解了一下基于深度学习的编解码的具体的几种实现框架，第一种是基于 AI-vocoder。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibbggSDhgUibosVuRyN6T43VhJDtDPFHpNdfyxPUjusYHPmV4hicjb9reg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先是是特征提取，然后编码压缩，最后提取特征，可以使用 AI-vocoder 这个框架去完成整体的操作。AI-vocoder 在 TTS 等场景中可以获得十分接近人类正常说话的水平的 MOS 分。他的核心有两点：首先逐点生成的自回归模型可以带来一个巨大的音质提升，同时编码算力低，而解码算力高，更加适合语音的编码解码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibNC9M96aiabM0mvYcI2bR3W57HkjAUE9G1PCw0erch7znATC8rAgZIEA/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二种是基于 Auto-encoder 的一个自编码的框架，上面的那个框架虽然可以在纯人声的场景下表现不错，但是在噪声鲁棒性等方面表现总是不尽如人意，于是就有了基于 Auto-encoder 以及变种的深度学习，这个框架在降噪、变声等更为专业的领域都有着不错的效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5Fdmibh3j4ib4fiaSNpibpicDbruqJrkiayT00ChxYNVGOM7MO6icq2TU7t8GiaWQdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;883&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Auto-encoder 的核心也很简单，就是利用深度学习的模型来做到端到端的音频压缩和编码、解码。特点是这种方式的编解码算力都比较高，但可以同时处理语音和音乐。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibBEhefzC9ETUsK33CgcJ33diby4rIIeiauC6KQUkTmA2eN40q7LUEhRuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;411&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibhfYLibib1sqb4oEE4DDmhicktvx0mV9hLj2GBoaGQRQOiacEOgElqiaCaqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;基于深度学习的编解码器存在三个问题：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第一个是噪声鲁棒性，&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;在噪声的情况下，由于低码率的传输，会影响我们对噪声的听感，有的噪声不会令人厌烦。但是如果在一个低码率的情况下，它的噪声可能会变成杂音，听上去很不自然，降低了听感。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第二个是移动端部署的实时性，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;也需要做很多的工程部署挑战。算力比较受限的情况下，做实时的编解码，甚至还需要多路同时进行解码的工作，这时都会受到实时性的挑战。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第三个是低码率的实时生成的稳定性，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在这里会发现模型的算力越大，码率越高，自然度就越好。但是 AI 模型在一些低码率的情况下，本就需要更多的算力来保证自然度，而模型又同时受到算力的影响，也不能太大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们从以下两个音频对比，就可以直观感受其中存在的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section class=&quot;custom_select_card_wrp wx-edui-media-wrp&quot;&gt;&lt;mpvoice class=&quot;js_editor_audio audio_iframe js_uneditable custom_select_card&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/audio_tmpl&amp;amp;name=%E5%8E%9F%E5%A3%B0&amp;amp;play_length=00:06&quot; isaac2=&quot;1&quot; low_size=&quot;11.07&quot; source_size=&quot;11.1&quot; high_size=&quot;35.48&quot; name=&quot;原声&quot; play_length=&quot;6000&quot; voice_encode_fileid=&quot;MzU1NjU4NzE0Ml8yMjQ3NDg1MTUx&quot; data-topic_id=&quot;&quot; data-topic_name=&quot;&quot; data-pluginname=&quot;insertaudio&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;custom_select_card_wrp wx-edui-media-wrp&quot;&gt;&lt;mpvoice class=&quot;js_editor_audio audio_iframe js_uneditable custom_select_card&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/audio_tmpl&amp;amp;name=%E4%B8%8D%E5%81%9A%E5%A4%84%E7%90%86%E7%9A%84DL-codec&amp;amp;play_length=00:05&quot; isaac2=&quot;1&quot; low_size=&quot;10.74&quot; source_size=&quot;10.7&quot; high_size=&quot;17.55&quot; name=&quot;不做处理的DL-codec&quot; play_length=&quot;5000&quot; voice_encode_fileid=&quot;MzU1NjU4NzE0Ml8yMjQ3NDg1MTUy&quot; data-topic_id=&quot;&quot; data-topic_name=&quot;&quot; data-pluginname=&quot;insertaudio&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibyNcuAu9xyuxnz9LMic7bARyxzkpyQ3EhhVeNed46NDXJHTXYHbYFFVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先看一下深度学习编解码器问题的大致的框架。AI 在降噪领域已经相对成熟，如果你是做一款语音编解码器，你要传递的信息就是语音，这时 AI 降噪就可以做一个很好的前处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在做编解码器之前，我们先用 AI 降噪的方法来实现。基于深度学习网络的降噪，能够很好地提取语音信号，把这些噪声、杂音都去掉。这里要注意降噪算法需要和编解码器的采样率相匹配，在编解码之前我们加入了一个实时的全频带的 AI 降噪算法，最高支持到 48K Hz 的采样率的语音信号的提纯、降噪。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样，大部分的噪声已经被去除，就可以很好地降低码率，同时降低模型的编解码的难度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是 AI 在降噪也是引入了额外的算力。在移动端部署时，基于深度学习的降噪和传统算法的语音分析作为编码，能够在像高通 855 的单核上实现 0.05RTF 的实时编码，也就是可以 20 倍实时编码，算力可以做到很低。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibQULebqGPUKNVKKl6RDJRv5K41fudwSERMhZuoiaxaOJkzZ8rldkUe2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Silver 语音编解码器有四个优点：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第一个是可以结局噪声鲁棒性的问题，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;加入了实时全频带的 AI 降噪算法，可以更大程度上降低噪音。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第二个是移动端的实时性，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;基于深度学习的降噪和传统算法的语音分析相结合进行编码，高通 855 单核上可以实现 0.05RTF 的实时编码，同时有基于深度优化的 WaveRNN 模型以及极小的算力实现语音解码，高通 855 单核上可以实现 0.125RTF 的实时解码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第三个是有超低码率，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;仅仅只有 3.6kbps。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第四个是自然，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;这也是最重要的，它支持高音质，支持 32KHz 采样率，超宽带音质编码，音色饱满自然，给你不一样的体验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5Fdmibp4OO5pqOiawibyu2R3uuibaKHA7GnSlsAuXWzbjQlI5nXm1GKxUatnYGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;833&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;市面上主流的解码/编码器的比较图如下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibjIRX32O7TYYKJEFvzJ8NbKicjicQFJXl32NfaCiam8KJTagicWlHHt9XpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;574&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5Fdmib9kVCpNUt5Ds71lmsfebTQJYBNftlIDEVtJayVgA0WFMgaHX3oxRDcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;942&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibMFUbLibYU3DBSMQy3UY9MJ1zpd1VCLMGu7B0J7sUuj2KzSnGw7chNrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大概可以分为三个方向来说明，首先是前处理，AI-NS 降噪算法可以提升语音信噪比，从而减少低码率带来的 artifact。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次是编码，基于传统算法的分频带特征提取（基频、子带频谱包络、能量等），而基于 RVQ、距离编码等方法可以实现特征编码，从而达到节省码率的效果。最后一步是解码，采用自回归模型和宽带拓展的 WaveRNN 模型实现模型算力的精简，基于自研的多平台 AI 推理引擎实现的非对称量化、混合精度推理、计算压缩解码耗时会更少。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibZjzffvaGJGvwicicElWf5DMtRDvibzDMMFx6WJkRepWQNsDW2UIedCBgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;982&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section class=&quot;custom_select_card_wrp wx-edui-media-wrp&quot;&gt;&lt;mpvoice class=&quot;js_editor_audio audio_iframe js_uneditable custom_select_card&quot; src=&quot;https://mp.weixin.qq.com/cgi-bin/readtemplate?t=tmpl/audio_tmpl&amp;amp;name=%E5%8E%9F%E5%A3%B0&amp;amp;play_length=00:06&quot; isaac2=&quot;1&quot; low_size=&quot;11.02&quot; source_size=&quot;11&quot; high_size=&quot;47.29&quot; name=&quot;原声&quot; play_length=&quot;6000&quot; voice_encode_fileid=&quot;MzU1NjU4NzE0Ml8yMjQ3NDg1MTUz&quot; data-topic_id=&quot;&quot; data-topic_name=&quot;&quot; data-pluginname=&quot;insertaudio&quot; data-name=&quot;原声&quot; data-length=&quot;0:((time % 60000) / 1000)&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;custom_select_card_wrp wx-edui-media-wrp&quot;&gt;&lt;mpvoice class=&quot;js_editor_audio audio_iframe js_uneditable custom_select_card&quot; src=&quot;https://mp.weixin.qq.com/cgi-bin/readtemplate?t=tmpl/audio_tmpl&amp;amp;name=Opus&amp;amp;play_length=00:06&quot; isaac2=&quot;1&quot; low_size=&quot;11.02&quot; source_size=&quot;11&quot; high_size=&quot;17.97&quot; name=&quot;Opus&quot; play_length=&quot;6000&quot; voice_encode_fileid=&quot;MzU1NjU4NzE0Ml8yMjQ3NDg1MTU0&quot; data-topic_id=&quot;&quot; data-topic_name=&quot;&quot; data-pluginname=&quot;insertaudio&quot; data-name=&quot;Opus&quot; data-length=&quot;0:((time % 60000) / 1000)&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;custom_select_card_wrp wx-edui-media-wrp&quot;&gt;&lt;mpvoice class=&quot;js_editor_audio audio_iframe js_uneditable custom_select_card&quot; src=&quot;https://mp.weixin.qq.com/cgi-bin/readtemplate?t=tmpl/audio_tmpl&amp;amp;name=Silver&amp;amp;play_length=00:06&quot; isaac2=&quot;1&quot; low_size=&quot;11&quot; source_size=&quot;11&quot; high_size=&quot;35.48&quot; name=&quot;Silver&quot; play_length=&quot;6000&quot; voice_encode_fileid=&quot;MzU1NjU4NzE0Ml8yMjQ3NDg1MTU1&quot; data-topic_id=&quot;&quot; data-topic_name=&quot;&quot; data-pluginname=&quot;insertaudio&quot; data-name=&quot;Silver&quot; data-length=&quot;0:((time % 60000) / 1000)&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在传统的编解码里面，码率越低，能支持的采样率也越低，听起来高频部分会有很多衰减。同时在噪声环境下，听到了风噪，由于它的降噪能力，又能体现出在噪声环境下的低码率的编解码的能力。所以，在采样率和抗噪能力上，都能够有不错的提升。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上是关于编解码器本身的能力，但进行在移动端的部署，就会遇到很多需要去权衡码率、算力的效果这些方面的问题和挑战。以 AI-vocoder为例给大家进行介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;刚提到，越大的模型，算力越大，越能够提供比较好的声音还原能力。对 TTS 或者是语音生成的模型进行对比，不同的模型生成，跑出来的主观评测的分数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;例如 WavNet 的算力是 100G，几乎在 CPU 上完全不可能，只能在 GPU 上的，甚至在 GPU 上也不能做到实时的算力。它的评分能达到 90，几乎接近于满分。比它小的是 WavRNN 模型，算力降了 6 倍左右，其实可以达到 16.3GFLOPS，它的分数也降了不少，降到了 75 分。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样一个算力在一些 GPU 端，已经可以做到实时，但是如果放到 CPU 上，或者手机的移动端上，还不能实现。比如LPCnet已经降到了 3GFLOPS，大概是 70 分，大概是可用的分数线。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到，模型越大，主观生成的音频质量越好。但是要找到其中的一个平衡点即用多大的算力去能够实现实时性，同时分数又不会降得太低。可以想到在自回归的逐点生成的编解码器，如果在低频段用逐点生成，高频采用一些 BWE 的技术进行高频的扩展，这样就会损到很多高频带宽编解码的算力，就能够把它降下来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要是看做了哪些处理。前处理部分，提升信噪比也是减少码率的较好的措施。如果经过了 AI 降噪以后的语音，再做编解码，自然就可以把它的码率压到更低，同时在还原时又不去影响它的音质。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外在编码的时候，基于传统算法的分频带的特征提取，可以分成不同的子带，每个子带有不同的处理形式。通过一些特征的建模，在编码处就可以把它分成不同的频带去针对性地处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;传统方法也有类似，比如距离编码，可以实现特征维度的压缩。这样，可以把码率压到 3.6K pbs。在解码端的时候，自回归模型就会把它拆成两个部分，去做低频的部分，然后结合 BWE，实现对模型的改造，这样可以实现模型算力的精简。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在部署的时候，比如 ARM 平台数据一般以4为单位组合计算，在其他平台基于不同芯片计算优化也不同，会涉及到多平台的优化。这里我们有一个自研的多平台的 AI 推力引擎，去实现量化、混合精度推理的加速，在工程的角度上进一步压缩解码端的耗时。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后我们可以看看深度学习现在到了一个什么样的阶段，以及后续会有哪些可以做的方向。对于现在还是针对于极低码率的编码，看看深度学习能够把音频还原到什么样的程度。其实用深度学习，已经能够实现在 10K 以下的码率，超越传统的编解码器。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再往上，传统算法是在 100K pbs 以上，这已经能够做到我们对音频的编解码透明的状态，我们编解码后，大家已经分辨不出它是否经过编解码。在这种角度上说，AI-codec 现在还没有能够完美地还原音频编解码的能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再比如大于 100K pbs，我们甚至可以编一些立体声的声音。超过 100K pbs，甚至可以编一些多通道的音频。再对音质体验的更高的要求，如果能把码率降下来，对于基于深度学习的音频编解码器会带来更多收益，这也是冯建元的研究方向。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了编解码本身，为了保证整条音频链路沟通的流畅性，我们还需要很多弱网的丢包的策略。比如一个比较低码率的编解码器，能够更好地去冗余、重传，这也可以更方便地做。比如本来冗余只能多做一倍，现在因为码率比较低，可以做更多倍的冗余，在弱网情况下，它的音质体验会更好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于生成的模型，在做丢包补偿，如果丢一个包，后续可以把这个包再恢复出来，这也是不错的尝试，后续我们会给大家放一个 demo。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们现在基本上能做到把深度学习的编解码器放到移动端，但是我们现在能最多做到的解码，是在高通 855 芯片上做到8路同时的解码。但是如果在一些低端的手机，可能就做不了这么多路，还需要在低端算力的多路编解码的能力上去进行一些持续的优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了 Agora 本身能够降低码率外，其实还能够在一些丢包补偿上进行进一步提升。如果是 Agora 的解码部分，即 AI 的声码器，冯建元对做丢包补偿效果做了音频展示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section class=&quot;custom_select_card_wrp wx-edui-media-wrp&quot;&gt;&lt;mpvoice class=&quot;js_editor_audio audio_iframe js_uneditable custom_select_card&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/audio_tmpl&amp;amp;name=AI%20PLC%E8%A1%A5%E5%81%BF%E5%89%8D%E7%9A%84%E7%94%B7%E5%A3%B0&amp;amp;play_length=00:06&quot; isaac2=&quot;1&quot; low_size=&quot;9.35&quot; source_size=&quot;9.4&quot; high_size=&quot;17.87&quot; name=&quot;AI PLC补偿前的男声&quot; play_length=&quot;6000&quot; voice_encode_fileid=&quot;MzU1NjU4NzE0Ml8yMjQ3NDg1MTU2&quot; data-topic_id=&quot;&quot; data-topic_name=&quot;&quot; data-pluginname=&quot;insertaudio&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;custom_select_card_wrp wx-edui-media-wrp&quot;&gt;&lt;mpvoice class=&quot;js_editor_audio audio_iframe js_uneditable custom_select_card&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/audio_tmpl&amp;amp;name=AI%20PLC%E8%A1%A5%E5%81%BF%E5%89%8D%E7%9A%84%E5%A5%B3%E5%A3%B0&amp;amp;play_length=00:03&quot; isaac2=&quot;1&quot; low_size=&quot;6.27&quot; source_size=&quot;6.3&quot; high_size=&quot;11.75&quot; name=&quot;AI PLC补偿前的女声&quot; play_length=&quot;3000&quot; voice_encode_fileid=&quot;MzU1NjU4NzE0Ml8yMjQ3NDg1MTU3&quot; data-topic_id=&quot;&quot; data-topic_name=&quot;&quot; data-pluginname=&quot;insertaudio&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;custom_select_card_wrp wx-edui-media-wrp&quot;&gt;&lt;mpvoice class=&quot;js_editor_audio audio_iframe js_uneditable custom_select_card&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/audio_tmpl&amp;amp;name=AI%20PLC%E8%A1%A5%E5%81%BF%E5%90%8E%E7%9A%84%E7%94%B7%E5%A3%B0&amp;amp;play_length=00:06&quot; isaac2=&quot;1&quot; low_size=&quot;11.36&quot; source_size=&quot;11.4&quot; high_size=&quot;17.87&quot; name=&quot;AI PLC补偿后的男声&quot; play_length=&quot;6000&quot; voice_encode_fileid=&quot;MzU1NjU4NzE0Ml8yMjQ3NDg1MTU4&quot; data-topic_id=&quot;&quot; data-topic_name=&quot;&quot; data-pluginname=&quot;insertaudio&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;custom_select_card_wrp wx-edui-media-wrp&quot;&gt;&lt;mpvoice class=&quot;js_editor_audio audio_iframe js_uneditable custom_select_card&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/audio_tmpl&amp;amp;name=AI%20PLC%E8%A1%A5%E5%81%BF%E5%90%8E%E7%9A%84%E5%A5%B3%E5%A3%B0&amp;amp;play_length=00:03&quot; isaac2=&quot;1&quot; low_size=&quot;7.54&quot; source_size=&quot;7.5&quot; high_size=&quot;11.75&quot; name=&quot;AI PLC补偿后的女声&quot; play_length=&quot;3000&quot; voice_encode_fileid=&quot;MzU1NjU4NzE0Ml8yMjQ3NDg1MTU5&quot; data-topic_id=&quot;&quot; data-topic_name=&quot;&quot; data-pluginname=&quot;insertaudio&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以听到在补偿之前，因为有丢包，所以声音是不连续的，在可懂度方面下降得很快，在弱网情况下就很影响听感，甚至不知道对方在说什么。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在经过 PLC 之后，模型是一样的，可以复用 AI 的解码能力，就能够把丢失掉的包的信息补偿回来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总结：基于 TTS 的发展，我们一步一步地实现了深度学习的音频编解码器。类似的这种框架，可以在音频的框架中再找一找，可能还有其他方向的发展。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在现阶段，音频编解码器还面临着很多比如噪声鲁棒性、实时性以及低码率的音频生成的稳定性的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Silver 提供了一种可落地的实现方案，它的特性主要来源于 AI 降噪对于它的前处理，解决了噪声的问题，采用频带扩展、自回归模型相结合的形式，还有多平台的工程优化，最后实现了移动端的部署。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在深度学习的音频编解码中，还有高音质、多通道以及对抗弱网等方向，期待有更多发展。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5Fdmib9Dv8e1RutetIqiaIfUMUSGZtRmDWGdg4oxBPsjmibh8vdF5CKKtSiao4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于未来的深度学习的音频编码/解码将有三点展望，首先第一点是对于低码率、高保真编/解码器能力边界的探索，其次是增加立体声、多通道音频的编/解码的能力，同时增加弱网抗丢包等场景的策略完善，最后是对于低端算力的多路编解码的持续算力优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iaJdNvKAPusTQzuWnbyl3wDD9Aux5FdmibWIF2quSr2nxLQ7r0d1AYzgUl2PJLoPxsd4VQIM6FNYLpFOesepJw9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>35a967bca263f891d5fc3f9240fb0a7a</guid>
<title>使用机器学习检测结肠镜检查中的覆盖不足</title>
<link>https://toutiao.io/k/53h6lyi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;p&gt;结直肠癌(CRC) 是一个全球性的健康问题，也是美国第二大致命癌症，估计每年导致90 万人死亡。虽然是致命的，但可以通过在结肠癌前病变（称为息肉）癌变之前去除它们来预防 CRC。事实上，据估计，腺瘤检出率（ADR，定义为医生发现至少一个息肉的手术比例）每增加1%，间期 CRC的发生率就会降低 6%（a在结肠镜检查阴性后 60 个月内诊断出的结直肠癌）。&lt;/p&gt;&lt;p&gt;结肠镜检查被认为是检测和去除息肉的金标准程序。不幸的是，文献表明内窥镜医师在结肠镜检查期间平均漏诊 22%-28% 的息肉；此外，有 20% 到 24% 有可能癌变的息肉（腺瘤）被遗漏了。可能导致内窥镜医师漏诊息肉的两个主要因素是 (1) 息肉出现在视野中，但内窥镜医师可能会由于其体积小或形状扁平而漏诊；(2) 息肉未出现在视野内，因为内窥镜医师在手术过程中没有完全覆盖相关区域。&lt;/p&gt;&lt;p&gt;在“检测结肠镜检查中的不足覆盖率”中，我们介绍了通过深度算法或 C2D2 的结肠镜检查覆盖率不足，这是一种基于机器学习的提高结肠镜检查覆盖率的方法。C2D2 算法在手术过程中捕获图像时执行结肠的局部 3D 重建，并在此基础上识别结肠的哪些区域被覆盖，哪些区域留在视野之外。然后，C2D2 可以实时指示结肠的特定区域是否存在覆盖不足的问题，以便内窥镜医师可以返回该区域。我们的工作提出了一种实时计算覆盖率的新方法，为此使用无校准、无监督学习方法完成 3D 重建，并以大规模方式对其进行评估。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;em&gt;C2D2 算法&lt;/em&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;在考虑结肠覆盖率时，重要的是估计覆盖率——完整程序覆盖相关区域的百分比。虽然回顾性分析对医生很有用，并且可以为未来的程序提供一般指导，但在逐段的基础上实时估计覆盖率更有用，即了解当前段的哪个部分已经被穿过结肠时被覆盖。这种功能的帮助是显而易见的：在程序本身期间，医生可能会收到覆盖不足的部分的警报，并且可以立即返回查看这些区域。更高的覆盖率将导致更高比例的息肉被看到。&lt;/p&gt;&lt;p&gt;C2D2 算法旨在分两个阶段计算这种逐段覆盖：为结肠镜检查视频的每一帧计算深度图，然后根据这些深度图计算覆盖范围。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceGmEBxnwnm3SzjciaM4oicDlUHv1shn8P4WUhGskvPIlPEic3O7RX5w37ueEqmalicoRbNvSoibibqOhHLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;p&gt;深度图创建包括深度估计和姿势估计——内窥镜在空间中的位置以及它指向的方向。除了检测覆盖不足之外，深度和姿态估计对于各种其他有趣的任务也很有用。例如，深度可用于改进扁平息肉的检测，而姿势估计可用于重新定位内窥镜医师希望重新访问的结肠区域（包括息肉），并且两者一起可用于可视化和导航。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceGmEBxnwnm3SzjciaM4oicDlUINm6rn9nAhia1U7usjiaXhBiakf1tTTKia1ztwVJlwH0CJwHJuk42LHvpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;为了从这些深度图中计算覆盖率，我们在两个数据源上训练了 C2D2：合成序列和真实序列。我们使用冒号的图形模型生成了合成视频。对于每个合成视频，地面实况覆盖率以 0（完全未覆盖）和 1（完全覆盖）之间的数字形式提供。对于真实序列，我们分析了去识别化的结肠镜检查视频，因此无法获得地面实况覆盖。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;em&gt;合成视频的性能&lt;/em&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;使用合成视频时，地面实况覆盖的可用性可以直接测量 C2D2 的性能。我们使用平均绝对误差(MAE)对此进行量化，该平均绝对误差表明算法的预测与真实情况的平均差异程度。我们发现C2D2的MAE=0.075；这意味着，平均而言，C2D2 的预测在真实情况的 7.5% 以内。相比之下，一组执行相同任务的医生实现了 MAE = 0.177，即在基本事实的 17.7% 以内。因此，C2D2 在合成序列上的准确率提高了 2.4 倍。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;em&gt;在真实视频上&lt;/em&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;的表现 当然，最重要的是在真实结肠镜检查视频上的表现。这种情况下的挑战是缺乏真实标签：我们不知道实际覆盖范围是什么。此外，由于前面描述的挑战，人们不能直接使用专家提供的标签，因为它们并不总是准确的。但是，C2D2 仍然可以对真实的结肠镜视频进行推理。事实上，学习管道旨在在合成和真实结肠镜检查视频上表现同样出色。&lt;/p&gt;&lt;p&gt;为了验证真实序列的性能，我们使用了生成建模文献中常见技术的变体，其中包括向人类专家提供视频序列以及 C2D2 对这些序列的覆盖率分数。然后我们请专家评估 C2D2 的分数是否正确。这个想法是，虽然专家很难直接分配分数，但验证给定分数的任务要容易得多。（这类似于验证算法问题的建议解决方案通常比计算该解决方案容易得多。）使用这种方法，专家在 93% 的时间内验证了 C2D2 的分数。而在更定性的意义上，C2D2的输出似乎通过了“眼球测试”，见下图。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceGmEBxnwnm3SzjciaM4oicDlUTVv0PyDH73kh3aq3ClHuSuEedg9hLaz79onyVSTsGQbMFqbAicsfQPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;em&gt;下一步&lt;/em&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;通过提醒医生注意结肠壁的遗漏区域，C2D2 有望导致发现更多的腺瘤，从而增加 ADR 并同时降低间期 CRC的发生率。这对患者来说是非常有益的。&lt;/p&gt;&lt;p&gt;除了解决结肠镜检查覆盖范围的这项工作外，我们还在同时进行研究，通过将 C2D2 与自动实时息肉检测算法相结合来改进息肉检测。这项研究增加了越来越多的证据，表明医生可能会使用机器学习方法来加强他们的努力，尤其是在手术过程中，以提高患者的护理质量。&lt;/p&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7fcce734e52aa49ab3e526a8c7cf3de9</guid>
<title>Rust 中的无锁编程技术（四）</title>
<link>https://toutiao.io/k/5i10b1q</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;span&gt;在之前的博客里面，我们通过最基本的SpinLock的实现对锁有一个比较完整的认识了，但同时我也指出了自旋锁实际上是相当粗糙的，我们只要仔细想想其工作原理就会发现，最大的问题是线程与线程之间毫无公平性可言，导致这个结果的本质原因是对于Atomic类的&lt;/span&gt;&lt;code&gt;&lt;span&gt;compare_and_swap&lt;/span&gt;&lt;/code&gt;&lt;span&gt;对于不同线程之间是完全随机的，也就是这个函数没有办法控制哪个线程将会成功置换共享内存中的值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么从理论上来讲，如果我们的操作系统没有很好的处理好CPU调度的优先级的问题，有可能有的线程会饿死，而有的线程可能可以一直占据共有资源。那么我们如何解决这个问题呢？&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;一个更好的模型（TicketLock）&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;我们先思考一下SpinLock的模型：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;有多个线程在同时试着置换其&lt;/span&gt;&lt;code&gt;&lt;span&gt;AtomicBool&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;OS会在这些线程中随机选一个线程，让其成功置换&lt;/span&gt;&lt;code&gt;&lt;span&gt;AtomicBool&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的值。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;其他线程会一直卡在代码某处，一直自旋。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当上一个线程结束了对共享资源的使用后，会回到上诉的第二点。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span&gt;这就好像我们去银行办业务，但是只有一个窗口，大家都挤在这个窗口前面，谁将会是下一个可以办业务的人完全看业务员的心情。更好的做法应该是叫号的模式，我们现在去银行，都会提前去前台拿一个号码，当上一个人的业务办完了，就轮到了持有下一个号码的人去办业务。即使有许多人同时去办业务，前台的工作人员也会&lt;span&gt;按顺序&lt;/span&gt;给每一个前来办业务的人一个独有的号码。比起第一种模式，这种模式就会更加的公平，确保了先到先得的顺序。我们可以将这种模式运用到锁的实现里面，这个就是我们常说的TicketLock。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pub struct TicketLock {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    curr: AtomicUsize,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    next: AtomicUsize,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;impl Default for TicketLock {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    fn default() -&amp;gt; Self {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Self {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            curr: AtomicUsize::new(0),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            next: AtomicUsize::new(0),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比起SpinLock，TicketLock维护了两个共享变量，&lt;/span&gt;&lt;code&gt;&lt;span&gt;curr&lt;/span&gt;&lt;/code&gt;&lt;span&gt;以及&lt;/span&gt;&lt;code&gt;&lt;span&gt;next&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，其&lt;span&gt;语义&lt;/span&gt;表示的是当前正在处理的号码及下一个将会处理的号码。我们来看一下&lt;/span&gt;&lt;code&gt;&lt;span&gt;lock&lt;/span&gt;&lt;/code&gt;&lt;span&gt;以及&lt;/span&gt;&lt;code&gt;&lt;span&gt;unlock&lt;/span&gt;&lt;/code&gt;&lt;span&gt;函数的实现：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;impl RawLock for TicketLock {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    type Token = usize;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    fn lock(&amp;amp;self) -&amp;gt; usize {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        let ticket = self.next.fetch_add(1, Ordering::Relaxed);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        let backoff = Backoff::new();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        while self.curr.load(Ordering::Acquire) != ticket {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            backoff.snooze();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ticket&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    unsafe fn unlock(&amp;amp;self, ticket: usize) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        self.curr.store(ticket.wrapping_add(1), Ordering::Release);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;我们还是忽略掉&lt;/span&gt;&lt;code&gt;&lt;span&gt;Backoff&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;code&gt;&lt;span&gt;AtomicUsize&lt;/span&gt;&lt;/code&gt;&lt;span&gt;类型会提供一个&lt;/span&gt;&lt;code&gt;&lt;span&gt;fetch_add&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的函数，我们还是先忽略掉关于&lt;span&gt;Memory Ordering&lt;/span&gt;的参数，&lt;/span&gt;&lt;code&gt;&lt;span&gt;fetch_add&lt;/span&gt;&lt;/code&gt;&lt;span&gt;函数和一般我们认识的自加函数类似，但是&lt;/span&gt;&lt;code&gt;&lt;span&gt;fetch_add&lt;/span&gt;&lt;/code&gt;&lt;span&gt;是适用于多线程编程环境的。打个比方，比如100个线程同时对一个&lt;/span&gt;&lt;code&gt;&lt;span&gt;AtomicUsize&lt;/span&gt;&lt;/code&gt;&lt;span&gt;变量进行一次&lt;/span&gt;&lt;code&gt;&lt;span&gt;fetch_add&lt;/span&gt;&lt;/code&gt;&lt;span&gt;操作，并且&lt;/span&gt;&lt;code&gt;&lt;span&gt;AtomicUsize&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的初始值为0，那么我们最后得到的结果一定是100，因为这个是CPU指令集给我们提供的最小的保障了。但是如果是一个普通的&lt;/span&gt;&lt;code&gt;&lt;span&gt;usize&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的变量，那么我们是无法保证最后的结果是100的，有可能是小于或等于100的任何的值。所以通过&lt;/span&gt;&lt;code&gt;&lt;span&gt;fetch_add&lt;/span&gt;&lt;/code&gt;&lt;span&gt;这个函数，我们可以确保我们的ticket一定是单调线性递增的，并且每个ticket之间相差为1。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;那么我们来思考下假设现在有许多线程同时在调用TicketLock的&lt;/span&gt;&lt;code&gt;&lt;span&gt;lock&lt;/span&gt;&lt;/code&gt;&lt;span&gt;函数，那么每个线程都会得到一个唯一的ticket，如果像我们的例子中，&lt;/span&gt;&lt;code&gt;&lt;span&gt;AtomicUsize&lt;/span&gt;&lt;/code&gt;&lt;span&gt;是从0开始的，那么接下来的线程会得到的ticket将会是1,2,3,4…这样的顺序排列下去。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;接下来，每个线程都会卡在以下这一行。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;while self.curr.load(Ordering::Acquire) != ticket {}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在这里每个线程相当于在等待叫号，如果当前办业务的号码并不是自己手里的号码，那么这个线程将会在这个位置等待，直到叫到自己的号码为止才可以继续执行下去。值得注意的地方是，每个线程在拿号的时候，用的是&lt;/span&gt;&lt;code&gt;&lt;span&gt;self.next&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，而线程在等待的时候用的是&lt;/span&gt;&lt;code&gt;&lt;span&gt;self.curr&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，其实从&lt;span&gt;语义&lt;/span&gt;上来讲，这个是非常好理解的。拿号的时候，我们用的是&lt;/span&gt;&lt;code&gt;&lt;span&gt;next&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，而真正等叫号的是&lt;/span&gt;&lt;code&gt;&lt;span&gt;curr&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;有了上面对语义的理解，接下来的&lt;/span&gt;&lt;code&gt;&lt;span&gt;unlock&lt;/span&gt;&lt;/code&gt;&lt;span&gt;函数便非常好理解了，当上一个线程结束了对共享资源的使用后，就会&lt;/span&gt;&lt;code&gt;&lt;span&gt;unlock&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，也就是准备让窗口的业务员叫下一个号码，因此，我们在&lt;/span&gt;&lt;code&gt;&lt;span&gt;unlock&lt;/span&gt;&lt;/code&gt;&lt;span&gt;函数中将当前的&lt;/span&gt;&lt;code&gt;&lt;span&gt;curr&lt;/span&gt;&lt;/code&gt;&lt;span&gt;增加1，这时候，之前卡在&lt;/span&gt;&lt;code&gt;&lt;span&gt;while&lt;/span&gt;&lt;/code&gt;&lt;span&gt;处，并且号码是上一个线程ticket的值+1的线程便可以跳出循环得到了共享资源的使用权。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们可以看到，TicketLock比起SpinLock在实现上面巧妙的运用了&lt;/span&gt;&lt;code&gt;&lt;span&gt;Token&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。在之前的SpinLock中，&lt;/span&gt;&lt;code&gt;&lt;span&gt;Token&lt;/span&gt;&lt;/code&gt;&lt;span&gt;就是&lt;/span&gt;&lt;code&gt;&lt;span&gt;()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，并没有好好利用其&lt;span&gt;传递&lt;/span&gt;的特性，我们仔细想想，当一个线程&lt;/span&gt;&lt;code&gt;&lt;span&gt;lock&lt;/span&gt;&lt;/code&gt;&lt;span&gt;成功时，获取了&lt;/span&gt;&lt;code&gt;&lt;span&gt;Token&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，表示其可以独占共享资源，当这个线程&lt;/span&gt;&lt;code&gt;&lt;span&gt;unlock&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的时候，&lt;/span&gt;&lt;code&gt;&lt;span&gt;Token&lt;/span&gt;&lt;/code&gt;&lt;span&gt;会作为一个参数传入到&lt;/span&gt;&lt;code&gt;&lt;span&gt;unlock&lt;/span&gt;&lt;/code&gt;&lt;span&gt;函数中，TicketLock通过一个共享变量&lt;/span&gt;&lt;code&gt;&lt;span&gt;curr&lt;/span&gt;&lt;/code&gt;&lt;span&gt;将上一个线程的信息传递给了下一个线程，这样的实现方式使得线程间具有了&lt;span&gt;公平性&lt;/span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是事情并没有那么美好，无论是SpinLock还是TicketLock，所有的线程都在为同一个内存空间在打架，在SpinLock中，线程们都在争夺一个&lt;/span&gt;&lt;code&gt;&lt;span&gt;AtomicBool&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，在TicketLock中，线程们都在争夺一个&lt;/span&gt;&lt;code&gt;&lt;span&gt;AtomicUsize&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（&lt;/span&gt;&lt;code&gt;&lt;span&gt;self.curr&lt;/span&gt;&lt;/code&gt;&lt;span&gt;）。其实这样的设计从资源利用的角度来看是很不好的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从OS的角度来看，每一次线程的切换，都会有Context Swtich，这对于系统来说都是一笔不小的开销，并且对多个线程同时访问同一个Atomic的内存地址来说，必须要等前一个线程访问结束了，才可以换下一个线程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么解决这个问题的思路就是我们能不能通过内存来换取系统等待的时间？最理想的情况就是每个线程只需要访问&lt;span&gt;自己独有的一个&lt;/span&gt;内存空间，我们的设计尽量要减少对同一个共享变量访问的线程的数量。这个就是下一个博客会介绍的内容，CLHLock的实现。&lt;/span&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>