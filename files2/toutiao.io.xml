<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>11ad6585985f065e64a61f4466164e40</guid>
<title>首个确保缓存与数据库一致性的方案</title>
<link>https://toutiao.io/k/imjqbp3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;h2 tabindex=&quot;-1&quot;&gt;概述&lt;/h2&gt;&lt;p&gt;大量的实际的项目中，都会引入 Redis 缓存来缓解数据库的查询压力，此时由于一个数据在 Redis 和数据库两处进行了存储，就会有数据一致性的问题。目前业界尚未见到成熟的能够确保最终一致性的方案，特别是当如下场景发生时，会直接导致缓存数据与数据库数据不一致。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7247579529737206&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/VNDQtnw16icLecJiaHcUyhQMmfTjtEA2RTUnhHD4uV0F3rd64YmWyhKB09sl2FdPHyUibdMpSV5xkXf60s4vcticDDKniaHqCc284/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;723&quot;/&gt;&lt;/p&gt;&lt;p&gt;在上述场景下，缓冲中的数据最终版本为v1，而数据库的最终版本为v2，可能给应用带来较大问题。&lt;/p&gt;&lt;p&gt;dtm-labs 致力于解决数据一致性问题，在分析了行业的现有做法后，提出了新解决方案dtm + rockscache，彻底解决了上述问题。另外作为一个成熟方案，该方案还可以防缓存穿透，防缓存击穿，防缓存雪崩，同时也可应用于要求数据强一致的场景。&lt;/p&gt;&lt;p&gt;关于管理缓存的现有方案，本文不再赘述，不太了解的同学可以参考下面这两篇文章&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;乱序产生的不一致&lt;/h2&gt;&lt;p&gt;在上述这个时序图中，由于服务1发生了进程暂停（例如由于GC导致），因此当它往缓存当中写入v1时，覆盖了缓存中的v2，导致了最终的不一致（DB中为v2，缓存中为v1）。&lt;/p&gt;&lt;p&gt;对于上述这类问题应当如何解决？目前现存的方案，全都没有彻底解决该问题，一般都是通过设定稍短的过期时间兜底。我们实现的缓存延迟删除方案，能够彻底解决这个问题，确保缓存与数据库之间的数据保持一致。解决原理如下：&lt;/p&gt;&lt;p&gt;缓存中的数据是一个hash，里面有以下几个字段：&lt;/p&gt;&lt;p&gt;查询缓存时：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;如果数据为空，且被锁定，则睡眠1s后，重新查询&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果数据为空，且未被锁定，同步执行&quot;取数据&quot;，返回结果&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果数据不为空，那么立即返回结果，并异步执行&quot;取数据&quot;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;其中&quot;取数据&quot;的操作定义为：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;判断是否需要更新缓存，下面两个条件满足其一，则需要更新缓存&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;如果需要更新，则锁定缓存，查询DB，校验锁持有者无变化，写入缓存，解锁缓存&lt;/p&gt;&lt;/li&gt;&lt;p&gt;当DB数据更新时，通过dtm确保数据更新成功时，将缓存延迟删除（将在后面一节展开详细讲解）&lt;/p&gt;&lt;p&gt;在上述的策略下：假如最后写入数据库的版本为Vi，最后写入到缓存的版本为V，写入V的uuid为uuidv，那么一定存在以下事件序列：&lt;/p&gt;&lt;p&gt;数据库写入Vi -&amp;gt; 缓存数据被标记为删除 -&amp;gt; 某个查询锁定数据并写入uuidv -&amp;gt; 查询数据库结果V -&amp;gt; 缓存中的锁定者为uuidv，写入结果V&lt;/p&gt;&lt;p&gt;在这个序列中，V的读取发生在写入Vi之后，所以V等于Vi，保证了缓存的数据的最终一致性。&lt;/p&gt;&lt;p&gt;dtm-labs/rockscache已经实现了上述方法，能够确保缓存数据的最终一致性。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;Fetch&lt;/code&gt;函数实现了前面的查询缓存&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;DelayDelete&lt;/code&gt;函数实现了延迟删除逻辑&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;感兴趣的同学，可以参考dtm-cases/cache，里面有详细的例子&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;DB与缓存操作的原子性&lt;/h2&gt;&lt;p&gt;对于缓存的管理，一般业界会采用写完数据库后，删除/更新缓存数据的策略。由于保存到缓存和保存到数据库两个操作之间不是原子的，一定会有时间差，因此这两个数据之间会有一个不一致的时间窗口，通常这个窗口不大，影响较小。但是两个中间可能发生宕机，也可能发生各种网络错误，因此就有可能发生完成了其中一个，但是未完成另一个，导致数据会出现长时间不一致。&lt;/p&gt;&lt;p&gt;举一个场景来说明上述不一致的情况，数据用户将数据 A 修改为 B ，应用修改完数据库之后，再去删除/更新缓存，如果未发生异常，那么数据库和缓存的数据是一致的，没有问题。但是分布式系统中，可能会发生进程crash、宕机等事件，因此如果更新完数据库，尚未删除/更新缓存时，出现进程crash，那么数据库和缓存的数据就可能出现长时间的不一致。&lt;/p&gt;&lt;p&gt;面对这里的长时间不一致的情况，想要彻底解决，并不是一件容易的事，我们下面分各种应用情况来介绍解决方案。&lt;/p&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;方案一：较短的缓存时间&lt;/h4&gt;&lt;p&gt;这个方案，是最简单的方案，适合并发量不大应用。如果应用的并发不高，那么整个缓存系统，只需要设置了一个较短的缓存时间，例如一分钟。这种情况下数据库需要承担的负载是：大约每一分钟，需要将访问到的缓存数据全部生成一遍，在并发量不大的情况下，这种策略是可行的。&lt;/p&gt;&lt;p&gt;上述这种策略非常简单，易于理解和实现，缓存系统提供的语义是，大多数情况下，缓存和数据库之间不一致的时间窗口是很短的，在较低概率发生进程crash的情况下，不一致的时间窗口会达到一分钟。&lt;/p&gt;&lt;p&gt;应用在上述约束下，需要将一致性要求不高的数据读取，从缓存读取；而将一致性要求较高的读，不走缓存，直接从数据库查询。&lt;/p&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;方案二：消息队列保证一致&lt;/h4&gt;&lt;p&gt;假如应用的并发量很高，缓存过期时间需要比一分钟更长，而且应用中的大量请求不能够容忍较长时间的不一致，那么这个时候，可以通过使用消息队列的方式，来更新缓存。具体的做法是：&lt;/p&gt;&lt;p&gt;这种做法可以保证数据库更新之后，缓存一定会被更新。但这种这种架构方案很重，这几个部分开发维护成本都不低：消息队列的维护；高效轮询任务的开发与维护。&lt;/p&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;方案三：订阅 binlog&lt;/h4&gt;&lt;p&gt;这个方案适用场景与方案二非常类似，原理又与数据库的主从同步类似，数据库的主从同步是通过订阅binlog，将主库的更新应用到从库上，而这个方案则是通过订阅binlog，将数据库的更新应用到缓存上。具体做法是：&lt;/p&gt;&lt;p&gt;这种方案也可以保证数据库更新之后，缓存一定会被更新，但是这种架构方案跟前面的消息队列方案一样，也非常重。一方面 canal 的学习维护成本不低，另一方面，开发者可能只需要少量数据更新缓存，通过订阅所有的 binlog 来做这个事情，浪费了很多资源。&lt;/p&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;方案四：dtm 二阶段消息方案&lt;/h4&gt;&lt;p&gt;dtm 里的二阶段消息模式，非常适合这里的修改数据库之后更新/删除缓存，主要代码如下：&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20534458509142053&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9m9OfQX94VstsDlZWn1DicInYoJUPQe5tXCbBk3NHJaZDVfiatcHOJZMQPDlkcU4y3byGmP3z8Uk9eGxThodsvLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1422&quot;/&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;这段代码，DoAndSubmitDB会进行本地数据库操作，进行数据库的数据修改，修改完成后，会提交一个二阶段消息事务，消息事务将会异步调用 UpdateRedis。假如本地事务执行之后，就立刻发生了进程 crash 事件，那么 dtm 会进行回查调用 QueryPrepared ，保证本地事务提交成功的情况下，UpdateRedis 会被最少成功执行一次。&lt;/p&gt;&lt;p&gt;回查的逻辑非常简单，只需要copy类似下面这样的代码即可：&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.10909090909090909&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9m9OfQX94VstsDlZWn1DicInYoJUPQe5tMiawYOaDlQpCM03XQRekicRL3Xds9hMSYuolZqA9wVPm2aSaib6uCKoIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1430&quot;/&gt;&lt;/p&gt;&lt;p&gt;这种方案的优点：&lt;/p&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;从库延时&lt;/h4&gt;&lt;p&gt;上述的方案中，假定缓存删除后，服务进行数据查询，总是能够查到最新的数据。但是实际的生产环境中，可能会出现主从分离的架构，而主从延时并不是一个可控的变量，那么这时候又要怎么处理？&lt;/p&gt;&lt;p&gt;处理方案两种：一是区分最终一致性很高和不高的缓存数据，查询数据时，将要求很高的数据必须从主库读取，而把要求不高的数据从从库读取。对于使用了rockscache的应用来说，高并发的请求都会在Redis这一层被拦截，对于一个数据，最多只会有一个请求到达数据库，因此数据库的负载已大幅降低，采用主库读取是一个实际可行的方案。&lt;/p&gt;&lt;p&gt;另一种方案是，主从分离需要采用不分叉的单链架构，那么链条末尾的从库必定是延迟最长的从库，此时采用监听binlog的方案，需要监听链条做末端的从库binlog，当收到数据变更通知时，按照上述方案将缓存标记为延迟删除。&lt;/p&gt;&lt;p&gt;这两个方案各有优缺点，业务可以根据自己的特点采用。&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;防缓存击穿&lt;/h2&gt;&lt;p&gt;rockscache还可以防缓存击穿。当数据变更时，业界现有做法既可以选择更新缓存，也可以选择删除缓存，各有优劣。而延迟删除综合了两种方法的优势，并克服了两种方法的劣势：&lt;/p&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;更新缓存&lt;/h4&gt;&lt;p&gt;采取更新缓存策略，那么会为所有的DB数据更新生成缓存，不区分冷热数据，那么会存在以下问题：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;内存上，即使一个数据没有被读取，也会保存在缓存里，浪费了宝贵的内存资源；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在计算上，即使一个数据没有被读取，也可能因为多次更新，被多次计算，浪费了宝贵的计算资源。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;上述的乱序不一致发生的概率会较高，当两个临近的更新中出现延迟，就可能触发。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;删除缓存&lt;/h4&gt;&lt;p&gt;因为前面的更新缓存做法问题较多，因此大多数的实践采用的是删除缓存策略，查询时再按需生成缓存。这种做法解决了更新缓存中的问题，但是又带来新问题：&lt;/p&gt;&lt;p&gt;为了防止缓存击穿，通用的做法是使用分布式 Redis 锁保证只有一个请求到数据库，等缓存生成之后，其他请求进行共享。这种方案能够适合很多的场景，但有些场景却不适合。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;例如有一个重要的热点数据，计算代价比较高，需要3s才能够获得结果，那么上述方案在删除一个这种热点数据之后，就会在这个时刻，有大量请求3s才返回结果，一方面可能造成大量请求超时，另一方面3s没有释放链接，会导致并发连接数量突然升高，可能造成系统不稳定。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;另外使用 Redis 锁时，未获得锁的这部分用户，通常会定时轮询，而这个睡眠时间不好设定。如果设定比较大的睡眠时间1s，那么对于10ms就计算出结果的缓存数据，返回太慢了；如果设定的睡眠时间太短，那么很消耗 CPU 和 Redis 性能&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;延迟删除法的应对策略&lt;/h4&gt;&lt;p&gt;前面介绍的dtm-labs/rockscache实现的延时删除法也属于删除法，但它彻底解决了删除缓存中的击穿问题，以及击穿带来的附带问题。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;缓存击穿问题：延迟删除法中，如果缓存中的数据不存在，那么会锁定缓存中的这条数据，因此避免了多个请求打到后端数据库。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;上述大量请求3s才返回数据，以及定时轮询的问题，在延时删除中也不存在，因为热点数据被延时删除时，旧版本的数据还在缓存中，会被立即返回，无需等待。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们来看看不同的数据访问频率下，延迟删除法的表现如何：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;热点数据，每秒1K qps，计算缓存时间5ms，此时延迟删除法，大约5~8ms左右的时间里，会返回过期数据，而先更新DB，再更新缓存，因为更新缓存需要时间，也会有大约0~3ms返回过期数据，因此两者差别不大。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;热点数据，每秒1K qps，计算缓存时间3s，此时延迟删除法，大约3s的时间里，会返回过期数据。对比于等待3s后再返回数据，那么返回旧数据，通常是更好的行为。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;普通数据，每秒50 qps，计算缓存时间1s，此时延迟删除法的行为分析，类似2，没有问题。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;低频数据，5秒访问一次，计算缓存时间3s，此时延迟删除法的行为与删除缓存策略基本一样，没有问题&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;冷数据，10分钟访问一次，此时延迟删除法，与删除缓存策略基本一样，只是数据比删除缓存的方式多保存10s，占用空间不大，没有问题&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;有一种极端情况是，那就是原先缓存中没有数据，突然大量请求到来，这种场景对，更新缓存法删除缓存法，延迟删除法，都是不友好的。这种的场景是开发人员需要避免的，需要通过预热来解决，而不应当直接扔给缓存系统。当然，由于延迟删除法已经把打到数据库的请求量降到最低，因此表现也不弱于任何其他方案。&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;防缓存穿透与缓存雪崩&lt;/h2&gt;&lt;p&gt;dtm-labs/rockscache还实现了防缓存穿透与缓存雪崩。&lt;/p&gt;&lt;p&gt;缓存穿透是指，缓存和数据库都没有的数据，被大量请求。由于数据不存在，缓存就也不会存在该数据，所有的请求都会直接穿透到数据库。rockscache中可以设定&lt;code&gt;EmptyExipire&lt;/code&gt;设定对空结果的缓存时间，如果设定为0，那么不缓存空数据，关闭防缓存穿透&lt;/p&gt;&lt;p&gt;缓存雪崩是指缓存中有大量的数据，在同一个时间点，或者较短的时间段内，全部过期了，这个时候请求过来，缓存没有数据，都会请求数据库，则数据库的压力就会突增，扛不住就会宕机。rockscache可以设定&lt;code&gt;RandomExpireAdjustment&lt;/code&gt;，对过期时间加上随机值，避免同时过期。&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;应用能否做到强一致？&lt;/h2&gt;&lt;p&gt;上面已经介绍了缓存一致性的各种场景，以及相关的解决方案，那么是否可以保证使用缓存的同时，还提供强一致的数据读写呢？强一致的读写需求比前面的最终一致的需求场景少，但是在金融领域，也是有不少场景的。&lt;/p&gt;&lt;p&gt;当我们在这里讨论强一致时，我们需要先把一致性的含义做一下明确。&lt;/p&gt;&lt;p&gt;开发者最直观的强一致性很可能理解为，数据库和缓存保持完全一致，写数据的过程中以及写完之后，无论从数据库直接读，或者从缓存直接读，都能够获得最新写入的结果。对于这种两个独立系统之间的“强一致性”，可以非常明确的说，理论上是不可能的，因为更新数据库和更新缓存在不同的机器上，无法做到同时更新，无论如何都会有时间间隔，在这个时间间隔里，一定是不一致的。&lt;/p&gt;&lt;p&gt;但是应用层的强一致性，则是可以做到的。可以简单考虑我们熟悉的场景：CPU的缓存作为内存的缓存，内存作为磁盘的缓存，这些都是缓存的场景，从来没有发生过一致性问题。为什么？其实很简单，要求所有的数据使用方，只能够从缓存读取数据，而不能同时从缓存和底层存储同时读取数据。&lt;/p&gt;&lt;p&gt;对于DB和Redis，如果所有的数据读取，只能够由缓存提供，就可以很容易的做到强一致，不会出现不一致的情况。下面我们来根据DB和Redis的特点，来分析其中的设计：&lt;/p&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;先更新缓存还是DB&lt;/h4&gt;&lt;p&gt;类比CPU缓存与内存，内存缓存与磁盘，这两个系统都是先修改缓存，再修改底层存储，那么到了现在的DB缓存场景是否也先修改缓存再修改DB？&lt;/p&gt;&lt;p&gt;在绝大多数的应用场景下，开发者会认为Redis作为缓存，当Redis出现故障时，那么应用需要支持降级处理，依旧能够访问数据库，提供一定的服务能力。考虑这种场景，一旦出现降级，先写缓存再写DB方案就有问题，一方面会丢失数据，另一方面会发生先读取到缓存中的新版本v2，再读取到旧版本v1。因此在Redis作为缓存的场景下，绝大部分系统会采取先写入DB，再写入缓存的这种设计&lt;/p&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;写入DB成功缓存失败情况&lt;/h4&gt;&lt;p&gt;假如因为进程crash，导致写入DB成功，但是标记延迟删除第一次失败怎么办？虽然间隔几秒之后，会重试成功，但这几秒钟的时间里，用户去读取缓存，依旧还是旧版本的数据。例如用户发起了一笔充值，资金已经进入到DB，只是更新缓存失败，导致从缓存看到的余额还是旧值。这种情况的处理很简单，用户充值时，写入DB成功时，应用不要给用户返回成功，而是等缓存更新也成功了，再给用户返回成功；用户查询充值交易时，要查询DB和缓存是否都成功了（可以查询二阶段消息全局事务是否已成功），只有两者都成功了，才返回成功。&lt;/p&gt;&lt;p&gt;在上述的处理策略下，当用户发起充值后，在缓存更新完成之前，用户看到的是，这笔交易还在处理中，结果未知，此时是符合强一致要求的；当用户看到交易已经处理成功，也就是缓存已更新成功，那么所有从缓存中拿到的数据都是更新后的数据，那么也符合强一致的要求。&lt;/p&gt;&lt;p&gt;dtm-labs/rockscache也实现了强一致的读取需求。当打开&lt;code&gt;StrongConsistency&lt;/code&gt;选项，那么rockscache里&lt;code&gt;Fetch&lt;/code&gt;函数就提供了强一致的缓存读取。其原理与延迟删除差别不大，仅做了很小的改变，就是不再返回旧版本的数据，而是同步等待“取数据”的最新结果&lt;/p&gt;&lt;p&gt;当然这个改变会带来性能上的下降，对比与最终一致的数据读取，强一致的读取一方面要等待当前“取数据”的最新结果，增加了返回延迟，另一方面要等待其他进程的结果，会产生sleep等待，耗费资源。&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;缓存降级升级中的强一致&lt;/h2&gt;&lt;p&gt;上述的强一致方案中，说明了其强一致的前提是：“所有的数据读取，只能够由缓存”。不过如果Redis如果发生故障，需要进行降级，那么降级的过程可能很短只有几秒，但是这个几秒内如果不能接受不可访问，还严苛的要求提供访问的话，就会出现读取缓存和读取DB混用情况，就不满足这个前提。不过因为Redis故障的频率不高，要求强一致性的应用通常配备专有Redis，因此遇见故障降级的概率很低，很多应用不会在这个地方提出苛刻的要求。&lt;/p&gt;&lt;p&gt;不过dtm-labs作为数据一致性领域的领导者，也深入研究了这个问题，并给出这种苛刻条件下的解决方案。&lt;/p&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;升降级的过程&lt;/h4&gt;&lt;p&gt;现在我们来考虑应用在Redis缓存出现问题的升降级处理。一般情况下这个升降级的开关在配置中心，当修改配置后，各个应用进程会陆续收到降级配置变更通知，然后在行为上降级。在降级的过程中，会出现缓存与DB混合访问的情况，这时我们上面的方案就有可能出现不一致。那么如何处理才能够保证在这种混合访问的情况下，依旧能够让应用获取到强一致的结果呢？&lt;/p&gt;&lt;p&gt;混合访问的过程中，我们可以采取下面这个策略，来保证DB和缓存混合访问时的数据一致性。&lt;/p&gt;&lt;p&gt;这个策略跟前面不考虑降级场景的强一致方案，差别不大，读数据部分完全不变，需要变的是更新数据。rockscache假定更新DB是一个业务上可能失败的操作，于是采用一个SAGA事务来保证原子操作，详情参见例子dtm-cases/cache&lt;/p&gt;&lt;p&gt;升降级的开启关闭有顺序要求，不能够同时开启缓存读和写，而是需要在开启缓存读的时候，所有的写操作都已经确保会更新缓存。&lt;/p&gt;&lt;p&gt;降级的详细过程如下：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;最初状态：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;读降级：&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;读：关闭缓存读。混合读 =&amp;gt; 全部DB读&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;写：DB+缓存&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;写降级：&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;读：全部DB读；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;写：关闭缓存写。DB+缓存 =&amp;gt; 只写DB&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;升级的过程与此相反，如下：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;最初状态：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;写升级：&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;读：全部读DB&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;写：打开写缓存。只写DB =&amp;gt; 写DB+缓存&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;读升级：&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;读：部分读缓存。全部读DB =&amp;gt; 混合读&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;写：写DB+缓存&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;dtm-labs/rockscache已实现了上述强一致的缓存管理方法。&lt;/p&gt;&lt;p&gt;感兴趣的同学，可以参考dtm-cases/cache，里面有详尽的例子&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;小结&lt;/h2&gt;&lt;p&gt;这篇文章很长，许多的分析比较晦涩，最后将Redis缓存的使用方式做个总结：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;最简单的方式为：较短的缓存时间，允许少量数据库修改，未同步删除缓存&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;保证最终一致，并且可防缓存击穿的方式为：二阶段消息+延迟删除(rockscache)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;强一致：二阶段消息+强一致(rockscache)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;一致性要求最严苛的方式为：二阶段消息+强一致(rockscache)+升降级兼容&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;对于后两种方式，我们都推荐使用dtm-labs/rockscache来作为您的缓存方案&lt;/p&gt;&lt;h2&gt;联系我们&lt;/h2&gt;&lt;p&gt;欢迎访问我们的项目，并star支持我们：&lt;/p&gt;&lt;p&gt;https://github.com/dtm-labs/dtm&lt;/p&gt;&lt;p&gt;https://github.com/dtm-labs/rockscache&lt;/p&gt;&lt;p&gt;关注【分布式事务】公众号，获得更多分布式事务相关知识&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIwNzQ2NzMyNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/9m9OfQX94Vv04GUcaMFCzcfHeGnTECibTEibP26ByiaHcdD7qYLNFAyQcDvbVBerQs55hXppwia3XpPjIYF3MKGzVQ/0?wx_fmt=png&quot; data-nickname=&quot;分布式事务&quot; data-alias=&quot;wangxiyan0901&quot; data-signature=&quot;介绍分布式事务相关理论与实践知识。 开源项目dtm-labs/dtm的相关信息发布。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7bedebd8d9217f9aaf7b170ebd05c3c7</guid>
<title>你见过哪些目瞪口呆的 Java 代码技巧？</title>
<link>https://toutiao.io/k/avsba7r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;来源：blog.csdn.net/zl1zl2zl3/article/details/85196627&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;技术点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开发工具&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Bean&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Bean 的验证&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;拥抱 lombok&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重构&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设计模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;技能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;总结&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;技术点&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文不是一个吹嘘的文章，不会讲很多高深的架构，相反，会讲解很多基础的问题和写法问题，如果读者自认为基础问题和写法问题都是不是问题，那请忽略这篇文章，节省出时间去做一些有意义的事情。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;开发工具&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道有多少”老”程序员还在使用 Eclipse，这些程序员们要不就是因循守旧，要不就是根本就不知道其他好的开发工具的存在，Eclipse 吃内存卡顿的现象以及各种偶然莫名异常的出现，都告知我们是时候寻找新的开发工具了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;更换 IDE&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根本就不想多解释要换什么样的 IDE，如果你想成为一个优秀的 Java 程序员，请更换 IntelliJ IDEA。使用 IDEA 的好处，请搜索谷歌。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;别告诉我快捷键不好用&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更换 IDE 不在我本文的重点内容中，所以不想用太多的篇幅去写为什么更换IDE。在这里，我只能告诉你，更换 IDE 只为了更好、更快的写好 Java 代码。原因略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;别告诉我快捷键不好用，请尝试新事物。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Bean&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;bean 使我们使用最多的模型之一，我将以大篇幅去讲解 bean，希望读者好好体会。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;domain 包名&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据很多 Java 程序员的”经验”来看，一个数据库表则对应着一个 domain 对象，所以很多程序员在写代码时，包名则使用：com.xxx.domain ，这样写好像已经成为了行业的一种约束，数据库映射对象就应该是 domain。但是你错了，domain 是一个领域对象，往往我们再做传统 Java 软件 Web 开发中，这些 domain 都是贫血模型，是没有行为的，或是没有足够的领域模型的行为的，所以，以这个理论来讲，这些 domain 都应该是一个普通的 entity 对象，并非领域对象，所以请把包名改为:com.xxx.entity。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你还不理解我说的话，请看一下 Vaughn Vernon 出的一本叫做《IMPLEMENTING DOMAIN-DRIVEN DESIGN》(实现领域驱动设计)这本书，书中讲解了贫血模型与领域模型的区别，相信你会受益匪浅。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;DTO&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据传输我们应该使用 DTO 对象作为传输对象，这是我们所约定的，因为很长时间我一直都在做移动端 API 设计的工作，有很多人告诉我，他们认为只有给手机端传输数据的时候(input or output)，这些对象成为 DTO 对象。请注意！这种理解是错误的，只要是用于网络传输的对象，我们都认为他们可以当做是 DTO 对象，比如电商平台中，用户进行下单，下单后的数据，订单会发到 OMS 或者 ERP 系统，这些对接的返回值以及入参也叫 DTO 对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们约定某对象如果是 DTO 对象，就将名称改为 XXDTO，比如订单下发OMS：OMSOrderInputDTO。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;DTO 转化&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如我们所知，DTO 为系统与外界交互的模型对象，那么肯定会有一个步骤是将 DTO 对象转化为 BO 对象或者是普通的 entity 对象，让 service 层去处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;场景&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如添加会员操作，由于用于演示，我只考虑用户的一些简单数据，当后台管理员点击添加用户时，只需要传过来用户的姓名和年龄就可以了，后端接受到数据后，将添加创建时间和更新时间和默认密码三个字段，然后保存数据库。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@RequestMapping(&lt;span&gt;&quot;/v1/api/user&quot;&lt;/span&gt;)&lt;br/&gt;@RestController&lt;br/&gt;public class UserApi {&lt;br/&gt;&lt;br/&gt;    @Autowired&lt;br/&gt;    private UserService userService;&lt;br/&gt;&lt;br/&gt;    @PostMapping&lt;br/&gt;    public User addUser(UserInputDTO userInputDTO){&lt;br/&gt;        User user = new User();&lt;br/&gt;        user.setUsername(userInputDTO.getUsername());&lt;br/&gt;        user.setAge(userInputDTO.getAge());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; userService.addUser(user);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们只关注一下上述代码中的转化代码，其他内容请忽略：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;User user = new User();&lt;br/&gt;user.setUsername(userInputDTO.getUsername());&lt;br/&gt;user.setAge(userInputDTO.getAge());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;请使用工具&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上边的代码，从逻辑上讲，是没有问题的，只是这种写法让我很厌烦，例子中只有两个字段，如果有 20 个字段，我们要如何做呢？一个一个进行 set 数据吗？当然，如果你这么做了，肯定不会有什么问题，但是，这肯定不是一个最优的做法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网上有很多工具，支持浅拷贝或深拷贝的 Utils。举个例子，我们可以使用 org.springframework.beans.BeanUtils#copyProperties 对代码进行重构和优化：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@PostMapping&lt;br/&gt;public User addUser(UserInputDTO userInputDTO){&lt;br/&gt;    User user = new User();&lt;br/&gt;    BeanUtils.copyProperties(userInputDTO,user);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; userService.addUser(user);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BeanUtils.copyProperties 是一个浅拷贝方法，复制属性时，我们只需要把 DTO 对象和要转化的对象两个的属性值设置为一样的名称，并且保证一样的类型就可以了。如果你在做 DTO 转化的时候一直使用 set 进行属性赋值，那么请尝试这种方式简化代码，让代码更加清晰!&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;转化的语义&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上边的转化过程，读者看后肯定觉得优雅很多，但是我们再写 Java 代码时，更多的需要考虑语义的操作，再看上边的代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;User user = new User();&lt;br/&gt;BeanUtils.copyProperties(userInputDTO,user);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然这段代码很好的简化和优化了代码，但是他的语义是有问题的，我们需要提现一个转化过程才好，所以代码改成如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@PostMapping&lt;br/&gt; public User addUser(UserInputDTO userInputDTO){&lt;br/&gt;         User user = convertFor(userInputDTO);&lt;br/&gt;&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; userService.addUser(user);&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; private User convertFor(UserInputDTO userInputDTO){&lt;br/&gt;&lt;br/&gt;         User user = new User();&lt;br/&gt;         BeanUtils.copyProperties(userInputDTO,user);&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; user;&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个更好的语义写法，虽然他麻烦了些，但是可读性大大增加了，在写代码时，我们应该尽量把语义层次差不多的放到一个方法中，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;User user = convertFor(userInputDTO);&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; userService.addUser(user);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两段代码都没有暴露实现，都是在讲如何在同一个方法中，做一组相同层次的语义操作，而不是暴露具体的实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上所述，是一种重构方式，读者可以参考 Martin Fowler 的《Refactoring Imporving the Design of Existing Code》(重构 改善既有代码的设计) 这本书中的 Extract Method 重构方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;抽象接口定义&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当实际工作中，完成了几个 API 的 DTO 转化时，我们会发现，这样的操作有很多很多，那么应该定义好一个接口，让所有这样的操作都有规则的进行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果接口被定义以后，那么 convertFor 这个方法的语义将产生变化，它将是一个实现类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一下抽象后的接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public interface DTOConvert&amp;lt;S,T&amp;gt; {&lt;br/&gt;    T convert(S s);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然这个接口很简单，但是这里告诉我们一个事情，要去使用泛型，如果你是一个优秀的 Java 程序员，请为你想做的抽象接口，做好泛型吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看接口实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class UserInputDTOConvert implements DTOConvert {&lt;br/&gt;@Override&lt;br/&gt;public User convert(UserInputDTO userInputDTO) {&lt;br/&gt;User user = new User();&lt;br/&gt;BeanUtils.copyProperties(userInputDTO,user);&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; user;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们这样重构后，我们发现现在的代码是如此的简洁，并且那么的规范：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@RequestMapping(&lt;span&gt;&quot;/v1/api/user&quot;&lt;/span&gt;)&lt;br/&gt;@RestController&lt;br/&gt;public class UserApi {&lt;br/&gt;&lt;br/&gt;    @Autowired&lt;br/&gt;    private UserService userService;&lt;br/&gt;&lt;br/&gt;    @PostMapping&lt;br/&gt;    public User addUser(UserInputDTO userInputDTO){&lt;br/&gt;        User user = new UserInputDTOConvert().convert(userInputDTO);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; userService.addUser(user);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;review code&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你是一个优秀的 Java 程序员，我相信你应该和我一样，已经数次重复 review 过自己的代码很多次了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再看这个保存用户的例子，你将发现，API 中返回值是有些问题的，问题就在于不应该直接返回 User 实体，因为如果这样的话，就暴露了太多实体相关的信息，这样的返回值是不安全的，所以我们更应该返回一个 DTO 对象，我们可称它为 UserOutputDTO：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@PostMapping&lt;br/&gt;public UserOutputDTO addUser(UserInputDTO userInputDTO){&lt;br/&gt;        User user = new UserInputDTOConvert().convert(userInputDTO);&lt;br/&gt;        User saveUserResult = userService.addUser(user);&lt;br/&gt;        UserOutputDTO result = new UserOutDTOConvert().convertToUser(saveUserResult);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样你的 API 才更健全。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道在看完这段代码之后，读者有是否发现还有其他问题的存在，作为一个优秀的 Java 程序员，请看一下这段我们刚刚抽象完的代码:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;User user = new UserInputDTOConvert().convert(userInputDTO);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你会发现，new 这样一个 DTO 转化对象是没有必要的，而且每一个转化对象都是由在遇到 DTO 转化的时候才会出现，那我们应该考虑一下，是否可以将这个类和 DTO 进行聚合呢，看一下我的聚合结果:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class UserInputDTO {&lt;br/&gt;private String username;&lt;br/&gt;private int age;&lt;br/&gt;&lt;br/&gt;    public String &lt;span&gt;&lt;span&gt;getUsername&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; username;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public void setUsername(String username) {&lt;br/&gt;        this.username = username;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public int &lt;span&gt;&lt;span&gt;getAge&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; age;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public void setAge(int age) {&lt;br/&gt;        this.age = age;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    public User &lt;span&gt;&lt;span&gt;convertToUser&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;        UserInputDTOConvert userInputDTOConvert = new UserInputDTOConvert();&lt;br/&gt;        User convert = userInputDTOConvert.convert(this);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; convert;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    private static class UserInputDTOConvert implements DTOConvert&amp;lt;UserInputDTO,User&amp;gt; {&lt;br/&gt;        @Override&lt;br/&gt;        public User convert(UserInputDTO userInputDTO) {&lt;br/&gt;            User user = new User();&lt;br/&gt;            BeanUtils.copyProperties(userInputDTO,user);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; user;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后 API 中的转化则由：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;User user = new UserInputDTOConvert().convert(userInputDTO);&lt;br/&gt;User saveUserResult = userService.addUser(user);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;变成了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;User user = userInputDTO.convertToUser();&lt;br/&gt;User saveUserResult = userService.addUser(user);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再 DTO 对象中添加了转化的行为，我相信这样的操作可以让代码的可读性变得更强，并且是符合语义的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;再查工具类&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来看 DTO 内部转化的代码，它实现了我们自己定义的 DTOConvert 接口，但是这样真的就没有问题，不需要再思考了吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我觉得并不是，对于 Convert 这种转化语义来讲，很多工具类中都有这样的定义，这中 Convert 并不是业务级别上的接口定义，它只是用于普通 bean 之间转化属性值的普通意义上的接口定义，所以我们应该更多的去读其他含有 Convert 转化语义的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我仔细阅读了一下 GUAVA 的源码，发现了 com.google.common.base.Convert 这样的定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public abstract class Converter&amp;lt;A, B&amp;gt; implements Function&amp;lt;A, B&amp;gt; {&lt;br/&gt;    protected abstract B doForward(A a);&lt;br/&gt;    protected abstract A doBackward(B b);&lt;br/&gt;    //其他略&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从源码可以了解到，GUAVA 中的 Convert 可以完成正向转化和逆向转化，继续修改我们 DTO 中转化的这段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;private static class UserInputDTOConvert implements DTOConvert&amp;lt;UserInputDTO,User&amp;gt; {&lt;br/&gt;        @Override&lt;br/&gt;        public User convert(UserInputDTO userInputDTO) {&lt;br/&gt;                User user = new User();&lt;br/&gt;                BeanUtils.copyProperties(userInputDTO,user);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; user;&lt;br/&gt;        }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改后：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;private static class UserInputDTOConvert extends Converter&amp;lt;UserInputDTO, User&amp;gt; {&lt;br/&gt;         @Override&lt;br/&gt;         protected User doForward(UserInputDTO userInputDTO) {&lt;br/&gt;                 User user = new User();&lt;br/&gt;                 BeanUtils.copyProperties(userInputDTO,user);&lt;br/&gt;                 &lt;span&gt;return&lt;/span&gt; user;&lt;br/&gt;         }&lt;br/&gt;&lt;br/&gt;         @Override&lt;br/&gt;         protected UserInputDTO doBackward(User user) {&lt;br/&gt;                 UserInputDTO userInputDTO = new UserInputDTO();&lt;br/&gt;                 BeanUtils.copyProperties(user,userInputDTO);&lt;br/&gt;                 &lt;span&gt;return&lt;/span&gt; userInputDTO;&lt;br/&gt;         }&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看了这部分代码以后，你可能会问，那逆向转化会有什么用呢？其实我们有很多小的业务需求中，入参和出参是一样的，那么我们变可以轻松的进行转化，我将上边所提到的 UserInputDTO 和 UserOutputDTO 都转成 UserDTO 展示给大家。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DTO：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class UserDTO {&lt;br/&gt;    private String username;&lt;br/&gt;    private int age;&lt;br/&gt;&lt;br/&gt;    public String &lt;span&gt;&lt;span&gt;getUsername&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; username;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public void setUsername(String username) {&lt;br/&gt;            this.username = username;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public int &lt;span&gt;&lt;span&gt;getAge&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; age;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public void setAge(int age) {&lt;br/&gt;            this.age = age;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    public User &lt;span&gt;&lt;span&gt;convertToUser&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;            UserDTOConvert userDTOConvert = new UserDTOConvert();&lt;br/&gt;            User convert = userDTOConvert.convert(this);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; convert;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public UserDTO convertFor(User user){&lt;br/&gt;            UserDTOConvert userDTOConvert = new UserDTOConvert();&lt;br/&gt;            UserDTO convert = userDTOConvert.reverse().convert(user);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; convert;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    private static class UserDTOConvert extends Converter&amp;lt;UserDTO, User&amp;gt; {&lt;br/&gt;            @Override&lt;br/&gt;            protected User doForward(UserDTO userDTO) {&lt;br/&gt;                    User user = new User();&lt;br/&gt;                    BeanUtils.copyProperties(userDTO,user);&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; user;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            @Override&lt;br/&gt;            protected UserDTO doBackward(User user) {&lt;br/&gt;                    UserDTO userDTO = new UserDTO();&lt;br/&gt;                    BeanUtils.copyProperties(user,userDTO);&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; userDTO;&lt;br/&gt;            }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;API：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@PostMapping&lt;br/&gt; public UserDTO addUser(UserDTO userDTO){&lt;br/&gt;         User user =  userDTO.convertToUser();&lt;br/&gt;         User saveResultUser = userService.addUser(user);&lt;br/&gt;         UserDTO result = userDTO.convertFor(saveResultUser);&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，上述只是表明了转化方向的正向或逆向，很多业务需求的出参和入参的 DTO 对象是不同的，那么你需要更明显的告诉程序：逆向是无法调用的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;private static class UserDTOConvert extends Converter&amp;lt;UserDTO, User&amp;gt; {&lt;br/&gt;         @Override&lt;br/&gt;         protected User doForward(UserDTO userDTO) {&lt;br/&gt;                 User user = new User();&lt;br/&gt;                 BeanUtils.copyProperties(userDTO,user);&lt;br/&gt;                 &lt;span&gt;return&lt;/span&gt; user;&lt;br/&gt;         }&lt;br/&gt;&lt;br/&gt;         @Override&lt;br/&gt;         protected UserDTO doBackward(User user) {&lt;br/&gt;                 throw new AssertionError(&lt;span&gt;&quot;不支持逆向转化方法!&quot;&lt;/span&gt;);&lt;br/&gt;         }&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一下 doBackward 方法，直接抛出了一个断言异常，而不是业务异常，这段代码告诉代码的调用者，这个方法不是准你调用的，如果你调用，我就”断言”你调用错误了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于异常处理的更详细介绍，可以参考我之前的文章：如何优雅的设计 Java 异常（http://lrwinx.github.io/2016/04/28/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%AE%BE%E8%AE%A1java%E5%BC%82%E5%B8%B8/） ，应该可以帮你更好的理解异常。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Bean 的验证&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你认为我上边写的那个添加用户 API 写的已经非常完美了，那只能说明你还不是一个优秀的程序员。我们应该保证任何数据的入参到方法体内都是合法的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么要验证&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多人会告诉我，如果这些 API 是提供给前端进行调用的，前端都会进行验证啊，你为什还要验证？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实答案是这样的，我从不相信任何调用我 API 或者方法的人，比如前端验证失败了，或者某些人通过一些特殊的渠道(比如 Charles 进行抓包)，直接将数据传入到我的 API，那我仍然进行正常的业务逻辑处理，那么就有可能产生脏数据！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“对于脏数据的产生一定是致命”，这句话希望大家牢记在心，再小的脏数据也有可能让你找几个通宵！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;jsr 303验证&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;hibernate 提供的 jsr 303 实现，我觉得目前仍然是很优秀的，具体如何使用，我不想讲，因为谷歌上你可以搜索出很多答案!&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再以上班的 API 实例进行说明，我们现在对 DTO 数据进行检查：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class UserDTO {&lt;br/&gt;    @NotNull&lt;br/&gt;    private String username;&lt;br/&gt;    @NotNull&lt;br/&gt;    private int age;&lt;br/&gt;        //其他代码略&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;API 验证：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@PostMapping&lt;br/&gt;    public UserDTO addUser(@Valid UserDTO userDTO){&lt;br/&gt;            User user =  userDTO.convertToUser();&lt;br/&gt;            User saveResultUser = userService.addUser(user);&lt;br/&gt;            UserDTO result = userDTO.convertFor(saveResultUser);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要将验证结果传给前端，这种异常应该转化为一个 api 异常(带有错误码的异常)。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@PostMapping&lt;br/&gt;public UserDTO addUser(@Valid UserDTO userDTO, BindingResult bindingResult){&lt;br/&gt;     checkDTOParams(bindingResult);&lt;br/&gt;&lt;br/&gt;     User user =  userDTO.convertToUser();&lt;br/&gt;     User saveResultUser = userService.addUser(user);&lt;br/&gt;     UserDTO result = userDTO.convertFor(saveResultUser);&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;br/&gt;private void checkDTOParams(BindingResult bindingResult){&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt;(bindingResult.hasErrors()){&lt;br/&gt;             //throw new 带验证码的验证错误异常&lt;br/&gt;     }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BindingResult 是 Spring MVC 验证 DTO 后的一个结果集，可以参考spring 官方文档（http://spring.io/）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;检查参数后，可以抛出一个“带验证码的验证错误异常”，具体异常设计可以参考如何优雅的设计 Java 异常（http://lrwinx.github.io/2016/04/28/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%AE%BE%E8%AE%A1java%E5%BC%82%E5%B8%B8/）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;拥抱 lombok&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上边的 DTO 代码，已经让我看的很累了，我相信读者也是一样，看到那么多的 Getter 和 Setter 方法，太烦躁了，那时候有什么方法可以简化这些呢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请拥抱 lombok,它会帮助我们解决一些让我们很烦躁的问题&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;去掉 Setter 和 Getter&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这个标题，我不太想说，因为网上太多，但是因为很多人告诉我，他们根本就不知道 lombok 的存在，所以为了让读者更好的学习，我愿意写这样一个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Setter&lt;br/&gt;@Getter&lt;br/&gt;public class UserDTO {&lt;br/&gt;    @NotNull&lt;br/&gt;    private String username;&lt;br/&gt;    @NotNull&lt;br/&gt;    private int age;&lt;br/&gt;&lt;br/&gt;    public User &lt;span&gt;&lt;span&gt;convertToUser&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;        UserDTOConvert userDTOConvert = new UserDTOConvert();&lt;br/&gt;        User convert = userDTOConvert.convert(this);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; convert;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public UserDTO convertFor(User user){&lt;br/&gt;        UserDTOConvert userDTOConvert = new UserDTOConvert();&lt;br/&gt;        UserDTO convert = userDTOConvert.reverse().convert(user);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; convert;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    private static class UserDTOConvert extends Converter&amp;lt;UserDTO, User&amp;gt; {&lt;br/&gt;        @Override&lt;br/&gt;        protected User doForward(UserDTO userDTO) {&lt;br/&gt;            User user = new User();&lt;br/&gt;            BeanUtils.copyProperties(userDTO,user);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; user;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        @Override&lt;br/&gt;        protected UserDTO doBackward(User user) {&lt;br/&gt;            throw new AssertionError(&lt;span&gt;&quot;不支持逆向转化方法!&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到了吧，烦人的 Getter 和 Setter 方法已经去掉了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是上边的例子根本不足以体现 lombok 的强大。我希望写一些网上很难查到，或者很少人进行说明的 lombok 的使用以及在使用时程序语义上的说明。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如:@Data,@AllArgsConstructor,@NoArgsConstructor..这些我就不进行一一说明了，请大家自行查询资料。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;bean 中的链式风格&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么是链式风格？我来举个例子，看下面这个 Student 的 bean：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class Student {&lt;br/&gt;    private String name;&lt;br/&gt;    private int age;&lt;br/&gt;&lt;br/&gt;    public String &lt;span&gt;&lt;span&gt;getName&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; name;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public Student setName(String name) {&lt;br/&gt;        this.name = name;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; this;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public int &lt;span&gt;&lt;span&gt;getAge&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; age;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public Student setAge(int age) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; this;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仔细看一下 set 方法，这样的设置便是 chain 的 style，调用的时候，可以这样使用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Student student = new Student()&lt;br/&gt;        .setAge(24)&lt;br/&gt;        .setName(&lt;span&gt;&quot;zs&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信合理使用这样的链式代码，会更多的程序带来很好的可读性，那看一下如果使用 lombok 进行改善呢，请使用 @Accessors(chain = true)，看如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Accessors(chain = &lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;@Setter&lt;br/&gt;@Getter&lt;br/&gt;public class Student {&lt;br/&gt;    private String name;&lt;br/&gt;    private int age;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就完成了一个对于 bean 来讲很友好的链式操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;静态构造方法&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;静态构造方法的语义和简化程度真的高于直接去 new 一个对象。比如 new 一个 List 对象，过去的使用是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一下 guava 中的创建方式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;String&amp;gt; list = Lists.newArrayList();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lists 命名是一种约定(俗话说：约定优于配置)，它是指 Lists 是 List 这个类的一个工具类，那么使用 List 的工具类去产生 List，这样的语义是不是要比直接 new 一个子类来的更直接一些呢，答案是肯定的，再比如如果有一个工具类叫做 Maps，那你是否想到了创建 Map 的方法呢：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;HashMap&amp;lt;String, String&amp;gt; objectObjectHashMap = Maps.newHashMap();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，如果你理解了我说的语义，那么，你已经向成为 Java 程序员更近了一步了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再回过头来看刚刚的 Student，很多时候，我们去写 Student 这个 bean 的时候，他会有一些必输字段，比如 Student 中的 name 字段，一般处理的方式是将 name 字段包装成一个构造方法，只有传入 name 这样的构造方法，才能创建一个 Student 对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接上上边的静态构造方法和必传参数的构造方法，使用 lombok 将更改成如下写法（@RequiredArgsConstructor 和 @NonNull）:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Accessors(chain = &lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;@Setter&lt;br/&gt;@Getter&lt;br/&gt;@RequiredArgsConstructor(staticName = &lt;span&gt;&quot;ofName&quot;&lt;/span&gt;)&lt;br/&gt;public class Student {&lt;br/&gt;    @NonNull private String name;&lt;br/&gt;    private int age;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Student student = Student.ofName(&lt;span&gt;&quot;zs&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样构建出的 bean 语义是否要比直接 new 一个含参的构造方法(包含  name 的构造方法)要好很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，看过很多源码以后，我想相信将静态构造方法 ofName 换成 of 会先的更加简洁：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Accessors(chain = &lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;@Setter&lt;br/&gt;@Getter&lt;br/&gt;@RequiredArgsConstructor(staticName = &lt;span&gt;&quot;of&quot;&lt;/span&gt;)&lt;br/&gt;public class Student {&lt;br/&gt;        @NonNull private String name;&lt;br/&gt;        private int age;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Student student = Student.of(&lt;span&gt;&quot;zs&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然他仍然是支持链式调用的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Student student = Student.of(&lt;span&gt;&quot;zs&quot;&lt;/span&gt;).setAge(24);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样来写代码，真的很简洁，并且可读性很强。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;使用 builder&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Builder 模式我不想再多解释了，读者可以看一下《Head First》(设计模式) 的建造者模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天其实要说的是一种变种的 builder 模式，那就是构建 bean 的 builder 模式，其实主要的思想是带着大家一起看一下 lombok 给我们带来了什么。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一下 Student 这个类的原始 builder 状态:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class Student {&lt;br/&gt;    private String name;&lt;br/&gt;    private int age;&lt;br/&gt;&lt;br/&gt;    public String &lt;span&gt;&lt;span&gt;getName&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; name;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public void setName(String name) {&lt;br/&gt;            this.name = name;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public int &lt;span&gt;&lt;span&gt;getAge&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; age;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public void setAge(int age) {&lt;br/&gt;            this.age = age;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public static Builder &lt;span&gt;&lt;span&gt;builder&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; new Builder();&lt;br/&gt;    }&lt;br/&gt;    public static class Builder{&lt;br/&gt;            private String name;&lt;br/&gt;            private int age;&lt;br/&gt;            public Builder name(String name){&lt;br/&gt;                    this.name = name;&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; this;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            public Builder age(int age){&lt;br/&gt;                    this.age = age;&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; this;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            public Student &lt;span&gt;&lt;span&gt;build&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;                    Student student = new Student();&lt;br/&gt;                    student.setAge(age);&lt;br/&gt;                    student.setName(name);&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; student;&lt;br/&gt;            }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用方式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Student student = Student.builder().name(&lt;span&gt;&quot;zs&quot;&lt;/span&gt;).age(24).build();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的 builder 代码，让我是在恶心难受，于是我打算用 lombok 重构这段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Builder&lt;br/&gt;public class Student {&lt;br/&gt;    private String name;&lt;br/&gt;    private int age;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用方式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Student student = Student.builder().name(&lt;span&gt;&quot;zs&quot;&lt;/span&gt;).age(24).build();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代理模式&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如我们所知的，在程序中调用 rest 接口是一个常见的行为动作，如果你和我一样使用过 spring 的 RestTemplate，我相信你会我和一样，对他抛出的非 http 状态码异常深恶痛绝。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们考虑将 RestTemplate 最为底层包装器进行包装器模式的设计：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public abstract class FilterRestTemplate implements RestOperations {&lt;br/&gt;        protected volatile RestTemplate restTemplate;&lt;br/&gt;&lt;br/&gt;        protected FilterRestTemplate(RestTemplate restTemplate){&lt;br/&gt;                this.restTemplate = restTemplate;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        //实现RestOperations所有的接口&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后再由扩展类对 FilterRestTemplate 进行包装扩展：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class ExtractRestTemplate extends FilterRestTemplate {&lt;br/&gt;    private RestTemplate restTemplate;&lt;br/&gt;    public ExtractRestTemplate(RestTemplate restTemplate) {&lt;br/&gt;            super(restTemplate);&lt;br/&gt;            this.restTemplate = restTemplate;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public &amp;lt;T&amp;gt; RestResponseDTO&amp;lt;T&amp;gt; postForEntityWithNoException(String url, Object request, Class&amp;lt;T&amp;gt; responseType, Object... uriVariables)&lt;br/&gt;                    throws RestClientException {&lt;br/&gt;            RestResponseDTO&amp;lt;T&amp;gt; restResponseDTO = new RestResponseDTO&amp;lt;T&amp;gt;();&lt;br/&gt;            ResponseEntity&amp;lt;T&amp;gt; tResponseEntity;&lt;br/&gt;            try {&lt;br/&gt;                    tResponseEntity = restTemplate.postForEntity(url, request, responseType, uriVariables);&lt;br/&gt;                    restResponseDTO.setData(tResponseEntity.getBody());&lt;br/&gt;                    restResponseDTO.setMessage(tResponseEntity.getStatusCode().name());&lt;br/&gt;                    restResponseDTO.setStatusCode(tResponseEntity.getStatusCodeValue());&lt;br/&gt;            }catch (Exception e){&lt;br/&gt;                    restResponseDTO.setStatusCode(RestResponseDTO.UNKNOWN_ERROR);&lt;br/&gt;                    restResponseDTO.setMessage(e.getMessage());&lt;br/&gt;                    restResponseDTO.setData(null);&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; restResponseDTO;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;包装器 ExtractRestTemplate 很完美的更改了异常抛出的行为，让程序更具有容错性。在这里我们不考虑 ExtractRestTemplate 完成的功能，让我们把焦点放在 FilterRestTemplate 上，“实现 RestOperations 所有的接口”,这个操作绝对不是一时半会可以写完的，当时在重构之前我几乎写了半个小时,如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public abstract class FilterRestTemplate implements RestOperations {&lt;br/&gt;&lt;br/&gt;    protected volatile RestTemplate restTemplate;&lt;br/&gt;&lt;br/&gt;    protected FilterRestTemplate(RestTemplate restTemplate) {&lt;br/&gt;            this.restTemplate = restTemplate;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    public &amp;lt;T&amp;gt; T getForObject(String url, Class&amp;lt;T&amp;gt; responseType, Object... uriVariables) throws RestClientException {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; restTemplate.getForObject(url,responseType,uriVariables);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    public &amp;lt;T&amp;gt; T getForObject(String url, Class&amp;lt;T&amp;gt; responseType, Map&amp;lt;String, ?&amp;gt; uriVariables) throws RestClientException {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; restTemplate.getForObject(url,responseType,uriVariables);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    public &amp;lt;T&amp;gt; T getForObject(URI url, Class&amp;lt;T&amp;gt; responseType) throws RestClientException {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; restTemplate.getForObject(url,responseType);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    public &amp;lt;T&amp;gt; ResponseEntity&amp;lt;T&amp;gt; getForEntity(String url, Class&amp;lt;T&amp;gt; responseType, Object... uriVariables) throws RestClientException {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; restTemplate.getForEntity(url,responseType,uriVariables);&lt;br/&gt;    }&lt;br/&gt;    //其他实现代码略。。。&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我相信你看了以上代码，你会和我一样觉得恶心反胃，后来我用 lombok 提供的代理注解优化了我的代码(@Delegate)：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@AllArgsConstructor&lt;br/&gt;public abstract class FilterRestTemplate implements RestOperations {&lt;br/&gt;    @Delegate&lt;br/&gt;    protected volatile RestTemplate restTemplate;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这几行代码完全替代上述那些冗长的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是不是很简洁，做一个拥抱 lombok 的程序员吧。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;重构&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;需求案例&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;项目需求&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目开发阶段，有一个关于下单发货的需求：如果今天下午 3 点前进行下单，那么发货时间是明天，如果今天下午 3 点后进行下单，那么发货时间是后天，如果被确定的时间是周日，那么在此时间上再加 1 天为发货时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;思考与重构&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我相信这个需求看似很简单，无论怎么写都可以完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多人可能看到这个需求，就动手开始写 Calendar 或 Date 进行计算，从而完成需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而我给的建议是，仔细考虑如何写代码，然后再去写，不是说所有的时间操作都用 Calendar 或 Date 去解决，一定要看场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于时间的计算我们要考虑 joda-time 这种类似的成熟时间计算框架来写代码，它会让代码更加简洁和易读。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请读者先考虑这个需求如何用 Java 代码完成，或先写一个你觉得完成这个代码的思路，再来看我下边的代码，这样，你的收获会更多一些：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;final DateTime DISTRIBUTION_TIME_SPLIT_TIME = new DateTime().withTime(15,0,0,0);&lt;br/&gt;private Date calculateDistributionTimeByOrderCreateTime(Date orderCreateTime){&lt;br/&gt;    DateTime orderCreateDateTime = new DateTime(orderCreateTime);&lt;br/&gt;    Date tomorrow = orderCreateDateTime.plusDays(1).toDate();&lt;br/&gt;    Date theDayAfterTomorrow = orderCreateDateTime.plusDays(2).toDate();&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; orderCreateDateTime.isAfter(DISTRIBUTION_TIME_SPLIT_TIME) ? wrapDistributionTime(theDayAfterTomorrow) : wrapDistributionTime(tomorrow);&lt;br/&gt;}&lt;br/&gt;private Date wrapDistributionTime(Date distributionTime){&lt;br/&gt;    DateTime currentDistributionDateTime = new DateTime(distributionTime);&lt;br/&gt;    DateTime plusOneDay = currentDistributionDateTime.plusDays(1);&lt;br/&gt;    boolean isSunday = (DateTimeConstants.SUNDAY == currentDistributionDateTime.getDayOfWeek());&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; isSunday ? plusOneDay.toDate() : currentDistributionDateTime.toDate() ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读这段代码的时候，你会发现，我将判断和有可能出现的不同结果都当做一个变量，最终做一个三目运算符的方式进行返回，这样的优雅和可读性显而易见，当然这样的代码不是一蹴而就的，我优化了 3 遍产生的以上代码。读者可根据自己的代码和我写的代码进行对比。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;提高方法&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你做了 3 年+的程序员，我相信像如上这样的需求，你很轻松就能完成，但是如果你想做一个会写 Java 的程序员，就好好的思考和重构代码吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写代码就如同写字一样，同样的字，大家都会写，但是写出来是否好看就不一定了。如果想把程序写好，就要不断的思考和重构，敢于尝试，敢于创新，不要因循守旧，一定要做一个优秀的 Java 程序员。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提高代码水平最好的方法就是有条理的重构！(注意：是有条理的重构)&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;设计模式&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计模式就是工具，而不是提现你是否是高水平程序员的一个指标。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我经常会看到某一个程序员兴奋的大喊，哪个程序哪个点我用到了设计模式，写的多么多么优秀，多么多么好。我仔细去翻阅的时候，却发现有很多是过度设计的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;业务驱动技术 or 技术驱动业务&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务驱动技术 or 技术驱动业务 ？其实这是一个一直在争论的话题，但是很多人不这么认为，我觉得就是大家不愿意承认罢了。我来和大家大概分析一下作为一个 Java 程序员，我们应该如何判断自己所处于的位置.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;业务驱动技术：&lt;/strong&gt; 如果你所在的项目是一个收益很小或者甚至没有收益的项目，请不要搞其他创新的东西，不要驱动业务要如何如何做，而是要熟知业务现在的痛点是什么？如何才能帮助业务盈利或者让项目更好，更顺利的进行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;技术驱动业务：&lt;/strong&gt; 如果你所在的项目是一个很牛的项目，比如淘宝这类的项目，我可以在满足业务需求的情况下，和业务沟通，使用什么样的技术能更好的帮助业务创造收益，比如说下单的时候要进队列，可能几分钟之后订单状态才能处理完成，但是会让用户有更流畅的体验，赚取更多的访问流量，那么我相信业务愿意被技术驱动，会同意订单的延迟问题，这样便是技术驱动业务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我相信大部分人还都处于业务驱动技术的方向吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以你既然不能驱动业务，那就请拥抱业务变化吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码设计&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一直在做 Java 后端的项目，经常会有一些变动，我相信大家也都遇到过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如当我们写一段代码的时候，我们考虑将需求映射成代码的状态模式，突然有一天，状态模式里边又添加了很多行为变化的东西，这时候你就挠头了，你硬生生的将状态模式中添加过多行为和变化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;慢慢的你会发现这些状态模式，其实更像是一簇算法，应该使用策略模式，这时你应该已经晕头转向了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说了这么多，我的意思是，只要你觉得合理，就请将状态模式改为策略模式吧，所有的模式并不是凭空想象出来的，都是基于重构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 编程中没有银弹，请拥抱业务变化，一直思考重构，你就有一个更好的代码设计!&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;你真的优秀吗？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;真不好意思，我取了一个这么无聊的标题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;国外流行一种编程方式，叫做结对编程，我相信国内很多公司都没有这么做，我就不在讲述结对编程带来的好处了，其实就是一边 code review，一边互相提高的一个过程。既然做不到这个，那如何让自己活在自己的世界中不断提高呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“平时开发的时候，做出的代码总认为是正确的，而且写法是完美的。”，我相信这是大部分人的心声，还回到刚刚的问题，如何在自己的世界中不断提高呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案就是:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;多看成熟框架的源码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多回头看自己的代码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;勤于重构&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你真的优秀吗？如果你每周都完成了学习源码，回头看自己代码，然后勤于重构，我认为你就真的很优秀了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使也许你只是刚刚入门，但是一直坚持，你就是一个真的会写java代码的程序员了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;技能&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;UML&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不想多讨论 UML 相关的知识，但是我觉得你如果真的会写 Java，请先学会表达自己，UML 就是你说话的语言，做一名优秀的 Java 程序员，请至少学会这两种 UML 图：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;类图&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;时序图&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;clean code&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我认为保持代码的简洁和可读性是代码的最基本保证，如果有一天为了程序的效率而降低了这两点，我认为是可以谅解的，除此之外，没有任何理由可以让你任意挥霍你的代码。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;读者可以看一下 Robert C. Martin 出版的《Clean Code》（代码整洁之道） 这本书&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以参考美团文章聊聊 clean code（http://tech.meituan.com/clean-code.html）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;也可以看一下阿里的 Java 编码规范（https://yq.aliyun.com/articles/69327?spm=5176.100239.topwz.1.om5dRN）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论如何，请保持你的代码的整洁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Linux 基础命令&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这点其实和会写 Java 没有关系，但是 Linux 很多时候确实承载运行 Java 的容器，请学好 Linux 的基础命令。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;参考鸟哥的《Linux私房菜》&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 是一个大体系，今天讨论并未涉及框架和架构相关知识，只是讨论如何写好代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文从写 Java 程序的小方面一直写到大方面，来阐述了如何才能写好 Java 程序，并告诉读者们如何才能提高自身的编码水平。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我希望看到这篇文章的各位都能做一个优秀的 Java 程序员。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5d4ea1c8442a2603b530df86f3cac807</guid>
<title>解决微服务架构下流量有损问题的实践和探索</title>
<link>https://toutiao.io/k/f8xxqp3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;阿里开发者&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;ali_tech&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;阿里巴巴官方技术号，关于阿里的技术创新均呈现于此。&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>10f6242a0e67c699e3ea03fad0d3fd50</guid>
<title>程序设计的2个技巧</title>
<link>https://toutiao.io/k/iwooo69</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;善用本地缓存&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;7年前见过一个别人做的项目：因为公司的视频和专辑这些媒体资讯信息属于基础数据，非常重要。有个基础服务专门将这些基础数据提供给全公司使用。这些数据都是从后台信息中录入的，全量数据数据库中有存储，并全量存到了集中式缓存中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;全量数据大概不到500M。但是存在一些大专辑，就是说有的数据一条就占几M。所以在查询时，特别是请求多的时候遇到很多超时现象。毕竟像redis等集中式缓存都不建议缓存大数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是我们这个服务特别重要，请求量大，SLA要求高，得缓存啊。这时我建议直接使用本地缓存。很多人在设计的时候有个误区：有了集中式缓存再用本地缓存好像不够高级。最高级的用法是采用合适的技术。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;咱们以终为始的来考虑问题：集中式缓存的好处是数据一致性高，一旦数据更新了。从哪台应用服务器取的数据都是一样的。但是咱们目前的情况是数据是后台录入的，本身就有人工时间误差。所以定时1分钟、2分钟从数据库刷新一次检查数据有没有变化也是可以的。每个服务有一定时间差也是可以容忍的。所以集中式缓存的必要性并不高。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有人说本地内存很珍贵呀。咱们来算一算哈。一般这种核心的系统，随着请求量的增加，IO会增加、CPU会增加，基本与请求量成线性关系。当然每个请求都要占用一定内存，拿Java语言来说。主要是年轻代的占用。像这种大数据一直在内存中的就直接进入老年代了，当然也可以直接使用堆外内存。因为JVM等存储各个内存区大小固定，请求增多会导致年轻代的young gc频率升高，其实对老年代影响并不明显。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其实可以验证一下，请求量升高时，内存的使用量变化很少。所以内存影响是可以计算的。比如咱们4C8G的虚机，内存多使用500M，只要JVM参数设置合理，对一般程序来说都是可以接受的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用这种方案，避免了集中式缓存大value引起的各种超时等问题，很多请求下反而更优。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;不兼容版本设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;当开发了一个接口2.0，产品设计人员的设计与原来1.0完全不兼容。1.0已经有用户在使用了。怎么办呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当遇到一个问题，不知道怎么做更合适的时候首先要做业界调研。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;微信开放平台的做法：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2843560933448574&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8vHMYx0goeNdBCnJ2ljcXuz3vOy3iaHj4FwnjFvBStY8TOez8DBF8kjrgCz0CkKvO4JXYAqmI5oQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1157&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在url中标明版本号，按照版本号进行路由。不同版本对应不同的实现，并且将不同版本的请求不同点都体现在文档中。接入方就不会质疑版本不兼容问题了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;编程一生&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;因为公众号平台更改了推送规则，如果不想错过内容，记得读完点一下“在看”，加个“星标”，这样每次新文章推送才会第一时间出现在你的订阅列表里。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;想知道自己错过了哪些更新，可参考我不定期更新的《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247487380&amp;amp;idx=2&amp;amp;sn=4e71d679e2c22f9c5af4ea3abc667b76&amp;amp;chksm=fafde53acd8a6c2c9d2fb5eb83de5e5a2e3f244a57fa275394d9d61a0cdfa154290fe7a21fe8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;系列文章分类汇总&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;em&gt;&lt;strong&gt;系列文章分类汇总&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt;》。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6ded83e42f672a50ce34bb3e11e3890b</guid>
<title>万字多图，搞懂 Nginx 高性能网络工作原理！</title>
<link>https://toutiao.io/k/1uwy12d</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在单进程的网络编程模型中。所有的网络相关的动作都是在一个进程里完成的，如监听 socket 的创建， bind、listen。再比如 epoll 的创建、要监听事件的添加，以及 epoll_wait 等待时间发生。这些统统都是在一个进程里搞定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个客户端和使用了 epoll 的服务端的交互过程如下图所示。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7338935574229691&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwpF6MsOEOggicl4DMuMMRw1vkVmVYgicMhkScuhx89b3toAUmiaqNW33N2U7EWgPCVrDUph9yp6BXoOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;714&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是其大概的代码示例（没耐心看的同学可以先）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//监听&lt;/span&gt;&lt;br/&gt; lfd = socket(AF_INET,SOCK_STREAM,&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt; bind(lfd, ...)&lt;br/&gt; listen(lfd, ...);&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//创建epoll对象，并把 listen socket的事件管理起来&lt;/span&gt;&lt;br/&gt; efd = epoll_create(...);&lt;br/&gt; epoll_ctl(efd, EPOLL_CTL_ADD, lfd, ...);&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//事件循环&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; (;;)&lt;br/&gt; {&lt;br/&gt;  &lt;span&gt;size_t&lt;/span&gt; nready = epoll_wait(efd, ep, ...);&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; nready; ++i){&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt;(ep[i].data.fd == lfd){&lt;br/&gt;    &lt;span&gt;//lfd上发生事件表示都连接到达，accept接收它&lt;/span&gt;&lt;br/&gt;    fd = accept(listenfd, ...);&lt;br/&gt;    epoll_ctl(efd, EPOLL_CTL_ADD, fd, ...);&lt;br/&gt;   }&lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//其它socket发生的事件都是读写请求、或者关闭连接&lt;/span&gt;&lt;br/&gt;    ...&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在单进程模型中，不管有多少的连接，是几万还是几十万，服务器都是通过 epoll 来监控这些连接 socket 上的可读和可写事件。当某个 socket 上有数据发生的时候，再以非阻塞的方式对 socket 进行读写操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上，Redis 5.0 及以前的版本中，它的网络部分去掉对 handler 的封装，去掉时间事件以后，代码基本和上述 demo 非常接近。而且因为 Redis 的业务特点只需要内存 IO，且 CPU 计算少，所以可以达到数万的 QPS。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.36952714535901926&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwpUl8z4ZynA4FDhCF7r0gOFTefBrdiaDuF5uLLtZ664DBdQspzb8jCUPYverYWiaicsygWzvcM7lOx3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;571&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是单进程的问题也是显而易见的，没有办法充分发挥多核的优势。所以目前业界绝大部分的后端服务还都是需要基于多进程的方式来进行开发的。到了多进程的时候，更复杂的问题多进程之间的配合和协作问题就产生了。比如&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;哪个进程执行监听 listen ，以及 accept 接收新连接？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;哪个进程负责发现用户连接上的读写事件？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当有用户请求到达的时候，如何均匀地将请求分散到不同的进程中？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需不需要单独搞一部分进程执行计算工作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;...&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上，以上这些问题并没有标准答案。各大应用或者网络框架都有自己不同的实现方式。为此业界还专门总结出了两类网络设计模式 - Reactor 和 Proactor。不过今天我不想讨论这种抽象模式，而是想带大家看一个具体的 Case - Nginx 是如何在多进程下使用 epoll 的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、 Nginx Master 进程初始化&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Nginx 中，将进程分成了两类。一类是 Master 进程，一类是 Worker 进程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Master 进程中，主要的任务是负责启动整个程序、读取配置文件、监听和处理各种信号，并对 Worker 进程进行统筹管理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过今天我们要查看的重点问题是看网络。在 Master 进程中，和网络相关的操作非常简单就是创建了 socket 并对其进行 bind 和 监听。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3630573248407643&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwpF6MsOEOggicl4DMuMMRw1vKUIAcnIbKgy8fJD5AUy9UHbnicycrDicmISSsxSbiaZbTV0UQbFtlmB7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;471&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体细节我们来看 Main 函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/core/nginx.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; ngx_cdecl &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;const&lt;/span&gt; *argv)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;ngx_cycle_t&lt;/span&gt;      *cycle, init_cycle;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//1.1 ngx_init_cycle 中开启监听&lt;/span&gt;&lt;br/&gt; cycle = ngx_init_cycle(&amp;amp;init_cycle);&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//1.2 启动主进程循环&lt;/span&gt;&lt;br/&gt; ngx_master_process_cycle(cycle);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Nginx 中，ngx_cycle_t 是非常核心的一个结构体。这个结构体存储了很多东西，也贯穿了好多的函数。其中对端口的 bind 和 listen 就是在它执行时完成的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ngx_master_process_cycle 是 Master 进程的主事件循环。它先是根据配置启动指定数量的 Worker 进程，然后就开始关注和处理重启、退出等信号。接下来我们分两个小节来更详细地看。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 Nginx 的服务端口监听&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看下 ngx_init_cycle 中是如何执行 bind 和 listen 的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/core/ngx_cycle.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;ngx_cycle_t&lt;/span&gt; *&lt;span&gt;ngx_init_cycle&lt;/span&gt;&lt;span&gt;(&lt;span&gt;ngx_cycle_t&lt;/span&gt; *old_cycle)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; ......&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (ngx_open_listening_sockets(cycle) != NGX_OK) {&lt;br/&gt;  &lt;span&gt;goto&lt;/span&gt; failed;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;真正的监听还是在 ngx_open_listening_sockets 函数中，继续看它的源码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/core/ngx_connection.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;ngx_int_t&lt;/span&gt; &lt;span&gt;ngx_open_listening_sockets&lt;/span&gt;&lt;span&gt;(&lt;span&gt;ngx_cycle_t&lt;/span&gt; *cycle)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; ......&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//要监听的 socket 对象&lt;/span&gt;&lt;br/&gt; ls = cycle-&amp;gt;listening.elts;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; cycle-&amp;gt;listening.nelts; i++) {&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;//获取第i个socket&lt;/span&gt;&lt;br/&gt;  s = ngx_socket(ls[i].sockaddr-&amp;gt;sa_family, ls[i].type, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;//绑定&lt;/span&gt;&lt;br/&gt;  bind(s, ls[i].sockaddr, ls[i].socklen)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;//监听&lt;/span&gt;&lt;br/&gt;  listen(s, ls[i].backlog)&lt;br/&gt;  ls[i].listen = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  ls[i].fd = s;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个函数中，遍历要监听的 socket。如果是启用了 REUSEPORT 配置，那先把 socket 设置上 SO_REUSEPORT 选项。然后接下来就是大家都熟悉的 bind 和 listen。&lt;strong&gt;所以，bind 和 listen 是在 Master 进程中完成的。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 Master 进程的主循环&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 ngx_master_process_cycle 中主要完成两件事。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;启动 Worker 进程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 Master 进程推入事件循环&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在创建 Worker 进程的时候，是通过 fork 系统调用让 Worker 进程完全复制自己的资源，包括 listen 状态的 socket 句柄。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.423728813559322&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwpF6MsOEOggicl4DMuMMRw1vnjib4EcVV0ofKK0ljicIaTMS2DpeEmaBZFpqdFrCyG4qb9ib6W7ibzmvdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;531&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们接下来看详细的代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/os/unix/ngx_process_cycle.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;ngx_master_process_cycle&lt;/span&gt;&lt;span&gt;(&lt;span&gt;ngx_cycle_t&lt;/span&gt; *cycle)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; ......&lt;br/&gt; ngx_start_worker_processes(cycle, ccf-&amp;gt;worker_processes,&lt;br/&gt;          NGX_PROCESS_RESPAWN);&lt;br/&gt; &lt;span&gt;//进入主循环,等待接收各种信号&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; ( ;; ) {&lt;br/&gt;  &lt;span&gt;//ngx_quit&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//ngx_reconfigure&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//ngx_restart&lt;/span&gt;&lt;br/&gt;  ...&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主进程在配置中读取到了 Worker 进程的数量 &lt;code&gt;ccf-&amp;gt;worker_processes&lt;/code&gt;。通过 ngx_start_worker_processes 来启动指定数量的 Worker。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/os/unix/ngx_process_cycle.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;ngx_start_worker_processes&lt;/span&gt;&lt;span&gt;(...)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++) {&lt;br/&gt;  ngx_spawn_process(cycle, ngx_worker_process_cycle,&lt;br/&gt;        (&lt;span&gt;void&lt;/span&gt; *) (&lt;span&gt;intptr_t&lt;/span&gt;) i, &lt;span&gt;&quot;worker process&quot;&lt;/span&gt;, type);&lt;br/&gt;  ...&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述代码中值得注意的是，在调用 ngx_spawn_process 时的几个参数&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;cycle：nginx 的核心数据结构&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ngx_worker_process_cycle：worker 进程的入口函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;i: 当前 worker 的序号&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/os/unix/ngx_process.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;ngx_pid_t&lt;/span&gt; &lt;span&gt;ngx_spawn_process&lt;/span&gt;&lt;span&gt;(&lt;span&gt;ngx_cycle_t&lt;/span&gt; *cycle, ngx_spawn_proc_pt proc,...)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; pid = fork();&lt;br/&gt; &lt;span&gt;switch&lt;/span&gt; (pid) {&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;: &lt;span&gt;//出错了&lt;/span&gt;&lt;br/&gt;   ... &lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;: &lt;span&gt;//子进程创建成功&lt;/span&gt;&lt;br/&gt;   ngx_parent = ngx_pid;&lt;br/&gt;   ngx_pid = ngx_getpid();&lt;br/&gt;   proc(cycle, data);&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt; }&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 ngx_spawn_process 中调用 fork 来创建进程，创建成功后 Worker 进程就将进入 ngx_worker_process_cycle 来进行处理了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;总结：&lt;/strong&gt; 在网络上，master 进程其实只是 listen 了一下。listen 过后的 socket 存到 cycle-&amp;gt;listening 这里了。剩下的网络操作都是在 Worker 中完成的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、Worker 进程处理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面小节中看到，Master 进程关于网络其实做的事情不多，只是 bind 和 listen 了一下。epoll 相关的函数调用一个也没见着，更别说 accept 接收连接，以及 read 、 write 函数处理了。那这些细节一定都是在 Worker 进程中完成的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实的确如此，epoll_create、epoll_ctl、epoll_wait 都是在 Worker 进程中执行的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5612708018154312&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwpF6MsOEOggicl4DMuMMRw1vcL2AwTHxYD6ZK7uvniaetQIiaicF9dluc6CD2EX3qLoC4EyuObNbzzxicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;661&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Worker 进程中，创建了一个 epoll 内核对象，通过 epoll_ctl 将其想监听的事件注册上去，然后调用 epoll_wait 进入事件循环。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/os/unix/ngx_process_cycle.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;ngx_worker_process_cycle&lt;/span&gt;&lt;span&gt;(&lt;span&gt;ngx_cycle_t&lt;/span&gt; *cycle, &lt;span&gt;void&lt;/span&gt; *data)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//2.2 Worker进程初始化编译进来的各个模块&lt;/span&gt;&lt;br/&gt; ngx_worker_process_init(cycle, worker);&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//进入事件循环&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; ( ;; ) {&lt;br/&gt;  &lt;span&gt;//2.3 进入 epollwait&lt;/span&gt;&lt;br/&gt;  ngx_process_events_and_timers(cycle);&lt;br/&gt;  ......&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们分别来细看。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 Nginx 的 网络相关 module&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;撇开 Worker 的工作流程不提，咱们先来了解一个背景知识 - Nginx module。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nginx 采用的是一种模块化的架构，它的模块包括核心模块、标准HTTP模块、可选HTTP模块、邮件服务模块和第三方模块等几大类。每一个模块都以一个 module 的形式存在，都对应一个 ngx_module_s 结构体。通过这种方式来实现软件可拔插，是一种非常优秀的软件架构。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5583864118895966&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwpF6MsOEOggicl4DMuMMRw1vZ8EZRHBzDQuDSVPMlvEjiaT6WuMsYZ7GJ1ttJicEZ2fCeTwvfbzfGWCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;471&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个 module 根据自己的需求来实现各种 init_xxx, exit_xxx 方法来供 Nginx 在合适的时机调用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/core/ngx_module.h&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;ngx_module_s&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; ......&lt;br/&gt;&lt;br/&gt; &lt;span&gt;ngx_uint_t&lt;/span&gt;            version;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;void&lt;/span&gt;                 *ctx;&lt;br/&gt; &lt;span&gt;ngx_command_t&lt;/span&gt;        *commands;&lt;br/&gt; &lt;span&gt;ngx_uint_t&lt;/span&gt;            type;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;ngx_int_t&lt;/span&gt;           (*init_master)(&lt;span&gt;ngx_log_t&lt;/span&gt; *&lt;span&gt;log&lt;/span&gt;);&lt;br/&gt; &lt;span&gt;ngx_int_t&lt;/span&gt;           (*init_module)(&lt;span&gt;ngx_cycle_t&lt;/span&gt; *cycle);&lt;br/&gt; &lt;span&gt;ngx_int_t&lt;/span&gt;           (*init_process)(&lt;span&gt;ngx_cycle_t&lt;/span&gt; *cycle);&lt;br/&gt; &lt;span&gt;ngx_int_t&lt;/span&gt;           (*init_thread)(&lt;span&gt;ngx_cycle_t&lt;/span&gt; *cycle);&lt;br/&gt; &lt;span&gt;void&lt;/span&gt;                (*exit_thread)(&lt;span&gt;ngx_cycle_t&lt;/span&gt; *cycle);&lt;br/&gt; &lt;span&gt;void&lt;/span&gt;                (*exit_process)(&lt;span&gt;ngx_cycle_t&lt;/span&gt; *cycle);&lt;br/&gt; &lt;span&gt;void&lt;/span&gt;                (*exit_master)(&lt;span&gt;ngx_cycle_t&lt;/span&gt; *cycle);&lt;br/&gt;&lt;br/&gt; ......&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中和网络相关的 module 有 ngx_events_module 、ngx_event_core_module 和具体的网络底层模块 ngx_epoll_module、ngx_kqueue_module等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 ngx_epoll_module 来说，它在其上下文 ngx_epoll_module_ctx 中定义了各种 actions 方法（添加事件、删除事件、添加连接等）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/event/ngx_event.h&lt;/span&gt;&lt;br/&gt;&lt;span&gt;typedef&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;ngx_str_t&lt;/span&gt;              *name;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;void&lt;/span&gt;                 *(*create_conf)(&lt;span&gt;ngx_cycle_t&lt;/span&gt; *cycle);&lt;br/&gt; &lt;span&gt;char&lt;/span&gt;                 *(*init_conf)(&lt;span&gt;ngx_cycle_t&lt;/span&gt; *cycle, &lt;span&gt;void&lt;/span&gt; *conf);&lt;br/&gt;&lt;br/&gt; &lt;span&gt;ngx_event_actions_t&lt;/span&gt;     actions;&lt;br/&gt;} &lt;span&gt;ngx_event_module_t&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/event/modules/ngx_epoll_module.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;ngx_event_module_t&lt;/span&gt;  ngx_epoll_module_ctx = {&lt;br/&gt; &amp;amp;epoll_name,&lt;br/&gt; ngx_epoll_create_conf,               &lt;span&gt;/* create configuration */&lt;/span&gt;&lt;br/&gt; ngx_epoll_init_conf,                 &lt;span&gt;/* init configuration */&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; {&lt;br/&gt;  ngx_epoll_add_event,             &lt;span&gt;/* add an event */&lt;/span&gt;&lt;br/&gt;  ngx_epoll_del_event,             &lt;span&gt;/* delete an event */&lt;/span&gt;&lt;br/&gt;  ngx_epoll_add_event,             &lt;span&gt;/* enable an event */&lt;/span&gt;&lt;br/&gt;  ngx_epoll_del_event,             &lt;span&gt;/* disable an event */&lt;/span&gt;&lt;br/&gt;  ngx_epoll_add_connection,        &lt;span&gt;/* add an connection */&lt;/span&gt;&lt;br/&gt;  ngx_epoll_del_connection,        &lt;span&gt;/* delete an connection */&lt;/span&gt;&lt;br/&gt;#&lt;span&gt;if&lt;/span&gt; (NGX_HAVE_EVENTFD)&lt;br/&gt;  ngx_epoll_notify,                &lt;span&gt;/* trigger a notify */&lt;/span&gt;&lt;br/&gt;#&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;NULL&lt;/span&gt;,                            &lt;span&gt;/* trigger a notify */&lt;/span&gt;&lt;br/&gt;#endif&lt;br/&gt;  ngx_epoll_process_events,        &lt;span&gt;/* process the events */&lt;/span&gt;&lt;br/&gt;  ngx_epoll_init,                  &lt;span&gt;/* init the events */&lt;/span&gt;&lt;br/&gt;  ngx_epoll_done,                  &lt;span&gt;/* done the events */&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中有一个 init 方法是 ngx_epoll_init，在这个 init 中会进行 epoll 对象的创建，以及 ngx_event_actions 方法的设置。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file:src/event/modules/ngx_epoll_module.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;ngx_int_t&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ngx_epoll_init&lt;/span&gt;&lt;span&gt;(&lt;span&gt;ngx_cycle_t&lt;/span&gt; *cycle, &lt;span&gt;ngx_msec_t&lt;/span&gt; timer)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//创建一个 epoll 句柄&lt;/span&gt;&lt;br/&gt; ep = epoll_create(cycle-&amp;gt;connection_n / &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt; ...&lt;br/&gt;&lt;br/&gt; ngx_event_actions = ngx_epoll_module_ctx.actions;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 Worker 进程初始化各个模块&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Worker 进程初始化的时候，在 ngx_worker_process_init 中读取配置信息进行一些设置，然后调用所有模块的 init_process 方法。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5473321858864028&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwpF6MsOEOggicl4DMuMMRw1vYO3aMKcF4lvBPVvWibgLG5WNUbJjWZAQC3TPw5mkGNt63UibGaUbY9ag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;581&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来看详细代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/os/unix/ngx_process_cycle.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ngx_worker_process_init&lt;/span&gt;&lt;span&gt;(&lt;span&gt;ngx_cycle_t&lt;/span&gt; *cycle, &lt;span&gt;ngx_int_t&lt;/span&gt; worker)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; ...&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//获取配置&lt;/span&gt;&lt;br/&gt; ccf = (&lt;span&gt;ngx_core_conf_t&lt;/span&gt; *) ngx_get_conf(cycle-&amp;gt;conf_ctx, ngx_core_module);&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//设置优先级&lt;/span&gt;&lt;br/&gt; setpriority(PRIO_PROCESS, &lt;span&gt;0&lt;/span&gt;, ccf-&amp;gt;priority)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//设置文件描述符限制&lt;/span&gt;&lt;br/&gt; setrlimit(RLIMIT_NOFILE, &amp;amp;rlmt)&lt;br/&gt; setrlimit(RLIMIT_CORE, &amp;amp;rlmt)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//group 和 uid 设置&lt;/span&gt;&lt;br/&gt; initgroups(ccf-&amp;gt;username, ccf-&amp;gt;group)&lt;br/&gt; setuid(ccf-&amp;gt;user)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//CPU亲和性&lt;/span&gt;&lt;br/&gt; cpu_affinity = ngx_get_cpu_affinity(worker)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (cpu_affinity) {&lt;br/&gt;  ngx_setaffinity(cpu_affinity, cycle-&amp;gt;&lt;span&gt;log&lt;/span&gt;);&lt;br/&gt; }&lt;br/&gt; ......&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//调用各个模块的init_process进行模块初始化&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; cycle-&amp;gt;modules[i]; i++) {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (cycle-&amp;gt;modules[i]-&amp;gt;init_process) {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (cycle-&amp;gt;modules[i]-&amp;gt;init_process(cycle) == NGX_ERROR) {&lt;br/&gt;    &lt;span&gt;/* fatal */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;exit&lt;/span&gt;(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们说过 ngx_event_core_module ，它的 init_process 方法是 ngx_event_process_init。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/event/ngx_event.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ngx_module_t&lt;/span&gt;  ngx_event_core_module = {&lt;br/&gt; ...&lt;br/&gt; ngx_event_process_init,                &lt;span&gt;/* init process */&lt;/span&gt;&lt;br/&gt; ...&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 ngx_event_core_module 的 ngx_event_process_init 中，我们将看到 &lt;strong&gt;Worker 进程使用 epoll_create 来创建 epoll 对象，使用epoll_ctl 来监听 listen socket 上的连接请求&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.656786271450858&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwpF6MsOEOggicl4DMuMMRw1v4ey3MArmjqfCFRnNs7KS0ZYdkLibI8ic86wxwTdzYhfPUWSsibAPqZhHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;641&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来详细看 ngx_event_process_init 的代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/event/ngx_event.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;ngx_int_t&lt;/span&gt; &lt;span&gt;ngx_event_process_init&lt;/span&gt;&lt;span&gt;(&lt;span&gt;ngx_cycle_t&lt;/span&gt; *cycle)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//调用模块的init，创建 epoll 对象&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; (m = &lt;span&gt;0&lt;/span&gt;; cycle-&amp;gt;modules[m]; m++) {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (cycle-&amp;gt;modules[m]-&amp;gt;type != NGX_EVENT_MODULE) {&lt;br/&gt;   &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  ...&lt;br/&gt;  &lt;span&gt;module&lt;/span&gt;-&amp;gt;actions.init(cycle, ngx_timer_resolution)&lt;br/&gt;  &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt; }&lt;br/&gt; ...&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//获取自己监听的sokcet，将它们都添加到 epoll 中&lt;/span&gt;&lt;br/&gt; &lt;span&gt;ngx_event_t&lt;/span&gt;         *rev&lt;br/&gt; ls = cycle-&amp;gt;listening.elts;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; cycle-&amp;gt;listening.nelts; i++) {&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;//获取一个 ngx_connection_t&lt;/span&gt;&lt;br/&gt;  c = ngx_get_connection(ls[i].fd, cycle-&amp;gt;&lt;span&gt;log&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;//设置回调函数为 ngx_event_accept&lt;/span&gt;&lt;br/&gt;  rev-&amp;gt;handler = ngx_event_accept &lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (ngx_add_event(rev, NGX_READ_EVENT, &lt;span&gt;0&lt;/span&gt;) == NGX_ERROR) {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; NGX_ERROR;&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 ngx_add_event 注册的 READ 事件的处理函数。ngx_add_event 就是一个抽象，对于 epoll 来说就是对 epoll_ctl 的封装而已。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/event/ngx_event.h&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; ngx_add_event        ngx_event_actions.add&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//file: src/event/modules/ngx_epoll_module.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;ngx_int_t&lt;/span&gt; &lt;span&gt;ngx_epoll_add_event&lt;/span&gt;&lt;span&gt;(...)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (epoll_ctl(ep, op, c-&amp;gt;fd, &amp;amp;ee) == &lt;span&gt;-1&lt;/span&gt;) {&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TODO: epoll_create 还没解决呢。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 进入 epollwait&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 ngx_worker_process_init 中， epoll_create 和 epoll_ctl 都已经完成了。接下来就是进入事件循环，执行 epoll_wait 来处理。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3291731669266771&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwpF6MsOEOggicl4DMuMMRw1vMiatpS4eVRqnaxyibpowTaVjFbMFoZTHVq77gaeWF9O8Fb7oR6ygY67w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;641&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/event/ngx_event.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ngx_process_events_and_timers&lt;/span&gt;&lt;span&gt;(&lt;span&gt;ngx_cycle_t&lt;/span&gt; *cycle)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; ...&lt;br/&gt; &lt;span&gt;// 防accept惊群锁&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (ngx_use_accept_mutex) {&lt;br/&gt;  &lt;span&gt;//尝试获取锁，获取失败直接返回&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (ngx_trylock_accept_mutex(cycle) == NGX_ERROR) {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;//获取锁成功，则设置 NGX_POST_EVENTS 标记。&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (ngx_accept_mutex_held) {&lt;br/&gt;   flags |= NGX_POST_EVENTS;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;   ...&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//处理各种事件&lt;/span&gt;&lt;br/&gt; (&lt;span&gt;void&lt;/span&gt;) ngx_process_events(cycle, timer, flags);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 ngx_process_events_and_timers 开头处，判断是否使用 accpet_mutext 锁。这是一个防止惊群的解决办法。如果使用的话，先调用 ngx_trylock_accept_mutex 获取锁，获取失败则直接返回，过段时间再来尝试。获取成功是则设置 NGX_POST_EVENTS 的标志位。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来调用 ngx_process_events 来处理各种网络和 timer 事件。对于 epoll 来说，这个函数就是对 epoll_wait 的封装。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/event/ngx_event.h&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; ngx_process_events   ngx_event_actions.process_events&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/event/modules/ngx_epoll_module.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;ngx_int_t&lt;/span&gt; &lt;span&gt;ngx_epoll_process_events&lt;/span&gt;&lt;span&gt;(&lt;span&gt;ngx_cycle_t&lt;/span&gt; *cycle, ...)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; events = epoll_wait(ep, event_list, (&lt;span&gt;int&lt;/span&gt;) nevents, timer);&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; (i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; events; i++) {&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (flags &amp;amp; NGX_POST_EVENTS) {&lt;br/&gt;   ...&lt;br/&gt;   ngx_post_event(rev, &lt;span&gt;queue&lt;/span&gt;);&lt;br/&gt;  }&lt;span&gt;else&lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;//调用回调函数&lt;/span&gt;&lt;br/&gt;   rev-&amp;gt;handler(rev);&lt;br/&gt;  }&lt;br/&gt;  ...&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可见，在 ngx_epoll_process_events 是调用 epoll_wait 等待各种事件的发生。如果没有 NGX_POST_EVENTS 标志，则直接回调 rev-&amp;gt;handler 进行处理。使用了 accept_mutex 锁的话，先把这个事件保存起来，等后面合适的时机再去 accpet。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单对本节内容汇总一下。在 Master 进程中只是做了 socket 的 bind 和 listen。 而在 Worker 进程中所做的事情比较多，创建了 epoll，使用 epoll_ctl 将 listen 状态的 socket 的事件监控起来。最后调用 epoll_wait 进入了事件循环，开始处理各种网络和 timer 事件。 本节流程总结如图。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8330733229329174&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwpF6MsOEOggicl4DMuMMRw1vsNrcmGsploLdSTpymwibaepmtxib9YXAhJ2b9LU9ufKJcSChDQJBIRDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;641&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、用户连接来啦！&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在假设用户的连接请求已经到了，这时候 epoll_wait 返回后会执行其对应的 handler 函数 ngx_add_event。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6833073322932918&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwpF6MsOEOggicl4DMuMMRw1vqcrsf1IZSzxebBicic5L3FdvDibmsy17Gu3C0bscgoCCpl8DicPWV8iaOibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;641&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在该回调函数中被执行到的时候，表示 listen 状态的 socket 上面有连接到了。所以这个函数主要做了三件事。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;1.调用 accept 获取用户连接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2.获取 connection 对象，其回调函数为 ngx_http_init_connection&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3.将新连接 socket 通过 epoll_ctl 添加到 epoll 中进行管理&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看 ngx_event_accept 详细代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/event/ngx_event_accept.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;ngx_event_accept&lt;/span&gt;&lt;span&gt;(&lt;span&gt;ngx_event_t&lt;/span&gt; *ev)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;do&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;//接收建立好的连接&lt;/span&gt;&lt;br/&gt;  s = accept(lc-&amp;gt;fd, &amp;amp;sa.sockaddr, &amp;amp;socklen);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; s {&lt;br/&gt;   &lt;span&gt;//3.1 获取 connection&lt;/span&gt;&lt;br/&gt;   c = ngx_get_connection(s, ev-&amp;gt;&lt;span&gt;log&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;//3.2 添加新连接&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (ngx_add_conn(c) == NGX_ERROR) {&lt;br/&gt;    ngx_close_accepted_connection(c);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;   }&lt;br/&gt;  } &lt;br/&gt; } &lt;span&gt;while&lt;/span&gt; (ev-&amp;gt;available);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;listen socket 上的读事件发生的时候，就意味着有用户连接就绪了。所以可以直接通过 accept 将其取出来。取出连接以后，再获取一个空闲的 connection对象，通过 ngx_add_conn 将其添加到 epoll 中进行管理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 获取 connection&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们说一下 ngx_get_connection，这个函数本身倒是没有啥可说的。就是从 ngx_cycle 的 free_connections 中获取一个 connection 出来。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/core/ngx_connection.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;ngx_connection_t&lt;/span&gt; *&lt;span&gt;ngx_get_connection&lt;/span&gt;&lt;span&gt;(&lt;span&gt;ngx_socket_t&lt;/span&gt; s, &lt;span&gt;ngx_log_t&lt;/span&gt; *&lt;span&gt;log&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; c = ngx_cycle-&amp;gt;free_connections;&lt;br/&gt; c-&amp;gt;read = rev;&lt;br/&gt; c-&amp;gt;write = wev;&lt;br/&gt; c-&amp;gt;fd = s;&lt;br/&gt; c-&amp;gt;&lt;span&gt;log&lt;/span&gt; = &lt;span&gt;log&lt;/span&gt;;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; c&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得说的是 free_connections 中的连接，对于 HTTP 服务来说，会经过 ngx_http_init_connection 的初始化处理。它会设置该连接读写事件的回调函数 c-&amp;gt;read-&amp;gt;handler 和 c-&amp;gt;write-&amp;gt;handler。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/http/ngx_http_request.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;ngx_http_init_connection&lt;/span&gt;&lt;span&gt;(&lt;span&gt;ngx_connection_t&lt;/span&gt; *c)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; ...&lt;br/&gt; rev = c-&amp;gt;read;&lt;br/&gt; rev-&amp;gt;handler = ngx_http_wait_request_handler;&lt;br/&gt; c-&amp;gt;write-&amp;gt;handler = ngx_http_empty_handler;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 添加新连接&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看 ngx_add_conn，对于 epoll module 来说，它就是 ngx_epoll_add_connection 这个函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//file: src/event/ngx_event.h&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;define&lt;/span&gt; ngx_add_conn         ngx_event_actions.add_conn&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//file: src/event/modules/ngx_epoll_module.c&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;ngx_int_t&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ngx_epoll_add_connection&lt;/span&gt;&lt;span&gt;(&lt;span&gt;ngx_connection_t&lt;/span&gt; *c)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;epoll_event&lt;/span&gt;  &lt;span&gt;ee&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt; ee.events = EPOLLIN|EPOLLOUT|EPOLLET|EPOLLRDHUP;&lt;br/&gt; ee.data.ptr = (&lt;span&gt;void&lt;/span&gt; *) ((&lt;span&gt;uintptr_t&lt;/span&gt;) c | c-&amp;gt;read-&amp;gt;instance);&lt;br/&gt;&lt;br/&gt; epoll_ctl(ep, EPOLL_CTL_ADD, c-&amp;gt;fd, &amp;amp;ee)&lt;br/&gt; c-&amp;gt;read-&amp;gt;active = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt; c-&amp;gt;write-&amp;gt;active = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; NGX_OK;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可见这只是 epoll_ctl 的一个封装而已。这里再补充说一下，如果这个客户端连接 socket 上有数据到达的时候，就会进入到上面 3.1 节中注册的 ngx_http_wait_request_handler 函数进行处理。后面就是 HTTP 的处理逻辑了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nginx 的 Master 中做的网络相关动作不多，仅仅只是创建了 socket、然后 bind 并 listen 了一下。接着就是用自己 fork 出来多个 Worker 进程来。由于每个进程都一样，所以每个 Worker 都有 Master 创建出来的 listen 状态的 socket 句柄。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.691609977324263&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwpF6MsOEOggicl4DMuMMRw1vfhDIdpqjP9KBEfwZia0UAeVwfDtTuhq9BIGAZGcQF6ScBcz6by6mpNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;441&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Worker 进程处理的网络相关工作就比较多了。epoll_create、epoll_ctl、epoll_wait 都是在 Worker 进程中执行的，也包括用户连接上的数据 read、处理 和 write。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.1294851794071763&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwpF6MsOEOggicl4DMuMMRw1vibFInkptT6CL6ibokJPRL5dEq46NibfoXLLTJgd4saUofpPKJZIRSaCPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;641&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;1.先是使用 epoll_create 创建一个 epoll 对象出来&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2.设置回调为 ngx_event_accept&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3.通过 epoll_ctl 将所有 listen 状态的 socket 的事件都管理起来&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;4.执行 epoll_wait 等待 listen socket 上的连接到来&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;5.新连接到来是 epoll_wait 返回，进入 ngx_event_accept 回调&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;6.ngx_event_accept 回调中将新连接也添加到 epoll 中进行管理（其回调为ngx_http_init_connection）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;7.继续进入 epoll_wait 等待事件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;8.用户数据请求到达时进入 http 回调函数进行处理&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;讲到这里，你可以觉得咱们已经讨论完了。实际上有一个点我们还没有考虑到。我们上面讨论的流程是一个 Worker 在工作的情况。那么在多 Worker 的情况下，Nginx 的全貌咱们还没展开说过。通过上文我们可以看到以下几个细节：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;1.每个 Worker 都会有一个属于自己的 epoll 对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2.每个 Worker 会关注所有的 listen 状态上的新连接事件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;3.对于用户连接，只有一个 Worker 会处理，其它 Worker 不会持有该用户连接的 socket。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据这三条结论，我们再画一个 Nginx 的全貌图。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8193916349809885&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwpF6MsOEOggicl4DMuMMRw1vUWdsibiaGzNnvaPR4w8nCro9hmibB9s7l4xMkQHH5aTiaM4FpYSzC9vU7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;526&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，今天关于 Nginx 网络原理的分享就到此结束。希望通过这个优秀的软件能给你的工作带去一些启发和思考，助力你的工作提升。能阅读到这里的同学们都是好样的，晚餐回去都给自己加个鸡腿！&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>