<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>a4dda03ac7a288445e2708404fe7ab68</guid>
<title>MySQL 索引知识点总结</title>
<link>https://toutiao.io/k/u9plzvk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：fanili，腾讯 WXG 后台开发工程师&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;知其然知其所以然！本文介绍索引的数据结构、查找算法、常见的索引概念和索引失效场景。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是索引？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。（百度百科）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;索引的目的是提高查找效率，对数据表的值集合进行了排序，并按照一定数据结构进行了存储。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文将从一个案例开始，从索引的数据结构、分类、关键概念及如何使用索引提高查找效率等方面对索引知识进行总结。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;从一个案例开始&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;现象&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务中有个既存的历史 SQL 语句在运行时会导致 DB 服务器过载，进而导致相关服务阻塞无法及时完成。CPU 监控曲线如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5283198476915755&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPx9FqYNKfgUian0EKdca922a8cuU9ias8ArtftZibX3mWQU522F3eaCr2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2101&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5264916467780429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPOVPLf0eWZkV4LFvwKNf8yw0H5z5E5PSCm4oIZPtFy2ut6JXRw7tVeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2095&quot;/&gt;&lt;figcaption&gt;图1-优化前的CPU使用率&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 DB 的 CPU 使用率曲线可以看到业务运行一直处于“亚健康”状态（1），随着业务的增长随时都可能出现问题。这种问题（2）在 11 月 11 日凌晨出现，当时 DB CPU 一直处于 100%高负荷状态，且存在大量的慢查询语句。最终以杀死进程降低 DB 负载、减少业务进程（3）的方式恢复业务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 11 月 11 日下午，对该业务的 SQL 语句进行了优化，优化的效果如下。业务运行时的 CPU 使用率峰值有很大的降低（对比图 2 的 1，2，3 可见）；慢查询语句几乎在监控曲线上也无法明显观察到（对比图 3 的 1，2，3 可见）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5211803902903379&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPHic5bC1371koNCsDUTibdjDGQCYRqPYoXCp9bIbI5ZDkYqTRL2P6WIuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2101&quot;/&gt;&lt;figcaption&gt;图2-优化前后的CPU使用率&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5304761904761904&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPNm3BUIjzbIHHdDOYTh4zn8g5ANnghchS3ZN2aITCLfyicknBaCjw5Cw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2100&quot;/&gt;&lt;figcaption&gt;图3-优化前后的慢查询数量&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分析&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;表结构&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CREATE TABLE T_Mch******Stat (`FStatDate` int unsigned NOT NULL DEFAULT 19700101 COMMENT &#x27;统计日期&#x27;,&lt;br/&gt;`FMerchantId` bigint unsigned NOT NULL DEFAULT 0 COMMENT &#x27;商户ID&#x27;,&lt;br/&gt;`FVersion` int unsigned NOT NULL DEFAULT 0 COMMENT &#x27;数据版本号&#x27;,&lt;br/&gt;`FBatch` bigint unsigned NOT NULL DEFAULT 0 COMMENT &#x27;统计批次&#x27;,&lt;br/&gt;`FTradeAmount` bigint NOT NULL DEFAULT 0 COMMENT &#x27;交易金额&#x27;&lt;br/&gt;PRIMARY KEY (`FStatDate`,`FMerchantId`,`FVersion`),&lt;br/&gt;INDEX i_FStatDate_FVersion (`FStatDate`,`FVersion`))&lt;br/&gt;DEFAULT CHARSET = utf8 ENGINE = InnoDB;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从建表语句可以知道该表有两个索引：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;主键索引，是一个组合索引，由字段 FStateDate、FMerchantId 和 FVersion 组成；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;普通索引，是一个组合索引，由字段 FStateDate 和 FVersion 组成；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优化前的 SQL 语句（做了部分裁剪）A：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SELECT SQL_CALC_FOUND_ROWS FStatDate,&lt;br/&gt;    FMerchantId,&lt;br/&gt;    FVersion,&lt;br/&gt;    FBatch,&lt;br/&gt;    FTradeAmount,&lt;br/&gt;    FTradeCount&lt;br/&gt;FROM T_Mch******Stat_1020&lt;br/&gt;WHERE FStatDate = 20201020&lt;br/&gt;    AND FVersion = 0&lt;br/&gt;    AND FMerchantId &amp;gt; 0&lt;br/&gt;ORDER BY FMerchantId ASC LIMIT 0, 8000&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对该 SQL 进行 explain 得到如下结果，Extra 字段的值为 using where，说明并没有使用到索引。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.09743346007604563&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPDrh6Q41sqn3Uyp72wmoQpicufoUGbXdyN27uMd8icR2Mfz0L7eJpJGsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2104&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优化后的 SQL 语句（做了部分裁剪）B：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SELECT SQL_CALC_FOUND_ROWS a1.FStatDate,&lt;br/&gt;    a1.FMerchantId,&lt;br/&gt;    a1.FVersion,&lt;br/&gt;    FBatch,&lt;br/&gt;    FTradeAmount,&lt;br/&gt;    FTradeCount&lt;br/&gt;FROM T_Mch******Stat_1020 a1, (&lt;br/&gt;    SELECT FStatDate, FMerchantId, FVersion&lt;br/&gt;    FROM T_Mch******Stat_1020&lt;br/&gt;    WHERE FStatDate = 20201020&lt;br/&gt;        AND FVersion = 0&lt;br/&gt;        AND FMerchantId &amp;gt; 0&lt;br/&gt;        ORDER BY FMerchantId ASC LIMIT 0, 8000 ) a2&lt;br/&gt;where a1.FStatDate = a2.FStatDate&lt;br/&gt;    and a1.FVersion = a2.FVersion&lt;br/&gt;    and a1.FMerchantId = a2.FMerchantId;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优化关键步骤为：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该 SQL 的 explain 结果如下，子查询语句使用了索引，而最终在线上运行结果也证明了优化效果显著。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.09843081312410841&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPMuLIYHXQtTWbDiaM0eZIwHWliaqdaicM6ZJOsgLoeLzqqh5lxcGNqXnXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2103&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;疑问&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优化后的 SQL 语句 B 比原来的 SQL 语句 A 复杂的多（子查询，临时表关联等），怎么效率会提升，违反直觉？有三个疑问：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;SQL 语句 A 的查询条件字段都在主键中，主键索引用到了没？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SQL 语句 B 的子查询为什么能够用到索引？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;前后两条语句执行流程的差异是什么？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;索引的数据结构&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 MySQL 中，索引是在存储引擎层实现的，而不同的存储引擎根据其业务场景特点会有不同的实现方式。这里会先介绍我们常见的有序数组、Hash 和搜索树，最后看下 Innodb 的引擎支持的 B+树。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;有序数组&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数组是在任何一本数据结构和算法的书籍都会介绍到的一种重要的数据结构。有序数组如其字面意思，以 Key 的递增顺序保存数据在数组中。非常适合等值查询和范围查询。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;ID：1&lt;/th&gt;&lt;th&gt;ID：2&lt;/th&gt;&lt;th&gt;......&lt;/th&gt;&lt;th&gt;ID:N&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;name2&lt;/td&gt;&lt;td&gt;name2&lt;/td&gt;&lt;td&gt;......&lt;/td&gt;&lt;td&gt;nameN&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 ID 值没有重复的情况下，上述数组按照 ID 的递增顺序进行保存。这个时候如果需要查询特定 ID 值的 name，用二分法就可以快速得到，时间复杂度是 O(logn)。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// 二分查找递归实现方式&lt;br/&gt;int binary_search(const int arr[], int start, int end, int key)&lt;br/&gt;{&lt;br/&gt;    if (start &amp;gt; end)&lt;br/&gt;        return -1;&lt;br/&gt;&lt;br/&gt;    int mid = start + (end - start) / 2;&lt;br/&gt;    if (arr[mid] &amp;gt; key)&lt;br/&gt;        return binary_search(arr, start, mid - 1, key);&lt;br/&gt;    else if (arr[mid] &amp;lt; key)&lt;br/&gt;        return binary_search(arr, mid + 1, end, key);&lt;br/&gt;    else&lt;br/&gt;        return mid;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有序数组的优点很明显，同样其缺点也很明显。其只适合静态数据，如遇到有数据新增插入，则就会需要数据移动（新申请空间、拷贝数据和释放空间等动作），这将非常消耗资源。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Hash&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哈希表是一种以键-值（K-V）存储数据的结构，我们只需要输入键 K，就可以找到对应的值 V。哈希的思路是用特定的哈希函数将 K 换算到数组中的位置，然后将值 V 放到数组的这个位置。如果遇到不同的 K 计算出相同的位置，则在这个位置拉出一个链表依次存放。哈希表适用于等值查询的场景，对应范围查询则无能为力。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7466784765279008&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPPLxr8Fkb6Mbc3yJLw1neFbMQVHpKZNAoMucm4u703Dz6PbWt0LTJyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1129&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二叉搜索树&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二叉搜索树，也称为二叉查找树、有序二叉树或排序二叉树，是指一颗空树或者具有以下性质的二叉树：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若任意节点的右子树不空，则右子树上所有节点的值均大于或等于它的根节点的值；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;任意节点的左、右子树也分别为二叉查找树；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8590065228299046&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPCK7gEZLIYPP0WERxwQxD8RPLCCDVQa7QcRLATnYGSp2Wv3Rt7icapAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1993&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二叉搜索树相比于其它数据结构的优势在于查找、插入的时间复杂度较低，为 O(logn)。为了维持 O(logn)的查询复杂度，需要保持这棵树是平衡二叉树。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二叉搜索树的查找算法：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;若 b 是空树，则搜索失败，否则：&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若 x 等于 b 的根节点的值，则查找成功；否则：&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;若 x 小于 b 的根节点的值，则搜索左子树；否则：&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;查找右子树。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对于有序数组和 Hash，二叉搜索树在查找和插入两端的表现都非常不错。后续基于此不断的优化，发展出 N 叉树等。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;B+树&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Innodb 存储引擎支持 B+树索引、全文索引和哈希索引。其中 Innodb 存储引擎支持的哈希索引是自适应的，Innodb 存储引擎会根据表的使用情况自动为表生成哈希索引，不能人为干预。B+树索引是关系型数据库中最常见的一种索引，也将是本文的主角。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据结构&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前文简单介绍了有序数组和二叉搜索树，对二分查找法和二叉树有了基本了解。B+树的定义相对复杂，在理解索引工作机制上无须深入、只需理解数据组织形式和查找算法即可。我们可以简单的认为 B+树是一种 N 叉树和有序数组的结合体。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.45925925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPiaxh0FtmHQ9BVq5u3CYjxlkctLzd1ScbSOmhgTIZR0eTHaf31xaPSxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2025&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;B+树的 3 个优点:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;层级更低，IO 次数更少&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每次都需要查询到叶子节点，查询性能稳定&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;叶子节点形成有序链表，范围查询方便&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;操作算法&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由根节点自顶向下遍历树，根据分离值在要查找的一边的指针；在节点内使用二分查找来确定位置。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.49950787401574803&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPQs78KkYUNJ4NDd7iaSiah1hA608wo0xVAxF9bQeQceG7CU1CCZE7r0RQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2032&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3295&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPrGQXVXEeTlYPsazcx7GQhgwzdWlPibO0YbuZ7aaN0rQHkht2gHjxk5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注：插入和删除两个表格内容来自《MySQL 技术内幕-InnoDB 存储引擎》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;填充因子（innodb_fill_factor）：索引构建期间填充的每个 B-tree 页面上的空间百分比，其余空间保留给未来索引增长。从插入和删除操作中可以看到填充因子的值会影响到数据页的 split 和 merge 的频率。将值设置小些，可以减少 split 和 merge 的频率，但是索引相对会占用更多的磁盘空间；反之，则会增加 split 和 merge 的频率，但是可以减少占用磁盘空间。Innodb 对于聚集索引默认会预留 1/16 的空间保证后续的插入和升级索引。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Innodb B+树索引&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前文介绍了索引的基本数据结构，现在开始我们从 Innodb 的角度了解如何使用 B+树构建索引，索引如何工作和如何使用索引提升查找效率。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;聚集索引和非聚集索引&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库中的 B+树索引可以分为聚集索引和非聚集索引。聚集索引和非聚集索引的不同点在于叶子节点是否是完整行数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Innodb 存储引擎表是索引组织表，即表中的数据按照主键顺序存放。聚集索引就是按照每张表的主键构造一棵 B+树，叶子节点存放的是表的完整行记录。非聚集索引的叶子节点不包含行记录的全部数据。Innodb 存储引擎的非聚集索引的叶子节点的内容为主键索引值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若数据表没有主键聚集索引是怎么建立的？在没有主键时 Innodb 会给数据表的每条记录生成一个 6 个字节长度的 RowId 字段，会以此建立聚集索引。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Select 语句查找记录的过程&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面例子将展示索引数据的组织形式及 Select 语句查询数据的过程。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;create table T (&lt;br/&gt;    ID int primary key,&lt;br/&gt;    k int NOT NULL DEFAULT 0,&lt;br/&gt;    s varchar(16) NOT NULL DEFAULT &#x27;&#x27;,&lt;br/&gt;    index k(k)&lt;br/&gt;) engine=InnoDB DEFAULT CHARSET=utf8;&lt;br/&gt;&lt;br/&gt;insert into T values(100, 1, &#x27;aa&#x27;),(200, 2, &#x27;bb&#x27;),(300, 3, &#x27;cc&#x27;),(500, 5, &#x27;ee&#x27;),(600,6,&#x27;ff&#x27;),(700,7,&#x27;gg&#x27;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.338&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPYf9WdmGmOicIjvtCFockO9KoRzan18nSqeeUTyqY73Sx4OkzPlKxUCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;左边是以主键 ID 建立起的聚集索引，其叶子节点存储了完整的表记录信息；右边是以普通字段 K 建立的普通索引，其叶子节点的值是主键 ID。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;select * from T where k between 3 and 5;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行流程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在 K 索引树上找到 k=3 的记录，取得 ID=300；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再到 ID 索引树上查找 ID=300 对应的 R3；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 k 索引树取下一个值 k=5，取得 ID=500；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再回到 ID 索引树查到 ID=500 对应的 R4；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 k 索引树取下一个值 k=6，不满足条件，循环结束。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述查找记录的过程中引入了一个重要的概念：&lt;strong&gt;回表&lt;/strong&gt;，即回到主键索引树搜索的过程。避免回表操作是提升 SQL 查询效率的常规思路及重要方法。那么如何避免回表？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注：该例子来自《MySQL 实战 45 讲》&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;覆盖索引&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL 5.7,建表语句：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CREATE TABLE `employees` (&lt;br/&gt;  `emp_no` int(11) NOT NULL,&lt;br/&gt;  `birth_date` date NOT NULL,&lt;br/&gt;  `first_name` varchar(14) NOT NULL,&lt;br/&gt;  `last_name` varchar(16) NOT NULL,&lt;br/&gt;  `gender` enum(&#x27;M&#x27;,&#x27;F&#x27;) NOT NULL,&lt;br/&gt;  `hire_date` date NOT NULL,&lt;br/&gt;  PRIMARY KEY (`emp_no`),&lt;br/&gt;  KEY `i_first_name` (`first_name`),&lt;br/&gt;  KEY `i_hire_date` (`hire_date`)&lt;br/&gt;) ENGINE=InnoDB DEFAULT CHARSET=utf8;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;explain select * from employees where hire_date &amp;gt; &#x27;1990-01-14&#x27;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;explain 结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.16375436844732902&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPZ0aRsD4HlMOrsW1BLvDEn5OvAMKaRaWRjvTbYqVVPhjd0uf98Th8Cg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2003&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;explain select emp_no from employees where hire_date &amp;gt; &#x27;1990-01-14&#x27;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;explain 结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.14028956565152273&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPTicg7bRKicpZRawTUTWZN2w61xf0xS7NxjgxdyOYO09icKGPKm0oCmWkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2003&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从前后两次 explain 的结果可以看到 SQL 语句 A 的 extra 为 using where，SQL 语句 B 的 extra 为 using where;using index。这说明 A 没有使用索引，而 B 使用了索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;索引 K 中包含了查询语句所需要的字段 ID 的值，无需再次回到主键索引树查找，也就是“覆盖”了我们的查询需求，我们称之为覆盖索引。覆盖索引可以减少树的搜索次数，显著提升查询性能。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最左匹配&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;explain select * from employees where hire_date &amp;gt; &#x27;1990-01-14&#x27; and first_name like &#x27;%Hi%&#x27;;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.15604616156547918&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPhlzGHu2XEL4kUPHRcvBSx3wBZvw2YxRAyyud8NDSAFQeI7AEicxicvgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1993&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;explain select * from employees where hire_date &amp;gt; &#x27;1990-01-14&#x27; and first_name like &#x27;Hi%&#x27;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.12131802296555168&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPO2QUQ0q2WfeJ8sA9OuxZWFKGmx8DJxbSqEtZoQfQ5c0rOsvgdLJBNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2003&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上述测试的 SQL 语句 A 使用了极端方式: first_name like &#x27;%Hi%&#x27;，前后都增加模糊匹配使得 SQL 语句无法使用到索引；当去掉最左边的‘%’后，SQL 语句 B 就使用了索引。最左匹配可以是字符串索引的最左 N 个字符，也可以是联合索引的最左 M 的字段。合理规划、使用最左匹配可以减少索引，从而节约磁盘空间。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;索引下推&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;何为索引下推？我们先从下面这组对比测试开始，将在 MySQL5.5 版本和 MySQL5.7 版本中执行同一条 SQL 语句：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;select * from employees where hire_date &amp;gt; &#x27;1990-01-14&#x27; and first_name like &#x27;Hi%&#x27;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在 MySQL 5.5 执行 explain，extra 字段的值显示没有使用索引&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.18344965104685942&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPJJW14E31oD7fx7DA5X6Ag9QEaRamfBeXgASEm6lEsAJzQkuordWugQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2006&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行查询花费时间为 0.12s&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2329608938547486&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPDvKXWDzSU0F4cyaAK88U7wIh3T8iaml8MxsiaN3hF84NGlcwlfJ13jRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1790&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在 MySQL 5.7 执行 explain，extra 字段的值显示使用了索引下推&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.11755725190839694&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocP1nic7EpkhniaBhNAptcO26AEeSgricR14uobugV5y3Y10Zcfga0Eflfug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1965&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行查询花费时间为 0.02s&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23992784125075164&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPHYyOFz7qhQiaMcCReP5ibDOPS9CKsIaDbvLYQqPexIFpaKHF303OPicuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1663&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;explain 结果中的 extra 字段值包含 using index condition，则说明使用了索引下推。索引下推功能是从 5.6 版本开始支持的。在 5.6 版本之前，i_first_name 索引是没有使用上的，需要每次去主键索引表取完整的记录值进行比较。从 5.6 版本开始，由于索引 i_first_name 的存在，可以直接取索引的 first_name 值进行过滤，这样不符合&quot;first_name like &#x27;Hi%&#x27;&quot;条件的记录就不再需要回表操作。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;MRR 优化&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL 5.6 版本开始支持 Multi-Range Read(MRR)优化，MRR 优化的目的是为减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问，对于 IO-bound 类型的 SQL 查询语句可带来性能极大提升。我们先看下对比测试，以下测试语句在同一个 MySQL 实例下执行，执行前均进行 mysql 服务重启，以保证缓存此没被预热。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SET @@optimizer_switch=&#x27;mrr=off&#x27;;&lt;br/&gt;select * from employees where hire_date &amp;gt; &#x27;1990-01-14&#x27; and first_name like &#x27;Hi%&#x27;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行耗时未 0.90s&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.20550964187327825&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPpewplicIIxskx2AOdVvbia4ywqWtGroleJPj045jnMNls1KSw4Njv9rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1815&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; SET @@optimizer_switch=&#x27;mrr=on,mrr_cost_based=off&#x27;;&lt;br/&gt; select * from employees where hire_date &amp;gt; &#x27;1990-01-14&#x27; and first_name like &#x27;Hi%&#x27;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2332719459791283&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPULyqCnzZ5Uj8Q6okQxqSy2icWicYwROPll4Guiaw1Uf08galHdxS1ic0pQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1629&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从测试结果可以发现在 mrr 从关闭到开启，耗时从 0.90s 减少到 0.03s，查询速率达到 30 倍的提升。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;常见的索引失效场景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 MySQL 表中建立了索引，SQL 查询语句就会一定使用到索引么？不一定，存在着索引失效的场景。我们给 employees 表增一个组合索引，后续例子均基于此表进行分析、测试。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;alter table employees add index i_b_f_l(birth_date, first_name, last_name)&lt;br/&gt;alter table employees add index i_h(hire_date);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.18724489795918367&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPmGwsqwZClLWsZHpFCh68d5SS5icAtDdbCH5LwhWKkfUl8BOyIFcHcpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1960&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;失效场景&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;explain select * from employees where hire_date &amp;gt; &#x27;1989-06-02&#x27;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.15099135739705136&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPUsQIZgInd3W1yaXhq4IetsAkkpwvkTK6zEVyWhYgzt3sibgHa0N7icOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1967&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;alter table employees add index i_first_name (first_name);&lt;br/&gt;explain select * from employees where first_name = 1;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23748723186925433&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocP1wElsmCdAlpN61F48GoyicR5YuicLOOXTiaxnicgXdnBDzMnquwSJqb1qg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1958&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;explain select * from employees where CHAR_LENGTH(hire_date) = 10;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1550584646670056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocP9kcAt9j7H6rwSe9WjCibaWMNvFFZYI97kyIicJESbrNia5lsOFDQ5JJgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1967&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;explain select * from employees where hire_date  like  &#x27;%1995&#x27;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1296579887697805&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPRicDibbzm38zgVz28QFicTiaeBkXBwetfpM9mSW7dArUwKa3fnuPYs4zRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1959&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;explain select * from employees where last_name = &#x27;Kalloufi&#x27; and first_name = &#x27;Saniya&#x27;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.11603053435114503&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPOKaaqPKfSU9ib7czzZibEdBdZv08Q4YpBFOzt4FlnpibMFhVzrFo3QCOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1965&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么会失效？&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;顺序读比离散读性能要好&lt;/p&gt;&lt;p&gt;范围查询一定会导致索引失效么？&lt;/p&gt;&lt;p&gt;并不会！稍微更改下查询条件看下 explain 的对比结果，可以看到新语句用到索引下推，说明索引并未失效。为什么？&lt;/p&gt;&lt;p&gt;在不使用覆盖索引的情况下，优化器只有在数据量小的时候才会选择使用非聚集索引。受制于传统的机械磁盘特性，通过聚集索引顺序读数据行的性能会比通过非聚集索引离散读数据行要好。所以，优化器在即使有非聚集索引、但是访问数据量可能达到送记录数的 20%时会选择聚集索引。当然也可以用 Force index 强制使用索引。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;explain select * from employees where hire_date &amp;gt; &#x27;1999-06-02&#x27;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2774390243902439&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocP578UWmiaKvK06IJK1tkKcwdcoeUBo5icPUQ11JYepmiaJqzMNTjw10Gjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1968&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;无法使用 B+索引快速查找&lt;/p&gt;&lt;p&gt;B+树索引支持快速查询的基本要素是因为其索引键值是有序存储的，从左到右由小到大，这样就可以在每个层级的节点中快速查并进入下一层级，最终在叶子节点找到对应的值。&lt;/p&gt;&lt;p&gt;使用函数会使得 MySQL 无法使用索引进行快速查询，因为对索引字段做函数操作会破坏索引值的有序性，所以优化器选择不使用索引。而查询条件类型不一致其实也是同样的情况，因为其使用了隐式类型转换*。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;模糊匹配和不使用组合索引的首字段作为查询条件均是无法快速定位索引位置从而导致无法使用索引。模糊匹配当查询条件是 lwhere A ike &#x27;a%&#x27;，a 是 A 的最左前缀时是可能用上索引的（最左匹配），是否用上最终还是依赖优化器对查询数据量的评估。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;回到初始的案例&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们回到文章初的案例，尝试回答下当时提出的 3 个问题。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-- A语句&lt;br/&gt;SELECT FStatDate, FMerchantId, FVersion, FBatch, FTradeAmount, FTradeCount FROM T_Mch******Stat_1020 WHERE FStatDate = 20201020     AND FVersion = 0     AND FMerchantId &amp;gt; 0 ORDER BY FMerchantId ASC LIMIT 0, 8000;&lt;br/&gt;&lt;br/&gt;-- B语句&lt;br/&gt;SELECT SQL_CALC_FOUND_ROWS a1.FStatDate,&lt;br/&gt;    a1.FMerchantId,&lt;br/&gt;    a1.FVersion,&lt;br/&gt;    FBatch,&lt;br/&gt;    FTradeAmount,&lt;br/&gt;    FTradeCount&lt;br/&gt;FROM T_Mch******Stat_1020 a1, (&lt;br/&gt;    SELECT FStatDate, FMerchantId, FVersion&lt;br/&gt;    FROM T_Mch******Stat_1020&lt;br/&gt;    WHERE FStatDate = 20201020&lt;br/&gt;        AND FVersion = 0&lt;br/&gt;        AND FMerchantId &amp;gt; 0&lt;br/&gt;        ORDER BY FMerchantId ASC LIMIT 0, 8000 ) a2&lt;br/&gt;where a1.FStatDate = a2.FStatDate&lt;br/&gt;    and a1.FVersion = a2.FVersion&lt;br/&gt;    and a1.FMerchantId = a2.FMerchantId;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;SQL 语句 A 的查询条件字段都在主键中，主键索引用到了没？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主键索引其实是有被使用的：索引的范围查询，只是其需要逐条读取和解析所有记录才导致慢查询。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;SQL 语句 B 的子查询为什么能够用到索引？&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;前文中我们介绍了聚集索引，其索引键值就是主键。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;两条 SQL 语句的不同之处在于 B 语句的子查询语句的 Select 字段都包含在主键字段中，而 A 语句还有其它字段（例如 FBatch 和 FTradeAmount 等）。这种情况下只凭主键索引的键值就能满足 B 语句的字段要求；A 语句则需要逐条取整行记录进行解析。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;前后两条语句执行流程的差异是什么？&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;逐条扫描索引表并比较查询条件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;遇到符合查询条件的则读取整行数据返回&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;回到 a 步骤，直至完成所有索引记录的比较&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对返回的所有符合条件的记录（完整的记录）进行排序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;选取前 8000 条数据返回&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;逐条扫描索引表并比较查询条件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;遇到符合查询条件的则从索引键中取相关字段值返回&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;回到 a 步骤，直至完成所有索引记录的比较&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对返回的所有符合条件的记录（每条记录只有 3 个主键）进行排序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;选取前 8000 条数据返回形成临时表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关联临时表与主表，使用主键相等比较查询 8000 条数据&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对比两个 SQL 语句的执行过程，可以发现差异点集中在步骤 2 和步骤 4。在步骤 2 中 SQL 语句 A 需要随机读取整行数据并解析非常耗资源；步骤 4 涉及 MySQL 的排序算法，这里也会对执行效率有影响，排序效果上看 SQL 语句 B 比 SQL 语句 A 好。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2414844941535333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocP9DuM2vVDU4QC7oic6g8DEmdyoIRt5Dic5q5x0nGZrG5jibQvtXQkUN4sA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1967&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;名词解释&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顾名思义该类索引由表的主键组成，从左到右由小到大排序。一个 Innodb 存储表只有一张主键索引表（聚集索引）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最为平常的一种索引，没有特别限制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该索引的字段不能有相同值，但允许有空值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由多列字段组合而成的索引，往往是为了提升查询效率而设置。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在文章开始时介绍了常见的几种索引数据结构，适合静态数据的有序数组、适合 KV 结构的哈希索引及兼顾查询及插入性能的搜索二叉树；然后介绍了 Innodb 的常见索引实现方式 B+树及 Select 语句使用 B+树索引查找记录的执行过程，在这个部分我们了解了几个关键的概念，回表、覆盖索引、最左匹配、索引下推和 MMR；之后还总结了索引的失效场景及背后的原因。最后，我们回到最初的案例，分析出优化前后 SQL 语句在使用索引的差异，进而导致执行效率的差异。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文介绍了索引的一些粗浅知识，希望能够对读者有些许帮助。作为阶段性学习的一个总结，文章对 MySQL 索引的相关知识基本上是浅藏辄止，日后还需多多使用和深入学习。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;何以解忧？唯有学习。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9896073903002309&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasiakO80E7oJ3OgPxsdzDocPInAl2qnb42D66xPMLVVme7mI6P33KAHJyaXCo63Qx0U6yy7ianQ6UBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1732&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考书目和资料&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.729264475743349&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvatricjRxhpM1x45aB6doaVg7WMhINPwOiaqpskia1kH7hgibO0dicW2HLcW8HRGMzESQwehIcyckLXtwsA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;639&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0331f4b89b79436aacd95af39c83d539</guid>
<title>常见算法模版总结（二）</title>
<link>https://toutiao.io/k/s66geea</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5620967741935484&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/f93EtXu3Zk9f5UI0RNeuS7C4kYVcmSc6qrDla8cHxSc4KRxkS9INqd4Dzq500wFcnnLgSx1y7yOMicYsH9SLf4A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1240&quot; title=&quot;怪化猫&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;怪化猫&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;本次233酱介绍下单调栈、单调队列、并查集、KMP算法，欢迎交流指正～&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;单调栈&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;「单调栈」&lt;/strong&gt;首先是一种基于栈的数据结构，只不过通过栈来维护的是单调递增或单调递减的数据。入栈和出栈都是操作栈顶。对于每一个元素都只有一次入栈和出栈的操作，因此时间复杂度为O(N)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;递增栈（递减栈）是通过出栈的顺序是递增还是递减来定义。从&lt;strong&gt;栈顶到栈底是递增&lt;/strong&gt;，则为&lt;strong&gt;单调递增栈&lt;/strong&gt;；从&lt;strong&gt;栈顶到栈底是递减&lt;/strong&gt;，则为&lt;strong&gt;单调递减栈&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设我们把数组[7,8,3,4,1] 中的每个元素构建成一个二元组&lt;/span&gt;&lt;index&gt;&lt;span&gt;（其中index为元素下标，value为元素的值）,然后随着二元组index的增加，构建一个单调递增栈stack，则stack的动态变化图如下：&lt;/span&gt;&lt;/index&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5629032258064516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/f93EtXu3Zk9f5UI0RNeuS7C4kYVcmSc65ZUYMg5BE9K2FFYPicicDicP8guic5tZEXLtg4dTAwRmakeg5OfhpoDiaPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;单调递增栈&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;单调递增栈&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;我们可以看到单调递增栈其实动态维护的是基于当前栈顶的一段单调递增区间。&lt;br/&gt;那我们便可以利用栈中维护的这段单调性元素获得下一个插入元素和栈中元素的关系。如：&lt;strong&gt;找到从左/右遍历第一个比它大/小的元素&lt;/strong&gt;。&lt;br/&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;单调栈Java模版&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;        Stack&amp;lt;Integer&amp;gt; &lt;span&gt;stack&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; arr.length; i++) {&lt;br/&gt;            &lt;span&gt;//check函数：和栈的单调性定义有关&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;//先弹出来不符合当前遍历元素单调性的元素&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;stack&lt;/span&gt;.empty() &amp;amp;&amp;amp; check(&lt;span&gt;stack&lt;/span&gt;.peek(),arr[i])) &lt;span&gt;stack&lt;/span&gt;.pop();&lt;br/&gt;            &lt;span&gt;//把当前遍历元素加入栈顶&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;stack&lt;/span&gt;.push(i);&lt;br/&gt;        }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;我们来看一道典型的利用单调栈的问题&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;leetcode42：接雨水&lt;br/&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;br/&gt;给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7536496350364964&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/f93EtXu3Zk9f5UI0RNeuS7C4kYVcmSc6NlXaNhOvRFX9MiaoXJCh6Mua7gplC50OZxCWU8vlj3zoDsCE22ARzfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1096&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;题目分析&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;br/&gt;能够有雨水必须存在一个凹槽，即凹槽处左右两边均存在比它高的柱子。可以维护一个单调递增栈，满足栈顶的下一个元素（即左边元素）高于栈顶，当待压栈元素高于栈顶时，则栈顶元素出栈，计算栈顶所在凹槽面积后，并将待压栈元素压栈。否则，直接压栈。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;leetcode42&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;trap&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] height)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Stack&amp;lt;Integer&amp;gt; &lt;span&gt;stack&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; res = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; height.length; i++) {&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;stack&lt;/span&gt;.empty() &amp;amp;&amp;amp; height[i] &amp;gt; height[&lt;span&gt;stack&lt;/span&gt;.peek()]){&lt;br/&gt;                &lt;span&gt;//凹槽下标出栈&lt;/span&gt;&lt;br/&gt;                Integer top = &lt;span&gt;stack&lt;/span&gt;.pop();&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;stack&lt;/span&gt;.empty())&lt;br/&gt;                    &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;//计算凹槽的面积&lt;/span&gt;&lt;br/&gt;                Integer left = &lt;span&gt;stack&lt;/span&gt;.peek();&lt;br/&gt;                res += (Math.min(height[i],height[left]) - height[top]) * (i-left &lt;span&gt;-1&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;stack&lt;/span&gt;.push(i);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; res;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;单调队列&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;「单调队列」首先是一种双端队列，然后队列中维护的元素具有单调性。其中队首元素拥有最值。从队首到对尾是递增，则为单调递增队列；从队首到对尾是递减，则为单调递减队列。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相比维护优先级队列的时间复杂度O(NlogN)，维护单调队列的时间复杂度为O(N)。单调队列和单调栈比较类似，单调栈只操作栈顶。而单调队列元素从队首出最值，从队尾删除不满足单调性的元素，入满足单调性的当前入队元素。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设我们把数组[7,8,3,4,1] 中的每个元素构建成一个二元组&lt;/span&gt;&lt;index&gt;&lt;span&gt;（其中index为元素下标，value为元素的值）,然后随着二元组index的增加，构建一个单调递增队列queue，则queue的动态变化图如下：&lt;br/&gt;&lt;/span&gt;&lt;/index&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5629032258064516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/f93EtXu3Zk9f5UI0RNeuS7C4kYVcmSc6d73iaepJhxP6jte5e31RXicaUD6Pbic2OHkM2z8TVR83XvVdMsomrWuDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;单调队列&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;单调队列&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;单调队列Java模版&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;        Deque&amp;lt;Integer&amp;gt; &lt;span&gt;deque&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; arr.length; i++) {&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (check(&lt;span&gt;deque&lt;/span&gt;.getLast(),arr[i]))&lt;span&gt;deque&lt;/span&gt;.removeLast();&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (checkout(&lt;span&gt;deque&lt;/span&gt;.getFirst()))&lt;span&gt;deque&lt;/span&gt;.removeFirst();&lt;br/&gt;            &lt;span&gt;deque&lt;/span&gt;.addLast(i);&lt;br/&gt;        }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;我们来看一道利用单调队列求区间最值的问题。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;leetcode239&lt;br/&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;br/&gt;给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。&lt;br/&gt;返回滑动窗口中的最大值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;题目示例&lt;/strong&gt;&lt;br/&gt;输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3&lt;br/&gt;输出: [3,3,5,5,6,7] &lt;br/&gt;解释: 滑动窗口的位置最大值&lt;br/&gt;[1  3  -1] -3  5  3  6  7       3&lt;br/&gt; 1 [3  -1  -3] 5  3  6  7       3&lt;br/&gt; 1  3 [-1  -3  5] 3  6  7       5&lt;br/&gt; 1  3  -1 [-3  5  3] 6  7       5&lt;br/&gt; 1  3  -1  -3 [5  3  6] 7       6&lt;br/&gt; 1  3  -1  -3  5 [3  6  7]      7&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;题目分析&lt;/strong&gt;&lt;br/&gt;直接套用模版，从左到右遍历数组nums,维护一个单调递减队列。从队尾插入元素，当待插入元素&amp;gt;队尾元素时，队尾元素弹出，再插入待插入元素。当队列长度&amp;gt;k时，队首元素弹出。队首元素即为当前滑动窗口的最大值。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;leetcode239&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] maxSlidingWindow(&lt;span&gt;int&lt;/span&gt;[] nums, &lt;span&gt;int&lt;/span&gt; k) {&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; n = nums.length;&lt;br/&gt;&lt;span&gt;//实际的滑动窗口大小&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; realK = k % n;&lt;br/&gt;        &lt;span&gt;//滑动窗口的个数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt;[] res;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (realK == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            realK = k;&lt;br/&gt;            res = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;        }&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;            res = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[n-realK+&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;        Deque&amp;lt;Integer&amp;gt; &lt;span&gt;deque&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt; ArrayDeque&amp;lt;&amp;gt;(realK);&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; i =&lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt; ; j &amp;lt; n; j++) {&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;deque&lt;/span&gt;.isEmpty() &amp;amp;&amp;amp; (j-&lt;span&gt;deque&lt;/span&gt;.getFirst() &amp;gt;= realK)) &lt;span&gt;deque&lt;/span&gt;.removeFirst();&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;deque&lt;/span&gt;.isEmpty() &amp;amp;&amp;amp; nums[&lt;span&gt;deque&lt;/span&gt;.getLast()] &amp;lt; nums[j]) &lt;span&gt;deque&lt;/span&gt;.removeLast();&lt;br/&gt;            &lt;span&gt;deque&lt;/span&gt;.addLast(j);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (j&amp;gt;= realK &lt;span&gt;-1&lt;/span&gt;) {&lt;br/&gt;                res[i] = nums[&lt;span&gt;deque&lt;/span&gt;.getFirst()];&lt;br/&gt;                i++;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; res;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;并查集&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;并查集&lt;/strong&gt;是一种树型的数据结构，用于处理一些&lt;strong&gt;不交集&lt;/strong&gt;的 合并 及 查询 问题。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;不交集：在数学里，若两个集合没有共同的元素，称为&lt;strong&gt;不交&lt;/strong&gt;。例如{1,2,3}和{4,5,6}为&lt;strong&gt;不交集&lt;/strong&gt;（disjoint sets）。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;有一个&lt;strong&gt;联合-查找算法&lt;/strong&gt;（&lt;strong&gt;union-find algorithm&lt;/strong&gt;）定义了两个用于此数据结构的操作：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其他的重要方法，&lt;/span&gt;&lt;code&gt;&lt;span&gt;MakeSet&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，用于创建单元素集合。有了这些方法，许多经典的 &lt;strong&gt;划分问题&lt;/strong&gt; 可以被解决。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了更加精确的定义这些方法，需要定义如何表示集合。一种常用的策略是为每个集合选定一个固定的元素，称为&lt;strong&gt;祖宗&lt;/strong&gt;，以表示整个集合。接着，&lt;/span&gt;&lt;code&gt;&lt;span&gt;find(x)&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 返回&lt;/span&gt;&lt;code&gt;&lt;span&gt;x&lt;/span&gt;&lt;/code&gt;&lt;span&gt;所属集合的祖宗，而&lt;/span&gt;&lt;code&gt;&lt;span&gt;union(x,y)&lt;/span&gt;&lt;/code&gt;&lt;span&gt;使用两个集合的祖宗作为参数。&lt;br/&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;并查集Java模版&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] &lt;span&gt;makeSet&lt;/span&gt;(&lt;span&gt;&lt;span&gt;int&lt;/span&gt;[] arr&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt;[] parent = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[arr.length];&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; arr.length; i++) {&lt;br/&gt;            parent[i] = i;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; parent;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;find&lt;/span&gt;(&lt;span&gt;&lt;span&gt;int&lt;/span&gt; x&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (parent[x] == x) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; x;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; find(parent[x]);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;union&lt;/span&gt;(&lt;span&gt;&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt; y&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; rootX = find(x);&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; rootY = find(y);&lt;br/&gt;        parent[rootX] = rootY;&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;如果集合的树状结构拉成了链表，则&lt;/span&gt;&lt;code&gt;&lt;span&gt;find&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的效率较低。优化方式有：&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;find&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; x)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (parent[x] == x) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; x;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; rootX = find(parent[x]);&lt;br/&gt;        &lt;span&gt;//查找x的祖先直到找到代表,于是顺手路径压缩&lt;/span&gt;&lt;br/&gt;        parent[x] = rootX;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; rootX;&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;关于&lt;/span&gt;&lt;code&gt;&lt;span&gt;union&lt;/span&gt;&lt;/code&gt;&lt;span&gt;,优化方式有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;鉴于子节点数目与深度这两个特征都很容易维护，我们常常从中择一，作为估价函数。这里我们选择维护子节点数目。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt;[] size = makeSet(arr);&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[] &lt;span&gt;makeSet1&lt;/span&gt;(&lt;span&gt;&lt;span&gt;int&lt;/span&gt;[] arr&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt;[] size = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[arr.length];&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; arr.length; i++) {&lt;br/&gt;&lt;span&gt;//初始化子树的大小为 1&lt;/span&gt;&lt;br/&gt;            size[i] = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; size;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;union&lt;/span&gt;(&lt;span&gt;&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt; y&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; rootX = find(x);&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; rootY = find(y);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (size[rootX] &amp;lt; size[rootY]) {&lt;br/&gt;&lt;span&gt;//保证小的合并到大的里&lt;/span&gt;&lt;br/&gt;            swap(rootX,rootY);&lt;br/&gt;        }&lt;br/&gt;        parent[rootY] = rootX;&lt;br/&gt;        size[rootX] += size[rootY];&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;我们来看一道经典的并差集算法题。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;leetcode547: 朋友圈&lt;br/&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;br/&gt;班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;题目示例&lt;/strong&gt;&lt;br/&gt;输入：&lt;br/&gt;[[1,1,0],&lt;br/&gt; [1,1,0],&lt;br/&gt; [0,0,1]]&lt;br/&gt;输出：2 &lt;br/&gt;解释：已知学生 0 和学生 1 互为朋友，他们在一个朋友圈。&lt;br/&gt;第2个学生自己在一个朋友圈。所以返回 2 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;题目分析&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;学生i和学生j互为朋友，则代表i 和 j之间有一条边，则他们应该合并到一个集合里面，因为M[i][j] 和 M[j][i] 代表一对朋友关系，所以矩阵只需要遍历一半对角线即可。求朋友圈的个数就是求不相交集合的祖宗个数（即 parent[x] = x 的个数）。&lt;br/&gt;PS:我发现leetcode提交用了优化反而没有未优化的版本耗时少，那我就上传一个朴素的并差集版本吧：）&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;leetcode547&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;findCircleNum&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[][] M)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; n = M.length;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt;[] parent = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[n];&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++) {&lt;br/&gt;            parent[i] = i;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++) {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; i; j++) {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (M[i][j] &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                    &lt;span&gt;union&lt;/span&gt;(i,j,parent);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (parent[i] == i) {&lt;br/&gt;                count++;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; count;&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;find&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt;[] parent)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (parent[x] == x) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; x;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; find(parent[x],parent);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;union&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; x,&lt;span&gt;int&lt;/span&gt; y,&lt;span&gt;int&lt;/span&gt;[] parent)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; rootX = find(x,parent);&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; rootY = find(y,parent);&lt;br/&gt;        parent[rootX] = rootY;&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;span&gt;KMP算法&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;「KMP算法」是字符串查找算法，可在一个主文本字符串&lt;/span&gt;&lt;code&gt;&lt;span&gt;string&lt;/span&gt;&lt;/code&gt;&lt;span&gt;内查找一个&lt;strong&gt;词&lt;/strong&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;pattern&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的出现位置。此算法通过运用对这个词在不匹配时 本身就包含足够的信息 来确定下一个匹配 将在哪里开始的发现，从而避免重新检查先前匹配的 字符。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们先来理解下这个算法。这个算法的&lt;strong&gt;目标&lt;/strong&gt;是：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4093484419263456&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/f93EtXu3Zk9f5UI0RNeuS7C4kYVcmSc6IfA1nGWZbxj2DoCTkbNPicvW3ibvMkIdQXT4TqJAJrCia2dErBV3rY76w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;706&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5855513307984791&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/f93EtXu3Zk9f5UI0RNeuS7C4kYVcmSc60p8mL4rjSfKqqZtCiaXsGJ9VjAFX7DxLUh5xQJ17WzhkQtQZnWGT2Cw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1052&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;我们先来看一下简单的「从开始位置比」做法：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.39342806394316165&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/f93EtXu3Zk9f5UI0RNeuS7C4kYVcmSc6JAxZXWLJI0zS4WGKZszRF3nwficT536dUv5G4HgNoOpm0dp5nPyQBicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1126&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;而KMP的做法能将时间复杂度优化到O(n+m)&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4612903225806452&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/f93EtXu3Zk9f5UI0RNeuS7C4kYVcmSc6iaicrr2BiaSXAInpAN3YcjLsHXpicHUHTmyQBnMOP6d8Yd6aZE0qkjhXXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5185483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/f93EtXu3Zk9f5UI0RNeuS7C4kYVcmSc6HBJSrrz6xXENtX0DecZVmhmIZIQXyxVQq8c2Apx7Cm0WCzgYmqy30Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;那match(j)如何求呢？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5591872791519434&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/f93EtXu3Zk9f5UI0RNeuS7C4kYVcmSc65hbFaUJpd0pHPcdzlnBo8AxIic5Nqz8UWrDnIXPx5Nd2qxKiccGIUjLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1132&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;至于为什么 match[j] = match[j-1] + 1;我们可以用反证法证明一下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.47982456140350876&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/f93EtXu3Zk9f5UI0RNeuS7C4kYVcmSc6KqdyprUnDzAJtSM4Keib5pgngvtJx4mVKYI1uYd2jkhibDwDl89xmTjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1140&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;br/&gt;&lt;span&gt;好了，关于string 和 pattern 如何确定 指针s 和 p的位置 以及 如何求match(p) 我们都分析过了，上模版吧。&lt;/span&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;KMP算法Java模版&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;strStr&lt;/span&gt;&lt;span&gt;(String &lt;span&gt;string&lt;/span&gt;, String pattern)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; m = &lt;span&gt;string&lt;/span&gt;.length(),n=pattern.length();&lt;br/&gt;&lt;span&gt;//计算match(p)的值&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt;[] match = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[n];&lt;br/&gt;        match[&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt; n; i++) {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; j = match[i - &lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (j&amp;gt;=&lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; (pattern.charAt(i) != pattern.charAt(j +&lt;span&gt;1&lt;/span&gt;))){&lt;br/&gt;                j = match[j];&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (pattern.charAt(i) == pattern.charAt(j +&lt;span&gt;1&lt;/span&gt;)) {&lt;br/&gt;                match[i] = j +&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            }&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;                match[i] = &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; s = &lt;span&gt;0&lt;/span&gt;,p=&lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//字符串string 和 pattern的匹配&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (s&amp;lt;m &amp;amp;&amp;amp; p &amp;lt;n){&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;.charAt(s) == pattern.charAt(p)) {&lt;br/&gt;                s++;&lt;br/&gt;                p++;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (p&amp;gt;&lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                p=match[p&lt;span&gt;-1&lt;/span&gt;] + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            }&lt;span&gt;else&lt;/span&gt; s++;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (p == n) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; s-n;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;hr/&gt;&lt;h4&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;[1].https://www.bilibili.com/video/BV1Bp411f7kZ?from=search&amp;amp;seid=11686356292427499857&lt;br/&gt;[2].https://www.icourse163.org/learn/ZJU-93001?tid=1003997005#/learn/announce&lt;br/&gt;[3].https://oi-wiki.org/ds/dsu/#_5&lt;br/&gt;[4].维基百科&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0a7340b3b3749e923e6988b7d429ca07</guid>
<title>分享 8 个非常实用的 Vue 自定义指令</title>
<link>https://toutiao.io/k/zwn1ji1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;article fmt article-content&quot; data-id=&quot;1190000038475001&quot; data-license=&quot;&quot;&gt;
                                &lt;p&gt;本文在github做了收录 &lt;a href=&quot;https://github.com/Michael-lzg/my--article/blob/master/vue/%E5%88%86%E4%BA%AB8%E4%B8%AAVue%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4.md&quot; rel=&quot;nofollow noreferrer&quot;&gt;github.com/Michael-lzg…&lt;/a&gt;&lt;/p&gt;&lt;p&gt;demo源码地址 &lt;a href=&quot;https://github.com/Michael-lzg/v-directives&quot; rel=&quot;nofollow noreferrer&quot;&gt;github.com/Michael-lzg…&lt;/a&gt;&lt;/p&gt;&lt;p&gt;在 Vue，除了核心功能默认内置的指令 ( v-model 和 v-show )，Vue 也允许注册自定义指令。它的作用价值在于当开发人员在某些场景下需要对普通 DOM 元素进行操作。&lt;/p&gt;&lt;p&gt;Vue 自定义指令有全局注册和局部注册两种方式。先来看看注册全局指令的方式，通过 &lt;code&gt;Vue.directive( id, [definition] )&lt;/code&gt; 方式注册全局指令。然后在入口文件中进行 &lt;code&gt;Vue.use()&lt;/code&gt; 调用。&lt;/p&gt;&lt;p&gt;批量注册指令，新建 &lt;code&gt;directives/index.js&lt;/code&gt; 文件&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;import copy from &#x27;./copy&#x27;
import longpress from &#x27;./longpress&#x27;
// 自定义指令
const directives = {
  copy,
  longpress,
}

export default {
  install(Vue) {
    Object.keys(directives).forEach((key) =&amp;gt; {
      Vue.directive(key, directives[key])
    })
  },
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 &lt;code&gt;main.js&lt;/code&gt; 引入并调用&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;import Vue from &#x27;vue&#x27;
import Directives from &#x27;./JS/directives&#x27;
Vue.use(Directives)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;指令定义函数提供了几个钩子函数（可选）：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;bind: 只调用一次，指令第一次绑定到元素时调用，可以定义一个在绑定时执行一次的初始化动作。&lt;/li&gt;&lt;li&gt;inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。&lt;/li&gt;&lt;li&gt;update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值。&lt;/li&gt;&lt;li&gt;componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。&lt;/li&gt;&lt;li&gt;unbind: 只调用一次， 指令与元素解绑时调用。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;下面分享几个实用的 Vue 自定义指令&lt;/p&gt;&lt;ul&gt;&lt;li&gt;复制粘贴指令 &lt;code&gt;v-copy&lt;/code&gt;&lt;/li&gt;&lt;li&gt;长按指令 &lt;code&gt;v-longpress&lt;/code&gt;&lt;/li&gt;&lt;li&gt;输入框防抖指令 &lt;code&gt;v-debounce&lt;/code&gt;&lt;/li&gt;&lt;li&gt;禁止表情及特殊字符 &lt;code&gt;v-emoji&lt;/code&gt;&lt;/li&gt;&lt;li&gt;图片懒加载 &lt;code&gt;v-LazyLoad&lt;/code&gt;&lt;/li&gt;&lt;li&gt;权限校验指令 &lt;code&gt;v-premission&lt;/code&gt;&lt;/li&gt;&lt;li&gt;实现页面水印 &lt;code&gt;v-waterMarker&lt;/code&gt;&lt;/li&gt;&lt;li&gt;拖拽指令 &lt;code&gt;v-draggable&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;v-copy&lt;/h2&gt;&lt;p&gt;需求：实现一键复制文本内容，用于鼠标右键粘贴。&lt;/p&gt;&lt;p&gt;思路：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;动态创建 &lt;code&gt;textarea&lt;/code&gt; 标签，并设置 &lt;code&gt;readOnly&lt;/code&gt; 属性及移出可视区域&lt;/li&gt;&lt;li&gt;将要复制的值赋给 &lt;code&gt;textarea&lt;/code&gt; 标签的 &lt;code&gt;value&lt;/code&gt; 属性，并插入到 &lt;code&gt;body&lt;/code&gt;&lt;/li&gt;&lt;li&gt;选中值 &lt;code&gt;textarea&lt;/code&gt; 并复制&lt;/li&gt;&lt;li&gt;将 &lt;code&gt;body&lt;/code&gt; 中插入的 &lt;code&gt;textarea&lt;/code&gt; 移除&lt;/li&gt;&lt;li&gt;在第一次调用时绑定事件，在解绑时移除事件&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;const copy = {
  bind(el, { value }) {
    el.$value = value
    el.handler = () =&amp;gt; {
      if (!el.$value) {
        // 值为空的时候，给出提示。可根据项目UI仔细设计
        console.log(&#x27;无复制内容&#x27;)
        return
      }
      // 动态创建 textarea 标签
      const textarea = document.createElement(&#x27;textarea&#x27;)
      // 将该 textarea 设为 readonly 防止 iOS 下自动唤起键盘，同时将 textarea 移出可视区域
      textarea.readOnly = &#x27;readonly&#x27;
      textarea.style.position = &#x27;absolute&#x27;
      textarea.style.left = &#x27;-9999px&#x27;
      // 将要 copy 的值赋给 textarea 标签的 value 属性
      textarea.value = el.$value
      // 将 textarea 插入到 body 中
      document.body.appendChild(textarea)
      // 选中值并复制
      textarea.select()
      const result = document.execCommand(&#x27;Copy&#x27;)
      if (result) {
        console.log(&#x27;复制成功&#x27;) // 可根据项目UI仔细设计
      }
      document.body.removeChild(textarea)
    }
    // 绑定点击事件，就是所谓的一键 copy 啦
    el.addEventListener(&#x27;click&#x27;, el.handler)
  },
  // 当传进来的值更新的时候触发
  componentUpdated(el, { value }) {
    el.$value = value
  },
  // 指令与元素解绑的时候，移除事件绑定
  unbind(el) {
    el.removeEventListener(&#x27;click&#x27;, el.handler)
  },
}

export default copy&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用：给 Dom 加上 &lt;code&gt;v-copy&lt;/code&gt; 及复制的文本即可&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;button v-copy=&quot;copyText&quot;&amp;gt;复制&amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt; export default {
    data() {
      return {
        copyText: &#x27;a copy directives&#x27;,
      }
    },
  }
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;v-longpress&lt;/h2&gt;&lt;p&gt;需求：实现长按，用户需要按下并按住按钮几秒钟，触发相应的事件&lt;/p&gt;&lt;p&gt;思路：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;创建一个计时器， 2 秒后执行函数&lt;/li&gt;&lt;li&gt;当用户按下按钮时触发 &lt;code&gt;mousedown&lt;/code&gt; 事件，启动计时器；用户松开按钮时调用 &lt;code&gt;mouseout&lt;/code&gt; 事件。&lt;/li&gt;&lt;li&gt;如果 &lt;code&gt;mouseup&lt;/code&gt; 事件 2 秒内被触发，就清除计时器，当作一个普通的点击事件&lt;/li&gt;&lt;li&gt;如果计时器没有在 2 秒内清除，则判定为一次长按，可以执行关联的函数。&lt;/li&gt;&lt;li&gt;在移动端要考虑 &lt;code&gt;touchstart&lt;/code&gt;，&lt;code&gt;touchend&lt;/code&gt; 事件&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;const longpress = {
  bind: function (el, binding, vNode) {
    if (typeof binding.value !== &#x27;function&#x27;) {
      throw &#x27;callback must be a function&#x27;
    }
    // 定义变量
    let pressTimer = null
    // 创建计时器（ 2秒后执行函数 ）
    let start = (e) =&amp;gt; {
      if (e.type === &#x27;click&#x27; &amp;amp;&amp;amp; e.button !== 0) {
        return
      }
      if (pressTimer === null) {
        pressTimer = setTimeout(() =&amp;gt; {
          handler()
        }, 2000)
      }
    }
    // 取消计时器
    let cancel = (e) =&amp;gt; {
      if (pressTimer !== null) {
        clearTimeout(pressTimer)
        pressTimer = null
      }
    }
    // 运行函数
    const handler = (e) =&amp;gt; {
      binding.value(e)
    }
    // 添加事件监听器
    el.addEventListener(&#x27;mousedown&#x27;, start)
    el.addEventListener(&#x27;touchstart&#x27;, start)
    // 取消计时器
    el.addEventListener(&#x27;click&#x27;, cancel)
    el.addEventListener(&#x27;mouseout&#x27;, cancel)
    el.addEventListener(&#x27;touchend&#x27;, cancel)
    el.addEventListener(&#x27;touchcancel&#x27;, cancel)
  },
  // 当传进来的值更新的时候触发
  componentUpdated(el, { value }) {
    el.$value = value
  },
  // 指令与元素解绑的时候，移除事件绑定
  unbind(el) {
    el.removeEventListener(&#x27;click&#x27;, el.handler)
  },
}

export default longpress&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用：给 Dom 加上 &lt;code&gt;v-longpress&lt;/code&gt; 及回调函数即可&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;button v-longpress=&quot;longpress&quot;&amp;gt;长按&amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt; 
export default {
  methods: {
    longpress () {
      alert(&#x27;长按指令生效&#x27;)
    }
  }
} 
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;v-debounce&lt;/h2&gt;&lt;p&gt;背景：在开发中，有些提交保存按钮有时候会在短时间内被点击多次，这样就会多次重复请求后端接口，造成数据的混乱，比如新增表单的提交按钮，多次点击就会新增多条重复的数据。&lt;/p&gt;&lt;p&gt;需求：防止按钮在短时间内被多次点击，使用防抖函数限制规定时间内只能点击一次。&lt;/p&gt;&lt;p&gt;思路：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;定义一个延迟执行的方法，如果在延迟时间内再调用该方法，则重新计算执行时间。&lt;/li&gt;&lt;li&gt;将时间绑定在 click 方法上。&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;const debounce = {
  inserted: function (el, binding) {
    let timer
    el.addEventListener(&#x27;keyup&#x27;, () =&amp;gt; {
      if (timer) {
        clearTimeout(timer)
      }
      timer = setTimeout(() =&amp;gt; {
        binding.value()
      }, 1000)
    })
  },
}

export default debounce&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用：给 Dom 加上 &lt;code&gt;v-debounce&lt;/code&gt; 及回调函数即可&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;button v-debounce=&quot;debounceClick&quot;&amp;gt;防抖&amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt; 
export default {
  methods: {
    debounceClick () {
      console.log(&#x27;只触发一次&#x27;)
    }
  }
} 
&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;v-emoji&lt;/h2&gt;&lt;p&gt;背景：开发中遇到的表单输入，往往会有对输入内容的限制，比如不能输入表情和特殊字符，只能输入数字或字母等。&lt;/p&gt;&lt;p&gt;我们常规方法是在每一个表单的 &lt;code&gt;on-change&lt;/code&gt; 事件上做处理。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;input type=&quot;text&quot; v-model=&quot;note&quot; @change=&quot;vaidateEmoji&quot; /&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt; export default {
    methods: {
      vaidateEmoji() {
        var reg = /[^u4E00-u9FA5|d|a-zA-Z|rns,.?!，。？！…—&amp;amp;$=()-+/*{}[]]|s/g
        this.note = this.note.replace(reg, &#x27;&#x27;)
      },
    },
  } &amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样代码量比较大而且不好维护，所以我们需要自定义一个指令来解决这问题。&lt;/p&gt;&lt;p&gt;需求：根据正则表达式，设计自定义处理表单输入规则的指令，下面以禁止输入表情和特殊字符为例。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;let findEle = (parent, type) =&amp;gt; {
  return parent.tagName.toLowerCase() === type ? parent : parent.querySelector(type)
}

const trigger = (el, type) =&amp;gt; {
  const e = document.createEvent(&#x27;HTMLEvents&#x27;)
  e.initEvent(type, true, true)
  el.dispatchEvent(e)
}

const emoji = {
  bind: function (el, binding, vnode) {
    // 正则规则可根据需求自定义
    var regRule = /[^u4E00-u9FA5|d|a-zA-Z|rns,.?!，。？！…—&amp;amp;$=()-+/*{}[]]|s/g
    let $inp = findEle(el, &#x27;input&#x27;)
    el.$inp = $inp
    $inp.handle = function () {
      let val = $inp.value
      $inp.value = val.replace(regRule, &#x27;&#x27;)

      trigger($inp, &#x27;input&#x27;)
    }
    $inp.addEventListener(&#x27;keyup&#x27;, $inp.handle)
  },
  unbind: function (el) {
    el.$inp.removeEventListener(&#x27;keyup&#x27;, el.$inp.handle)
  },
}

export default emoji&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用：将需要校验的输入框加上 &lt;code&gt;v-emoji&lt;/code&gt; 即可&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;input type=&quot;text&quot; v-model=&quot;note&quot; v-emoji /&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;v-LazyLoad&lt;/h2&gt;&lt;p&gt;背景：在类电商类项目，往往存在大量的图片，如 banner 广告图，菜单导航图，美团等商家列表头图等。图片众多以及图片体积过大往往会影响页面加载速度，造成不良的用户体验，所以进行图片懒加载优化势在必行。&lt;/p&gt;&lt;p&gt;需求：实现一个图片懒加载指令，只加载浏览器可见区域的图片。&lt;/p&gt;&lt;p&gt;思路：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;图片懒加载的原理主要是判断当前图片是否到了可视区域这一核心逻辑实现的&lt;/li&gt;&lt;li&gt;拿到所有的图片 Dom ，遍历每个图片判断当前图片是否到了可视区范围内&lt;/li&gt;&lt;li&gt;如果到了就设置图片的 &lt;code&gt;src&lt;/code&gt; 属性，否则显示默认图片&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;图片懒加载有两种方式可以实现，一是绑定 &lt;code&gt;srcoll&lt;/code&gt; 事件进行监听，二是使用 &lt;code&gt;IntersectionObserver&lt;/code&gt; 判断图片是否到了可视区域，但是有浏览器兼容性问题。&lt;/p&gt;&lt;p&gt;下面封装一个懒加载指令兼容两种方法，判断浏览器是否支持 &lt;code&gt;IntersectionObserver&lt;/code&gt; API，如果支持就使用 &lt;code&gt;IntersectionObserver&lt;/code&gt; 实现懒加载，否则则使用 &lt;code&gt;srcoll&lt;/code&gt; 事件监听 + 节流的方法实现。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;const LazyLoad = {
  // install方法
  install(Vue, options) {
    const defaultSrc = options.default
    Vue.directive(&#x27;lazy&#x27;, {
      bind(el, binding) {
        LazyLoad.init(el, binding.value, defaultSrc)
      },
      inserted(el) {
        if (IntersectionObserver) {
          LazyLoad.observe(el)
        } else {
          LazyLoad.listenerScroll(el)
        }
      },
    })
  },
  // 初始化
  init(el, val, def) {
    el.setAttribute(&#x27;data-src&#x27;, val)
    el.setAttribute(&#x27;src&#x27;, def)
  },
  // 利用IntersectionObserver监听el
  observe(el) {
    var io = new IntersectionObserver((entries) =&amp;gt; {
      const realSrc = el.dataset.src
      if (entries[0].isIntersecting) {
        if (realSrc) {
          el.src = realSrc
          el.removeAttribute(&#x27;data-src&#x27;)
        }
      }
    })
    io.observe(el)
  },
  // 监听scroll事件
  listenerScroll(el) {
    const handler = LazyLoad.throttle(LazyLoad.load, 300)
    LazyLoad.load(el)
    window.addEventListener(&#x27;scroll&#x27;, () =&amp;gt; {
      handler(el)
    })
  },
  // 加载真实图片
  load(el) {
    const windowHeight = document.documentElement.clientHeight
    const elTop = el.getBoundingClientRect().top
    const elBtm = el.getBoundingClientRect().bottom
    const realSrc = el.dataset.src
    if (elTop - windowHeight &amp;lt; 0 &amp;amp;&amp;amp; elBtm &amp;gt; 0) {
      if (realSrc) {
        el.src = realSrc
        el.removeAttribute(&#x27;data-src&#x27;)
      }
    }
  },
  // 节流
  throttle(fn, delay) {
    let timer
    let prevTime
    return function (...args) {
      const currTime = Date.now()
      const context = this
      if (!prevTime) prevTime = currTime
      clearTimeout(timer)

      if (currTime - prevTime &amp;gt; delay) {
        prevTime = currTime
        fn.apply(context, args)
        clearTimeout(timer)
        return
      }

      timer = setTimeout(function () {
        prevTime = Date.now()
        timer = null
        fn.apply(context, args)
      }, delay)
    }
  },
}

export default LazyLoad&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用，将组件内  标签的 &lt;code&gt;src&lt;/code&gt; 换成 &lt;code&gt;v-LazyLoad&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;img v-LazyLoad=&quot;xxx.jpg&quot; /&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;v-permission&lt;/h2&gt;&lt;p&gt;背景：在一些后台管理系统，我们可能需要根据用户角色进行一些操作权限的判断，很多时候我们都是粗暴地给一个元素添加 &lt;code&gt;v-if / v-show&lt;/code&gt; 来进行显示隐藏，但如果判断条件繁琐且多个地方需要判断，这种方式的代码不仅不优雅而且冗余。针对这种情况，我们可以通过全局自定义指令来处理。&lt;/p&gt;&lt;p&gt;需求：自定义一个权限指令，对需要权限判断的 Dom 进行显示隐藏。&lt;/p&gt;&lt;p&gt;思路：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;自定义一个权限数组&lt;/li&gt;&lt;li&gt;判断用户的权限是否在这个数组内，如果是则显示，否则则移除 Dom&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;function checkArray(key) {
  let arr = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;]
  let index = arr.indexOf(key)
  if (index &amp;gt; -1) {
    return true // 有权限
  } else {
    return false // 无权限
  }
}

const permission = {
  inserted: function (el, binding) {
    let permission = binding.value // 获取到 v-permission的值
    if (permission) {
      let hasPermission = checkArray(permission)
      if (!hasPermission) {
        // 没有权限 移除Dom元素
        el.parentNode &amp;amp;&amp;amp; el.parentNode.removeChild(el)
      }
    }
  },
}

export default permission&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用：给 &lt;code&gt;v-permission&lt;/code&gt; 赋值判断即可&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;div class=&quot;btns&quot;&amp;gt;
  &amp;lt;!-- 显示 --&amp;gt;
  &amp;lt;button v-permission=&quot;&#x27;1&#x27;&quot;&amp;gt;权限按钮1&amp;lt;/button&amp;gt;
  &amp;lt;!-- 不显示 --&amp;gt;
  &amp;lt;button v-permission=&quot;&#x27;10&#x27;&quot;&amp;gt;权限按钮2&amp;lt;/button&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;vue-waterMarker&lt;/h2&gt;&lt;p&gt;需求：给整个页面添加背景水印&lt;/p&gt;&lt;p&gt;思路：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;使用 &lt;code&gt;canvas&lt;/code&gt; 特性生成 &lt;code&gt;base64&lt;/code&gt; 格式的图片文件，设置其字体大小，颜色等。&lt;/li&gt;&lt;li&gt;将其设置为背景图片，从而实现页面或组件水印效果&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;function addWaterMarker(str, parentNode, font, textColor) {
  // 水印文字，父元素，字体，文字颜色
  var can = document.createElement(&#x27;canvas&#x27;)
  parentNode.appendChild(can)
  can.width = 200
  can.height = 150
  can.style.display = &#x27;none&#x27;
  var cans = can.getContext(&#x27;2d&#x27;)
  cans.rotate((-20 * Math.PI) / 180)
  cans.font = font || &#x27;16px Microsoft JhengHei&#x27;
  cans.fillStyle = textColor || &#x27;rgba(180, 180, 180, 0.3)&#x27;
  cans.textAlign = &#x27;left&#x27;
  cans.textBaseline = &#x27;Middle&#x27;
  cans.fillText(str, can.width / 10, can.height / 2)
  parentNode.style.backgroundImage = &#x27;url(&#x27; + can.toDataURL(&#x27;image/png&#x27;) + &#x27;)&#x27;
}

const waterMarker = {
  bind: function (el, binding) {
    addWaterMarker(binding.value.text, el, binding.value.font, binding.value.textColor)
  },
}

export default waterMarker&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用，设置水印文案，颜色，字体大小即可&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div v-waterMarker=&quot;{text:&#x27;lzg版权所有&#x27;,textColor:&#x27;rgba(180, 180, 180, 0.4)&#x27;}&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;效果如图所示&lt;/p&gt;&lt;p&gt;&lt;img alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;/p&gt;&lt;h2&gt;v-draggable&lt;/h2&gt;&lt;p&gt;需求：实现一个拖拽指令，可在页面可视区域任意拖拽元素。&lt;/p&gt;&lt;p&gt;思路：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;设置需要拖拽的元素为相对定位，其父元素为绝对定位。&lt;/li&gt;&lt;li&gt;鼠标按下&lt;code&gt;(onmousedown)&lt;/code&gt;时记录目标元素当前的 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;top&lt;/code&gt; 值。&lt;/li&gt;&lt;li&gt;鼠标移动&lt;code&gt;(onmousemove)&lt;/code&gt;时计算每次移动的横向距离和纵向距离的变化值，并改变元素的 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;top&lt;/code&gt; 值&lt;/li&gt;&lt;li&gt;鼠标松开&lt;code&gt;(onmouseup)&lt;/code&gt;时完成一次拖拽&lt;/li&gt;&lt;/ol&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;const draggable = {
  inserted: function (el) {
    el.style.cursor = &#x27;move&#x27;
    el.onmousedown = function (e) {
      let disx = e.pageX - el.offsetLeft
      let disy = e.pageY - el.offsetTop
      document.onmousemove = function (e) {
        let x = e.pageX - disx
        let y = e.pageY - disy
        let maxX = document.body.clientWidth - parseInt(window.getComputedStyle(el).width)
        let maxY = document.body.clientHeight - parseInt(window.getComputedStyle(el).height)
        if (x &amp;lt; 0) {
          x = 0
        } else if (x &amp;gt; maxX) {
          x = maxX
        }

        if (y &amp;lt; 0) {
          y = 0
        } else if (y &amp;gt; maxY) {
          y = maxY
        }

        el.style.left = x + &#x27;px&#x27;
        el.style.top = y + &#x27;px&#x27;
      }
      document.onmouseup = function () {
        document.onmousemove = document.onmouseup = null
      }
    }
  },
}
export default draggable&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用: 在 Dom 上加上 v-draggable 即可&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;el-dialog&quot; v-draggable&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所有指令源码地址 &lt;a href=&quot;https://github.com/Michael-lzg/v-directives&quot; rel=&quot;nofollow noreferrer&quot;&gt;github.com/Michael-lzg…&lt;/a&gt;&lt;/p&gt;&lt;h2&gt;推荐文章&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6901210575162834958&quot; rel=&quot;nofollow noreferrer&quot;&gt;你必须知道的webpack插件原理分析&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://juejin.cn/post/6895546761255845901&quot; rel=&quot;nofollow noreferrer&quot;&gt;webpack的异步加载原理及分包策略&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://juejin.im/post/6844904193589772301&quot; rel=&quot;nofollow noreferrer&quot;&gt;总结18个webpack插件，总会有你想要的！&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://juejin.im/post/6844904152389124103#heading-19&quot; rel=&quot;nofollow noreferrer&quot;&gt;搭建一个 vue-cli4+webpack 移动端框架（开箱即用）&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://juejin.im/post/6844904168868544525&quot; rel=&quot;nofollow noreferrer&quot;&gt;从零构建到优化一个类似vue-cli的脚手架&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://juejin.im/post/6844903991655022600&quot; rel=&quot;nofollow noreferrer&quot;&gt;封装一个toast和dialog组件并发布到npm&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://juejin.im/post/6844904005286494215&quot; rel=&quot;nofollow noreferrer&quot;&gt;从零开始构建一个webpack项目&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://juejin.im/post/6844904004825120782&quot; rel=&quot;nofollow noreferrer&quot;&gt;总结几个webpack打包优化的方法&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://juejin.im/post/6844904094692278286&quot; rel=&quot;nofollow noreferrer&quot;&gt;总结vue知识体系之高级应用篇&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://juejin.im/post/6844904080960126989&quot; rel=&quot;nofollow noreferrer&quot;&gt;总结vue知识体系之实用技巧&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://juejin.im/post/6844904079164964871&quot; rel=&quot;nofollow noreferrer&quot;&gt;总结vue知识体系之基础入门篇&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://juejin.im/post/6844904066301050893&quot; rel=&quot;nofollow noreferrer&quot;&gt;总结移动端H5开发常用技巧（干货满满哦！）&lt;/a&gt;&lt;/p&gt;
                            &lt;/article&gt;

                            
                            

                            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5fa0d794313c8b8d20e970b50a2874b5</guid>
<title>10 张图让你彻底理解回调函数</title>
<link>https://toutiao.io/k/vxd1xum</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;不知你是不是也有这样的疑惑，我们为什么需要回调函数这个概念呢？直接调用函数不就可以了？回调函数到底有什么作用？程序员到底该如何理解回调函数？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这篇文章就来为你解答这些问题，&lt;strong&gt;读完这篇文章后你的武器库将新增一件功能强大的利器&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;一切要从这样的需求说起&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;假设你们公司要开发下一代国民App“明日油条”，一款主打解决国民早餐问题的App，为了加快开发进度，这款应用由A小组和B小组协同开发。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其中有一个核心模块由A小组开发然后供B小组调用，这个核心模块被封装成了一个函数，这个函数就叫make_youtiao()。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果make_youtiao()这个函数执行的很快并可以立即返回，那么B小组的同学只需要：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;调用make_youtiao()&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;等待该函数执行完成&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;该函数执行完后继续后续流程&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;从程序执行的角度看这个过程是这样的：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;保存当前被执行函数的上下文&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;开始执行make_youtiao()这个函数&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;make_youtiao()执行完后，控制转回到调用函数中&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8521594684385382&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya3KTK31oeaDK36PSaic3t9LDl0Two4NxibagqfQqDHs8gSkNYSO3BhQA4gGRBpjLKab3fY1POTcGhFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;602&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果世界上所有的函数都像make_youtiao()这么简单，那么程序员大概率就要失业了，还好程序的世界是复杂的，这样程序员才有了存在的价值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;现实并不容易&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;现实中make_youtiao()这个函数需要处理的数据非常庞大，假设有10000个，&lt;strong&gt;那么make_youtiao(10000)不会立刻返回&lt;/strong&gt;，而是可能需要10分钟才执行完成并返回。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这时你该怎么办呢？想一想这个问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可能有的同学会问，和刚才一样直接调用不可以吗，这样多简单。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;是的，这样做没有问题，但就像爱因斯坦说的那样“一切都应该尽可能简单，但是不能过于简单”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;想一想直接调用会有什么问题？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;显然直接调用的话，那么调用线程会被阻塞暂停，在等待10分钟后才能继续运行。在这10分钟内该线程不会被操作系统分配CPU，也就是说该线程得不到任何推进。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这并不是一种高效的做法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;没有一个程序员想死盯着屏幕10分钟后才能得到结果。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么有没有一种更加高效的做法呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;想一想我们上一篇中那个一直盯着你写代码的老板(见《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247484851&amp;amp;idx=1&amp;amp;sn=30d68a28f926b3e8b53f4d86e5630b60&amp;amp;chksm=fcb982edcbce0bfbb213afdb2f0996f11771b21b940b535171c5d974c6b0b882a9b8bb3ef192&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;从小白到高手，你需要理解同步与异步&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;从小白到高手，你需要理解同步与异步&lt;/a&gt;》)，我们已经知道了这种&lt;strong&gt;一直等待直到另一个任务完成的&lt;/strong&gt;模式叫做同步。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你是老板的话你会什么都不干一直盯着员工写代码吗？因此一种更好的做法是程序员在代码的时候老板该干啥干啥，程序员写完后自然会通知老板，这样老板和程序员都不需要相互等待，这种模式被称为异步。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;回到我们的主题，这里一种更好的方式是&lt;strong&gt;调用make_youtiao()这个函数后不再等待这个函数执行完成&lt;/strong&gt;，而是直接返回继续后续流程，这样A小组的程序就可以和make_youtiao()这个函数同时进行了，就像这样：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8311258278145696&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya3KTK31oeaDK36PSaic3t9LDxibF5DQhH4jAuiaA8GWiblo9JoPyHqQ4Cy8w3zRDwgHdyAlAZ2EWyzzsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;604&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在这种情况下，回调(callback)就必须出场了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;为什么我们需要回调callback&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;有的同学可能还没有明白为什么在这种情况下需要回调，别着急，我们慢慢讲。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;假设我们“明日油条”App代码第一版是这样写的：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;make_youtiao(10000);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sell();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以看到这是最简单的写法，意思很简单，制作好油条后卖出去。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7302725968436155&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya3KTK31oeaDK36PSaic3t9LDC0IR1SibsDXlqzAoPBZBnj3HJic6TwYMot8lribM93JBq3Fs1wLbicpeRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;697&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们已经知道了由于make_youtiao(10000)这个函数10分钟才能返回，你不想一直死盯着屏幕10分钟等待结果，那么一种更好的方法是让make_youtiao()这个函数知道制作完油条后该干什么，即，更好的调用make_youtiao的方式是这样的：&lt;/span&gt;&lt;span&gt;“制作10000个油条，&lt;/span&gt;&lt;strong&gt;炸好后卖出去&lt;/strong&gt;&lt;span&gt;”，因此调用make_youtiao就变出这样了：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;make_youtiao(10000, sell);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;看到了吧，现在make_youtiao这个函数多了一个参数，除了指定制作油条的数量外&lt;/span&gt;&lt;strong&gt;还可以指定制作好后该干什么&lt;/strong&gt;&lt;span&gt;，第二个被make_youtiao这个函数调用的函数就叫回调，callback。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在你应该看出来了吧，虽然sell函数是你定义的，但是这个函数却是被其它模块调用执行的，就像这样：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.2877551020408162&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya3KTK31oeaDK36PSaic3t9LDx1fFI6FTG3BvkAfr36DaOIo4MhpdcH5IQSpibIKpvLIv4JbH6sfBMzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;490&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;make_youtiao这个函数是怎么实现的呢，很简单：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;make_youtiao&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; num, func call_back&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    call_back(); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这样你就不用死盯着屏幕了，因为你把make_youtiao这个函数执行完后该做的任务交代给make_youtiao这个函数了，该函数制作完油条后知道该干些什么，这样就解放了你的程序。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有的同学可能还是有疑问，为什么编写make_youtiao这个小组不直接定义sell函数然后调用呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不要忘了明日油条这个App是由A小组和B小组同时开发的，A小组在编写make_youtiao时怎么知道B小组要怎么用这个模块，假设A小组真的自己定义sell函数就会这样写：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;make_youtiao&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; num&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    real_make_youtiao(num);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    sell(); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同时A小组设计的模块非常好用，这时C小组也想用这个模块，然而C小组的需求是制作完油条后放到仓库而不是不是直接卖掉，要满足这一需求那么A小组该怎么写呢？&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;make_youtiao&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; num&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    real_make_youtiao(num);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (Team_B) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       sell(); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (Team_D) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       store(); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;故事还没完，假设这时D小组又想使用呢，难道还要接着添加if else吗？&lt;/span&gt;&lt;span&gt;这样的话A小组的同学只需要维护make_youtiao这个函数就能做到工作量饱满了，显然这是一种非常糟糕的设计。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以你会看到，制作完油条后接下来该做什么不是实现make_youtiao的A小组该关心的事情，很明显只有调用make_youtiao这个函数的使用方才知道。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因此make_youtiao的A小组完全可以通过回调函数将接下来该干什么交给调用方实现，A小组的同学只需要针对回调函数这一抽象概念进行编程就好了，这样调用方在制作完油条后不管是卖掉、放到库存还是自己吃掉等等想做什么都可以，&lt;strong&gt;A小组的make_youtiao函数根本不用做任何改动&lt;/strong&gt;，因为A小组是针对回调函数这一抽象概念来编程的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;以上就是回调函数的作用，当然这也是针对抽象而不是具体实现进行编程这一思想的威力所在。面向对象中的多态本质上就是让你用来针对抽象而不是针对实现来编程的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;异步回调&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;故事到这里还没有结束。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在上面的示例中，虽然我们使用了回调这一概念，也就是调用方实现回调函数然后再将该函数当做参数传递给其它模块调用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是，这里依然有一个问题，那就是make_youtiao函数的调用方式依然是同步的，关于同步异步请参考《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247484851&amp;amp;idx=1&amp;amp;sn=30d68a28f926b3e8b53f4d86e5630b60&amp;amp;chksm=fcb982edcbce0bfbb213afdb2f0996f11771b21b940b535171c5d974c6b0b882a9b8bb3ef192&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;从小白到高手，你需要理解同步与异步&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;从小白到高手，你需要理解同步与异步&lt;/a&gt;》，也就是说调用方是这样实现的：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;make_youtiao(&lt;span class=&quot;code-snippet__number&quot;&gt;10000&lt;/span&gt;, sell);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.2877551020408162&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya3KTK31oeaDK36PSaic3t9LDx1fFI6FTG3BvkAfr36DaOIo4MhpdcH5IQSpibIKpvLIv4JbH6sfBMzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;490&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们可以看到，调用方必须等待make_youtiao函数返回后才可以继续后续流程，我们再来看下make_youtiao函数的实现：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;make_youtiao&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; num, func call_back&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    real_make_youtiao(num);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    call_back(); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;看到了吧，由于我们要制作10000个油条，make_youtiao函数执行完需要10分钟，也就是说即便我们使用了回调，调用方完全不需要关心制作完油条后的后续流程，但是调用方依然会被阻塞10分钟，这就是同步调用的问题所在。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你真的理解了上一节的话应该能想到一种更好的方法了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;没错，那就是&lt;strong&gt;异步调用&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;反正制作完油条后的后续流程并不是调用方该关心的，也就是说调用方并不关心make_youtiao这一函数的返回值，那么一种更好的方式是：&lt;strong&gt;把制作油条的这一任务放到另一个线程(进程)、甚至另一台机器上&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果用线程实现的话，那么make_youtiao就是这样实现了:&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;make_youtiao&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; num, func call_back&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    create_thread(real_make_youtiao,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                  num,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                  call_back);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.074468085106383&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya3KTK31oeaDK36PSaic3t9LDJq57truibr8GAibc1RI1mku6SJ9hbbZlxxO1xpeRiaQHA0qjAVjzJQBAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;564&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;看到了吧，这时当我们调用make_youtiao时就会&lt;/span&gt;&lt;strong&gt;立刻返回&lt;/strong&gt;&lt;span&gt;，即使油条还没有真正开始制作，而调用方也完全无需等待制作油条的过程，可以立刻执行后流程：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;make_youtiao(&lt;span class=&quot;code-snippet__number&quot;&gt;10000&lt;/span&gt;, sell);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这时调用方的后续流程可以和制作油条&lt;/span&gt;&lt;strong&gt;同时&lt;/strong&gt;&lt;span&gt;进行，这就是函数的&lt;/span&gt;&lt;strong&gt;异步调用&lt;/strong&gt;&lt;span&gt;，当然这也是异步的高效之处。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;新的编程思维模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;让我们再来仔细的看一下这个过程。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;程序员最熟悉的思维模式是这样的：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;res = request();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;handle(res);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这就是函数的同步调用，只有request()函数返回拿到结果后，才能调用handle函数进行处理，request函数返回前我们必须&lt;/span&gt;&lt;strong&gt;等待&lt;/strong&gt;&lt;span&gt;，这就是同步调用，其控制流是这样的：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.4953271028037383&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya3KTK31oeaDK36PSaic3t9LDqfoGCLtrK6HKBB4ic0icw3SefibVnj2Sk7s1rzFmwSm7P2pic8QLHRXabA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;428&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;但是如果我们想更加高效的话，那么就需要异步调用了，我们不去直接调用handle函数，而是作为参数传递给request：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;request(handle);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们根本就不关心request什么时候真正的获取的结果，这是request该关心的事情，我们只需要把获取到结果后该怎么处理告诉request就可以了，因此request函数可以立刻返回，真的获取结果的处理可能是在另一个线程、进程、甚至另一台机器上完成。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这就是异步调用，其控制流是这样的：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.2258064516129032&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya3KTK31oeaDK36PSaic3t9LDzUHqr9H5GcDdgQicxT28m8Zjk5FN5t7NoAk1SE8iaoZ0ib4T8It60d8eg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;527&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;从编程思维上看，异步调用和同步有很大的差别，如果我们把处理流程当做一个任务来的话，那么同步下整个任务都是我们来实现的，但是异步情况下任务的处理流程被分为了两部分：&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一部分是我们来处理的，也就是调用request之前的部分&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二部分不是我们处理的，而是在其它线程、进程、甚至另一个机器上处理的。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;我们可以看到由于任务被分成了两部分，第二部分的调用不在我们的掌控范围内，同时只有调用方才知道该做什么，因此在这种情况下回调函数就是一种必要的机制了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;也就是说回调函数的本质就是“只有我们才知道做些什么，但是我们并不清楚什么时候去做这些，只有其它模块才知道，因此我们必须把我们知道的封装成回调函数告诉其它模块”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在你应该能看出异步回调这种编程思维模式和同步的差异了吧。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;接下来我们给回调一个较为学术的定义&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;正式定义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;37&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;在计算机科学中，回调函数是指一段以参数的形式传递给其它代码的可执行代码。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;这就是回调函数的定义了。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;回调函数就是一个函数，和其它函数没有任何区别。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;注意，回调函数是一种软件设计上的概念，和某个编程语言没有关系，几乎所有的编程语言都能实现回调函数。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于一般的函数来说，我们自己编写的函数会在自己的程序内部调用，也就是说函数的编写方是我们自己，调用方也是我们自己。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但回调函数不是这样的，虽然函数编写方是我们自己，但是函数调用方不是我们，而是我们引用的其它模块，也就是第三方库，我们调用第三方库中的函数，并把回调函数传递给第三方库，第三方库中的函数调用我们编写的回调函数，如图所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6071019473081328&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya3KTK31oeaDK36PSaic3t9LD5vkmLgv7xuTuO7R01U20JvGmICxramu15ibos6OMPp0yA0j5ofGibqOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;873&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;而之所以需要给第三方库指定回调函数，是因为第三方库的编写者并不清楚在某些特定节点，比如我们举的例子油条制作完成、接收到网络数据、文件读取完成等之后该做什么，这些只有库的使用方才知道，因此第三方库的编写者无法针对具体的实现来写代码，而只能对外提供一个回调函数，库的使用方来实现该函数，第三方库在特定的节点调用该回调函数就可以了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另一点值得注意的是，从图中我们可以看出回调函数和我们的主程序位于&lt;strong&gt;同一层&lt;/strong&gt;中，我们只负责编写该回调函数，但并不是我们来调用的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后值得注意的一点就是回调函数被调用的时间节点，回调函数只在某些特定的节点被调用，就像上面说的油条制作完成、接收到网络数据、文件读取完成等，这些都是事件，也就是event，本质上我们编写的回调函数就是用来处理event的，因此从这个角度看回调函数不过就是event handler，因此回调函数天然适用于事件驱动编程event-driven，我们将会在后续文章中再次回到这一主题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;回调的类型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;我们已经知道有两种类型的回调，这两种类型的回调区别在于回调函数被调用的时机。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;注意，接下来会用到同步和异步的概念，对这两个概念不熟悉的同学可以参考上一盘文章《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NTYyOTQ4OQ==&amp;amp;mid=2247484851&amp;amp;idx=1&amp;amp;sn=30d68a28f926b3e8b53f4d86e5630b60&amp;amp;chksm=fcb982edcbce0bfbb213afdb2f0996f11771b21b940b535171c5d974c6b0b882a9b8bb3ef192&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;从小白到高手，你需要理解同步和异步&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;从小白到高手，你需要理解同步和异步&lt;/a&gt;》。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;同步回调&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这种回调就是通常所说的同步回调synchronous callbacks、也有的将其称为阻塞式回调blocking callbacks，或者什么修饰都没有，就是回调，callback，这是我们最为熟悉的回调方式。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当我们调用某个函数A并以参数的形式传入回调函数后，在A返回之前回调函数会被执行，也就是说我们的主程序会等待回调函数执行完成，这就是所谓的同步回调。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9868247694334651&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya3KTK31oeaDK36PSaic3t9LDShMRdDjCW6A0Z3DM8GjrWogCUULttpsJ8uU8Plmhf8fzr6Uf9LU0GQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;759&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有同步回调就有异步回调。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;异步回调&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不同于同步回调， 当我们调用某个函数A并以参数的形式传入回调函数后，A函数会立刻返回，也就是说函数A并不会阻塞我们的主程序，一段时间后回调函数开始被执行，此时我们的主程序可能在忙其它任务，回调函数的执行和我们主程序的运行同时进行。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;既然我们的主程序和回调函数的执行可以同时发生，因此一般情况下，主程序和回调函数的执行位于不同的线程或者进程中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.0065876152832676&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8g3rwJPmya3KTK31oeaDK36PSaic3t9LDu2ST60GDeuXPynibBUh906xnkqicarCL5tBTmcndhwSXr2iad5OzLzddw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;759&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这就是所谓的异步回调，asynchronous callbacks，也有的资料将其称为deferred callbacks ，名字很形象，延迟回调。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;从上面这两张图中我们也可以看到，异步回调要比同步回调更能充分的利用机器资源，原因就在于在同步模式下主程序会“偷懒”，因为调用其它函数被阻塞而暂停运行，但是异步调用不存在这个问题，主程序会一直运行下去。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因此，异步回调更常见于I/O操作，天然适用于Web服务这种高并发场景。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;回调对应的编程思维模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;让我们用简单的几句话来总结一下回调下与常规编程思维模式的不同。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;假设我们想处理某项任务，这项任务需要依赖某项服务S，我们可以将任务的处理分为两部分，调用服务S前的部分PA，和调用服务S后的部分PB。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在常规模式下，PA和PB都是服务调用方来执行的，也就是我们自己来执行PA部分，等待服务S返回后再执行PB部分。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但在回调这种方式下就不一样了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在这种情况下，我们自己来执行PA部分，然后告诉服务S：“等你完成服务后执行PB部分”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因此我们可以看到，现在一项任务是由不同的模块来协作完成的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;即：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;常规模式：调用完S服务后后我去执行X任务，&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;回调模式：调用完S服务后你接着再去执行X任务，&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;其中X是服务调用方制定的，区别在于谁来执行。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;为什么异步回调越来越重要&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;在同步模式下，服务调用方会因服务执行而被阻塞暂停执行，这会导致整个线程被阻塞，因此这种编程方式天然不适用于高并发动辄几万几十万的并发连接场景，&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;针对高并发这一场景，异步其实是更加高效的，原因很简单，你不需要在原地等待，因此从而更好的利用机器资源，而回调函数又是异步下不可或缺的一种机制。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;回调地狱，callback hell &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;有的同学可能认为有了异步回调这种机制应付起一切高并发场景就可以高枕无忧了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;实际上在计算机科学中还没有任何一种可以横扫一切包治百病的技术，现在没有，在可预见的将来也不会有，一切都是妥协的结果。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么异步回调这种机制有什么问题呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;实际上我们已经看到了，异步回调这种机制和程序员最熟悉的同步模式不一样，在可理解性上比不过同步，而如果业务逻辑相对复杂，比如我们处理某项任务时不止需要调用一项服务，而是几项甚至十几项，如果这些服务调用都采用异步回调的方式来处理的话，那么很有可能我们就陷入回调地狱中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;举个例子，假设处理某项任务我们需要调用四个服务，每一个服务都需要依赖上一个服务的结果，如果用同步方式来实现的话可能是这样的：&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;a&lt;/span&gt; = GetServiceA();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;b&lt;/span&gt; = GetServiceB(a);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;c&lt;/span&gt; = GetServiceC(b);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;d&lt;/span&gt; = GetServiceD(c);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;代码很清晰，很容易理解有没有。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们知道异步回调的方式会更加高效，那么使用异步回调的方式来写将会是什么样的呢？&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;GetServiceA(&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;a&lt;/span&gt;)&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    GetServiceB(a, &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;b&lt;/span&gt;)&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        GetServiceC(b, &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;c&lt;/span&gt;)&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            GetServiceD(c, &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;d&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                ....&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;});&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我想不需要再强调什么了吧，你觉得这两种写法哪个更容易理解，代码更容易维护呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;博主有幸曾经维护过这种类型的代码，不得不说每次增加新功能的时候恨不得自己化为两个分身，一个不得不去重读一边代码；另一个在一旁骂自己为什么当初选择维护这个项目。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;异步回调代码稍不留意就会跌到回调陷阱中，那么有没有一种更好的办法既能结合异步回调的高效又能结合同步编码的简单易读呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;幸运的是，答案是肯定的，我们会在后续文章中详细讲解这一技术。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;在这篇文章中，我们从一个实际的例子出发详细讲解了回调函数这种机制的来龙去脉，这是应对高并发、高性能场景的一种极其重要的编码机制，异步加回调可以充分利用机器资源，实际上异步回调最本质上就是事件驱动编程，这是我们接下来要重点讲解的内容。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__0&quot;&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2934&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2935&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2936&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2937&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2938&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2939&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2940&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2941&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2942&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2943&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;伟&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2944&quot;&gt;伟&lt;/span&gt;&lt;span data-raw-text=&quot;大&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2945&quot;&gt;大&lt;/span&gt;&lt;span data-raw-text=&quot;的&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2946&quot;&gt;的&lt;/span&gt;&lt;span data-raw-text=&quot;分&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2947&quot;&gt;分&lt;/span&gt;&lt;span data-raw-text=&quot;割&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2948&quot;&gt;割&lt;/span&gt;&lt;span data-raw-text=&quot;线&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2949&quot;&gt;线&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2950&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2951&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2952&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2953&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2954&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2955&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2956&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2957&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2958&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2959&quot;&gt;-&lt;/span&gt;&lt;span data-raw-text=&quot;-&quot; data-textnode-index=&quot;97&quot; data-index=&quot;2960&quot;&gt;-&lt;/span&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__1&quot;&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__2&quot;&gt;&lt;span data-raw-text=&quot;P&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2961&quot;&gt;P&lt;/span&gt;&lt;span data-raw-text=&quot;H&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2962&quot;&gt;H&lt;/span&gt;&lt;span data-raw-text=&quot;P&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2963&quot;&gt;P&lt;/span&gt;&lt;span data-raw-text=&quot;饭&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2964&quot;&gt;饭&lt;/span&gt;&lt;span data-raw-text=&quot;米&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2965&quot;&gt;米&lt;/span&gt;&lt;span data-raw-text=&quot;粒&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2966&quot;&gt;粒&lt;/span&gt;&lt;span data-raw-text=&quot;(&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2967&quot;&gt;(&lt;/span&gt;&lt;span data-raw-text=&quot;p&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2968&quot;&gt;p&lt;/span&gt;&lt;span data-raw-text=&quot;h&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2969&quot;&gt;h&lt;/span&gt;&lt;span data-raw-text=&quot;p&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2970&quot;&gt;p&lt;/span&gt;&lt;span data-raw-text=&quot;f&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2971&quot;&gt;f&lt;/span&gt;&lt;span data-raw-text=&quot;a&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2972&quot;&gt;a&lt;/span&gt;&lt;span data-raw-text=&quot;m&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2973&quot;&gt;m&lt;/span&gt;&lt;span data-raw-text=&quot;i&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2974&quot;&gt;i&lt;/span&gt;&lt;span data-raw-text=&quot;l&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2975&quot;&gt;l&lt;/span&gt;&lt;span data-raw-text=&quot;y&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2976&quot;&gt;y&lt;/span&gt;&lt;span data-raw-text=&quot;)&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2977&quot;&gt;)&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;98&quot; data-index=&quot;2978&quot;&gt; &lt;/span&gt;&lt;span data-raw-text=&quot;由&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2979&quot;&gt;由&lt;/span&gt;&lt;span data-raw-text=&quot;一&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2980&quot;&gt;一&lt;/span&gt;&lt;span data-raw-text=&quot;群&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2981&quot;&gt;群&lt;/span&gt;&lt;span data-raw-text=&quot;靠&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2982&quot;&gt;靠&lt;/span&gt;&lt;span data-raw-text=&quot;谱&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2983&quot;&gt;谱&lt;/span&gt;&lt;span data-raw-text=&quot;的&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2984&quot;&gt;的&lt;/span&gt;&lt;span data-raw-text=&quot;人&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2985&quot;&gt;人&lt;/span&gt;&lt;span data-raw-text=&quot;建&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2986&quot;&gt;建&lt;/span&gt;&lt;span data-raw-text=&quot;立&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2987&quot;&gt;立&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2988&quot;&gt;，&lt;/span&gt;&lt;span data-raw-text=&quot;愿&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2989&quot;&gt;愿&lt;/span&gt;&lt;span data-raw-text=&quot;为&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2990&quot;&gt;为&lt;/span&gt;&lt;span data-raw-text=&quot;P&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2991&quot;&gt;P&lt;/span&gt;&lt;span data-raw-text=&quot;H&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2992&quot;&gt;H&lt;/span&gt;&lt;span data-raw-text=&quot;P&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2993&quot;&gt;P&lt;/span&gt;&lt;span data-raw-text=&quot;e&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2994&quot;&gt;e&lt;/span&gt;&lt;span data-raw-text=&quot;r&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2995&quot;&gt;r&lt;/span&gt;&lt;span data-raw-text=&quot;带&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2996&quot;&gt;带&lt;/span&gt;&lt;span data-raw-text=&quot;来&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2997&quot;&gt;来&lt;/span&gt;&lt;span data-raw-text=&quot;一&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2998&quot;&gt;一&lt;/span&gt;&lt;span data-raw-text=&quot;些&quot; data-textnode-index=&quot;98&quot; data-index=&quot;2999&quot;&gt;些&lt;/span&gt;&lt;span data-raw-text=&quot;值&quot; data-textnode-index=&quot;98&quot; data-index=&quot;3000&quot;&gt;值&lt;/span&gt;&lt;span data-raw-text=&quot;得&quot; data-textnode-index=&quot;98&quot; data-index=&quot;3001&quot;&gt;得&lt;/span&gt;&lt;span data-raw-text=&quot;细&quot; data-textnode-index=&quot;98&quot; data-index=&quot;3002&quot;&gt;细&lt;/span&gt;&lt;span data-raw-text=&quot;细&quot; data-textnode-index=&quot;98&quot; data-index=&quot;3003&quot;&gt;细&lt;/span&gt;&lt;span data-raw-text=&quot;品&quot; data-textnode-index=&quot;98&quot; data-index=&quot;3004&quot;&gt;品&lt;/span&gt;&lt;span data-raw-text=&quot;味&quot; data-textnode-index=&quot;98&quot; data-index=&quot;3005&quot;&gt;味&lt;/span&gt;&lt;span data-raw-text=&quot;的&quot; data-textnode-index=&quot;98&quot; data-index=&quot;3006&quot;&gt;的&lt;/span&gt;&lt;span data-raw-text=&quot;精&quot; data-textnode-index=&quot;98&quot; data-index=&quot;3007&quot;&gt;精&lt;/span&gt;&lt;span data-raw-text=&quot;神&quot; data-textnode-index=&quot;98&quot; data-index=&quot;3008&quot;&gt;神&lt;/span&gt;&lt;span data-raw-text=&quot;食&quot; data-textnode-index=&quot;98&quot; data-index=&quot;3009&quot;&gt;食&lt;/span&gt;&lt;span data-raw-text=&quot;粮&quot; data-textnode-index=&quot;98&quot; data-index=&quot;3010&quot;&gt;粮&lt;/span&gt;&lt;span data-raw-text=&quot;！&quot; data-textnode-index=&quot;98&quot; data-index=&quot;3011&quot;&gt;！&lt;/span&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__3&quot;&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__4&quot;&gt;&lt;span data-raw-text=&quot;饭&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3012&quot;&gt;饭&lt;/span&gt;&lt;span data-raw-text=&quot;米&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3013&quot;&gt;米&lt;/span&gt;&lt;span data-raw-text=&quot;粒&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3014&quot;&gt;粒&lt;/span&gt;&lt;span data-raw-text=&quot;只&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3015&quot;&gt;只&lt;/span&gt;&lt;span data-raw-text=&quot;发&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3016&quot;&gt;发&lt;/span&gt;&lt;span data-raw-text=&quot;原&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3017&quot;&gt;原&lt;/span&gt;&lt;span data-raw-text=&quot;创&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3018&quot;&gt;创&lt;/span&gt;&lt;span data-raw-text=&quot;或&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3019&quot;&gt;或&lt;/span&gt;&lt;span data-raw-text=&quot;授&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3020&quot;&gt;授&lt;/span&gt;&lt;span data-raw-text=&quot;权&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3021&quot;&gt;权&lt;/span&gt;&lt;span data-raw-text=&quot;发&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3022&quot;&gt;发&lt;/span&gt;&lt;span data-raw-text=&quot;表&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3023&quot;&gt;表&lt;/span&gt;&lt;span data-raw-text=&quot;的&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3024&quot;&gt;的&lt;/span&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3025&quot;&gt;文&lt;/span&gt;&lt;span data-raw-text=&quot;章&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3026&quot;&gt;章&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3027&quot;&gt;，&lt;/span&gt;&lt;span data-raw-text=&quot;不&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3028&quot;&gt;不&lt;/span&gt;&lt;span data-raw-text=&quot;转&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3029&quot;&gt;转&lt;/span&gt;&lt;span data-raw-text=&quot;载&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3030&quot;&gt;载&lt;/span&gt;&lt;span data-raw-text=&quot;网&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3031&quot;&gt;网&lt;/span&gt;&lt;span data-raw-text=&quot;上&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3032&quot;&gt;上&lt;/span&gt;&lt;span data-raw-text=&quot;的&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3033&quot;&gt;的&lt;/span&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3034&quot;&gt;文&lt;/span&gt;&lt;span data-raw-text=&quot;章&quot; data-textnode-index=&quot;99&quot; data-index=&quot;3035&quot;&gt;章&lt;/span&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__5&quot;&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__6&quot;&gt;&lt;span data-raw-text=&quot;所&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3036&quot;&gt;所&lt;/span&gt;&lt;span data-raw-text=&quot;发&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3037&quot;&gt;发&lt;/span&gt;&lt;span data-raw-text=&quot;的&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3038&quot;&gt;的&lt;/span&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3039&quot;&gt;文&lt;/span&gt;&lt;span data-raw-text=&quot;章&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3040&quot;&gt;章&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3041&quot;&gt;，&lt;/span&gt;&lt;span data-raw-text=&quot;均&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3042&quot;&gt;均&lt;/span&gt;&lt;span data-raw-text=&quot;可&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3043&quot;&gt;可&lt;/span&gt;&lt;span data-raw-text=&quot;找&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3044&quot;&gt;找&lt;/span&gt;&lt;span data-raw-text=&quot;到&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3045&quot;&gt;到&lt;/span&gt;&lt;span data-raw-text=&quot;原&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3046&quot;&gt;原&lt;/span&gt;&lt;span data-raw-text=&quot;作&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3047&quot;&gt;作&lt;/span&gt;&lt;span data-raw-text=&quot;者&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3048&quot;&gt;者&lt;/span&gt;&lt;span data-raw-text=&quot;进&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3049&quot;&gt;进&lt;/span&gt;&lt;span data-raw-text=&quot;行&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3050&quot;&gt;行&lt;/span&gt;&lt;span data-raw-text=&quot;沟&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3051&quot;&gt;沟&lt;/span&gt;&lt;span data-raw-text=&quot;通&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3052&quot;&gt;通&lt;/span&gt;&lt;span data-raw-text=&quot;。&quot; data-textnode-index=&quot;100&quot; data-index=&quot;3053&quot;&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__7&quot;&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__8&quot;&gt;&lt;span&gt;&lt;span data-raw-text=&quot;也&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3054&quot;&gt;也&lt;/span&gt;&lt;span data-raw-text=&quot;希&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3055&quot;&gt;希&lt;/span&gt;&lt;span data-raw-text=&quot;望&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3056&quot;&gt;望&lt;/span&gt;&lt;span data-raw-text=&quot;各&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3057&quot;&gt;各&lt;/span&gt;&lt;span data-raw-text=&quot;位&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3058&quot;&gt;位&lt;/span&gt;&lt;span data-raw-text=&quot;多&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3059&quot;&gt;多&lt;/span&gt;&lt;span data-raw-text=&quot;多&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3060&quot;&gt;多&lt;/span&gt;&lt;span data-raw-text=&quot;打&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3061&quot;&gt;打&lt;/span&gt;&lt;span data-raw-text=&quot;赏&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3062&quot;&gt;赏&lt;/span&gt;&lt;span data-raw-text=&quot;（&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3063&quot;&gt;（&lt;/span&gt;&lt;span data-raw-text=&quot;算&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3064&quot;&gt;算&lt;/span&gt;&lt;span data-raw-text=&quot;作&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3065&quot;&gt;作&lt;/span&gt;&lt;span data-raw-text=&quot;稿&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3066&quot;&gt;稿&lt;/span&gt;&lt;span data-raw-text=&quot;费&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3067&quot;&gt;费&lt;/span&gt;&lt;span data-raw-text=&quot;给&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3068&quot;&gt;给&lt;/span&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3069&quot;&gt;文&lt;/span&gt;&lt;span data-raw-text=&quot;章&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3070&quot;&gt;章&lt;/span&gt;&lt;span data-raw-text=&quot;作&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3071&quot;&gt;作&lt;/span&gt;&lt;span data-raw-text=&quot;者&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3072&quot;&gt;者&lt;/span&gt;&lt;span data-raw-text=&quot;）&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3073&quot;&gt;）&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3074&quot;&gt;，&lt;/span&gt;&lt;span data-raw-text=&quot;更&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3075&quot;&gt;更&lt;/span&gt;&lt;span data-raw-text=&quot;希&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3076&quot;&gt;希&lt;/span&gt;&lt;span data-raw-text=&quot;望&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3077&quot;&gt;望&lt;/span&gt;&lt;span data-raw-text=&quot;大&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3078&quot;&gt;大&lt;/span&gt;&lt;span data-raw-text=&quot;家&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3079&quot;&gt;家&lt;/span&gt;&lt;span data-raw-text=&quot;多&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3080&quot;&gt;多&lt;/span&gt;&lt;span data-raw-text=&quot;多&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3081&quot;&gt;多&lt;/span&gt;&lt;span data-raw-text=&quot;投&quot; data-textnode-index=&quot;101&quot; data-index=&quot;3082&quot;&gt;投&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;稿&quot; data-textnode-index=&quot;102&quot; data-index=&quot;3083&quot;&gt;稿&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__9&quot;&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__10&quot;&gt;&lt;span data-raw-text=&quot;投&quot; data-textnode-index=&quot;104&quot; data-index=&quot;3085&quot;&gt;投&lt;/span&gt;&lt;span data-raw-text=&quot;稿&quot; data-textnode-index=&quot;104&quot; data-index=&quot;3086&quot;&gt;稿&lt;/span&gt;&lt;span data-raw-text=&quot;请&quot; data-textnode-index=&quot;104&quot; data-index=&quot;3087&quot;&gt;请&lt;/span&gt;&lt;span data-raw-text=&quot;联&quot; data-textnode-index=&quot;104&quot; data-index=&quot;3088&quot;&gt;联&lt;/span&gt;&lt;span data-raw-text=&quot;系&quot; data-textnode-index=&quot;104&quot; data-index=&quot;3089&quot;&gt;系&lt;/span&gt;&lt;span data-raw-text=&quot;：&quot; data-textnode-index=&quot;104&quot; data-index=&quot;3090&quot;&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__11&quot;&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__12&quot;&gt;&lt;span data-raw-text=&quot;s&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3091&quot;&gt;s&lt;/span&gt;&lt;span data-raw-text=&quot;h&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3092&quot;&gt;h&lt;/span&gt;&lt;span data-raw-text=&quot;e&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3093&quot;&gt;e&lt;/span&gt;&lt;span data-raw-text=&quot;n&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3094&quot;&gt;n&lt;/span&gt;&lt;span data-raw-text=&quot;z&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3095&quot;&gt;z&lt;/span&gt;&lt;span data-raw-text=&quot;h&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3096&quot;&gt;h&lt;/span&gt;&lt;span data-raw-text=&quot;e&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3097&quot;&gt;e&lt;/span&gt;&lt;span data-raw-text=&quot;1&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3098&quot;&gt;1&lt;/span&gt;&lt;span data-raw-text=&quot;6&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3099&quot;&gt;6&lt;/span&gt;&lt;span data-raw-text=&quot;3&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3100&quot;&gt;3&lt;/span&gt;&lt;span data-raw-text=&quot;@&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3101&quot;&gt;@&lt;/span&gt;&lt;span data-raw-text=&quot;g&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3102&quot;&gt;g&lt;/span&gt;&lt;span data-raw-text=&quot;m&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3103&quot;&gt;m&lt;/span&gt;&lt;span data-raw-text=&quot;a&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3104&quot;&gt;a&lt;/span&gt;&lt;span data-raw-text=&quot;i&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3105&quot;&gt;i&lt;/span&gt;&lt;span data-raw-text=&quot;l&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3106&quot;&gt;l&lt;/span&gt;&lt;span data-raw-text=&quot;.&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3107&quot;&gt;.&lt;/span&gt;&lt;span data-raw-text=&quot;c&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3108&quot;&gt;c&lt;/span&gt;&lt;span data-raw-text=&quot;o&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3109&quot;&gt;o&lt;/span&gt;&lt;span data-raw-text=&quot;m&quot; data-textnode-index=&quot;105&quot; data-index=&quot;3110&quot;&gt;m&lt;/span&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__13&quot;&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__14&quot;&gt;&lt;span data-raw-text=&quot;本&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3111&quot;&gt;本&lt;/span&gt;&lt;span data-raw-text=&quot;文&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3112&quot;&gt;文&lt;/span&gt;&lt;span data-raw-text=&quot;由&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3113&quot;&gt;由&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;106&quot; data-index=&quot;3114&quot;&gt;&lt;span&gt;&lt;span&gt; &lt;span&gt;码农的荒岛求生&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span data-raw-text=&quot;授&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3119&quot;&gt;授&lt;/span&gt;&lt;span data-raw-text=&quot;权&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3120&quot;&gt;权&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;106&quot; data-index=&quot;3121&quot;&gt; &lt;/span&gt;&lt;span data-raw-text=&quot;饭&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3122&quot;&gt;饭&lt;/span&gt;&lt;span data-raw-text=&quot;米&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3123&quot;&gt;米&lt;/span&gt;&lt;span data-raw-text=&quot;粒&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3124&quot;&gt;粒&lt;/span&gt;&lt;span data-raw-text=&quot; &quot; data-textnode-index=&quot;106&quot; data-index=&quot;3125&quot;&gt; &lt;/span&gt;&lt;span data-raw-text=&quot;发&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3126&quot;&gt;发&lt;/span&gt;&lt;span data-raw-text=&quot;布&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3127&quot;&gt;布&lt;/span&gt;&lt;span data-raw-text=&quot;，&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3128&quot;&gt;，&lt;/span&gt;&lt;span data-raw-text=&quot;转&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3129&quot;&gt;转&lt;/span&gt;&lt;span data-raw-text=&quot;载&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3130&quot;&gt;载&lt;/span&gt;&lt;span data-raw-text=&quot;请&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3131&quot;&gt;请&lt;/span&gt;&lt;span data-raw-text=&quot;注&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3132&quot;&gt;注&lt;/span&gt;&lt;span data-raw-text=&quot;明&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3133&quot;&gt;明&lt;/span&gt;&lt;span data-raw-text=&quot;本&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3134&quot;&gt;本&lt;/span&gt;&lt;span data-raw-text=&quot;来&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3135&quot;&gt;来&lt;/span&gt;&lt;span data-raw-text=&quot;源&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3136&quot;&gt;源&lt;/span&gt;&lt;span data-raw-text=&quot;信&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3137&quot;&gt;信&lt;/span&gt;&lt;span data-raw-text=&quot;息&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3138&quot;&gt;息&lt;/span&gt;&lt;span data-raw-text=&quot;和&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3139&quot;&gt;和&lt;/span&gt;&lt;span data-raw-text=&quot;以&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3140&quot;&gt;以&lt;/span&gt;&lt;span data-raw-text=&quot;下&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3141&quot;&gt;下&lt;/span&gt;&lt;span data-raw-text=&quot;的&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3142&quot;&gt;的&lt;/span&gt;&lt;span data-raw-text=&quot;二&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3143&quot;&gt;二&lt;/span&gt;&lt;span data-raw-text=&quot;维&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3144&quot;&gt;维&lt;/span&gt;&lt;span data-raw-text=&quot;码&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3145&quot;&gt;码&lt;/span&gt;&lt;span data-raw-text=&quot;（&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3146&quot;&gt;（&lt;/span&gt;&lt;span data-raw-text=&quot;长&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3147&quot;&gt;长&lt;/span&gt;&lt;span data-raw-text=&quot;按&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3148&quot;&gt;按&lt;/span&gt;&lt;span data-raw-text=&quot;可&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3149&quot;&gt;可&lt;/span&gt;&lt;span data-raw-text=&quot;识&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3150&quot;&gt;识&lt;/span&gt;&lt;span data-raw-text=&quot;别&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3151&quot;&gt;别&lt;/span&gt;&lt;span data-raw-text=&quot;二&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3152&quot;&gt;二&lt;/span&gt;&lt;span data-raw-text=&quot;维&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3153&quot;&gt;维&lt;/span&gt;&lt;span data-raw-text=&quot;码&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3154&quot;&gt;码&lt;/span&gt;&lt;span data-raw-text=&quot;关&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3155&quot;&gt;关&lt;/span&gt;&lt;span data-raw-text=&quot;注&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3156&quot;&gt;注&lt;/span&gt;&lt;span data-raw-text=&quot;）&quot; data-textnode-index=&quot;106&quot; data-index=&quot;3157&quot;&gt;）&lt;/span&gt;&lt;/p&gt;&lt;p data-style=&quot;color: rgb(53, 53, 53); font-size: 14px; text-align: start; white-space: normal; max-width: 100%; min-height: 1em; font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__15&quot;&gt;&lt;span&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/LHDiahSVnXhunbEtuowcI7kF5kmUaeTrszibibQ3st6OU8hy2CoIotHHLxicicibyF1qkNI7HibXYHXGN6hRby4ZyjR6A/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b85161d01b8ca15003b5af1937998291</guid>
<title>漫谈分布式系统（二十三）：分布式数据仓库</title>
<link>https://toutiao.io/k/lk48kxt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;这是《漫谈分布式系统》系列的第 23 篇，预计会写 30 篇左右。扫描文末二维码，关注公众号，听我娓娓道来。也欢迎转发朋友圈分享给更多人。&lt;/span&gt;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86318&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;分布式数据库&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n3&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;前面几篇讲 SQL 的文章，大量提到了 Hive。作为 SQL on Hadoop 的初代领军者，Hive 大大降低了使用分布式系统处理海量数据的学习和使用成本，同时提供了一些性能优化的手段。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n4&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n5&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;但这并不是 Hive 的全部，它还有一个甚至更加重要的功能和职责，也就是我们这篇要重点聊的，作为数据库，甚至是数据仓库的核心。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n6&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n7&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;作为数据库自不用多说，虽然 SQL 也能用来分析自描述性的文件，但更多还是用来操作数据库。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n8&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;464&quot; data-ratio=&quot;0.7291897891231964&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GXjTj2xclXgsQ8hOBgjzNs1f2QHQ5EwxlR9MfjPoZZiaR0KSicKDYQwiaLlKP2d7mtBxOt9gw2JQia3Yy4KNBjtfPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1802&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n8&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n9&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;从上面这张 Hive 的架构图也很容易看出，Hive 提供了完整的元数据存储和管理功能，使得我们可以像操作传统关系数据库那样处理数据，并且得到的是一个分布式的数据库，不用再引入各种中间件去做分库分表。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n10&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n11&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;常规的 DDL、DML 操作，库、表、分区、桶等不同层次的数据规划等等，大家都非常熟悉了，这里不再赘述。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n12&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h3 cid=&quot;n13&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;/&gt;&lt;/h3&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86318&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;分布式数据仓库&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n15&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在数据量膨胀、业务复杂度升级、参与人员扩张后，单纯技术上的数据库已经不再能满足人们的需求。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n16&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n17&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;大量的数据冗余和作业冗余产生，大量的业务歧义无法统一，大量的数据孤岛丛生。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n18&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n19&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;数据的规范化变得迫在眉睫。过去几十年，在关系数据库领域，已经从实践中总结出了一套数据仓库的方法论，来指导企业数据的建设。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n20&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n21&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;和前面文章提到的各种 Join 算法一样，在分布式的场景下，只要依葫芦画瓢，就能用来建设分布式数据仓库。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n22&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n23&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;而基于 Hive 提供的分布式数据库能力去建设数据仓库，也成了大数据领域的主流。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n155&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n157&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;即使是分布式数仓，在技术上也并没有体现出多少和传统数仓的区别，分布式更多体现在更底层。不过我们还是简单梳理下数仓的要点。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n24&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n52&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;最经典的数据仓库模型有两种：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n63&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n66&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;顾名思义，两种模型各有特点：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n72&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n133&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;这两种模型没有绝对的优劣，对不同的业务场景而言，会有不同的选择。甚至还诞生了所谓混合模型（Hybrid Model），综合了各个模型的特点。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n135&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n74&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;对典型的互联网业务而言，更加追求业务上的敏捷度，以适应市场的快速变化，因此，维度模型得到了更加广泛的应用。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n64&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n76&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;而根据维度组合方式的不同，维度模型又分为两种：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n28&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n137&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;这两种方式，望文即能生义，当维度复杂、体现出层次时，可以考虑雪花模型，否则，星型模型足以。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n139&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n141&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在数仓的实践中，为了更好的整理和使用数据，又会做横向和纵向切分：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n152&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n153&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;横向划域的方法，没有定论，全看各家业务，复杂的多分细分，简单的就怎么简单怎么来。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n159&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n161&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;纵向分层的方法，各有实践，但大体有固定套路。以数据中台的首倡阿里巴巴为例，可以看到，数据流向和聚合粒度是比较清晰的。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n161&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6209279368213229&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GXjTj2xclXj6uTEjF4LGGqc3ic8egKnl4oea030kCnSjOs28J1n981O0NY4zoFms6PwvYO3wSLciaII3jqAMiawog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2026&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n29&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在数仓架构设计完后，要保证顺利落地，还需要在流程规范和配套工具有足够的限制和支持。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n167&quot; mdtype=&quot;list&quot; data-mark=&quot;+&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n170&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;流程上，需要明确设计-审核-上线的阶段，尽早发现处理问题，避免污染，&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n174&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;规范上，需要定义清楚一些指导性的实践要求，如词根定义、主题定义、表命名规范、指标命名规范等，&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n171&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;配套工具方面，最好有专门的系统固化流程规范，否则很难有执行力。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n30&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n177&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;按照上述的模型和规范，就能得到一个基于 Hive 的分布式数据仓库。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n179&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h3 cid=&quot;n31&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;/&gt;&lt;/h3&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86318&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;实时数据仓库&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n46&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;上面提到的数据仓库，都是所谓离线数据仓库，需要经过漫长的数据处理流程，才能拿到更新的数据。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n84&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n86&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;对于一些对实时性要求比较高的场景，就显得不够用了。这个时候就需要实时/流式数仓了。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n96&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n98&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;流处理是个很宽泛的话题，我们后面会专门讲。这里只简单介绍下和数仓有关的部分。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n100&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n102&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;最典型的实时数仓，可以考虑依托 Kafka 这样的消息中间件 + 以 Flink 为代表的流处理引擎去做。和离线数仓的主要区别，是离线的表换成了实时的 topic，这样就能依托消息中间件的能力，提供更加及时的数据更新。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n108&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n110&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;而离线数仓中的层次划分、维度定义、指标定义，以及构建和审核流程等，都可以沿用。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n112&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n114&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;当然，这样带来的就是两套不同的技术架构，也就是数仓这个场景下的所谓 lambda 架构，开发和维护成本是 double 的。关于 lambda 架构，后面我们也会专门讲，先不展开。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n120&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n122&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;不过这里可以提一个折中的改进思路，考虑在计算引擎和 ETL 阶段，以流式数仓为基础，在数据存储上做系统级别的批和流的双写，再结合统一的元数据，就能同时提供流和批的数仓。这块又涉及所谓「流批一体」，我们也放在后续的文章中讨论。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n33&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5292425695110259&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GXjTj2xclXj6uTEjF4LGGqc3ic8egKnl4b0cauCQs3E4NWu3UkpAW5uw0kZvrQ3b8CoYQDAncBcBBRDY8NKmxvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2086&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n187&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n187&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;当然，这只是一个思路，具体做的时候仍然有许多问题要解决。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n187&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n187&quot; mdtype=&quot;paragraph&quot;&gt;&lt;strong&gt;&lt;span md-inline=&quot;plain&quot;&gt;而另一方面，Kafka 虽然也可以通过设置偏移量来访问旧的历史数据，但由于设计上的取舍，其实并不擅长。&lt;/span&gt;&lt;/strong&gt;&lt;span md-inline=&quot;plain&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n187&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n187&quot; mdtype=&quot;paragraph&quot;&gt;所以上面提到的 Kafka topic 替换 Hive table 来建设实时数仓的方式，更适合实时响应类的场景，比如实时 ETL、实时报表等。&lt;/p&gt;&lt;p cid=&quot;n187&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n187&quot; mdtype=&quot;paragraph&quot;&gt;而对于需要大量频繁处理历史数据的场景，比如探索类的 ad-hoc 查询，或者明细数据类的查询，就并不适合了。&lt;/p&gt;&lt;p cid=&quot;n187&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n187&quot; mdtype=&quot;paragraph&quot;&gt;&lt;strong&gt;对于这种场景，可以考虑把 Kafka topic 的数据实时写入到诸如 Clickhouse、Druid 这样的分布式 OLAP 数据库。&lt;/strong&gt;&lt;/p&gt;&lt;p cid=&quot;n187&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n187&quot; mdtype=&quot;paragraph&quot;&gt;大致示意图如下：&lt;/p&gt;&lt;p cid=&quot;n187&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.546234509056244&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/GXjTj2xclXiaEdmticZRSFiaH3Wd3mxYUb6oAbJpD7fUHNU0RqvWq6ia8vH2RZhQpibAPEUpPrzL9hEccv1HGwr1qyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2098&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n185&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86318&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;数据仓库的局限性&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另一个值得一提的趋势，是云原生的数据仓库逐渐流行起来。像 Snowflake 这样的公司，甚至都做到上市了，体量还不小。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p cid=&quot;n34&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;不难看出，数据仓库为了更好的使用数据，在前期建设阶段会有很多规范和限制。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n35&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n36&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;换句话说，是为了读友好而加重了写的负担。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n37&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n38&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;这就限制了数据仓库的适用场景，比如有些探索性的业务，没法事先定义好数据模型，也不愿意早期就投入大量人力和时间成本去做规范化的数仓建设。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n39&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n40&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;&lt;span&gt;可谓「&lt;/span&gt;天&lt;span&gt;下苦数仓久矣」，于是出现了数据湖的概念，也涌现了一些技术和实践。&lt;/span&gt;&lt;span&gt;这个系列的提纲里也已经计划好了，后面会专门写一篇介绍数据湖的文章。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n41&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n189&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在这里，我们需要知道的是，数仓通过规范建设，可以很好用。但数仓也不是银弹，不要指望能解决所有问题。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n191&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p cid=&quot;n193&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;这篇文章就写到这里，基于 Hive 的离线数仓，和基于 Kafka+Flink 的实时数仓，使得我们很容易就能给数仓插上分布式的翅膀，不用再为存储和计算能力操心。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n193&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-category=&quot;引导&quot; data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;原创不易&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;关注/分享/赞赏&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;给我坚持的动力&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;120&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;120&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/GXjTj2xclXgv4Lzq3YZ7xcXiajveiawhR8iafwPDRIc89Jib7TWiaaMYvyWmrVtAk1GLalDicuQalMoEXtliaaP1ibicsCA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>