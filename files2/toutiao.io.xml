<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>d0821c894696406068a8ddb70b3fe678</guid>
<title>著名的 Java 并发编程大师都这么说了，你还不知道伪共享么</title>
<link>https://toutiao.io/k/3q7ujrr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;&lt;strong&gt;本文首发于公众号【看点代码再上班】，欢迎围观，第一时间获取最新文章。&lt;/strong&gt;
记得关注我，订阅更多好文！&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;全文共计2163字18图，预计阅读时间13分钟&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;大家好，我是tin，这是我的第7篇原创文章
&lt;img src=&quot;https://135editor.cdn.bcebos.com/files/users/969/9695546/202102/0w55IaOhs_2BkC.jpeg&quot; alt=&quot;WechatIMG43.jpeg&quot;/&gt;
图拍摄于深圳桃园南山图书馆，年前某个阳光明媚的周六，看到挂满的灯笼，觉得甚是喜庆。文章较长，先上一个目录：上个全文目录：&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;一、Doug lea&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在微博上看到这么一句话，挺有意思的。
&lt;img src=&quot;https://135editor.cdn.bcebos.com/files/users/969/9695546/202102/0qsBhUu5Z_dtVh.png&quot; alt=&quot;image.png&quot;/&gt;
Doug Lea是谁？为什么这么说？估计还真挺多人不认识他吧。&lt;/p&gt;

&lt;p&gt;Doug Lea，中文名为道格·利。java.util.concurrent并发包的作者。说他是这个世界上对Java影响力最大的一个人，一点也不为过。因为两次Java历史上的大变革，他都间接或直接的扮演了举足轻重的角色。2004年所推出的Tiger。Tiger广纳了15项JSRs的语法及标准，其中一项便是JSR-166。JSR-166是来自于Doug编写的util.concurrent包，主要是关于J.U.C的技术规范。&lt;/p&gt;

&lt;p&gt;上文摘抄自百度百科：
&lt;img src=&quot;https://135editor.cdn.bcebos.com/files/users/969/9695546/202102/xHzVVafB_LxYr.png&quot; alt=&quot;iShot2021-02-13 17.26.26.png&quot;/&gt;
JSRs(Java Specification Requests)，表示Java规范请求，由JCP成员向委员会提交的Java发展议案，经过一系列流程后，如果通过最终会体现在未来的Java中。&lt;/p&gt;

&lt;p&gt;JCP全称Java Community Process ，翻译中文即是：Java社区进程。JCP成立于1998年，官网地址&lt;a href=&quot;https://www.jcp.org%EF%BC%8C%E7%94%B1%E7%A4%BE%E4%BC%9A%E5%90%84%E7%95%8CJava%E7%BB%84%E6%88%90%E7%9A%84%E7%A4%BE%E5%8C%BA%EF%BC%8C%E4%B8%BB%E8%A6%81%E8%A7%84%E5%88%92%E5%92%8C%E9%A2%86%E5%AF%BCJava%E7%9A%84%E5%8F%91%E5%B1%95%E3%80%82&quot;&gt;https://www.jcp.org，由社会各界Java组成的社区，主要规划和领导Java的发展。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、CPU缓存架构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;国内另一位大神，dubbo的创作者，曾经在他的ppt写过这样的一页
&lt;img src=&quot;https://135editor.cdn.bcebos.com/files/users/969/9695546/202102/t9Nq5eZC_BnwJ.png&quot; alt=&quot;image.png&quot;/&gt;
或许有人已经猜到这ppt作者是谁的，有兴趣可自行了解（需要完整ppt也可联系我！）。ppt描述的背后原理就是伪共享问题。&lt;/p&gt;

&lt;p&gt;说起伪共享，还得从cpu的缓存架构说起。
&lt;img src=&quot;https://135editor.cdn.bcebos.com/files/users/969/9695546/202102/0mZZvXf77_f7FL.png&quot; alt=&quot;iShot2021-02-13 13.09.12.png&quot;/&gt;
CPU缓存可以分为一级缓存，二级缓存，三级缓存，每一级缓存中所储存的全部数据都是下一级缓存的一部分。当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。一般来说，每级缓存的命中率大概都在80%左右，也就是说全部数据量的80%都可以在一级缓存中找到，只剩下20%的总数据量才需要从二级缓存、三级缓存或内存中读取。&lt;/p&gt;

&lt;p&gt;越靠近 CPU 的缓存越快也越小。所以 L1 缓存很小但很快，紧接着L2 大一些，也会慢一些，L3更慢，最后到主存，主存保存着程序运行的所有数据，由所有 CPU 核共享。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、CPU缓存行&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;CPU缓存由缓存行组成，缓存行长度为64字节，可以这么认为，缓存行是缓存更新的基本单位。缓存每次更新都从主内存中加载连续的 64 个字节。试想，如果在内存中有两个紧邻的long型变量a和b，当a加载到缓存时，b也可以一起被加载到缓存，下一次如果访问b则可以直接从缓存读取，这对读取的效率提升是非常大的。
&lt;img src=&quot;https://135editor.cdn.bcebos.com/files/users/969/9695546/202102/0BTrdAsJP_KswJ.png&quot; alt=&quot;image.png&quot;/&gt;
但是，正因为缓存都以缓存行为基本单位处理，如果cpu core1修改a变量，core1上包含a变量的缓存行将失效，同时其他core上包含a变量的缓存行也将失效。此时，如果core2要访问和a在同一缓存行上的b变量，会被告知缓存行失效，这时只能到主内存重新加载b变量。&lt;/p&gt;

&lt;p&gt;在《Java并发编程的艺术》一书中，第二章第11页如是说：
&lt;img src=&quot;https://135editor.cdn.bcebos.com/files/users/969/9695546/202102/0eGWQQXNt_tvxe.jpeg&quot; alt=&quot;WechatIMG44.jpeg&quot;/&gt;
Doug lea在jdk7的并发包里面新增一个队列集合类LinkedTransferQueue，它在使用volatie变量时，用一种追加字节的方式来优化队列出队和入队的性能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、伪共享&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;缓存以缓存行为基本单位，当线程修改互相独立的变量时，如果这些变量在同一缓存行中，那么就会互相变量缓存值得有效性，从而影响访问性能，这就是伪共享。&lt;/p&gt;

&lt;p&gt;看一个单元测试源码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.tin.example.falls.sharing;
​
import org.springframework.util.StopWatch;
​
/**
 * title: AutoIncrement
 * &amp;lt;p&amp;gt;
 * description: 多线程环境下，long变量自增
 *
 * @author tin @看点代码再上班 on 2021/2/17 下午1:28
 */
public class AutoIncrement {
​
 public static void main(String[] args) throws InterruptedException {
 StopWatch stopWatch = new StopWatch(&quot;@看点代码再上班&quot;);
 stopWatch.start();
 System.out.println(&quot;====== start to iterate ======&quot;);
 autoIncrement(new LongNumber());
​
 stopWatch.stop();
 System.out.println(&quot;cost &quot; + stopWatch.getTotalTimeMillis() + &quot;ms&quot;);
 }
​
 private static void autoIncrement(LongNumber longNumber) throws InterruptedException {
 Thread t1 = new Thread(() -&amp;gt; {
 for (int i = 0; i &amp;lt; 100000000; i++) {
 longNumber.n1++;
 }
 });
​
 Thread t2 = new Thread(() -&amp;gt; {
 for (int i = 0; i &amp;lt; 100000000; i++) {
 longNumber.n2++;
 }
 });
​
 t1.start();
 t2.start();
 t1.join();
 t2.join();
 }
​
 static class LongNumber {
//        @sun.misc.Contended
 volatile long n1;
 volatile long n2;
 }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当我启用两个线程，分别自增1亿次n1和n2时，耗时大约3000+ms
&lt;img src=&quot;https://135editor.cdn.bcebos.com/files/users/969/9695546/202102/qqAnrAud_XbEx.png&quot; alt=&quot;image.png&quot;/&gt;
当我在n1字段加上注解@sun.misc.Contended，重新跑程序，耗时变为800+ms
&lt;img src=&quot;https://135editor.cdn.bcebos.com/files/users/969/9695546/202102/JwcsVnGd_2krY.png&quot; alt=&quot;image.png&quot;/&gt;
@sun.misc.Contended注解在Java 8后新增，其用来进行缓存行填充。它可以用于类级别的修饰，同时也可以用于字段级别的修饰，当应用于字段级别时，被注释的字段将和其他字段隔离开来，会被加载在独立的缓存行上。&lt;/p&gt;

&lt;p&gt;@sun.misc.Contended注解和上文ppt中提及的追加字节效果是等同的（注解要生效需在启动参数上加-XX:-RestrictContended）。除了加注解，如果在n1和n2中间增加16个对象引用也同样起到作用（一个对象引用4个字节）。&lt;/p&gt;

&lt;p&gt;我们要看一个对象所占的字节数大小怎么看？分享一个好东西，引用下面的包依赖：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;lt;dependency&amp;gt;
 &amp;lt;groupId&amp;gt;org.openjdk.jol&amp;lt;/groupId&amp;gt;
 &amp;lt;artifactId&amp;gt;jol-core&amp;lt;/artifactId&amp;gt;
 &amp;lt;version&amp;gt;0.9&amp;lt;/version&amp;gt;
 &amp;lt;/dependency&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;代码中显式打印对象即可：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ClassLayout.parseInstance(obj).toPrintable()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到打印出来的结果：
&lt;img src=&quot;https://135editor.cdn.bcebos.com/files/users/969/9695546/202102/0v5mCNnpj_Th8P.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;五、结语&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我是tin，一个在努力让自己变得更优秀的普通攻城狮。自己阅历有限、学识浅薄，如有发现文章不妥之处，非常欢迎加我提出，我一定细心推敲加以修改。&lt;/p&gt;

&lt;p&gt;看到这里请安排个点赞再走吧，坚持原创不容易，你的正反馈是我坚持输出的最强大动力，谢谢啦！
&lt;img src=&quot;https://135editor.cdn.bcebos.com/files/users/969/9695546/202012/J4GcAzne_sx7V.gif&quot; alt=&quot;20190911181805AMQR5B8FDFDAXGLA.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;别忘了关注我哦！⏬⏬⏬&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7ed7b11627955ba3186f1c2d833a5c9a</guid>
<title>Java 8 为什么需要引入新的日期和时间库</title>
<link>https://toutiao.io/k/4bii1m0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Java8为什么需要引入新的日期和时间库&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Date日期输出可读性较差&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Date date = new Date();&lt;br/&gt;System.out.println(date);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打印输出的结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Sat Nov 14 11:03:41 CST 2020&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Date日期的解析、格式化通过JDK自带的api实现较为麻烦，通常会使用第三方的日期时间库，比如：&lt;code&gt;joda-time&lt;/code&gt;, &lt;code&gt;commons-lang&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Java8中提供了哪些日期和时间类&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java.time包中提供了很多新的类，通常主要使用到的是&lt;code&gt;LocalDate&lt;/code&gt;, &lt;code&gt;LocalTime&lt;/code&gt;, &lt;code&gt;LocalDateTime&lt;/code&gt;, &lt;code&gt;ZoneId&lt;/code&gt;, &lt;code&gt;ZoneDateTime&lt;/code&gt;; 关系图如下：&lt;img data-ratio=&quot;0.48&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zGicfclm6Zzicicyic1PgJWokjcSP2PBT76a5doFXlxIZPngqic3QEkWibjsWAAUcIOnTnpUCh7QbkYFYrSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LocaDate这个类本身不包含时间和时区信息，只包含了日期信息；提供了很多方法来获取常用的值：星期几，几月 ...&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的静态构造&lt;code&gt;LocaDate&lt;/code&gt;方法&lt;code&gt;LocalDate.of(2020, 11, 14); //指定年月日 LocalDate.of(2020, Month.NOVEMBER, 14); //指定年月日 使用Month枚举类 LocalDate.ofYearDay(2020, 10); //2020年第10天 =&amp;gt; 2020-01-10 LocalDate.now(); //当前时间 System.out.println(LocalDate.now()); // 比较好的可读性输出 =&amp;gt; 2020-11-14&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;LocaDate&lt;/code&gt;常用实例方法&lt;code&gt;LocalDate now = LocalDate.of(2020, 11, 14); System.out.println(now.getMonth()); //月份的枚举 =&amp;gt; NOVEMBER System.out.println(now.getMonthValue()); //月份的数字 =&amp;gt; 11 System.out.println(now.getDayOfMonth()); //几号 =&amp;gt; 14 System.out.println(now.getDayOfYear()); // 一年中的第几天 =&amp;gt; 319 System.out.println(now.getDayOfWeek()); // 周几枚举 =&amp;gt; SATURDAY System.out.println(now.lengthOfMonth()); //本月多少天 =&amp;gt; 30 System.out.println(now.lengthOfYear()); //本年多少天 =&amp;gt; 366&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;LocalTime.of(12, 9, 10); //时、分、秒&lt;br/&gt;LocalTime.now();&lt;br/&gt;LocalTime time = LocalTime.of(12, 9, 10);&lt;br/&gt;System.out.println(time.getHour());&lt;br/&gt;System.out.println(time.getMinute());&lt;br/&gt;System.out.println(time.getSecond());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LocalDateTime 从这个类的名字可以看出是合并了&lt;code&gt;LocalDate&lt;/code&gt;, &lt;code&gt;LocalTime&lt;/code&gt;，只包含日期和时间，不包含时区信息
构造的方式，可以直接使用静态方法创建，也可以通过&lt;code&gt;LocalDate&lt;/code&gt;，&lt;code&gt;LocalTime&lt;/code&gt;合并&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;LocalDateTime.of(LocalDate.now(), LocalTime.now());&lt;br/&gt;LocalDateTime.of(2020, 11, 14, 13, 10, 50);&lt;br/&gt;LocalDate.now().atTime(LocalTime.now());&lt;br/&gt;LocalTime.now().atDate(LocalDate.now());&lt;br/&gt;LocalDateTime.now();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于&lt;code&gt;LocalDateTime&lt;/code&gt;是&lt;code&gt;LocalDate&lt;/code&gt;, &lt;code&gt;LocalTime&lt;/code&gt;的合并，所以&lt;code&gt;LocalDate&lt;/code&gt;, &lt;code&gt;LocalTime&lt;/code&gt;有的实例方法，基本在&lt;code&gt;LocalDateTime&lt;/code&gt;中都可以找到&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ZoneId 用来替代老版本&lt;code&gt;TimeZone&lt;/code&gt;, 每个&lt;code&gt;ZoneId&lt;/code&gt;都有一个特定的地区标识;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  ZoneId.of(&lt;span&gt;&quot;Asia/Shanghai&quot;&lt;/span&gt;);&lt;br/&gt;  ZoneId.systemDefault()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看所有的地区标识可以进入到&lt;code&gt;ZoneId&lt;/code&gt;源码&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ZoneDateTime带有日期、时间、时区信息，是&lt;code&gt;LocalDateTime&lt;/code&gt;和&lt;code&gt;ZoneId&lt;/code&gt;的组合&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ZonedDateTime zonedDateTime = ZonedDateTime.of(LocalDateTime.now(), ZoneId.systemDefault());&lt;br/&gt;ZonedDateTime.of(LocalDate.now(),LocalTime.now(),ZoneId.of(&lt;span&gt;&quot;Asia/Shanghai&quot;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经常我们会遇到需要求两个时间之间相差的时间, 如何实现呢？Java8也提供给了相应的API支持， &lt;code&gt;Duration&lt;/code&gt;、&lt;code&gt;Period&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Duration between = Duration.between(LocalTime.of(13, 0), LocalTime.of(14, 0)); &lt;br/&gt;between.getSeconds(); //返回两个时间相差的秒数 =&amp;gt; 3600&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Duration&lt;/code&gt;是通过秒和毫秒来记录时间的长短，所以只能处理两个&lt;code&gt;LocalTime&lt;/code&gt;, &lt;code&gt;DateLocalTime&lt;/code&gt;, &lt;code&gt;ZonedDateTime&lt;/code&gt;; 如果传入的是&lt;code&gt;LocalDate&lt;/code&gt;，将会抛出异常&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java.time.temporal.UnsupportedTemporalTypeException: Unsupported unit: Seconds&lt;br/&gt;&lt;br/&gt; at java.time.LocalDate.until(LocalDate.java:1614)&lt;br/&gt; at java.time.Duration.between(Duration.java:475)&lt;br/&gt; at com.haixue.crm.stock.service.LocalTest.testDate(LocalTest.java:121)&lt;br/&gt; at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)&lt;br/&gt; at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)&lt;br/&gt; at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)&lt;br/&gt; at java.lang.reflect.Method.invoke(Method.java:498)&lt;br/&gt; at org.junit.runners.model.FrameworkMethod&lt;span&gt;$1&lt;/span&gt;.runReflectiveCall(FrameworkMethod.java:50)&lt;br/&gt; at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)&lt;br/&gt; at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)&lt;br/&gt; at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)&lt;br/&gt; at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)&lt;br/&gt; at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)&lt;br/&gt; at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)&lt;br/&gt; at org.junit.runners.ParentRunner&lt;span&gt;$3&lt;/span&gt;.run(ParentRunner.java:290)&lt;br/&gt; at org.junit.runners.ParentRunner&lt;span&gt;$1&lt;/span&gt;.schedule(ParentRunner.java:71)&lt;br/&gt; at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)&lt;br/&gt; at org.junit.runners.ParentRunner.access&lt;span&gt;$000&lt;/span&gt;(ParentRunner.java:58)&lt;br/&gt; at org.junit.runners.ParentRunner&lt;span&gt;$2&lt;/span&gt;.evaluate(ParentRunner.java:268)&lt;br/&gt; at org.junit.runners.ParentRunner.run(ParentRunner.java:363)&lt;br/&gt; at org.junit.runner.JUnitCore.run(JUnitCore.java:137)&lt;br/&gt; at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)&lt;br/&gt; at com.intellij.rt.execution.junit.IdeaTestRunner&lt;span&gt;$Repeater&lt;/span&gt;.startRunnerWithArgs(IdeaTestRunner.java:47)&lt;br/&gt; at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:242)&lt;br/&gt; at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:70)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这种情况下就可以使用&lt;code&gt;Period&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Period between1 = Period.between(LocalDate.of(2020, 11, 13), LocalDate.of(2020, 11, 13));&lt;br/&gt;between1.getDays();  //返回相差的天数 =&amp;gt; 1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;时间日期的更高级的操作&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;以为对时间日期的修改增加减少都是通过第三方依赖包操作，现在原生API已经支持&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;LocalDate now2 = LocalDate.of(2020, 11, 13);&lt;br/&gt;System.out.println(now2.plusDays(2));       //加2天   =&amp;gt; 2020-11-15&lt;br/&gt;System.out.println(now2.plusMonths(1));     //加1月   =&amp;gt; 2020-12-13&lt;br/&gt;System.out.println(now2.plusWeeks(1));      //加一周   =&amp;gt; 2020-11-20&lt;br/&gt;System.out.println(now2.minusDays(1));      //减一天   =&amp;gt; 2020-11-12&lt;br/&gt;System.out.println(now2.minusMonths(1));    //减一月   =&amp;gt; 2020-10-13&lt;br/&gt;System.out.println(now2.minusYears(1));     //减一年   =&amp;gt; 2019-11-13&lt;br/&gt;System.out.println(now2.withYear(2021));    //修改年   =&amp;gt; 2021-11-13&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;有时候我们会遇到需要取本月的最后一天、本月的第一天、调整日期到下一个周日... ;这些需求也能够通过使用&lt;code&gt;TemporalAdjuster&lt;/code&gt;很好的实现，&lt;code&gt;TemporalAdjuster&lt;/code&gt; 能够实现很多定制化的日期操作，Java8在&lt;code&gt;TemporalAdjusters&lt;/code&gt;已经给提供了默认的很多实现。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;LocalDate now3 = LocalDate.of(2020, 11, 13);&lt;br/&gt;System.out.println(now3.with(TemporalAdjusters.firstDayOfYear())); // 本年的第一天 =&amp;gt; 2020-01-01&lt;br/&gt;System.out.println(now3.with(TemporalAdjusters.next(DayOfWeek.MONDAY))); //下一个周一 =&amp;gt; 2020-11-16&lt;br/&gt;System.out.println(now3.with(TemporalAdjusters.lastDayOfMonth())); // 本月的最后一天 =&amp;gt; 2020-11-30&lt;br/&gt;System.out.println(now3.with(TemporalAdjusters.lastDayOfYear())); // 本年的最后一天 =&amp;gt; 2020-12-31&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;自定义&lt;code&gt;TemporalAdjuster&lt;/code&gt;实现获取当天的开始时间和当天的最后时间&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;LocalDateTime localDateTime = LocalDateTime.of(2020, 11, 13, 10, 10, 10);&lt;br/&gt;System.out.println(localDateTime);&lt;br/&gt;System.out.println(localDateTime.with((temporal) -&amp;gt; &lt;br/&gt;    temporal.with(ChronoField.SECOND_OF_DAY, 0))); // 当天的凌晨 =&amp;gt; 2020-11-13T00:00&lt;br/&gt;System.out.println(localDateTime.with((temporal) -&amp;gt;&lt;br/&gt;    temporal.with(ChronoField.SECOND_OF_DAY, temporal.range(ChronoField.SECOND_OF_DAY).getMaximum()))); // 当天的最后一刻时间 =&amp;gt; 2020-11-13T23:59:59&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;解析、格式化&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对日期的字符串解析和格式化的操作是常用的，首先看下不用第三方包如何简单的实现日期解析&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;System.out.println(LocalDateTime.parse(&lt;span&gt;&quot;2020-11-14T20:50:00&quot;&lt;/span&gt;)); // 输出：2020-11-14T20:50&lt;br/&gt;System.out.println(LocalDateTime.parse(&lt;span&gt;&quot;2020/11/14 20:50:00&quot;&lt;/span&gt;,&lt;br/&gt;        DateTimeFormatter.ofPattern(&lt;span&gt;&quot;yyyy/MM/dd HH:mm:ss&quot;&lt;/span&gt;))); // 输出：2020-11-14T20:50&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现格式化同样也简单&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;LocalDate now4 = LocalDate.of(2020, 11, 13);&lt;br/&gt;System.out.println(now4.format(DateTimeFormatter.ofPattern(&lt;span&gt;&quot;yyyy/MM/dd&quot;&lt;/span&gt;))); //输出：2020/11/13&lt;br/&gt;&lt;br/&gt;LocalDateTime localDateTime2 = LocalDateTime.of(2020, 11, 13, 10, 10, 10);&lt;br/&gt;System.out.println(localDateTime2.format(DateTimeFormatter.ofPattern(&lt;span&gt;&quot;yyyy/MM/dd HH:mm:ss&quot;&lt;/span&gt;))); //输出：2020/11/13 10:10:10&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>029bf7760f7f6338f8a7338281eefa77</guid>
<title>身份认证之双因素认证 2FA</title>
<link>https://toutiao.io/k/4sfxuxd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img data-ratio=&quot;0.4255555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybw7l7PVNNr7rzJcpwA9bNQCbgMd0YUHWP5kKRjiaaML5DyibzChE0Z0LQs7dVibFHNowjorlCcVAN8Lw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h2&gt;身份认证&lt;/h2&gt;&lt;p&gt;这里所说的身份认证，指的是狭义上的在计算机及其网络系统中确认操作者身份的过程，从而确定用户是否具有访问或操作某种资源的权限。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybw7l7PVNNr7rzJcpwA9bNQCxHgtZvq6MUX9uFe4RFE0rNvNy4SkCls94hqgY9icJxEFaavqfgnSYWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;之所以要在互联网中进行身份认证，是为了防止攻击者假冒你的身份在系统中进行不利于你的操作。试想一下，万一哪天早晨起来你发现你的支付宝账号被盗了，你余额宝里的钱全没了，那岂不是亏大了。&lt;/p&gt;&lt;p&gt;只不过，和现实世界不同的是，网络世界中一切信息都是用一组特定的数据来表示的，计算机只能识别用户的数字身份，所以&lt;strong&gt;对用户的授权本质上就是针对用户数字身份的授权&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;因此，如何保证操作者的物理身份和数字身份相对应，就成了一个至关重要的议题了，身份认证也因此在互联网世界中起着举足轻重的作用了。本文将会介绍目前很多网站常用的一种方式——双因素认证（也叫两步验证，英语：Two-factor authentication，缩写为 2FA）。&lt;/p&gt;&lt;h2&gt;双因素认证 2FA&lt;/h2&gt;&lt;p&gt;虽然网络世界和真实世界对于身份的表示不尽相同，但是对于身份认证的手段与经验是可以相互借鉴的。在真实世界，对用户的身份认证基本依据可以分为这三种：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4098883572567783&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybw7l7PVNNr7rzJcpwA9bNQC41sSr8atqWfVmpwkJOVyiawYG09jCaYgWxDQIzRLybkZYJWDqTIdeSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1254&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;上述三种认证依据被称为三种「因素」（factor）。因素越多，证明力就越强，身份就越可靠。&lt;/p&gt;&lt;p&gt;因此，在网络世界中，为了达到更高的身份认证安全性，某些场景会将上面 3 种挑选 2 种混合使用，即双因素认证。&lt;/p&gt;&lt;p&gt;在支付宝还没有在中华大地普及的时候，去银行通常需要准备一个叫「U 盾」的东西，在使用网上银行时，用户需要先插上 U 盾，然后再输入密码才能登录网上银行。在这一操作中，U 盾（you have）+密码（you know）这两种因素组合在一起就构成了一个双因素认证。&lt;/p&gt;&lt;p&gt;只是后来，随着移动互联网的普及，手机渐渐成为最离不开人身边的物品了，于是传统的「U 盾+密码」的组合方案就被「手机+密码」的组合替代了。&lt;/p&gt;&lt;p&gt;现如今，短信验证码在国内已经成为使用最广泛的两步验证方法之一了，虽然操作方便，不需要安装额外的 APP，但是验证码的下发&lt;strong&gt;依赖网络和运营商信号&lt;/strong&gt;，有被窃听的风险。试想一下，如果这种验证码的获取不需要依赖运营商和网络，哪怕手机处于飞行模式也可以获取验证码，那么安全性是不是就得到提升了？&lt;/p&gt;&lt;p&gt;而这也就是下面将要说的 TOTP，即&lt;strong&gt;“基于时间的一次性密码（Time-based One-time Password）”&lt;/strong&gt;。这是目前公认的可靠解决方案，已被纳入国际标准。&lt;/p&gt;&lt;h2&gt;TOTP&lt;/h2&gt;&lt;h3&gt;流程&lt;/h3&gt;&lt;p&gt;TOTP 的流程如下：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;服务器随机生成一个的密钥，并且把这个密钥保存在数据库中。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;服务端将该密钥下发，通常是在页面上显示一个二维码，内容中包含密钥。&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;客户端扫描二维码，把密钥保存在客户端。&lt;/span&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;客户端每 30 秒使用密钥和时间戳通过 TOTP 算法生成一个 6 位数字的一次性密码&lt;/span&gt;&lt;/p&gt;&lt;p&gt;其实利用 TOTP 验证的流程很简单，这里也只是介绍，如果想深入了解 TOTP 算法的具体实现过程，可以参考 👉&lt;span&gt; TOTP: Time-Based One-Time Password Algorithm&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;通过这种方式生成一次性验证码，除去第一次获取服务器下发的密钥外，对网络并无其他要求了，这样即使是在离线情况下也可以使用，而且由于由于这种动态生成的密码通常只会存在 30s，安全性也得到了较大的提升。&lt;/p&gt;&lt;p&gt;只是在实际过程中，肯定要额外考虑一些情况，比如如果有人想要暴力破解验证码时，我们可以对验证的错误次数进行限制；抑或是手机端时间和服务器时间不同步，我们需要通过算法的方式兼容服务器时间的前后 30s，从而有效的避免细微时间上差异而导致的验证失败。&lt;/p&gt;&lt;h3&gt;使用现状&lt;/h3&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.682089552238806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybw7l7PVNNr7rzJcpwA9bNQCiaR3ZbsYVsU8x7vjly1k3Czicia61IZbPMY1VLduOmoakH0fqrt9gQoCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1340&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;目前 TOTP 验证 App 主要分为两类：“独占类”和“开放类”。所谓独占类指的是只支持自家账户登录的两步验证，比如 QQ 安全中心、Steam 验证令牌等。开放类则是一个纯粹的两步验证 App，通过一个 App 去作为多个网站的验证器，例如 &lt;code&gt;Google authenticator&lt;/code&gt; 就是一个开源的基于 TOTP 原理实现的一个生成一次性密码的工具。&lt;/p&gt;&lt;p&gt;Google Play Store 上就有许多第三方的基于 TOTP 原理实现的一次性验证码工具，只是由于国内用户使用习惯的问题，除非在一些特殊场合，例如找回密码时会用到 TOTP 验证外，其他大多数情况还是会使用短信验证码的方式，这也算国内外使用习惯的差异了。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4098073555166375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybw7l7PVNNr7rzJcpwA9bNQCwf5nmGmu6icEopvM6gjvIemm8r9zmAKLrObaEo9zsVYBYqMUWbmBYKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1142&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;总的来说，基于 TOTP 机制的两步验证 APP 有着比短信验证码高得多的安全性和相媲美的便利性，是一种能保障用户财产安全的工具。只是在登录时会多一步，费时且麻烦，可能会引起用户的不适。只是在重要数据面前，还是尽量使用两步验证吧，不然和 AntDesign 一样丢了代码库可就不好了。&lt;/p&gt;&lt;p&gt;以上就是本文的全部内容了，新年已到，想必大家也都已经复工了，在这里祝大家新年快乐，牛年大吉 🐂。如果你觉得我的文章对你有所帮助，还希望在新的一年里可以继续支持「01 二进制」，你们的支持是我更新原创的最大动力！&lt;/p&gt;&lt;h3&gt;References&lt;/h3&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; TOTP: Time-Based One-Time Password Algorithm: &lt;em&gt;https://tools.ietf.org/html/rfc6238&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6654547862f5b8d2a12f5e834a840845</guid>
<title>介绍一个小工具：网络策略可视化编辑器</title>
<link>https://toutiao.io/k/pkdp4sn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2&gt;引子&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;跳过本节不影响阅读&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;既然是牛年第一篇，总要写点废话起个头。另外写小工具系列经常面对的一个难题就是——怎样凑够 300 字的原创门槛。&lt;/p&gt;&lt;p&gt;2020 年有大半年我都在唠叨云原生安全的事情，现在的情况按照我的理解，有点像 2000 年附近的互联网——各种东西都在往新瓶子里装，那时候的新瓶子是互联网，现在的新瓶子是云原生；那时候的旧酒是邮件、留言板、传呼机，现在的旧酒除了这些生活内容之外，多了更多的 ToB/G 的内容；从前的较大规模的公开互联网服务多数是自建自维护的，现在的公开服务则往往会用到大量的公有云、SaaS/PaaS 服务以及第三方交付项目。&lt;/p&gt;&lt;p&gt;在 Kubernetes 来说：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;推出了 CKS 认证&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;OPA 毕业&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Kyverno 进入沙箱&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Redhat 收购 StackRox&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;综上，经过轰轰烈烈的云原生运动之后，安全问题就已经被怼到了我们面前，很多时候一些重点服务一旦遭到破坏，虽说安全相关的黑产已经有了成熟的获利链条；然而在责任方来说，的确可以挤出一句——这不是钱的事儿。&lt;/p&gt;&lt;h2&gt;正文&lt;/h2&gt;&lt;p&gt;言归正传，今天要介绍的是一个&lt;strong&gt;安全相关&lt;/strong&gt;的网络策略&lt;strong&gt;小工具&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;网络策略是 Kubernetes 内置的重要安全机制之一，用它可以轻松地使用 Namespace、Label Selector、CIDR 等方式，限制 Pod 的 Ingress/Egress 访问，相对于 RBAC 来说，这东西其实更贴近传统网络策略的限制方式，但是目前应用还较少，也就显得比较难用了。Cilium 推出的这个可视化编辑器，是个很好的入门工具。&lt;/p&gt;&lt;p&gt;缺省界面如图所示：&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;31&quot; data-backw=&quot;61&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;61&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;22&quot; data-ratio=&quot;0.5063613231552163&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mbeSBYZpODzoZotRA1taGPbHwWr3bicmKJ74qWqG5HGpia9SC9M9YBicr1KbZPmNibCuZ94VKW0lN2e6iaYhoLV0ARg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3144&quot;/&gt;&lt;/p&gt;&lt;p&gt;整个界面分为几个部分：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;A：&lt;/p&gt;&lt;p&gt;可视化编辑区：&lt;/p&gt;&lt;p&gt;区域中可以用点选的方式产生不同的 Ingress Egress 规则。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;B：&lt;/p&gt;&lt;p&gt;代码编辑区：&lt;/p&gt;&lt;p&gt;交互式编辑区产生的策略变更都会用 YAML 代码的形式反映在该区域，另外左上角还可以通过上传的方式载入现有 YAML 文件，上传的内容也会反向映射回到可视化编辑区中。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;C：&lt;/p&gt;&lt;p&gt;该区域是教学区域，下拉菜单中包含了几个常用的策略的相关教学，注意这里的是教学，给出的可能是一个待修复的策略和修复方法，不要直接复制使用。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;可视化编辑区分为左中右三个部分：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;1：&lt;/p&gt;&lt;p&gt;这里可以定义策略的主体，例如命名空间、名称、策略对应的管理目标（Pod Selector），另外还可以定义 Ingress 和 Egress 的缺省行为，例如缺省 Deny 或者 Allow，这里可以看到，随着策略的变化，相应的连接线颜色会发生变化。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2：&lt;/p&gt;&lt;p&gt;Ingress 区域，管理进入 Pod 的流量，分为集群外、集群内、本命名空间三种配置方法。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3：&lt;/p&gt;&lt;p&gt;Egress 区域，管理从 Pod 发出的流量，和 Ingress 区域一样，分为三种配置。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;例如新建一个缺省禁止所有其它命名空间访问的策略，只要新建策略，在 1 区点击 &lt;code&gt;Ingress&lt;/code&gt;，将其设为 Default Deny，然后在 2 区点击 &lt;code&gt;In Namespace&lt;/code&gt;，在弹出窗口中选择 &lt;code&gt;Allow from any pod&lt;/code&gt; 即可。最终结果如图所示：&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;42&quot; data-backw=&quot;65&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;65&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;22&quot; data-ratio=&quot;0.6507258753202391&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mbeSBYZpODzoZotRA1taGPbHwWr3bicmKhXxNy1C2UC2MMj9ibhQe8O8Jlv0rE91Sw3HDlGFjH5ibjib4sLt6aadgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2342&quot;/&gt;&lt;/p&gt;&lt;p&gt;除了 All 之外，编辑器还支持 namespaceSelector、podSelector 以及集群外 CIDR 等的源头选择。Egress 策略中也包括对目标端口的设置。&lt;/p&gt;&lt;h2&gt;结论&lt;/h2&gt;&lt;p&gt;这才能叫可视化吧。&lt;/p&gt;&lt;h2&gt;相关链接&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;工具地址：&lt;/p&gt;&lt;p&gt;&lt;code&gt;https://editor.cilium.io/&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Kubernetes Network Policies：&lt;/p&gt;&lt;p&gt;&lt;code&gt;https://kubernetes.io/docs/concepts/services-networking/network-policies/&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1d1d81e1f8ac3798cc1960add6370f5e</guid>
<title>CPU 缓存一致性协议 MESI</title>
<link>https://toutiao.io/k/zks9o4u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;吹剑出自《庄子》：“夫吹管也，犹有也；吹剑首者，而已矣。” 吹剑只能发出小声，以示自谦。“并发吹剑录”，表达的是笔者斗胆讲一些并发编程有关的知识，由于涉及计算机体系架构，笔者才疏学浅，恐有错漏，望诸位不吝赐教，吾定当改之。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;CPU架构&lt;/b&gt;&lt;/h2&gt;&lt;h2&gt;&lt;b&gt;缓存与主存&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;解读缓存一致性（Cache Coherency），先看一下CPU的架构&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-80e69cc5f8788d360ef7d6ae39378b94_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;721&quot; data-rawheight=&quot;271&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-80e69cc5f8788d360ef7d6ae39378b94_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;721&quot; data-rawheight=&quot;271&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-80e69cc5f8788d360ef7d6ae39378b94_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-80e69cc5f8788d360ef7d6ae39378b94_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;图示一个4核CPU，有三个级别的缓存，分为是L1 Cache（一级缓存）、L2 Cache（二级缓存）、L3 Cache（三级缓存）&lt;/p&gt;&lt;p&gt;其中一级缓存有两部分组成：L1I Cache（一级指令缓存）和L1D Cache（一级数据缓存）。&lt;/p&gt;&lt;p&gt;越靠近CPU的缓存速度越快，单价也更昂贵。其中一级和二级如今都属于片内缓存（在CPU核内，早期L2缓存是片外的）独立归属给各个CPU，而三级缓存是CPU间共享的。&lt;/p&gt;&lt;p&gt;查询缓存的时候也是由近及远，优先从一级缓存去查找，找到就结束查找，找不到则再去二级缓存查找。二级缓存找不到去三级缓存查找。三级缓存还找不到就去主存（Main Memory）查找。这里说的主存，就是我们平常说的内存。&lt;/p&gt;&lt;p&gt;内存是DRAM（Dynamic RAM），缓存是SRAM（Static RAM）。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;缓存行&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;CPU操作缓存的单位是”缓存行“（cacheline），也就是说如果CPU要读一个变量x，那么其实是读变量x所在的整个缓存行。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;缓存行大小&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;好了，既然我们知道了CPU读写缓存的单位是缓存行，那么缓存行的大小是多少呢？&lt;/p&gt;&lt;p&gt;查看机器缓存行大小的方法有很多，在Linux上你可以查看如下文件确认缓存行大小：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;# L1D Cache
cat /sys/devices/system/cpu/cpu0/cache/index0/coherency_line_size

# L1I Cache
cat /sys/devices/system/cpu/cpu0/cache/index1/coherency_line_size

# L2 Cache
cat /sys/devices/system/cpu/cpu0/cache/index2/coherency_line_size

# L3 Cache
cat /sys/devices/system/cpu/cpu0/cache/index3/coherency_line_size
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或者用getconf命令：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;# L1D Cache
getconf LEVEL1_DCACHE_LINESIZE

# L1I Cache
getconf LEVEL1_ICACHE_LINESIZE

# L2 Cache
getconf LEVEL2_CACHE_LINESIZE

# L3 Cache
getconf LEVEL3_CACHE_LINESIZE
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一般会看到：64。表示的是64字节。&lt;/p&gt;&lt;p&gt;注意，单核CPU上，可能没有L3缓存。比如我在腾讯云买的最低配云主机……&lt;/p&gt;&lt;h2&gt;&lt;b&gt;MESI&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;并发场景下（比如多线程）如果操作相同变量，如何保证每个核中缓存的变量是正确的值，这涉及到一些”缓存一致性“的协议。其中应用最广的就是MESI协议（当然这并不是唯一的缓存一致性协议）。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;状态介绍&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在缓存行的元信息中有一个Flag字段，它会表示4种状态，分为对应如下所说的M、E、S、I状态。【知乎的表格是真的丑！】&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;状态&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;M（Modified）&lt;/td&gt;&lt;td&gt;代表该缓存行中的内容被修改了，并且该缓存行只被缓存在该CPU中。这个状态的缓存行中的数据和内存中的不一样，在未来的某个时刻它会被写入到内存中（当其他CPU要读取该缓存行的内容时。或者其他CPU要修改该缓存对应的内存中的内容时&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;E（Exclusive）&lt;/td&gt;&lt;td&gt;代表该缓存行对应内存中的内容只被该CPU缓存，其他CPU没有缓存该缓存对应内存行中的内容。这个状态的缓存行中的内容和内存中的内容一致。该缓存可以在任何其他CPU读取该缓存对应内存中的内容时变成S状态。或者本地处理器写该缓存就会变成M状态&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;S（Shared）&lt;/td&gt;&lt;td&gt;该状态意味着数据不止存在本地CPU缓存中，还存在别的CPU的缓存中。这个状态的数据和内存中的数据是一致的。当其他CPU修改该缓存行对应的内存的内容时会使该缓存行变成 I 状态&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;I（Invalid）&lt;/td&gt;&lt;td&gt;代表该缓存行中的内容是无效的&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;&lt;b&gt;总线嗅探机制&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;CPU和内存通过总线（BUS）互通消息。&lt;/p&gt;&lt;p&gt;CPU感知其他CPU的行为（比如读、写某个缓存行）就是是通过嗅探（Snoop）线性中其他CPU发出的请求消息完成的，有时CPU也需要针对总线中的某些请求消息进行响应。这被称为”总线嗅探机制“。&lt;/p&gt;&lt;p&gt;这些消息类型分为请求消息和响应消息两大类，细分为6小类。&lt;/p&gt;&lt;p&gt;【知乎的表格是真的丑！】&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;消息类型&lt;/th&gt;&lt;th&gt;请求/响应&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Read&lt;/td&gt;&lt;td&gt;请求&lt;/td&gt;&lt;td&gt;通知其他处理器和内存，当前处理器准备读取某个数据。该消息内包含待读取数据的内存地址&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Read Response&lt;/td&gt;&lt;td&gt;响应&lt;/td&gt;&lt;td&gt;该消息内包含了被请求读取的数据。该消息可能是主内存返回的，也可能是其他高速缓存嗅探到Read 消息返回的&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Invalidate&lt;/td&gt;&lt;td&gt;请求&lt;/td&gt;&lt;td&gt;通知其他处理器删除指定内存地址的数据副本（缓存行中的数据）。所谓“删除”，其实就是更新下缓存行对应的FLAG（MESI那个）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Invalidate Acknowledge&lt;/td&gt;&lt;td&gt;响应&lt;/td&gt;&lt;td&gt;接收到Invalidate消息的处理器必须回复此消息，表示已经删除了其高速缓存内对应的数据副本&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Read Invalidate&lt;/td&gt;&lt;td&gt;请求&lt;/td&gt;&lt;td&gt;此消息为Read 和 Invalidate消息组成的复合消息，主要是用于通知其他处理器当前处理器准备更新一个数据了，并请求其他处理器删除其高速缓存内对应的数据副本。接收到该消息的处理器必须回复Read Response 和 Invalidate Acknowledge消息&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Writeback&lt;/td&gt;&lt;td&gt;响应&lt;/td&gt;&lt;td&gt;消息包含了需要写入内存的数据和其对应的内存地址&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;&lt;b&gt;状态流转&lt;/b&gt;&lt;/h2&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-46819167708c9625d5b10a259c444778_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;662&quot; data-rawheight=&quot;952&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-46819167708c9625d5b10a259c444778_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;662&quot; data-rawheight=&quot;952&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-46819167708c9625d5b10a259c444778_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-46819167708c9625d5b10a259c444778_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;&lt;b&gt;记忆要点&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;有些眼花缭乱，个人总结了一些要点，方便记忆。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;I 状态有5条外出的线（local read有两种可能的状态转移） &lt;/li&gt;&lt;ul&gt;&lt;li&gt;当其他CPU没有这个缓存行时，当前CPU从内存取缓存行更新到Cache，并把状态设置为E&lt;/li&gt;&lt;li&gt;当其他CPU有这份数据时： &lt;/li&gt;&lt;ul&gt;&lt;li&gt;如果其他CPU是M状态，则同步其缓存到主存，然后两个CPU状态再变为S&lt;/li&gt;&lt;li&gt;如果其他CPU是S或E，则两个CPU状态都变为S&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;MSE三个状态都是有4条外出的线（对应4种操作，只会流转到一个状态）&lt;/li&gt;&lt;li&gt;而想从其他状态流转到达E状态，比较刁钻。只能从 &lt;b&gt;I 状态&lt;/b&gt;进行&lt;b&gt;local read&lt;/b&gt;，并且&lt;b&gt;其他CPU没有该缓存行数据&lt;/b&gt;时，三个限定条件（加粗部分）缺一不可。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;举例&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;假设CPU0、CPU1、CPU2、CPU3中有一个缓存行（包含变量x）都是S状态。&lt;/p&gt;&lt;p&gt;此时CPU1要对变量x进行写操作，这时候通过总线嗅探机制，CPU0、CPU2、CPU3中的缓存行会置为I状态（无效），然后给CPU1发响应（Invalidate Acknowledge），收到全部响应后CPU1会完成对于变量x的写操作，更新了CPU1内的缓存行为M状态，但不会同步到内存中。&lt;/p&gt;&lt;p&gt;接着CPU0想要对变量x执行读操作，却发现本地缓存行是I状态，就会触发CPU1去把缓存行写入（回写）到内存中，然后CPU0再去主存中同步最新的值。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Store Buffer&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;当然前面的描述隐藏了一些细节，比如实际CPU1在执行写操作，更新缓存行的时候，其实并不会等待其他CPU的状态都置为I状态，才去做些操作，这是一个同步行为，效率很低。当前的CPU都引入了Store Buffer（写缓存器）技术，也就是在CPU和cache之间又加了一层buffer，在CPU执行写操作时直接写StoreBuffer，然后就忙其他事去了，等其他CPU都置为I之后，CPU1才把buffer中的数据写入到缓存行中。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Invalidate Queue&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;看前面的描述，执行写操作的CPU1很聪明啦，引入了store buffer不等待其他CPU中的对应缓存行失效就忙别的去了。而其他CPU也不傻，实际上他们也不会真的把缓存行置为I后，才给CPU0发响应。他们会写入一个Invalidate Queue（无效化队列），还没把缓存置为I状态就发送响应了。&lt;/p&gt;&lt;p&gt;后续CPU会异步扫描Invalidate Queue，将缓存置为I状态。和Store Buffer不同的是，在CPU1后续读变量x的时候，会先查Store Buffer，再查缓存。而CPU0要读变量x时，则不会扫描Invalidate Queue，所以存在脏读可能。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;L3 Cache在MESI中的角色&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;L3 缓存是所有CPU共享的一个缓存。纵观刚才描述的MESI，好像涉及的都是CPU内的缓存更新，不涉及L3缓存，那么L3缓存在MESI中扮演什么角色呢？&lt;/p&gt;&lt;p&gt;其实在常见的MESI的状态流程描述中（我上文也是），所有提到”内存“的地方都是值得商榷的。比如我上一节举的例子中，CPU0中某缓存行是I，CPU1 中是M。当CPU0想到执行local read操作时，就会触发CPU1中的缓存写入到内存中，然后CPU0从内存中取最新的缓存行。其实准确来讲这里是不准确的，因为由于L3缓存的存在，这里其实是直接从L3缓存读取缓存行，而不直接访问内存。&lt;/p&gt;&lt;p&gt;个人猜测是如果描述MESI状态流转的时候引入L3缓存，会造成描述会极其复杂。所以一般的描述都好似有意地忽略了L3缓存。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;尾声&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;从CPU的底层视角切入并发编程，其实还有很多可以介绍，比如伪共享、内存屏障又或者SIMD。然而技术文章毕竟应该做到主次分明，不能贪多。试图大包大揽，反而让读者难以明辨纲要。这类文章读起来也过于枯燥，读者大多以收藏代替阅读……&lt;/p&gt;&lt;p&gt;所以更多相关文章请关注后续啦！当然前提是有人乐意阅读的话，我会继续更新的，感谢支持！&lt;/p&gt;&lt;p&gt;你也可以关注我的公众号：&lt;b&gt;编程往事&lt;/b&gt;。和我交个朋友！&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;参考资料&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/54282246/whats-l3-role-part-in-mesi-protocal&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;stackoverflow.com/quest&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;ions/54282246/whats-l3-role-part-in-mesi-protocal&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.cnblogs.com/jiagoujishu/p/13799459.html&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;cnblogs.com/jiagoujishu&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;/p/13799459.html&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.sohu.com/a/407346190_120647979&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;sohu.com/a/407346190_12&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;0647979&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/b&gt;&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>