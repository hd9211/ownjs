<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ac069c684d33e315fca9f950f5a0b2a3</guid>
<title>峰值超2亿/秒，Kafka在美团数据平台的逆袭之战</title>
<link>https://toutiao.io/k/jmil15d</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;319&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8aEibu8LhlWJdmubIx7icuEEoNH7fCFmRbH5kV9awLiaU8HZfBfu234CTwgRHqibvrHV2p1vxMHzFpk6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2-1 Kafka概览图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如图2-1，这张图是针对读写延迟碰到的问题，以及对应优化方案的一个概览图。我们把整个受影响的因素分为应用层和系统层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;应用层，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;主要表现在系统设计的不合理导致，包括消费者端的单线程模型存在缺陷导致运维指标失真，并且单consumer消费的分区数是不受限制的，当消费的分区数增多的时候可能会引起回溯读，因为消费能力不足就无法跟上实时最新的数据；其次是broker端，broker端主要表现在负载不均衡上，具体表现是磁盘使用率不均衡方面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们针对此做了磁盘均衡，但磁盘均衡需要使用分区迁移，分区迁移又引入了一些新的问题，包括迁移只能按批提交，这存在长尾问题，以及迁移fetcher和实时拉取fetcher存在资源竞争，分区迁移的fetcher会影响实时消费。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;系统层，&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;主要包括三个方面，一是pagecache的容量不足会导致磁盘读写，磁盘读写的性能显著慢于内存，而且容量不足时还会导致pagecache污染，pagecache污染后，磁盘读和回溯读会影响实时读；另一方面，Kafka目前使用的disk主要是HDD，HDD是比较符合顺序读写的场景。但是对于随机读写的场景，它的性能是不足的；最后由于CPU的资源竞争，在美团这边为了提高资源的利用率，IO密集型的服务（比如Kafka）会和CPU密集型的服务（比如实时作业）混布，混布其实是存在资源竞争的，也会影响读写的延迟。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对刚才提到的应用层和系统层存在的各种问题，我们这边分层的去解决。对于应用层提到的每一点问题都会有针对性的解决方案，比如说限流、流水线加速、资源隔离等。针对系统层存在的问题，我们做了cgroup的优化以及物理核的隔离来保证当CPU实时计算的飙升时不会影响读写延迟。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;319&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8aEibu8LhlWJdmubIx7icuEEozEymJN5CwbKhvnGMaYE01yppMDIK07HGmbGwfSOcnXsUvRAjmd2xLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图&lt;/span&gt;&lt;span&gt;2-2 Kafka应用层磁盘均衡&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面介绍一下读写延迟在应用层遇到到的问题，磁盘热点导致磁盘利用率不均衡，它会带来两个问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对这两个问题我们做了基于空闲磁盘优先这样一个分区迁移计算计划，整个计划分为5个点。如图2-2 所示，首先会有一个组件叫rebalancer，rebalancer通过目标的使用率和Kafka monitor组件不断从Kafka broker集群上报上来的当前磁盘的使用状况这两类指标持续生成具体的分区迁移计划，执行迁移计划并检查进度；然后rebalancer会向zookeeper的reassign节点提交刚才生成的迁移计划，Kafka的controller收到这个reassign事件之后会向整个Kafka broker集群提交reassign事件，然后Kafka broker集群让整体磁盘利用率趋于均衡值这样一个目标执行磁盘迁移计划。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如图2-2所示，对于所有的disk，三个分区属于一个相对均衡的状态，那么如果有一个四个分区的disk，就会把其中一个分区迁移到另外两个分区的disk上，最终尽可能地保证整体磁盘利用率是均衡的。但是Kafka的分区迁移只能是按组提交的，在执行分区迁移过程中碰到了许多新的问题，下面会继续介绍这些问题是怎么解决的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分区迁移存在一个迁移效率不足的问题，因为是按组提交的，在上一批没有完成之前，下一批无法开始提交，这样就会导致整体迁移进度受阻，进而对读写请求造成影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对迁移效率问题以及带来的它带来的影响，我们主要做了三点改进：第一点是做流水线加速，流水线加速能够保证长尾分区不影响整体迁移进度；第二点是迁移取消，在原生Kafka版本中，当一个分区迁移被提交后，是无法中断的，只能等他迁移完成，那么如果他在影响一个实时读写请求的时候，如果它迟迟不能完成，可能另一个实时读写的请求一直都会受到影响；第三点是做fetcher隔离，Kafka在做分区迁移的时候会利用follower通过最近读去拉数据同步，当发起最近读的迁移请求和某一个实时写请求共享同一个fetcher的时候，迁移分区的读请求会影响实时分区的读请求，后面会进一步详细描述具体的问题和对应的解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2）迁移优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; ① 流水线加速&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;319&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8aEibu8LhlWJdmubIx7icuEEoZTpACJIdhZxJ8icwItOlyZc9GBDhUcxiafxpWib8QysCaicbibwV3sGZA5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2-3 流水线加速&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对长尾分区问题，我们主要是做了流水线加速，如图2-3所示，箭头以上原生Kafka版本只支持按组提交，比如说一批提交了四个分区，当tp4这个分区一直卡着无法完成的时候，后续所有分区都无法继续进行。采用流水线加速之后，即使tp4这个分区还没有完成，当其它三个分区已经完成的时候，后续就可以继续提交新的分区。可以看出在相同的时间内，原有的方案受阻于tp4没有完成后续所有分区都没办法完成，但是在新的方案中，tp4分区已经迁移到tp11分区了。图中虚线代表了一个无序的时间窗口，主要用于控制并发，目的是为了和原有的按组提交的个数保持一致，避免过多的迁移影响读写请求服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; ② 迁移取消&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;319&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8aEibu8LhlWJdmubIx7icuEEokLWRf0D6KG9794iaddFCTlY99mQnrRvJmJgFh1gsUJVgRqDbruXk6Vg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2-4 迁移取消&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如图2-4所示，箭头左侧描述了因为迁移影响的三种线上类型。第一种是因为迁移会触发最旧读，同步大量的数据，在这个过程中会首先将数据回刷到pagecache上，那么可能会污染pagecache，进而导致某个实时读的分区发生cache miss，就会导致实时读触发磁盘度进而影响读写请求；第二类和第三类分别描述的是当存在某些异常节点导致迁移hang住的时候，想对topic做某些操作，比如对topic扩容，例如在午高峰时由于流量上涨想对topic扩容，实际上这个时候扩容是无法完成的。因为在Kafka迁移过程中这些操作都被限制住。第三个和第二个有些类似，它的主要问题是当目标节点挂了，这个时候topic扩容也是无法完成的，用户可能一直忍受读写请求受影响，直到迁移完成。针对这种场景，线上无法忍受由于长时间迁移导致读写延迟变高的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对上面提到的各种问题，我们支持了一个功能叫迁移取消。当遇到这类问题时，管理员可以调用迁移取消命令，中断正在迁移的分区，针对第一种场景，pagecache就不会被污染，实时读得以保证；在二、三类场景中，因为迁移取消，扩容得以完成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;迁移取消必须要删除那些还没有完成的分区，大量的删除会导致磁盘IO，称为性能瓶颈进而影响读写，因此在这里我们针对迁移取消做了平滑删除，避免因大量删除影响性能问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; ③ fetcher隔离&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;319&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8aEibu8LhlWJdmubIx7icuEEokibPIZ04ngJnzB7TeicUlfXOCSRjglhFwkHL15q2pIkIicSJZDuLBjPjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2-5 fetcher隔离&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如图2-5，绿色代表实时读，红色代表延时读。当某一个follower的实时读和延时读共享同一个fetcher时，延时读会影响实时读。因为每一次延时读的数据量是显著大于实时读的，而且延时读容易触发磁盘读，可能数据已经不在pagecache中了，显著的拖慢了fetcher的拉取效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对这种问题我们做的策略叫fetcher隔离。也就是说所有isr的follower共享fetcher，所有非isr的follower共享fetcher，这样就能保证所有isr中的实时读不会被非isr的回溯读所影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3）Consumer异步化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;319&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8aEibu8LhlWJdmubIx7icuEEocTQGickBicp7mo3ziawhnfoKUeMxVkeohw09AVgCgk4t5QjxxpWRZyQXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2-6 Kafka-broker分阶段延时统计模型&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先来了解一下Kafka-broker分阶段延时统计模型，当一个Kafka的producer或consumer请求进入到Kafka-broker时，首先由processor将请求写入RequestQueue里面，然后RequestHandler就会从RequestQueue源源不断地去拉取请求进行处理，在RequestQueue中的等待时间是RequestQueueTime，RequestHandler具体的执行时间为LocalTime，当RequestHandler执行完毕后会将请求扔到DelayedPurgatory组件中，这个实际上就是一个延时队列。这个延时队列当触发某一个延时条件完成了以后会把请求塞到ResponseQueue中，在DelayedPurgatory队列持续的时间为RemoteTime，processor会不断的从ResponseQueue中将数据拉取出来发往客户端，标红的ResponseTime是可能会被客户端影响的，因为如果客户端接收能力不足，那么ResponseTime就会一直持续增加，从Kafka-broker角度，每一次请求总的延迟叫RequestTotalTime包含了刚才所有流程分阶段计时总和。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;319&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8aEibu8LhlWJdmubIx7icuEEokLuLpdO8NcnKf7giacktOlvYcc1DYZnl84eO0UnVvAZctdeqAAlsNiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2-7 Consumer异步化&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要问题是因为Kafka原生consumer基于NIO的单线程模型存在缺陷。如图2-7所示，在phase1，user首先在调用poll请求时，当本地无数据时，同时向broker1、broker2和broker3发送请求，实际上broker1的数据先回来了，Kafka Client立即将数据写入CompleteQueue，这个时候立即返回，不会再拉取broker2和broker3的数据，此时user线程会直接从CompleteQueue中读取数据，然后直接返回。此时broker2和broker3服务端可能已经处理好，数据已经准备就绪。user线程会继续调用poll，访问下一批请求，可是因为CompleteQueue依然存在broker1上次拉取的数据，这时user线程直接返回了，这样就会导致broker2和broker3中已就绪的数据一直得不到拉取。如图中phase2，因为单线程模型存在缺陷导致waitFetch这部分时长变大，导致Kafka-broker延时指标不断升高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;319&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8aEibu8LhlWJdmubIx7icuEEoTRdAx4nekKUOVibsmpARZhGtECZDvIaRDxIrJNDmKtUicvbUuY4IOnoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2-8 引入异步拉取线程&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对这个问题我们的改进是引入异步拉取线程。异步拉取线程会及时的拉取就绪的数据，避免服务端延时指标受影响，而且原生Kafka并没有限制同时拉取的分区数，我们在这里做了限速，避免GC和OOM的发生。异步线程在后台持续不断地拉取数据放到CompleteQueue中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;3、系统层&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1）Raid卡加速&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;319&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8aEibu8LhlWJdmubIx7icuEEoe1DJ5D0XCo3weGPw9sDlqdYPFYMweCNiaz8DFdUz15sZatE6HicibraCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2-9 Raid卡加速&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;众所周知，Kafka的写入借助了Zero Copy技术将数据直接写入pagecache，但是随着随机读写并发量的提升，随机写导致的性能不足问题就会显现出来。表现是随机写入的延时会显著升高，针对这个问题我们引入了Raid卡。Raid卡有一个好处是自带缓存，而且Raid卡使用的是Raid-0模式，并没有冗余，与pagecache类似，在这一层会继续做merge，把数据merge成更大的block写入disk。更加充分利用顺序写HDD的带宽，借助Raid卡保证了随机写的性能是比较稳定的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2）cgroup隔离优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;319&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8aEibu8LhlWJdmubIx7icuEEovake1Scx94aF4Ogk4a0TFf6bPAgATjS5WcSqPlicnho8wYmWxwlnSUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2-10 cgroup隔离&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在介绍cgroup的隔离优化之前需要提到的背景是，为了提高资源利用率，美团数据平台将IO密集型应用和CPU密集型应用混布。IO密集型应用在这里指的就是Kafka，CPU密集型应用在这里指的是Flink和Storm，但是原有的隔离策略存在两个问题：首先是物理核本身会存在资源竞争，在这个物理核下，共享的L1cache和L2cache都存在竞争，当实时平台CPU飙升时会导致Kafka读写延时受到影响；另外，Kafka的HT跨NUMA，增加内存访问耗时，如图2-10所示，跨NUMA节点是通过QPI去做远程访问，而这个远程访问的耗时是40ns。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对这两个问题我们改进了隔离策略，针对物理核的资源竞争，我们新的混布策略Kafka是独占物理核的，也就是说在新的隔离策略中，不存在同一个物理核被Kafka和Flink同时使用；然后是保证Kafka的所有超线程处于同一侧的NUMA，避免Kafka跨NUMA带来的访问延时。通过新的隔离策略，Kafka的读写延时不再受Flink CPU飙升的影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;4、混合层-SSD新缓存架构&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;319&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8aEibu8LhlWJdmubIx7icuEEoECyT7g69DxbC87k3T5FOAK5EW93QsjOF0IJt7x3OvPcv30ibz4ooqTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2-11 混合层SSD新缓存架构&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先来了解一下Kafka的数据消费模型，Kafka利用操作系统提供的ZeroCopy技术处理数据读取请求，pagecache容量充裕时数据直接从pagecache拷贝到网卡，有效降低了读取延时。但是实际上往往pagecache的的容量是不足的，因为它不会超过一个机器的内存，容量不足时，ZeroCopy就会触发磁盘读，磁盘读不仅显著变慢，还会污染pagecache影响其他读写。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如图2-11中左半部分所示，当一个延迟消费者去拉取数据时，发现pagecache中没有它想要的数据，这个时候就会触发磁盘读，磁盘读后会将数据回写到pagecache，导致pagecache污染，自己读写延迟变慢同时也会导致另一个实时消费受影响，因为对于实时消费而言，它一直读的是最新的数据，最新的数据按正常来说时不应该出发磁盘读的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;319&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8aEibu8LhlWJdmubIx7icuEEolxP0CDMOETnb1KwtN6Ms2ibHDSACxggbMGEWKRiaF4KHCIKtHFBUhY7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2-12 SSD新缓存架构方案选型&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对这个问题，我们这边在做方案选型时有两种方案，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;方案一：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;读磁盘时不回写pagecache，比如使用DirectIO，不过Java并不支持；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;方案二：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;在内存和HDD之间引入中间层，比如SDD，如图2-12所示，随着读取并发的增加，SSD的性能并不会显著降低，非常适合我们的使用场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;319&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8aEibu8LhlWJdmubIx7icuEEoWx9tw98Q2gHudfPNicUiaObYBFuFYu0lt0EKrLszbwkKtEadjq81eooA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2-13 SSD新缓存架构决策&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;针对SSD的方案也有两种选型:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;方案一：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;可以基于操作系统的内核实现，这种方案SSD与HDD存储空间按照固定大小分块，并且SSD与HDD建立映射关系，同时会基于数据局部性原理，cache miss后数据会按LRU和LFU替换SSD中部分数据，业界典型方案包括OpenCAS和FlashCache。优势是数据路由对应用层透明，对应用代码改动量小，并且社区活跃可用性好；但是问题是局部性原理并不满足Kafka的读写特性，而且缓存空间污染问题并未得到根本解决，因为它会根据LRU和LFU去替换SSD中的部分数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;方案二：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;是基于Kafka的应用层去实现，具体就是Kafka的数据按照时间维度存储在不同设备上，对于近实时数据直接放在SSD上，针对较为久远的数据直接放在HDD上，然后leader直接根据offset从对应设备读取数据。这种方案的优势是他的缓存策略充分考虑了Kafka的读写特性，确保近实时的数据消费请求全部落在SSD上，保证这部分请求处理的低延迟，同时从HDD读取的数据不回刷到SSD防止缓存污染，同时由于每个日志段都有唯一明确的状态，因此每次请求目的明确，不存在因cache miss带来的额外性能开销。同时劣势也很明显，需要在server端代码上进行改进，涉及的开发以及测试工作量较多。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8aEibu8LhlWJdmubIx7icuEEo88WQnicyNqAOzaa8RYR150l2FbGhk090CxTmVyuMtJfRwEUxmiaKTA1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2-14 SSD新缓存架构具体实现&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面来介绍一下SSD新缓存架构的&lt;/span&gt;&lt;strong&gt;&lt;span&gt;具体实现。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;首先新的缓存架构会将log内的多个segment按时间维度存储在不同的存储设备上，如图2-14中的红圈1，新缓存架构数据会有三种典型状态，一种叫only cache，指的是数据刚写进SSD，还未同步到HDD上；第2个是cached，指数据既同步到了HDD也有一部分缓存在SSD上；第三种类型叫withoutCache，指的是同步到了HDD但是SSD中已经没有缓存了；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;然后后台异步线程持续地将SSD数据同步到HDD上；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;随着SSD的持续写入，当存储空间达到阈值后，会按时间顺序删除距当前时间最久的数据，因为SSD他的数据空间也是有限的；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;副本可根据可用性要求灵活开启是否写入SSD；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;从HDD读取的数据是不会回刷到SSD上的，防止缓存污染。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;319&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8aEibu8LhlWJdmubIx7icuEEoWBiccuiczCCo12DojMheicyWkkGMPjFs5rQWCcBehJ3nZ437OpicKB2aLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2-15 SSD新缓存架构细节优化&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;介绍了具体实现之后，再来看一下&lt;/span&gt;&lt;strong&gt;&lt;span&gt;细节优化。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先是关于日志段同步，就是刚才说到的segment，只同步Inactive的日志段，Inactive指的是现在并没有在写的日志段，低成本解决数据一致性问题；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次是做同步限速优化，在SSD向HDD同步时是需要限速的，同时保护了两种设备，不会影响其他IO请求的处理，向SSD写入数据也是需要限速的，因为SSD的使用寿命是有限的。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;三、大规模集群管理优化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;了解了读写延迟优化之后，下面来看一下Kafka在美团数据平台是如何保证大规模集群的稳定性的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;1、隔离优化&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;319&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8aEibu8LhlWJdmubIx7icuEEons2Ew6GoHKicMlUfS5YvYlpLSPUx7E51ib2NXfUJC9mQqMxvB50KgibIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3-1 隔离优化&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于Kafka服务于多个业务，这些业务的topic混布在一起的话很有可能造成不同业务的不同topic之间相互影响。例如broker如果和controller混布在一起，当broker负载明显变高的时候，会导致controller无法及时处理请求，从而可能会造成整个集群发生故障，因为元数据的变更请求无法发送出去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对这些相互影响的问题，我们从业务、角色和优先级三个维度来做隔离优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第一点是业务隔离，如图3-1所示，每一个大的业务会有一个独立的kafka集群，比如外卖、团购、优选；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第二点是分角色隔离，这里Kafka的broker和controller以及他们依赖的组件zookeeper是部署在不同机器上的，避免之间相互影响；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;第三点是可以分优先级，有的业务可能它的topic可用性等级特别高，那么我们就可以给他划分为VIP集群，给他更多的资源冗余去保证可用性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;2、全链路监控&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;319&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8aEibu8LhlWJdmubIx7icuEEoOT69icM3qvSmTI21aDXgPIib7icYZbAkhnUNMcmthZ7IWJPiaxEwfd7CoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3-2 全链路优化&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着集群规模的增大分区数变多，读写的客户端也会变多，Kafka当前提供的broker端粒度的延时指标在很多情况下无法真实反映某些客户端是否慢，还有一类问题是当集群发生故障时，如何能及时得到感知和处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对这两个问题，我们做了全链路监控这样一个项目。把Kafka核心组件以及指标全部收集起来做了一个全链路的追踪，通过分析上报上来的日志和指标，我们就可以建立细粒度的日志大盘。当某一个读写请求变慢时，我们通过日志大盘很容易就知道他具体是慢在哪个环节。日志和指标的解析服务可以自动实时感知故障还有一些慢节点，这两类故障有一部分我们可以做到自动处理，我们会把他通过事件的方式通知到Kafka manager，然后Kafka manager会根据这个事件自动去处理这些故障。还有一类故障是无法得到自动处理的，比如说僵尸节点，僵尸节点指的是zookeeper的临时节点还没有掉线，但是这个节点不管是controller也好还是客户端也好，都已经无法访问了，访问就会报错或者超时，这一类故障需要人工介入处理，会直接发给具体的管理员。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;3、服务生命周期管理&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;319&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8aEibu8LhlWJdmubIx7icuEEoY2ibzmR8TAkEAUVvosGIDqBoGFpAfb2W5icANBD7Mic4BAUIU02p53OFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3-3 服务生命周期管理&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先介绍一下当集群规模增大以后存在的一系列问题。之前版本的Kafka也有一套自动化运维的系统，但是它存在一些问题，首先是状态语义存在歧义，无法真实反映系统状态，往往需要借助日志和指标去找到真实系统是否健康或者异常；然后是状态不全面，异常case需人工介入处理，误操作风险极大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于这两点问题，我们引入了生命周期管理机制，保证状态能真实反映系统状态。生命周期管理指的是从服务开始运行到机器报废停止服务的全流程管理。并且做到了服务状态和机器状态联动，无需人工同步变更。而且新的生命周期管理机制的状态变更由特定的自动化运维触发，禁止人工变更。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86152&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span data-bgopacity=&quot;40%&quot;/&gt; &lt;span data-bgopacity=&quot;25%&quot;/&gt; &lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;4、TOR容灾&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;319&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8aEibu8LhlWJdmubIx7icuEEoWlAG9ibfzEzk8C1kBQB6XpzZWb8PJOficm0uY6TbckiavI9HwC06FHdSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3-4 TOR容灾-挑战&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后一个集群管理优化是TOR容灾。随着集群规模的变大，Rack级别的故障变得平凡起来，而我们是无法容忍Rack级别的故障的，因为Rack级别的故障可能会导致分区不可用，原因是分区的多副本在同一个rack下，特别是在流存储环境下，当某些分区不可用时，它会导致收集侧的拥堵，影响其他topic的收集上报。并且当实时作业的某个分区出现异常时，它会影响整个链路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如图3-4所示，当rack1发生故障时，TopicPartition1是完全不可用的，因为他的两个副本都在rack1上，TopicPartition2也是不可用的，虽然他有三个副本，但是他的两个副本都已经不可用了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-backh=&quot;319&quot; data-backw=&quot;568&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ufWcjcomw8aEibu8LhlWJdmubIx7icuEEoe3Uo4FPdBwcvt1WA5nOZZhlQRiaN1jUMoNsu6LvC1uoYWmpD7UVpdZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3-5 TOR容灾-改进&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对Rack级别的故障，我们做了TOR容灾。改进了副本的分配算法，保证同一个分区的不同副本不在同一个rack下，如图3-5所示，即使rack1整个发生故障，也能保证所有分区是可用的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86122&quot; data-custom=&quot;#138bde&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;四、未来展望&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;最后介绍一下美团数据平台的Kafka未来可以做哪些优化：首先我们会继续去做Kafka的高可用建设，比如说客户端主动去做一些故障节点的避让，服务端通过多队列的方式去隔离一些异常请求，避免它们之间相互影响。另外，高可靠方面会去做quorum write多数派写优化，因为Kafka的ack等于1时是需要写入所有副本的。我们还会去做流批一体的存储架构，比如Kafka on HDFS。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;39&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;作者丨赵海源&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;来源丨公众号：DataFunTalk（ID：datafuntalk）&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;dbaplus社群欢迎广大技术人员投稿，投稿邮箱：&lt;/span&gt;&lt;span&gt;editor@dbaplus.cn&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8f5de8bfc2abbb79541d46aac3698e1b</guid>
<title>开源｜腾讯出品的，基于云原生技术的成本优化项目</title>
<link>https://toutiao.io/k/eu428cf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断。&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;扫描下方二维码&lt;/span&gt;，即刻加入！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;腾讯开源的，基于云原生技术的成本优化项目 &lt;span&gt;Crane&lt;/span&gt;。&lt;span&gt;Crane&lt;/span&gt; 遵循 FinOps 标准，旨在为云原生用户提供云成本优化一站式解决方案。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Crane 是腾讯内部云资源优化流程方法和工具的系统性输出，同时，Crane 核心能力的构建与规划均与 FinOps 基金会提出的能力模型完全契合。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Crane 致力于推荐资源和智能弹性配置，业务人员无需再为业务需要多少资源，自动扩缩容应该如何配置等问题而烦恼，Crane 会基于业务的时序变动数据给出最优解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1171&quot; data-ratio=&quot;1.88&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNav9PmIJ4tODmFGkQTPUiafKWSUJKnttpVvSnPE2SvRLUllJlD4YVDQ9y7m1NxJBkbBEk0O4fCMRjgmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d546ff28513d27189b2f3a36143ac1ac</guid>
<title>Go 微服务工具包 Go kit 怎么集成 gRPC？</title>
<link>https://toutiao.io/k/zczfvlt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;大家好，我是 frank。&lt;br/&gt;欢迎大家点击标题下方&lt;span&gt;蓝色&lt;/span&gt;文字「Golang 语言开发栈」关注公众号。&lt;br/&gt;&lt;strong&gt;设为星标&lt;/strong&gt;，第一时间接收推送文章。&lt;br/&gt;&lt;strong&gt;文末扫码&lt;/strong&gt;，加群一起学 Golang 语言。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;01 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;介绍&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在上一篇文章「&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247485994&amp;amp;idx=1&amp;amp;sn=a17963c2958100053416ac3800b4b85a&amp;amp;chksm=9f81a044a8f62952d51a60b378ce785a313791ae4962a1cd9a1c19c1ba46f8f24a70fd9d4996&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Go 语言基于 Go kit 开发 Web 项目&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt;Go 语言基于 Go kit 开发 Web 项目&lt;/strong&gt;&lt;/a&gt;」中，介绍了怎么使用 Go kit 开发 Web 项目，在这篇文章中，我们传输层使用的是 HTTP，本文我们介绍 Go kit 怎么集成 gRPC，也就是说我们在传输层使用 rpc。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在阅读完前面几篇文章后，我们已经了解 Go kit 分为三层，分别是 Transport、Endpoint 和 Service，其中 Transport 负责网络传输，Endpoint 负责接收请求和返回响应，Service 层负责定义业务接口，并实现接口方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go kit 集成 gRPC，主要在 Transport 层实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实现原理&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go kit 集成 gRPC，即将 gRPC 集成到 Go kit 的 Transport 层。Transport 层将接收到的网络请求转换为 Endpoint 层可以处理的对象，主要需要实现两个功能，解码和编码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，解码负责把网络请求转换为 Endpoint 可以处理的请求对象；编码负责将 Endpoint 处理结果转换为响应对象，返回给客户端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go kit 集成 gRPC 的示例项目&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在了解完实现原理之后，我们通过示例项目介绍 Go kit 怎么集成 gRPC，关于定义 proto 文件，和使用 protoc 生成 pb 文件，我们在之前的文章中已经介绍过，限于篇幅，本文不再赘述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 Go kit 集成 gRPC，实际上就是在 Transport 层使用 gRPC 传输，除此之外，它和我们上一节讲的使用 Go kit 开发 Web 项目的流程是一样的，共分为五个步骤实现该示例项目，分别是定义 proto 并生成 pb 文件、创建 service 层、创建 endpoint 层、创建 transport 层和定义主函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;定义 proto&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;option go_package = &quot;./user&quot;;&lt;br/&gt;&lt;br/&gt;service UserService {&lt;br/&gt;  rpc Register(RegisterReq) returns (RegisterRes) {}&lt;br/&gt;}&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;生成 pb 文件&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;protoc -I proto \&lt;br/&gt;&amp;gt; --go_out ./pb/user --go_opt paths=source_relative \&lt;br/&gt;&amp;gt; --go-grpc_out=require_unimplemented_servers=&lt;span&gt;false&lt;/span&gt;:./pb/user --go-grpc_opt paths=source_relative \&lt;br/&gt;&amp;gt; proto/user.proto&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阅读上面这段代码，我们定义一个 proto 文件，并使用 protoc 工具生成 pb 文件，需要注意的是我们将 &lt;code&gt;require_unimplemented_servers&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;By default, to register services using the methods generated by this tool, the service implementations must embed the corresponding Unimplemented&lt;servicename&gt;Server for future compatibility. This is a behavior change from the grpc code generator previously included with protoc-gen-go. To restore this behavior, set the option require_unimplemented_servers=false.&lt;/servicename&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Service&lt;/strong&gt; - 定义接口&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; IUser &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; Register(ctx context.Context, username, email, password &lt;span&gt;string&lt;/span&gt;) error&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; User &lt;span&gt;struct&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(u User)&lt;/span&gt; &lt;span&gt;Register&lt;/span&gt;&lt;span&gt;(ctx context.Context, username, email, password &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; username != &lt;span&gt;&quot;&quot;&lt;/span&gt; &amp;amp;&amp;amp; email != &lt;span&gt;&quot;&quot;&lt;/span&gt; &amp;amp;&amp;amp; password != &lt;span&gt;&quot;&quot;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; errors.New(&lt;span&gt;&quot;register param is invalid&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阅读上面这段代码，我们在 Service 层创建 IUser 接口，接口包含一个方法 Register，需要注意的是，Register 方法会通过调用 &lt;code&gt;grpc.Handler&lt;/code&gt; 的 ServeGRPC 方法，将请求参数传递给 Go kit 处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Endpoint&lt;/strong&gt; - 接收请求和返回响应&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;MakeUserEndpoint&lt;/span&gt;&lt;span&gt;(user IUser)&lt;/span&gt; &lt;span&gt;endpoint&lt;/span&gt;.&lt;span&gt;Endpoint&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(ctx context.Context, request &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;(response &lt;span&gt;interface&lt;/span&gt;{}, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  req := request.(RegisterReq)&lt;br/&gt;  err = user.Register(ctx, req.Username, req.Email, req.Password)&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   log.Printf(&lt;span&gt;&quot;err:%s&quot;&lt;/span&gt;, err)&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; RegisterRes{&lt;br/&gt;   Username: req.Username,&lt;br/&gt;   Email:    req.Email,&lt;br/&gt;  }, &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阅读上面这段代码，在 Endpoint 层，我们给业务接口 IUser 构建 &lt;code&gt;endpoint.Endpoint&lt;/code&gt;，用于调用 Service 层的接口的方法处理请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Transport&lt;/strong&gt; - 传输层&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; grpcHandler &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; register grpc.Handler&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(g *grpcHandler)&lt;/span&gt; &lt;span&gt;Register&lt;/span&gt;&lt;span&gt;(ctx context.Context, req *pb.RegisterReq)&lt;/span&gt; &lt;span&gt;(*pb.RegisterRes, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; _, res, err := g.register.ServeGRPC(ctx, req)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;, err&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; res.(*pb.RegisterRes), &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewUserServer&lt;/span&gt;&lt;span&gt;(ctx context.Context, endpoints Endpoints)&lt;/span&gt; &lt;span&gt;pb&lt;/span&gt;.&lt;span&gt;UserServiceServer&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &amp;amp;grpcHandler{&lt;br/&gt;  register: grpc.NewServer(&lt;br/&gt;   endpoints.UserEndpoint,&lt;br/&gt;   DecodeRegister,&lt;br/&gt;   EncodeRegister,&lt;br/&gt;  ),&lt;br/&gt; }&lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阅读上面这段代码，我们在 Transport 层实现 pb 文件中的 UserServiceServer 方法，需要注意的是，我们在 NewUserService 函数中，传入 Endpoint。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;blockquote&gt;&lt;blockquote&gt;&lt;p&gt;完整代码，请参阅 Github。&lt;/p&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;04 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们通过示例项目介绍 Go kit 怎么集成 gRPC，通过集成 gRPC，Transport 层实现通过 rpc 进行网络传输。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247485871&amp;amp;idx=1&amp;amp;sn=5e9eac1cce46b90fdab7be5ea14be9ef&amp;amp;chksm=9f81a3c1a8f62ad7f00ae7659154d87c2790097944d8606cf440aa5cd58e29c9b13cedad2099&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Golang 语言 vendor 在 GOPATH 和 Modules 中的区别&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Golang 语言 vendor 在 GOPATH 和 Modules 中的区别&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247485896&amp;amp;idx=1&amp;amp;sn=7f13caa0a4a0efc9aa52f91449f1eee7&amp;amp;chksm=9f81a3a6a8f62ab0e4476eab641b65fc0376f817c7393dabdefeb239fcf8fb879bec353df558&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Golang 语言的多种变量声明方式和使用场景&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Golang 语言的多种变量声明方式和使用场景&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247485863&amp;amp;idx=1&amp;amp;sn=6e119515e734fddacc87713bb3b26ce8&amp;amp;chksm=9f81a3c9a8f62adf7d4b6e2b91538919799dd0b27ff0064780db052a1e5636f2a46a6f51a446&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Golang 语言微服务的服务发现组件 Consul 的系统架构介绍&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Golang 语言微服务的服务发现组件 Consul 的系统架构介绍&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247484749&amp;amp;idx=1&amp;amp;sn=6e5455fb53756f08c32940e476138753&amp;amp;chksm=9f81af23a8f626351263aaa520929fda1afd086bd7d708d2c6f7248880b0c764fd8ca3339caa&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Golang 语言中基础同步原语 Mutex 和 RWMutex 的区别&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Golang 语言中基础同步原语 Mutex 和 RWMutex 的区别&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Mjc1NTMyOQ==&amp;amp;mid=2247483808&amp;amp;idx=1&amp;amp;sn=3e71c90a6e8400e886144fe187c59077&amp;amp;chksm=9f81abcea8f622d84ba865bf5b7a738de092423b52dd3c8a539f964c15a4832add82b5b4249e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Go 语言学习之测试&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Go 语言学习之测试&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;br/&gt;https://github.com/grpc/grpc-go/blob/master/cmd/protoc-gen-go-grpc/README.md &lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fce21cde7216398b1ab5e5933bb0d34f</guid>
<title>什么是跨级管理与跨级上报</title>
<link>https://toutiao.io/k/zzgnacw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原创不易，求分享、求一键三连&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hi，各位亲爱的小伙伴，小钗公号遵循日复盘-&amp;gt;周复盘-&amp;gt;月复盘-&amp;gt;季度复盘-&amp;gt;年总结策略，所以某类型文章到后期才会成体系。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4537037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdfjlwvwuTDVLKVBcphDxNyvHPMjr0cPBbSlPPchL1gRJNt6uiaAYloQicdhjJuqjnvOh6nRF6KFl5mib4k10SLQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天这篇文章属于&lt;strong&gt;「周复盘」&lt;/strong&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;两种跨级&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;跨级管理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前两天&lt;strong&gt;「知识星球」&lt;/strong&gt;有个同学很生气，因为他的Leader总是喜欢跨级管理：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Leader 35+，空降一年管理30人；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;小A 28，管理10人；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近Leader有些行为逐渐让小A感到烦躁：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Leader经常跟一线沟通技术细节；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Leader在横向业务的前置沟通中，会完全饶过小A找一线干活；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上案例都是在日常工作中发生，并不是项目特殊时期，这种跨级管理让小A感到很无奈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为一个一线Leader，你遇到这种&lt;strong&gt;「跨级管理」&lt;/strong&gt;该怎么办呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;跨级上报&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小B是一线Leader，因为一些渊源与部门负责人建立了联系，于是小B就像找到了上升通道一样，不断的与负责人沟通，内容包括但不限于：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;项目问题求助；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;团队问题暴露；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开始小B的Leader还不以为意，但渐渐的他觉得不对了：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;每次小B出现问题，负责人总会比自己先知道；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;而实际协助小B解决问题的依旧是自己；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;小B渐渐不把自己当一回事了；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;负责人偶尔会抱怨，为什么小B总是跨级上报，但因为要维护自己亲民的人设，也没有直接拒绝小B；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是小B的行为引发了三个人的烦恼。而问题还没结束，聪明的一线Leader小C发现小B的套路后，也开始了和负责人的工作交流...&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是一条&lt;strong&gt;「终南捷径」&lt;/strong&gt;似乎打开聊天工具就能发生，ROI极高！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为中层干部，你发现下面Leader&lt;strong&gt;「跨级上报」&lt;/strong&gt;，又该怎么办呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;跨级管理的本质&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先关注第一个问题，为什么会发生跨级管理，跨级管理的本质是什么？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;正常情况下，跨级管理的本质是&lt;strong&gt;「梯队有问题」&lt;/strong&gt;，需要团队Leader向下进行补位&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如以下场景：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;下面同学项目要崩了，团队Leader直接下场指挥作战，打赢这场战役；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一线Leader出现了严重问题（不称职或要离职），团队Leader手上一时没有PlanB人选，只能自己上；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;团队Leader从战略层判断，下面某个团队接下来会上升为公司级核心，一线Leader一定搞不定，于是直接自己带队；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上情况都有一个特性：原来的Leader搞不定，需要进行补位。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这个认知，我们回到小A的问题，显然小A并不存在需要帮助的情况，那么他的Leader不停的跨级管理是为什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回答可以是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小A Leader管理风格就是如此；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但管理风格就是如此显然是个&lt;strong&gt;「回避性的回答」&lt;/strong&gt;，类似的回答可以解释问题但并没有什么卵用，所以这里还需要深入挖掘，我们可以拿到以下客观条件：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;小A的Leader35+；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;管理30人；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;核心参与一线工作；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常情况下30人团队只需要一个Leader即可，由此我们可以做一个假设：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;小A Leader认为团队只需要一个Leader；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;小A Leader对自己的定位是一线Leader；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;小A Leader认为小A是组长或者一线员工；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且从结构来说，小A的下属直接与其Leader对话肯定收益更高，所以小A可能是当前结构中唯一不满的人...&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这也说明了跨级管理的另一个本质：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;特殊情况下，跨级管理是一种&lt;strong&gt;「降维使用」&lt;/strong&gt;，属于防守型战略&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种Case也很多：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;公司业务爆炸，规模由100人变成了10000人，我从管10人变成了管500人，从一线Leader变成了VP；但今年效益很差，预计公司规模要缩水80%，于是我回归一线Leader，提前布局开始跨量级管理；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我今年已经35了，自觉能力有限、上升无望，为了今后职业生涯更好的适配性，准备一直干一线Leader的工作；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;因为一线Leader最接近业务，秀操作场景会很多，属于&lt;strong&gt;「低强度脑力、中强度体力」&lt;/strong&gt;工作者，待遇不差还很安全，只要守分，会是一个ROI很高的职位&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上，这也是跨级管理为什么很容易发生：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;梯队经常出问题；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;大Leader憋不住想装逼秀操作的心；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有预期的&lt;strong&gt;「降维使用」&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;跨级上报的本质&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前我们聊过向上管理的本质：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;向上管理是获取（leader可提供）资源的手段；&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45740740740740743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdfjlwvwuTDVLKVBcphDxNyvHPMjr0cPSjAgZZWpicbZsWibop5AfEJSiauElw7uZ9apEmHRW5fiayegAKdH0iathrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6287037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdfjlwvwuTDVLKVBcphDxNyvHPMjr0cPkLTMY8TvWda2LyQJabGlTMiawSjG7KxqV1Qm7Mt8gdysEysibtzwYCkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你在团队中的势能，决定了你能获取的资源，其中leader的期待（看法），很大部分决定了你势能的多少。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以向上管理本质是你提升自身势能的一种手段。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;而跨级上报是管理Leader的Leader，是一种高阶的向上管理，收益会很高，当然风险会很大...&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小B的行为自然是一种不好的示范，属于&lt;strong&gt;「能力不行强行借势」&lt;/strong&gt;，不然也不用每次其Leader帮他擦屁股了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而这里部门负责人显然有点&lt;strong&gt;「犯贱」&lt;/strong&gt;，为了维护自己的人设，直接把团队上升通道搞出问题了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果真有终南捷径，那大家也不用一路打怪升级了&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;核心问题还是团队资源有限，如果负责人选择帮助小B，那么小C和小D就会排队，最终负责人会因为自己的精力而引起公平问题。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;不患寡患不均，不可不慎&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再次看向此图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8888888888888888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdfjlwvwuTDVLKVBcphDxNyvHPMjr0cPuXkVD4gTxwaPcCibrUubhjsP9hbUAqsQt0tKhNkibMRvGI07LD4rtgQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同的层级有他应得的资源，偶尔的向上管理是可以的，极少的跨级上报也可以原谅，但如果向上管理变成日常，那要你何用？&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;谁是你的老板&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;职位到一定阶段，实际的汇报关系会很复杂：虚线、实线、项目线、委员会...&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信我，同时存在多个Leader的情况不在少数，这里需要思考一个问题：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;谁是你真正的老板，这里有个逻辑是：&lt;/p&gt;&lt;p&gt;谁对你负责，你就需要对谁负责；&lt;/p&gt;&lt;p&gt;你对谁负责，他就需要对你负责。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思考以下问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;你汇报关系上的Leader是你的老板吗；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;帮你解决问题的是你的老板吗；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;给你升职加薪的是你的老板吗；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你的老板和你的Leader发生冲突怎么办；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你是你下属的Leader还是老板；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;怎么看待你的下属跨级上报；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;怎么看待你这次的跨级管理；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;你的老板是你Leader的Leader，那你该如何汇报；&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;找准自己的老板，&lt;strong&gt;「找到自己真正的老板」&lt;/strong&gt;，这个话题其实很大，但是又有些敏感，一些信息还不好直接透露，如果大家感兴趣就留言，后续我们再做讨论。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想要更多交流可以加我微信：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2982954545454546&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JdfjlwvwuTDVLKVBcphDxNyvHPMjr0cPKPibcsPQIPWE7N4oxlcXcO0nfs3YL19jRnrdmPxGDdGjibaOGibFK9uwQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1056&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a58718915546c8a2a76f3f1dbdfd50c0</guid>
<title>一次关于架构的“嘴炮”</title>
<link>https://toutiao.io/k/ajzeree</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章标题很随意，些微有一些骗点击的“贼意”；但内容却是充满了诚意，想必你已经感受到了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一次源于头条 Android 客户端软件架构问题的探讨，之所以冠上“嘴炮”之名，是因为它有一些&lt;strong&gt;务虚&lt;/strong&gt;；同时又夹杂了一些&lt;strong&gt;方法论&lt;/strong&gt;，不仅适用于客户端软件架构，也适用于其他工作场景，希望对大家有所帮助。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了拉满读者的带入感，且以“我们”为主语，来看&lt;strong&gt;架构的挑战、判断和打法&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;我们的挑战&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;期望高&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优秀的公司对架构都有着很高的期许，都希望有一个良好的顶层设计，从上到下有统一的认知，遵循共同的规范，写出让人舒适的代码，甚至有那么一丢偷懒，有没有“一劳永逸”的架构设计可保基业长青？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而高期望意味着高落差，面对落差，我们容易焦虑：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;代码什么时候能写的看上去本就应该是那个样子；而现在怎么就像是在攀登“屎山”呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;文档什么时候能写的既简明又详细；而现在怎么就简明的看不懂，详细的很多余呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;工具什么时候能更好用更强大一点；而现在怎么就动不动掉链子，没有想要的功能常年等排期呢？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“我”什么时候能从架构工作中找到成就感，而不是搞一搞就想着跑路呢？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;责任大&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大量问题的最终归因都是&lt;strong&gt;代码问题&lt;/strong&gt;：设计不合理、使用不规范、逻辑太晦涩、编码“坑”太多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没有一个单一的团队能承担这些问题的责任，我们收到过很多“吐槽”：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;这尼玛谁写的，简直不堪入目，看小爷我推倒重来展现一把真正的实力&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;XX 在这里埋了颗雷，但 XX 已经不管了，事到如今，我也只能兜底搞一把&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这压根就不应该这么用，本来的设计又不是为了这个场景，乱搞怪我咯？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;卧槽，这特么是隐藏技能啊，编译时悄悄改了老子的代码，找瞎了都没找到在哪过环节渗透进来的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一方面，口嗨一时爽，我们“吐槽”历史代码得到了一时的舒缓；另一方面，也意味着责任也传递到了我们：处理得好，我们的产出可能还是一样会被当作糟粕，但如果处理不好，我们就断送了业务发展的前程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;事情难&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;架构面临的从来不是单一的业务问题，而是多个业务多人协作的&lt;strong&gt;交叉问题&lt;/strong&gt;，负重前行是常态。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;业务历久弥新，历史包袱叠加新的场景，随便动动刀子就拔出萝卜带出泥。譬如：头条 2021 年 10 月的版本有 XXXX 组件，相比一年前已经翻倍；类个数 XXXXX；插件 XX 个；仓库数量 XX 个；ttmain 仓库权限 XXX 人。(XX 代表数量级，隐去了具体数字，^_^)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;技术栈层出不穷，一方面要保持成熟稳定，一方面要积极探索落地。架构的同学要熟悉多种技术栈，譬如：跨端技术在客户端业务中通常都是多种共存(H5/Hybrid/小程序/Lynx/Flutter)，一个业务到底选用哪种技术栈进行承载，需要耗费多少成本？选定技术栈后存在什么局限，是否存在不可逾越的障碍？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;疗效慢&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们经常说代码复杂度高，并把降复杂度作为架构方向的重点工作之一；但影响复杂度的因子众多，从&lt;strong&gt;外部&lt;/strong&gt;来看，有主观感受、客观指标、行业对标三个角度；从&lt;strong&gt;内部&lt;/strong&gt;来看，有工程组织、代码实现和技术栈三个角度。即便我们很好的优化了工程结构这个因子，短时间内也很难感受到复杂度有一个明显的下降。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5128022759601707&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaKIKycrgQkE6ZDSnOzQhbuA1dyl0J1T2UumoNJprIqZffwz1KfBXs9DJluZRricszoJhDPNbSpOQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2812&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;我们常说治理，其实是设计一种机制，在这种机制下运转直到治愈。&lt;/p&gt;&lt;p&gt;就像老中医开方子，开的不是特效药，而是应对病症的方法，是不是有用的方子，终究还是需要通过实践和时间的检验。希望我们不要成为庸医，瞎抓几把药一炖，就吹嘘药到病除。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;我们的判断&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;架构问题老生常谈&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;谁来复盘架构问题，都免不了炒一炒“冷饭”；谁来规划架构方向，都逃不出了“减负”、“重构”、“复用”、“规范”这些关键词。难点在于把冷饭炒热，把方向落实。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.28733997155049784&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaKIKycrgQkE6ZDSnOzQhbueiaHbde2iaLeib6wV2VMQLKdkKE6RRKYnU2BbgWwzqmpwlB8SOXxib6czQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1406&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;架构方向一直存在&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;架构并不只局限于一个产品的初始阶段，而是伴随着产品的整个生命周期。架构也不是一成不变的，它只适合于特定的场景，过去的架构不一定适合现在，当下的架构不一定能预测未来，架构是随着业务不断演进的，不会出现架构方向做到头了、没有事情可搞了的情况，架构永远生机勃勃。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.33487450462351387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaKIKycrgQkE6ZDSnOzQhbuXOgefxUbDpYIfKFiczyT6LOpe5Eua0p9qsQCiapVabTqYHwTCpRbxiaNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1514&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48058902275769744&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaKIKycrgQkE6ZDSnOzQhbuDOIvnPd02JlOsfb9rgGJ1v8xoDtalItrANicQLrKEyo7hrsFTd8XicJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1494&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;强制遵循规范：&lt;/strong&gt; 通常会要求业务公共的组件逐渐下沉到基础组件层，但随着时间的推移，这个规范很容易被打破&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;需要成熟的团队：&lt;/strong&gt; 领域专家（对业务细节非常熟悉的角色）和开发团队需紧密协作，构建出核心领域模型是关键。但盲目尝试 DDD 往往容易低估领域驱动设计这套方法论的实践成本，譬如将简单问题复杂化、陷入过分强调技术模型的陷阱&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;迄今为止，用于商业应用程序的最流行的软件架构设计模式是大泥球（Big Ball of Mud, BBoM），BBoM 是“......一片随意构造、杂乱无章、凌乱、任意拼贴、毫无头绪的代码丛林。”&lt;/p&gt;&lt;p&gt;泥球模式将扼杀开发，即便重构令人担忧，但也被认为是理所应当。然而，如果还是缺乏对领域知识应有的关注和考量，新项目最终也会走向泥球。没有开发人员愿意处理大泥球，对于企业而言，陷入大泥球就会丧失快速实现商业价值的能力。&lt;/p&gt;&lt;p&gt;——《领域驱动设计模式、原理与实践》Scott Millett &amp;amp; Nick Tune&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;复杂系统熵增不断&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只要业务继续发展，越来越复杂就是必然趋势，这贴合热力学的熵增定律。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以从两个维度来看复杂度熵增的过程：&lt;strong&gt;理解成本变高&lt;/strong&gt;和&lt;strong&gt;预测难度变大&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47959183673469385&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaKIKycrgQkE6ZDSnOzQhbupvyAacR8k0r84szjwhicsKPnWXWnWYBHfOb7FeU5CdcABMcEaTtiaibZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;490&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;理解成本&lt;/strong&gt;：规模和结构是影响理解成本的两个因素&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;宏大的规模&lt;/strong&gt;是不好理解的，譬如：在城市路网中容易迷路，但在乡村中就那么几条道&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;复杂的结构&lt;/strong&gt;是不好理解的，譬如：一个钟表要比一条内裤难以理解&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;当需求增多时，软件系统的规模也会增大，且这种增长趋势并非线性增长，会更加陡峭。倘若需求还产生了事先未曾预料到的变化，我们又没有足够的风险应对措施，在时间紧迫的情况下，难免会对设计做出妥协，头疼医头、脚疼医脚，在系统的各个地方打上补丁，从而欠下技术债（Technical Debt）。当技术债务越欠越多，累积到某个临界点时，就会由量变引起质变，整个软件系统的复杂度达到巅峰，步入衰亡的老年期，成为“可怕”的遗留系统。&lt;/p&gt;&lt;p&gt;正如饲养场的“奶牛规则”：奶牛逐渐衰老，最终无奶可挤；然而与此同时，饲养成本却在上升。&lt;/p&gt;&lt;p&gt;——《实现领域驱动设计 - 深入理解软件的复杂度》张逸&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;预测难度&lt;/strong&gt;：当下的筹码不足以应对未来的变化&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;业务变化不可预测&lt;/strong&gt;，譬如：头条一开始只是一个单端的咨询流产品，5 年前谁也不会预先设计 Lite 版、抖音、懂车帝等，多端以及新的业务场景带来的变化是无法预测的。很多时候，我们只需要在当下做到“恰当”的架构设计，但需要尽可能保持“有序”，一旦脱离了“有序”，那必将走向混乱，变得愈加不可预测&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;技术变化不可预测&lt;/strong&gt;，譬如：作为一个 Java 开发人员，Lambda 表达式的简洁、函数式编程的快感、声明式/响应式 UI 的体验，都是“真香”的技术变化，而陈旧的 Java 版本以及配套的依赖都需要升级，一旦升级，伴随着的就是多版本共存、依赖地狱(传递升级)等令人胆颤的问题。很多时候，我们不需要也没办法做出未来技术的架构设计，但需要让架构保持“清晰”，这样我们能更快的拥抱技术的变化&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;既然注定是逆风局，那跑到最后就算赢。&lt;/p&gt;&lt;p&gt;过多的流程规范反倒会让大家觉得是自己是牵线木偶，牵线木偶注定会随风而逝。&lt;/p&gt;&lt;p&gt;我们应该更多“强调”一些原则，譬如：分而治之、控制规模、保持结构的清晰与一致，而不是要求大家一定要按照某一份指南进行架构设计，那既降低不了复杂度，又跟不上变化。“强调”并不直接解决问题，而是把重要的问题凸显出来，让大家在一定的原则下自己找到问题的解决办法。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;我们的打法&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的套路是：定义问题 → 确定架构 → 方案落地 → 结果复盘。越是前面的步骤，就越是重要和抽象，也越是困难，越能体现架构师的功力。所以，我们打法的第一步就是要认清问题所在。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;认清问题&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;问题分类&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;架构的问题是盘根错节的，将所有问题放在一起，就有轻重缓急之分，就有类别之分。区分问题的类别，就能在一定的边界内，匹配上对应的人来解决问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工程架构：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8418141592920354&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaKIKycrgQkE6ZDSnOzQhbuAyktVESVLf6feTKMf9y6M6ib1ABsU43e4seWpibON7cibNTNqmMmgtQqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1808&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务架构：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5738295318127251&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaKIKycrgQkE6ZDSnOzQhbua3ArBUqynuhXicGuuR2x0tG63mnRibUia2nUEshEJRG1pnYGibkqgsy2yg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1666&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基础能力：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8362831858407079&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaKIKycrgQkE6ZDSnOzQhbuoGouQFKaIUH4eha5KHFPECWCyHNKWZgTibPIIEMn2wW2oMJkgicnVEibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1808&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标准化：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6933333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaKIKycrgQkE6ZDSnOzQhbuoL38PKNrcPUR85dVicLeaANdPH5KGiaBCPBlqIus598krGLguCCaTZJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;问题分级&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;挑战、问题、手段这些经常混为一谈，哪些是挑战？哪些是问题？那些是手段？其实这些都是一回事，就是矛盾，只是不同场景下，矛盾所在的层级不同，举一个例子：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7695783132530121&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaKIKycrgQkE6ZDSnOzQhbusVzv43p7JRrwu40YVUQNC7yIyDfcdLDSD8aAgG3pjM8z69ox73g9AA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;664&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们判断当前的研发体验不能满足业务日渐延伸的需要，这是一个矛盾，既是当下的挑战，也是当下的&lt;strong&gt;一级问题&lt;/strong&gt;。要处理好这个矛盾，我们得拆解它，于是就有了&lt;strong&gt;二级问题&lt;/strong&gt;：我们的代码逻辑是否已经足够优化？研发流程是否已经足够便捷？文档工具是否已经足够完备？二级问题也是矛盾，解决好二级问题就是我们处理一级矛盾的手段。这样&lt;strong&gt;层层递进&lt;/strong&gt;下去，我们就能把握住当前我们要重点优化和建设的一些基础能力：插件化、热更新、跨端能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在具体实践过程中，&lt;strong&gt;基础技术能力&lt;/strong&gt;还需要继续拆解，譬如：热更新能力有很多（Java 层的 Robust/Qzone 超级补丁/Tinker 等，Native 层的 Sophix/ByteFix 等），不同热更方案各有优劣，适用场景也不尽相同。我们要结合现状做出判断，从众多方案汲取长处，要么做出更大的技术突破创新，要么整合已有的技术方案进行组合创新。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;勤于思考问题背后的问题&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;亨利福特说，如果我问客户需要什么，他们会告诉我，他们需要一匹更快的马。从亨利福特的这句话，我们可以提炼出一个最直接的问题：客户需要一匹更快的马。立足这个问题本身去找解决方案，可能永远交不出满意的答卷：寻找更好的品种，更科学的训马方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思考问题背后的问题，&lt;strong&gt;为什么客户需要一匹更快的马？&lt;/strong&gt;可能客户想要更快的日常交通方式，上升了一个层次后，我们立刻找到了更好的解决方案：造车。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们不能只局限于问题本身，还需要看到问题背后的问题，然后才能更容易找到更多的解决方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;认知金字塔&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引用认知金字塔这个模型，谨以此共勉，让我们能从最原始数据中，提炼出解决问题的智慧。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6323529411764706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaKIKycrgQkE6ZDSnOzQhbuxBCuXJpMm8Y8icobOR0HeFlciaptxPZwgDibcoNYKnuLeTEFicAy0fxZKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;544&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;DATA：&lt;/strong&gt; 金字塔的最底层是数据。数据代表各种事件和现象。数据本身没有组织和结构，也没有意义。数据只能告诉你发生了什么，并不能让你理解为什么会发生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;INFORMATION：&lt;/strong&gt; 数据的上一层是信息。信息是结构化的数据。信息是很有用的，可以用来做分析和解读。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;KNOWLEDGE：&lt;/strong&gt; 信息再往上一层是知识。知识能把信息组织起来，告诉我们事件之间的逻辑联系。有云导致下雨，因为下雨所以天气变得凉快，这都是知识。成语典故和思维套路都是知识。模型，则可以说是一种高级知识，能解释一些事情，还能做预测。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;WISDOM：&lt;/strong&gt; 认知金字塔的最上一层，是智慧。智慧是识别和选择相关知识的能力。你可能掌握很多模型，但是具体到这个问题到底该用哪个模型，敢不敢用这个模型，就是智慧。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这就是“DIKW 模型”。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;循序渐进&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;架构的问题不能等，也不能急。一个大型应用软件，并非要求所有部分都是完美设计，针对一部分低复杂性的区域或者不太可能花精力投入的区域，满足可用的条件即可，不需要投入高质量的构建成本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以治理头条复杂度为例：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;长期的架构目标&lt;/strong&gt;：更广（多端复用）、更快（单端开发速度）、更好（问题清理和前置拦截）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;当下的突出问题&lt;/strong&gt;：业务之间耦合太重、缺少标准规范、代码冗余晦涩&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5796232876712328&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaKIKycrgQkE6ZDSnOzQhbuiazy3ANIPHAQJ7ZNxxXKbQdTCBNpTQKNZeqAP9bRbScImVDndxTmRqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2336&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;细节已打码，请读者不要在意。重点在于厘清问题之后，螺旋式上升，做到长期有方向，短期有反馈。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;最后&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一顿输出之后，千万不能忘却了&lt;strong&gt;人文关怀&lt;/strong&gt;，毕竟谋事在人。架构狮得供起来，他们高瞻远瞩，运筹帷幄；但架构人，却是更需要被点亮的，他们可能常年在“铲屎”，他们期望得到认可，他们有的还没有对象...干着干着，架构的故事还在，但人却仿佛早已翻篇。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;加入我们&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们是&lt;strong&gt;今日头条客户端 Android 团队&lt;/strong&gt;，我们的业务方向包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;架构优化（深圳/北京）：负责头条系 APP 的客户端架构、插件、热修等基础能力建设优化等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;增长业务（深圳）：负责头条系 APP 的金币、活动、联动等增长相关业务，海量数据挖掘业务增长；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;安全合规（广州/深圳）：负责头条系 APP 的安全、隐私保护、监管合规等工作；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大量 HC 正在热招，投递简历或问题咨询，可发送邮件到：wangkangning@bytedance.com。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>