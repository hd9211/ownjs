<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>21d5a8064580cd546cd71ee3e1e70ab6</guid>
<title>谈一谈算法工程师的落地能力</title>
<link>https://toutiao.io/k/c7m6qzt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;27&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;27&quot; data-custom=&quot;#1e9be8&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;点击标题下「&lt;em&gt;&lt;strong&gt;搜索与推荐Wiki&lt;/strong&gt;&lt;/em&gt;」可快速关注&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;93040&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;92886&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;▼&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;相关推荐&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;▼&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;strong&gt;1、&lt;/strong&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MDU3OTgyOQ==&amp;amp;mid=2247492967&amp;amp;idx=1&amp;amp;sn=c00788cd4ae9dbc14037ba0631711706&amp;amp;chksm=ea652dfddd12a4ebe0b1bef4fcf332706e46bc18878e667e612fd5343cc6875a3338f6c1aeab&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;腾讯2020广告大赛冠军解决方案带来的思考&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MDU3OTgyOQ==&amp;amp;mid=2247493122&amp;amp;idx=1&amp;amp;sn=1005d5bddd68f5a3f779b10e74d72163&amp;amp;chksm=ea652e98dd12a78ebb6f7079a34a816e22a1ae93a1584d0d7e28b8cb673f64fa234d7c1ddb7f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;span/&gt;&lt;/a&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MDU3OTgyOQ==&amp;amp;mid=2247486905&amp;amp;idx=1&amp;amp;sn=42504fbf91eecd424f0302a5f6a3e1f5&amp;amp;chksm=ea66c523dd114c35f928eb6a053e8471c201a03624b511a333e3bbc39db74698617c7266aa70&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;&lt;strong&gt;2、&lt;/strong&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2MDU3OTgyOQ==&amp;amp;mid=2247492960&amp;amp;idx=1&amp;amp;sn=e2a9628dd4fa2feb41c2b66a168accaf&amp;amp;chksm=ea652dfadd12a4ecdac9a0787d5e110dff36c09c158efa02ecd253020c77d613544d45af1cef&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;&lt;strong&gt;转化率预估中的贝叶斯平滑&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;32&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;作者 | 桔了个仔 &lt;/p&gt;&lt;p&gt;来源 | 文末阅读原文处  &lt;/p&gt;&lt;p&gt;整理 | NewBeeNLP公众号&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，这里是桔了个仔，目前是一名Data Scientist(不太想翻译成数据科学家，毕竟感觉自己就是个工程师），过去几年在做基于机器学习的风控与合规系统，参与了一些算是成功的项目，和团队一起，成功在几个跨国银行那里落地了我们开发的系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据我的经历以及对身边同事的观察，我个人会把落地工程师的「落地能力」分为三个维度： &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7287037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DHibuUfpZvQfyQicaOkUoKbxsW201yrtSPN4PhBNqNx9MBjsAkRw1BNaWasOeWbmN4hW8qLZSia2ChgONwd4hvwMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-backw=&quot;558&quot; data-backh=&quot;407&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.技术层面&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多人以为算法工程师日常工作就是调下参，改个算法再跑跑，直到神经网络输出符合预期。在入行前，他们以为算法工程师的日常是这样的：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.1546296296296297&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DHibuUfpZvQfyQicaOkUoKbxsW201yrtSPG42Nk7ktHdbehvSLkTseNlZz5WJwgHicibGPJWEwIUYWiabDInDiaPS1Xg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-backw=&quot;542&quot; data-backh=&quot;626&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上，算法工程师可能涉及的技术范围是很广的。很可能是这样的：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.38333333333333336&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DHibuUfpZvQfyQicaOkUoKbxsW201yrtSP5ag0q0gSFKOchicpmWSPDQANlNS9fj4D4Qz07quJMjn9o0RxL4tVCOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-backw=&quot;542&quot; data-backh=&quot;208&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;中间那个小小的几乎都快看不见的黑块，你放大图片，会发现里面写着ML Code，这就是「算法」的部分。当然，别被这个图吓到，这不一定全是你的工作，这里是一个团队的任务，这个团队可能是两人的团队，也可能是几十人的团队.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但可以肯定的是，无论你在哪个公司，一个算法工程师都不太可能只做纯&lt;strong&gt;「算法」&lt;/strong&gt;，不要忘了&lt;strong&gt;「工程师」&lt;/strong&gt;三个字。对于要做产品落地的工程师，搞算法的时间很可能不到10%，其他技术部分可能占据你40%。要增强自己落地能力中的技术水平，除了算法要基础打好，你还需要：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;学会数据获取&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原始数据需要经过ETL才能被算法利用。ETL（Extract, Transform, Load）是将业务系统的数据经过抽取、清洗转换之后加载到数据仓库的过程，目的是将企业中的分散、零乱、标准不统一的数据整合到一起，为企业的决策提供分析依据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也许你们公司有专职的数据工程师来做ETL，但你如果能稍微参与到ETL的过程中，不仅让你在大数据技术方面得到提升，而且对你理解上游业务非常有帮助。ETL工具的典型代表有:Informatica、Datastage、OWB、微软DTS等。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;构建特征&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有机会参加到ETL里，也没关系，我也没，毕竟客户不想给让我们接触原始数据。这时候，你也可以处理ETL之后的数据，从中构建特征。其实特征构建的过程能帮助你理解业务，例如给银行预测信用卡逾期风险，你了解到，债务负担率和用户风险有着一定关联，于是你会考虑把用户所有信用卡的欠款加起来除以这个用户的收入，得到一个新的特征。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于相关技术，我知道很多人肯定马上想到pandas，但老实讲句，我做了几年数据工作，能用到pandas的机会真的不多。产品都要落地了，几百万条的数据马上进来了，还在玩pandas？spark, hadoop, flink等分布式计算平台赶紧给我研究起来。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;可视化数据&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我相信问出来这个问题的人都知道哪些python库可以做可视化，例如matplot, seaborn等等。当然，除了python库，excel里的可视化也要做好，这与算法无关，但在你做汇报时能帮助你把一个结果解释清楚。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;会用服务器&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般数据产品部署，得上云或者私有服务器吧，那么如果你还不熟悉linux，那就赶紧练练吧。你把系统部署到服务器时，是不太可能用鼠标拖拽个exe就完事的。如果你还能熟练使用aws等云服务，那就更好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于UI层面，例如构建网页等等，开发app这种，这就不再推荐算法工程师学了，毕竟人的精力有限。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面技术部分花了10%+40%的工作时间，然后其他50%的时间呢？用来和客户或者产品经理沟通，然后理解业务，做ppt，汇报结果。杂事很多，很难接受吧？没错，我刚入行时也是觉得自己一身技术无处施展，后来我上司一句话启发了我：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;p&gt;技术是逻辑的艺术，业务也是，所以只搞技术不管业务的，不能算是逻辑能力出众的。&lt;/p&gt;&lt;span/&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你现在应该有疑问了，那怎么才算&lt;strong&gt;「懂业务」&lt;/strong&gt;？嘿嘿，马上道来。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.业务层面&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实关于「懂业务」，可以分为宏观业务和微观业务两部分。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;宏观业务指的是行业的「共性」&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：你的产品所服务的对象所在的行业都有什么「痛点」。sorry，句子有点长，而且说法也有点「老土」，但了解客户痛点永远都是必须的。例如我做金融风控，客户的痛点是「旧的专家系统规则更新慢」，而我们提供「基于机器学习的方案」，数据来了就自动更新规则，就能解决他们痛点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他们这项业务目前的工作流程如何。例如我做反洗钱，那么我得了解洗钱的三个步骤，反洗钱的警报产生，警报调查等等。这些流程在不同客户之间都是一样的，我了解清楚了这些，我才能知道，我的产品是在哪个环节发挥价值。如果你做的项目是对内的，例如为自己公司电商搞推荐算法，那你必须清楚用户在你们APP上的路径，例如首页到搜索页再到详情页。以及在每条路径上，怎么做推荐商品，例如有的商品是推荐搭配，有的商品是推荐近似替代品。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;微观业务是指不同部门/公司在实践上的不同。&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微观业务是最容易被人忽视的而且也是最辛苦的，因为大家都有不同的「知识沉淀」方式，学习起来并没有那么立竿见影。但我发现有趣的一点是，当你接触微观的业务多了，你还是能从中提取「共性」。例如某个算法工程师，之前在银行做风控，在银行获取数据流程会比较长，每个步骤要做的事情不能跳过；现在去某互联网金融公司做风控，可能获取数据流程变得很短，但是你会发现共性是，大家都有准入审查、逾期催收等环节，用到的技术可能也是相近的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在你已经掌握了各种技术，准备大干一场，准备拿最强的深度学习模型，给客户设计一款准确率非常高的产品。现在你开始学习相关业务，我建议你带着问题学习。不过，你什么都不懂时，你应该问自己的第一个问题是什么？没错，那就是：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;做这个系统的真实需求是什么？&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题很重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有个故事是这样的：某大型日化公司引入了一条国外肥皂生产线，这条生产线将肥皂从原材料加入直到包装箱自动完成。不过产品线有瑕疵，个别肥皂盒是空的，这家公司联系厂商后被告知这是设计上的缺陷，无法避免。于是老板要求工程师们解决这个问题，以数名博士为核心形成一个技术攻关团队，耗费大笔资金之后，终于宣告解决。解决的办法是在生产线上安装一套 X 光机进行扫描识别。在另一家私人企业，老板让新来的小工解决问题，小工所用的办法是，找来一台电风扇放在生产线旁边&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道这是真实故事还是段子，不过我们可以知道的是，如果你只顾着解决自己拿到的问题，而不想问题背后的真实需求是什么，埋头苦干，用复杂的方法来解决个很简单的事，那么会弄出大炮打蚊子的笑话。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个该问自己的问题是：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;有什么制约因素？&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于机器学习系统，落地时的制约因素主要包括（但不限于）：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;开发时间&lt;/strong&gt;。即使项目刚开始，你还不知道要花多久，你也得计划开发时间出来，你计划不出来，领导也会给你设定期限。毕竟做产品不同于做研究，做产品大家都喜欢确定的投入和可预估的汇报。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;计算资源&lt;/strong&gt;。因为机器学习系统使用是需要成本的，你得知道用户能承受怎么样的成本或者自己服务器能承受怎样的成本。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;算法性能&lt;/strong&gt;。算法落地不同于打kaggle比赛，并没有时间能把性能压榨到极致。只要比预期好些，基本就「先用着再说」了&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9462962962962963&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DHibuUfpZvQfyQicaOkUoKbxsW201yrtSPNPyG0QPRpszxyw4bL78exRa5JKOHb61Lgsp4ianX4WCdsic2cOibRZicBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-backw=&quot;516&quot; data-backh=&quot;489&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要在这三个限制因素里面取得微妙的平衡，才能使得产品落地。我刚做数据科学工作时，总喜欢搞算法调优来炫技，但其实压榨算法的边际收益很低，你用一个月把算法准确率从70%提升到80%，可能还不如提前一个月把系统上线使用起来的收益高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三个该问自己的问题是：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;算法、性能评估和业务是否吻合？&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是拿我自己的经历做例子。我工作中面对的数据，是非常的不平衡的，我们做二元分类，100条数据里，标签为1的只有2~3条，其他97~98条数据标签都是0。这个时候显然需要选择一些合理的评估方法，首先就排除了用准确率（Accuracy）作为评判标准了，F1-score, AUC都可以备选。原因？可以看我在另一个问题的举的例子。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如何评价德国训练探雷犬和寻尸犬识别新冠患者，称准确率达94%？嗅探犬接触患者后会成为病毒传播介质吗？&lt;sup&gt;[1]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后是模型选择。银行的业务需要强解释性，所以又否决了所有黑箱模型。剩下的就在tree-based model、logistic regression还有线性kernel的svm之间选择了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上线之后要评价模型对正负样本区分度，于是又要引入KS值。随着时间迁移，数据分布可能会变化，又要引入PSI值来监控数据偏移程度来决定是否重新训练模型。你看，模型和评价指标，都是和业务息息相关的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你看到这里还是感觉到迷茫，不知道怎么补足相关业务知识，例如产品和运营的知识，可以看我之前写的一个回答，这里就不重复叙述了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那怎么检验自己真的「懂业务」了呢？你可以检查下自己能不能做到下面这些点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;检查下自己是否能快速复现方案？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果能快速复现方案，是否能估算每个阶段大致需要多少人多少时间？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面对不同的数据量，能否估算一个大概的服务器性能需求？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.软实力层面&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;懂技术了，又懂业务了，是不是感觉还不够差点什么能力去推动产品落地？这个是抛开技术和业务之外的东西，要描述成一个具体的能力，真的很难，我会把这些能力都归结于「软实力」。我认为主要是表现在沟通，思维这两方面。情商、亲和力、共情能力、有眼光，这些算不算软实力？当然算，但你有没有发现，这些软实力都是基于沟通和思维的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;沟通和思维等软实力包括（但不限于）：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;和客户沟通的能力&lt;/strong&gt;。听你讲的客户并不一定是算法工程师或者数据科学家，你是否能把自己的方案原理讲清楚？设计到技术的概念，是否能让非技术的听众也能大致理解？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;思考能力&lt;/strong&gt;。例如结构化思维和批判性思维。其实有一定套路，只要多加练习就能掌握。推荐书籍有《金字塔原理》、《批判性思维工具》等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;推动团队的能力&lt;/strong&gt;。和个人魅力息息相关。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里说个真实故事，和算法无关，和软实力有关。我大舅是开工厂的，产品良品率之前一直上不去。我二舅退休后就去我大舅厂里做质量监督。我二舅就中学学历，普通话也不标准，但我二舅进厂后，产品良品率上去了，工厂也扭亏为盈了。我问他怎么做到的，他说，很简单啊，对于那些手工不精湛的小伙子，我就亲自做一遍给他看，并告诉他，我一个退休老头都能按质做好，为啥你不行？就这么耐心的一个个沟通，一个个教学，盯着他们直到确认他们能做好为止。看起来这很简单是吧，但这过程需要耐心沟通，需要系统性思维找到关键因素。这就是软实力的表现之一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你观察销售团队的日常，你会发现，他们做的事情看起来简单，大部分时间就是给客户发发邮件，和客户开开会，都是动嘴皮子的事情，但是如果让你去做这些，你会发现你会缺少自己貌似很难推进，你会问自己，自己嘴皮子咋就不那么好呢？软实力就像肌肉，运用软实力的过程就像搬砖，把砖头从A点搬到B点看着很容易，但搬起来才发现自己肌肉还不够强大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而锻炼软实力的方法？无它，只有干多了，软实力才能上去。具体的说，对于算法工程师而言，就是不要逃避那些繁琐的看似没收获的事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如在我为某客户落地风控系统的过程中，我们需要和他们的项目经理保持联系，有问题也要给他们的数据团队反馈。其实这过程还挺难搞，因为他们作为一个跨国大公司，显然数据中心是需要同时对接很多vendor的，所以当和他们合作时，需要经常主动推进项目进度，不然他们的项目经理会问责我们。例如我们有个pipeline每天固定时间要跑，他们作为上游，需要在运行时间前把数据给到我们。当时间到了，数据还没给到我们，我们要做的第一个事，就立马需要给数据团队发送邮件，抄送项目经理，分清责任；然后积极跟进回复，搞清楚原因，和数据团队商量个预计解决时间，并且在这个时间点来临前就问问进度，以预留足够时间来应变。在这些看似繁琐的沟通过程中，我掌握了推进工作的方法，养成了积极推动工作进展，并在deadline来临前检查进度以预留时间应变的好习惯。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;算法工程师的&lt;strong&gt;「落地能力」&lt;/strong&gt;包括技术能力，业务理解，还有软实力。但对自己要求不要太苛刻，就好像你玩游戏时很少能用到每个维度的能力都满分的英雄一样，人的能力是有个频谱的，不可能方方面面都能做得满分，所以不要对自己感到挫败。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就拿我自己说，大家别看我说的头头是道，但是说实话，说了这么多，其实我自己也并不能每个方面都做得好。这个「落地能力频谱」就像是一个打分卡，帮助你从更全面的角度来分析自己的能力频谱。有的人技术不那么精湛，但很懂业务，很会带队，也能使得产品顺利落地；有的人技术满分，但业务和沟通能力欠缺，但配合其他团队成员的优势，也能使得产品顺利落地。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，接受自己的不足，尽可能动态平衡自己的能力频谱，总有一日，你能成为具有超强「落地能力」甚至能独当一面的算法工程师。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一起交流&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果你想和小编一起交流技术，交流心得，扫码下面的微信，一对一沟通吧！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.3146473779385173&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/02kicEWsIniciaZHX6E8pbwVZJwF0hyLqRnHm4XE8duvGxbibWmEvYTmGTrYa32y4209EjEwOCnWaygxen3T6PtBBw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1106&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;如何评价德国训练探雷犬和寻尸犬识别新冠患者，称准确率达94%？嗅探犬接触患者后会成为病毒传播介质吗？: &lt;span&gt;https://www.zhihu.com/question/442962994/answer/1717172385&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;算法工程师如何补足产品和运营知识？: &lt;span&gt;https://www.zhihu.com/question/436066262/answer/1695872348&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3b85ebab7364f82771c3da1123257828</guid>
<title>又有两人要离职……</title>
<link>https://toutiao.io/k/76ood6y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;昨天还在沾沾自喜自己部门还没有人离职，这不今天就啪啪打脸了。本来就人手就不够，还给我一下整出2个。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;小方&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;事情是这样的，大家还记得年前的那篇《内向不应该被误解》文章吗，打年度绩效时，本来是打给了内向的小王的。后来经过思考还是打给了部门内另一个工作量小的小方。（下图这篇文章）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.5188679245283019&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PVZcww4Su3ibia3uv7fKkWckZutmGCiamB0rCJvpiavqjObDc2Myzn6pC3buI8VKCbr9MgDMXVSa6f4eqGwQubWJ7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;636&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;今天下午习惯性的问了他，开发任务进展如何，他告知我已经完成，我再三确认是否经过详细测试了，他不耐烦的说：是的的的！（“的”字拉的很长）。听到这句话，让我惊讶了，这小方今天是不是有啥事不开心？我继续问道：你现在在做什么的？他邹着眉头，提高声音：没什么，我要离职了！这句话直接把我干懵了。我都不知道怎么接话了，愣了几秒钟，把他叫到了会议室。经过深入的沟通，原因也比较简单，就是年前的待提升绩效觉得接受不了，年终奖直接砍半，就想着要离职，当然我表示很无奈，我也帮他努力争取多了一点年终奖，但是杯水车薪。可惜了，哎。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;小威&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;今天晚上9点半的时候，准备下班回家了，正在等待电梯，听到一个非常轻的声音在我耳边响起。“领导，领导，领导…”，我猛一回头，原来是今年刚毕业，校招进来的小明啊。我好奇的问到“咋了，小明~”，他不好意思的，腼腆的笑着：“领导，我有个事情跟你讲下”。我心头一紧，心想这个时候找我沟通肯定十有八九是要离职了。我们来到一个会议室，果然不出我所料，这个小兄弟是想要离职了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来，他跟我说了一大堆的理由，离家太远了，女朋友不在这里，习惯不了公司的经常性的加班，等等…&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我反问到“你对自己的后续职业生涯有长期的规划？”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;他也回答不上来，表达的意思大概就是父母和女朋友都希望回答老家发展。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每一个从我的团队离职的同事，我都会问他们职业规划是怎样的？希望自己成为怎样的人？特别是刚刚毕业的小鲜肉和职场新人，很容易没有清晰的职业规划，总是不停跳槽，最后搞得自己身心俱疲，得不到更多的发展机会。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;结语&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;离职跳槽并没有什么不好，这是一个中性词。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每个人的追求都不太一样。&lt;/span&gt;&lt;span&gt;有的人的志向就是想要干一番事业，能够承受着“996”工作制的高压状态&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;乐于承担&lt;/span&gt;&lt;span&gt;各种&lt;/span&gt;&lt;span&gt;开发任务&lt;/span&gt;&lt;span&gt;，并且&lt;/span&gt;&lt;span&gt;斗志昂扬。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你也是看重这种收益而选择长期高压职场环境的人，我认为在理性看待风险与收益的前提下，这也是相对合理的选择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有的人就想简简单单的过着日子，就大可不必连续加班的工作，可以寻找自己的“静心”场地。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是千万不要贪图安逸却又不甘平庸，内心渴望挑战却又过得四平八稳。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;客观地评估之后，做出的选择和你内心渴求的匹配才是问题的关键。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;---------END---------&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我是袁吴范，一个教你如何提升认知、快速晋升的90后技术总监&lt;span&gt;，&lt;/span&gt;公众号：”pointers“&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;你可以加我微信，&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;拉你进一个高品质群，&lt;/span&gt;&lt;span&gt;&lt;span&gt;群里有开发、产品、技术经理、技术总监&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg4MTU0NTkxNA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PVZcww4Su38XVBkNk2LxyaH1M8JQxTS3zcqP7QooB7uKPrqMZar5mWMJVYI6j7gzWJdwpE7at6dHmlZMVUKk6w/0?wx_fmt=png&quot; data-nickname=&quot;pointers&quot; data-alias=&quot;cpointers&quot; data-signature=&quot;技术大厂总监，专注技术人的认知提升和职业成长&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>579fda63a5aa58c67dcb2e9a230c7740</guid>
<title>2021 的 Node.js 开发人员路线图</title>
<link>https://toutiao.io/k/snaoe21</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;1. JavaScript&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;如果你是一名希望掌握一些后端技能的前端开发人员，那么在开始构建 Node.js 应用程序之前，将不必花费大量时间学习 JavaScript。但是，如果你是一个初学者，希望在尽可能短的时间内掌握 Node.js，那么在深入研究 Node.js 环境之前，必须学习以下概念。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;箭头函数&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据类型&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;表达式&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;函数&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;词法&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;this&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;循环和作用域&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数组&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;模版字符串&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;严格模式&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;ES6/ES7&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在Node.js中，将面对大量的异步编程，为此，建议学习以下概念。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;计时器&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Promises&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;闭包&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;事件循环&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;异步函数&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;回调函数&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;2. NPM&lt;/h2&gt;&lt;p&gt;Node Package Manager 拥有大量的软件包，在我们开发需要大量依赖关系的应用程序时，使用 NPM 包管理程序将非常方便。&lt;/p&gt;&lt;h2&gt;3. Node.js 基础&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Event Emitters&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Callbacks&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Buffers&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Module System&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;4. 版本控制系统&lt;/h2&gt;&lt;p&gt;Git，GitHub&lt;/p&gt;&lt;h2&gt;5. HTTP / HTTPS协议&lt;/h2&gt;&lt;p&gt;了解有关如何使用传输协议传输数据的基础知识将使您成为更好的Node.js开发人员，对HTTP和HTTPS的工作原理有很好的了解。HTTPS使用称为传输层安全性（TLS）的加密协议来加密通信。在后端环境中有很多东西要学习，如果您不了解网络的工作原理，可能会有些困惑，有以下几种请常见的求方法用于网络上的基本通信：&lt;/p&gt;&lt;h2&gt;6. WEB 框架&lt;/h2&gt;&lt;p&gt;以下框架不需要全部精通，择一学习即可。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Express.js&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Meteor.js&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Sails.js&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Koa.js&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Nest.js&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;7. 数据库管理&lt;/h2&gt;&lt;h3&gt;关系型数据库&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;SQL Server&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;MySQL&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;PostgreSQL&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;MariaDB&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;NoSQL数据库&lt;/h3&gt;&lt;h2&gt;8. 全文检索&lt;/h2&gt;&lt;h3&gt;ElasticSearch&lt;/h3&gt;&lt;p&gt;一个基于Apache Lucene并使用Java开发的搜索和分析引擎。使用ElasticSearch，您可以实时存储和分析大量数据。当它搜索索引而不是搜索文本时，ElasticSearch也实现了出色的搜索性能。它的核心是使用基于结构的文档，而不是广泛的REST API附带的用于存储和搜索数据的表和模式。您可以将ElasticSearch视为处理JSON请求并向您返回JSON数据的服务器。&lt;/p&gt;&lt;h3&gt;Solr&lt;/h3&gt;&lt;p&gt;它提供了相当高级的实时搜索功能，例如字段搜索，布尔查询，阶段查询，模糊查询，拼写检查，自动完成等等。&lt;/p&gt;&lt;h2&gt;9. 缓存&lt;/h2&gt;&lt;h3&gt;Memory Cache&lt;/h3&gt;&lt;p&gt;这种技术通常也称为缓存，因为在大多数情况下，缓存与服务器中的内存相关联。在这种技术中，服务器内存的一部分用作缓存，我们在其中存储减少应用程序中的网络调用所需的所有数据。在Node.js中，我们拥有node-cache 和 memory-cache作为一些出色的库来处理nodejs服务器中的内存缓存。&lt;/p&gt;&lt;h3&gt;Distributed Cache&lt;/h3&gt;&lt;p&gt;在这种缓存技术中，我们将多个网络的内存合并到一个内存数据存储中，之后将其用作最终数据缓存以证明对数据的快速访问。此技术尤其适用于大量数据，并且通过向群集添加更多服务器内存，大量的网络调用同时允许增量扩展和扩展。关于分布式缓存，Redis是最著名的事情之一。&lt;/p&gt;&lt;h2&gt;10. 模板引擎&lt;/h2&gt;&lt;p&gt;使用模板引擎，我们可以在应用程序中使用静态模板文件，而在运行时，该模板引擎将模板文件中的变量替换为实际值，然后将模板转换为发送给客户端的HTML文件。下面列出了一些流行的模板引擎。&lt;/p&gt;&lt;h2&gt;11. 实时通讯&lt;/h2&gt;&lt;p&gt;如果您只是作为后端开发人员起步，那么在了解Socket.IO中的实时通信方面有很多事情，实时通信背后的主要逻辑就在于客户端和服务器之间。它允许流动双向客户端与服务器之间的数据，你能想到的双向数据流的数据的两个终端之间的同步流程，实现实时通讯的行为，这类行为被启用时，客户端在浏览器中具有Socket.IO以及与Socket.IO软件包集成的服务器。并且数据可以以JSON请求的形式发送。&lt;/p&gt;&lt;h2&gt;12. API Clients&lt;/h2&gt;&lt;h2&gt;13. 测试&lt;/h2&gt;&lt;p&gt;单元测试框架&lt;br/&gt;在单元测试中，我们隔离地测试各个单元/组件，其中单元可以是应用程序中代码中可测试的最小部分。在Node.js中，下面列出了几种常见的单元测试框架：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/btsCOHx9LAPWWsjRocrDTkNwLZloQWZ36IdgR3UF3aPwKE5juHUXicFU10wN2Pw9ObAjlIXZ5J0iaufdicuINIjww/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.4375&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwNjI5MTYyMw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/btsCOHx9LAO55RFZ2rpHxp8JCdibf2zroiae9jOtwgicS0DIZM6II8CkDDY1icAQ2QakuFr6pkRJgIIdyicDM4FRic2w/0?wx_fmt=png&quot; data-nickname=&quot;JavaScript&quot; data-alias=&quot;FedJavaScript&quot; data-signature=&quot;面向JavaScript爱好人员提供：Web前端最新资讯、原创内容、JavaScript、HTML5、Ajax、jQuery、Node.js、Vue.js、React、Angular等一系列教程和经验分享。&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;mpsearch class=&quot;js_mpsearch appmsg_search_iframe js_uneditable custom_select_card&quot; data-keywords=&quot;%5B%7B%22label%22%3A%22JavaScript%22%7D%2C%7B%22label%22%3A%22Vue%22%7D%2C%7B%22label%22%3A%22React%22%7D%2C%7B%22label%22%3A%22Node.js%22%7D%5D&quot; data-parentclass=&quot;appmsg_search_iframe_wrp&quot; data-ratio=&quot;1.5664335664335665&quot; data-w=&quot;286&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fa12661745939f820ef3480e9fa3ab0e</guid>
<title>让您的 Android Auto 应用吸引更多用户</title>
<link>https://toutiao.io/k/8thoryh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;&lt;i&gt;作者 / 产品经理 Eric Bahna&lt;/i&gt;&lt;/p&gt;&lt;p&gt;去年 12 月份，&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//android-developers.googleblog.com/2020/12/opening-google-play-store-for-more-car.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;我们更新了 Google Play 商店，以允许开发者发布新的 Android Auto 应用进行封闭式测试&lt;/a&gt;&lt;/b&gt;。现在，您可以将导航、停车以及收费类的应用发布到 Google Play 商店进行开放式测试，以触达更多的用户。在开放式测试中，可下载应用的用户数没有任何限制，您也无需管理电子邮件列表。这是一个重要的里程碑，借此我们能够更方便地将这些应用提供给所有实际使用的用户。您可以着手使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/cars/navigation&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Android 汽车应用库&lt;/a&gt;&lt;/b&gt;并在 Play 管理中心选择开放式测试轨道。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-442fdb00a734a6b187dfc33ca24eb770_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1198&quot; data-rawheight=&quot;718&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-442fdb00a734a6b187dfc33ca24eb770_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1198&quot; data-rawheight=&quot;718&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-442fdb00a734a6b187dfc33ca24eb770_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-442fdb00a734a6b187dfc33ca24eb770_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们的早期合作伙伴之一 TomTom AmiGO&lt;/p&gt;&lt;p&gt;提前透露一下我们未来的工作: 我们会将 Android 汽车应用库添加到 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/jetpack&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Android Jetpack&lt;/a&gt;&lt;/b&gt; 中！这样您就能保留与其他 Jetpack API 一致的体验，同时还能查看新的功能。我们添加该 Jetpack 开发库后，您可以轻松将自己的应用从现有库中迁移到该库，只需更改命名空间，并调整一些 API 调用即可。当该 Jetpack 库测试稳定后，我们会准备好 Google Play 商店，以便您能将这些新应用发布到生产轨道上。&lt;/p&gt;&lt;p&gt;当然，您现在就可以着手准备，无需等待该 Jetpack 库上线。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;参考 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/cars/navigation&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;开发者指南&lt;/a&gt;&lt;/b&gt; 和 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/docs/quality-guidelines/car-app-quality&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;应用质量指南&lt;/a&gt;&lt;/b&gt; 设计您的应用。&lt;/li&gt;&lt;li&gt;借助 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/cars/navigation%23install-library&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;当前的 Beta 版开发库&lt;/a&gt;&lt;/b&gt; 进行开发，这样您可以从一开始就获得用户反馈。&lt;/li&gt;&lt;li&gt;使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/cars/testing%23test-auto&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Desktop Head Unit&lt;/a&gt;&lt;/b&gt; 进行测试。&lt;/li&gt;&lt;li&gt;发布到 Google Play 商店 (现可发布至开放式测试轨道)。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们非常期待看到各位构建的应用，赶快尝试吧！&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>023812eb760d255ef4c5a48b51867132</guid>
<title>Android NativeCrash 捕获与解析</title>
<link>https://toutiao.io/k/gdwz713</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Android 开发中，NE一直是不可忽略却又异常难解的一个问题，原因是这里面涉及到了跨端开发和分析，需要同时熟悉 Java，C&amp;amp;C++，并且需要熟悉 NDK开发，并且解决起来不像 Java异常那么明了，本文为了解决部分疑惑，将从NE的捕获，解析与还原等三个方面进行探索。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、NE 简介&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;NE全称NativeCrash，就是C或者C++运行过程中产生的错误，NE不同于普通的 Java 错误，普通的logcat无法直接还原成可阅读的堆栈，一般没有源码也无法调试。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以日常应用层的工程师，即使我们内部有云诊断的日志，一般也会忽略NE的错误，那么遇到这些问题，作为应用层、对C++不甚了解的工程师能否解决还原堆栈，能否快速定位或者解决NE的问题呢？&lt;/p&gt;&lt;p&gt;下面将着重介绍：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.1 so 组成&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们先了解一下 so 的组成，一个完整的 so 由C代码加一些 debug 信息组成，这些debug信息会记录 so 中所有方法的对照表，就是方法名和其便宜地址的对应表，也叫做符号表，这种 so  也叫做未 strip 的，通常体积会比较大。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通常release的 so 都是需要经过一个strip操作的，这样strip之后的 so 中的debug信息会被剥离，整个 so 的体积也会缩小。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如下图所示：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.38005390835579517&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jLP0VMQbkpQpptBGrgSMDQJibtmRDvCIVQoLtATEXsRHgicf4pZ4pHS4CffYe05PiaYW7Eib6L4Lj4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;371&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如下可以看到strip之前和之后的大小对比。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.07561436672967864&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jLP0VMQbkpQpptBGrgSMDzLzUAEV4OianNKlicwP0FDK72vJyOicEp8sUQ2INIuKVSvUglUhTn2x2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1058&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如果对 NE 或者 so 不了解的，可以简单将这个debug信息理解为Java代码混淆中的mapping文件，只有拥有这个mapping文件才能进行堆栈分析。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果堆栈信息丢了，基本上堆栈无法还原，问题也无法解决。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以，这些debug信息尤为重要，是我们分析NE问题的关键信息，那么我们在编译 so 时候务必保留一份未被strip的so 或者剥离后的符号表信息，以供后面问题分析，并且每次编译的so 都需要保存，一旦产生代码修改重新编译，那么修改前后的符号表信息会无法对应，也无法进行分析。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.2 查看 so 状态&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;事实上，也可以通过命令行来查看 so 的状态，Mac下使用 file 命令即可，在命令返回值里面可以查看到so的一些基本信息。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如下图所示，stripped代表是没有debug信息的so，with debug_info, not stripped代表携带debug信息的so。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;file libbreakpad-core-s.so&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;libbreakpad-core-s.so: *******, BuildID[sha1]=54ad86d708f4dc0926ad220b098d2a9e71da235a, stripped&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;file libbreakpad-core.so&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;libbreakpad-core.so: ******, BuildID[sha1]=54ad86d708f4dc0926ad220b098d2a9e71da235a, with debug_info, not stripped&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如果你是 Windows系统的话，那么我劝你装一个 Linux子系统，然后在 Linux执行同样的命令，同样也可以得到该信息。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;接下来看下我们如何获取两种状态下的so。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1.3 获取 strip 和未被 strip 的 so&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;目前Android Studio无论是使用mk或者Cmake编译的方式都会同时输出strip和未strip的so，如下图是Cmake编译so产生的两个对应的so。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;strip之前的so路径：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;build/intermediates/transforms/mergeJniLibs&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;strip之后的so路径：&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;build/intermediates/transforms/stripDebugSymbol&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.1985111662531018&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jLP0VMQbkpQpptBGrgSMD0kP7ciawAMLoHOuicgTylrMzkJDcnkBgr8fBiaLcUmVG7eNY4SdT1JicdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;403&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt; 另外也可以通过Android SDK提供的工具aarch64-linux-android-strip手动进行strip，aarch64-linux-android-strip这个工具位于&lt;/p&gt;&lt;p&gt;/Users/njvivo/Library/Android/sdk/ndk/21.3.6528147/toolchains目录下。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个工具有多种版本，主要针对不同的手机CPU架构，如果不知道手机的CPU架构，可以连接手机使用以下命令查看：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;adb&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;shell cat /proc/cpuinfo&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Processor&lt;/span&gt;   : &lt;span class=&quot;code-snippet__string&quot;&gt;AArch64 Processor rev 12 (aarch64)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如上图可以看到我的手机CPU用的是aarch64，所以使用aarch64对应的工具aarch64-linux-android-strip，由于NDK提供了很多工具，后续都依照此原则使用即可：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aarch64架构&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/Users/njvivo/Library/Android/sdk/ndk/21.3.6528147/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/bin/aarch64-linux-android-strip&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;arm架构&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/Users/njvivo/Library/Android/sdk/ndk/21.3.6528147/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin/arm-linux-android-strip&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;使用如下命令可以直接将debug的so进行strip&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aarch64-linux-android-strip &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;使用Cmake进行编译的时候，可以增加如下命令，可以直接编译出strip的so&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;set&lt;/span&gt;(CMAKE_C_FLAGS_RELEASE &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&lt;span class=&quot;code-snippet__variable&quot;&gt;${CMAKE_C_FLAGS_RELEASE}&lt;/span&gt; -s&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;set&lt;/span&gt;(CMAKE_CXX_FLAGS_RELEASE &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&lt;span class=&quot;code-snippet__variable&quot;&gt;${CMAKE_CXX_FLAGS_RELEASE}&lt;/span&gt; -s&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;使用mk文件进行编译的时候，可以增加如下命令，也可以直接编译出strip的so&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;-fvisibility&lt;/span&gt;=hidden&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、NE 捕获与解析&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;NE解析顾名思议就是堆栈解析，当然所有的前提就是需要保存一份带符号表、也就是未被strip的so，如果你只有strip之后的so，那就无能为力了，堆栈基本无法还原了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一般有以下三种方式可以捕获和还原堆栈。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.1 logcat捕获&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;顾名思义，就是通过logcat进行捕获，我们通过Android Studio打开logcat，制造一个NE，只能看到很多类似#00 pc 00000000000161a0的符号，并没有一个可以直接阅读的日志，我们想通过logcat直接输出一份可以直接阅读的log。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;可以使用Android/SDK/NDK下面提供的一个工具ndk-stack，它可以直接将NE输出的log解析为可阅读的日志。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;ndk-stack一般是位于ndk的工具下面，Mac下的地址为&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/Users/XXXX/Library/Android/sdk/ndk/&lt;span class=&quot;code-snippet__number&quot;&gt;21.3&lt;/span&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;.6528147&lt;/span&gt;/ndk-&lt;span class=&quot;code-snippet__built_in&quot;&gt;stack&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;然后在该目录下执行控制台命令，或者在 Android Studio的terminal中执行也可&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;adb shell logcat | androidsdk绝对路径/ndk-&lt;span class=&quot;code-snippet__built_in&quot;&gt;stack&lt;/span&gt; -sym so所在目录&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如此控制台在应用发生NE的时候便会输出如下日志，由日志可以看出，崩溃对应的so以及对应的方法名，如果有c的源码，那么就很容易定位问题。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;markdown&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;promote:~ njvivo$ adb shell logcat | ndk-stack -sym libbreakpad-core.so&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;code-snippet__strong&quot;&gt;*****&lt;/span&gt; Crash dump: &lt;span class=&quot;code-snippet__strong&quot;&gt;*****&lt;/span&gt;&lt;span class=&quot;code-snippet__strong&quot;&gt;*****&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Build fingerprint: &#x27;vivo/PD1809/PD1809:8.1.0/OPM1.171019.026/compil04252203:user/release-keys&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;#00 0x00000000000161a0 /data/app/com.android.necase-lEp0warh8FqicyY1YqGXXA==/lib/arm64/libbreakpad-core.so (Java_com_online_breakpad_BreakpadInit_nUpdateLaunchInfo+16)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;#01 0x00000000000090cc /data/app/com.android.necase-lEp0warh8FqicyY1YqGXXA==/oat/arm64/base.odex (offset 0x9000)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Crash dump is completed&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;其实ndk-stack这个工具原理就是内部集成利用了addr2line来实时解析堆栈并且显示在控制台中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;看到这里有的小伙伴就觉得那这个不是很简单，但是实际的崩溃场景一是不容易复现，二是用户的场景有时候很难模拟，那么线上的NE崩溃又该如何监测和定位呢，有两种方式。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.2 通过DropBox日志解析--适用于系统应用&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这个很简单，DropBox会记录JE，NE，ANR的各种日志，只需要将DropBox下面的日志传上来即可进行分析解决，下面贴上一份日志示例。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.72890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jLP0VMQbkpQpptBGrgSMD0UNeubbiatU49icOiawqztQ3791QdWoLK2mSosGVlY9FgbMuh6sscexWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;解析方案1：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;借助上述的ndk-stack工具，可以直接将DropBox下面的日志解析成堆栈，从中可以看出，崩溃在breakpad.cpp第111行的Crash()方法中。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ndk-stack -sym /Users/njvivo/Desktop/NE -&lt;span class=&quot;code-snippet__keyword&quot;&gt;dump&lt;/span&gt; data_app_native_crash@1605531663898.txt&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;********** Crash &lt;span class=&quot;code-snippet__keyword&quot;&gt;dump&lt;/span&gt;: **********&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Build fingerprint: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;vivo/PD1809/PD1809:8.1.0/OPM1.171019.026/compil04252203:user/release-keys&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Crash()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/Users/njvivo/Documents/project/Breakpad/breakpad-build/src/main/cpp/breakpad.cpp:&lt;span class=&quot;code-snippet__number&quot;&gt;111&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Java_com_online_breakpad_BreakpadInit_nUpdateLaunchInfo&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/Users/njvivo/Documents/project/Breakpad/breakpad-build/src/main/cpp/breakpad.cpp:&lt;span class=&quot;code-snippet__number&quot;&gt;122&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Crash &lt;span class=&quot;code-snippet__keyword&quot;&gt;dump&lt;/span&gt; is completed&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;解析方案2：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;还是利用Android/SDK/NDK提供的工具linux-android-addr2line，这个工具位于/Users/njvivo/Library/Android/sdk/ndk目录下，有两个版本。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aarch64架构&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/Users/njvivo/Library/Android/sdk/ndk/21.3.6528147/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/bin/aarch64-linux-android-addr2line&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;arm架构&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/Users/njvivo/Library/Android/sdk/ndk/21.3.6528147/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin/arm-linux-androideabi-addr2line&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;命令使用方法如下，结合未被strip的so以及日志里面出现的堆栈符号00000000000161a0，同样可以解析出崩溃地址和方法。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aarch64-linux-android-addr2line -f -C -e libbreakpad-core.so 00000000000161a0&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Crash()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;/Users/njvivo/Documents/project/Breakpad/breakpad-build/src/main/cpp/breakpad.cpp:111&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;基于以上，看似也很简单，但是有一个致命的问题就是DropBox只有系统应用能访问，非系统应用根本拿不到日志，那么，非系统应用该怎么办呢？&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.3 通过BreakPad捕获解析--适用于所有应用&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;非系统应用可以通过google提供的开源工具BreakPad进行监测分析，CrashSDK也是采用的此种方式，可以实时监听到NE的发生，并且记录相关的文件， 从而可以将崩溃和相应的应用崩溃时的启动、场景等结合起来上报。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下面简单介绍一下BreakPad的使用方式。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.3.1 BreakPad的实现功能&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;BreakPad主要提供两个个功能，NE的监听和回调，生成minidump文件，也就是dmp结尾的文件，另外提供两个工具，符号表工具和堆栈还原工具。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4431554524361949&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jLP0VMQbkpQpptBGrgSMDqa1fibcHtEg0baOicqXe83g0aS0XZpB96PhAbbVWdrZDG0vhdicKpjpRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;431&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这两个工具会在编译BreakPad源码的时候产生。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;编译完之后会产生minidump_stackwalk工具，有些同学不想编译的话，Android Studio本身也提供了这个工具。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个minidump_stackwalk程序在Android Studio的目录下面也存在，可以拿出来直接使用，如果不想编译的话，直接到该目录下面取即可，Mac路径为：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/Applications/Android Studio.app/Contents/bin/lldb/bin/minidump_stackwalk&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.3.2 BreakPad的捕获原理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;由上述可以得知，BreakPad在应用发生NE崩溃时，可以将NE对应的minidump文件写入到本地，同时会回调给应用层，应用层可以针对本次崩溃做一些处理，达到捕获统计的作用，后续将minidump文件上传之后结合minidump_stackwalk以及addr2line工具可以还原出实际堆栈，示意图如下：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.734789391575663&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jLP0VMQbkpQpptBGrgSMDwpv65Cw4awKibbFGzZC0yG1uXYL3ibickTwc6tx7qYibMDzK2AA1XULPdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;641&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在应用发生NE时，BreakPad会在手机本地生成一个dump文件，如图所示：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.41875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jLP0VMQbkpQpptBGrgSMD9AkwiaYnJFrMTGMOPELEnTrIWmZoU4apIskoPmdkxiawFusGKWfgFcqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;得到了以上文件，我们只能知道应用发生了NE，但是这些文件其实是不可读的，需要解析这些文件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下面着重讲一下如何分析上面产生的NE：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.3.3 解析dump文件&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1、获取NE崩溃的dump文件，将刚才得到的minidump_stackwalk和dump文件放在同一个目录，也可以不放，填写路径的时候填写绝对路径即可。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;然后在该目录下的终端窗口执行以下命令，该命令表示用minidump_stackwalk解析dump文件，解析后的信息输出到当前目录下的crashLog.txt文件。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;./minidump_stackwalk xxxxxxxx.dmp &amp;gt;crashLog.txt&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2、执行完之后，minidump_stackwalk会将NE的相关信息写到crashLog.txt里面，详细信息如图所示：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jLP0VMQbkpQpptBGrgSMD3wSzwVCytKrmheAzG2HI0DAGydBWsclvCBcFWIKYBOqZ0a1YuENReA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3、根据解析出的NE信息，关注图中红框，可以得知，这个崩溃发生的 &lt;a target=&quot;_blank&quot; href=&quot;http://libcrash-lib.so/&quot; textvalue=&quot;libbreakpad-core.so&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;libbreakpad-core.so&lt;/a&gt; 里面，0x161a0代表崩溃发生在相对根位置偏移161a0的位置&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2.3.4 获取崩溃堆栈&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1、利用之前提到的addr2line工具，可以根据发生Crash的so文件以及偏移地址（0x161a0）可以得出产生crash的方法、行数和调用堆栈关系。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2、在其根目录对的终端窗口运行以下命令。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;arm-linux-androideabi-addr2line -C -f -e ${SOPATH} ${Address}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;-C -f           &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;-e                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;${SOPATH}         &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;${Address}        &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3、如下图是真实运行的示例&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aarch64-linux-android-addr2line -f -C -e libbreakpad-core.so 0x161a0&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Crash()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;/Users/njvivo/Documents/project/Breakpad/breakpad-build/src/main/cpp/breakpad.cpp:111&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;由上图可以知道，该崩溃发生在breakpad.cpp文件的第111行，函数名是Crash()，与真实的文件一致，崩溃代码如下：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Crash&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; *a = (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; *) (&lt;span class=&quot;code-snippet__literal&quot;&gt;NULL&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    *a = &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;extern&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;C&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;JNIEXPORT &lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; JNICALL&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__title&quot;&gt;Java_com_online_breakpad_BreakpadInit_nUpdateLaunchInfo&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(JNIEnv *env, jobject instance,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                                                        jstring mLaunchInfoStr_)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    DO_TRY&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Crash();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt; *mLaunchInfoStr = env-&amp;gt;GetStringUTFChars(mLaunchInfoStr_, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        launch_info = (&lt;span class=&quot;code-snippet__keyword&quot;&gt;char&lt;/span&gt; *) mLaunchInfoStr;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    DO_CATCH(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;updateLaunchInfo&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;基于以上，便可以通过应用收集的dump文件解析的NE的详细堆栈信息。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt; 三、so 符号表的提取&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;3.1 提取 so 的符号表&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;通过以上内容，我们知道，so中包含了一些debug信息，又叫做符号表，那么我们如何将这些debug信息单独剥离出来呢，ndk也给我们提供了相关的工具。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;aarch64架构&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/Users/njvivo/Library/Android/sdk/ndk/21.3.6528147/toolchains/aarch64-linux-android-4.9/prebuilt/darwin-x86_64/bin/aarch64-linux-android-objdump&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;arm架构&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/Users/njvivo/Library/Android/sdk/ndk/21.3.6528147/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin/arm-linux-android-objdump&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如下是命令运行的方式，通过此命令，可以将so中的debug信息提取到文件中。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;promote:~ njvivo$ aarch64-linux-android-objdump -S libbreakpad-core.so &amp;gt; breakpad.&lt;span class=&quot;code-snippet__keyword&quot;&gt;asm&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;3.2 符号表分析&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.2.1 直接分析&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如下图所示就是输出的符号表文件，结合上面的log以及下面的符号表文件，我们同样可以分析出堆栈。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如log中所示，已经表明了崩溃地址是161a0，而161a0对应的代码是*a=1,由上面的分析我们已经知道该崩溃是在breakpad.cpp的111行，也就是*a=1的位置，完全符合预期。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;backtrace:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5jLP0VMQbkpQpptBGrgSMDFTXCqFweWWzYoEBYKyYUo6tcmmGDiao195qUOAAcVibckUk9uciaBHPQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6240740740740741&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.2.2 工具解析&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;google提供了一个Python的工具，将符号表和log结合起来可以直接分析出堆栈，python工具访问&lt;a target=&quot;_blank&quot; href=&quot;https://code.google.com/archive/p/android-ndk-stacktrace-analyzer/&quot; textvalue=&quot;https://code.google.com/archive/p/android-ndk-stacktrace-analyzer/&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;https://code.google.com/archive/p/android-ndk-stacktrace-analyzer/&lt;/a&gt; 可以进行下载。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;执行命令，就可以解析出相关堆栈，该工具可以用于服务端批量进行解析，此处不再详细说明。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;python parse_stack.py &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;asm-file&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;logcat-file&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.2.3 偏移位置简析&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;上面文章提到了一个偏移位置的概念，笔者对此了解也不多，不过大致有一个概念，C代码有一个根位置的代码的，每行代码相对根代码都有一个偏移位置。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如上图示例log中有一行语句&lt;/p&gt;&lt;p&gt;(Java_com_online_breakpad_BreakpadInit_nUpdateLaunchInfo+16)，+16就是代表相对nUpdateLaunchInfo方法的位置往后偏移16。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由上图可以看到，nUpdateLaunchInfo方法的位置是16190，偏移16，也就是16190+10(10进制的16转化16进制后为10)=161a0，同日志输出的一样。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt; 四、总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;以上就是本篇文章的所有内容，主要简述了so的一些基础知识，以及Android中NE的崩溃，捕获解析方案，希望通过该文档对涉及到NE相关的小伙伴带来帮助，同时后续CrashSDK也会支持相关NE的解析功能。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>