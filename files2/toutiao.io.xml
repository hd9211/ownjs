<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f51b8bfcd26e79563274022b552b94ea</guid>
<title>五一没地方去？来这里吧！</title>
<link>https://toutiao.io/k/m70wnkv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;我爱程序员&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;developerWorks&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;我们的产品：《码农周刊》 http://manong.io/ 、《开发者头条》 http://toutiao.io/&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a9c50de2c98dc9ad5ab552fee94187af</guid>
<title>引入『客户端缓存』，Redis6算是把缓存玩明白了…</title>
<link>https://toutiao.io/k/txajf8j</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哈喽大家好啊，我是没更新就是在家忙着带娃的Hydra。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面介绍两级缓存的文章中，我们总共给出了4种实现方案，在项目中整合了本地缓存&lt;code&gt;Caffeine&lt;/code&gt;和远程缓存&lt;code&gt;Redis&lt;/code&gt;，将应用的性能从仅适用单独远程缓存的基础上，再次提高了一个层次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而今天Hydra要和大家分享的技术，在思想上和上面两级缓存有些类似，不过不需要借助其他本地缓存中间件，只使用&lt;code&gt;Redis&lt;/code&gt;自身服务端和客户端就可以实现。这就是&lt;code&gt;Redis6&lt;/code&gt;中的客户端缓存&lt;code&gt;Client-side caching&lt;/code&gt;这一项新特性，它允许将数据缓存在&lt;strong&gt;应用服务端&lt;/strong&gt;以及&lt;strong&gt;远程缓存&lt;/strong&gt;两个位置。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;简介&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端缓存是Redis6众多新特性中比较实用的一项新功能，我们看看官方文档，了解一下它的作用：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;客户端缓存是一种用于创建高性能服务的技术，它可以利用&lt;strong&gt;应用服务器&lt;/strong&gt;上的可用内存（这些服务器通常是一些不同于数据库服务器的节点），在这些应用服务端来直接存储数据库中的一些信息。&lt;/p&gt;&lt;p&gt;与访问数据库等网络服务相比，访问本地内存所需要的时间消耗要少得多，因此这个模式可以大大缩短应用程序获取数据的延迟，同时也能减轻数据库的负载压力。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这，我心想这不是和其他本地缓存Guava、Caffeine啥的一样吗，换汤不换药，都是使用的应用服务的内存罢了。要说有什么好处，可能就是我在项目中能少引入一个中间件了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，我这点浅薄的猜想，在看完客户端缓存的具体应用模式后，彻底被颠覆了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;两种模式&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在了解了客户端缓存的基本功能后，我们来看看它的两种基本应用模式。Redis的客户端缓存支持被称为&lt;code&gt;tracking&lt;/code&gt;，个人感觉翻译为对key的&lt;strong&gt;追踪&lt;/strong&gt;就很好理解，它具有两种模式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;默认模式，服务端会记录某个客户端具体访问过哪一些&lt;code&gt;key&lt;/code&gt;，当这些&lt;code&gt;key&lt;/code&gt;对应的值发生变化时，会发送失效消息给这些客户端。这个模式会在服务端消耗一些内存，但是发送失效消息的范围，被限制在了客户端存储了的&lt;code&gt;key&lt;/code&gt;的集合范围内&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;广播模式，服务端不会再记录某个客户端访问了哪些&lt;code&gt;key&lt;/code&gt;，因此这个模式不消耗服务端的内存。取而代之的是，客户端需要订阅&lt;code&gt;key&lt;/code&gt;的特定前缀，每当符合这个前缀的&lt;code&gt;key&lt;/code&gt;对应的值发生改变时，客户端都会收到通知消息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里，它和我们之前使用的两级缓存之间差异，是不是已经初露端倪了呢？如果还不熟悉两级缓存的架构，那么可以先来看看下面的这张图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4039158810732415&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbdISYMMsL8iaw6JWTYeElpIfwWIbTXwKx9bO6IQnWHgQ8wJ5GeFicia4uTa60PXcB7R0X2poXJ76PsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1379&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种架构在理论上看起来不错，但是实际使用起来需要注意的点不少，尤其是在分布式模式下，需要保证各个主机下的一级缓存的一致性问题，回想一下我们原先的解决方案，可以使用redis本身的&lt;strong&gt;发布/订阅&lt;/strong&gt;功能来实现：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4524053224155578&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbdISYMMsL8iaw6JWTYeElpIJxlOVudq9zMusjqV8y0EaUjWCu7fIXbhm1GYibvGdfP8PgHiaPHZAmpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;977&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而客户端缓存的出现，大大简化了这一过程。我们以&lt;strong&gt;默认模式&lt;/strong&gt;为例，看一下使用了客户端缓存后的操作过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5650406504065041&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbdISYMMsL8iaw6JWTYeElpIuavKHIuHUsqicwelYcT9ovvmgOyDfQ0w9icEVFlZORSLzLTsKA1GADfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;984&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比原先的发布/订阅模式，我们可以看到明显的优势，使用客户端缓存功能后，我们只需要单纯的修改redis中的数据就可以了，手动处理发布/订阅消息的这一过程可以完全被省略。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;优势&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，在了解了客户端缓存的基本功能与两种模式后，我们来对比一下，和传统的只使用redis做远程缓存、以及使用整合后的两级缓存相比较，客户端缓存具有什么样的优势。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当应用的服务端存在缓存时，会直接读取本地缓存，能够减少网络访问上造成的延迟，从而加快访问速度&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同时也能减少访问redis服务端的次数，降低redis的负载压力&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在分布式环境下，不再需要通过发布订阅来通知其他主机更新本地缓存，来保证数据的一致性。使用客户端缓存后，它所具有的原生的消息通知功能，能很好地支持作废本地缓存，保证之后访问时能取到更新后的新数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;误区&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开始演示客户端缓存的使用之前，我们先来纠正一个误区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然这个新特性被称为&lt;strong&gt;客户端缓存&lt;/strong&gt;，但是redis本身不提供在应用服务端缓存数据的功能，这个功能要由&lt;strong&gt;访问redis的客户端&lt;/strong&gt;自己去实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说白了，也就是redis服务端只负责通知你，你缓存在应用服务本地的这个key已经作废了，至于你本地如何缓存的这些数据，redis并不关心，也不负责。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;功能演示&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面将通过一些实例来进行演示，本文代码的运行前提条件是你已经装好了&lt;code&gt;Redis6.x&lt;/code&gt;版本，linux环境下可以直接从官网下载后编译安装，windows环境下的安装可以参考 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTgzOTQ0Ng==&amp;amp;mid=2247488620&amp;amp;idx=1&amp;amp;sn=0065c23e5055adddbe9ead318a49c9c6&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;手摸手教你在Windows环境下运行Redis6.x&lt;/a&gt; 这篇文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;概念上的东西我们也大体了解了，下面我们分别来看一下客户端缓存具体实现的三种模式（至于为什么多了一种，后面再来细说）。在正式开始前，强烈建议大家先花个十几分钟了解一下 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIwMTgzOTQ0Ng==&amp;amp;mid=2247489005&amp;amp;idx=1&amp;amp;sn=ef5ceda185c92758e98b36888d53d34d&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Redis6底层的通信协议RESP3&lt;/a&gt;，否则在看到具体的通信内容时可能会存在一些疑问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先做一下准备工作，通过&lt;code&gt;telnet&lt;/code&gt;连接redis服务，并切换到&lt;code&gt;resp3&lt;/code&gt;协议模式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;telnet 127.0.0.1 6379&lt;br/&gt;hello 3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;1、默认模式&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用客户端连接到redis服务后，需要先通过指令开启&lt;code&gt;tracking&lt;/code&gt;模式的功能，因为在客户端连接后这个选项是默认关闭的，会无法收到失效类型的&lt;code&gt;push&lt;/code&gt;消息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;开启&lt;/span&gt;&lt;br/&gt;client tracking on&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;关闭&lt;/span&gt;&lt;br/&gt;client tracking off&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当开启&lt;code&gt;tracking&lt;/code&gt;后的默认模式下，redis服务端会记录每个客户端请求过的key，当key对应的值发生变化时，会发送失效信息给客户端。简单总结一下，也就是说这个模式能够生效的&lt;strong&gt;必要前提条件&lt;/strong&gt;有两个：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们还是在&lt;code&gt;telnet&lt;/code&gt;中来模拟一下这个过程，分别启动两个redis客户端，在client1中先执行&lt;code&gt;get&lt;/code&gt;命令后，再在client2对相同的key执行&lt;code&gt;set&lt;/code&gt;操作修改它的值，之后就会在client1中收到&lt;code&gt;push&lt;/code&gt;类型的消息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9079563182527302&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbdISYMMsL8iaw6JWTYeElpIBy8dicdc0qhE2HicicW5lmxoLhojOibBaNrjGd06MGsnjoJV6zsHWm5tYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;641&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;push&lt;/code&gt;类型的消息我们在RESP3中介绍过了，这里简单再唠叨两句：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;&lt;br/&gt;invalidate&lt;br/&gt;*1&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;br/&gt;user&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;起始的第一字节&lt;code&gt;&amp;gt;&lt;/code&gt;表示该消息为&lt;code&gt;push&lt;/code&gt;类型，后面消息体中包含了两部分内容，第一部分表示收到的消息类型为&lt;code&gt;invalidate&lt;/code&gt;，也就是作废类型的信息，第二部分则是需要作废的key是&lt;code&gt;user&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，当一个缓存的key到达失效时间导致过期，或是因为到达最大内存，要使用驱逐策略进行驱逐时，也会对客户端发送&lt;code&gt;PUSH&lt;/code&gt;的消息。下面以缓存的key过期为例：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.9145299145299146&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbdISYMMsL8iaw6JWTYeElpI7zK86c5B5Cp4UGaxy9dULWtAav83AnuYtVLkichLkjTuicQiagHGDcQUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;351&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，对于单个key来说，这个&lt;code&gt;tracking&lt;/code&gt;消息只会对客户端发送一次，当第二次修改该key所对应的值后，客户端不会再收到&lt;code&gt;tracking&lt;/code&gt;的消息。只有对这个key再执行一次&lt;code&gt;get&lt;/code&gt;命令，之后才会再次收到&lt;code&gt;tracking&lt;/code&gt;消息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8611544461778471&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbdISYMMsL8iaw6JWTYeElpImbfxhg4gz6OBUhI48weyQTPicGLHyINMY3BhD2zgDqWyGKNDyOAQNSg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;641&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认模式虽然使用起来简单，但是需要在服务端存储客户端的访问数据，记录哪些key被哪些客户端访问过。如果访问的不是少量的热点数据的话，可能会占用大量redis服务端的内存空间。应对这种情况，可以试一试下面要介绍的广播模式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;2、广播模式&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在广播模式&lt;code&gt;BCAST&lt;/code&gt;下，redis服务端不再记录key的访问情况，而是无差别地向所有开启&lt;code&gt;tracking&lt;/code&gt;广播的客户端发送消息。这样一来，好处就是不需要浪费redis服务端的内存进行记录，但是坏处就是客户端可能会收到过多的消息，其中可能还会包含自己不需要的一些key。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用前，需要先通过命令开启广播模式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;client tracking on bcast&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面，我们通过一个例子来进行广播模式的使用演示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.06396255850234&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbdISYMMsL8iaw6JWTYeElpIXcUMZBcx6nar5oclMBx9G77jVF5JUbvU63jNrvGMLmciak5kSLOYLCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;641&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到在开启广播模式后，只要在client2中修改了key对应的值，在client1中都会收到作废消息，而不管client1之前在本地是否进行过缓存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且，另外一点和默认模式不同的是，广播模式是能够重复多次收到一个key的失效消息的，因为服务端没有记录，所以只要有key发生了修改，客户端就会收到失效消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候，有的小伙伴可能就要问了，如果我不想收到这么多没用的冗余消息，有没有什么办法进行一下过滤或精简呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是可以的，在广播模式下，客户端可以只关注一些&lt;strong&gt;特定前缀&lt;/strong&gt;的key，表示我只需要接收这些前缀的key，其他的就不要发给我了。命令格式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;client tracking on bcast prefix myprefix&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来看一下使用过程的示例：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9547581903276131&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbdISYMMsL8iaw6JWTYeElpIkB3wc37bHabT5VvXTshZHJWziaAbAvPapfXf5ILlpdPIQKxPwOSiaegw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;641&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，在设置了只关注以&lt;code&gt;order:&lt;/code&gt;作为前缀的key后，成功过滤掉了&lt;code&gt;user&lt;/code&gt;的失效消息。从这个角度来看，也要求了我们在缓存一个类型的数据时，都以相同的单词作为前缀，规范了我们在使用缓存中对key的命名规则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于在业务中具体要使用哪种模式，可能更多的需要进行一下权衡。看一下你究竟是能忍受占用更多redis服务端的内存，还是能够忍受收到大量不需要的失效消息。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;3、转发模式&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认模式和广播模式的生效，都要在开启&lt;code&gt;RESP3&lt;/code&gt;协议的前提下，具体原因看过上面的例子大家应该也都清楚了，因为要使用&lt;code&gt;tracking&lt;/code&gt;的话，就必须要借助到&lt;code&gt;RESP3&lt;/code&gt;协议中的新的&lt;code&gt;push&lt;/code&gt;消息类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么如果客户端还是使用的旧版本&lt;code&gt;RESP V2&lt;/code&gt;的话，也想要体验这一功能，应该如何进行改造呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不得不说redis6的开发者想的还是蛮全面的，为了适配&lt;code&gt;RESP V2&lt;/code&gt;，专门设计了一种新的&lt;strong&gt;转发模式&lt;/strong&gt;，允许使用旧版本协议的客户端通过&lt;code&gt;Pub/Sub&lt;/code&gt;发布订阅功能来接收key的失效信息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.444794952681388&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbdISYMMsL8iaw6JWTYeElpIdfRS9Jnu0OPqzpeFN3Tqh8L6iaOuLSj3duic243oZxTVvopEFUFpB23A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;951&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面这张图可以看到，转发模式的核心就是redis服务端会将原先&lt;code&gt;push&lt;/code&gt;类型的&lt;code&gt;tracking&lt;/code&gt;信息，转发到订阅了&lt;code&gt;_redis_:invalidate&lt;/code&gt;这一信道的被指定的客户端上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来梳理一下上面的流程，首先在client1需要使用指令开启转发模式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;client tracking on bcast redirect [client-id]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对广播模式，多了两个参数，&lt;code&gt;redirect&lt;/code&gt;表示为转发模式，后面的&lt;code&gt;client-id&lt;/code&gt;表示消息要发送给哪一个客户端，客户端的id可以在client2上通过&lt;code&gt;client id&lt;/code&gt;指令获取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在client2中，则需要订阅指定的信道：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;subscribe _redis_:invalidate&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实说白了，转发模式还是使用的发布订阅功能罢了，只不过redis帮我们解放了双手，把发送消息的工作由自己完成了。整个操作的流程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8621997471554994&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicbdISYMMsL8iaw6JWTYeElpI0V1QIuzTVQYDBfPq6CZQRqTiaSk1Kpiay83IuDQA8wIqFoEUibWqKsC9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;791&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，client2中收到的消息格式与之前的&lt;code&gt;push&lt;/code&gt;类型消息不同，是一条RESP V2中多条批量回复格式的消息，表示的含义同样是收到的key已经作废掉了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，虽然说开启转发模式的指令中也带了一个&lt;code&gt;bcast&lt;/code&gt;，但是它和广播模式有着非常大的区别。在转发模式下，&lt;code&gt;key&lt;/code&gt;的作废消息只能被转发到一个客户端上，如果先后执行两条指定转发指令，那么后执行的指令会覆盖前一指令中转发的&lt;code&gt;client-id&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8060965283657917&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zpom4BeZSicbdISYMMsL8iaw6JWTYeElpI3ia7QMXQg1ib5YWibVv4OL6iaaX5VQiaeSYS0uLq05o0ickiabMe4gRHZ4gdw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1181&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里是不是多少感觉这个转发模式有点鸡肋，毕竟实际的业务场景中很有可能会有多个客户端的存在，只能转发一个实在是有点说不过去了。不过，也有可能作者就是这么设计，留点缺陷，好让大家更快地拥抱&lt;code&gt;RESP3&lt;/code&gt;……&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好啦，到这里客户端缓存的基本理论和使用就介绍的差不多了，不得不说，Redis6的这个新特性确实给了我们眼前一亮的感觉。从这个新特性也可以看出，Redis大有把缓存从服务端的局限中挣脱出来，染指向客户端，一统缓存江湖的意味。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过这个过程应该并不简单，就像我们前面说的，毕竟只有Redis服务端还不够，还需要优秀的客户端进行支持才行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么下一篇文章，我们就来从实战角度，看看如何改造客户端，让&lt;code&gt;client-side caching&lt;/code&gt;能在项目中落地开花。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次的分享就到这里，我是Hydra，下篇文章再见。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;官方文档：&lt;/p&gt;&lt;p&gt;https://redis.io/docs/manual/client-side-caching/&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>31be310e12f5148c6efbd2ea28b28bc4</guid>
<title>Golang用proto文件同时生成gRPC和HTTP</title>
<link>https://toutiao.io/k/t6bq5xo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;strong&gt;&lt;span&gt;这里是Z哥的个人公众号&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;每周五11：45 按时送达&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;当然了，也会时不时加个餐～&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;我的第「224」篇原创敬上&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;大家好，我是Z哥。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;做技术的都知道，程序之间的通讯，常用的方式有两种，RPC 和 HTTP。普遍的共识是系统内部的各个子系统之间的通讯用 RPC，与外部系统之间的通讯用 HTTP。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了避免需要分别编写两套契约文件来生成两套 API（.proto 和 .api），如果能够根据同一份契约文件生成两套 API 的代码就太棒了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Z哥目前所在的公司，rpc 使用的框架是 gRPC，所以自然先想得是，是否能够根据一份 proto 文件，同时生成 gRPC 和 HTTP 的 stub 代码呢。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;网上很快就找到了一个符合要求的框架。相信不少 gopher 们应该也听说过或者正在使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;46&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;https://github.com/grpc-ecosystem/grpc-gateway&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;框架的原理用一张图即可表达。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6785714285714286&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oB5bd6W6hI3YVXf0Zbucyv7GAQTfuVjCp8knSDvjvU1dKFAWCicc48BNHNtLeH8NJJOIU30l0cibCsyXZ3ZWqgEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1120&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过一份 proto 文件，在生成 gRPC 代码的同时生成一个基于 HTTP1.1 + JSON 的反向代理 gateway，如此一来，既可以通过 gRPC 的方式直接调用实际的 server ，也可以通过反向代理中转一次来访问 server。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具体的使用方式看 github 上的官方教程即可，Z 哥和你主要聊一下其中可能会遇到的卡点。毕竟国内的网络情况你懂的，有些操作可能会遇到一些困难。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;/01  不会科学上网不要用buf/&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;教程里提供了两种来操作，一种是通过基础工具 protoc 来操作，另一种是通过一个基于 protoc 封装的工具 buf 来操作。protoc 可以基于 go mod 来安装，鉴于 go mod 还有国内的镜像站点可以解决访问的困难，建议不会科学上网的小伙伴通过 protoc 来操作，因为你没办法成功安装 buf。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;/02  手动下载 googleapis 的repo/&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;然后，当你定义 gateway 的时候，需要引入一些 google 的 packages，怎么办呢？直接去 github 上下载，具体地址是：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;40&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;https://github.com/googleapis/googleapis&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;如果可以的话，建议把整个仓库都下载下来，否则就单独下载教程里提到的4个文件即可。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;特别要注意的是，在 googleapis/google/目录下缺少的 protobuf 相关文件需要到下面的 repo 里去下载，并且放到 googleapis/google/目录下。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;73&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;https://github.com/protocolbuffers/protobuf/tree/main/src/google/protobuf&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/03  protoc -I 指定查找目录/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;官方教程里的 protoc -I . 只会查找当前命令执行所在目录的范围，所以如果你下载的 googlesapi 不存放在当前目录下，则需要增加额外信息指定一下查找目录。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;指定的方式是再增加一个 -I，命令如下（其中第二行就是新增的用于查找 google packages 的目录）：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;protoc&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;-I ./ \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    -I $GOPATH/src/googleapis\&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    --grpc-gateway_out ./gen/go \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    --grpc-gateway_opt logtostderr=true \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    --grpc-gateway_opt paths=source_relative \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    --grpc-gateway_opt generate_unbound_methods=true \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    your/service/v1/your_service.proto&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果还有其它目录需要查找，那么继续增加 -I 即可。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;好了需要注意的点就是以上3个，官方教程中提到的三个命令可以一起执行，这样便可同时生成 gRPC server、gateway 和 swagger.json ：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;protoc&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;-I ./ \&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    -I $GOPATH/src/googleapis\&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    --go_out ./gen/go/ --go_opt paths=source_relative \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    --go-grpc_out ./gen/go/ --go-grpc_opt paths=source_relative \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    --grpc-gateway_out ./gen/go/  \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    --grpc-gateway_opt logtostderr=true \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    --grpc-gateway_opt paths=source_relative \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    --grpc-gateway_opt generate_unbound_methods=true \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    --openapiv2_out . --openapiv2_opt logtostderr=true \&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    your/service/v1/your_service.proto&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;关于一些gRPC-Gateway的其它用法可以参考：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;46&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;https://grpc-ecosystem.github.io/grpc-gateway/&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;好了，这篇呢，Z哥和你分享了如何用一份 proto 文件同时生成 gRPC 和 HTTP 的 Stub 代码以及 Swagger 文档。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如此不但可以提高效率，还可以避免维护两份不同的契约文件所带来不一致风险，希望对你有所帮助。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原创不易，如果你觉得这篇文章还不错，就「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;点赞&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」或者「&lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;」一下吧，鼓励我的创作 ：）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也可以分享我的公众号名片给有需要的朋友们。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU2NzEwMDc4OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/oB5bd6W6hI1ENbrFbGjEucl1Az92hEuwmUSdaNXxibiaWuO9sLTPHokw00p8ZxAYdIJJJ7FXj77Ts0YoV5KwEKCA/0?wx_fmt=png&quot; data-nickname=&quot;跨界架构师&quot; data-alias=&quot;Zachary_ZF&quot; data-signature=&quot;坚持原创。专注大型互联网技术，涉猎产品、运营。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如果你有关于软件架构、分布式系统、产品、运营的困惑&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以试试点击「&lt;strong&gt;阅读原文&lt;/strong&gt;」&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9e55c5ec2faf1027147a89e3430125fb</guid>
<title>vector初始化与否导致的巨大性能差异</title>
<link>https://toutiao.io/k/8uzcpmb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzk0MzI4OTI1Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHhKgtwWvzaYZodgfpphdA6WWKEMXTn6ImCCCuEzlPKicNBcpzBUyjK1XicWwqIwusqLGpwyyOc87JPQ/0?wx_fmt=png&quot; data-nickname=&quot;高性能架构探索&quot; data-alias=&quot;gxnjgts&quot; data-signature=&quot;毕业于中国科学技术大学，现任某互联网公司高级技术专家一职。专注于分享干货，硬货，欢迎关注😄&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你好，我是雨乐！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近在优化引擎代码，在优化的过程中发现一个很奇怪的问题，一个简单的对象，存放在std::vector&amp;lt;&amp;gt; v中，如果v定义的时候为每个元素指定初值，那么后面对v中每个元素的写就飞快；相反的，如果v定义的时候，不指定初始值，那么后面对v中元素写操作的时候，就花费大约前一种2-3倍的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天，借助此文，分享下原因的排查过程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;问题&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了能够快速说明问题，直接上代码吧，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;chrono&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;functional&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; num = &lt;span&gt;1000000000&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;AdItem&lt;/span&gt;&lt;br/&gt;{&lt;/span&gt;&lt;br/&gt;     AdItem() {}&lt;br/&gt;&lt;br/&gt;     AdItem(&lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt; y, &lt;span&gt;int&lt;/span&gt; z)&lt;br/&gt;     {&lt;br/&gt;         x_ = x; y_ = y; z_ = z;&lt;br/&gt;     }&lt;/code&gt;&lt;code&gt;&lt;br/&gt;     &lt;span&gt;int&lt;/span&gt; x_;&lt;br/&gt;     &lt;span&gt;int&lt;/span&gt; y_;&lt;br/&gt;     &lt;span&gt;int&lt;/span&gt; z_;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;time_report&lt;/span&gt;&lt;span&gt;(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;::function&amp;lt;&lt;span&gt;void&lt;/span&gt;()&amp;gt; &amp;amp;f1, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;::function&amp;lt;&lt;span&gt;void&lt;/span&gt;()&amp;gt; &amp;amp;f2)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;auto&lt;/span&gt; start = &lt;span&gt;std&lt;/span&gt;::chrono::high_resolution_clock::now();&lt;br/&gt;   f1();&lt;br/&gt;   &lt;span&gt;auto&lt;/span&gt; end = &lt;span&gt;std&lt;/span&gt;::chrono::high_resolution_clock::now();&lt;br/&gt;   &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;allocation done in &quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::chrono::duration_cast&amp;lt;&lt;span&gt;std&lt;/span&gt;::chrono::milliseconds&amp;gt;(end - start).count() &amp;lt;&amp;lt; &lt;span&gt;&quot;ms&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;   start = &lt;span&gt;std&lt;/span&gt;::chrono::high_resolution_clock::now();&lt;br/&gt;   f2();&lt;br/&gt;   end = &lt;span&gt;std&lt;/span&gt;::chrono::high_resolution_clock::now();&lt;br/&gt;   &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;assignment done in &quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::chrono::duration_cast&amp;lt;&lt;span&gt;std&lt;/span&gt;::chrono::milliseconds&amp;gt;(end - start).count() &amp;lt;&amp;lt; &lt;span&gt;&quot;ms&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;uninitialized_performance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;AdItem&amp;gt; v;&lt;br/&gt;  time_report([&amp;amp;v]() { v.reserve(num); },&lt;br/&gt;          [&amp;amp;v]() {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; num; ++i) {&lt;br/&gt;              v[i] = {i + &lt;span&gt;2&lt;/span&gt;, i + &lt;span&gt;4&lt;/span&gt;, i + &lt;span&gt;6&lt;/span&gt;};&lt;br/&gt;            } });&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;initialized_performance&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;AdItem&amp;gt; v;&lt;br/&gt;  time_report([&amp;amp;v]() { v.assign(num, AdItem{&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;}); },&lt;br/&gt;          [&amp;amp;v]() {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; num; ++i) {&lt;br/&gt;              v[i] = {i + &lt;span&gt;2&lt;/span&gt;, i + &lt;span&gt;4&lt;/span&gt;, i + &lt;span&gt;6&lt;/span&gt;};&lt;br/&gt;            } });&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;     uninitialized_performance();&lt;br/&gt;     initialized_performance();&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序输出如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;allocation done in 0ms&lt;br/&gt;assignment done in 59ms&lt;br/&gt;allocation done in 46ms&lt;br/&gt;assignment done in 27ms&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论使用&lt;code&gt;-g -O2 -O3&lt;/code&gt;都是一样的效果，执行多次结果仍然一样。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;CPU Cache&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;CPU缓存（CPU Cache）位于CPU与内存之间的临时存储器，它的容量比内存小但交换速度快。在缓存中的数据是内存中的一小部分，但这一小部分是短时间内CPU即将访问的，当CPU调用大量数据时，就可避开内存直接从缓存中调用，从而加快读取速度。&lt;/p&gt;&lt;p&gt;在CPU中加入缓存是一种高效的解决方案，这样整个内存储器（缓存+内存）就变成了既有缓存的高速度，又有内存的大容量的存储系统了。缓存对CPU的性能影响很大，主要是因为CPU的数据交换顺序和CPU与缓存间的带宽引起的。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到结果以后，第一反应是CPU Cache导致，因为占用的内存大小一样，所以怀疑在第二次访问的时候，因为CPU Cache中已经有缓存，所以直接使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了确认是否是因为CPU Cache而导致的性能差异，所以将测试分成两个独立的程序进行，即分别执行&lt;code&gt;uninitialized_performance()&lt;/code&gt;和&lt;code&gt;initialized_performance()&lt;/code&gt;函数，结果与之前的一致，所以&lt;strong&gt;排除CPU Cache的原因&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;perf工具&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;perf是用来进行软件性能分析的工具,可以利用PMU、tracepoint和内核中的特殊计数器来进行性能统计，用来分析内核和应用程序的性能。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;perf stat uninitialized_performance&lt;/code&gt;结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Performance counter stats &lt;span&gt;for&lt;/span&gt; &lt;span&gt;&#x27;uninitialized_performance&#x27;&lt;/span&gt;:&lt;br/&gt;&lt;br/&gt;         47.923956      task-clock (msec)         &lt;span&gt;#    0.985 CPUs utilized&lt;/span&gt;&lt;br/&gt;                 6      context-switches          &lt;span&gt;#    0.125 K/sec&lt;/span&gt;&lt;br/&gt;                 0      cpu-migrations            &lt;span&gt;#    0.000 K/sec&lt;/span&gt;&lt;br/&gt;             1,007      page-faults               &lt;span&gt;#    0.021 M/sec&lt;/span&gt;&lt;br/&gt;        99,354,240      cycles                    &lt;span&gt;#    2.073 GHz                      (83.33%)&lt;/span&gt;&lt;br/&gt;        72,689,011      stalled-cycles-frontend   &lt;span&gt;#   73.16% frontend cycles idle     (83.46%)&lt;/span&gt;&lt;br/&gt;        48,738,086      stalled-cycles-backend    &lt;span&gt;#   49.05% backend cycles idle      (66.66%)&lt;/span&gt;&lt;br/&gt;        98,377,529      instructions              &lt;span&gt;#    0.99  insn per cycle&lt;/span&gt;&lt;br/&gt;                                                  &lt;span&gt;#    0.74  stalled cycles per insn  (83.32%)&lt;/span&gt;&lt;br/&gt;        11,399,060      branches                  &lt;span&gt;#  237.857 M/sec                    (83.39%)&lt;/span&gt;&lt;br/&gt;            19,617      branch-misses             &lt;span&gt;#    0.17% of all branches          (83.16%)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;perf stat initialized_performance&lt;/code&gt;结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;76.092443      task-clock (msec)         &lt;span&gt;#    0.991 CPUs utilized&lt;/span&gt;&lt;br/&gt;                 6      context-switches          &lt;span&gt;#    0.079 K/sec&lt;/span&gt;&lt;br/&gt;                 0      cpu-migrations            &lt;span&gt;#    0.000 K/sec&lt;/span&gt;&lt;br/&gt;             1,007      page-faults               &lt;span&gt;#    0.013 M/sec&lt;/span&gt;&lt;br/&gt;       157,742,162      cycles                    &lt;span&gt;#    2.073 GHz                      (82.94%)&lt;/span&gt;&lt;br/&gt;       110,940,710      stalled-cycles-frontend   &lt;span&gt;#   70.33% frontend cycles idle     (82.96%)&lt;/span&gt;&lt;br/&gt;        72,531,622      stalled-cycles-backend    &lt;span&gt;#   45.98% backend cycles idle      (65.92%)&lt;/span&gt;&lt;br/&gt;       178,142,743      instructions              &lt;span&gt;#    1.13  insn per cycle&lt;/span&gt;&lt;br/&gt;                                                  &lt;span&gt;#    0.62  stalled cycles per insn  (82.99%)&lt;/span&gt;&lt;br/&gt;        31,488,875      branches                  &lt;span&gt;#  413.824 M/sec                    (84.01%)&lt;/span&gt;&lt;br/&gt;            24,309      branch-misses             &lt;span&gt;#    0.08% of all branches          (84.17%)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为perf只能得到整个程序执行期间的变化，而我们实际上需要的是核心部分，看来通过perf得到有用的信息，只能另寻他法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;源码跟踪&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;截止到现在，上述方案都没能解答本次问题的疑问，只能祭出屠龙刀，看源码了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;未初始化版&lt;/code&gt;调用信息如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-&amp;gt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;AdItem, &lt;span&gt;std&lt;/span&gt;::allocator&amp;lt;AdItem&amp;gt; &amp;gt;::&lt;span&gt;vector&lt;/span&gt;&lt;br/&gt;--&amp;gt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;AdItem, &lt;span&gt;std&lt;/span&gt;::allocator&amp;lt;AdItem&amp;gt; &amp;gt;::_M_default_initialize&lt;br/&gt;---&amp;gt; &lt;span&gt;std&lt;/span&gt;::__uninitialized_default_n_a&amp;lt;AdItem*, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;, AdItem&amp;gt;&lt;br/&gt;----&amp;gt; &lt;span&gt;std&lt;/span&gt;::__uninitialized_default_n&amp;lt;AdItem*, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&amp;gt;&lt;br/&gt;-----&amp;gt; &lt;span&gt;std&lt;/span&gt;::__uninitialized_default_n_1&amp;lt;&lt;span&gt;false&lt;/span&gt;&amp;gt;::__uninit_default_n&amp;lt;AdItem*, &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&amp;gt;&lt;br/&gt;------&amp;gt; &lt;span&gt;std&lt;/span&gt;::_Construct(&lt;span&gt;std&lt;/span&gt;::__addressof(*__cur))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;初始化版&lt;/code&gt;调用信息如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-&amp;gt; std::vector&amp;lt;AdItem, std::allocator&amp;lt;AdItem&amp;gt; &amp;gt;::vector&lt;br/&gt;--&amp;gt; std::vector&amp;lt;AdItem, std::allocator&amp;lt;AdItem&amp;gt; &amp;gt;::_M_fill_initialize&lt;br/&gt;---&amp;gt; std::__uninitialized_fill_n_a&amp;lt;AdItem*, unsigned long, AdItem, AdItem&amp;gt;&lt;br/&gt;----&amp;gt; std::uninitialized_fill_n&amp;lt;AdItem*, unsigned long, AdItem&amp;gt;&lt;br/&gt;-----&amp;gt; std::__uninitialized_fill_n&amp;lt;&lt;span&gt;false&lt;/span&gt;&amp;gt;::__uninit_fill_n&amp;lt;AdItem*, unsigned long, AdItem&amp;gt;&lt;br/&gt;------&amp;gt; std::_Construct(std::__addressof(*__cur), __x)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上述函数调用信息可以看出，初始化版本和都调用了std::_Construct函数，而该函数通过其名称就能看到，是调用了构造函数对内存块进行构造(底层是用&lt;code&gt;placement new&lt;/code&gt;实现)，得不到我们有用的信息。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;汇编&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们从汇编角度来看下(为了篇幅，去掉了无关紧要的部分以及相同的部分)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;未初始化版本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;uninitialized_performance():&lt;br/&gt;  mov QWORD PTR [rsp+104], OFFSET FLAT:std::_Function_handler&amp;lt;void (), uninitialized_performance()::{lambda()#2}&amp;gt;::_M_invoke(std::_Any_data const&amp;amp;)&lt;br/&gt;  mov QWORD PTR [rsp+80], rax&lt;br/&gt;  mov QWORD PTR [rsp+96], OFFSET FLAT:std::_Function_base::_Base_manager&amp;lt;uninitialized_performance()::{lambda()#2}&amp;gt;::_M_manager(std::_Any_data&amp;amp;, std::_Any_data const&amp;amp;, std::_Manager_operation)&lt;br/&gt;  mov QWORD PTR [rsp+48], rax&lt;br/&gt;  mov QWORD PTR [rsp+72], OFFSET FLAT:std::_Function_handler&amp;lt;void (), uninitialized_performance()::{lambda()#1}&amp;gt;::_M_invoke(std::_Any_data const&amp;amp;)&lt;br/&gt;  mov QWORD PTR [rsp+64], OFFSET FLAT:std::_Function_base::_Base_manager&amp;lt;uninitialized_performance()::{lambda()#1}&amp;gt;::_M_manager(std::_Any_data&amp;amp;, std::_Any_data const&amp;amp;, std::_Manager_operation)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始化版本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;initialized_performance():&lt;br/&gt;  mov QWORD PTR [rsp+64], rsp&lt;br/&gt;  mov QWORD PTR [rsp+88], OFFSET FLAT:std::_Function_handler&amp;lt;void (), initialized_performance()::{lambda()#2}&amp;gt;::_M_invoke(std::_Any_data const&amp;amp;)&lt;br/&gt;  mov QWORD PTR [rsp+80], OFFSET FLAT:std::_Function_base::_Base_manager&amp;lt;initialized_performance()::{lambda()#2}&amp;gt;::_M_manager(std::_Any_data&amp;amp;, std::_Any_data const&amp;amp;, std::_Manager_operation)&lt;br/&gt;  mov QWORD PTR [rsp+32], rsp&lt;br/&gt;  mov QWORD PTR [rsp+56], OFFSET FLAT:std::_Function_handler&amp;lt;void (), initialized_performance()::{lambda()#1}&amp;gt;::_M_invoke(std::_Any_data const&amp;amp;)&lt;br/&gt;  mov QWORD PTR [rsp+48], OFFSET FLAT:std::_Function_base::_Base_manager&amp;lt;initialized_performance()::{lambda()#1}&amp;gt;::_M_manager(std::_Any_data&amp;amp;, std::_Any_data const&amp;amp;, std::_Manager_operation)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上述汇编结果没看到有什么区别，所以排除了语言层面的区别了，尝试从其它方面进行分析。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;lazy allocation&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然源码和汇编都看不出来区别，那么只能从另外一个方向来进行考虑，那就是&lt;code&gt;内存分配&lt;/code&gt;，有没有可能虽然是都调用了new进行内存分配，但是实际上并没有分配呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记得之前看过一些文章，说是操作系统有个&lt;code&gt;lazy allocation（延迟分配）&lt;/code&gt;机制，即用户调用API进行内存分配的时候，操作系统并不会直接分配给用户这么多内存，而是直到用户真的访问了申请的page时产生一个page falut，然后将这个page真的分配给用户，并重新执行产生page fault的语句。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用以下例子进行验证：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;X&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; x_[&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;24&lt;/span&gt;];&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;auto&lt;/span&gt; x = &lt;span&gt;new&lt;/span&gt; X;&lt;br/&gt;    sleep(&lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后通过&lt;code&gt;htop -p xxx&lt;/code&gt;命令查看信息，如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1244343891402715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHgicKYkawpGRm5ImNWe1fxhm52j5nVhcJUHnBmhhPuTocLZno0QgiaUsYVYl8dpgnVW4JnN9v7e2yug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;884&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，我们尝试将代码进行修改如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;X&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; x_[&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;24&lt;/span&gt;];&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;auto&lt;/span&gt; x = &lt;span&gt;new&lt;/span&gt; X;&lt;br/&gt;    &lt;span&gt;memset&lt;/span&gt;(x-&amp;gt;x_, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(x-&amp;gt;x_)); &lt;span&gt;// 增加了该句，仅仅为了访问&lt;/span&gt;&lt;br/&gt;    sleep(&lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.07568807339449542&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/p3sYCQXkuHgicKYkawpGRm5ImNWe1fxhmt0yOibHHjWmCDM5ejQwyCI39lbKeeq3C0XYUrILQzkUFbJqyAv2ADXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;872&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上述htop的输出信息的&lt;code&gt;RES&lt;/code&gt;块可以看出，第二次调用分配了足够的虚拟内存，这就验证了我们这次的结论，即使使用了new，在真正使用之前是&lt;code&gt;没有被真正的分配虚拟内存&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;Lazy allocation simply means not allocating a resource until it is actually needed.&lt;/strong&gt; This is common with singleton objects, but strictly speaking, any time a resource is allocated as late as possible, you have an example of lazy allocation.&lt;/p&gt;&lt;p&gt;By delaying allocation of a resource until you actually need it, you can &lt;strong&gt;decrease startup time, and even eliminate the allocation entirely if you never actually use the object&lt;/strong&gt;. In contrast, you could pre-allocate a resource you expect to need later, which can make later execution more efficient at the expense of startup time, and also avoids the possibility of the allocation failing later in program execution.&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，我们从&lt;code&gt;lazy allocation&lt;/code&gt;角度来分析该问题。对于未初始化的vector，该vector申请了一大块内存，operator new只是返回了虚拟地址(此时并未将物理地址与其关联)，当具体访问数据(for循环)的时候，操作系统才会将虚拟地址与物理地址进行关联。而在构造时给初值，算是访问大块连续逻辑空间，操作系统会将虚拟地址与物理地址相关联，这样在后面访问的时候，因为已经访问了一次了，所以会很快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在源码一节中，我们提到未初始化版本和初始化版本最终分别调用了&lt;code&gt;std::_Construct(std::__addressof(*__cur))&lt;/code&gt;和&lt;code&gt;_Construct(std::__addressof(*__cur), __x)&lt;/code&gt;，下面是其具体实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;未初始化版本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;template&lt;/span&gt;&amp;lt;&lt;span&gt;typename&lt;/span&gt; _T1, &lt;span&gt;typename&lt;/span&gt;... _Args&amp;gt;&lt;br/&gt;   &lt;span&gt;inline&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;br/&gt;   _Construct(_T1* __p, _Args&amp;amp;&amp;amp;... __args) { &lt;br/&gt;    ::&lt;span&gt;new&lt;/span&gt;(&lt;span&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span&gt;void&lt;/span&gt;*&amp;gt;(__p)) _T1(&lt;span&gt;std&lt;/span&gt;::forward&amp;lt;_Args&amp;gt;(__args)...); &lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始化版本如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;inline&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;br/&gt;   _Construct(_T1* __p, &lt;span&gt;const&lt;/span&gt; _T2&amp;amp; __value) {&lt;br/&gt;     ::&lt;span&gt;new&lt;/span&gt;(&lt;span&gt;static_cast&lt;/span&gt;&amp;lt;&lt;span&gt;void&lt;/span&gt;*&amp;gt;(__p)) _T1(__value);&lt;br/&gt;   }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;std::_Construct是在std::vector&amp;lt;&amp;gt;定义中进行调用的，也就是说都访问了对应的地址，但是为什么区别这么大呢？后面，对示例代码进行了修改：&lt;/p&gt;&lt;section&gt;1、在默认的构造函数中对变量进行了赋值初始化操作&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;  &lt;span/&gt;&lt;span&gt;AdItem(&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         x_ = 0; y_ = 0; z_ = z;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;2、对构造函数使用default关键字&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; &lt;span&gt;AdItem(&lt;/span&gt;&lt;span&gt;) = default;&lt;/span&gt;&lt;span/&gt;&lt;/code&gt;&lt;p/&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;修改之后，再次编译，运行，未初始化版本和初始化版本的性能结果基本一致，进一步验证了我们的猜想&lt;/span&gt;&lt;code&gt;lazy allocation&lt;/code&gt;&lt;span&gt;引起的性能差异。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;结语&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发过程，就是一个&lt;code&gt;不断采坑&lt;/code&gt;的过程，从一个坑到另一个坑，技术才能成长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，今天的文章就到这，我们下期见！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b6d238db2ffef7af11adecef42a899c2</guid>
<title>一种优雅的Golang的库插件注册加载机制</title>
<link>https://toutiao.io/k/sywhmm4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最近看到一个项目的插件加载机制，非常赞。&lt;/span&gt;&lt;span&gt;当然这里说的插件并不是指的golang&lt;/span&gt;&lt;span&gt;原生的可以在buildmode中加载指定so文件的那种加载机制。&lt;/span&gt;&lt;span&gt;而是软件设计上的「插件」。&lt;/span&gt;&lt;span&gt;如果你的软件是一个框架，或者一个平台性产品，想要提升扩展性，即可以让第三方进行第三方库开发，最终能像搭积木一样将这些库组装起来。&lt;/span&gt;&lt;span&gt;那么就可能需要这种库加载机制。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的目标是什么？对第三方库进行某种库规范，只要按照这种库规范进行开发，这个库就可以被加载到框架中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先定义一个插件的数据结构，这里肯定是需要使用接口来规范，这个可以根据你的项目自由发挥，比如我希望插件有一个Setup方法来在启动的时候加载即可。然后我就定义如下的Plugin结构。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Plugin &lt;span&gt;interface&lt;/span&gt;{&lt;br/&gt;  Name() &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;  Setup(config &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;string&lt;/span&gt;) error&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在框架启动的时候，我启动了一个如下的全局变量：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; plugins &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]Plugin&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;注册&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有人可能会问，这里有了加载函数setup，但是为什么没有注册逻辑呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是注册的逻辑放在库的init函数中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即框架还提供了一个注册函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// package plugin&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;Register(plugin Plugin)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个register就是实现了将第三方plugin放到plugins全局变量中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以第三方的plugin库大致实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package MyPlugin&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; MyPlugin struct{&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (m *MyPlugin) Setup(config map[string]string) error {&lt;br/&gt; // TODO&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (m *MyPlugin) Name() string {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;myPlugin&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;init&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; plugin.Register(&amp;amp;MyPlugin)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样注册的逻辑就变成了，如果你要加载一个插件，那么你在main.go中直接以 _ import的形式引入即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;_ import &lt;span&gt;&quot;github.com/foo/myplugin&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体的感觉，这样子插件的注册就被“隐藏”到import中了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;加载&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注册的逻辑其实看起来也平平无奇，但是加载的逻辑就考验细节了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先插件的加载其实有两点需要考虑：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置指的是插件一定是有某种配置的，这些配置以配置文件yaml中plugins.myplugin的路径存在。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;plugins:&lt;br/&gt; myplugin:&lt;br/&gt;  foo: bar&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实我对这种实现持保留意见。配置文件以一个文件中配置项的形式存在，好像不如以配置文件的形式存在，即以config/plugins/myplugin.yaml 的文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样不会出现一个大配置文件的问题。毕竟每个配置文件本身就是一门DSL语言。如果你将配置文件的逻辑变复杂，一定会有很多附带的bug是由于配置文件错误导致的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个说的是依赖。插件A依赖于插件B，那么这里就有加载函数Setup的先后顺序了。这种先后顺序如果纯依赖用户的“经验”，将某个插件的Setup调用放在某个插件的Setup调用之前，是非常痛苦的。（虽然一定是有办法可以做到）。更好的办法是依赖于框架自身的加载机制来进行加载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们在plugin包中定义一个接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Depend &lt;span&gt;interface&lt;/span&gt;{&lt;br/&gt; DependOn() []&lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我的插件依赖一个名字为 “fooPlugin” 的插件，那么我的插件 MyPlugin就会实现这个接口。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package MyPlugin&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; MyPlugin struct{&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (m *MyPlugin) Setup(config map[string]string) error {&lt;br/&gt; // TODO&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (m *MyPlugin) Name() string {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;myPlugin&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;init&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; plugin.Register(&amp;amp;MyPlugin)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func (m *MyPlugin) DependOn() []string {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; []string{&lt;span&gt;&quot;fooPlugin&quot;&lt;/span&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在最终加载所有插件的时候，我们并不是简单地将所有插件调用Setup，而是使用一个channel，将所有插件放在channel中，然后一个个调用Setup，遇到有Depend其他插件的，且依赖插件还未被加载，则将当前插件放在队列最后（重新塞入channel）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;var setupStatus map[string]bool&lt;br/&gt;&lt;br/&gt;// 获取所有注册插件&lt;br/&gt;func loadPlugins() (plugin chan Plugin, setupStatus map[string]bool) {&lt;br/&gt; // 这里定义一个长度为10的队列&lt;br/&gt; var sortPlugin = make(chan Plugin, 10)&lt;br/&gt; var setupStatus = make[string]bool&lt;br/&gt; &lt;br/&gt; // 所有的插件&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; name, plugin := range plugins {&lt;br/&gt;  sortPlugin &amp;lt;- plugin&lt;br/&gt;  setupStatus[name] = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;br/&gt; &lt;span&gt;return&lt;/span&gt; sortPlugin, setupStatus&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 加载所有插件&lt;br/&gt;func SetupPlugins(pluginChan chan Plugin, setupStatus map[string]bool) error {&lt;br/&gt; num := len(pluginChan)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; num &amp;gt; 0 {&lt;br/&gt;  plugin &amp;lt;- pluginChan&lt;br/&gt;  &lt;br/&gt;  canSetup := &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; deps, ok := p.(Depend); ok {&lt;br/&gt;   depends := deps.DependOn()&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; _, dependName := range depends{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; _, setuped := setupStatus[dependName]; !setup {&lt;br/&gt;      // 有未加载的插件&lt;br/&gt;      canSetup = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt;  &lt;br/&gt;  // 如果这个插件能被setup&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; canSetup {&lt;br/&gt;   plugin.Setup(xxx)&lt;br/&gt;   setupStatus[p.Name()] = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;   // 如果插件不能被setup, 这个plugin就塞入到最后一个队列&lt;br/&gt;   pluginChan &amp;lt;- plugin&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; nil&lt;br/&gt;} &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这段代码最精妙的就是使用了一个有buffer的channel作为一个队列，消费队列一方SetupPlugins，除了消费队列，也有可能生产数据到队列，这样就保证了队列中所有plugin都是被按照标记的依赖被顺序加载的。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种插件的注册和加载机制是非常优雅的。注册方面，巧妙使用隐式import来做插件的注册。而加载方面，巧妙使用有buffer的channel作为加载队列。&lt;/p&gt; &lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>