<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>35128aad9b33a273ba2024109b87a8ed</guid>
<title>sonic ：基于 JIT 技术的开源全场景高性能 JSON 库</title>
<link>https://toutiao.io/k/p9vuoir</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;项目仓库：https://github.com/bytedance/sonic&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sonic 是字节跳动&lt;strong&gt;开源&lt;/strong&gt;的一款 &lt;strong&gt;Golang JSON 库&lt;/strong&gt;，基于即时编译（Just-In-Time Compilation）与向量化编程（Single Instruction Multiple Data）技术，大幅提升了 Go 程序的 JSON 编解码性能。同时结合 lazy-load 设计思想，它也为不同业务场景打造了一套全面高效的 API。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自 2021 年 7 月份发布以来， sonic 已被抖音、今日头条等业务采用，累计为字节跳动&lt;strong&gt;节省了数十万 CPU 核&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么要自研 JSON 库&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JSON（JavaScript Object Notation） 以其简洁的语法和灵活的自描述能力，被广泛应用于各互联网业务。但是 JSON 由于本质是一种文本协议，且没有类似 Protobuf 的强制模型约束（schema），编解码效率往往十分低下。再加上有些业务开发者对 JSON 库的不恰当选型与使用，最终导致服务性能急剧劣化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在字节跳动，我们也遇到了上述问题。根据此前统计的公司 CPU 占比 TOP 50 服务的性能分析数据，JSON 编解码开销总体接近 10%，单个业务占比甚至超过 40%，提升 JSON 库的性能至关重要。因此我们对业界现有 Go JSON 库进行了一番评估测试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，根据主流 JSON 库 API，我们将它们的使用方式分为三种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;泛型（generic）编解码&lt;/strong&gt;：JSON 没有对应的 schema，只能依据自描述语义将读取到的 value 解释为对应语言的运行时对象，例如：JSON object 转化为 Go map[string]interface{}；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;定型（binding）编解码&lt;/strong&gt;：JSON 有对应的 schema，可以同时结合模型定义（Go struct）与 JSON 语法，将读取到的 value 绑定到对应的模型字段上去，同时完成数据解析与校验；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;查找（get）&amp;amp; 修改（set）&lt;/strong&gt;：指定某种规则的查找路径（一般是 key 与 index 的集合），获取需要的那部分 JSON value 并处理。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次，我们根据样本 JSON 的 key 数量和深度分为三个量级：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;小（small）&lt;/strong&gt;：400B，11 key，深度 3 层；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;中（medium）&lt;/strong&gt;：110KB，300+ key，深度 4 层（实际业务数据，其中有大量的嵌套 JSON string)；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;大（large）&lt;/strong&gt;：550KB，10000+ key，深度 6 层。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试结果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;352&quot; data-backw=&quot;558&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;352&quot; data-ratio=&quot;0.6304347826086957&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaTEXRLjJ4sDdFQGTvfP2A0gXCYzMFBsFFl3n4ESrRtJzQ2IYiaFpolZGapib9lUmZibOUqYJ7tXMb1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1748&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不同数据量级下 JSON 库性能表现&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果显示：&lt;strong&gt;目前这些 JSON 库均无法在各场景下都保持最优性能，即使是当前使用最广泛的第三方库 json-iterator，在泛型编解码、大数据量级场景下的性能也满足不了我们的需要&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JSON 库的基准编解码性能固然重要，但是对不同场景的最优匹配更关键 —— 于是我们走上了自研 JSON 库的道路。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;开源库 sonic 技术原理&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 JSON 业务场景复杂，指望通过单一算法来优化并不现实。于是在设计 sonic 的过程中，我们借鉴了其他领域/语言的优化思想（不仅限于 JSON），将其融合到各个处理环节中。其中较为核心的技术有三块：&lt;strong&gt;JIT、lazy-load&lt;/strong&gt; 与 &lt;strong&gt;SIMD&lt;/strong&gt; 。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;JIT&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于有 schema 的&lt;strong&gt;定型编解码&lt;/strong&gt;场景而言，很多运算其实不需要在“运行时”执行。这里的“运行时”是指程序真正开始解析 JSON 数据的时间段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子，如果业务模型中确定了某个 JSON key 的值一定是布尔类型，那么我们就可以在序列化阶段直接输出这个对象对应的 JSON 值（‘true’或‘false’），并不需要再检查这个对象的具体类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sonic-JIT 的核心思想就是：&lt;strong&gt;将模型解释与数据处理逻辑分离，让前者在“编译期”固定下来&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种思想也存在于标准库和某些第三方 JSON 库，如 json-iterator 的函数组装模式：把 Go struct 拆分解释成一个个字段类型的编解码函数，然后组装并缓存为整个对象对应的编解码器（codec），运行时再加载出来处理 JSON。但是这种实现难以避免转化成大量 interface 和 function 调用栈，随着 JSON 数据量级的增长，function-call 开销也成倍放大。只有&lt;strong&gt;将模型解释逻辑真正编译出来&lt;/strong&gt;，实现 stack-less 的执行体，才能最大化 schema 带来的性能收益。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业界实现方式目前主要有两种：&lt;strong&gt;代码生成 code-gen&lt;/strong&gt;（或&lt;strong&gt;模版 template&lt;/strong&gt;）和 &lt;strong&gt;即时编译 JIT&lt;/strong&gt;。前者的优点是库开发者实现起来相对简单，缺点是增加业务代码的维护成本和局限性，无法做到秒级热更新——这也是代码生成方式的 JSON 库受众并不广泛的原因之一。JIT 则将编译过程移到了程序的加载（或首次解析）阶段，只需要提供 JSON schema 对应的结构体类型信息，就可以一次性编译生成对应的 codec 并高效执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sonic-JIT 大致过程如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;321&quot; data-backw=&quot;558&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;321&quot; data-ratio=&quot;0.575925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/5EcwYhllQOiaTEXRLjJ4sDdFQGTvfP2A0X6sJicMXefj3x9mE5GmnRb4KI4GZKiasuCU5q1h8MRvjWibAOhwPSR2Yg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;sonic-JIT 体系&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;初次运行时，基于 Go 反射来获取需要编译的 schema 信息；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;结合 JSON 编解码算法生成一套自定义的中间代码 OP codes；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 OP codes 翻译为 Plan9 汇编；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用第三方库 golang-asm 将 Plan 9 转为机器码；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将生成的二进制码注入到内存 cache 中并封装为 go function；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;后续解析，直接根据 type ID （rtype.hash）从 cache 中加载对应的 codec 处理 JSON。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从最终实现的结果来看，sonic-JIT 生成的 codec 性能不仅好于 json-iterator，甚至超过了代码生成方式的 easyjson（见后文“性能测试”章节）。这一方面跟底层文本处理算子的优化有关（见后文“SIMD &amp;amp; asm2asm”章节），另一方面来自于 sonic-JIT 能控制底层 CPU 指令，在运行时建立了一套独立高效的 ABI（Application Binary Interface）体系：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将使用频繁的变量放到固定的寄存器上（如 JSON buffer、结构体指针），尽量避免 memory load &amp;amp; store；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自己维护变量栈（内存池），避免 Go 函数栈扩展；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自动生成跳转表，加速 generic decoding 的分支跳转；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用寄存器传递参数（当前 Go Assembly 并未支持，见“SIMD &amp;amp; asm2asm”章节）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Lazy-load&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于大部分 Go JSON 库，泛型编解码是它们性能表现最差的场景之一，然而由于业务本身需要或业务开发者的选型不当，它往往也是被应用得最频繁的场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;泛型编解码性能差仅仅是因为没有 schema 吗？其实不然。我们可以对比一下 C++ 的 JSON 库，如 rappidjson、simdjson，它们的解析方式都是泛型的，但性能仍然很好（simdjson 可达 2GB/s 以上）。标准库泛型解析性能差的根本原因在于&lt;strong&gt;它采用了 Go 原生泛型——interface（map[string]interface{}）作为 JSON 的编解码对象&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这其实是一种糟糕的选择：首先是数据反序列化的过程中，map 插入的开销很高；其次在数据序列化过程中，map 遍历也远不如数组高效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回过头来看，JSON 本身就具有完整的自描述能力，如果我们用一种与 JSON AST 更贴近的数据结构来描述，不但可以让转换过程更加简单，甚至可以实现按需加载（lazy-load）——这便是 sonic-ast 的核心逻辑：&lt;strong&gt;它是一种 JSON 在 Go 中的编解码对象，用 node {type, length, pointer} 表示任意一个 JSON 数据节点，并结合树与数组结构描述节点之间的层级关系&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;623&quot; data-backw=&quot;558&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;359&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;401&quot; data-ratio=&quot;1.117794486215539&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaTEXRLjJ4sDdFQGTvfP2A0FHyUaCytibObOKKqycXdMmysapbE8FbkeAxZpTI9mYDrbt6ibeTWXEZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;399&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;sonic-ast 结构示意&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sonic-ast 实现了一种有状态、可伸缩的 JSON 解析过程：当使用者 get 某个 key 时，sonic 采用 skip 计算来轻量化跳过要获取的 key 之前的 json 文本；对于该 key 之后的 JSON 节点，直接不做任何的解析处理；仅使用者真正需要的 key 才完全解析（转为某种 Go 原始类型）。由于节点转换相比解析 JSON 代价小得多，在并不需要完整数据的业务场景下收益相当可观。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然 skip 是一种轻量的文本解析（处理 JSON 控制字符“[”、“{”等），但是使用类似 gjson 这种纯粹的 JSON 查找库时，往往会有相同路径查找导致的重复开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对该问题，sonic 在对于子节点 skip 处理过程增加了一个步骤，将跳过 JSON 的 key、起始位、结束位记录下来，分配一个 Raw-JSON 类型的节点保存下来，这样二次 skip 就可以直接基于节点的 offset 进行。同时 sonic-ast 支持了节点的更新、插入和序列化，甚至支持将任意 Go types 转为节点并保存下来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换言之，sonic-ast 可以作为一种通用的泛型数据容器替代 Go interface，在&lt;strong&gt;协议转换、动态代理&lt;/strong&gt;等服务场景有巨大潜力。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;SIMD &amp;amp; asm2asm&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是定型编解码场景还是泛型编解码场景，核心都离不开 JSON 文本的处理与计算。其中一些问题在业界已经有比较成熟高效的解决方案，如浮点数转字符串算法 Ryu，整数转字符串的查表法等，这些都被实现到 sonic 的底层文本算子中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一些问题逻辑相对简单，但是可能会面对较大数量级的文本，如 JSON string 的 unquote\quote 处理、空白字符的跳过等。此时我们就需要某种技术手段来提升处理能力。SIMD 就是这样一种用于并行处理大规模数据的技术，目前大部分 CPU 已具备 SIMD 指令集（例如 Intel AVX），并且在 simdjson 中有比较成功的实践。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是一段 sonic 中 skip 空白字符的算法代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#if USE_AVX2&lt;/span&gt;&lt;br/&gt;    // 一次比较比较32个字符&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (likely(nb &amp;gt;= 32)) {&lt;br/&gt;        // vmovd 将单个字符转成YMM&lt;br/&gt;        __m256i x = _mm256_load_si256 ((const void *)sp);&lt;br/&gt;        // vpcmpeqb 比较字符，同时为了充分利用CPU 超标量特性使用4 倍循环&lt;br/&gt;        __m256i a = _mm256_cmpeq_epi8 (x, _mm256_set1_epi8(&lt;span&gt;&#x27; &#x27;&lt;/span&gt;));&lt;br/&gt;        __m256i b = _mm256_cmpeq_epi8 (x, _mm256_set1_epi8(&lt;span&gt;&#x27;\t&#x27;&lt;/span&gt;));&lt;br/&gt;        __m256i c = _mm256_cmpeq_epi8 (x, _mm256_set1_epi8(&lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;));&lt;br/&gt;        __m256i d = _mm256_cmpeq_epi8 (x, _mm256_set1_epi8(&lt;span&gt;&#x27;\r&#x27;&lt;/span&gt;));&lt;br/&gt;        // vpor 融合4次结果&lt;br/&gt;        __m256i u = _mm256_or_si256   (a, b);&lt;br/&gt;        __m256i v = _mm256_or_si256   (c, d);&lt;br/&gt;        __m256i w = _mm256_or_si256   (u, v);&lt;br/&gt;        // vpmovmskb  将比较结果按位展示&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; ((ms = _mm256_movemask_epi8(w)) != -1) {&lt;br/&gt;            _mm256_zeroupper();&lt;br/&gt;            // tzcnt 计算末尾零的个数N&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; sp - ss + __builtin_ctzll(~(uint64_t)ms);&lt;br/&gt;        }&lt;br/&gt;        /* move to next block */&lt;br/&gt;        sp += 32;&lt;br/&gt;        nb -= 32;&lt;br/&gt;    }&lt;br/&gt;    /* clear upper half to avoid AVX-SSE transition penalty */&lt;br/&gt;    _mm256_zeroupper();&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;sonic 中 strnchr() 实现（SIMD 部分）&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发者们会发现这段代码其实是用 C 语言编写的 —— 其实 sonic 中绝大多数文本处理函数都是用 C 实现的：一方面 SIMD 指令集在 C 语言下有较好的封装，实现起来较为容易；另一方面这些 C 代码通过 clang 编译能充分享受其编译优化带来的提升。为此我们开发了一套 x86 汇编转 Plan9 汇编的工具 asm2asm，将 clang 输出的汇编通过 Go Assembly 机制静态嵌入到 sonic 中。同时在 JIT 生成的 codec 中我们利用 asm2asm 工具计算好的 C 函数 PC 值，直接调用 CALL 指令跳转，从而绕过 Go Assembly 不能寄存器传参的限制，压榨最后一丝 CPU 性能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;其它&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了上述提到的技术外，sonic 内部还有很多的细节优化，比如使用 RCU 替换 sync.Map 提升 codec cache 的加载速度，使用内存池减少 encode buffer 的内存分配，等等。这里限于篇幅便不详细展开介绍了，感兴趣的同学可以自行搜索阅读 sonic 源码进行了解。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;性能测试&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以前文中的不同测试场景进行测试，得到结果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;259&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.46440677966101696&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaTEXRLjJ4sDdFQGTvfP2A0gaCk2VdgAN3nvdlQuZSkrRtETiazdkd1GaAKsN2xEaaCqcBHU2khDTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3245&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;小数据（400B，11 个 key，深度 3 层）&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;251&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.44998461064943057&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaTEXRLjJ4sDdFQGTvfP2A0SGPLjjBa016SS1nMN9dXoCILibLroR6cJX9WicgKsweb61wGMzl28oiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3249&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;中数据（110KB，300+ key，深度 4 层）&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;250&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.44745762711864406&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaTEXRLjJ4sDdFQGTvfP2A0sEuykFSIIsEWWDGx7ibqCQHgGzX8aqzm68Wic72a22sWByKnLNuX9sPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3245&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大数据（550KB，10000+ key，深度 6 层）&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到 sonic 在几乎所有场景下都处于领先（sonic-ast 由于直接使用了 Go Assembly 导入的 C 函数导致小数据集下有一定性能折损）&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;平均编码性能较 json-iterator 提升 240% ，平均解码性能较 json-iterator 提升 110% ；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;单 key 修改能力较 sjson 提升 75% 。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且在生产环境中，sonic 中也验证了良好的收益，服务高峰期占用核数减少将近三分之一：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;338&quot; data-backw=&quot;558&quot; data-ratio=&quot;0.60625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaTEXRLjJ4sDdFQGTvfP2A0ZibGPQxV6yFavpQKg3ODEgZyKkMwPRAayC3z05RZibEOknDibjibx5Tdgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;字节某服务在 sonic 上线前后的 CPU 占用（核数）对比&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;结语&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于底层基于汇编进行开发，sonic 当前仅支持 amd64 架构下的 darwin/linux 平台 ，后续会逐步扩展到其它操作系统及架构。除此之外，我们也考虑将 sonic 在 Go 语言上的成功经验移植到不同语言及序列化协议中。目前 sonic 的 C++ 版本正在开发中，其定位是基于 sonic 核心思想及底层算子实现一套通用的高性能 JSON 编解码接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;近日，sonic 发布了第一个大版本 v1.0.0，标志着其除了可被企业灵活用于生产环境，也正在积极响应社区需求、拥抱开源生态。我们期待 sonic 未来在使用场景和性能方面可以有更多突破，欢迎开发者们加入进来贡献 PR，一起打造业界最佳的 JSON 库！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;相关链接&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目地址：https://github.com/bytedance/sonic&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BenchMark：https://github.com/bytedance/sonic/blob/main/bench.sh&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bc6d5a44d41be344a0cfc26b993ef8b7</guid>
<title>十亿用户的系统！</title>
<link>https://toutiao.io/k/pqsnqhd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;前几天有朋友问了这么个问题，这是一道面试题：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;十亿用户的系统，用户可以用手机号、账号、邮箱、昵称等登录，这样的表结构应该怎样设计？登录流程大致是怎样的？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;好家伙！十亿用户的系统……&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在我看来，这道面试题主要是想考察两点：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;面试者是否做过相关业务或者有非常扎实的数据库表设计能力&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;面试者是否真的了解在高并发下应该怎么分库分表&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们先看第一个问题：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;表结构怎么设计？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当出现多种登录方式的时候，就意味着一个用户对应的账号可能会有若干个。现在可能用手机和昵称登录，以后就可能用邮箱登录，甚至将来还可能通过微信、QQ、微博等第三方渠道登录。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，直觉上，咱们第一个冒出的念头是什么？对我个人来说，就是本能的想着，如果是多种登录类型，就在存储用户信息的表上加多个字段。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;比如，支持手机号登录，就加一个手机号字段，支持邮箱登录，就加一个邮箱字段等等。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;表结构类似下面这样：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;id&lt;span class=&quot;code-snippet__params&quot;&gt;|name|&lt;/span&gt;phone&lt;span class=&quot;code-snippet__params&quot;&gt;|email|&lt;/span&gt;nick_name&lt;span class=&quot;code-snippet__params&quot;&gt;|desc&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但是仔细一想，这种设计存在问题：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;当用户登录的时候，我们需要根据用户的登录类型，先要知道去查找用户表的哪个字段才可以进行登录逻辑判断。例如，用户登录用手机号了，我们就要知道去表里查找对应的 phone 字段去校验登录；登录用邮箱了，我们就要知道去表里查找对应的 email 字段才可以。这样做，代码逻辑会很复杂。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;再增加一种登录方式的时候，我们还得给数据库的表里再增加一个字段，同时还得修改登录的代码。这种修改一不小心，还很容易修改不完善，造成线上 bug。每增加一种登录方式，就搞一次这种流程，成本有点过高了。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此，我们最好能找到另一种更灵活的办法。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;更灵活的办法就意味着，我们设计的表，必须易扩展。怎么叫易扩展？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;加记录比加字段要更容易扩展。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样的话，我们只能想想是不是考虑列变行的思路了，即添加字段变成添加行记录来解决。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此方案如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;创建一张授权表，专门用来处理登录。当新增登录类型的时候，只需要考虑增加一条记录即可：记录登录类型、登录名称以及相关密码，同时有个 user_id 字段，去和用户表做关联。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6168032786885246&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KS7zNT0Jvu2ianT9eGK5kh2WbNoCEkC6mDD2VOcwtm6k788PqqiaCKpkJFzOUFjgBMUrj5HKmCjlkPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;976&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;用户表就存储一些非登录相关的额外信息即可。像这样：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9400630914826499&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KS7zNT0Jvu2ianT9eGK5kh2Wmmo4phibJqq0YUHPfIxOugPiax4uKIv4ofh9Nl3jaJT6qF7YyGLWJFEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;634&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样设计后，很明显就做到了易扩展。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假如我自己有两种登录方式，授权表（Author）的数据：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.17220543806646527&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQysy0HuQxRLZ4HSwT66pXeKFbLoRMV4bBvssia9yXT87bFG7Fg4BCKWWXgvyuTVfvqGn4Siatygopicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;993&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;用户表（User）的数据：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.12185297079556898&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQysy0HuQxRLZ4HSwT66pXeKfCkliclic09AxYviahwHhaUwqSUOXGWX0swLc0Jp91Sv4QiaQ34dW0kLOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;993&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种方案的缺点就是，改密码的时候，得一起改动。需要注意。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;说完表结构后，再来说下一个问题：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;十亿用户系统的登录流程&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;乍一看，这道题里有十亿用户，那基本可以算是高并发、大数据了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为十亿用户，哪怕有百分之一的活跃用户，也是千万级别的。所以，在这样的情况下，必然需要考虑分库分表。分库是为了应对高并发，分表则是为了应对大数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以 MySQL 为例， 一般来讲，在 4核CPU/8G内存/RAID10 的普通硬盘的服务器配置下，一台 &lt;span&gt;M&lt;/span&gt;&lt;span&gt;y&lt;/span&gt;&lt;span&gt;SQL&lt;/span&gt; 库能一直可靠运行的可承载压力是 1000TPS 左右。一张通常的 20 个字段以内的表，能保证查询性能没有大的下降的话，可承载的数据量大致是 1000 万条数据左右。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以，咱们分表的时候就要尽量控制表数据不超过一千万条数据。也因此，十亿用户，分表就是分 100 张表。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同时呢，咱们说了，一台库大概能承载的可靠运行并发数是 1000TPS 左右。分库一般来说，100 张表分 10 个库，每个库 10 张表，就很绰绰有余了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;好，现在问题来了，&lt;/span&gt;&lt;span&gt;分库分表的策略是什么呢？就是按什么分呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一般是按照 user_id 分。假如我们要分 10 个库 100 张表是吧， 一般来说就是先通过 user_id mod 10 去定义好库，再通过 user_id mod 100 定义好表。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;比如 user_id mod 10 = 3，user_id mod 100 = 33，那么这个用户的数据就被定位到了数据库 3 中的 33 号表。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;注意，这里又来了一个问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设一个 user_id = 100 会怎么样？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;user_id  mod 10 = 0，user_id mod 100 = 0。它会被分在 0 号库，0 号表。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那如果我想分到 1 号库，0 号表呢，有对应的 user_id 吗？&lt;/span&gt;&lt;span&gt;是没有的。为什么呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为当一个 user_id mod 100 = 0 时，这个 user_id mod 10 也一定为 0 。所以，不会存在 1 号库，0 号表的情况。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以，我们还需要对库进行调整，要把库变成 11 个库，然后呢，每个库有 100 张表。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原因就是：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;库数和表数之间不能存在公约数，也就是他们需要互质，只有这样，我们分配数据的时候，才会尽量均匀。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;好了，当 user_id 分完之后，你会发现，按照咱们的设计，只能解决 User 表的问题。那登录在哪里？该怎么办？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;咱们继续看，前面说了，登录逻辑是靠 Author 表来验证。那 Author 表数据大，也得分库分表啊？它怎么分？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实挺简单，分库分表的时候，我们根据 Author 表的 user_name 的 Hash 去分。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设有个用户的 user_name 是 abc，然后将这个 abc 进行下 hash，再除以库的数量。现在是 11 个库，所以就是 hash(abc) mod 11 这样得到库的编号，然后再 hash(abc) mod 100 得到表的编号。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;于是，当我们登录的时候，流程如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;输入 abc 和密码；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;验证出账号类型；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将信息传递给服务器；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;服务器在数据库层之上会有一个路由层，根据 hash(abc) mod 11/100 定位数据库和表；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;查询 Author 表验证。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这道题到此为止，算是回答完毕了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但是，我要在此再多说一点东西。面试题这里，其实是限制死了，只让你考虑数据库。但是在实际工作当中呢，对于这种高并发、大数据的解决，方向往往是多重索引，加外置缓存。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为，在面试题中，我们只需要考虑登录问题。而在实际工作里，我们往往还需要考虑数据重用、资源耗费等问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以，实际上，很多这种高并发、大数据的登录，我们根据手头的资源，虽然依然会使用分库分表，但是，往往还会采用 ElasticSearch 缓存一些用户基本信息和用户数据所在的数据库和表的地址信息，将他们作为索引，去真正的做相关登录业务行为。并根据用户字段的使用热度，会在登录时，把一些用户关键字段读取出来，放到外置的 Redis 缓存中，供以后重用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样做的好处就是，分库分表我们可以根据资源随意增加减少，只需要到时候修改下 ElasticSearch 中的索引信息即可。同时，有了 Redis，也能减少后面分库分表资源的消耗。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651506905&amp;amp;idx=2&amp;amp;sn=be4dc72831a156ff656ca5c40e643944&amp;amp;chksm=bd25a4a68a522db0b135b5fb87ffc5b76c27aeeaf9407a3ca7beadda7b47b61e06a963556516&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;B站高可用架构实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;B站高可用架构实践&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651501882&amp;amp;idx=1&amp;amp;sn=5905a566d095ab63f2d3505b7fbfdd33&amp;amp;chksm=bd25d9458a5250537bd86cd82d3b8194bf14811e8a4e6888865fe528eee43d98570b0dc4dbc7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Kafka 架构设计的任督二脉&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Kafka 架构设计的任督二脉&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651501882&amp;amp;idx=1&amp;amp;sn=5905a566d095ab63f2d3505b7fbfdd33&amp;amp;chksm=bd25d9458a5250537bd86cd82d3b8194bf14811e8a4e6888865fe528eee43d98570b0dc4dbc7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Kafka 架构设计的任督二脉&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651501881&amp;amp;idx=1&amp;amp;sn=fedcb35a5a47b3a2ce9bef2073482429&amp;amp;chksm=bd25d9468a525050d6587dd3651913ccebf98e1b85a3acd7a18695750ca574719ddd52584e0c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;ElasticSearch让人叹为观止的分布式系统架构设计&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;ElasticSearch让人叹为观止的分布式系统架构设计&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>71f11aea97679613d0d0e02530d7b567</guid>
<title>TCP网络那点破事！三次握手、四次挥手、TIME-WAIT、HTTP 2.0 ....</title>
<link>https://toutiao.io/k/igh5e8c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;10&quot; data-source-title=&quot;&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;来自公众号：&lt;span&gt;微观技术&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是Tom哥~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天主要给各位分享&lt;code&gt;TCP网络&lt;/code&gt;的一些常见知识点，日常工作或面试会经常遇到。考虑内容篇幅不小，建议先收藏，慢慢咀嚼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有帮助，也请转给身边的朋友们，”独乐乐不如众乐乐“&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，来个目录，让大家对文章内容先有个直观了解&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.024945770065076&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwdRomH3FoIUyOnHOhxmENBvYWY9TIB7H14hiaic9lK8tjQN1gbQusSaQgWOvyYC9icVTPa0LX7W5ZKDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;922&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;网络的七层模型，简单介绍每层的作用？&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：分为7层，从下到上依次是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;应用层：计算机用户与网络之间的接口，常见的协议有：HTTP、FTP、 SMTP、TELNET&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表示层：数据的表示、安全、压缩。将应用处理的信息转换为适合网络传输的格式。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;会话层：建立和管理本地主机与远程主机之间的会话。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;传输层：定义传输数据的&lt;code&gt;协议端口号&lt;/code&gt;，以及流控和差错校验，保证报文能正确传输。协议有TCP、UDP&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;网络层：路由选择算法，进行逻辑地址寻址，实现不同网络之间的最佳路径选择。协议有IP、ICMP&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据链路层：接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层的数据叫做帧。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;物理层：建立、维护、断开物理连接。传输比特流（将1、0转化为电流强弱来进行传输，到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.63125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwdRomH3FoIUyOnHOhxmENBvMYUsbNmTZ8lezG0pEZ0X7whHQVyO6MbxS1hzOpzBDyPZDR5cl1NO4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;TCP 报文首部有哪些字段?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6567425569176882&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwdRomH3FoIUyOnHOhxmENBvaZ1PKzDu2mMvjvwlT1M5n9NR9F72xajuz4IicibJheSacQOFM0j3jxRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;571&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;源端口、目的端口：各占2个字节，表示数据从哪个进程来，去往哪个进程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;序号（Sequence Number）：占4个字节，TCP连接中传送的数据每一个字节都会有一个序号&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;确认号（Acknowledgement Number）：占4个字节，另一方发送的tcp报文段的响应&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据偏移：头部长度，占4个字节，表示TCP报文段的数据距离TCP报文段的起始处有多远。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;6位标志位：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;URG：紧急指针是否有效&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ACK：表示确认号是否有效&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PSH：提示接收端应用程序立刻将数据从tcp缓冲区读走&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RST：表示要求对方重新建立连接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SYN：这是一个连接请求或连接接受的报文&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;FIN：告知对方本端要关闭连接&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;窗口大小：占4个字节，用于TCP流量控制。告诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;校验和：占2个字节，由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。检验的范围包括头部、数据两部分，是TCP可靠传输的一个重要保障。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;紧急指针：占2个字节，一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一个字节的序号，用于发送端向接收端发送紧急数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;TCP 三次握手过程？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：目的是同步连接双方的序列号和确认号，并交换TCP窗口。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一次握手，客户端发送(seq=x)，客户端进入&lt;/span&gt;&lt;code&gt;&lt;span&gt;SYN_SEND&lt;/span&gt;&lt;/code&gt;&lt;span&gt;状态&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二次握手，服务端响应(Seq=y, Ack=x+1)，服务器端就进入&lt;/span&gt;&lt;code&gt;&lt;span&gt;SYN_RCV&lt;/span&gt;&lt;/code&gt;&lt;span&gt;状态。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第三次握手，客户端收到服务端的确认后，发送(Ack=y+1)，客户端进入&lt;/span&gt;&lt;code&gt;&lt;span&gt;ESTABLISHED&lt;/span&gt;&lt;/code&gt;&lt;span&gt;状态。当服务器端接收到这个包时，也进入&lt;/span&gt;&lt;code&gt;&lt;span&gt;ESTABLISHED&lt;/span&gt;&lt;/code&gt;&lt;span&gt;状态。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8194444444444444&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwdRomH3FoIUyOnHOhxmENBvsxho6J2Z0LjgdMJibJOgO0qAT6NlQcazaaHSnWSu2Fj300Ay6PswhWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;792&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;br/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;为什么是三次握手，而不是两次或四次？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果只有两次握手，那么服务端向客户端发送 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SYN/ACK&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 报文后，就会认为连接建立。但是如果客户端没有收到报文，那么客户端是没有建立连接的，这就导致服务端会浪费资源。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用两次握手无法建立 TCP 连接，而使用三次握手是建立连接所需要的最小次数&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;TCP 四次挥手的过程？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一次挥手：客户端向服务端发送连接释放报文&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二次挥手：服务端收到连接释放报文后，立即发出确认报文。这时 TCP 连接处于半关闭状态，即客户端到服务端的连接已经释放了，但是服务端到客户端的连接还未释放。表示客户端已经没有数据发送了，但是服务端可能还要给客户端发送数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三次挥手：服务端向客户端发送连接释放报文&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第四次挥手：客户端收到服务端的连接释放报文后，立即发出确认报文。此时，客户端就进入了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;TIME-WAIT&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 状态。注意此时客户端到 TCP 连接还没有释放，必须经过 2*MSL（最长报文段寿命）的时间后，才进入&lt;/span&gt;&lt;code&gt;&lt;span&gt;CLOSED&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 状态。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.725576289791438&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwdRomH3FoIUyOnHOhxmENBv7BicFBax3vfnWmRNC5p9Hx3gYiaibfIpPprOChqFcf7iawVF369XYX6RSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;911&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;为什么需要四次挥手？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：TCP 是&lt;/span&gt;&lt;code&gt;&lt;span&gt;全双工&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。一方关闭连接后，另一方还可以继续发送数据。所以四次挥手，将断开连接分成两个独立的过程。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;客户端 TIME-WAIT ，为什么要等待 2MSL 才进入 CLOSED 状态？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：MSL 是报文段在网络上最大存活时间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;确保 ACK 报文能够到达服务端，从而使服务端正常关闭连接。客户端在发送完最后一个 ACK 报文段后，再经过 2MSL，就可以保证本连接持续的时间内产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;一台 8G 内存服务器，可以同时维护多少个连接？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：发送、接收缓存各4k，还要考虑socket描述符，一个tcp连接需要占用的最小内存是8k，那么最大连接数为：&lt;/span&gt;&lt;code&gt;&lt;span&gt;8*1024*1024 K / 8 K = 1048576 个&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，即约100万个tcp长连接。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;什么是拆包？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：传输层封包不能太大，基于这个限制，往往以缓冲区大小为单位，将数据拆分成多个 TCP 段（&lt;/span&gt;&lt;code&gt;&lt;span&gt;TCP Segment&lt;/span&gt;&lt;/code&gt;&lt;span&gt;）传输。在接收数据的时候，一个个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;TCP 段&lt;/span&gt;&lt;/code&gt;&lt;span&gt;又被重组成原来的数据。简单来讲分为几个过程：拆分——传输——重组。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;什么是粘包？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：解决数据太小问题，防止&lt;/span&gt;&lt;code&gt;&lt;span&gt;多次发送&lt;/span&gt;&lt;/code&gt;&lt;span&gt;占用资源。TCP 协议将它们合并成一个 TCP 段发送，在目的地再还原成多个数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;缓冲区是做什么用？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：缓冲区是在内存中开辟的一块区域，目的是缓冲。当应用频繁地通过网卡收、发数据，网卡只能一个一个处理。当网卡忙不过来的时候，数据就需要排队，也就是将数据放入缓冲区。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;注意：TCP Segment 的大小不能超过缓冲区大小。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;TCP 协议是如何保证数据的顺序？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.20234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwdRomH3FoIUyOnHOhxmENBv5FJQGXYRMxECxFc2Uzjm5vNyia2Bhg3hRFRpfsjWSHNBEfccymJc35w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大数据拆包成多个片段，发送可以保证有序，但是由于网络环境复杂，并不能保证它们到达时也是有序的，为了解决这个问题，对每个片段用&lt;/span&gt;&lt;code&gt;&lt;span&gt;Sequence Number&lt;/span&gt;&lt;/code&gt;&lt;span&gt;编号，接收数据的时候，通过 Seq 进行排序。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;注意：seq是累计的发送字节数&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;TCP 协议如何解决丢包？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：丢包需要重发，关键是如何判断有没有丢包！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;每一个数据包，接收方都会给发送方发响应。每个 TCP 段发送时，接收方已经接收了多少数据，用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Acknowledgement Number&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（简写ACK） 表示。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;注意：ack是累计的接收字节数，表示这个包之前的包都已经收到了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;什么是 MSS ?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：MSS 全称 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Maximun Segment Size&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。是TCP Header 中的可选项（Options），控制了 TCP 段的大小，不能由单方决定，需要双方协商。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;TCP 协议如何控制流量传输速度？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：简单讲通过&lt;/span&gt;&lt;code&gt;&lt;span&gt;滑动窗口&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。发送、接收窗口的大小可以用来控制 TCP 协议的流速。窗口越大，同时可以发送、接收的数据就越多，吞吐量也就越大。但是窗口越大，如果数据发生错误，损失也就越大，因为需要重传越多的数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;TCP每个请求都要有响应，如果一个请求没有收到响应，发送方就会认为这次发送出现了故障，会触发重发。为了提升吞吐量，一个TCP段再没有收到响应时，可以继续发送下一个段。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5450081833060556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwdRomH3FoIUyOnHOhxmENBvdoNu7Giaza2xicichwJvCpVK5P7pDaxbWPzYcuPWelonKzLNIzgQcibRww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1222&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;br/&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;窗口区域包含两类数据：已发送未确认、未发送（即将发送）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;窗口中序号最小的分组如果收到 ACK，窗口就会向右滑动&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;滑动窗口的size规格可能会变化，需要从ACK数据包实时取最新值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果最小序号的分组长时间没有收到 ACK，就会触发整个窗口的数据重新发送&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;HTTP 1.0 、1.1 和 HTTP 2.0 有什么区别？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、HTTP 1.0&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;默认是短连接，每次与服务器交互，都需要新开一个连接。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、HTTP 1.1&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;默认持久化连接，建立一次连接，多次请求均由这个连接完成。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、HTTP 2.0&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;二进制分帧：在应用层和传输层之间加了一个二进制分帧层，将所有传输的信息分割为更小的消息和帧（frame），并对它们采用二进制格式的编码。减少服务端的压力，内存占用更少，连接吞吐量更大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多路复用：允许同时通过单一的HTTP/2.0连接发起多次的请求-响应消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;头部压缩：采用了&lt;/span&gt;&lt;code&gt;&lt;span&gt;Hpack&lt;/span&gt;&lt;/code&gt;&lt;span&gt;头部压缩算法对Header进行压缩，减少重复发送。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务器推送：服务器主动将一些资源推送给浏览器并缓存起来。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;HTTP 与 HTTPS 的区别？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：HTTPS = HTTP + SSL/TLS&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;HTTP 采用明文通讯；端口 80&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;HTTPS 在HTTP的基础上加入了&lt;/span&gt;&lt;code&gt;&lt;span&gt;SSL/TLS协议&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，SSL/TLS依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。端口 443&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;HTTP 协议为什么要设计成无状态？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：HTTP是一种无状态协议，每个请求都是独立执行，请求/响应。这样设计的重要原因是，降低架构设计复杂度，毕竟服务器一旦带上了状态，&lt;/span&gt;&lt;code&gt;&lt;span&gt;扩容、缩容、路由&lt;/span&gt;&lt;/code&gt;&lt;span&gt;都会受到制约。无状态协议不要求服务器在多个请求期间保留每个用户的信息。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但，你可能会问，如果有登录要求的业务怎么办？HTTP协议提供扩展机制，Header中增加了Cookie，存储在客户端，每次请求时自动携带，采用空间换时间机制，满足上下请求关联。虽然浪费了些网络带宽，但是减少了复杂度。当然为了减轻网络负担，浏览器会限制Cookie的大小，不同浏览器的限制标准略有差异，如：Chrome 10，限制最多 180个，每个Cookie大小不能超过 4096 bytes&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;HTTPS 的访问流程是什么？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;客户端发起一个http请求，告诉服务器自己支持哪些hash算法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;服务端把自己的信息以&lt;/span&gt;&lt;code&gt;&lt;span&gt;数字证书&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的形式返回给客户端（公钥在证书里面，私钥由服务器持有）。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端收到服务器的响应后会先验证证书的合法性（证书中包含的地址与正在访问的地址是否一致，证书是否过期）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果证书验证通过，就会生成一个随机的&lt;/span&gt;&lt;code&gt;&lt;span&gt;对称密钥&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，用证书的公钥加密。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;客户端将证书公钥加密后的密钥发送给服务端&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务端用私钥解密，解密之后就得到客户端的密钥&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后，客户端与服务端就靠密钥完成明文加密、安全通信、对称解密&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;对称加密与非对称加密有什么区别？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对称加密。加密和解密使用同一个密钥。速度快。常用的如：AES、DES&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非对称加密。公钥与私钥配对出现，公钥对数据加密，私钥对数据解密。常用的如：RSA、DSS&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;TCP 抓包用什么工具？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;答案：Wireshark，应用最广泛的网络协议分析器。功能非常丰富&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;支持数百个协议&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实时捕获、离线分析&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持 Windows、Linux、macOS、Solaris、FreeBSD、NetBSD等平台；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;界面化操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持 Gzip&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持 IPSec&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;span&gt;--- EOF ---&lt;/span&gt;&lt;br/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;推荐↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAxNTcyNzAyOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/NW4iaKVI4GNOJHFfxs3Dq0jLTT7riaETbUFsDsjYiaOftPu1tdHm0icq8sgibZo5ZEiaHGbLLxSVrd3B5psBZVwVCdHQ/0?wx_fmt=png&quot; data-nickname=&quot;运维&quot; data-alias=&quot;Operation1024&quot; data-signature=&quot;分享网络管理、网络运维、运维规划、运维开发、Python运维、Linux运维等知识，推广围绕DevOps理念的自动化运维、精益运维、智能运维等优秀实践，让运维工程师更加专注于自动化。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d82b3112b8fffa5bb22b7572ea30a579</guid>
<title>也许你该找个人聊聊？</title>
<link>https://toutiao.io/k/1qrbh71</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ff285900aed0d46bec082052797fd6f2</guid>
<title>Streaming 102:批处理之外的流式世界第二部分</title>
<link>https://toutiao.io/k/32bn3a7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nKovjAe6Lrq9AjzdXrOnYTAIMbL4gGiaOF6QmPDWvoa0BO4eQc0kia0KaBcO7KHjSib7ziaQ23OSdvoBOKrHmyA0wg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在流式系统方面，有两篇经典的文章，&lt;span&gt;非常适合初学者&lt;/span&gt;：&lt;/span&gt;Streaming 101&lt;span&gt;  与 &lt;/span&gt;Streaming102&lt;span&gt;。这两篇文章的作者是 Google 流式系统的负责人 &lt;/span&gt;Tyler Akidau&lt;span&gt;，他也是 MillWheel 与 DataFlow 的开发者。本篇文章是 Streaming102 的翻译版本，如果英文能力比较好的，强烈建议直接阅读原版英文。英文不好的，可以直接阅读本文，但需要你返回原文借助动画来理解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI0OTYwNTQ4Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/nKovjAe6LrpVR0GEQn2UGOvBUCta35aF6ibVFvTR0fFPE83DrdKGl8v2sCTVbYNJPnun6Yftg1OAlMJ94kxzgyg/0?wx_fmt=png&quot; data-nickname=&quot;大数据生态&quot; data-alias=&quot;big_data_ecosphere&quot; data-signature=&quot;火爆数年的大数据圈，让很多人还没弄懂大数据是什么，就已然身处其中。该订阅号对大数据行业中的各个领域进行梳理，有助于业内人士了解大数据生态圈。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;h2&gt;1. 引言&lt;/h2&gt;&lt;p&gt;欢迎回来！如果你错过了我之前的博文：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI0OTYwNTQ4Ng==&amp;amp;mid=2247485476&amp;amp;idx=1&amp;amp;sn=7d08637d111e05f78c0b77ecce7d38ec&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; data-linktype=&quot;2&quot;&gt;Streaming 101:批处理之外的流式世界第一部分&lt;/a&gt;，我强烈建议你先花时间阅读这篇文章。在这篇文章介绍的内容是下面介绍内容的基础，并且当你阅读这篇文章时，我假设你已经熟悉第一篇文章中介绍的术语和概念了（有些东西在这篇文章不会详细介绍）。现在我们进入正题。先简要回顾一下，上篇文章我主要关注的三个方面：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;术语：当使用流等多语义术语时，明确了我要表达的意思；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;批与流的比较：比较这两种系统的理论能力，并提出流处理系统超越批处理系统只需要两件事：正确性和时间推理工具；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据处理模式：介绍批处理和流处理系统处理有限和无限数据时所采用的方法。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在这篇文章中，我接着上次进一步介绍数据处理模式，但这次借助具体示例来更详细的介绍。这篇文章主要分为两个章节：&lt;/p&gt;&lt;p&gt;当我们读完这篇文章时，我们会学习到一个具有鲁棒性的乱序数据处理所需的核心原则和概念以及可以实现超越经典批处理系统的时间推理工具。为了让你有直观的感受，我会使用 Dataflow SDK 代码（即 Google Cloud Dataflow 的 API），并结合动画来表达一些概念。使用 Dataflow SDK 而不是你可能更熟悉的 Spark Streaming 或 Storm 的原因是，目前几乎没有其他系统可以提供我想要表达所有示例的能力。好消息是其他项目也开始朝这个方向发展。更好的消息是，我们（谷歌）今天向 Apache 软件基金会提交了一份提案，来创建一个 Apache Dataflow 孵化器项目（与 data Artisans、Cloudera、Talend 和其他一些公司合作），希望围绕数据流模型提供的强大的乱序处理语义建立一个开放的社区和生态系统。&lt;/p&gt;&lt;p&gt;很抱歉，这篇文章中缺少了我上次承诺的比较部分。我低估了这篇文章中包含的内容以及需要完成的时间。我不想为了完成这个一部分再看到时间上的延迟以及再做一些其他扩展。如果有什么安慰的话，我在 Strata + Hadoop World Singapore 2015 上做了一个 The evolution of massive-scale data processing 演讲（并将在 6 月的 Strata + Hadoop World London 2016 上给出它的更新版本），这里面会提供缺失的比较部分的资料；同时，会奉上一个精美的幻灯片。&lt;/p&gt;&lt;h2&gt;2. 总结和路线图&lt;/h2&gt;&lt;p&gt;在Streaming 101中，我们首先明确了一些术语。我们先区分了有限数据和无限数据。有限数据源的大小是有限的，通常被称为 ‘batch’ 批数据。无限数据源一般大小都是无限的，并且通常被称为 ‘streaming’ 流数据。我会尽量避免使用批和流术语来指代数据源，因为这些名称会让我们产生误解。然后，我们继续定义了批处理引擎和流处理引擎之间的区别：批处理引擎是那些仅为有限数据设计的引擎，而流处理引擎在设计时考虑到了无限数据。我的目标是只在谈及执行引擎时才使用批和流这样的术语。&lt;/p&gt;&lt;p&gt;在介绍完术语之后，我介绍了两个与处理无限数据有关的重要概念。首先明确了事件时间(事件发生的时间)和处理时间(处理期间观察到时间)之间的重要区别。这为Streaming 101提出的主要论点之一提供了基础：如果你关心正确性和事件实际发生的上下文，那么必须根据事件固有的事件时间来分析数据，而不是用它们在分析过程中的处理时间。最后我介绍了窗口的概念(即，将数据集按时间边界划分)，这是处理无限数据源的一种常见方法。窗口策略中比较简单的是固定窗口的和滑动窗口，也还有更复杂的窗口类型，例如会话窗口(窗口由数据本身的特征定义，例如捕获每个用户的活动会话)。&lt;/p&gt;&lt;p&gt;除了这两个概念之外，我们还需要仔细研究一下如下三个概念：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Watermarks：衡量事件时间输入完整性的一个概念。时间为 x 的 Watermark 表示事件时间小于 X 的所有输入数据都已经到达。因此，当不知道无限数据源什么时候结束时，Watermark 就用作进度的度量。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Triggers：触发器是一种声明窗口何时触发计算输出的机制（响应某个外部信号）。触发器在选择什么时候发送输出时提供了一定的灵活性。这为窗口演变时多次观察窗口输出提供了可能。反过来，也为随着时间的推移修正结果提供了可能，我们可以在数据到达时提供一个推测结果，然后处理随着时间变化的上游数据以及 Watermark 之后的迟到数据（修正结果）。（比如手机传感器，当用户离线时，他们记录了手机各种各样的信息，而当用户重新连线时把这些离线时收集的数据继续传送上报）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Accumulation：累积模式指定了在同一窗口中观察到的多个结果之间的关系。这些结果可能完全不相关，只是随着时间推移各自的增量，或者它们之间可能存在重叠。不同的累积模式具有不同的语义和与之相关的成本，因此需要从多种使用用例中寻找合适的模式。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;最后，为了更好的理解这些概念之间的关系，我们可以在回答下面四个问题的过程中温故知新，这些问题对于无限数据处理来说是至关重要的：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;What：计算逻辑是什么？这个问题的答案是 Pipeline 的 transforms。这其中包括计算总和、构造直方图以及机器学习模型训练等。同样在经典批处理中也是如此。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Where：计算的事件时间范围？这个问题的答案是 Pipeline 的事件时间窗口。这包括Streaming 101中介绍的常见窗口(固定，滑动和会话窗口)，没有窗口概念的用例(例如，Streaming 101中描述的与时间无关的处理；经典的批处理也通常属于这种类别)以及其他更复杂的窗口类型。还要注意，如果将记录到达系统时的摄入时间作为事件时间时，也可以包含处理时间窗口。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;When：什么时候(处理时间)输出结果？这个问题的答案是 Watermark 和 Triggers。最常见的模式是使用 Watermark 来描述给定窗口的输入是否完成，使用 Triggers 指定是否输出提前结果(在窗口完成之前发送推测结果)和迟到结果(Watermark 仅是对完整性的评估，在 Watermark 声明给定窗口的输入完成之后可能还会有其他的输入数据)。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;How：如何修正相关结果？这个问题的答案是所使用的 Accumulation 类型：丢弃(结果都是独立且不同的)，累积(后来的结果建立在先前的结果之上)以及累积并撤回(输出累积值和先前已被触发值的撤回)。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;3. Streaming 101 总结&lt;/h2&gt;&lt;p&gt;首先，让我们回顾一下在Streaming 101中提出的一些概念，但是这次会提供一些详细的例子，这些例子将有助于我们更好的理解这些概念。&lt;/p&gt;&lt;h3&gt;3.1 What: transformations&lt;/h3&gt;&lt;p&gt;经典的批处理应用中的 transformations 回答了第一个问题：计算逻辑是什么？尽管你们可能对经典的批处理已经很熟悉了，但是我们还是从这里开始，因为它是我们添加所有其他的概念的基础。&lt;/p&gt;&lt;p&gt;在本节中，我们会看到一个简单的例子：在由 10 个值组成的简单数据集上分 Key 计算 SUM。对于每个示例，我都会提供一个 Dataflow Java SDK 伪代码的简短片段。从某种意义上说，这是伪代码，有时我会略作修改以使示例更清晰、也会省略一些细节(比如使用具体的I/O源)以及简化名称(Java 中当前的触发器名称非常冗长；为了清晰，我将使用更简单的名称)。除了诸如此类的小事之外，基本上都是真实的 Dataflow SDK 代码。后面我还会为那些对类似例子(可以编译和运行)感兴趣的人提供一个实际代码演练的链接。&lt;/p&gt;&lt;p&gt;如果你熟悉 Spark Streaming 或 Flink 等类似的工具，那么很容易理解 Dataflow 的代码。Dataflow 中有两个基本原语：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.41640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6Lrq9AjzdXrOnYTAIMbL4gGiaO4QUZuf1BhiaU8AAmibibtCas1HWiaVze8ZGefDI8xicFPCXaEkp4PoAGTqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;图1&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;就我们的例子而言，我们假定从名为 ‘input’ 的 &lt;code&gt;PCollection&amp;lt;KV&amp;lt;String，Integer&amp;gt;&amp;gt;&lt;/code&gt; (PCollection 由 Strings 和 Integer 的键/值对组成，其中 Strings 像是团队名称，Integer 则是对应每个团队成员分数)开始。在现实世界的 Pipeline 中，我们从来自 I/O 数据源的原始数据(例如，日志记录) PCollection 来获取输入，然后将日志记录解析为键/值对，并转换为 &lt;code&gt;PCollection&amp;lt; KV&amp;lt;String，Integer&amp;gt;&amp;gt;&lt;/code&gt;。在为了第一个例子更加清晰，我会包含所有步骤的伪代码，但在随后的例子中，我会忽略 I/O 和解析部分。因此，简单地从 I/O 源读取数据，解析出团队/分数，并计算每个团队总分数的 Pipeline 如下所示：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;// 代码1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;PCollection&amp;lt;String&amp;gt; raw = IO.read(...);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;PCollection&amp;lt;KV&amp;lt;String, Integer&amp;gt;&amp;gt; input = raw.apply(ParDo.of(new ParseFn());&lt;/span&gt;&lt;br/&gt;&lt;span&gt;PCollection&amp;lt;KV&amp;lt;String, Integer&amp;gt;&amp;gt; scores = input.apply(Sum.integersPerKey());&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;上述代码从 I/O 数据源读取键/值对数据，其中 Key 是 String 类型的团队名称，Value 是 Integer 类型的团队每个成员分数。然后根据 Key 分组求和产生每个团队的总分数。&lt;/p&gt;&lt;p&gt;对于接下来的所有例子，我们都会先看 Pipeline 的代码，然后再用动画展示一个数据集的运行过程。更具体地说，我们会看到一个 Key 的 10 条输入数据的执行过程。在一个真正的 Pipeline 中，你可以想象类似的操作会在多台机器上并行执行，但是在这里会尽量简化。每个动画都有两个维度：X 轴上的事件时间和 Y 轴上处理时间。白色的粗线条从底部向上移动表示 Pipeline 的实时进度，圆圈表示输入，圆圈内的数字表示记录的值。当观察到它们时，它们由之前的灰色变成白色，同时将它们累加在状态中，并最终将聚合结果输出。状态和输出由矩形表示，靠近顶部展示一个聚合值，矩形覆盖的区域表示部分事件时间和处理时间已经累加到结果中。对于上述代码中的 Pipeline，在经典的批处理引擎上执行时看起来就像下面一样：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6165951359084406&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6Lrq9AjzdXrOnYTAIMbL4gGiaOtPibKjwcefpKv7UDBpmuic0zmJXZPkKXwxsGf29oJKibSJ3rEiag7N3Fbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;699&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;图2&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;由于这是一个批处理 Pipeline，因此会累积状态，直到所有输入完成(到达顶部的绿色虚线时表示看到所有的输入)，此时产生最终的结果为 51。在这个示例中，因为我们没有使用任何窗口转换操作，所以我们是在所有事件时间上计算的总和，因此状态和输出的矩形覆盖了整个 X 轴。如果我们处理的是一个无限数据源，那么经典的批处理是不够的。我们不能等待所有输入结束，因为输入永远不会结束。在这里我们需要使用窗口这个概念，上篇文章中已经介绍了这个概念。因此，在回答第二个问题之前：计算的事件时间范围？，先我们简要回顾一下窗口这个概念。&lt;/p&gt;&lt;h3&gt;3.2 Where: windowing&lt;/h3&gt;&lt;p&gt;正如上次讨论的那样，窗口是沿着时间边界分割数据源的过程。常见的窗口策略有固定窗口、滑动窗口和会话窗口：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6Lrq9AjzdXrOnYTAIMbL4gGiaOvVFtF8GWbDrXaPCXcMH31R0AvcNGUnDz8nicFNSYk4n4ibHe683IyrOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;图3&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;为了更好地在实践中理解在窗口，我们以 2 分钟的固定窗口求和为例。使用 Dataflow SDK 比较简单，添加 Window.into 转换操作即可：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;// 代码2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;PCollection&amp;lt;KV&amp;lt;String, Integer&amp;gt;&amp;gt; scores = input&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  .apply(Window.into(FixedWindows.of(Duration.standardMinutes(2))))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  .apply(Sum.integersPerKey());&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;Dataflow 提供了一个适用于批处理和流式传输的统一模型（语义上批处理只是流式处理的一种特殊情况）。因此，我们先在批处理引擎上执行这个 Pipeline；机制比较简单，可以与切换到的流处理引擎直接进行比较。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6107954545454546&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6Lrq9AjzdXrOnYTAIMbL4gGiaOGLPCic9UibRbOd8tckVn3qicichU2kVLc75vwljVRibjyC53vPSjcShNqcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;704&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;图4&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;和以前一样，输入在状态中累积，直到所有输入完成，最后才输出最终结果。在这种情况下，我们会得到四个输出：四个两分钟事件时间窗口都有对应的一个输出。&lt;/p&gt;&lt;p&gt;到目前，我们重新回顾了 Streaming 101 中引入的两个概念：事件时间和处理时间之间的关系以及窗口。如果我们想继续探讨，我们需要了解本节涉及的新概念：Watermark、Triggers 和累积模式。&lt;/p&gt;&lt;h2&gt;4. Streaming 102&lt;/h2&gt;&lt;p&gt;我们刚才观察到的是在批处理引擎上执行一个窗口的 Pipeline。但理想情况下，我们希望结果具有较低的延迟。切换到流式引擎是才是正确的方向，对于批处理引擎我们都知道，每个窗口的输入都是完整的(即一旦有限输入源中的所有数据都已被消费)，但是对于无限数据源，我们目前缺乏确定其完整性的实际方法。因此引入了 Watermarks。&lt;/p&gt;&lt;h3&gt;4.1 When: watermarks&lt;/h3&gt;&lt;p&gt;Watermark 回答了 “什么时候(处理时间)输出结果？” 的前半部分。Watermark 是一个事件时间概念，用来衡量输入数据的完整性。换一种说法，它是系统以事件时间为尺度衡量记录在事件流中处理的进度和完整性的方法(无论是有限还是无限数据，尽管在无限数据中作用更明显)。回想一下 Streaming 101 中这张图（在这里稍作了修改），对于大多数现实世界分布式数据处理系统，事件时间和处理时间之间的偏差可以用随时间不断变化的函数表示。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.9772528433945756&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6Lrq9AjzdXrOnYTAIMbL4gGiaOlAAtmOQ9Z9sbJKaekNGVExn9Q5T8cp3pb2JgPzQbw0w8kCacibXoR8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1143&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;图5&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;上图中那条弯弯曲曲的红线实际上就是 Watermark，可以随着处理时间的推移能够获取事件时间完整性的进度。从概念上讲，可以将 Watermark 看作是一个函数 &lt;code&gt;F(P) -&amp;gt; E&lt;/code&gt;，输入一个处理时间点输出一个事件时间点。(更准确地说，函数的输入实际上是 Pipeline 中观察到 Watermark 时间点上游所有的当前状态：输入源，缓冲的数据，正在处理的数据等；但从概念上讲，可以简单的理解为处理时间到事件时间的映射)。事件时间点 E 表示事件时间小于 E 的那些输入数据都已经被看到了。换句话说，我们断言不会再看到事件时间小于 E 的其他数据了。根据 Watermark 的类型，完美 Watermark 和启发式 Watermark 会分别提供严格保证和有依据的猜测：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;完美 Watermarks：在对所有输入数据充分了解的情况下（了解数据的最大延迟等），可以构建完美 Watermarks；在这种情况下，没有迟到数据(late)，所有数据都是提前(early)或者准时到达(on-time)。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;启发式 Watermarks：对于许多分布式输入源，充分了解输入数据是不切实际的，在这种情况下，最佳选择是启发式 Watermarks。启发式 Watermarks 充分利用任何可以获取到的输入信息(分区，分区内的排序(如果有的话)，文件的增长率等)来提供尽可能准确的进度估计。在许多情况下，这种 Watermark 预测中是非常准确的，但是使用这种 Watermark 意味着有时可能是错的，这会导致迟到数据。我们会在下面的触发器部分中了解如何处理迟到数据。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Watermark 是一个非常吸引人且复杂的话题，但是它不是这篇文章讨论的重点，以后有机会专门写一篇文章来介绍。现在，为了更好地理解 Watermark 的作用和缺点，我们来看看两个使用 Watermark 流引擎的例子，以确定在执上述代码的窗口化 Pipeline 时何时输出结果。左边的例子使用的是完美 Watermarks，右边使用的是启发式 Watermarks。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.35650224215246634&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6Lrq9AjzdXrOnYTAIMbL4gGiaO1yJyQficV4Z5y5GtBabDOISyTwezOxIEVXlNg9JdJaEdNgzfOSsicjgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;图6&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在这两种情况下，当 Watermark 到达窗口结尾时，窗口就会被触发计算。两次执行的主要区别在于右侧的 Watermark 计算使用的是启发式算法没有考虑到 9 这个值，这很大程度上改变了 Watermark 的形状。这两个例子突出了 Watermark (以及其他的完整性概念)的两个缺点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Watermark 太慢：当任何类型的 Watermark 由于知道还有未处理的数据(例如，由于网络带宽限制而缓慢增长的输入日志)明确地延迟时，并且结果的计算需要依赖 Watermark 的推进，那么效果直接转换为输出中的延迟。这在左图中体现最明显，迟到到达的数据 9 卡住了所有后续窗口的 Watermark，就算这些窗口的输入数据早已经到达（也无法触发计算输出结果）。这在第二个窗口 [12：02,12：04] 中尤其明显，从窗口中第一个值到达到我们看到窗口输出结果花费了将近7分钟。启发式 Watermarks 表现的没有那么严重(花费了5分钟)，但不要认为启发式 Watermarks 不会受到 Watermark 延迟的影响；这个例子的效果与我选择的记录有关系（没有体现出来罢了）。需要注意的是：虽然 Watermark 提供了非常有用的完整性概念，但是从延迟角度来看，根据完整性生成输出往往不是很理想。设想一个仪表板，按小时或天划分窗口。你不太可能要等一小时或一天才能看到当前窗口的结果；这也是使用经典批处理系统为此类系统的痛点之一。我们更希望可以随着时间推移看到窗口的结果发生变化，最终产生完整地结果。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Watermark 太快：当启发式 Watermarks 错误的比原本的提前了，事件时间在 Watermark 之前的数据可能会延迟到达，从而产生迟到数据。在右边的例子就出现了这样的情况：在观察到该窗口的所有输入数据到达之前，Watermark 就提前到达了第一个窗口的结尾，导致错误的输出值 5 而不是 14。这是启发式 Watermarks 的一个严重问题，这种启发特性意味着它们有时会出错。因此，如果你关心正确性，只依靠它们来确定何时输出是不够的。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在 Streaming 101 中，我就强调完整性不足以解决无限数据流的乱序问题。Watermark 太慢和太快这两个缺点，是这个论点的理论依据。你不能寄希望系统只依赖完整性就能获得低延迟和正确性。触发器就是为了解决这些缺点而引入的。&lt;/p&gt;&lt;h3&gt;4.2 When: Triggers&lt;/h3&gt;&lt;p&gt;触发器(Triggers)回答了 “什么时候(处理时间)输出结果？” 的后半部分。触发器决定了窗口在处理时间上什么时候输出(尽管触发器本身可以根据其他时间概念作出上述决策，例如基于事件时间的 Watermark 处理)。窗口的每个特定输出都称为窗口的窗格(pane)。有几种触发的信号，如下所示：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Watermark 的进度(即事件时间进度)：上图 6 中已经隐含了触发器，当 Watermark 到达窗口末尾时输出被触发。另一个用例是当一个窗口的生命周期结束时会触发垃圾回收，我们稍后会看到这个例子。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;处理时间进度：对于提供有规律与周期性的更新非常有用，因为处理时间(不像事件时间)均匀的运行，不会出现延迟。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;元素个数：当一定数量的元素到达窗口时会触发。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;特殊标记：当遇到指定记录或者具有某些特征的记录(例如，EOF元素或刷新事件)时窗口触发。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;除了基于具体信号触发的简单触发器之外，还有复合触发器，可以允许创建更复杂的触发逻辑。复合触发器如下所示：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;重复触发器：与处理时间触发器配合使用，在提供有规律与周期性更新的场景下特别有用。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;逻辑与触发器(AND)：只有当所有子触发器触发时(例如，在 Watermark 到达窗口结尾并且观察到终止标点符记录之后)才触发。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;逻辑或触发器(OR)：任何一个子触发器触发时(例如，在 Watermark 到达窗口结尾或者观察到终止标点符记录之后)才触发。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;顺序触发器：按照预先定义的顺序触发一系列的子触发器(后一个子触发器必须等待前一个触发器触发)。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;为了更具体的了解触发器，我们将上述代码 2 中的隐式触发器显示添加到代码中：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;// 代码3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;PCollection&amp;lt;KV&amp;lt;String, Integer&amp;gt;&amp;gt; scores = input&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  .apply(Window.into(FixedWindows.of(Duration.standardMinutes(2)))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;               .triggering(AtWatermark()))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  .apply(Sum.integersPerKey());&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;考虑到我们已经对触发器有了基本了解，现在我们可以考虑解决 Watermark 太慢以及太快的问题。在这两种情况下，我们希望为窗口提供某种周期性的更新，无论是 Watermark 到达窗口结尾之前还是之后(不仅仅是在 Watermark 通过窗口的结尾时触发更新)。所以，我们需要某种重复触发器。那么问题就变成了：重复触发的条件是什么？&lt;/p&gt;&lt;p&gt;在太慢的情况下：由于输出太晚，所以要提早提供推测结果。我们假定任何窗口都有稳定的输入数据量，我们知道窗口输入是不完整的，还有数据尚未到达。因此，按照处理时间周期性(例如，每分钟一次)触发可能是一种明智的做法。因为触发器触发的次数不会取决于窗口内观察到的实际数据量，在最坏的情况下，也就是源源不断的周期性触发。&lt;/p&gt;&lt;p&gt;在太快的情况下：使用启发式 Watermarks 会出现迟到数据，所以当出现迟到数据时需要修正结果。假设我们的 Watermark 基于相对准确的启发式算法(通常是合理安全的假设)。在这种情况下，不会有过多的迟到数据，但是当看到迟到数据时，需要快速修正我们的结果。只要看到一个迟到元素时就要立即触发更新。考虑到这种迟到数据不会太多，不会对我们系统的负载产生太大影响。请注意，这里只是举了一个例子，你可以根据自己的情况自由选择触发的条件（比如只在上面某一种情况下触发，或者都不触发）。&lt;/p&gt;&lt;p&gt;最后，我们需要协调各种触发的时机：提前、准时或者迟到。我们可以通过顺序触发器和一个特殊的 OrFinally 触发器来完成这个工作，OrFinally 触发器有一个子触发器，当子触发器触发时会终止父触发器。&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;// 代码4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;PCollection&amp;lt;KV&amp;lt;String, Integer&amp;gt;&amp;gt; scores = input&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  .apply(Window.into(FixedWindows.of(Duration.standardMinutes(2)))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;               .triggering(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                  Sequence(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                    Repeat(AtPeriod(Duration.standardMinutes(1))).OrFinally(AtWatermark()),&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                    Repeat(AtCount(1))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                  )&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                )&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  .apply(Sum.integersPerKey());&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;但是，这种写法很罗嗦。考虑到 &lt;code&gt;repeated-early | on-time | repeated-late&lt;/code&gt; 触发模式非常常见，所以我们在 Dataflow 中提供了一个自定义的(但是语义上相同的)API，使得指定这样的触发器更简单清晰：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;// 代码5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;PCollection&amp;lt;KV&amp;lt;String, Integer&amp;gt;&amp;gt; scores = input&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  .apply(Window.into(FixedWindows.of(Duration.standardMinutes(2)))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;               .triggering(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                 AtWatermark()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   .withEarlyFirings(AtPeriod(Duration.standardMinutes(1)))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   .withLateFirings(AtCount(1))))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  .apply(Sum.integersPerKey());&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;在流式引擎上执行上述两段代码(与之前一样使用完美 Watermarks 和启发式 watermarks)，然后生成如下所示的结果：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3523489932885906&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6Lrq9AjzdXrOnYTAIMbL4gGiaOMM91eibBL1k5EpyGZ6WSo7sgXpE56ARzricaAeGlUE2u2SU5Fe30EAkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;894&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;图 7&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;这个版本比图 6 有两个明显的改进：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;对于第二个窗口 [12:02, 12:04) 中的’Watermark 太慢’的情况：我们现在每分钟提供一次周期性提前更新。在完美 Watermark 情况下，差异最为明显，首次输出时间从接近七分钟减少到三分半。在启发式 Watermark 场景下也得到了明显的改进。这两个版本随着时间的推移都不断的修正结果（值分别为 7、14 和 22 的窗格），在输入完成和窗口的最终输出之间提供了相对最小的延迟。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;对于第一个窗口 [12:00, 12:02) 中的’启发式 Watermark 太快’的情况：当迟到数据 9 到达时，我们立即更新输出结果，输出了正确的窗格值 14。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这些新触发器的让人兴奋的作用是有效地统一了完美和启发式 Watermark 版本之间的输出模式。虽然图 6 中的两个版本截然不同，但这里的两个版本看起来已经非常相似了。此时剩下最大的差异是窗口生命周期。在完美 Watermark 情况下，我们知道一旦 Watermark 到达了窗口结尾，我们再也不会看到窗口的其他任何数据，因此我们可以在这个时候删除窗口的所有状态。但在启发式 Watermark 的情况下，我们仍然需要保留一段时间的窗口状态，以解决迟到数据。但是到目前为止，我们的系统还没有任何好的方法可以知道每个窗口的状态需要保留多长时间。这里我们需要引入’可允许的迟到’这个概念。&lt;/p&gt;&lt;h3&gt;4.3 When: allowed lateness&lt;/h3&gt;&lt;p&gt;在进入最后一个问题’如何修正相关结果？’之前，我们先讨论处理长期无序数据数据流系统必备的一个功能：垃圾回收。图 7 的启发式 Watermark 例子中，窗口的状态在该示例的整个生命周期内都会保存。为了处理迟到数据，这么做是有必要的。虽然将我们所有的持久状态保存到时间结束时是一件很棒的事情，但是，在实际环境中，当处理无限数据源时，无限期地保存窗口状态（包括元数据）是不切实际的，最终会耗尽磁盘空间。&lt;/p&gt;&lt;p&gt;因此，任何现实世界的无序处理系统都需要提供某种方法来限制窗口的生命周期。一种简单的方法是在系统内定义可允许的迟到时间范围，即需要对记录可能迟到多长时间(相对于 Watermark)设置一个上限，以便系统进行处理；在此范围之后到达的任何数据都会被简单地丢弃。一旦确定了单条数据的迟到时间，你就能精确地确定窗口的状态必须保存多长时间：直到 Watermark 超过窗口结束后的可迟到时间范围。此外，还允许系统立即删除观察到任何晚于可迟到时间范围内的数据，这意味着系统不会浪费资源处理没人关心的数据。&lt;/p&gt;&lt;p&gt;由于可允许的迟到时间范围与 Watermark 之间的交互有点微妙，所以我们需要看一个例子。我们在代码 5 中添加一分钟的可允许的迟到时间范围（请注意，这里选择这个迟到时间范围是因为它比较适合图表展示，但在实际用例中，迟到时间范围可能会有更大）：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;// 代码6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;PCollection&amp;lt;KV&amp;lt;String, Integer&amp;gt;&amp;gt; scores = input&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  .apply(Window.into(FixedWindows.of(Duration.standardMinutes(2)))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;               .triggering(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                 AtWatermark()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   .withEarlyFirings(AtPeriod(Duration.standardMinutes(1)))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   .withLateFirings(AtCount(1)))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;               .withAllowedLateness(Duration.standardMinutes(1)))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  .apply(Sum.integersPerKey());&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;上述代码的执行类似于下图 8 所示，在图中我添加了如下功能来突出可允许的迟到时间范围的影响：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;粗白线表示处理时间的当前位置，现在用有注释的虚白线给所有窗口标注可允许的迟到时间范围（注意的是迟到时间范围是使用的事件时间）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;一旦 Watermark 超过了窗口的可允许的迟到时间范围，窗口就会关闭，这意味着窗口的所有状态都会被丢弃。图中的虚线矩形表示窗口关闭时覆盖的时间范围（两个时间上的范围：处理时间和事件时间），一条小尾巴向右延伸表示窗口的可允许迟到时间范围（事件时间上的范围，用于与 Watermark 对比）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我在第一个窗口中添加了一个额外的迟到数据 ‘6’。虽然是迟到数据，但仍在可允许的迟到时间范围内，因此这个数据到达时也会更新结果（11）。但是，迟到数据 9 已经超过了可允许的迟到时间范围，所以被简单地丢弃了。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.671664167916042&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6Lrq9AjzdXrOnYTAIMbL4gGiaOHAgbHu3kqkyGtF1YCSbgLzBkpV4yBqMC7cQKjD3C33libIr5mPyEZqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;667&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;图8 流引擎上的窗口求和，有 early 和 late 触发并设置了可允许的迟到时间范围&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;关于可允许的迟到时间范围最后有两个注意点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;如果你使用的是来自具有完美 Watermark 数据源的数据，那么无需处理迟到数据，并且将可允许的迟到时间范围设置 0 秒即可。这就是图 7 中完美 Watermark 部分中看到的效果。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;指定可允许的迟到时间范围有一个例外：即使使用启发式 Watermark 时，也可以像为有限数量的 Key 计算全局聚合结果（例如，按 Web 浏览器类型分组计算网站的总访问次数）。在这种情况下，系统中活动窗口的数量受限于有限 Key 的个数。只要 Key 的数量保持在可管理的低水平，就无需担心通过可允许的迟到来限制窗口的生命周期。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;4.4 How: accumulation&lt;/h3&gt;&lt;p&gt;随着时间的推移，触发器会为一个窗口产生多个窗格。到这，我们剩最后一个问题：如何修正相关结果？在我们目前看到的例子中，每个连续的窗格都建立在它前面的窗格之上。实际上存在三种不同的累积模式：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;丢弃(Discarding)：每次物化输出窗格时，都会丢弃存储状态。这意味着每个窗格都是相互独立的。当下游消费者自己执行某种累积时，这种丢弃模式很有用，例如那些只希望接收差值（delta）来求和的系统，我们只需要把接收到的新数值发送给它即可。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;累积(Accumulating)：如图 7 所示，每次物化输出窗格时，都会保留存储状态，并将新的输入累积到现有状态中。这意味着每个连续的窗格都建立在前一个窗格的基础上。当新的结果可以简单地覆盖老的结果时，这种累积模式很有用，例如将输出存储在 BigTable 或 HBase 等键/值存储中时。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;累积和撤回(Accumulating &amp;amp; Retracting)：与累积模式一样，但在物化输出窗格时，会为之前的窗格生成一个单独的撤回。撤回（配合新的累积结果）实质上是明确告诉你：’对不起，我之前告诉你的结果是 X 是错的。把我上次告诉你的 X 撤回，换成 Y’。撤回在如下两种情况下特别有用：&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;三种不同的累积模式放在一起对比查看时，不同模式的不同语义会更加清晰。我们以图 7 中第二个窗口为例，该窗口出现了三个窗格（事件时间范围为 [12:02, 12:04））。下表展示了在三种累积模式下每个窗格的值是什么样的（图 7 使用的是累积模式）：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3765281173594132&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6Lrq9AjzdXrOnYTAIMbL4gGiaO7pFWsFhVAITtd37iaYFopAJerqrNic5ZKgzR0cFVJuZQvbMQpo4Pbckw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;818&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;表1&lt;/p&gt;&lt;/blockquote&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;丢弃模式：每个窗格仅包含在该窗格期间到达的值。因此，观察到的最终值并不等于最终的总和。但是，如果你将每个窗格的值相加，你就会得到正确的值 22。这就是为什么当下游消费者本身在窗格上执行某种聚合时丢弃模式很有用的原因。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;累积模式：如图 7 所示，每个窗格都包含在该窗格期间到达的值，以及来自上一个窗格的所有值。因此，观察到的最终值正确的计算出总和 22。但是，如果你将每个窗格的值相加，那么实际上对窗格 2 重复计算了两次，对窗口 1 重复计算了三次，给到你的总和 51 也不是正确的。这就是为什么当你可以简单地用新值覆盖以前的值时累积模式最有用的原因：新值已经包含了迄今为止看到的所有数据。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;累积和撤回模式：每个窗格都包括一个新的累积值以及对前一个窗格值的撤回。因此，观察到的最后一个（非撤回）值以及所有窗格值（包括撤回值）的总和都为你提供了正确答案 22。这就是撤回如此强大的原因。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果要查看丢弃模式的实际效果，我们需要对代码 5 做如下修改：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;// 代码7&lt;/span&gt;&lt;br/&gt;&lt;span&gt;PCollection&amp;lt;KV&amp;lt;String, Integer&amp;gt;&amp;gt; scores = input&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  .apply(Window.into(FixedWindows.of(Duration.standardMinutes(2)))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;               .triggering(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                 AtWatermark()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   .withEarlyFirings(AtPeriod(Duration.standardMinutes(1)))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   .withLateFirings(AtCount(1)))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;               .discardingFiredPanes())&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  .apply(Sum.integersPerKey());&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;在带有启发式 Watermark 的流引擎上再次运行会产生如下输出：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6952380952380952&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6Lrq9AjzdXrOnYTAIMbL4gGiaOp7HG1iavY2AZB5Ycxg3HEia40FicSYrdrNOLrP5cFA7rHtHnJkqiaaTv2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;630&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;图9&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;虽然输出的整体形状类似于图 7 中的累积模式，但需要注意的是丢弃模式下任何窗格都没有重叠。因此，每个输出都与其他输出是相互独立的。如果我们想查看实际的撤回效果，修改也是相似的（但是请注意，此时 Google Cloud Dataflow 的撤回仍在开发中，因此 API 中的命名有些推测）：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;// 代码8&lt;/span&gt;&lt;br/&gt;&lt;span&gt;PCollection&amp;lt;KV&amp;lt;String, Integer&amp;gt;&amp;gt; scores = input&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  .apply(Window.into(FixedWindows.of(Duration.standardMinutes(2)))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;               .triggering(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                 AtWatermark()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   .withEarlyFirings(AtPeriod(Duration.standardMinutes(1)))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   .withLateFirings(AtCount(1)))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;               .accumulatingAndRetractingFiredPanes())&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  .apply(Sum.integersPerKey());&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;在流引擎上运行，会产生如下输出：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6904761904761905&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6Lrq9AjzdXrOnYTAIMbL4gGiaOruiaUCGmZMWtXjbmNiaXIpPdOMWDxwHcyQicGO5J6GNd2LnIeWNH66qBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;630&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;图10&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;由于每个窗格都有重叠，因此要清楚地看到撤回有点棘手，因此我们用红色表示撤回，由于与背景蓝色窗格重叠会产生略带紫色的颜色。为了更容易的区分两个值，我稍微调整了下两个数值的位置并把它们以逗号分隔。把图 9、7（仅看启发式）和 10 的最终帧放在一起比较，可以更好的看出三种模式的区别：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6Lrq9AjzdXrOnYTAIMbL4gGiaOCicpZBgxvuBK4KS0BrDt77TUtkLWaZLdwCg0iaJdU9EOQgkicUd1giatFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;图11&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;可以预想到，按顺序呈现的三种模式（丢弃、累积、累积和收回）在存储和计算成本方面都越来越贵。因此，累积模式的选择是在正确性、延迟和成本三方面的一种权衡。&lt;/p&gt;&lt;h2&gt;5. 插曲&lt;/h2&gt;&lt;p&gt;到目前为止，我们已经回答了所有四个问题：&lt;/p&gt;&lt;p&gt;上面我们上只研究了一种窗口：基于事件时间的固定窗口。从 Streaming 101 中我们知道，窗口有好几种类型，在结束之前我们一起看一下这两种窗口：处理时间固定窗口和事件时间会话窗口。&lt;/p&gt;&lt;h3&gt;5.1 When/Where: 处理时间窗口&lt;/h3&gt;&lt;p&gt;处理时间窗口很重要，原因有两个：&lt;/p&gt;&lt;p&gt;因此，深入了解处理时间窗口和事件时间窗口之间的差异是非常值得的，特别是考虑到当今大多数流系统中处理时间窗口被广泛应用。当我们面对的模型是严格使用事件时间时（例如本文的例子），有两种方式可以实现处理窗口：&lt;/p&gt;&lt;p&gt;需要注意的是，这两种方法或多或少是等价的，尽管在多阶段（Stage） Pipeline 的情况下会略有不同：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;在使用触发器情况下，每个阶段独立地切分处理时间窗口，例如这一阶段窗口 X 中的数据可能会在出现在下一阶段的窗口 X-1 或 X+1 中；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在使用摄入时间情况下，一旦数据进入到窗口 X 中，在整个 Pipeline 期间都只会出现在窗口 X 中。这是由于通过 Watermark（在 Dataflow 中）、微批次边界（在 Spark Streaming 中）或引擎级别的其他协调因素实现了不同阶段的进度同步。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;正如我已经注意到的那样，处理时间窗口的最大缺点是当输入的顺序发生变化时窗口的内容也会发生变化。为了更具体地说明这一点，我们将研究如下三个用例：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;事件时间窗口&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过触发器实现的处理时间窗口&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;通过摄入时间实现的处理时间窗口&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们会在这三种用例上分别使用两个不同的数据集（所以，一共会有2*3种情况）。这两个输入集有完全相同的事件（相同的值，相同的事件时间），但是观察到顺序不同（即处理时间不同）。第一个输入集是我们上面一直看到的观察顺序，颜色为白色；第二个输入集在处理时间轴上做了一些移动（改变了处理时间），如下图 12 所示，颜色为紫色。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6536144578313253&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6Lrq9AjzdXrOnYTAIMbL4gGiaOxxTBB4D7SMicIDwiaNBA2rImpwAkAtAgGOhz3F2EuoaoABXWxYV9lLxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;664&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;图12&lt;/p&gt;&lt;/blockquote&gt;&lt;h4&gt;5.1.1 事件时间窗口&lt;/h4&gt;&lt;p&gt;为了建立一个基线，我们首先在启发式 Watermark 的事件时间固定窗口上分别观察这两个输入集的输出结果。我们重用代码 5/图 7 中的 early/late 代码来获得下面的结果。左边基本上是我们之前看到的样子；右边是第二个输入集的结果。这里需要注意的一点是：即使输出的整体形状不同（在处理时间上观察的顺序不同），但四个窗口的最终输出结果都是一样的：14、22、3 和 12：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.35159235668789807&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6Lrq9AjzdXrOnYTAIMbL4gGiaOxjqB6yNF5A2be1icO4kemf5BbN3SrTvpqaDT0ib15drNWcicXfQqUm7icg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;785&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;图13&lt;/p&gt;&lt;/blockquote&gt;&lt;h4&gt;5.1.2 通过触发器实现的处理时间窗口&lt;/h4&gt;&lt;p&gt;现在让我们对比一下上述两种处理时间的方法。首先，我们看一下如何使用触发器实现，需要注意三个方面：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;窗口：我们使用全局事件时间窗口，本质上是用事件时间窗格模拟处理时间窗口。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;触发器：我们根据所需的处理时间窗口大小在处理时间上定期触发窗口。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;累积模式：我们使用丢弃模式来保持窗格之间的彼此独立，从而让它们每个都像一个独立的处理时间’窗口’。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;相应的代码类似于代码 9；需要注意的是，全局窗口是默认设置，因此不需指定窗口策略：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;// 代码9&lt;/span&gt;&lt;br/&gt;&lt;span&gt;PCollection&amp;lt;KV&amp;lt;String, Integer&amp;gt;&amp;gt; scores = input&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  .apply(Window.triggering(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                  Repeatedly(AtPeriod(Duration.standardMinutes(2))))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;               .discardingFiredPanes())&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  .apply(Sum.integersPerKey());&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;当使用两种不同顺序的输入数据在流式引擎上执行时，结果如下图 14 所示。需要注意的是：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.31297709923664124&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6Lrq9AjzdXrOnYTAIMbL4gGiaOBJpgExXnCTegyibWoTAricLEMkoS4IbPganicHGftIgicHiac51KHqV642Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;786&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;图14&lt;/p&gt;&lt;/blockquote&gt;&lt;h4&gt;5.1.3 通过摄入时间实现的处理时间窗口&lt;/h4&gt;&lt;p&gt;最后，让我们看看通过将摄入时间映射输入数据的事件时间来实现处理时间窗口。代码方面，这里有四个方面值得一提：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;时间修改：当元素到达时，事件时间需要被摄入时间覆盖。需要注意的是，我们目前在 Dataflow 中还没有标准 API（因此在伪代码 I/O 源上使用了虚构的方法）。对于 Google Cloud Pub/Sub，你只需在发布消息时将消息的 timestampLabel 字段留空即可；对于其他来源，你需要自己查阅文档。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;窗口：使用标准的事件时间固定窗口。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;触发器：由于摄入时间提供了计算完美 Watermark 的能力，我们可以使用默认触发器，在这种情况下，当 Watermark 超过窗口末尾时，会隐式触发一次。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;累积模式：由于我们每个窗口只有一个输出，因此累积模式不重要。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;因此，实际代码如下所示：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;// 代码10&lt;/span&gt;&lt;br/&gt;&lt;span&gt;PCollection&amp;lt;String&amp;gt; raw = IO.read().withIngressTimeAsTimestamp();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;PCollection&amp;lt;KV&amp;lt;String, Integer&amp;gt;&amp;gt; input = raw.apply(ParDo.of(new ParseFn());&lt;/span&gt;&lt;br/&gt;&lt;span&gt;PCollection&amp;lt;KV&amp;lt;String, Integer&amp;gt;&amp;gt; scores = input&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  .apply(Window.into(FixedWindows.of(Duration.standardMinutes(2))))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  .apply(Sum.integersPerKey());&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;在流式引擎上执行如下图 15 所示。当数据到达时，事件时间会用摄入时间更新（即到达系统时的处理时间），从而导致向右水平移动到理想的 Watermark 线上。需要注意的是：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;与其他处理时间窗口示例一样，当输入的顺序发生变化时，我们也会得到不同的结果，即使输入的值和事件时间保持不变。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;与 Trigger 示例不同，窗口在事件时间上（因此沿着 X 轴）。尽管如此，它们并不是真正的事件时间窗口。我们只是将处理时间映射到事件时间上，删除每个输入的原始发生记录，并用一个新记录替换它，实际上并不是首次观察到数据的时间。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;尽管如此，由于有了 Watermark，触发器仍然在前面处理时间示例完全相同的时间点触发。此外，生成的输出值与 Trigger 示例的相同：左侧为 12、21、18，右侧为 7、36、4。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;由于使用摄入时间时可能会出现完美的 Watermark，实际 Watermark 与理想 Watermark 一样，以斜率为 1 的直线向右上方上升。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3324742268041237&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6Lrq9AjzdXrOnYTAIMbL4gGiaOibNEGwXwCkK6eK93JPtVaU0X4rctgn3Ua7tEgT3dqoxwT6ia8A3DtVEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;776&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;图15&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我们可以看到实现处理时间窗口可以有不同的方式，但这里最大的收获是我自第一篇文章以来一直在强调的：事件时间窗口与顺序无关（在输入完成之前，实际的窗口会不断变化）；然而处理时窗口不是这样的。如果你关心事件实际发生的时间，则必须使用事件时间窗口，否则你的结果将会毫无意义。&lt;/p&gt;&lt;h3&gt;5.2 Where: 会话窗口&lt;/h3&gt;&lt;p&gt;我们现在要看看我最喜欢的功能之一：动态的、数据驱动的窗口，称为会话窗口。会话窗口是一种特殊类型的窗口，会捕获数据中的一个活动周期（由不活动的间隔时间划分不同的活动周期）。这在数据分析中特别有用，因为可以提供用户在特定时间段内参与的某些活动。在会话中看到关联的活动，并根据会话的长度推断参与程度等。从窗口的角度来看，会话窗口在两个方面特别有趣：&lt;/p&gt;&lt;p&gt;对于某些用例，可以提前使用通用标识符对单个会话中的数据进行打标。在这种情况下，会话更容易构建，因为基本上只要按照 Key 分组就好了。然而，在更一般的情况下（即，实际会话本身并不提前知道），会话必须仅根据在时间范围上的位置来构建。在处理乱序数据时，这变得特别棘手。&lt;/p&gt;&lt;p&gt;提供一般会话的关键是，根据定义，完整的会话窗口是一组较小的重叠窗口的组合，每个窗口包含一条记录，序列中的每条记录与下一条记录之间的间隔不超过预定义的超时时间。因此，即使我们观察到会话中的有乱序数据，我们也可以简单地通过将重叠的窗口合并在一起来构建最终会话，以便在单个数据到达时将它们合并在一起。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6Lrq9AjzdXrOnYTAIMbL4gGiaOO7C2bEM3PricvLsRE6eqkMKiajqKkVm1cPj3JHkBMcE0t76iczQ1Vv7jA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;图16&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;让我们看一个示例，使用代码 8 中启用了撤回的 early/late 代码，并改为会话窗口：&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;// 代码11&lt;/span&gt;&lt;br/&gt;&lt;span&gt;PCollection&amp;lt;KV&amp;lt;String, Integer&amp;gt;&amp;gt; scores = input&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  .apply(Window.into(Sessions.withGapDuration(Duration.standardMinutes(1)))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;               .triggering(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                 AtWatermark()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   .withEarlyFirings(AtPeriod(Duration.standardMinutes(1)))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                   .withLateFirings(AtCount(1)))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;               .accumulatingAndRetractingFiredPanes())&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  .apply(Sum.integersPerKey());&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;在流引擎上执行，你会得到如下图 17 所示的内容：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.696&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6Lrq9AjzdXrOnYTAIMbL4gGiaOiaNZO562Agsdib3LV0ZFqhDqjvOkDgwxFaY9P2ROW9kAehkicpX8IzNOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;625&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;图17&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;这里做了很多事情，所以我与你们一起看一下：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;当遇到第一个值为 5 的记录时，会被放置到一个原始会话窗口中，该窗口从该记录的事件时间开始并横跨会话间隙持续时间的宽度，例如，超过该数据发生点一分钟。后面再遇到与这个窗口重叠的任何窗口都应该是同一会话的一部分，会被合并到这个窗口中。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;第二个到达的记录是 7，同样被放置在它自己的原始会话窗口中，因为它不与 5 的窗口重叠。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;同时，Watermark 已经超过了第一个窗口的末尾，所以值 5 在 12:06 之前作为 on-time 结果输出。此后不久，就在处理时间达到 12:06 时，第二个窗口也输出值为 7。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;接下来，我们观察到一系列记录：3、4 和 3，它们的原始会话出现了重叠。最终，它们全部合并在一起，并在 12:07 时遇到了 early 触发器触发，输出一个值为 10 的窗口。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;8 很快到达，与值为 7 的原始会话和值 10 的合并会话重叠。因此，这三个需要合并在一起，形成一个新的组合会话，值为 25。当 Watermark 到达这个会话结尾时，输出新会话值 25 以及先前输出但后来合并到其中的两个窗口的撤回：7 和 10。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;当迟到的数据 9 到达时，同值为 5 的原始会话和值为 25 的合并会话再合并为一个更大的值为 39 的新会话。39 以及 5 和 25 窗口的撤回都在迟到数据触发器触发时立即输出。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这非常强大。真正令人敬畏的是，在一个模型中描述这样的事情是多么的容易，该模型将流处理的维度分解为不同的、可组合的部分。最后，你只需要更多地关注手头的业务逻辑，不用关注将数据塑造成某种可用形式的细节。如果你不相信我，可以查看这篇博文：如何在 Spark Streaming 上手动建立会话（请注意，这样做并不是为了指责他们做的不好；Spark 的人在其他所有方面都做得很好）。&lt;/p&gt;&lt;h2&gt;6. 终结篇，感觉好极了！&lt;/h2&gt;&lt;p&gt;到此，我已经完成了所有示例。你现在已经深入了解强大的流处理的基础，并准备好走向这个流处理世界并做出一些令人兴奋的事情。但在你离开之前，我想快速回顾一下我们所涵盖的内容，以免你匆忙忘记其中的任何内容。首先，我们涉及的主要概念：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;事件时间与处理时间：最重要的区别是一个是事件发生时间；一个是数据处理系统观察到事件时间。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;窗口：沿时间边界切分是管理无限数据的常用方法（按照处理时间或事件时间，尽管我们在 Dataflow 模型中仅使用事件时间）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Watermarks：衡量事件时间进度的一个非常有用的概念，提供了一种在操作无限数据的无序处理系统中推测完整性的方法。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;触发器：一种告知系统何时可以输出数据的声明机制。在某些场景中十分重要。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;累积模式：单个窗口在演变多次物化时，不同修正结果之间的关系。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;其次，我们用来构建框架的四个问题（我承诺这是最后一次说它们）：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;What：计算逻辑是什么？= transformations&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Where：计算的事件时间范围？= 窗口&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;When：什么时候(处理时间)输出结果？= watermarks + triggers&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;How：如何修正相关结果？= accumulation&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;第三，也是最后一点，为了将这种流处理模型所提供的灵活性带回家（因为最后，这才是真正的意义：权衡正确性、延迟和成本三者之间的关系），回顾一下：我们只要修改一点点代码就能实现在相同数据集上各种不同的产出：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8687898089171975&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6Lrq9AjzdXrOnYTAIMbL4gGiaOftdHKLiaRgczSD4G6IN1dhnRdTibuLSJmFfcBNnQHg7wGDTGDqsCcWLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;785&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;图18&lt;/p&gt;&lt;/blockquote&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI0OTYwNTQ4Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/nKovjAe6LrpVR0GEQn2UGOvBUCta35aF6ibVFvTR0fFPE83DrdKGl8v2sCTVbYNJPnun6Yftg1OAlMJ94kxzgyg/0?wx_fmt=png&quot; data-nickname=&quot;大数据生态&quot; data-alias=&quot;big_data_ecosphere&quot; data-signature=&quot;火爆数年的大数据圈，让很多人还没弄懂大数据是什么，就已然身处其中。该订阅号对大数据行业中的各个领域进行梳理，有助于业内人士了解大数据生态圈。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;原文: Streaming 102: The world beyond batch&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>