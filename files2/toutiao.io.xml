<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b06f159afce4d8153161d0a50842e973</guid>
<title>[推荐] 软件架构基础（一）：架构师的 8 大核心能力</title>
<link>https://toutiao.io/k/mk9kqnq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;strong data-darkmode-bgcolor-16068282692859=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16068282692859=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16068282692859=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16068282692859=&quot;rgb(0, 0, 0)&quot; data-style=&quot;font-size: medium; white-space: normal; caret-color: rgb(52, 73, 94); max-width: 100%; color: rgb(0, 0, 0); font-family: -apple-system-font, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; text-align: left; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__1&quot; data-darkmode-color-16094149065186=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16094149065186=&quot;rgb(0, 0, 0)&quot;&gt;&lt;span data-darkmode-bgcolor-16068282692859=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16068282692859=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16068282692859=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16068282692859=&quot;rgb(136, 136, 136)&quot; data-darkmode-color-16094149065186=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16094149065186=&quot;rgb(136, 136, 136)&quot;&gt;&lt;span data-darkmode-bgcolor-16068282692859=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16068282692859=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16068282692859=&quot;rgb(217, 33, 66)&quot; data-darkmode-original-color-16068282692859=&quot;rgb(217, 33, 66)&quot; data-darkmode-color-16094149065186=&quot;rgb(217, 33, 66)&quot; data-darkmode-original-color-16094149065186=&quot;rgb(217, 33, 66)&quot;&gt;▲ &lt;/span&gt;&lt;span data-darkmode-bgcolor-16068282692859=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16068282692859=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16068282692859=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16068282692859=&quot;rgb(2, 30, 170)&quot; data-style=&quot;max-width: 100%; color: rgb(2, 30, 170); text-align: center; font-size: 11px; letter-spacing: 1px; visibility: visible;&quot; class=&quot;js_darkmode__2&quot; data-darkmode-color-16094149065186=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16094149065186=&quot;rgb(2, 30, 170)&quot;&gt;点击上方&quot;多颗糖&quot;&lt;/span&gt;&lt;span data-darkmode-bgcolor-16068282692859=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16068282692859=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16068282692859=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16068282692859=&quot;rgb(62, 62, 62)&quot; data-style=&quot;max-width: 100%; color: rgb(62, 62, 62); text-align: center; font-size: 11px; letter-spacing: 1px; visibility: visible;&quot; class=&quot;js_darkmode__3&quot; data-darkmode-color-16094149065186=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16094149065186=&quot;rgb(62, 62, 62)&quot;&gt;关注公众号&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;《软件架构基础（Fundamentals of Software Architecture）》被誉为和《设计数据密集型应用》一样经典的后端书籍，架构师的入门指南。本篇为该书第一章的读书笔记，2021 年第一个目标就是和大家一起读完这本书。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.3226600985221675&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA1sLqkl0nicPpFFBzwPJGIhB7Jv4gHI8AQBGRolrSlMMhNLvV32cmZA51czvSH8fvIKDFFEfibRexMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;812&quot;/&gt;&lt;/p&gt;&lt;p&gt;如今，全球范围内“架构师”这一头衔炒得十分火热，但没有真正的指南来帮助开发人员成为软件架构师。&lt;/p&gt;&lt;p&gt;这本书主要有三部分内容：基础、架构风格、技术和软技能。基础部分是关于软件体系结构的一般概念；架构风格部分介绍了不同的架构风格，并以一些架构特征标准进行评价；技术和软技能部分涵盖了很多好的概念，包括做出健康的架构决策、风险分析技术、演讲能力、管理团队关系、谈判、架构师职业规划等。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;架构就是关于重要的东西......不管那是什么。—— Ralph Johnson&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;1. 什么是软件架构&lt;/h2&gt;&lt;p&gt;学习架构就像学习艺术一样，读者必须要在特定的背景下去理解它。&lt;/p&gt;&lt;p&gt;在一个动态系统中，不存在一劳永逸的解决方案。&lt;/p&gt;&lt;p&gt;学习架构时，必须放在上下文中理解。架构师做的许多决定都是基于他们所处的实际情况。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;例如，在 20 世纪末的主要目标是有效地利用共享资源，因为当时所有的基础设施都是昂贵的商业化产品：操作系统、服务器和数据库等等。如果你在 2002 年告诉主管，“我有一个革命性的架构好主意，每个服务都运行在自己隔离的机器上，有自己的专用数据库……（即描述今天的微服务架构）所以，我需要 50 个 Windows 的许可证，另外 30 个服务器许可证，以及至少 50 个数据库许可证。”在 2002 年想构建这样的微服务架构成本之高难以想象。然而这几年，随着开源运动的兴起，以及 DevOps 的出现，我们可以合理地构建一个如上所述的架构。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;整个行业都在努力精确定义“软件架构”，有些称为系统的蓝图，有些定义为开发的路线图。本书关于架构的定义主要从四个方面：&lt;/p&gt;&lt;h4&gt;&lt;span&gt;系统的结构指的是系统实现架构风格的类型（如微服务、分层或微内核）。但仅仅通过结构来描述一个架构，并不能完全阐明一个架构。&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6964924838940587&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA1sLqkl0nicPpFFBzwPJGIhBtCQv2FHH8A6vamHZ2QefZNwC81bWiagAsaeh6ZiaGQQV13N54JYOhl4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1397&quot;/&gt;&lt;/p&gt;&lt;p&gt;￼&lt;/p&gt;&lt;h4&gt;&lt;span&gt;架构特性多以 &quot;&lt;em&gt;-ility&lt;/em&gt;&quot; 结尾（例如 Availability、Scalability）&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6964924838940587&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA1sLqkl0nicPpFFBzwPJGIhBTlkT7LCZeO3Z7oYrmvVjQ3eMMMeKVEnW2LRuLE276F4x7hjHcwIVEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1397&quot;/&gt;&lt;/p&gt;&lt;p&gt;￼&lt;/p&gt;&lt;h4&gt;&lt;span&gt;架构决策定义了系统应该如何构建的规则。例如，架构师可能会做出一个架构决策，即在分层架构中只有业务层和服务层可以访问数据库（见图），限制表现层直接调用数据库。架构决策形成了系统的约束，并指导开发团队什么是允许的，什么是不允许的。&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7050823192555477&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA1sLqkl0nicPpFFBzwPJGIhBfBo6ZbhHUk7MEmKf8GFa46NR2XxKdFmmWjDnicVdyA0McNOSyRN8a7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1397&quot;/&gt;&lt;/p&gt;&lt;p&gt;￼&lt;/p&gt;&lt;h4&gt;&lt;span&gt;设计原则与架构决策的不同之处在于，设计原则是一个指导方针，而不是一个硬性规定。例如，图示的设计原则指出，开发团队应该在微服务架构中的服务之间传递异步消息来提高性能。一个架构决策永远不可能涵盖服务之间通信的每一个条件和选项，设计原则为首选方法（在本例中，异步消息传递）提供指导，允许开发人员在特定情况下选择更合适的通信协议（如 REST 或 gRPC）。&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6964924838940587&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA1sLqkl0nicPpFFBzwPJGIhBVjS7UVDeyUxohJFdVrMK50jISI59tibmArclDTkcn9NktyZYwtibW1Ng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1397&quot;/&gt;&lt;/p&gt;&lt;p&gt;￼&lt;/p&gt;&lt;h2&gt;2. 对架构师的 8 个期待&lt;/h2&gt;&lt;h3&gt;2.1 做出架构决定&lt;/h3&gt;&lt;p&gt;架构师应确定架构和设计原则，用于指导团队、部门或整个企业的技术决策。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;架构师应该指导而不是指定技术选择&lt;/strong&gt;。例如，架构师应该决定开发团队使用基于响应式 (Reactive) 的框架进行开发，从而指导开发团队在 Angular、Elm、React.js、Vue 或其他任何基于响应式的 Web 框架之间做出选择。&lt;/p&gt;&lt;p&gt;架构师偶尔需要做出特定的技术决策，以保留特定的架构特性，如可扩展性、性能或可用性。&lt;/p&gt;&lt;p&gt;架构师经常为找到正确的界线而苦恼。&lt;/p&gt;&lt;h3&gt;2.2 持续分析架构&lt;/h3&gt;&lt;p&gt;多数架构都会经历结构性衰变，当开发人员进行编码或设计变更时，会影响到所需的架构特性，如性能、可用性和可扩展性。架构师需要评估三年或更长时间前定义的架构在今天的可行性。&lt;/p&gt;&lt;p&gt;另一方面，架构师还常常忘记测试和发布环境。敏捷性有很大的好处，如果团队需要几周的时间来测试变更，而发布又需要几个月的时间，那么架构师就无法实现整体架构的敏捷性。&lt;/p&gt;&lt;h3&gt;2.3 紧跟最新趋势&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;架构师要跟上最新的技术和行业趋势。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;开发人员必须掌握他们每天使用的最新技术，以保持代码能力(并保住一份工作！)。架构师有一个更关键的要求，就是要掌握最新的技术和行业趋势。架构师所做的决定往往是长期的，难以改变的，了解和跟踪关键趋势有助于架构师为未来做好准备，做出正确的决定。&lt;/p&gt;&lt;h3&gt;2.4 确保遵守各项决定&lt;/h3&gt;&lt;p&gt;架构师要不断验证开发团队是否遵循架构师定义、记录和传达的架构决策和设计原则。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;考虑这样的场景：架构师做出一个决定，在分层架构中限制对数据库的访问，只限于业务层和服务层（而不是表现层）。这意味着表现层必须经过架构的所有层才能进行最简单的数据库调用。用户界面开发人员可能不同意这个决定，出于性能考虑而直接访问数据库。然而，架构师做出这个架构决策是有特定原因的：控制变化。通过保持各层独立，可以在不影响表现层的情况下进行数据库变更。如果不确保架构决策的合规性，就会发生类似这样的违规行为，架构将无法满足所需的架构特性，应用程序或系统将无法按预期工作。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;2.5 多样化的接触和经验&lt;/h3&gt;&lt;p&gt;架构师要接触多种多样的技术、框架、平台和环境。&lt;/p&gt;&lt;p&gt;现在的大多数环境都是异构的，一个架构师至少应该知道如何与多个系统和服务对接，不管这些系统或服务是用什么语言、平台和技术编写的。&lt;/p&gt;&lt;p&gt;最好方法之一是让架构师延伸自己的舒适区，只关注单一技术或平台是一个安全的避风港，一个好的软件架构师应该积极寻找机会，以获得多种语言、平台和技术的经验，关注技术广度而不只是技术深度。&lt;/p&gt;&lt;h3&gt;2.6 具备业务领域知识&lt;/h3&gt;&lt;p&gt;一个架构师要有一定的业务领域专业知识。&lt;/p&gt;&lt;p&gt;有效的软件架构师不仅了解技术，还了解业务问题。&lt;strong&gt;如果没有业务领域的知识，就很难理解业务问题、目标和需求，很难设计出满足业务需求的有效架构。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;最成功的架构师是那些拥有广泛的、实践性的技术知识，再加上对某一特定领域的深刻了解的人。这些软件架构师能够使用这些利益相关者所能理解的领域知识和语言，与主管和业务用户进行有效的沟通。&lt;/p&gt;&lt;h3&gt;2.7 具备人际交往能力&lt;/h3&gt;&lt;p&gt;架构师应具备卓越的人际交往能力，包括团队合作、促进和领导能力。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;拥有卓越的领导力和人际交往能力是大多数开发人员和架构师难以企及的期望&lt;/strong&gt;。作为技术专家，开发人员和架构师喜欢解决技术问题，而不是人的问题。&lt;/p&gt;&lt;p&gt;架构师不仅要为团队提供技术指导，还要带领开发团队完成架构的实施。无论架构师的角色和头衔是什么，领导能力是成为一个软件架构师不可或缺的。&lt;/p&gt;&lt;h3&gt;2.8 理解和驾驭企业政治&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;架构师要了解企业的政治氛围，并能驾驭政治。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在一本关于软件架构的书中谈论谈判和驾驭办公室政治，可能看起来比较奇怪。主要的一点是，&lt;strong&gt;几乎架构师的每一个决策都会受到挑战&lt;/strong&gt;。由于涉及到成本或工作量（时间）的增加，架构决策会受到产品、项目经理、开发和业务利益相关者的挑战，因为他们觉得自己的方法更好。无论在哪种情况下，架构师都必须驾驭公司的政治，并应用基本的谈判技巧来获得批准。&lt;/p&gt;&lt;p&gt;架构师不像开发，可以自行设计代码结构、类、设计模式甚至是语言而不需要批准，架构师做出广泛而重要的决策，必须为几乎每一个决策进行论证和争取。&lt;/p&gt;&lt;h2&gt;3. 架构师和其它的交集&lt;/h2&gt;&lt;h3&gt;3.1 工程实践&lt;/h3&gt;&lt;p&gt;将软件开发过程与软件工程实践分开是有益的。所谓过程，我们指的是如何组建和管理团队，如何进行会议以及工作流组织，指的是人们如何组织和互动的机制。而&lt;strong&gt;软件工程实践则是指那些已经说明了的、可重复效益的与过程无关的实践。&lt;/strong&gt;例如，持续集成是一种经过验证的工程实践，它不依赖于特定的过程。&lt;/p&gt;&lt;p&gt;注重工程实践很重要：&lt;/p&gt;&lt;p&gt;unknown unknowns 是软件系统的克星：没有人知道会出现的东西，却又意外地出现了。例如：某个意外的 bug 出现。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;所有的架构都会因为 unknown unknowns 而变成迭代式的，敏捷只是认识到了这一点，并且更早去做了。（All architectures become iterative because of unknown unknowns, Agile just recognizes this and does it sooner.）&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;迭代流程更符合软件架构的本质，试图使用像瀑布这样的陈旧流程来构建微服务这样的现代系统的团队会发现，一个陈旧的流程忽视了软件如何结合在一起的现实，会产生大量的摩擦。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.54177897574124&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA1sLqkl0nicPpFFBzwPJGIhBKiaGewtzqYY6nq5aibPYnrfV4gPsK1xsTiahKjQlvRUXXK8SMCono5EUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;742&quot;/&gt;&lt;/p&gt;&lt;p&gt;￼&lt;/p&gt;&lt;p&gt;如图所示，&lt;strong&gt;软件系统的架构由需求和所有其他架构特征组成&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;采用敏捷工程实践，如持续集成、自动机器供应和类似的实践，使构建弹性架构变得更容易。这也说明了架构与工程实践是如何相互交织在一起的。&lt;/p&gt;&lt;h3&gt;3.2 运维/DevOps&lt;/h3&gt;&lt;p&gt;架构和相关领域之间最近最明显的交集发生在 DevOps 的出现。许多公司认为运维是与软件开发是分离的，在 20 世纪 90 年代和 2000 年代设计的架构都假设架构师无法控制运维，架构师们被迫围绕引入的限制进行防御性设计。因此，他们构建了能够在内部处理规模、性能、弹性和其他一系列能力的架构。这种设计的副作用是大大增加了架构的复杂性。&lt;/p&gt;&lt;p&gt;微服务风格架构的构建者们意识到，通过在架构和运维之间建立一个联络点，架构师可以简化设计，依靠运维来处理他们最擅长的事情。因此，意识到资源的挪用导致了意外的复杂性，架构师和运维合作创建了微服务。&lt;/p&gt;&lt;h3&gt;3.3 流程&lt;/h3&gt;&lt;p&gt;软件架构与软件开发过程大多是正交的（相互不可替代的），大多数关于软件架构的书籍都忽略了软件开发过程。例如，在过去的几十年里，由于软件的性质，许多公司都采用了敏捷开发方法。架构师在敏捷项目中得到更快的反馈，这使得架构师可以更积极地进行实验。&lt;/p&gt;&lt;p&gt;所有的架构都会变成迭代式的，这只是时间问题。为此，我们要在整个过程中假设敏捷方法论的基线，并允许适当的例外。例如，许多单体架构因为年龄、政治或其他与软件无关的因素而使用旧流程的情况还是很常见的。&lt;/p&gt;&lt;h3&gt;3.4 数据&lt;/h3&gt;&lt;p&gt;很大一部分严肃的应用程序开发包括外部数据存储，通常采用关系型(或越来越多的 NoSQL)数据库的形式。然而，许多关于软件架构的书籍只对架构的这一重要方面进行了轻描淡写的处理。代码和数据具有共生关系：两者缺一不可。&lt;/p&gt;&lt;h2&gt;4. 软件架构法则&lt;/h2&gt;&lt;p&gt;软件架构第一定律：&lt;br/&gt;&lt;strong&gt;软件架构中的所有东西都是一种权衡。(Everything in software architecture is a trade-off.)&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们对软件架构的定义超越了结构的范畴，包含了原则、特性等，架构的范围比单纯的结构更广，体现在我们的软件架构第二定律中：&lt;br/&gt;&lt;strong&gt;为什么比怎么做更重要。（Why is more important than how.）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;欢迎关注我的公众号：&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hBL5R2neMA2qgPwzomIicebbmoOGzU1IsUWQMb3xr4nLcjtfIy5Zwyia3HTKnIJ8xc9NFkkPBkL8MEAfh3YdNuaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4940695b13f99cf10643596bf0233a61</guid>
<title>[推荐] vivo 全球商城：订单中心架构设计与实践</title>
<link>https://toutiao.io/k/lcopypw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、背景&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;随着用户量级的快速增长，vivo 官方商城 v1.0 的单体架构逐渐暴露出弊端：模块愈发臃肿、开发效率低下、性能出现瓶颈、系统维护困难。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从2017年开始启动的 v2.0 架构升级，基于业务模块进行垂直的系统物理拆分，拆分出来业务线各司其职，提供服务化的能力，共同支撑主站业务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;订单模块是电商系统的交易核心，不断累积的数据即将达到单表存储瓶颈，系统难以支撑新品发布和大促活动期间的流量，服务化改造势在必行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本文将介绍 vivo 商城 订单系统建设的过程中遇到的问题和解决方案，分享架构设计经验。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、系统架构&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;将订单模块从商城拆分出来，独立为订单系统，使用独立的数据库，为商城相关系统提供订单、支付、物流、售后等标准化服务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;系统架构如下图所示：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.575859178541492&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1CoZgD6Vxapl8dWE0UsaiasktBUZQIGQ74Tn0CVDMcQzUmapKwu8etyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1193&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、技术挑战&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.1 数据量和高并发问题&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;首先面对的挑战来自存储系统：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;下面对这些方案进行简单描述：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7768762677484787&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY11hmthbJbQDOmHu0BzE1X9Q9948xRic2R5KaiccHZgRWiaFOQfO4JjusZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;493&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;读写分离&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;主库负责执行数据更新请求，然后将数据变更实时同步到所有从库，用多个从库来分担查询请求。&lt;/p&gt;&lt;p&gt;但订单数据的更新操作较多，下单高峰时主库的压力依然没有得到解决。且存在主从同步延迟，正常情况下延迟非常小，不超过1ms，但也会导致在某一个时刻的主从数据不一致。&lt;/p&gt;&lt;p&gt;那就需要对所有受影响的业务场景进行兼容处理，可能会做一些妥协，比如下单成功后先跳转到一个下单成功页，用户手动点击查看订单后才能看到这笔订单。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7393939393939394&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1iaw0EsH2ia5jEicvsLaVOmlT2d23tEgjwcfcoh8HyFmyZmI3LGO2qichpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;495&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们综合考虑了改造成本、效果和对现有业务的影响，决定直接使用最后一招：&lt;strong&gt;分库分表&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.2 分库分表技术选型&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;分库分表的技术选型主要从这几个方向考虑：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;客户端sdk开源方案&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;中间件proxy开源方案&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;公司中间件团队提供的自研框架&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;自己动手造轮子&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;参考之前项目经验，并与公司中间件团队沟通后，采用了开源的 &lt;strong&gt;Sharding-JDBC &lt;/strong&gt;方案。现已更名为Sharding-Sphere。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1ibXRKtMYdic4UPwDVhEhRO4Amrhj2W8yTOfjtU19yDoaGJ3ia0xNhMuLA/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1005.0000000000001&quot; data-cropy1=&quot;17.387543252595158&quot; data-cropy2=&quot;815.4757785467128&quot; data-ratio=&quot;0.7940298507462686&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1pjFwEtN04LTevEYlTRYZDfqzKOXuicictqFX3MUalXwibjdhKCl53QTJg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1005&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.2.1 分库分表策略&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;结合业务特性，选取用户标识作为分片键，通过计算用户标识的哈希值再取模来得到用户订单数据的库表编号.&lt;/p&gt;&lt;p&gt;&lt;br/&gt;假设共有n个库，每个库有m张表，&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;则库表编号的计算方式为：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;- 库序号：Hash(userId) / m % n&lt;/p&gt;&lt;p&gt;- 表序号：Hash(userId) % m&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;路由过程如下图所示：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.071301247771836&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1ibUKPzPpqblQUYwqx73ibRUOBGaSu3QRu1fYjAgS21ic2kH0L2dkyufHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;561&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3.2.2 分库分表的局限性和应对方案&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;分库分表解决了数据量和并发问题，但它会极大限制数据库的查询能力，有一些之前很简单的关联查询，在分库分表之后可能就没法实现了，那就需要单独对这些Sharding-JDBC不支持的SQL进行改写。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;除此之外，还遇到了这些挑战：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;（1）全局唯一ID设计&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;分库分表后，数据库自增主键不再全局唯一，不能作为订单号来使用，但很多内部系统间的交互接口只有订单号，没有用户标识这个分片键，如何用订单号来找到对应的库表呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;原来，我们在生成订单号时，就将库表编号隐含在其中了。这样就能在没有用户标识的场景下，从订单号中获取库表编号。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（2）历史订单号没有隐含库表信息&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;用一张表单独存储历史订单号和用户标识的映射关系，随着时间推移，这些订单逐渐不在系统间交互，就慢慢不再被用到。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（3）管理后台需要根据各种筛选条件，分页查询所有满足条件的订单&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;将订单数据冗余存储在搜索引擎Elasticsearch中，仅用于后台查询。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.3 怎么做 MySQL 到 ES 的数据同步&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;上面说到为了便于管理后台的查询，我们将订单数据冗余存储在Elasticsearch中，那么，如何在MySQL的订单数据变更后，同步到ES中呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里要考虑的是数据同步的时效性和一致性、对业务代码侵入小、不影响服务本身的性能等。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4986225895316804&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1ayCo401tFN99S4rIEA3stmYWktpx3xOlcVtH78pcI7Hf4N6uCuzQ1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;726&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5787172011661808&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY15ia7kMfZUQicmycyESeP5XwQF1wf27oygRsvxLcnxT3mxRKl2l3yHuFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;686&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;其中BinLog方案比较通用，但实现起来也较为复杂，我们最终选用的是MQ方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因为ES数据只在管理后台使用，对数据可靠性和同步实时性的要求不是特别高。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;考虑到宕机和消息丢失等极端情况，在后台增加了按某些条件手动同步ES数据的功能来进行补偿。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.4 如何安全地更换数据库&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如何将数据从原来的单实例数据库迁移到新的数据库集群，也是一大技术挑战&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不但要确保数据的正确性，还要保证每执行一个步骤后，一旦出现问题，能快速地回滚到上一个步骤。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们考虑了停机迁移和不停机迁移的两种方案：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;（1）不停机迁移方案：&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;把旧库的数据复制到新库中，上线一个同步程序，使用 Binlog等方案实时同步旧库数据到新库。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;上线双写订单新旧库服务，只读写旧库。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;开启双写，同时停止同步程序，开启对比补偿程序，确保新库数据和旧库一致。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;逐步将读请求切到新库上。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;读写都切换到新库上，对比补偿程序确保旧库数据和新库一致。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;下线旧库，下线订单双写功能，下线同步程序和对比补偿程序。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.4760956175298805&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1dvic2nJV7K2CQBdBMtPmBavbibuwWdqbIptPwu8k310ytTTicAW7dk8Jw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;502&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;（2）停机迁移方案：&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;上线新订单系统，执行迁移程序将两个月之前的订单同步到新库，并对数据进行稽核。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;将商城V1应用停机，确保旧库数据不再变化。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;执行迁移程序，将第一步未迁移的订单同步到新库并进行稽核。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;上线商城V2应用，开始测试验证，如果失败则回退到商城V1应用（新订单系统有双写旧库的开关）。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8896848137535817&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1x9EEsvjZSe69Cs8FR3wYZUWWcjaRSNrzwC8nX8m9kQqvpmrSUT7Qeg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;698&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;考虑到不停机方案的改造成本较高，而夜间停机方案的业务损失并不大，最终选用的是停机迁移方案。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.5 分布式事务问题&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;电商的交易流程中，分布式事务是一个经典问题，比如：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;/&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们是如何保证微服务架构下数据的一致性呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不同业务场景对数据一致性的要求不同，业界的主流方案中，用于解决强一致性的有两阶段提交(2PC)、三阶段提交(3PC)，解决最终一致性的有TCC、本地消息、事务消息和最大努力通知等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里不对上述方案进行详细的描述，介绍一下我们正在使用的本地消息表方案：在本地事务中将要执行的异步操作记录在消息表中，如果执行失败，可以通过定时任务来补偿。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下图以订单完成后通知积分系统赠送积分为例。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4189497716894977&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1NVX7wcb37XQC6gGxIqcFUJPYqwKanADGbMHNMNjiaSND449xYHm0z3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;876&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.6 系统安全和稳定性&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;网络隔离&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;只有极少数第三方接口可通过外网访问，且都会验证签名，内部系统交互使用内网域名和RPC接口。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;并发锁&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;任何订单更新操作之前，会通过数据库行级锁加以限制，防止出现并发更新。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;幂等性&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;所有接口均具备幂等性，不用担心对方网络超时重试所造成的影响。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;熔断&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;使用Hystrix组件，对外部系统的实时调用添加熔断保护，防止某个系统故障的影响扩大到整个分布式系统中。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;监控和告警&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通过配置日志平台的错误日志报警、调用链的服务分析告警，再加上公司各中间件和基础组件的监控告警功能，让我们能够能够第一时间发现系统异常。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.7  踩过的坑&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;采用MQ消费的方式同步数据库的订单相关数据到ES中，遇到的写入数据不是订单最新数据问题&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下图左边是原方案：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在消费订单数据同步的MQ时，如果线程A在先执行，查出数据，这时候订单数据被更新了，线程B开始执行同步操作，查出订单数据后先于线程A一步写入ES中，线程A执行写入时就会将线程B写入的数据覆盖，导致ES中的订单数据不是最新的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;解决方案是在查询订单数据时加行锁，整个业务执行在事务中，执行完成后再执行下一个线程。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6141450313339302&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt7orIXpEkiaO1lkDqhgnCyY1nQawSEsRicwcPwTgWZfBMDJp6KRCwQWxibJJO1pBFJKsrmmibVzWxsDHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1117&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;sharding-jdbc 分组后排序分页查询出所有数据问题&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;示例：select a  from  temp group by a，b order by a  desc limit 1,10。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;执行是Sharding-jdbc里group by 和 order by 字段和顺序不一致是将10置为Integer.MAX_VALUE, 导致分页查询失效。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;io.shardingsphere.core.routing.router.sharding.ParsingSQLRouter&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; void processLimit(&lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;List&lt;/span&gt;&amp;lt;Object&amp;gt; parameters, &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; SelectStatement selectStatement, &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; boolean isSingleRouting) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     boolean isNeedFetchAll = (!selectStatement.getGroupByItems().isEmpty() || !selectStatement.getAggregationSelectItems().isEmpty()) &amp;amp;&amp;amp; !selectStatement.isSameGroupByAndOrderByItems();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    selectStatement.getLimit().processParameters(parameters, isNeedFetchAll, databaseType, isSingleRouting);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;io.shardingsphere.core.parsing.parser.context.limit.Limit&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;* &lt;span class=&quot;code-snippet__doctag&quot;&gt;@param&lt;/span&gt; isFetchAll is fetch all data or not&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;* &lt;span class=&quot;code-snippet__doctag&quot;&gt;@param&lt;/span&gt; databaseType database type&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;* &lt;span class=&quot;code-snippet__doctag&quot;&gt;@param&lt;/span&gt; isSingleRouting is single routing or not&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__comment&quot;&gt;*/&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; void processParameters(&lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;List&lt;/span&gt;&amp;lt;Object&amp;gt; parameters, &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; boolean isFetchAll, &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; DatabaseType databaseType, &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; boolean isSingleRouting) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    fill(parameters);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    rewrite(parameters, isFetchAll, databaseType, isSingleRouting);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; void rewrite(&lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;List&lt;/span&gt;&amp;lt;Object&amp;gt; parameters, &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; boolean isFetchAll, &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; DatabaseType databaseType, &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; boolean isSingleRouting) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    int rewriteOffset = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    int rewriteRowCount;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (isFetchAll) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        rewriteRowCount = Integer.MAX_VALUE;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (isNeedRewriteRowCount(databaseType) &amp;amp;&amp;amp; !isSingleRouting) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         rewriteRowCount = &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt; == rowCount ? &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt; : getOffsetValue() + rowCount.getValue();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       rewriteRowCount = rowCount.getValue();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt; != offset &amp;amp;&amp;amp; offset.getIndex() &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt; &amp;amp;&amp;amp; !isSingleRouting) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       parameters.set(offset.getIndex(), rewriteOffset);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt; != rowCount &amp;amp;&amp;amp; rowCount.getIndex() &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        parameters.set(rowCount.getIndex(), rewriteRowCount);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;正确的写法应该是  select a  from  temp group by a desc ，b limit 1,10 ；  使用的版本是sharing-jdbc的3.1.1。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ES分页查询如果排序字段存在重复的值，最好加一个唯一的字段作为第二排序条件，避免分页查询时漏掉数据、查出重复数据，比如用的是订单创建时间作为唯一排序条件，同一时间如果存在很多数据，就会导致查询的订单存在遗漏或重复，需要增加一个唯一值作为第二排序条件或者直接使用唯一值作为排序条件。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、成果&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;一次性上线成功，稳定运行了一年多&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;核心服务性能提升十倍以上&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;系统解耦，迭代效率大幅提升&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;能够支撑商城至少五年的高速发展&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;五、结语&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们在系统设计时并没有一味追求前沿技术和思想，面对问题时也不是直接采用主流电商的解决方案，而是根据业务实际状况来选取最合适的办法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;个人觉得，一个好的系统不是在一开始就被大牛设计出来的，一定是随着业务的发展和演进逐渐被迭代出来的，持续预判业务发展方向，提前制定架构演进方案，简单来说就是：走到业务的前面去！&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8103bbbc84d9433b76154fd9401b8915</guid>
<title>[推荐] 微服务架构 10 个最重要的设计模式</title>
<link>https://toutiao.io/k/krsjiu0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;自从软件开发的早期(1960年代)以来，解决大型软件系统中的复杂性一直是一项艰巨的任务。多年来，软件工程师和架构师为解决软件系统的复杂性进行了许多尝试：David Parnas的模块化和信息隐藏(1972)，Edsger W. Dijkstra的关注分离(1974)，面向服务的体系结构(1998)。&lt;/p&gt;&lt;p&gt;&lt;img border=&quot;0&quot; data-ratio=&quot;0.663594470046083&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/XCETLoXzTr9w4qNRPLGNX0N8q32dgibwJBy5vUxDpTNbiaEUHk59HEe0XHUO0jl4PelXsoAjX0bltNpdp2N9ThEg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;651&quot; title=&quot;&quot;/&gt;&lt;/p&gt;&lt;p&gt;他们所有人都使用了久经考验的成熟技术来解决大型系统的复杂性：分而治之。自2010年代以来，这些技术不足以解决Web规模应用程序或现代大型企业应用程序的复杂性。结果，架构师和工程师开发了一种新方法来解决现代软件系统的复杂性：微服务架构。它也使用了相同的旧&quot;分而治之&quot;技术，尽管采用了新颖的方式。&lt;/p&gt;&lt;p&gt;软件设计模式是解决软件设计中常见问题的通用，可重用的解决方案。设计模式可帮助我们共享通用词汇，并使用经过实战检验的解决方案，而不是重新发明轮子。今天描述的是一组设计模式，以帮助您实现这些最佳实践。&lt;/p&gt;&lt;p&gt;本文&lt;strong&gt;主要内容：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;微服务架构&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;微服务架构的优势&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;微服务架构的缺点&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;何时使用微服务架构&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;微服务架构设计模式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;请注意，此清单的大多数设计模式都有几种上下文，可以在非微服务体系结构中使用。但是我将在微服务架构的背景下对其进行描述。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;微服务架构&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;微服务体系结构：&lt;/strong&gt;简要概述以及为什么要在下一个项目中使用它以及模块化单片软件体系结构真的死了吗?&lt;/p&gt;&lt;p&gt;我的&lt;strong&gt;微服务架构定义&lt;/strong&gt;是：&lt;/p&gt;&lt;p&gt;微服务架构旨在将大型，复杂的系统垂直(按功能或业务要求)划分为较小的子系统，这些子系统属于流程(因此可独立部署)，并且这些子系统之间通过与语言无关的轻量级网络通信相互通信(例如REST，gRPC)或异步(通过消息传递)方式。&lt;/p&gt;&lt;p&gt;这是具有微服务架构的业务Web应用程序的组件视图：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6383333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/XCETLoXzTr9w4qNRPLGNX0N8q32dgibwJCdibw578Lh5QZclGw8iaZuplLicnjUJPW8zjlRTLdXx45ld2nhJFNNlRg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&amp;gt; Microservice Architecture by Md Kamaruzzaman&lt;/p&gt;&lt;p&gt;微服务架构的&lt;strong&gt;重要特征&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;整个应用程序分为多个单独的进程，每个进程可以包含多个内部模块。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;与模块化Monoliths或SOA相反，微服务应用程序是垂直拆分的(根据业务能力或领域)微服务边界是外部的。结果，微服务通过网络调用(RPC或消息)相互通信。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;由于微服务是独立的流程，因此它们可以独立部署。他们以轻巧的方式交流，不需要任何智能交流渠道。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;微服务架构的&lt;strong&gt;优势&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;更好的开发规模。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;更高的发展速度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;支持迭代或增量现代化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;充分利用现代软件开发生态系统(云，容器，DevOps，无服务器)的优势。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;支持水平缩放和粒度缩放。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;由于尺寸较小，它降低了开发人员的认知复杂度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;微服务架构的&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;大量的活动部件(服务，数据库，流程，容器，框架)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;复杂性从代码转移到基础架构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;RPC调用和网络流量的激增。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;管理整个系统的安全性具有挑战性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;设计整个系统比较困难。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;介绍分布式系统的复杂性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;何时使用&lt;/strong&gt;微服务架构：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;·&lt;/strong&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;Web规模应用程序开发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;当多个团队处理应用程序时，进行企业应用程序开发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;长期收益优先于短期收益。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;该团队拥有能够设计微服务架构的软件架构师或高级工程师。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;微服务架构的设计模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;每个微服务独占数据库&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;一旦公司用许多较小的微服务替换了大型的单片系统，它面临的最重要的决定就是关于数据库。在整体架构中，使用大型中央数据库。许多架构师都喜欢保留数据库原样，即使他们转向微服务架构也是如此。尽管它提供了一些短期好处，但它是一种反模式，尤其是在大规模系统中，因为微服务将紧密耦合在数据库层中。转向微服务的整个目标将失败(例如，团队授权，独立开发)。&lt;/p&gt;&lt;p&gt;更好的方法是为每个微服务都提供自己的数据存储，以使数据库层中的服务之间不存在强耦合。在这里，我使用数据库一词来表示数据的逻辑分离，即微服务可以共享同一物理数据库，但是它们应该使用单独的架构/集合/表。它还将确保根据域驱动设计正确隔离微服务。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.62&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/XCETLoXzTr9w4qNRPLGNX0N8q32dgibwJUehtJMibXpDvScaR8vheWsZP6z6O9jfOFGfjEcmCtPHDea00iaSMIZibA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&amp;gt; Database per Microservice by Md Kamaruzzaman&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;数据对服务的完全所有权。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;开发服务的团队之间的松耦合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;在服务之间共享数据变得充满挑战。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;提供应用程序范围的ACID事务保证变得更加困难。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;将Monolith数据库分解为较小的零件需要仔细设计，这是一项艰巨的任务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每个微服务&lt;strong&gt;何时使用数据库：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;在大型企业中的应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;当团队需要其微服务的完全所有权以进行开发扩展和提高开发速度时。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;什么时候不使用&lt;/strong&gt;每个微服务的数据库：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;在小型应用中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;如果一个团队开发所有微服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;启用&lt;strong&gt;技术示例&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所有SQL和NoSQL数据库都提供逻辑上的数据分离(例如，分离的表，集合，模式，数据库)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;事件源 Event Sourcing&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在微服务架构中，尤其是在每个微服务使用数据库的情况下，微服务需要交换数据。对于有弹性，高度可扩展和容错的系统，它们应通过交换事件进行异步通信。&lt;/p&gt;&lt;p&gt;在这种情况下，可能需要进行原子操作，例如，更新数据库并发送消息。如果您有SQL数据库，并且希望为大量数据分配分布式事务，则不能使用两阶段锁定(2PL)，因为它无法扩展。&lt;/p&gt;&lt;p&gt;如果使用NoSQL数据库并希望具有分布式事务，则不能使用2PL，因为许多NoSQL数据库不支持两阶段锁定。&lt;/p&gt;&lt;p&gt;在这种情况下，请结合使用基于事件的体系结构和事件源。在传统数据库中，具有当前&quot;状态&quot;的业务实体被直接存储。在事件源中，将存储任何状态更改事件或其他重要事件，而不是实体。&lt;/p&gt;&lt;p&gt;这意味着业务实体的修改将保存为一系列不可变的事件。通过在给定时间重新处理该业务实体的所有事件，可以扣除该业务实体的状态。因为数据存储为一系列事件，而不是通过直接更新数据存储来存储，所以各种服务可以从事件存储中重播事件以计算其各自数据存储的适当状态。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.25666666666666665&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/XCETLoXzTr9w4qNRPLGNX0N8q32dgibwJw9wtq6GFMy46ONjQpZ0cctjyQPsG0N180Ehd0XVvxnpGhFctgA9lvg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&amp;gt; Event Sourcing by Md Kamaruzzaman&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;·&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;为高度可扩展的系统提供原子性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;实体的自动历史记录，包括时间旅行功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;松散耦合和事件驱动的微服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;从事件存储中读取实体变得具有挑战性，通常需要额外的数据存储(CQRS模式)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;系统的整体复杂性增加，通常需要域驱动设计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;系统需要处理重复事件(幂等)或丢失事件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;迁移事件模式变得具有挑战性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;何时使用&lt;/strong&gt;事件来源：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;具有SQL数据库的高度可扩展的事务系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;带有NoSQL数据库的事务系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;高度可扩展且具有弹性的微服务架构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;典型的消息驱动或事件驱动系统(电子商务，预订和预订系统)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;何时不使用&lt;/strong&gt;事件来源：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;具有SQL数据库的低伸缩性事务系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;在简单的微服务架构中，微服务可以同步交换数据(例如，通过API)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;启用&lt;strong&gt;技术示例&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;&lt;strong&gt;事件存储：&lt;/strong&gt;EventStoreDB，Apache Kafka，Confluent Cloud，AWS Kinesis，Azure事件中心，GCP发布/订阅，Azure Cosmos DB，MongoDB，Cassandra。Amazon DynamoDB，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;&lt;strong&gt;框架：&lt;/strong&gt;Lagom，Akka，Spring，akkatecture，Axon，Eventuate&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;命令查询职责隔离(CQRS)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;如果我们使用事件源，那么从事件存储中读取数据将变得充满挑战。要从数据存储中获取实体，我们需要处理所有实体事件。另外，有时我们对读写操作有不同的一致性和吞吐量要求。&lt;/p&gt;&lt;p&gt;在这种用例中，我们可以使用CQRS模式。在CQRS模式中，系统的数据修改部分(命令)与数据读取(查询)部分分开。CQRS模式有两种形式：简单和高级，这导致软件工程师之间产生一些混淆。&lt;/p&gt;&lt;p&gt;以简单的形式，不同的实体或ORM模型用于读取和写入，如下所示：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.498533724340176&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/XCETLoXzTr9w4qNRPLGNX0N8q32dgibwJ8bnJcFucxtpJiakbwFwIhmtbyXWBiaWwqRv1KOw7eKal3GZ78IbWbaTQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;341&quot;/&gt;&lt;/p&gt;&lt;p&gt;&amp;gt; CQRS (simple) by Md Kamaruzzaman&lt;/p&gt;&lt;p&gt;它有助于实施&quot;单一责任原则&quot;和&quot;关注点分离&quot;，从而使设计更简洁。&lt;/p&gt;&lt;p&gt;在其高级形式中，不同的数据存储区用于读取和写入操作。高级CQRS与事件来源一起使用。根据使用情况，使用不同类型的写入数据存储和读取数据存储。写入数据存储区是&quot;记录系统&quot;，即整个系统的黄金来源。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.160919540229885&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/XCETLoXzTr9w4qNRPLGNX0N8q32dgibwJicfYMaWvyt7kcdLQjEw58gotOwHQdZ2CoWwtmdc3Zl2iaXeR0PyRa04w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;435&quot;/&gt;&lt;/p&gt;&lt;p&gt;&amp;gt; CQRS (advanced) by Md Kamaruzzaman&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于重读应用程序或微服务体系结构，将OLTP数据库(任何提供ACID事务保证的SQL或NoSQL数据库)或分布式消息平台用作写存储。对于繁重的写程序(高写可伸缩性和吞吐量)，使用了水平可写伸缩的数据库(公共云全局数据库)。规范化的数据保存在写入数据存储中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为搜索(例如Apache Solr，Elasticsearch)或读取(键值数据存储，文档数据存储)而优化的NoSQL数据库用作读取存储。在许多情况下，在需要SQL查询的地方使用可伸缩的SQL数据库。归一化和优化的数据将保存在读取存储中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据从写入存储异步复制到读取存储。结果，读存储区滞后于写存储区，并且最终保持一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;在事件驱动的微服务中更快地读取数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;数据的高可用性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;读写系统可以独立扩展。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;读取数据存储弱一致性(最终一致性)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;系统的整体复杂性增加。货运培训CQRS可能会严重危害整个项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;何时使用&lt;/strong&gt;CQRS：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;在使用事件源的高度可扩展的微服务体系结构中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;在读取数据需要查询到多个数据存储区的复杂域模型中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;在读写操作具有不同负载的系统中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;何时不使用&lt;/strong&gt;CQRS：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;在微事件数量微不足道的微服务体系结构中，使用事件存储快照来计算实体状态是更好的选择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;在读写操作具有相似负载的系统中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;启用&lt;strong&gt;技术示例&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;·&lt;/strong&gt;&lt;strong&gt; 写存储：&lt;/strong&gt;EventStoreDB，Apache Kafka，Confluent Cloud，AWS Kinesis，Azure Event Hub，GCP发布/订阅，Azure Cosmos DB，MongoDB，Cassandra。亚马逊DynamoDB&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;&lt;strong&gt;阅读商店：&lt;/strong&gt;Elastic Search，Solr，Cloud Spanner，Amazon Aurora，Azure Cosmos DB，Neo4j&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;&lt;strong&gt;框架：&lt;/strong&gt;Lagom，Akka，Spring，akkatecture，Axon，Eventuate&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;SAGA&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;如果您将微服务体系结构与每个微服务的数据库一起使用，那么通过分布式事务管理一致性就具有挑战性。您不能使用传统的两阶段提交协议，因为它无法扩展(SQL数据库)或不被支持(许多NoSQL数据库)。&lt;/p&gt;&lt;p&gt;您可以将Saga模式用于Microservice Architecture中的分布式事务。Saga是一种旧模式，于1987年开发，作为SQL数据库中长期运行的数据库事务的概念替代方案。但是，这种模式的现代变体对于分布式事务也非常有效。Saga模式是一个本地事务序列，其中每个事务在单个微服务中更新数据存储中的数据并发布事件或消息。传奇中的第一个事务由外部请求(事件或操作)启动。一旦本地事务完成(数据存储在数据存储中，并且发布消息或事件)，发布的消息/事件将触发Saga中的下一个本地事务。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.44&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/XCETLoXzTr9w4qNRPLGNX0N8q32dgibwJq9dBmhuz2F4LicaLeIF425icCemeRvWibAgmefwrsTpXmWQNNN3BSWVHg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&amp;gt; Saga by Md Kamaruzzaman&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果本地事务失败，则Saga执行一系列补偿事务，以撤消先前本地事务的更改。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Saga交易协调主要有&lt;strong&gt;两种变体：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;&lt;strong&gt;分散的协调&lt;/strong&gt;，每个微服务生成并收听其他微服务的事件/消息，并决定是否应该采取措施。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;&lt;strong&gt;统筹协调&lt;/strong&gt;，协调器告诉协调的微服务哪些本地事务需要执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;通过高度可扩展的或松散耦合的，事件驱动的微服务架构中的事务来提供一致性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;通过使用没有2PC支持的NoSQL数据库的微服务体系结构中的事务来提供一致性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;需要处理短暂故障，并应提供幂等性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;难以调试，并且随着微服务数量的增加，复杂性也随之增加。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;何时使用&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;在使用事件源的高度可扩展的，松散耦合的微服务架构中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;在使用分布式NoSQL数据库的系统中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;什么时候不使用&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;具有SQL数据库的低伸缩性事务系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;在服务之间存在循环依赖性的系统中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;启用&lt;strong&gt;技术示例：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Axon，Eventuate，Narayana&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;前端的后端(BFF)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在现代业务应用程序开发中，尤其是在微服务体系结构中，前端和后端应用程序是分离的和独立的服务。它们通过API或GraphQL连接。如果应用程序还具有Mobile App客户端，则对Web和Mobile客户端使用相同的后端微服务将成为问题。移动客户端的API要求通常与Web客户端不同，因为它们具有不同的屏幕大小，显示，性能，能源和网络带宽。&lt;/p&gt;&lt;p&gt;后端的后端模式可用于每个UI都有为特定UI定制的单独后端的场景。它还提供了其他优势，例如充当下游微服务的外观，从而减少了UI与下游微服务之间的闲聊通信。同样，在高度安全的情况下，下游微服务部署在DMZ网络中，BFF用于提供更高的安全性。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.065&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/XCETLoXzTr9w4qNRPLGNX0N8q32dgibwJCz1jTaJ5Lej2RDoZzf8hML8FlmKGhUQOAQ6J6oa6oSXGV4Rb5safLw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&amp;gt; Backends for Frontends by Md Kamaruzzaman&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;BFF之间的关注点分离。我们可以针对特定的UI优化它们。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;提供更高的安全性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;减少UI与下游微服务之间的交流。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;BFF之间的代码重复。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;如果使用其他许多UI(例如，智能电视，Web，移动设备，台式机)，BFF的数量也会激增。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;BFF不应包含任何业务逻辑，而应仅包含特定于客户的逻辑和行为，因此需要仔细设计和实施。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;何时将后端用于前端：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;如果应用程序具有多个具有不同API要求的UI。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;如果出于安全原因在UI和下游微服务之间需要额外的一层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;如果在UI开发中使用微前端。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;何时不使用&lt;/strong&gt;后端作为前端：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;如果应用程序具有多个UI，但是它们使用相同的API。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;如果未在DMZ中部署核心微服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;启用&lt;strong&gt;技术示例：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong/&gt;任何后端框架(Node.js，Spring，Django，Laravel，Flask，Play等)都支持它。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;API网关&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在微服务架构中，UI通常与多个微服务连接。如果微服务是细粒度的(FaaS)，则客户端可能需要连接许多微服务，这变得很繁琐且具有挑战性。而且，服务(包括其API)可以发展。大型企业还希望拥有其他跨领域的问题(SSL终止，身份验证，授权，限制，日志记录等)。&lt;/p&gt;&lt;p&gt;解决这些问题的一种可能方法是使用API网关。API网关位于客户端APP和后端微服务之间，并充当外观。它可以用作反向代理，将客户端请求路由到适当的后端微服务。它还可以支持将客户端请求的扇出扩展到多个微服务，然后将汇总的响应返回给客户端。它还支持基本的跨领域关注。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.99&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/XCETLoXzTr9w4qNRPLGNX0N8q32dgibwJVAv3nn7Flzianzia0X2yOYMOll5yUibyjQ8usDK3tQQzsL0moiaQbFicTUQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&amp;gt; API Gateway by Md Kamaruzzaman&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;提供前端和后端微服务之间的松散耦合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;减少客户端和微服务之间的往返呼叫次数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;通过SSL终止，身份验证和授权实现高安全性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;集中管理的跨领域问题，例如日志记录和监视，节流，负载平衡。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;可能导致微服务架构中的单点故障。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;由于额外的网络呼叫，延迟增加了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;如果不进行扩展，它们很容易成为整个企业的瓶颈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;额外的维护和开发成本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;何时使用API网关：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;在复杂的微服务架构中，这几乎是强制性的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;在大型公司中，必须使用API网关来集中安全性和跨领域问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;何时不使用API网关：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;在安全性和中央管理不是最高优先级的私人项目或小型公司中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;如果微服务的数量很小。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;启用&lt;strong&gt;技术示例：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Amazon API Gateway，Azure API管理，Apigee，Kong，WSO2 API管理器&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;扼杀者&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;如果要在棕地项目中使用微服务架构，则需要将旧版或现有的Monolithic应用程序迁移到微服务。将现有的大型生产单片式应用程序迁移到微服务中具有很大的挑战性，因为这可能会破坏应用程序的可用性。&lt;/p&gt;&lt;p&gt;一种解决方案是使用Strangler模式。Strangler模式意味着通过逐步用新的微服务替换特定功能，将Monolithic应用程序逐步迁移到微服务架构。此外，新功能仅在微服务中添加，绕过了传统的Monolithic应用程序。然后将Facade(API网关)配置为在旧版Monolith和微服务之间路由请求。一旦功能从Monolith迁移到微服务，Facade就会拦截客户端请求并路由到新的微服务。一旦所有旧版Monolithic功能都已迁移，旧版Monolithic应用程序将被&quot;勒死&quot;，即退役。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6366666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/XCETLoXzTr9w4qNRPLGNX0N8q32dgibwJwQXezMYGNicxoQ8vfRamHqibUy9SkKvBxCr6M5qLeOkJCdoxDCkaQN3Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&amp;gt; Strangler by Md Kamaruzzaman&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;将Monolithic应用程序安全迁移到微服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;迁移和新功能开发可以并行进行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;迁移过程可以有自己的进度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;在现有的Monolith和新的微服务之间共享数据存储变得充满挑战。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;添加外观(API网关)将增加系统延迟。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;端到端测试变得困难。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;何时使用&lt;/strong&gt;Strangler：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;将大型后端单片应用程序增量迁移到微服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;何时不使用&lt;/strong&gt;Strangler：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;如果后端整体组件较小，则批量替换是一个更好的选择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;如果客户端对旧版Monolithic应用程序的请求无法被拦截。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;推动技术：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;带有API网关的后端应用程序框架。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;断路器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在微服务体系结构中，微服务进行同步通信，微服务通常调用其他服务来满足业务需求。由于瞬态故障(网络连接速度慢，超时或时间不可用)，对另一个服务的调用可能会失败。在这种情况下，重试呼叫可以解决此问题。但是，如果存在严重问题(微服务完全失败)，则微服务将长时间不可用。在这种情况下，重试是没有意义的，并且浪费了宝贵的资源(线程被阻塞，浪费了CPU周期)。同样，一项服务的故障可能会导致整个应用程序级联故障。在这种情况下，立即失败是一种更好的方法。&lt;/p&gt;&lt;p&gt;对于此类用例，可以使用断路器模式。微服务应通过代理来请求另一个微服务，该代理的工作方式类似于断路器。代理应该计算最近发生的故障数，并使用它来决定是允许操作继续进行还是直接返回异常。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.565&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/XCETLoXzTr9w4qNRPLGNX0N8q32dgibwJ6CU7NLe1ZI6ibiaTDVAo2IaX8oDcWMLUXW7jz8QxfuIUFRMv4ibeyeY6w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&amp;gt; Circuit Breaker by Md Kamaruzzaman&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;断路器&lt;/strong&gt;可以具有以下&lt;strong&gt;三种状态：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;·&lt;/strong&gt; &lt;strong&gt;已关闭：&lt;/strong&gt;断路器将请求发送到微服务，并计算给定时间段内的故障数。如果在一定时间内的故障数量超过阈值，则它将跳闸并进入&quot;打开状态&quot;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;&lt;strong&gt;打开：&lt;/strong&gt;来自微服务的请求立即失败，并返回异常。超时后，断路器进入半开状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;&lt;strong&gt;半开放式：&lt;/strong&gt;仅允许来自微服务的有限数量的请求通过并调用该操作。如果这些请求成功，则断路器将进入闭合状态。如果任何请求失败，则断路器进入&quot;打开&quot;状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;提高微服务架构的容错性和弹性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;停止将故障级联到其他微服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;需要复杂的异常处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;记录和监视。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;应该支持手动重置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;何时使用&lt;/strong&gt;断路器：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;在紧密耦合的微服务体系结构中，微服务进行同步通信。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;一个微服务是否依赖于多个其他微服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;何时不使用&lt;/strong&gt;断路器：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;松散耦合的，事件驱动的微服务架构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;微服务是否不依赖于其他微服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;推动技术：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;API网关，服务网格，各种断路器库(Hystrix，Reselience4J，Polly。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;外部化配置&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每个业务应用程序都有许多用于各种基础结构的配置参数(例如，数据库，网络，连接的服务地址，凭据，证书路径)。同样，在企业环境中，应用程序通常部署在各种运行时中(本地，开发，生产)。实现此目标的一种方法是通过内部配置，这是一种致命的不良做法。由于很容易破坏生产凭据，因此可能导致严重的安全风险。另外，配置参数的任何更改都需要重建应用程序。在微服务架构中，这一点尤为重要，因为我们可能拥有数百种服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;更好的方法是外部化所有配置。结果，将构建过程与运行时环境分开。此外，由于生产配置文件仅在运行时或通过环境变量使用，因此将安全风险降到最低。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;生产配置不是代码库的一部分，因此可以最大程度地减少安全漏洞。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;无需重新构建即可更改配置参数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们需要选择一个支持外部化配置的框架。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;何时使用&lt;/strong&gt;外部化配置：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;任何重要的生产应用程序都必须使用外部配置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;何时不使用&lt;/strong&gt;外部化配置：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在概念发展的证明。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;推动技术：&lt;/strong&gt;几乎所有企业级的现代框架都支持外部化配置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;消费者驱动的合同测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在微服务架构中，通常由独立的团队开发许多微服务。这些微服务一起工作来满足业务需求(例如，客户请求)，并且彼此同步或异步地通信。消费者微服务的集成测试具有挑战性。通常，在这种情况下使用TestDouble可以进行更快，更便宜的测试。但是TestDouble通常并不代表真正的提供程序微服务。另外，如果提供者微服务更改了其API或消息，则TestDouble无法确认这一点。另一个选择是进行端到端测试。虽然在生产之前必须进行端到端测试，但它脆弱，缓慢，昂贵，并且不能替代集成测试(测试金字塔)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消费者驱动的合同测试可以在这方面为我们提供帮助。此处，消费者微服务所有者团队编写了一个测试套件，其中包含针对特定提供者微服务的请求和预期响应(用于同步通信)或预期消息(用于异步通信)。这些测试套件称为显式合同。对于提供商微服务，其使用者的所有合同测试套件都添加到了自动测试中。在执行针对特定提供程序微服务的自动测试时，它将运行自己的测试，合同并验证合同。通过这种方式，合同测试可以帮助以自动化的方式维护微服务通信的完整性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;如果提供者意外更改了API或消息，则会在很短的时间内自动找到它。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;·&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;更少的惊喜和更高的健壮性，尤其是包含大量微服务的企业应用程序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;改善团队自主权。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;由于合同测试可能使用完全不同的测试工具，因此需要进行额外的工作才能&lt;strong&gt;· &lt;/strong&gt;在合同商微服务中开发和集成合同测试。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;如果合同测试与实际服务消耗不匹配，则可能导致生产失败。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;何时使用&lt;/strong&gt;消费者驱动的合同测试：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在大型企业业务应用程序中，通常，不同的团队开发不同的服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;何时不使用&lt;/strong&gt;消费者主导的合同测试：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;一个团队开发所有微服务的相对简单，较小的应用程序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;· &lt;/strong&gt;提供者微服务是否相对稳定且未处于积极开发中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;推动技术：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;契约，邮递员，Spring Cloud合同&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在现代的大型企业软件开发中，微服务体系结构可以帮助扩展规模并带来许多长期利益。但是微服务架构并不是可以在每个用例中使用的&quot;银弹&quot;。&lt;/p&gt;&lt;p&gt;如果在错误的应用程序类型中使用它，则微服务架构会带来更多的麻烦。&lt;/p&gt;&lt;p&gt;想要采用微服务体系结构的开发团队应遵循一组最佳实践，并使用一组可重复使用的，经过严格实践的设计模式。&lt;/p&gt;&lt;p&gt;微服务架构中最重要的设计模式是每个微服务的数据库。实施此设计模式具有挑战性，并且需要其他几个紧密相关的设计模式(事件源，CQRS和Saga)。&lt;/p&gt;&lt;p&gt;在具有多个客户端(Web，移动，台式机，智能设备)的典型业务应用程序中，客户端与微服务之间的通信可能会比较混乱，可能需要具有附加安全性的中央控制。在这种情况下，前端的设计模式和API网关非常有用。&lt;/p&gt;&lt;p&gt;同样，断路器模式可以极大地帮助处理此类应用程序中的错误情况。将旧的Monolithic应用程序迁移到微服务中具有很大的挑战性，而Strangler模式可以帮助迁移。&lt;/p&gt;&lt;p&gt;消费者驱动的合同测试是微服务集成测试的工具模式。同时，外部化配置是任何现代应用程序开发中的强制性模式。&lt;/p&gt;&lt;p&gt;该列表并不全面，并且取决于您的用例，您可能需要其他设计模式。但是此列表将为您提供有关微服务体系结构设计模式的出色介绍。&lt;/p&gt;&lt;section&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3OTc0MzY1Mg==&amp;amp;mid=2247497661&amp;amp;idx=2&amp;amp;sn=498d58941fe929e119c5da5e2f2be244&amp;amp;chksm=9fac6876a8dbe160df0969d290f9d91b36f76576a08a985d8397149f1d0513e55ebff818e3c2&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;GO语言版《算法进阶指南》火了，完整版PDF下载！&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3OTc0MzY1Mg==&amp;amp;mid=2247496096&amp;amp;idx=5&amp;amp;sn=7f9e3943e58eb80882d10de6deb7b8f0&amp;amp;chksm=9fac6e6ba8dbe77deb78425738150660bda9e3d60dea3758a946a81792db28e96a7a753ddf00&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;使用 Redis 实现一个轻量级的搜索引擎，牛逼啊！&lt;/a&gt;&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3OTc0MzY1Mg==&amp;amp;mid=2247484297&amp;amp;idx=5&amp;amp;sn=c98ff15a98ab191b042c4d1184e03019&amp;amp;chksm=9faf9c42a8d8155474c17050c8f90385b7983f3f8ac73fc42ca1190ad37d89d703276bd15452&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;【重磅分享】从零到一搭建推荐系统指南白皮书.pdf（附48页下载链接）&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3OTc0MzY1Mg==&amp;amp;mid=2247485571&amp;amp;idx=1&amp;amp;sn=0f55a55ed8fb0d3219b7f2d56eeaf953&amp;amp;chksm=9faf9748a8d81e5e4a987a80e56cd417ae68b597264d38fa031eed0e89e7c5992f9425cbe398&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;亿级(无限级)并发，没那么难&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3OTc0MzY1Mg==&amp;amp;mid=2247484337&amp;amp;idx=1&amp;amp;sn=b82bc301d542459d7f36c56172d02e93&amp;amp;chksm=9faf9c7aa8d8156c38234d11232a16242ec6235ba4f0e8f52b33b3b4d76ecd6ff1838c18f626&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;世界的真实格局分析，地球人类社会底层运行原理&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3OTc0MzY1Mg==&amp;amp;mid=2247484891&amp;amp;idx=1&amp;amp;sn=11430a774940305e7703f33a1f4ff0bd&amp;amp;chksm=9faf9a10a8d8130623b5906b1f124ede6859ac5dc60ccd12fe3d2357cb76f740c34c39f43cb8&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;不是你需要中台，而是一名合格的架构师（附各大厂中台建设PPT）&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3OTc0MzY1Mg==&amp;amp;mid=2247497455&amp;amp;idx=1&amp;amp;sn=65518c3b097f81ca6e9cc761746578e4&amp;amp;chksm=9fac6924a8dbe032f09c8b031a89a8c660f828bf496ea3fef0e0bf50befe6e6ce4c69193a44f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;字节跳动MySQL学习笔记火了，完整版开放下载！&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5626740947075209&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DMP9YVibia1dRcoIRZhIEXjOiadY6nez36IR7kcRPHYnzIMUjuhwA4q1nX78edeXc3JsWM0Dqdl3csJvp7BiaLSbXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1077&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c2e192598b63f23c41336324eca7214d</guid>
<title>[推荐] 9 条消除 if...else 的锦囊妙计，助你写出更优雅的代码</title>
<link>https://toutiao.io/k/6o9uhdv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近在做代码重构，发现了很多代码的烂味道。其他的不多说，今天主要说说那些又臭又长的if...else要如何重构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在介绍更更优雅的编程之前，让我们一起回顾一下，不好的if...else代码&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、又臭又长的if...else&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;废话不多说，先看看下面的代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;  &lt;br/&gt;}  &lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AliaPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;  &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===发起支付宝支付===&quot;&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;}  &lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WeixinPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;  &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;         System.out.println(&lt;span&gt;&quot;===发起微信支付===&quot;&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;}  &lt;br/&gt;  &lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JingDongPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;  &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===发起京东支付===&quot;&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;}  &lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PayService&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;@Autowired&lt;/span&gt;  &lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; AliaPay aliaPay;  &lt;br/&gt;     &lt;span&gt;@Autowired&lt;/span&gt;  &lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; WeixinPay weixinPay;  &lt;br/&gt;     &lt;span&gt;@Autowired&lt;/span&gt;  &lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; JingDongPay jingDongPay;  &lt;br/&gt;    &lt;br/&gt;   &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;toPay&lt;/span&gt;&lt;span&gt;(String code)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;alia&quot;&lt;/span&gt;.equals(code)) {  &lt;br/&gt;             aliaPay.pay();  &lt;br/&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;weixin&quot;&lt;/span&gt;.equals(code)) {  &lt;br/&gt;              weixinPay.pay();  &lt;br/&gt;         } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;jingdong&quot;&lt;/span&gt;.equals(code)) {  &lt;br/&gt;              jingDongPay.pay();  &lt;br/&gt;         } &lt;span&gt;else&lt;/span&gt; {  &lt;br/&gt;              System.out.println(&lt;span&gt;&quot;找不到支付方式&quot;&lt;/span&gt;);  &lt;br/&gt;         }  &lt;br/&gt;     }  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PayService类的toPay方法主要是为了发起支付，根据不同的code，决定调用用不同的支付类（比如：aliaPay）的pay方法进行支付。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码有什么问题呢？也许有些人就是这么干的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;试想一下，如果支付方式越来越多，比如：又加了百度支付、美团支付、银联支付等等，就需要改toPay方法的代码，增加新的else...if判断，判断多了就会导致逻辑越来越多？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很明显，这里违法了设计模式六大原则的：&lt;code&gt;开闭原则&lt;/code&gt; 和 &lt;code&gt;单一职责原则&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;开闭原则：对扩展开放，对修改关闭。就是说增加新功能要尽量少改动已有代码。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;单一职责原则：顾名思义，要求逻辑尽量单一，不要太复杂，便于复用。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那有什么办法可以解决这个问题呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、消除if...else的锦囊妙计&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;1、使用注解&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码中之所以要用code判断使用哪个支付类，是因为code和支付类没有一个绑定关系，如果绑定关系存在了，就可以不用判断了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先定义一个注解。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)  &lt;br/&gt;&lt;span&gt;@Target&lt;/span&gt;(ElementType.TYPE)  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;@interface&lt;/span&gt; PayCode {  &lt;br/&gt;&lt;br/&gt;     &lt;span&gt;String &lt;span&gt;value&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;    &lt;br/&gt;     &lt;span&gt;String &lt;span&gt;name&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在所有的支付类上都加上该注解&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@PayCode&lt;/span&gt;(value = &lt;span&gt;&quot;alia&quot;&lt;/span&gt;, name = &lt;span&gt;&quot;支付宝支付&quot;&lt;/span&gt;)  &lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AliaPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;&lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;  &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;         System.out.println(&lt;span&gt;&quot;===发起支付宝支付===&quot;&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;}  &lt;br/&gt;&lt;br/&gt; &lt;br/&gt;&lt;span&gt;@PayCode&lt;/span&gt;(value = &lt;span&gt;&quot;weixin&quot;&lt;/span&gt;, name = &lt;span&gt;&quot;微信支付&quot;&lt;/span&gt;)  &lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WeixinPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt; &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;  &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;         System.out.println(&lt;span&gt;&quot;===发起微信支付===&quot;&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;} &lt;br/&gt;&lt;br/&gt; &lt;br/&gt;&lt;span&gt;@PayCode&lt;/span&gt;(value = &lt;span&gt;&quot;jingdong&quot;&lt;/span&gt;, name = &lt;span&gt;&quot;京东支付&quot;&lt;/span&gt;)  &lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JingDongPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt; &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;  &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===发起京东支付===&quot;&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后增加最关键的类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PayService2&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ApplicationListener&lt;/span&gt;&amp;lt;&lt;span&gt;ContextRefreshedEvent&lt;/span&gt;&amp;gt; &lt;/span&gt;{  &lt;br/&gt; &lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String, IPay&amp;gt; payMap = &lt;span&gt;null&lt;/span&gt;;  &lt;br/&gt;     &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;  &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onApplicationEvent&lt;/span&gt;&lt;span&gt;(ContextRefreshedEvent contextRefreshedEvent)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;         ApplicationContext applicationContext = contextRefreshedEvent.getApplicationContext();  &lt;br/&gt;         Map&amp;lt;String, Object&amp;gt; beansWithAnnotation = applicationContext.getBeansWithAnnotation(PayCode&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;  &lt;br/&gt;        &lt;br/&gt;         &lt;span&gt;if&lt;/span&gt; (beansWithAnnotation != &lt;span&gt;null&lt;/span&gt;) {  &lt;br/&gt;             payMap = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();  &lt;br/&gt;             beansWithAnnotation.forEach((key, value) -&amp;gt;{  &lt;br/&gt;                 String bizType = value.getClass().getAnnotation(PayCode&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;).&lt;span&gt;value&lt;/span&gt;()&lt;/span&gt;;  &lt;br/&gt;                 payMap.put(bizType, (IPay) value);  &lt;br/&gt;             });  &lt;br/&gt;         }  &lt;br/&gt;     }  &lt;br/&gt;    &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;(String code)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        payMap.get(code).pay();  &lt;br/&gt;     }  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PayService2类实现了&lt;code&gt;ApplicationListener&lt;/code&gt;接口，这样在&lt;code&gt;onApplicationEvent&lt;/code&gt;方法中，就可以拿到&lt;code&gt;ApplicationContext&lt;/code&gt;的实例。我们再获取打了PayCode注解的类，放到一个map中，map中的key就是PayCode注解中定义的value，跟code参数一致，value是支付类的实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，每次就可以每次直接通过code获取支付类实例，而不用if...else判断了。如果要加新的支付方法，只需在支付类上面打上PayCode注解定义一个新的code即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：这种方式的code可以没有业务含义，可以是纯数字，只有不重复就行。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;2、动态拼接名称&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法主要针对code是有业务含义的场景。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PayService3&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ApplicationContextAware&lt;/span&gt; &lt;/span&gt;{   &lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; ApplicationContext applicationContext;  &lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String SUFFIX = &lt;span&gt;&quot;Pay&quot;&lt;/span&gt;;  &lt;br/&gt;&lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;  &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setApplicationContext&lt;/span&gt;&lt;span&gt;(ApplicationContext applicationContext)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{  &lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.applicationContext = applicationContext;  &lt;br/&gt;     }  &lt;br/&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;toPay&lt;/span&gt;&lt;span&gt;(String payCode)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;         ((IPay) applicationContext.getBean(getBeanName(payCode))).pay();  &lt;br/&gt;     }  &lt;br/&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getBeanName&lt;/span&gt;&lt;span&gt;(String payCode)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; payCode + SUFFIX;  &lt;br/&gt;     }  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到，支付类bean的名称是由code和后缀拼接而成，比如：aliaPay、weixinPay和jingDongPay。这就要求支付类取名的时候要特别注意，前面的一段要和code保持一致。调用的支付类的实例是直接从&lt;code&gt;ApplicationContext&lt;/code&gt;实例中获取的，默认情况下&lt;code&gt;bean&lt;/code&gt;是单例的，放在内存的一个&lt;code&gt;map&lt;/code&gt;中，所以不会有性能问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;特别说明一下，这种方法实现了&lt;code&gt;ApplicationContextAware&lt;/code&gt;接口跟上面的&lt;code&gt;ApplicationListener&lt;/code&gt;接口不一样，是想告诉大家获取&lt;code&gt;ApplicationContext&lt;/code&gt;实例的方法不只一种。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;3、模板方法判断&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然除了上面介绍的两种方法之外，spring的源码实现中也告诉我们另外一种思路，解决if...else问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先一起看看&lt;code&gt;spring AOP&lt;/code&gt;的部分源码，看一下&lt;code&gt;DefaultAdvisorAdapterRegistry&lt;/code&gt;的&lt;code&gt;wrap&lt;/code&gt;方法&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Advisor &lt;span&gt;wrap&lt;/span&gt;&lt;span&gt;(Object adviceObject)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; UnknownAdviceTypeException &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; (adviceObject &lt;span&gt;instanceof&lt;/span&gt; Advisor) {  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (Advisor) adviceObject;  &lt;br/&gt;     }  &lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; (!(adviceObject &lt;span&gt;instanceof&lt;/span&gt; Advice)) {  &lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UnknownAdviceTypeException(adviceObject);  &lt;br/&gt;     }  &lt;br/&gt;     Advice advice = (Advice) adviceObject;  &lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; (advice &lt;span&gt;instanceof&lt;/span&gt; MethodInterceptor) {    &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; DefaultPointcutAdvisor(advice);  &lt;br/&gt;     }  &lt;br/&gt;     &lt;span&gt;for&lt;/span&gt; (AdvisorAdapter adapter : &lt;span&gt;this&lt;/span&gt;.adapters) {  &lt;br/&gt;         &lt;span&gt;if&lt;/span&gt; (adapter.supportsAdvice(advice)) {  &lt;br/&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; DefaultPointcutAdvisor(advice);  &lt;br/&gt;         }  &lt;br/&gt;     }  &lt;br/&gt;     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UnknownAdviceTypeException(advice);  &lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重点看看&lt;code&gt;supportAdvice&lt;/code&gt;方法，有三个类实现了这个方法。我们随便抽一个类看看&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AfterReturningAdviceAdapter&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;AdvisorAdapter&lt;/span&gt;, &lt;span&gt;Serializable&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt; &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;  &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;supportsAdvice&lt;/span&gt;&lt;span&gt;(Advice advice)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (advice &lt;span&gt;instanceof&lt;/span&gt; AfterReturningAdvice);  &lt;br/&gt;     }  &lt;br/&gt; &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;  &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; MethodInterceptor &lt;span&gt;getInterceptor&lt;/span&gt;&lt;span&gt;(Advisor advisor)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        AfterReturningAdvice advice = (AfterReturningAdvice) advisor.getAdvice();  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; AfterReturningAdviceInterceptor(advice);  &lt;br/&gt;     }   &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该类的&lt;code&gt;supportsAdvice&lt;/code&gt;方法非常简单，只是判断了一下&lt;code&gt;advice&lt;/code&gt;的类型是不是&lt;code&gt;AfterReturningAdvice&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到这里应该有所启发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，我们可以这样做，定义一个接口或者抽象类，里面有个&lt;code&gt;support&lt;/code&gt;方法判断参数传的code是否自己可以处理，如果可以处理则走支付逻辑。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;&lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;support&lt;/span&gt;&lt;span&gt;(String code)&lt;/span&gt;&lt;/span&gt;;   &lt;br/&gt;     &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;  &lt;br/&gt;}  &lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AliaPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{   &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;  &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;support&lt;/span&gt;&lt;span&gt;(String code)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;alia&quot;&lt;/span&gt;.equals(code);  &lt;br/&gt;     }  &lt;br/&gt; &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;  &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===发起支付宝支付===&quot;&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;}  &lt;br/&gt; &lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WeixinPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt; &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;  &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;support&lt;/span&gt;&lt;span&gt;(String code)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;weixin&quot;&lt;/span&gt;.equals(code);  &lt;br/&gt;     }  &lt;br/&gt; &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;  &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===发起微信支付===&quot;&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;}  &lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JingDongPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;  &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;support&lt;/span&gt;&lt;span&gt;(String code)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;jingdong&quot;&lt;/span&gt;.equals(code);  &lt;br/&gt;     }  &lt;br/&gt; &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;  &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===发起京东支付===&quot;&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个支付类都有一个support方法，判断传过来的code是否和自己定义的相等。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PayService4&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ApplicationContextAware&lt;/span&gt;, &lt;span&gt;InitializingBean&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;&lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; ApplicationContext applicationContext;  &lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; List&amp;lt;IPay&amp;gt; payList = &lt;span&gt;null&lt;/span&gt;;  &lt;br/&gt;&lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;  &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;afterPropertiesSet&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{  &lt;br/&gt;         &lt;span&gt;if&lt;/span&gt; (payList == &lt;span&gt;null&lt;/span&gt;) {  &lt;br/&gt;             payList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();  &lt;br/&gt;             Map&amp;lt;String, IPay&amp;gt; beansOfType = applicationContext.getBeansOfType(IPay&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;  &lt;br/&gt; &lt;br/&gt;             beansOfType.forEach((key, value) -&amp;gt; payList.add(value));  &lt;br/&gt;         }  &lt;br/&gt;     }  &lt;br/&gt; &lt;br/&gt;     &lt;span&gt;@Override&lt;/span&gt;  &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setApplicationContext&lt;/span&gt;&lt;span&gt;(ApplicationContext applicationContext)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{  &lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.applicationContext = applicationContext;  &lt;br/&gt;     }  &lt;br/&gt; &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;toPay&lt;/span&gt;&lt;span&gt;(String code)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;         &lt;span&gt;for&lt;/span&gt; (IPay iPay : payList) {  &lt;br/&gt;             &lt;span&gt;if&lt;/span&gt; (iPay.support(code)) {  &lt;br/&gt;                iPay.pay();  &lt;br/&gt;             }  &lt;br/&gt;         }  &lt;br/&gt;     }  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码中先把实现了IPay接口的支付类实例初始化到一个list集合中，返回在调用支付接口时循环遍历这个list集合，如果code跟自己定义的一样，则调用当前的支付类实例的pay方法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;4.策略+工厂模式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式也是用于code是有业务含义的场景。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;策略模式&lt;/code&gt;定义了一组算法，把它们一个个封装起来, 并且使它们可相互替换。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;工厂模式&lt;/code&gt;用于封装和管理对象的创建，是一种创建型模式。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AliaPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@PostConstruct&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        PayStrategyFactory.register(&lt;span&gt;&quot;aliaPay&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===发起支付宝支付===&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WeixinPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@PostConstruct&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        PayStrategyFactory.register(&lt;span&gt;&quot;weixinPay&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===发起微信支付===&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JingDongPay&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;IPay&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@PostConstruct&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        PayStrategyFactory.register(&lt;span&gt;&quot;jingDongPay&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;===发起京东支付===&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PayStrategyFactory&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String, IPay&amp;gt; PAY_REGISTERS = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;register&lt;/span&gt;&lt;span&gt;(String code, IPay iPay)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; != code &amp;amp;&amp;amp; !&lt;span&gt;&quot;&quot;&lt;/span&gt;.equals(code)) {&lt;br/&gt;            PAY_REGISTERS.put(code, iPay);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IPay &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(String code)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; PAY_REGISTERS.get(code);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PayService3&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;toPay&lt;/span&gt;&lt;span&gt;(String code)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        PayStrategyFactory.get(code).pay();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码的关键是&lt;code&gt;PayStrategyFactory&lt;/code&gt;类，它是一个策略工厂，里面定义了一个全局的map，在所有IPay的实现类中注册当前实例到map中，然后在调用的地方通过&lt;code&gt;PayStrategyFactory&lt;/code&gt;类根据code从map获取支付类实例即可。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;5.责任链模式&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式在代码重构时用来消除if...else非常有效。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;责任链模式：将请求的处理对象像一条长链一般组合起来，形成一条对象链。请求并不知道具体执行请求的对象是哪一个，这样就实现了请求与处理对象之间的解耦。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的&lt;code&gt;filter&lt;/code&gt;、&lt;code&gt;spring aop&lt;/code&gt;就是使用了责任链模式，这里我稍微改良了一下，具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PayHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Getter&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Setter&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; PayHandler next;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;(String pay)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AliaPayHandler&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;PayHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;(String code)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;alia&quot;&lt;/span&gt;.equals(code)) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;===发起支付宝支付===&quot;&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            getNext().pay(code);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WeixinPayHandler&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;PayHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;(String code)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;weixin&quot;&lt;/span&gt;.equals(code)) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;===发起微信支付===&quot;&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            getNext().pay(code);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JingDongPayHandler&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;PayHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pay&lt;/span&gt;&lt;span&gt;(String code)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;jingdong&quot;&lt;/span&gt;.equals(code)) {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;===发起京东支付===&quot;&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            getNext().pay(code);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PayHandlerChain&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ApplicationContextAware&lt;/span&gt;, &lt;span&gt;InitializingBean&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ApplicationContext applicationContext;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; PayHandler header;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;handlePay&lt;/span&gt;&lt;span&gt;(String code)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        header.pay(code);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setApplicationContext&lt;/span&gt;&lt;span&gt;(ApplicationContext applicationContext)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.applicationContext = applicationContext;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;afterPropertiesSet&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        Map&amp;lt;String, PayHandler&amp;gt; beansOfTypeMap = applicationContext.getBeansOfType(PayHandler&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (beansOfTypeMap == &lt;span&gt;null&lt;/span&gt; || beansOfTypeMap.size() == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        List&amp;lt;PayHandler&amp;gt; handlers = beansOfTypeMap.values().stream().collect(Collectors.toList());&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; handlers.size(); i++) {&lt;br/&gt;            PayHandler payHandler = handlers.get(i);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (i != handlers.size() - &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;                payHandler.setNext(handlers.get(i + &lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        header = handlers.get(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码的关键是每个PayHandler的子类，都定义了下一个需要执行的PayHandler子类，构成一个链式调用，通过PayHandlerChain把这种链式结构组装起来。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;6、其他的消除if...else的方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然实际项目开发中使用if...else判断的场景非常多，上面只是其中几种场景。下面再列举一下，其他常见的场景。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;1.根据不同的数字返回不同的字符串&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getMessage&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; code)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; (code == &lt;span&gt;1&lt;/span&gt;) {  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;成功&quot;&lt;/span&gt;;  &lt;br/&gt;     } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (code == -&lt;span&gt;1&lt;/span&gt;) {  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;失败&quot;&lt;/span&gt;;  &lt;br/&gt;     } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (code == -&lt;span&gt;2&lt;/span&gt;) {  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;网络超时&quot;&lt;/span&gt;;  &lt;br/&gt;     } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (code == -&lt;span&gt;3&lt;/span&gt;) {  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;参数错误&quot;&lt;/span&gt;;  &lt;br/&gt;     }  &lt;br/&gt;     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&lt;span&gt;&quot;code错误&quot;&lt;/span&gt;);  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，这种判断没有必要，用一个枚举就可以搞定。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; MessageEnum {  &lt;br/&gt;     SUCCESS(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;成功&quot;&lt;/span&gt;),  &lt;br/&gt;     FAIL(-&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;失败&quot;&lt;/span&gt;),  &lt;br/&gt;     TIME_OUT(-&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;&quot;网络超时&quot;&lt;/span&gt;),  &lt;br/&gt;     PARAM_ERROR(-&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;&quot;参数错误&quot;&lt;/span&gt;);  &lt;br/&gt;&lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; code;  &lt;br/&gt;     &lt;span&gt;private&lt;/span&gt; String message;  &lt;br/&gt;&lt;br/&gt;     MessageEnum(&lt;span&gt;int&lt;/span&gt; code, String message) {  &lt;br/&gt;         &lt;span&gt;this&lt;/span&gt;.code = code;  &lt;br/&gt;         &lt;span&gt;this&lt;/span&gt;.message = message;  &lt;br/&gt;     }  &lt;br/&gt;   &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getCode&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.code;  &lt;br/&gt;     }  &lt;br/&gt;&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getMessage&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.message;  &lt;br/&gt;     }  &lt;br/&gt;  &lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; MessageEnum &lt;span&gt;getMessageEnum&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; code)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Arrays.stream(MessageEnum.values()).filter(x -&amp;gt; x.code == code).findFirst().orElse(&lt;span&gt;null&lt;/span&gt;);  &lt;br/&gt;     }  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再把调用方法稍微调整一下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getMessage&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; code)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     MessageEnum messageEnum = MessageEnum.getMessageEnum(code);  &lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; messageEnum.getMessage();  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完美。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;2.集合中的判断&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的枚举MessageEnum中的getMessageEnum方法，如果不用java8的语法的话，可能要这样写&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; MessageEnum &lt;span&gt;getMessageEnum&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; code)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;for&lt;/span&gt; (MessageEnum messageEnum : MessageEnum.values()) {  &lt;br/&gt;         &lt;span&gt;if&lt;/span&gt; (code == messageEnum.code) {  &lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; messageEnum;  &lt;br/&gt;         }  &lt;br/&gt;     }  &lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于集合中过滤数据，或者查找方法，java8有更简单的方法消除if...else判断。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; MessageEnum &lt;span&gt;getMessageEnum&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; code)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; Arrays.stream(MessageEnum.values()).filter(x -&amp;gt; x.code == code).findFirst().orElse(&lt;span&gt;null&lt;/span&gt;);  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;3.简单的判断&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实有些简单的if...else完全没有必要写，可以用三目运算符代替，比如这种情况：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getMessage2&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; code)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;if&lt;/span&gt;(code == &lt;span&gt;1&lt;/span&gt;) {  &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;  &lt;span&gt;&quot;成功&quot;&lt;/span&gt;;  &lt;br/&gt;     }  &lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;失败&quot;&lt;/span&gt;;  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改成三目运算符：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getMessage2&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; code)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; code == &lt;span&gt;1&lt;/span&gt; ? &lt;span&gt;&quot;成功&quot;&lt;/span&gt; : &lt;span&gt;&quot;失败&quot;&lt;/span&gt;;  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改之后代码更简洁一些。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;4.spring中的判断&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于参数的异常，越早被发现越好，在spring中提供了&lt;code&gt;Assert&lt;/code&gt;用来帮助我们检测参数是否有效。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;save&lt;/span&gt;&lt;span&gt;(Integer code，String name)&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;     &lt;span&gt;if&lt;/span&gt;(code == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;       &lt;span&gt;throw&lt;/span&gt; Exception(&lt;span&gt;&quot;code不能为空&quot;&lt;/span&gt;);     &lt;br/&gt;     } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;         &lt;span&gt;if&lt;/span&gt;(name == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;             &lt;span&gt;throw&lt;/span&gt; Exception(&lt;span&gt;&quot;name不能为空&quot;&lt;/span&gt;);     &lt;br/&gt;         } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;             System.out.println(&lt;span&gt;&quot;doSave&quot;&lt;/span&gt;);&lt;br/&gt;         }&lt;br/&gt;     }&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果参数非常多的话，if...else语句会很长，这时如果改成使用&lt;code&gt;Assert&lt;/code&gt;类判断，代码会简化很多：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;save2&lt;/span&gt;&lt;span&gt;(Integer code，String name)&lt;/span&gt; &lt;/span&gt;{      &lt;br/&gt;     Assert.notNull(code,&lt;span&gt;&quot;code不能为空&quot;&lt;/span&gt;); &lt;br/&gt;     Assert.notNull(name,&lt;span&gt;&quot;name不能为空&quot;&lt;/span&gt;); &lt;br/&gt;     System.out.println(&lt;span&gt;&quot;doSave&quot;&lt;/span&gt;);&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，还有很多其他的场景可以优化if...else，我再这里就不一一介绍了，感兴趣的朋友可以给我留言，一起探讨和研究一下。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;最后说一句(求关注，别白嫖我)&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这篇文章对您有所帮助，或者有所启发的话，帮忙扫描下发二维码关注一下，您的支持是我坚持写作最大的动力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;求一键三连：点赞、转发、在看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在公众号中回复：面试、代码神器、开发手册、时间管理有超赞的粉丝福利，另外回复：加群，可以跟很多BAT大厂的前辈交流和学习。&lt;/p&gt;&lt;section data-mid=&quot;&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;更多好文敬请关注公众号&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;扫描二维码&lt;/p&gt;&lt;p data-mid=&quot;&quot;&gt;关注公众号&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;苏三说技术&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;99&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;99&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDHUdzOhPCwBUOUgBJ8TrNhn8g5OiaO1C12Y71FPVcyqFkOzz4FnwsLyvZic0dNSYw8hfSjQOeJhDnWw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.12462908011869436&quot; data-type=&quot;png&quot; data-w=&quot;1348&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/pVibvv4KleFsnBBpxZsEibYGOXkgfekPUTZRBBZM4OqltADkUibt0xDic7ZY2MzBx4M7MLwTCXmia2kHCliccmCUQwuA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-style=&quot;font-variant-numeric: normal; font-variant-east-asian: normal; white-space: normal; text-align: center; color: rgb(127, 127, 127); letter-spacing: 0.54px; font-family: 微软雅黑; font-size: 16px; word-spacing: 1px; min-height: 1em; max-width: 100%; box-sizing: border-box; widows: 1; overflow-wrap: break-word; background-color: rgb(255, 255, 255);&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;欢迎跟我一起唠嗑，加下方微信备注【加群】即可，欢迎加入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.26356589147286824&quot; data-type=&quot;png&quot; data-w=&quot;258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/836iaaYdRmibxXjurZRm6AMAJydTZntswnnAmTWCfLag8Jdl3I1d745CkibAeBtdFB6Ej9iccMexDjXmJHibJEDgacw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;101&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;101&quot; data-ratio=&quot;1.0048309178743962&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDHUdzOhPCwBUOUgBJ8TrNhnfLeme2LIF0wf8xJX3Oich2efGXhGJic7ibdIDhY9icZiaPAyAFSvVn8AM6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;414&quot;/&gt;&lt;/section&gt;&lt;p data-mid=&quot;&quot;&gt;扫描二维码加好友&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1686af0a91d2f6a9d76f7cd085f66630</guid>
<title>[推荐] 几乎刷完了力扣所有的堆题，我发现了这些东西</title>
<link>https://toutiao.io/k/im0exw3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6601466992665037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeX9kJPsfuDyDDQX2XytZI4mqa00Kwh4DhkbDkgibI9CZrME3k9NpEvtzcPzn5rcCpufNbZj63Ks4Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1636&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是 lucifer。今天给大家带来的是《堆》专题。先上下本文的提纲，这个是我用 mindmap 画的一个脑图，之后我会继续完善，将其他专题逐步完善起来。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;大家也可以使用 vscode blink-mind 打开源文件查看，里面有一些笔记可以点开查看。源文件可以去我的公众号《力扣加加》回复脑图获取，以后脑图也会持续更新更多内容。vscode 插件地址：https://marketplace.visualstudio.com/items?itemName=awehook.vscode-blink-mind&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本系列包含以下专题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;几乎刷完了力扣所有的链表题，我发现了这些东西。。。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;几乎刷完了力扣所有的树题，我发现了这些东西。。。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;几乎刷完了力扣所有的堆题，我发现了这些东西。。。（就是本文）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一点絮叨&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;堆标签&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;在 leetcode 一共有 &lt;strong&gt;「42 道题」&lt;/strong&gt;。为了准备这个专题，我将 leetcode 几乎所有的堆题目都刷了一遍。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.503448275862069&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeX9kJPsfuDyDDQX2XytZI4HWUSQTBf1Ll2v9DLrelpCiajZNzAFpAqKIPZkMCdS3fuFEC0SPOMSmw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1450&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出，除了 3 个上锁的，其他我都刷了一遍。通过集中刷这些题，我发现了一些有趣的信息，今天就分享给大家。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，本文不对堆和优先队列进行区分。因此本文提到的堆和优先队列大家可以认为是同一个东西。如果大家对两者的学术区别感兴趣，可以去查阅相关资料。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;如果不做特殊说明，本文的堆均指的是小顶堆。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;堆的题难度几何？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆确实是一个难度不低的专题。从官方的难度标签来看，堆的题目一共才 42 道，困难度将近 50%。没有对比就没有伤害，树专题困难度只有不到 10%。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从通过率来看，&lt;strong&gt;「一半以上」&lt;/strong&gt;的题目平均通过率在 50% 以下。作为对比， 树的题目通过率在 50% 以下的只有&lt;strong&gt;「不到三分之一」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过大家不要太有压力。lucifer 给大家带来了一个口诀&lt;strong&gt;「一个中心，两种实现，三个技巧，四大应用」&lt;/strong&gt;，我们不仅讲实现和原理，更讲问题的&lt;strong&gt;「背景以及套路和模板」&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;文章里涉及的模板大家随时都可以从我的力扣刷题插件 leetcode-cheatsheet&lt;sup&gt;[2]&lt;/sup&gt; 中获取。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;堆的使用场景分析&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆其实就是一种数据结构，数据结构是为了算法服务的，那堆这种数据结构是为哪种算法服务的？它的适用场景是什么？这是每一个学习堆的人&lt;strong&gt;「第一个」&lt;/strong&gt;需要解决的问题。在什么情况下我们会使用堆呢？堆的原理是什么？如何实现一个堆？别急，本文将一一为你揭秘。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在进入正文之前，给大家一个学习建议 - &lt;strong&gt;「先不要纠结堆怎么实现的，咱先了解堆解决了什么问题」&lt;/strong&gt;。当你了解了使用背景和解决的问题之后，然后&lt;strong&gt;「当一个调包侠」&lt;/strong&gt;，直接用现成的堆的 api 解决问题。等你理解得差不多了，再去看堆的原理和实现。我就是这样学习堆的，因此这里就将这个学习经验分享给你。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了对堆的使用场景进行说明，这里我虚拟了一个场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「下面这个例子很重要， 后面会反复和这个例子进行对比」&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;一个挂号系统&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;问题描述&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如你是一个排队挂号系统的技术负责人。该系统需要给每一个前来排队的人发放一个排队码（入队），并根据&lt;strong&gt;「先来后到」&lt;/strong&gt;的原则进行叫号（出队）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，我们还可以区分了几种客户类型， 分别是普通客户， VIP 客户 和 至尊 VIP 客户。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果不同的客户使用不同的窗口的话，我该如何设计实现我的系统？（大家获得的服务不一样，比如 VIP 客户是专家级医生，普通客户是普通医生）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果不同的客户都使用一个窗口的话，我该如何设计实现我的系统？（大家获得的服务都一样，但是优先级不一样。比如其他条件相同情况下(比如他们都是同时来挂号的)，VIP 客户 优先级高于普通客户）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我该如何设计我的系统才能满足需求，并获得较好的扩展性？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;初步的解决方案&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不同的客户使用不同的窗口。那么我们可以设计三个队列，分别存放正在排队的三种人。这种设计满足了题目要求，也足够简单。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5176470588235295&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeX9kJPsfuDyDDQX2XytZI46sH2K1AubdjUazzu4wTYszkWWE9Epm95nXUaaiaNbwIhVa6TloeE54g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1190&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们&lt;strong&gt;「只有一个窗口」&lt;/strong&gt;，所有的病人需要使用同一个队列，并且同样的客户类型按照上面讲的&lt;strong&gt;「先到先服务原则」&lt;/strong&gt;，但是不同客户类型之间可能会插队。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单起见，我引入了&lt;strong&gt;「虚拟时间」&lt;/strong&gt;这个概念。具体来说：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;普通客户的虚拟时间就是真实时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;VIP 客户的虚拟时间按照实际到来时间减去一个小时。比如一个 VIP 客户是 14:00 到达的，我认为他是 13:00 到的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;至尊 VIP 客户的虚拟时间按照实际到来时间减去两个小时。比如一个 至尊 VIP 客户是 14:00 到达的，我认为他是 12:00 到的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，我们只需要按照上面的”虚拟到达时间“进行&lt;strong&gt;「先到先服务」&lt;/strong&gt;即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此我们就可以继续使用刚才的三个队列的方式，只不过队列存储的不是真实时间，而是虚拟时间。每次开始叫号的时候，我们使用虚拟时间比较，虚拟时间较小的先服务即可。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5055710306406686&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeX9kJPsfuDyDDQX2XytZI4KBuV2v4B8Wwcd1xicicBvRiaibgSQ7bhszPicvpLZc1w5VMq5XP1b0ZboAQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1436&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;不难看出，队列内部的时间都是有序。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「而这里的虚拟时间，其实就是优先队列中的优先权重」&lt;/strong&gt;，虚拟时间越小，权重越大。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;可以插队怎么办？&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种算法很好地完成了我们的需求，复杂度相当不错。不过事情还没有完结，这一次我们又碰到新的产品需求：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果有别的门诊的病人转院到我们的诊所，则按照他之前的排队信息算，比如 ta 是 12:00 在别的院挂的号，那么转到本院仍然是按照 12:00 挂号算。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果被叫到号三分钟没有应答，将其作废。但是如果后面病人重新来了，则认为他是当前时间减去一个小时的虚拟时间再次排队。比如 ta 是 13:00 被叫号，没有应答，13：30 又回来，则认为他是 12:30 排队的，重新进队列。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就有了”插队“的情况了。该怎么办呢？一个简单的做法是，将其插入到正确位置，并&lt;strong&gt;「重新调整后面所有人的排队位置」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图是插入一个 1:30 开始排队的普通客户的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7947019867549668&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeX9kJPsfuDyDDQX2XytZI4Hiak1bBAiceFtwvayFGlC10cjGasWp6zebMGBRmFR6qWcjRBFIORKDew/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1359&quot;/&gt;（查找插入位置）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5576642335766423&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeX9kJPsfuDyDDQX2XytZI4wXf8Q0bKmSINplricveiaUC0xiceNbdSnGiayLYg4h6kXMz3d1JpduzkVw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1370&quot;/&gt;（将其插入）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果队列使用数组实现， 上面插队过程的时间复杂度为 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;O(N)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 2429 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2040, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;，其中 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;N&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -683 888 683&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt; 为被插队的队伍长度。如果队伍很长，那么调整的次数明显增加。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过我们发现，本质上我们就是在维护一个&lt;strong&gt;「有序列表」&lt;/strong&gt;，而使用数组方式去维护有序列表的好处是可以随机访问，但是很明显这个需求并不需要这个特性。如果使用链表去实现，那么时间复杂度理论上是 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;O(1)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 2041 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1652, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;，但是如何定位到需要插入的位置呢？朴素的思维是遍历查找，但是这样的时间复杂度又退化到了 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;O(N)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 2429 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2040, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;。有没有时间复杂度更好的做法呢？答案就是本文的主角&lt;strong&gt;「优先队列」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面说了链表的实现核心在于查找也需要 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;O(N)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 2429 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2040, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;，我们可以优化这个过程吗？实际上这就是优先级队列的链表实现，由于是有序的，我们可以用跳表加速查找，时间复杂度可以优化到 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;O(logN)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 3689 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;path data-c=&quot;6C&quot; d=&quot;M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1450, 0)&quot;&gt;&lt;path data-c=&quot;6F&quot; d=&quot;M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1935, 0)&quot;&gt;&lt;path data-c=&quot;67&quot; d=&quot;M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2412, 0)&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(3300, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3806921675774135&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeX9kJPsfuDyDDQX2XytZI4M9SYYeJbD9YyH7SZ8cU1dgZGYs3kmAk9BaN9YC1k0VWyOcpUYbg7Lg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1098&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实算法界有很多类似的问题。比如建立数据库索引的算法，如果给某一个有序的列添加索引，不能每次插入一条数据都去调整所有的数据吧（上面的数组实现）？因此我们可以用平衡树来实现，这样每次插入可以最多调整 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;(O(logN))&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 4467 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mo&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(389, 0)&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1541, 0)&quot;&gt;&lt;path data-c=&quot;6C&quot; d=&quot;M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1839, 0)&quot;&gt;&lt;path data-c=&quot;6F&quot; d=&quot;M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2324, 0)&quot;&gt;&lt;path data-c=&quot;67&quot; d=&quot;M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2801, 0)&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(3689, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(4078, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;。优先队列的另外一种实现 - 二叉堆就是这个思想，时间复杂度也可以优化到&lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;O(logN)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 3689 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;path data-c=&quot;6C&quot; d=&quot;M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1450, 0)&quot;&gt;&lt;path data-c=&quot;6F&quot; d=&quot;M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1935, 0)&quot;&gt;&lt;path data-c=&quot;67&quot; d=&quot;M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2412, 0)&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(3300, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9296636085626911&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeX9kJPsfuDyDDQX2XytZI4vNKoLVbB5kuRAjpic8plL9PDEHX46H0ibkGjfV9rANmcUlm7ClMyVQ9w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;654&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文只讲解常见的二叉堆实现，对于跳表和红黑树不再这里讲。关于优先队列的二叉堆实现，我们会在后面给大家详细介绍。这里大家只有明白优先队列解决的问题是什么就可以了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;使用堆解决问题&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆的两个核心 API 是 push 和 pop。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家先不考虑它怎么实现的，你可以暂时把 ta 想象成一个黑盒，提供了两个 api：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;push&lt;/code&gt;：推入一个数据，内部怎么组织我不管。对应我上面场景里面的&lt;strong&gt;「排队」&lt;/strong&gt;和&lt;strong&gt;「插队」&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;pop&lt;/code&gt;：弹出一个数据，该数据一定是最小的，内部怎么实现我不管。对应我上面场景里面的&lt;strong&gt;「叫号」&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;这里的例子其实是小顶堆。而如果弹出的数据一定是最大的，那么对应的实现为大顶堆。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;借助这两个 api 就可以实现上面的需求。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 12:00 来了一个普通的顾客（push）&lt;/span&gt;&lt;br/&gt;heapq.heappush(normal_pq, &lt;span&gt;&#x27;12:00&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;# 12:30 来了一个普通顾客（push）&lt;/span&gt;&lt;br/&gt;heapq.heappush(normal_pq, &lt;span&gt;&#x27;12:30&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;# 13:00 来了一个普通顾客（push）&lt;/span&gt;&lt;br/&gt;heapq.heappush(normal_pq, &lt;span&gt;&#x27;13:00&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;# 插队（push）。时间复杂度可以达到 O(logN)。如何做到先不管，我们先会用就行，具体实现细节后面再讲。&lt;/span&gt;&lt;br/&gt;heapq.heappush(normal_pq, &lt;span&gt;&#x27;12: 20&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;# 叫号（pop）。12:00 来的先被叫到。需要注意的是这里的弹出时间复杂度也变成了 O(logN)，这或许就是幸福的代价吧。&lt;/span&gt;&lt;br/&gt;heapq.heappop(normal_pq)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;小结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这个场景单纯使用数组和链表都可以满足需求，但是使用其他数据结构在应对”插队“的情况表现地会更好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体来说：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果永远都维护一个有序数组的方式取极值很容易，但是插队麻烦。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果永远都维护一个有序链表的方式取极值也容易。不过要想查找足够快，而不是线性扫描，就需要借助索引，这种实现对应的就是优先级队列的&lt;strong&gt;「跳表实现」&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果永远都维护一个树的方式取极值也可以实现，比如根节点就是极值，这样 O(1) 也可以取到极值，但是调整过程需要 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;O(logN)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 3689 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;path data-c=&quot;6C&quot; d=&quot;M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1450, 0)&quot;&gt;&lt;path data-c=&quot;6F&quot; d=&quot;M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1935, 0)&quot;&gt;&lt;path data-c=&quot;67&quot; d=&quot;M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2412, 0)&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(3300, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;。这种实现对应的就是优先级队列的&lt;strong&gt;「二叉堆实现」&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单总结下就是，&lt;strong&gt;「堆就是动态帮你求极值的」&lt;/strong&gt;。当你需要动态求最大或最小值就就用它。而具体怎么实现，复杂度的分析我们之后讲，现在你只要记住使用场景，堆是如何解决这些问题的以及堆的 api 就够了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;队列 VS 优先队列&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面通过一个例子带大家了解了一下优先队列。那么在接下来讲具体实现之前，我觉得有必要回答下一个大家普遍关心的问题，那就是&lt;strong&gt;「优先队列是队列么」&lt;/strong&gt;？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多人觉得队列和优先队列是完全不同的东西，就好像 Java 和 JavaScript 一样，我看了很多文章都是这么说的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而我不这么认为。实际上，普通的队列也可以看成是一个特殊的&lt;strong&gt;「优先级队列」&lt;/strong&gt;， 这和网上大多数的说法&lt;strong&gt;「优先级队列和队列没什么关系」&lt;/strong&gt;有所不同。我认为&lt;strong&gt;「队列无非就是以时间这一变量作为优先级的优先队列」&lt;/strong&gt;，时间越早，优先级越高，优先级越高越先出队。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家平时写 BFS 的时候都会用到队列来帮你处理节点的访问顺序。那使用优先队列行不行？当然可以了！我举个例子：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;例题 - 513. 找树左下角的值&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;题目描述&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;定一个二叉树，在树的最后一行找到最左边的值。&lt;br/&gt;&lt;br/&gt;示例 1:&lt;br/&gt;&lt;br/&gt;输入:&lt;br/&gt;&lt;br/&gt;    2&lt;br/&gt;   / \&lt;br/&gt;  1   3&lt;br/&gt;&lt;br/&gt;输出:&lt;br/&gt;1&lt;br/&gt; &lt;br/&gt;&lt;br/&gt;示例 2:&lt;br/&gt;&lt;br/&gt;输入:&lt;br/&gt;&lt;br/&gt;        1&lt;br/&gt;       / \&lt;br/&gt;      2   3&lt;br/&gt;     /   / \&lt;br/&gt;    4   5   6&lt;br/&gt;       /&lt;br/&gt;      7&lt;br/&gt;&lt;br/&gt;输出:&lt;br/&gt;7&lt;br/&gt; &lt;br/&gt;&lt;br/&gt;注意: 您可以假设树（即给定的根节点）不为 NULL。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;思路&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用 BFS 来做一次层次遍历，并且每一层我们都从右向左遍历，这样层次遍历的最后一个节点就是&lt;strong&gt;「树左下角的节点」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常规的做法是使用双端队列（就是队列）来实现，由于队列的先进先出原则很方便地就能实现&lt;strong&gt;「层次遍历」&lt;/strong&gt;的效果。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;代码&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于代码看不懂的同学，可以先不要着急。等完整读完本文之后再回过头看会容易很多。下同，不再赘述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python Code:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;findBottomLeftValue&lt;/span&gt;&lt;span&gt;(self, root: TreeNode)&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; root &lt;span&gt;is&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;br/&gt;        queue = collections.deque([root])&lt;br/&gt;        ans = &lt;span&gt;None&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; queue:&lt;br/&gt;            size = len(queue)&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt; range(size):&lt;br/&gt;                ans = node = queue.popleft()&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; node.right:&lt;br/&gt;                    queue.append(node.right)&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; node.left:&lt;br/&gt;                    queue.append(node.left)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ans.val&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上， 我们也可以使用优先队列的方式，思路和代码也几乎和上面完全一样。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;findBottomLeftValue&lt;/span&gt;&lt;span&gt;(self, root: TreeNode)&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; root &lt;span&gt;is&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;br/&gt;        queue = []&lt;br/&gt;        &lt;span&gt;# 堆存储三元组(a,b,c)，a 表示层级，b 表示节点编号（以完全二叉树的形式编号，空节点也编号），c 是节点本身&lt;/span&gt;&lt;br/&gt;        heapq.heappush(queue, (&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, root))&lt;br/&gt;        ans = &lt;span&gt;None&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; queue:&lt;br/&gt;            size = len(queue)&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt; range(size):&lt;br/&gt;                level, i, node = heapq.heappop(queue)&lt;br/&gt;                ans = node&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; node.right:&lt;br/&gt;                    heapq.heappush(queue, (level + &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt; * i + &lt;span&gt;1&lt;/span&gt;, node.right))&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; node.left:&lt;br/&gt;                    heapq.heappush(queue, (level + &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt; * i + &lt;span&gt;2&lt;/span&gt;, node.left))&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ans.val&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;小结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「所有使用队列的地方，都可以使用优先队列来完成，反之却不一定。」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然优先队列这么厉害，那平时都用优先队列不就行了？为啥使用队列的地方没见过别人用堆呢？最核心的原因是时间复杂度更差了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如上面的例子，本来入队和出队都可是很容易地在 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;O(1)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 2041 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1652, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt; 的时间完成。而现在呢？入队和出队的复杂度都是 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;O(logN)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 3689 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;path data-c=&quot;6C&quot; d=&quot;M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1450, 0)&quot;&gt;&lt;path data-c=&quot;6F&quot; d=&quot;M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1935, 0)&quot;&gt;&lt;path data-c=&quot;67&quot; d=&quot;M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2412, 0)&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(3300, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;，其中 N 为当前队列的大小。因此在没有必要的地方使用堆，会大大提高算法的时间复杂度，这当然不合适。说的粗俗一点就是脱了裤子放屁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过 BFS 真的就没人用优先队列实现么？当然不是！比如带权图的最短路径问题，如果用队列做 BFS 那就需要优先队列才可以，因为路径之间是有&lt;strong&gt;「权重的差异」&lt;/strong&gt;的，这不就是优先队列的设计初衷么。&lt;strong&gt;「使用优先队列的 BFS 实现典型的就是 dijkstra 算法」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这再一次应征了我的那句话&lt;strong&gt;「队列就是一种特殊的优先队列而已」&lt;/strong&gt;。特殊到大家的权重就是按照到来的顺序定，谁先来谁的优先级越高。在这种特殊情况下，我们没必须去维护堆来完成，进而获得更好的时间复杂度。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一个中心&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆的问题核心点就一个，那就是&lt;strong&gt;「动态求极值」&lt;/strong&gt;。动态和极值二者缺一不可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;求极值比较好理解，无非就是求最大值或者最小值，而动态却不然。比如要你求一个数组的第 k 小的数，这是动态么？这其实完全看你怎么理解。而在我们这里，这种情况就是动态的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何理解上面的例子是动态呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以这么想。由于堆只能求极值。比如能求最小值，但不能直接求第 k 小的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那我们是不是先求最小的值，然后将其出队（对应上面例子的叫号）。然后继续求最小的值，这个时候求的就是第 2 小了。如果要求第 k 小，那就如此反复 k 次即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个过程，你会发现数据是在&lt;strong&gt;「动态变化的」&lt;/strong&gt;，对应的就是堆的大小在变化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们通过几个例子来进行说明。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;例一 - 1046. 最后一块石头的重量&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;题目描述&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;有一堆石头，每块石头的重量都是正整数。&lt;br/&gt;&lt;br/&gt;每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x &amp;lt;= y。那么粉碎的可能结果如下：&lt;br/&gt;&lt;br/&gt;如果 x == y，那么两块石头都会被完全粉碎；&lt;br/&gt;如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。&lt;br/&gt;最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。&lt;br/&gt;&lt;br/&gt; &lt;br/&gt;&lt;br/&gt;示例：&lt;br/&gt;&lt;br/&gt;输入：[2,7,4,1,8,1]&lt;br/&gt;输出：1&lt;br/&gt;解释：&lt;br/&gt;先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，&lt;br/&gt;再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，&lt;br/&gt;接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，&lt;br/&gt;最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。&lt;br/&gt; &lt;br/&gt;&lt;br/&gt;提示：&lt;br/&gt;&lt;br/&gt;1 &amp;lt;= stones.length &amp;lt;= 30&lt;br/&gt;1 &amp;lt;= stones[i] &amp;lt;= 1000&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;思路&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;题目比较简单，直接模拟即可。需要注意的是，每次选择两个最重的两个石头进行粉碎之后，最重的石头的重量便发生了变化。这会&lt;strong&gt;「影响到下次取最重的石头」&lt;/strong&gt;。简单来说就是最重的石头在模拟过程中是&lt;strong&gt;「动态变化」&lt;/strong&gt;的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种&lt;strong&gt;「动态取极值」&lt;/strong&gt;的场景使用堆就非常适合。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;当然看下这个数据范围&lt;code&gt;1 &amp;lt;= stones.length &amp;lt;= 30 且 1 &amp;lt;= stones[i] &amp;lt;= 1000&lt;/code&gt;，使用计数的方式应该也是可以的。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;代码&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java Code:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; java.util.PriorityQueue;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;lastStoneWeight&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] stones)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; n = stones.length;&lt;br/&gt;        PriorityQueue&amp;lt;Integer&amp;gt; maxHeap = &lt;span&gt;new&lt;/span&gt; PriorityQueue&amp;lt;&amp;gt;(n, (a, b) -&amp;gt; b - a);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; stone : stones) {&lt;br/&gt;            maxHeap.add(stone);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (maxHeap.size() &amp;gt;= &lt;span&gt;2&lt;/span&gt;) {&lt;br/&gt;            Integer head1 = maxHeap.poll();&lt;br/&gt;            Integer head2 = maxHeap.poll();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (head1.equals(head2)) {&lt;br/&gt;                &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            maxHeap.offer(head1 - head2);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (maxHeap.isEmpty()) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; maxHeap.poll();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;例二 - 313. 超级丑数&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;题目描述&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;编写一段程序来查找第 n 个超级丑数。&lt;br/&gt;&lt;br/&gt;超级丑数是指其所有质因数都是长度为 k 的质数列表 primes 中的正整数。&lt;br/&gt;&lt;br/&gt;示例:&lt;br/&gt;&lt;br/&gt;输入: n = 12, primes = [2,7,13,19]&lt;br/&gt;输出: 32&lt;br/&gt;解释: 给定长度为 4 的质数列表 primes = [2,7,13,19]，前 12 个超级丑数序列为：[1,2,4,7,8,13,14,16,19,26,28,32] 。&lt;br/&gt;说明:&lt;br/&gt;&lt;br/&gt;1 是任何给定 primes 的超级丑数。&lt;br/&gt; 给定 primes 中的数字以升序排列。&lt;br/&gt;0 &amp;lt; k ≤ 100, 0 &amp;lt; n ≤ 10^6, 0 &amp;lt; primes[i] &amp;lt; 1000 。&lt;br/&gt;第 n 个超级丑数确保在 32 位有符整数范围内。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;思路&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题看似和动态求极值没关系。其实不然，让我们来分析一下这个题目。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以实现生成超级多的丑数，比如先从小到大生成 N 个丑数，然后直接取第 N 个么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拿这道题来说， 题目有一个数据范围限制 &lt;code&gt;0 &amp;lt; n ≤ 10^6&lt;/code&gt;，那我们是不是预先生成一个大小为 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;10^6&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -864 1403.6 886&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;msup&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;path data-c=&quot;30&quot; d=&quot;M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z&quot; transform=&quot;translate(500, 0)&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(1000, 393.1) scale(0.707)&quot;&gt;&lt;path data-c=&quot;36&quot; d=&quot;M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt; 的超级丑数数组，这样我们就可通过 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;O(1)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 2041 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1652, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt; 的时间获取到第 N 个超级丑数了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先第一个问题就是时间和空间浪费。我们其实没有必要每次都计算所有的超级丑数，这样的预处理空间和时间都很差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个问题是，我们如何生成 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;10^6&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -864 1403.6 886&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;msup&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;path data-c=&quot;30&quot; d=&quot;M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z&quot; transform=&quot;translate(500, 0)&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(1000, 393.1) scale(0.707)&quot;&gt;&lt;path data-c=&quot;36&quot; d=&quot;M42 313Q42 476 123 571T303 666Q372 666 402 630T432 550Q432 525 418 510T379 495Q356 495 341 509T326 548Q326 592 373 601Q351 623 311 626Q240 626 194 566Q147 500 147 364L148 360Q153 366 156 373Q197 433 263 433H267Q313 433 348 414Q372 400 396 374T435 317Q456 268 456 210V192Q456 169 451 149Q440 90 387 34T253 -22Q225 -22 199 -14T143 16T92 75T56 172T42 313ZM257 397Q227 397 205 380T171 335T154 278T148 216Q148 133 160 97T198 39Q222 21 251 21Q302 21 329 59Q342 77 347 104T352 209Q352 289 347 316T329 361Q302 397 257 397Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt; 以为的超级丑数呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过丑数的定义，我们能知道超级丑数一定可以写出如下形式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; primes = [a,b,c,....]&lt;br/&gt;&lt;span&gt;then&lt;/span&gt; f(ugly) = a * x1 * b * x2 * c * x3 ...&lt;br/&gt;其中 x1，x2，x3 均为正整数。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不妨将问题先做一下简化处理。考虑题目给的例子：[2,7,13,19]。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用四个指针来处理。直接看下代码吧：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;solve&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; n)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; ans[]=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[n+&lt;span&gt;5&lt;/span&gt;];&lt;br/&gt;        ans[&lt;span&gt;0&lt;/span&gt;]=&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; p1=&lt;span&gt;0&lt;/span&gt;,p2=&lt;span&gt;0&lt;/span&gt;,p3=&lt;span&gt;0&lt;/span&gt;,p4=&lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;n;i++){&lt;br/&gt;            ans[i]=Math.min(ans[p1]*&lt;span&gt;2&lt;/span&gt;,Math.min(ans[p2]*&lt;span&gt;7&lt;/span&gt;,Math.min(ans[p3]*&lt;span&gt;13&lt;/span&gt;,ans[p4]*&lt;span&gt;19&lt;/span&gt;)));&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(ans[i]==ans[p1]*&lt;span&gt;2&lt;/span&gt;) p1++;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(ans[i]==ans[p2]*&lt;span&gt;7&lt;/span&gt;) p2++;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(ans[i]==ans[p3]*&lt;span&gt;13&lt;/span&gt;) p3++;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(ans[i]==ans[p3]*&lt;span&gt;19&lt;/span&gt;) p4++;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ans[n-&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个技巧我自己称之为&lt;strong&gt;「多路归并」&lt;/strong&gt;（实现想不到什么好的名字），我也会在后面的&lt;strong&gt;「三个技巧」&lt;/strong&gt;也会对此方法使用堆来优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于这里的指针是动态的，指针的数量其实和题目给的 primes 数组长度一致。因此实际上，我们可以使用记忆化递归的形式来完成，&lt;strong&gt;「递归体和递归栈分别维护一个迭代变量即可」&lt;/strong&gt;。而这道题其实可以看出是一个状态机，因此使用动态规划来解决是符合直觉的。而这里，介绍一种堆的解法，相比于动态规划，个人认为更简单和符合直觉。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;关于状态机，我这里有一篇文章原来状态机也可以用来刷 LeetCode？&lt;sup&gt;[3]&lt;/sup&gt;，大家可以参考一下哦。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上，我们可以&lt;strong&gt;「动态」&lt;/strong&gt;维护一个当前最小的超级丑数。找到第一个， 我们将其移除，再找&lt;strong&gt;「下一个当前最小的超级丑数」&lt;/strong&gt;（也就是全局第二小的超级丑数）。这样经过 n 轮，我们就得到了第 n 小的超级丑数。这种动态维护极值的场景正是堆的用武之地。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;有没有觉得和上面石头的题目很像？&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以题目给的例子 [2,7,13,19] 来说。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将 [2,7,13,19] 依次入堆。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;出堆一个数字，也就是是 2。这时取到了&lt;strong&gt;「第一个」&lt;/strong&gt;超级丑数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接着将 2 和 [2,7,13,19] 的乘积，也就是 [4,14,26,38] 依次入堆。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如此反复直到取到第 n 个超级丑数。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的正确性是毋庸置疑的，由于每次堆都可以取到最小的，每次我们也会将最小的从堆中移除。因此取 n 次自然就是第 n 大的超级丑数了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆的解法没有太大难度，唯一需要注意的是去重。比如 2 * 13 = 16，而 13 * 2 也是 16。我们不能将 16 入两次堆。解决的方法也很简单：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;要么使用哈希表记录全部已经取出的数，对于已经取出的数字不再取即可。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;另一种方法是记录上一次取出的数，由于取出的数字是按照&lt;strong&gt;「数字大小不严格递增」&lt;/strong&gt;的，这样只需要拿上次取出的数和本次取出的数比较一下就知道了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用哪种方法不用多说了吧？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;代码&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java Code:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;nthSuperUglyNumber&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; n, &lt;span&gt;int&lt;/span&gt;[] primes)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        PriorityQueue&amp;lt;Long&amp;gt; queue=&lt;span&gt;new&lt;/span&gt; PriorityQueue&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; ans = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        queue.add(ans);&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (count &amp;lt; n) {&lt;br/&gt;            ans=queue.poll();&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (!queue.isEmpty() &amp;amp;&amp;amp; ans == queue.peek()) {&lt;br/&gt;                queue.poll();&lt;br/&gt;            }&lt;br/&gt;            count++;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; primes.length ; i++) {&lt;br/&gt;                queue.offer(ans * primes[i]);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt;)ans;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;ans 初始化为 1 的作用相当于虚拟头，仅仅起到了简化操作的作用&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;小结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆的中心就一个，那就是&lt;strong&gt;「动态求极值」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而求极值无非就是最大值或者最小值，这不难看出。如果求最大值，我们可以使用大顶堆，如果求最小值，可以用最小堆。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而实际上，如果没有动态两个字，很多情况下没有必要使用堆。比如可以直接一次遍历找出最大的即可。而动态这个点不容易看出来，这正是题目的难点。这需要你先对问题进行分析， 分析出这道题&lt;strong&gt;「其实就是动态求极值」&lt;/strong&gt;，那么使用堆来优化就应该被想到。类似的例子有很多，我也会在后面的小节给大家做更多的讲解。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;两种实现&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面简单提到了堆的几种实现。这里介绍两种常见的实现，一种是基于链表的实现- 跳表，另一种是基于数组的实现 - 二叉堆。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用跳表的实现，如果你的算法没有经过精雕细琢，性能会比较不稳定，且在数据量大的情况下内存占用会明显增加。因此我们仅详细讲述二叉堆的实现，而对于跳表的实现，仅讲述它的基本原理，对于代码实现等更详细的内容由于比较偏就不在这里讲了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;跳表&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跳表也是一种数据结构，因此 ta 其实也是服务于某种算法的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跳表虽然在面试中出现的频率不大，但是在工业中，跳表会经常被用到。力扣中关于跳表的题目只有一个。但是跳表的设计思路值得我们去学习和思考。其中有很多算法和数据结构技巧值得我们学习。比如空间换时间的思想，比如效率的取舍问题等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面提到了应付插队问题是设计&lt;strong&gt;「堆」&lt;/strong&gt;应该考虑的首要问题。堆的跳表实现是如何解决这个问题的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，不借助额外空间的情况下，在链表中查找一个值，需要按照顺序一个个查找，时间复杂度为 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;O(N)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 2429 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2040, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;，其中 N 为链表长度。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.08952702702702703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeX9kJPsfuDyDDQX2XytZI4KMibNLm4oD9zaY2N5VzqeEDpZlCtcTd8t30yl4uG686Vv3ulMU7c1kQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2368&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（单链表）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当链表长度很大的时候， 这种时间是很难接受的。一种常见的的优化方式是&lt;strong&gt;「建立哈希表，将所有节点都放到哈希表中，以空间换时间的方式减少时间复杂度」&lt;/strong&gt;，这种做法时间复杂度为 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;O(1)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 2041 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1652, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;，但是空间复杂度为 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;O(N)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 2429 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2040, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeX9kJPsfuDyDDQX2XytZI4SbQLicjk2rgOwbCv7kBapYow0TcvrbjNVMAGiaf9jV6RmCcOlZnjAjXQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1572&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（单链表 + 哈希表）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了防止链表中出现重复节点带来的问题，我们需要序列化节点，再建立哈希表，这种空间占用会更高，虽然只是系数级别的增加，但是这种开销也是不小的 。更重要的是，哈希表不能解决查找极值的问题，其仅适合根据 key 来获取内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决上面的问题，跳表应运而生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示，我们从链表中每两个元素抽出来，加一级索引，一级索引指向了原始链表，即：通过一级索引 7 的 down 指针可以找到原始链表的 7 。那怎么查找 10 呢？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;注意这个算法要求链表是有序的。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.27736686390532544&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeX9kJPsfuDyDDQX2XytZI4H2nu8rHfy0LWo47ibGtJjxyVaZFB1ZSG8XxuIVRmsibHib2cWGdpKRfTQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2704&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（建立一级索引）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过现在一级跳表中搜索到 7，发现下一个 18 大于 10 ，也就是说我们要找的 10 在这两者之间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 down 指针回到原始链表，通过原始链表的 next 指针我们找到了 10。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子看不出性能提升。但是如果元素继续增大， 继续增加索引的层数，建立二级，三级。。。索引，使得链表能够实现二分查找，从而获得更好的效率。但是相应地，我们需要付出额外空间的代价。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4528301886792453&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeX9kJPsfuDyDDQX2XytZI42SymNriaFgm8fMtof4nB7v2NGuiaIjgqXNSKZ3E4MggJwTVgDbdBuTSA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2385&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（增加索引层数）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解了上面的点，你可以形象地将跳表想象为玩游戏的&lt;strong&gt;「存档」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个游戏有 10 关。如果我想要玩第 5 关的某一个地方，那么我可以直接从第五关开始，这样要比从第一关开始快。我们甚至可以在每一关同时设置很多的存档。这样我如果想玩第 5 关的某一个地方，也可以不用从第 5 关的开头开始，而是直接选择&lt;strong&gt;「离你想玩的地方更近的存档」&lt;/strong&gt;，这就相当于跳表的二级索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跳表的时间复杂度和空间复杂度不是很好分析。由于时间复杂度 = 索引的高度 * 平均每层索引遍历元素的个数，而高度大概为 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;logn&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -694 1860 899&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;6C&quot; d=&quot;M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(298, 0)&quot;&gt;&lt;path data-c=&quot;6F&quot; d=&quot;M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(783, 0)&quot;&gt;&lt;path data-c=&quot;67&quot; d=&quot;M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1260, 0)&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;，并且每层遍历的元素是常数，因此时间复杂度为 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;logn&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -694 1860 899&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;6C&quot; d=&quot;M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(298, 0)&quot;&gt;&lt;path data-c=&quot;6F&quot; d=&quot;M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(783, 0)&quot;&gt;&lt;path data-c=&quot;67&quot; d=&quot;M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1260, 0)&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;，和二分查找的空间复杂度是一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;空间复杂度就等同于索引节点的个数，以每两个节点建立一个索引为例，大概是 n/2 + n/4 + n/8 + … + 8 + 4 + 2 ，因此空间复杂度是 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;O(n)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 2141 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1752, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;。当然你如果每三个建立一个索引节点的话，空间会更省，但是复杂度不变。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解了上面的内容，使用跳表实现堆就不难了。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;入堆操作，只需要根据索引插到链表中，并更新索引（可选）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;出堆操作，只需要删除头部（或者尾部），并更新索引（可选）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家如果想检测自己的实现是否有问题，可以去力扣的1206. 设计跳表 检测。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们看下一种更加常见的实现 - 二叉堆。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;二叉堆&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二叉堆的实现，我们仅讲解最核心的两个操作：heappop（出堆） 和 heappush（入堆）。对于其他操作不再讲解，不过我相信你会了这两个核心操作，其他的应该不是难事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现之后的使用效果大概是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;h = min_heap()&lt;br/&gt;h.build_heap([&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;])&lt;br/&gt;&lt;br/&gt;h.heappush(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;h.heappop() &lt;span&gt;# 1&lt;/span&gt;&lt;br/&gt;h.heappop() &lt;span&gt;# 2&lt;/span&gt;&lt;br/&gt;h.heappush(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;h.heappop() &lt;span&gt;# 1&lt;/span&gt;&lt;br/&gt;h.heappop() &lt;span&gt;# 3&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;基本原理&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本质上来说，二叉堆就是一颗特殊的完全二叉树。它的特殊性只体现在一点，那就是&lt;strong&gt;「父节点的权值不大于儿子的权值（小顶堆）」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeX9kJPsfuDyDDQX2XytZI477m9temKwibibO9Puw0L3SxOrPcoLiaR2UXUGIzY5JcJXdTuUjDwRm0icQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;730&quot;/&gt;（一个小顶堆）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这句话需要大家记住，一切的一切都源于上面这句话。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于&lt;strong&gt;「父节点的权值不大于儿子的权值（小顶堆）」&lt;/strong&gt;，那么很自然能推导出树的根节点就是最小值。这就起到了堆的&lt;strong&gt;「取极值」&lt;/strong&gt;的作用了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那动态性呢？二叉堆是怎么做到的呢？&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;出堆&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如，我将树的根节点出堆，那么根节点不就空缺了么？我应该将第二小的顶替上去。怎么顶替上去呢？一切的一切还是那句话&lt;strong&gt;「父节点的权值不大于儿子的权值（小顶堆）」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果仅仅是删除，那么一个堆就会变成两个堆了，问题变复杂了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6976744186046512&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeX9kJPsfuDyDDQX2XytZI4z1pE7ZTeHSSM57UXPbC1wpBgouJjBl36JFANCAriciawrwaoVtiaicQ6sw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;688&quot;/&gt;（上图出堆之后会生成两个新的堆）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个常见的操作是，把根结点和最后一个结点交换。但是新的根结点可能不满足 &lt;strong&gt;「父节点的权值不大于儿子的权值（小顶堆）」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图，我们将根节点的 2 和尾部的数字进行交换后，这个时候是不满足堆性质的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8650137741046832&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeX9kJPsfuDyDDQX2XytZI4AM5F96rwypfCsOmfibAibbqTfUKJibFqs8GFibLc8SN9TO7zCPFhOefXXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;726&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候，其实只需要将新的根节点下沉到正确位置即可。这里的&lt;strong&gt;「正确位置」&lt;/strong&gt;，指的还是那句话&lt;strong&gt;「父节点的权值不大于儿子的权值（小顶堆）」&lt;/strong&gt;。如果不满足这一点，我们就继续下沉，直到满足。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道根节点往下下沉的过程，其实有两个方向可供选择，是下沉到左子节点？还是下沉到右子节点？以小顶堆来说，答案应该是下沉到较小的子节点处，否则会错失正确答案。以上面的堆为例，如果下沉到右子节点 4，那么就无法得到正确的堆顶 3。因此我们需要下沉到左子节点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1128048780487805&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeX9kJPsfuDyDDQX2XytZI4O1YhIT4Op0XYndgOlE7Cq2NZORdc60MZeYxYpmicn9wUpgAnWQ6QZ2g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;656&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下沉到如图位置，还是不满足 &lt;strong&gt;「父节点的权值不大于儿子的权值（小顶堆）」&lt;/strong&gt;，于是我们继续执行同样的操作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7901907356948229&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeX9kJPsfuDyDDQX2XytZI4VHRdOCRd89XFevOuibgJaBstCe89mlwhm7ZYzv5Rl25aeKes7BKdmRQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;734&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有的同学可能有疑问。弹出根节点前堆满足堆的性质，但是弹出之后经过你上面讲的下沉操作，一定还满足么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是肯定的。这个也不难理解。由于最后的叶子节点被提到了根节点，它其实最终在哪是不确定的，但是经过上面的操作，我们可以看出：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;其下沉路径上的节点一定都满足堆的性质。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不在下沉路径上的节点都保持了堆之前的相对关系，因此也满足堆的性质。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此&lt;strong&gt;「弹出根节点后，经过上面的下沉操作一定仍然满足堆的性质」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;时间复杂度方面可以证明，下沉和树的高度成正相关，因此时间复杂度为 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;logh&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -694 1836 899&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;6C&quot; d=&quot;M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(298, 0)&quot;&gt;&lt;path data-c=&quot;6F&quot; d=&quot;M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(783, 0)&quot;&gt;&lt;path data-c=&quot;67&quot; d=&quot;M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1260, 0)&quot;&gt;&lt;path data-c=&quot;68&quot; d=&quot;M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;，其中 h 为树高。而由于二叉堆是一颗完全二叉树，因此树高大约是 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;logN&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -694 2148 899&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;6C&quot; d=&quot;M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(298, 0)&quot;&gt;&lt;path data-c=&quot;6F&quot; d=&quot;M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(783, 0)&quot;&gt;&lt;path data-c=&quot;67&quot; d=&quot;M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1260, 0)&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;，其中 N 为树中的节点个数。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;入堆&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;入堆和出堆类似。我们可以直接往树的最后插入一个节点。和上面类似，这样的操作同样可能会破坏堆的性质。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;之所以这么做的其中一个原因是时间复杂度更低，因为我们是用数组进行模拟的，而在数组尾部添加元素的时间复杂度为 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;O(1)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 2041 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1652, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8455882352941176&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeX9kJPsfuDyDDQX2XytZI43m84ZSicOGGr1B9famuhJbzKWNfSPJPPpGibMOvDiayuXLFzXF1n0XboQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;816&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次我们发现，不满足堆的节点目前是刚刚被插入节点的尾部节点，因此不能进行下沉操作了。这一次我们需要执行&lt;strong&gt;「上浮操作」&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;叶子节点是只能上浮的（根节点只能下沉，其他节点既可以下沉，又可以上浮）&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和上面基本类似，如果不满足堆的性质，我们将其和父节点交换（上浮），继续这个过程，直到满足堆的性质。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5637065637065637&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeX9kJPsfuDyDDQX2XytZI4j0GnnhSmiaa3aqJGj7dHI9cLGwa5zndrLToazmRqUKkf9v1ZnqQhv2Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1036&quot;/&gt;(第一次上浮，仍然不满足堆特性，继续上浮)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7482185273159145&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeX9kJPsfuDyDDQX2XytZI480PNQnibrB66l0kJzwHqwbIyODnMGXD3IGJyJ1xzNsefSHWibniaiaU7Pg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;842&quot;/&gt;（满足了堆特性，上浮过程完毕）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过这样的操作，其还是一个满足堆性质的堆。证明过程和上面类似，不再赘述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，由于上浮&lt;strong&gt;「只需要拿当前节点和父节点进行比对就可以了，」&lt;/strong&gt; 由于省去了判断左右子节点哪个更小的过程，因此更加简单。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;实现&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于完全二叉树来说使用数组实现非常方便。因为：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果节点在数组中的下标为 i，那么其左子节点下标为 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;2 \times i&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -666 2067.4 677&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(722.2, 0)&quot;&gt;&lt;path data-c=&quot;D7&quot; d=&quot;M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1722.4, 0)&quot;&gt;&lt;path data-c=&quot;69&quot; d=&quot;M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;，右节点为 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;2 \times i&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -666 2067.4 677&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(722.2, 0)&quot;&gt;&lt;path data-c=&quot;D7&quot; d=&quot;M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1722.4, 0)&quot;&gt;&lt;path data-c=&quot;69&quot; d=&quot;M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;+1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果节点在数组中的下标为 i，那么父节点下标为 i//2（地板除）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这要求你的&lt;strong&gt;「数组从 1 开始存储数据」&lt;/strong&gt;。如果不是，上面的公式其实微调一下也可以达到同样的效果。不过这是一种业界习惯，我们还是和业界保持一致比较好。从 1 开始存储的另外一个好处是，我们可以将索引为 0 的位置空出来存储诸如&lt;strong&gt;「堆大小」&lt;/strong&gt;的信息，这是一些大学教材里的做法，大家作为了解即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图所示是一个完全二叉树和树的数组表示法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0925553319919517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeX9kJPsfuDyDDQX2XytZI4FSEUvA5PJhFtQL3XPicEx3MibGyoaqepWUGicQUfzpV7bZuKmXnPtsM5g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;497&quot;/&gt;（注意数组索引的对应关系）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;形象点来看，我们可以可以画出如下的对应关系图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.4859649122807017&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeX9kJPsfuDyDDQX2XytZI4ov1XWCEiczvXkOBaHgJ96Meia3icHWLnrtS8TDvhJrLGXIVhiaum0iccibUg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;570&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一来，是不是和上面的树差不多一致了？有没有容易理解一点呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面已经讲了上浮和下沉的过程。刚才也讲了父子节点坐标的关系。那么代码就呼之欲出了。我们来下最核心的&lt;strong&gt;「上浮」&lt;/strong&gt;和&lt;strong&gt;「下沉」&lt;/strong&gt;的代码实现吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;伪代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// x 是要上浮的元素，从树的底部开始上浮&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;shift_up&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (x &amp;gt; &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; h[x] &amp;gt; h[x / &lt;span&gt;2&lt;/span&gt;]) {&lt;br/&gt;    &lt;span&gt;//  swqp 就是交换数组两个位置的值&lt;/span&gt;&lt;br/&gt;    swap(h[x], h[x / &lt;span&gt;2&lt;/span&gt;]);&lt;br/&gt;    x /= &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// x 是要下沉的元素，从树的顶部开始下沉&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;shift_down&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (x * &lt;span&gt;2&lt;/span&gt; &amp;lt;= n) {&lt;br/&gt;    &lt;span&gt;// minChild 是获取更小的子节点的索引并返回&lt;/span&gt;&lt;br/&gt;    mc = minChild(x);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (h[mc] &amp;lt;= h[x]) &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    swap(h[x], h[mc]);&lt;br/&gt;    x = mc;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里 Java 语言为例，讲述一下代码的编写。其他语言的二叉堆实现可以去我的&lt;strong&gt;「刷题插件 leetcode-cheatsheet」&lt;/strong&gt; 中获取。插件的获取方式在公众号&lt;strong&gt;「力扣加加」&lt;/strong&gt;里，回复插件即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; java.util.Arrays;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.Comparator;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 用完全二叉树来构建 堆&lt;br/&gt; * 前置条件 起点为 1&lt;br/&gt; * 那么 子节点为  i &amp;lt;&amp;lt;1 和 i&amp;lt;&amp;lt;1 + 1&lt;br/&gt; * 核心方法为&lt;br/&gt; * shiftdown 交换下沉&lt;br/&gt; * shiftup 交换上浮&lt;br/&gt; * &amp;lt;p&amp;gt;&lt;br/&gt; * build 构建堆&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Heap&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; queue[];&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Heap&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; initialCapacity)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (initialCapacity &amp;lt; &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException();&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.queue = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[initialCapacity];&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Heap&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] arr)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        size = arr.length;&lt;br/&gt;        queue = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[arr.length + &lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; val : arr) {&lt;br/&gt;            queue[i++] = val;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;shiftDown&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; temp = queue[i];&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; ((i &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;) &amp;lt;= size) {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; child = i &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;// child!=size 判断当前元素是否包含右节点&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (child != size &amp;amp;&amp;amp; queue[child + &lt;span&gt;1&lt;/span&gt;] &amp;lt; queue[child]) {&lt;br/&gt;                child++;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (temp &amp;gt; queue[child]) {&lt;br/&gt;                queue[i] = queue[child];&lt;br/&gt;                i = child;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        queue[i] = temp;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;shiftUp&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; i)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; temp = queue[i];&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; ((i &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;) &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (temp &amp;lt; queue[i &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;]) {&lt;br/&gt;                queue[i] = queue[i &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;                i &amp;gt;&amp;gt;= &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        queue[i] = temp;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;peek&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; res = queue[&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; res;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;pop&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; res = queue[&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;&lt;br/&gt;        queue[&lt;span&gt;1&lt;/span&gt;] = queue[size--];&lt;br/&gt;        shiftDown(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; res;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;push&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; val)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (size == queue.length - &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;            queue = Arrays.copyOf(queue, size &amp;lt;&amp;lt; &lt;span&gt;1&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;        queue[++size] = val;&lt;br/&gt;        shiftUp(size);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;buildHeap&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = size &amp;gt;&amp;gt; &lt;span&gt;1&lt;/span&gt;; i &amp;gt;= &lt;span&gt;0&lt;/span&gt;; i--) {&lt;br/&gt;            shiftDown(i);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; arr[] = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[]{&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;};&lt;br/&gt;        Heap heap = &lt;span&gt;new&lt;/span&gt; Heap(arr);&lt;br/&gt;        heap.buildHeap();&lt;br/&gt;        System.out.println(heap.peek());&lt;br/&gt;        heap.push(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (heap.size &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; num = heap.pop();&lt;br/&gt;            System.out.printf(num + &lt;span&gt;&quot;&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;小结&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆的实现有很多。比如基于链表的跳表，基于数组的二叉堆和基于红黑树的实现等。这里我们详细地讲述了二叉堆的实现，不仅是其实现简单，而且其在很多情况下表现都不错，推荐大家重点掌握二叉堆实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于二叉堆的实现，核心点就一点，那就是始终维护堆的性质不变，具体是什么性质呢？那就是 &lt;strong&gt;「父节点的权值不大于儿子的权值（小顶堆）」&lt;/strong&gt;。为了达到这个目的，我们需要在入堆和出堆的时候，使用上浮和下沉操作，并恰当地完成元素交换。具体来说就是上浮过程和比它大的父节点进行交换，下沉过程和两个子节点中较小的进行交换，当然前提是它有子节点且子节点比它小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于堆化我们并没有做详细分析。不过如果你理解了本文的入堆操作，这其实很容易。因此堆化本身就是一个不断入堆的过程，只不过&lt;strong&gt;「将时间上的离散的操作变成了一次性操作」&lt;/strong&gt;而已。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;预告&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文预计分两个部分发布。这是第一部分，后面的内容更加干货，分别是&lt;strong&gt;「三个技巧」&lt;/strong&gt;和&lt;strong&gt;「四大应用」&lt;/strong&gt;。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;多路归并&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;固定堆&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事后小诸葛&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;topK&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;带权最短距离&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;因子分解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;堆排序&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个主题是专门教你怎么解题的。掌握了它，力扣中的大多数堆的题目都不在话下（当然我指的仅仅是题目中涉及到堆的部分）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家对此有何看法，欢迎给我留言，我有时间都会一一查看回答。更多算法套路可以访问我的 LeetCode 题解仓库：https://github.com/azl397985856/leetcode 。目前已经 37K star 啦。大家也可以关注我的公众号《力扣加加》带你啃下算法这块硬骨头。&lt;/span&gt;&lt;img data-ratio=&quot;0.5555555555555556&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTfxVVL24QAkhAH6jz59gX6V38gUibAy7Qth9CC0VibNIf4fMCxfuaxLicDjRdNopThzeO2HMmAkoBUVA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;爱心三连击&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;1.看到这里了就点个在看支持下吧，你的&lt;strong&gt;在看&lt;/strong&gt;是我创作的动力。&lt;/p&gt;&lt;p&gt;2.关注公众号&lt;strong&gt;力扣加加&lt;/strong&gt;，带你啃下算法这块硬骨头！&lt;strong&gt;加个星标&lt;/strong&gt;，不错过每一条成长的机会。&lt;/p&gt;&lt;p&gt;3.如果你觉得本文的内容对你有帮助，就帮我&lt;strong&gt;转发&lt;/strong&gt;一下吧。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Reference&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;堆标签: &lt;span&gt;https://leetcode-cn.com/tag/tree/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;力扣刷题插件 leetcode-cheatsheet: &lt;span&gt;https://chrome.google.com/webstore/detail/leetcode-cheatsheet/fniccleejlofifaakbgppmbbcdfjonle/related?hl=zh-CN&amp;amp;authuser=0&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;原来状态机也可以用来刷 LeetCode？: &lt;span&gt;https://lucifer.ren/blog/2020/01/12/1262.greatest-sum-divisible-by-three/&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>