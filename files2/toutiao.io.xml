<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>19586f11ffd15d2738877513e94971fb</guid>
<title>一个技术团队leader的搭建私有知识库避坑经验分享</title>
<link>https://toutiao.io/k/o3dptn4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;container app-preview post-body&quot;&gt;
  &lt;div class=&quot;preview&quot;&gt;&lt;p&gt;作为一名技术团队的管理者，团队整体规模达到80人，对团队人才培养与团队搭建有些所思所得，现在分享下。
1、需求的产生
开始带团队的时候，对​​知识库​​完全没有概念，公司内也没有什么分享整理的系统的解决方法，大多数都是些成word或者excel，甚至文本文档，然后在svn上的某一个文件夹一丢，就算是知识库了。但是两年过后，就发现这种杂乱无序的知识库分享方式，有很多缺点，比如快速查找、文档有错的时候不能同步更新等等。 。
基于我遇到的情况，公司内部要搭建统一管理的知识库，知识库要能够实实在在的帮助到团队的每一个需要帮助的人，而不仅仅是一个形式，马马虎虎应付了事的知识库资料是没有意义。
然后，整理了我的想法思路需求：
• 内容划分：将知识或者信息分类，形成文档集或者知识库。从知识信息的用途来分为：公司制度管理类、通用技术类、市场知识类、产品规范与案例类、入职培训类等；&lt;/p&gt;

&lt;p&gt;• 信息安全：对于公司内部信息，特别是技术、市场相关的信息，有非常机密敏感的内容，一定不能是SaaS，要支持本地化部署；一定要有权限化管理，有效的信息分级控制；&lt;/p&gt;

&lt;p&gt;• 内容形式：B/S模式，支持富文本、支持演示文稿、支持脑图、支持画图等；&lt;/p&gt;

&lt;p&gt;• 快速检索：要支持内容级的检索，不能只是搜索题目，一定要能支持内容搜索；&lt;/p&gt;

&lt;p&gt;• 形成交流：对内容可以评价与评论，这样更加容易形成团队内部交流，最好是类似于论坛的形式，相关的人都可以发表相关的意见和建议；&lt;/p&gt;

&lt;p&gt;• 易于分享：能对分享的范围进行控制，可以对分享的时间有效性、支持密码、内部账号等；&lt;/p&gt;

&lt;p&gt;• 简易操作：交付一定要简单，最好支持便捷的用户认证等；&lt;/p&gt;

&lt;p&gt;• 成本控制：因为公司人数逐步在增加，最好是成本越低越好，不能有人数与功能的限制；&lt;/p&gt;

&lt;p&gt;• 易于扩展：最好是完全开源，容易扩展，因为我们内部有个需求，是日常项目执行的过程中，能把日常项目中的某些文档形成知识积累（产品经理的​​需求分析​​，prd等），那么要在知识库上可以提供便捷的二开；&lt;/p&gt;

&lt;p&gt;2、技术选型
其实从交付上最理想的是语雀和Thoughts（teambition的内容管理），虽然也有腾讯文档与石墨文档等，其实从需求层面都可以使用，但是更多的侧重于个人使用，但是这些都是SaaS的，​​私有化​​部署贵的吓人。
然后找了支持本地化部署的MRdoc，但是这个版本是python的，我们的技术团队都是java，技术栈不对。然后也看了开源wiki，根据项目组的实际情况，修改代码，实现自己想要的效果。推荐使用dokuwiki，简洁、可自行性极高、支持权限、版本持续更新重。最大的的缺点是，编辑文档的操作性比较不友好。
最后我们选型的是 “​​无忧·企业文档​​”，对我们企业需求相当匹配。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/attachment/089f787eb4c540d19191a0423c476710/w600&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;

&lt;p&gt;git开源地址：gitee.com/software-minister/jvs-knowledge-lib/tree/master&lt;/p&gt;

&lt;p&gt;PC端演示环境：
无忧·企业文档-微信扫码直接登录  knowledge.bctools.cn/#/index&lt;/p&gt;

&lt;p&gt;从开始看文档到部署完成，花了半天时间，文档支持还是比较充足。
部分图片：&lt;img src=&quot;https://img.toutiao.io/attachment/119710fff0124df1b445b8120029ce17/w600&quot; alt=&quot;file&quot;/&gt;&lt;img src=&quot;https://img.toutiao.io/attachment/ff7ab8847a8e4c5d89750f037e506cf1/w600&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、最后总结
• 团队一旦达到一定规模，内部信息流动的有效性降低，特别是在技能的传递与知识的沉淀上存在明显的问题。一定要有配套的机制进行技术内容的沉淀与知识的传递。&lt;/p&gt;

&lt;p&gt;• 一定要有所分工与负责人，内容的整理一定是要有经验，对公司的背景特点有非常深刻认识的。公司制度由人事管理、​​通用技术​​有技术部技术专家管理、市场知识类有市场总监负责、产品需求类由产品总监负责等。&lt;/p&gt;

&lt;p&gt;• 知识库的建立到一定程度之后，写的分享就会实实在在的帮助到新人或者其他成员，逐渐的，团队也就能感受到知识库的作用，但是这个过程比较漫长。个人认为分享知识，要调动所有人的积极性是不可能的事情，唯有负责人+强制+鼓励并行，才能真正的建立起知识库。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>083260150feefd9e01dfc9ef29fe082a</guid>
<title>网络字节序列-大端序和小端序</title>
<link>https://toutiao.io/k/ohy7j47</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引子&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485988&amp;amp;idx=1&amp;amp;sn=efad5a030bc0a933ac5af2ee09f3c6c4&amp;amp;chksm=fafde08acd8a699c198d0d65c413273f05f2796cfd873160c2ba81ed3f33aebfaccb62234cb7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《一个http请求进来都经过了什么(2021版)》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《一个http请求进来都经过了什么(2021版)》&lt;/a&gt;到&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486103&amp;amp;idx=1&amp;amp;sn=943c5b7f3558df78164321806f273c8f&amp;amp;chksm=fafde039cd8a692f86f0ac97b0e1e05ece075de3e4f33e6a5ec90b269c51aed1963ff3107e0e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《懂得三境界-使用dubbo时请求超过问题》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《懂得三境界-使用dubbo时请求超过问题》&lt;/a&gt;，再到&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486166&amp;amp;idx=1&amp;amp;sn=08a24c175c02a4b146dc52088d410599&amp;amp;chksm=fafde078cd8a696e616aebcb72aeef444e1e0008bf950a368933195f13c0a268face0d3ee371&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《接下来一段时间会对大家进行网络通信的魔鬼训练-理解socket》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《接下来一段时间会对大家进行网络通信的魔鬼训练-理解socket》&lt;/a&gt;和&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486186&amp;amp;idx=1&amp;amp;sn=f21e17b21beb4c99cef0e076071ac859&amp;amp;chksm=fafde044cd8a69526aa3ec9edbe71ea5aa41de2ef236494201dc2f20701ed8abc6be1a72344f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《深入理解MQ生产端的底层通信过程-理解channel》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《&lt;span&gt;深入理解MQ生产端的底层通信过程-理解channel&lt;/span&gt;&lt;span&gt;》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，我的思路是一篇篇的深入网络通信底层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;到了通信底层，必须要了解的一个知识是网络字节序列。这个东东，99%以上的开发中都用不到。but:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先这个问题比较好理解；第二，要手动处理二进制流的话就不得不考虑，否则可能测试的时候完全没有发现问题，到线上出现诡异事件；第三，这个知识如此之重要，我记得大学的时候课本上也讲过。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;字节序列的历史&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;字节序列分成大端序（big endian或称大尾序）和小端序（little endian或称小尾序）。那为什么大小尾序会称为大小端序呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;术语“little endian(小端)”和“big endian(大端)”出自Swift的《格列佛游记》（Gulliver&#x27;s Trabels）一书，其中交战的两个派别无法就应该从哪一端（小端还是大端）打开一个半熟的鸡蛋达成一致。就像鸡蛋的问题一样，选择何种字节顺序没有技术上的理由。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;“小”国和“大”国，这两大强国在过去三年一直在苦战。战争开始是由于：我们大家都认为，吃鸡蛋前，原始的方法是打破鸡蛋较大的一端，可是“小”国的祖父小时候吃鸡蛋，一次按古法打鸡蛋是碰巧将一个手指弄破了，因此他的父亲，当时的皇帝，就下了一道敕令，命令全体臣民吃鸡蛋时打破鸡蛋较小的一端，违令者重罚。老百姓们对这项命令极为反感。历史告诉我们，由此曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。这些叛乱大多都是由“大”国的人们煽动起来的。因为叛乱平息后，流亡的人总是逃到“大”国去寻救避难，“大”国的人口就增加了。据估计，先后几次有11000人情愿受死也不肯去打破鸡蛋较小的一端。关于这一争端，曾出版过几百本大部著作，不过大端派的书一直是受禁的，法律也规定该派的任何人不得做官。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Swift是在讽刺英国和法国之间的持续的冲突。Danny Cohen，一位网络协议的早期开创者，第一次使用这两个术语来指代字节顺序，后来这个术语被广泛接纳了。因为产生两种序列的标准和Swift讲的故事如出一辙：几十年前，两强互相看不惯，摩托罗拉(Motorala)使用大端序，英特尔(Intel)使用小端序。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;大端序和小&lt;strong&gt;&lt;span&gt;端&lt;/span&gt;&lt;/strong&gt;序的理解&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;数值例如0x2266使用两个字节储存：高位字节是0x22，低位字节是0x66。&lt;/p&gt;&lt;blockquote/&gt;&lt;p&gt;0x1234567大端字节序和小端字节序的写法如下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;200&quot; data-backw=&quot;400&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibpMFn6yJ42PkM6FDR6NNvsNKyHic0WYn72S9OeWvJMgrIgPvGKscDLf9tgN5lIttJt35Gp1CdsliaA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p&gt;打个比方：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.568&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlibpMFn6yJ42PkM6FDR6NNvspUShpCYV4Tp2Kmgpic2OuibiaJBicB3FicnIrZ1Wno4Z8WJeT9qwGGbkE6Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;&lt;p&gt;计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;结论：网络字节序列传输采用大端序。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;标准不同引发的问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2016年我做了一款用于处理图片位置被旋转的方法和工具，并成功申请了专利。起因是这样的：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;做过一个项目，有天运营打电话过来说：“有个用户上传了头像到咱们应用上，结果头像是倒置的。”我去后台一看果然是和练倒立一样倒置着脑袋。我们自己测试的时候，从来没有发生这种问题。但是用户所有的声音都是有道理的。当时我们动员了公司所有人用我们的应用看看有没有类似的情况。终于在一个三星的手机上重现了这个问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;原来照片属性中是存储了旋转信息的，我们之所以看到照片显示的位置都很正确，其实是iphone系统，还有大部分的安卓系统发现图片被旋转了之后都有将图片旋转回来的处理。但是在部分android系统中，却没有做这种处理。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.32470334412081986&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibpMFn6yJ42PkM6FDR6NNvsT358Kk1c1sfxibFKicYLN1PTKBibmLqld7Gn8LAGerse0xY1ga9AzU1KQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;927&quot;/&gt;&lt;/p&gt;&lt;p&gt;上面两张图片，每张图片被旋转了旋转了8个角度。这里面只有它们的EXIF信息里的orientation值不同。EXIF信息是数码相机的拍摄信息，在压缩文件的格式中只有JPEG格式的储存了这种信息。它可以有1-8的8个值。分别对应于旋转0度，水平翻转，旋转180度，垂直翻转，顺时针90度—+水平翻转，顺时针90度，顺时针90度+垂直翻转，逆时针90度。这时就会发生这种情况。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;经过调查发现目前并没有现成的java类库来做这件事情，基本都是从系统层面就解决了这个问题。确实有图片处理的类库，可是添加一个大jar包进来就只为获取图片的旋转信息，jar包可有将近一个MB呢。所以咱们尽量还是自己写工具类来解决问题吧。因为这种解决这种问题不涉及其他的处理，这时只用这样一个针对特定问题的工具类增加了代码的可读性，减少了服务器负担。&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;实现原理简单可以理解为：存储图片的旋转信息都是放在EXIF信息里。所以只要找到EXIF信息，根据EXIF信息里的旋转方向将图片旋转回来即可。当然实际上各种考虑要复杂的多。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;后记&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;还记得&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485790&amp;amp;idx=1&amp;amp;sn=28d1275aec18350f7627e81bbdab4dfc&amp;amp;chksm=fafde3f0cd8a6ae60b893b6998175db1c20e96328a5721a1b00a2d7b231d141ba7e85f02c6f0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《面试中一个暴露能力等级的问题》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《面试中一个暴露能力等级的问题》&lt;/a&gt;那篇文章吗？相信只要在工作中遇到问题仔细思考，不放过，一定能说出让面试官眼前一亮的故事。&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6d39e299e619d6434e0f636dcf6bbbcf</guid>
<title>干货 | 分布式数据库TiDB在携程的实践</title>
<link>https://toutiao.io/k/67t945m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single js_wx_tap_highlight wx_tap_card&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left&quot; aria-describedby=&quot;js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MjM5MDI3MjA5MQ==&amp;amp;action=getalbum&amp;amp;album_id=2170120724240302083#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;2170120724240302083&quot; data-tag_source=&quot;3&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#数据库&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;1个&lt;span class=&quot;weui-hidden_abs&quot;&gt;内容&lt;/span&gt;&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:0.title1&quot;&gt;&lt;p&gt;&lt;strong&gt;作者简介&lt;/strong&gt;&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Army，携程数据库专家，主要负责分布式数据库运维及研究。&lt;/p&gt;&lt;p&gt;Keira，资深数据库工程师，主要负责MySQL和TiDB运维。&lt;/p&gt;&lt;p&gt;Rongjun，携程大数据架构开发，专注离线和实时大数据产品和技术。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程自2014年左右开始全面使用MySQL数据库，随着业务增长、数据量激增，单机实例逐渐出现瓶颈，如单表行数过大导致历史数据查询耗时升高，单库容量过大导致磁盘空间不足等。为应对这些问题，我们采取了诸多措施如分库分表的水平拆分、一主多从读写分离、硬件SSD升级、增加前端Redis缓存等，但同时也使得整个业务层架构更加复杂，且无法做到透明的弹性，因此开始将目光转移到分布式数据库以解决这些痛点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;近年来受到Spanner&amp;amp;F1的启发，基于CAP理论和Paxos、Raft协议作为工程实现的分布式数据库得到了蓬勃发展，从硅谷的CockroachDB到国产的TiDB都在社区产生了很强的影响力。携程也对这些产品从社区活跃度、用户规模、易用性等多个方面做了调研，最终选择了国产的TiDB。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TiDB是一个开源的NewSQL数据库，支持混合事务和分析处理（HTAP）工作负载，兼容大部分MySQL语法，并且提供水平可扩展性、强一致性和高可用性。主要由PingCAP公司开发和支持，并在Apache 2.0下授权。2018年11月我们开始TiDB的POC以及与携程现有运维平台的整合，2019年1月第一个线上应用正式接入，最初的目标只是保证数据库的可用性以及可以存储足够多的关系型数据。随着TiDB快速迭代，越来越多的功能进入社区，如HATP特性，让我们不局限于最初的目标，开始了新的探索。本文将介绍TiDB在携程业务场景中的运维实践，希望对读者有所帮助和参考。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、架构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程内部历时1年，代号为“流浪地球”的机房级故障演练，验证了IDC级别故障容灾能力。我们将TiDB的三个副本分布在三个数据中心，保证在单中心故障时不影响对外服务，同时数据一致性也不受影响，并在tidb-server层实现了自动探活以及自动故障切换，让RPO等于0，RTO小于30S。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们先来了解一下TiDB的整体架构（如图1-1），再结合携程的场景来部署。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5244479495268138&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlVOWWWXtR6ckO6HmJBBpeTPlCmSrVx9L6icZxZsz2SsS5ujT9MXDqvvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1-1 TiDB的整体架构图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从TiDB的架构图我们可以看到，得益于组件 PD 和 TiKV 都通过 Raft 实现了数据的容灾，原生就提供了多IDC的部署能力，和 Google Spanner 采用原子钟方案不同的是，TiDB 采用了 PD 进行单点全局统一授时的 Timestamp方案。TiDB 中的每个事务都需要向 PD leader 获取 TSO，当 TiDB 与 PD leader 不在同一个数据中心时，它上面运行的事务也会因此受网络延迟影响。目前携程的跨 IDC 延迟在 0.5-2ms之间 ，属于可接受的延迟范围。配置三数据中心时，需要对相应的TiKV和PD的label配置规则，这样PD在调度re&lt;/span&gt;&lt;span&gt;gion副本时会根据标签属性在每一个机房都拥有一份全量数据。具体的一个配置示例，如图1-2：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.32636469221835074&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlnicXUdMNyYRCvnRBtibsOdLrj0fcAicjCcudyzFLJ3HUcUKFCSwiadssuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;861&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1-2 TiDB在携程的部署架构和配置&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种部署架构的优点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;所有数据的副本分布在三个数据中心，具备IDC级别的高可用和容灾能力&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;任何一个数据中心失效后，不会产生任何数据丢失 (RPO = 0)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;任何一个数据中心失效后，其他两个数据中心会自动发起 leader election，并在合理长的时间内（通常情况 20s 以内）自动恢复服务&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、应用场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TiDB目前已经应用到携程的多个业务场景，包括风控、社区、营销、搜索、酒店等。这里选取两个比较典型的使用案例——国际业务CDP平台和酒店结算业务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.1 国际业务CDP平台&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为Trip数据来源比较广泛，既有自身数据也有外部数据；数据形式也非常多样化，既有结构化数据，也有半结构化和非结构化数据；数据加工形式既有离线数据处理，也有在线数据处理，因此国际业务构建了CDP平台以解决加工这些数据，形成业务系统、运营、市场需要并且可以理解的数据和标签，具体可以阅读往期文章：《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDI3MjA5MQ==&amp;amp;mid=2697271936&amp;amp;idx=2&amp;amp;sn=72d5a081eb34f37a3bd3bdc9e1758b88&amp;amp;chksm=8376e5b4b4016ca2a37435cc855ac9a119a1546821aff30ecef51631c0d14ee31e5ee6695e39&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;携程国际业务动态实时标签处理平台实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;携程国际业务动态实时标签处理平台实践&lt;/a&gt;》。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Ti&lt;/span&gt;&lt;span&gt;DB在其中主要承担存储业务持久化的标签以及内部SOA调用的查询服务。查询分为UID等维度的基础信息查询、订单订阅基础信息查询的OLTP，以及EDM\Marketing等人群的OLAP查询。整个CDP平台的架构如图2-1：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.47012302284710017&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlQknvoGVddYSFXx1kxiaWEPornWQNjegMaX0P3yl3AAEc8AsicLWuiapEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1138&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2-1 CDP平台架构图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体的数据处理，历史全量数据通过数据批处理引擎（如Spark）转换完成以后批量写入到数据持久化存储引擎（TiDB），增量数据业务应用以消息的形式发送到Kafka或者QMQ消息队列，通过实时DAG处理完后持久化到存储引擎（TiDB）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;持久标签访问的主要场景有两个，一种是跟现有CRM系统对接，在线根据业务的特征圈选符合条件的业务数据，这种场景的查询条件不固定，返回结果集因筛选条件而定，对于数据存储引擎的数据计算和处理能力要求比较高，即我们在数据处理领域经常提到的OLAP的场景。&lt;/span&gt;&lt;span&gt;另一种场景是线上业务根据前端传入的业务标签相关的唯一标识来查询是否满足特定业务要求，或者返回指定特征值，满足业务处理的需要，需要毫秒级响应，对应的是OLTP场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于标签的多样性，有查询记录的字段多达60个，查询条件是60个字段的随机组合，无法通过传统数据库层的Index来提高查询效率，经典的方案是OLTP和OLAP分离，但数据会存储多份，多数据源的数据一致性是一个很大的挑战。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于这种场景，我们开启了TiDB的TiFlash，TiFlash 是 TiDB HTAP 形态的关键组件，它是 TiKV 的列存扩展，在提供了良好的隔离性的同时，也兼顾了强一致性。列存副本通过 Raft Learner 协议异步复制，但是在读取的时候通过 Raft 校对索引配合 MVCC 的方式获得 Snapshot Isolation 的一致性隔离级别。&lt;span&gt;TiFlash&lt;/span&gt; MPP模式如图2-2。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.51875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlSAMeqJap3J7C4icicsj0qZ0bWHgNeKYxeqM6E1w4NTZBKnBKrmv2icCQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2-2 TiDB MPP模式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种架构很好地解决了 HTAP 场景的隔离性以及列存同步的问题，开启之后几个典型查询性能提升：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;TiFlash MPP提升，20s -&amp;gt; 1s&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;Set @@session.tidb_allow_mpp=1;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;Set @@session.tidb_enforce_mpp=0;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.12812248186946013&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlaicH70pms48eA0u6kAl6avI4Bqzyq7O25jOElCp7StJ2nTUn665XUAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1241&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;TiFlash 列裁剪，16.9s -&amp;gt; 2.8s&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;Set @@session.tidb_allow_mpp=1;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;Set @@session.tidb_enforce_mpp=0;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;Set session tidb_isolation_read_engines =’tidb,tiFlash’;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.07661290322580645&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlCM8th2Kwk5ehiblHuqrvVpNG3SfNc4HM2WLwflm8icMecLVVCA51JSHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.2 酒店结算业务&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程酒店结算业务全库6T，单服务器存储6T全量数据有很大挑战。常规的方法是用分库分表的方式来减少实例数据量及压力，但分库分表的维度很难确定，无论从酒店维度还是供应商维度都无法避免跨片的查询，给程序的开发带来了很大的困难，并且大部分查询都是聚合运算，因此我们尝试迁移到TiDB。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前最大的表存储了28亿条数据，读写已完全切换到TiDB。具体所使用的部署模式和上节提到的国际业务CDP平台类似，同样是开启了TiDB的TiFlash来加速查询的性能，具体的性能如图2-3：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5172995780590718&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlVQiawmS0L6MbvEGbLjbTVuL7hbsEibzzqMgnbBSqTUSrOcIhdhF9ugdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1185&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2-3 酒店结算性能监控&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、一些问题的实践&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.1 参数不合理导致的性能问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分布式数据库有别于传统单机，通常MySQL遇到性能问题时可以快速定位是由于网络抖动、SQL缺失索引还是请求次数激增等原因导致的，但分布式的&lt;span&gt;Ti&lt;/span&gt;&lt;span&gt;DB&lt;/span&gt;&lt;/span&gt;&lt;span&gt;组件众多，各个组件之间的网络通信、某个组件资源不足、SQL复杂等都可能是导致出现性能问题的原因。目前官方提供了问题导图，方便根据不同的场景尽快定位原因。这里给出一个具体的案例，总结了一个典型问题的排查思路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;国际业务集群使用官方默认配置的集群上线测试时，发现写入耗时高达秒级，且耗时波动较大。来自应用端的监控（纵坐标单位为毫秒）,如图3-1：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7613636363636364&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlSibFtzZUTujYhHM0LjJAuWwpQ3Rnb74hBuS6NA4fKSJRmSd2EtdtaWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;528&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3-1 IBA写入响应监控&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据Pingcap的导图发现scheduler command duration的时间约等于事务的prewrite时间（纵坐标单位为秒），可以看出scheduler-worker不足。如图3-2：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.40339425587467365&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlrTV5ahKCibPuUicKpC8HGWXZ4HSEKC6VZc5D1MmxrdSvibr4xGdZsJBFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;766&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3-2 scheduler command duration的时间&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以我们做了如下的调整：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;调整完成后来自应用端的监控（纵坐标单位为毫秒），如图3-3，红色箭头处是参数调整的时间点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4430379746835443&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlxhVWz64nt2icsCnOMmuibWnmVUPuT56XFTqKdOacxtZqkQqqTojgnEIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;711&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3-3 IBA写入响应监控&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;默认配置并非最佳配置，需要根据服务器硬件、使用场景不断调试并最终固化为每个集群甚至所有集群的最佳实践配置；根据PingCAP提供的问题导图，逐步定位具体哪个组件哪个方面存在瓶颈，我们同时也在进一步开发一键定位工具，能更快速的定位性能瓶颈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.2 分布式带来的自增列问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;含自增列的表，在自增列不强制赋值的情况下，insert语句报主键冲突：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;报错SQL：INSERT INTO `xxx_table ` (`id, `name`, `tag`, `comment`, `creator`) VALUES (?, ?, ?, ?, ?)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;报错内容：com.mysql.jdbc.exceptions.jdbc4.MySQLIntegrity&lt;/span&gt;&lt;span&gt;Constraint&lt;/span&gt;&lt;span&gt;ViolationException: Duplicate entry 175190 for key &#x27;PRIMARY&#x27;.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在PingCAP官方文档上，有以下介绍：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TiDB 中，自增列只保证自增且唯一，并不保证连续分配。TiDB 目前采用批量分配 ID 的方式，所以如果在多台 TiDB 上同时插入数据，分配的自增 ID 会不连续。TiDB 实现自增 ID 的原理是每个 tidb-server 实例缓存一段 ID 值用于分配（目前会缓存 30000 个 ID），用完这段值再去取下一段。假设集群中有两个 tidb-server 实例 A 和 B（A 缓存 [1,30000] 的自增 ID，B 缓存 [30001,60000] 的自增 ID），依次执行如下操作：客户端向 B 插入一条将 id 设置为 1 的语句 insert into t values (1, 1)，并执行成功。客户端向 A 发送 Insert 语句 insert into t (c) (1)，这条语句中没有指定 id 的值，所以会由 A 分配，当前 A 缓存了 [1, 30000] 这段 ID，所以会分配 1 为自增 ID 的值，并把本地计数器加 1。而此时数据库中已经存在 id 为 1 的数据，最终返回 Duplicated Error 错误。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过这段介绍，我们了解到造成自增主键冲突，是因为存在自增主键显式插入导致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;结论：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;分布式数据库对于表自增列是预分配的，自增主键显式插入会导致tidb-server上的计数器混乱，引起数据写入报错。在开发规范中，我们明确要求TiDB不允许自增主键显式插入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.3 修改字段是否为空导致默认值异常&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下的表，我们字段从int升级到bigint&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CREATE TABLE `test` (`id` int);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;alter table `test` add `col1` int(11) null default &#x27;0&#x27;;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;alter table `test` add `col2` int(11) null default &#x27;0&#x27;;   &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;alter table `test` change `col1` `col1` bigint(20) null default &#x27;0&#x27;;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;alter table `test` change `col2` `col2` bigint(20) null default &#x27;0&#x27;;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们发现默认值0不合适，因此，执行下面的语句，把默认值调整为null&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;alter table `test` change `col1` `col1` bigint(20) null ;   &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;alter table `test` change `col2` `col2` bigint(20) null&#x27;;   &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此时，我们插入一条数据：insert into test(id) values(1);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;神奇的发现，col1和col2的值依旧是0. 这和我们的预期不符。经过一系列重现测试，以及社区论坛的查找，我们发现这个问题是一个已知问题。&lt;a target=&quot;_blank&quot; href=&quot;https://github.com/pingcap/tidb/pull/20491&quot; textvalue=&quot;https://github.com/pingcap/tidb/pull/20491&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;https://github.com/pingcap/tidb/pull/20491&lt;/a&gt;. 该Bug在TiDB 4.0.9及以后版本已修复。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;结论：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;成熟的社区论坛是TiDB日常运维和快速排障的利器，借助社区论坛上各种技术探索和交流分享，可以汲取优质内容，收获前沿知识，快速定位和解决问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、监控与告警&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于分布式数据库运维，监控和告警是非常核心的一环，冒烟现象或者不规范现象，需要及时发现，及时解决，避免问题恶化。监控准确、告警及时可以帮助运维人员准确定位问题，快速解决故障。TiDB 使用开源时序数据库 Prometheus 作为监控和性能指标信息存储方案，使用 Grafana 作为可视化组件进行展示，我们在此基础上进一步做了整合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.1 TiDB监控大盘&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TiDB原生提供prometheus+Grafana的性能大盘，数据非常丰富，但数据分散在单独的集群，无法提供全局视角，我们通过prometheus源生remote write到9201端口，自研了一个adaptor监听9201端口，转发性能数据到携程统一监控平台，搭建了我们自己的监控大盘。如图4-1：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.45&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlYNjibrJTuNyUbfuMBXqn3O27sghq24cIBWCMfd530hBT8gD1lSUU0xQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4-1 整合后的TiDB监控大盘 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.2 三副本监控&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TiDB使用三个以上的副本，通过raft协议来保证数据的一致性。当出现多数副本丢失或者宕机时，这部分数据处于不可用状态，是否存在副本缺失或者副本状态异常是需要特别注意的。因此我们会针对副本的数目及状态进行巡检，确保不会出现长时间内副本不足的情况，一旦发现有副本丢失，可以增加副本的调度线程，务必及时解决副本缺失问题。Region Peer的监控如图4-2：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4709090909090909&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdl5AMVht994duxmH66vOKjq80s4nltUJgRej56DwmA93Mx1zAl9n1jbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4-2 三副本监控&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.3 磁盘容量监控&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TiDB存储数据量庞大，需要特别关注机器磁盘剩余可使用空间的情况，以免写满磁盘造成不必要的故障。对于磁盘的监控，我们的阈值是物理磁盘的80%，一旦磁盘使用容量超过阈值，我们需要安排加机器扩容。对比相同情况下MySQL复杂的拆分方法，TiDB的处理方法更简单高效。磁盘的监控告警如图4-3：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5444444444444444&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlem5Ao42rbS1CZickcCZfCXIjxY0zLYFT0giaYRpHzh9PWJD3FJDPzFTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;360&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4-3 TiDB磁盘监控&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.4 配置标准化检查&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TiDB集群的配置文件参数、系统参数众多，不同实例的配置项各不相同，且经常会对集群扩容缩容，因此我们要求变更前后集群的配置必须严格按照标准配置进行调整。只要做到配置标准，很大程度上就会保证集群标准化运行。配置标准化的监控告警如图4-4：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.16752312435765673&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1crw9HkpWicbLUPHibZpLqibqCp7RzaX0XDWjzobFyVIpibVolrHR04ZpJNI8EjFr3EPw55WI8z3m6QZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;973&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4-4 配置标准化的监控告警&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4.5 性能告警&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有时候会存在突发的流量上升，或者瞬间的性能尖峰的情况，这时候就需要关注性能告警。METRICS_SCHEMA 是基于 Prometheus 中 TiDB 监控指标的一组视图，有了基础的性能数据，我们只需要根据性能阈值，及时告警，及时分析处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、周边工具&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了监控与告警，我们也开发了一系列周边工具，对于TiDB的运维，带来了更大的便利。这些周边工具主要包括：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.1 和现有的数据周边工具打通&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现有的数据周边工具主要包括：数据库的发布（DDL），数据在线查询，数据在线修改，以及和现有的大数据流程打通等，这些支持MySQL的工具也一样可以支持TiDB，为MySQL迁移TiDB打解决了后顾之忧，让之前使用MySQL的开发测试人员可以方便流畅地切换到TiDB。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.2 TiDB部署工具&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TiDB集群实例角色较多，集群部署有别于传统单机，需要单独开发一套部署工具，包括集群上线流程、集群下线流程、扩容缩容实例、集群版本升级等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.3 TiDB闪回工具&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有时候会遇到开发测试人员误操作数据的情况，可以使用数据闪回工具进行回退，我们借助TiDB binlog开发了闪回工具，对binlog的内容做反转，生成数据恢复SQL，供 TiDB数据恢复使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;六、未来规划&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.1 故障的一键分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分布式数据库与单机不同， TiDB组件比较多，可供调整的参数有数百个，各个组件之间的网络通信、某个组件资源不足、SQL复杂等都可能导致出现性能问题，后续计划将TiDB诊断做成自动化和智能化，目前已经通过改造TiDB server源码，完成了TiDB的全链路SQL收集和分析，这将作为未来故障一键分析的基础。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.2 基于HDD硬盘测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TiDB 所有的优化都是基于SSD来做的，高性能意味着高成本。我们还是会面临数据量比较大，但写入和查询都比较少，响应要求不高的场景。我们目前已经完成基于HDD硬盘的测试，选择的机器配置为12块10T HDD硬盘，单机部署12个TiKV实例，这种架构已经在小范围应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.3 同城双中心自适应同步方案DR Auto-Sync&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DR Auto-Sync 正处在高速迭代的周期中，后续版本将会有一系列高可用和容灾能力的加强。从 5.3.0 开始将支持双中心对等部署，藉此获得快速恢复多副本的能力，我们也在保持关注中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;【推荐阅读】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1crw9HkpWicbLUPHibZpLqibqCNpp1MADT0D3Tic6Aaw2wmqnpOhvqedVNzZbkqicLxbb6h9O8p1uNKI6Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; “携程技术”公众号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;  分享，交流，成长&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ceb98fa23101caa6f2dd801be4a047e9</guid>
<title>vscode-loader 解析之（node 环境） - 悠然宜想亭</title>
<link>https://toutiao.io/k/r3oixv0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;Post-body&quot;&gt;
                    &lt;p&gt;前面，我们已经分析过浏览器环境的模块加载，接下来看 node 环境的模块加载。&lt;/p&gt;

&lt;h2&gt;示例&lt;/h2&gt;

&lt;p&gt;vscode-loader 在 node 环境下加载模块，和浏览器环境基本一致。不同点是，不是通过 script 标签加载 loader.js，而是通过 require 加载。&lt;/p&gt;

&lt;p&gt;具体示例如下：&lt;/p&gt;

&lt;p&gt;加载 loader.js，再调用 loader 模块的方法，加载 test 依赖：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;loader = require(&quot;./src/loader&quot;);
// 设置缓存
loader.config({
  nodeCachedData: {
    path: &quot;./cache-data&quot;,
  },
});
loader([&quot;test&quot;], function (test) {
  console.log(test.compare(7, 5));
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;定义模块：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// test.js

define(&quot;test&quot;, function () {
  return {
    compare: function (a, b) {
      return a &amp;gt; b;
    },
  };
});&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;loader 加载模块&lt;/h2&gt;

&lt;p&gt;上一篇文章中，我们提到，浏览器环境通过 require 函数加载模块。而 node 环境，是通过 loader.js 的模块导出值，加载其他模块。&lt;/p&gt;

&lt;p&gt;查看入口文件中的逻辑，可以看出 loader 就是 require 函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;// 初始化
export function init(): void {
...

if (env.isNode &amp;amp;&amp;amp; !env.isElectronRenderer) {
// 设置 module.expots
module.exports = RequireFunc;
require = &amp;lt;any&amp;gt;RequireFunc;
} else {
...
}
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，node 环境加载模块的逻辑，和浏览器基本是一致的。不同点在于，之前提到的，不同环境下的 &lt;code&gt;scriptLoader&lt;/code&gt; (脚本加载器)。&lt;/p&gt;

&lt;h2&gt;NodeScriptLoader&lt;/h2&gt;

&lt;p&gt;下面，我们具体来看 node 的脚本加载器。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;class OnlyOnceScriptLoader implements IScriptLoader {

...

public load(moduleManager: IModuleManager, scriptSrc: string, callback: () =&amp;gt; void, errorback: (err: any) =&amp;gt; void): void {
if (!this._scriptLoader) {
if (this._env.isWebWorker) {
this._scriptLoader = new WorkerScriptLoader();
} else if (this._env.isElectronRenderer) {
// electron 渲染进程，preferScriptTags 指定是否用 &amp;lt;script&amp;gt; 标签加载，默认为 false
const { preferScriptTags } = moduleManager.getConfig().getOptionsLiteral();
if (preferScriptTags) {
this._scriptLoader = new BrowserScriptLoader();
} else {
this._scriptLoader = new NodeScriptLoader(this._env);
}
} else if (this._env.isNode) {
// node 环境，新建 node 的脚本加载器
this._scriptLoader = new NodeScriptLoader(this._env);
} else {
this._scriptLoader = new BrowserScriptLoader();
}
}
...
}
}

class NodeScriptLoader implements IScriptLoader {

private static _BOM = 0xFEFF;
private static _PREFIX = &#x27;(function (require, define, __filename, __dirname) { &#x27;;
private static _SUFFIX = &#x27;\n});&#x27;;

...

public load(moduleManager: IModuleManager, scriptSrc: string, callback: () =&amp;gt; void, errorback: (err: any) =&amp;gt; void): void {
// load-1: 获取配置
const opts = moduleManager.getConfig().getOptionsLiteral();
const nodeRequire = ensureRecordedNodeRequire(moduleManager.getRecorder(), (opts.nodeRequire || global.nodeRequire)); // nodeRequire 增加事件记录
const nodeInstrumenter = (opts.nodeInstrumenter || function (c) { return c; });// 如果设置了 nodeInstrumenter，在脚本加载之前，会先对脚本执行该转换函数
// load-2: 初始化
this._init(nodeRequire);
this._initNodeRequire(nodeRequire, moduleManager);
let recorder = moduleManager.getRecorder();

// load-3: 加载模块
if (/^node\|/.test(scriptSrc)) {
// &#x27;node|&#x27; 开头的，用 nodeRequire 加载（同步加载），直接调用 callback

let pieces = scriptSrc.split(&#x27;|&#x27;);

let moduleExports = null;
try {
moduleExports = nodeRequire(pieces[1]);
} catch (err) {
errorback(err);
return;
}

moduleManager.enqueueDefineAnonymousModule([], () =&amp;gt; moduleExports);
callback();

} else {

// load-3-1: 路径处理
scriptSrc = Utilities.fileUriToFilePath(this._env.isWindows, scriptSrc);
const normalizedScriptSrc = this._path.normalize(scriptSrc);
const vmScriptPathOrUri = this._getElectronRendererScriptPathOrUri(normalizedScriptSrc);
const wantsCachedData = Boolean(opts.nodeCachedData);
const cachedDataPath = wantsCachedData ? this._getCachedDataPath(opts.nodeCachedData!, scriptSrc) : undefined;

// load-3-2: 获取模块代码和缓存，执行代码
this._readSourceAndCachedData(normalizedScriptSrc, cachedDataPath, recorder, (err: any, data: string, cachedData: Buffer, hashData: Buffer) =&amp;gt; {
if (err) {
errorback(err);
return;
}

// 处理模块代码
let scriptSource: string;
if (data.charCodeAt(0) === NodeScriptLoader._BOM) {
scriptSource = NodeScriptLoader._PREFIX + data.substring(1) + NodeScriptLoader._SUFFIX;
} else {
scriptSource = NodeScriptLoader._PREFIX + data + NodeScriptLoader._SUFFIX;
}

scriptSource = nodeInstrumenter(scriptSource, normalizedScriptSrc);

// 生成并执行脚本
const scriptOpts: INodeVMScriptOptions = { filename: vmScriptPathOrUri, cachedData };
const script = this._createAndEvalScript(moduleManager, scriptSource, scriptOpts, callback, errorback);

// 处理、验证缓存
this._handleCachedData(script, scriptSource, cachedDataPath!, wantsCachedData &amp;amp;&amp;amp; !cachedData, moduleManager);
this._verifyCachedData(script, scriptSource, cachedDataPath!, hashData, moduleManager);
});
}
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;初始化&lt;/h3&gt;

&lt;p&gt;这里，我们先看 load-2 初始化的处理：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;class NodeScriptLoader implements IScriptLoader {
private _init(nodeRequire: (nodeModule: string) =&amp;gt; any): void {
if (this._didInitialize) {
return;
}
this._didInitialize = true;

// 获取 node 原生模块
this._fs = nodeRequire(&#x27;fs&#x27;);
this._vm = nodeRequire(&#x27;vm&#x27;);
this._path = nodeRequire(&#x27;path&#x27;);
this._crypto = nodeRequire(&#x27;crypto&#x27;);
}

// 修补 nodejs 的 require 函数，以便我们可以从缓存数据手动创建脚本。这是通过覆盖 `Module._compile` 函数来完成的。
private _initNodeRequire(nodeRequire: (nodeModule: string) =&amp;gt; any, moduleManager: IModuleManager): void {
// require-1: 如果已经打过补丁，直接返回
const { nodeCachedData } = moduleManager.getConfig().getOptionsLiteral();
if (!nodeCachedData) {
return;
}
if (this._didPatchNodeRequire) {
return;
}
this._didPatchNodeRequire = true;

// require-2: 修改 Module.compile
const that = this
const Module = nodeRequire(&#x27;module&#x27;);

function makeRequireFunction(mod: any) {
...
}

Module.prototype._compile = function (content: string, filename: string) {
...
}
}
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，_initNodeRequire 修改了 node 的 &lt;code&gt;require&lt;/code&gt; 函数，主要是改写了 &lt;code&gt;Module.prototype._compile&lt;/code&gt;。&lt;/p&gt;

&lt;h4&gt;node 的 _compile&lt;/h4&gt;

&lt;p&gt;我们先了解一下 node 的 &lt;code&gt;require&lt;/code&gt; 函数，及 &lt;code&gt;Module.prototype._compile&lt;/code&gt;，以便后续对比。这里的 node 代码为 &lt;a href=&quot;https://github.com/nodejs/node/blob/v14.0.0/lib/internal/modules/cjs/loader.js&quot; rel=&quot; nofollow ugc&quot;&gt;14.0.0 版本&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;先看 &lt;code&gt;require&lt;/code&gt; 函数：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// require: 根据路径加载模块，返回模块的 exports 属性。
Module.prototype.require = function(id) {
...
// 第一步：调用 Module._load
return Module._load(id, this, /* isMain */ false);
};

// Module._load：加载模块、管理缓存
Module._load = function(request, parent, isMain) {
...

// 1. 如果缓存中已存在模块，返回模块的 exports
const cachedModule = Module._cache[filename];
    if (cachedModule !== undefined) {
        updateChildren(parent, cachedModule, true);
        if (!cachedModule.loaded)
            return getExportsForCircularRequire(cachedModule);
        return cachedModule.exports;
    }

...

// 2. 如果是原生模块，调用 `NativeModule.prototype.compileForPublicLoader()` 并返回 exports
    const mod = loadNativeModule(filename, request);
    if (mod &amp;amp;&amp;amp; mod.canBeRequiredByUsers) return mod.exports;

...

// 3. 否则，新建一个模块并保存到缓存，加载文件，返回 exports
const module = new Module(filename, parent);
...
Module._cache[filename] = module;
try {
...
// 第二步：调用 Module.prototype.load
        module.load(filename);
        ...
    } finally {
        ...
    }

    return module.exports;
}

// Module.prototype.load: 根据文件名，调用合适的扩展处理器。
Module.prototype.load = function (filename) {
    ...

// 第三步：调用对应的处理器，比如 Module._extensions[&#x27;.js&#x27;]
    Module._extensions[extension](this, filename);
    this.loaded = true;

    ...
};

Module._extensions[&#x27;.js&#x27;] = function (module, filename) {
    ...
    content = fs.readFileSync(filename, &#x27;utf8&#x27;);
// 第四步：调用 Module.prototype._compile
    module._compile(content, filename);
};&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;从上面代码，可以看出 node 的 &lt;code&gt;require&lt;/code&gt; 函数，执行过程是 &lt;code&gt;require&lt;/code&gt; -&amp;gt; &lt;code&gt;Module._load&lt;/code&gt; -&amp;gt; &lt;code&gt;Module.prototype.load&lt;/code&gt; -&amp;gt; &lt;code&gt;Module._extensions[&#x27;.js&#x27;]&lt;/code&gt; -&amp;gt; &lt;code&gt;Module.prototype._compile&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;继续看 node 的 &lt;code&gt;Module.prototype._compile&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;// node

// Module.prototype._compile: 在指定的上下文中，编译、运行文件内容。
Module.prototype._compile = function (content, filename) {
    ...

// node-compile-1：compiledWrapper: 将文件内容进行封装
    const compiledWrapper = wrapSafe(filename, content, this);

    ...
// node-compile-2：生成 require, exports 等参数
    const dirname = path.dirname(filename);
    const require = makeRequireFunction(this, redirects);
    let result;
    const exports = this.exports;
    const thisValue = exports;
    const module = this;
    ...
    if (inspectorWrapper) {
// 断点调试，一般不走这个逻辑
        result = inspectorWrapper(compiledWrapper, thisValue, exports,
            require, module, filename, dirname);
    } else {
// node-compile-3：调用 compiledWrapper
        result = compiledWrapper.call(thisValue, exports, require, module,
            filename, dirname);
    }
    ...
    return result;
};

// 封装文件内容
function wrapSafe(filename, content, cjsModuleInstance) {
    if (patched) {
// node-compile-1-1：Module.wrap，封装文件内容，返回 (function (exports, require, module, __filename, __dirname) { ${content} \n})
        const wrapper = Module.wrap(content);
// node-compile-1-2：vm.runInThisContext，调用虚拟机接口，编译代码，并在当前上下文执行代码
        return vm.runInThisContext(wrapper, {
            filename,
            lineOffset: 0,
            displayErrors: true,
            importModuleDynamically: async (specifier) =&amp;gt; {
                const loader = asyncESM.ESMLoader;
                return loader.import(specifier, normalizeReferrerURL(filename));
            },
        });
    }
    ...
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;node 的 &lt;code&gt;Module.prototype._compile&lt;/code&gt;，将文件内容进行封装（compiledWrapper），然后生成 require 等参数，再调用封装的函数（compiledWrapper）。&lt;/p&gt;

&lt;p&gt;node-compile-1-2 使用了 node 的 &lt;a href=&quot;https://nodejs.org/api/vm.html&quot; rel=&quot; nofollow ugc&quot;&gt;vm&lt;/a&gt; 模块，该模块支持编译代码、运行代码等功能。&lt;/p&gt;

&lt;h4&gt;vscode-loader 的 _compile&lt;/h4&gt;

&lt;p&gt;vscode-loader 的 &lt;code&gt;Module.prototype._compile&lt;/code&gt;，逻辑如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;class NodeScriptLoader implements IScriptLoader {
private _initNodeRequire(nodeRequire: (nodeModule: string) =&amp;gt; any, moduleManager: IModuleManager): void {

...

Module.prototype._compile = function (content: string, filename: string) {
// compile-1: 替换 shebang，包装源码
const scriptSource = Module.wrap(content.replace(/^#!.*/, &#x27;&#x27;));

// compile-2: 获取缓存数据，并记录事件
const recorder = moduleManager.getRecorder();
// 对于示例而言，缓存路径为 cache-data/test-${hash}.code
const cachedDataPath = that._getCachedDataPath(nodeCachedData, filename);
const options: INodeVMScriptOptions = { filename };
let hashData: Buffer | undefined;
try {
// 读取缓存数据
const data = that._fs.readFileSync(cachedDataPath);
hashData = data.slice(0, 16);
// 设置到 options.cachedData
options.cachedData = data.slice(16);
recorder.record(LoaderEventType.CachedDataFound, cachedDataPath);
} catch (_e) {
recorder.record(LoaderEventType.CachedDataMissed, cachedDataPath);
}
// compile-3: 新建 vm.Script，编译代码
const script = new that._vm.Script(scriptSource, options);
// compile-4: 生成 compileWrapper，用于在当前上下文运行代码
const compileWrapper = script.runInThisContext(options);

// compile-5: 生成 require 等参数
const dirname = that._path.dirname(filename);
const require = makeRequireFunction(this);
const args = [this.exports, require, this, filename, dirname, process, _commonjsGlobal, Buffer];
// compile-6: 执行 compileWrapper，传入参数
const result = compileWrapper.apply(this.exports, args);

// compile-7: 缓存数据
that._handleCachedData(script, scriptSource, cachedDataPath, !options.cachedData, moduleManager);
that._verifyCachedData(script, scriptSource, cachedDataPath!, hashData, moduleManager);

return result;
}
}
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;和 node 的相似之处：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;code&gt;compile-1&lt;/code&gt;，等同于 &lt;code&gt;node-compile-1-1&lt;/code&gt;，通过 &lt;code&gt;Module.wrap&lt;/code&gt; 封装文件内容。这样可以保证代码在独立上下文中运行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compile-3&lt;/code&gt;、&lt;code&gt;compile-4&lt;/code&gt;，等同于 &lt;code&gt;node-compile-1-2&lt;/code&gt;，调用虚拟机接口 &lt;code&gt;runInThisContext&lt;/code&gt;，用于在当前上下文执行代码。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compile-5&lt;/code&gt;，等同于 &lt;code&gt;node-compile-2&lt;/code&gt;，生成 require 等参数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compile-6&lt;/code&gt;，等同于 &lt;code&gt;node-compile-3&lt;/code&gt;，执行封装后的代码。&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;和 node 的不同之处：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;code&gt;compile-2&lt;/code&gt;，增加了获取缓存，并记录缓存事件的逻辑。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compile-3&lt;/code&gt;，编译代码时，options 中传入了缓存。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compile-5&lt;/code&gt;，改写了 &lt;code&gt;makeRequireFunction&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;compile-7&lt;/code&gt;，执行代码后，缓存了数据。&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;可以看出，vscode-loader 的 &lt;code&gt;Module.prototype._compile&lt;/code&gt;，主要是&lt;strong&gt;增加了缓存的逻辑&lt;/strong&gt;，改写了 &lt;code&gt;makeRequireFunction&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;makeRequireFunction&lt;/code&gt; 的对比如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;// node
function makeRequireFunction(mod, redirects) {
    const Module = mod.constructor;

    let require;
    if (redirects) {
// 处理重定向
        const { resolve, reaction } = redirects;
        const id = mod.filename || mod.id;
        require = function require(path) {
// node 协议，加载原生模块，返回 exports
// 文件协议，调用 mode.require，加载文件
...
            return mod.require(path);
        };
    } else {
// 非重定向，直接调用 mod.require
        require = function require(path) {
            return mod.require(path);
        };
    }

    function resolve(request, options) {
        validateString(request, &#x27;request&#x27;);
        return Module._resolveFilename(request, mod, false, options);
    }
    require.resolve = resolve;
    function paths(request) {
        validateString(request, &#x27;request&#x27;);
        return Module._resolveLookupPaths(request, mod);
    }
    resolve.paths = paths;
    require.main = process.mainModule;
    require.extensions = Module._extensions;
    require.cache = Module._cache;
    return require;
}

// vscode-loader
function makeRequireFunction(mod: any) {
const Module = mod.constructor;
// 直接调用 mod.require
let require = &amp;lt;any&amp;gt;function require(path) {
try {
return mod.require(path);
} finally {
// nothing
}
}
require.resolve = function resolve(request, options) {
return Module._resolveFilename(request, mod, false, options);
};
require.resolve.paths = function paths(request) {
return Module._resolveLookupPaths(request, mod);
};
require.main = process.mainModule;
require.extensions = Module._extensions;
require.cache = Module._cache;
return require;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，由于 vscode-loader 的 &lt;code&gt;Module.prototype._compile&lt;/code&gt; 没有重定向的情况，所以 &lt;code&gt;makeRequireFunction&lt;/code&gt; 中的 require，删除了重定向处理。而 require 的其他属性，和 node 保持一致，没有修改。&lt;/p&gt;

&lt;h4&gt;vscode-loader 的缓存处理&lt;/h4&gt;

&lt;p&gt;vscode-loader 通过 config 来设置缓存目录：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;// 设置缓存
loader.config({
  nodeCachedData: {
    path: &quot;./cache-data&quot;,
  },
});&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;compile-2&lt;/code&gt; 通过 &lt;code&gt;_getCachedDataPath&lt;/code&gt; 获取缓存路径：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;// compile-2
const cachedDataPath = that._getCachedDataPath(nodeCachedData, filename);

// 对于示例而言，缓存路径为 cache-data/test-${hash}.code
private _getCachedDataPath(config: INodeCachedDataConfiguration, filename: string): string {
// 根据文件名、配置等生成 hash 值
const hash = this._crypto.createHash(&#x27;md5&#x27;).update(filename, &#x27;utf8&#x27;).update(config.seed!, &#x27;utf8&#x27;).update(process.arch, &#x27;&#x27;).digest(&#x27;hex&#x27;);
const basename = this._path.basename(filename).replace(/\.js$/, &#x27;&#x27;);
return this._path.join(config.path, `${basename}-${hash}.code`);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;compile-2&lt;/code&gt; 读取缓存后，并通过 options 传入 vm.script，以使用缓存数据：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;// compile-2
try {
const cachedDataPath = that._getCachedDataPath(nodeCachedData, filename);
// 读取缓存数据
const data = that._fs.readFileSync(cachedDataPath);
hashData = data.slice(0, 16);
// 设置到 options.cachedData
options.cachedData = data.slice(16);
...
} catch (_e) {
...
}
// options 中包含 cachedData
const script = new that._vm.Script(scriptSource, options);&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行源文件的代码后，&lt;code&gt;compile-7&lt;/code&gt; 更新和校验缓存数据：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;// compile-7
that._handleCachedData(script, scriptSource, cachedDataPath, !options.cachedData, moduleManager);
that._verifyCachedData(script, scriptSource, cachedDataPath!, hashData, moduleManager);

// 处理缓存数据：如果缓存失败，就删除原来的缓存，重新生成缓存；如果 options 没有缓存数据，就生成缓存数据
private _handleCachedData(script: INodeVMScript, scriptSource: string, cachedDataPath: string, createCachedData: boolean, moduleManager: IModuleManager): void {
if (script.cachedDataRejected) {
// cached data got rejected -&amp;gt; delete and re-create
this._fs.unlink(cachedDataPath, err =&amp;gt; {
moduleManager.getRecorder().record(LoaderEventType.CachedDataRejected, cachedDataPath);
this._createAndWriteCachedData(script, scriptSource, cachedDataPath, moduleManager);
if (err) {
moduleManager.getConfig().onError(err)
}
});
} else if (createCachedData) {
// no cached data, but wanted
this._createAndWriteCachedData(script, scriptSource, cachedDataPath, moduleManager);
}
}

// 校验缓存数据：如果 hash 值改变，就删除缓存文件
private _verifyCachedData(script: INodeVMScript, scriptSource: string, cachedDataPath: string, hashData: Buffer | undefined, moduleManager: IModuleManager): void {
if (!hashData) {
// nothing to do
return;
}
if (script.cachedDataRejected) {
// invalid anyways
return;
}
setTimeout(() =&amp;gt; {
// check source hash - the contract is that file paths change when file content
// change (e.g use the commit or version id as cache path). this check is
// for violations of this contract.
const hashDataNow = this._crypto.createHash(&#x27;md5&#x27;).update(scriptSource, &#x27;utf8&#x27;).digest();
if (!hashData.equals(hashDataNow)) {
moduleManager.getConfig().onError(&amp;lt;any&amp;gt;new Error(`FAILED TO VERIFY CACHED DATA, deleting stale &#x27;${cachedDataPath}&#x27; now, but a RESTART IS REQUIRED`));
this._fs.unlink(cachedDataPath!, err =&amp;gt; {
if (err) {
moduleManager.getConfig().onError(err);
}
});
}

}, Math.ceil(5000 * (1 + Math.random())));
}&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;加载模块&lt;/h3&gt;

&lt;p&gt;初始化之后，load-3 进行模块加载，主要分为路径处理、获取模块代码并执行。&lt;/p&gt;

&lt;h4&gt;路径处理&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;class NodeScriptLoader implements IScriptLoader {
public load(moduleManager: IModuleManager, scriptSrc: string, callback: () =&amp;gt; void, errorback: (err: any) =&amp;gt; void): void {
...
// load-3-1: 路径处理
// 对于示例而言，test.js -&amp;gt; test.js
scriptSrc = Utilities.fileUriToFilePath(this._env.isWindows, scriptSrc);
const normalizedScriptSrc = this._path.normalize(scriptSrc);
const vmScriptPathOrUri = this._getElectronRendererScriptPathOrUri(normalizedScriptSrc);
// 配置是否使用缓存，示例为 true
const wantsCachedData = Boolean(opts.nodeCachedData);
// 如果使用缓存，获取缓存路径，示例为 cache-data/test-${hash}.code
const cachedDataPath = wantsCachedData ? this._getCachedDataPath(opts.nodeCachedData!, scriptSrc) : undefined;
...
}
}&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;获取模块代码并执行&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;language-ts&quot;&gt;class NodeScriptLoader implements IScriptLoader {

private static _BOM = 0xFEFF;
private static _PREFIX = &#x27;(function (require, define, __filename, __dirname) { &#x27;;
private static _SUFFIX = &#x27;\n});&#x27;;

public load(moduleManager: IModuleManager, scriptSrc: string, callback: () =&amp;gt; void, errorback: (err: any) =&amp;gt; void): void {
...
// load-3-2: 获取模块代码和缓存，执行代码
// 第一步: 获取模块代码和缓存，其中获取缓存同 compile-2
this._readSourceAndCachedData(normalizedScriptSrc, cachedDataPath, recorder, (err: any, data: string, cachedData: Buffer, hashData: Buffer) =&amp;gt; {
if (err) {
errorback(err);
return;
}

// 第二步: 处理模块代码，同 compile-1
// 如果有 bom 则去除，再封装文件内容，即 &#x27;(function (require, define, __filename, __dirname)&#x27; + data + &#x27;{ \n});&#x27;;
let scriptSource: string;
if (data.charCodeAt(0) === NodeScriptLoader._BOM) {
scriptSource = NodeScriptLoader._PREFIX + data.substring(1) + NodeScriptLoader._SUFFIX;
} else {
scriptSource = NodeScriptLoader._PREFIX + data + NodeScriptLoader._SUFFIX;
}
// 如果配置了转换函数，则执行转换函数：const nodeInstrumenter = (opts.nodeInstrumenter || function (c) { return c; });
scriptSource = nodeInstrumenter(scriptSource, normalizedScriptSrc);

// 第三步: 生成并执行脚本，cacheData 对应从缓存路径读取的缓存数据，同 compile-3 ~ compile-6
const scriptOpts: INodeVMScriptOptions = { filename: vmScriptPathOrUri, cachedData };
const script = this._createAndEvalScript(moduleManager, scriptSource, scriptOpts, callback, errorback);

// step-4: 更新、验证缓存，同 compile-7
this._handleCachedData(script, scriptSource, cachedDataPath!, wantsCachedData &amp;amp;&amp;amp; !cachedData, moduleManager);
this._verifyCachedData(script, scriptSource, cachedDataPath!, hashData, moduleManager);
});

// 第一步. 读取模块和缓存文件
private _readSourceAndCachedData(sourcePath: string, cachedDataPath: string | undefined, recorder: ILoaderEventRecorder, callback: (err?: any, source?: string, cachedData?: Buffer, hashData?: Buffer) =&amp;gt; any): void {

if (!cachedDataPath) {
// 不使用缓存时，直接读取模块文件
this._fs.readFile(sourcePath, { encoding: &#x27;utf8&#x27; }, callback);

} else {
// 使用缓存时，同时读取模块文件和缓存文件
let source: string | undefined = undefined;
let cachedData: Buffer | undefined = undefined;
let hashData: Buffer | undefined = undefined;
let steps = 2;

const step = (err?: any) =&amp;gt; {
if (err) {
callback(err);

} else if (--steps === 0) {
// 两个文件都读取后，steps 变为 0，再执行 callback
callback(undefined, source, cachedData, hashData);
}
}

this._fs.readFile(sourcePath, { encoding: &#x27;utf8&#x27; }, (err: any, data: string) =&amp;gt; {
source = data;
step(err);
});

this._fs.readFile(cachedDataPath, (err: any, data: Buffer) =&amp;gt; {
if (!err &amp;amp;&amp;amp; data &amp;amp;&amp;amp; data.length &amp;gt; 0) {
hashData = data.slice(0, 16);
cachedData = data.slice(16);
recorder.record(LoaderEventType.CachedDataFound, cachedDataPath);

} else {
recorder.record(LoaderEventType.CachedDataMissed, cachedDataPath);
}
step(); // ignored: cached data is optional
});
}
}

// 第三步. 生成并执行脚本
private _createAndEvalScript(moduleManager: IModuleManager, contents: string, options: INodeVMScriptOptions, callback: () =&amp;gt; void, errorback: (err: any) =&amp;gt; void): INodeVMScript {
const recorder = moduleManager.getRecorder();
recorder.record(LoaderEventType.NodeBeginEvaluatingScript, options.filename);

// 同 compile-3: 新建 vm.Script，编译代码
const script = new this._vm.Script(contents, options);
// 同 compile-4: 生成 ret，用于在当前上下文运行代码
const ret = script.runInThisContext(options);

// 获取 define 函数，对应 main.ts 中的 DefineFunc
const globalDefineFunc = moduleManager.getGlobalAMDDefineFunc();
let receivedDefineCall = false;
const localDefineFunc: IDefineFunc = &amp;lt;any&amp;gt;function () {
receivedDefineCall = true;
return globalDefineFunc.apply(null, arguments);
};
localDefineFunc.amd = globalDefineFunc.amd;

// 同 compile-6: 执行 ret
ret.call(global, moduleManager.getGlobalAMDRequireFunc(), localDefineFunc, options.filename, this._path.dirname(options.filename));

recorder.record(LoaderEventType.NodeEndEvaluatingScript, options.filename);

if (receivedDefineCall) {
callback();
} else {
errorback(new Error(`Didn&#x27;t receive define call in ${options.filename}!`));
}

return script;
}
}
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，load-3 加载模块，和 &lt;code&gt;Module.prototype._compile&lt;/code&gt; 的处理逻辑基本一致，都是调用 &lt;code&gt;vm.script&lt;/code&gt;，&lt;code&gt;runInThisContext&lt;/code&gt; 编译代码、执行代码。对缓存的处理也基本一致，都是读取缓存文件内容 &lt;code&gt;cachedData&lt;/code&gt;，在 &lt;code&gt;new vm.script&lt;/code&gt; 时传入缓存；执行代码后，通过 &lt;code&gt;_handleCachedData&lt;/code&gt;、&lt;code&gt;_verifyCachedData&lt;/code&gt; 更新、验证缓存。&lt;/p&gt;

&lt;h2&gt;define 定义模块&lt;/h2&gt;

&lt;p&gt;node 环境和浏览器环境，define 定义模块的逻辑是一致的，本文不再赘述。&lt;/p&gt;

&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;本文主要介绍了 vscode-loader 在 node 环境和浏览器环境的区别，即 &lt;code&gt;scriptLoader&lt;/code&gt; 加载模块的方式不同：&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;浏览器环境，生成 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标签，并设置 async，异步加载模块。&lt;/li&gt;
&lt;li&gt;node 环境，读取文件内容，再调用 &lt;code&gt;vm&lt;/code&gt; 接口（&lt;code&gt;vm.script&lt;/code&gt;，&lt;code&gt;runInThisContext&lt;/code&gt;）编译代码、执行代码，且支持缓存数据。&lt;/li&gt;&lt;/ul&gt;


&lt;h2&gt;猜您可能感兴趣的文章&lt;/h2&gt;



                &lt;/div&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d2fd1992483d3c5fb556093888f4429d</guid>
<title>【ClickHouse 技术系列】-  使用新的 TTL move，将数据存储在合适的地方</title>
<link>https://toutiao.io/k/giawp1c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single js_wx_tap_highlight wx_tap_card&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left&quot; aria-describedby=&quot;js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=Mzg3MjI0NjUxMA==&amp;amp;action=getalbum&amp;amp;album_id=2168818415631663104#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;2168818415631663104&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#EMR ClickHouse&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;7个&lt;span class=&quot;weui-hidden_abs&quot;&gt;内容&lt;/span&gt;&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;2446&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;strong&gt;译者&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;何源（荆杭），阿里云计算平台事业部高级产品专家&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文翻&lt;/span&gt;&lt;span&gt;译自 Altinity 针对 ClickHo&lt;/span&gt;&lt;span&gt;use 的系列技术文章。&lt;/span&gt;&lt;span&gt;面向联机分析处理（OLAP）的开源分析引擎 ClickHouse，因其优良的查询性能，PB 级的数据规模，简单的架构，被国内外公司广泛采用。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;a32429525ae98543e2791d4f36608714&quot; data-spm-anchor-id=&quot;a2c6h.12873639.0.i4.4a1ca648rJdA7I&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;0ea5e42170777abceb759adca5a8e45e&quot;&gt;&lt;span&gt;阿里云 EMR-OLAP 团队，基于开源 ClickHouse 进行了系列优化，提供了开源 OLAP 分析引擎 ClickHouse 的云上托管服务。EMR ClickHouse 完全兼容开源版本的产品特性，同时提供集群快速部署、集群管理、扩容、缩容和监控告警等云上产品功能，并且在开源的基础上优化了 ClickHouse 的读写性能，提升了 ClickHouse 与 EMR 其他组件快速集成的能力。访问&lt;/span&gt;&lt;span&gt;https://help.aliyun.com/document_detail/212195.html&lt;br/&gt;&lt;/span&gt;&lt;span&gt;了解详情。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;0ea5e42170777abceb759adca5a8e45e&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QDdcCFX9vIf3ibBtibctDov6nw29EqF60s684pgTCD9pcapJkibR7OFzZIqBib3wHZ9ALvvR18niaDDJhzbjAfkRFkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;ac0623fde82355c3be7527444777494a&quot;&gt;&lt;span&gt;（图源Altinity，侵删）&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;37d959a041bca7912455376eafd0b1ad&quot;&gt;&lt;/p&gt;&lt;h1 data-lake-id=&quot;feffd4b50dfa3c821b26d21e0bdb776f&quot;&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;h1 data-lake-id=&quot;f3f7a1cec9c90a7fe127078ca1ca3a8e&quot;&gt;&lt;strong&gt;&lt;span&gt;使用新的 TTL move，将数据存储在合适的地方&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;h2&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;目录&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;ul data-lake-id=&quot;45de547a8d1765fc4fa09a27da8a8489&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;TTL 表达式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;设置演示&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;在不重新启动服务器的情况下添加存储配置&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;创建使用 TTL move 的表&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关于 TTL delete 的题外话&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;将 TTL move 添加到现有表中&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;一些关于方式和时机的问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;结论&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;后续&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-lake-id=&quot;0523a9ffdc0733caf08bc7bc922074bc&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;0523a9ffdc0733caf08bc7bc922074bc&quot;&gt;&lt;span&gt;多卷存储在许多用例中是至关重要的。它有助于降低存储成本，并将最关键的应用数据放在最快的存储设备上，从而提高查询性能。监控数据是一个经典用例。随着时间的推移，数据的价值会迅速下降。前一天、上一周、上一月和上一年的数据在访问模式上截然不同，这又对应于各种不同的存储需求。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;4d8781910ff8bcb94b0e421d539a98cb&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;827779d33cd4d69ed5e5594aa6fdd87e&quot;&gt;&lt;span&gt;因此，根据数据时间来适当放置数据就非常重要了。ClickHouse TTL move 现在提供了一种机制来实现这一点。ClickHouse 基于时间的 TTL move 的最大的优势在于非常直观，直接对应于人们的日历时间概念。TTL move 大幅简化了与业务要求相对应的多卷存储的设置。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;b55741d7c5a1f634befa53218b5b594b&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;041c5fc9e73c781db58ac168382ea4c7&quot;&gt;&lt;span&gt;多卷功能大大增加了 ClickHouse 服务器的容量。它通过提供存储策略，将磁盘排列成卷，并在它们之间建立关系，从而实现分层存储。然而，存储策略本身并没有提供太多的灵活性来控制 ClickHouse 保存数据的位置。用户要么使用 ALTER TABLE [db.]table MOVE PART|PARTITION 命令手动操作，要么依赖 move factor 参数来实现基于已用空间比例的卷间数据的简单分配。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;2ac0f72ab4e1c09f2019c31c8f6c221d&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;e5afb9617aa71f4410eb0bdf04a4e112&quot;&gt;&lt;span&gt;在本文中，我们将研究新表 TTL move，它允许用户定义表达式，而这些表达式可以自动将数据移动到用户在存储配置中指定的特定磁盘或卷。新 TTL move 大大增强了多卷存储能力，并提供了充分使用多卷存储能力所需的细粒度控制。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;e5afb9617aa71f4410eb0bdf04a4e112&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-lake-id=&quot;7c117da3a30303810e21ac2d38618cc1&quot;&gt;&lt;strong&gt;&lt;span&gt;TTL 表达式&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-lake-id=&quot;dca13a7d117a2e32951ab2e7e3c10230&quot;&gt;&lt;span&gt;MergeTree 是目前唯一支持 TTL 表达式的引擎系列。ClickHouse 首先增加了对 TTL 表达式的支持，以启用自动删除突变。TTL 表达式只是一种 SQL 表达式，它必须评估为 Date 或 DateTime 数据类型。这种表达式可以使用显式时间间隔（用到 INTERVAL 关键字）或使用 toInterval 转换函数。例如，&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;span&gt;&lt;span/&gt;&lt;span/&gt;&lt;/span&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;TTL&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;date_time + INTERVAL 1 MONTH&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;TTL&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;date_time + INTERVAL 15 HOUR&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-lake-id=&quot;22bc8bba3cfb81cf8ab37dc8cff261b8&quot;&gt;&lt;span&gt;或者使用 toInterval 转换函数，可以得到以下表达式&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;span&gt;&lt;span/&gt;&lt;span/&gt;&lt;/span&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;TTL&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;date_time + toIntervalMonth(ttl)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;TTL&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;date_time + toIntervalHour(ttl)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-lake-id=&quot;728e12b113af9979d502ce0664b54d96&quot;&gt;&lt;span&gt;或者只是&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;span&gt;&lt;span/&gt;&lt;span/&gt;&lt;/span&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;TTL&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;date_time + INTERVAL ttl MONTH&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;TTL&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;date_time + INTERVAL ttl HOUR&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-lake-id=&quot;bb3bdaf9a3e1e36395cb1220e903a5c3&quot;&gt;&lt;span&gt;我们可以把这些表达式分配给一个表，分配后可称为 表达式。一个表只能有一个表达式用于删除，有多个表达式用于将分片自动移动到磁盘或卷。例如，假设我们有一个存储策略，其中定义了一个卷 slow_volume 和一个磁盘 slow_disk，那么表 TTL 表达式可以如下所示&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;span&gt;&lt;span/&gt;&lt;span/&gt;&lt;/span&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;TTL date_time + INTERVAL 1 MONTH &lt;span class=&quot;code-snippet__keyword&quot;&gt;DELETE&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   date_time + &lt;span class=&quot;code-snippet__built_in&quot;&gt;INTERVAL&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;WEEK&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;TO&lt;/span&gt; VOLUME &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;slow_volume&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   date_time + &lt;span class=&quot;code-snippet__built_in&quot;&gt;INTERVAL&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;WEEK&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;TO&lt;/span&gt; DISK &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;slow_disk&#x27;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-lake-id=&quot;4c265614b9bfcfbc80f783281e7f36e0&quot;&gt;&lt;span&gt;有一点值得注意。因为 ClickHouse 首先增加了对 delete TTL 表达式的支持，如果没有指定 TO DISK 或 TO VOLUME 子句，则假定 DELETE 子句。因此，我们建议务必要明确地使用 DELETE 子句来确定要将哪一个 TTL 表达式用于删除。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;ced2629805f6ab47de9e1569350cde66&quot;&gt;&lt;/p&gt;&lt;h2 data-lake-id=&quot;0be1025efb4c89be52fe1dcb7a4ece8d&quot;&gt;&lt;strong&gt;&lt;span&gt;设置演示&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-lake-id=&quot;136ffdde35e954df74a2c861bdac0b6f&quot;&gt;&lt;span&gt;如果你未研究过多卷存储，或未使用过 TTL delete 或 move 表达式，我们建议你使用最新的 ClickHouse 版本 20.3.2.1。我们将在本文的其余部分使用这一版本。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;span&gt;&lt;span/&gt;&lt;span/&gt;&lt;/span&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;clickhouse-client&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;ClickHouse&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;client version 20.3.2.1 (official build).&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Connecting&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;to localhost:9000 as user default.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Connected&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;to ClickHouse server version 20.3.2 revision 54433.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-lake-id=&quot;63aed4356d9201c8e814a1100d7b100d&quot;&gt;&lt;span&gt;出于演示目的，我们将使用 OnTime 数据库（1987 至 2018 年的美国民用飞行数据）。为了方便，我们将下载并使用预先制作的分区。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;span&gt;&lt;span/&gt;&lt;span/&gt;&lt;/span&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;$ curl -O &lt;span class=&quot;code-snippet__symbol&quot;&gt;https:&lt;/span&gt;/&lt;span class=&quot;code-snippet__regexp&quot;&gt;/clickhouse-datasets.s3.yandex.net/ontime&lt;/span&gt;&lt;span class=&quot;code-snippet__regexp&quot;&gt;/partitions/ontime&lt;/span&gt;.tar&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;$ tar xvf ontime.tar -C /var/lib/clickhouse &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;$ &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;$ sudo service clickhouse-server restart&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;$ clickhouse-client --query &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;select count(*) from datasets.ontime&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-lake-id=&quot;aca585330840eb99b1523324df45c738&quot;&gt;&lt;span&gt;当然，如果不使用多卷存储，TTL move 表达式就没有意义了。因此，我们将通过创建不同的文件夹来模拟多个存储设备，这些文件夹将代表具有不同速度和容量的已安装存储设备。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;span&gt;&lt;span/&gt;&lt;span/&gt;&lt;/span&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;powershell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;/fast&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;/med0&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;/med1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;/&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;/slow&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h2 data-lake-id=&quot;f62c3387c2937968ebf6b12a22828e80&quot;&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2 data-lake-id=&quot;f62c3387c2937968ebf6b12a22828e80&quot;&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h2 data-lake-id=&quot;f62c3387c2937968ebf6b12a22828e80&quot;&gt;&lt;strong&gt;&lt;span&gt;在不重新启动服务器的情况下添加存储配置&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-lake-id=&quot;a63bbd6e97bdf4e88c7a00191608ab55&quot;&gt;&lt;span&gt;目前，我们的服务器只使用默认磁盘。我们只要查看 system.disks 表就能发现这一点。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;:) &lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; system.disks&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;SELECT&lt;/span&gt; *&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;FROM&lt;/span&gt; system.disks&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;┌─&lt;span class=&quot;code-snippet__keyword&quot;&gt;name&lt;/span&gt;────┬─&lt;span class=&quot;code-snippet__keyword&quot;&gt;path&lt;/span&gt;─────────────────┬──free_space─┬──total_space─┬─keep_free_space─┐&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ &lt;span class=&quot;code-snippet__keyword&quot;&gt;default&lt;/span&gt; │ /&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt;/lib/clickhouse/ │ &lt;span class=&quot;code-snippet__number&quot;&gt;37705834496&lt;/span&gt; │ &lt;span class=&quot;code-snippet__number&quot;&gt;468514799616&lt;/span&gt; │               &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;└─────────┴──────────────────────┴─────────────┴──────────────┴─────────────────┘&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-lake-id=&quot;5ef55aa5564be996b267ebc17b1ba781&quot;&gt;&lt;span&gt;我们需要更多的存储空间，并且可以在不重新启动服务器的情况下添加新磁盘。我们最近在 ClickHouse 中添加了此功能。现在可以先睹为快。通过将 storage.xml 放入我们的 /etc/clickhouse-server/config.d/ 文件夹，可以定义存储配置。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;span&gt;&lt;span/&gt;&lt;span/&gt;&lt;/span&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;yandex&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;storage_configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;disks&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;default&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;keep_free_space_bytes&lt;/span&gt;&amp;gt;&lt;/span&gt;1024&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;keep_free_space_bytes&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;default&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;fast&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;path&lt;/span&gt;&amp;gt;&lt;/span&gt;/data/fast/&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;path&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;fast&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;med0&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;path&lt;/span&gt;&amp;gt;&lt;/span&gt;/data/med0/&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;path&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;med0&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;med1&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;path&lt;/span&gt;&amp;gt;&lt;/span&gt;/data/med1/&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;path&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;med1&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;slow&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;path&lt;/span&gt;&amp;gt;&lt;/span&gt;/data/slow/&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;path&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;slow&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;disks&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;policies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;default&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;volumes&lt;/span&gt;&amp;gt;&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;default&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;disk&lt;/span&gt;&amp;gt;&lt;/span&gt;default&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;disk&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;default&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;fast&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;disk&lt;/span&gt;&amp;gt;&lt;/span&gt;fast&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;disk&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;fast&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;med&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;disk&lt;/span&gt;&amp;gt;&lt;/span&gt;med0&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;disk&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;disk&lt;/span&gt;&amp;gt;&lt;/span&gt;med1&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;disk&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;med&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;slow&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;disk&lt;/span&gt;&amp;gt;&lt;/span&gt;slow&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;disk&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;slow&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;volumes&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;default&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;policies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;storage_configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;yandex&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-lake-id=&quot;7ae2a7b1ce6a38bfd29b6aad835e1e35&quot;&gt;&lt;span&gt;如果我们使用 SYSTEM RELOAD CONFIG 命令重载该配置，那么应该能够在 system.disks 表中看到新磁盘。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;:) SYSTEM RELOAD CONFIG&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;:) &lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; system.disks&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;┌─&lt;span class=&quot;code-snippet__keyword&quot;&gt;name&lt;/span&gt;────┬─&lt;span class=&quot;code-snippet__keyword&quot;&gt;path&lt;/span&gt;─────────────────┬──free_space─┬──total_space─┬─keep_free_space─┐&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ &lt;span class=&quot;code-snippet__keyword&quot;&gt;default&lt;/span&gt; │ /&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt;/lib/clickhouse/ │ &lt;span class=&quot;code-snippet__number&quot;&gt;37993152512&lt;/span&gt; │ &lt;span class=&quot;code-snippet__number&quot;&gt;468514799616&lt;/span&gt; │               &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ &lt;span class=&quot;code-snippet__keyword&quot;&gt;fast&lt;/span&gt;    │ /&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;/&lt;span class=&quot;code-snippet__keyword&quot;&gt;fast&lt;/span&gt;/          │ &lt;span class=&quot;code-snippet__number&quot;&gt;37993152512&lt;/span&gt; │ &lt;span class=&quot;code-snippet__number&quot;&gt;468514799616&lt;/span&gt; │               &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ med0    │ /&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;/med0/          │ &lt;span class=&quot;code-snippet__number&quot;&gt;37993152512&lt;/span&gt; │ &lt;span class=&quot;code-snippet__number&quot;&gt;468514799616&lt;/span&gt; │               &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ med1    │ /&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;/med1/          │ &lt;span class=&quot;code-snippet__number&quot;&gt;37993152512&lt;/span&gt; │ &lt;span class=&quot;code-snippet__number&quot;&gt;468514799616&lt;/span&gt; │               &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ slow    │ /&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;/slow/          │ &lt;span class=&quot;code-snippet__number&quot;&gt;37993152512&lt;/span&gt; │ &lt;span class=&quot;code-snippet__number&quot;&gt;468514799616&lt;/span&gt; │               &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;└─────────┴──────────────────────┴─────────────┴──────────────┴─────────────────┘&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;我们可以进入 system.storage_policies 表检索存储策略。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;:) &lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; system.storage_policies&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;┌─policy_name─┬─volume_name─┬─volume_priority─┬─disks───────────┬─max_data_part_size─┬─move_factor─┐&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ &lt;span class=&quot;code-snippet__keyword&quot;&gt;default&lt;/span&gt;     │ &lt;span class=&quot;code-snippet__keyword&quot;&gt;default&lt;/span&gt;     │               &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; │ [&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;default&#x27;&lt;/span&gt;]     │                  &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; │         &lt;span class=&quot;code-snippet__number&quot;&gt;0.1&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ &lt;span class=&quot;code-snippet__keyword&quot;&gt;default&lt;/span&gt;     │ &lt;span class=&quot;code-snippet__keyword&quot;&gt;fast&lt;/span&gt;        │               &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt; │ [&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;fast&#x27;&lt;/span&gt;]        │                  &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; │         &lt;span class=&quot;code-snippet__number&quot;&gt;0.1&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ &lt;span class=&quot;code-snippet__keyword&quot;&gt;default&lt;/span&gt;     │ med         │               &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt; │ [&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;med0&#x27;&lt;/span&gt;,&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;med1&#x27;&lt;/span&gt;] │                  &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; │         &lt;span class=&quot;code-snippet__number&quot;&gt;0.1&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ &lt;span class=&quot;code-snippet__keyword&quot;&gt;default&lt;/span&gt;     │ slow        │               &lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt; │ [&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;slow&#x27;&lt;/span&gt;]        │                  &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; │         &lt;span class=&quot;code-snippet__number&quot;&gt;0.1&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;└─────────────┴─────────────┴─────────────────┴─────────────────┴────────────────────┴─────────────┘&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;h2 data-lake-id=&quot;511aa3b19ebb3ea564907ba1b3d0a49b&quot;&gt;&lt;strong&gt;&lt;span&gt;创建使用 TTL move 的表&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-lake-id=&quot;bd7d3bffa1668928b377eba98ff1a678&quot;&gt;&lt;span&gt;现在我们来看看在创建新表时如何定义 TTL move。我们将使用截至 2010 年的飞行数据。最后三年的数据我们将保留在 fast 卷上，3-5 年之间的数据保留在 med 卷上，5-7 年之间的数据应进入 slow 存储，而更早的数据将删除。我们可以通过下表定义来实现这样的方案。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;TABLE&lt;/span&gt; ontime_chunk&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;ENGINE&lt;/span&gt; = MergeTree()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;PARTITION&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;Year&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;BY&lt;/span&gt; FlightDate&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;TTL FlightDate &lt;span class=&quot;code-snippet__keyword&quot;&gt;TO&lt;/span&gt; VOLUME &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;fast&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   FlightDate + &lt;span class=&quot;code-snippet__built_in&quot;&gt;INTERVAL&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;YEAR&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;TO&lt;/span&gt; VOLUME &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;med&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   FlightDate + &lt;span class=&quot;code-snippet__built_in&quot;&gt;INTERVAL&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;YEAR&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;TO&lt;/span&gt; VOLUME &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;slow&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   FlightDate + &lt;span class=&quot;code-snippet__built_in&quot;&gt;INTERVAL&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;7&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;YEAR&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;DELETE&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;AS&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;SELECT&lt;/span&gt; *&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;FROM&lt;/span&gt; datasets.ontime&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;WHERE&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;Year&lt;/span&gt; &amp;gt;= &lt;span class=&quot;code-snippet__number&quot;&gt;2010&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;← Progress: &lt;span class=&quot;code-snippet__number&quot;&gt;55.09&lt;/span&gt; million &lt;span class=&quot;code-snippet__keyword&quot;&gt;rows&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;40.13&lt;/span&gt; GB (&lt;span class=&quot;code-snippet__number&quot;&gt;472.19&lt;/span&gt; thousand &lt;span class=&quot;code-snippet__keyword&quot;&gt;rows&lt;/span&gt;/s., &lt;span class=&quot;code-snippet__number&quot;&gt;344.00&lt;/span&gt; MB/s.) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;██████████████████████████████████████████████████████▌  &lt;span class=&quot;code-snippet__number&quot;&gt;96&lt;/span&gt;%Ok.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;rows&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; set. Elapsed: &lt;span class=&quot;code-snippet__number&quot;&gt;116.659&lt;/span&gt; sec. Processed &lt;span class=&quot;code-snippet__number&quot;&gt;55.09&lt;/span&gt; million &lt;span class=&quot;code-snippet__keyword&quot;&gt;rows&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;40.13&lt;/span&gt; GB (&lt;span class=&quot;code-snippet__number&quot;&gt;472.19&lt;/span&gt; thousand &lt;span class=&quot;code-snippet__keyword&quot;&gt;rows&lt;/span&gt;/s., &lt;span class=&quot;code-snippet__number&quot;&gt;344.00&lt;/span&gt; MB/s.)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;请注意&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，TTL move 不支持 MergeTree 表的旧函数样式语法。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;a65889de12dc85929d74306f5765b14d&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;69719c769eb813c757b7a7968067fa7b&quot;&gt;&lt;span&gt;创建并填充表后，我们可以查看表分片的存储位置。你可以通过查看 system.parts 表实现这一点。下面的查询可以给我们一些基本的统计数据。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;SELECT&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;partition&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   disk_name,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;count&lt;/span&gt;(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;sum&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;rows&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;max&lt;/span&gt;(bytes_on_disk),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;avg&lt;/span&gt;(bytes_on_disk)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;FROM&lt;/span&gt; system.parts&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;WHERE&lt;/span&gt; active &lt;span class=&quot;code-snippet__keyword&quot;&gt;AND&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;table&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;ontime_chunk&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;BY&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;partition&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   disk_name&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;partition&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;DESC&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;┌─&lt;span class=&quot;code-snippet__keyword&quot;&gt;partition&lt;/span&gt;─┬─disk_name─┬─&lt;span class=&quot;code-snippet__keyword&quot;&gt;count&lt;/span&gt;()─┬─&lt;span class=&quot;code-snippet__keyword&quot;&gt;sum&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;rows&lt;/span&gt;)─┬─&lt;span class=&quot;code-snippet__keyword&quot;&gt;max&lt;/span&gt;(bytes_on_disk)─┬─&lt;span class=&quot;code-snippet__keyword&quot;&gt;avg&lt;/span&gt;(bytes_on_disk)─┐&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ &lt;span class=&quot;code-snippet__number&quot;&gt;2018&lt;/span&gt;      │ &lt;span class=&quot;code-snippet__keyword&quot;&gt;fast&lt;/span&gt;      │       &lt;span class=&quot;code-snippet__number&quot;&gt;7&lt;/span&gt; │   &lt;span class=&quot;code-snippet__number&quot;&gt;6033426&lt;/span&gt; │          &lt;span class=&quot;code-snippet__number&quot;&gt;264508145&lt;/span&gt; │  &lt;span class=&quot;code-snippet__number&quot;&gt;86241164.71428572&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ &lt;span class=&quot;code-snippet__number&quot;&gt;2017&lt;/span&gt;      │ &lt;span class=&quot;code-snippet__keyword&quot;&gt;fast&lt;/span&gt;      │       &lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt; │   &lt;span class=&quot;code-snippet__number&quot;&gt;5674621&lt;/span&gt; │          &lt;span class=&quot;code-snippet__number&quot;&gt;274419521&lt;/span&gt; │       &lt;span class=&quot;code-snippet__number&quot;&gt;138846953.25&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ &lt;span class=&quot;code-snippet__number&quot;&gt;2016&lt;/span&gt;      │ med1      │       &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt; │   &lt;span class=&quot;code-snippet__number&quot;&gt;2169891&lt;/span&gt; │          &lt;span class=&quot;code-snippet__number&quot;&gt;147475124&lt;/span&gt; │  &lt;span class=&quot;code-snippet__number&quot;&gt;70784017.66666667&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ &lt;span class=&quot;code-snippet__number&quot;&gt;2016&lt;/span&gt;      │ med0      │       &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt; │   &lt;span class=&quot;code-snippet__number&quot;&gt;3447767&lt;/span&gt; │          &lt;span class=&quot;code-snippet__number&quot;&gt;316232407&lt;/span&gt; │ &lt;span class=&quot;code-snippet__number&quot;&gt;112364801.66666667&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ &lt;span class=&quot;code-snippet__number&quot;&gt;2015&lt;/span&gt;      │ med1      │       &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt; │   &lt;span class=&quot;code-snippet__number&quot;&gt;5265093&lt;/span&gt; │          &lt;span class=&quot;code-snippet__number&quot;&gt;260304509&lt;/span&gt; │          &lt;span class=&quot;code-snippet__number&quot;&gt;259205244&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ &lt;span class=&quot;code-snippet__number&quot;&gt;2015&lt;/span&gt;      │ med0      │       &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; │    &lt;span class=&quot;code-snippet__number&quot;&gt;553986&lt;/span&gt; │           &lt;span class=&quot;code-snippet__number&quot;&gt;54923408&lt;/span&gt; │           &lt;span class=&quot;code-snippet__number&quot;&gt;54923408&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ &lt;span class=&quot;code-snippet__number&quot;&gt;2014&lt;/span&gt;      │ slow      │       &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt; │   &lt;span class=&quot;code-snippet__number&quot;&gt;5819811&lt;/span&gt; │          &lt;span class=&quot;code-snippet__number&quot;&gt;315955553&lt;/span&gt; │        &lt;span class=&quot;code-snippet__number&quot;&gt;288535865.5&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ &lt;span class=&quot;code-snippet__number&quot;&gt;2013&lt;/span&gt;      │ slow      │       &lt;span class=&quot;code-snippet__number&quot;&gt;7&lt;/span&gt; │   &lt;span class=&quot;code-snippet__number&quot;&gt;5089209&lt;/span&gt; │          &lt;span class=&quot;code-snippet__number&quot;&gt;266864685&lt;/span&gt; │           &lt;span class=&quot;code-snippet__number&quot;&gt;71928783&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ &lt;span class=&quot;code-snippet__number&quot;&gt;2012&lt;/span&gt;      │ slow      │       &lt;span class=&quot;code-snippet__number&quot;&gt;6&lt;/span&gt; │    &lt;span class=&quot;code-snippet__number&quot;&gt;436874&lt;/span&gt; │            &lt;span class=&quot;code-snippet__number&quot;&gt;9818520&lt;/span&gt; │  &lt;span class=&quot;code-snippet__number&quot;&gt;7203465.166666667&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ &lt;span class=&quot;code-snippet__number&quot;&gt;2011&lt;/span&gt;      │ slow      │       &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt; │     &lt;span class=&quot;code-snippet__number&quot;&gt;62029&lt;/span&gt; │            &lt;span class=&quot;code-snippet__number&quot;&gt;5946491&lt;/span&gt; │            &lt;span class=&quot;code-snippet__number&quot;&gt;2973249&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ &lt;span class=&quot;code-snippet__number&quot;&gt;2010&lt;/span&gt;      │ slow      │       &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt; │    &lt;span class=&quot;code-snippet__number&quot;&gt;113398&lt;/span&gt; │            &lt;span class=&quot;code-snippet__number&quot;&gt;8838400&lt;/span&gt; │ &lt;span class=&quot;code-snippet__number&quot;&gt;3741370.6666666665&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;└───────────┴───────────┴─────────┴───────────┴────────────────────┴────────────────────┘&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如上所示，ClickHouse 对插入内容应用了 TTL move，分片几乎都处于我们预期的位置。为什么说是几乎？因为 TTL delete 表达式与众不同。ClickHouse 在插入过程中不评估这些，因此我们在 slow 磁盘上看到的仍是我们想要删除的 2013 到 2010 年的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;关于 TTL delete 的题外话&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;3b01db29ea218fff1ebe7d8c4dcdb9a5&quot;&gt;&lt;span&gt;ClickHouse 对于 TTL move 和 delete 的处理方式不同。我特意在上面的示例中纳入了一个 TTL delete 表达式来说明这一点。这是因为，TTL delete 会导致代价高昂的变异操作。因此，与仅在磁盘之间复制分片的 TTL move 相比，可能代价更高昂。所以在使用 TTL 时请记住这一点。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;bd8c23b559c9c76a9025314ee3d3aa75&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;bf8dc1c616c6b0cacadb77b6876257c8&quot;&gt;&lt;span&gt;但是鉴于大多数用户会同时用到 TTL delete 和 move，因此必须指出的是，ClickHouse 通过“merge_with_ttl_timeout”MergeTree 表设置来控制 TTL delete 的频率。默认设置为 24 小时，并定义了&lt;strong&gt;可重复进行基于 TTL 的合并的最小时间（秒）&lt;/strong&gt;。此设置实际上意味着，每 24 小时（或者发生了后台合并时）仅在一个分区上执行一次 TTL delete。那么在最坏的情况下，现在 ClickHouse 将最多每 24 小时删除一个与 TTL delete 表达式匹配的分区。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;61530c6e5ece7c226513896024e549eb&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;61bdf44dc5bf1ff78f8dfdaafd042f89&quot;&gt;&lt;span&gt;这种行为可能并不理想，所以如果你想让 TTL delete 表达式更快地执行删除，你可以修改表的 &lt;strong&gt;merge_with_ttl_timeout&lt;/strong&gt; 设置。例如，我们可以将其设置为一小时，如下所示。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;TABLE&lt;/span&gt; [db.]&lt;span class=&quot;code-snippet__keyword&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;MODIFY&lt;/span&gt; SETTING merge_with_ttl_timeout = &lt;span class=&quot;code-snippet__number&quot;&gt;3600&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-lake-id=&quot;f6f2e0c405dbfd7e7f56a0318687d92c&quot;&gt;&lt;span&gt;现在你应该看到，ClickHouse 正在根据你的 TTL delete 表达式每小时删除分片。当然，如果你的表不是太大，可以强制使用 OPTIMIZE TABLE [db.]table FINAL 语句。但是对于大表不建议使用。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;c428e2f5153e463764a07cf89c82484d&quot;&gt;&lt;/p&gt;&lt;h2 data-lake-id=&quot;6363bcd05e4e0a4d4f9f6af9a8aea524&quot;&gt;&lt;strong&gt;&lt;span&gt;将 TTL move 添加到现有表中&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-lake-id=&quot;65544714d8a02b275d1d4fe817f6db58&quot;&gt;&lt;span&gt;我们已经看过如何使用预先定义的 TTL move 创建表。但是，如果你已经有了一个表，或者想更改现有的 TTL move 表达式，则必须使用 ALTER TABLE [db.]table MODIFY TTL 命令。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;68a1712345cae3b02217db7f344b92c4&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;f8fb5d417cafa819b58c18b535ff5cf9&quot;&gt;&lt;strong&gt;&lt;span&gt;请注意&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，在修改 TTL 表达式时，必须重新列出所有 TTL。所有 move 表达式和 delete 表达式（如果存在）。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;65ca8fefa12f012771c77a6e571d4475&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;a7cfe35a17b10caf28836cc48cafa426&quot;&gt;&lt;span&gt;让我们重新使用上表并更改 TTL 表达式。我们现在希望将除了最后三年的数据外的其他数据都放在 slow 卷上，或删除七年之前数据。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;TABLE&lt;/span&gt; ontime_chunk&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;MODIFY&lt;/span&gt; TTL FlightDate &lt;span class=&quot;code-snippet__keyword&quot;&gt;TO&lt;/span&gt; VOLUME &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;fast&#x27;&lt;/span&gt;, FlightDate + toIntervalYear(&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;) &lt;span class=&quot;code-snippet__keyword&quot;&gt;TO&lt;/span&gt; VOLUME &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;slow&#x27;&lt;/span&gt;, FlightDate + toIntervalYear(&lt;span class=&quot;code-snippet__number&quot;&gt;7&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Ok.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;rows&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; set. Elapsed: &lt;span class=&quot;code-snippet__number&quot;&gt;0.037&lt;/span&gt; sec.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-lake-id=&quot;54975847a7343ee97d09df5d3a94570e&quot;&gt;&lt;span&gt;很快啊！我说停停，有什么数据移动了吗？并没有。新的 TTL 表达式将只分配给新分片，要么是在插入的时候，要么是因为新分片作为后台合并操作的结果而创建。对于现有分片，可以通过使用 ALTER TABLE [db.]table MATERIALIZE TTL 语句实现 TTL 来应用新的 TTL。如果对我们的表执行它，该命令将很快返回。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;span&gt;&lt;span/&gt;&lt;span/&gt;&lt;/span&gt;&lt;/pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;ALTER&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;TABLE&lt;/span&gt; ontime_chunk&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   MATERIALIZE TTL&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Ok.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;rows&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; set. Elapsed: &lt;span class=&quot;code-snippet__number&quot;&gt;0.044&lt;/span&gt; sec.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-lake-id=&quot;112b8eb7b54ca7c60eee54f0741ae5d9&quot;&gt;&lt;span&gt;这只是重写你可以在分片的文件夹内找到的 ttl.txt 文件。例如，我们可以看看随机分片有什么。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;$ sudo cat /&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;/fast/&lt;span class=&quot;code-snippet__keyword&quot;&gt;data&lt;/span&gt;/&lt;span class=&quot;code-snippet__keyword&quot;&gt;default&lt;/span&gt;/ontime_chunk/&lt;span class=&quot;code-snippet__number&quot;&gt;2017_113_113_0&lt;/span&gt;/ttl.txt&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ttl format version: &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;table&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;min&quot;&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;1710457200&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;max&quot;&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;1710975600&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;moves&quot;&lt;/span&gt;:[&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     {&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;expression&quot;&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;FlightDate&quot;&lt;/span&gt;,&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;min&quot;&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;1489532400&lt;/span&gt;,&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;max&quot;&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;1490050800&lt;/span&gt;},&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     {&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;expression&quot;&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;plus(FlightDate, toIntervalYear(3))&quot;&lt;/span&gt;,&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;min&quot;&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;1584226800&lt;/span&gt;,&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;max&quot;&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;1584745200&lt;/span&gt;},&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     {&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;expression&quot;&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;plus(FlightDate, toIntervalYear(5))&quot;&lt;/span&gt;,&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;min&quot;&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;1647298800&lt;/span&gt;,&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;max&quot;&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;1647817200&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; ]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/pre&gt;&lt;p data-lake-id=&quot;54f88046b65aa7a920f887f30b394604&quot;&gt;&lt;span&gt;在你执行 MATERIALIZE TTL 命令后，ClickHouse 会在下一个后台周期开始将分片移动到新位置。在我们的示例中，这没有花很长时间。再来看看 system.parts 表，我发现分片移动到了新位置，有些则因为后台合并而被删除。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;SELECT&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;partition&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   disk_name,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;count&lt;/span&gt;(),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;sum&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;rows&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;max&lt;/span&gt;(bytes_on_disk),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;avg&lt;/span&gt;(bytes_on_disk)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;FROM&lt;/span&gt; system.parts&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;WHERE&lt;/span&gt; active &lt;span class=&quot;code-snippet__keyword&quot;&gt;AND&lt;/span&gt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;table&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;ontime_chunk&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;GROUP&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;BY&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;partition&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   disk_name&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;ORDER&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;partition&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;DESC&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;┌─&lt;span class=&quot;code-snippet__keyword&quot;&gt;partition&lt;/span&gt;─┬─disk_name─┬─&lt;span class=&quot;code-snippet__keyword&quot;&gt;count&lt;/span&gt;()─┬─&lt;span class=&quot;code-snippet__keyword&quot;&gt;sum&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;rows&lt;/span&gt;)─┬─&lt;span class=&quot;code-snippet__keyword&quot;&gt;max&lt;/span&gt;(bytes_on_disk)─┬─&lt;span class=&quot;code-snippet__keyword&quot;&gt;avg&lt;/span&gt;(bytes_on_disk)─┐&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ &lt;span class=&quot;code-snippet__number&quot;&gt;2018&lt;/span&gt;      │ &lt;span class=&quot;code-snippet__keyword&quot;&gt;fast&lt;/span&gt;      │       &lt;span class=&quot;code-snippet__number&quot;&gt;8&lt;/span&gt; │   &lt;span class=&quot;code-snippet__number&quot;&gt;6033426&lt;/span&gt; │          &lt;span class=&quot;code-snippet__number&quot;&gt;372476291&lt;/span&gt; │         &lt;span class=&quot;code-snippet__number&quot;&gt;75689482.5&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ &lt;span class=&quot;code-snippet__number&quot;&gt;2017&lt;/span&gt;      │ &lt;span class=&quot;code-snippet__keyword&quot;&gt;fast&lt;/span&gt;      │       &lt;span class=&quot;code-snippet__number&quot;&gt;8&lt;/span&gt; │   &lt;span class=&quot;code-snippet__number&quot;&gt;5674621&lt;/span&gt; │          &lt;span class=&quot;code-snippet__number&quot;&gt;304683038&lt;/span&gt; │       &lt;span class=&quot;code-snippet__number&quot;&gt;69514551.875&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ &lt;span class=&quot;code-snippet__number&quot;&gt;2016&lt;/span&gt;      │ slow      │       &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt; │   &lt;span class=&quot;code-snippet__number&quot;&gt;5617658&lt;/span&gt; │          &lt;span class=&quot;code-snippet__number&quot;&gt;396503243&lt;/span&gt; │ &lt;span class=&quot;code-snippet__number&quot;&gt;183260415.33333334&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ &lt;span class=&quot;code-snippet__number&quot;&gt;2015&lt;/span&gt;      │ slow      │       &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt; │   &lt;span class=&quot;code-snippet__number&quot;&gt;5819079&lt;/span&gt; │          &lt;span class=&quot;code-snippet__number&quot;&gt;329783074&lt;/span&gt; │        &lt;span class=&quot;code-snippet__number&quot;&gt;286661116.5&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ &lt;span class=&quot;code-snippet__number&quot;&gt;2014&lt;/span&gt;      │ slow      │       &lt;span class=&quot;code-snippet__number&quot;&gt;7&lt;/span&gt; │   &lt;span class=&quot;code-snippet__number&quot;&gt;5819811&lt;/span&gt; │          &lt;span class=&quot;code-snippet__number&quot;&gt;244641752&lt;/span&gt; │           &lt;span class=&quot;code-snippet__number&quot;&gt;85566643&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ &lt;span class=&quot;code-snippet__number&quot;&gt;2013&lt;/span&gt;      │ slow      │       &lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt; │   &lt;span class=&quot;code-snippet__number&quot;&gt;5089209&lt;/span&gt; │          &lt;span class=&quot;code-snippet__number&quot;&gt;383141486&lt;/span&gt; │        &lt;span class=&quot;code-snippet__number&quot;&gt;102324330.2&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ &lt;span class=&quot;code-snippet__number&quot;&gt;2012&lt;/span&gt;      │ slow      │       &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; │         &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; │                  &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt; │                  &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ &lt;span class=&quot;code-snippet__number&quot;&gt;2011&lt;/span&gt;      │ slow      │       &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt; │         &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; │                  &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt; │                  &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;│ &lt;span class=&quot;code-snippet__number&quot;&gt;2010&lt;/span&gt;      │ slow      │       &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt; │         &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; │                  &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt; │                  &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt; │&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;└───────────┴───────────┴─────────┴───────────┴────────────────────┴────────────────────┘&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-lake-id=&quot;54f88046b65aa7a920f887f30b394604&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;54f88046b65aa7a920f887f30b394604&quot;&gt;&lt;strong&gt;&lt;span&gt;一些关于方式和时机的问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;9e9a06204df2abf9c1dd4ec096b1e86f&quot;&gt;&lt;span&gt;在了解如何使用 TTL move 表达式之后，让我们看看 ClickHouse 如何以及何时评估 TTL move 表达式。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;9e9a06204df2abf9c1dd4ec096b1e86f&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;07530671c46d268ffbdb185938ec5670&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何评估 TTL move？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-lake-id=&quot;c5ed48d64264d85fceb7762c4d1ab13e&quot;&gt;&lt;span&gt;ClickHouse 使用一个专门的后台线程池来评估 TTL move 表达式。该池的行为由以下参数控制，这些参数可以在 config.xml 或 /etc/clickhouse-server/config.d/ 文件夹内的单独配置文件中进行定义。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;23d666b75fc40a0710e07f27a669cf5c&quot;&gt;&lt;span&gt;以下列出了参数及其当前默认值：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;background_move_pool_size: 8&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;background_move_processing_pool_thread_sleep_seconds: 10&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;background_move_processing_pool_thread_sleep_seconds_random_part: 1.0&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;background_move_processing_pool_thread_sleep_seconds_if_nothing_to_do: 0.1&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;background_move_processing_pool_task_sleep_seconds_when_no_work_min: 10&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;background_move_processing_pool_task_sleep_seconds_when_no_work_max: 600&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;background_move_processing_pool_task_sleep_seconds_when_no_work_multiplier: 1.1&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;background_move_processing_pool_task_sleep_seconds_when_no_work_random_part: 1.0&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-lake-id=&quot;22208b88b9d6ace7dbcb28753dd28ac6&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;22208b88b9d6ace7dbcb28753dd28ac6&quot;&gt;&lt;span&gt;出于测试目的，我们使用以下配置文件来实现即时移动。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;yandex&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;background_move_processing_pool_thread_sleep_seconds&lt;/span&gt;&amp;gt;&lt;/span&gt;0.5&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;background_move_processing_pool_thread_sleep_seconds&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;background_move_processing_pool_task_sleep_seconds_when_no_work_max&lt;/span&gt;&amp;gt;&lt;/span&gt;0.5&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;background_move_processing_pool_task_sleep_seconds_when_no_work_max&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;yandex&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-lake-id=&quot;238d4e45e4551feca2a32cfe43a383b4&quot;&gt;&lt;span&gt;这个简单的配置突出了两个最重要的参数，你需要视情况加以调整。这两个参数是“background_move_processing_pool_task_sleep_seconds_when_no_work_max”和“background_move_processing_pool_thread_sleep_seconds”。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;“b&lt;/span&gt;&lt;span&gt;ackground_move_processing_pool_task_sleep_seconds_when_no_work_max”定义了当没有工作（移动）时，线程池可以睡眠的最长时间。默认情况下，ClickHouse 将其设置为 600 秒。这意味着，在触发 TTL move 表达式后，实际的移动可以在 10 分钟内开始。完成移动的时间取决于 ClickHouse 需要移动的分片数量和磁盘的 I/O 性能。&lt;br/&gt;&lt;br/&gt;“background_move_processing_pool_thread_sleep_seconds”参数定义了工作者线程在接受另一个任务之前睡眠的秒数。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;0da6eb292141287d1eea7f15efbbf6bd&quot;&gt;&lt;span&gt;基于这些参数，当后台 move 进程池唤醒时，它会扫描所有分片的 TTL 表达式，并确定是否有任何需要移动的数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;f10fef5f396c1a737fc9f4e720a3ef25&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;8fdaa683175df217a4da7649b5242ecf&quot;&gt;&lt;span&gt;请注意，将分片移动到一个磁盘或卷时，后台 move 进程池会检查由存储策略定义的限制条件。如果 ClickHouse 不能根据 TTL move 表达式移动某些分片，则会稍后尝试移动。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;d9f960507c904d8f4769c5b4cc51211a&quot;&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;200c2f68319ac50212a3811cff105f2a&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;何时评估 TTL move？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-lake-id=&quot;cefc07226c71f1adf4f9d977273538af&quot;&gt;&lt;span&gt;ClickHouse 会在以下情况下评估 TTL move 表达式：&lt;/span&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;97dc54149bf4da67d75115fc4f5f1cf9&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-lake-id=&quot;97dc54149bf4da67d75115fc4f5f1cf9&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一些已知的极端情况&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-lake-id=&quot;64248724afc1305c6a19bc129a9234ab&quot;&gt;&lt;span&gt;没有什么是完美的，所以这里列出了一些已知的与 TTL move 相关的极端情况，请你注意。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;没有 SQL 语句来强制执行 TTL move 而不执行分片合并。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;TTL move 和 delete 之间的行为差异。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;由于 I/O 瓶颈，在同一物理磁盘内的大量分片的多线程移动会有损性能。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-lake-id=&quot;e3f1326d84ed9c276b77753620f2f373&quot;/&gt;&lt;h2 data-lake-id=&quot;e3f1326d84ed9c276b77753620f2f373&quot;&gt;&lt;strong&gt;&lt;span&gt;结论&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-lake-id=&quot;52a641d0a59117f3f4cadada9b85af39&quot;&gt;&lt;span&gt;在本文中，我们研究了新的 TTL move 功能，以及它如何扩展新存储策略的用法。借助 TTL move，ClickHouse 拥有一个强大的工具来管理使用多卷存储情况下的数据存储方式。虽然仍存在一些极端情况，但我们在努力解决。你无需顾虑这些情况，不妨尝试一下，看看存储策略和 TTL move 如何显著降低存储成本，为你节约资金。新的 TTL move 将帮助你把数据存储到合适的地方。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;e78c7bda5af5913bc5e718dbf045b6a3&quot;&gt;&lt;/p&gt;&lt;h2 data-lake-id=&quot;44978bc4d8d0672a5611f11dafdce377&quot; data-spm-anchor-id=&quot;a2c6h.12873639.0.i8.4a1ca648rJdA7I&quot;&gt;&lt;strong&gt;&lt;span&gt;后续&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-lake-id=&quot;c08a5575f7bbe14d3ddaf98598d6e6d7&quot;&gt;&lt;span&gt;您已经了解了在 ClickHouse 中处理实时更新相关内容，本系列还包括其他内容：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;f24fda24a4fbb7e722e94d11a4595039&quot;&gt;&lt;span&gt;获取更多 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;EMR ClickHouse&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 相关信息，可查看产品文档：&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;f06660e33a084b0f1074a27610feeddb&quot;&gt;&lt;span&gt;https://help.aliyun.com/document_detail/212195.html&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;a3340531514d007bbd80bfb146bc114c&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;e95ba292d29e2eca2ed42a8b6c41a07a&quot;&gt;&lt;span&gt;钉钉扫描下方二维码加入产品交流群一起参与讨论~&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.32&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/QDdcCFX9vIfRnAJXcVw6vKtwIM5Fot7S3bZZmkMHXcdEFxyqQkbuoNsibGZqEkiclCSCe5omlrW6vhlj6nDfwG3w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>