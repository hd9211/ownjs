<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>84913401e1d36baf008d1323a5ccb08f</guid>
<title>大数据告诉你：程序员真的是吃青春饭的吗？</title>
<link>https://toutiao.io/k/wqo3p4x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;程序员真的是吃青春饭的吗？不少程序员认为编程只能干到 35 岁，事实果真如此吗？&lt;br/&gt;&lt;br/&gt;一篇基于 StackOverflow.com 上的用户数据分析做出的论文《Is Programming Knowledge Related To Age?》，给出了一些答案。&lt;br/&gt;论文地址：https://people.engr.ncsu.edu/ermurph3/papers/msr13.pdf&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据采样和清洗条件：1694981 位用户，平均年龄 30.3 岁。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们来具体看下&lt;strong&gt;：&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;年龄分布图&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以看到程序员年龄的正态分布：高点在 25 岁左右，但是中点在 29 岁左右。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9394495412844037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav8kVlpmZh0m9tqplzkQOkC7EQDYuXSbGdIsrRwz809cYAeicnumKfaFOckGicnIacG6ETSMmHnvhBHQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;545&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;能力和年龄分布图&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;计算每个人每个月的 Reputation，这样可以找到这个用户的真正活跃时间，便于计算这个程序员的真实能力。总声望/活跃时间，可以得到他平均每个月得来的 Reputation。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9887640449438202&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav8kVlpmZh0m9tqplzkQOkC7gPbI1yDD6WVu3vRTPWbwRKDAkoCxj9kJwrqMZibicvePKJI0W4bJDJqw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;534&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以看到：程序员的能力从 25 岁左右开始上升，一直到 50 岁后才会开始下降。所以说，&lt;strong&gt;程序员吃的不是青春饭&lt;/strong&gt;。&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;年纪大的人是否跟不上新技术？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;论文作者用了最近 5 年内比较流行的技术 Tag，然后用了一套比较严谨的算法来查看那些所谓的 “老程序员” 是否在新技术上跟上不了。所谓跟不上，就是这些老的程序员在回答这些新技术上并不活跃。所谓老，就是 37 岁以上的程序员。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从下表可以看到：老程序员和年轻程序员对于一些新技术的学习来说也是差不多的，甚至有些项还超过了年轻的程序员。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.30092592592592593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav8kVlpmZh0m9tqplzkQOkC7S6WFfraS2yCZjJCUYNgqiaFbwLVtPNJfT5l0iadr1LJhOvCsRdqlJZhA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;最后，论文得出结论：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、程序员技术能力上升是可以到 50 岁或 60 岁的；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、老程序员在获取新技术上的能力并不比年轻的程序员差。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;由上面的数据分析可以看出，因为太浮燥，才会说 30 岁是程序员的顶峰。&lt;br/&gt;其实，对于大多数人来说，如果还没有编程到 30 岁，还不能成为一个 “合格” 的程序员。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;并不是编程编到 30 岁就玩完了，而是编程编到 30 岁才刚刚入门。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;拒绝浮躁，加入我们！&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;👇&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;👇👇&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;原价 365 元/年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;，现价仅需 108 元！&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;全年 52 期「VIP 会员专属邮件周报」&lt;br/&gt;只限 VIP 会员加入的交流圈子&lt;br/&gt;大厂「内推机会」&lt;br/&gt;N 多福利，你值得拥有！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;322&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;350&quot; data-ratio=&quot;1.318840579710145&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav8pVYfXHFZnJw6GmED4PucZvQd6m3AP8fUG1IKJyBgicmJ3P5ygQjO5r6Bib2x190MFOlb6PwExNQuA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f605c8f94fbb53c15f504c71f17ea818</guid>
<title>Redis 入门-数据类型：3 种特殊类型详解</title>
<link>https://toutiao.io/k/4xposai</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;blockquote&gt;
&lt;p&gt;Redis除了上文中5种基础数据类型，还有三种特殊的数据类型，分别是 &lt;strong&gt;HyperLogLogs&lt;/strong&gt;（基数统计）， &lt;strong&gt;Bitmaps&lt;/strong&gt; (位图) 和 &lt;strong&gt;geospatial&lt;/strong&gt; （地理位置）。@pdai&lt;/p&gt;
&lt;/blockquote&gt;



&lt;h2&gt;HyperLogLogs（基数统计）&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Redis 2.8.9 版本更新了 Hyperloglog 数据结构！&lt;/p&gt;
&lt;/blockquote&gt;



&lt;p&gt;举个例子，A = {1, 2, 3, 4, 5}， B = {3, 5, 6, 7, 9}；那么基数（不重复的元素）= 1, 2, 4, 6, 7, 9； （允许容错，即可以接受一定误差）&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;HyperLogLogs 基数统计用来解决什么问题&lt;/strong&gt;？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个结构可以非常省内存的去统计各种计数，比如注册 IP 数、每日访问 IP 数、页面实时UV、在线用户数，共同好友数等。&lt;/p&gt;



&lt;p&gt;一个大型的网站，每天 IP 比如有 100 万，粗算一个 IP 消耗 15 字节，那么 100 万个 IP 就是 15M。而 HyperLogLog 在 Redis 中每个键占用的内容都是 12K，理论存储近似接近 2^64 个值，不管存储的内容是什么，它一个基于基数估算的算法，只能比较准确的估算出基数，可以使用少量固定的内存去存储并识别集合中的唯一元素。而且这个估算的基数并不一定准确，是一个带有 0.81% 标准错误的近似值（对于可以接受一定容错的业务场景，比如IP数统计，UV等，是可以忽略不计的）。 &lt;/p&gt;



&lt;pre lang=&quot;bash&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; pfadd key1 a b c d e f g h i    # 创建第一组元素
(integer) 1
127.0.0.1:6379&amp;gt; pfcount key1                    # 统计元素的基数数量
(integer) 9
127.0.0.1:6379&amp;gt; pfadd key2 c j k l m e g a      # 创建第二组元素
(integer) 1
127.0.0.1:6379&amp;gt; pfcount key2
(integer) 8
127.0.0.1:6379&amp;gt; pfmerge key3 key1 key2          # 合并两组：key1 key2 -&amp;gt; key3 并集
OK
127.0.0.1:6379&amp;gt; pfcount key3
(integer) 13
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Bitmap （位存储）&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Bitmap 即位图数据结构，都是操作二进制位来进行记录，只有0 和 1 两个状态。&lt;/p&gt;
&lt;/blockquote&gt;



&lt;p&gt;比如：统计用户信息，活跃，不活跃！ 登录，未登录！ 打卡，不打卡！ &lt;strong&gt;两个状态的，都可以使用 Bitmaps&lt;/strong&gt;！&lt;/p&gt;

&lt;p&gt;如果存储一年的打卡状态需要多少内存呢？ 365 天 = 365 bit 1字节 = 8bit 46 个字节左右！&lt;/p&gt;



&lt;p&gt;使用bitmap 来记录 周一到周日的打卡！ 周一：1 周二：0 周三：0 周四：1 ......&lt;/p&gt;

&lt;pre lang=&quot;bash&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; setbit sign 0 1
(integer) 0
127.0.0.1:6379&amp;gt; setbit sign 1 1
(integer) 0
127.0.0.1:6379&amp;gt; setbit sign 2 0
(integer) 0
127.0.0.1:6379&amp;gt; setbit sign 3 1
(integer) 0
127.0.0.1:6379&amp;gt; setbit sign 4 0
(integer) 0
127.0.0.1:6379&amp;gt; setbit sign 5 0
(integer) 0
127.0.0.1:6379&amp;gt; setbit sign 6 1
(integer) 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看某一天是否有打卡！&lt;/p&gt;

&lt;pre lang=&quot;bash&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; getbit sign 3
(integer) 1
127.0.0.1:6379&amp;gt; getbit sign 5
(integer) 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;统计操作，统计 打卡的天数！&lt;/p&gt;

&lt;pre lang=&quot;bash&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; bitcount sign # 统计这周的打卡记录，就可以看到是否有全勤！
(integer) 3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;geospatial (地理位置)&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;Redis 的 Geo 在 Redis 3.2 版本就推出了! 这个功能可以推算地理位置的信息: 两地之间的距离, 方圆几里的人&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3&gt;geoadd&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;添加地理位置&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre lang=&quot;bash&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; geoadd china:city 118.76 32.04 manjing 112.55 37.86 taiyuan 123.43 41.80 shenyang
(integer) 3
127.0.0.1:6379&amp;gt; geoadd china:city 144.05 22.52 shengzhen 120.16 30.24 hangzhou 108.96 34.26 xian
(integer) 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;规则&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;两级无法直接添加，我们一般会下载城市数据(这个网址可以查询 GEO： &lt;a href=&quot;http://www.jsons.cn/lngcode)%EF%BC%81&quot;&gt;http://www.jsons.cn/lngcode)！&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;有效的经度从-180度到180度。&lt;/li&gt;
&lt;li&gt;有效的纬度从-85.05112878度到85.05112878度。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre lang=&quot;bash&quot;&gt;&lt;code&gt;# 当坐标位置超出上述指定范围时，该命令将会返回一个错误。
127.0.0.1:6379&amp;gt; geoadd china:city 39.90 116.40 beijin
(error) ERR invalid longitude,latitude pair 39.900000,116.400000
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;geopos&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;获取指定的成员的经度和纬度&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre lang=&quot;bash&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; geopos china:city taiyuan manjing
1) 1) &quot;112.54999905824661255&quot;
   1) &quot;37.86000073876942196&quot;
2) 1) &quot;118.75999957323074341&quot;
   1) &quot;32.03999960287850968&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获得当前定位, 一定是一个坐标值!&lt;/p&gt;

&lt;h3&gt;geodist&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;如果不存在, 返回空&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;单位如下&lt;/p&gt;



&lt;pre lang=&quot;bash&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; geodist china:city taiyuan shenyang m
&quot;1026439.1070&quot;
127.0.0.1:6379&amp;gt; geodist china:city taiyuan shenyang km
&quot;1026.4391&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;georadius&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;附近的人 ==&amp;gt; 获得所有附近的人的地址, 定位, 通过半径来查询&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;获得指定数量的人&lt;/p&gt;

&lt;pre lang=&quot;bash&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; georadius china:city 110 30 1000 km         以 100,30 这个坐标为中心, 寻找半径为1000km的城市
1) &quot;xian&quot;
2) &quot;hangzhou&quot;
3) &quot;manjing&quot;
4) &quot;taiyuan&quot;
127.0.0.1:6379&amp;gt; georadius china:city 110 30 500 km
1) &quot;xian&quot;
127.0.0.1:6379&amp;gt; georadius china:city 110 30 500 km withdist
1) 1) &quot;xian&quot;
   2) &quot;483.8340&quot;
127.0.0.1:6379&amp;gt; georadius china:city 110 30 1000 km withcoord withdist count 2
1) 1) &quot;xian&quot;
   2) &quot;483.8340&quot;
   3) 1) &quot;108.96000176668167114&quot;
      2) &quot;34.25999964418929977&quot;
2) 1) &quot;manjing&quot;
   2) &quot;864.9816&quot;
   3) 1) &quot;118.75999957323074341&quot;
      2) &quot;32.03999960287850968&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数 key 经度 纬度 半径 单位 [显示结果的经度和纬度] [显示结果的距离] [显示的结果的数量]&lt;/p&gt;

&lt;h3&gt;georadiusbymember&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;显示与指定成员一定半径范围内的其他成员&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre lang=&quot;bash&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; georadiusbymember china:city taiyuan 1000 km
1) &quot;manjing&quot;
2) &quot;taiyuan&quot;
3) &quot;xian&quot;
127.0.0.1:6379&amp;gt; georadiusbymember china:city taiyuan 1000 km withcoord withdist count 2
1) 1) &quot;taiyuan&quot;
   2) &quot;0.0000&quot;
   3) 1) &quot;112.54999905824661255&quot;
      2) &quot;37.86000073876942196&quot;
2) 1) &quot;xian&quot;
   2) &quot;514.2264&quot;
   3) 1) &quot;108.96000176668167114&quot;
      2) &quot;34.25999964418929977&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参数与 georadius 一样&lt;/p&gt;

&lt;h3&gt;geohash(较少使用)&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;该命令返回11个字符的hash字符串&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre lang=&quot;bash&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; geohash china:city taiyuan shenyang
1) &quot;ww8p3hhqmp0&quot;
2) &quot;wxrvb9qyxk0&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将二维的经纬度转换为一维的字符串, 如果两个字符串越接近, 则距离越近&lt;/p&gt;

&lt;h3&gt;底层&lt;/h3&gt;

&lt;blockquote&gt;
&lt;p&gt;geo底层的实现原理实际上就是Zset, 我们可以通过Zset命令来操作geo&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre lang=&quot;bash&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; type china:city
zset
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看全部元素 删除指定的元素&lt;/p&gt;

&lt;pre lang=&quot;bash&quot;&gt;&lt;code&gt;127.0.0.1:6379&amp;gt; zrange china:city 0 -1 withscores
 1) &quot;xian&quot;
 2) &quot;4040115445396757&quot;
 3) &quot;hangzhou&quot;
 4) &quot;4054133997236782&quot;
 5) &quot;manjing&quot;
 6) &quot;4066006694128997&quot;
 7) &quot;taiyuan&quot;
 8) &quot;4068216047500484&quot;
 9) &quot;shenyang&quot;
1)  &quot;4072519231994779&quot;
2)  &quot;shengzhen&quot;
3)  &quot;4154606886655324&quot;
127.0.0.1:6379&amp;gt; zrem china:city manjing
(integer) 1
127.0.0.1:6379&amp;gt; zrange china:city 0 -1
1) &quot;xian&quot;
2) &quot;hangzhou&quot;
3) &quot;taiyuan&quot;
4) &quot;shenyang&quot;
5) &quot;shengzhen&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;参考文章&lt;/h2&gt;



&lt;h2&gt;知识体系&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;知识体系&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://pdai.tech/_images/db/redis/db-redis-overview.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;相关文章&lt;/em&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;首先，我们通过学习Redis的概念基础，了解它适用的场景。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://pdai.tech/md/db/nosql-redis/db-redis-introduce.html&quot;&gt;Redis入门 - Redis概念和基础&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;其次，这些适用场景都是基于Redis支持的数据类型的，所以我们需要学习它支持的数据类型；同时在redis优化中还需要对底层数据结构了解，所以也需要了解一些底层数据结构的设计和实现。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://pdai.tech/_images/db/redis/db-redis-object-2-2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;blockquote&gt;
&lt;p&gt;再者，需要学习Redis支持的核心功能，包括持久化，消息，事务，高可用；高可用方面包括，主从，哨兵等；高可拓展方面，比如 分片机制等。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://pdai.tech/md/db/nosql-redis/db-redis-x-rdb-aof.html&quot;&gt;Redis进阶 - 持久化：RDB和AOF机制详解&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;为了防止数据丢失以及服务重启时能够恢复数据，Redis支持数据的持久化，主要分为两种方式，分别是RDB和AOF; 当然实际场景下还会使用这两种的混合模式。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pdai.tech/md/db/nosql-redis/db-redis-x-pub-sub.html&quot;&gt;Redis进阶 - 消息传递：发布订阅模式详解&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pdai.tech/md/db/nosql-redis/db-redis-x-event.html&quot;&gt;Redis进阶 - 事件：Redis事件机制详解&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Redis 采用事件驱动机制来处理大量的网络IO。它并没有使用 libevent 或者 libev 这样的成熟开源方案，而是自己实现一个非常简洁的事件驱动库 ae_event。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pdai.tech/md/db/nosql-redis/db-redis-x-trans.html&quot;&gt;Redis进阶 - 事务：Redis事务详解&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pdai.tech/md/db/nosql-redis/db-redis-x-copy.html&quot;&gt;Redis进阶 - 高可用：主从复制详解&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;我们知道要避免单点故障，即保证高可用，便需要冗余（副本）方式提供集群服务。而Redis 提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式。本文主要阐述Redis的主从复制。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pdai.tech/md/db/nosql-redis/db-redis-x-sentinel.html&quot;&gt;Redis进阶 - 高可用：哨兵机制（Redis Sentinel）详解&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;在上文主从复制的基础上，如果注节点出现故障该怎么办呢？ 在 Redis 主从集群中，哨兵机制是实现主从库自动切换的关键机制，它有效地解决了主从复制模式下故障转移的问题。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pdai.tech/md/db/nosql-redis/db-redis-x-cluster.html&quot;&gt;Redis进阶 - 高可拓展：分片技术（Redis Cluster）详解&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;前面两篇文章，主从复制和哨兵机制保障了高可用，就读写分离而言虽然slave节点来扩展主从的读并发能力，但是写能力和存储能力是无法进行扩展的，就只能是master节点能够承载的上限。如果面对海量数据那么必然需要构建master（主节点分片)之间的集群，同时必然需要吸收高可用（主从复制和哨兵机制）能力，即每个master分片节点还需要有slave节点，这是分布式系统中典型的纵向扩展（集群的分片技术）的体现；所以在Redis 3.0版本中对应的设计就是Redis Cluster。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;最后，就是具体的实践以及实践中遇到的问题和解决方法了：在不同版本中有不同特性，所以还需要了解版本；以及性能优化，大厂实践等。&lt;/p&gt;
&lt;/blockquote&gt;



&lt;h2&gt;学习资料&lt;/h2&gt;



&lt;p&gt;除此之外，我还推荐你看下 极客时间 《Redis核心技术与实战》（作者：蒋德钧）的相关内容，它是我看到的为数不多的含有实战经验比较多的专栏，部分文章中图片也来源于这个系列。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c3de36d991026db8f5298cb44dcb3203</guid>
<title>海量数据业务有哪些优化手段？</title>
<link>https://toutiao.io/k/ae23a9e</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;互联网时代，亿级用户各种网络行为产生大量数据，如何解决海量数据存储？如何高性能读写？解决思路有哪些，本文列举了常用的解决方案：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;缓存加速&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;读写分离&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;垂直拆分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分库分表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;冷热数据分离&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ES助力复杂搜索&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NoSQL&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NewSQL&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;🌴 缓存加速&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存就是为了弥补存储系统在这些复杂业务场景下的不足，其基本原理是将可能重复使用的数据放到内存中，一次生成、多次使用，避免每次使用都去访问存储系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存能够带来性能的大幅提升，以 Memcache 为例，单台 Memcache 服务器简单的 key-value 查询能够达到 TPS 50000 以上；Redis性能数据是10W+ QPS&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么缓存的速度那么快？&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.747&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3Ohm6WHibeXJYf7UuB346o52ZqtqQyyic82HgV3QIGvPR7YgVvyHz5xYf1tqwtwtStCcTO6mM7iad0edLpxhlGicibw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图中发现，同机房两台服务器跑个来回，再从内存中顺序读取1M数据，共耗时0.75ms。如果从硬盘读取，做一次磁盘寻址需要10ms，再从磁盘里顺序读取1M数据需要30ms。可见，使用内存缓存性能上提高多个数量级，同时也能支持更高的并发量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;常见的缓存分为本地缓存和分布式缓存，区别在与是否要走网络通讯。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本地缓存是部署在应用服务器中，而我们应用服务器通常会部署多台，当数据更新时，我们不能确定哪台服务器本地中了缓存，更新或者删除所有服务器的缓存不是一个好的选择，所以我们通常会等待缓存过期。因此，这种缓存的有效期很短，通常为分钟或者秒级别，以避免返回前端脏数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相反，分布式缓存采用集群化管理，支持水平扩容，并提供客户端路由数据，数据一致性维护更好。虽然有不到 1ms的网络开销，但比起其优势，这点损耗微不足道。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：在引入缓存后，如果数据库的访问量依旧很大，我们可以考虑对数据库读写分离，通过多个读库分摊压力。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI5NDAwMzM0MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/3Ohm6WHibeXJY3p8ibo9XeCic0sLhnu7GGMo7TiacVcs0wM8dKUzwjjsX9CVPLTZqZsVNgWCWgjTiaFhZ2elNs9RB8Q/0?wx_fmt=png&quot; data-nickname=&quot;微观技术&quot; data-alias=&quot;weiguanjishu&quot; data-signature=&quot;业务架构、职业规划、源码解读等，畅想技术改变人生&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;🌴 读写分离&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;互联网业务有个重要特性，不知道大家有没有发现？大多数业务都是读多写少，如：刷朋友圈的请求量肯定比发朋友圈的量大，淘宝上一个商品的浏览量也肯定远大于它的下单量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么数据库如何抵抗更高的查询请求？那么首先你需要把读写流量区分开，因为这样才方便针对读流量做单独的扩展，这就是我们所说的主从读写分离。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;读写分离定义&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;每次写数据时会同步多份到其它的存储系统，生成多个备份，当用户读取数据时直接从备份存储系统获取数据。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;应用场景：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;读多写少&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据量较大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据查询频率很高，且对性能要求很高&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、由于数据存在备份，甚至是多份备份。那么如何来实现数据备份？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;直接方式是修改业务代码，这也是新手常用的方式。在写入主库后，同步更新备库。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;缺点：如果备库较多，会同步调用多次，如果备库做了调整，业务代码也要跟着修改。优点：实时性好，所见即所得。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;监控数据库 binlog 日志，（如：引入canal组件），由数据同步中心，将变更数据同步到备库中。该方式实现了业务代码解耦，扩展性较好，也是实际工作推崇的技术方案。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;缺点：数据同步需要花费一定时间，如果这期间查询备库，查询到的是旧数据，此类业务场景需要特别注意。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、数据备份有哪些存储介质？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;mysql。关系型数据库，容易上手&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Elasticsearch。可以定制索引结构，满足多样化复杂的业务查询。另外采用分片结构，可以满足较大量数据存储。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MongoDB&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HBase&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;市面的开源框架较多，要注意技术选型。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、查询数据如何实现？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个没有什么可以讲得，以上的中间件开源社区都有封装好的API，直接调用即可。但要注意一点。&lt;code&gt;数据查询时，如果还没有备份完成怎么办？&lt;/code&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一种方案，不允许用户查询，用户体验较差，也不容易控制。鬼知道有没有同步完。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对实时性要求不高的查询，选择走备库，但页面要做好提示引导。比如付款动作，一般会有一个中间页，提示用户付款成功。一般不会直接跳到订单详情页。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对实时性要求非常高的查询，走主库。比如：新用户注册，立即登录。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;🌴 垂直拆分&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;垂直拆分是指按照业务功能拆分，业务表分布在不同的数据库上，这样也就将数据或者说压力分担到不同的库上面 。比如电商系统会拆分出会员、商品、交易、类目、营销、搜索等业务库，分别归属到不用的技术团队维护。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优势：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;职责单一，业务清晰&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;便于维护，易扩展&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通常会独立部署，独享服务器资源，数据库访问性能会有很大提升&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;耦合性低，降低不同应用间故障干扰&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;形成跨库事务，需要引入&lt;strong&gt;分布式事务解决方案&lt;/strong&gt;，提高整个应用的复杂度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“木桶效应”，任何一个短板有可能影响整个系统&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不用业务表之间不能 &lt;code&gt;join&lt;/code&gt; ，只能通过服务间接口调用，在应用层做数据组装，提高了复杂度&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;🌴 分库分表&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：数据库垂直拆分后，遇到单机数据库性能瓶颈，我们可以考虑分表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分表又可以细分为 &lt;strong&gt;垂直分表&lt;/strong&gt; 和 &lt;strong&gt;水平分表&lt;/strong&gt; 两种形式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1、垂直分表&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据表垂直拆分就是纵向地把一张表中的列拆分到多个表，&lt;strong&gt;表由“宽”变“窄”&lt;/strong&gt;，简单来讲，就是将大表拆成多张小表，一般会遵循以下几个原则：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;冷热分离，把常用的列放在一个表，不常用的放在一个表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;字段更新、查询频次拆分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;大字段列独立存放&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;关系紧密的列放在一起&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2、水平分表&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;表结构维持不变，对数据行进行切分，将表中的某些行切分到一张表中，而另外的某些行又切分到其他的表中，也就是说拆分后数据集的并集等于拆分前的数据集。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;分库分表技术点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;SQl组合。因为是逻辑表名，需要按分表键计算对应的物理表编号，根据逻辑重新组装动态的SQL&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据库路由。如果采用分库，需要根据逻辑的分表编号计算数据库的编号&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;结果合并。如果查询没有传入指定的分表键，会全库执行，此时需要将结果合并再输出。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;目前市面有很多的开源框架，大致分为两种模式：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Proxy模式。SQL 组合、数据库路由、执行结果合并等功能全部存放在一个代理服务中，业务方可以当做。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;优点：支持多种语言。升级方便。对业务代码无侵入。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缺点：额外引入一个中间件，容易形成流量瓶颈，安全风险较高，有运维成本&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Client 模式。常见是 &lt;code&gt;sharding-jdbc&lt;/code&gt;，业务端系统只需要引入一个jar包即可，按照规范配置路由规则。jar 中处理 SQL 组合、数据库路由、执行结果合并等相关功能。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;优点：简单、轻便。不存在流量瓶颈，减少运维成本&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缺点：单语言，升级不方便。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、如何选择分表键。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据尽量均匀分布在不同表或库、跨库查询操作尽可能少、这个字段的值不会变。比如电商订单采用user_id。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、分片策略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据范围分片、根据 hash 值分片、根据 hash 值及范围混合分片&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、如何编写业务代码。结合具体的业务实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、历史数据迁移&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;增量数据监听 binlog，然后通过 canal 通知迁移程序开始增量数据迁移&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开启任务，全量数据迁移&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开启双写，并关闭增量迁移任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;读业务切换到新库&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线上运行一段时间，确认没有问题后，下线老库的写操作&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;有一种说法：数据量大，就分表；并发高，就分库&lt;/strong&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后：在实际的业务开发中，要做好数据量的增长预测，做好技术方案选型。另外，在引入分表方案后，要考虑数据倾斜问题，这个跟分表键有很大关系，避免数据分布不均衡影响系统性能。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;🌴 冷热数据分离&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据&lt;strong&gt;二八定律&lt;/strong&gt;，系统绝大部分的性能开销花在20%的业务。数据也不例外，从数据的使用频率来看，经常被业务访问的数据称为热点数据；反之，称之为冷数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在了解的数据的冷、热特性后，便可以指导我们做一些有针对性的性能优化。这里面有业务层面的优化，也有技术层面的优化。比如：电商网站，一般只能查询3个月内的订单，如果你想看看3个月前的订单，需要访问历史订单页面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;实现思路：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、冷热数据区分的标准是什么？要结合业务思考，可能要找产品同学一块讨论才能做决策，切记不要拍脑袋。以电商订单为例：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;方案一：以“下单时间”为标准，将3 个月前的订单数据当作冷数据，3 个月内的当作热数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方案二：根据“订单状态”字段来区分，已完结的订单当作冷数据，未完结的订单当作热数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方案三：组合方式，把下单时间 &amp;gt; 3 个月且状态为“已完结”的订单标识为冷数据，其他的当作热数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、如何触发冷热数据的分离&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;方案一：直接修改业务代码，每次业务请求触发冷热数据判断，根据结果路由到对应的冷数据表或热数据表。缺点：如果判断标准是 &lt;code&gt;时间维度&lt;/code&gt;，数据过期了无法主动感知。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方案二：如果觉得修改业务代码，耦合性高，不易于后期维护。可以通过监听数据库变更日志 binlog 方式来触发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方案三：常用的手段是跑定时任务，一般是选择凌晨系统压力小的时候，通过跑批任务，将满足条件的冷数据迁移到其他存储介质。在途业务表中只留下来少量的热点数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、如何实现冷热数据分离，过程大概分为三步：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;判断数据是冷、还是热&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将冷数据插入冷数据表中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后，从原来的热库中删除迁移的数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、如何使用冷热数据&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;方案一：界面设计时会有选项区分，如上面举例的电商订单&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方案二：直接在业务代码里区分。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;🌴 ES助力复杂搜索&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ES是基于索引结构，无法像mysql那样使用join语句。所以我们在构建索引时需要将主表记录及关联表打平，整合到一条记录中。以&lt;strong&gt;倒排索引&lt;/strong&gt;作为核心技术原理，为你提供了分布式的全文搜索服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mysql与es的概念关系映射&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;mysql&lt;/th&gt;&lt;th&gt;ES&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;数据库&lt;/td&gt;&lt;td&gt;索引 index&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;表&lt;/td&gt;&lt;td&gt;Type&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;行&lt;/td&gt;&lt;td&gt;Document&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;列&lt;/td&gt;&lt;td&gt;Field&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ES分页查询流程：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;协调节点首先把分页查询请求分发给所有分片&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个分片在本地查询一个结果集列表（包含 Document id和搜索分数），返回（from+size）条记录。&lt;code&gt;特别注意：这一步返回的只是主键id&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;协调节点拿到所有分片的返回数据，按分数全局排序，并截取一页大小的数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;协调节点根据结果集里的Document id 向所有的分片查询完整的Document，然后协调节点将结果返回给客户端。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在读取操作流程中，Elasticsearch 集群实际上需要给协调节点返回 shards number * （from + size) 条数据，然后在单机上进行排序，最后返回给客户端这个 size 大小的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着分页的深度增加，性能会越来越差，为了避免这个问题，ES有个&lt;code&gt;max_result_window&lt;/code&gt;配置，默认值10000，超过这个大小，ES返回错误。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用户确实有深度翻页的需求，可以采用&lt;code&gt;search_after&lt;/code&gt;解决，比如 &lt;code&gt;id&amp;gt;20000 limit 10&lt;/code&gt;。&lt;strong&gt;缺点：无法实现跳页。&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;🌴 NoSQL&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NoSQL 数据库放弃了与分布式环境相悖的 &lt;strong&gt;ACID 事务&lt;/strong&gt;，提供了另一种聚合数据模型，从而具有可伸缩性的非关系数据库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;NoSQL 数据库分为五类：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、KV 数据库，通常基于哈希表实现，性能非常好。其中 Value 的类型通常由应用层代码决定。常用的如 Redis，value支持 String、List、Map、Set、Zset等&lt;strong&gt;复合结构&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、文档型数据库，如：MongoDB、CouchDB ，这种数据库的特点是 Schema Free（模式自由），数据表中的字段可以任意扩展，比如说电商系统中的商品有非常多的字段，并且不同品类的商品的字段也都不尽相同，使用关系型数据库就需要不断增加字段支持，而用文档型数据库就简单很多了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、列式数据库，比如 Hbase、Cassandra。列式数据库基于 Key 来映射行，再通过列名进行二级映射，同时它基于列来安排存储的拓扑结构，这样当仅读写大量行中某个列时，操作的数据节点、磁盘非常集中，磁盘 IO、网络 IO 都会少很多。列式数据库的应用场景非常有针对性，比如博客文章标签的行数很多，但在做数据分析时往往只读取标签列，这就很适合使用列式数据库。再比如，通过倒排索引实现了全文检索的 ElasticSearch，就适合使用列式存储存放 Doc Values，这样做排序、聚合时非常高效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、图数据库，在社交关系、知识图谱等场景中，携带各种属性的边可以表示节点间的关系，由于节点的关系数量多，而且非常容易变化，所以关系数据库的实现成本很高，而图数据库既没有固定的数据模型，遍历关系的速度也非常快，很适合处理这类问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5、时序数据库，如：InfluxDB，一般用来做 &lt;code&gt;Metrics&lt;/code&gt; 打点。时序数据库的优势，在于处理指标数据的聚合，并且读写效率非常高。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;应用场景：比如对1000 万数据进行一个统计，查询最近 60 天的数据，按照 1 小时的时间粒度聚合，统计 value 列的最大值、最小值和平均值，并将统计结果绘制成曲线图。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;InfluxDB 也有不足之处：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;InfluxDB 不支持数据更新操作，毕竟时间数据只能随着时间产生新数据，肯定无法对过去的数据做修改；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从数据结构上说，时间序列数据数据没有单一的主键标识，必须包含时间戳，数据只能和时间戳进行关联，不适合普通业务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;相比传统关系型数据库，NoSQL 有哪些优势：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;弥补了传统数据库在性能方面的不足；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据库变更方便，不需要更改原先的数据结构；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;适合互联网常见的大数据量的场景；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;🌴 NewSQL&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;New SQL 是新一代的分布式数据库，它具备原生分布式存储系统高性能、高可靠、高可用和弹性扩容的能力，同时还兼顾了传统关系型数据库的 SQL 支持。另外，它还提供了和传统关系型数据库不相上下的、真正的事务支持，具备了支撑在线交易类业务的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;完整地支持 SQL 和 ACID 事务，提供和 Old SQL 隔离级别相当的事务能力；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高性能、高可靠、高可用，支持水平扩容。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的 New SQL 数据库有：Google 的 Cloud Spanner、阿里巴巴的 OceanBase 以及开源的CockroachDB。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a1e187ec6d55b9bd7e30147b06d68a71</guid>
<title>Go 可用性（五）：自适应限流</title>
<link>https://toutiao.io/k/8rglg7c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;markdown-body&quot;&gt;&lt;div class=&quot;note note-info&quot;&gt;&lt;p&gt;本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 &lt;a href=&quot;https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/&quot;&gt;博客: Go进阶训练营&lt;/a&gt;, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。&lt;/p&gt;&lt;/div&gt;&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;/&gt;序&lt;/h2&gt;&lt;p&gt;在前面限流的三篇文章，我们学习了令牌桶、漏桶算法的原理、实现以及使用方式，不知道你有没有觉得这两种算法存在着一些问题。&lt;/p&gt;&lt;p&gt;这两种算法最大的一个问题就是他们都属于需要提前设置阈值的算法，基于 QPS 进行限流的时候最麻烦的就是这个阈值应该怎么设定。一般来说我们可以通过压测来决定这个阈值。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;但是如果每个系统上线前都要经过很严格的压测，那么成本相对来说会比较大&lt;/li&gt;&lt;li&gt;并且我们很多时候压测都会在测试环境进行压测，测试环境一般来说和生产环境会有一定的差异，即使我们在生产环境做了压测，现在我们的应用都是以容器的形式跑在不同的宿主机上的，每台宿主机上的差异，以及不同的负载都会导致这个压测时的结果不一定就一定是正确的&lt;/li&gt;&lt;li&gt;当我们的机器型号、数量等发生改变时，之前压测的指标能不能用其实是一个问题，这些数据对于系统负载的影响其实不是线性的，举个例子之前一台机器，后面再加一台，负载就一定能到 2 倍么？其实是不一定的&lt;/li&gt;&lt;li&gt;如果需要修改限流的值，虽然之前我们将令牌桶的限流是可以动态调整，但是靠人去调整，如果真出现问题然后再叫运维或者是开发同学去调整可能黄花菜都凉了&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;既然这种方式有这么多的缺点，那有没有办法解决呢？答案就是今天讲到的 &lt;strong&gt;自适应限流&lt;/strong&gt;&lt;/p&gt;&lt;h2 id=&quot;自适应限流&quot;&gt;&lt;a href=&quot;#自适应限流&quot; class=&quot;headerlink&quot; title=&quot;自适应限流&quot;/&gt;自适应限流&lt;/h2&gt;&lt;h3 id=&quot;自适应限流怎么做&quot;&gt;&lt;a href=&quot;#自适应限流怎么做&quot; class=&quot;headerlink&quot; title=&quot;自适应限流怎么做&quot;/&gt;自适应限流怎么做&lt;/h3&gt;&lt;p&gt;前面我们遇到的主要问题就是每个服务实例的限流阈值实际应该是动态变化的，我们应该根据系统能够承载的最大吞吐量，来进行限流，当当前的流量大于最大吞吐的时候就限制流量进入，反之则允许通过。那现在的问题就是&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;系统的吞吐量该如何计算？&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;什么时候系统的吞吐量就是最大的吞吐量了？&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;**&lt;/p&gt;&lt;h4 id=&quot;计算吞吐量：利特尔法则-L-λ-W&quot;&gt;&lt;a href=&quot;#计算吞吐量：利特尔法则-L-λ-W&quot; class=&quot;headerlink&quot; title=&quot;计算吞吐量：利特尔法则 L = λ * W&quot;/&gt;计算吞吐量：利特尔法则 L = λ * W&lt;/h4&gt;&lt;blockquote&gt;&lt;p&gt;利特尔法则由麻省理工大学斯隆商学院（MIT Sloan School of Management）的教授 John Little﹐于 1961 年所提出与证明。它是一个有关提前期与在制品关系的简单数学公式，这一法则为精益生产的改善方向指明了道路。 —- &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://wiki.mbalib.com/wiki/%E5%88%A9%E7%89%B9%E5%B0%94%E6%B3%95%E5%88%99&quot;&gt;MBA 智库百科 (mbalib.com)&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img src=&quot;https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1618149289604-8e317c82-9a06-4369-99ca-61f138515439.png&quot; srcset=&quot;/img/loading.gif&quot; alt=&quot;image.png&quot;/&gt;&lt;br/&gt;如上图所示，如果我们开一个小店，平均每分钟进店 2 个客人(λ)，每位客人从等待到完成交易需要 4 分钟(W)，那我们店里能承载的客人数量就是 2 * 4 = 8 个人&lt;/p&gt;&lt;p&gt;同理，我们可以将 &lt;code&gt;λ&lt;/code&gt; 当做 QPS， &lt;code&gt;W&lt;/code&gt; 呢是每个请求需要花费的时间，那我们的系统的吞吐就是 &lt;code&gt;L = λ * W&lt;/code&gt; ，所以我们可以使用利特尔法则来计算系统的吞吐量。&lt;/p&gt;&lt;h4 id=&quot;什么时候系统的吞吐量就是最大的吞吐量？&quot;&gt;&lt;a href=&quot;#什么时候系统的吞吐量就是最大的吞吐量？&quot; class=&quot;headerlink&quot; title=&quot;什么时候系统的吞吐量就是最大的吞吐量？&quot;/&gt;什么时候系统的吞吐量就是最大的吞吐量？&lt;/h4&gt;&lt;p&gt;首先我们可以通过统计过去一段时间的数据，获取到平均每秒的请求量，也就是 QPS，以及请求的耗时时间，为了避免出现前面 900ms 一个请求都没有最后 100ms 请求特别多的情况，我们可以使用滑动窗口算法来进行统计。&lt;/p&gt;&lt;p&gt;最容易想到的就是我们从系统启动开始，就把这些值给保存下来，然后计算一个吞吐的最大值，用这个来表示我们的最大吞吐量就可以了。但是这样存在一个问题是，我们很多系统其实都不是独占一台机器的，一个物理机上面往往有很多服务，并且一般还存在一些超卖，所以可能第一个小时最大处理能力是 100，但是这台节点上其他服务实例同时都在抢占资源的时候，这个处理能力最多就只能到 80 了&lt;/p&gt;&lt;p&gt;所以我们需要一个数据来做启发阈值，只要这个指标达到了阈值那我们就进入流控当中。常见的选择一般是 CPU、Memory、System Load，这里我们以 CPU 为例&lt;/p&gt;&lt;p&gt;只要我们的 CPU 负载超过 80% 的时候，获取过去 5s 的最大吞吐数据，然后再统计当前系统中的请求数量，只要当前系统中的请求数大于最大吞吐那么我们就丢弃这个请求。&lt;/p&gt;&lt;h3 id=&quot;kratos-自适应限流分析&quot;&gt;&lt;a href=&quot;#kratos-自适应限流分析&quot; class=&quot;headerlink&quot; title=&quot;kratos 自适应限流分析&quot;/&gt;kratos 自适应限流分析&lt;/h3&gt;&lt;h3 id=&quot;限流公式&quot;&gt;&lt;a href=&quot;#限流公式&quot; class=&quot;headerlink&quot; title=&quot;限流公式&quot;/&gt;限流公式&lt;/h3&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// PS: 官方文档这里写的是 cpu &amp;gt; 800 AND (Now - PrevDrop) &amp;lt; 1s&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 应该是写错了，等下看源码就知道了&lt;/span&gt;&lt;br/&gt;(cpu &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;800&lt;/span&gt; OR (Now - PrevDrop) &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;s) AND (MaxPass * MinRt * windows / &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;) &amp;lt; InFlight&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;cpu &amp;gt; 800&lt;/code&gt; 表示 CPU 负载大于 80% 进入限流&lt;/li&gt;&lt;li&gt;&lt;code&gt;(Now - PrevDrop) &amp;lt; 1s&lt;/code&gt; 这个表示只要触发过 1 次限流，那么 1s 内都会去做限流的判定，这是为了避免反复出现限流恢复导致请求时间和系统负载产生大量毛刺&lt;/li&gt;&lt;li&gt;&lt;code&gt;(MaxPass * MinRt * windows / 1000) &amp;lt; InFlight&lt;/code&gt; 判断当前负载是否大于最大负载&lt;ul&gt;&lt;li&gt;&lt;code&gt;InFlight&lt;/code&gt; 表示当前系统中有多少请求&lt;/li&gt;&lt;li&gt;&lt;code&gt;(MaxPass * MinRt * windows / 1000)&lt;/code&gt; 表示过去一段时间的最大负载&lt;/li&gt;&lt;li&gt;&lt;code&gt;MaxPass&lt;/code&gt; 表示最近 5s 内，单个采样窗口中最大的请求数&lt;/li&gt;&lt;li&gt;&lt;code&gt;MinRt&lt;/code&gt; 表示最近 5s 内，单个采样窗口中最小的响应时间&lt;/li&gt;&lt;li&gt;&lt;code&gt;windows&lt;/code&gt; 表示一秒内采样窗口的数量，默认配置中是 5s 50 个采样，那么 windows 的值为 10。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;源码分析&quot;&gt;&lt;a href=&quot;#源码分析&quot; class=&quot;headerlink&quot; title=&quot;源码分析&quot;/&gt;源码分析&lt;/h3&gt;&lt;h4 id=&quot;BBR-结构体&quot;&gt;&lt;a href=&quot;#BBR-结构体&quot; class=&quot;headerlink&quot; title=&quot;BBR 结构体&quot;/&gt;BBR 结构体&lt;/h4&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; BBR &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {&lt;br/&gt;cpu             cpuGetter&lt;br/&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;// 请求数，和响应时间的采样数据，使用滑动窗口进行统计&lt;/span&gt;&lt;br/&gt;passStat        metric.RollingCounter&lt;br/&gt;rtStat          metric.RollingCounter&lt;br/&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;// 当前系统中的请求数&lt;/span&gt;&lt;br/&gt;inFlight        &lt;span class=&quot;hljs-keyword&quot;&gt;int64&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 每秒钟内的采样数量，默认是10&lt;/span&gt;&lt;br/&gt;    winBucketPerSec &lt;span class=&quot;hljs-keyword&quot;&gt;int64&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;// 单个 bucket 的时间&lt;/span&gt;&lt;br/&gt;bucketDuration  time.Duration&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 窗口数量&lt;/span&gt;&lt;br/&gt;    winSize         &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 配置&lt;/span&gt;&lt;br/&gt;    conf            *Config&lt;br/&gt;prevDrop        atomic.Value&lt;br/&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;// 表示最近 5s 内，单个采样窗口中最大的请求数的缓存数据&lt;/span&gt;&lt;br/&gt;maxPASSCache    atomic.Value&lt;br/&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;// 表示最近 5s 内，单个采样窗口中最小的响应时间的缓存数据&lt;/span&gt;&lt;br/&gt;minRtCache      atomic.Value&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h4 id=&quot;Allow-判断请求是否允许通过&quot;&gt;&lt;a href=&quot;#Allow-判断请求是否允许通过&quot; class=&quot;headerlink&quot; title=&quot;Allow: 判断请求是否允许通过&quot;/&gt;Allow: 判断请求是否允许通过&lt;/h4&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(l *BBR)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Allow&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ctx context.Context, opts ...limit.AllowOption)&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt;(info limit.DoneInfo)&lt;/span&gt;, &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;)&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// ... 省略配置修改代码&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; l.shouldDrop() {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;, ecode.LimitExceed&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;atomic.AddInt64(&amp;amp;l.inFlight, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&lt;br/&gt;stime := time.Since(initTime)&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(do limit.DoneInfo)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;rt := &lt;span class=&quot;hljs-keyword&quot;&gt;int64&lt;/span&gt;((time.Since(initTime) - stime) / time.Millisecond)&lt;br/&gt;l.rtStat.Add(rt)&lt;br/&gt;atomic.AddInt64(&amp;amp;l.inFlight, &lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;switch&lt;/span&gt; do.Op {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;case&lt;/span&gt; limit.Success:&lt;br/&gt;l.passStat.Add(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt;:&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;}, &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;这个方法主要是给中间件使用的&lt;/p&gt;&lt;ul&gt;&lt;li&gt;首先使用 &lt;code&gt;shouldDrop&lt;/code&gt; 方法判断这个请求是否应该丢弃&lt;/li&gt;&lt;li&gt;如果成功放行，那么当前系统中的请求数就 +1&lt;/li&gt;&lt;li&gt;然后返回一个 &lt;code&gt;function&lt;/code&gt; 用于请求结束之后&lt;ul&gt;&lt;li&gt;统计请求的响应时间&lt;/li&gt;&lt;li&gt;如果请求成功了，给成功的请求数 +1&lt;/li&gt;&lt;li&gt;并且当前系统中的请求数量 &lt;code&gt;Inflight&lt;/code&gt; -1&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 id=&quot;shouldDrop-判断请求是否应该被丢弃&quot;&gt;&lt;a href=&quot;#shouldDrop-判断请求是否应该被丢弃&quot; class=&quot;headerlink&quot; title=&quot;shouldDrop: 判断请求是否应该被丢弃&quot;/&gt;shouldDrop: 判断请求是否应该被丢弃&lt;/h4&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(l *BBR)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;shouldDrop&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; l.cpu() &amp;lt; l.conf.CPUThreshold {&lt;br/&gt;prevDrop, _ := l.prevDrop.Load().(time.Duration)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; prevDrop == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; time.Since(initTime)-prevDrop &amp;lt;= time.Second {&lt;br/&gt;inFlight := atomic.LoadInt64(&amp;amp;l.inFlight)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; inFlight &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &amp;amp;&amp;amp; inFlight &amp;gt; l.maxFlight()&lt;br/&gt;}&lt;br/&gt;l.prevDrop.Store(time.Duration(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;))&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;inFlight := atomic.LoadInt64(&amp;amp;l.inFlight)&lt;br/&gt;drop := inFlight &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &amp;amp;&amp;amp; inFlight &amp;gt; l.maxFlight()&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; drop {&lt;br/&gt;prevDrop, _ := l.prevDrop.Load().(time.Duration)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; prevDrop != &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; drop&lt;br/&gt;}&lt;br/&gt;l.prevDrop.Store(time.Since(initTime))&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; drop&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;这个方法其实就是开头讲到的限流公式了，逻辑如下图所示&lt;br/&gt;&lt;img src=&quot;https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1618158541909-f94f46a3-fad8-47d3-a389-395a57116c55.png&quot; srcset=&quot;/img/loading.gif&quot; alt=&quot;Go可用性 限流-分布式限流-kratos 限流策略.png&quot;/&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;首先看 CPU 的使用率是否达到了阈值&lt;/li&gt;&lt;li&gt;如果没到，则回去判断一下上次触发限流到现在是否在一秒以内&lt;ul&gt;&lt;li&gt;如果在一秒内，就判断当前负载是否超过限制，如果超过了就需要丢弃&lt;/li&gt;&lt;li&gt;如果不在 1s 内或者是请求数量已经降下来了，那么就吧 &lt;code&gt;prevDrop&lt;/code&gt; 清零然后返回 false&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;如果到了，则判断一下当前负载是否超过限制&lt;ul&gt;&lt;li&gt;如果超过了，则设置丢弃时间 &lt;code&gt;prevDrop&lt;/code&gt;，返回 true 需要丢弃请求&lt;/li&gt;&lt;li&gt;如果没超过直接返回 false&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 id=&quot;maxFlight-系统的最大负载&quot;&gt;&lt;a href=&quot;#maxFlight-系统的最大负载&quot; class=&quot;headerlink&quot; title=&quot;maxFlight: 系统的最大负载&quot;/&gt;maxFlight: 系统的最大负载&lt;/h4&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(l *BBR)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;maxFlight&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;int64&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int64&lt;/span&gt;(math.Floor(&lt;span class=&quot;hljs-keyword&quot;&gt;float64&lt;/span&gt;(l.maxPASS()*l.minRT()*l.winBucketPerSec)/&lt;span class=&quot;hljs-number&quot;&gt;1000.0&lt;/span&gt; + &lt;span class=&quot;hljs-number&quot;&gt;0.5&lt;/span&gt;))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;这个就是计算过去一段时间系统的最大负载是多少&lt;/p&gt;&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;/&gt;总结&lt;/h2&gt;&lt;p&gt;这篇文章我们讲了一下为什么需要自适应限流，令牌桶和漏桶这类需要手动设置 rps 算法的问题所在，了解了自适应限流的实现原理，最后看了一下 kratos 当中是如何实现自适应限流的。但是由于篇幅关系，CPU 的数据如何进行统计，文章中提到了很多次的滑动窗口是个什么原理这些知识点大家可以自行查看 kratos 中的源码，或者去看极客时间的 Go 进阶训练营都有讲到。&lt;/p&gt;&lt;p&gt;kratos 中的限流算法其实灵感源于 Google SRE，实现上参考了 sentinel，其中一个有意思的点是 sentinel 默认使用 load 作为启发阈值，而 kratos 使用了 cpu，kratos 为什么要使用 cpu 呢？这个大家可以自己想想（答案可以自行观看极客时间的 Go 进阶训练营）&lt;/p&gt;&lt;p&gt;而 sentinel 的实现其实是参考了 TCP 中的 BBR 算法，在 BBR 的基础上加上了 load 作为启发阈值的判断，所以多了解一下基础知识总是没错的，指不定当下遇到的场景就能解决。&lt;/p&gt;&lt;h2 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;/&gt;参考文献&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://u.geekbang.org/subject/go?utm_source=lailin.xyz&amp;amp;utm_medium=lailin.xyz&quot;&gt;Go 进阶训练营-极客时间&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://kunzhao.org/docs/cloud-plus-bbs/bilibili-high-availability/&quot;&gt;B 站高可用架构实践 | 赵坤的个人网站 (kunzhao.org)&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://wiki.mbalib.com/wiki/%E5%88%A9%E7%89%B9%E5%B0%94%E6%B3%95%E5%88%99&quot;&gt;利特尔法则 - MBA 智库百科 (mbalib.com)&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://aws.amazon.com/cn/blogs/china/talking-about-network-optimization-from-the-flow-control-algorithm/&quot;&gt;从流量控制算法谈网络优化 – 从 CUBIC 到 BBRv2 算法 | 亚马逊 AWS 官方博客 (amazon.com)&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/go-kratos/kratos/blob/v1.0.x/docs/ratelimit.md&quot;&gt;kratos/ratelimit.md at v1.0.x · go-kratos/kratos (github.com)&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://my.oschina.net/u/3162806/blog/4525952&quot;&gt;限流器系列(3)–自适应限流 - 郝洪范的个人空间 - OSCHINA - 中文开源技术交流社区&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://en.wikipedia.org/wiki/TCP_congestion_control#TCP_BBR&quot;&gt;TCP congestion control - Wikipedia&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/alibaba/Sentinel/wiki/%E7%B3%BB%E7%BB%9F%E8%87%AA%E9%80%82%E5%BA%94%E9%99%90%E6%B5%81&quot;&gt;系统自适应限流 · alibaba/Sentinel Wiki · GitHub&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;div class=&quot;note note-info&quot;&gt;&lt;p&gt;第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠&lt;br/&gt;&lt;strong&gt;扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦&lt;/strong&gt;&lt;/p&gt;&lt;/div&gt;&lt;h2 id=&quot;关注我获取更新&quot;&gt;&lt;a href=&quot;#关注我获取更新&quot; class=&quot;headerlink&quot; title=&quot;关注我获取更新&quot;/&gt;关注我获取更新&lt;a class=&quot;anchorjs-link&quot; aria-label=&quot;Anchor&quot; data-anchorjs-icon=&quot;&quot; href=&quot;#关注我获取更新&quot;/&gt;&lt;/h2&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>642df5d409f32274cc7b62d60f9c1a59</guid>
<title>MySQL 提升笔记（一）：MySQL 逻辑架构</title>
<link>https://toutiao.io/k/n0xgxs1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODE5ODM0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeFt08hV3N1706WTzfhoTNoXm5LXRV0XibppmeNR4zSNMa3QOJJ7ib4O21P5yohibwuD26Tp9ETWZAqA/0?wx_fmt=png&quot; data-nickname=&quot;三分恶&quot; data-alias=&quot;Fighter3FullStack&quot; data-signature=&quot;一个全栈开发。分享Java后端、Web前端、计算机基础知识。&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;深入学习MySQL，从概览MySQL逻辑架构开始。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先来看一下MySQL的逻辑架构图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.4716157205240175&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdJJmea4NvtFz7JMNfY6vZE587OWkO4FDasB9CeFYo9qAnFDXngHM6JPIWyMxZ8zt3NIc7AnVXibKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;458&quot;/&gt;&lt;figcaption&gt;MySQL逻辑架构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL逻辑架构大概可以分为三层：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;客户端：最上层的服务并不是MySQL所独有的，大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Server层：大多数MySQL的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;存储引擎层：第三层包含了存储引擎。存储引擎负责MySQL中数据的存储和提取。Server层通过API与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;值得一提的是在MySQL8.0中取消了查询缓存，大概的理由是查询缓存存在严重的可伸缩性问题，并且很容易成为严重的瓶颈缓存，将缓存移动到客户端能收获更好的性能。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.425947187141217&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdJJmea4NvtFz7JMNfY6vZEtHWNpMsNhRLShibLpBJmUk1gFfHHnkHvkO8xPZbt2hviaR7CX4qIhN4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;871&quot;/&gt;&lt;figcaption&gt;MySQL查询缓存&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过一条查询语句的执行过程，来了解一些关键的部件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; T &lt;span&gt;where&lt;/span&gt; &lt;span&gt;ID&lt;/span&gt;=&lt;span&gt;10&lt;/span&gt;；&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1、连接器&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，需要连接数据库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当客户端（应用）连接到MySQL服务器时，服务器需要对其进行认证。认证基于用户名、原始主机信息和密码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;连接命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mysql -h$ip -P$port -u$user -p&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了基本认证之外，连接器还会进行一些线程的处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行，该线程只能轮流在某个CPU核心或者CPU中运行。服务器会负责缓存线程，因此不需要为每一个新建的连接创建或者销毁线程。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2、查询缓存&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于SELECT语句，在解析查询之前，服务器会先检查查询缓存（Query Cache），如果能够在其中找到对应的查询，服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;但不推荐使用查询缓存，为什么呢？因为查询缓存往往弊大于利。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好在MySQL也提供了这种“按需使用”的方式。可以将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存。而对于确定要使用查询缓存的语句，可以用SQL_CACHE显式指定，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;SQL_CACHE&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; T &lt;span&gt;where&lt;/span&gt; &lt;span&gt;ID&lt;/span&gt;=&lt;span&gt;10&lt;/span&gt;；&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面也提到了MySQL8.0彻底废弃了查询缓存的功能。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3、解析器&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果缓存没有命中的话，MySQL会对查询语句进行解析。简单说解析的作用将我们人能看懂的SQL解析成MySQ能识别的语言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解析器先会做“词法解析”。输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL从输入的&quot;select&quot;这个关键字识别出来，这是一个查询语句。它也要把字符串“T”识别成“表名T”，把字符串“ID”识别成“列ID”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做完了这些识别以后，就要做“语法解析”。根据词法解析的结果，语法解析器会根据语法规则，判断输入的这个SQL语句是否满足MySQL语法。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4、优化器&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过了解析器器，MySQL知道我们要干什么。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来并不是直接执行，而是会在优化器这一层进行优化，优化器是个非常复杂的部件，它会帮我去使用他自己认为的最好的方式去优化这条 SQL  语句，并生成一条条的执行计划。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。比如你执行下面这样的语句，这个语句是执行两个表的join：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; t1 &lt;span&gt;join&lt;/span&gt; t2 &lt;span&gt;using&lt;/span&gt;(&lt;span&gt;ID&lt;/span&gt;)  &lt;span&gt;where&lt;/span&gt; t1.c=&lt;span&gt;10&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; t2.d=&lt;span&gt;20&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段。如果你还有一些疑问，比如优化器是怎么选择索引的，有没有可能选择错等等，没关系，我会在后面的文章中单独展开说明优化器的内容。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5、执行器&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL通过解析器知道了你要做什么，通过优化器知道了该怎么做，于是就进入了执行器阶段，执行器会根据一系列的执行计划去调用存储引擎的接口去完成SQL的执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开始执行的时候，要先判断一下你对这个表T有没有执行查询的权限，如果没有，就会返回没有权限的错误，如下所示(在工程实现上，如果命中查询缓存，会在查询缓存放回结果的时候，做权限验证。查询也会在优化器之前调用precheck验证权限)。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; T &lt;span&gt;where&lt;/span&gt; &lt;span&gt;ID&lt;/span&gt;=&lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;ERROR 1142 (42000): &lt;span&gt;SELECT&lt;/span&gt; command denied &lt;span&gt;to&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;&#x27;b&#x27;&lt;/span&gt;@&lt;span&gt;&#x27;localhost&#x27;&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;&#x27;T&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;调用InnoDB引擎接口取这个表的第一行，判断ID值是不是10，如果不是则跳过，如果是则将这行存在结果集中；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，这个语句就执行完成了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于有索引的表，执行的逻辑也差不多。第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这些接口都是引擎中已经定义好的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;big&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【1】：《高性能MySQL》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【2】：极客时间 《MySQL实战45讲》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【3】：《MySQL技术内幕 InnoDB存储引擎》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【4】：[MySQL 8.0: Retiring Support for the Query Cache](https://mysqlserverteam.com/mysql-8-0-retiring-support-for-the-query-cache/)&lt;br/&gt;&lt;br/&gt;【5】：[头条二面: 详解一条 SQL 的执行过程](https://blog.csdn.net/weixin_41385912/article/details/112975752)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODE5ODM0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWeFt08hV3N1706WTzfhoTNoXm5LXRV0XibppmeNR4zSNMa3QOJJ7ib4O21P5yohibwuD26Tp9ETWZAqA/0?wx_fmt=png&quot; data-nickname=&quot;三分恶&quot; data-alias=&quot;Fighter3FullStack&quot; data-signature=&quot;一个全栈开发。分享Java后端、Web前端、计算机基础知识。&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;204&quot; data-backw=&quot;558&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.36484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdBLml8yqRnW8SzBIzu9h5RZaLdMfqqUt3mXMbX3bO0nu0FyfqotEfYm56F1xTqoqsmrQn3icGJ6Dw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>