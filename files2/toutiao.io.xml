<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>c96f48a26c0ae90d4b8066f3c7b8fb85</guid>
<title>从 Linux 源码看 socket 的 close</title>
<link>https://toutiao.io/k/fg9y3td</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h1&gt;从linux源码看socket的close&lt;/h1&gt;&lt;p&gt;笔者一直觉得如果能知道从应用到框架再到操作系统的每一处代码，是一件Exciting的事情。上篇博客讲了socket的阻塞和非阻塞，这篇就开始谈一谈socket的close(以tcp为例且基于linux-2.6.24内核版本)&lt;/p&gt;&lt;h2&gt;TCP关闭状态转移图:&lt;/h2&gt;&lt;p&gt;众所周知，TCP的close过程是四次挥手，状态机的变迁也逃不出TCP状态转移图，如下图所示:&lt;br/&gt;&lt;img data-ratio=&quot;0.5576923076923077&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSnOMwkovogv7LsFqichPhEf38roxic4q4LUGmqgHqRFDpfqsfkoBQ8MiawgwibgibTYoS0bg0ic1rdL4qA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1456&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;br/&gt;tcp的关闭主要分主动关闭、被动关闭以及同时关闭(特殊情况,不做描述)&lt;/p&gt;&lt;h2&gt;主动关闭&lt;/h2&gt;&lt;h3&gt;close(fd)的过程&lt;/h3&gt;&lt;p&gt;以C语言为例，在我们关闭socket的时候，会使用close(fd)函数:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;int    socket_fd;&lt;br/&gt;socket_fd = socket(AF_INET, SOCK_STREAM, 0);&lt;br/&gt;...&lt;br/&gt;// 此处通过文件描述符关闭对应的socket&lt;br/&gt;close(socket_fd)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而close(int fd)又是通过系统调用sys_close来执行的:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;asmlinkage long sys_close(unsigned int fd)&lt;br/&gt;{&lt;br/&gt;    // 清除(close_on_exec即退出进程时）的位图标记&lt;br/&gt;    FD_CLR(fd, fdt-&amp;gt;close_on_exec);&lt;br/&gt;    // 释放文件描述符&lt;br/&gt;    // 将fdt-&amp;gt;open_fds即打开的fd位图中对应的位清除&lt;br/&gt;    // 再将fd挂入下一个可使用的fd以便复用&lt;br/&gt;    __put_unused_fd(files, fd);&lt;br/&gt;    // 调用file_pointer的close方法真正清除&lt;br/&gt;    retval = filp_close(filp, files);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们看到最终是调用的filp_close方法:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;int filp_close(struct file *filp, fl_owner_t id)&lt;br/&gt;{&lt;br/&gt;    // 如果存在flush方法则flush&lt;br/&gt;    if (filp-&amp;gt;f_op &amp;amp;&amp;amp; filp-&amp;gt;f_op-&amp;gt;flush)&lt;br/&gt;        filp-&amp;gt;f_op-&amp;gt;flush(filp, id);&lt;br/&gt;    // 调用fput&lt;br/&gt;    fput(filp);&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;紧接着我们进入fput:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;void fastcall fput(struct file *file)&lt;br/&gt;{&lt;br/&gt;    // 对应file-&amp;gt;count--,同时检查是否还有关于此file的引用&lt;br/&gt;    // 如果没有，则调用_fput进行释放&lt;br/&gt;    if (atomic_dec_and_test(&amp;amp;file-&amp;gt;f_count))&lt;br/&gt;        __fput(file);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同一个file(socket)有多个引用的情况很常见，例如下面的例子:&lt;br/&gt;&lt;img data-ratio=&quot;0.2859848484848485&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSnOMwkovogv7LsFqichPhEfNlgbk14xTlScDs1chVClPnoRVASuvq2nKVEIlVRiaPfS0eABvlLkC2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1056&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;br/&gt;所以在多进程的socket服务器编写过程中，父进程也需要close(fd)一次，以免socket无法最终关闭&lt;/p&gt;&lt;p&gt;然后就是_fput函数了:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;void fastcall __fput(struct file *file)&lt;br/&gt;{&lt;br/&gt;    // 从eventpoll中释放file&lt;br/&gt;    eventpoll_release(file);&lt;br/&gt;    // 如果是release方法，则调用release&lt;br/&gt;    if (file-&amp;gt;f_op &amp;amp;&amp;amp; file-&amp;gt;f_op-&amp;gt;release)&lt;br/&gt;        file-&amp;gt;f_op-&amp;gt;release(inode, file);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于我们讨论的是socket的close,所以，我们现在探查下file-&amp;gt;f_op-&amp;gt;release在socket情况下的实现:&lt;/p&gt;&lt;h3&gt;f_op-&amp;gt;release的赋值&lt;/h3&gt;&lt;p&gt;我们跟踪创建socket的代码，即&lt;/p&gt;&lt;pre&gt;&lt;code&gt;socket(AF_INET, SOCK_STREAM, 0);&lt;br/&gt;    |-sock_create  // 创建sock&lt;br/&gt;    |-sock_map_fd  // 将sock和fd关联&lt;br/&gt;            |-sock_attach_fd&lt;br/&gt;                    |-init_file(file,...,&amp;amp;socket_file_ops);&lt;br/&gt;                            |-file-&amp;gt;f_op = fop; //fop赋值为socket_file_ops&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;socket_file_ops的实现为:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;static const struct file_operations socket_file_ops = {&lt;br/&gt;    .owner =    THIS_MODULE,&lt;br/&gt;    ......&lt;br/&gt;    // 我们在这里只考虑sock_close&lt;br/&gt;    .release =    sock_close,&lt;br/&gt;    ......&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;继续跟踪:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;sock_close&lt;br/&gt;    |-sock_release&lt;br/&gt;        |-sock-&amp;gt;ops-&amp;gt;release(sock);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在上一篇博客中，我们知道sock-&amp;gt;ops为下图所示:&lt;br/&gt;&lt;img data-ratio=&quot;0.4434931506849315&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSnOMwkovogv7LsFqichPhEfIAxSDlBZzLm9WhVU9IibD6Hhaibj5e7qpiaOCbKC8e6e5ic559GZA2K2Jg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1168&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;br/&gt;即(在这里我们仅考虑tcp,即sk_prot=tcp_prot):&lt;/p&gt;&lt;pre&gt;&lt;code&gt;inet_stream_ops-&amp;gt;release&lt;br/&gt;    |-inet_release&lt;br/&gt;            |-sk-&amp;gt;sk_prot-&amp;gt;close(sk, timeout);&lt;br/&gt;                |-tcp_prot-&amp;gt;close(sk, timeout);&lt;br/&gt;                    |-&amp;gt;tcp_prot.tcp_close&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关于fd与socket的关系如下图所示:&lt;br/&gt;&lt;img data-ratio=&quot;0.5472972972972973&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSnOMwkovogv7LsFqichPhEfibO2MeA7USX6zwdZJSQ3ficvIN7jzVwn29sgR2AfqkVkaFyibf2GqGnTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1480&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;br/&gt;上图中红色线标注的是close(fd)的调用链&lt;/p&gt;&lt;h3&gt;tcp_close&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;void tcp_close(struct sock *sk, long timeout)&lt;br/&gt;{&lt;br/&gt;    if (sk-&amp;gt;sk_state == TCP_LISTEN) {&lt;br/&gt;        // 如果是listen状态，则直接设为close状态&lt;br/&gt;        tcp_set_state(sk, TCP_CLOSE);&lt;br/&gt;    }&lt;br/&gt;    // 清空掉recv.buffer&lt;br/&gt;    ......&lt;br/&gt;    // SOCK_LINGER选项的处理&lt;br/&gt;    ......&lt;br/&gt;    else if (tcp_close_state(sk)){&lt;br/&gt;        // tcp_close_state会将sk从established状态变为fin_wait1&lt;br/&gt;        // 发送fin包&lt;br/&gt;        tcp_send_fin(sk);&lt;br/&gt;    }&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;四次挥手&lt;/h3&gt;&lt;p&gt;现在就是我们的四次挥手环节了，其中上半段的两次挥手下图所示:&lt;br/&gt;&lt;img data-ratio=&quot;0.6488222698072805&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSnOMwkovogv7LsFqichPhEfHSiaNibRU3eVGNTm5WYkWKUyZIicSkUbicnvpSve9KvrZEul1V5du3hCPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;934&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;br/&gt;首先，在tcp_close_state(sk)中已经将状态设置为fin_wait1,并调用tcp_send_fin&lt;/p&gt;&lt;pre&gt;&lt;code&gt;void tcp_send_fin(struct sock *sk)&lt;br/&gt;{&lt;br/&gt;    ......&lt;br/&gt;    // 这边设置flags为ack和fin&lt;br/&gt;    TCP_SKB_CB(skb)-&amp;gt;flags = (TCPCB_FLAG_ACK | TCPCB_FLAG_FIN);&lt;br/&gt;    ......&lt;br/&gt;    // 发送fin包，同时关闭nagle&lt;br/&gt;    __tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_OFF);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如上图Step1所示。&lt;br/&gt;接着，主动关闭的这一端等待对端的ACK，如果ACK回来了，就设置TCP状态为FIN_WAIT2,如上图Step2所示,具体代码如下:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;tcp_v4_do_rcv&lt;br/&gt;    |-tcp_rcv_state_process&lt;br/&gt;int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb, struct tcphdr *th, unsigned len)&lt;br/&gt;{&lt;br/&gt;    ......&lt;br/&gt;    /* step 5: check the ACK field */&lt;br/&gt;    if (th-&amp;gt;ack) {&lt;br/&gt;        ...&lt;br/&gt;        case TCP_FIN_WAIT1:&lt;br/&gt;            // 这处判断是确认此ack是发送Fin包对应的那个ack&lt;br/&gt;            if (tp-&amp;gt;snd_una == tp-&amp;gt;write_seq) {&lt;br/&gt;                // 设置为FIN_WAIT2状态&lt;br/&gt;                tcp_set_state(sk, TCP_FIN_WAIT2);&lt;br/&gt;                ......&lt;br/&gt;                // 设定TCP_FIN_WAIT2定时器，将在tmo时间到期后将状态变迁为TIME_WAIT&lt;br/&gt;                // 不过是这时候改的已经是inet_timewait_sock了&lt;br/&gt;                tcp_time_wait(sk, TCP_FIN_WAIT2, tmo);&lt;br/&gt;                ......&lt;br/&gt;            }&lt;br/&gt;    }&lt;br/&gt;    /* step 7: process the segment text */&lt;br/&gt;    switch(sk-&amp;gt;sk_state) {&lt;br/&gt;    case TCP_FIN_WAIT1:&lt;br/&gt;    case TCP_FIN_WAIT2:&lt;br/&gt;        ......&lt;br/&gt;    case TCP_ESTABLISHED:&lt;br/&gt;        tcp_data_queue(sk, skb);&lt;br/&gt;        queued = 1;&lt;br/&gt;        break;&lt;br/&gt;    }&lt;br/&gt;    .....&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;值的注意的是，从TCP_FIN_WAIT1变迁到TCP_FIN_WAIT2之后，还调用tcp_time_wait设置一个TCP_FIN_WAIT2定时器，在tmo+(2MSL或者基于RTO计算超时)超时后会直接变迁到closed状态(不过此时已经是inet_timewait_sock了）。这个超时时间可以配置,如果是ipv4的话,则可以按照下列配置:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;net.ipv4.tcp_fin_timeout&lt;br/&gt;/sbin/sysctl -w net.ipv4.tcp_fin_timeout=30&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如下图所示:&lt;br/&gt;&lt;img data-ratio=&quot;0.4943181818181818&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSnOMwkovogv7LsFqichPhEficnFqTTeicEs5X7hK6agGk8Ik3lvmA1TG1cWgNOSylqDboibhOE2b5ubg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1056&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;br/&gt;有这样一步的原因是防止对端由于种种原因始终没有发送fin,防止一直处于FIN_WAIT2状态。&lt;/p&gt;&lt;p&gt;接着在FIN_WAIT2状态等待对端的FIN，完成后面两次挥手:&lt;br/&gt;&lt;img data-ratio=&quot;0.488929889298893&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSnOMwkovogv7LsFqichPhEfrzpEa8Lvv5YnmG02iazlQY2ibsb6Wng2hib49KIocbibAmLibWhutvvhDew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1084&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;br/&gt;由Step1和Step2将状态置为了FIN_WAIT_2，然后接收到对端发送的FIN之后,将会将状态设置为time_wait,如下代码所示:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;tcp_v4_do_rcv&lt;br/&gt;    |-tcp_rcv_state_process&lt;br/&gt;        |-tcp_data_queue&lt;br/&gt;                |-tcp_fin&lt;br/&gt;static void tcp_fin(struct sk_buff *skb, struct sock *sk, struct tcphdr *th)&lt;br/&gt;{&lt;br/&gt;    switch (sk-&amp;gt;sk_state) {&lt;br/&gt;        ......&lt;br/&gt;        case TCP_FIN_WAIT1:&lt;br/&gt;            // 这边是处理同时关闭的情况&lt;br/&gt;            tcp_send_ack(sk);&lt;br/&gt;            tcp_set_state(sk, TCP_CLOSING);&lt;br/&gt;            break;&lt;br/&gt;        case TCP_FIN_WAIT2:&lt;br/&gt;            /* Received a FIN -- send ACK and enter TIME_WAIT. */&lt;br/&gt;            // 收到FIN之后，发送ACK同时将状态进入TIME_WAIT&lt;br/&gt;            tcp_send_ack(sk);&lt;br/&gt;            tcp_time_wait(sk, TCP_TIME_WAIT, 0);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;time_wait状态时，原socket会被destroy,然后新创建一个inet_timewait_sock,这样就能及时的将原socket使用的资源回收。而inet_timewait_sock被挂入一个bucket中，由&lt;br/&gt;inet_twdr_twcal_tick定时从bucket中将超过(2MSL或者基于RTO计算的时间)的time_wait的实例删除。&lt;br/&gt;我们来看下tcp_time_wait函数&lt;/p&gt;&lt;pre&gt;&lt;code&gt;void tcp_time_wait(struct sock *sk, int state, int timeo)&lt;br/&gt;{&lt;br/&gt;    // 建立inet_timewait_sock&lt;br/&gt;    tw = inet_twsk_alloc(sk, state);&lt;br/&gt;    // 放到bucket的具体位置等待定时器删除&lt;br/&gt;    inet_twsk_schedule(tw, &amp;amp;tcp_death_row, time,TCP_TIMEWAIT_LEN);&lt;br/&gt;    // 设置sk状态为TCP_CLOSE,然后回收sk资源&lt;br/&gt;    tcp_done(sk);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体的定时器操作函数为inet_twdr_twcal_tick,这边就不做描述了&lt;/p&gt;&lt;h2&gt;被动关闭&lt;/h2&gt;&lt;h3&gt;close_wait&lt;/h3&gt;&lt;p&gt;在tcp的socket时候，如果是established状态，接收到了对端的FIN,则是被动关闭状态,会进入close_wait状态,如下图Step1所示:&lt;br/&gt;&lt;img data-ratio=&quot;0.5347985347985348&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSnOMwkovogv7LsFqichPhEfibK2MZUAB9E9wym3O6mX0HE5lLvhGYBJyCW6CBjjCyVOHCghJuUFibbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1092&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;br/&gt;具体代码如下所示:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;tcp_rcv_state_process&lt;br/&gt;    |-tcp_data_queue&lt;br/&gt;static void tcp_data_queue(struct sock *sk, struct sk_buff *skb)&lt;br/&gt;{&lt;br/&gt;    ...&lt;br/&gt;    if (th-&amp;gt;fin)&lt;br/&gt;        tcp_fin(skb, sk, th);&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们再看下tcp_fin&lt;/p&gt;&lt;pre&gt;&lt;code&gt;static void tcp_fin(struct sk_buff *skb, struct sock *sk, struct tcphdr *th)&lt;br/&gt;{&lt;br/&gt;    ......&lt;br/&gt;    // 这一句表明当前socket有ack需要发送&lt;br/&gt;    inet_csk_schedule_ack(sk);&lt;br/&gt;    ......&lt;br/&gt;    switch (sk-&amp;gt;sk_state) {&lt;br/&gt;            case TCP_SYN_RECV:&lt;br/&gt;            case TCP_ESTABLISHED:&lt;br/&gt;                /* Move to CLOSE_WAIT */&lt;br/&gt;                // 状态设置程close_wait状态&lt;br/&gt;                tcp_set_state(sk, TCP_CLOSE_WAIT);&lt;br/&gt;                // 这一句表明，当前fin可以延迟发送&lt;br/&gt;                // 即和后面的数据一起发送或者定时器到时后发送&lt;br/&gt;                inet_csk(sk)-&amp;gt;icsk_ack.pingpong = 1;&lt;br/&gt;                break;&lt;br/&gt;    }&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这边有意思的点是，收到对端的fin之后并不会立即发送ack告知对端收到了，而是等有数据携带一块发送,或者等携带重传定时器到期后发送ack。&lt;/p&gt;&lt;p&gt;如果对端关闭了，应用端在read的时候得到的返回值是0,此时就应该手动调用close去关闭连接&lt;/p&gt;&lt;pre&gt;&lt;code&gt;if(recv(sockfd, buf, MAXLINE,0) == 0){&lt;br/&gt;    close(sockfd)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们看下recv是怎么处理fin包，从而返回0的,上一篇博客可知，recv最后调用tcp_rcvmsg,由于比较复杂，我们分两段来看:&lt;br/&gt;tcp_recvmsg第一段&lt;/p&gt;&lt;pre&gt;&lt;code&gt;        ......&lt;br/&gt;        // 从接收队列里面获取一个sk_buffer&lt;br/&gt;        skb = skb_peek(&amp;amp;sk-&amp;gt;sk_receive_queue);&lt;br/&gt;        do {&lt;br/&gt;            // 如果已经没有数据，直接跳出读取循环，返回0&lt;br/&gt;            if (!skb)&lt;br/&gt;                break;&lt;br/&gt;            ......&lt;br/&gt;            // *seq表示已经读到多少seq&lt;br/&gt;            // TCP_SKB_CB(skb)-&amp;gt;seq表示当前sk_buffer的起始seq&lt;br/&gt;            // offset即是在当前sk_buffer中已经读取的长度&lt;br/&gt;            offset = *seq - TCP_SKB_CB(skb)-&amp;gt;seq;&lt;br/&gt;            // syn处理&lt;br/&gt;            if (tcp_hdr(skb)-&amp;gt;syn)&lt;br/&gt;                offset--;&lt;br/&gt;            // 此处判断表示，当前skb还有数据可读，跳转found_ok_skb&lt;br/&gt;            if (offset &amp;lt; skb-&amp;gt;len)&lt;br/&gt;                goto found_ok_skb;&lt;br/&gt;            // 处理fin包的情况&lt;br/&gt;            // offset == skb-&amp;gt;len,跳转到found_fin_ok然后跳出外面的大循环&lt;br/&gt;            // 并返回0&lt;br/&gt;            if (tcp_hdr(skb)-&amp;gt;fin)&lt;br/&gt;                goto found_fin_ok;&lt;br/&gt;            BUG_TRAP(flags &amp;amp; MSG_PEEK);&lt;br/&gt;            skb = skb-&amp;gt;next;&lt;br/&gt;        } while (skb != (struct sk_buff *)&amp;amp;sk-&amp;gt;sk_receive_queue);&lt;br/&gt;        ......&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面代码的处理过程如下图所示:&lt;br/&gt;&lt;img data-ratio=&quot;0.3670520231213873&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSnOMwkovogv7LsFqichPhEfiaIciaAO0InTM3sX28K5yEf7gKwrcoeYeSHt6BgpicJFgwzQYTkbMHqdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1384&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;br/&gt;我们看下tcp_recmsg的第二段:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;found_ok_skb:&lt;br/&gt;        // tcp已读seq更新&lt;br/&gt;        *seq += used;&lt;br/&gt;        // 这次读取的数量更新&lt;br/&gt;        copied += used;&lt;br/&gt;        // 如果还没有读到当前sk_buffer的尽头，则不检测fin标识&lt;br/&gt;        if (used + offset &amp;lt; skb-&amp;gt;len)&lt;br/&gt;            continue;&lt;br/&gt;        // 如果发现当前skb有fin标识，去found_fin_ok&lt;br/&gt;        if (tcp_hdr(skb)-&amp;gt;fin)&lt;br/&gt;            goto found_fin_ok;&lt;br/&gt;        ......&lt;br/&gt;found_fin_ok:&lt;br/&gt;        /* Process the FIN. */&lt;br/&gt;        // tcp已读seq++&lt;br/&gt;        ++*seq;&lt;br/&gt;        ...&lt;br/&gt;        break;&lt;br/&gt;} while(len &amp;gt; 0);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由上面代码可知，一旦当前skb读完了而且携带有fin标识，则不管有没有读到用户期望的字节数量都会返回已读到的字节数。下一次再读取的时候则在刚才描述的tcp_rcvmsg上半段直接不读取任何数据再跳转到found_fin_ok并返回0。这样应用就能感知到对端已经关闭了。&lt;br/&gt;如下图所示:&lt;br/&gt;&lt;img data-ratio=&quot;0.3844049247606019&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSnOMwkovogv7LsFqichPhEfy4tyfG7oONGGLhJyJ7JIag8qb8SgUzh4vAz2UdHOibQR7nhic3Ev7ubA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1462&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&lt;h3&gt;last_ack&lt;/h3&gt;&lt;p&gt;应用层在发现对端关闭之后已经是close_wait状态，这时候再调用close的话，会将状态改为last_ack状态，并发送本端的fin,如下代码所示:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;void tcp_close(struct sock *sk, long timeout)&lt;br/&gt;{&lt;br/&gt;    ......&lt;br/&gt;    else if (tcp_close_state(sk)){&lt;br/&gt;        // tcp_close_state会将sk从close_wait状态变为last_ack&lt;br/&gt;        // 发送fin包&lt;br/&gt;        tcp_send_fin(sk);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在接收到主动关闭端的last_ack之后，则调用tcp_done(sk)设置sk为tcp_closed状态，并回收sk的资源,如下代码所示:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;tcp_v4_do_rcv&lt;br/&gt;    |-tcp_rcv_state_process&lt;br/&gt;int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb, struct tcphdr *th, unsigned len)&lt;br/&gt;{&lt;br/&gt;    ......&lt;br/&gt;    /* step 5: check the ACK field */&lt;br/&gt;    if (th-&amp;gt;ack) {&lt;br/&gt;        ...&lt;br/&gt;        case TCP_LAST_ACK:&lt;br/&gt;            // 这处判断是确认此ack是发送Fin包对应的那个ack&lt;br/&gt;            if (tp-&amp;gt;snd_una == tp-&amp;gt;write_seq) {&lt;br/&gt;                    tcp_update_metrics(sk);&lt;br/&gt;                    // 设置socket为closed，并回收socket的资源&lt;br/&gt;                    tcp_done(sk);&lt;br/&gt;                    goto discard;&lt;br/&gt;            }&lt;br/&gt;        ...&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码就是被动关闭端的后两次挥手了,如下图所示:&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5622641509433962&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSnOMwkovogv7LsFqichPhEfJqDFrzadZcH74R2rISk8D8ZfXHokc2DAXqKgQOIVPPTicxLR5mnMyDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1060&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&lt;h3&gt;出现大量close_wait的情况&lt;/h3&gt;&lt;p&gt;linux中出现大量close_wait的情况一般是应用在检测到对端fin时没有及时close当前连接。有一种可能如下图所示:&lt;br/&gt;&lt;img data-ratio=&quot;0.5744360902255639&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSnOMwkovogv7LsFqichPhEfogLryVmOkria1Paxsp8qEYEZBIf7KNeZ94cOp6ACQcNmx8eTsGhIrtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1330&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;br/&gt;当出现这种情况，通常是minIdle之类参数的配置不对(如果连接池有定时收缩连接功能的话)。给连接池加上心跳也可以解决这种问题。&lt;br/&gt;如果应用close的时间过晚，对端已经将连接给销毁。则应用发送给fin给对端，对端会由于找不到对应的连接而发送一个RST(Reset)报文。&lt;/p&gt;&lt;h3&gt;操作系统何时回收close_wait&lt;/h3&gt;&lt;p&gt;如果应用迟迟没有调用close_wait,那么操作系统有没有一个回收机制呢，答案是有的。&lt;br/&gt;tcp本身有一个包活(keep alive)定时器，在(keep alive)定时器超时之后，会强行将此连接关闭。可以设置tcp keep alive的时间&lt;/p&gt;&lt;pre&gt;&lt;code&gt;/etc/sysctl.conf&lt;br/&gt;net.ipv4.tcp_keepalive_intvl = 75&lt;br/&gt;net.ipv4.tcp_keepalive_probes = 9&lt;br/&gt;net.ipv4.tcp_keepalive_time = 7200&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;默认值如上面所示，设置的很大，7200s后超时，如果想快速回收close_wait可以设置小一点。但最终解决方案还是得从应用程序着手。&lt;br/&gt;关于tcp keepalive包活定时器可见笔者另一篇博客:&lt;br/&gt;https://my.oschina.net/alchemystar/blog/833981&lt;/p&gt;&lt;h2&gt;进程关闭时清理socket资源&lt;/h2&gt;&lt;p&gt;进程在退出时候(无论kill,kill -9 或是正常退出)都会关闭当前进程中所有的fd(文件描述符)&lt;/p&gt;&lt;pre&gt;&lt;code&gt;do_exit&lt;br/&gt;    |-exit_files&lt;br/&gt;        |-__exit_files&lt;br/&gt;            |-close_files&lt;br/&gt;                    |-filp_close&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样我们又回到了博客伊始的filp_close函数，对每一个是socket的fd发送send_fin&lt;/p&gt;&lt;h2&gt;Java GC时清理socket资源&lt;/h2&gt;&lt;p&gt;Java的socket最终关联到AbstractPlainSocketImpl,且其重写了object的finalize方法&lt;/p&gt;&lt;pre&gt;&lt;code&gt;abstract class AbstractPlainSocketImpl extends SocketImpl&lt;br/&gt;{&lt;br/&gt;    ......&lt;br/&gt;    /**&lt;br/&gt;     * Cleans up if the user forgets to close it.&lt;br/&gt;     */&lt;br/&gt;    protected void finalize() throws IOException {&lt;br/&gt;        close()&lt;br/&gt;    }&lt;br/&gt;    ......&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;所以Java会在GC时刻会关闭没有被引用的socket,但是切记不要寄希望于Java的GC,因为GC时刻并不是以未引用的socket数量来判断的，所以有可能泄露了一堆socket,但仍旧没有触发GC。&lt;/p&gt;&lt;h2&gt;总结&lt;/h2&gt;&lt;p&gt;linux内核源代码博大精深，阅读其代码很费周折。之前读\&amp;lt;\&lt;tcp&gt;&amp;gt;的时候由于有先辈引导和梳理，所以看书中所使用的BSD源码并不觉得十分费劲。直到现在自己带着问题独立看linux源码的时候，尽管有之前的基础，仍旧被其中的各种细节所迷惑。希望笔者这篇文章能帮助到阅读linux网络协议栈代码的人。&lt;/tcp&gt;&lt;/p&gt;&lt;h2&gt;原文链接&lt;/h2&gt;&lt;p&gt;https://my.oschina.net/alchemystar/blog/1821680&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c0bb86e4c77ddfc3c5e658996778a1bc</guid>
<title>本地生活综合性需求图谱的构建及应用</title>
<link>https://toutiao.io/k/mz1bk58</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一、背景&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;二、解决方案&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;三、实现方法&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.1 行业体系层&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.2 需求对象层&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.3 具象需求层&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.4 场景要素层&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.5 场景需求层&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;四、应用实践&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;五、总结展望&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一、背景&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.1 业务现状&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以“帮大家吃得更好，生活更好”为使命，美团覆盖了外卖、餐饮、酒店、民宿、旅游、门票、电影/演出、休闲/玩乐、丽人、医疗、亲子、教育、结婚、生活服务等数百个行业，满足数以亿计用户的多样化生活服务需求。为了持续增加平台价值，除了推动用户和商户在数量和质量上的不断提升之外，更高效地匹配用户需求和商户供给也是重要抓手之一。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了提升匹配的效率，我们需要更充分、深入地理解用户需求和商户供给，并且尝试从用户视角出发来组织和管理供给。当前，“行业-类目-商户-商品”是一种较为常见的供给组织和管理方式，然而随着业务和行业的快速发展，这种组织方式带来的痛点日渐突显，举例来说：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;部分指向性不明确的用户需求，较难得到适合的匹配结果。例如“周末陪宝宝去哪儿玩？”由于平台的匹配结果不理想，用户往往只能在线下完成类目决策，决定带宝宝去农家乐烧烤，再到平台上搜索相应的农家乐团购。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;部分需求跨多个类目，匹配过程不够流畅。例如“周末和朋友去哪里放松一下？”用户在线下完成类目决策后，可选类目包括KTV、酒吧、密室、桌游等，但各类目的承载页面相互独立，用户需要在承载页面间来回切换。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在部分指向明确的类目中，用户仍然难以找到满足自己需求的供给。例如在医美类目下，因为缺乏相关知识，用户往往并不了解商户提供的形形色色的服务项目分别具有什么功效，适合什么部位，应该使用什么材料，无法高效地找到适合自己的服务供给。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上述问题的本质原因在于供给的组织方式主要是从行业视角出发，没有充分考虑到用户视角。在当前以满足用户需求为首要目标的市场环境下，我们需要迭代完善现有的供给组织方式。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.2 问题解析&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了解决上述问题，我们尝试从一个外部视角，结合第一性原理去进行剖析。在整个人类社会中，按照马斯洛需求层次&lt;sup&gt;[1]&lt;/sup&gt;的理论，人的需求是可以被归纳及分层的。如果将人类社会看作一个系统，人类在其中一个称为“市场”的子系统中，通过交易来满足自己的需求。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;人类从需求层次出发，在市场中完成交易，最终需求得以满足，那么在市场中交易的过程可以被拆解为“起心动念-&amp;gt;考虑-&amp;gt;选择评估-&amp;gt;交易购买-&amp;gt;履约/服务”。并且，经由前三个阶段，用户的需求逐渐从粗粒度演变为细粒度，从抽象过渡到具象。下面将结合具体的例子来进行解读：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;需求层次&lt;/strong&gt;：在马斯洛需求层次中有一个情感层次，对应了人类丰富多样的情感需求，包含亲情、友情、爱情等等。作为一个母亲，与自己的宝宝之间往往存在一种强烈的母子情，并且希望不断去强化这种情感。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;起心动念&lt;/strong&gt;：为此，母亲往往都会尽力花较多的时间去陪伴宝宝。通过增加陪伴方式的维度，变为“陪宝宝玩”；通过增加时间、空间等维度，变为“周末陪宝宝去哪儿玩？”&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;考虑&lt;/strong&gt;：对于上述问题，母亲会找出很多种方案，比如户外烧烤、农家采摘、主题公园等等。当她决定选用户外烧烤这一方案时，便会转化为具体的商品需求，如购买烤架。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;评估选择&lt;/strong&gt;：母亲于是在可触达的供给范围中进行选择。正如人们常说的货比三家，选择的依据会各不相同，如价格、质量、口碑等等。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;交易购买&lt;/strong&gt;：当完成选择之后，母亲便会进行交易，以换取商品或服务。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;履约服务&lt;/strong&gt;：即商品到货、完成服务等等。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;市场是人类社会的一个子系统，电商平台则是市场中的一个子系统。同时，电商平台是一种线上化的子系统，它提供了搜索、推荐等形式的供给检索能力。当前的一个现状是：用户往往在线下完成了“起心动念”到“考虑”的过程，转化为具体的商品/服务需求，随后进入电商平台完成“选择评估”到“履约服务”的后续过程（&lt;/span&gt;&lt;span&gt;如下图1所示&lt;/span&gt;&lt;span&gt;）。而电商平台往往聚焦于后三个阶段的能力提升，容易忽略前两个阶段。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6717948717948717&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWkROqbUOkxgoZReLFeaRAicjVCdAOubRspdQo5MZJNU4hygD0hw6QNEu3fUOpHDe6SBU5D04o3ibMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1170&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 1&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此，用户较难形成在平台上完成“起心动念”和“考虑”的心智，而大部分电商平台按“行业-类目-商户-商品”的方式对供给进行组织和管理。最终，用户和电商平台之间形成了一种相互掣肘的关系。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;事实上，相对于“烤架”这种明确的商品需求，用户还有很多抽象的、模糊的、不明确的需求，依然停留在前两个阶段。例如，周末陪宝宝去哪儿玩？周末和朋友去哪里放松一下？结婚前怎样才能让自己变得更美？暑假如何培养孩子的动手能力？同时，这样的需求往往跨越多个类目，或者在同类目下存在多种选择。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;电商平台只有打破既有的掣肘关系，向用户提供前两个阶段（&lt;/span&gt;&lt;span&gt;起心动念、考虑&lt;/span&gt;&lt;span&gt;）的能力，才能进一步满足用户的需求。用户的决策成本进一步降低，决策过程更加连贯，用户体验也能得到相应的提升，同时用户在市场中的交易过程也能够进一步实现线上化。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以“行业-类目-商户-商品”作为参考，&lt;strong&gt;如果电商平台能够识别出用户在前两个阶段的需求，并且在其和供给之间建立新的关联关系，辅以搜索、推荐等检索能力，用户便有可能在线上完成前两个阶段&lt;/strong&gt;。而知识图谱作为一种揭示实体之间关系的语义网络，用以解决上述问题显得尤为合适。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;二、解决方案&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1 解决思路&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;延续1.2中的例子，这位母亲将“周末陪宝宝去哪儿玩？”的需求转化为具体的“户外烧烤”需求，延伸至更为具体的“烤架”和“农家乐团购”需求。此时，母亲便会分别前往各类实物电商平台以及以美团为代表的生活服务电商平台进行“选择评估”。两种电商平台分别在实物供给池或服务供给池中采用搜索、推荐之类的召排技术定位到具体的商品/服务，并反馈给这位母亲。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于1.2中的所述，技术团队期望达成的目的，目前比较有代表性的参考案例是阿里巴巴电商认知图谱AliCoCo&lt;sup&gt;[2]&lt;/sup&gt;。它基本构建思路是从用户视角出发，先进行各种类型的原子词挖掘，再进一步对原子词进行组合和挖掘出相关候选短语，再从中识别出真实的用户需求，最后关联至相应的供给。它的层次结构如图2所示：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;分类层&lt;/strong&gt;：构建完备的分类体系，包含了的大千世界的各种分类，既有通用的空间、时间等类别，也有电商中涉及的颜色、功能以及最为重要的品类等类别。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;原子概念层&lt;/strong&gt;：在分类层诸多类别的基础上进行扩展，包含了各种类别下的原子概念（&lt;/span&gt;&lt;span&gt;例如空间-&amp;gt;户外、事件-&amp;gt;烧烤、时间-&amp;gt;圣诞节、颜色-&amp;gt;红色、功能-&amp;gt;保暖、品类-&amp;gt;连衣裙&lt;/span&gt;&lt;span&gt;）及原子概念之间的关系。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;电商概念层&lt;/strong&gt;：在原子概念层之上，包含了由原子概念组成或直接挖掘的短语粒度的用户购物需求，即电商概念（&lt;/span&gt;&lt;span&gt;例如户外烧烤&lt;/span&gt;&lt;span&gt;），从而将用户购物需求显式地用一个符合自然语言的短语表示。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;商品层&lt;/strong&gt;：包含了商品与各种原子概念、电商概念之间的关联关系（&lt;/span&gt;&lt;span&gt;例如户外烧烤-&amp;gt;烤架、黄油、锡纸&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.525035765379113&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWkROqbUOkxgoZReLFeaRAicO1Fqs1zUNqx7N2N7hEw7MbTjNT4uG8Z7JETKusibVmANiaVF8Tu9NLbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1398&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 2&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基于上述图谱，这位母亲可以直接在天猫上表达“户外烧烤”的需求，而非更具体的“烤架”；天猫也会将烤架以外其他和户外烧烤相关的重要商品反馈给这位母亲。从对应关系来看，AliCoCo的电商概念层对应至“考虑”阶段，商品层对应至“选择评估”阶段。显然，由于AliCoCo的存在，天猫能够从“考虑”阶段开始介入用户的交易过程。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由此推论，我们应该可以将图谱构建得更为完整，以覆盖“起心动念”阶段。在此阶段，人类的需求，按马斯洛需求层次，通过增加一个或多个维度约束，而被逐渐具象化。对于这样的维度约束，我们统称为“场景约束”。因此，我们将“考虑”阶段对应的需求称为“具象需求”；将“起心动念”阶段对应的需求称为“场景需求”。为此，我们希望构建一个&lt;strong&gt;本地生活综合性需求图谱（GENE：&lt;strong&gt;lifestyle &lt;strong&gt;GE&lt;/strong&gt;neral &lt;strong&gt;NE&lt;/strong&gt;eds net&lt;/strong&gt;）&lt;/strong&gt;，如下图3所示。对于本地生活场景下所涉及的数百个综合性行业，我们认为新的供给组织方式更能贴近用户需求，也是从用户视角去解决供需匹配的问题。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48046230049532196&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWkROqbUOkxgoZReLFeaRAicw3Sv8cQcDPfwpnUxOzMUeYsMnzAVSWHgjj6ecSq5EzD85TMsSZ6DeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1817&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 3&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2 具体方案&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;延续2.1中的构建思路，我们尝试构建一套多层次的图谱结构，并将“具象需求”和“场景需求”拆分为独立的层次，既避免了两种类型的需求合在同一层级中而引起混淆，又能对用户场景化的需求进行更详尽的拆解、更丰富的刻画。本地生活综合性需求图谱（&lt;/span&gt;&lt;span&gt;GENE&lt;/span&gt;&lt;span&gt;），主要由六部分构成，包含场景需求层、场景要素层、具象需求层、需求对象层、行业体系层和供给层，如下图4所示：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;286&quot; data-ratio=&quot;0.53604568165596&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVr2YQEnJOlA9vRMeZPsShNZ98grQJCGHdZUmxHlVcTNC386hk7Brq5VS8bG7Ednb5ic4OWzqQsIeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2802&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 4&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在场景需求层，我们用Human-Readable的短句来表征场景化的用户需求，如“国庆节陪3岁宝宝去哪玩”、“结婚前让自己变得更美”、“小学生提升思维能力”等。一个场景需求的表述中，通常会包含人物、目的、时间、空间、方式等要素，以“国庆节陪3岁宝宝去哪玩”为例，“3岁宝宝”是人物，“陪宝宝玩”是目的，“国庆节”是时间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在场景要素层，为了更好地表达场景需求，我们将这些短句进行拆解，细化成多个细粒度的词汇，用这些词汇对场景需求中的人物、目的、时间、空间、方式等要素进行完整的覆盖和系统的组织，我们将其称为“场景要素”。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在具象需求层，由于场景需求的表述往往并不显式地指向某个具体的服务/供给，而是隐含了一批潜在的适合这一场景的服务/供给。例如，在“国庆节陪3岁宝宝去哪玩”这个例子中，户外烧烤、喂羊驼、玩滑梯、骑小马等都是适合这一场景需求的具体服务。所以我们需要将所有这些具体的服务通过短语的形式显式的展现出来，这些短语直接反应了用户具体的服务需求，被称之为“具象需求”。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在需求对象层，为了进一步的理解具象需求，我们将具象需求分为具体的服务需求所对应的对象，我们称之为“需求对象”，以及该服务中用户和对象之间的交互行为。例如，对于具象需求喂羊驼，可以分为羊驼（&lt;/span&gt;&lt;span&gt;需求对象&lt;/span&gt;&lt;span&gt;）和喂（&lt;/span&gt;&lt;span&gt;服务交互&lt;/span&gt;&lt;span&gt;），由于本地生活服务的多样性，围绕羊驼这一需求对象，除了喂羊驼外，还可以产生触摸羊驼、骑羊驼和看羊驼表演等多种具象需求。这一层除了包含需求对象节点外，也会涵盖需求对象的属性信息，以对需求对象进行更详尽地描述。例如对于具象需求户外烧烤，可分为烧烤（&lt;/span&gt;&lt;span&gt;需求对象&lt;/span&gt;&lt;span&gt;）、户外（&lt;/span&gt;&lt;span&gt;需求对象属性&lt;/span&gt;&lt;span&gt;）和体验（&lt;/span&gt;&lt;span&gt;隐含的服务交互&lt;/span&gt;&lt;span&gt;）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在行业体系层，由于用户的场景需求和具象需求往往会跨越多个传统的服务类目，为了给用户需求确定一个具体的业务范围，我们还需要构建出各行业涉及的类目体系，作为上述各层构建的业务基础。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在供给层，包含内容这类虚拟供给和商户与商品这类实体供给，这些供给将会和具象需求和场景需求等节点进行关联，从而为用户需求提供相对应的供给支撑。例如，一个提供户外烧烤的供给将会关联上具象需求“户外烧烤”，并进一步关联上场景需求“国庆节陪3岁宝宝去哪玩”。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;综上所述，在本地生活综合性需求图谱中，用户场景化的需求和具体的服务需求被分别表达成短句级别的场景需求和短语级别的具象需求。这两种需求分别通过场景要素和需求对象进行表达。最后，不同类型的供给都会和场景需求和具象需求相关联，从而以用户需求为纽带，提升供给和用户的匹配效率。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;三、实现方法&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当前，本地生活综合性需求图谱已经初步涵盖了用户在玩乐、医美和教育三个本地生活相关行业中的多元化需求。我们在图谱的构建过程中，自底向上按照行业体系层、需求对象层、具象需求层、场景要素层、场景需求层的顺序逐层进行构建，并将各层的节点与各种类型的供给建立关联关系。下文将以玩乐行业为例，对图谱每一层的构建细节以及涉及的算法进行介绍。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1 行业体系层&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.1 行业类目树的构建&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在玩乐行业中，行业体系层包含了能够提供玩乐服务的类目，类目信息通过一个树形结构来表征。由于玩乐行业体系的构建，对专家知识的要求非常高，并且这部分的设计对后续各层的知识挖掘至关重要，因此我们没有直接进行人工定义，而是以当前我们成熟的行业类目树为基础，通过对其进行剪枝和分裂来构建。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先在类目树中筛选出和玩乐相关的一级类目节点，包括“休闲娱乐”、“亲子”、“旅游”、“餐饮”等。对于每个一级类目，我们进一步筛选其和玩乐相关的下一级类目直至叶子类目，并剪去与玩乐无关的类目。此外，我们还对剪枝后的类目树中可以细分的玩乐相关的叶子类目进行分裂，例如将“洗浴”细分为“私汤”、“洗浴中心”等，最终得到完整的玩乐行业类目树。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1.2 类目的供给关联&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;确定了类目树后，我们还需要获取实体供给（&lt;/span&gt;&lt;span&gt;商户和商品&lt;/span&gt;&lt;span&gt;）和虚拟供给（&lt;/span&gt;&lt;span&gt;内容，例如UGC&lt;/span&gt;&lt;span&gt;）与类目的从属关系，从而为后续的一系列挖掘提供数据支持。由于商品和内容均可链接到商户，所以我们只需要获取商户与类目的从属关系即可。玩乐类目树是对我们已有的类目进行剪枝和分裂得到的，除了分裂出的新类目外，其余类目和商户的关系均可直接继承原有的结果。对于新分裂的类目，我们则需要重新构建商户和其之间的从属关系。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;要判断一个商户属于哪个类目，最直观的依据就是商户名、商品名及商品详情，然而很多商户的商户名和商品包含的信息往往较少，增加了类目判别的难度。为了确保商户类目判别的准确性，我们引入更多的商户信息，包括商户UGC和商户画像，设计了一个多源异构数据融合判别模型，整体模型结构如下图5所示：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4819855884707766&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWkROqbUOkxgoZReLFeaRAich2Ht7UbL3RPZ6dHhKvJDcL6rgKiabzegpUOjHVyHnxftWKlHVpkZFfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2498&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 5&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其中，不同来源数据的特征提取和处理方式如下：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;商户名、商品名及商品详情：均为文本数据，直接通过BERT&lt;sup&gt;[3]&lt;/sup&gt;提取文本特征后输出。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;商户UGC：由于商户的UGC往往数量非常多，为了对其信息进行有效利用，首先通过Doc2Vec&lt;sup&gt;[4]&lt;/sup&gt;的方式进行Encode得到UGC的特征后，再通过一个Self-Attention&lt;sup&gt;[5]&lt;/sup&gt;模块进行特征处理后输出。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;商户画像：转成One-Hot特征后，通过全连接层进行非线性映射后输出。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上述三种特征相连接后进行融合，通过全连接层和softmax层实现最终的类目判别。基于多源数据的融合建模，商户信息得到了充分利用。以洗浴细分类目为例，仅利用商户名、商品名及商品详情数据，基于BERT判别，准确率为92%，而基于多源融合模型判别后，准确率提升到98%。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2 需求对象层&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在需求对象层，我们希望能够挖掘出玩乐行业体系中各类目涉及的玩乐对象词作为该层的节点，这些词能够描述出用户在实际玩乐过程中的交互对象，这是用于组成具象玩乐需求的基础。为了确保玩乐对象挖掘的全面性，我们采用多源多方法的形式。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在数据上，我们采用来自商户和用户的相关文本作为挖掘语料。在方法上，我们采用两种方式来挖掘玩乐对象词：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一种是无监督的扩充，在开始挖掘前运营会首先根据经验，提供一些玩乐对象词作为种子输入，我们提前利用语料构建无监督的Skip-Gram结构的Word2Vec模型，对业务输入的种子词提取词向量，并结合余弦相似度，快速扩充相关的对象词。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二种是有监督的标注，我们将其定义序列标注问题，采用基于BERT+CRF的模型，在语料中自动识别出新的对象词。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在实践过程中，为了更高效的挖掘，我们将无监督环节扩充和质检后的对象词在语料中进行文本匹配，并将匹配结果转化为有监督标注环节的训练样本；同时对于有监督标注的结果，经过运营质检后，也会将其作为无监督扩充的输入，通过两个环节相结合，我们完成玩乐对象的挖掘，完整流程如下图6所示。此外，在运营人工审核玩乐对象词的过程中，对于一些业务已知的核心玩乐对象，也会直接输入业务侧已经沉淀的相关特征作为其属性，进一步完善玩乐对象的信息，例如对于“剧本杀”这一玩乐对象，增加相应的“实景”和“桌面”等类型属性。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5195266272189349&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWkROqbUOkxgoZReLFeaRAicTUaZgFoJ9Ty6jYapKR7gx5gIwul7s6lO1Nca99X2ksjjXe7kL84qog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1690&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 6&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在获取对象词后，我们还需要知道对象词属于哪个类目，以便下一步的具象需求挖掘及供给关联，为此我们构建对象词和类目之间的关系。通过各类目下的语料文本中提及对象词的次数来衡量两者关系，是最直观且准确率最高的方法。因此，我们直接使用对象词在每个类目下的语料中进行文本匹配，通过词频高低来确定关系。同时，我们进一步构建对象词之间的上下位和同义关系，当前常见的有通过投影和分类（&lt;/span&gt;&lt;span&gt;如BERT句间关系模型&lt;/span&gt;&lt;span&gt;）等方法来进行关系判别等有监督方法。在实际过程中，我们采用规则辅助人工的方式，基于对象词的统计特征及Pattern共现的结果指导人工快速完成构建。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3 具象需求层&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.1 具象需求挖掘&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;具象需求层可以看成是用户在玩乐行业中的具体服务需求的集合，每个具象玩乐需求是该层的一个节点，由玩乐对象叠加用户与对象之间的多元化的交互行为及对象描述信息得到，它通过短语的形式表达出用户对于玩乐服务供给的本质诉求。具体玩乐需求挖掘的流程流程可以分为两个步骤：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;候选短语生成&lt;/strong&gt;：围绕玩乐对象词，生成大量包含玩乐对象的短语，作为具象玩乐需求候选集。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;短语质量判别&lt;/strong&gt;：建立一个语义判别模型从候选集中提取真实的具象玩乐需求。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;候选短语生成&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在步骤1中，首先我们以需求对象词为核心，采用与玩乐对象挖掘相同的语料，进行候选短语的生成。常用的短语挖掘算法如AutoPhrase&lt;sup&gt;[6]&lt;/sup&gt;，是以Ngram来进行短语组合，而这种形式对于有需求对象的短语显得过于冗余，所以我们考虑基于句法结构来进行短语挖掘。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了使生成短语符合句法的要求，我们以预设的句法关系为模板进行挖掘。在大规模语料中为了更高效地挖掘句法关系，我们基于更轻便的ELECTRA&lt;sup&gt;[7]&lt;/sup&gt;预训练模型获取句子各成分的Embedding后，再利用BiAffine&lt;sup&gt;[8]&lt;/sup&gt;预测其句法关系。通过依存句法分析，我们在各个类目的语料中挖掘出包含相应的玩乐对象且符合句法关系的短语。此外，需求对象层中对象的属性也会被用作对象描述进行短语生成。最终所有挖掘的短语，经过词频等统计特征粗筛后将作为具象玩乐需求的候选集，挖掘示例如图7(a)所示。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34945054945054943&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWkROqbUOkxgoZReLFeaRAicdPssqe4FmGh98AuxF0t2P54Sicey9kjJuK04pcAysJWOAaXycpGdgvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1820&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 7&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;短语质量判别&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在步骤2中，经过步骤1获取的候选集短语虽然符合预设的句法关系，但是从语义上仍然存在大量与用户实际需求不符的表述，通过抽检分析我们发现符合要求的短语不足10%。如何从海量的候选短语中挑选出反映真实的用户具象玩乐需求的短语成为亟需解决的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;AutoPhrase通过基于短语统计特征的判别模型进行短语打分，然而仅通过统计特征难以识别语义质量低的短语，为此我们进一步基于统计和语义特征联合建模，构建一个Wide&amp;amp;Deep&lt;sup&gt;[9]&lt;/sup&gt;结构的判别模型，对候选集合中的短语是否为具象玩乐需求进行判别，我们希望判别模型能过滤掉大量的低质短语，从而为运营节省大量的人力成本。判别模型的整体结构如图7(b)所示，其中：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Wide部分，提取候选短语的全局和上下文的统计特征，通过全连接层进行非线性映射后输出。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Deep部分，提取候选短语的深度语义特征，通过BERT完成相应特征的提取后输出。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上述Wide和Deep部分输出的特征相连接后进行融合，优势互补，经过全连接层和softmax层来实现最终的短语判别。在实践过程中，除了直接使用已经积累的短语标签作为正样本外，我们还通过预设一些常识性的Pattern从候选集中构造正样本，例如观赏[植物]、触摸[动物]，并对候选集采样构造负样本，完成初版模型的训练，之后结合主动学习，经过多轮迭代，模型最终达到92%的召回率和85%的准确率。通过质量判别后保留的短语则会交由运营人工审核提炼后成为最终的具象玩乐需求。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3.2 具象需求的供给关联&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在具象需求层中，由于具象玩乐需求是由玩乐对象得到的，所以两者之间天然地建立了对应关系。而对于具象玩乐需求之间的上下位和同义关系，则可以基于其对象之间的关系及其句法关系，在人工审核的环节来辅助人工完成构建。除此之外，更重要的是需要将具象玩乐需求与实体供给（&lt;/span&gt;&lt;span&gt;商户和商品&lt;/span&gt;&lt;span&gt;）及虚拟供给（&lt;/span&gt;&lt;span&gt;内容，例如UGC&lt;/span&gt;&lt;span&gt;）进行关联。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们将这个问题抽象为一个语义匹配的问题，通过具象玩乐需求与其对应的类目的供给的文本信息进行匹配来实现，其中，商户使用商户名文本信息，商品使用商品名和商品详情文本信息，UGC使用其自身文本信息。由于UGC和商品属于商户的一部分，所以具象玩乐需求与UGC/商品的关系也会加入其与商户关系的构建中。整体匹配流程如下图8所示，我们首先进行具象玩乐需求与UGC/商品的匹配，在此基础上再结合商户名文本的匹配结果，一起通过规则聚合后关联到商户。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34247967479674796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWkROqbUOkxgoZReLFeaRAic7CIMeH3UJibFzSqNXZKgUcDy67Fa47OCqLPC7SOEqS6FriaLIy3TlqKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1968&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 8&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由于具象玩乐需求数量众多，同时供给的文本信息通常包含多个子句，出于效率和效果的平衡考虑，我们将匹配过程分为了召回和排序两个阶段。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在召回阶段，我们粗筛出和具象玩乐需求可能有潜在关联的子句。对于具象玩乐需求，我们基于构建的同义关系，扩展具象需求的同义标签，并将其与子句文本进行粗粒度Pattern匹配，对于匹配中的子句则将进入到排序阶段进行精细化的关联关系计算。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在排序阶段，我们构建基于BERT句间关系分类的语义匹配模型，通过在BERT后增加全连接层和softmax层来实现分类。模型通过对召回阶段得到的粗筛样本进行预测，识别两者在语义上的匹配关系（&lt;/span&gt;&lt;span&gt;关联/不关联&lt;/span&gt;&lt;span&gt;）。最终供给关联关系的平均召回率和准确率分别达到90%和95%。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4 场景要素层&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4.1 场景要素拆解&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;场景要素层包含了组成用户场景化需求的场景要素。如文初提及，要描述一个场景，需要交代特定的人物、时间、空间、目的等要素。例如，对于“国庆节陪3岁宝宝去哪儿玩？”这个场景化需求，我们可做如下拆解：时间-国庆节，人物-3岁宝宝，目的-亲情陪伴（&lt;/span&gt;&lt;span&gt;陪宝宝玩&lt;/span&gt;&lt;span&gt;）。所以我们按照上述方式，对场景要素进行拆解，以期对场景要素的挖掘和梳理尽可能的全面与系统。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4.2 场景要素挖掘&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;完成了场景要素拆解后，下一步就是要分别在每个拆解的类别中进行场景要素的挖掘。场景要素作为具象需求的场景化的信息，往往来自于用户的直观感受，所以挖掘的语料我们选择与具象玩乐需求关联的UGC的上下文语料。与需求对象挖掘的方法类似，我们将每个类别的已提炼总结的场景要素作为种子词，通过相关要素扩充和序列标注的方式完成场景要素的挖掘。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;确定场景要素后，接下来的关键是完成场景要素与具象玩乐需求的关系构建，即对于每个场景要素，找出其适合的具象玩乐需求，如春季适合观赏樱花、孩子适合亲近动物。我们通过对UGC文本分析后发现，UGC中用户说到某一具象玩乐需求的同时，往往也会交代一些相关的场景要素信息，所以我们继续选择与具象玩乐需求关联的UGC的上下文语料，作为关系构建的数据来源。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最初我们采用基于Pattern的方法，通过归纳可用于判断场景要素和具象玩乐需求关系的Pattern，从语料中直接抽取包含两者的文本。但由于用户表达的多样性，不仅准确率无法保证，同时有限的Pattern也影响了召回，因此我们进一步尝试使用基于模型判别的方法提升泛化性，完善关系的构建。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4351145038167939&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWkROqbUOkxgoZReLFeaRAicYLlugKSWhj6wnIN3gQ7DntJDnChVxLEngaoJp3SdwHgIlPI8MYf0Zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2358&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 9&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由于我们使用的语料中的具象玩乐需求是已知的，如果将场景要素看成是具象玩乐需求的属性，那么问题就可以看成是一个属性级（&lt;/span&gt;&lt;span&gt;Aspect-Based&lt;/span&gt;&lt;span&gt;）的分类问题。参考属性级情感分类的做法&lt;sup&gt;[10]&lt;/sup&gt;，我们通过预设句子模板的方式，结合场景要素和具象玩乐需求构造出辅助句子，将属性级分类转换为一个类QA的句对分类问题。例如，对于已经关联了“喂羊驼”这一具象玩乐需求的某个语料：“这个周六我们到农家乐喂了羊驼”，其中一个辅助句子为“周末适合喂羊驼”。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们采用BERT句间关系分类模型来实现句对分类，如图9所示。辅助句子与语料文本通过[SEP]相连后输入模型进行判别，模型输出判别结果（&lt;/span&gt;&lt;span&gt;适合/不适合&lt;/span&gt;&lt;span&gt;）。最后我们根据在所有语料上的关系提取结果，对每个场景要素和具象需求之间的关系进行投票计算评分后来确定两者的关系。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.5 场景需求层&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.5.1 场景需求组装&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在场景需求层，我们会将场景要素层和具象需求层的信息进行组装，从而生成大量的场景需求。组装出的场景需求，既可能仅含场景要素，如“国庆节陪3岁宝宝去哪儿玩？”不含任何具象需求，又可以同时包含场景要素和具象需求，如“周末去郊外摘草莓”中，周末、郊外是场景要素，摘草莓是具象需求。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.5.2 场景需求判别&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于组装得到的场景需求，最重要的是保证其合理性，例如“周末”和“亲子”就是合理的玩乐场景，而“闺蜜”和“亲子”则是矛盾的玩乐场景。为此，我们首先需要计算场景要素之间的关系评分，从而指导场景需求的组装。场景要素只有依托具象需求，搭配上适合的玩法，参与组装的场景需求才有意义。因此，对于场景要素之间的合理关系构建，我们尝试以场景要素和具象需求的关系得分作为依据，通过关系传递评估两个场景要素之间的相关性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在3.4.2节中，我们已经量化了场景要素和具象需求之间的关系评分，一个最直观的想法是通过场景要素-具象需求-场景要素的关系传递来进行计算场景要素之间关系的计算。如图10(a)所示，以具象需求“喂羊驼”为纽带，可以获取“亲子”和“闺蜜”两个场景要素的关系得分。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们首先构建场景要素和具象需求的关系评分矩阵，考虑到玩法数量满足长尾分布的情况，对矩阵进行具象需求维度的列归一化处理，同时为了保证场景要素-场景要素矩阵的自相关系数为1，对归一化后的场景要素-具象需求矩阵进行L2行范数归一化处理，因此该归一化矩阵与自身转置的矩阵乘得到的新矩阵即可作为场景要素-场景要素的关系评分矩阵。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.33192567567567566&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWkROqbUOkxgoZReLFeaRAicUCWDbroibaY08HMIo6kbtiaO5nicOW0acFlh9PdEicAmzlU3FiawhZKJg2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2368&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 10&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过上述方法可以很快得到场景要素之间的关系评分，然而该方法仅以场景要素-具象需求-场景要素的关系传递模式，计算场景要素在具象需求上的直接共指强弱，导致场景要素关系的覆盖不足。为此，我们扩展为更长的节点关系链传递模式，这种节点之间的传递关系是服从马尔可夫性质的，如图10(b)所示。但是随着传递路径的增长，计算成本会呈指数级增长。所以我们采用强化学习&lt;sup&gt;[11]&lt;/sup&gt;中的One-Step时序差分方法进行求解，以“累计回报的期望最大化”的概念作为节点的价值，以场景要素节点集合作为强化学习概念中的状态空间，具象需求节点集合作为动作空间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例如当我们处在“亲子”场景要素这个状态下，可以通过选择“喂羊驼”或者“角色扮演”来跳转到下一个状态“闺蜜”或“户外”。该状态跳转过程的决策函数，根据当前场景要素状态关联的所有具象需求中随机抽取一个具象需求节点作为决策行为，抽取概率与得分正相关；状态转移概率则为在该具象需求节点决策下，随机跳转到与之相关联的场景要素，跳转概率与得分正相关。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同时，对于特定的互斥关系，我们根据实际的业务应用需求制定奖励矩阵实现多样化的场景要素关系评分模型。这样我们将节点关系传递模型转化为了马尔可夫决策模型，结合贝尔曼最优原理推导出的价值迭代表达式和节点对关系得分预测公式，如图10(c)所示。根据图示的公式，在保持策略不变的前提下采用自举迭代的思想计算节点的价值，并进一步计算场景要素之间的关系评分，既能够保证更充分的利用已有的关系网络信息，提高关系覆盖，又能通过奖励矩阵的约束关系降低互斥关系的影响，灵活适应不同业务的需求。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后基于场景要素之间的关系评分，我们从组装的场景需求集合中选择评分高的场景需求，并根据预设的模板生成最终的场景需求表达，例如“周末和朋友放松”、“和闺蜜一起玩”、“国庆节带孩子户外烧烤好去处”。这些场景需求通过其包含的场景要素/具象玩乐需求，可以链接到相应的具象玩乐需求，进而关联相关的供给，从而给用户提供场景化玩乐的解决方案。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;四、应用实践&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本地生活综合性需求图谱，涵盖了用户的场景需求和具象需求，一方面更前置地参与用户决策，在“起心动念”、“考虑”、“选择评估”等多个阶段影响用户，降低其决策成本，另一方面，提供更多样化的供给选择，高效地进行供需匹配。应用方式上，应用于搜索、推荐等各类业务形态。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;经过近一年的建设，当前综合性需求图谱包含数十万核心具象需求和场景需求节点，以及数千万的关系，并在美团的亲子、休闲娱乐、医美、教育培训等多个业务进行了初步的应用实践，下面举例介绍具体的应用方式和应用效果。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.1 亲子&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;亲子原频道页用户需求和供给之间匹配效率低下，其中ICON按照亲子传统类目划分，无法满足用户不同类型的需求（&lt;/span&gt;&lt;span&gt;图11(a)左&lt;/span&gt;&lt;span&gt;），而底部猜喜的供给形态单一，且体现用户需求的优质供给不足，决策信息不足（&lt;/span&gt;&lt;span&gt;图11(b)左&lt;/span&gt;&lt;span&gt;），因此对亲子频道页进行改版。为了贴合亲子的业务特色，我们将亲子玩乐相关的需求节点和关系，应用于频道改版后的多个流量位，为其提供标签和供给数据的支撑。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;224&quot; data-ratio=&quot;1.1496746203904555&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVsG7TewiaUngCltfx0tabDkCbdqLMr9C0nk0LMHON14iaMMVbWAsdhCjfYFrqUDeQ9LPZKvmRIt2Kw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;922&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 11&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其中，对于ICON，基于高频的场景和具象需求，跨类目生成需求ICON，如“亲近动物”、“带娃泡汤”等（&lt;/span&gt;&lt;span&gt;图11(a)中&lt;/span&gt;&lt;span&gt;）及相应二级页（&lt;/span&gt;&lt;span&gt;图11(a)右&lt;/span&gt;&lt;span&gt;），这些ICON包含了原本多个类目中的相似需求，在用户“考虑”阶段为其提供决策信息。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于底部推荐，我们围绕亲子玩乐的具象需求进行供给优化，将其关联的内容作为优质供给进行推荐，并为每个供给提取包含相应具象需求的文本，作为推荐理由外露，这些句子从用户实际需求的角度展示信息，极大地吸引了用户（&lt;/span&gt;&lt;span&gt;图11(b)右&lt;/span&gt;&lt;span&gt;）。此外，还进一步根据浏览和交易行为，以供给为媒介建立具象需求与用户的关联关系，应用于个性化推荐的召回和排序的优化。改版后的亲子频道页，满足了用户多样化的推荐需求，极大地改善了用户体验。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2 休闲娱乐&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在休闲娱乐频道页，我们围绕场景需求和具象需求进行了一系列应用。一方面，基于玩乐的场景需求组织新的场景ICON，如满足用户户外游玩的“踏青赏花”、满足用户在室内潮流玩乐的“室内潮玩”、满足喜欢晚上玩乐用户的“夜生活”、满足和朋友同事聚会玩乐的“团建聚会”，这些ICON从用户场景化的玩乐出发，打破了传统类目的限制，让用户和供给的匹配更加流畅，每个ICON的二级页面则会展示每个场景的具象玩法需求及关联的商户和内容。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;另一方面，在频道页场景导航模块中，尝试利用场景需求来进一步展示场景化的玩乐信息，包括“一人乐”、“家庭暖”、“过生日”等十多个玩乐场景主题，并针对这些场景的具象需求关联的商户进行推荐。这些场景化的应用（&lt;/span&gt;&lt;span&gt;图12(a)&lt;/span&gt;&lt;span&gt;），在“起心动念”阶段即作用于用户，提升了用户的决策效率。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;187&quot; data-ratio=&quot;1.1717391304347826&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsVsG7TewiaUngCltfx0tabDk7SbFwm4C5vn2sc2e6oUMtVMsl5fL2p5I6mibGqt9EAHHdl0aBfP4EJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;920&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图 12&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此外，部分具象需求经过改写可以直接用于相应类目的列表页商户的快筛，例如实景剧本杀/桌面剧本杀，换装/汉服体验/撸宠必去/飞行模拟等（&lt;/span&gt;&lt;span&gt;图12(b)左和中&lt;/span&gt;&lt;span&gt;），而我们在行业体系层中类目的细分结果，亦可以成为商户的快筛，例如洗浴类目的细分（&lt;/span&gt;&lt;span&gt;图12(b)右&lt;/span&gt;&lt;span&gt;），这些快筛的应用，更加方便了用户选店。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;五、总结展望&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在本地生活服务中，如何不断提高供给和用户之间的匹配效率，是摆在我们面前的一道难题。我们尝试以用户关注对象为切入点，通过深挖用户需求并以其为纽带来关联供给和用户。为了全方位挖掘和理解用户需求，我们努力探索并尝试构建本地生活综合性需求图谱，以行业体系层、需求对象层、具象需求层、场景要素层、场景需求层的顺序逐层构建，并为各种类型的供给建立关联关系。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;目前，综合性需求图谱的结果可应用于搜索、推荐等各类业务形态，并已在美团多个业务场景中取得实践成果。不过，我们还处在探索的初级阶段，接下来还有很长的迭代之路要走，在此我们提出一些后续的思考和展望：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;更广的行业覆盖&lt;/strong&gt;：一方面加深对已有的玩乐、医美和教育行业的建设，挖掘更多的节点和关系，更好的理解用户需求；一方面向丽人、结婚等更多的行业进行横向覆盖；此外还将进一步扩展到用户决策的全链路，构建服务体验图谱，覆盖履约服务环节，分析其中的用户需求和反馈，更好地赋能商家提升用户体验。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;更多的数据引入&lt;/strong&gt;：当前图谱的构建主要是以平台的用户和商户的文本语料为主，下一步将利用图像等更多模态的数据，并尝试引入外部的知识，对当前的节点和关系进行完善和补充。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;更深的图谱应用&lt;/strong&gt;：现阶段图谱在搜索和推荐上的实践主要集中在标签及其关联供给的直接应用，后续考虑进一步深化图谱的应用，充分利用场景需求和场景要素的信息，为推荐侧更准的用户意图识别提供支撑，从而提升供给和用户的匹配效率，发挥出知识图谱更大的价值。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考文献&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;[1] Maslow A H. A theory of human motivation[J]. Psychological review, 1943, 50(4): 370.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[2] Luo X, Liu L, Yang Y, et al. AliCoCo: Alibaba e-commerce cognitive concept net[C]. Proceedings of the 2020 ACM SIGMOD International Conference on Management of Data. 2020: 313-327.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[3] Devlin J, Chang M W, Lee K, et al. Bert: Pre-training of deep bidirectional transformers for language understanding[J]. arXiv preprint arXiv:1810.04805, 2018.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[4] Le Q, Mikolov T. Distributed representations of sentences and documents[C]. International conference on machine learning. PMLR, 2014: 1188-1196.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[5] Vaswani A, Shazeer N, Parmar N, et al. Attention is all you need[J]. arXiv preprint arXiv:1706.03762, 2017.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[6] Shang J, Liu J, Jiang M, et al. Automated phrase mining from massive text corpora[J]. IEEE Transactions on Knowledge and Data Engineering, 2018, 30(10): 1825-1837.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[7] Clark K, Luong M T, Le Q V, et al. Electra: Pre-training text encoders as discriminators rather than generators[J]. arXiv preprint arXiv:2003.10555, 2020.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[8] Dozat T, Manning C D. Deep biaffine attention for neural dependency parsing[J]. arXiv preprint arXiv:1611.01734, 2016.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[9] Cheng H T, Koc L, Harmsen J, et al. Wide &amp;amp; deep learning for recommender systems[C]. Proceedings of the 1st workshop on deep learning for recommender systems. 2016: 7-10.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[10] Sun C, Huang L, Qiu X. Utilizing BERT for aspect-based sentiment analysis via constructing auxiliary sentence[J]. arXiv preprint arXiv:1903.09588, 2019.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[11] Sutton R S, Barto A G. Reinforcement learning: An introduction[J]. 2011.&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;作者简介&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;李翔、陈焕、志伟、晓阳、艳婷、旭乐、曹臻等，均来自美团到店平台技术部到综业务数据团队。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a89b61acb27efb92954c85fd93960f46</guid>
<title>资料 | 《设计数据密集型应用》中文翻译</title>
<link>https://toutiao.io/k/vnf7h38</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>47447508bc7f0489c1dd1400e1d24499</guid>
<title>决策易赵祝维：从满足应用需求到服务业务目标，从 SasS 服务商到业务合作伙伴</title>
<link>https://toutiao.io/k/gaejsd0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;—&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;文| babayage&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;编辑 | 笑   笑&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;工作狂的养成&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;《科创人》曾与苏州To B创业者聊起“为何苏州To B产业起步早、发展好、规模大”，其中一个重要原因是：上世纪90年代，许多跨国企业巨头落户苏州，这些企业既是中国To B服务的早期客户、又同时具备输出To B服务的能力，培育了大量To B人才，堪称中国To B行业的黄埔军校——明基逐鹿，便是个中代表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大学毕业之后，赵祝维选择了明基的技术工程师岗位，一干就是三年。赵祝维表示这段经历主要是养成较好的工作习惯和职业态度，具体来说，具备了应对高强度工作的能力。直到如今他依旧保持每天12~14小时的超大工作量。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;工作三年之后，日后输送诸多To B人才的“明基逐鹿”孵化计划浮出水面，信息团队由内部支持转向外部服务，开门纳客。对早已渴望走进市场广阔天地的赵祝维来说，“觉得这可能是我职涯中最重要的一个转折点”，于是主动请缨。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正确选择带来超速成长，4年后， 赵祝维成长为明基逐鹿ERP事业部总监，为企业提供基于微软MBS、SAP产品的ERP解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;有能量，更要有方向&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2007年，在西门子移动投资失败后的动荡中，赵祝维离开明基，北上进京在工信部短暂任职，随后回到苏州，在全球知名电动工具公司宝时得机械（中国），就任CIO。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“人成长到一定程度，做了一些事情之后，会有盲目的自信。内心就会有冲动，推动你走上创业这条路。”从2009年底到2016年，赵祝维在创业之路上奔跑了7年。他的第一次创业尝试是非生产性物料交易平台，却因资源受限没能铺陈出大的局面；此后，他尝试过新锐的移动互联网，尝试过相对保守传统的文化传媒，虽说不算失败，但也没有让赵祝维获得自我满足的成功，“过程很有趣，但从结果来讲，这是平淡的7年”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回首第一阶段的7年创业之路，赵祝维认为最大收获是广泛且立体的视角，“做IT Service的时候，接触的行业也很多，视野不缺宽度，但却只能观察到‘流程’这一高度。只有真正创业之后，才知道一个完整的商业体是五脏六腑七经八络样样都不能少的，而最大的教训则是当初认为有想法、有热情就能做出成功的事业，但事后才发现，专注才是成功事业的基础。这一反思，直接影响着赵祝维将下一阶段的人生All In于一个极其细分、聚焦的赛道。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;投身大健康行业，锁定决策易&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;赵祝维与决策易创始团队本是旧识，&lt;/span&gt;&lt;span&gt;结合&lt;/span&gt;&lt;span&gt;来自于双方对&lt;/span&gt;&lt;span&gt;IT &lt;/span&gt;&lt;span&gt;服务领域机会的共识。&lt;/span&gt;&lt;span&gt;2016&lt;/span&gt;&lt;span&gt;年，&lt;/span&gt;&lt;span&gt;To C&lt;/span&gt;&lt;span&gt;浪潮下半场已近尾声，&lt;/span&gt;&lt;span&gt;To B&lt;/span&gt;&lt;span&gt;方兴未艾，尤其是大健康行业，作为生活水平提升后长期利好的细分行业，势必将迎来长远发展。&lt;/span&gt;&lt;span&gt;切入细分行业提供精细化服务、构建竞争壁垒，从宏观到微观，都是正确的选择。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;“这个行业够好，够特殊，这就足够了”在这样的共识下，老战友们再次携手，定位于“生命科学行业数字化服务商”的决策易事业，正式启动。&lt;/span&gt;&lt;/p&gt;&lt;section&gt; &lt;/section&gt;&lt;section&gt;&lt;span&gt;科创人：&lt;/span&gt;&lt;span&gt;决策易立项之初，如何分析判断当时的市场形势？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;赵祝维：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;2016年那个时间点，医药行业CRM服务商，除了在头部市场高举高打的国际巨头之外，其他竞争者都进场不久。各有优势，有的擅长资源对接，有的在个别业务领域有产品优势，而决策易团队最擅长的则是解决方案以及落地，所以我们确立“方案+落地”路线，作为初期的竞争策略。并规划出不断强化优势、补足短板的路线图，比如决策易创始团队的能力和资源结构中，行业渗透和对接能力明显薄弱，在2018年前后几乎成为了发展瓶颈，我们随即按照规划，投入充足的资源增强市场能力，既然私域没有优势，就从公域航线抵达客户，如今市场能力已不再是决策易竞争力的短板。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;科创人：To B行业的底层逻辑之一便是越稳定、越繁荣，医疗行业的特点是不断推动着各种自上而下的变革，决策易对此有何判断、后续发展受到了多大影响？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;赵祝维：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;这个底层逻辑我个人没把握，毕竟机会都是在变化中产生的。对于固有市场的龙头来说稳定代表繁荣大概是对的，但对于新的蛋糕或挑战者来说，恰恰相反，市场变化更多意味着机会。迄今为止医疗改革依旧在不断推进，药企和药械为代表的供应端改革已进入后期，将来就是拼产品创新和管理体系。未来更多的变化会在医疗服务端发生，目前的主要矛盾体现在优质的诊断和治疗资源的稀缺，与大量的患者需求之间的矛盾。对此我们已经动手在选点进入：希望从连接患者入手，通过提供患者基于Patient Journey的知识库、自助服务、社群沟通、资源对接等价值建立用户粘性，并逐步整合资源并形成商业模式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总之行业的变化对我们来说应该都是积极因素，毕竟数字化转型所代表的模式创新和精细化管理，对规范化的市场是更加刚需的内容。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;越动荡，越成长&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;2017年1月9日，国家卫计委印发《关于在公立医疗机构药品采购中推行“两票制”的实施意见（试行）》，宣告全国“两票制”落地的开始。自此，多年的医改正式进入了各项政策密集出台、全面落地的阶段，以医药和医疗为中心的健康行业面临着巨大的动荡和重构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经营环境的变化，对服务商来说，不仅需要跟进，更多的是引领和方案。决策易团队在这场变革中，积极应对，分析政策变化对营销管理的最终影响，抓住数据服务和合规这两个业务痛点，迅速调整方案。向行业推出数据服务和合规解决方案及产品，这些方案和服务的落地，让客户体验到了决策易作为服务商的专业能力，带动了一系列的项目合作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这场巨大变革之中，决策易的IT Service方案能力发挥了巨大优势，快速应变、快速形成解决方案、快速帮助客户落地实施，最终在剧变期抢占先机。2019年，决策易度过了初创期，已位列医疗行业营销数字化服务商的第一梯队。&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;科创人：&lt;/span&gt;&lt;span&gt;在行业遭遇重大变革的时候，决策易如何发挥自身优势将其转化为发展机遇？&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;赵祝维：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;受变革影响最大的是客户，我们从客户视角出发、发现客户的管理痛点，据此确定客户的真实需求，设计可靠的解决方案，快速迭代发布产品，并确保实施落地。从而帮助客户降低变革期带来的管理调整周期和成本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如，药企典型的直营和招商两种业务模式所面临的合规建设是完全不同的。对于直营团队，合规体系比较好建设，在内稽内控的制度保障下，推进一套自营团队行为绩效体系基本就能解决主要问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而对于招商团队，其合规业务管理体系的业务环节较多，包括服务商的准入、服务委托管理、服务数据提交和重点业务管理、服务数据报告等。整个业务链条较长，涉及角色较多，需要我们提供一整套的闭环管理方案，这样才能确保整个招商业务的体系合规。但即便这样，这也只能帮助到药企，却很难赋能CSO，而未来无法自证合规的 CSO 将很难生存。在帮助药企做合规的同时，我们发现CSO是有自我管理的需求的，于是我们打通了CSO的行为过程管理和药企合规体系管理，真正形成了穿透式的过程管理到合规证据链的完整闭环。这是目前市场上较为领先的方案，帮助了不少客户快速完成了合规体系的建设。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们对方案的执着来源于我们对客户管理痛点的敏感，这是我们作为服务商的价值所在。坚持从战略远瞻层面着眼和工具创新着手，帮助客户解决问题。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3&gt;&lt;strong&gt;数据+产品+服务&lt;/strong&gt;&lt;/h3&gt;&lt;h3&gt;&lt;strong&gt;驱动药企营销创新&lt;/strong&gt;&lt;/h3&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;科创人：&lt;/span&gt;&lt;span&gt;启动数据智能化，往往意味着&lt;/span&gt;&lt;span&gt;To B&lt;/span&gt;&lt;span&gt;企业从需求响应阶段，迈进了创新驱动、深度赋能阶段，决策易发现了哪些数据智能与大健康行业场景价值结合的可能性？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;赵祝维：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;可结合的场景很多，理论上讲，只要数据够充分，有成熟的模型或逻辑。所有的业务场景都可以实现智能化的管理，这也是数字化转型的愿景之一，但这需要时间。目前受限于数据的完整度和商业逻辑的积累，我们聚焦在数据掌握度较高的一些业务场景上，主要是针对市场策略和销售策略两个点。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;以市场策略为例，结合全量的市场数据，可以清晰地告诉用户目前市场覆盖的广度深度，发现空白市场，提示开发目标，可以大幅的提升对市场现状做掌握和决策的效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于销售策略方面，一个典型场景例如医药代表与HCP的学术沟通，基于我们的HCP大数据和算法，系统会提供完整的客户画像，代表可以据此来做行动计划。同时智能助手在代表请求帮助时，可以建议代表用何种方式、何种频率、采用什么学术资料与对方进行沟通，这时候代表只要负责执行就好。这样智能化场景下的代表，其能力要求更加聚焦，工作内容更加简化，产能输出会明显提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;未来随着决策易行业数据和商业逻辑的累积，智能化的业务场景会越来越多。最终我们的智能助手将成为营销业务全角色、全场景、陪伴式的AI助理。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4640759150474469&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orBnshnyvSNjMusbcf5WIvO9f5L79hEMOfOvU0aCtT9vkgeB8vfia19zYiaU3nVlLjcmr94xTLSwfqOv6KqRNeJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2213&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;▲&lt;/span&gt;&lt;span&gt;2021&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;年，决策易全面重构全链路底层扩机。&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt; &lt;/section&gt;&lt;section&gt;&lt;span&gt;科创人：&lt;/span&gt;&lt;span&gt;数据智能在不同领域内的发展瓶颈各不相同，在大健康行业，数据智能化的核心要素是什么？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;赵祝维：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;数据智能化的核心要素是大数据和数据应用场景的商业逻辑。大健康行业客户大数据涉及众多，除了医院、连锁、药店等直接终端客户信息外，也包括了GPO药品采购组织、商业、KOL关键意见领袖、HCP医学专业人士等相关信息。随着数字化转型不断推进，企业决策场景都需要全量市场大数据的支撑。而建设全量的大数据对任何一家企业来说，都是不现实的。因此服务商的大数据成为必备的能力。我们需要做的就是不断提升数据覆盖度，扩展数据内容，完善和整合应用场景。目前为止，决策易大数据已覆盖了100%的等级医院，98%以上的商业、连锁、药店，70%以上基层医疗，在数据完整度方面我们建立了一定的优势。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;而商业逻辑的掌握，则依靠服务商的研究和最佳业务实践的积累。要靠研究来强化商业逻辑的细节，这种方式目前对我们来说不太现实，未来应该也不会走这条路。因此我们主要依靠最佳业务实践的抽象化来进行积累。我们的产品团队，会持续地进行优秀案例的分析和业务模型化设计的工作。这是一个不断积累的过程，我们做的标杆客户越多，所积累的商业逻辑就越丰富。&lt;/span&gt;&lt;/p&gt;&lt;section&gt; &lt;/section&gt;&lt;section&gt;&lt;span&gt;科创人：&lt;/span&gt;&lt;span&gt;对于&lt;/span&gt;&lt;span&gt;To B&lt;/span&gt;&lt;span&gt;企业而言，&lt;/span&gt;&lt;span&gt;PaaS&lt;/span&gt;&lt;span&gt;的价值感始终争议巨大，决策易为何决定打造&lt;/span&gt;&lt;span&gt;aPaaS&lt;/span&gt;&lt;span&gt;？&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;赵祝维：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;即便跳出大健康行业，我认为To B IT服务发展到一定程度是离不开aPaaS的。标准化的优势供需双方都很清楚，轻、快、方便，但个性化又必定存在。企业和个人一样，任何一家公司在成长中都会主动构建差异化的管理，或被动形成差异化的流程。这些差异化的元素必然要求服务商个性化的满足能力。aPaaS平台是用技术手段去满足企业复杂、长期且多变的个性需求的最佳选择，所以我们会坚定地投入aPaaS平台地研发和迭代。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;科创人：&lt;/span&gt;&lt;span&gt;我看到在决策易的业务领域方面，部分以&lt;/span&gt;&lt;span&gt;Saas&lt;/span&gt;&lt;span&gt;方式覆盖的业务也同时推出了业务运营的服务，这两种服务的比重未来是怎样的，这种从软件服务商到运营服务的转型如何处理，团队怎么建设？&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;赵祝维：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;SaaS服务商向业务运营拓展是自然的业务延伸，不能算转型。而且这种延伸比我们预想的要平滑很多，是核心能力具备后服务形式的自然拓展，团队建设也没有预想中的困难。我们所提供的运营服务都基于我们解决方案所覆盖的业务场景进行，都是数据化和系统化程度很高的一些业务。目前为止，我们提供的业务服务包括流向数据的相关服务、在线会议的整体流程服务、激励方案的设计和奖金计算服务、以及在线的学术拜访和销售辅助服务等。从服务形式来说，SaaS还是业务运营的选择是企业经营策略的反映，会长期并存，在短期内，我们不做侧重的选择，取决于市场。当然业务运营服务的市场规模从长期来看远大于Saas的市场，这也是我们的增长方向。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;决策易团队专注于数据、产品、服务三大能力的建设，赋能大健康行业客户营销体系的数字化运营，帮助客户快速进入合规化、精细化、数智化管理时代，在行业转型时代率先强化能力，赢得先机。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5066666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/orBnshnyvSNWuPOhbWJCJAjqibfhcHV6QPs25jIqxwMTicdibnPG3RFL3oq7Sw7Wu6bEu74mjb11pY2DI2DuHgiavw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>df3b70ba0c6fc8c63eba3b7018b2a7b9</guid>
<title>Flutter 控件 CustomScrollView 原理解析及应用实践</title>
<link>https://toutiao.io/k/vbo15c2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:0.title1&quot;&gt;&lt;p&gt;&lt;strong&gt;作者简介&lt;/strong&gt;&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;popeye，携程软件技术专家，关注移动端跨端技术，致力于快速，高性能地支撑业务开发。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;说起移动端跨平台解决方案，Flutter无疑是最近被谈到最多的话题。相对于React Native这样的前端技术栈，Flutter更贴近于客户端的技术栈特性，所以迅速获得大批原移动端开发的热烈拥护，再加上其优秀的渲染性能和友好的开发模式，目前已经在业内被广泛使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程酒店研发从去年底开始对Flutter进行可行性调研，在今年年初陆续完成了酒店详情页和酒店列表页的转Flutter工作，通过这项工作，实现了客户端技术栈的统一，大大提高了研发效率和双端一致性。在Flutter开发的过程中，对CustomScrollView的使用是比较多的，这也是我们开发过程中比较重要和复杂的控件。    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.36640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1fGeUUZT4NNowUtm5fgGQnhSOJgp7xHnloAWlvHYhBicmzhEdSc6CxYh4U2slf1wUuIR9RY7Hk9hiag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1  CustomScrollView可承载的子布局类型&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CustomScrollView是Flutter的SDK提供的实现长列表的控件。它像一个强大的粘合剂，如图1所示在此控件中我们可以将各种不同的布局，比如列表，网格，瀑布流，吸顶组件等，在其里面组合，实现较为复杂的页面。以往在Native的开发中，官方组件没有提供如此强大的组合能力，我们在Native中实现列表中组合不同布局，或者是通过index映射布局类型这种异构的方式，或者需要自己去自定义一个能够组合不同布局的控件，都没有CustomScrollView方便。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3487133984028394&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1fGeUUZT4NNowUtm5fgGQnhe2pJ6CkHUrr84LI28wbmoBeE2yU9Mm8c7IDINhmBZRMBgEWBfWxdIA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1127&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2  酒店详情页使用的主要sliver类型&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2是携程酒店详情页主要模块所使用到的布局类型。如上文提到，系统提供的布局方式还是很强大的，基本能够满足我们这个相对复杂页面大多数的布局要求，当然有些特殊的模块，需要去做一些定制，比如通过定制“paintOrigin”实现的日历模块的特殊吸顶交互等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于这个较复杂且使用广泛的组件的内部实现原理有较深入的了解，对于我们的应用以及后续的性能优化都有较大意义。因此本文将对其实现原理做一定的剖析，并就其在实际工作中的应用实践给出具体例子。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;&lt;span&gt;一、概述&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.1 Flutter渲染流程简述&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.11662726556343578&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1fGeUUZT4NNowUtm5fgGQnhWa3DPjmDwEjvehichFA6yKx5NJNZsZuRrl8qlz1gfVvZuVPsjSdeIicQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1269&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3  Flutter渲染流程&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;FlutterUI绘制的驱动主要可以简述如图3所示。可以看到，Flutter的Framewrok在启动初始化后主要构建了四颗树Widget、Element、RenderObject和Layer。然后在系统Vsync的驱动下，通过它们的改变生成出绘制每一帧画面的数据，然后显示到屏幕上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中的Widget树是平常接触最多的一颗树，它类似一颗配置数据树，配置页面的样子。而RenderObject树则是一颗真正的实现生成绘制内容树，完成各个控件的大小计算，布局，以及绘制数据，它的数据来源就是前面的Widget树。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;中间的Element树更像是一个媒介，因为Flutter借鉴了当今比较流行的React的思想，它并不希望我们还是像以前在Native的时候直接去操作RenderObject，而是希望我们在它的框架下面只配置我们想要什么，以及状态怎么改变，而最终的复杂的位置计算和如何绘制交给它解决。因此中间的Element树因此就应运而生，它会负责根据Widget树去生成和改变RenderObject树，当然这个过程中会做一定的Diff策略，从而尽量减少RenderObject树的变化，因为RenderObject树的变化相对来说是比较大的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终RenderObject树会生成Layer树，Layer树是Flutter engine所需要的数据格式，Flutter engine会利用这颗树进行相应渲染，并最终绘制在我们宿主平台提供给Engine的画布上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4923469387755102&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1fGeUUZT4NNowUtm5fgGQnhUcQMYhiboB7sI1sxZUgccpQAIuYrouwHpogQsHVCZdJsuibPiaBF3ib8RA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;784&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4  CustomScrollView的三层结构&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CustomScrollView作为Flutter提供的控件，其内部结构肯定也是上述这样，图4给出了其三层（Widget,Element,RenderObject）对应的结构图。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先看一下其在Widget这层的主要构成。总的来说由两部分构成：第一部分是Srollable，这层主要是接受用户手势同时根据配置参数，决定相应的滑动位置；第二部分是真正要显示的内容ViewPort，这层会根据监听Srollable给设置的offset，去将自己的显示内容也就是一个个的sliver展示出来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;中间的一层是Viewport Element，然后就是最后的RenderObject层。RenderObject主要是由展示窗口RenderViewPort和其具体的展示内容条目List（Render sliver）组成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样的分层设计方式还是很清晰，解耦的，相对于以往Native将上述的大部分内容聚合在一个View类里面，Flutter在这方面还是做了相应的设计的。尽量将不同职责的内容做了拆分，完成高内聚低耦合，从而能在多变的场景的应用中组合，实现相应的功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总的来说，不管是Widget还是RenderObject层，各自都可以对应的分成两部分，一部分负责监听用户手势然后计算自己对应滑动偏移值Offset，还有一部分则是具体展示内容，以及相应地怎么布局。下面我们以一个垂直向下滚动的CustomScrollView为例对它的实现做一些具体的剖析。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、Srollable&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.1  Srollable总述&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7151079136690648&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fGeUUZT4NNowUtm5fgGQnhA42rTOohqFVHJvWSseY7BQMMQEiaIhJXK64lpfFRcyNGOI7eVaq24EQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;695&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图5  Srollable的Build方法&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先我们来看一下Srollable的builder方法如图5所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Srollable最外面一层是Srollablescrope，这层可以理解为一个辅助层。我们可以利用它在Srollable的子Widget里很方便地锁定到对应的Srollable。&lt;/span&gt;&lt;span&gt;在Srollable中有一个“of”方法，这个方法就是依靠Srollablescrope的“Type”很方便地定位到Srollable。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而在Srollablescrope的child层则是此方法的核心，主要是通过“RawGestureDetector”去监听了用户的滑动手势，从而让Srollable根据用户的滑动手势去做相应的位置变化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.2 触摸事件的监听&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面主要介绍一下主要的4个触摸事件处理：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）DragDown&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.25957446808510637&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fGeUUZT4NNowUtm5fgGQnhXhTbayKowlk1bD0vMicgcZE7Cn2SnSVqzjorkariaRPLfib6OnTPibkWZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;705&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图6  dragDown触摸事件&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如图6所示，这个事件主要是对应用户手指按下跟屏幕接触的时刻。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）DragStart&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.26346604215456676&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fGeUUZT4NNowUtm5fgGQnhjmumrNR7h3xzkV8JOBERoWb5Pia2LIQOfGP2oAaWo46TzZBaw5Y3Xqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;854&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图7  dragStart触摸事件&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如图7所示，这个是手势Recongnize认为用户这次的操作已经达到了drag的标准，此时用户本次手势的操作才真正被认为是一个合法的drag动作的开始。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3）DrageUpdate&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2025862068965517&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fGeUUZT4NNowUtm5fgGQnhkRiaCficUx52kjtNSGM5icib2y8GehHhaLdKA0hRaomUu5GlKZv2kljZibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;928&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图8  dragUpdate触摸事件&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如图8所示，这个手势代表用户在dragStart后在屏幕上move的更新值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4）DragEnd&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3178294573643411&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fGeUUZT4NNowUtm5fgGQnhxbvL2CysHIkUs56EMRzmDE7gDQt9uAickEkaveicPYOkydpPM1h3GtXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;645&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图9  dragEnd触摸事件&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如图9，dragEnd这个手势代表用户的手离开了屏幕，也就意味着这次手势操作的结束。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过这几个方法，我们可以看到，手势的开始是通过“scrollPosition”生成了一个drag对象，然后接下来的update，end都是让这个对象进行处理，因此这个对象才是真正决定了当前的scrollView如何应对用户的操作，而进行相应的改变的处理类。接下来我们就重点来看这个类都做了什么。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.3 ScrollPosition&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.33937007874015745&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1fGeUUZT4NNowUtm5fgGQnhXhuBYRYFsD5mDDckbP82WhCSPy0IgjOn2NQct2xW6mZ80SkzGp85Lg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1270&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图10  scrollPosition类图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图10给出了” scrollPosition”主要关系的一个类图，下面我们具体看一下它们各自的作用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）首先可以看到” scrollPosition”是继承于ViewportOffset和ScrollMetrics这两个类。其中ScrollMetrics主要描述了scroll基本的一些状态信息。比如当前Srollable可视区域的大小，最小、最大的滑动offset限制，以及当前的offset。而ViewportOffset则提供了很多改变offset的方式，比如不带任何过渡交互效果就直接滑动到某个offset的“jumpto”方法，还有可以以带动画的方式滑动到某个offset的“animateto”。同时可以看到ViewportOffset的父类是一个ChangeNotifier，也就是说” scrollPosition”改变是可以被观察的。因此可想而知Srollable的子child也就是真正我们要显示的内容ViewPort会以观察者的模式监听它的改变，从而做出相应的变化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）再来看下ScrollPhysics这个重要的类，它主要决定了滑动位置处于一些边界场景情况下，对于用户的滑动应该怎么去反馈。比如说对于overScroll的反馈即用户滑动的位置超过scrollview的最大或最小活动限制的边缘时，在Android和iOS这两个平台上的表现是不一样的。在Android平台上默认是不让用户overscroll的，就是不能滑动超过边缘，而在iOS平台上则允许。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;又比如我们经常使用的PageView（它的原理与scrollView类似）。它要求每次滑动都是整页滑动。即使用户在滑动手抬起时，页面当前的offset位置还处于两个页面的过渡期间，不是一个整页。这时候PageView对应的ScrollPhysics就会再给一个自动的矫正滑动，让我们的页面滑动到对应的整页。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ScrollPhysics在SDK中已经提供了好几种实现。比如提供给Android平台的“ClampingScrollPhysics”，提供给iOS平台的默认的是“BouncingScrollPhysics”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些不同类型的ScrollPhysics是可以组合使用的，ScrollPhysics本身的设计也考虑到了这点。在构造一个ScrollPhysics时，我们可以传入一个默认的ScrollPhysics，也就是说新的ScrollPhysics默认就会组合传入的ScrollPhysics特性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来具体看一下这个类可以用来控制特性的一些重要的方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;“applyPhysicsToUserOffset”方法&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：当用户手势滑动超出scrollable最大或最小的滑动界限时，也就是我们常说的overscroll状态时，对用户手势做出一定的矫正。比如通过算法转换压缩用户的滑动距离，从而体现出一定的阻尼效果，让用户感知到已经滑到边缘了，没有可以滑动的内容了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;“shouldAcceptUserOffset”方法&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：它配置用户是否能够滑动scrollable。比如说NeverScrollableScrollPhysics的这个方法永远返回的都是false，那也就意味着scrollable不允许用户通过手势去滑动它。当然一般情况我们实际使用时都是返回true，允许滑动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;“applyBoundaryConditions”方法&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：它主要也是为“overscroll”场景服务。它决定了用户的滑动位置能否overscroll。这个方法的返回值是一个矫正值，比如BouncingScrollPhysics 永远返回的都是0，也就是说它允许用户进行overscroll。而“ClampingScrollPhysics”在overscroll状态的返回的是一个非0的矫正值，会将新的offset矫正到scrollable的boundary里面来，避免出现overscroll。因此如果我们想要实现一个一端可以overscroll，另一端不允许的scrollable，就可以通过重写这个方法加以实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;“createBallisticSimulation”方法&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：它主要是返回一个变化的方程式。其大多数的应用场景主要是用来在用户的操作或者说滑动结束时有个反弹的效果。比如在PageView中当用户滑动结束手抬起时，页面的滑动位置不是一个整页的位置，这个方法就会返回一个方程式，然后我们就看到了一个按照这个方程式变化反弹动画，滑动到一个整页的位置。类似的iOS平台上默认的BouncingScrollPhysics在overscroll时，手松开时也会有一个反弹的动画，也是由这个方程决定。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;“recommendDeferredLoading”方法&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：它主要是提供给scrollable自己的显示内容子控件使用。其目的是为了提高性能，比如当我们做了“Fling”这样的快速动作后，scrollable接下来可能会滑动一个非常大的距离，而在这个距离中间的很多很耗资源的数据在这个过程不需要加载，因为用户基本也不会看到。特别典型的比如图片，因此在这个过程中这些耗资源的组件就可以通过这个方法判断是否需要延迟加载，以提高性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总的来说ScrollPhysics还是非常重要的，它承担用户在scrollable上滑动各种特殊场景的效果逻辑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3）ScrollContext：它主要是充当一个媒介角色，其真正的实现就是ScrollableState，目的主要是让scrollPosition可以去改变ScrollableState的一些能力。比如说在做某个滑动的过程中，scrollable中的内容是否能接受点击，以及控制用户能否对scrollable进行滑动。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4）ScrollActivity：这个类主要负责封装当scrollable接受到用户的各种手势事件后做各种不同的流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如当用户的手势被确认识别成drag动作后就会发起一个“DragScrollActivity”，负责此后用户手势在此基础上的新的滑动变化的处理，一直到用户手势抬起结束后怎么反应。还有比如像用户在滑动过程中突然有系统框弹出该怎么处理等这些针对具体场景的处理，都封装成了特定的流程，定义在这个类的某个具体实现子类里面，由其负责具体处理。像上文讲的用户手松开后的一个反弹效果，对应就是“BallisticScrollActivity”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5）Controller：这个类是我们在使用CustomScrollView时经常会设置的一个参数，它顾名思义就是一个控制器可以让我们去控制ScrollView，设置参数让它去滚动。之所以能够控制，是因为在内部绑定了前面讲的scrollPosition，因此能让我们利用它去控制CustomScrollView滑动，以及监听CustomScrollView最新的状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;   &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小结一下，scrollPosition主要负责用来实现对ScrollView的offset计算怎么改变，而physics是scrollPosition用来做怎么改变的重要的规则和限制，而最终scrollPosition又通过Controller与外界的CustomScrollView的使用者串联，让外界可以操控和获得CustomScrollView的滑动状态。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;至此CustomScrollView第一个重要的部分滑动位置改变的控制，我们基本就分析完了，接下来看一下有了这个具体的滑动的Offset，显示的内容怎么展示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;三、ViewPort&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.1  整体布局流程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.1880674448767834&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1fGeUUZT4NNowUtm5fgGQnh0o438JK6HNcicdBXADlHu3Rjdo9F1gUiaVMgOUpEQmQr7Uvueyga4wgg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;771&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图11  RenderViewport布局流程&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来我们来看真正展示内容的ViewPort它的RenderObject（RenderViewport）是怎么布局的。如图11所示，是其布局的整个流程概况。可以看到其主体的流程还是比较简单的，从第一个child不断的遍历到最后一个child，从而完成整个ViewPort的布局。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;里面有个特殊场景会抛出Error的异常，我们在布局每个child的过程中，会把当前scrollview的offset作为输入给当前正在布局的child，而某些chid在做内部布局的时候，可能会认为scrollview给的offset会有问题需要矫正。比如说用来展示长列表的SliverList在做内部布局的时候，如果SliverList发现自己的child已经全部布局完了，但是scrollview给的offset还没有填满，这时候就会认为scrollview给的offset太长了，会给一个矫正值，让它缩短回去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.2  吸顶效果（Pinned）的实现原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际开发中用的比较多的一个效果是吸顶。在Native的开发中，一般这个效果是我们自己去实现的。但是CustomScrollview很强大，直接提供了这个功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对应的控件是SliverPersistentHeader，并将其pinned属性设置为true，就可以实现吸顶效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.538552787663108&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fGeUUZT4NNowUtm5fgGQnhCpBKlFgWga6fWPqPHWRHCTdHRzLsBuxwXjHxLiaZ8oGWpo8Bv1Gzk2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;843&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图12 RenderSliverPinnedPersistentHeader的布局代码&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其对应的renderObject是RenderSliverPinnedPersistentHeader，它的布局代码如图12所示。重点关注一下其返回给renderViewPort的SliverGeometry中的paintOrigin，这个参数直接给的就是“constraints.overlap”。那么这个参数在renderViewport中具体代表什么意思哪。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5849056603773585&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1fGeUUZT4NNowUtm5fgGQnhzLy7EcjIrG51NYkPVoLlWD9iaclibNnMlVcfsJLibQvFkQiaf6lY9icLaeg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;583&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图13 RenderViewport布局流程&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再回头来看renderViewport的layoutChildSequence方法。前面说了这个方法会遍历自己所有的子sliver然后逐个布局，在这个过程中我们着重关注一下maxPaintOffset和layoutOffset这两个变量。在普通场景下这两个值都是从0开始，随着对child list的遍历而做相应的递增，也就是说默认的情况下这两个offset都是相等的。&lt;span&gt;但是参考图13所示，黄色部分&lt;/span&gt;&lt;span&gt;的某个pinned sliver child模块如果前面已经出现了红色区域的吸顶部分，那么此时对于黄色的这个child这两个值的位置就不是一致的了。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;如图中所示，可以看到此时对于它的PaintOffset是比layoutOffset大的，而它们之间的差值就是作为输入传给黄色sliver的overlap。可以看到RenderSliverPinnedPersistentHeader在自己的布局方法中，在返回给renderViewPort的“SliverGeometry”返回值中的paintOrigin就是直接赋的这个值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后再回到renderviewport里，可以看到renderviewport在拿到child的这个参数会做如图14所示的一个修正流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.09953488372093024&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fGeUUZT4NNowUtm5fgGQnhph0vFcLHY2pwZLZicCFQbibxo02EpH0nPIawPxeEaA8ZPfaqyibOIGfBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1075&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图14 renderViewport修正LayoutOffset&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也就是说render viewport会用子sliver回传的paintOrigin矫正一下最后真正绘制的offset，经过这个矫正后的offset正好是图13中所示的已经吸顶（红色）部分的底部。当用户再继续往上滑动时，本应该滑出可视区域的黄色sliver，因为上面讲的处理，将一直绘制在屏幕上方，因此实现了吸顶效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.673211781206171&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/kEeDgfCVf1etFrqeZBAuicvibibLNORTRkxXAtggFxrHQ4fMzhXUTYrvDtqyuuO04XFxBic0CVFkNG1WeUjNvMe9BQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;713&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图15 日历部分阶段性吸顶效果&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有了这个参数我们可以很多特殊的处理，比如酒店详情页的日历，交互要求其是阶段性吸顶。就是说虽然要吸顶，但不是一直都是吸顶的，当房型区域滑出屏幕时要随着最后一个房型的底部同步滑出，如图15所示。我们知道customscrollview默认没提供这样的实现，后来就是通过监听最后一个房型的滑动位置，然后去改变日历吸顶组件中“paintOrigin”参数的值，从而完成了此效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.3  Tab按钮和锚定&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.7279102384291725&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/kEeDgfCVf1etFrqeZBAuicvibibLNORTRkx8A5QD7C75eP73QiaP0TeupFCfHmGJGEtHRyZ3HD8fibXR3U2U9LzFSXw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;713&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图16 Tab按钮和锚定效果&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如图16所示的tab变化和锚定是我们经常会遇到的场景，这个时候需要准确地知道要锚定的模块所对应的offset值，而Tab的变换就是一个反向的过程，即当前scrollview的offset对应到了哪个具体的模块。说白了就是需要一个转化公式，给定一个指定的模块我们需要知道其对应的offset值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很庆幸scrollview直接提供了对应的接口，如图17所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.09527559055118111&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fGeUUZT4NNowUtm5fgGQnhLvsPYoRdibic5jwSIMLy1iamZDW93zo0WSxp0qEOQicEBzuVWQmE9x2l2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1270&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图17 获取指定child展示在可视区域内offset的函数&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面我们分析过renderViewport会在每次布局时对其所有的子sliver进行布局，同时每个child会返回它们自己的布局结果。那么在返回结果里面跟这个方法紧密相关的两个变量是scrollExtent和maxScrollObstructionExtent，其中“scrollExtent”代表了这个child自己拥有的滑动距离&lt;/span&gt;&lt;span&gt;，而maxScrollObstructionExtent则主要是为吸顶的sliver所服务的， 它表示这个吸顶的sliver处于吸顶状态时所占的吸顶区域的高度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当我们要获得某个具体的sliver滑动到屏幕可视区域最上方所需要的offset时，其实就是把该sliver前方所有的sliver的scrollExtent相加，同时减去该sliver前面所有吸顶的sliver的maxScrollObstructionExtent，就可以获得相应的offset值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.4  长列表的懒加载机制和其子renderObject的复用机制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来我们再看一下非常重要同时大家都很关注的长列表的懒加载机制和内存复用的机制。我们还是用展示向下布局的长列表“SliverList”作为代表来介绍一下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.4.1 懒加载机制&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.33033303330333036&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1fGeUUZT4NNowUtm5fgGQnhfwW6xq8ImlricywrzxYcYk7nDRicK1iahpqHY5LXpyCQEic8DdJbjHSCJw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1111&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图19 SliverList的布局流程&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如图19所示是SliverList布局的主要流程，大体可以分为三个阶段。第一个阶段和第二阶段主要是定位，定位在当前scrollView对应的scrollOffset下在可视窗口内用户所能看到的第一个child是谁。那么第一个阶段是从上一次布局结果的firstChild按其index的逆序往前找，找到第一个自己的scrollOffset比scrollView的scrollOffset小的child。在这个过程中找到的child是有可能在用户的可视范围内的，再往前的child用户肯定是看不见了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二个阶段是一个相反的过程，它会从第一个阶段找到的那个child往后找，找到第一个child的尾部是超过scrollView的当前的scrollOffset。那么这个child就是接下来用户在当前所能看到的第一个child了，本次的布局也只需从这个child开始，index在这个child之前的children相应肯定是看不到的，因此本次布局和渲染会忽略它们。在这之后会定义一个游标trailingChild指向child。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来就进入了第三阶段，真正创建和布局本次渲染所要的所有child。算法也很清晰，一直往下逐个遍历和布局接下来child，直到某个child的末尾超过了本次布局一开始提前限定的范围。这个范围一般是scrollView可视范围的窗口高度再加上一个cache距离。至此整个布局就全部结束了。可以看到对于一个有很多数据的列表来说，在本次布局中，只有用户可视范围内的child会参与其中，不在的都会被忽略，从而实现了懒加载，大大提高了绘制性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了SliverList，sdk中的Grid，开源的瀑布流组件StaggeredGrid等长列表实现懒加载的机制也是类似，只是排列自己子child的布局方式不一样。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.4.2 内存的复用管理&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在以往Native的开发中，内存的复用是大家非常关心的问题，因为长列表可能会对内存造成非常大的压力，从而出现OOM。我们在接触flutter的时候也很好奇，下面来看一下SliverList在这块的处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4025670945157526&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fGeUUZT4NNowUtm5fgGQnhHZxtiaiaibbXCUjibcxxXwvhOxoduMCQdxMPKm7m3h6PqZz5iaQ2cgv8Ylw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;857&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图20 SliverList单个child的创建或重用&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.36312217194570134&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fGeUUZT4NNowUtm5fgGQnhFzWFRia1ia0IEz4uBcbjsVdtIvwKOnnZvJ8HeciaCFIDyREYYdNia6H0BQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;884&quot;/&gt;&lt;span&gt;图21 SliverList单个child的销毁或回收&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;sliverList创建和回收每个scrollview的child的方法分别如图20和图21所示。从创建的代码可以看到，其首先会去一个keepAliveBucker的Map里面根据该child的index去寻找有没有对应的child缓存。如果有，会重用这个缓存里面的child，如果没有，则会使用childManager去真正地创建一个child对象。在destory方法中主要是一个逆向的过程，会首先判断输入的child是不是要做缓存的，如果是则放入缓存池，如果不是则会真正将其对象销毁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.08228571428571428&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fGeUUZT4NNowUtm5fgGQnhLRgj7r2tG6M6TyicicIKW3Aa4GT6XdaicwTUDqZZtZicbrJ8SqVjJ4LEmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;875&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图22 keepAlive后keepAliveBucker中节点的数量&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到这里面是否会做缓存主要是由一个keepAlive的标志决定的。对于sliverList默认情况下所有的child是不开启keepAlive的，也就是说每次布局只要是被认为不需要的child都会被销毁。而如果我们需要让某个child变为keepAlive状态，只需要在这个child的widget外面用“AutomaticKeepAliveClientMixin”包装一下，就可以实现对它做缓存。图22所示是把每个child都设置成keepAlive的状态后的缓存截图，可以看到keepAliveBucker这个Map里面缓存了每个index对应的child，数量达到了200多个child。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总的来说，Flutter在长列表的内存复用这块基本没采取特别的优化措施。如果我们打开child的keepAlive，也只是一个对应到index的简单的重用，并没有像Native那样去设计比较复杂的复用机制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从我们之前的应用来看，不用keepAlive对于像List，Grid这样的普通布局在使用时性能还好，但是如果是瀑布流的布局，在Android某些机型上如果不开启keepAlive对性能有一定影响，当然开启后对内存的消耗也相应会增大。对于这块需要思考如何做进一步的优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、结语&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;至此，对于CustomScrollView这个Flutter中比较复杂的且应用广泛的组件的大体运行机制我们就分析完了。应该说在应用的方便性上，相对以往Native中的组件在功能上还是更强大的，它像一个粘合剂，让我们可以在它里面组合各种不同的布局子组件，&lt;/span&gt;&lt;span&gt;以往在Native的开发中这些大都需要我们自己去定制。当然在数据量很大的情况下，对内存使用这块的设计相对以前Native还是比较简单的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;后续我们也会在应用继续深入的基础上，在功能上做进一步的丰富以及在性能上考虑如何做进一步的优化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt; 团队招聘信息&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们是携程酒店前端研发团队，负责携程Ctrip APP/国际版Trip APP/小程序/Web端的酒店业务研发和创新，&lt;/span&gt;&lt;span&gt;保障酒店业务高效产出、稳定迭代的同时，持续优化用户体验和优化酒店预订流程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在酒店前端研发团队，有包容性，多样性的团队文化，你可以和一群纯真，富有激情的年轻人一起工作，为全球旅行者提升旅行体验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你热爱技术，并渴望不断成长，携程酒店前端研发团队期待你的加入。目前我们Android/IOS/RN/Flutter/H5/服务等领域均有开放职位。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;简历投递邮箱：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;tech@trip.com&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，邮件标题：&lt;/span&gt;&lt;span&gt;【姓名】-【携程酒店前端】-【投递职位】。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;【推荐阅读】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1etFrqeZBAuicvibibLNORTRkxCOHYWvse3MeJ1zEKzBuibaBtYaSP5iagRCsoC6qIcjKl02Elc9oEiaotA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; “携程技术”公众号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;  分享，交流，成长&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt; &lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>