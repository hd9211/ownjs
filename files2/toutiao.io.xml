<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>cbb9ac1dc92411698f9c08d5b64336b4</guid>
<title>周末别闲着，快来吧！</title>
<link>https://toutiao.io/k/sat069j</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>415d8d9c97561b0c489ee80f620229a3</guid>
<title>基于开源工具的人生管理</title>
<link>https://toutiao.io/k/e2ie57j</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content&quot; itemprop=&quot;articleBody&quot;&gt;&amp;#13;
&lt;p&gt;我在《&lt;a href=&quot;https://www.bmpi.dev/self/gtd-tools-i-used/&quot;&gt;我的时间管理工具&lt;/a&gt;》与《&lt;a href=&quot;https://www.bmpi.dev/self/note-system/&quot;&gt;我的笔记系统&lt;/a&gt;》中分享过我不断演进的时间管理工具与笔记系统。在使用这些系统多年后，始终有个困惑萦绕在我耳边，那就是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单纯的记录时间、笔记和资金是一种碎片化的行为，容易导致过于追求细节而忘掉全局，让自己成为一个忙碌的战略懒人。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;时间管理、记账、记笔记、学习、写作、阅读、交流这些行为都不是最终目的，它们只是一种实现个人长期目标的辅助方法，如果做这些事对长期目标毫无帮助，那没必要浪费时间去做。&lt;/p&gt;
&lt;p&gt;虽然我做了大量的时间与资金开销记录，但我也很难评估这些开销对实现长期目标有何影响。这种困扰可以看作个人时间管理的哥德巴赫猜想：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我知道我的时间有一半都被浪费掉，但就是不知道哪一半。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想解决这个问题，就得简化问题的复杂度，这个问题其实等价于以下两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;今天我做了啥？&lt;/li&gt;
&lt;li&gt;做这些事对我的长期目标有什么帮助？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;经过一段时间的思考，我有了以下的简单模型去解决这个问题。让我们先对问题进行建模。&lt;/p&gt;
&lt;h3&gt;问题建模&lt;/h3&gt;
&lt;p&gt;如果把人看作一个 Machine，这个 Machine 有输入有输出。最初这个 Machine 只拥有时间维度，逐渐它拥有了技能维度，同时积累了金钱维度。如果把时间、技能与金钱看作它的输入端，那它输出端就是金钱、技能与影响力维度。其中金钱和技能在输入与输出间自循环，一般是正向的。我们的金钱和技能都会随着输入与输出的循环而提升，而影响力其实就是知识的变体，我们通过知识去影响别人，通过知识去建立权威与信誉度，最终发展出个人品牌。这个流程看起来非常像是一场 &lt;a href=&quot;https://www.bmpi.dev/self/road_to_life_games/&quot;&gt;打怪升级的游戏&lt;/a&gt;。这些抽象的维度落地后就变为&lt;a href=&quot;https://www.bmpi.dev/self/gtd-tools-i-used/&quot;&gt;时间管理系统（目标、任务与时间）&lt;/a&gt;、&lt;a href=&quot;https://www.bmpi.dev/self/note-system/&quot;&gt;财务管理系统（记账、投资与保险）&lt;/a&gt; 与&lt;a href=&quot;https://www.bmpi.dev/self/build-personal-knowledge-system/&quot;&gt;知识体系（写作、笔记与个人品牌）&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;想象这个场景：通过设定个人 OKR，把一个个 Key Result 拆解为一个个 TODO Task，用时间管理工具去追踪这些 Task 的时间开销，用财务管理去追踪这些 Task 的金钱开销，用知识管理去追踪这些 Task 的笔记，那我们是可以知道每个 Objective 的时间与资金开销，同时也能知道这个 Objective 的输出笔记产物有哪些，最终输出的影响力程度。通过不断优化输入与输出端，我们可以形成高效的学习能力，更好的适应外界的变化。如何优化？就需要记录输入与输出端各个维度的数据。通过记录底层维度数据来把控高层目标的实现。从时间与财务性价比的角度看一个个最终执行的任务，如果某个任务能更好的推动 OKR 目标的实现，那这个任务的投入就有价值。&lt;/p&gt;
&lt;p&gt;理想的情况是，每个人拥有自己的输入与输出各维度的 Dashboard，这样就能从宏观视角看到自己每天做的事情的价值。我们可以量化每件事情的投入产出比，去优化自己的处理流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/07/1-life-management-based-on-open-source.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;系统设计&lt;/h3&gt;
&lt;p&gt;在对问题建模后，我现在的业务需求是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全局的 Tag 系统。该 Tag 系统可以从个人愿景中设定年度 OKR 目标，之后可以对 OKR 的 Key Result 进行细粒度的 Task 拆分。&lt;/li&gt;
&lt;li&gt;任务时间开销追踪。可以对 OKR 目标的某个 Key Result 统计相关的 Task 的总耗费时间。&lt;/li&gt;
&lt;li&gt;任务资金开销追踪。可以对 OKR 目标的某个 Key Result 统计相关的 Task 的总资金成本。&lt;/li&gt;
&lt;li&gt;任务相关笔记关联。可以对 OKR 目标的某个 Key Result 关联相关的 Task 的笔记。&lt;/li&gt;
&lt;li&gt;Dashboard 原始数据生成。可以自动或手动生成个人 OKR 完成度表现报告与财务健康度报告。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下图是一个从个人愿景到 OKR ，之后从 OKR 生成每日待办任务，追踪任务相关时间、资金与笔记的流程图。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/07/2-life-management-based-on-open-source.jpg&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/07/2-life-management-based-on-open-source-768x368.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;系统实现&lt;/h3&gt;
&lt;p&gt;我的系统实现原则是尽可能用开源的工具组合实现我的需求。所以基本原则有以下几条：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工具需必须要开源。不考虑商业版的原因是未知不可控的商业风险，这些工具都是要长期使用的，选择开源方案是性价比最高的。&lt;/li&gt;
&lt;li&gt;工具需要具备可扩展的能力。只有可扩展的系统才具备组合的能力，这样方便后期定制化的使用。&lt;/li&gt;
&lt;li&gt;工具要有一个好的社区。一个好的社区非常重要，可以让我们解决问题的成本下降很多。也可以使用别人提供的现成解决方案。&lt;/li&gt;
&lt;li&gt;数据必须能自托管。数据必须要存放到自己控制的存储（本地和网络都可以）中，隐私第一原则。&lt;/li&gt;
&lt;li&gt;数据尽可能是纯文本。纯文本更简单，就算工具不可用，也可以直接对文本进行读取或修改。长期来看，这点很重要。&lt;/li&gt;
&lt;li&gt;门槛低。最好一天上手，三天精通，我不想花费数周时间去学习一个复杂的工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;现有解决方案&lt;/h4&gt;
&lt;h5&gt;Emacs&lt;/h5&gt;
&lt;p&gt;如果直接选现成的方案，一定有人会提到这篇 《&lt;a href=&quot;http://doc.norang.ca/org-mode.html&quot;&gt;Organize Your Life In Plain Text!&lt;/a&gt;》。这篇超过 10 年历史的文章看起来如 Emacs 一样强大而久远。用 Emacs 做的确符合以上所有基本原则，问题在于我不是一个 Emacs 专家，我不想学数年 Emacs 后再开始解决这个问题。我的思路是花最多不过一周时间去用开源工具组合出一套解决我需求的方案出来。一周时间，我可能连 Emacs 快捷键都记不住。&lt;/p&gt;
&lt;h5&gt;自己动手做&lt;/h5&gt;
&lt;p&gt;当我看到这篇《&lt;a href=&quot;https://beepb00p.xyz/blog-graph.html&quot;&gt;Blog graph&lt;/a&gt;》 和 《&lt;a href=&quot;https://beepb00p.xyz/myinfra.html&quot;&gt;Map of my personal data infrastructure&lt;/a&gt; 》时整个人都震惊了。作者全部自己动手做了一套类似的系统去管理他的人生。如果我有时间的话我一定会这么尝试去做，但是我没时间。&lt;/p&gt;
&lt;h5&gt;工具选择&lt;/h5&gt;
&lt;p&gt;这套系统实现的关键在于需要有 Tag、TODO、笔记管理、记账等功能，记账可以用 Beancount 去做，只需要结合它的 Tag 功能就可以追逐相关 Tag 的开销。那么只需要选择一个具备 Tag 和 TODO 功能的开源笔记工具就行了。这么看来我们可选择的很有限了。&lt;br/&gt;
以最近大热的 Roam Research 为例，它开启了不少笔记工具的新特性：反向链接、右边栏、每日笔记及图数据库。最重要的其实是它的图数据库特性，因为当一个工具具备了数据库的查询能力时，结合插件特性我们可以做出非常多的应用场景。可惜的是它是一个商业软件且不开源（ Notion 也因为这个原因被排除），所以我找到了一个具备它很多特性的开源软件 Logseq，Logseq 本身受很多笔记工具的启发，如 Roam Research、Tiddlywiki、Workflowy 与 Org Mode 。&lt;br/&gt;
在把玩了几天 Logseq 后我发现最强的就是它底层的 DataScript 内存图数据库，可以通过高级查询做很多自定义界面。这样就可以满足我们的很多需求了，比如生成每日待办任务，根据 OKR 生成的 Tag 来过滤和 OKR 相关的任务，统计相关任务的花费时间等。&lt;br/&gt;
目前 Logseq 还在开发插件系统，等插件系统上线后，很多难以实现的功能都可以通过插件来完成。当然我的需求还不需要插件系统的支持，光高级查询就可以满足。&lt;/p&gt;
&lt;h5&gt;我的方案&lt;/h5&gt;
&lt;p&gt;当确定了笔记工具和记账工具后，我最终的方案如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/07/3-life-management-based-on-open-source.jpg&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/07/3-life-management-based-on-open-source-768x617.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各工具的职责如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Logseq。负责制定 OKR 、设定相关 Tag 、拆分 OKR 相关任务并追踪任务耗费时间（时间管理）及管理这些任务相关的笔记（笔记系统）。&lt;/li&gt;
&lt;li&gt;Beancount。负责记录相关 Tag 的资金开销，当然也是我的记账工具，最终帮助我生成家庭财务健康度的评估报告。&lt;/li&gt;
&lt;li&gt;Tiddlywiki。负责公开笔记的输出。和 Logseq 的区别在于，我会将 Logseq 的一些笔记整理成可供分享的知识后发布到 Tiddlywiki 上。虽然 Logseq 支持公开某个页面，但是为了更好的区分私人笔记和公开笔记，我还是做了这个区分。&lt;/li&gt;
&lt;li&gt;Amazon AWS。我的个人云平台。目前主要是用 S3 + CloudFront 做博客的图床。&lt;a href=&quot;https://www.bmpi.dev/dev/pulumi-aws-serverless-hugo-site-vists/&quot;&gt;博客的页面访问数据&lt;/a&gt; 也是用 &lt;a href=&quot;https://www.bmpi.dev/dev/guide-to-serverless/&quot;&gt;AWS Serverless&lt;/a&gt; 开发实现的。&lt;/li&gt;
&lt;li&gt;Wayback Machine。类似 OneNote 和 Evernote 的 Web 剪藏工具。它可以永久保存网页的所有变更版本，所以一般无需自己把网页内容下载到笔记工具里，这样会导致笔记工具同步缓慢。我当时用 OneNote 剪藏了很多网页导致其存储达几 GB ，每次换设备同步都很头疼。实际上只需要保存网页链接即可，最多加几句总结的话助记。有 Wayback Machine 再也无需担心网页突然不见了。&lt;/li&gt;
&lt;li&gt;GitHub。项目托管与云存储平台。博客、记账与时间管理的所有数据包括文件（某些文件会放到 Google Drive 里）都存放到 GitHub 公开或私有仓库中。&lt;/li&gt;
&lt;li&gt;Vercel。博客与Wiki托管平台。可直接关联 GitHub 后一键发布网站并自带 CDN 且 &lt;a href=&quot;https://www.bmpi.dev/dev/guide-to-setup-blog-site-with-zero-cost-5/&quot;&gt;国内访问速度不错&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;VSCode。文本编辑工具。一般我会用它完成博客写作、笔记写作（也可用浏览器）、绘图（也可用浏览器）、记账及代码开发。&lt;/li&gt;
&lt;li&gt;Google/Twitter/YouTube。主要的信息获取平台。主动搜索用 Google，被动获取用 Twitter 及 YouTube。中文高质量的信息获取平台越来越少了，很多时候需要用英文才能搜索到我想要的信息。所以搜索技能和英文能力已经算基本能力了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最右侧有颜色的三个框就是我的愿景最关注的三个领域了，我的所有输出都会和这三个领域相关。&lt;/p&gt;
&lt;h3&gt;实现效果&lt;/h3&gt;
&lt;p&gt;使用 Logseq 完成的最终效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/07/4-life-management-based-on-open-source.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每天我都可以在 Logseq 系统首页看到以时间四象限划分法而划分的待办任务。具体如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;📅 在做计划事项。标记为重要的或者和任何 OKR 相关的在做任务。&lt;/li&gt;
&lt;li&gt;🌞 待做计划事项。标记为重要的或者和任何 OKR 相关的待做任务。&lt;/li&gt;
&lt;li&gt;⏰ 在做其他事项。任何不重要的或者和 OKR 不相关的在做任务。&lt;/li&gt;
&lt;li&gt;🚮 待做其他事项。任何不重要的或者和 OKR 不相关的待做任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;底部的区块是和 OKR 相关的信息，让我可以快速了解到目前最重要的 Objective 有哪些。&lt;br/&gt;
当然这个系统远不止如此，更多的信息我会新开一篇文章来介绍如何用 Logseq 实现这些功能。也会写一篇文章介绍如何基于文本使用 Beancount 做复式记账。&lt;/p&gt;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3341cf6f94c0487190d7433a93080b67</guid>
<title>了不起的 Chrome 浏览器（四）：Chrome 92 新增 at 和 randomUUID 方法，Canvas 支持 Display P3 色域</title>
<link>https://toutiao.io/k/a333hks</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;7月20日正式发布的Chrome 92，带来了哪些有意思的新特性呢？&lt;/p&gt;&lt;h1 data-lake-id=&quot;34ddb71c8f8a82125eaf87ae6d4ea601&quot;/&gt;&lt;h1 data-lake-id=&quot;34ddb71c8f8a82125eaf87ae6d4ea601&quot;&gt;背景&lt;/h1&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;十多年来，Web技术突飞猛进，其中Chrome功不可没，了解Chrome可以帮助我们理解整个行业的发展趋势。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;因此，我将以《了不起的Chrome浏览器》为题，对Chrome的每一个版本的重要特性进行详细解读，同时分享一些自己的一些思考：&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;通过专注于Chrome的写作，既可以可以提高我的专业能力，也可以提高个人影响力。&lt;span&gt;我的目标是在2025年出版一本关于Chrome的书&lt;/span&gt;，毕竟出版自己的书每一个写作者最高的追求。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;我是寒雁，一个热爱写代码和写文章的程序员，欢迎关注我的微信公众号寒雁Talk。&lt;/p&gt;&lt;h1 data-lake-id=&quot;029f19ae2d05a034702f31a96a8d5500&quot;&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1 data-lake-id=&quot;029f19ae2d05a034702f31a96a8d5500&quot;&gt;TL;TR&lt;/h1&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;ul data-lake-id=&quot;f47e54ae4cb1ddca0278a84be2ace458&quot; start=&quot;1&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Chrome 92最大的亮点是什么？说实话，&lt;span&gt;Chrome92并没有什么特别大的亮点&lt;/span&gt;，不过Array.prototype.at()还是挺实用的&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Chrome 92是哪天发布的？2021-07-20&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Chrome 92更新了多少个特性？14个，具体有哪些特性可以查看Chrome Platform Status&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Chrome 92将使用哪个版本的V8引擎？9.2&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我感兴趣的新特性依次有哪些？&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-lake-id=&quot;a307463c5681d2c5807a63eedde86843&quot;&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1 data-lake-id=&quot;a307463c5681d2c5807a63eedde86843&quot;&gt;详细解读&lt;/h1&gt;&lt;h3 data-lake-id=&quot;da2607b47c7f128fa56b5519712d9475&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-lake-id=&quot;da2607b47c7f128fa56b5519712d9475&quot;&gt;Array.prototype.at()&lt;/h3&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;想必大家都写过这样的代码，使用数组长度减1来获取过数组的最后一个元素：&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; A = [&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;]; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;console&lt;/span&gt;.log(A[A.length - &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;]);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/pre&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;作为一个有代码洁癖的人，这样的写法冗长而奇怪。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;现在好了，Chrome 92支持Array.prototype.at()了：&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; A = [&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;]; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;console&lt;/span&gt;.log(A.at(&lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/pre&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;代码少了5个字符，可读性也提高了很多，一举两得!&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;另外，除了Array，String与TypedArray也支持了at方法。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;at方法对应的ECMAScript提案&lt;span&gt;proposal-relative-indexing-method已经处于stage 3&lt;/span&gt;，目测最快明年将会纳入ECMAScript规范。&lt;/p&gt;&lt;h3 data-lake-id=&quot;3d00855a8c2a513153da594cee6bb54b&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-lake-id=&quot;3d00855a8c2a513153da594cee6bb54b&quot;&gt;crypto.randomUUID()&lt;/h3&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;日常开发中，我们经常会需要生成唯一ID，例如给每个用户生成唯一ID。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;npm包uuid的周下载量高达4000万+，我在自己的代码里也搜到了uuid模块：&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2021%2Fjpeg%2F928098%2F1626511048566-ef600748-9b21-4dfe-a9bc-62ce08d5656d.jpeg%22%2C%22originWidth%22%3A616%2C%22originHeight%22%3A302%2C%22name%22%3A%22uuid.jpeg%22%2C%22size%22%3A32197%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A23.600388%2C%22y%22%3A26.034937%2C%22width%22%3A89.497292%2C%22height%22%3A19.291891%2C%22text%22%3A%22SEARCH%22%7D%2C%7B%22x%22%3A573.852%2C%22y%22%3A93.99997%2C%22width%22%3A17.957750000000033%2C%22height%22%3A17.957750000000033%2C%22text%22%3A%22*%22%7D%2C%7B%22x%22%3A477.27963%2C%22y%22%3A96.268555%2C%22width%22%3A29.191899999999976%2C%22height%22%3A20.685035%2C%22text%22%3A%22Aa%22%7D%2C%7B%22x%22%3A519.5305%2C%22y%22%3A96.96076%2C%22width%22%3A31.716600000000085%2C%22height%22%3A24.78455000000001%2C%22text%22%3A%22Abl%22%7D%2C%7B%22x%22%3A35.097496%2C%22y%22%3A101.07541%2C%22width%22%3A50.082863999999994%2C%22height%22%3A18.37362999999999%2C%22text%22%3A%22uuid%22%7D%2C%7B%22x%22%3A28.598978%2C%22y%22%3A167.71324%2C%22width%22%3A435.798882%2C%22height%22%3A24.737089999999995%2C%22text%22%3A%2215resultsin15files-Openineditor%22%7D%2C%7B%22x%22%3A85.401146%2C%22y%22%3A223.99823%2C%22width%22%3A163.973474%2C%22height%22%3A30.528879999999987%2C%22text%22%3A%22package.json%22%7D%2C%7B%22x%22%3A44.734283%2C%22y%22%3A229.47353%2C%22width%22%3A29.592957000000006%2C%22height%22%3A11.546019999999999%2C%22text%22%3A%22npm%22%7D%2C%7B%22x%22%3A71.00187%2C%22y%22%3A269.1899%2C%22width%22%3A174.92923%2C%22height%22%3A23.32556999999997%2C%22text%22%3A%22uuid%5C%22%3A%5C%227.0.3%5C%22%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22SEARCH%20*%20Aa%20Abl%20uuid%2015resultsin15files-Openineditor%20package.json%20npm%20uuid%5C%22%3A%5C%227.0.3%5C%22%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A308%2C%22height%22%3A151%2C%22id%22%3A%22yiIrd%22%7D&quot;&gt;&lt;img data-height=&quot;151px&quot; data-ratio=&quot;0.4902597402597403&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UnKibSlmUib8h6VL1oK56FSAYR5QY0f3dDVkuZIib2I3Juichaeajo39ia5Qa5WbPrHAsglUbUGwjgHe4UfqtjZvyEg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;616&quot; title=&quot;uuid.jpeg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;Chrome 92新增了crypto.randomUUID()方法，用于生成符合RFC 4122 version 4规范的唯一ID。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;可惜的是，由于Firefox、Safari等其他浏览器没有支持，因此前端项目中将依然需要使用uuid模块。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;不过，Node.js 14.17.0已经支持了crypto.randomUUID()方法，而生成唯一ID通常是在后端进行，因此目测uuid模块的使用量将会有所降低。使用官方提供的API更加安全，且性能更好。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;要保证随机生成的UUID的唯一性和安全性，是一个看起来简单，但实际非常复杂的问题。图灵奖得主Donald Knuth在他的鸿篇巨制《The Art of Computer Programming》中花了一个章节来讨论随机数：&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;It is not easy to invent a foolproof source of random numbers.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;我们所熟悉的Math.random()其实名不副实，并不随机，它是一个伪随机数生成器（Pseudo Random Number Generator，简称PRNG），当我们指定同一个random_seed启动时，它生成的随机数序列是一样的！&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;node --random_seed=&lt;span class=&quot;code-snippet__number&quot;&gt;42&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Welcome to Node.js v14&lt;span class=&quot;code-snippet__number&quot;&gt;.17&lt;/span&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;.3&lt;/span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Type &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;.help&quot;&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; more information.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Math&lt;/span&gt;.random()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;0.5254990606499601&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Math&lt;/span&gt;.random()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;0.963056226312738&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;node --random_seed=&lt;span class=&quot;code-snippet__number&quot;&gt;42&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Welcome to Node.js v14&lt;span class=&quot;code-snippet__number&quot;&gt;.17&lt;/span&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;.3&lt;/span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Type &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;.help&quot;&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; more information.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Math&lt;/span&gt;.random()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;0.5254990606499601&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Math&lt;/span&gt;.random()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;0.963056226312738&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;也就是说，只要黑客获取了random_seed，就能预测Math.random()所返回的&quot;随机序列&quot;，是不是有点可怕？&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;当然，获取random_seed并不是一件简单的事情，不过并非没有可能，因为random_seed不是随机的，而是依赖于一些内部状态，比如浏览器的启动时间、某个变量的虚拟内存地址，这些内部状态是有规律可循的。2014年，Andriod版的Firefox就曾被人破解过Math.random()。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;span&gt;因此，在对安全性要求比较高的场景中，不要使用Math.random()。&lt;/span&gt;CVE中有多个安全漏洞是与Math.random()相关。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;为了满足大家对于更加安全的加密API的需求，社区提供了很多解决方案，其中最出名的为CryptoJS。但是，对于加密这种CPU密集型应用，纯JavaScript的方案存在比较严重的性能问题，且不够安全。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;因此，2017年，W3C发布了Web Cryptography API，提供更加安全、性能更好的加密API。其中，crypto.getRandomValues()可以用于生成更加安全的随机数，它是密码学安全伪随机数生成器（Cryptographically Secure Pseudo Random Number Generator，简称CSPRNG）。其实，CSPRNG也不能生成真正的随机数，只是它可以通过一些严格的密码学测试，可以认为是安全的。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;51f50693f66baf1ce01a6330f88e7839&quot;&gt;crypto.randomUUID()是基于CSPRNG的，因此也可以认为是安全的。&lt;/p&gt;&lt;p data-lake-id=&quot;346b270359ecdd244fdaa1f36858afd3&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;a4156fd03a3b349d8aa16ede9ded4d06&quot;&gt;crypto.randomUUID()虽然放在cypto对象中，但是它还并未被纳入Web Cryptography API，因此还不是W3C标准。&lt;/p&gt;&lt;h3 data-lake-id=&quot;c52720c8c1e0172fb7ca680a89b969c5&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-lake-id=&quot;c52720c8c1e0172fb7ca680a89b969c5&quot;&gt;Canvas color management&lt;/h3&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;目前，2D canvas仅支持陈旧的sRGB色域，但是现在的屏幕和相机早就支持更大的色域了。&lt;/p&gt;&lt;p data-lake-id=&quot;21da956303b1d9a8d156c67dc2bf6ea5&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;4a0c96cf3239c96adb1866c928625585&quot;&gt;色域是什么呢？它的英文名是Color Gamut或者Color Space，是设备（显示器、投影仪、打印机）可以表达的颜色范围。人眼可见的颜色范围是有限的，而设备能表达的颜色范围是人眼可见的颜色范围的子集，而不同色域标准比如sRGB和Display P3能表达的颜色范围也不一样。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;Chrome 92支持在创建2D canvas时，使用Display P3色域，这将增强2D canvas的颜色还原能力。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;canvas.getContext(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;2d&#x27;&lt;/span&gt;, { &lt;span class=&quot;code-snippet__attr&quot;&gt;colorSpace&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;display-p3&quot;&lt;/span&gt;} );&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/pre&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;Display P3的色域比sRGB的色域大25%，当我们对比两者时，会发现Display P3要比sRGB明亮很多，区别非常明显：&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2021%2Fjpeg%2F928098%2F1626597197633-2387609e-2caf-4c26-84c2-f66df9bba5dc.jpeg%22%2C%22originWidth%22%3A1920%2C%22originHeight%22%3A1080%2C%22name%22%3A%22sRGB_vs_Display%20P3jpg.jpg%22%2C%22size%22%3A317566%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A1269.397%2C%22y%22%3A960.95935%2C%22width%22%3A340.9797000000001%2C%22height%22%3A70.90105000000005%2C%22text%22%3A%22DisplayP3%22%7D%2C%7B%22x%22%3A389.8314%2C%22y%22%3A971.4579%2C%22width%22%3A174.87640000000005%2C%22height%22%3A53.52499999999998%2C%22text%22%3A%22SRGB%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22DisplayP3%20SRGB%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A480%2C%22height%22%3A270%2C%22id%22%3A%22rmkeH%22%7D&quot;&gt;&lt;img data-height=&quot;270px&quot; data-ratio=&quot;0.5626666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UnKibSlmUib8h6VL1oK56FSAYR5QY0f3dDhCOGwuyTXAxbwxich3BJFnlhWLc7mVIVncavFu4IicqySzLzFssCHibbA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1500&quot; title=&quot;sRGB_vs_Display P3jpg.jpg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;图片来源：Get Started with Display P3&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;span&gt;对于图像、视频、设计、游戏、地图、外卖、电商等应用，准确还原颜色的重要性不言而喻&lt;/span&gt;。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;大多数情况下，买家秀和卖家秀的明显差异是由于卖家过度PS导致的，但是也有可能是颜色没有得到准确还原导致的。&lt;/p&gt;&lt;h3 data-lake-id=&quot;1eab0fba397f46ead93f4c3e8c9751c0&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-lake-id=&quot;1eab0fba397f46ead93f4c3e8c9751c0&quot;&gt;Web Bluetooth manufacturer data filter&lt;/h3&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;早在6年前，Chrome就开始开发Web Bluetooth了，不过直到今天，Web Bluetooth也没有成为W3C标准，Safari和Firefox也没有支持Web Bluetooth，这就有点尴尬了。&lt;/p&gt;&lt;p data-lake-id=&quot;e0b33ae1135656caa4d7bbc7ec4897a5&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;510d8be2365cf3b900b008f291b30360&quot;&gt;&lt;span&gt;Chrome以一己之力推动了众多Web技术标准的进步，但是从Web Bluetooth也可以看出，其过程还是比较艰辛的，需要时间和耐心。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;不过，为了让Web可以获得原生应用一样的能力，Chrome也不会放弃Web Bluetooth。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;使用Web Bluetooth，Web应用也可以连接并控制各种蓝牙设备，比如彩灯、玩具车、LED、无人机，还是很有意思的：&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p/&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;视频来源：WebBluetooth demos for Bluetooth.rocks&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;Chrome 92为Web Bluetooth新增了按照蓝牙设备的制造商来过滤蓝牙设备的能力。这样，对于一些针对特定产商的Web应用，就可以只给用户展示对应产商的蓝牙设备。&lt;/p&gt;&lt;h1 data-lake-id=&quot;e0ff11f66e8207127bf9c4be254c79c2&quot;&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1 data-lake-id=&quot;e0ff11f66e8207127bf9c4be254c79c2&quot;&gt;总结&lt;/h1&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;本篇是《了不起的Chrome浏览器》的第4篇，坚持更新这个系列的博客还是挺难的，一方面工作太忙了，另一方面Chrome 92可以写的内容确实不多，我也不是很熟悉，需要很多时间挖掘。但是，不管怎样，我还是会坚持写下去，因为每次都能学到一些新的东西。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;写博客的过程中，我会阅读大量的参考资料，并且记录阅读笔记，所以我阅读的时间是远远大于写作的时间的。如果不是为了写作，我并不会对某一个知识点进行深究，&lt;span&gt;这也是写作最大的好处，通过输入倒逼输出，倒逼自己进行深度学习&lt;/span&gt;。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;对于比较权威，内容很有启发的参考资料，我都会列到文章后面。这样既是对作者版权的尊重，也是方便自己和读者去阅读相关资料。某个知识点真正优质的内容是非常稀缺的，要找到这些资料是需要一些Google技巧的：准确变换不同的搜索关键词，不断递归地挖掘最原始、最权威的第一手资料。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;另外，我写博客都不是几个小时或者几天时间写完的，长篇的博客写作时间长达一个月，所以改动会很频繁，整个写作过程语雀都会有修改记录。这样写看起来很累，但是其实是把一个大的任务拆分成了一个个小任务，反而轻松很多。另外，每一次写都会有一些新的发现、新的灵感，这对于写作也是非常有帮助的。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;欢迎关注寒雁Talk公众号，关注《了不起的Chrome浏览器》系列博客，与我一起见证大前端的星辰大海！&lt;/p&gt;&lt;h1 data-lake-id=&quot;66e83f284b44207f4edb9c154b825666&quot;&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1 data-lake-id=&quot;66e83f284b44207f4edb9c154b825666&quot;&gt;参考资料&lt;/h1&gt;&lt;p data-lake-id=&quot;4b8cf913d96df71dd5bbba164fdbd7ff&quot;&gt;&lt;/p&gt;&lt;ul data-lake-id=&quot;a49861708177b3fa3e4972a9e227ecbf&quot; start=&quot;1&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjI2OTI0Nw==&amp;amp;mid=2247483736&amp;amp;idx=1&amp;amp;sn=48b87e3902fe8f6752aae18b9fe2a18d&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;了不起的Chrome浏览器（1）：Chrome 89开启Web应用的物联网时代&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjI2OTI0Nw==&amp;amp;mid=2247483765&amp;amp;idx=1&amp;amp;sn=cebe653e89518574a785c32b6aad88aa&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;了不起的Chrome浏览器（2）：Chrome 90将默认使用HTTPS，Web更安全了&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjI2OTI0Nw==&amp;amp;mid=2247483785&amp;amp;idx=1&amp;amp;sn=e66890ec12bc3f9ffa88e8712283abbc&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;了不起的Chrome浏览器（3）：Chrome 91支持WebAssembly SIMD，加&lt;/a&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjI2OTI0Nw==&amp;amp;mid=2247483785&amp;amp;idx=1&amp;amp;sn=e66890ec12bc3f9ffa88e8712283abbc&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;Web在AI等领域的应用&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Chrome 92: Web Apps as File Handlers, New JavaScript Features, and More&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;V8 release v9.2&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;at method for relative indexing&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;crypto.randomUUID is three times faster uuid.v4&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Overtaking Firefox Profiles: Vulnerabilities in Firefox for Android&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;TIFU by using Math.random()&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;A Brief History of Random Numbers&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;[V8 Deep Dives] Random Thoughts on Math.random()&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;《Art of Computer Programming, Volume 2: Seminumerical Algorithms, 3rd Edition》Chapter 3: Random Numbers&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Securing JavaScript applications with the Web Cryptography API&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Update on Web Cryptography&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Get Started with Display P3&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Improving Color on the Web&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Pixar in a Box: Color science&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;An Introduction To WebBluetooth&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;WebBluetooth demos for Bluetooth.rocks&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-lake-id=&quot;876710649adfccbc2696bad88f733ccb&quot;&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1 data-lake-id=&quot;876710649adfccbc2696bad88f733ccb&quot;&gt;招聘&lt;/h1&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;阿里巴巴业务平台事业部长期招聘P6及以上前端大佬，参与建设最前沿的阿里前端生态系统，推动行业技术发展，内推地址：hanyan.lk@alibaba-inc.com&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;欢迎大家关注我的微信公众号寒雁Talk。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2021%2Fwebp%2F928098%2F1619341927214-9586185e-dfc0-4bf1-a2b8-222f7059c1bd.webp%22%2C%22originWidth%22%3A1080%2C%22originHeight%22%3A394%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A540%2C%22height%22%3A197%2C%22id%22%3A%22pfcLA%22%7D&quot;&gt;&lt;img data-height=&quot;197px&quot; data-ratio=&quot;0.3648148148148148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/UnKibSlmUib8h6VL1oK56FSAYR5QY0f3dDzLPm5ibCBjlHgrQYNjjL7OQ02gicezTDy8SUt9MibmxLhWQ2VI2TZKz3A/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1080&quot; title=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ea1f9a1bf5e2c124ecd19d17b8d5dc39</guid>
<title>前端单元测试技术方案总结</title>
<link>https://toutiao.io/k/7iqle6u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.00703125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KV8By3euEQhZYTauMbrpamMgft7MXkV3icjnWU3XfYR2IN32GOkuaEa93kR5muQNzujot0JBJKjp49QnU7Oiaelw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本文作者: &lt;span&gt;江水&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要介绍前端&lt;strong&gt;单元测试&lt;/strong&gt;的一些技术方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单元测试的技术方案很多，不同工具之间有互相协同，也存在功能重合，给我们搭配测试方案带来不小的困难，而且随着 &lt;code&gt;ES6&lt;/code&gt;, &lt;code&gt;TypeScript&lt;/code&gt; 的出现，单元测试又增加了很多其他步骤，完整配置起来往往需要很大的时间成本。我希望通过对这些工具的各自作用的掌握，了解完整的前端测试技术方案。前端单元测试的领域也很多，这里主要讲对于前端组件如何进行单元测试，最后会主要介绍下对于 &lt;code&gt;React&lt;/code&gt; 组件的一些测试方法总结。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;通用测试&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单元测试最核心的部分就是做断言，比如传统语言中的 &lt;code&gt;assert&lt;/code&gt; 函数，如果当前程序的某种状态符合 &lt;code&gt;assert&lt;/code&gt; 的期望此程序才能正常执行，否则直接退出应用。所以我们可以直接用 &lt;code&gt;Node&lt;/code&gt; 中自带的 &lt;code&gt;assert&lt;/code&gt; 模块做断言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用最简单的例子做个验证&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;multiple&lt;/span&gt;(&lt;span&gt;a, b&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; result = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b; ++i)&lt;br/&gt;        result += a;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; assert = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;assert&#x27;&lt;/span&gt;);&lt;br/&gt;assert.equal(multiple(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;), &lt;span&gt;3&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种例子能够满足基础场景的使用，也可以作为一种单元测试的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;nodejs&lt;/code&gt; 自带的 &lt;code&gt;assert&lt;/code&gt; 模块提供了下面一些断言方法，只能满足一些简单场景的需要。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;assert.deepEqual(actual, expected[, message])&lt;br/&gt;assert.deepStrictEqual(actual, expected[, message])&lt;br/&gt;assert.doesNotMatch(string, regexp[, message])&lt;br/&gt;assert.doesNotReject(asyncFn[, error][, message])&lt;br/&gt;assert.doesNotThrow(fn[, error][, message])&lt;br/&gt;assert.equal(actual, expected[, message])&lt;br/&gt;assert.fail([message])&lt;br/&gt;assert.ifError(value)&lt;br/&gt;assert.match(string, regexp[, message])&lt;br/&gt;assert.notDeepEqual(actual, expected[, message])&lt;br/&gt;assert.notDeepStrictEqual(actual, expected[, message])&lt;br/&gt;assert.notEqual(actual, expected[, message])&lt;br/&gt;assert.notStrictEqual(actual, expected[, message])&lt;br/&gt;assert.ok(value[, message])&lt;br/&gt;assert.rejects(asyncFn[, error][, message])&lt;br/&gt;assert.strictEqual(actual, expected[, message])&lt;br/&gt;assert.throws(fn[, error][, message])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自带的 &lt;code&gt;assert&lt;/code&gt; 不是专门给单元测试使用, 提供的错误信息文档性不好，上面的 &lt;code&gt;demo&lt;/code&gt; 最终执行下来会产生下面的报告:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ node index.js&lt;br/&gt;assert.js:84&lt;br/&gt;  throw new AssertionError(obj);&lt;br/&gt;  ^&lt;br/&gt;&lt;br/&gt;AssertionError [ERR_ASSERTION]: 2 == 3&lt;br/&gt;    at Object.&amp;lt;anonymous&amp;gt; (/home/quanwei/git/index.js:4:8)&lt;br/&gt;    at Module._compile (internal/modules/cjs/loader.js:778:30)&lt;br/&gt;    at Object.Module._extensions..js (internal/modules/cjs/loader.js:789:10)&lt;br/&gt;    at Module.load (internal/modules/cjs/loader.js:653:32)&lt;br/&gt;    at tryModuleLoad (internal/modules/cjs/loader.js:593:12)&lt;br/&gt;    at Function.Module._load (internal/modules/cjs/loader.js:585:3)&lt;br/&gt;    at Function.Module.runMain (internal/modules/cjs/loader.js:831:12)&lt;br/&gt;    at startup (internal/bootstrap/node.js:283:19)&lt;br/&gt;    at bootstrapNodeJSCore (internal/bootstrap/node.js:623:3)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于自带的模块依赖 &lt;code&gt;Node&lt;/code&gt; 自身的版本，没办法自由升级，所以使用内置的包灵活性有时候不太够，另外我们很多断言函数也需要在浏览器端执行，所以我们需要同时支持浏览器和 &lt;code&gt;Node&lt;/code&gt; 端的断言库。同时观察上面的输出可以发现，这个报告更像是程序的错误报告，而不是一个单元测试报告。而我们在做单元测时往往需要断言库能够提供良好的测试报告，这样才能一目了然地看到有哪些断言通过没通过，所以使用专业的单元测试断言库还是很有必要。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;chai&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4000744324525493&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQhZYTauMbrpamMgft7MXkV33b7975QDrWQCSnPO5oglyBGEoczzDpYJ9vyfibQTicqOnWCodIwrJF8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2687&quot;/&gt;&lt;figcaption&gt;chai&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;chai&lt;/code&gt; 是目前很流行的断言库，相比于同类产品比较突出。&lt;code&gt;chai&lt;/code&gt; 提供了 &lt;span&gt;TDD&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt; (Test-driven development）和 &lt;span&gt;BDD&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt; (Behavior-driven development) 两种风格的断言函数，这里不会过多介绍两种风格的优缺，本文主要以 &lt;code&gt;BDD&lt;/code&gt; 风格做演示。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;TDD 风格的 chai&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; assert = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;chai&#x27;&lt;/span&gt;).assert&lt;br/&gt;  , foo = &lt;span&gt;&#x27;bar&#x27;&lt;/span&gt;&lt;br/&gt;  , beverages = { &lt;span&gt;tea&lt;/span&gt;: [ &lt;span&gt;&#x27;chai&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;matcha&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;oolong&#x27;&lt;/span&gt; ] };&lt;br/&gt;&lt;br/&gt;assert.typeOf(foo, &lt;span&gt;&#x27;string&#x27;&lt;/span&gt;); &lt;span&gt;// without optional message&lt;/span&gt;&lt;br/&gt;assert.typeOf(foo, &lt;span&gt;&#x27;number&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;foo is a number&#x27;&lt;/span&gt;); &lt;span&gt;// with optional message&lt;/span&gt;&lt;br/&gt;assert.equal(foo, &lt;span&gt;&#x27;bar&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;foo equal `bar`&#x27;&lt;/span&gt;);&lt;br/&gt;assert.lengthOf(foo, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;&#x27;foo`s value has a length of 3&#x27;&lt;/span&gt;);&lt;br/&gt;assert.lengthOf(beverages.tea, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;&#x27;beverages has 3 types of tea&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;chai&lt;/code&gt; 比 &lt;code&gt;Node&lt;/code&gt; 自带的 &lt;code&gt;assert&lt;/code&gt; 增加了一个断言说明参数，可以通过这个参数提高测试报告的可读性&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ node chai-assert.js&lt;br/&gt;&lt;br/&gt;/home/quanwei/git/learn-tdd-bdd/node_modules/chai/lib/chai/assertion.js:141&lt;br/&gt;      throw new AssertionError(msg, {&lt;br/&gt;      ^&lt;br/&gt;AssertionError: foo is a number: expected &lt;span&gt;&#x27;bar&#x27;&lt;/span&gt; to be a number&lt;br/&gt;    at Object.&amp;lt;anonymous&amp;gt; (/home/quanwei/git/learn-tdd-bdd/chai-assert.js:6:8)&lt;br/&gt;    at Module._compile (internal/modules/cjs/loader.js:778:30)&lt;br/&gt;    at Object.Module._extensions..js (internal/modules/cjs/loader.js:789:10)&lt;br/&gt;    at Module.load (internal/modules/cjs/loader.js:653:32)&lt;br/&gt;    at tryModuleLoad (internal/modules/cjs/loader.js:593:12)&lt;br/&gt;    at Function.Module._load (internal/modules/cjs/loader.js:585:3)&lt;br/&gt;    at Function.Module.runMain (internal/modules/cjs/loader.js:831:12)&lt;br/&gt;    at startup (internal/bootstrap/node.js:283:19)&lt;br/&gt;    at bootstrapNodeJSCore (internal/bootstrap/node.js:623:3)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;BDD 风格的 chai&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;chai&lt;/code&gt; 的 &lt;code&gt;BDD&lt;/code&gt; 风格使用 &lt;code&gt;expect&lt;/code&gt; 函数作为语义的起始，也是目前几乎所有 &lt;code&gt;BDD&lt;/code&gt; 工具库都遵循的风格。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;chai&lt;/code&gt; 的 &lt;code&gt;expect&lt;/code&gt; 断言风格如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;expect(foo).to.be.a(&lt;span&gt;&#x27;string&#x27;&lt;/span&gt;);&lt;br/&gt;expect(foo).to.equal(&lt;span&gt;&#x27;bar&#x27;&lt;/span&gt;);&lt;br/&gt;expect(foo).to.have.lengthOf(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;BDD&lt;/code&gt; 的思想就是写单元测试就像写产品需求，而不关心内部逻辑，每一个用例阅读起来就像一篇文档。例如下面的用例：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;foo 是一个字符串              -&amp;gt;&lt;code&gt;expect(foo).to.be.a(&#x27;string&#x27;)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;foo 字符串里包含 &#x27;bar&#x27;     -&amp;gt;&lt;code&gt;expect(foo).to.include(&#x27;bar&#x27;)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;foo 字符串里不包含 &#x27;biz&#x27;  -&amp;gt; &lt;code&gt;expect(foo).to.not.include(&#x27;biz&#x27;)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到这种风格的测试用例可读性更强。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他的断言库还有 &lt;code&gt;expect.js&lt;/code&gt; &lt;code&gt;should.js&lt;/code&gt; &lt;span&gt;better-assert&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt; , &lt;span&gt;unexpected.js&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt; 这些断言库都只提供纯粹的断言函数，可以根据喜好选择不同的库使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了断言库之后我们还需要使用测试框架将我们的断言更好地组织起来。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;mocha 和 Jasmine&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4188262195121951&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQhZYTauMbrpamMgft7MXkV3wLnQa5ryeJqMPPuGVkMBkOkCqD24qbUZH1q5VdS6lFHzV5k1nC8vwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2624&quot;/&gt;&lt;figcaption&gt;mocha jasmine&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;mocha&lt;/code&gt; 是一个经典的测试框架(Test Framework)，测试框架提供了一个单元测试的骨架，可以将不同子功能分成多个文件，也可以对一个子模块的不同子功能再进行不同的功能测试，从而生成一份结构型的测试报告。例如 &lt;code&gt;mocha&lt;/code&gt; 就提供了&lt;code&gt;describe&lt;/code&gt; 和 &lt;code&gt;it&lt;/code&gt; 描述用例结构，提供了 &lt;code&gt;before&lt;/code&gt;, &lt;code&gt;after&lt;/code&gt;, &lt;code&gt;beforeEach&lt;/code&gt;, &lt;code&gt;afterEach&lt;/code&gt; 生命周期函数，提供了 &lt;code&gt;describe.only&lt;/code&gt; ,&lt;code&gt;describe.skip&lt;/code&gt; , &lt;code&gt;it.only&lt;/code&gt;, &lt;code&gt;it.skip&lt;/code&gt; 用以执行指定部分测试集。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; { expect } = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;chai&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; { multiple } = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;./index&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;describe(&lt;span&gt;&#x27;Multiple&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;    it (&lt;span&gt;&#x27;should be a function&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;        expect(multiple).to.be.a(&lt;span&gt;&#x27;function&#x27;&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;&lt;br/&gt;    it (&lt;span&gt;&#x27;expect 2 * 3 = 6&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;        expect(multiple(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;)).to.be.equal(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试框架不依赖底层的断言库，哪怕使用原生的 &lt;code&gt;assert&lt;/code&gt; 模块也可以进行。给每一个文件都要手动引入 &lt;code&gt;chai&lt;/code&gt; 比较麻烦 ，这时候可以给 &lt;code&gt;mocha&lt;/code&gt; 配置全局脚本，在项目根目录 &lt;code&gt;.mocharc.js&lt;/code&gt; 文件中加载断言库, 这样每个文件就可以直接使用 &lt;code&gt;expect&lt;/code&gt; 函数了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// .mocharc.js&lt;/span&gt;&lt;br/&gt;global.expect = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;chai&#x27;&lt;/span&gt;).expect;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 mocha 可以将我们的单元测试输出成一份良好的测试报告 &lt;code&gt;mocha *.test.js&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3337969401947149&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQhZYTauMbrpamMgft7MXkV3yrCp19zdvz9gFa8J3xDvrALTdp42aYhnT1ibxxHwojPr22NKPWoAjHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1438&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当出现错误时输出如下&lt;img data-ratio=&quot;0.5314091680814941&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQhZYTauMbrpamMgft7MXkV3yAwX12uvlhsEkfrzcZNgEZqpsvMXXh9rEPXepaDeYgOzlwux9UQTqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1767&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为运行在不同环境中需要的包格式不同，所以需要我们针对不同环境做不同的包格式转换，为了了解在不同端跑单元测试需要做哪些事情，可以先来了解一下常见的包格式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前我们主流有三种模块格式，分别是 &lt;code&gt;AMD&lt;/code&gt;, &lt;code&gt;CommonJS&lt;/code&gt;, &lt;code&gt;ES Module&lt;/code&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;AMD&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;AMD&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt; 是 &lt;code&gt;RequireJS&lt;/code&gt; 推广过程中流行的一个比较老的规范，目前无论浏览器还是 &lt;code&gt;Node&lt;/code&gt; 都没有默认支持。&lt;code&gt;AMD&lt;/code&gt; 的标准定义了 &lt;code&gt;define&lt;/code&gt; 和 &lt;code&gt;require&lt;/code&gt;函数，&lt;code&gt;define&lt;/code&gt;用来定义模块及其依赖关系，&lt;code&gt;require&lt;/code&gt; 用以加载模块。例如&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;!doctype html&amp;gt;&lt;br/&gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&lt;br/&gt;    &amp;lt;head&amp;gt;&lt;br/&gt;        &amp;lt;meta charset=&quot;UTF-8&quot;/&amp;gt;&lt;br/&gt;        &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;&lt;br/&gt;&lt;span&gt;+        &amp;lt;script&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+   src=&quot;https://requirejs.org/docs/release/2.3.6/minified/require.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+        &amp;lt;script src=&quot;./index.js&quot; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;    &amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&amp;lt;/html&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// index.js&lt;/span&gt;&lt;br/&gt;define(&lt;span&gt;&#x27;moduleA&#x27;&lt;/span&gt;, [&lt;span&gt;&#x27;https://some/of/cdn/path&#x27;&lt;/span&gt;], &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; { &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;moduleA&#x27;&lt;/span&gt; };&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;define(&lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;require&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; fs = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;fs&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; fs;&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;define(&lt;span&gt;&#x27;moduleB&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; { &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;module B&#x27;&lt;/span&gt; }&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;require&lt;/span&gt;([&lt;span&gt;&#x27;moduleA&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;moduleB&#x27;&lt;/span&gt;], &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;moduleA, moduleB&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;module&lt;/span&gt;);&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里使用了&lt;code&gt;RequireJS&lt;/code&gt; 作为 &lt;code&gt;AMD&lt;/code&gt; 引擎, 可以看到 &lt;code&gt;define&lt;/code&gt; 函数会定义当前依赖了哪些模块并将模块加载完成后异步回调给当前模块，这种特性使得 AMD 尤为适合浏览器端异步加载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用 &lt;code&gt;webpack&lt;/code&gt; 打包一份 &lt;code&gt;amd&lt;/code&gt; 模块看下真实代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// entry.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;sayHello&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&#x27;hello amd&#x27;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// webpack.config.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;    &lt;span&gt;mode&lt;/span&gt;: &lt;span&gt;&#x27;development&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;devtool&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;entry&lt;/span&gt;: &lt;span&gt;&#x27;./entry.js&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;output&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;libraryTarget&lt;/span&gt;: &lt;span&gt;&#x27;amd&#x27;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终生成代码(精简了不相关的逻辑)&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// dist/main.js&lt;/span&gt;&lt;br/&gt;define(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; ({&lt;br/&gt;    &lt;span&gt;default&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;sayHello&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&#x27;hello amd&#x27;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在浏览器/&lt;code&gt;Node&lt;/code&gt; 中想要使用 &lt;code&gt;AMD&lt;/code&gt; 需要全局引入 &lt;code&gt;RequireJS&lt;/code&gt;，对单元测试而言比较典型的问题是在初始化 &lt;code&gt;karma&lt;/code&gt; 时会询问是否使用 &lt;code&gt;RequireJS&lt;/code&gt; ，不过一般现在很少有人使用了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;CommonJS&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以缩写成&lt;code&gt;CJS&lt;/code&gt; , 其 &lt;span&gt;规范 &lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;主要是为了定义 &lt;code&gt;Node&lt;/code&gt; 的包格式，&lt;code&gt;CJS&lt;/code&gt; 定义了三个关键字, 分别为 &lt;code&gt;require&lt;/code&gt;，&lt;code&gt;exports&lt;/code&gt;, &lt;code&gt;module&lt;/code&gt;, 目前几乎所有&lt;code&gt;Node&lt;/code&gt; 包以及前端相关的&lt;code&gt;NPM&lt;/code&gt;包都会转换成该格式, &lt;code&gt;CJS&lt;/code&gt; 在浏览器端需要使用 &lt;code&gt;webpack&lt;/code&gt; 或者 &lt;code&gt;browserify&lt;/code&gt; 等工具打包后才能执行。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ES Module&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ES Module&lt;/code&gt; 是 &lt;code&gt;ES 2015&lt;/code&gt; 中定义的一种模块规范，该规范定义了 代表为 &lt;code&gt;import&lt;/code&gt; 和 &lt;code&gt;export&lt;/code&gt; ，是我们开发中常用的一种格式。虽然目前很多新版浏览器都支持&lt;code&gt;&amp;lt;script type=&quot;module&quot;&amp;gt;&lt;/code&gt; 了，支持在浏览器中直接运行 &lt;code&gt;ES6&lt;/code&gt; 代码，但是浏览器不支持 &lt;code&gt;node_modules&lt;/code&gt; ，所以我们的原始 &lt;code&gt;ES6&lt;/code&gt; 代码在浏览器上依然无法运行，所以这里我暂且认为浏览器不支持 &lt;code&gt;ES6&lt;/code&gt; 代码, 依然需要做一次转换。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下表为每种格式的支持范围，括号内表示需要借助外部工具支持。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;Node&lt;/th&gt;&lt;th&gt;浏览器&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;AMD&lt;/td&gt;&lt;td&gt;不支持(require.js, r.js)&lt;/td&gt;&lt;td&gt;不支持(require.js)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CommonJS&lt;/td&gt;&lt;td&gt;&lt;strong&gt;支持&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;不支持(webpack/browserify)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ESModule&lt;/td&gt;&lt;td&gt;不支持(babel)&lt;/td&gt;&lt;td&gt;不支持(webpack)&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单元测试要在不同的环境下执行就要打不同环境对应的包，所以在搭建测试工具链时要确定自己运行在什么环境中，如果在 &lt;code&gt;Node&lt;/code&gt; 中只需要加一层 &lt;code&gt;babel&lt;/code&gt; 转换，如果是在真实浏览器中，则需要增加 &lt;code&gt;webpack&lt;/code&gt; 处理步骤。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以为了能够在 &lt;code&gt;Node&lt;/code&gt; 环境的 &lt;code&gt;Mocha&lt;/code&gt;中使用 &lt;code&gt;ES Module&lt;/code&gt; 有两种方式&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Node&lt;/code&gt; 环境天生支持 &lt;code&gt;ES Module&lt;/code&gt; (node version &amp;gt;= 15)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 &lt;code&gt;babel&lt;/code&gt; 代码进行一次转换&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一种方式略过，第二种方式使用下面的配置&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install @babel/register @babel/core @babel/preset-env --save-dev&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// .mocharc.js&lt;br/&gt;&lt;span&gt;+ require(&#x27;@babel/register&#x27;);&lt;/span&gt;&lt;br/&gt;global.expect = require(&#x27;chai&#x27;).expect;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// .babelrc&lt;br/&gt;&lt;span&gt;+ {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+    &quot;presets&quot;: [&quot;@babel/preset-env&quot; ，“@babel/preset-typescript”]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+ }&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样地如果在项目中用到了 &lt;code&gt;TypeScript&lt;/code&gt;, 就可以使用&lt;code&gt;ts-node/register&lt;/code&gt; 来解决，因为 &lt;code&gt;TypeScript&lt;/code&gt;本身支持 &lt;code&gt;ES Module&lt;/code&gt; 转换成 &lt;code&gt;CJS&lt;/code&gt;, 所以支持了 &lt;code&gt;TypeScript&lt;/code&gt;后就不需要使用 &lt;code&gt;babel&lt;/code&gt; 来转换了。(这里假设使用了 &lt;code&gt;TypeScript&lt;/code&gt; 的默认配置)&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install ts-node typescript --save-dev&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// .mocharc.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;ts-node/register&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Mocha&lt;/code&gt; 自身支持浏览器和 &lt;code&gt;Node&lt;/code&gt; 端测试，为了在浏览器端测试我们需要写一个 html, 里面使用 &lt;code&gt;&amp;lt;script src=&quot;mocha.min.js&quot;&amp;gt;&lt;/code&gt; 的文件，然后再将本地所有文件插入到html中才能完成测试，手动做工程化效率比较低，所以需要借助工具来实现这个任务，这个工具就是 &lt;code&gt;Karma&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Karma&lt;/code&gt; 本质上就是在本地启动一个web服务器，然后再启动一个外部浏览器加载一个引导脚本，这个脚本将我们所有的源文件和测试文件加载到浏览器中，最终就会在浏览器端执行我们的测试用例代码。所以使用 &lt;code&gt;Karma&lt;/code&gt; + &lt;code&gt;mocha&lt;/code&gt; +&lt;code&gt;chai&lt;/code&gt; 即可搭建一个完整的浏览器端的单元测试工具链。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install karma mocha chai karma-mocha karma-chai --save-dev&lt;br/&gt;npx karma init&lt;br/&gt;// Which testing framework do you want to use: mocha&lt;br/&gt;// Do you want to use Require.js: no&lt;br/&gt;// Do you want capture any browsers automatically: Chrome&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里 &lt;code&gt;Karma&lt;/code&gt; 初始化时选择了 &lt;code&gt;Mocha&lt;/code&gt; 的支持，然后第二个 &lt;code&gt;Require.js&lt;/code&gt; 一般为否，除非业务代码中使用了&lt;code&gt;amd&lt;/code&gt;类型的包。第三个选用 &lt;code&gt;Chrome&lt;/code&gt; 作为测试浏览器。然后再在代码里单独配置下 &lt;code&gt;chai&lt;/code&gt; 。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// karma.conf.js&lt;br/&gt;module.exports = function(config) {&lt;br/&gt;  config.set({&lt;br/&gt;&lt;br/&gt;    // base path that will be used to resolve all patterns (eg. files, exclude)&lt;br/&gt;    basePath: &#x27;&#x27;,&lt;br/&gt;&lt;br/&gt;    // frameworks to use&lt;br/&gt;    // available frameworks: https://npmjs.org/browse/keyword/karma-adapter&lt;br/&gt;&lt;span&gt;-    frameworks: [&#x27;mocha&#x27;],&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+    frameworks: [&#x27;mocha&#x27;, &#x27;chai&#x27;],&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    // list of files / patterns to load in the browser&lt;br/&gt;    files: [],&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Karma&lt;/code&gt; 的 &lt;code&gt;frameworks&lt;/code&gt; 作用是在全局注入一些依赖，这里的配置就是将 &lt;code&gt;Mocha&lt;/code&gt; 和 &lt;code&gt;chai&lt;/code&gt; 提供的测试相关工具暴露在全局上供代码里使用。&lt;code&gt;Karma&lt;/code&gt; 只是将我们的文件发送到浏览器去执行，但是根据前文所述我们的代码需要经过 &lt;code&gt;webpack&lt;/code&gt; 或 &lt;code&gt;browserify&lt;/code&gt; 打包后才能运行在浏览器端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果原始代码已经是 &lt;code&gt;CJS&lt;/code&gt;了，可以使用 &lt;code&gt;browserify&lt;/code&gt; 来支持浏览器端运行，基本零配置，但是往往现实世界比较复杂，我们有 &lt;code&gt;ES6&lt;/code&gt;，&lt;code&gt;JSX&lt;/code&gt; 以及 &lt;code&gt;TypeScript&lt;/code&gt; 要处理，所以这里我们使用 &lt;code&gt;webpack&lt;/code&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是 &lt;code&gt;webpack&lt;/code&gt; 的配置信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install karma-webpack@4 webpack@4 @babel/core @babel/preset-env @babel/preset-react babel-loader --save-dev&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// karma.conf.js&lt;br/&gt;module.exports = function(config) {&lt;br/&gt;  config.set({&lt;br/&gt;&lt;br/&gt;    // base path that will be used to resolve all patterns (eg. files, exclude)&lt;br/&gt;    basePath: &#x27;&#x27;,&lt;br/&gt;&lt;br/&gt;    // frameworks to use&lt;br/&gt;    // available frameworks: https://npmjs.org/browse/keyword/karma-adapter&lt;br/&gt;    frameworks: [&#x27;mocha&#x27;, &#x27;chai&#x27;],&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    // list of files / patterns to load in the browser&lt;br/&gt;    files: [&lt;br/&gt;&lt;span&gt;+      { pattern: &quot;test/*.test.js&quot;, watched: false }&lt;/span&gt;&lt;br/&gt;    ],&lt;br/&gt;&lt;br/&gt;    preprocessors: {&lt;br/&gt;&lt;span&gt;+      &#x27;test/**/*.js&#x27;: [ &#x27;webpack&#x27;]&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;&lt;br/&gt;&lt;span&gt;+    webpack: {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+       module: {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+   rules: [{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+           test: /.*\.js/,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+           use: &#x27;babel-loader&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+         }]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+     }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+    },&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// .babelrc&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;&quot;presets&quot;&lt;/span&gt;: [&lt;span&gt;&quot;@babel/preset-env&quot;&lt;/span&gt;, &lt;span&gt;&quot;@babel/preset-react&quot;&lt;/span&gt;]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们测试一个&lt;code&gt;React&lt;/code&gt; 程序代码如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// js/index.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; React &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; ReactDOM &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react-dom&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;renderToPage&lt;/span&gt;(&lt;span&gt;str&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; container = &lt;span&gt;document&lt;/span&gt;.createElement(&lt;span&gt;&#x27;div&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;document&lt;/span&gt;.body.appendChild(container);&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;there is real browser&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;&lt;span&gt;resolve&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        ReactDOM.render(&lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;{ str } &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;, container, resolve);&lt;br/&gt;    });&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// test/index.test.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { renderToPage } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;../js/index&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;describe(&lt;span&gt;&#x27;renderToPage&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;    it (&lt;span&gt;&#x27;should render to page&#x27;&lt;/span&gt;, &lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; content = &lt;span&gt;&#x27;magic string&#x27;&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;await&lt;/span&gt; renderToPage(content);&lt;br/&gt;        expect(&lt;span&gt;document&lt;/span&gt;.documentElement.innerText).to.be.contain(content);&lt;br/&gt;    })&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.28008407777193906&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQhZYTauMbrpamMgft7MXkV3yIVR17Kp33u07AL5tuoaq36MowPveCtpibp68o8E6SayOkndUiaIzpFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1903&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且打开了本地浏览器&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.42946708463949845&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQhZYTauMbrpamMgft7MXkV3ib5yjXImfcfyAybZ22HpMtJHTFza4OPNIzcNnoX6b3Px7ib9cxaI0a9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2233&quot;/&gt;&lt;figcaption&gt;karma browser&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到现在已经在真实浏览器中运行测试程序了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为图形化的测试对 &lt;code&gt;CI&lt;/code&gt; 机器不友好，所以可以选择 &lt;code&gt;puppeteer&lt;/code&gt; 代替 &lt;code&gt;Chrome&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再者这些都是很重的包，如果对真实浏览器依赖性不强，可以使用 &lt;code&gt;JSDOM&lt;/code&gt; 在 &lt;code&gt;Node&lt;/code&gt; 端模拟一个浏览器环境。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;稍微总结下工具链&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在 Node 环境下测试工具链可以为 : &lt;code&gt;mocha&lt;/code&gt; + &lt;code&gt;chai&lt;/code&gt; + &lt;code&gt;babel&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模拟浏览器环境可以为 : &lt;code&gt;mocha&lt;/code&gt; + &lt;code&gt;chai&lt;/code&gt; + &lt;code&gt;babel&lt;/code&gt; + &lt;code&gt;jsdom&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在真实浏览器环境下测试工具链可以为 : &lt;code&gt;karma&lt;/code&gt; + &lt;code&gt;mocha&lt;/code&gt; + &lt;code&gt;chai&lt;/code&gt; + &lt;code&gt;webpack&lt;/code&gt; + &lt;code&gt;babel&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个测试流水线往往需要很多个工具搭配使用，配置起来比较繁琐，还有一些额外的工具例如单元覆盖率（istanbul），函数/时间模拟 (sinon.js）等工具。工具之间的配合有时候不一定能够完美契合，选型费时费力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;jasmine&lt;/code&gt; 的出现就稍微缓解了一下这个问题，但也不够完整，&lt;code&gt;jasmine&lt;/code&gt;提供一个测试框架，里面包含了 测试流程框架，断言函数，mock工具等测试中会遇到的工具。可以近似地看作 &lt;code&gt;jasmine = mocha + chai + 辅助工具&lt;/code&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来试一试 &lt;code&gt;jasmine&lt;/code&gt; 的工作流程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;npx jasmine init&lt;/code&gt; 初始化之后会在当前目录中生成&lt;code&gt;spec&lt;/code&gt;目录, 其中包含一份默认的配置文件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// ./spec/support/jasmine.json&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;spec_dir&quot;&lt;/span&gt;: &lt;span&gt;&quot;spec&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;spec_files&quot;&lt;/span&gt;: [&lt;br/&gt;    &lt;span&gt;&quot;**/*[sS]pec.js&quot;&lt;/span&gt;&lt;br/&gt;  ],&lt;br/&gt;  &lt;span&gt;&quot;helpers&quot;&lt;/span&gt;: [&lt;br/&gt;    &lt;span&gt;&quot;helpers/**/*.js&quot;&lt;/span&gt;&lt;br/&gt;  ],&lt;br/&gt;  &lt;span&gt;&quot;stopSpecOnExpectationFailure&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;random&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果希望加载一些全局的配置可以在 &lt;code&gt;spec/helpers&lt;/code&gt; 目录中放一些&lt;code&gt;js&lt;/code&gt;文件, 正如配置所言，jasmine 在启动时会去执行 &lt;code&gt;spec/helpers&lt;/code&gt; 目录下的所有&lt;code&gt;js&lt;/code&gt;文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们常常使用 &lt;code&gt;es6&lt;/code&gt;语法，就需要增加&lt;code&gt;es6&lt;/code&gt;的支持。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新增 &lt;code&gt;spec/helpers/babel.js&lt;/code&gt; 写入如下配置即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install @babel/register @babel/core @babel/preset-env --save-dev&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// spec/helpers/babel.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;babel-register&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// .babelrc&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;&quot;presets&quot;&lt;/span&gt;: [&lt;span&gt;&quot;@babel/preset-env&quot;&lt;/span&gt;]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和 &lt;code&gt;mocha&lt;/code&gt; 一样，如果需要 &lt;code&gt;TypeScript&lt;/code&gt; 的支持，可以使用如下配置&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install ts-node typescript --save-dev&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// spec/helpers/typescript.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;ts-node/register&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置文件中的 &lt;code&gt;spec_dir&lt;/code&gt;是 &lt;code&gt;jasmine&lt;/code&gt;约定的用例文件目录，&lt;code&gt;spec_files&lt;/code&gt;规定了用例文件格式为 &lt;code&gt;xxx.spec.js&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这份默认配置就可以按照要求写用例，例如&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// ./spec/index.spec.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { multiple } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;../index.js&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;describe(&lt;span&gt;&#x27;Multiple&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;    it (&lt;span&gt;&#x27;should be a function&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;        expect(multiple).toBeInstanceOf(&lt;span&gt;Function&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;&lt;br/&gt;    it (&lt;span&gt;&#x27;should 7 * 2 = 14&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;        expect(multiple(&lt;span&gt;7&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;)).toEqual(&lt;span&gt;14&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;&lt;br/&gt;    it (&lt;span&gt;&#x27;should 7 * -2 = -14&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;        expect(multiple(&lt;span&gt;7&lt;/span&gt;, &lt;span&gt;-2&lt;/span&gt;)).toEqual(&lt;span&gt;-14&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;jasmine&lt;/code&gt; 的断言风格和 &lt;code&gt;chai&lt;/code&gt; 很不一样，&lt;code&gt;jasmine&lt;/code&gt; 的 &lt;code&gt;API&lt;/code&gt; 如下，与 &lt;code&gt;chai&lt;/code&gt; 相比少写了很多 &lt;code&gt;.&lt;/code&gt; ，而且支持的功能更加清晰，不用考虑如何组合使用的问题，而且下文介绍的 &lt;code&gt;jest&lt;/code&gt; 测试框架也是使用这种风格。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;nothing()&lt;br/&gt;toBe(expected)&lt;br/&gt;toBeCloseTo(expected, precisionopt)&lt;br/&gt;toBeDefined()&lt;br/&gt;toBeFalse()&lt;br/&gt;toBeFalsy()&lt;br/&gt;toBeGreaterThan(expected)&lt;br/&gt;toBeGreaterThanOrEqual(expected)&lt;br/&gt;toBeInstanceOf(expected)&lt;br/&gt;toBeLessThan(expected)&lt;br/&gt;toBeLessThanOrEqual(expected)&lt;br/&gt;toBeNaN()&lt;br/&gt;toBeNegativeInfinity()&lt;br/&gt;toBeNull()&lt;br/&gt;toBePositiveInfinity()&lt;br/&gt;toBeTrue()&lt;br/&gt;toBeTruthy()&lt;br/&gt;toBeUndefined()&lt;br/&gt;toContain(expected)&lt;br/&gt;toEqual(expected)&lt;br/&gt;toHaveBeenCalled()&lt;br/&gt;toHaveBeenCalledBefore(expected)&lt;br/&gt;toHaveBeenCalledOnceWith()&lt;br/&gt;toHaveBeenCalledTimes(expected)&lt;br/&gt;toHaveBeenCalledWith()&lt;br/&gt;toHaveClass(expected)&lt;br/&gt;toHaveSize(expected)&lt;br/&gt;toMatch(expected)&lt;br/&gt;toThrow(expectedopt)&lt;br/&gt;toThrowError(expectedopt, messageopt)&lt;br/&gt;toThrowMatching(predicate)&lt;br/&gt;withContext(message) → {matchers}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行 &lt;code&gt;jasmine&lt;/code&gt; 即可生成测试报告&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.42237061769616024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQhZYTauMbrpamMgft7MXkV3gxrWQNlATNfvnYuvHyR2WN5w2g7iabfYQqH4N5jDTxXVj9KPBM6C7Sw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1797&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认的测试报告不是很直观， 如果希望提供类似 &lt;code&gt;Mocha&lt;/code&gt; 风格的报告可以安装 &lt;code&gt;jasmine-spec-reporter&lt;/code&gt; ，在 &lt;code&gt;spec/helpers&lt;/code&gt; 目录中添加一个配置文件， 例如&lt;code&gt;spec/helpers/reporter.js&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; SpecReporter = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;jasmine-spec-reporter&#x27;&lt;/span&gt;).SpecReporter;&lt;br/&gt;&lt;br/&gt;jasmine.getEnv().clearReporters();               &lt;span&gt;// remove default reporter logs&lt;/span&gt;&lt;br/&gt;jasmine.getEnv().addReporter(&lt;span&gt;new&lt;/span&gt; SpecReporter({  &lt;span&gt;// add jasmine-spec-reporter&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;spec&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;displayPending&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时输出的用例报告如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4301449275362319&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQhZYTauMbrpamMgft7MXkV3L8pgxRCsT5mqTC0nem85ZLQJdMkpljW87RSNADvkKJAPmtsVB61OYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1725&quot;/&gt;&lt;figcaption&gt;jasmine&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在 &lt;code&gt;Jasmine&lt;/code&gt; 中执行 DOM 级别的测试，就依然需要借助 &lt;code&gt;Karma&lt;/code&gt; 或 &lt;code&gt;JSDOM&lt;/code&gt;了，具体的配置这里就不再赘述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结下 &lt;code&gt;Jasmine&lt;/code&gt; 的工具链&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Node 环境下测试 : &lt;code&gt;Jasmine&lt;/code&gt; + &lt;code&gt;babel&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模拟 &lt;code&gt;JSDOM&lt;/code&gt; 测试 : &lt;code&gt;Jasmine&lt;/code&gt; + &lt;code&gt;JSDOM&lt;/code&gt; + &lt;code&gt;babel&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;真实浏览器测试 : &lt;code&gt;Karma&lt;/code&gt; + &lt;code&gt;Jasmine&lt;/code&gt; + &lt;code&gt;webpack&lt;/code&gt; + &lt;code&gt;babel&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;JEST&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34531081566654687&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQhZYTauMbrpamMgft7MXkV3fZJgdFmaPhvibH7ejVRGttjF1iaHyL9S4m8fGziazKNsXpquVune7cXtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2783&quot;/&gt;&lt;figcaption&gt;jest&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Jest&lt;/code&gt; 是 &lt;code&gt;facebook&lt;/code&gt; 出的一个完整的单元测试技术方案，集 测试框架, 断言库, 启动器, 快照，沙箱，mock工具于一身，也是 &lt;code&gt;React&lt;/code&gt; 官方使用的测试工具。&lt;code&gt;Jest&lt;/code&gt; 和 &lt;code&gt;Jasmine&lt;/code&gt; 具有非常相似的 &lt;code&gt;API&lt;/code&gt; ，所以在 &lt;code&gt;Jasmine&lt;/code&gt; 中用到的工具在 &lt;code&gt;Jest&lt;/code&gt; 中依然可以很自然地使用。可以近似看作 &lt;code&gt;Jest = JSDOM 启动器 + Jasmine&lt;/code&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然 Jest 提供了很丰富的功能，但是并没有内置 &lt;code&gt;ES6&lt;/code&gt; 支持，所以依然需要根据不同运行时对代码进行转换，由于 Jest 主要运行在 &lt;code&gt;Node&lt;/code&gt; 中，所以需要使用 &lt;code&gt;babel-jest&lt;/code&gt; 将 &lt;code&gt;ES Module&lt;/code&gt; 转换成 &lt;code&gt;CommonJS&lt;/code&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Jest 的默认配置&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install jest --save-dev&lt;br/&gt;npx jest --init&lt;br/&gt;√ Would you like to use Jest when running &quot;test&quot; script in &quot;package.json&quot;? ... yes&lt;br/&gt;√ Would you like to use Typescript for the configuration file? ... no&lt;br/&gt;√ Choose the test environment that will be used for testing » jsdom (browser-like)&lt;br/&gt;√ Do you want Jest to add coverage reports? ... no&lt;br/&gt;√ Which provider should be used to instrument code for coverage? » babel&lt;br/&gt;√ Automatically clear mock calls and instances between every test? ... yes&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;Node&lt;/code&gt; 或 &lt;code&gt;JSDOM&lt;/code&gt; 下增加 &lt;code&gt;ES6&lt;/code&gt;代码的支持&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install jest-babel @babel/core @babel/preset-env&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// .babelrc&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;&quot;presets&quot;&lt;/span&gt;: [&lt;span&gt;&quot;@babel/preset-env&quot;&lt;/span&gt;]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// jest.config.js&lt;br/&gt;// 下面两行为默认配置，不写也可以&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;+    testEnvironment: &quot;jsdom&quot;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+    transform: {&quot;\\.[jt]sx?$&quot;: &quot;babel-jest&quot;}&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;Jest&lt;/code&gt; 生成测试报告&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3801732435033686&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQhZYTauMbrpamMgft7MXkV3LsShvuKbtgy8UeUlu5wrNhIYhiaoqjNFyqLpFnAOxNS7pfoEPqjvBGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1039&quot;/&gt;&lt;figcaption&gt;jest&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 &lt;code&gt;React&lt;/code&gt; 和 &lt;code&gt;TypeScript&lt;/code&gt; 支持也可以通过修改 &lt;code&gt;babel&lt;/code&gt; 的配置解决&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install @babel/preset-react @babel/preset-typescript --save-dev&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// .babrlrc&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;&quot;presets&quot;&lt;/span&gt;: [&lt;span&gt;&quot;@babel/preset-env&quot;&lt;/span&gt;, &lt;span&gt;&quot;@babel/preset-react&quot;&lt;/span&gt;, &lt;span&gt;&quot;@babel/preset-typescript&quot;&lt;/span&gt;]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Jest 在真实浏览器环境下测试&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前 &lt;code&gt;Jest&lt;/code&gt; 不支持直接在真实浏览器中进行测试，其默认的启动器只提供了一个 &lt;code&gt;JSDOM&lt;/code&gt; 环境，在浏览器中进行单元测试目前只有 &lt;code&gt;Karma&lt;/code&gt; 方案能做到，所以也可以使用 &lt;code&gt;Karma&lt;/code&gt; + &lt;code&gt;Jest&lt;/code&gt; 方案实现，但是不建议这么做，因为 &lt;code&gt;Jest&lt;/code&gt; 自身太重，使用 &lt;code&gt;Karma&lt;/code&gt; + &lt;code&gt;Jasmine&lt;/code&gt; 能达到基本一样的效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外还有一个比较流行的 &lt;code&gt;E2E&lt;/code&gt; 方案 &lt;code&gt;Jest&lt;/code&gt; + &lt;code&gt;Puppeteer&lt;/code&gt; ,  由于 &lt;code&gt;E2E&lt;/code&gt;  不属于单元测试范畴，这里不再展开。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Jest&lt;/code&gt; 工具链总结&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Node 环境下测试 : &lt;code&gt;Jest&lt;/code&gt; + &lt;code&gt;babel&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;JSDOM&lt;/code&gt; 测试 : &lt;code&gt;Jest&lt;/code&gt; + &lt;code&gt;babel&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;真实浏览器测试(不推荐)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;E2E&lt;/code&gt; 测试 : &lt;code&gt;Jest&lt;/code&gt; + &lt;code&gt;Puppeteer&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;稍作总结&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的内容介绍了 &lt;code&gt;chai&lt;/code&gt; ,  &lt;code&gt;mocha&lt;/code&gt; , &lt;code&gt;karma&lt;/code&gt; , &lt;code&gt;jasmine&lt;/code&gt; 和 &lt;code&gt;jest&lt;/code&gt;, 每种工具分别对应一些自己特有的工具链，在选取合适的测试工具时根据实际需要选择， 测试领域还有非常多的工具数都数不过来，下面来看下 React 单元测试的一些方法。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;使用 Jest + Enzyme 对 React 进行单元测试&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3540462427745665&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQhZYTauMbrpamMgft7MXkV3ket1vuUibYIeNFwL6PXxINjOW2ZT01c5C3u1jSFiciccIh3j2tqFfADaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2768&quot;/&gt;&lt;figcaption&gt;enzyme&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Enzyme&lt;/code&gt;基础配置如下:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install enzyme enzyme-adapter-react-16 jest-enzyme jest-environment-enzyme jest-canvas-mock react@16 react-dom@16 --save-dev&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// jest.config.js&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;- &quot;testEnvironment&quot;: &quot;jsdom&quot;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+  setupFilesAfterEnv: [&quot;jest-enzyme&quot;, &quot;jest-canvas-mock&quot;],&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+  testEnvironment: &quot;enzyme&quot;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+  testEnvironmentOptions: {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+    &quot;enzymeAdapter&quot;: &quot;react16&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+  },&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;jest-canvas-mock&lt;/code&gt; 这个包是为了解决一些使用 &lt;code&gt;JSDOM&lt;/code&gt; 未实现行为触发警告的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面建立了一个使用 &lt;code&gt;Enzyme&lt;/code&gt; 比较友好的环境，可以直接在全局作用域里引用 &lt;code&gt;React&lt;/code&gt; , &lt;code&gt;shallow&lt;/code&gt;, &lt;code&gt;mount&lt;/code&gt; 等 &lt;code&gt;API&lt;/code&gt;。此外 &lt;code&gt;Enzyme&lt;/code&gt; 还注册了许多友好的断言函数到 &lt;code&gt;Jest&lt;/code&gt; 中，如下所示，&lt;span&gt;参考地址&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;toBeChecked()&lt;br/&gt;toBeDisabled()&lt;br/&gt;toBeEmptyRender()&lt;br/&gt;toExist()&lt;br/&gt;toContainMatchingElement()&lt;br/&gt;toContainMatchingElements()&lt;br/&gt;toContainExactlyOneMatchingElement()&lt;br/&gt;toContainReact()&lt;br/&gt;toHaveClassName()&lt;br/&gt;toHaveDisplayName()&lt;br/&gt;toHaveHTML()&lt;br/&gt;toHaveProp()&lt;br/&gt;toHaveRef()&lt;br/&gt;toHaveState()&lt;br/&gt;toHaveStyle()&lt;br/&gt;toHaveTagName()&lt;br/&gt;toHaveText()&lt;br/&gt;toIncludeText()&lt;br/&gt;toHaveValue()&lt;br/&gt;toMatchElement()&lt;br/&gt;toMatchSelector()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// js/ClassComponent.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; React &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ClassComponent&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;React&lt;/span&gt;.&lt;span&gt;PureComponent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;constructor&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;();&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.state = { &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;classcomponent&#x27;&lt;/span&gt; };&lt;br/&gt;    }&lt;br/&gt;    render() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;            &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                a simple class component&lt;br/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;CustomComponent&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;        );&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// test/hook.test.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; HookComponent &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;../js/HookComponent&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;describe(&lt;span&gt;&#x27;HookComponent&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;    it (&lt;span&gt;&#x27;test with shallow&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; wrapper = shallow(&lt;span&gt;&amp;lt;&lt;span&gt;HookComponent&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;{1}&lt;/span&gt; /&amp;gt;&lt;/span&gt;);&lt;br/&gt;        expect(wrapper).toHaveState(&lt;span&gt;&#x27;name&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;classcomponent&#x27;&lt;/span&gt;);&lt;br/&gt;        expect(wrapper).toIncludeText(&lt;span&gt;&#x27;a simple class component&#x27;&lt;/span&gt;);&lt;br/&gt;        expect(wrapper).toContainReact(&lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;a simple class component&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;);&lt;br/&gt;        expect(wrapper).toContainMatchingElement(&lt;span&gt;&#x27;CustomComponent&#x27;&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Enzyme&lt;/code&gt; 提供了三种渲染组件方法&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;shallow&lt;/code&gt; 使用 &lt;code&gt;react-test-renderer&lt;/code&gt; 将组件渲染成内存中的对象, 可以方便进行 &lt;code&gt;props&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt; 等数据方面的测试，对应的操作对象为 &lt;code&gt;ShallowWrapper&lt;/code&gt;，在这种模式下仅能感知到第一层自定义子组件，对于自定义子组件内部结构则无法感知。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;mount&lt;/code&gt; 使用 &lt;code&gt;react-dom&lt;/code&gt; 渲染组件，会创建真实 &lt;code&gt;DOM&lt;/code&gt; 节点，比 &lt;code&gt;shallow&lt;/code&gt; 相比增加了可以使用原生 &lt;code&gt;API&lt;/code&gt; 操作 &lt;code&gt;DOM&lt;/code&gt; 的能力，对应的操作对象为 &lt;code&gt;ReactWrapper&lt;/code&gt;，这种模式下感知到的是一个完整的 &lt;code&gt;DOM&lt;/code&gt; 树。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;render&lt;/code&gt; 使用 &lt;code&gt;react-dom-server&lt;/code&gt; 渲染成 &lt;code&gt;html&lt;/code&gt; 字符串，基于这份静态文档进行操作，对应的操作对象为 &lt;code&gt;CheerioWrapper&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Shallow 渲染&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 &lt;code&gt;shallow&lt;/code&gt; 模式仅能感知到第一层自定义子组件组件，往往只能用于简单组件测试。例如下面的组件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// js/avatar.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Image&lt;/span&gt;(&lt;span&gt;{ src }&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;span&gt;img&lt;/span&gt; &lt;span&gt;src&lt;/span&gt;=&lt;span&gt;{src}&lt;/span&gt; /&amp;gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Living&lt;/span&gt;(&lt;span&gt;{ children }&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;icon-living&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt; { children } &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Avatar&lt;/span&gt;(&lt;span&gt;{ user, onClick }&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; { living, avatarUrl } = user;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;container&quot;&lt;/span&gt; &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{onClick}&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;wrapper&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;&amp;lt;&lt;span&gt;Living&lt;/span&gt; &amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;text&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt; 直播中 &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;&amp;lt;/&lt;span&gt;Living&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;Image&lt;/span&gt; &lt;span&gt;src&lt;/span&gt;=&lt;span&gt;{avatarUrl}&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    )&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; Avatar;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;shallow&lt;/code&gt; 渲染虽然不是真正的渲染，但是其组件生命周期会完整地走一遍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;shallow(&amp;lt;Avatar /&amp;gt;)&lt;/code&gt; 能感知到的结构如下, 注意看到 &lt;code&gt;div.text&lt;/code&gt; 作为 &lt;code&gt;Living&lt;/code&gt; 组件的 &lt;code&gt;children&lt;/code&gt; 能够被检测到，但是 &lt;code&gt;Living&lt;/code&gt; 的内部结构无法感知。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6296918767507003&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQhZYTauMbrpamMgft7MXkV3KLRcF118L4bsfrB22vO6nAr9F2YFziay1ldgEH4JGkwYWjTIWTAUfqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1785&quot;/&gt;&lt;figcaption&gt;shallow&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Enzyme&lt;/code&gt; 支持的选择器支持我们熟悉的 &lt;code&gt;css selector&lt;/code&gt; 语法，这种情况下我们可以对 &lt;code&gt;DOM&lt;/code&gt; 结构做如下测试&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// test/avatar.test.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Avatar &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;../js/avatar&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;describe(&lt;span&gt;&#x27;Avatar&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; wrapper = &lt;span&gt;null&lt;/span&gt;, avatarUrl = &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    beforeEach(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        wrapper = shallow(&lt;span&gt;&amp;lt;&lt;span&gt;Avatar&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;=&lt;span&gt;{{&lt;/span&gt; avatarUrl: avatarUrl }} /&amp;gt;&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;&lt;br/&gt;    afterEach(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        wrapper.unmount();&lt;br/&gt;        jest.clearAllMocks();&lt;br/&gt;    })&lt;br/&gt;&lt;br/&gt;    it (&lt;span&gt;&#x27;should render success&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;        &lt;span&gt;// wrapper 渲染不为空&lt;/span&gt;&lt;br/&gt;        expect(wrapper).not.toBeEmptyRender();&lt;br/&gt;        &lt;span&gt;// Image 组件渲染不为空, 这里会执行 Image 组件的渲染函数&lt;/span&gt;&lt;br/&gt;        expect(wrapper.find(&lt;span&gt;&#x27;Image&#x27;&lt;/span&gt;)).not.toBeEmptyRender();&lt;br/&gt;        &lt;span&gt;// 包含一个节点&lt;/span&gt;&lt;br/&gt;        expect(wrapper).toContainMatchingElement(&lt;span&gt;&#x27;div.container&#x27;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 包含一个自定义组件&lt;/span&gt;&lt;br/&gt;        expect(wrapper).toContainMatchingElement(&lt;span&gt;&quot;Image&quot;&lt;/span&gt;);&lt;br/&gt;        expect(wrapper).toContainMatchingElement(&lt;span&gt;&#x27;Living&#x27;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// shallow 渲染不包含子组件的内部结构&lt;/span&gt;&lt;br/&gt;        expect(wrapper).not.toContainMatchingElement(&lt;span&gt;&#x27;img&#x27;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// shallow 渲染包含 children 节点&lt;/span&gt;&lt;br/&gt;        expect(wrapper).toContainMatchingElement(&lt;span&gt;&#x27;div.text&#x27;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// shallow 渲染可以对 children 节点内部结构做测试&lt;/span&gt;&lt;br/&gt;        expect(wrapper.find(&lt;span&gt;&#x27;div.text&#x27;&lt;/span&gt;)).toIncludeText(&lt;span&gt;&#x27;直播中&#x27;&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们想去测试对应组件的 &lt;code&gt;props&lt;/code&gt; / &lt;code&gt;state&lt;/code&gt; 也可以很方便测试，不过目前存在缺陷，&lt;code&gt;Class Component&lt;/code&gt; 能通过 &lt;code&gt;toHaveProp&lt;/code&gt;, &lt;code&gt;toHaveState&lt;/code&gt; 直接测试， 但是 &lt;code&gt;Hook&lt;/code&gt; 组件无法测试 &lt;code&gt;useState&lt;/code&gt; 。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;it (&lt;span&gt;&#x27;Image component receive props&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; imageWrapper = wrapper.find(&lt;span&gt;&#x27;Image&#x27;&lt;/span&gt;);、&lt;br/&gt;  &lt;span&gt;// 对于 Hook 组件目前我们只能测试 props&lt;/span&gt;&lt;br/&gt;  expect(imageWrapper).toHaveProp(&lt;span&gt;&#x27;src&#x27;&lt;/span&gt;, avatarUrl);&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;wrapper.find&lt;/code&gt; 虽然会返回同样的一个 &lt;code&gt;ShallowWrapper&lt;/code&gt; 对象，但是这个对象的子结构是未展开的，如果想测试&lt;code&gt;imageWrapper&lt;/code&gt; 内部结构，需要再 &lt;code&gt;shallow render&lt;/code&gt; 一次。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;it (&lt;span&gt;&#x27;Image momponent receive props&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; imageWrapper = wrapper.find(&lt;span&gt;&#x27;Image&#x27;&lt;/span&gt;).shallow();&lt;br/&gt;&lt;br/&gt;  expect(imageWrapper).toHaveProp(&lt;span&gt;&#x27;src&#x27;&lt;/span&gt;, avatarUrl);&lt;br/&gt;  expect(imageWrapper).toContainMatchingElement(&lt;span&gt;&#x27;img&#x27;&lt;/span&gt;);&lt;br/&gt;  expect(imageWrapper.find(&lt;span&gt;&#x27;img&#x27;&lt;/span&gt;)).toHaveProp(&lt;span&gt;&#x27;src&#x27;&lt;/span&gt;, avatarUrl);&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以改变组件的 &lt;code&gt;props&lt;/code&gt;, 触发组件重绘&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;it (&lt;span&gt;&#x27;should rerender when user change&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; newAvatarUrl = &lt;span&gt;&#x27;&#x27;&lt;/span&gt; + &lt;span&gt;Math&lt;/span&gt;.random();&lt;br/&gt;    wrapper.setProps({ &lt;span&gt;user&lt;/span&gt;: { &lt;span&gt;avatarUrl&lt;/span&gt;: newAvatarUrl }});&lt;br/&gt;    wrapper.update();&lt;br/&gt;    expect(wrapper.find(&lt;span&gt;&#x27;Image&#x27;&lt;/span&gt;)).toHaveProp(&lt;span&gt;&#x27;src&#x27;&lt;/span&gt;, newAvatarUrl);&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一个常见的场景是事件模拟，事件比较接近真实测试场景，这种场景下使用 &lt;code&gt;shallow&lt;/code&gt; 存在诸多缺陷，因为 &lt;code&gt;shallow&lt;/code&gt; 场景事件不会像真实事件一样有捕获和冒泡流程，所以此时只能简单的触发对应的 &lt;code&gt;callback&lt;/code&gt; 达到测试目的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;it (&lt;span&gt;&#x27;will call onClick prop when click event fired&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; fn = jest.fn();&lt;br/&gt;&lt;br/&gt;    wrapper.setProps({ &lt;span&gt;onClick&lt;/span&gt;: fn });&lt;br/&gt;    wrapper.update();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 这里触发了两次点击事件，但是 onClick 只会被调用一次。&lt;/span&gt;&lt;br/&gt;    wrapper.find(&lt;span&gt;&#x27;div.container&#x27;&lt;/span&gt;).simulate(&lt;span&gt;&#x27;click&#x27;&lt;/span&gt;);&lt;br/&gt;    wrapper.find(&lt;span&gt;&#x27;div.wrapper&#x27;&lt;/span&gt;).simulate(&lt;span&gt;&#x27;click&#x27;&lt;/span&gt;);&lt;br/&gt;    expect(fn).toHaveBeenCalledTimes(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于这些网上有人总结了 &lt;code&gt;shallow&lt;/code&gt; 模式下的一些不足&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;shallow&lt;/code&gt; 渲染不会进行事件冒泡，而 &lt;code&gt;mount&lt;/code&gt; 会。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;shallow&lt;/code&gt; 渲染因为不会创建真实 &lt;code&gt;DOM&lt;/code&gt;，所以组件中使用 &lt;code&gt;refs&lt;/code&gt; 的地方都无法正常获取，如果确实需要使用 &lt;code&gt;refs&lt;/code&gt; , 则必须使用 &lt;code&gt;mount&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;simulate&lt;/code&gt;  在 &lt;code&gt;mount&lt;/code&gt; 中会更加有用，因为它会进行事件冒泡。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实上面几点说明了一个现象是 &lt;code&gt;shallow&lt;/code&gt; 往往只适合一种理想的场景，一些依赖浏览器行为表现的操作 &lt;code&gt;shallow&lt;/code&gt; 无法满足，这些和真实环境相关的就只能使用&lt;code&gt;mount&lt;/code&gt;了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Mount 渲染&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Mount&lt;/code&gt; 渲染的对象结构为 &lt;code&gt;ReactWrapper&lt;/code&gt; 其提供了和 &lt;code&gt;ShallowWrapper&lt;/code&gt; 几乎一样的 &lt;code&gt;API&lt;/code&gt; , 差异很小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;API&lt;/code&gt;层面的一些差异如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;+ getDOMNode()        获取DOM节点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+ detach()            卸载React组件，相当于 unmountComponentAtNode&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+ mount()             挂载组件，unmount之后通过这个方法重新挂载&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+ ref(refName)        获取 class component 的 instance.refs 上的属性&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+ setProps(nextProps, callback)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;- setProps(nextProps)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;- shallow()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;- dive()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;- getElement()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;- getElements()&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外由于 &lt;code&gt;mount&lt;/code&gt; 使用 &lt;code&gt;ReactDOM&lt;/code&gt; 进行渲染，所以其更加接近真实场景，在这种模式下我们能观察到整个 &lt;code&gt;DOM&lt;/code&gt; 结构和React组件节点结构。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.643793369313801&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQhZYTauMbrpamMgft7MXkV3icJmwZuVmYaEPMXjricYNfemwZrfAHwZpPlczepjhAEBC71svE0lK4icA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1297&quot;/&gt;&lt;figcaption&gt;mount&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;describe(&lt;span&gt;&#x27;Mount Avatar&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; wrapper = &lt;span&gt;null&lt;/span&gt;, avatarUrl = &lt;span&gt;&#x27;123&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    beforeEach(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        wrapper = mount(&lt;span&gt;&amp;lt;&lt;span&gt;Avatar&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;=&lt;span&gt;{{&lt;/span&gt; avatarUrl }} /&amp;gt;&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;&lt;br/&gt;    afterEach(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        jest.clearAllMocks();&lt;br/&gt;    })&lt;br/&gt;&lt;br/&gt;    it (&lt;span&gt;&#x27;should set img src with avatarurl&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;        expect(wrapper.find(&lt;span&gt;&#x27;Image&#x27;&lt;/span&gt;)).toExist();&lt;br/&gt;        expect(wrapper.find(&lt;span&gt;&#x27;Image&#x27;&lt;/span&gt;)).toHaveProp(&lt;span&gt;&#x27;src&#x27;&lt;/span&gt;, avatarUrl);&lt;br/&gt;        expect(wrapper.find(&lt;span&gt;&#x27;img&#x27;&lt;/span&gt;)).toHaveProp(&lt;span&gt;&#x27;src&#x27;&lt;/span&gt;, avatarUrl);&lt;br/&gt;    })&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;shallow&lt;/code&gt; 中无法模拟的事件触发问题在 &lt;code&gt;mount&lt;/code&gt; 下就不再是问题。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;it (&lt;span&gt;&#x27;will call onClick prop when click event fired&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; fn = jest.fn();&lt;br/&gt;&lt;br/&gt;    wrapper.setProps({ &lt;span&gt;onClick&lt;/span&gt;: fn });&lt;br/&gt;    wrapper.update();&lt;br/&gt;&lt;br/&gt;    wrapper.find(&lt;span&gt;&#x27;div.container&#x27;&lt;/span&gt;).simulate(&lt;span&gt;&#x27;click&#x27;&lt;/span&gt;);&lt;br/&gt;    wrapper.find(&lt;span&gt;&#x27;div.wrapper&#x27;&lt;/span&gt;).simulate(&lt;span&gt;&#x27;click&#x27;&lt;/span&gt;);&lt;br/&gt;    expect(fn).toHaveBeenCalledTimes(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结一下 &lt;code&gt;shallow&lt;/code&gt; 中能做的 &lt;code&gt;mount&lt;/code&gt; 都能做，&lt;code&gt;mount&lt;/code&gt;中能做的 &lt;code&gt;shallow&lt;/code&gt;不一定能做。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Render 渲染&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;render&lt;/code&gt; 内部使用 &lt;code&gt;react-dom-server&lt;/code&gt; 渲染成字符串，再经过 &lt;code&gt;Cherrio&lt;/code&gt; 转换成内存中的结构，返回 &lt;code&gt;CheerioWrapper&lt;/code&gt; 实例，能够完整地渲染整个&lt;code&gt;DOM&lt;/code&gt; 树，但是会将内部实例的状态丢失，所以也称为 &lt;code&gt;Static Rendering&lt;/code&gt; 。这种渲染能够进行的操作比较少，这里也不作具体介绍，可以参考 &lt;span&gt;官方文档&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt; 。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果让我推荐的话，对于真实浏览器我会推荐 &lt;code&gt;Karma&lt;/code&gt; + &lt;code&gt;Jasmine&lt;/code&gt; 方案测试，对于 &lt;code&gt;React&lt;/code&gt; 测试 &lt;code&gt;Jest&lt;/code&gt; + &lt;code&gt;Enzyme&lt;/code&gt; 在 &lt;code&gt;JSDOM&lt;/code&gt; 环境下已经能覆盖大部分场景。另外测试 &lt;code&gt;React&lt;/code&gt;组件除了 &lt;code&gt;Enzyme&lt;/code&gt; 提供的操作， &lt;code&gt;Jest&lt;/code&gt; 中还有很多其他有用的特性，比如可以 &lt;code&gt;mock&lt;/code&gt; 一个 &lt;code&gt;npm&lt;/code&gt; 组件的实现，调整 &lt;code&gt;setTimeout&lt;/code&gt; 时钟等，真正进行单元测试时，这些工具也是必不可少的，整个单元测试技术体系包含了很多东西，本文无法面面俱到，只介绍了一些距离我们最近的相关的技术体系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;https://medium.com/building-ibotta/understanding-chai-js-language-mechanics-cc28e4c9604b&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://medium.com/@turhan.oz/typescript-with-jasmine-easy-project-setup-530c7cc764e8&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://www.liuyiqi.cn/2015/10/12/karma-start/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://jestjs.io/docs/en&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://blog.bitsrc.io/how-to-test-react-components-with-jest-and-enzyme-in-depth-145fcd06b90&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://www.freecodecamp.org/news/testing-react-hooks/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://www.reddit.com/r/reactjs/comments/ajw2uv/jestenzyme_simulate_event_bubbling_onclick/&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本文发布自 &lt;span&gt;网易云音乐大前端团队&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt;，文章未经授权禁止任何形式的转载。我们常年招收前端、iOS、Android，如果你准备换工作，又恰好喜欢云音乐，那就加入我们 grp.music-fe(at)corp.netease.com！&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;江水: &lt;em&gt;https://www.zhihu.com/people/li-quan-wei-41&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;TDD: &lt;em&gt;https://en.wikipedia.org/wiki/Test-driven_development&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;BDD: &lt;em&gt;https://en.wikipedia.org/wiki/Behavior-driven_development&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;better-assert: &lt;em&gt;https://github.com/tj/better-assert&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;unexpected.js: &lt;em&gt;https://unexpected.js.org/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;AMD: &lt;em&gt;https://github.com/amdjs/amdjs-api/blob/master/AMD.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;规范 : &lt;em&gt;http://wiki.commonjs.org/wiki/Modules/1.1&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;参考地址: &lt;em&gt;https://github.com/enzymejs/enzyme-matchers/blob/master/packages/jest-enzyme/README.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;官方文档: &lt;em&gt;https://enzymejs.github.io/enzyme/docs/api/render.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10]&lt;/span&gt;&lt;p&gt;网易云音乐大前端团队: &lt;em&gt;https://github.com/x-orpheus&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c3b7f68d4f960e2e62eda7e34c530e74</guid>
<title>Android 系统推送 Hook 实战</title>
<link>https://toutiao.io/k/8g4pb8s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section id=&quot;toc-content&quot; class=&quot;post no-image&quot;&gt;
      &lt;h1 id=&quot;%E8%83%8C%E6%99%AF&quot;&gt;背景&lt;/h1&gt;&lt;p&gt;随着数据生产功能的逐渐稳定，工作重点开始从&lt;strong&gt;保证数据总量&lt;/strong&gt;转移到了&lt;strong&gt;保证数据实效性&lt;/strong&gt;上来了。传统的定时爬虫能比较轻松的把数据总量做起来，但是对于很多热点数据，却很难做到实时获取。&lt;/p&gt;&lt;p&gt;考虑到大部分产品、尤其是新闻资讯类的产品，都会对热点数据做推送拉活，如果能拦截到这些数据，那么我们就能应当将数据实效性提升一个档次。&lt;/p&gt;&lt;p&gt;这次我们就主要尝试拦截下小米手机的系统通道的推送数据。当然，对于各个 App 自身的通道，也可以用类似的方法做到拦截，不过那就需要对各个 App 再做好保活。&lt;/p&gt;&lt;h1 id=&quot;%E6%8E%A8%E9%80%81%E6%B5%81%E7%A8%8B&quot;&gt;推送流程&lt;/h1&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2021/06/image-33.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/figure&gt;&lt;p&gt;以小米官方的文档为例，整体推送流程大致分四步：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;应用客户端在启动时向 MiPush SDK 中注册当前设备，并获得对应的唯一标识 regId。&lt;/li&gt;&lt;li&gt;应用服务端告诉小米统一推送服务，他需要向某个指定账号、指定类型、或指定设备推送消息。&lt;/li&gt;&lt;li&gt;小米统一的服务端通过与手机上的 MiPush SDK 的长连接，向手机推送数据，并展示在通知栏中。&lt;/li&gt;&lt;li&gt;应用客户端实现一个自定义 PushMessageReceiver 做好数据解析的准备，等用户点击通知栏后就可以将数据传过去。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;牵涉到的大概有五方的代码：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;手机内部的MIUI框架部分代码。&lt;/li&gt;&lt;li&gt;应用客户端代码。&lt;/li&gt;&lt;li&gt;应用客户端引用的小米的 MiPush SDK代码。&lt;/li&gt;&lt;li&gt;小米 PushServer 的代码。&lt;/li&gt;&lt;li&gt;应用服务端的代码。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;在这里当中，我们其实只需要关心 1、3 两部分的代码即可。&lt;/p&gt;&lt;h1 id=&quot;%E8%8E%B7%E5%8F%96%E6%80%9D%E8%B7%AF&quot;&gt;获取思路&lt;/h1&gt;&lt;p&gt;简单翻阅了网络上已知的策略，获得通知栏的推送数据一般有如下思路：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;通过 Appium 等自动化测试工具，直接获取通知栏的元素中的消息文本。&lt;/li&gt;&lt;li&gt;自己写一个 App ，实现 NotificationListenerService 方法，监听所有过来的消息。&lt;/li&gt;&lt;li&gt;通过 Frida 等 hook 工具，直接拦截 MiPush 推过来的原始数据，自行做解析和解密。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;虽然我并没有做尝试，但是前两种方式似乎最多只能获得推送的标题和文本等基本信息，无法获得更详细的原始信息（尤其是跳转 scheme 、参数列表等）。因此我们主要尝试第三种思路。&lt;/p&gt;&lt;h1 id=&quot;%E5%8A%A8%E6%89%8B%E5%AE%9E%E8%B7%B5&quot;&gt;动手实践&lt;/h1&gt;&lt;p&gt;下面就以手头的 Redmi6 设备进行尝试。&lt;/p&gt;&lt;h2 id=&quot;%E5%AE%9A%E4%BD%8D%E5%BA%94%E7%94%A8&quot;&gt;定位应用&lt;/h2&gt;&lt;p&gt;既然我们希望获取通知栏的数据，那我们首先应当定位到通知栏的相关代码。拉出通知栏，dumpsys一下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ adb shell dumpsys activity top|grep ACTIVITY
ACTIVITY com.android.systemui/.recents.RecentsActivity c2efb6 pid=30467
ACTIVITY com.ss.android.ugc.aweme/.splash.SplashActivity f9d8beb pid=7270
ACTIVITY com.miui.home/.launcher.Launcher 119c6 pid=1950&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看起来 com.android.systemui 和 com.miui.home 这两个包比较可疑，我们再用 Appium check 一下。&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2021/06/image-34.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这样就肯定是 com.android.systemui 没跑了。&lt;/p&gt;&lt;h2 id=&quot;%E8%8E%B7%E5%8F%96%E4%BB%A3%E7%A0%81&quot;&gt;获取代码&lt;/h2&gt;&lt;p&gt;定位到包名，那就去手机上把包搞下来就行：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ adb shell pm list packages -f |grep com.android.systemui
package:/vendor/overlay/SysuiDarkTheme/SysuiDarkThemeOverlay.apk=com.android.systemui.theme.dark
package:/system/priv-app/MiuiSystemUI/MiuiSystemUI.apk=com.android.systemui
 
$ adb pull /system/priv-app/MiuiSystemUI/MiuiSystemUI.apk
/system/priv-app/MiuiSystemUI/MiuiSystemUI.apk: 1 file pulled, 0 skipped. 10.5 MB/s (4901017 bytes in 0.446s)
 
$ ls -la MiuiSystemUI.apk
-rw-r--r--  1 myths  staff  4901017 Jun 29 15:42 MiuiSystemUI.apk&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后拿 jadx 打开看看：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2021/06/image-35.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/figure&gt;&lt;p&gt;发现不对劲，怎么一行代码也没有，都是些没用的资源文件。。。在尝试了诸如 jeb、androidkiller、apktool等反编译软件均失败后，我陷入了沉思。&lt;/p&gt;&lt;p&gt;沉思过后，决定换一部更高级的 Redmi9 手机试试，结果发现 Redmi9 手机的 MiuiSystemUI.apk 竟然是有代码的，估计是 Redmi6 用了什么古老的科技把代码隐藏掉或者下沉了啥的，但是代码一定是有的，否则哪来的 &lt;code&gt;com.android.systemui/.recents.RecentsActivity&lt;/code&gt; 这个 activity。&lt;/p&gt;&lt;p&gt;于是我暴力 grep 了 /system 目录下的文件，果然给我找到了线索：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ adb shell su -c &quot;grep RecentsActivity -r /system&quot;
grep: /system/framework/miuisdk.jar: No such file or directory
grep: /system/framework/miuisystem.jar: No such file or directory
Binary file /system/framework/oat/arm/services.vdex matches
Binary file /system/priv-app/MiuiSystemUI/oat/arm/MiuiSystemUI.vdex matches&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;发现了一个奇怪的 &lt;code&gt;MiuiSystemUI.vdex&lt;/code&gt; 文件，简单查了下，应当是为了优化系统 &lt;a href=&quot;https://source.android.google.cn/devices/tech/ota?hl=zh-cn&quot;&gt;OTA&lt;/a&gt; 时 dex2oat 过程的类似预编译的东西，本质还是代码片段。&lt;/p&gt;&lt;p&gt;于是用 &lt;a href=&quot;https://github.com/anestisb/vdexExtractor&quot;&gt;vdexExtractor&lt;/a&gt; 转成 MiuiSystemUI.dex  :&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ ./vdexExtractor -i  ../../Jadx/MiuiSystemUI.vdex  -o output
[INFO] Processing 1 file(s) from ../../Jadx/MiuiSystemUI.vdex
[INFO] 1 out of 1 Vdex files have been processed
[INFO] 1 Dex files have been extracted in total
[INFO] Extracted Dex files are available in &#x27;output&#x27;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;再用 jadx 打开这个 MiuiSystemUI.dex ：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2021/06/image-36.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这下就舒服了。&lt;/p&gt;&lt;h2 id=&quot;%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84&quot;&gt;代码结构&lt;/h2&gt;&lt;p&gt;对源码经过简单阅读，再辅以 &lt;a href=&quot;https://github.com/sensepost/objection&quot;&gt;objection&lt;/a&gt; 和 frida 的 Java.choose() 方法动态调试后发现存储通知栏消息的地方主要是在 &lt;code&gt;com.android.systemui.statusbar.phone.NotificationGroupManager&lt;/code&gt; 。这个类在系统中似乎还是个单例。&lt;/p&gt;&lt;p&gt;找到这个类之后，四下观察就可以整理出大致如下的类图：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2021/06/image-37.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这里每个 NotificationData.Entry 就是每一条推送记录，不断深入看下去就会发现真正的数据还是指向了 StatusBarNotification 这个类。而这个类的源码只能去对应的 Android SDK 里去看了。&lt;/p&gt;&lt;p&gt;于是打开了对应版本（api 27）的SDK，继续整理了一下核心数据涉及到的类：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2021/06/image-38.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/figure&gt;&lt;h2 id=&quot;%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90&quot;&gt;数据解析&lt;/h2&gt;&lt;p&gt;跟踪上面涉及到的相关对象，根据所需要的数据做相关解析和拼接即可：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;Java.perform(function () {

    let MurmurHash3 = {
        mul32: function (m, n) {
            let nlo = n &amp;amp; 0xffff;
            let nhi = n - nlo;
            return ((nhi * m | 0) + (nlo * m | 0)) | 0;
        },
        hashString: function (data, len, seed) {
            let c1 = 0xcc9e2d51, c2 = 0x1b873593;

            let h1 = seed;
            let k1 = &#x27;&#x27;;
            let roundedEnd = len &amp;amp; ~0x1;

            for (let i = 0; i &amp;lt; roundedEnd; i += 2) {
                let k1 = data.charCodeAt(i) | (data.charCodeAt(i + 1) &amp;lt;&amp;lt; 16);

                k1 = this.mul32(k1, c1);
                k1 = ((k1 &amp;amp; 0x1ffff) &amp;lt;&amp;lt; 15) | (k1 &amp;gt;&amp;gt;&amp;gt; 17);
                k1 = this.mul32(k1, c2);

                h1 ^= k1;
                h1 = ((h1 &amp;amp; 0x7ffff) &amp;lt;&amp;lt; 13) | (h1 &amp;gt;&amp;gt;&amp;gt; 19);
                h1 = (h1 * 5 + 0xe6546b64) | 0;
            }

            if ((len % 2) === 1) {
                k1 = data.charCodeAt(roundedEnd);
                k1 = this.mul32(k1, c1);
                k1 = ((k1 &amp;amp; 0x1ffff) &amp;lt;&amp;lt; 15) | (k1 &amp;gt;&amp;gt;&amp;gt; 17);
                k1 = this.mul32(k1, c2);
                h1 ^= k1;
            }

            h1 ^= (len &amp;lt;&amp;lt; 1);

            h1 ^= h1 &amp;gt;&amp;gt;&amp;gt; 16;
            h1 = this.mul32(h1, 0x85ebca6b);
            h1 ^= h1 &amp;gt;&amp;gt;&amp;gt; 13;
            h1 = this.mul32(h1, 0xc2b2ae35);
            h1 ^= h1 &amp;gt;&amp;gt;&amp;gt; 16;

            return h1;
        }
    };

    let NotificationGroup = Java.use(&#x27;com.android.systemui.statusbar.phone.NotificationGroupManager$NotificationGroup&#x27;)
    let Entry = Java.use(&#x27;com.android.systemui.statusbar.NotificationData$Entry&#x27;)
    let Base64 = Java.use(&#x27;android.util.Base64&#x27;);

    function processInfo(statusbar, folded) {
        let mmap = statusbar.notification.value.extras.value.mMap.value;

        if (statusbar.notification.value.contentIntent.value) {
            let intent = statusbar.notification.value.contentIntent.value.getIntent();
            if (intent.mComponent.value) {
                let txt = mmap.get(&quot;android.text&quot;).toString()
                let id = MurmurHash3.hashString(txt, txt.length, 0).toString().replace(&quot;-&quot;, &quot;&quot;)
                let msg = {
                    &#x27;type&#x27;: &#x27;mi_push&#x27;,
                    &#x27;data&#x27;: {
                        &quot;folded&quot;: folded,
                        &quot;id&quot;: id,
                        &quot;intent&quot;: intent.getDataString() === null ? &quot;&quot; : intent.getDataString(),
                        &quot;title&quot;: mmap.get(&quot;android.title&quot;).toString(),
                        &quot;text&quot;: mmap.get(&quot;android.text&quot;).toString(),
                        &quot;package&quot;: intent.mComponent.value.mPackage.value,
                        &quot;class&quot;: intent.mComponent.value.mClass.value,
                        &quot;time&quot;: statusbar.postTime.value
                    },
                    &#x27;id&#x27;: id
                };
                let bundle = intent.getExtras()
                if (bundle) {
                    let miPushByte = bundle.get(&quot;mipush_payload&quot;)
                    if (miPushByte) {
                        let arr = Java.array(&#x27;byte&#x27;, miPushByte)
                        msg[&#x27;data&#x27;][&#x27;mipush&#x27;] = Base64.encodeToString(arr, 0).replaceAll(&quot;\n&quot;, &quot;&quot;);
                    }

                }
                send(JSON.stringify(msg));
            } else {
                console.log(&quot;contentIntent is null &quot; + mmap)
            }
        } else {
            console.log(&quot;intent.mComponent.value not exist &quot; + mmap)
        }
    }


    function processManager(manager) {
        try {
            let entrys = manager.mGroupMap.value.keySet()
            let it = entrys.iterator();
            while (it.hasNext()) {
                let key = it.next();
                let data = manager.mGroupMap.value.get(key)
                let nData = Java.cast(data, NotificationGroup)
                let unfoldIterator = nData.unfoldChildren.value.iterator()
                let foldIterator = nData.foldChildren.value.iterator()

                while (unfoldIterator.hasNext()) {
                    let entry = Java.cast(unfoldIterator.next(), Entry);
                    let row = entry.row.value
                    let statusbar = row.mExpandedNotification.value
                    processInfo(statusbar, false)

                }
                while (foldIterator.hasNext()) {
                    let entry = Java.cast(foldIterator.next(), Entry);
                    let row = entry.row.value
                    let statusbar = row.mExpandedNotification.value
                    processInfo(statusbar, true)
                }
            }
        } catch (e) {
            console.log(e.stack)
        }
    }
    Java.choose(&quot;com.android.systemui.statusbar.phone.NotificationGroupManager&quot;, {
        onMatch: function (instance) {
            processManager(instance)
        },
        onComplete: function () {
        }
    });
});&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;需要注意的是，这里的代码和 Android 版本、MIUI 版本都有关，不同种的设备之间大概率是不能兼容的。在我的手机上，这样解析出来数据如下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
    &quot;package&quot;: &quot;com.smile.gifmaker&quot;,
    &quot;mipush&quot;: &quot;CAABAAAABQIAAgECAAMACwAEAAAEsOp4pGZjhmJnTz3lGB/Ta7aS5iS5UIKGF23UT2AvpzdmIbLJu0h9JH799FoT7VEdFq9vzPWuiLybhqJ2tcBm5tHXJ5Ff/eSje9jFUm799PQKg7uQEE3ieH/Bu5nglvYwk0+ku7bWfp3MjB8ukRrr5XgIUqLSVEyi4wICeBkHSWwVzIcfk63TH6z8r9wemQq8fZFPqq817rR4zED6MUQu83frrtYY/4i6kSazw2zKkhoR+T0j7/7ed4r/si3RwUBCsO9d73Ehdmrjg7odKxHP9q6yUFam4JihZYN2DzG3KsajgwZg+CmXCOQFanmpyYgKhUc+psE1Kl5bikWY9KqLYo1JD/Boesq4d82Yfub61xGoWaeli/SJwG8JMtsH5FmC7mxDwluhutoDEuRlX3HodtU1GlEaz2SBabRIOcFLYv6SjOrBN1o2xE+lvpHv1o0Reh4GG0mlnmrV7a236XHwMmSOdY4Akr4WR3eQz+NTNaqLwUjvQIb1GwWXauNWMAM4nroK38KAfBORVDLAZSoMLambNM+JsBZKRcmIPreuupVaYlS2hnlEr2qaGsfpPZK8bJs7PgXU6zscMBmVMjy/nL6D5+uUwVEkYbzoPdMCbsHPxxKcFeiR/AYJe7G1QK5KQMTtVY/jnJVRNG8T3H5fC52CO4xOFKRrpdNv30C/NvtBOIokBCqXXXf2Z4gWroq17Tc385/WhxhvcvazXoI8rjaF/ZHh7KGUN24VuN07tnjKvs74h3Z1JJi82WRuzxkSsFDQJNwIX3/Qk6U5mgHGwZJTtdB8IijTUn5GZG6C/c8CNYN36iy7ToIDCiNbIWO40GwDrmIHiaK3R6a0de6jCr917C1AfT1JFlNr9GeztWq/4tLH3F88SGWIhj00XFWcBWVa2EB7Du3yjFD0S18/HoCIi5j5l/HsvvMo0BpdWd0hTRQ89NUK409QiblaVjJ8vCtz3PrNLAiCROJPzA5GcD5x6F7xUi05YsBE+xX59kqf7Wzrs6IXb9frgllwWkS2aKcHNmZYT6TTE6QNII4rYOHlLhIB6bIq6iktbMY63TRAQi8a/1sBPuoMJ3tndbBZmumsV+emgbY5p4xv7YnA9AYK001Q+o2CfyfUjCRlhWAGZ5ZOe0Z/o6jSQegq39ib3KbPyE6ZxjEtNYMt/pLdIKyh86ixiv0rRqI2meLilcekGrFKmI46JK8YbYuVzYr5VIJdDEnvawnxjmw5qYVo6AE/uppaX5p8t+sBAaofqbYmpW6dIFEBR5vmE/ahZZolCgD1dwxNFAkTZf8hoBfG9/cZI3zaqEOfTghxw9FkVyauJwY4Qe5E4VuQxZfHEy4HVKhhIi4zkRLDpPJBUiovGZFaLMR3s2EnHppq2xrnA12FVeBuUjDJQpRER+E8DFErvk8MfjT4CoL05djf5BWPHfCdCvnGFg49Up1LbidPpycnlnTr4f/Nu87Ed0FmL6/81knkj3rT2fPdINpweHWZok9o55lHojNHANHae64FBQrwC/057zoKI3Oo5GBU85qcnCxvGKpzDZbVVF9Y/HQIR4DGVdIC91i6EiYGYdD1VsQVDwRu6P77ixubXjV+eq56KQsABQAAABMyODgyMzAzNzYxNTE3MTMwNTM0CwAGAAAAEmNvbS5zbWlsZS5naWZtYWtlcgwABwoAAQAAAAAAAAAFCwACAAAACzcwMDg0ODc2NDA2CwADAAAACnhpYW9taS5jb20LAAQAAAAIYW5TUVJTRUgIAAYAAAAACwAIAAAAAkM0AAwACAsAAQAAABZzY201OTI1NDYyNDkzMjg4MDk2MmpTCgACAAABelWMEkILAAQAAAAG5b+r5omLCwAFAAAAq+S9oOeci+i/h+eahOWon+WnkO+8iOaJi+acuuaRhOW9se+8ieWPkeW4g+S6huaWsOS9nOWTge+8muWkj+WkqeeahOiaiuWtkOWlveWkmuWViu+9nuWkquiuqOWOjOS6hu+8jOaVtOS4quWkp+iaiummmeaKiuS7luS7rOeGj+aZleWQp++8gSAj5omL5py65pGE5b2xICPliJvkvZzngbXmhJ8gI+WIm+aEjwgABgAAAAAIAAgAAAAACAAJD5/Mww0ACgsLAAAACQAAAA5uX3N0YXRzX2V4cG9zZQAAAIB2SktrUzArUHo2QzVXRXN5MjhtWnlvSE4zZnFRMGorYXhLMVhWWFovK3h0NUFDQTcybmRjSmcxdWh4clhMdStSblI0ODFCc0hwZDNoeWZPVWQ4dHdqbVVJM0lBbDJ3V3J3d3owSEQ0b2xvNXlHQUM5NStZaDdYMU5WT29VbUtTeAAAABFub3RpZnlfZm9yZWdyb3VuZAAAAAExAAAADmNhbGxiYWNrLnBhcmFtAAAAMDE0M0pyQnQ0R2JKVzAwNjM3KjFFTU5QV2pjZHA1dW5zZXQ4MncwTVdoNlJlZG1pNgAAAA1fX3RhcmdldF9uYW1lAAAAQE5UTWpMRk1ZNnRQWkpONFcrdytvZndvTUZOOWxhZDNublFUOWJPUEEyeUNJSDlrSml2bWM5V1Jmb0R0ZWRXOWoAAAAFZmVfdHMAAAANMTYyNDkzMjg4MDk2MgAAAA1jYWxsYmFjay50eXBlAAAAAjE3AAAAF25vdGlmaWNhdGlvbl9zdHlsZV90eXBlAAAAATEAAAAIY2FsbGJhY2sAAAA+aHR0cHM6Ly9wdXNoLmtzYXBpc3J2LmNvbS9yZXN0L2luZnJhL3B1c2gvcHJvdmlkZXIvbXQvY2FsbGJhY2sAAAAGX19tX3RzAAAADTE2MjQ5MzI4ODEzNDQNAAsLCwAAAAEAAAAKc2NvcmVfaW5mbwAABIl7InNlcnZlcl9zY29yZSI6MSwiZ3JvdXBfaW50ZXJ2YWwiOjcyMDAwMDAsImV4dHJhX2luZm8iOiJbe1widlwiOjAsXCJiXCI6LTAuOTI4NjcyMzk3NDQxOTE1NSxcIndcIjpbMTQuMDQyMzAwNjYwODQ4MDQyLC0wLjEwNDgyMTA5MTUxOTE1MzA5LDAsMCwwXSxcImVsXCI6W1szMCwwXSxbMCwwXV0sXCJjbFwiOltbMCwwXV0sXCJjZ1wiOltbMCwwXV0sXCJwa2dcIjp7XCJjb20udGVuY2VudC5tbVwiOjksXCJjb20udGVuY2VudC5tb2JpbGVxcVwiOjksXCJjb20uYW5kcm9pZC5tbXNcIjo5LFwiY29tLmFuZHJvaWQuY29udGFjdHNcIjo5LFwiY29tLmFuZHJvaWQucHJvdmlkZXJzLmNvbnRhY3RzXCI6OSxcImNvbS5hbmRyb2lkLmNhbGVuZGFyXCI6OSxcImNvbS5hbmRyb2lkLnByb3ZpZGVycy5jYWxlbmRhclwiOjksXCJjb20uZ29vZ2xlLmFuZHJvaWQuY2FsZW5kYXJcIjo5LFwiY29tLndoYXRzYXBwXCI6OSxcImNvbS5mYWNlYm9vay5vcmNhXCI6OSxcImNvbS5nb29nbGUuYW5kcm9pZC5nbVwiOjksXCJjb20uYW5kcm9pZC5kZXNrY2xvY2tcIjo5LFwiY29tLmFuZHJvaWQucGhvbmVcIjo5LFwiY29tLmFuZHJvaWQuc3RrXCI6OSxcImNvbS5hbmRyb2lkLmNlbGxicm9hZGNhc3RyZWNlaXZlclwiOjksXCJjb20uYW5kcm9pZC5pbmNhbGx1aVwiOjksXCJjb20uYW5kcm9pZC5zZXJ2ZXIudGVsZWNvbVwiOjksXCJjb20uYW5kcm9pZC5lbWFpbFwiOjksXCJjb20ueGlhb21pLmNoYW5uZWxcIjo5LFwiY29tLmFuZHJvaWQudXBkYXRlclwiOjksXCJjb20uYW5kcm9pZC5zZXR0aW5nc1wiOjksXCJjb20ubWl1aS5wbGF5ZXJcIjo5LFwiY29tLm1pdWkuYnVncmVwb3J0XCI6OSxcImNvbS5lZy5hbmRyb2lkLkFsaXBheUdwaG9uZVwiOjksXCJjb20ueGlhb21pLm1hcmtldFwiOjksXCJjb20uYW5kcm9pZC5wcm92aWRlcnMuZG93bmxvYWRzXCI6OSxcImNvbS5hbGliYWJhLmFuZHJvaWQucmltZXQuYWxpZGluZ3RhbGtcIjo5LFwiY29tLmFsaWJhYmEuYW5kcm9pZC5yaW1ldFwiOjksXCJjb20udGVuY2VudC50aW1cIjo5LFwiY29tLm1pdWkuaG9tZVwiOjl9LFwidGhcIjowLjUsXCJuXCI6M31dIiwidGhyZXNob2xkIjowLjY3LCJyYXdfc2NvcmUiOjAuNjQ3Mzc2NTY0OTk5MDQ1NSwic29ydF9kZWxheSI6MTAwMDAsInNlcnZlcl9zdHJhdGVneSI6ImxyIn0CAAwAAAA=&quot;,
    &quot;text&quot;: &quot;你看过的娟姐（手机摄影）发布了新作品：夏天的蚊子好多啊～太讨厌了，整个大蚊香把他们熏晕吧！ #手机摄影 #创作灵感 #创意&quot;,
    &quot;title&quot;: &quot;快手&quot;,
    &quot;folded&quot;: false,
    &quot;id&quot;: &quot;scm59254624932880962jS&quot;,
    &quot;time&quot;: &quot;1624932881487&quot;,
    &quot;class&quot;: &quot;com.xiaomi.mipush.sdk.PushMessageHandler&quot;
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以发现，在 intent 的 bundle 里有一个 key 为 &quot;mipush_payload&quot; 的加密数据（我这里展示成了base64），这里存的就是加密后的推送数据详情，我们还需要继续做处理。&lt;/p&gt;&lt;h2 id=&quot;%E6%95%B0%E6%8D%AE%E8%A7%A3%E5%AF%86&quot;&gt;数据解密&lt;/h2&gt;&lt;h3 id=&quot;%E5%85%A5%E5%8F%A3&quot;&gt;入口&lt;/h3&gt;&lt;p&gt;数据解密的逻辑应当是放在 MiPush SDK 中，我们就只能去&lt;a href=&quot;https://admin.xmpush.xiaomi.com/zh_CN/mipush/downpage&quot;&gt;小米开发者中心&lt;/a&gt;把源码下下来看看。小米这里的处理比较让人蛋疼，一定要注册小米开发者然后才能下载代码。求爹爹告奶奶终于整到了 SDK，下面就以 MiPush_SDK_Client_4_0_2.jar 这个版本来看。&lt;/p&gt;&lt;p&gt;很容易想到的入手点就是 &quot;mipush_payload&quot; 这个字符串，先简单搜索一番试试：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2021/06/image-39.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/figure&gt;&lt;p&gt;涉及到的代码不多，挺好。考虑到既然我们想要的是解密，那应当是更关心 getByteArrayExtra 方法。进去看一看：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2021/06/image-40.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这里对 action 的值有几个分支判断，我们显然是希望 MESSAGE_ARRIVED 这个事件，那解析代码应当就是这个没跑了。&lt;/p&gt;&lt;h3 id=&quot;%E5%9D%91%E7%82%B9&quot;&gt;坑点&lt;/h3&gt;&lt;p&gt;入口都找到了，剩下就是无聊的人肉跟踪了。不过小米做了字节码级别的混淆，导致在同一个类中有很多类型不同但是名字相同的变量（不符合java语法、但是符合jvm规范）。这样就使 jadx 无法正常反编译出 java 代码，只能对变量名重命名展示。例如上面的 &lt;code&gt;b.m36a(this.f43a)&lt;/code&gt; 这个方法，他的函数声明的地方有 jadx 的注释:&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2021/06/image-41.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/figure&gt;&lt;p&gt;为了方便人眼看，这样的操作还是很有帮助的。但是由于在写代码的时候还是需要用真正的变量名，因此在搞清逻辑之后，我们还是只能用 IDEA 去看真正的代码。上面的代码在 IDEA 中就是这样：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2021/06/image-42.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/figure&gt;&lt;p&gt;不得不说这种代码混淆是真的恶心，在 IDEA 中我还看到了这种槽点十足、普通方法根本无法调用的代码：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2021/06/image-43.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上面的一系列操作导致的结果就是我们不得不一律采用反射来调用这些函数。&lt;/p&gt;&lt;h3 id=&quot;%E5%AF%86%E9%92%A5&quot;&gt;密钥&lt;/h3&gt;&lt;p&gt;在经过一系列斗争后，发现这些数据其实是采用了 AES 对称加密，加解密用的 key 是从名为 mipush 的 sharedpreferences 中的 regSec 中获得的：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;//com.xiaomi.push.i
private static Cipher a(byte[] bArr, int i) {
    SecretKeySpec secretKeySpec = new SecretKeySpec(bArr, &quot;AES&quot;);
    IvParameterSpec ivParameterSpec = new IvParameterSpec(a);
    Cipher instance = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);
    instance.init(i, secretKeySpec, ivParameterSpec);
    return instance;
}
 
//com.xiaomi.mipush.sdk.b
public static SharedPreferences a(Context context) {
    return context.getSharedPreferences(&quot;mipush&quot;, 0);
}
 
//com.xiaomi.mipush.sdk.b
public static a a(Context context, String str) {
    try {
        JSONObject jSONObject = new JSONObject(str);
        a aVar = new a(context);
        aVar.f62a = jSONObject.getString(&quot;appId&quot;);
        aVar.b = jSONObject.getString(&quot;appToken&quot;);
        aVar.c = jSONObject.getString(&quot;regId&quot;);
        aVar.d = jSONObject.getString(&quot;regSec&quot;);//这个！
        aVar.f = jSONObject.getString(&quot;devId&quot;);
        aVar.e = jSONObject.getString(&quot;vName&quot;);
        aVar.f63a = jSONObject.getBoolean(&quot;valid&quot;);
        aVar.f64b = jSONObject.getBoolean(&quot;paused&quot;);
        aVar.a = jSONObject.getInt(&quot;envType&quot;);
        aVar.g = jSONObject.getString(&quot;regResource&quot;);
        return aVar;
    } catch (Throwable th) {
        com.xiaomi.channel.commonutils.logger.b.a(th);
        return null;
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;密钥的位置在对应 app 内部存储目录的 shared_prefs 文件夹下。以 gifmaker 为例：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;$ adb shell su -c &#x27;cat /data/data/com.smile.gifmaker/shared_prefs/mipush.xml&#x27;
&amp;lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27; standalone=&#x27;yes&#x27; ?&amp;gt;
&amp;lt;map&amp;gt;
    &amp;lt;string name=&quot;devId&quot;&amp;gt;951ECBAB1F2EB405ABF912BD65FC703FF43969CE&amp;lt;/string&amp;gt;
    &amp;lt;boolean name=&quot;valid&quot; value=&quot;true&quot; /&amp;gt;
    &amp;lt;string name=&quot;regResource&quot;&amp;gt;oGZD6g&amp;lt;/string&amp;gt;
    &amp;lt;string name=&quot;vName&quot;&amp;gt;8.2.31.17191&amp;lt;/string&amp;gt;
    &amp;lt;string name=&quot;pref_msg_ids&quot;&amp;gt;,sdm580566248810824873c,sdm58782624881295100Zr&amp;lt;/string&amp;gt;
    &amp;lt;int name=&quot;envType&quot; value=&quot;1&quot; /&amp;gt;
    &amp;lt;string name=&quot;appToken&quot;&amp;gt;5431713053534&amp;lt;/string&amp;gt;
    &amp;lt;string name=&quot;appId&quot;&amp;gt;2882303761517130534&amp;lt;/string&amp;gt;
    &amp;lt;string name=&quot;regId&quot;&amp;gt;NTMjLFMY6tPZJN4W+w+ofwoMFN9lad3nnQT9bOPA2yCIH9kJivmc9WRfoDtedW9j&amp;lt;/string&amp;gt;
    &amp;lt;string name=&quot;regSec&quot;&amp;gt;AMjTZmbZx2LS1X7dp0AAAA==&amp;lt;/string&amp;gt;
    &amp;lt;string name=&quot;appRegion&quot;&amp;gt;China&amp;lt;/string&amp;gt;
&amp;lt;/map&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里的密钥就是 AMjTZmbZx2LS1X7dp0AAAA== 。&lt;/p&gt;&lt;p&gt;需要注意的是，这个密钥是在 app 初次启动时生成的，不通设备之间不一样，相同设备的不同次安装也不一样。&lt;/p&gt;&lt;h3 id=&quot;%E5%AE%9E%E7%8E%B0&quot;&gt;实现&lt;/h3&gt;&lt;p&gt;最后把相关代码拼接下，在服务端实现一个服务即可。代码参考如下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;public class PushMessage implements Serializable {
    private static final long serialVersionUID = 4745289224411613134L;
 
    private String id;
    private Long channelId;
    private String userId;
    private String server;
    private String resource;
    private String appId;
    private String packageName;
    private String payload;
    private Long createAt;
    private Long ttl;
    private Boolean isOnline;
    private Boolean needsAck;
    
    //some getter and setter
}
 
public PushMessage decrypt(String secKey, String payload) {
    try {
        byte[] data = Base64.getDecoder().decode(payload);
        byte[] key = Base64.getDecoder().decode(secKey);
 
        im im = new im();
 
        ja.a(im, data);
 
        byte[] buffer = null;
        for (Method declaredMethod : im.getClass().getDeclaredMethods()) {
            if (declaredMethod.getReturnType().equals(byte[].class)) {
                try {
                    buffer = (byte[]) declaredMethod.invoke(im);
                } catch (IllegalAccessException | InvocationTargetException e) {
                    throw new RuntimeException(e);
                }
            }
        }
        if (buffer == null) {
            throw new RuntimeException(&quot;buffer is null&quot;);
        }
 
 
        byte[] decrypted = i.a(key, buffer);
        it a3 = null;
        for (Method declaredMethod : com.xiaomi.mipush.sdk.ai.class.getDeclaredMethods()) {
            if (declaredMethod.getName().equals(&quot;a&quot;)
                    &amp;amp;&amp;amp; declaredMethod.getReturnType().equals(jb.class)
                    &amp;amp;&amp;amp; declaredMethod.getModifiers() == (Modifier.PRIVATE | Modifier.STATIC)) {
                declaredMethod.setAccessible(true);
                try {
                    a3 = (it) declaredMethod.invoke(com.xiaomi.mipush.sdk.ai.class, hq.a(5), true);
                } catch (IllegalAccessException | InvocationTargetException e) {
                    throw new RuntimeException(&quot;reflect invoke failed&quot;, e);
                }
            }
        }
 
        if (a3 == null) {
            throw new RuntimeException(&quot;a3 not found&quot;);
        }
        new jf(new com.xiaomi.push.js.a(true, true, data.length)).a(a3, decrypted);
 
        PushMessage pushMessage = convertToMessage(a3);
        logger.info(&quot;decrypt for {} \ndata: {}\nresult: {}&quot;, secKey, payload, JSONObject.toJSONString(pushMessage));
        return pushMessage;
    } catch (DecryptFailedException e) {
        logger.error(&quot;decrypt for {} failed\ndata: {}&quot;, secKey, payload, e);
        throw e;
    } catch (Throwable e) {
        RuntimeException ex = new RuntimeException(&quot;decode failed,&quot;, e);
        logger.error(&quot;decrypt for {} failed\ndata: {}&quot;, secKey, payload, ex);
        throw ex;
    }
}
 
private PushMessage convertToMessage(it result) throws IllegalAccessException, ClassNotFoundException {
    PushMessage pushMessage = new PushMessage();
 
    Field idField = findFieldByNameAndType(it.class, &quot;b&quot;, String.class);
    pushMessage.setId((String) idField.get(result));
 
    Field needsAckField = findFieldByNameAndType(it.class, &quot;a&quot;, boolean.class);
    pushMessage.setNeedsAck((boolean) needsAckField.get(result));
 
    Field appIdField = findFieldByNameAndType(it.class, &quot;c&quot;, String.class);
    pushMessage.setAppId((String) appIdField.get(result));
 
    Field packageNameField = findFieldByNameAndType(it.class, &quot;d&quot;, String.class);
    pushMessage.setPackageName((String) packageNameField.get(result));
 
    Class&amp;lt;?&amp;gt; ifClass = Class.forName(&quot;com.xiaomi.push.if&quot;);
    Field ifField = findFieldByNameAndType(it.class, &quot;a&quot;, ifClass);
    Object target = ifClass.cast(ifField.get(result));
 
    Field targetField = findFieldByNameAndType(ifClass, &quot;a&quot;, long.class);
    pushMessage.setChannelId((long) targetField.get(target));
 
    Field userIdField = findFieldByNameAndType(ifClass, &quot;a&quot;, String.class);
    pushMessage.setUserId((String) userIdField.get(target));
 
    Field serverField = findFieldByNameAndType(ifClass, &quot;b&quot;, String.class);
    pushMessage.setServer((String) serverField.get(target));
 
    Field resourceField = findFieldByNameAndType(ifClass, &quot;c&quot;, String.class);
    pushMessage.setResource((String) resourceField.get(target));
 
    Field icField = findFieldByNameAndType(it.class, &quot;a&quot;, ic.class);
    ic pmsg = (ic) icField.get(result);
 
    Field payloadField = findFieldByNameAndType(ic.class, &quot;c&quot;, String.class);
    pushMessage.setPayload((String) payloadField.get(pmsg));
 
    Field createAtField = findFieldByNameAndType(ic.class, &quot;a&quot;, long.class);
    pushMessage.setCreateAt((long) createAtField.get(pmsg));
 
    Field ttlField = findFieldByNameAndType(ic.class, &quot;b&quot;, long.class);
    pushMessage.setTtl((long) ttlField.get(pmsg));
 
    Field onlineField = findFieldByNameAndType(ic.class, &quot;a&quot;, boolean.class);
    pushMessage.setOnline((boolean) onlineField.get(pmsg));
 
    return pushMessage;
}
 
private Field findFieldByNameAndType(Class&amp;lt;?&amp;gt; clazz, String name, Class&amp;lt;?&amp;gt; returnType) {
    for (Field field : clazz.getDeclaredFields()) {
        if (field.getName().equals(name) &amp;amp;&amp;amp; field.getType().equals(returnType)) {
            return field;
        }
    }
    throw new FieldNotFoundException(String.format(&quot;cannot find name-&amp;gt;%s returnType-&amp;gt;%s for class-&amp;gt;%s&quot;, name, returnType, clazz));
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;mipush 的内部实现依赖了 android 相关的类，虽然在解密的过程中并没有用到，但是如果类不存在还是会报错的。因此还需要加两个mock类，空实现即可。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package android.content;
 
public class Context {
}&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;package android.text;
 
public class TextUtils {
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于 java 编译器的关系，在运行时需要加上 &lt;code&gt;-noverify&lt;/code&gt; 的参数，否则会报 &lt;code&gt;java.lang.VerifyError&lt;/code&gt; 的错。（参考 &lt;a href=&quot;https://stackoverflow.com/questions/15122890/java-lang-verifyerror-expecting-a-stackmap-frame-at-branch-target-jdk-1-7&quot;&gt;sf&lt;/a&gt; ）&lt;/p&gt;&lt;h3 id=&quot;%E8%BF%90%E8%A1%8C&quot;&gt;运行&lt;/h3&gt;&lt;p&gt;最后，我们把本次从 gifmaker 拿到的推送解析一把：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
    &quot;appId&quot;: &quot;2882303761517130534&quot;,
    &quot;channelId&quot;: 5,
    &quot;createAt&quot;: 1624932880962,
    &quot;id&quot;: &quot;scm59254624932880962jS&quot;,
    &quot;needsAck&quot;: true,
    &quot;online&quot;: true,
    &quot;packageName&quot;: &quot;com.smile.gifmaker&quot;,
    &quot;payload&quot;: &quot;{\&quot;click_payload\&quot;:\&quot;true\&quot;,\&quot;push_notification\&quot;:\&quot;{}\&quot;,\&quot;infra_tag\&quot;:\&quot;cdp\&quot;,\&quot;onlyInBar\&quot;:\&quot;false\&quot;,\&quot;dndModeIsOn\&quot;:\&quot;false\&quot;,\&quot;push_msg_id\&quot;:\&quot;0000016249328800885970645000158\&quot;,\&quot;id\&quot;:\&quot;0000016249328800885970645000158\&quot;,\&quot;push_back\&quot;:\&quot;143JrBt4GbJW00637*1EMNPWjcdp5unset82w0MWh6Redmi6oANDROID_021f5a0bbeeb1eb1\&quot;,\&quot;server_key\&quot;:\&quot;{\\\&quot;business\\\&quot;:\\\&quot;RECO_PUSH\\\&quot;,\\\&quot;object_type\\\&quot;:\\\&quot;OBJECT_PHOTO\\\&quot;,\\\&quot;item_id\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;ks_order_id\\\&quot;:\\\&quot;empty\\\&quot;,\\\&quot;object_id\\\&quot;:\\\&quot;5205879746946008323\\\&quot;,\\\&quot;sender_id\\\&quot;:\\\&quot;0\\\&quot;,\\\&quot;push_type\\\&quot;:\\\&quot;PUSH_PHOTO\\\&quot;,\\\&quot;infra_tag\\\&quot;:\\\&quot;cdp\\\&quot;,\\\&quot;event_type\\\&quot;:\\\&quot;EVENT_CONSUME_AUTHOR_PHOTO_PUSH\\\&quot;,\\\&quot;time_ms\\\&quot;:\\\&quot;1624932880244\\\&quot;,\\\&quot;business_type\\\&quot;:\\\&quot;KUAISHOU\\\&quot;,\\\&quot;badge\\\&quot;:0}\&quot;,\&quot;title\&quot;:\&quot;快手\&quot;,\&quot;body\&quot;:\&quot;你看过的娟姐（手机摄影）发布了新作品：夏天的蚊子好多啊～太讨厌了，整个大蚊香把他们熏晕吧！ #手机摄影 #创作灵感 #创意\&quot;,\&quot;uri\&quot;:\&quot;kwai:\\/\\/work\\/5205879746946008323?userId=2331994191&amp;amp;exp_tag=1_a\\/0_ps\&quot;}&quot;,
    &quot;resource&quot;: &quot;anSQRSEH&quot;,
    &quot;server&quot;: &quot;xiaomi.com&quot;,
    &quot;ttl&quot;: 86401,
    &quot;userId&quot;: &quot;70084876406&quot;
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中的payload 再展开看下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;{
    &quot;click_payload&quot;: &quot;true&quot;,
    &quot;push_notification&quot;: &quot;{}&quot;,
    &quot;infra_tag&quot;: &quot;cdp&quot;,
    &quot;onlyInBar&quot;: &quot;false&quot;,
    &quot;dndModeIsOn&quot;: &quot;false&quot;,
    &quot;push_msg_id&quot;: &quot;0000016249328800885970645000158&quot;,
    &quot;id&quot;: &quot;0000016249328800885970645000158&quot;,
    &quot;push_back&quot;: &quot;143JrBt4GbJW00637*1EMNPWjcdp5unset82w0MWh6Redmi6oANDROID_021f5a0bbeeb1eb1&quot;,
    &quot;server_key&quot;: &quot;{\&quot;business\&quot;:\&quot;RECO_PUSH\&quot;,\&quot;object_type\&quot;:\&quot;OBJECT_PHOTO\&quot;,\&quot;item_id\&quot;:\&quot;0\&quot;,\&quot;ks_order_id\&quot;:\&quot;empty\&quot;,\&quot;object_id\&quot;:\&quot;5205879746946008323\&quot;,\&quot;sender_id\&quot;:\&quot;0\&quot;,\&quot;push_type\&quot;:\&quot;PUSH_PHOTO\&quot;,\&quot;infra_tag\&quot;:\&quot;cdp\&quot;,\&quot;event_type\&quot;:\&quot;EVENT_CONSUME_AUTHOR_PHOTO_PUSH\&quot;,\&quot;time_ms\&quot;:\&quot;1624932880244\&quot;,\&quot;business_type\&quot;:\&quot;KUAISHOU\&quot;,\&quot;badge\&quot;:0}&quot;,
    &quot;title&quot;: &quot;快手&quot;,
    &quot;body&quot;: &quot;你看过的娟姐（手机摄影）发布了新作品：夏天的蚊子好多啊～太讨厌了，整个大蚊香把他们熏晕吧！ #手机摄影 #创作灵感 #创意&quot;,
    &quot;uri&quot;: &quot;kwai://work/5205879746946008323?userId=2331994191&amp;amp;exp_tag=1_a/0_ps&quot;
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;信息非常全，还带了跳转用的scheme，通过&lt;code&gt;adb shell am start -a android.intent.action.VIEW -d kwai://work/5205879746946008323?userId=2331994191&amp;amp;exp_tag=1_a/0_ps&lt;/code&gt; 就能直接跳转到对应页面了。&lt;/p&gt;&lt;h2 id=&quot;%E9%80%9A%E7%9F%A5%E6%A0%8F%E6%B8%85%E7%90%86&quot;&gt;通知栏清理&lt;/h2&gt;&lt;p&gt;上面的脚本仅仅涉及了获取数据，并没有涉及清理通知栏。显然，如果一直不清理，不仅要考虑数据去重，也会影响拉取效率。实际用起来发现，如果一直不清理，也容易 hook 不动。。。&lt;/p&gt;&lt;p&gt;要清理也很简单，在每次拉取消息结束后，调用一下命令即可：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ adb shell su -c &#x27;service call notification 1&#x27;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;%E5%AE%9E%E6%97%B6%E7%9B%91%E5%90%AC&quot;&gt;实时监听&lt;/h2&gt;&lt;p&gt;不要忘了，我们需要的是实时监听，因此还需要监听下&lt;code&gt;NotificationGroupManager&lt;/code&gt; 的触发器。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;let NotificationGroupManager = Java.use(&#x27;com.android.systemui.statusbar.phone.NotificationGroupManager&#x27;)
let onEntryAdded = NotificationGroupManager.onEntryAdded;
onEntryAdded.implementation = function (entry) {
    let res = onEntryAdded.call(this, entry);
    processManager(this)
    return res;
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不过，从实践中看，想通过直接 hook 一次这个 onEntryAdded 事件就能一劳永逸还是想太多了。Frida进程或者是桌面进程总会有各种理由挂掉，因此我们在生产中也并没有依赖这个，而是通过外部定时任务来触发。&lt;/p&gt;&lt;h2 id=&quot;%E5%AE%9A%E6%97%B6%E6%8B%89%E6%B4%BB&quot;&gt;定时拉活&lt;/h2&gt;&lt;p&gt;由于小米厂家自身的通道（可能）比较贵，因此各大应用几乎都有很大一部分走的是自己的长链接。与小米自身的系统通道不同，这些长链接都是需要 App 在后台运行才能保证的。因此我们也需要定期把那些重要的 App 进行强制拉活，这样我们能收到的 push 才能更快、更多。不过好消息是，应用自身通道的推送数据是不用走 mipush 加密那一套东西，所以搞起来更简单～&lt;/p&gt;&lt;h1 id=&quot;%E7%BB%93%E8%AF%AD&quot;&gt;结语&lt;/h1&gt;&lt;p&gt;最后反手夸一夸腾讯，看起来各大厂家对热点事件的推送中，腾讯爸爸还是最及时的，运营同学们辛苦了。&lt;/p&gt;&lt;h1 id=&quot;%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99&quot;&gt;参考资料&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://dev.mi.com/console/doc/detail?pId=863&quot;&gt;小米推送产品说明&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://wwm0609.github.io/2017/12/21/android-vdex/&quot;&gt;Android 8.0 VDEX机制简介&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://pitechan.com/%E9%80%86%E5%90%91Settings%E5%AE%9E%E7%8E%B0%E7%9B%91%E6%8E%A7App%E9%80%9A%E7%9F%A5/&quot;&gt;逆向settings实现监控app通知&lt;/a&gt;&lt;/p&gt;
    &lt;/section&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>