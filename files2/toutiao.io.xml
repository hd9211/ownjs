<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>cbb9ac1dc92411698f9c08d5b64336b4</guid>
<title>周末别闲着，快来吧！</title>
<link>https://toutiao.io/k/sat069j</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>415d8d9c97561b0c489ee80f620229a3</guid>
<title>基于开源工具的人生管理</title>
<link>https://toutiao.io/k/e2ie57j</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content&quot; itemprop=&quot;articleBody&quot;&gt;&amp;#13;
&lt;p&gt;我在《&lt;a href=&quot;https://www.bmpi.dev/self/gtd-tools-i-used/&quot;&gt;我的时间管理工具&lt;/a&gt;》与《&lt;a href=&quot;https://www.bmpi.dev/self/note-system/&quot;&gt;我的笔记系统&lt;/a&gt;》中分享过我不断演进的时间管理工具与笔记系统。在使用这些系统多年后，始终有个困惑萦绕在我耳边，那就是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单纯的记录时间、笔记和资金是一种碎片化的行为，容易导致过于追求细节而忘掉全局，让自己成为一个忙碌的战略懒人。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;时间管理、记账、记笔记、学习、写作、阅读、交流这些行为都不是最终目的，它们只是一种实现个人长期目标的辅助方法，如果做这些事对长期目标毫无帮助，那没必要浪费时间去做。&lt;/p&gt;
&lt;p&gt;虽然我做了大量的时间与资金开销记录，但我也很难评估这些开销对实现长期目标有何影响。这种困扰可以看作个人时间管理的哥德巴赫猜想：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我知道我的时间有一半都被浪费掉，但就是不知道哪一半。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想解决这个问题，就得简化问题的复杂度，这个问题其实等价于以下两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;今天我做了啥？&lt;/li&gt;
&lt;li&gt;做这些事对我的长期目标有什么帮助？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;经过一段时间的思考，我有了以下的简单模型去解决这个问题。让我们先对问题进行建模。&lt;/p&gt;
&lt;h3&gt;问题建模&lt;/h3&gt;
&lt;p&gt;如果把人看作一个 Machine，这个 Machine 有输入有输出。最初这个 Machine 只拥有时间维度，逐渐它拥有了技能维度，同时积累了金钱维度。如果把时间、技能与金钱看作它的输入端，那它输出端就是金钱、技能与影响力维度。其中金钱和技能在输入与输出间自循环，一般是正向的。我们的金钱和技能都会随着输入与输出的循环而提升，而影响力其实就是知识的变体，我们通过知识去影响别人，通过知识去建立权威与信誉度，最终发展出个人品牌。这个流程看起来非常像是一场 &lt;a href=&quot;https://www.bmpi.dev/self/road_to_life_games/&quot;&gt;打怪升级的游戏&lt;/a&gt;。这些抽象的维度落地后就变为&lt;a href=&quot;https://www.bmpi.dev/self/gtd-tools-i-used/&quot;&gt;时间管理系统（目标、任务与时间）&lt;/a&gt;、&lt;a href=&quot;https://www.bmpi.dev/self/note-system/&quot;&gt;财务管理系统（记账、投资与保险）&lt;/a&gt; 与&lt;a href=&quot;https://www.bmpi.dev/self/build-personal-knowledge-system/&quot;&gt;知识体系（写作、笔记与个人品牌）&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;想象这个场景：通过设定个人 OKR，把一个个 Key Result 拆解为一个个 TODO Task，用时间管理工具去追踪这些 Task 的时间开销，用财务管理去追踪这些 Task 的金钱开销，用知识管理去追踪这些 Task 的笔记，那我们是可以知道每个 Objective 的时间与资金开销，同时也能知道这个 Objective 的输出笔记产物有哪些，最终输出的影响力程度。通过不断优化输入与输出端，我们可以形成高效的学习能力，更好的适应外界的变化。如何优化？就需要记录输入与输出端各个维度的数据。通过记录底层维度数据来把控高层目标的实现。从时间与财务性价比的角度看一个个最终执行的任务，如果某个任务能更好的推动 OKR 目标的实现，那这个任务的投入就有价值。&lt;/p&gt;
&lt;p&gt;理想的情况是，每个人拥有自己的输入与输出各维度的 Dashboard，这样就能从宏观视角看到自己每天做的事情的价值。我们可以量化每件事情的投入产出比，去优化自己的处理流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/07/1-life-management-based-on-open-source.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;系统设计&lt;/h3&gt;
&lt;p&gt;在对问题建模后，我现在的业务需求是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全局的 Tag 系统。该 Tag 系统可以从个人愿景中设定年度 OKR 目标，之后可以对 OKR 的 Key Result 进行细粒度的 Task 拆分。&lt;/li&gt;
&lt;li&gt;任务时间开销追踪。可以对 OKR 目标的某个 Key Result 统计相关的 Task 的总耗费时间。&lt;/li&gt;
&lt;li&gt;任务资金开销追踪。可以对 OKR 目标的某个 Key Result 统计相关的 Task 的总资金成本。&lt;/li&gt;
&lt;li&gt;任务相关笔记关联。可以对 OKR 目标的某个 Key Result 关联相关的 Task 的笔记。&lt;/li&gt;
&lt;li&gt;Dashboard 原始数据生成。可以自动或手动生成个人 OKR 完成度表现报告与财务健康度报告。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下图是一个从个人愿景到 OKR ，之后从 OKR 生成每日待办任务，追踪任务相关时间、资金与笔记的流程图。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/07/2-life-management-based-on-open-source.jpg&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/07/2-life-management-based-on-open-source-768x368.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;系统实现&lt;/h3&gt;
&lt;p&gt;我的系统实现原则是尽可能用开源的工具组合实现我的需求。所以基本原则有以下几条：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;工具需必须要开源。不考虑商业版的原因是未知不可控的商业风险，这些工具都是要长期使用的，选择开源方案是性价比最高的。&lt;/li&gt;
&lt;li&gt;工具需要具备可扩展的能力。只有可扩展的系统才具备组合的能力，这样方便后期定制化的使用。&lt;/li&gt;
&lt;li&gt;工具要有一个好的社区。一个好的社区非常重要，可以让我们解决问题的成本下降很多。也可以使用别人提供的现成解决方案。&lt;/li&gt;
&lt;li&gt;数据必须能自托管。数据必须要存放到自己控制的存储（本地和网络都可以）中，隐私第一原则。&lt;/li&gt;
&lt;li&gt;数据尽可能是纯文本。纯文本更简单，就算工具不可用，也可以直接对文本进行读取或修改。长期来看，这点很重要。&lt;/li&gt;
&lt;li&gt;门槛低。最好一天上手，三天精通，我不想花费数周时间去学习一个复杂的工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;现有解决方案&lt;/h4&gt;
&lt;h5&gt;Emacs&lt;/h5&gt;
&lt;p&gt;如果直接选现成的方案，一定有人会提到这篇 《&lt;a href=&quot;http://doc.norang.ca/org-mode.html&quot;&gt;Organize Your Life In Plain Text!&lt;/a&gt;》。这篇超过 10 年历史的文章看起来如 Emacs 一样强大而久远。用 Emacs 做的确符合以上所有基本原则，问题在于我不是一个 Emacs 专家，我不想学数年 Emacs 后再开始解决这个问题。我的思路是花最多不过一周时间去用开源工具组合出一套解决我需求的方案出来。一周时间，我可能连 Emacs 快捷键都记不住。&lt;/p&gt;
&lt;h5&gt;自己动手做&lt;/h5&gt;
&lt;p&gt;当我看到这篇《&lt;a href=&quot;https://beepb00p.xyz/blog-graph.html&quot;&gt;Blog graph&lt;/a&gt;》 和 《&lt;a href=&quot;https://beepb00p.xyz/myinfra.html&quot;&gt;Map of my personal data infrastructure&lt;/a&gt; 》时整个人都震惊了。作者全部自己动手做了一套类似的系统去管理他的人生。如果我有时间的话我一定会这么尝试去做，但是我没时间。&lt;/p&gt;
&lt;h5&gt;工具选择&lt;/h5&gt;
&lt;p&gt;这套系统实现的关键在于需要有 Tag、TODO、笔记管理、记账等功能，记账可以用 Beancount 去做，只需要结合它的 Tag 功能就可以追逐相关 Tag 的开销。那么只需要选择一个具备 Tag 和 TODO 功能的开源笔记工具就行了。这么看来我们可选择的很有限了。&lt;br/&gt;
以最近大热的 Roam Research 为例，它开启了不少笔记工具的新特性：反向链接、右边栏、每日笔记及图数据库。最重要的其实是它的图数据库特性，因为当一个工具具备了数据库的查询能力时，结合插件特性我们可以做出非常多的应用场景。可惜的是它是一个商业软件且不开源（ Notion 也因为这个原因被排除），所以我找到了一个具备它很多特性的开源软件 Logseq，Logseq 本身受很多笔记工具的启发，如 Roam Research、Tiddlywiki、Workflowy 与 Org Mode 。&lt;br/&gt;
在把玩了几天 Logseq 后我发现最强的就是它底层的 DataScript 内存图数据库，可以通过高级查询做很多自定义界面。这样就可以满足我们的很多需求了，比如生成每日待办任务，根据 OKR 生成的 Tag 来过滤和 OKR 相关的任务，统计相关任务的花费时间等。&lt;br/&gt;
目前 Logseq 还在开发插件系统，等插件系统上线后，很多难以实现的功能都可以通过插件来完成。当然我的需求还不需要插件系统的支持，光高级查询就可以满足。&lt;/p&gt;
&lt;h5&gt;我的方案&lt;/h5&gt;
&lt;p&gt;当确定了笔记工具和记账工具后，我最终的方案如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/07/3-life-management-based-on-open-source.jpg&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/07/3-life-management-based-on-open-source-768x617.jpg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各工具的职责如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Logseq。负责制定 OKR 、设定相关 Tag 、拆分 OKR 相关任务并追踪任务耗费时间（时间管理）及管理这些任务相关的笔记（笔记系统）。&lt;/li&gt;
&lt;li&gt;Beancount。负责记录相关 Tag 的资金开销，当然也是我的记账工具，最终帮助我生成家庭财务健康度的评估报告。&lt;/li&gt;
&lt;li&gt;Tiddlywiki。负责公开笔记的输出。和 Logseq 的区别在于，我会将 Logseq 的一些笔记整理成可供分享的知识后发布到 Tiddlywiki 上。虽然 Logseq 支持公开某个页面，但是为了更好的区分私人笔记和公开笔记，我还是做了这个区分。&lt;/li&gt;
&lt;li&gt;Amazon AWS。我的个人云平台。目前主要是用 S3 + CloudFront 做博客的图床。&lt;a href=&quot;https://www.bmpi.dev/dev/pulumi-aws-serverless-hugo-site-vists/&quot;&gt;博客的页面访问数据&lt;/a&gt; 也是用 &lt;a href=&quot;https://www.bmpi.dev/dev/guide-to-serverless/&quot;&gt;AWS Serverless&lt;/a&gt; 开发实现的。&lt;/li&gt;
&lt;li&gt;Wayback Machine。类似 OneNote 和 Evernote 的 Web 剪藏工具。它可以永久保存网页的所有变更版本，所以一般无需自己把网页内容下载到笔记工具里，这样会导致笔记工具同步缓慢。我当时用 OneNote 剪藏了很多网页导致其存储达几 GB ，每次换设备同步都很头疼。实际上只需要保存网页链接即可，最多加几句总结的话助记。有 Wayback Machine 再也无需担心网页突然不见了。&lt;/li&gt;
&lt;li&gt;GitHub。项目托管与云存储平台。博客、记账与时间管理的所有数据包括文件（某些文件会放到 Google Drive 里）都存放到 GitHub 公开或私有仓库中。&lt;/li&gt;
&lt;li&gt;Vercel。博客与Wiki托管平台。可直接关联 GitHub 后一键发布网站并自带 CDN 且 &lt;a href=&quot;https://www.bmpi.dev/dev/guide-to-setup-blog-site-with-zero-cost-5/&quot;&gt;国内访问速度不错&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;VSCode。文本编辑工具。一般我会用它完成博客写作、笔记写作（也可用浏览器）、绘图（也可用浏览器）、记账及代码开发。&lt;/li&gt;
&lt;li&gt;Google/Twitter/YouTube。主要的信息获取平台。主动搜索用 Google，被动获取用 Twitter 及 YouTube。中文高质量的信息获取平台越来越少了，很多时候需要用英文才能搜索到我想要的信息。所以搜索技能和英文能力已经算基本能力了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最右侧有颜色的三个框就是我的愿景最关注的三个领域了，我的所有输出都会和这三个领域相关。&lt;/p&gt;
&lt;h3&gt;实现效果&lt;/h3&gt;
&lt;p&gt;使用 Logseq 完成的最终效果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/07/4-life-management-based-on-open-source.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每天我都可以在 Logseq 系统首页看到以时间四象限划分法而划分的待办任务。具体如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;📅 在做计划事项。标记为重要的或者和任何 OKR 相关的在做任务。&lt;/li&gt;
&lt;li&gt;🌞 待做计划事项。标记为重要的或者和任何 OKR 相关的待做任务。&lt;/li&gt;
&lt;li&gt;⏰ 在做其他事项。任何不重要的或者和 OKR 不相关的在做任务。&lt;/li&gt;
&lt;li&gt;🚮 待做其他事项。任何不重要的或者和 OKR 不相关的待做任务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;底部的区块是和 OKR 相关的信息，让我可以快速了解到目前最重要的 Objective 有哪些。&lt;br/&gt;
当然这个系统远不止如此，更多的信息我会新开一篇文章来介绍如何用 Logseq 实现这些功能。也会写一篇文章介绍如何基于文本使用 Beancount 做复式记账。&lt;/p&gt;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3341cf6f94c0487190d7433a93080b67</guid>
<title>了不起的 Chrome 浏览器（四）：Chrome 92 新增 at 和 randomUUID 方法，Canvas 支持 Display P3 色域</title>
<link>https://toutiao.io/k/a333hks</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;7月20日正式发布的Chrome 92，带来了哪些有意思的新特性呢？&lt;/p&gt;&lt;h1 data-lake-id=&quot;34ddb71c8f8a82125eaf87ae6d4ea601&quot;/&gt;&lt;h1 data-lake-id=&quot;34ddb71c8f8a82125eaf87ae6d4ea601&quot;&gt;背景&lt;/h1&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;十多年来，Web技术突飞猛进，其中Chrome功不可没，了解Chrome可以帮助我们理解整个行业的发展趋势。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;因此，我将以《了不起的Chrome浏览器》为题，对Chrome的每一个版本的重要特性进行详细解读，同时分享一些自己的一些思考：&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;通过专注于Chrome的写作，既可以可以提高我的专业能力，也可以提高个人影响力。&lt;span&gt;我的目标是在2025年出版一本关于Chrome的书&lt;/span&gt;，毕竟出版自己的书每一个写作者最高的追求。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;我是寒雁，一个热爱写代码和写文章的程序员，欢迎关注我的微信公众号寒雁Talk。&lt;/p&gt;&lt;h1 data-lake-id=&quot;029f19ae2d05a034702f31a96a8d5500&quot;&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1 data-lake-id=&quot;029f19ae2d05a034702f31a96a8d5500&quot;&gt;TL;TR&lt;/h1&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;ul data-lake-id=&quot;f47e54ae4cb1ddca0278a84be2ace458&quot; start=&quot;1&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Chrome 92最大的亮点是什么？说实话，&lt;span&gt;Chrome92并没有什么特别大的亮点&lt;/span&gt;，不过Array.prototype.at()还是挺实用的&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Chrome 92是哪天发布的？2021-07-20&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Chrome 92更新了多少个特性？14个，具体有哪些特性可以查看Chrome Platform Status&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Chrome 92将使用哪个版本的V8引擎？9.2&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我感兴趣的新特性依次有哪些？&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-lake-id=&quot;a307463c5681d2c5807a63eedde86843&quot;&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1 data-lake-id=&quot;a307463c5681d2c5807a63eedde86843&quot;&gt;详细解读&lt;/h1&gt;&lt;h3 data-lake-id=&quot;da2607b47c7f128fa56b5519712d9475&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-lake-id=&quot;da2607b47c7f128fa56b5519712d9475&quot;&gt;Array.prototype.at()&lt;/h3&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;想必大家都写过这样的代码，使用数组长度减1来获取过数组的最后一个元素：&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; A = [&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;]; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;console&lt;/span&gt;.log(A[A.length - &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;]);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/pre&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;作为一个有代码洁癖的人，这样的写法冗长而奇怪。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;现在好了，Chrome 92支持Array.prototype.at()了：&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; A = [&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;]; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;console&lt;/span&gt;.log(A.at(&lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/pre&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;代码少了5个字符，可读性也提高了很多，一举两得!&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;另外，除了Array，String与TypedArray也支持了at方法。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;at方法对应的ECMAScript提案&lt;span&gt;proposal-relative-indexing-method已经处于stage 3&lt;/span&gt;，目测最快明年将会纳入ECMAScript规范。&lt;/p&gt;&lt;h3 data-lake-id=&quot;3d00855a8c2a513153da594cee6bb54b&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-lake-id=&quot;3d00855a8c2a513153da594cee6bb54b&quot;&gt;crypto.randomUUID()&lt;/h3&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;日常开发中，我们经常会需要生成唯一ID，例如给每个用户生成唯一ID。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;npm包uuid的周下载量高达4000万+，我在自己的代码里也搜到了uuid模块：&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2021%2Fjpeg%2F928098%2F1626511048566-ef600748-9b21-4dfe-a9bc-62ce08d5656d.jpeg%22%2C%22originWidth%22%3A616%2C%22originHeight%22%3A302%2C%22name%22%3A%22uuid.jpeg%22%2C%22size%22%3A32197%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A23.600388%2C%22y%22%3A26.034937%2C%22width%22%3A89.497292%2C%22height%22%3A19.291891%2C%22text%22%3A%22SEARCH%22%7D%2C%7B%22x%22%3A573.852%2C%22y%22%3A93.99997%2C%22width%22%3A17.957750000000033%2C%22height%22%3A17.957750000000033%2C%22text%22%3A%22*%22%7D%2C%7B%22x%22%3A477.27963%2C%22y%22%3A96.268555%2C%22width%22%3A29.191899999999976%2C%22height%22%3A20.685035%2C%22text%22%3A%22Aa%22%7D%2C%7B%22x%22%3A519.5305%2C%22y%22%3A96.96076%2C%22width%22%3A31.716600000000085%2C%22height%22%3A24.78455000000001%2C%22text%22%3A%22Abl%22%7D%2C%7B%22x%22%3A35.097496%2C%22y%22%3A101.07541%2C%22width%22%3A50.082863999999994%2C%22height%22%3A18.37362999999999%2C%22text%22%3A%22uuid%22%7D%2C%7B%22x%22%3A28.598978%2C%22y%22%3A167.71324%2C%22width%22%3A435.798882%2C%22height%22%3A24.737089999999995%2C%22text%22%3A%2215resultsin15files-Openineditor%22%7D%2C%7B%22x%22%3A85.401146%2C%22y%22%3A223.99823%2C%22width%22%3A163.973474%2C%22height%22%3A30.528879999999987%2C%22text%22%3A%22package.json%22%7D%2C%7B%22x%22%3A44.734283%2C%22y%22%3A229.47353%2C%22width%22%3A29.592957000000006%2C%22height%22%3A11.546019999999999%2C%22text%22%3A%22npm%22%7D%2C%7B%22x%22%3A71.00187%2C%22y%22%3A269.1899%2C%22width%22%3A174.92923%2C%22height%22%3A23.32556999999997%2C%22text%22%3A%22uuid%5C%22%3A%5C%227.0.3%5C%22%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22SEARCH%20*%20Aa%20Abl%20uuid%2015resultsin15files-Openineditor%20package.json%20npm%20uuid%5C%22%3A%5C%227.0.3%5C%22%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A308%2C%22height%22%3A151%2C%22id%22%3A%22yiIrd%22%7D&quot;&gt;&lt;img data-height=&quot;151px&quot; data-ratio=&quot;0.4902597402597403&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UnKibSlmUib8h6VL1oK56FSAYR5QY0f3dDVkuZIib2I3Juichaeajo39ia5Qa5WbPrHAsglUbUGwjgHe4UfqtjZvyEg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;616&quot; title=&quot;uuid.jpeg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;Chrome 92新增了crypto.randomUUID()方法，用于生成符合RFC 4122 version 4规范的唯一ID。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;可惜的是，由于Firefox、Safari等其他浏览器没有支持，因此前端项目中将依然需要使用uuid模块。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;不过，Node.js 14.17.0已经支持了crypto.randomUUID()方法，而生成唯一ID通常是在后端进行，因此目测uuid模块的使用量将会有所降低。使用官方提供的API更加安全，且性能更好。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;要保证随机生成的UUID的唯一性和安全性，是一个看起来简单，但实际非常复杂的问题。图灵奖得主Donald Knuth在他的鸿篇巨制《The Art of Computer Programming》中花了一个章节来讨论随机数：&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;It is not easy to invent a foolproof source of random numbers.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;我们所熟悉的Math.random()其实名不副实，并不随机，它是一个伪随机数生成器（Pseudo Random Number Generator，简称PRNG），当我们指定同一个random_seed启动时，它生成的随机数序列是一样的！&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;node --random_seed=&lt;span class=&quot;code-snippet__number&quot;&gt;42&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Welcome to Node.js v14&lt;span class=&quot;code-snippet__number&quot;&gt;.17&lt;/span&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;.3&lt;/span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Type &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;.help&quot;&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; more information.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Math&lt;/span&gt;.random()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;0.5254990606499601&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Math&lt;/span&gt;.random()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;0.963056226312738&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;node --random_seed=&lt;span class=&quot;code-snippet__number&quot;&gt;42&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Welcome to Node.js v14&lt;span class=&quot;code-snippet__number&quot;&gt;.17&lt;/span&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;.3&lt;/span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Type &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;.help&quot;&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; more information.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Math&lt;/span&gt;.random()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;0.5254990606499601&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Math&lt;/span&gt;.random()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__number&quot;&gt;0.963056226312738&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;也就是说，只要黑客获取了random_seed，就能预测Math.random()所返回的&quot;随机序列&quot;，是不是有点可怕？&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;当然，获取random_seed并不是一件简单的事情，不过并非没有可能，因为random_seed不是随机的，而是依赖于一些内部状态，比如浏览器的启动时间、某个变量的虚拟内存地址，这些内部状态是有规律可循的。2014年，Andriod版的Firefox就曾被人破解过Math.random()。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;span&gt;因此，在对安全性要求比较高的场景中，不要使用Math.random()。&lt;/span&gt;CVE中有多个安全漏洞是与Math.random()相关。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;为了满足大家对于更加安全的加密API的需求，社区提供了很多解决方案，其中最出名的为CryptoJS。但是，对于加密这种CPU密集型应用，纯JavaScript的方案存在比较严重的性能问题，且不够安全。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;因此，2017年，W3C发布了Web Cryptography API，提供更加安全、性能更好的加密API。其中，crypto.getRandomValues()可以用于生成更加安全的随机数，它是密码学安全伪随机数生成器（Cryptographically Secure Pseudo Random Number Generator，简称CSPRNG）。其实，CSPRNG也不能生成真正的随机数，只是它可以通过一些严格的密码学测试，可以认为是安全的。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;51f50693f66baf1ce01a6330f88e7839&quot;&gt;crypto.randomUUID()是基于CSPRNG的，因此也可以认为是安全的。&lt;/p&gt;&lt;p data-lake-id=&quot;346b270359ecdd244fdaa1f36858afd3&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;a4156fd03a3b349d8aa16ede9ded4d06&quot;&gt;crypto.randomUUID()虽然放在cypto对象中，但是它还并未被纳入Web Cryptography API，因此还不是W3C标准。&lt;/p&gt;&lt;h3 data-lake-id=&quot;c52720c8c1e0172fb7ca680a89b969c5&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-lake-id=&quot;c52720c8c1e0172fb7ca680a89b969c5&quot;&gt;Canvas color management&lt;/h3&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;目前，2D canvas仅支持陈旧的sRGB色域，但是现在的屏幕和相机早就支持更大的色域了。&lt;/p&gt;&lt;p data-lake-id=&quot;21da956303b1d9a8d156c67dc2bf6ea5&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;4a0c96cf3239c96adb1866c928625585&quot;&gt;色域是什么呢？它的英文名是Color Gamut或者Color Space，是设备（显示器、投影仪、打印机）可以表达的颜色范围。人眼可见的颜色范围是有限的，而设备能表达的颜色范围是人眼可见的颜色范围的子集，而不同色域标准比如sRGB和Display P3能表达的颜色范围也不一样。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;Chrome 92支持在创建2D canvas时，使用Display P3色域，这将增强2D canvas的颜色还原能力。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;canvas.getContext(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;2d&#x27;&lt;/span&gt;, { &lt;span class=&quot;code-snippet__attr&quot;&gt;colorSpace&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;display-p3&quot;&lt;/span&gt;} );&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/pre&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;Display P3的色域比sRGB的色域大25%，当我们对比两者时，会发现Display P3要比sRGB明亮很多，区别非常明显：&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2021%2Fjpeg%2F928098%2F1626597197633-2387609e-2caf-4c26-84c2-f66df9bba5dc.jpeg%22%2C%22originWidth%22%3A1920%2C%22originHeight%22%3A1080%2C%22name%22%3A%22sRGB_vs_Display%20P3jpg.jpg%22%2C%22size%22%3A317566%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22ocrLocations%22%3A%5B%7B%22x%22%3A1269.397%2C%22y%22%3A960.95935%2C%22width%22%3A340.9797000000001%2C%22height%22%3A70.90105000000005%2C%22text%22%3A%22DisplayP3%22%7D%2C%7B%22x%22%3A389.8314%2C%22y%22%3A971.4579%2C%22width%22%3A174.87640000000005%2C%22height%22%3A53.52499999999998%2C%22text%22%3A%22SRGB%22%7D%5D%2C%22style%22%3A%22none%22%2C%22search%22%3A%22DisplayP3%20SRGB%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A480%2C%22height%22%3A270%2C%22id%22%3A%22rmkeH%22%7D&quot;&gt;&lt;img data-height=&quot;270px&quot; data-ratio=&quot;0.5626666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UnKibSlmUib8h6VL1oK56FSAYR5QY0f3dDhCOGwuyTXAxbwxich3BJFnlhWLc7mVIVncavFu4IicqySzLzFssCHibbA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1500&quot; title=&quot;sRGB_vs_Display P3jpg.jpg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;图片来源：Get Started with Display P3&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;span&gt;对于图像、视频、设计、游戏、地图、外卖、电商等应用，准确还原颜色的重要性不言而喻&lt;/span&gt;。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;大多数情况下，买家秀和卖家秀的明显差异是由于卖家过度PS导致的，但是也有可能是颜色没有得到准确还原导致的。&lt;/p&gt;&lt;h3 data-lake-id=&quot;1eab0fba397f46ead93f4c3e8c9751c0&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-lake-id=&quot;1eab0fba397f46ead93f4c3e8c9751c0&quot;&gt;Web Bluetooth manufacturer data filter&lt;/h3&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;早在6年前，Chrome就开始开发Web Bluetooth了，不过直到今天，Web Bluetooth也没有成为W3C标准，Safari和Firefox也没有支持Web Bluetooth，这就有点尴尬了。&lt;/p&gt;&lt;p data-lake-id=&quot;e0b33ae1135656caa4d7bbc7ec4897a5&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;510d8be2365cf3b900b008f291b30360&quot;&gt;&lt;span&gt;Chrome以一己之力推动了众多Web技术标准的进步，但是从Web Bluetooth也可以看出，其过程还是比较艰辛的，需要时间和耐心。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;不过，为了让Web可以获得原生应用一样的能力，Chrome也不会放弃Web Bluetooth。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;使用Web Bluetooth，Web应用也可以连接并控制各种蓝牙设备，比如彩灯、玩具车、LED、无人机，还是很有意思的：&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p/&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;视频来源：WebBluetooth demos for Bluetooth.rocks&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;Chrome 92为Web Bluetooth新增了按照蓝牙设备的制造商来过滤蓝牙设备的能力。这样，对于一些针对特定产商的Web应用，就可以只给用户展示对应产商的蓝牙设备。&lt;/p&gt;&lt;h1 data-lake-id=&quot;e0ff11f66e8207127bf9c4be254c79c2&quot;&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1 data-lake-id=&quot;e0ff11f66e8207127bf9c4be254c79c2&quot;&gt;总结&lt;/h1&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;本篇是《了不起的Chrome浏览器》的第4篇，坚持更新这个系列的博客还是挺难的，一方面工作太忙了，另一方面Chrome 92可以写的内容确实不多，我也不是很熟悉，需要很多时间挖掘。但是，不管怎样，我还是会坚持写下去，因为每次都能学到一些新的东西。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;写博客的过程中，我会阅读大量的参考资料，并且记录阅读笔记，所以我阅读的时间是远远大于写作的时间的。如果不是为了写作，我并不会对某一个知识点进行深究，&lt;span&gt;这也是写作最大的好处，通过输入倒逼输出，倒逼自己进行深度学习&lt;/span&gt;。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;对于比较权威，内容很有启发的参考资料，我都会列到文章后面。这样既是对作者版权的尊重，也是方便自己和读者去阅读相关资料。某个知识点真正优质的内容是非常稀缺的，要找到这些资料是需要一些Google技巧的：准确变换不同的搜索关键词，不断递归地挖掘最原始、最权威的第一手资料。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;另外，我写博客都不是几个小时或者几天时间写完的，长篇的博客写作时间长达一个月，所以改动会很频繁，整个写作过程语雀都会有修改记录。这样写看起来很累，但是其实是把一个大的任务拆分成了一个个小任务，反而轻松很多。另外，每一次写都会有一些新的发现、新的灵感，这对于写作也是非常有帮助的。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;欢迎关注寒雁Talk公众号，关注《了不起的Chrome浏览器》系列博客，与我一起见证大前端的星辰大海！&lt;/p&gt;&lt;h1 data-lake-id=&quot;66e83f284b44207f4edb9c154b825666&quot;&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1 data-lake-id=&quot;66e83f284b44207f4edb9c154b825666&quot;&gt;参考资料&lt;/h1&gt;&lt;p data-lake-id=&quot;4b8cf913d96df71dd5bbba164fdbd7ff&quot;&gt;&lt;/p&gt;&lt;ul data-lake-id=&quot;a49861708177b3fa3e4972a9e227ecbf&quot; start=&quot;1&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjI2OTI0Nw==&amp;amp;mid=2247483736&amp;amp;idx=1&amp;amp;sn=48b87e3902fe8f6752aae18b9fe2a18d&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;了不起的Chrome浏览器（1）：Chrome 89开启Web应用的物联网时代&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjI2OTI0Nw==&amp;amp;mid=2247483765&amp;amp;idx=1&amp;amp;sn=cebe653e89518574a785c32b6aad88aa&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;了不起的Chrome浏览器（2）：Chrome 90将默认使用HTTPS，Web更安全了&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjI2OTI0Nw==&amp;amp;mid=2247483785&amp;amp;idx=1&amp;amp;sn=e66890ec12bc3f9ffa88e8712283abbc&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;了不起的Chrome浏览器（3）：Chrome 91支持WebAssembly SIMD，加&lt;/a&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI4NjI2OTI0Nw==&amp;amp;mid=2247483785&amp;amp;idx=1&amp;amp;sn=e66890ec12bc3f9ffa88e8712283abbc&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-linktype=&quot;2&quot;&gt;Web在AI等领域的应用&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Chrome 92: Web Apps as File Handlers, New JavaScript Features, and More&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;V8 release v9.2&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;at method for relative indexing&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;crypto.randomUUID is three times faster uuid.v4&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Overtaking Firefox Profiles: Vulnerabilities in Firefox for Android&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;TIFU by using Math.random()&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;A Brief History of Random Numbers&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;[V8 Deep Dives] Random Thoughts on Math.random()&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;《Art of Computer Programming, Volume 2: Seminumerical Algorithms, 3rd Edition》Chapter 3: Random Numbers&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Securing JavaScript applications with the Web Cryptography API&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Update on Web Cryptography&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Get Started with Display P3&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Improving Color on the Web&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Pixar in a Box: Color science&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;An Introduction To WebBluetooth&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;WebBluetooth demos for Bluetooth.rocks&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-lake-id=&quot;876710649adfccbc2696bad88f733ccb&quot;&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1 data-lake-id=&quot;876710649adfccbc2696bad88f733ccb&quot;&gt;招聘&lt;/h1&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;阿里巴巴业务平台事业部长期招聘P6及以上前端大佬，参与建设最前沿的阿里前端生态系统，推动行业技术发展，内推地址：hanyan.lk@alibaba-inc.com&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;欢迎大家关注我的微信公众号寒雁Talk。&lt;/p&gt;&lt;p data-lake-id=&quot;da7032b39bddef89519c381ca7ae23b8&quot;&gt;&lt;span data-card-type=&quot;inline&quot; data-lake-card=&quot;image&quot; data-card-value=&quot;data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2021%2Fwebp%2F928098%2F1619341927214-9586185e-dfc0-4bf1-a2b8-222f7059c1bd.webp%22%2C%22originWidth%22%3A1080%2C%22originHeight%22%3A394%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22style%22%3A%22none%22%2C%22search%22%3A%22%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22width%22%3A540%2C%22height%22%3A197%2C%22id%22%3A%22pfcLA%22%7D&quot;&gt;&lt;img data-height=&quot;197px&quot; data-ratio=&quot;0.3648148148148148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/UnKibSlmUib8h6VL1oK56FSAYR5QY0f3dDzLPm5ibCBjlHgrQYNjjL7OQ02gicezTDy8SUt9MibmxLhWQ2VI2TZKz3A/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1080&quot; title=&quot;image&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ea1f9a1bf5e2c124ecd19d17b8d5dc39</guid>
<title>前端单元测试技术方案总结</title>
<link>https://toutiao.io/k/7iqle6u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.00703125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KV8By3euEQhZYTauMbrpamMgft7MXkV3icjnWU3XfYR2IN32GOkuaEa93kR5muQNzujot0JBJKjp49QnU7Oiaelw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本文作者: &lt;span&gt;江水&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要介绍前端&lt;strong&gt;单元测试&lt;/strong&gt;的一些技术方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单元测试的技术方案很多，不同工具之间有互相协同，也存在功能重合，给我们搭配测试方案带来不小的困难，而且随着 &lt;code&gt;ES6&lt;/code&gt;, &lt;code&gt;TypeScript&lt;/code&gt; 的出现，单元测试又增加了很多其他步骤，完整配置起来往往需要很大的时间成本。我希望通过对这些工具的各自作用的掌握，了解完整的前端测试技术方案。前端单元测试的领域也很多，这里主要讲对于前端组件如何进行单元测试，最后会主要介绍下对于 &lt;code&gt;React&lt;/code&gt; 组件的一些测试方法总结。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;通用测试&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单元测试最核心的部分就是做断言，比如传统语言中的 &lt;code&gt;assert&lt;/code&gt; 函数，如果当前程序的某种状态符合 &lt;code&gt;assert&lt;/code&gt; 的期望此程序才能正常执行，否则直接退出应用。所以我们可以直接用 &lt;code&gt;Node&lt;/code&gt; 中自带的 &lt;code&gt;assert&lt;/code&gt; 模块做断言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用最简单的例子做个验证&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;multiple&lt;/span&gt;(&lt;span&gt;a, b&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; result = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b; ++i)&lt;br/&gt;        result += a;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; assert = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;assert&#x27;&lt;/span&gt;);&lt;br/&gt;assert.equal(multiple(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;), &lt;span&gt;3&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种例子能够满足基础场景的使用，也可以作为一种单元测试的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;nodejs&lt;/code&gt; 自带的 &lt;code&gt;assert&lt;/code&gt; 模块提供了下面一些断言方法，只能满足一些简单场景的需要。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;assert.deepEqual(actual, expected[, message])&lt;br/&gt;assert.deepStrictEqual(actual, expected[, message])&lt;br/&gt;assert.doesNotMatch(string, regexp[, message])&lt;br/&gt;assert.doesNotReject(asyncFn[, error][, message])&lt;br/&gt;assert.doesNotThrow(fn[, error][, message])&lt;br/&gt;assert.equal(actual, expected[, message])&lt;br/&gt;assert.fail([message])&lt;br/&gt;assert.ifError(value)&lt;br/&gt;assert.match(string, regexp[, message])&lt;br/&gt;assert.notDeepEqual(actual, expected[, message])&lt;br/&gt;assert.notDeepStrictEqual(actual, expected[, message])&lt;br/&gt;assert.notEqual(actual, expected[, message])&lt;br/&gt;assert.notStrictEqual(actual, expected[, message])&lt;br/&gt;assert.ok(value[, message])&lt;br/&gt;assert.rejects(asyncFn[, error][, message])&lt;br/&gt;assert.strictEqual(actual, expected[, message])&lt;br/&gt;assert.throws(fn[, error][, message])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自带的 &lt;code&gt;assert&lt;/code&gt; 不是专门给单元测试使用, 提供的错误信息文档性不好，上面的 &lt;code&gt;demo&lt;/code&gt; 最终执行下来会产生下面的报告:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ node index.js&lt;br/&gt;assert.js:84&lt;br/&gt;  throw new AssertionError(obj);&lt;br/&gt;  ^&lt;br/&gt;&lt;br/&gt;AssertionError [ERR_ASSERTION]: 2 == 3&lt;br/&gt;    at Object.&amp;lt;anonymous&amp;gt; (/home/quanwei/git/index.js:4:8)&lt;br/&gt;    at Module._compile (internal/modules/cjs/loader.js:778:30)&lt;br/&gt;    at Object.Module._extensions..js (internal/modules/cjs/loader.js:789:10)&lt;br/&gt;    at Module.load (internal/modules/cjs/loader.js:653:32)&lt;br/&gt;    at tryModuleLoad (internal/modules/cjs/loader.js:593:12)&lt;br/&gt;    at Function.Module._load (internal/modules/cjs/loader.js:585:3)&lt;br/&gt;    at Function.Module.runMain (internal/modules/cjs/loader.js:831:12)&lt;br/&gt;    at startup (internal/bootstrap/node.js:283:19)&lt;br/&gt;    at bootstrapNodeJSCore (internal/bootstrap/node.js:623:3)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于自带的模块依赖 &lt;code&gt;Node&lt;/code&gt; 自身的版本，没办法自由升级，所以使用内置的包灵活性有时候不太够，另外我们很多断言函数也需要在浏览器端执行，所以我们需要同时支持浏览器和 &lt;code&gt;Node&lt;/code&gt; 端的断言库。同时观察上面的输出可以发现，这个报告更像是程序的错误报告，而不是一个单元测试报告。而我们在做单元测时往往需要断言库能够提供良好的测试报告，这样才能一目了然地看到有哪些断言通过没通过，所以使用专业的单元测试断言库还是很有必要。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;chai&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4000744324525493&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQhZYTauMbrpamMgft7MXkV33b7975QDrWQCSnPO5oglyBGEoczzDpYJ9vyfibQTicqOnWCodIwrJF8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2687&quot;/&gt;&lt;figcaption&gt;chai&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;chai&lt;/code&gt; 是目前很流行的断言库，相比于同类产品比较突出。&lt;code&gt;chai&lt;/code&gt; 提供了 &lt;span&gt;TDD&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt; (Test-driven development）和 &lt;span&gt;BDD&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt; (Behavior-driven development) 两种风格的断言函数，这里不会过多介绍两种风格的优缺，本文主要以 &lt;code&gt;BDD&lt;/code&gt; 风格做演示。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;TDD 风格的 chai&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; assert = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;chai&#x27;&lt;/span&gt;).assert&lt;br/&gt;  , foo = &lt;span&gt;&#x27;bar&#x27;&lt;/span&gt;&lt;br/&gt;  , beverages = { &lt;span&gt;tea&lt;/span&gt;: [ &lt;span&gt;&#x27;chai&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;matcha&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;oolong&#x27;&lt;/span&gt; ] };&lt;br/&gt;&lt;br/&gt;assert.typeOf(foo, &lt;span&gt;&#x27;string&#x27;&lt;/span&gt;); &lt;span&gt;// without optional message&lt;/span&gt;&lt;br/&gt;assert.typeOf(foo, &lt;span&gt;&#x27;number&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;foo is a number&#x27;&lt;/span&gt;); &lt;span&gt;// with optional message&lt;/span&gt;&lt;br/&gt;assert.equal(foo, &lt;span&gt;&#x27;bar&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;foo equal `bar`&#x27;&lt;/span&gt;);&lt;br/&gt;assert.lengthOf(foo, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;&#x27;foo`s value has a length of 3&#x27;&lt;/span&gt;);&lt;br/&gt;assert.lengthOf(beverages.tea, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;&#x27;beverages has 3 types of tea&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;chai&lt;/code&gt; 比 &lt;code&gt;Node&lt;/code&gt; 自带的 &lt;code&gt;assert&lt;/code&gt; 增加了一个断言说明参数，可以通过这个参数提高测试报告的可读性&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ node chai-assert.js&lt;br/&gt;&lt;br/&gt;/home/quanwei/git/learn-tdd-bdd/node_modules/chai/lib/chai/assertion.js:141&lt;br/&gt;      throw new AssertionError(msg, {&lt;br/&gt;      ^&lt;br/&gt;AssertionError: foo is a number: expected &lt;span&gt;&#x27;bar&#x27;&lt;/span&gt; to be a number&lt;br/&gt;    at Object.&amp;lt;anonymous&amp;gt; (/home/quanwei/git/learn-tdd-bdd/chai-assert.js:6:8)&lt;br/&gt;    at Module._compile (internal/modules/cjs/loader.js:778:30)&lt;br/&gt;    at Object.Module._extensions..js (internal/modules/cjs/loader.js:789:10)&lt;br/&gt;    at Module.load (internal/modules/cjs/loader.js:653:32)&lt;br/&gt;    at tryModuleLoad (internal/modules/cjs/loader.js:593:12)&lt;br/&gt;    at Function.Module._load (internal/modules/cjs/loader.js:585:3)&lt;br/&gt;    at Function.Module.runMain (internal/modules/cjs/loader.js:831:12)&lt;br/&gt;    at startup (internal/bootstrap/node.js:283:19)&lt;br/&gt;    at bootstrapNodeJSCore (internal/bootstrap/node.js:623:3)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;BDD 风格的 chai&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;chai&lt;/code&gt; 的 &lt;code&gt;BDD&lt;/code&gt; 风格使用 &lt;code&gt;expect&lt;/code&gt; 函数作为语义的起始，也是目前几乎所有 &lt;code&gt;BDD&lt;/code&gt; 工具库都遵循的风格。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;chai&lt;/code&gt; 的 &lt;code&gt;expect&lt;/code&gt; 断言风格如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;expect(foo).to.be.a(&lt;span&gt;&#x27;string&#x27;&lt;/span&gt;);&lt;br/&gt;expect(foo).to.equal(&lt;span&gt;&#x27;bar&#x27;&lt;/span&gt;);&lt;br/&gt;expect(foo).to.have.lengthOf(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;BDD&lt;/code&gt; 的思想就是写单元测试就像写产品需求，而不关心内部逻辑，每一个用例阅读起来就像一篇文档。例如下面的用例：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;foo 是一个字符串              -&amp;gt;&lt;code&gt;expect(foo).to.be.a(&#x27;string&#x27;)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;foo 字符串里包含 &#x27;bar&#x27;     -&amp;gt;&lt;code&gt;expect(foo).to.include(&#x27;bar&#x27;)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;foo 字符串里不包含 &#x27;biz&#x27;  -&amp;gt; &lt;code&gt;expect(foo).to.not.include(&#x27;biz&#x27;)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到这种风格的测试用例可读性更强。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他的断言库还有 &lt;code&gt;expect.js&lt;/code&gt; &lt;code&gt;should.js&lt;/code&gt; &lt;span&gt;better-assert&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt; , &lt;span&gt;unexpected.js&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt; 这些断言库都只提供纯粹的断言函数，可以根据喜好选择不同的库使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了断言库之后我们还需要使用测试框架将我们的断言更好地组织起来。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;mocha 和 Jasmine&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4188262195121951&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQhZYTauMbrpamMgft7MXkV3wLnQa5ryeJqMPPuGVkMBkOkCqD24qbUZH1q5VdS6lFHzV5k1nC8vwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2624&quot;/&gt;&lt;figcaption&gt;mocha jasmine&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;mocha&lt;/code&gt; 是一个经典的测试框架(Test Framework)，测试框架提供了一个单元测试的骨架，可以将不同子功能分成多个文件，也可以对一个子模块的不同子功能再进行不同的功能测试，从而生成一份结构型的测试报告。例如 &lt;code&gt;mocha&lt;/code&gt; 就提供了&lt;code&gt;describe&lt;/code&gt; 和 &lt;code&gt;it&lt;/code&gt; 描述用例结构，提供了 &lt;code&gt;before&lt;/code&gt;, &lt;code&gt;after&lt;/code&gt;, &lt;code&gt;beforeEach&lt;/code&gt;, &lt;code&gt;afterEach&lt;/code&gt; 生命周期函数，提供了 &lt;code&gt;describe.only&lt;/code&gt; ,&lt;code&gt;describe.skip&lt;/code&gt; , &lt;code&gt;it.only&lt;/code&gt;, &lt;code&gt;it.skip&lt;/code&gt; 用以执行指定部分测试集。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; { expect } = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;chai&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; { multiple } = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;./index&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;describe(&lt;span&gt;&#x27;Multiple&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;    it (&lt;span&gt;&#x27;should be a function&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;        expect(multiple).to.be.a(&lt;span&gt;&#x27;function&#x27;&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;&lt;br/&gt;    it (&lt;span&gt;&#x27;expect 2 * 3 = 6&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;        expect(multiple(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;)).to.be.equal(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试框架不依赖底层的断言库，哪怕使用原生的 &lt;code&gt;assert&lt;/code&gt; 模块也可以进行。给每一个文件都要手动引入 &lt;code&gt;chai&lt;/code&gt; 比较麻烦 ，这时候可以给 &lt;code&gt;mocha&lt;/code&gt; 配置全局脚本，在项目根目录 &lt;code&gt;.mocharc.js&lt;/code&gt; 文件中加载断言库, 这样每个文件就可以直接使用 &lt;code&gt;expect&lt;/code&gt; 函数了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// .mocharc.js&lt;/span&gt;&lt;br/&gt;global.expect = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;chai&#x27;&lt;/span&gt;).expect;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 mocha 可以将我们的单元测试输出成一份良好的测试报告 &lt;code&gt;mocha *.test.js&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3337969401947149&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQhZYTauMbrpamMgft7MXkV3yrCp19zdvz9gFa8J3xDvrALTdp42aYhnT1ibxxHwojPr22NKPWoAjHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1438&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当出现错误时输出如下&lt;img data-ratio=&quot;0.5314091680814941&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQhZYTauMbrpamMgft7MXkV3yAwX12uvlhsEkfrzcZNgEZqpsvMXXh9rEPXepaDeYgOzlwux9UQTqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1767&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为运行在不同环境中需要的包格式不同，所以需要我们针对不同环境做不同的包格式转换，为了了解在不同端跑单元测试需要做哪些事情，可以先来了解一下常见的包格式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前我们主流有三种模块格式，分别是 &lt;code&gt;AMD&lt;/code&gt;, &lt;code&gt;CommonJS&lt;/code&gt;, &lt;code&gt;ES Module&lt;/code&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;AMD&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;AMD&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt; 是 &lt;code&gt;RequireJS&lt;/code&gt; 推广过程中流行的一个比较老的规范，目前无论浏览器还是 &lt;code&gt;Node&lt;/code&gt; 都没有默认支持。&lt;code&gt;AMD&lt;/code&gt; 的标准定义了 &lt;code&gt;define&lt;/code&gt; 和 &lt;code&gt;require&lt;/code&gt;函数，&lt;code&gt;define&lt;/code&gt;用来定义模块及其依赖关系，&lt;code&gt;require&lt;/code&gt; 用以加载模块。例如&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;!doctype html&amp;gt;&lt;br/&gt;&amp;lt;html lang=&quot;en&quot;&amp;gt;&lt;br/&gt;    &amp;lt;head&amp;gt;&lt;br/&gt;        &amp;lt;meta charset=&quot;UTF-8&quot;/&amp;gt;&lt;br/&gt;        &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;&lt;br/&gt;&lt;span&gt;+        &amp;lt;script&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+   src=&quot;https://requirejs.org/docs/release/2.3.6/minified/require.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+        &amp;lt;script src=&quot;./index.js&quot; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;    &amp;lt;body&amp;gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&amp;lt;/html&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// index.js&lt;/span&gt;&lt;br/&gt;define(&lt;span&gt;&#x27;moduleA&#x27;&lt;/span&gt;, [&lt;span&gt;&#x27;https://some/of/cdn/path&#x27;&lt;/span&gt;], &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; { &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;moduleA&#x27;&lt;/span&gt; };&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;define(&lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;require&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; fs = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;fs&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; fs;&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;define(&lt;span&gt;&#x27;moduleB&#x27;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; { &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;module B&#x27;&lt;/span&gt; }&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;&lt;span&gt;require&lt;/span&gt;([&lt;span&gt;&#x27;moduleA&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;moduleB&#x27;&lt;/span&gt;], &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;moduleA, moduleB&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;module&lt;/span&gt;);&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里使用了&lt;code&gt;RequireJS&lt;/code&gt; 作为 &lt;code&gt;AMD&lt;/code&gt; 引擎, 可以看到 &lt;code&gt;define&lt;/code&gt; 函数会定义当前依赖了哪些模块并将模块加载完成后异步回调给当前模块，这种特性使得 AMD 尤为适合浏览器端异步加载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用 &lt;code&gt;webpack&lt;/code&gt; 打包一份 &lt;code&gt;amd&lt;/code&gt; 模块看下真实代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// entry.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;sayHello&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&#x27;hello amd&#x27;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// webpack.config.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = {&lt;br/&gt;    &lt;span&gt;mode&lt;/span&gt;: &lt;span&gt;&#x27;development&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;devtool&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;entry&lt;/span&gt;: &lt;span&gt;&#x27;./entry.js&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;output&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;libraryTarget&lt;/span&gt;: &lt;span&gt;&#x27;amd&#x27;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终生成代码(精简了不相关的逻辑)&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// dist/main.js&lt;/span&gt;&lt;br/&gt;define(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; ({&lt;br/&gt;    &lt;span&gt;default&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;sayHello&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&#x27;hello amd&#x27;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在浏览器/&lt;code&gt;Node&lt;/code&gt; 中想要使用 &lt;code&gt;AMD&lt;/code&gt; 需要全局引入 &lt;code&gt;RequireJS&lt;/code&gt;，对单元测试而言比较典型的问题是在初始化 &lt;code&gt;karma&lt;/code&gt; 时会询问是否使用 &lt;code&gt;RequireJS&lt;/code&gt; ，不过一般现在很少有人使用了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;CommonJS&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以缩写成&lt;code&gt;CJS&lt;/code&gt; , 其 &lt;span&gt;规范 &lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;主要是为了定义 &lt;code&gt;Node&lt;/code&gt; 的包格式，&lt;code&gt;CJS&lt;/code&gt; 定义了三个关键字, 分别为 &lt;code&gt;require&lt;/code&gt;，&lt;code&gt;exports&lt;/code&gt;, &lt;code&gt;module&lt;/code&gt;, 目前几乎所有&lt;code&gt;Node&lt;/code&gt; 包以及前端相关的&lt;code&gt;NPM&lt;/code&gt;包都会转换成该格式, &lt;code&gt;CJS&lt;/code&gt; 在浏览器端需要使用 &lt;code&gt;webpack&lt;/code&gt; 或者 &lt;code&gt;browserify&lt;/code&gt; 等工具打包后才能执行。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ES Module&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ES Module&lt;/code&gt; 是 &lt;code&gt;ES 2015&lt;/code&gt; 中定义的一种模块规范，该规范定义了 代表为 &lt;code&gt;import&lt;/code&gt; 和 &lt;code&gt;export&lt;/code&gt; ，是我们开发中常用的一种格式。虽然目前很多新版浏览器都支持&lt;code&gt;&amp;lt;script type=&quot;module&quot;&amp;gt;&lt;/code&gt; 了，支持在浏览器中直接运行 &lt;code&gt;ES6&lt;/code&gt; 代码，但是浏览器不支持 &lt;code&gt;node_modules&lt;/code&gt; ，所以我们的原始 &lt;code&gt;ES6&lt;/code&gt; 代码在浏览器上依然无法运行，所以这里我暂且认为浏览器不支持 &lt;code&gt;ES6&lt;/code&gt; 代码, 依然需要做一次转换。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下表为每种格式的支持范围，括号内表示需要借助外部工具支持。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;br/&gt;&lt;/th&gt;&lt;th&gt;Node&lt;/th&gt;&lt;th&gt;浏览器&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;AMD&lt;/td&gt;&lt;td&gt;不支持(require.js, r.js)&lt;/td&gt;&lt;td&gt;不支持(require.js)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CommonJS&lt;/td&gt;&lt;td&gt;&lt;strong&gt;支持&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;不支持(webpack/browserify)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ESModule&lt;/td&gt;&lt;td&gt;不支持(babel)&lt;/td&gt;&lt;td&gt;不支持(webpack)&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单元测试要在不同的环境下执行就要打不同环境对应的包，所以在搭建测试工具链时要确定自己运行在什么环境中，如果在 &lt;code&gt;Node&lt;/code&gt; 中只需要加一层 &lt;code&gt;babel&lt;/code&gt; 转换，如果是在真实浏览器中，则需要增加 &lt;code&gt;webpack&lt;/code&gt; 处理步骤。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以为了能够在 &lt;code&gt;Node&lt;/code&gt; 环境的 &lt;code&gt;Mocha&lt;/code&gt;中使用 &lt;code&gt;ES Module&lt;/code&gt; 有两种方式&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Node&lt;/code&gt; 环境天生支持 &lt;code&gt;ES Module&lt;/code&gt; (node version &amp;gt;= 15)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 &lt;code&gt;babel&lt;/code&gt; 代码进行一次转换&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一种方式略过，第二种方式使用下面的配置&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install @babel/register @babel/core @babel/preset-env --save-dev&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// .mocharc.js&lt;br/&gt;&lt;span&gt;+ require(&#x27;@babel/register&#x27;);&lt;/span&gt;&lt;br/&gt;global.expect = require(&#x27;chai&#x27;).expect;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// .babelrc&lt;br/&gt;&lt;span&gt;+ {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+    &quot;presets&quot;: [&quot;@babel/preset-env&quot; ，“@babel/preset-typescript”]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+ }&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样地如果在项目中用到了 &lt;code&gt;TypeScript&lt;/code&gt;, 就可以使用&lt;code&gt;ts-node/register&lt;/code&gt; 来解决，因为 &lt;code&gt;TypeScript&lt;/code&gt;本身支持 &lt;code&gt;ES Module&lt;/code&gt; 转换成 &lt;code&gt;CJS&lt;/code&gt;, 所以支持了 &lt;code&gt;TypeScript&lt;/code&gt;后就不需要使用 &lt;code&gt;babel&lt;/code&gt; 来转换了。(这里假设使用了 &lt;code&gt;TypeScript&lt;/code&gt; 的默认配置)&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install ts-node typescript --save-dev&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// .mocharc.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;ts-node/register&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Mocha&lt;/code&gt; 自身支持浏览器和 &lt;code&gt;Node&lt;/code&gt; 端测试，为了在浏览器端测试我们需要写一个 html, 里面使用 &lt;code&gt;&amp;lt;script src=&quot;mocha.min.js&quot;&amp;gt;&lt;/code&gt; 的文件，然后再将本地所有文件插入到html中才能完成测试，手动做工程化效率比较低，所以需要借助工具来实现这个任务，这个工具就是 &lt;code&gt;Karma&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Karma&lt;/code&gt; 本质上就是在本地启动一个web服务器，然后再启动一个外部浏览器加载一个引导脚本，这个脚本将我们所有的源文件和测试文件加载到浏览器中，最终就会在浏览器端执行我们的测试用例代码。所以使用 &lt;code&gt;Karma&lt;/code&gt; + &lt;code&gt;mocha&lt;/code&gt; +&lt;code&gt;chai&lt;/code&gt; 即可搭建一个完整的浏览器端的单元测试工具链。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install karma mocha chai karma-mocha karma-chai --save-dev&lt;br/&gt;npx karma init&lt;br/&gt;// Which testing framework do you want to use: mocha&lt;br/&gt;// Do you want to use Require.js: no&lt;br/&gt;// Do you want capture any browsers automatically: Chrome&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里 &lt;code&gt;Karma&lt;/code&gt; 初始化时选择了 &lt;code&gt;Mocha&lt;/code&gt; 的支持，然后第二个 &lt;code&gt;Require.js&lt;/code&gt; 一般为否，除非业务代码中使用了&lt;code&gt;amd&lt;/code&gt;类型的包。第三个选用 &lt;code&gt;Chrome&lt;/code&gt; 作为测试浏览器。然后再在代码里单独配置下 &lt;code&gt;chai&lt;/code&gt; 。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// karma.conf.js&lt;br/&gt;module.exports = function(config) {&lt;br/&gt;  config.set({&lt;br/&gt;&lt;br/&gt;    // base path that will be used to resolve all patterns (eg. files, exclude)&lt;br/&gt;    basePath: &#x27;&#x27;,&lt;br/&gt;&lt;br/&gt;    // frameworks to use&lt;br/&gt;    // available frameworks: https://npmjs.org/browse/keyword/karma-adapter&lt;br/&gt;&lt;span&gt;-    frameworks: [&#x27;mocha&#x27;],&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+    frameworks: [&#x27;mocha&#x27;, &#x27;chai&#x27;],&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    // list of files / patterns to load in the browser&lt;br/&gt;    files: [],&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Karma&lt;/code&gt; 的 &lt;code&gt;frameworks&lt;/code&gt; 作用是在全局注入一些依赖，这里的配置就是将 &lt;code&gt;Mocha&lt;/code&gt; 和 &lt;code&gt;chai&lt;/code&gt; 提供的测试相关工具暴露在全局上供代码里使用。&lt;code&gt;Karma&lt;/code&gt; 只是将我们的文件发送到浏览器去执行，但是根据前文所述我们的代码需要经过 &lt;code&gt;webpack&lt;/code&gt; 或 &lt;code&gt;browserify&lt;/code&gt; 打包后才能运行在浏览器端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果原始代码已经是 &lt;code&gt;CJS&lt;/code&gt;了，可以使用 &lt;code&gt;browserify&lt;/code&gt; 来支持浏览器端运行，基本零配置，但是往往现实世界比较复杂，我们有 &lt;code&gt;ES6&lt;/code&gt;，&lt;code&gt;JSX&lt;/code&gt; 以及 &lt;code&gt;TypeScript&lt;/code&gt; 要处理，所以这里我们使用 &lt;code&gt;webpack&lt;/code&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是 &lt;code&gt;webpack&lt;/code&gt; 的配置信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install karma-webpack@4 webpack@4 @babel/core @babel/preset-env @babel/preset-react babel-loader --save-dev&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// karma.conf.js&lt;br/&gt;module.exports = function(config) {&lt;br/&gt;  config.set({&lt;br/&gt;&lt;br/&gt;    // base path that will be used to resolve all patterns (eg. files, exclude)&lt;br/&gt;    basePath: &#x27;&#x27;,&lt;br/&gt;&lt;br/&gt;    // frameworks to use&lt;br/&gt;    // available frameworks: https://npmjs.org/browse/keyword/karma-adapter&lt;br/&gt;    frameworks: [&#x27;mocha&#x27;, &#x27;chai&#x27;],&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    // list of files / patterns to load in the browser&lt;br/&gt;    files: [&lt;br/&gt;&lt;span&gt;+      { pattern: &quot;test/*.test.js&quot;, watched: false }&lt;/span&gt;&lt;br/&gt;    ],&lt;br/&gt;&lt;br/&gt;    preprocessors: {&lt;br/&gt;&lt;span&gt;+      &#x27;test/**/*.js&#x27;: [ &#x27;webpack&#x27;]&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;&lt;br/&gt;&lt;span&gt;+    webpack: {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+       module: {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+   rules: [{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+           test: /.*\.js/,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+           use: &#x27;babel-loader&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+         }]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+     }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+    },&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// .babelrc&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;&quot;presets&quot;&lt;/span&gt;: [&lt;span&gt;&quot;@babel/preset-env&quot;&lt;/span&gt;, &lt;span&gt;&quot;@babel/preset-react&quot;&lt;/span&gt;]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们测试一个&lt;code&gt;React&lt;/code&gt; 程序代码如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// js/index.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; React &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; ReactDOM &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react-dom&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;renderToPage&lt;/span&gt;(&lt;span&gt;str&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; container = &lt;span&gt;document&lt;/span&gt;.createElement(&lt;span&gt;&#x27;div&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;document&lt;/span&gt;.body.appendChild(container);&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;there is real browser&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;&lt;span&gt;resolve&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        ReactDOM.render(&lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;{ str } &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;, container, resolve);&lt;br/&gt;    });&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// test/index.test.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { renderToPage } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;../js/index&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;describe(&lt;span&gt;&#x27;renderToPage&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;    it (&lt;span&gt;&#x27;should render to page&#x27;&lt;/span&gt;, &lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; content = &lt;span&gt;&#x27;magic string&#x27;&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;await&lt;/span&gt; renderToPage(content);&lt;br/&gt;        expect(&lt;span&gt;document&lt;/span&gt;.documentElement.innerText).to.be.contain(content);&lt;br/&gt;    })&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.28008407777193906&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQhZYTauMbrpamMgft7MXkV3yIVR17Kp33u07AL5tuoaq36MowPveCtpibp68o8E6SayOkndUiaIzpFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1903&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且打开了本地浏览器&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.42946708463949845&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQhZYTauMbrpamMgft7MXkV3ib5yjXImfcfyAybZ22HpMtJHTFza4OPNIzcNnoX6b3Px7ib9cxaI0a9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2233&quot;/&gt;&lt;figcaption&gt;karma browser&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到现在已经在真实浏览器中运行测试程序了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为图形化的测试对 &lt;code&gt;CI&lt;/code&gt; 机器不友好，所以可以选择 &lt;code&gt;puppeteer&lt;/code&gt; 代替 &lt;code&gt;Chrome&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再者这些都是很重的包，如果对真实浏览器依赖性不强，可以使用 &lt;code&gt;JSDOM&lt;/code&gt; 在 &lt;code&gt;Node&lt;/code&gt; 端模拟一个浏览器环境。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;稍微总结下工具链&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在 Node 环境下测试工具链可以为 : &lt;code&gt;mocha&lt;/code&gt; + &lt;code&gt;chai&lt;/code&gt; + &lt;code&gt;babel&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模拟浏览器环境可以为 : &lt;code&gt;mocha&lt;/code&gt; + &lt;code&gt;chai&lt;/code&gt; + &lt;code&gt;babel&lt;/code&gt; + &lt;code&gt;jsdom&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在真实浏览器环境下测试工具链可以为 : &lt;code&gt;karma&lt;/code&gt; + &lt;code&gt;mocha&lt;/code&gt; + &lt;code&gt;chai&lt;/code&gt; + &lt;code&gt;webpack&lt;/code&gt; + &lt;code&gt;babel&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个测试流水线往往需要很多个工具搭配使用，配置起来比较繁琐，还有一些额外的工具例如单元覆盖率（istanbul），函数/时间模拟 (sinon.js）等工具。工具之间的配合有时候不一定能够完美契合，选型费时费力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;jasmine&lt;/code&gt; 的出现就稍微缓解了一下这个问题，但也不够完整，&lt;code&gt;jasmine&lt;/code&gt;提供一个测试框架，里面包含了 测试流程框架，断言函数，mock工具等测试中会遇到的工具。可以近似地看作 &lt;code&gt;jasmine = mocha + chai + 辅助工具&lt;/code&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来试一试 &lt;code&gt;jasmine&lt;/code&gt; 的工作流程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;npx jasmine init&lt;/code&gt; 初始化之后会在当前目录中生成&lt;code&gt;spec&lt;/code&gt;目录, 其中包含一份默认的配置文件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// ./spec/support/jasmine.json&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;spec_dir&quot;&lt;/span&gt;: &lt;span&gt;&quot;spec&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;spec_files&quot;&lt;/span&gt;: [&lt;br/&gt;    &lt;span&gt;&quot;**/*[sS]pec.js&quot;&lt;/span&gt;&lt;br/&gt;  ],&lt;br/&gt;  &lt;span&gt;&quot;helpers&quot;&lt;/span&gt;: [&lt;br/&gt;    &lt;span&gt;&quot;helpers/**/*.js&quot;&lt;/span&gt;&lt;br/&gt;  ],&lt;br/&gt;  &lt;span&gt;&quot;stopSpecOnExpectationFailure&quot;&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;random&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果希望加载一些全局的配置可以在 &lt;code&gt;spec/helpers&lt;/code&gt; 目录中放一些&lt;code&gt;js&lt;/code&gt;文件, 正如配置所言，jasmine 在启动时会去执行 &lt;code&gt;spec/helpers&lt;/code&gt; 目录下的所有&lt;code&gt;js&lt;/code&gt;文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们常常使用 &lt;code&gt;es6&lt;/code&gt;语法，就需要增加&lt;code&gt;es6&lt;/code&gt;的支持。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新增 &lt;code&gt;spec/helpers/babel.js&lt;/code&gt; 写入如下配置即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install @babel/register @babel/core @babel/preset-env --save-dev&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// spec/helpers/babel.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;babel-register&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// .babelrc&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;&quot;presets&quot;&lt;/span&gt;: [&lt;span&gt;&quot;@babel/preset-env&quot;&lt;/span&gt;]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和 &lt;code&gt;mocha&lt;/code&gt; 一样，如果需要 &lt;code&gt;TypeScript&lt;/code&gt; 的支持，可以使用如下配置&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install ts-node typescript --save-dev&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// spec/helpers/typescript.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;ts-node/register&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置文件中的 &lt;code&gt;spec_dir&lt;/code&gt;是 &lt;code&gt;jasmine&lt;/code&gt;约定的用例文件目录，&lt;code&gt;spec_files&lt;/code&gt;规定了用例文件格式为 &lt;code&gt;xxx.spec.js&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这份默认配置就可以按照要求写用例，例如&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// ./spec/index.spec.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { multiple } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;../index.js&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;describe(&lt;span&gt;&#x27;Multiple&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;    it (&lt;span&gt;&#x27;should be a function&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;        expect(multiple).toBeInstanceOf(&lt;span&gt;Function&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;&lt;br/&gt;    it (&lt;span&gt;&#x27;should 7 * 2 = 14&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;        expect(multiple(&lt;span&gt;7&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;)).toEqual(&lt;span&gt;14&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;&lt;br/&gt;    it (&lt;span&gt;&#x27;should 7 * -2 = -14&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;        expect(multiple(&lt;span&gt;7&lt;/span&gt;, &lt;span&gt;-2&lt;/span&gt;)).toEqual(&lt;span&gt;-14&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;jasmine&lt;/code&gt; 的断言风格和 &lt;code&gt;chai&lt;/code&gt; 很不一样，&lt;code&gt;jasmine&lt;/code&gt; 的 &lt;code&gt;API&lt;/code&gt; 如下，与 &lt;code&gt;chai&lt;/code&gt; 相比少写了很多 &lt;code&gt;.&lt;/code&gt; ，而且支持的功能更加清晰，不用考虑如何组合使用的问题，而且下文介绍的 &lt;code&gt;jest&lt;/code&gt; 测试框架也是使用这种风格。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;nothing()&lt;br/&gt;toBe(expected)&lt;br/&gt;toBeCloseTo(expected, precisionopt)&lt;br/&gt;toBeDefined()&lt;br/&gt;toBeFalse()&lt;br/&gt;toBeFalsy()&lt;br/&gt;toBeGreaterThan(expected)&lt;br/&gt;toBeGreaterThanOrEqual(expected)&lt;br/&gt;toBeInstanceOf(expected)&lt;br/&gt;toBeLessThan(expected)&lt;br/&gt;toBeLessThanOrEqual(expected)&lt;br/&gt;toBeNaN()&lt;br/&gt;toBeNegativeInfinity()&lt;br/&gt;toBeNull()&lt;br/&gt;toBePositiveInfinity()&lt;br/&gt;toBeTrue()&lt;br/&gt;toBeTruthy()&lt;br/&gt;toBeUndefined()&lt;br/&gt;toContain(expected)&lt;br/&gt;toEqual(expected)&lt;br/&gt;toHaveBeenCalled()&lt;br/&gt;toHaveBeenCalledBefore(expected)&lt;br/&gt;toHaveBeenCalledOnceWith()&lt;br/&gt;toHaveBeenCalledTimes(expected)&lt;br/&gt;toHaveBeenCalledWith()&lt;br/&gt;toHaveClass(expected)&lt;br/&gt;toHaveSize(expected)&lt;br/&gt;toMatch(expected)&lt;br/&gt;toThrow(expectedopt)&lt;br/&gt;toThrowError(expectedopt, messageopt)&lt;br/&gt;toThrowMatching(predicate)&lt;br/&gt;withContext(message) → {matchers}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行 &lt;code&gt;jasmine&lt;/code&gt; 即可生成测试报告&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.42237061769616024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQhZYTauMbrpamMgft7MXkV3gxrWQNlATNfvnYuvHyR2WN5w2g7iabfYQqH4N5jDTxXVj9KPBM6C7Sw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1797&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认的测试报告不是很直观， 如果希望提供类似 &lt;code&gt;Mocha&lt;/code&gt; 风格的报告可以安装 &lt;code&gt;jasmine-spec-reporter&lt;/code&gt; ，在 &lt;code&gt;spec/helpers&lt;/code&gt; 目录中添加一个配置文件， 例如&lt;code&gt;spec/helpers/reporter.js&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; SpecReporter = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;jasmine-spec-reporter&#x27;&lt;/span&gt;).SpecReporter;&lt;br/&gt;&lt;br/&gt;jasmine.getEnv().clearReporters();               &lt;span&gt;// remove default reporter logs&lt;/span&gt;&lt;br/&gt;jasmine.getEnv().addReporter(&lt;span&gt;new&lt;/span&gt; SpecReporter({  &lt;span&gt;// add jasmine-spec-reporter&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;spec&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;displayPending&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时输出的用例报告如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4301449275362319&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQhZYTauMbrpamMgft7MXkV3L8pgxRCsT5mqTC0nem85ZLQJdMkpljW87RSNADvkKJAPmtsVB61OYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1725&quot;/&gt;&lt;figcaption&gt;jasmine&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在 &lt;code&gt;Jasmine&lt;/code&gt; 中执行 DOM 级别的测试，就依然需要借助 &lt;code&gt;Karma&lt;/code&gt; 或 &lt;code&gt;JSDOM&lt;/code&gt;了，具体的配置这里就不再赘述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结下 &lt;code&gt;Jasmine&lt;/code&gt; 的工具链&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Node 环境下测试 : &lt;code&gt;Jasmine&lt;/code&gt; + &lt;code&gt;babel&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;模拟 &lt;code&gt;JSDOM&lt;/code&gt; 测试 : &lt;code&gt;Jasmine&lt;/code&gt; + &lt;code&gt;JSDOM&lt;/code&gt; + &lt;code&gt;babel&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;真实浏览器测试 : &lt;code&gt;Karma&lt;/code&gt; + &lt;code&gt;Jasmine&lt;/code&gt; + &lt;code&gt;webpack&lt;/code&gt; + &lt;code&gt;babel&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;JEST&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34531081566654687&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQhZYTauMbrpamMgft7MXkV3fZJgdFmaPhvibH7ejVRGttjF1iaHyL9S4m8fGziazKNsXpquVune7cXtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2783&quot;/&gt;&lt;figcaption&gt;jest&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Jest&lt;/code&gt; 是 &lt;code&gt;facebook&lt;/code&gt; 出的一个完整的单元测试技术方案，集 测试框架, 断言库, 启动器, 快照，沙箱，mock工具于一身，也是 &lt;code&gt;React&lt;/code&gt; 官方使用的测试工具。&lt;code&gt;Jest&lt;/code&gt; 和 &lt;code&gt;Jasmine&lt;/code&gt; 具有非常相似的 &lt;code&gt;API&lt;/code&gt; ，所以在 &lt;code&gt;Jasmine&lt;/code&gt; 中用到的工具在 &lt;code&gt;Jest&lt;/code&gt; 中依然可以很自然地使用。可以近似看作 &lt;code&gt;Jest = JSDOM 启动器 + Jasmine&lt;/code&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然 Jest 提供了很丰富的功能，但是并没有内置 &lt;code&gt;ES6&lt;/code&gt; 支持，所以依然需要根据不同运行时对代码进行转换，由于 Jest 主要运行在 &lt;code&gt;Node&lt;/code&gt; 中，所以需要使用 &lt;code&gt;babel-jest&lt;/code&gt; 将 &lt;code&gt;ES Module&lt;/code&gt; 转换成 &lt;code&gt;CommonJS&lt;/code&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Jest 的默认配置&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install jest --save-dev&lt;br/&gt;npx jest --init&lt;br/&gt;√ Would you like to use Jest when running &quot;test&quot; script in &quot;package.json&quot;? ... yes&lt;br/&gt;√ Would you like to use Typescript for the configuration file? ... no&lt;br/&gt;√ Choose the test environment that will be used for testing » jsdom (browser-like)&lt;br/&gt;√ Do you want Jest to add coverage reports? ... no&lt;br/&gt;√ Which provider should be used to instrument code for coverage? » babel&lt;br/&gt;√ Automatically clear mock calls and instances between every test? ... yes&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;Node&lt;/code&gt; 或 &lt;code&gt;JSDOM&lt;/code&gt; 下增加 &lt;code&gt;ES6&lt;/code&gt;代码的支持&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install jest-babel @babel/core @babel/preset-env&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// .babelrc&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;&quot;presets&quot;&lt;/span&gt;: [&lt;span&gt;&quot;@babel/preset-env&quot;&lt;/span&gt;]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// jest.config.js&lt;br/&gt;// 下面两行为默认配置，不写也可以&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;+    testEnvironment: &quot;jsdom&quot;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+    transform: {&quot;\\.[jt]sx?$&quot;: &quot;babel-jest&quot;}&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;Jest&lt;/code&gt; 生成测试报告&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3801732435033686&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQhZYTauMbrpamMgft7MXkV3LsShvuKbtgy8UeUlu5wrNhIYhiaoqjNFyqLpFnAOxNS7pfoEPqjvBGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1039&quot;/&gt;&lt;figcaption&gt;jest&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 &lt;code&gt;React&lt;/code&gt; 和 &lt;code&gt;TypeScript&lt;/code&gt; 支持也可以通过修改 &lt;code&gt;babel&lt;/code&gt; 的配置解决&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install @babel/preset-react @babel/preset-typescript --save-dev&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// .babrlrc&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;&quot;presets&quot;&lt;/span&gt;: [&lt;span&gt;&quot;@babel/preset-env&quot;&lt;/span&gt;, &lt;span&gt;&quot;@babel/preset-react&quot;&lt;/span&gt;, &lt;span&gt;&quot;@babel/preset-typescript&quot;&lt;/span&gt;]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Jest 在真实浏览器环境下测试&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前 &lt;code&gt;Jest&lt;/code&gt; 不支持直接在真实浏览器中进行测试，其默认的启动器只提供了一个 &lt;code&gt;JSDOM&lt;/code&gt; 环境，在浏览器中进行单元测试目前只有 &lt;code&gt;Karma&lt;/code&gt; 方案能做到，所以也可以使用 &lt;code&gt;Karma&lt;/code&gt; + &lt;code&gt;Jest&lt;/code&gt; 方案实现，但是不建议这么做，因为 &lt;code&gt;Jest&lt;/code&gt; 自身太重，使用 &lt;code&gt;Karma&lt;/code&gt; + &lt;code&gt;Jasmine&lt;/code&gt; 能达到基本一样的效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外还有一个比较流行的 &lt;code&gt;E2E&lt;/code&gt; 方案 &lt;code&gt;Jest&lt;/code&gt; + &lt;code&gt;Puppeteer&lt;/code&gt; ,  由于 &lt;code&gt;E2E&lt;/code&gt;  不属于单元测试范畴，这里不再展开。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Jest&lt;/code&gt; 工具链总结&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Node 环境下测试 : &lt;code&gt;Jest&lt;/code&gt; + &lt;code&gt;babel&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;JSDOM&lt;/code&gt; 测试 : &lt;code&gt;Jest&lt;/code&gt; + &lt;code&gt;babel&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;真实浏览器测试(不推荐)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;E2E&lt;/code&gt; 测试 : &lt;code&gt;Jest&lt;/code&gt; + &lt;code&gt;Puppeteer&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;稍作总结&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的内容介绍了 &lt;code&gt;chai&lt;/code&gt; ,  &lt;code&gt;mocha&lt;/code&gt; , &lt;code&gt;karma&lt;/code&gt; , &lt;code&gt;jasmine&lt;/code&gt; 和 &lt;code&gt;jest&lt;/code&gt;, 每种工具分别对应一些自己特有的工具链，在选取合适的测试工具时根据实际需要选择， 测试领域还有非常多的工具数都数不过来，下面来看下 React 单元测试的一些方法。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;使用 Jest + Enzyme 对 React 进行单元测试&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3540462427745665&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQhZYTauMbrpamMgft7MXkV3ket1vuUibYIeNFwL6PXxINjOW2ZT01c5C3u1jSFiciccIh3j2tqFfADaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2768&quot;/&gt;&lt;figcaption&gt;enzyme&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Enzyme&lt;/code&gt;基础配置如下:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm install enzyme enzyme-adapter-react-16 jest-enzyme jest-environment-enzyme jest-canvas-mock react@16 react-dom@16 --save-dev&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// jest.config.js&lt;br/&gt;{&lt;br/&gt;&lt;span&gt;- &quot;testEnvironment&quot;: &quot;jsdom&quot;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+  setupFilesAfterEnv: [&quot;jest-enzyme&quot;, &quot;jest-canvas-mock&quot;],&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+  testEnvironment: &quot;enzyme&quot;,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+  testEnvironmentOptions: {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+    &quot;enzymeAdapter&quot;: &quot;react16&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+  },&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;jest-canvas-mock&lt;/code&gt; 这个包是为了解决一些使用 &lt;code&gt;JSDOM&lt;/code&gt; 未实现行为触发警告的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面建立了一个使用 &lt;code&gt;Enzyme&lt;/code&gt; 比较友好的环境，可以直接在全局作用域里引用 &lt;code&gt;React&lt;/code&gt; , &lt;code&gt;shallow&lt;/code&gt;, &lt;code&gt;mount&lt;/code&gt; 等 &lt;code&gt;API&lt;/code&gt;。此外 &lt;code&gt;Enzyme&lt;/code&gt; 还注册了许多友好的断言函数到 &lt;code&gt;Jest&lt;/code&gt; 中，如下所示，&lt;span&gt;参考地址&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;toBeChecked()&lt;br/&gt;toBeDisabled()&lt;br/&gt;toBeEmptyRender()&lt;br/&gt;toExist()&lt;br/&gt;toContainMatchingElement()&lt;br/&gt;toContainMatchingElements()&lt;br/&gt;toContainExactlyOneMatchingElement()&lt;br/&gt;toContainReact()&lt;br/&gt;toHaveClassName()&lt;br/&gt;toHaveDisplayName()&lt;br/&gt;toHaveHTML()&lt;br/&gt;toHaveProp()&lt;br/&gt;toHaveRef()&lt;br/&gt;toHaveState()&lt;br/&gt;toHaveStyle()&lt;br/&gt;toHaveTagName()&lt;br/&gt;toHaveText()&lt;br/&gt;toIncludeText()&lt;br/&gt;toHaveValue()&lt;br/&gt;toMatchElement()&lt;br/&gt;toMatchSelector()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// js/ClassComponent.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; React &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;react&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ClassComponent&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;React&lt;/span&gt;.&lt;span&gt;PureComponent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;constructor&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;();&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.state = { &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;classcomponent&#x27;&lt;/span&gt; };&lt;br/&gt;    }&lt;br/&gt;    render() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;            &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                a simple class component&lt;br/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;CustomComponent&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;        );&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// test/hook.test.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; HookComponent &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;../js/HookComponent&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;describe(&lt;span&gt;&#x27;HookComponent&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;    it (&lt;span&gt;&#x27;test with shallow&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; wrapper = shallow(&lt;span&gt;&amp;lt;&lt;span&gt;HookComponent&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;{1}&lt;/span&gt; /&amp;gt;&lt;/span&gt;);&lt;br/&gt;        expect(wrapper).toHaveState(&lt;span&gt;&#x27;name&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;classcomponent&#x27;&lt;/span&gt;);&lt;br/&gt;        expect(wrapper).toIncludeText(&lt;span&gt;&#x27;a simple class component&#x27;&lt;/span&gt;);&lt;br/&gt;        expect(wrapper).toContainReact(&lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;a simple class component&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;);&lt;br/&gt;        expect(wrapper).toContainMatchingElement(&lt;span&gt;&#x27;CustomComponent&#x27;&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Enzyme&lt;/code&gt; 提供了三种渲染组件方法&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;shallow&lt;/code&gt; 使用 &lt;code&gt;react-test-renderer&lt;/code&gt; 将组件渲染成内存中的对象, 可以方便进行 &lt;code&gt;props&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt; 等数据方面的测试，对应的操作对象为 &lt;code&gt;ShallowWrapper&lt;/code&gt;，在这种模式下仅能感知到第一层自定义子组件，对于自定义子组件内部结构则无法感知。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;mount&lt;/code&gt; 使用 &lt;code&gt;react-dom&lt;/code&gt; 渲染组件，会创建真实 &lt;code&gt;DOM&lt;/code&gt; 节点，比 &lt;code&gt;shallow&lt;/code&gt; 相比增加了可以使用原生 &lt;code&gt;API&lt;/code&gt; 操作 &lt;code&gt;DOM&lt;/code&gt; 的能力，对应的操作对象为 &lt;code&gt;ReactWrapper&lt;/code&gt;，这种模式下感知到的是一个完整的 &lt;code&gt;DOM&lt;/code&gt; 树。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;render&lt;/code&gt; 使用 &lt;code&gt;react-dom-server&lt;/code&gt; 渲染成 &lt;code&gt;html&lt;/code&gt; 字符串，基于这份静态文档进行操作，对应的操作对象为 &lt;code&gt;CheerioWrapper&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Shallow 渲染&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 &lt;code&gt;shallow&lt;/code&gt; 模式仅能感知到第一层自定义子组件组件，往往只能用于简单组件测试。例如下面的组件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// js/avatar.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Image&lt;/span&gt;(&lt;span&gt;{ src }&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;span&gt;img&lt;/span&gt; &lt;span&gt;src&lt;/span&gt;=&lt;span&gt;{src}&lt;/span&gt; /&amp;gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Living&lt;/span&gt;(&lt;span&gt;{ children }&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;icon-living&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt; { children } &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Avatar&lt;/span&gt;(&lt;span&gt;{ user, onClick }&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; { living, avatarUrl } = user;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;        &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;container&quot;&lt;/span&gt; &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{onClick}&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;wrapper&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;&amp;lt;&lt;span&gt;Living&lt;/span&gt; &amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;text&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt; 直播中 &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;&amp;lt;/&lt;span&gt;Living&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;Image&lt;/span&gt; &lt;span&gt;src&lt;/span&gt;=&lt;span&gt;{avatarUrl}&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    )&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; Avatar;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;shallow&lt;/code&gt; 渲染虽然不是真正的渲染，但是其组件生命周期会完整地走一遍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;shallow(&amp;lt;Avatar /&amp;gt;)&lt;/code&gt; 能感知到的结构如下, 注意看到 &lt;code&gt;div.text&lt;/code&gt; 作为 &lt;code&gt;Living&lt;/code&gt; 组件的 &lt;code&gt;children&lt;/code&gt; 能够被检测到，但是 &lt;code&gt;Living&lt;/code&gt; 的内部结构无法感知。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6296918767507003&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQhZYTauMbrpamMgft7MXkV3KLRcF118L4bsfrB22vO6nAr9F2YFziay1ldgEH4JGkwYWjTIWTAUfqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1785&quot;/&gt;&lt;figcaption&gt;shallow&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Enzyme&lt;/code&gt; 支持的选择器支持我们熟悉的 &lt;code&gt;css selector&lt;/code&gt; 语法，这种情况下我们可以对 &lt;code&gt;DOM&lt;/code&gt; 结构做如下测试&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// test/avatar.test.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Avatar &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;../js/avatar&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;describe(&lt;span&gt;&#x27;Avatar&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; wrapper = &lt;span&gt;null&lt;/span&gt;, avatarUrl = &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    beforeEach(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        wrapper = shallow(&lt;span&gt;&amp;lt;&lt;span&gt;Avatar&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;=&lt;span&gt;{{&lt;/span&gt; avatarUrl: avatarUrl }} /&amp;gt;&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;&lt;br/&gt;    afterEach(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        wrapper.unmount();&lt;br/&gt;        jest.clearAllMocks();&lt;br/&gt;    })&lt;br/&gt;&lt;br/&gt;    it (&lt;span&gt;&#x27;should render success&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;        &lt;span&gt;// wrapper 渲染不为空&lt;/span&gt;&lt;br/&gt;        expect(wrapper).not.toBeEmptyRender();&lt;br/&gt;        &lt;span&gt;// Image 组件渲染不为空, 这里会执行 Image 组件的渲染函数&lt;/span&gt;&lt;br/&gt;        expect(wrapper.find(&lt;span&gt;&#x27;Image&#x27;&lt;/span&gt;)).not.toBeEmptyRender();&lt;br/&gt;        &lt;span&gt;// 包含一个节点&lt;/span&gt;&lt;br/&gt;        expect(wrapper).toContainMatchingElement(&lt;span&gt;&#x27;div.container&#x27;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 包含一个自定义组件&lt;/span&gt;&lt;br/&gt;        expect(wrapper).toContainMatchingElement(&lt;span&gt;&quot;Image&quot;&lt;/span&gt;);&lt;br/&gt;        expect(wrapper).toContainMatchingElement(&lt;span&gt;&#x27;Living&#x27;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// shallow 渲染不包含子组件的内部结构&lt;/span&gt;&lt;br/&gt;        expect(wrapper).not.toContainMatchingElement(&lt;span&gt;&#x27;img&#x27;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// shallow 渲染包含 children 节点&lt;/span&gt;&lt;br/&gt;        expect(wrapper).toContainMatchingElement(&lt;span&gt;&#x27;div.text&#x27;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// shallow 渲染可以对 children 节点内部结构做测试&lt;/span&gt;&lt;br/&gt;        expect(wrapper.find(&lt;span&gt;&#x27;div.text&#x27;&lt;/span&gt;)).toIncludeText(&lt;span&gt;&#x27;直播中&#x27;&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们想去测试对应组件的 &lt;code&gt;props&lt;/code&gt; / &lt;code&gt;state&lt;/code&gt; 也可以很方便测试，不过目前存在缺陷，&lt;code&gt;Class Component&lt;/code&gt; 能通过 &lt;code&gt;toHaveProp&lt;/code&gt;, &lt;code&gt;toHaveState&lt;/code&gt; 直接测试， 但是 &lt;code&gt;Hook&lt;/code&gt; 组件无法测试 &lt;code&gt;useState&lt;/code&gt; 。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;it (&lt;span&gt;&#x27;Image component receive props&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; imageWrapper = wrapper.find(&lt;span&gt;&#x27;Image&#x27;&lt;/span&gt;);、&lt;br/&gt;  &lt;span&gt;// 对于 Hook 组件目前我们只能测试 props&lt;/span&gt;&lt;br/&gt;  expect(imageWrapper).toHaveProp(&lt;span&gt;&#x27;src&#x27;&lt;/span&gt;, avatarUrl);&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;wrapper.find&lt;/code&gt; 虽然会返回同样的一个 &lt;code&gt;ShallowWrapper&lt;/code&gt; 对象，但是这个对象的子结构是未展开的，如果想测试&lt;code&gt;imageWrapper&lt;/code&gt; 内部结构，需要再 &lt;code&gt;shallow render&lt;/code&gt; 一次。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;it (&lt;span&gt;&#x27;Image momponent receive props&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; imageWrapper = wrapper.find(&lt;span&gt;&#x27;Image&#x27;&lt;/span&gt;).shallow();&lt;br/&gt;&lt;br/&gt;  expect(imageWrapper).toHaveProp(&lt;span&gt;&#x27;src&#x27;&lt;/span&gt;, avatarUrl);&lt;br/&gt;  expect(imageWrapper).toContainMatchingElement(&lt;span&gt;&#x27;img&#x27;&lt;/span&gt;);&lt;br/&gt;  expect(imageWrapper.find(&lt;span&gt;&#x27;img&#x27;&lt;/span&gt;)).toHaveProp(&lt;span&gt;&#x27;src&#x27;&lt;/span&gt;, avatarUrl);&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以改变组件的 &lt;code&gt;props&lt;/code&gt;, 触发组件重绘&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;it (&lt;span&gt;&#x27;should rerender when user change&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; newAvatarUrl = &lt;span&gt;&#x27;&#x27;&lt;/span&gt; + &lt;span&gt;Math&lt;/span&gt;.random();&lt;br/&gt;    wrapper.setProps({ &lt;span&gt;user&lt;/span&gt;: { &lt;span&gt;avatarUrl&lt;/span&gt;: newAvatarUrl }});&lt;br/&gt;    wrapper.update();&lt;br/&gt;    expect(wrapper.find(&lt;span&gt;&#x27;Image&#x27;&lt;/span&gt;)).toHaveProp(&lt;span&gt;&#x27;src&#x27;&lt;/span&gt;, newAvatarUrl);&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一个常见的场景是事件模拟，事件比较接近真实测试场景，这种场景下使用 &lt;code&gt;shallow&lt;/code&gt; 存在诸多缺陷，因为 &lt;code&gt;shallow&lt;/code&gt; 场景事件不会像真实事件一样有捕获和冒泡流程，所以此时只能简单的触发对应的 &lt;code&gt;callback&lt;/code&gt; 达到测试目的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;it (&lt;span&gt;&#x27;will call onClick prop when click event fired&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; fn = jest.fn();&lt;br/&gt;&lt;br/&gt;    wrapper.setProps({ &lt;span&gt;onClick&lt;/span&gt;: fn });&lt;br/&gt;    wrapper.update();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 这里触发了两次点击事件，但是 onClick 只会被调用一次。&lt;/span&gt;&lt;br/&gt;    wrapper.find(&lt;span&gt;&#x27;div.container&#x27;&lt;/span&gt;).simulate(&lt;span&gt;&#x27;click&#x27;&lt;/span&gt;);&lt;br/&gt;    wrapper.find(&lt;span&gt;&#x27;div.wrapper&#x27;&lt;/span&gt;).simulate(&lt;span&gt;&#x27;click&#x27;&lt;/span&gt;);&lt;br/&gt;    expect(fn).toHaveBeenCalledTimes(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于这些网上有人总结了 &lt;code&gt;shallow&lt;/code&gt; 模式下的一些不足&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;shallow&lt;/code&gt; 渲染不会进行事件冒泡，而 &lt;code&gt;mount&lt;/code&gt; 会。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;shallow&lt;/code&gt; 渲染因为不会创建真实 &lt;code&gt;DOM&lt;/code&gt;，所以组件中使用 &lt;code&gt;refs&lt;/code&gt; 的地方都无法正常获取，如果确实需要使用 &lt;code&gt;refs&lt;/code&gt; , 则必须使用 &lt;code&gt;mount&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;simulate&lt;/code&gt;  在 &lt;code&gt;mount&lt;/code&gt; 中会更加有用，因为它会进行事件冒泡。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实上面几点说明了一个现象是 &lt;code&gt;shallow&lt;/code&gt; 往往只适合一种理想的场景，一些依赖浏览器行为表现的操作 &lt;code&gt;shallow&lt;/code&gt; 无法满足，这些和真实环境相关的就只能使用&lt;code&gt;mount&lt;/code&gt;了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Mount 渲染&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Mount&lt;/code&gt; 渲染的对象结构为 &lt;code&gt;ReactWrapper&lt;/code&gt; 其提供了和 &lt;code&gt;ShallowWrapper&lt;/code&gt; 几乎一样的 &lt;code&gt;API&lt;/code&gt; , 差异很小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;API&lt;/code&gt;层面的一些差异如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;+ getDOMNode()        获取DOM节点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+ detach()            卸载React组件，相当于 unmountComponentAtNode&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+ mount()             挂载组件，unmount之后通过这个方法重新挂载&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+ ref(refName)        获取 class component 的 instance.refs 上的属性&lt;/span&gt;&lt;br/&gt;&lt;span&gt;+ setProps(nextProps, callback)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;- setProps(nextProps)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;- shallow()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;- dive()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;- getElement()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;- getElements()&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外由于 &lt;code&gt;mount&lt;/code&gt; 使用 &lt;code&gt;ReactDOM&lt;/code&gt; 进行渲染，所以其更加接近真实场景，在这种模式下我们能观察到整个 &lt;code&gt;DOM&lt;/code&gt; 结构和React组件节点结构。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.643793369313801&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KV8By3euEQhZYTauMbrpamMgft7MXkV3icJmwZuVmYaEPMXjricYNfemwZrfAHwZpPlczepjhAEBC71svE0lK4icA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1297&quot;/&gt;&lt;figcaption&gt;mount&lt;/figcaption&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;describe(&lt;span&gt;&#x27;Mount Avatar&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; wrapper = &lt;span&gt;null&lt;/span&gt;, avatarUrl = &lt;span&gt;&#x27;123&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    beforeEach(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        wrapper = mount(&lt;span&gt;&amp;lt;&lt;span&gt;Avatar&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;=&lt;span&gt;{{&lt;/span&gt; avatarUrl }} /&amp;gt;&lt;/span&gt;);&lt;br/&gt;    })&lt;br/&gt;&lt;br/&gt;    afterEach(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        jest.clearAllMocks();&lt;br/&gt;    })&lt;br/&gt;&lt;br/&gt;    it (&lt;span&gt;&#x27;should set img src with avatarurl&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;        expect(wrapper.find(&lt;span&gt;&#x27;Image&#x27;&lt;/span&gt;)).toExist();&lt;br/&gt;        expect(wrapper.find(&lt;span&gt;&#x27;Image&#x27;&lt;/span&gt;)).toHaveProp(&lt;span&gt;&#x27;src&#x27;&lt;/span&gt;, avatarUrl);&lt;br/&gt;        expect(wrapper.find(&lt;span&gt;&#x27;img&#x27;&lt;/span&gt;)).toHaveProp(&lt;span&gt;&#x27;src&#x27;&lt;/span&gt;, avatarUrl);&lt;br/&gt;    })&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;shallow&lt;/code&gt; 中无法模拟的事件触发问题在 &lt;code&gt;mount&lt;/code&gt; 下就不再是问题。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;it (&lt;span&gt;&#x27;will call onClick prop when click event fired&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; fn = jest.fn();&lt;br/&gt;&lt;br/&gt;    wrapper.setProps({ &lt;span&gt;onClick&lt;/span&gt;: fn });&lt;br/&gt;    wrapper.update();&lt;br/&gt;&lt;br/&gt;    wrapper.find(&lt;span&gt;&#x27;div.container&#x27;&lt;/span&gt;).simulate(&lt;span&gt;&#x27;click&#x27;&lt;/span&gt;);&lt;br/&gt;    wrapper.find(&lt;span&gt;&#x27;div.wrapper&#x27;&lt;/span&gt;).simulate(&lt;span&gt;&#x27;click&#x27;&lt;/span&gt;);&lt;br/&gt;    expect(fn).toHaveBeenCalledTimes(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结一下 &lt;code&gt;shallow&lt;/code&gt; 中能做的 &lt;code&gt;mount&lt;/code&gt; 都能做，&lt;code&gt;mount&lt;/code&gt;中能做的 &lt;code&gt;shallow&lt;/code&gt;不一定能做。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Render 渲染&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;render&lt;/code&gt; 内部使用 &lt;code&gt;react-dom-server&lt;/code&gt; 渲染成字符串，再经过 &lt;code&gt;Cherrio&lt;/code&gt; 转换成内存中的结构，返回 &lt;code&gt;CheerioWrapper&lt;/code&gt; 实例，能够完整地渲染整个&lt;code&gt;DOM&lt;/code&gt; 树，但是会将内部实例的状态丢失，所以也称为 &lt;code&gt;Static Rendering&lt;/code&gt; 。这种渲染能够进行的操作比较少，这里也不作具体介绍，可以参考 &lt;span&gt;官方文档&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt; 。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果让我推荐的话，对于真实浏览器我会推荐 &lt;code&gt;Karma&lt;/code&gt; + &lt;code&gt;Jasmine&lt;/code&gt; 方案测试，对于 &lt;code&gt;React&lt;/code&gt; 测试 &lt;code&gt;Jest&lt;/code&gt; + &lt;code&gt;Enzyme&lt;/code&gt; 在 &lt;code&gt;JSDOM&lt;/code&gt; 环境下已经能覆盖大部分场景。另外测试 &lt;code&gt;React&lt;/code&gt;组件除了 &lt;code&gt;Enzyme&lt;/code&gt; 提供的操作， &lt;code&gt;Jest&lt;/code&gt; 中还有很多其他有用的特性，比如可以 &lt;code&gt;mock&lt;/code&gt; 一个 &lt;code&gt;npm&lt;/code&gt; 组件的实现，调整 &lt;code&gt;setTimeout&lt;/code&gt; 时钟等，真正进行单元测试时，这些工具也是必不可少的，整个单元测试技术体系包含了很多东西，本文无法面面俱到，只介绍了一些距离我们最近的相关的技术体系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;https://medium.com/building-ibotta/understanding-chai-js-language-mechanics-cc28e4c9604b&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://medium.com/@turhan.oz/typescript-with-jasmine-easy-project-setup-530c7cc764e8&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://www.liuyiqi.cn/2015/10/12/karma-start/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://jestjs.io/docs/en&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://blog.bitsrc.io/how-to-test-react-components-with-jest-and-enzyme-in-depth-145fcd06b90&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://www.freecodecamp.org/news/testing-react-hooks/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://www.reddit.com/r/reactjs/comments/ajw2uv/jestenzyme_simulate_event_bubbling_onclick/&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本文发布自 &lt;span&gt;网易云音乐大前端团队&lt;/span&gt;&lt;sup&gt;[10]&lt;/sup&gt;，文章未经授权禁止任何形式的转载。我们常年招收前端、iOS、Android，如果你准备换工作，又恰好喜欢云音乐，那就加入我们 grp.music-fe(at)corp.netease.com！&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;江水: &lt;em&gt;https://www.zhihu.com/people/li-quan-wei-41&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;TDD: &lt;em&gt;https://en.wikipedia.org/wiki/Test-driven_development&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;BDD: &lt;em&gt;https://en.wikipedia.org/wiki/Behavior-driven_development&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;better-assert: &lt;em&gt;https://github.com/tj/better-assert&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;unexpected.js: &lt;em&gt;https://unexpected.js.org/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;AMD: &lt;em&gt;https://github.com/amdjs/amdjs-api/blob/master/AMD.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;规范 : &lt;em&gt;http://wiki.commonjs.org/wiki/Modules/1.1&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;参考地址: &lt;em&gt;https://github.com/enzymejs/enzyme-matchers/blob/master/packages/jest-enzyme/README.md&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;官方文档: &lt;em&gt;https://enzymejs.github.io/enzyme/docs/api/render.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[10]&lt;/span&gt;&lt;p&gt;网易云音乐大前端团队: &lt;em&gt;https://github.com/x-orpheus&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2094e5ee3263953a0041587a23becd33</guid>
<title>FPGA 双向口的使用及 Verilog 实现</title>
<link>https://toutiao.io/k/khm01t3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot; usegifprops=&quot;[object Object]&quot;&gt;&lt;p&gt;FPGA的双向口在FPGA的设计应用中使用及其广泛，如I2C接口中的SDA，3线制的SPI接口中的数据线，传统控制总线中的数据总线，以及内存的访问DDR3/DDR4的数据总线等都是双向访问的。双向访问涉及到的概念比较多，如三态的概念，高阻的概念，输入、输出引脚合并，输入输出分时复用等概念，因此初学者往往比较迷惑，觉得无所适从，本文从底层基本原理入手，揭示双向口的机理，并用Verilog程序开发为例一步步引导大家如何使用双向口（inout）的使用与开发。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;b&gt;双向口涉及的基本模型&lt;/b&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;为了描述方便，这里给两个命名tri0和tri1（tri是三态门（tri-state的缩略写法，其实在Verilog语法中有两个模型与之对应，分别为bufif0，bufif1。图1，2中的oe在传统的三总线结构中，通常对应OE（读）或WE（写）。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;bufif0是三态门模型，其例化格式如下：&lt;/p&gt;&lt;p&gt;bufif0 tri0 (out, in, oe); //tri0是bufif0的例化名。&lt;/p&gt;&lt;p&gt;其电路形态形态如图1：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ed854df95a54b98b51756ee13978b51b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;549&quot; data-rawheight=&quot;219&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-ed854df95a54b98b51756ee13978b51b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;549&quot; data-rawheight=&quot;219&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-ed854df95a54b98b51756ee13978b51b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-ed854df95a54b98b51756ee13978b51b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;图1 bufif0&lt;/p&gt;&lt;p&gt;在这两个模型中，oe端决定输出的形态，在tri0的模型中，如果oe为’0’， out就得到out0（out0是FPGA内部逻辑产生的值）的值，最终输出到端口PAD上。如果 oe为’1’，此时三态门的输出为高阻状态，在Verilog 描述中用’Z’表示，即三态门与外界是断开状态，如图2所示。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-cd5c553362ebfbf37a06baa3c31d6797_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;517&quot; data-rawheight=&quot;207&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-cd5c553362ebfbf37a06baa3c31d6797_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;517&quot; data-rawheight=&quot;207&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-cd5c553362ebfbf37a06baa3c31d6797_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-cd5c553362ebfbf37a06baa3c31d6797_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;图2&lt;/p&gt;&lt;p&gt;图1，2中的oe在传统的三总线结构中，通常对应OE（读）或WE（写）。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;bufif1是另一种三态门模型，其例化格式如下：&lt;/p&gt;&lt;p&gt;bufif1 tri1 (out, in, oe); //tri1是bufif1的例化名。&lt;/p&gt;&lt;p&gt;其电路形态形态如图3：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-cfcff93c94c2733a93bb8fc0bc4cc56b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;300&quot; data-rawheight=&quot;152&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;300&quot; data-rawheight=&quot;152&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-cfcff93c94c2733a93bb8fc0bc4cc56b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;图3 buffif1&lt;/p&gt;&lt;p&gt;在这两个模型中，oe端决定输出的形态，在tri1的模型中，如果oe为’1’， out就得到out0（out0是FPGA内部逻辑产生的值）的值，最终输出到端口PAD上。如果 oe为’0’，此时三态门的输出为高阻状态，在Verilog 描述中用’Z’表示，即三态门与外界是断开状态，如图4所示。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3180aa0884f2a72b90e1616867b94d25_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;305&quot; data-rawheight=&quot;175&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;305&quot; data-rawheight=&quot;175&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-3180aa0884f2a72b90e1616867b94d25_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;图4&lt;/p&gt;&lt;p&gt;图3，4中的oe在传统的三总线结构中，通常对应OE#（读）或WE#（写）。&lt;/p&gt;&lt;p&gt;FPGA的I/O基本上都支持双向数据操作，但是由于对外输出端口只有一个，因此需要在端口处合并。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-4ac325d07e94b38a7131914867aa2a7d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;418&quot; data-rawheight=&quot;252&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;418&quot; data-rawheight=&quot;252&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-4ac325d07e94b38a7131914867aa2a7d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;图5&lt;/p&gt;&lt;p&gt;在图5中，输出流向从FPGA内部逻辑out0–&amp;gt;out–&amp;gt;PAD；输入流向PAD–&amp;gt;in–&amp;gt;FPGA 内部逻辑。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-652fdac97bcdb8865e08487233a23457_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;438&quot; data-rawheight=&quot;243&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-652fdac97bcdb8865e08487233a23457_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;438&quot; data-rawheight=&quot;243&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-652fdac97bcdb8865e08487233a23457_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-652fdac97bcdb8865e08487233a23457_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;图6&lt;/p&gt;&lt;p&gt;在图6中，输出流向从FPGA内部逻辑–&amp;gt;out0–&amp;gt;out–&amp;gt;PAD；输入流向PAD–&amp;gt;in–&amp;gt;FPGA 内部逻辑。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;从图5，6可以看出，由于PAD 共享输入、输出。一般在推拉驱动模型中，三态门的输出能力相对较强，考虑到如果接到FPGA外部器件有同样的接口，应该严格控制他们的时序关系，以免发生短路。如图7，&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-2c4f4001b58a4ac7b3ff52f3bfacde25_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;478&quot; data-rawheight=&quot;592&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-2c4f4001b58a4ac7b3ff52f3bfacde25_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;478&quot; data-rawheight=&quot;592&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-2c4f4001b58a4ac7b3ff52f3bfacde25_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-2c4f4001b58a4ac7b3ff52f3bfacde25_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;图7&lt;/p&gt;&lt;p&gt;在图7中如果a,b两个器件同时输出（两个器件的oe都为’1’），如果恰好一个器件输出为高，一个为低，则会引起短路现象。因此要严格控制时序，保证a,b两个器件避开由内部逻辑同时驱动输出的情况。只有在两个器件oe一个为高，另一个为低，或者两个器件的oe都为低的时候，两个器件的端口才能连在一起。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;ol/&gt;&lt;p&gt;在传统的工业控制总线中，分为主从模式。一般MCU或FPGA为MASTER，SRAM 、EPROM等器件为从模式。在这种模式下，FPGA生成控制信号oe， 同时取反后接到对方的OE端上。如图8：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-c6ebb37d4dec2623ff67956fec8e7c5b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;480&quot; data-rawheight=&quot;359&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-c6ebb37d4dec2623ff67956fec8e7c5b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;480&quot; data-rawheight=&quot;359&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-c6ebb37d4dec2623ff67956fec8e7c5b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-c6ebb37d4dec2623ff67956fec8e7c5b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;图8&lt;/p&gt;&lt;p&gt;图8中，由于oe是由一个主器件控制，因此实现推拉模式，即主器件输入，从器件输出；主器件输出，从器件输入。从输出角度看，在输出的时段内，高低电平直接输出，这一点不同后面要介绍的漏极开路（OD）带上拉电阻的结构。&lt;/p&gt;&lt;p&gt;推拉MOS管模型如图9：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-e9e772e7fac9e29b0d8f0cd5e757ff2c_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1010&quot; data-rawheight=&quot;714&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-e9e772e7fac9e29b0d8f0cd5e757ff2c_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1010&quot; data-rawheight=&quot;714&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-e9e772e7fac9e29b0d8f0cd5e757ff2c_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-e9e772e7fac9e29b0d8f0cd5e757ff2c_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;图9&lt;/p&gt;&lt;p&gt;例1：Master 模式单线控制双向接口（Verilog）。&lt;/p&gt;&lt;p&gt;门级描述：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;12345678910111213141516171819202122232425262728293031323334&lt;/td&gt;&lt;td&gt;module bidir_gate(    input            clk,    input            rst,    inout      [3:0] a,    output           noe,    output reg [3:0] in_val  ); reg [3:0] counta, countb; assign noe = ~counta[3];bufif1 tri1_0(a[0], countb[0], ~noe);bufif1 tri1_1(a[1], countb[1], ~noe);bufif1 tri1_2(a[2], countb[2], ~noe);bufif1 tri1_3(a[3], countb[3], ~noe); always@(posedge clk or posedge rst)if(rst) begin    counta &amp;lt;= 0;    countb &amp;lt;= 0;endelse begin    counta &amp;lt;= counta + 1;     if(counta == 15)        countb &amp;lt;= countb + 1;     if(noe)        in_val &amp;lt;= a;endendmodule&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;RTL描述&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1234567891011121314151617181920212223242526272829303132&lt;/td&gt;&lt;td&gt;module bidir_RTL(    input            clk,    input            rst,    inout      [3:0] a,    output           noe,    output reg [3:0] in_val  );  reg [3:0] counta, countb; assign noe = ~counta[3];assign  a  = (!noe) ? countb : 4&#x27;bZZZZ;   //双向口输出  always@(posedge clk or posedge rst)if(rst) begin    counta &amp;lt;= 0;    in_val &amp;lt;= 0;endelse begin    counta &amp;lt;= counta + 1;     if(counta==15)        countb &amp;lt;= countb + 1;     if(noe)        in_val &amp;lt;= a; //获得输入，可以给FPGA内部其它模块使用end endmodule&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;在RTL的描述中可以看出，在Verilog中直接使用高阻4’bZZZZ就起到了三态门的效果，因此应习惯这种使用方法。&lt;/p&gt;&lt;p&gt;例2：Master 模式双向结构(Verilog RTL)， 结构模式参看例1。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;12345678910111213141516171819202122232425262728293031323334&lt;/td&gt;&lt;td&gt;module bidir_gate(    input            clk,    input            rst,    inout      [3:0] a,    output           noe,    output           nwe,    output reg [3:0] in_val  );  reg [3:0] counta, countb; assign noe = ~counta[3];assign nwe = counta[3];   //采用tri0模型assign a   = ~nwe ? countb : 4&#x27;bZZZZ; always@(posedge clk or posedge rst)if(rst) begin    counta &amp;lt;= 0;endelse begin    counta &amp;lt;= counta + 1;     if(counta==15)        countb &amp;lt;= countb + 1;    if(~noe) in_val &amp;lt;= a; end   endmodule&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;上拉电阻结构适合总线模型，如I2C总线，485总线等多master多slave的结构。在上拉电阻的结构中，双向口一般不需要读（noe）、写（nwe）控制接口配合。但需要协议配合实现。以I2C 为例，在主、从的结构中都采用OD的方式如图10，因此多个器件的输出端可以直接通过连线接在一起。但在由于输出没有推拉结构，在期望高电平输出时，由于MOS管关闭，实际输出为也为高阻，因此需要在总线上结上拉电阻，以保证在输出阶段且输出为高电平时，可以得到确保的高电平状态，如图11，&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-46760ba4189b6d5c37b864771c5c4778_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;214&quot; data-rawheight=&quot;125&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;214&quot; data-rawheight=&quot;125&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-46760ba4189b6d5c37b864771c5c4778_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;图10 OD结构&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-611cf20a5acc6b432c7b99e81bd8d3ce_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;319&quot; data-rawheight=&quot;507&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;319&quot; data-rawheight=&quot;507&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-611cf20a5acc6b432c7b99e81bd8d3ce_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;图11&lt;/p&gt;&lt;p&gt;在OD（或OC）的设计中，Verilog描述在输入、低电平输出时与推拉结构一致，只有在输出高电平时不同。在输出高电平时要确保真正输出的是高阻。I2C总线接口就是标准的OD结构，在SDA，SDL都要加上拉电阻，如图12&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-f8143099483b3baa62809f42579bd9e6_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;460&quot; data-rawheight=&quot;261&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-f8143099483b3baa62809f42579bd9e6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;460&quot; data-rawheight=&quot;261&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-f8143099483b3baa62809f42579bd9e6_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-f8143099483b3baa62809f42579bd9e6_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;图12&lt;/p&gt;&lt;p&gt;由于inout信号一般只在端口使用，因此在FPGA的内部逻辑（内部模块）将会把inout（双向口）变换成input, output类型进行传递, 具体的使用见例3.&lt;/p&gt;&lt;p&gt;例3：I2C接口Verilog描述。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;12345678910111213141516171819202122232425262728293031323334&lt;/td&gt;&lt;td&gt;module I2C_intereface(    inout        SCL,    inout        SDA,    input  [7:0] datain,    output [7:0] dataout);  wire    SCL_in;wire    SDA_in; wire    SCL_out;wire    SDA_out; assign  SCL     = SCL_out ? 1’bZ : 1’b0;   //这里处理方式与推拉结构不同。assign  SCL_in  = SCL;assign  SDA     = SDA_out ? 1’bZ : 1’b0;assign  SDA_in  = SDA; I2C  I2C_inst(    .SCL_in  (SCL_in),    .SDA_in  (SDA_in),     .SCL_out (SCL_out),    .SDA_out (SDA_out),     .datain  (datain),    .dataout (dataout))  endmodule&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;上面程序中，输入直接赋值给SDA_in，是全阶段赋值，即把输出阶段也给输入端赋值，因此在I2C 的程序中，何时使用输入的值，应有严格定时。关于I2C的时序描述请参照I2C部分内容。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>