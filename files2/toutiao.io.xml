<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f8028b4fcba6fdffdceecadd411cf538</guid>
<title>欢迎加入读者圈子，一起交流！</title>
<link>https://toutiao.io/k/mtrqmru</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎加入读者圈子，一起交流！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;307&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavich3VaNkKeiaAwUhz7TQbQmic4fFsr58X9PAYleYzxqc1K1vZjeBoZDMUsmia0xH67EQYINGRvNOtLmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;圈子剧透&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、600+圈子成员，以中高级程序员为主，更有架构师、CTO坐镇交流；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、1000+优质主题，数十G独家资料，每日分享，精挑细选；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、全年52期专属邮件周报，让你轻松掌握业界资讯、技术干货，提升认知水平；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、全年52本好书共读，让你花最少的时间，获取更好的知识；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;心动不如行动，赶快加入吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>966b0d0b7e807909e32bfdeff3fbf301</guid>
<title>消息队列原理和选型：Kafka、RocketMQ 、RabbitMQ 和 ActiveMQ</title>
<link>https://toutiao.io/k/nuwnwro</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是可读性很差，不想让这篇文章被埋没，五一特意花了 7 个小时重新整理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息队列中间件重要吗？面试必问问题之一，你说重不重要。我有时会问同事，为啥你用 RabbitMQ，不用 Kafka，或者 RocketMQ 呢，他给我的回答 “因为公司用的就是这个，大家都这么用”，如果你去面试，直接就被 Pass，今天这篇文章，告诉你如何回答。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章，我重点突出消息队列选型，弱化每种队列内部的实现细节，精华提炼，可读性更强！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的消息队列主要这 4 种，分别为 Kafka、RabbitMQ、RocketMQ 和 ActiveMQ，主要介绍前三，不BB，上思维导图！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6472081218274112&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaWdtp7WCQne2TOTXz0r8VzLk0GY0D4ibHy9ia4uAtGETaEhIK42glDhNFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1576&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;消息队列基础&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是消息队列？&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息队列是在消息的传输过程中保存消息的容器，用于接收消息并以文件的方式存储，一个消息队列可以被一个也可以被多个消费者消费，包含以下 3 元素：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Producer：消息生产者，负责产生和发送消息到 Broker；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Broker：消息处理中心，负责消息存储、确认、重试等，一般其中会包含多个 Queue；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Consumer：消息消费者，负责从 Broker 中获取消息，并进行相应处理。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41192411924119243&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaWcBEyibNjZxtpKMyn15mlhyLmhu72ibTYCXKsg3WKDsIb0dKKIicNqmkOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;738&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消息队列模式&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;点对点模式：多个生产者可以向同一个消息队列发送消息，一个具体的消息只能由一个消费者消费。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.30250990752972257&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaWXQuHVZm8lKSJE8sXh1LhIb9haBZv4S1RSrJIticpTRv7LSklO6xhlNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;757&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;发布/订阅模式：单个消息可以被多个订阅者并发的获取和处理。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3006896551724138&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaWjjkC0lhw5jQUB2moEqAjUiasmnqJA1oqibiaABnRHVlPscW6cpXhIx15Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;725&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消息队列应用场景&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;应用解耦&lt;/strong&gt;：消息队列减少了服务之间的耦合性，不同的服务可以通过消息队列进行通信，而不用关心彼此的实现细节。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;异步处理&lt;/strong&gt;：消息队列本身是异步的，它允许接收者在消息发送很长时间后再取回消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;流量削锋&lt;/strong&gt;：当上下游系统处理能力存在差距的时候，利用消息队列做一个通用的”载体”，在下游有能力处理的时候，再进行分发与处理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;日志处理&lt;/strong&gt;：日志处理是指将消息队列用在日志处理中，比如 Kafka 的应用，解决大量日志传输的问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;消息通讯&lt;/strong&gt;：消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯，比如实现点对点消息队列，或者聊天室等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;消息广播&lt;/strong&gt;：如果没有消息队列，每当一个新的业务方接入，我们都要接入一次新接口。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，是下游的事情，无疑极大地减少了开发和联调的工作量。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;常用消息队列&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于官方社区现在对 ActiveMQ 5.x 维护越来越少，较少在大规模吞吐的场景中使用，所以我们主要讲解 Kafka、RabbitMQ 和 RocketMQ。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Kafka&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Apache Kafka 最初由 LinkedIn 公司基于独特的设计实现为一个分布式的提交日志系统，之后成为 Apache 项目的一部分，&lt;strong&gt;号称大数据的杀手锏，在数据采集、传输、存储的过程中发挥着举足轻重的作用。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;它是一个分布式的，支持多分区、多副本，基于 Zookeeper 的分布式消息流平台&lt;/strong&gt;，它同时也是一款开源的基于发布订阅模式的消息引擎系统。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重要概念&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;主题（Topic）&lt;/strong&gt;：消息的种类称为主题，可以说一个主题代表了一类消息，相当于是对消息进行分类，主题就像是数据库中的表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;分区（partition）&lt;/strong&gt;：主题可以被分为若干个分区，同一个主题中的分区可以不在一个机器上，有可能会部署在多个机器上，由此来实现 kafka 的伸缩性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;批次&lt;/strong&gt;：为了提高效率， 消息会分批次写入 Kafka，批次就代指的是一组消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;消费者群组（Consumer Group）&lt;/strong&gt;：消费者群组指的就是由一个或多个消费者组成的群体。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Broker&lt;/strong&gt;: 一个独立的 Kafka 服务器就被称为 broker，broker 接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Broker 集群&lt;/strong&gt;：broker 集群由一个或多个 broker 组成。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;重平衡（Rebalance）&lt;/strong&gt;：消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Kafka 架构&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个典型的 Kafka 集群中包含 Producer、broker、Consumer Group、Zookeeper 集群。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 通过 Zookeeper 管理集群配置，选举 leader，以及在 Consumer Group 发生变化时进行 rebalance。Producer 使用 push 模式将消息发布到 broker，Consumer 使用 pull 模式从 broker 订阅并消费消息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.703125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaWib3Ps4YpGDZqtsrO91SJFCcVtU0aicWeeFr2vG6DCSbeqnDiaTlPfzezA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Kafka 工作原理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息经过序列化后，通过不同的分区策略，找到对应的分区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;相同主题和分区的消息，会被存放在同一个批次里&lt;/strong&gt;，然后由一个独立的线程负责把它们发到 Kafka Broker 上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9593984962406015&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaWrHraTiaXibia2ajHL96OZsOJDLypatHeicllUJChN9zFvaq9TEq7sBtzXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1330&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分区的策略包括顺序轮询、随机轮询和 key hash 这 3 种方式，那什么是分区呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分区是 Kafka 读写数据的最小粒度，比如主题 A 有 15 条消息，有 5 个分区，如果采用顺序轮询的方式，15 条消息会顺序分配给这 5 个分区，后续消费的时候，也是按照分区粒度消费。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.41124260355029585&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaWjOHToZ2xQ999kjeeekY1s9Qvt6OCVGiap90XKqe9icKBVgSLbtFYfsEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1352&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于分区可以部署在多个不同的机器上，所以可以通过分区实现 Kafka 的伸缩性，比如主题 A 的 5 个分区，分别部署在 5 台机器上，如果下线一台，分区就变为 4。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 消费是通过消费群组完成，同一个消费者群组，&lt;strong&gt;一个消费者可以消费多个分区，但是一个分区，只能被一个消费者消费。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.445993031358885&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaWn85JWEMDGK1uzdJ0srWwD11ibl24kTg2vuk6qT3aoqWkSm0iayibE3v9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1148&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果消费者增加，会触发 Rebalance，也就是分区和消费者需要重新配对&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;不同的消费群组互不干涉&lt;/strong&gt;，比如下图的 2 个消费群组，可以分别消费这 4 个分区的消息，互不影响。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6858552631578947&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaWBuugVw3OAeqFiaOI3lNiaJsPicXKHCiaicHor1dCkibAnZ8qlQHDqonS4BkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1216&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;更多知识，详见 《原理初探之 Kafka》&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;RocketMQ&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocketMQ 是阿里开源的消息中间件，它是纯 Java 开发，&lt;strong&gt;具有高性能、高可靠、高实时、适合大规模分布式系统应用的特点。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocketMQ 思路起源于 Kafka，但并不是 Kafka 的一个 Copy，&lt;strong&gt;它对消息的可靠传输及事务性做了优化&lt;/strong&gt;，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binlog 分发等场景。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重要概念&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Name 服务器（NameServer）&lt;/strong&gt;：充当注册中心，类似 Kafka 中的 Zookeeper。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Broker&lt;/strong&gt;: 一个独立的 RocketMQ 服务器就被称为 broker，broker 接收来自生产者的消息，为消息设置偏移量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;主题（Topic）&lt;/strong&gt;：消息的第一级类型，一条消息必须有一个 Topic。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;子主题（Tag）&lt;/strong&gt;：消息的第二级类型，同一业务模块不同目的的消息就可以用相同 Topic 和不同的 Tag 来标识。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;分组（Group）&lt;/strong&gt;：一个组可以订阅多个 Topic，包括生产者组（Producer Group）和消费者组（Consumer Group）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;队列（Queue）&lt;/strong&gt;：可以类比 Kafka 的分区 Partition。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;RocketMQ 工作原理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RockerMQ 中的消息模型就是按照主题模型所实现的，包括 Producer Group、Topic、Consumer Group 三个角色。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为了提高并发能力，一个 Topic 包含多个 Queue&lt;/strong&gt;，生产者组根据主题将消息放入对应的 Topic，下图是采用轮询的方式找到里面的 Queue。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RockerMQ 中的消费群组和 Queue，可以类比 Kafka 中的消费群组和 Partition：&lt;strong&gt;不同的消费者组互不干扰，一个 Queue 只能被一个消费者消费，一个消费者可以消费多个 Queue。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费 Queue 的过程中，通过偏移量记录消费的位置。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4982014388489209&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaWpI26387ic8ctIbdS1N1GP3yUicXdiaqQt4ul6yJjyW1cZnn4Y6HiaAFZPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1668&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;RocketMQ 架构&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocketMQ 技术架构中有四大角色 NameServer、Broker、Producer 和 Consumer，下面主要介绍 Broker。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Broker 用于存放 Queue，一个 Broker 可以配置多个 Topic，一个 Topic 中存在多个 Queue。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果某个 Topic 消息量很大，应该给它多配置几个 Queue，并且尽量多分布在不同 broker 上，以减轻某个 broker 的压力。Topic 消息量都比较均匀的情况下，如果某个 broker 上的队列越多，则该 broker 压力越大。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7048192771084337&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaW3iaS9JIzjWhvibOA2ibWYE6eyeqODjhJGjKSdd9MF2mKotl3pIqj58NiaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1660&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单提一下，Broker 通过集群部署，并且提供了 master/slave 的结构，slave 定时从 master 同步数据（同步刷盘或者异步刷盘），如果 master 宕机，则 slave 提供消费服务，但是不能写入消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里，大家应该可以发现，RocketMQ 的设计和 Kafka 真的很像！&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;更多知识，详见 《原理初探之 RocketMQ》&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RabbitMQ 2007 年发布，是使用 Erlang 语言开发的开源消息队列系统，基于 AMQP 协议来实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AMQP 的主要特征是面向消息、队列、路由、可靠性、安全。&lt;strong&gt;AMQP 协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重要概念&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;信道（Channel）&lt;/strong&gt;：消息读写等操作在信道中进行，客户端可以建立多个信道，每个信道代表一个会话任务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;交换器（Exchange）&lt;/strong&gt;：接收消息，按照路由规则将消息路由到一个或者多个队列；如果路由不到，或者返回给生产者，或者直接丢弃。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;路由键（RoutingKey）&lt;/strong&gt;：生产者将消息发送给交换器的时候，会发送一个 RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;绑定（Binding）&lt;/strong&gt;：交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个 RoutingKey。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;RabbitMQ 工作原理&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AMQP 协议模型由三部分组成：生产者、消费者和服务端，执行流程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;生产者是连接到 Server，建立一个连接，开启一个信道。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生产者声明交换器和队列，设置相关属性，并通过路由键将交换器和队列进行绑定。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费者也需要进行建立连接，开启信道等操作，便于接收消息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生产者发送消息，发送到服务端中的虚拟主机。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;虚拟主机中的交换器根据路由键选择路由规则，发送到不同的消息队列中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;订阅了消息队列的消费者就可以获取到消息，进行消费。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4993788819875776&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaW5zXAZJV6ickiaKzfgpv1x5BzEkG0tLIxga6fr3DbrGyRH5d30mSuUaJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1610&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;常用交换器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RabbitMQ 常用的交换器类型有 direct、topic、fanout、headers 四种，每种方法的详细介绍看这篇《入门RabbitMQ，这一篇绝对够！》。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的使用方法，可以参考官网：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;官网入口：https://www.rabbitmq.com/getstarted.html&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9128959276018099&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaWHbaEGicB8xLNNuwtd8LRXhPeFAtjjrMhfQZTpGUORLTxKaqPFVC3iceQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;884&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;更多知识，详见 《入门RabbitMQ，这一篇绝对够！》&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;消息队列对比&amp;amp;选型&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9122994652406418&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sXFqMxQoVLHRJib653Nic6v4jtibZLtzSaWflltexd88iatDULGFQRN5AzJtmJTvQewFaDI0Rl4WcvFDv8XRx9Xxkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;935&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消息队列对比&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Kafka&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;高吞吐、低延迟&lt;/strong&gt;：Kafka 最大的特点就是收发消息非常快，Kafka 每秒可以处理几十万条消息，它的最低延迟只有几毫秒；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;高伸缩性&lt;/strong&gt;：每个主题（topic）包含多个分区（partition），主题中的分区可以分布在不同的主机（broker）中；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;高稳定性&lt;/strong&gt;：Kafka 是分布式的，一个数据多个副本，某个节点宕机，Kafka 集群能够正常工作；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;持久性、可靠性、可回溯&lt;/strong&gt;：Kafka 能够允许数据的持久化存储，消息被持久化到磁盘，并支持数据备份防止数据丢失，支持消息回溯；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息有序：通过控制能够保证所有消息被消费且仅被消费一次；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有优秀的第三方 Kafka Web 管理界面 Kafka-Manager，在日志领域比较成熟，被多家公司和多个开源项目使用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消息响应时间变长；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;不支持消息路由，不支持延迟发送，不支持消息重试；&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;社区更新较慢。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;RocketMQ&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;高吞吐&lt;/strong&gt;：借鉴 Kafka 的设计，单一队列百万消息的堆积能力；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;高伸缩性&lt;/strong&gt;：灵活的分布式横向扩展部署架构，整体架构其实和 kafka 很像；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;高容错性&lt;/strong&gt;：通过ACK机制，保证消息一定能正常消费；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;持久化、可回溯&lt;/strong&gt;：消息可以持久化到磁盘中，支持消息回溯；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息有序：在一个队列中可靠的先进先出（FIFO）和严格的顺序传递；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持发布/订阅和点对点消息模型，支持拉、推两种消息模式；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供 docker 镜像用于隔离测试和云集群部署，提供配置、指标和监控等功能丰富的 Dashboard。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;不支持消息路由，&lt;strong&gt;支持的客户端语言不多，目前是 java 及 c++，其中 c++ 不成熟&lt;/strong&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;部分支持消息有序：需要将同一类的消息 hash 到同一个队列 Queue 中，才能支持消息的顺序，如果同一类消息散落到不同的 Queue中，就不能支持消息的顺序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;社区活跃度一般。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;RabbitMQ&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;支持几乎所有最受欢迎的编程语言&lt;/strong&gt;：Java，C，C ++，C＃，Ruby，Perl，Python，PHP等等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;支持消息路由&lt;/strong&gt;：RabbitMQ 可以通过不同的交换器支持不同种类的消息路由；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;消息时序&lt;/strong&gt;：通过延时队列，可以指定消息的延时时间，过期时间TTL等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持容错处理：通过交付重试和死信交换器（DLX）来处理消息处理故障；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;社区活跃度高。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;缺点：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Erlang 开发，很难去看懂源码，不利于做二次开发和维护&lt;/strong&gt;，基本只能依赖于开源社区的快速维护和修复 bug；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;RabbitMQ 吞吐量会低一些&lt;/strong&gt;，这是因为他做的实现机制比较重；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不支持消息有序、持久化不好、不支持消息回溯、伸缩性一般。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消息队列选型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Kafka：追求高吞吐量，一开始的目的就是用于日志收集和传输，&lt;strong&gt;适合产生大量数据的互联网服务的数据收集业务&lt;/strong&gt;，大型公司建议可以选用，&lt;strong&gt;如果有日志采集功能，肯定是首选 kafka。&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RocketMQ：&lt;strong&gt;天生为金融互联网领域而生，对于可靠性要求很高的场景&lt;/strong&gt;，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RocketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，&lt;strong&gt;如果你的业务有上述并发场景，建议可以选择 RocketMQ。&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;RabbitMQ：结合 erlang 语言本身的并发优势，性能较好，社区活跃度也比较高，但是不利于做二次开发和维护，不过 RabbitMQ 的社区十分活跃，可以解决开发过程中遇到的 bug。&lt;strong&gt;如果你的数据量没有那么大，小公司优先选择功能比较完备的 RabbitMQ。&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;ActiveMQ：官方社区现在对 ActiveMQ 5.x 维护越来越少，&lt;strong&gt;较少在大规模吞吐的场景中使用。&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU0OTE4MzYzMw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk55KKLFaGCDRURMvFtPXf9fZXJOHOFsA3Ye8Qbibf3qHLkBQNpdjicAVpPf2T03EcakjAFbwqicjXSibXA/0?wx_fmt=png&quot; data-nickname=&quot;架构师社区&quot; data-alias=&quot;devabc&quot; data-signature=&quot;架构师社区，专注分享架构师技术干货，架构师行业秘闻，汇集各类奇妙好玩的架构师话题和流行的架构师动向！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ad5592f9cb68f2937f5944650a81ad4e</guid>
<title>C# 中多态底层 (虚方法调用) 是怎么玩</title>
<link>https://toutiao.io/k/lwi1osh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在看 &lt;/span&gt;&lt;code&gt;&lt;span&gt;C++&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的虚方法调用实现原理，大概就是说在 class 的首位置存放着一个指向 &lt;/span&gt;&lt;code&gt;&lt;span&gt;vtable array&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 指针数组 的指针，而 &lt;/span&gt;&lt;code&gt;&lt;span&gt;vtable array&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中的每一个指针元素指向的就是各自的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;虚方法&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，实现方式很有意思，哈哈，现在我很好奇 C# 中如何实现的。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、C# 中的多态玩法&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、一个简单的 C# 例子&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了方便说明，我就定义一个 Person 类和一个 Chinese 类，详细代码如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;internal&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Program&lt;/span&gt;  &lt;br/&gt;{  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;Main&lt;/span&gt;(&lt;span&gt;&lt;span&gt;string&lt;/span&gt;[] args&lt;/span&gt;)&lt;/span&gt;  &lt;br/&gt;    {  &lt;br/&gt;        Person person = &lt;span&gt;new&lt;/span&gt; Chinese();  &lt;br/&gt;&lt;br/&gt;        person.SayHello();  &lt;br/&gt;&lt;br/&gt;        Console.ReadLine();  &lt;br/&gt;    }  &lt;br/&gt;}  &lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Person&lt;/span&gt;  &lt;br/&gt;{  &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;SayHello&lt;/span&gt;()&lt;/span&gt;  &lt;br/&gt;    {  &lt;br/&gt;        Console.WriteLine(&lt;span&gt;&quot;sayhello&quot;&lt;/span&gt;);  &lt;br/&gt;    }  &lt;br/&gt;}  &lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Chinese&lt;/span&gt;: &lt;span&gt;Person&lt;/span&gt;  &lt;br/&gt;{  &lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;SayHello&lt;/span&gt;()&lt;/span&gt;  &lt;br/&gt;        {  &lt;br/&gt;            Console.WriteLine(&lt;span&gt;&quot;chinese&quot;&lt;/span&gt;);  &lt;br/&gt;        }  &lt;br/&gt;    }  &lt;br/&gt;}  &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、汇编代码分析&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来用 windbg 在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;person.SayHello()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 处下一个断点，观察一下它的反汇编代码：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;D:\net6\ConsoleApplication2\ConsoleApp1\Program.cs @ &lt;span&gt;9&lt;/span&gt;:  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf21b3 b93c5dce05      mov     ecx,&lt;span&gt;5&lt;/span&gt;CE5D3Ch (MT: ConsoleApp1.Chinese)  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf21b8 e8030f89fa      call    &lt;span&gt;005830&lt;/span&gt;c0 (JitHelp: CORINFO_HELP_NEWSFAST)  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf21bd &lt;span&gt;8945f&lt;/span&gt;4          mov     dword ptr [ebp&lt;span&gt;-0&lt;/span&gt;Ch],eax  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf21c0 &lt;span&gt;8b&lt;/span&gt;4df4          mov     ecx,dword ptr [ebp&lt;span&gt;-0&lt;/span&gt;Ch]  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf21c3 e820fbffff      call    &lt;span&gt;05&lt;/span&gt;cf1ce8 (ConsoleApp1.Chinese..ctor(), mdToken: &lt;span&gt;0600000&lt;/span&gt;A)  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf21c8 &lt;span&gt;8b&lt;/span&gt;4df4          mov     ecx,dword ptr [ebp&lt;span&gt;-0&lt;/span&gt;Ch]  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf21cb &lt;span&gt;894&lt;/span&gt;df8          mov     dword ptr [ebp&lt;span&gt;-8&lt;/span&gt;],ecx  &lt;br/&gt;  &lt;br/&gt;D:\net6\ConsoleApplication2\ConsoleApp1\Program.cs @ &lt;span&gt;11&lt;/span&gt;:  &lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;05&lt;/span&gt;cf21ce &lt;span&gt;8b&lt;/span&gt;4df8          mov     ecx,dword ptr [ebp&lt;span&gt;-8&lt;/span&gt;]  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf21d1 &lt;span&gt;8b&lt;/span&gt;45f8          mov     eax,dword ptr [ebp&lt;span&gt;-8&lt;/span&gt;]  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf21d4 &lt;span&gt;8b&lt;/span&gt;00            mov     eax,dword ptr [eax]  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf21d6 &lt;span&gt;8b&lt;/span&gt;4028          mov     eax,dword ptr [eax+&lt;span&gt;28&lt;/span&gt;h]  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf21d9 ff5010          call    dword ptr [eax+&lt;span&gt;10&lt;/span&gt;h]  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf21dc &lt;span&gt;90&lt;/span&gt;              nop  &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从汇编代码看，逻辑非常清晰，大体步骤如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、&lt;/span&gt;&lt;code&gt;&lt;span&gt;eax,dword ptr [ebp-8]&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从栈上(ebp-8)处获取 person 在堆上的首地址，如果不相信的话，可以用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;!do 027ea88c&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 试试看。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;000&lt;/span&gt;&amp;gt; dp ebp&lt;span&gt;-8&lt;/span&gt; L1  &lt;br/&gt;&lt;span&gt;0057f&lt;/span&gt;300  &lt;span&gt;027&lt;/span&gt;ea88c  &lt;br/&gt;  &lt;br/&gt;&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;000&lt;/span&gt;&amp;gt; !&lt;span&gt;do&lt;/span&gt; &lt;span&gt;027&lt;/span&gt;ea88c  &lt;br/&gt;Name:        ConsoleApp1.Chinese  &lt;br/&gt;MethodTable: &lt;span&gt;05&lt;/span&gt;ce5d3c  &lt;br/&gt;EEClass:     &lt;span&gt;05&lt;/span&gt;cd3380  &lt;br/&gt;Size:        &lt;span&gt;12&lt;/span&gt;(&lt;span&gt;0xc&lt;/span&gt;) bytes  &lt;br/&gt;File:        D:\net6\ConsoleApplication2\ConsoleApp1\bin\x86\Debug\net6&lt;span&gt;.0&lt;/span&gt;\ConsoleApp1.dll  &lt;br/&gt;Fields:  &lt;br/&gt;None  &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、&lt;/span&gt;&lt;code&gt;&lt;span&gt;eax,dword ptr [eax]&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果大家了解 &lt;/span&gt;&lt;code&gt;&lt;span&gt;实例&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 在堆上的内存布局的话，应该知道，这个首地址存放的就是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;methodtable&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 指针,我们可以用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;!dumpmt 05ce5d3c&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来验证下。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;000&lt;/span&gt;&amp;gt; dp &lt;span&gt;027&lt;/span&gt;ea88c L1  &lt;br/&gt;&lt;span&gt;027&lt;/span&gt;ea88c  &lt;span&gt;05&lt;/span&gt;ce5d3c  &lt;br/&gt;  &lt;br/&gt;&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;000&lt;/span&gt;&amp;gt; !dumpmt &lt;span&gt;05&lt;/span&gt;ce5d3c  &lt;br/&gt;EEClass:         &lt;span&gt;05&lt;/span&gt;cd3380  &lt;br/&gt;Module:          &lt;span&gt;05&lt;/span&gt;addb14  &lt;br/&gt;Name:            ConsoleApp1.Chinese  &lt;br/&gt;mdToken:         &lt;span&gt;02000007&lt;/span&gt;  &lt;br/&gt;File:            D:\net6\ConsoleApplication2\ConsoleApp1\bin\x86\Debug\net6&lt;span&gt;.0&lt;/span&gt;\ConsoleApp1.dll  &lt;br/&gt;BaseSize:        &lt;span&gt;0xc&lt;/span&gt;  &lt;br/&gt;ComponentSize:   &lt;span&gt;0x0&lt;/span&gt;  &lt;br/&gt;DynamicStatics:  &lt;span&gt;false&lt;/span&gt;  &lt;br/&gt;ContainsPointers &lt;span&gt;false&lt;/span&gt;  &lt;br/&gt;Slots &lt;span&gt;in&lt;/span&gt; VTable: &lt;span&gt;6&lt;/span&gt;  &lt;br/&gt;Number of IFaces &lt;span&gt;in&lt;/span&gt; IFaceMap: &lt;span&gt;0&lt;/span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、&lt;/span&gt;&lt;code&gt;&lt;span&gt;eax,dword ptr [eax+28h]&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那这句话是什么意思呢？如果你了解 CoreCLR 的话，你应该知道 methedtable 是由一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;class MethodTable&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 类来承载的，所以它取了 methodtable 偏移 &lt;/span&gt;&lt;code&gt;&lt;span&gt;0x28&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  位置的一个字段，那这个偏移字段是什么呢？我们先用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;dt&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 把 methodtable 结构给导出来。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;000&lt;/span&gt;&amp;gt; dt &lt;span&gt;05&lt;/span&gt;ce5d3c MethodTable  &lt;br/&gt;coreclr!MethodTable  &lt;br/&gt;   =&lt;span&gt;7&lt;/span&gt;ad96bc8 s_pMethodDataCache : &lt;span&gt;0x00639ec8&lt;/span&gt; MethodDataCache  &lt;br/&gt;   =&lt;span&gt;7&lt;/span&gt;ad96bc4 s_fUseParentMethodData : &lt;span&gt;0&lt;/span&gt;n1  &lt;br/&gt;   =&lt;span&gt;7&lt;/span&gt;ad96bcc s_fUseMethodDataCache : &lt;span&gt;0&lt;/span&gt;n1  &lt;br/&gt;   +&lt;span&gt;0x000&lt;/span&gt; m_dwFlags        : &lt;span&gt;0xc&lt;/span&gt;  &lt;br/&gt;   +&lt;span&gt;0x004&lt;/span&gt; m_BaseSize       : &lt;span&gt;0x74088&lt;/span&gt;  &lt;br/&gt;   +&lt;span&gt;0x008&lt;/span&gt; m_wFlags2        : &lt;span&gt;5&lt;/span&gt;  &lt;br/&gt;   +&lt;span&gt;0x00a&lt;/span&gt; m_wToken         : &lt;span&gt;0&lt;/span&gt;  &lt;br/&gt;   +&lt;span&gt;0x00c&lt;/span&gt; m_wNumVirtuals   : &lt;span&gt;0x5ccc&lt;/span&gt;  &lt;br/&gt;   +&lt;span&gt;0x00e&lt;/span&gt; m_wNumInterfaces : &lt;span&gt;0x5ce&lt;/span&gt;  &lt;br/&gt;   +&lt;span&gt;0x010&lt;/span&gt; m_pParentMethodTable : IndirectPointer&amp;lt;MethodTable *&amp;gt;  &lt;br/&gt;   +&lt;span&gt;0x014&lt;/span&gt; m_pLoaderModule  : PlainPointer&amp;lt;Module *&amp;gt;  &lt;br/&gt;   +&lt;span&gt;0x018&lt;/span&gt; m_pWriteableData : PlainPointer&amp;lt;MethodTableWriteableData *&amp;gt;  &lt;br/&gt;   +&lt;span&gt;0x01c&lt;/span&gt; m_pEEClass       : PlainPointer&amp;lt;EEClass *&amp;gt;  &lt;br/&gt;   +&lt;span&gt;0x01c&lt;/span&gt; m_pCanonMT       : PlainPointer&amp;lt;unsigned &lt;span&gt;long&lt;/span&gt;&amp;gt;  &lt;br/&gt;   +&lt;span&gt;0x020&lt;/span&gt; m_pPerInstInfo   : PlainPointer&amp;lt;PlainPointer&amp;lt;Dictionary *&amp;gt; *&amp;gt;  &lt;br/&gt;   +&lt;span&gt;0x020&lt;/span&gt; m_ElementTypeHnd : &lt;span&gt;0&lt;/span&gt;  &lt;br/&gt;   +&lt;span&gt;0x020&lt;/span&gt; m_pMultipurposeSlot1 : &lt;span&gt;0&lt;/span&gt;  &lt;br/&gt;   +&lt;span&gt;0x024&lt;/span&gt; m_pInterfaceMap  : PlainPointer&amp;lt;InterfaceInfo_t *&amp;gt;  &lt;br/&gt;   +&lt;span&gt;0x024&lt;/span&gt; m_pMultipurposeSlot2 : &lt;span&gt;0x5ce5d68&lt;/span&gt;  &lt;br/&gt;   =&lt;span&gt;7&lt;/span&gt;ad04c78 c_DispatchMapSlotOffsets : [&lt;span&gt;0&lt;/span&gt;]  &lt;span&gt;&quot; $ (System.Private.CoreLib.dll&quot;&lt;/span&gt;  &lt;br/&gt;   =&lt;span&gt;7&lt;/span&gt;ad04c70 c_NonVirtualSlotsOffsets : [&lt;span&gt;0&lt;/span&gt;]  &lt;span&gt;&quot; $ ($((, $ (System.Private.CoreLib.dll&quot;&lt;/span&gt;  &lt;br/&gt;   =&lt;span&gt;7&lt;/span&gt;ad04c60 c_ModuleOverrideOffsets : [&lt;span&gt;0&lt;/span&gt;]  &lt;span&gt;&quot; $ ($((,$((,(,,0 $ ($((, $ (System.Private.CoreLib.dll&quot;&lt;/span&gt;  &lt;br/&gt;   =&lt;span&gt;7&lt;/span&gt;ad12838 c_OptionalMembersStartOffsets : [&lt;span&gt;0&lt;/span&gt;]  &lt;span&gt;&quot;(((((((,(((,(,,0(((,(,,0(,,0,004&quot;&lt;/span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从 methodtable 的布局图来看, &lt;/span&gt;&lt;code&gt;&lt;span&gt;eax+28h&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;m_pMultipurposeSlot2&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 结构的第二个字段了，因为第一个字段是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;虚方法表指针&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，如果要验证的话，也很简单，用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;!dumpmt -md 05ce5d3c&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 把所有的方法给导出来，然后结合 &lt;/span&gt;&lt;code&gt;&lt;span&gt;dp 05ce5d3c&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 看下 0x5ce5d68 之后是不是许多的方法。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;000&lt;/span&gt;&amp;gt; !dumpmt -md &lt;span&gt;05&lt;/span&gt;ce5d3c  &lt;br/&gt;EEClass:         &lt;span&gt;05&lt;/span&gt;cd3380  &lt;br/&gt;Module:          &lt;span&gt;05&lt;/span&gt;addb14  &lt;br/&gt;Name:            ConsoleApp1.Chinese  &lt;br/&gt;mdToken:         &lt;span&gt;02000007&lt;/span&gt;  &lt;br/&gt;File:            D:\net6\ConsoleApplication2\ConsoleApp1\bin\x86\Debug\net6&lt;span&gt;.0&lt;/span&gt;\ConsoleApp1.dll  &lt;br/&gt;BaseSize:        &lt;span&gt;0xc&lt;/span&gt;  &lt;br/&gt;ComponentSize:   &lt;span&gt;0x0&lt;/span&gt;  &lt;br/&gt;DynamicStatics:  &lt;span&gt;false&lt;/span&gt;  &lt;br/&gt;ContainsPointers &lt;span&gt;false&lt;/span&gt;  &lt;br/&gt;Slots &lt;span&gt;in&lt;/span&gt; VTable: &lt;span&gt;6&lt;/span&gt;  &lt;br/&gt;Number of IFaces &lt;span&gt;in&lt;/span&gt; IFaceMap: &lt;span&gt;0&lt;/span&gt;  &lt;br/&gt;--------------------------------------  &lt;br/&gt;MethodDesc Table  &lt;br/&gt;   Entry MethodDe    JIT Name  &lt;br/&gt;&lt;span&gt;02610028&lt;/span&gt; &lt;span&gt;02605568&lt;/span&gt;   NONE System.Object.Finalize()  &lt;br/&gt;&lt;span&gt;02610030&lt;/span&gt; &lt;span&gt;02605574&lt;/span&gt;   NONE System.Object.ToString()  &lt;br/&gt;&lt;span&gt;02610038&lt;/span&gt; &lt;span&gt;02605580&lt;/span&gt;   NONE System.Object.Equals(System.Object)  &lt;br/&gt;&lt;span&gt;02610050&lt;/span&gt; &lt;span&gt;026055&lt;/span&gt;ac   NONE System.Object.GetHashCode()  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;CF1CE0 &lt;span&gt;05&lt;/span&gt;ce5d24   NONE ConsoleApp1.Chinese.SayHello()  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;CF1CE8 &lt;span&gt;05&lt;/span&gt;ce5d30    JIT ConsoleApp1.Chinese..ctor()  &lt;br/&gt;&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;000&lt;/span&gt;&amp;gt; dp &lt;span&gt;05&lt;/span&gt;ce5d3c L10  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;ce5d3c  &lt;span&gt;00000200&lt;/span&gt; &lt;span&gt;0000000&lt;/span&gt;c &lt;span&gt;00074088&lt;/span&gt; &lt;span&gt;00000005&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;ce5d4c  &lt;span&gt;05&lt;/span&gt;ce5ccc &lt;span&gt;05&lt;/span&gt;addb14 &lt;span&gt;05&lt;/span&gt;ce5d7c &lt;span&gt;05&lt;/span&gt;cd3380  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;ce5d5c  &lt;span&gt;05&lt;/span&gt;cf1ce8 &lt;span&gt;00000000&lt;/span&gt; &lt;span&gt;05&lt;/span&gt;ce5d68 &lt;span&gt;02610028&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;ce5d6c  &lt;span&gt;02610030&lt;/span&gt; &lt;span&gt;02610038&lt;/span&gt; &lt;span&gt;02610050&lt;/span&gt; &lt;span&gt;05&lt;/span&gt;cf1ce0 &lt;/span&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;仔细看输出，上面的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;05ce5d68&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 后面的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;02610028&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 就是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;System.Object.Finalize()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法，&lt;/span&gt;&lt;code&gt;&lt;span&gt;02610030&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对应着 &lt;/span&gt;&lt;code&gt;&lt;span&gt;System.Object.ToString()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4、&lt;/span&gt;&lt;code&gt;&lt;span&gt;call dword ptr [eax+10h]&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有了前面的基础，这句话就好理解了，它是从 &lt;/span&gt;&lt;code&gt;&lt;span&gt;m_pMultipurposeSlot2&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 结构中找 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SayHello&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 所在的单元指针位置，然后做 call 调用。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;000&lt;/span&gt;&amp;gt; !U &lt;span&gt;05&lt;/span&gt;cf1ce0  &lt;br/&gt;Unmanaged code  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf1ce0 e88f9dde74      call    coreclr!PrecodeFixupThunk (&lt;span&gt;7&lt;/span&gt;aadba74)  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf1ce5 &lt;span&gt;5&lt;/span&gt;e              pop     esi  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf1ce6 &lt;span&gt;0001&lt;/span&gt;            &lt;span&gt;add&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt; ptr [ecx],al  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf1ce8 e913050000      jmp     &lt;span&gt;05&lt;/span&gt;cf2200  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf1ced &lt;span&gt;5f&lt;/span&gt;              pop     edi  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf1cee &lt;span&gt;0300&lt;/span&gt;            &lt;span&gt;add&lt;/span&gt;     eax,dword ptr [eax]  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf1cf0 &lt;span&gt;245&lt;/span&gt;d            and     al,&lt;span&gt;5&lt;/span&gt;Dh  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf1cf2 ce              &lt;span&gt;into&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf1cf3 &lt;span&gt;0500000000&lt;/span&gt;      &lt;span&gt;add&lt;/span&gt;     eax,&lt;span&gt;0&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf1cf8 &lt;span&gt;0000&lt;/span&gt;            &lt;span&gt;add&lt;/span&gt;     &lt;span&gt;byte&lt;/span&gt; ptr [eax],al &lt;/span&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从汇编看，它还是一段 &lt;/span&gt;&lt;code&gt;&lt;span&gt;桩代码&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，言外之意就是该方法没有被 JIT 编译，如果编译完了，这里的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;05CF1CE0 05ce5d24 NONE ConsoleApp1.Chinese.SayHello()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  的 Entry (05CF1CE0) 也会被同步修改，验证一下很简单，我们继续 go 代码让其编译完成，然后再 dumpmt 。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;008&lt;/span&gt;&amp;gt; !dumpmt -md &lt;span&gt;05&lt;/span&gt;ce5d3c  &lt;br/&gt;EEClass:         &lt;span&gt;05&lt;/span&gt;cd3380  &lt;br/&gt;Module:          &lt;span&gt;05&lt;/span&gt;addb14  &lt;br/&gt;Name:            ConsoleApp1.Chinese  &lt;br/&gt;mdToken:         &lt;span&gt;02000007&lt;/span&gt;  &lt;br/&gt;File:            D:\net6\ConsoleApplication2\ConsoleApp1\bin\x86\Debug\net6&lt;span&gt;.0&lt;/span&gt;\ConsoleApp1.dll  &lt;br/&gt;BaseSize:        &lt;span&gt;0xc&lt;/span&gt;  &lt;br/&gt;ComponentSize:   &lt;span&gt;0x0&lt;/span&gt;  &lt;br/&gt;DynamicStatics:  &lt;span&gt;false&lt;/span&gt;  &lt;br/&gt;ContainsPointers &lt;span&gt;false&lt;/span&gt;  &lt;br/&gt;Slots &lt;span&gt;in&lt;/span&gt; VTable: &lt;span&gt;6&lt;/span&gt;  &lt;br/&gt;Number of IFaces &lt;span&gt;in&lt;/span&gt; IFaceMap: &lt;span&gt;0&lt;/span&gt;  &lt;br/&gt;--------------------------------------  &lt;br/&gt;MethodDesc Table  &lt;br/&gt;   Entry MethodDe    JIT Name  &lt;br/&gt;&lt;span&gt;02610028&lt;/span&gt; &lt;span&gt;02605568&lt;/span&gt;   NONE System.Object.Finalize()  &lt;br/&gt;&lt;span&gt;02610030&lt;/span&gt; &lt;span&gt;02605574&lt;/span&gt;   NONE System.Object.ToString()  &lt;br/&gt;&lt;span&gt;02610038&lt;/span&gt; &lt;span&gt;02605580&lt;/span&gt;   NONE System.Object.Equals(System.Object)  &lt;br/&gt;&lt;span&gt;02610050&lt;/span&gt; &lt;span&gt;026055&lt;/span&gt;ac   NONE System.Object.GetHashCode()  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;CF2270 &lt;span&gt;05&lt;/span&gt;ce5d24    JIT ConsoleApp1.Chinese.SayHello()  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;CF1CE8 &lt;span&gt;05&lt;/span&gt;ce5d30    JIT ConsoleApp1.Chinese..ctor()  &lt;br/&gt;  &lt;br/&gt;&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;008&lt;/span&gt;&amp;gt; dp &lt;span&gt;05&lt;/span&gt;ce5d3c L10  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;ce5d3c  &lt;span&gt;00000200&lt;/span&gt; &lt;span&gt;0000000&lt;/span&gt;c &lt;span&gt;00074088&lt;/span&gt; &lt;span&gt;00000005&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;ce5d4c  &lt;span&gt;05&lt;/span&gt;ce5ccc &lt;span&gt;05&lt;/span&gt;addb14 &lt;span&gt;05&lt;/span&gt;ce5d7c &lt;span&gt;05&lt;/span&gt;cd3380  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;ce5d5c  &lt;span&gt;05&lt;/span&gt;cf1ce8 &lt;span&gt;00000000&lt;/span&gt; &lt;span&gt;05&lt;/span&gt;ce5d68 &lt;span&gt;02610028&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;ce5d6c  &lt;span&gt;02610030&lt;/span&gt; &lt;span&gt;02610038&lt;/span&gt; &lt;span&gt;02610050&lt;/span&gt; &lt;span&gt;05&lt;/span&gt;cf2270  &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此时可以看到它由 &lt;/span&gt;&lt;code&gt;&lt;span&gt;05cf1ce0&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 变成了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;05cf2270&lt;/span&gt;&lt;/code&gt;&lt;span&gt;， 这个就是 JIT 编译后的方法代码，我们用 !U 反编译下。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;0&lt;/span&gt;:&lt;span&gt;008&lt;/span&gt;&amp;gt; !U &lt;span&gt;05&lt;/span&gt;cf2270  &lt;br/&gt;Normal JIT generated code  &lt;br/&gt;ConsoleApp1.Chinese.SayHello()  &lt;br/&gt;ilAddr &lt;span&gt;is&lt;/span&gt; &lt;span&gt;05E720&lt;/span&gt;D5 pImport &lt;span&gt;is&lt;/span&gt; &lt;span&gt;008F&lt;/span&gt;6E88  &lt;br/&gt;Begin &lt;span&gt;05&lt;/span&gt;CF2270, size &lt;span&gt;27&lt;/span&gt;  &lt;br/&gt;  &lt;br/&gt;D:\net6\ConsoleApplication2\ConsoleApp1\Program.cs @ &lt;span&gt;28&lt;/span&gt;:  &lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;05&lt;/span&gt;cf2270 &lt;span&gt;55&lt;/span&gt;              push    ebp  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf2271 &lt;span&gt;8b&lt;/span&gt;ec            mov     ebp,esp  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf2273 &lt;span&gt;50&lt;/span&gt;              push    eax  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf2274 &lt;span&gt;894&lt;/span&gt;dfc          mov     dword ptr [ebp&lt;span&gt;-4&lt;/span&gt;],ecx  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf2277 &lt;span&gt;833&lt;/span&gt;d74dcad0500  cmp     dword ptr ds:[&lt;span&gt;5&lt;/span&gt;ADDC74h],&lt;span&gt;0&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf227e &lt;span&gt;7405&lt;/span&gt;            je      &lt;span&gt;05&lt;/span&gt;cf2285  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf2280 e8cb2bf174      call    coreclr!JIT_DbgIsJustMyCode (&lt;span&gt;7&lt;/span&gt;ac04e50)  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf2285 &lt;span&gt;90&lt;/span&gt;              nop  &lt;br/&gt;  &lt;br/&gt;D:\net6\ConsoleApplication2\ConsoleApp1\Program.cs @ &lt;span&gt;29&lt;/span&gt;:  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf2286 &lt;span&gt;8b&lt;/span&gt;0d74207e04    mov     ecx,dword ptr ds:[&lt;span&gt;47E2074&lt;/span&gt;h] (&lt;span&gt;&quot;chinese&quot;&lt;/span&gt;)  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf228c e8dffbffff      call    &lt;span&gt;05&lt;/span&gt;cf1e70  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf2291 &lt;span&gt;90&lt;/span&gt;              nop  &lt;br/&gt;  &lt;br/&gt;D:\net6\ConsoleApplication2\ConsoleApp1\Program.cs @ &lt;span&gt;30&lt;/span&gt;:  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf2292 &lt;span&gt;90&lt;/span&gt;              nop  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf2293 &lt;span&gt;8b&lt;/span&gt;e5            mov     esp,ebp  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf2295 &lt;span&gt;5&lt;/span&gt;d              pop     ebp  &lt;br/&gt;&lt;span&gt;05&lt;/span&gt;cf2296 c3              ret  &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;终于这就是多态下的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;ConsoleApp1.Chinese.SayHello&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法啦。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;三、总结&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本质上来说，CoreCLR 也是 C++ 写的，所以也逃不过用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;虚表&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来实现多态的玩法， 不过玩法也稍微复杂了一些，希望本篇对大家有帮助。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>85f107e085cc5f9eff9ba0e4fa826783</guid>
<title>实时预览组件效果，这个库让你方便到哭</title>
<link>https://toutiao.io/k/iwcb0r0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是&lt;strong&gt;零一&lt;/strong&gt;，看到一个好东西，忍不住来分享一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在写需求时都会封装一些组件，然后会为该组件定义一些 &lt;code&gt;props&lt;/code&gt; ，使其跟业务分离，变得更通用。写完组件后需要验证一下组件的效果，也就需要简单 &lt;code&gt;mock&lt;/code&gt; 一下数据传进去，然后跑一下项目看一下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// components/card/index.tsx  Card 组件 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 咱先来写个组件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Card&lt;/span&gt; (&lt;span&gt;props&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; { name } = props&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;div&amp;gt;{name}&amp;lt;&lt;span&gt;/div&amp;gt;&lt;br/&gt;  )&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// index.tsx  项目根目录&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 组件写好了，找个地方引入一下，传点数据进去，免得项目崩了&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Card form &lt;span&gt;&#x27;card&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;App&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;Card name=&lt;span&gt;&quot;零一&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;  )&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; &lt;span&gt;# 跑一下项目，看看刚才写的组件的效果&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; yarn dev&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这套流程，你是不是很熟悉？大家可能都是这么干的，看完效果后还要回过头去把刚刚不要的测试代码都删掉&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而，我找到了一个非常好用的 &lt;strong&gt;Vscode 插件&lt;/strong&gt; 大大简化了这个流程！！！！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它就是 &lt;strong&gt;Preview.js&lt;/strong&gt; ，一个用于项目中组件实时预览的插件&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它有什么&lt;strong&gt;优点&lt;/strong&gt;？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;支持 &lt;code&gt;React（v16+）&lt;/code&gt;、&lt;code&gt;Vue2&lt;/code&gt;、&lt;code&gt;Vue3&lt;/code&gt;、&lt;code&gt;SolidJS&lt;/code&gt;，并即将支持 &lt;code&gt;Preact&lt;/code&gt; 和 &lt;code&gt;Svelte&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;无需启动项目，直接静态预览组件效果&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自动识别组件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自动生成 props 的 mock 数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实时刷新，无需疯狂点保存触发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以针对同一个组件生成多个预览，并可快速切换&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持调整页面比例，以及切换不同分辨率的设备&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;暗黑模式切换&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;直接搜索项目中的其它组件，快速切换&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;香不香？我反正已经上手使用过了，是真的香！之前我自己也做过组件库的项目，写完一个组件，就需要写一个 &lt;code&gt;example&lt;/code&gt; 去看看效果，要是用了这个插件，项目也不用跑，实时预览，该有多爽啊（正在开发组件库的同学看过来，福利啊）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再讲一下这个插件的&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;插件是刚出的，可能会有一些bug，这是难免的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;上述优点中，6、7、8都是需要付费的，不过目前可以白嫖，等会讲&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;待发现...&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但我目前用下来是没啥问题的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;接下来带大家体验一下&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;安装&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接在 VsCode 的插件市场搜索：&lt;code&gt;Preview.js&lt;/code&gt;，安装即可&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23484848484848486&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTczSTEMHXML94icmpicms8BanXlbZzZIGH5UyREr8fOEkMfMgjUyxpZQX1lSvj8OX6ia86rnUT7XAqREQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;528&quot;/&gt;&lt;figcaption&gt;安装插件&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后最好重启一下 VsCode&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;emmmm，大多数同学应该会收到这样一条报错信息：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16373056994818652&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTczSTEMHXML94icmpicms8BanXxY4e33SNicjW1noGK6tiarvb99RgfiaZEyCJFaL1XoictCpKrJUb01PBdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1930&quot;/&gt;&lt;figcaption&gt;npm 版本过低&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为重启后的初始化阶段，&lt;code&gt;Preview.js&lt;/code&gt; 插件会安装一些依赖包，并且它们最低支持的 &lt;code&gt;npm&lt;/code&gt; 版本是 &lt;code&gt;7+&lt;/code&gt;，估摸着大部分同学的 &lt;code&gt;npm&lt;/code&gt; 包都是小于 7 的，所以还是建议大家想要使用时切换一下 &lt;code&gt;node&lt;/code&gt; 版本，比如用 &lt;code&gt;nvm use 17.5.0&lt;/code&gt;，此时的 &lt;code&gt;npm&lt;/code&gt; 版本就到了 &lt;code&gt;8+&lt;/code&gt; 了，满足了需求，此时还需要重启一次&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;稍微耐心等待几秒钟，等它的依赖包都装好就ok了&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40804597701149425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTczSTEMHXML94icmpicms8BanXuX0AZo3VoefWCxYy9p5YYIsgVGj7NaUsaBPFLXR8QSImZTptU0YqOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1044&quot;/&gt;&lt;figcaption&gt;preview.js 依赖包安装成功&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基本使用&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;为了方便起见，我就拿 &lt;code&gt;React&lt;/code&gt; 的代码来做示例了，但刚才提到那些库也都是支持的哈，大家可以自行尝试&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;咱们随便找到项目中的一个组件打开&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6751968503937008&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTczSTEMHXML94icmpicms8BanXK4KX5F4EhzyiaDMV1IPicT0FgLGreUmoOHUG69juxXYzjYCb0A3Xszicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1016&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，插件自动识别到了我的 &lt;code&gt;Card&lt;/code&gt; 组件，并在上方悬浮了一个 &lt;code&gt;Open Card in Preview.js&lt;/code&gt; 的灰色按钮，点击以后右边就会出来一个预览窗口了（此时咱们都还没启动项目）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4347442680776014&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/lgHVurTfTczSTEMHXML94icmpicms8BanXLAGZicvdPVzrjIlxGymV1g7OEFfjnmmL2VhFVggQFribK03ia9Lo1A9Bg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1134&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还能看到，右下角也帮我们生成了该组件需要的 &lt;code&gt;props&lt;/code&gt; 的 mock 数据，不过这个前提条件是你项目是 TS 的，并且给 props 限定了类型才行，否则是不行的（我试过了）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一切（新增组件、修改文本、修改样式...）的修改都是实时的（除了修改 props 类型），我们来看一下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43562610229276894&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/lgHVurTfTczSTEMHXML94icmpicms8BanXvmkEichQYP8fLzz1Iq50uh6CrpkSCucN6oTobdT72yAD5rQBIIr5XJw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1134&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类型修改不能实时也算是一个小缺点，希望后续可以改进一下。如果咱们改了类型，目前只需重启预览窗口就可以了，点底部的刷新是没用的&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Pro 级别的功能&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来是高级用户可以使用的功能，我看到他们官网是有申请 30 天免费体验资格的，为了本文的效果，我先申请了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;申请网址：https://previewjs.com/checkout&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;填一下自己的邮箱，就申请成功了&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44224037339556593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTczSTEMHXML94icmpicms8BanXHcz0lmrJtPyr4wujjruNAhPicIjcomuYdaVJqRzLlc7syPxicGjd8XsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1714&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后它会把一个兑换码发到你的邮箱里&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.834319526627219&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTczSTEMHXML94icmpicms8BanX3KicO7kaAmxEO4NvHJPMiazSKE26N0j4yTzkQ7aVeVmyxqAPD7SYFp4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1014&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拿着这个码去 VsCode 的 Preview.js 预览窗口里填写即可&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.875438596491228&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTczSTEMHXML94icmpicms8BanXRhI7Zscv7Gq4yiaKibqIvmOg0yfrtQlTlnpBUTMzAVhe9SknibDribsZZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1140&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6686991869918699&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTczSTEMHXML94icmpicms8BanXbstpk3ETvKM8mHBKwTpgxyouGUqIrpXhniaib7iclSUQqNjYtib69pG4KQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;984&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后就成功了，页面现在多了一堆功能&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8880994671403197&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lgHVurTfTczSTEMHXML94icmpicms8BanXH6QuCYGplYleMibCLJ0W0LJk034bdOtgwiaYw0kbgXSPEJ2ZXWj4NiaZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1126&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来统一体验一下吧&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8774422735346359&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/lgHVurTfTczSTEMHXML94icmpicms8BanXATlTnfBrDE2VzbZIUWAKlmgTRCgz9ib4KEUPF30okR0IHe5KXfsfpKg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;563&quot;/&gt;&lt;figcaption&gt;体验pro付费功能&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总体来说这个插件已经很 nice 了，即使不用付费版本的功能，也可以满足基本的需求，而且这个功能在写业务时非常有用，大大提高工作效率，&lt;strong&gt;真的真的强烈推荐！！！！&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;Preview.js&lt;/strong&gt;: https://previewjs.com/&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;296&quot; data-ratio=&quot;0.5299270072992701&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/5Q3ZxrD2qNDvxh93JHfZD80m7GhBmGicoYpnLCanxmxvpVm4ACYNms63xnCgKt1Py5rvMCEDkWebYCTpfDVBq7g/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;685&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong/&gt;&lt;strong&gt;&lt;span&gt;彦祖，亦菲，&lt;/span&gt;&lt;span&gt;点个&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;「在看」&lt;/strong&gt;&lt;span&gt;吧&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6b3d7937e0590aa1774f4ed47d47b3c0</guid>
<title>我们用了一个周末，将 370 万行代码迁移到了 TypeScript</title>
<link>https://toutiao.io/k/f0k1f3t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6546875&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/XIibZ0YbvibkXxRibhFyECpxpL8zzEgiay6xr4cCALjHuObKCg8sWAibMQNLuXdt3GqtyyZrIVdY5CFFj7Kgh1S6srQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;section&gt;作者 | Andrew Lunny&lt;/section&gt;&lt;section&gt;译者 | 核子可乐&lt;/section&gt;&lt;section&gt;策划 | Tina&lt;/section&gt;&lt;p&gt;TypeScript 是增长最快的语言之一，最近几年逐渐成为很多大厂的首选工具。最近，Stripe 将最大的 JavaScript 代码库（用于支持 Stripe Dashboard 功能）从 Flow 迁移到了 TypeScript。于是通过单一 PR 请求，转换了超过 370 万行代码。第二天，几百名工程师快速跟进，开始为自己的项目编写 TypeScript。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4329896907216495&quot; data-type=&quot;png&quot; data-w=&quot;485&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VMWOb2bsib7H0UAXEqAHYibibYbFuzUbib1KmzUGiabRk6dlTSyyzasD5hOnTicYY9hFn5EsLjaib3lTdibzA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;TypeScript 目前已经成为 JavaScript 类型检查的客观标准，Stripe 已经把这次使用的 TypeScript 转换工具分享到 GitHub&lt;span&gt;（https://github.com/stripe-archive/flow-to-typescript-codemod）&lt;/span&gt;，希望帮助更多朋友能够轻松完成类似的大规模迁移。&lt;/p&gt;&lt;p&gt;以下是他们迁移的具体步骤：&lt;/p&gt;&lt;section&gt;&lt;section&gt;
&lt;span&gt;Stripe 的 JavaScript 类型检查简史&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;Stripe 是一款诞生于 2012 年的大规模前端应用程序，共包含 stripe.com、Stripe JS 和 Stripe Dashboard 几大组成部分。随着业务的发展，我们开始对 JS 代码进行类型检查以提高产品质量和可靠性。2016 年，我们率先采用了 Flow——这是 Facebook 当时专门开发的 JavaScript 类型检查系统。之后几年间，Flow 一直为我们大部分前端应用程序的类型安全保驾护航。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4693140794223827&quot; data-type=&quot;png&quot; data-w=&quot;554&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VMWOb2bsib7H0UAXEqAHYibibYjCrsdsiaYpkOq4zEpGeZU2SvLxRvicOIy6uRG2la3THnfqUibuOuk02wA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为 API 资源和关联端点生成的 Flow 类型示例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;然而，工程师们在实际使用中发现 Flow 仍有诸多不足。首先，这款类型检查器会轻松耗尽笔记本电脑的内存，而编辑器内集成也速度缓慢、可靠性低下。与此同时，微软开发的另外一种类型系统 TypeScript 却在异军突起，凭借着完善的工具组合和强大社区而广受好评。于是，越来越多的 Stripe 工程师呼吁转向 TypeScript。&lt;/p&gt;&lt;p&gt;Stripe 拥有专门的开发者生产力团队，职责就是为工程师们提供最高效、最顺手的开发环境，所以他们的满意度就是生产力团队的使命。我们一直在努力确定开发者们最关心的紧迫问题：例如，我们在全部开发工具中都集成了上报错误 / 不便的功能，确保将情况快速发送给相关团队以评判优先级。对 TypeScript 的支持已经相当紧迫，于是支持团队决定在整个公司内帮助前端工程师转向 TypeScript。&lt;/p&gt;&lt;section&gt;&lt;section&gt;
&lt;span&gt;选择正确的迁移策略&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;在所有前端代码库中，最大的那个负责为 Stripe Dashboard 和其他一些面向用户的产品提供支持。Dashboard 代码库中的不同组件保持着紧密耦合，而且没有清晰拆分的依赖图表。如果选择面向 TypeScript 开展增量迁移，就意味着开发人员在一段时间内必须同时使用两种语言来完成常见任务。此外，我们还需要一个互操作层来同步两种语言之间的类型定义，并在整个开发过程中始终保持二者一致。&lt;/p&gt;&lt;p&gt;2020 年末，我们组建了一支新的横向 JavaScript 基础设施团队：在这里，工程师们只关注一项工作——提升 Stripe 编写 JS 代码时的体验。而团队的首要挑战之一，就是用 TypeScript 替换掉 Flow，同时回避掉漫长且充满不确定性的迁移过程。&lt;/p&gt;&lt;p&gt;我们首先与其他开展过类似迁移的企业进行交谈，并参考了 Airtable 和 Zapier 的经历回顾文章。这两家企业都开发出自动化脚本，用于将一种语言转换成另一种语言、贯穿整个代码库运行，再把输出结果合并成单一提交。Airtable 已经把自己的转换脚本以“codemod”源到源转换工具的形式上传至 GitHub，它就完全能够解析 Flow 代码并生成相应的 TypeScript。&lt;/p&gt;&lt;p&gt;这种迁移方式大大降低了工程师们的工作负担，也不需要为相同的产品维护两套类型系统。这么一看，从 Flow 到 TypeScript 的道路顿时平坦了起来。&lt;/p&gt;&lt;section&gt;&lt;section&gt;
&lt;span&gt;规划、筹备和迭代&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;Airtable 工具那出色的代码转换质量给我们留下了深刻印象，于是 Stripe 决定把它作为迁移工作的基础。这里要感谢 Airtable 团队开发并分享的这份工作成果——开源社区正是在无数这类案例的支持下，才变得如此兴盛蓬勃。&lt;/p&gt;&lt;p&gt;我们首先将 Airtable 的 codemod 复制到 Stripe 的 monorepo 当中，从而指向内部代码来运行。我们的 JS 项目中大量用到了 Sail——一个由严格类型化 React 组件构成的共享设计系统，所以我们决定在迁移之初先从 Sail 入手。我们为 Sail 生成了 TypeScript 定义，而非直接把代码转换成 TypeScript，这样就能保证它同时支持用 Flow 和 TypeScript 编写的应用程序。为了安全支持这两种类型系统，我们编写了测试来验证 TypeScript 定义对于底层 Flow 代码做出的具体更改。这种方法对于大规模代码库来说可能太过麻烦，好在 Sail 组件拥有明确且严格的接口，所以我们的测试倒是相当顺遂。&lt;/p&gt;&lt;p&gt;还有个问题，codemod 的底子很好、但功能并不全面：对于很多文件，它在转换中可能发生崩溃，输出结果也不够完善。所以在几个月时间里，我们通过一次次迭代解决了这些较为极端的句法和语义案例。&lt;/p&gt;&lt;p&gt;举个简单的例子，JS 箭头函数可以在没有 return 语句时直接返回单一表达式，如下所示：&lt;/p&gt;&lt;p&gt;const linesOfCode = () =&amp;gt; 7;&lt;/p&gt;&lt;p&gt;JS 对象字面量会使用大括号来体现属性定义。但因为大括号也被用于描述语句块，所以要从箭头函数返回对象字面量，还需要引入一组额外的括号来消除歧义：&lt;/p&gt;&lt;p&gt;const currencyMap = () =&amp;gt; ({ca:&#x27;CAD&#x27;,us:&#x27;USD&#x27;});&lt;/p&gt;&lt;p&gt;我们注意到，codemod 会错误删除掉箭头函数中这些额外的括号，但这个问题只发生在泛型函数（接受类型参数的函数）当中。可一旦删除，结果语法在标准 JS 中将不再可用：&lt;/p&gt;&lt;p&gt;// bad!&lt;/p&gt;&lt;p&gt;const wrapper = (arg:T) =&amp;gt; {wrapped: T};&lt;/p&gt;&lt;p&gt;于是我们修复了这个问题，并添加测试以防止其再次发生。整个迁移过程中，我们进行了大量类似的语法修复，才最终让之前庞大的代码库“旧月的换新颜”。&lt;/p&gt;&lt;p&gt;在确保 Sail 能够在 TypeScript 中正常起效之后，我们又开发了几个包含数百个 JS 模块的内部应用程序。我们还向 codemod 中添加二次检查，希望进一步减少生成代码中的错误，同时使用 TypeScript 的 @ts-expect-error 注释来标记这些错误。可以看到，我们的基本思路并不是提前解决掉每个错误，而是尽快替换掉 Flow，并在过程当中跟踪实际发生的 TypeScript 错误抑制并加以解决。&lt;/p&gt;&lt;p&gt;Dashboard 代码库的初始阶段共引发超过 97000 个错误抑制。在更新了 codemod 的迭代方法之后，这个数字被控制到了 37000 个，相当于每千行代码有 1 个错误抑制。相比之下，Flow 代码这边的错误抑制大概是 5000 个。Flow 和 TypeScript 都支持对类型覆盖率进行测量，而我们惊喜地发现虽然 TypeScript 这边的抑制数字更大，但这主要是因为其报告覆盖率要比 Flow 更高。这应该是因为 TypeScript 中的可用第三方类型定义在数量和质量上都优于 Flow，而后者则因为缺少这些定义而导致类型覆盖率不足。&lt;/p&gt;&lt;p&gt;不过面对包含数万个模块的 Dashboard 时，我们的方法对 TypeScript 编译器产生了巨大的内存压力。而解决这个问题的主要工具，就是 TypeScript 项目引用：尽管 Dashboard 并不进行模块区分，但我们还是正确推断出了它的模块结构，并据此建立起项目引用。通过这种方式，我们得以直接在代码库之上运行 TypeScript，且无需重构大量应用程序代码。&lt;/p&gt;&lt;section&gt;&lt;section&gt;
&lt;span&gt;正式上线&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;每周，都有数百名工程师在奋力推进 Dashboard 项目的迁移工作。但如此彻底的变动不容小觑，我们也不想在周内工作量合并这些更新。因此，团队决定选择 3 月 6 日星期天锁定 Stripe monorepo，同时上线我们的新分支。&lt;/p&gt;&lt;p&gt;在合并前一周，我们开始通过 CI 系统将 build 传递并部署到 QA 环境当中。毕竟除了 TypeScript 对项目本体的检查之外，我们还得更新 ESLint、Jest、Webpack、Metro 等负责处理源代码的其他工具。&lt;/p&gt;&lt;p&gt;这里出现了一个特别的痛点：Jest 快照测试。Jest 生成的快照文件中，会包含一条对快照生成文件的硬编码引用。由于 codemod 会给 TypeScript 文件生成.ts 或者.tsx 的扩展名，所以快照文件所引用的测试源将直接失效。为此，我们决定把生成文件的扩展名统一成.tsx，这样就可以批量重写快照并保证测试 100% 通过。&lt;/p&gt;&lt;p&gt;此外，我们还发现对某些 TypeScript 兼容代码的修复会带来不少工作量，甚至把日程安排推迟数周。其中的典型案例就是我们自定义的 ESLint 规则：其中一项规则会重新排序导入以强制保证各文件间的一致性，但该规则是针对 Babel 的 Flow 解析器编写的，所以生成的抽象语法树与 TypeScript 解析器会略有不同。在这种情况下，我们决定先禁用某些检查，并在转换完成后再行恢复。&lt;/p&gt;&lt;p&gt;通过手动上传 build，我们在 Dashboard 中与面向用户功能的产品团队成功会合。尽管 Dashboard 拥有广泛的单元和功能测试，但端到端测试覆盖率却比较有限。因此，各产品相关方就必须有能力开展手动测试。测试中同样暴露出不少小 bug，我们抢在最后一周成功将其解决：例如，由于翻译加载代码中存在一个硬编码.js 扩展名，因此我们无法为非英文版 Dashboard 用户正确加载翻译内容。&lt;/p&gt;&lt;p&gt;整个过程给了我们很大信心，但这种颠覆性的变更还是让大家有点忐忑：虽然我们牢牢掌握着开发工具和构建过程，但毕竟代码库中的每个文件都发生了变化。转换脚本中的任何一点细微错误（例如从多个组件间共享的对象中删除一个空字段）都有可能引发面向用户的错误，而任何现有自动化测试都发现不了这样的错误。另外，这类故障可能会有多种表现方式，例如引发下游开发工具报错、或者导致构建失败等。为了及时发现这些意外状况，我们只能依靠自动化与环境监控工具，同时建立了专门的协调部署 Slack 频道，保证面向用户的团队能够及时收到报告并快速着手修复。&lt;/p&gt;&lt;p&gt;3 月 5 日星期六，团队生成了新的迁移分支并运行了我们的自动化脚本。之后，我们将该分支部署到 QA 环境并重复验证过程，包括产品团队提议的手动测试。期间没有发现任何新问题，看起来一切合并准备均已就绪。&lt;/p&gt;&lt;p&gt;3 月 6 号星期天一大早，我们就锁定了 Stripe monorepo，又对迁移分支进行卫次 QA 测试，之后果断提交了变更。整个合并过程干净利落，我们的自动化测试也全部通过。就这样，TypeScript 顺顺当当进入了生产部署。&lt;/p&gt;&lt;p&gt;凭借这一年来的细心调整与严谨测试，新代码在接收生产流量后没有发生任何意外。我们随后解锁了 repo，让开发者们看到现在的 Dashboard 已经运行在 TypeScript 当中了。&lt;/p&gt;&lt;p&gt;有一天我正在面新员工，碰巧听说公司打算从 Flow 迁移到 TypeScript。&lt;/p&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;95&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;其实我是有点怀疑的，毕竟之前不少团队在小型代码库上都身陷泥潭、纠缠不清，这么大规模的迁移能顺利完成吗？但礼拜一的现实证明我想多了——一切如常。&lt;/section&gt;&lt;section&gt;&lt;strong&gt;Eric Clemmons&lt;/strong&gt;, Stripe 软件工程师&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;迁移一结束，公司内可以说是好评如潮。完善顺畅的迁移给工程师们留下了深刻印象，甚至有人认为这是 Stripe 多年以来最成功的一次开发者生产力提升。我们很高兴这一年的付出没有白费，Stripe 的代码库终于获得了显著、甚至可以说是颠覆性的改进。&lt;/p&gt;&lt;section&gt;&lt;section&gt;
&lt;span&gt;TypeScript……两个月之后&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;转换当然不可能毫无瑕疵。在接下来的几周内，我们的 JS 基础设施团队又先后解决了几个意外问题。但最让人吃惊的，是有工程师报告 CI 和本地 TypeScript 运行间存在不一致。在 TypeScript 中，我们直接使用由 npm 安装的各种第三方类型定义，而如果定义被更新，工程师们就得安装新版本。而这明显跟我们的 Flow 配置不同，其中的依赖更新很少会改变具体类型，因此我们只能提醒工程师们运行 yarn install 进行调试。&lt;/p&gt;&lt;p&gt;此外还有其他工作要做：我们知道更细粒度的项目引用可以进一步提高性能，更好的缓存设计则能加快 CI 运行速度。然而，这么点好处并不值得大费周章。工程师们喜欢使用自动依赖导入和代码补齐之类的功能，也离不开 TypeScript 社区中广泛的第三方类型定义和集成语料库。这也保证了当有新工程师加入 Stripe 编写前端代码时，他们能第一时间使用自己最熟悉的语言、把全部精力都投入到功能设计上。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6750902527075813&quot; data-type=&quot;png&quot; data-w=&quot;554&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YriaiaJPb26VMWOb2bsib7H0UAXEqAHYibibYpngnnyL7QxiaXaF6m46aDZ07O3uaxCHcA1jThjcbyrP1QzFF41v2KicA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;随着 Dashboard 迁移工作的完成，JS 基础设施团队开始进一步提高 TypeScript 在整个公司内的采用率。我们使用相同的工具又先后转移了不少其他代码库，包括我们的全部支付 UI Stripe Checkout。Stripe 的前端工程师们很快就适应了这一切，开始用 TypeScript 编写所有开发项目。&lt;/p&gt;&lt;p&gt;而且我们从迁移计划立项之初就在发布更新，相当于搞了个全程直播，反响同样热烈。来自整个行业的开发者纷纷给予关注，并在自己的代码库中尝试应用相同的改进。为了支持大家，我们决定在 GitHub 上分享 Stripe 的 TypeScript 转换代码&lt;span&gt;（https://github.com/stripe-archive/flow-to-typescript-codemod）&lt;/span&gt;，希望能起到些许积极作用。&lt;/p&gt;&lt;p&gt;除了关于 JavaScript、Flow 和 TypeScript 的种种细节之外，我们还从此次迁移中总结出另一条重要经验：只要勤奋、专注、乐观，对大规模代码库做出显著改进并非不可能。我们将保持住这份热情，为 Stripe 乃至整个行业内的工程师带来更高的生产效率与更丝滑的工作体验。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原文链接：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://stripe.com/blog/migrating-to-typescript&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>