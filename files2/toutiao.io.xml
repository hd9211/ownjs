<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e9e7c4768f77850c84bff441b02d87ab</guid>
<title>25 张图，一万字，拆解 Linux 网络包发送过程</title>
<link>https://toutiao.io/k/z26byeu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;问1：我们在查看内核发送数据消耗的 CPU 时，是应该看 sy 还是 si ？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;问2：为什么你服务器上的 /proc/softirqs 里 NET_RX 要比 NET_TX 大的多的多？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;问3：发送网络数据的时候都涉及到哪些内存拷贝操作？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些问题虽然在线上经常看到，但我们似乎很少去深究。如果真的能透彻地把这些问题理解到位，我们对性能的掌控能力将会变得更强。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;带着这三个问题，我们开始今天对 Linux 内核网络发送过程的深度剖析。还是按照我们之前的传统，先从一段简单的代码作为切入。如下代码是一个典型服务器程序的典型的缩微代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;int &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;(){  &lt;br/&gt; fd = socket(AF_INET, SOCK_STREAM, 0);  &lt;br/&gt; &lt;span&gt;bind&lt;/span&gt;(fd, ...);  &lt;br/&gt; listen(fd, ...);  &lt;br/&gt;  &lt;br/&gt; cfd = accept(fd, ...);  &lt;br/&gt;  &lt;br/&gt; // 接收用户请求  &lt;br/&gt; &lt;span&gt;read&lt;/span&gt;(cfd, ...);  &lt;br/&gt;  &lt;br/&gt; // 用户请求处理  &lt;br/&gt; dosometing();   &lt;br/&gt;  &lt;br/&gt; // 给用户返回结果  &lt;br/&gt; send(cfd, buf, sizeof(buf), 0);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们来讨论上述代码中，调用 send 之后内核是怎么样把数据包发送出去的。本文基于Linux 3.10，网卡驱动采用Intel的igb网卡举例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;预警：本文共有一万多字，25 张图，长文慎入！&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、Linux 网络发送过程总览&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我觉得看 Linux 源码最重要的是得有整体上的把握，而不是一开始就陷入各种细节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我这里先给大家准备了一个总的流程图，简单阐述下 send 发送了的数据是如何一步一步被发送到网卡的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNX1x1UEBIyveezFWoBqbfqcQO85kXF1L3YvcIS86ianMkm25OeWHg9sw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.9399141630901288&quot; data-w=&quot;466&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这幅图中，我们看到用户数据被拷贝到内核态，然后经过协议栈处理后进入到了 RingBuffer 中。随后网卡驱动真正将数据发送了出去。当发送完成的时候，是通过硬中断来通知 CPU，然后清理 RingBuffer。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为文章后面要进入源码，所以我们再从源码的角度给出一个流程图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNN5ndOR5DB5xHMjaV4XlJnY9iajk0ia1nAsm7CDzBrUDNzuiaJy4wPSL3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;3.65283540802213&quot; data-w=&quot;723&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然数据这时已经发送完毕，但是其实还有一件重要的事情没有做，那就是释放缓存队列等内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那内核是如何知道什么时候才能释放内存的呢，当然是等网络发送完毕之后。网卡在发送完毕的时候，会给 CPU 发送一个硬中断来通知 CPU。更完整的流程看图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNHO50EyzavTV4lzNMXbgmqXBzwibOH4fe4SEpTMYX93nHYf1MUDiaAPgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.525874125874126&quot; data-w=&quot;715&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，我们今天的主题虽然是发送数据，但是硬中断最终触发的软中断却是 NET_RX_SOFTIRQ，而并不是 NET_TX_SOFTIRQ ！！！（T 是 transmit 的缩写，R 表示 receive）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;意不意外，惊不惊喜？？？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这就是开篇问题 1 的一部分的原因（注意，这只是一部分原因）。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;问1：在服务器上查看 /proc/softirqs，为什么 NET_RX 要比 NET_TX 大的多的多？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传输完成最终会触发 NET_RX，而不是 NET_TX。所以自然你观测 /proc/softirqs 也就能看到 NET_RX 更多了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好，现在你已经对内核是怎么发送网络包的有一个全局上的把握了。不要得意，我们需要了解的细节才是更有价值的地方，让我们继续！！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、网卡启动准备&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在的服务器上的网卡一般都是支持多队列的。每一个队列上都是由一个 RingBuffer 表示的，开启了多队列以后的的网卡就会对应有多个 RingBuffer。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNdydA6qUibicwic6KVIO5L9v0ZqYx7WRbnDK7NbylJiaFruhSNRrNDcklLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.3608521970705726&quot; data-w=&quot;751&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网卡在启动时最重要的任务之一就是分配和初始化 RingBuffer，理解了 RingBuffer 将会非常有助于后面我们掌握发送。因为今天的主题是发送，所以就以传输队列为例，我们来看下网卡启动时分配 RingBuffer 的实际过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在网卡启动的时候，会调用到 __igb_open 函数，RingBuffer 就是在这里分配的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: drivers/net/ethernet/intel/igb/igb_main.c  &lt;br/&gt;static int __igb_open(struct net_device *netdev, bool resuming)  &lt;br/&gt;{  &lt;br/&gt; struct igb_adapter *adapter = netdev_priv(netdev);  &lt;br/&gt;  &lt;br/&gt; //分配传输描述符数组  &lt;br/&gt; err = igb_setup_all_tx_resources(adapter);  &lt;br/&gt;  &lt;br/&gt; //分配接收描述符数组  &lt;br/&gt; err = igb_setup_all_rx_resources(adapter);  &lt;br/&gt;  &lt;br/&gt; //开启全部队列  &lt;br/&gt; netif_tx_start_all_queues(netdev);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面 __igb_open 函数调用 igb_setup_all_tx_resources 分配所有的传输 RingBuffer, 调用 igb_setup_all_rx_resources 创建所有的接收 RingBuffer。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: drivers/net/ethernet/intel/igb/igb_main.c  &lt;br/&gt;static int igb_setup_all_tx_resources(struct igb_adapter *adapter)  &lt;br/&gt;{  &lt;br/&gt; //有几个队列就构造几个 RingBuffer  &lt;br/&gt; &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; adapter-&amp;gt;num_tx_queues; i++) {  &lt;br/&gt;  igb_setup_tx_resources(adapter-&amp;gt;tx_ring[i]);  &lt;br/&gt; }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;真正的 RingBuffer 构造过程是在 igb_setup_tx_resources 中完成的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: drivers/net/ethernet/intel/igb/igb_main.c  &lt;br/&gt;int igb_setup_tx_resources(struct igb_ring *tx_ring)  &lt;br/&gt;{  &lt;br/&gt; //1.申请 igb_tx_buffer 数组内存  &lt;br/&gt; size = sizeof(struct igb_tx_buffer) * tx_ring-&amp;gt;count;  &lt;br/&gt; tx_ring-&amp;gt;tx_buffer_info = vzalloc(size);  &lt;br/&gt;  &lt;br/&gt; //2.申请 e1000_adv_tx_desc DMA 数组内存  &lt;br/&gt; tx_ring-&amp;gt;size = tx_ring-&amp;gt;count * sizeof(union e1000_adv_tx_desc);  &lt;br/&gt; tx_ring-&amp;gt;size = ALIGN(tx_ring-&amp;gt;size, 4096);  &lt;br/&gt; tx_ring-&amp;gt;desc = dma_alloc_coherent(dev, tx_ring-&amp;gt;size,  &lt;br/&gt;        &amp;amp;tx_ring-&amp;gt;dma, GFP_KERNEL);  &lt;br/&gt;  &lt;br/&gt; //3.初始化队列成员  &lt;br/&gt; tx_ring-&amp;gt;next_to_use = 0;  &lt;br/&gt; tx_ring-&amp;gt;next_to_clean = 0;  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上述源码可以看到，实际上一个 RingBuffer 的内部不仅仅是一个环形队列数组，而是有两个。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）igb_tx_buffer 数组：这个数组是内核使用的，通过 vzalloc 申请的。&lt;br/&gt;2）e1000_adv_tx_desc 数组：这个数组是网卡硬件使用的，硬件是可以通过 DMA 直接访问这块内存，通过 dma_alloc_coherent 分配。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候它们之间还没有啥联系。将来在发送的时候，这两个环形数组中相同位置的指针将都将指向同一个 skb。这样，内核和硬件就能共同访问同样的数据了，内核往 skb 里写数据，网卡硬件负责发送。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNshNxj7ESgnlCGrw6pp71S9AmZKBZNzibib8HyZ5BMOlO1noHLCDImBUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.4416243654822335&quot; data-w=&quot;591&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后调用 netif_tx_start_all_queues 开启队列。另外，对于硬中断的处理函数 igb_msix_ring 其实也是在 __igb_open 中注册的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、accept 创建新 socket&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在发送数据之前，我们往往还需要一个已经建立好连接的 socket。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们就以开篇服务器缩微源代码中提到的 accept 为例，当 accept 之后，进程会创建一个新的 socket 出来，然后把它放到当前进程的打开文件列表中，专门用于和对应的客户端通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设服务器进程通过 accept 和客户端建立了两条连接，我们来简单看一下这两条连接和进程的关联关系。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNf9vlJUUicDicIQQRX6Gm7sibzKTxeCPeXLkmNNszwdy512ny7LFmdYhXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.3532219570405728&quot; data-w=&quot;838&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中代表一条连接的 socket 内核对象更为具体一点的结构图如下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNRlsujDHEyc56Miaicdz52ibMTZk9JRv6RH8ibk7ZoommWkyVic9jhl8NaJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.7654155495978552&quot; data-w=&quot;746&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了避免喧宾夺主，accept 详细的源码过程这里就不介绍了，感兴趣请参考 &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAwNjMxMTA5Mw==&amp;amp;mid=2651343800&amp;amp;idx=1&amp;amp;sn=eebe219df007e200a4b9a777b32f4c06&amp;amp;chksm=80f3b662b7843f743a65d22c437b9f5f80ec8ee79d1a3d8ecd637ab4b66c13d85326b135a9ee&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！》&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《图解 | 深入揭秘 epoll 是如何实现 IO 多路复用的！》&lt;/a&gt;。一文中的第一部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们还是把重点放到数据发送过程上。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、发送数据真正开始&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1 send 系统调用实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;send 系统调用的源码位于文件 net/socket.c 中。在这个系统调用里，内部其实真正使用的是 sendto 系统调用。整个调用链条虽然不短，但其实主要只干了两件简单的事情，&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一是在内核中把真正的 socket 找出来，在这个对象里记录着各种协议栈的函数地址。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二是构造一个 struct msghdr 对象，把用户传入的数据，比如 buffer地址、数据长度啥的，统统都装进去.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;剩下的事情就交给下一层，协议栈里的函数 inet_sendmsg 了，其中 inet_sendmsg 函数的地址是通过 socket 内核对象里的 ops 成员找到的。大致流程如图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNVf6gq2hiawPInMbFBzuKPB0yediaicpl4nsKwicpYj4JUWFFPibXZzIGL5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6823956442831216&quot; data-w=&quot;551&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了上面的了解，我们再看起源码就要容易许多了。源码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/socket.c  &lt;br/&gt;SYSCALL_DEFINE4(send, int, fd, void __user *, buff, size_t, len,  &lt;br/&gt;  unsigned int, flags)  &lt;br/&gt;{  &lt;br/&gt; &lt;span&gt;return&lt;/span&gt; sys_sendto(fd, buff, len, flags, NULL, 0);  &lt;br/&gt;}  &lt;br/&gt;  &lt;br/&gt;SYSCALL_DEFINE6(......)  &lt;br/&gt;{  &lt;br/&gt; //1.根据 fd 查找到 socket  &lt;br/&gt; sock = sockfd_lookup_light(fd, &amp;amp;err, &amp;amp;fput_needed);  &lt;br/&gt;  &lt;br/&gt; //2.构造 msghdr  &lt;br/&gt; struct msghdr msg;  &lt;br/&gt; struct iovec iov;  &lt;br/&gt;  &lt;br/&gt; iov.iov_base = buff;  &lt;br/&gt; iov.iov_len = len;  &lt;br/&gt; msg.msg_iovlen = 1;  &lt;br/&gt;  &lt;br/&gt; msg.msg_iov = &amp;amp;iov;  &lt;br/&gt; msg.msg_flags = flags;  &lt;br/&gt; ......  &lt;br/&gt;  &lt;br/&gt; //3.发送数据  &lt;br/&gt; sock_sendmsg(sock, &amp;amp;msg, len);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从源码可以看到，我们在用户态使用的 send 函数和 sendto 函数其实都是 sendto 系统调用实现的。send 只是为了方便，封装出来的一个更易于调用的方式而已。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 sendto 系统调用里，首先根据用户传进来的 socket 句柄号来查找真正的 socket 内核对象。接着把用户请求的 buff、len、flag 等参数都统统打包到一个 struct msghdr 对象中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着调用了 sock_sendmsg =&amp;gt; __sock_sendmsg ==&amp;gt;  __sock_sendmsg_nosec。在__sock_sendmsg_nosec 中，调用将会由系统调用进入到协议栈，我们来看它的源码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/socket.c  &lt;br/&gt;static inline int __sock_sendmsg_nosec(...)  &lt;br/&gt;{  &lt;br/&gt; ......  &lt;br/&gt; &lt;span&gt;return&lt;/span&gt; sock-&amp;gt;ops-&amp;gt;sendmsg(iocb, sock, msg, size);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过第三节里的 socket 内核对象结构图，我们可以看到，这里调用的是 sock-&amp;gt;ops-&amp;gt;sendmsg 实际执行的是 inet_sendmsg。这个函数是 AF_INET 协议族提供的通用发送函数。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2 传输层处理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1）传输层拷贝&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在进入到协议栈 inet_sendmsg 以后，内核接着会找到 socket 上的具体协议发送函数。对于 TCP 协议来说，那就是 tcp_sendmsg（同样也是通过 socket 内核对象找到的）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个函数中，内核会申请一个内核态的 skb 内存，将用户待发送的数据拷贝进去。注意这个时候不一定会真正开始发送，如果没有达到发送条件的话很可能这次调用直接就返回了。大概过程如图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZN02G9vIU8FIBvo1gkvLKQt1w8HBbupcpW28g7qmibEicVFbAISSnoP77g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.644808743169399&quot; data-w=&quot;549&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看 inet_sendmsg 函数的源码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/ipv4/af_inet.c  &lt;br/&gt;int inet_sendmsg(......)  &lt;br/&gt;{  &lt;br/&gt; ......  &lt;br/&gt; &lt;span&gt;return&lt;/span&gt; sk-&amp;gt;sk_prot-&amp;gt;sendmsg(iocb, sk, msg, size);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个函数中会调用到具体协议的发送函数。同样参考第三节里的 socket 内核对象结构图，我们看到对于 TCP 协议下的 socket 来说，来说 sk-&amp;gt;sk_prot-&amp;gt;sendmsg 指向的是 tcp_sendmsg（对于 UPD 来说是 udp_sendmsg）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;tcp_sendmsg 这个函数比较长，我们分多次来看它。先看这一段&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/ipv4/tcp.c  &lt;br/&gt;int tcp_sendmsg(...)  &lt;br/&gt;{  &lt;br/&gt; &lt;span&gt;while&lt;/span&gt;(...){  &lt;br/&gt;  &lt;span&gt;while&lt;/span&gt;(...){  &lt;br/&gt;   //获取发送队列  &lt;br/&gt;   skb = tcp_write_queue_tail(sk);  &lt;br/&gt;  &lt;br/&gt;   //申请skb 并拷贝  &lt;br/&gt;   ......  &lt;br/&gt;  }  &lt;br/&gt; }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: include/net/tcp.h  &lt;br/&gt;static inline struct sk_buff *tcp_write_queue_tail(const struct sock *sk)  &lt;br/&gt;{  &lt;br/&gt; &lt;span&gt;return&lt;/span&gt; skb_peek_tail(&amp;amp;sk-&amp;gt;sk_write_queue);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解对 socket 调用 tcp_write_queue_tail 是理解发送的前提。如上所示，这个函数是在获取 socket 发送队列中的最后一个 skb。skb 是 struct sk_buff 对象的简称，用户的发送队列就是该对象组成的一个链表。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNNMPkROrRkYKc4Jsu6ibkFn4eWK4pNl2CUQMBOt2kKXic6PufZH4OObwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.17608695652173914&quot; data-w=&quot;460&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再接着看 tcp_sendmsg 的其它部分。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/ipv4/tcp.c  &lt;br/&gt;int tcp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,  &lt;br/&gt;  size_t size)  &lt;br/&gt;{  &lt;br/&gt; //获取用户传递过来的数据和标志  &lt;br/&gt; iov = msg-&amp;gt;msg_iov; //用户数据地址  &lt;br/&gt; iovlen = msg-&amp;gt;msg_iovlen; //数据块数为1  &lt;br/&gt; flags = msg-&amp;gt;msg_flags; //各种标志  &lt;br/&gt;  &lt;br/&gt; //遍历用户层的数据块  &lt;br/&gt; &lt;span&gt;while&lt;/span&gt; (--iovlen &amp;gt;= 0) {  &lt;br/&gt;  &lt;br/&gt;  //待发送数据块的地址  &lt;br/&gt;  unsigned char __user *from = iov-&amp;gt;iov_base;  &lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (seglen &amp;gt; 0) {  &lt;br/&gt;  &lt;br/&gt;   //需要申请新的 skb  &lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (copy &amp;lt;= 0) {  &lt;br/&gt;  &lt;br/&gt;    //申请 skb，并添加到发送队列的尾部  &lt;br/&gt;    skb = sk_stream_alloc_skb(sk,  &lt;br/&gt;         select_size(sk, sg),  &lt;br/&gt;         sk-&amp;gt;sk_allocation);  &lt;br/&gt;  &lt;br/&gt;    //把 skb 挂到socket的发送队列上  &lt;br/&gt;    skb_entail(sk, skb);  &lt;br/&gt;   }  &lt;br/&gt;  &lt;br/&gt;   // skb 中有足够的空间  &lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (skb_availroom(skb) &amp;gt; 0) {  &lt;br/&gt;    //拷贝用户空间的数据到内核空间，同时计算校验和  &lt;br/&gt;    //from是用户空间的数据地址   &lt;br/&gt;    skb_add_data_nocache(sk, skb, from, copy);  &lt;br/&gt;   }   &lt;br/&gt;   ......  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个函数比较长，不过其实逻辑并不复杂。其中 msg-&amp;gt;msg_iov 存储的是用户态内存的要发送的数据的 buffer。接下来在内核态申请内核内存，比如 skb，并把用户内存里的数据拷贝到内核态内存中。&lt;strong&gt;这就会涉及到一次或者几次内存拷贝的开销&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZN1Ueyic8TiaLVOjSsmdfCOHFtgcsdbhBuF2p9RxBA2Mj2nmeam2ba60BQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.27235772357723576&quot; data-w=&quot;492&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于内核什么时候真正把 skb 发送出去。在 tcp_sendmsg 中会进行一些判断。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/ipv4/tcp.c  &lt;br/&gt;int tcp_sendmsg(...)  &lt;br/&gt;{  &lt;br/&gt; &lt;span&gt;while&lt;/span&gt;(...){  &lt;br/&gt;  &lt;span&gt;while&lt;/span&gt;(...){  &lt;br/&gt;   //申请内核内存并进行拷贝  &lt;br/&gt;  &lt;br/&gt;   //发送判断  &lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (forced_push(tp)) {  &lt;br/&gt;    tcp_mark_push(tp, skb);  &lt;br/&gt;    __tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_PUSH);  &lt;br/&gt;   } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (skb == tcp_send_head(sk))  &lt;br/&gt;    tcp_push_one(sk, mss_now);    &lt;br/&gt;   }  &lt;br/&gt;   &lt;span&gt;continue&lt;/span&gt;;  &lt;br/&gt;  }  &lt;br/&gt; }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有满足 forced_push(tp) 或者 skb == tcp_send_head(sk) 成立的时候，内核才会真正启动发送数据包。其中 forced_push(tp) 判断的是未发送的数据数据是否已经超过最大窗口的一半了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;条件都不满足的话，&lt;strong&gt;这次的用户要发送的数据只是拷贝到内核就算完事了！&lt;/strong&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2）传输层发送&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设现在内核发送条件已经满足了，我们再来跟踪一下实际的发送过程。对于上小节函数中，当满足真正发送条件的时候，无论调用的是 __tcp_push_pending_frames 还是 tcp_push_one 最终都实际会执行到 tcp_write_xmit。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们直接从 tcp_write_xmit 看起，这个函数处理了传输层的拥塞控制、滑动窗口相关的工作。满足窗口要求的时候，设置一下 TCP 头然后将 skb 传到更低的网络层进行处理。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNmvAvBIicvqQ6wfzLVRuk7giaCnLDvpERYJ2CYeePictS7k1c4mT7tfccA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6118299445471349&quot; data-w=&quot;541&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看下 tcp_write_xmit 的源码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/ipv4/tcp_output.c  &lt;br/&gt;static bool tcp_write_xmit(struct sock *sk, unsigned int mss_now, int nonagle,  &lt;br/&gt;      int push_one, gfp_t gfp)  &lt;br/&gt;{  &lt;br/&gt; //循环获取待发送 skb  &lt;br/&gt; &lt;span&gt;while&lt;/span&gt; ((skb = tcp_send_head(sk)))   &lt;br/&gt; {  &lt;br/&gt;  //滑动窗口相关  &lt;br/&gt;  cwnd_quota = tcp_cwnd_test(tp, skb);  &lt;br/&gt;  tcp_snd_wnd_test(tp, skb, mss_now);  &lt;br/&gt;  tcp_mss_split_point(...);  &lt;br/&gt;  tso_fragment(sk, skb, ...);  &lt;br/&gt;  ......  &lt;br/&gt;  &lt;br/&gt;  //真正开启发送  &lt;br/&gt;  tcp_transmit_skb(sk, skb, 1, gfp);  &lt;br/&gt; }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到我们之前在网络协议里学的滑动窗口、拥塞控制就是在这个函数中完成的，这部分就不过多展开了，感兴趣同学自己找这段源码来读。我们今天只看发送主过程，那就走到了 tcp_transmit_skb。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/ipv4/tcp_output.c  &lt;br/&gt;static int tcp_transmit_skb(struct sock *sk, struct sk_buff *skb, int clone_it,  &lt;br/&gt;    gfp_t gfp_mask)  &lt;br/&gt;{  &lt;br/&gt; //1.克隆新 skb 出来  &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (likely(clone_it)) {  &lt;br/&gt;  skb = skb_clone(skb, gfp_mask);  &lt;br/&gt;  ......  &lt;br/&gt; }  &lt;br/&gt;  &lt;br/&gt; //2.封装 TCP 头  &lt;br/&gt; th = tcp_hdr(skb);  &lt;br/&gt; th-&amp;gt;&lt;span&gt;source&lt;/span&gt;  = inet-&amp;gt;inet_sport;  &lt;br/&gt; th-&amp;gt;dest  = inet-&amp;gt;inet_dport;  &lt;br/&gt; th-&amp;gt;window  = ...;  &lt;br/&gt; th-&amp;gt;urg   = ...;  &lt;br/&gt; ......  &lt;br/&gt;  &lt;br/&gt; //3.调用网络层发送接口  &lt;br/&gt; err = icsk-&amp;gt;icsk_af_ops-&amp;gt;queue_xmit(skb, &amp;amp;inet-&amp;gt;cork.fl);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一件事是先克隆一个新的 skb，这里重点说下为什么要复制一个 skb 出来呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是因为 skb 后续在调用网络层，最后到达网卡发送完成的时候，这个 skb 会被释放掉。而我们知道 TCP 协议是支持丢失重传的，在收到对方的 ACK 之前，这个 skb 不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是 skb 的一个拷贝。等收到 ACK 再真正删除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二件事是修改 skb 中的 TCP header，根据实际情况把 TCP 头设置好。这里要介绍一个小技巧，skb 内部其实包含了网络协议中所有的 header。在设置 TCP 头的时候，只是把指针指向 skb 的合适位置。后面再设置 IP 头的时候，在把指针挪一挪就行，避免频繁的内存申请和拷贝，效率很高。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNRqslNiblOrkbl9qQmlBLyDa20xUCALE5QsAlD7uyCOia0IChPZqUDP9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.23161764705882354&quot; data-w=&quot;544&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;tcp_transmit_skb 是发送数据位于传输层的最后一步，接下来就可以进入到网络层进行下一层的操作了。调用了网络层提供的发送接口icsk-&amp;gt;icsk_af_ops-&amp;gt;queue_xmit()。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在下面的这个源码中，我们的知道了 queue_xmit 其实指向的是 ip_queue_xmit 函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/ipv4/tcp_ipv4.c  &lt;br/&gt;const struct inet_connection_sock_af_ops ipv4_specific = {  &lt;br/&gt; .queue_xmit    = ip_queue_xmit,  &lt;br/&gt; .send_check    = tcp_v4_send_check,  &lt;br/&gt; ...  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自此，传输层的工作也就都完成了。数据离开了传输层，接下来将会进入到内核在网络层的实现里。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.3 网络层发送处理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 内核网络层的发送的实现位于 net/ipv4/ip_output.c 这个文件。传输层调用到的 ip_queue_xmit 也在这里。（从文件名上也能看出来进入到 IP 层了，源文件名已经从 tcp_xxx 变成了 ip_xxx。）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在网络层里主要处理路由项查找、IP 头设置、netfilter 过滤、skb 切分（大于 MTU 的话）等几项工作，处理完这些工作后会交给更下层的邻居子系统来处理。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNHKljuAcgia19LTvD0E6gZT0KcSwD7XNV5rmSUib2icIqLPYrl6cicGPO0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.7814113597246127&quot; data-w=&quot;581&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看网络层入口函数 ip_queue_xmit 的源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/ipv4/ip_output.c  &lt;br/&gt;int ip_queue_xmit(struct sk_buff *skb, struct flowi *fl)  &lt;br/&gt;{  &lt;br/&gt; //检查 socket 中是否有缓存的路由表  &lt;br/&gt; rt = (struct rtable *)__sk_dst_check(sk, 0);  &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (rt == NULL) {  &lt;br/&gt;  //没有缓存则展开查找  &lt;br/&gt;  //则查找路由项， 并缓存到 socket 中  &lt;br/&gt;  rt = ip_route_output_ports(...);  &lt;br/&gt;  sk_setup_caps(sk, &amp;amp;rt-&amp;gt;dst);  &lt;br/&gt; }  &lt;br/&gt;  &lt;br/&gt; //为 skb 设置路由表  &lt;br/&gt; skb_dst_set_noref(skb, &amp;amp;rt-&amp;gt;dst);  &lt;br/&gt;  &lt;br/&gt; //设置 IP header  &lt;br/&gt; iph = ip_hdr(skb);  &lt;br/&gt; iph-&amp;gt;protocol = sk-&amp;gt;sk_protocol;  &lt;br/&gt; iph-&amp;gt;ttl      = ip_select_ttl(inet, &amp;amp;rt-&amp;gt;dst);  &lt;br/&gt; iph-&amp;gt;frag_off = ...;  &lt;br/&gt;  &lt;br/&gt; //发送  &lt;br/&gt; ip_local_out(skb);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ip_queue_xmit 已经到了网络层，在这个函数里我们看到了网络层相关的功能路由项查找，如果找到了则设置到 skb 上（没有路由的话就直接报错返回了）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Linux 上通过 route 命令可以看到你本机的路由配置。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNdr7Zib9CBF65ARWmR1v6V4PnTXbMDibNGicC3icd7iaLObnhqIIPzomcY2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.15364916773367476&quot; data-w=&quot;781&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在路由表中，可以查到某个目的网络应该通过哪个 Iface（网卡），哪个 Gateway（网卡）发送出去。查找出来以后缓存到 socket 上，下次再发送数据就不用查了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着把路由表地址也放到 skb 里去。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: include/linux/skbuff.h  &lt;br/&gt;struct sk_buff {  &lt;br/&gt; //保存了一些路由相关信息  &lt;br/&gt; unsigned long  _skb_refdst;  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来就是定位到 skb 里的 IP 头的位置上，然后开始按照协议规范设置 IP header。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNqIZkibKCHoqCAiapVUqdMrAryG98I9muj6CMkfvGu45rFOYcM3l27wTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.23161764705882354&quot; data-w=&quot;544&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再通过 ip_local_out 进入到下一步的处理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/ipv4/ip_output.c    &lt;br/&gt;int ip_local_out(struct sk_buff *skb)  &lt;br/&gt;{  &lt;br/&gt; //执行 netfilter 过滤  &lt;br/&gt; err = __ip_local_out(skb);  &lt;br/&gt;  &lt;br/&gt; //开始发送数据  &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (likely(err == 1))  &lt;br/&gt; &amp;amp;nbsnbsp;err = dst_output(skb);  &lt;br/&gt; ......  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 ip_local_out =&amp;gt; __ip_local_out =&amp;gt; nf_hook 会执行 netfilter 过滤。如果你使用 iptables 配置了一些规则，那么这里将检测是否命中规则。&lt;strong&gt;如果你设置了非常复杂的 netfilter 规则，在这个函数这里将会导致你的进程 CPU 开销会极大增加&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是不多展开说，继续只聊和发送有关的过程 dst_output。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: include/net/dst.h  &lt;br/&gt;static inline int dst_output(struct sk_buff *skb)  &lt;br/&gt;{  &lt;br/&gt; &lt;span&gt;return&lt;/span&gt; skb_dst(skb)-&amp;gt;output(skb);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此函数找到到这个 skb 的路由表（dst 条目） ，然后调用路由表的 output 方法。这又是一个函数指针，指向的是 ip_output 方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/ipv4/ip_output.c  &lt;br/&gt;int ip_output(struct sk_buff *skb)  &lt;br/&gt;{  &lt;br/&gt; //统计  &lt;br/&gt; .....  &lt;br/&gt;  &lt;br/&gt; //再次交给 netfilter，完毕后回调 ip_finish_output  &lt;br/&gt; &lt;span&gt;return&lt;/span&gt; NF_HOOK_COND(NFPROTO_IPV4, NF_INET_POST_ROUTING, skb, NULL, dev,  &lt;br/&gt;    ip_finish_output,  &lt;br/&gt;    !(IPCB(skb)-&amp;gt;flags &amp;amp; IPSKB_REROUTED));  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 ip_output 中进行一些简单的，统计工作，再次执行 netfilter 过滤。过滤通过之后回调 ip_finish_output。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/ipv4/ip_output.c  &lt;br/&gt;static int ip_finish_output(struct sk_buff *skb)  &lt;br/&gt;{  &lt;br/&gt; //大于 mtu 的话就要进行分片了  &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (skb-&amp;gt;len &amp;gt; ip_skb_dst_mtu(skb) &amp;amp;&amp;amp; !skb_is_gso(skb))  &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ip_fragment(skb, ip_finish_output2);  &lt;br/&gt; &lt;span&gt;else&lt;/span&gt;  &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ip_finish_output2(skb);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 ip_finish_output 中我们看到，&lt;strong&gt;如果数据大于 MTU 的话，是会执行分片的。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;实际 MTU 大小确定依赖 MTU 发现，以太网帧为 1500 字节。之前 QQ 团队在早期的时候，会尽量控制自己数据包尺寸小于 MTU，通过这种方式来优化网络性能。因为分片会带来两个问题：1、需要进行额外的切分处理，有额外性能开销。2、只要一个分片丢失，整个包都得重传。所以避免分片既杜绝了分片开销，也大大降低了重传率。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 ip_finish_output2 中，终于发送过程会进入到下一层，邻居子系统中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/ipv4/ip_output.c  &lt;br/&gt;static inline int ip_finish_output2(struct sk_buff *skb)  &lt;br/&gt;{  &lt;br/&gt; //根据下一跳 IP 地址查找邻居项，找不到就创建一个  &lt;br/&gt; nexthop = (__force u32) rt_nexthop(rt, ip_hdr(skb)-&amp;gt;daddr);    &lt;br/&gt; neigh = __ipv4_neigh_lookup_noref(dev, nexthop);  &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (unlikely(!neigh))  &lt;br/&gt;  neigh = __neigh_create(&amp;amp;arp_tbl, &amp;amp;nexthop, dev, &lt;span&gt;false&lt;/span&gt;);  &lt;br/&gt;  &lt;br/&gt; //继续向下层传递  &lt;br/&gt; int res = dst_neigh_output(dst, neigh, skb);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4 邻居子系统&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;邻居子系统是位于网络层和数据链路层中间的一个系统，其作用是对网络层提供一个封装，让网络层不必关心下层的地址信息，让下层来决定发送到哪个 MAC 地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且这个邻居子系统并不位于协议栈 net/ipv4/ 目录内，而是位于 net/core/neighbour.c。因为无论是对于 IPv4 还是 IPv6 ，都需要使用该模块。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNJZBziacZ2g4pYHa8A4TFHnfumx1Tmz21BrRnVMmhAWmCP9wr9JYUtog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.3197278911564626&quot; data-w=&quot;441&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在邻居子系统里主要是查找或者创建邻居项，在创造邻居项的时候，有可能会发出实际的 arp 请求。然后封装一下 MAC 头，将发送过程再传递到更下层的网络设备子系统。大致流程如图。&lt;br/&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNL6qiaV60wqwUvibIQpj5vic8vNREQq1jTEwhOdn5zzN5YedSmiccaUFXNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5690184049079755&quot; data-w=&quot;652&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解了大致流程，我们再回头看源码。在上面小节 ip_finish_output2 源码中调用了 __ipv4_neigh_lookup_noref。它是在 arp 缓存中进行查找，其第二个参数传入的是路由下一跳 IP 信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: include/net/arp.h  &lt;br/&gt;extern struct neigh_table arp_tbl;  &lt;br/&gt;static inline struct neighbour *__ipv4_neigh_lookup_noref(  &lt;br/&gt; struct net_device *dev, u32 key)  &lt;br/&gt;{  &lt;br/&gt; struct neigh_hash_table *nht = rcu_dereference_bh(arp_tbl.nht);  &lt;br/&gt;  &lt;br/&gt; //计算 &lt;span&gt;hash&lt;/span&gt; 值，加速查找  &lt;br/&gt; hash_val = arp_hashfn(......);  &lt;br/&gt; &lt;span&gt;for&lt;/span&gt; (n = rcu_dereference_bh(nht-&amp;gt;hash_buckets[hash_val]);  &lt;br/&gt;   n != NULL;  &lt;br/&gt;   n = rcu_dereference_bh(n-&amp;gt;next)) {  &lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (n-&amp;gt;dev == dev &amp;amp;&amp;amp; *(u32 *)n-&amp;gt;primary_key == key)  &lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; n;  &lt;br/&gt; }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果查找不到，则调用 __neigh_create 创建一个邻居。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/core/neighbour.c  &lt;br/&gt;struct neighbour *__neigh_create(......)  &lt;br/&gt;{  &lt;br/&gt; //申请邻居表项  &lt;br/&gt; struct neighbour *n1, *rc, *n = neigh_alloc(tbl, dev);  &lt;br/&gt;  &lt;br/&gt; //构造赋值  &lt;br/&gt; memcpy(n-&amp;gt;primary_key, pkey, key_len);  &lt;br/&gt; n-&amp;gt;dev = dev;  &lt;br/&gt; n-&amp;gt;parms-&amp;gt;neigh_setup(n);  &lt;br/&gt;  &lt;br/&gt; //最后添加到邻居 hashtable 中  &lt;br/&gt; rcu_assign_pointer(nht-&amp;gt;hash_buckets[hash_val], n);  &lt;br/&gt; ......  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了邻居项以后，此时仍然还不具备发送 IP 报文的能力，因为目的 MAC 地址还未获取。调用 dst_neigh_output 继续传递 skb。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: include/net/dst.h  &lt;br/&gt;static inline int dst_neigh_output(struct dst_entry *dst,   &lt;br/&gt;     struct neighbour *n, struct sk_buff *skb)  &lt;br/&gt;{  &lt;br/&gt; ......  &lt;br/&gt; &lt;span&gt;return&lt;/span&gt; n-&amp;gt;output(n, skb);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用 output，实际指向的是 neigh_resolve_output。在这个函数内部有可能会发出 arp 网络请求。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/core/neighbour.c  &lt;br/&gt;int &lt;span&gt;&lt;span&gt;neigh_resolve_output&lt;/span&gt;&lt;/span&gt;(){  &lt;br/&gt;  &lt;br/&gt; //注意：这里可能会触发 arp 请求  &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (!neigh_event_send(neigh, skb)) {  &lt;br/&gt;  &lt;br/&gt;  //neigh-&amp;gt;ha 是 MAC 地址  &lt;br/&gt;  dev_hard_header(skb, dev, ntohs(skb-&amp;gt;protocol),  &lt;br/&gt;           neigh-&amp;gt;ha, NULL, skb-&amp;gt;len);  &lt;br/&gt;  //发送  &lt;br/&gt;  dev_queue_xmit(skb);  &lt;br/&gt; }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当获取到硬件 MAC 地址以后，就可以封装 skb 的 MAC 头了。最后调用 dev_queue_xmit 将 skb 传递给 Linux 网络设备子系统。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.5 网络设备子系统&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNWlqeL1lcN9nsJ7J4cX1v3yYPYED4gV6uyBBlpwfCFDzPp3abYrT47Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.7246127366609294&quot; data-w=&quot;581&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;邻居子系统通过 dev_queue_xmit 进入到网络设备子系统中来。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/core/dev.c   &lt;br/&gt;int dev_queue_xmit(struct sk_buff *skb)  &lt;br/&gt;{  &lt;br/&gt; //选择发送队列  &lt;br/&gt; txq = netdev_pick_tx(dev, skb);  &lt;br/&gt;  &lt;br/&gt; //获取与此队列关联的排队规则  &lt;br/&gt; q = rcu_dereference_bh(txq-&amp;gt;qdisc);  &lt;br/&gt;  &lt;br/&gt; //如果有队列，则调用__dev_xmit_skb 继续处理数据  &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (q-&amp;gt;enqueue) {  &lt;br/&gt;  rc = __dev_xmit_skb(skb, q, dev, txq);  &lt;br/&gt;  goto out;  &lt;br/&gt; }  &lt;br/&gt;  &lt;br/&gt; //没有队列的是回环设备和隧道设备  &lt;br/&gt; ......  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开篇第二节网卡启动准备里我们说过，网卡是有多个发送队列的（尤其是现在的网卡）。上面对 netdev_pick_tx 函数的调用就是选择一个队列进行发送。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;netdev_pick_tx 发送队列的选择受 XPS 等配置的影响，而且还有缓存，也是一套小复杂的逻辑。这里我们只关注两个逻辑，首先会获取用户的 XPS 配置，否则就自动计算了。代码见 netdev_pick_tx =&amp;gt; __netdev_pick_tx。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/core/flow_dissector.c  &lt;br/&gt;u16 __netdev_pick_tx(struct net_device *dev, struct sk_buff *skb)  &lt;br/&gt;{  &lt;br/&gt; //获取 XPS 配置  &lt;br/&gt; int new_index = get_xps_queue(dev, skb);  &lt;br/&gt;  &lt;br/&gt; //自动计算队列  &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (new_index &amp;lt; 0)  &lt;br/&gt;  new_index = skb_tx_hash(dev, skb);}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后获取与此队列关联的 qdisc。在 linux 上通过 tc 命令可以看到 qdisc 类型，例如对于我的某台多队列网卡机器上是 mq disc。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#tc qdisc  &lt;/span&gt;&lt;br/&gt;qdisc mq 0: dev eth0 root  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大部分的设备都有队列（回环设备和隧道设备除外），所以现在我们进入到 __dev_xmit_skb。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/core/dev.c  &lt;br/&gt;static inline int __dev_xmit_skb(struct sk_buff *skb, struct Qdisc *q,  &lt;br/&gt;     struct net_device *dev,  &lt;br/&gt;     struct netdev_queue *txq)  &lt;br/&gt;{  &lt;br/&gt; //1.如果可以绕开排队系统  &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; ((q-&amp;gt;flags &amp;amp; TCQ_F_CAN_BYPASS) &amp;amp;&amp;amp; !qdisc_qlen(q) &amp;amp;&amp;amp;  &lt;br/&gt;     qdisc_run_begin(q)) {  &lt;br/&gt;  ......  &lt;br/&gt; }  &lt;br/&gt;  &lt;br/&gt; //2.正常排队  &lt;br/&gt; &lt;span&gt;else&lt;/span&gt; {  &lt;br/&gt;  &lt;br/&gt;  //入队  &lt;br/&gt;  q-&amp;gt;enqueue(skb, q)  &lt;br/&gt;  &lt;br/&gt;  //开始发送  &lt;br/&gt;  __qdisc_run(q);  &lt;br/&gt; }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述代码中分两种情况，1 是可以 bypass（绕过）排队系统的，另外一种是正常排队。我们只看第二种情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先调用 q-&amp;gt;enqueue 把 skb 添加到队列里。然后调用 __qdisc_run 开始发送。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/&lt;span&gt;sched&lt;/span&gt;/sch_generic.c  &lt;br/&gt;void __qdisc_run(struct Qdisc *q)  &lt;br/&gt;{  &lt;br/&gt; int quota = weight_p;  &lt;br/&gt;  &lt;br/&gt; //循环从队列取出一个 skb 并发送  &lt;br/&gt; &lt;span&gt;while&lt;/span&gt; (qdisc_restart(q)) {  &lt;br/&gt;    &lt;br/&gt;  // 如果发生下面情况之一，则延后处理：  &lt;br/&gt;  // 1. quota 用尽  &lt;br/&gt;  // 2. 其他进程需要 CPU  &lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (--quota &amp;lt;= 0 || need_resched()) {  &lt;br/&gt;   //将触发一次 NET_TX_SOFTIRQ 类型 softirq  &lt;br/&gt;   __netif_schedule(q);  &lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;;  &lt;br/&gt;  }  &lt;br/&gt; }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上述代码中，我们看到 while 循环不断地从队列中取出 skb 并进行发送。注意，这个时候其实都占用的是用户进程的系统态时间(sy)。只有当 quota 用尽或者其它进程需要 CPU 的时候才触发软中断进行发送。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;所以这就是为什么一般服务器上查看 /proc/softirqs，一般 NET_RX 都要比 NET_TX 大的多的第二个原因&lt;/strong&gt;。对于读来说，都是要经过 NET_RX 软中断，而对于发送来说，只有系统态配额用尽才让软中断上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来把精力在放到 qdisc_restart 上，继续看发送过程。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;static inline int qdisc_restart(struct Qdisc *q)  &lt;br/&gt;{  &lt;br/&gt; //从 qdisc 中取出要发送的 skb  &lt;br/&gt; skb = dequeue_skb(q);  &lt;br/&gt; ...  &lt;br/&gt;  &lt;br/&gt; &lt;span&gt;return&lt;/span&gt; sch_direct_xmit(skb, q, dev, txq, root_lock);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;qdisc_restart 从队列中取出一个 skb，并调用 sch_direct_xmit 继续发送。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/&lt;span&gt;sched&lt;/span&gt;/sch_generic.c  &lt;br/&gt;int sch_direct_xmit(struct sk_buff *skb, struct Qdisc *q,  &lt;br/&gt;   struct net_device *dev, struct netdev_queue *txq,  &lt;br/&gt;   spinlock_t *root_lock)  &lt;br/&gt;{  &lt;br/&gt; //调用驱动程序来发送数据  &lt;br/&gt; ret = dev_hard_start_xmit(skb, dev, txq);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.6 软中断调度&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 4.5 咱们看到了如果系统态 CPU 发送网络包不够用的时候，会调用 __netif_schedule 触发一个软中断。该函数会进入到 __netif_reschedule，由它来实际发出 NET_TX_SOFTIRQ 类型软中断。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软中断是由内核线程来运行的，该线程会进入到 net_tx_action 函数，在该函数中能获取到发送队列，并也最终调用到驱动程序里的入口函数 dev_hard_start_xmit。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNYsGqxicD45mB3SES9U7W7noexasRKmqKsFnZbSk0YOXOMBEXU1sI1hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.8336106489184693&quot; data-w=&quot;601&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/core/dev.c  &lt;br/&gt;static inline void __netif_reschedule(struct Qdisc *q)  &lt;br/&gt;{  &lt;br/&gt; sd = &amp;amp;__get_cpu_var(softnet_data);  &lt;br/&gt; q-&amp;gt;next_sched = NULL;  &lt;br/&gt; *sd-&amp;gt;output_queue_tailp = q;  &lt;br/&gt; sd-&amp;gt;output_queue_tailp = &amp;amp;q-&amp;gt;next_sched;  &lt;br/&gt;  &lt;br/&gt; ......  &lt;br/&gt; raise_softirq_irqoff(NET_TX_SOFTIRQ);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在该函数里在软中断能访问到的 softnet_data 里设置了要发送的数据队列，添加到了 output_queue 里了。紧接着触发了 NET_TX_SOFTIRQ 类型的软中断。（T 代表 transmit 传输）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软中断的入口代码我这里也不详细扒了，感兴趣的同学&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&amp;amp;mid=2666548640&amp;amp;idx=1&amp;amp;sn=7e6dcbbcd569ad4f3c20e915b78b3bac&amp;amp;chksm=80dc890bb7ab001d4cd880c773b3e7b3b9ee4d7d9d4fac0ebbeaa6d247c70084d8cde829bcf2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《图解Linux网络包接收过程》&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《图解Linux网络包接收过程》&lt;/a&gt;&lt;span&gt;参考&lt;/span&gt;&lt;span&gt;一&lt;/span&gt;&lt;span&gt;文&lt;/span&gt;&lt;span&gt;中&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;小&lt;/span&gt;&lt;span&gt;节&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;- k&lt;/span&gt;&lt;span&gt;so&lt;/span&gt;&lt;span&gt;ft&lt;/span&gt;&lt;span&gt;irqd&lt;/span&gt;&lt;span&gt;内核&lt;/span&gt;&lt;span&gt;线&lt;/span&gt;&lt;span&gt;程处&lt;/span&gt;&lt;span&gt;理&lt;/span&gt;&lt;span&gt;软&lt;/span&gt;&lt;span&gt;中断。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们直接从 NET_TX_SOFTIRQ softirq 注册的回调函数 net_tx_action讲起。用户态进程触发完软中断之后，会有一个软中断内核线程会执行到 net_tx_action。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;牢记，这以后发送数据消耗的 CPU 就都显示在 si 这里了，不会消耗用户进程的系统时间了&lt;/strong&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/core/dev.c  &lt;br/&gt;static void net_tx_action(struct softirq_action *h)  &lt;br/&gt;{  &lt;br/&gt; //通过 softnet_data 获取发送队列  &lt;br/&gt; struct softnet_data *sd = &amp;amp;__get_cpu_var(softnet_data);  &lt;br/&gt;  &lt;br/&gt; // 如果 output queue 上有 qdisc  &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (sd-&amp;gt;output_queue) {  &lt;br/&gt;  &lt;br/&gt;  // 将 head 指向第一个 qdisc  &lt;br/&gt;  head = sd-&amp;gt;output_queue;  &lt;br/&gt;  &lt;br/&gt;  //遍历 qdsics 列表  &lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (head) {  &lt;br/&gt;   struct Qdisc *q = head;  &lt;br/&gt;   head = head-&amp;gt;next_sched;  &lt;br/&gt;  &lt;br/&gt;   //发送数据  &lt;br/&gt;   qdisc_run(q);  &lt;br/&gt;  }  &lt;br/&gt; }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;软中断这里会获取 softnet_data。前面我们看到进程内核态在调用 __netif_reschedule 的时候把发送队列写到 softnet_data 的 output_queue 里了。软中断循环遍历 sd-&amp;gt;output_queue 发送数据帧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来看 qdisc_run，它和进程用户态一样，也会调用到 __qdisc_run。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: include/net/pkt_sched.h  &lt;br/&gt;static inline void qdisc_run(struct Qdisc *q)  &lt;br/&gt;{  &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (qdisc_run_begin(q))  &lt;br/&gt;  __qdisc_run(q);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后一样就是进入 qdisc_restart =&amp;gt; sch_direct_xmit，直到驱动程序函数 dev_hard_start_xmit。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.7 igb 网卡驱动发送&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们前面看到，无论是对于用户进程的内核态，还是对于软中断上下文，都会调用到网络设备子系统中的 dev_hard_start_xmit 函数。在这个函数中，会调用到驱动里的发送函数 igb_xmit_frame。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在驱动函数里，将 skb 会挂到 RingBuffer上，驱动调用完毕后，数据包将真正从网卡发送出去。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNCibicYkezt2Mz8oaq1DWJuPEcGPHn0XLKtAGHmm75GoAIg6hUlxJXJlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.9139414802065404&quot; data-w=&quot;581&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看看实际的源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: net/core/dev.c  &lt;br/&gt;int dev_hard_start_xmit(struct sk_buff *skb, struct net_device *dev,  &lt;br/&gt;   struct netdev_queue *txq)  &lt;br/&gt;{  &lt;br/&gt; //获取设备的回调函数集合 ops  &lt;br/&gt; const struct net_device_ops *ops = dev-&amp;gt;netdev_ops;  &lt;br/&gt;  &lt;br/&gt; //获取设备支持的功能列表  &lt;br/&gt; features = netif_skb_features(skb);  &lt;br/&gt;  &lt;br/&gt; //调用驱动的 ops 里面的发送回调函数 ndo_start_xmit 将数据包传给网卡设备  &lt;br/&gt; skb_len = skb-&amp;gt;len;  &lt;br/&gt; rc = ops-&amp;gt;ndo_start_xmit(skb, dev);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 ndo_start_xmit 是网卡驱动要实现的一个函数，是在 net_device_ops 中定义的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: include/linux/netdevice.h  &lt;br/&gt;struct net_device_ops {  &lt;br/&gt; netdev_tx_t  (*ndo_start_xmit) (struct sk_buff *skb,  &lt;br/&gt;         struct net_device *dev);  &lt;br/&gt;  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 igb 网卡驱动源码中，我们找到了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: drivers/net/ethernet/intel/igb/igb_main.c  &lt;br/&gt;static const struct net_device_ops igb_netdev_ops = {  &lt;br/&gt; .ndo_open  = igb_open,  &lt;br/&gt; .ndo_stop  = igb_close,  &lt;br/&gt; .ndo_start_xmit  = igb_xmit_frame,   &lt;br/&gt; ...  &lt;br/&gt;};  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，对于网络设备层定义的 ndo_start_xmit， igb 的实现函数是 igb_xmit_frame。这个函数是在网卡驱动初始化的时候被赋值的。具体初始化过程参见&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&amp;amp;mid=2666548640&amp;amp;idx=1&amp;amp;sn=7e6dcbbcd569ad4f3c20e915b78b3bac&amp;amp;chksm=80dc890bb7ab001d4cd880c773b3e7b3b9ee4d7d9d4fac0ebbeaa6d247c70084d8cde829bcf2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《图解Linux网络包接收过程》&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《图解Linux网络包接收过程》&lt;/a&gt;一文中的 2.4 节，网卡驱动初始化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在上面网络设备层调用 ops-&amp;gt;ndo_start_xmit 的时候，会实际上进入 igb_xmit_frame 这个函数中。我们进入这个函数来看看驱动程序是如何工作的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: drivers/net/ethernet/intel/igb/igb_main.c  &lt;br/&gt;static netdev_tx_t igb_xmit_frame(struct sk_buff *skb,  &lt;br/&gt;      struct net_device *netdev)  &lt;br/&gt;{  &lt;br/&gt; ......  &lt;br/&gt; &lt;span&gt;return&lt;/span&gt; igb_xmit_frame_ring(skb, igb_tx_queue_mapping(adapter, skb));  &lt;br/&gt;}  &lt;br/&gt;  &lt;br/&gt;netdev_tx_t igb_xmit_frame_ring(struct sk_buff *skb,  &lt;br/&gt;    struct igb_ring *tx_ring)  &lt;br/&gt;{  &lt;br/&gt; //获取TX Queue 中下一个可用缓冲区信息  &lt;br/&gt; first = &amp;amp;tx_ring-&amp;gt;tx_buffer_info[tx_ring-&amp;gt;next_to_use];  &lt;br/&gt; first-&amp;gt;skb = skb;  &lt;br/&gt; first-&amp;gt;bytecount = skb-&amp;gt;len;  &lt;br/&gt; first-&amp;gt;gso_segs = 1;  &lt;br/&gt;  &lt;br/&gt; //igb_tx_map 函数准备给设备发送的数据。  &lt;br/&gt; igb_tx_map(tx_ring, first, hdr_len);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里从网卡的发送队列的 RingBuffer 中取下来一个元素，并将 skb 挂到元素上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNwYLpPquCuztmAAqmcV41gzMST63ovYfoD96CgPcBArWJTI1D0nwBEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.25277161862527714&quot; data-w=&quot;451&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;igb_tx_map 函数处理将 skb 数据映射到网卡可访问的内存 DMA 区域。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: drivers/net/ethernet/intel/igb/igb_main.c  &lt;br/&gt;static void igb_tx_map(struct igb_ring *tx_ring,  &lt;br/&gt;      struct igb_tx_buffer *first,  &lt;br/&gt;      const u8 hdr_len)  &lt;br/&gt;{  &lt;br/&gt; //获取下一个可用描述符指针  &lt;br/&gt; tx_desc = IGB_TX_DESC(tx_ring, i);  &lt;br/&gt;  &lt;br/&gt; //为 skb-&amp;gt;data 构造内存映射，以允许设备通过 DMA 从 RAM 中读取数据  &lt;br/&gt; dma = dma_map_single(tx_ring-&amp;gt;dev, skb-&amp;gt;data, size, DMA_TO_DEVICE);  &lt;br/&gt;  &lt;br/&gt; //遍历该数据包的所有分片,为 skb 的每个分片生成有效映射  &lt;br/&gt; &lt;span&gt;for&lt;/span&gt; (frag = &amp;amp;skb_shinfo(skb)-&amp;gt;frags[0];; frag++) {  &lt;br/&gt;  &lt;br/&gt;  tx_desc-&amp;gt;read.buffer_addr = cpu_to_le64(dma);  &lt;br/&gt;  tx_desc-&amp;gt;read.cmd_type_len = ...;  &lt;br/&gt;  tx_desc-&amp;gt;read.olinfo_status = 0;  &lt;br/&gt; }  &lt;br/&gt;  &lt;br/&gt; //设置最后一个descriptor  &lt;br/&gt; cmd_type |= size | IGB_TXD_DCMD;  &lt;br/&gt; tx_desc-&amp;gt;read.cmd_type_len = cpu_to_le32(cmd_type);  &lt;br/&gt;  &lt;br/&gt; /* Force memory writes to complete before letting h/w know there  &lt;br/&gt;  * are new descriptors to fetch  &lt;br/&gt;  */  &lt;br/&gt; wmb();  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当所有需要的描述符都已建好，且 skb 的所有数据都映射到 DMA 地址后，驱动就会进入到它的最后一步，触发真实的发送。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.8 发送完成硬中断&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当数据发送完成以后，其实工作并没有结束。因为内存还没有清理。当发送完成的时候，网卡设备会触发一个硬中断来释放内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&amp;amp;mid=2666548640&amp;amp;idx=1&amp;amp;sn=7e6dcbbcd569ad4f3c20e915b78b3bac&amp;amp;chksm=80dc890bb7ab001d4cd880c773b3e7b3b9ee4d7d9d4fac0ebbeaa6d247c70084d8cde829bcf2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《图解Linux网络包接收过程》&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《图解Linux网络包接收过程》&lt;/a&gt; 一文中的 3.1 和 3.2 小节，我们详细讲述过硬中断和软中断的处理过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在发送完成硬中断里，会执行 RingBuffer 内存的清理工作，如图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNvsEmEtnv3YYBYMib8fLSyw8dm6kcZP77zdFWymvg4u8SBs9ttGTAeZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.6867469879518072&quot; data-w=&quot;581&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再回头看一下硬中断触发软中断的源码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: drivers/net/ethernet/intel/igb/igb_main.c  &lt;br/&gt;static inline void ____napi_schedule(...){  &lt;br/&gt; list_add_tail(&amp;amp;napi-&amp;gt;poll_list, &amp;amp;sd-&amp;gt;poll_list);  &lt;br/&gt; __raise_softirq_irqoff(NET_RX_SOFTIRQ);  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有个很有意思的细节，无论硬中断是因为是有数据要接收，还是说发送完成通知，&lt;strong&gt;从硬中断触发的软中断都是 NET_RX_SOFTIRQ&lt;/strong&gt;。这个我们在第一节说过了，这是软中断统计中 RX 要高于 TX 的一个原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好我们接着进入软中断的回调函数 igb_poll。在这个函数里，我们注意到有一行 igb_clean_tx_irq，参见源码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: drivers/net/ethernet/intel/igb/igb_main.c  &lt;br/&gt;static int igb_poll(struct napi_struct *napi, int budget)  &lt;br/&gt;{  &lt;br/&gt; //performs the transmit completion operations  &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (q_vector-&amp;gt;tx.ring)  &lt;br/&gt;  clean_complete = igb_clean_tx_irq(q_vector);  &lt;br/&gt; ...  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看看当传输完成的时候，igb_clean_tx_irq 都干啥了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//file: drivers/net/ethernet/intel/igb/igb_main.c  &lt;br/&gt;static bool igb_clean_tx_irq(struct igb_q_vector *q_vector)  &lt;br/&gt;{  &lt;br/&gt; //free the skb  &lt;br/&gt; dev_kfree_skb_any(tx_buffer-&amp;gt;skb);  &lt;br/&gt;  &lt;br/&gt; //clear tx_buffer data  &lt;br/&gt; tx_buffer-&amp;gt;skb = NULL;  &lt;br/&gt; dma_unmap_len_set(tx_buffer, len, 0);  &lt;br/&gt;  &lt;br/&gt; // clear last DMA location and unmap remaining buffers */  &lt;br/&gt; &lt;span&gt;while&lt;/span&gt; (tx_desc != eop_desc) {  &lt;br/&gt; }  &lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无非就是清理了 skb，解除了 DMA 映射等等。到了这一步，传输才算是基本完成了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为啥我说是基本完成，而不是全部完成了呢？因为传输层需要保证可靠性，所以 skb 其实还没有删除。它得等收到对方的 ACK 之后才会真正删除，那个时候才算是彻底的发送完毕。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用一张图总结一下整个发送过程&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNC00DTfspwPMWXLjTYWB23MPL7Uz1TsDhgdsdOF920V4GqZwJyZs8gg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;1.4696673189823874&quot; data-w=&quot;511&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解了整个发送过程以后，我们回头再来回顾开篇提到的几个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1.我们在监控内核发送数据消耗的 CPU 时，是应该看 sy 还是 si ？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在网络包的发送过程中，用户进程（在内核态）完成了绝大部分的工作，甚至连调用驱动的事情都干了。只有当内核态进程被切走前才会发起软中断。发送过程中，绝大部分（90%）以上的开销都是在用户进程内核态消耗掉的。只&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一少部分情况下才会触发软中断（NET_TX 类型），由软中断 ksoftirqd 内核进程来发送。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，在监控网络 IO 对服务器造成的 CPU 开销的时候，不能仅仅只看 si，而是应该把 si、sy 都考虑进来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2. 在服务器上查看 /proc/softirqs，为什么 NET_RX 要比 NET_TX 大的多的多？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前我认为 NET_RX 是读取，NET_TX 是传输。对于一个既收取用户请求，又给用户返回的 Server 来说。这两块的数字应该差不多才对，至少不会有数量级的差异。但事实上，飞哥手头的一台服务器是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwqUG6AE07rYfdAq7rDK2kZNyMmfBRBc22wSuW4caOVsZeiaBticLr9tXeRZibyav6AylEwzWibmHUv6RA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.4419889502762431&quot; data-w=&quot;543&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过今天的源码分析，发现这个问题的原因有两个。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个原因是当数据发送完成以后，通过硬中断的方式来通知驱动发送完毕。但是硬中断无论是有数据接收，还是对于发送完毕，触发的软中断都是 NET_RX_SOFTIRQ，而并不是 NET_TX_SOFTIRQ。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个原因是对于读来说，都是要经过 NET_RX 软中断的，都走 ksoftirqd 内核进程。而对于发送来说，绝大部分工作都是在用户进程内核态处理了，只有系统态配额用尽才会发出 NET_TX，让软中断上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上两个原因，那么在机器上查看 NET_RX 比 NET_TX 大的多就不难理解了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3.发送网络数据的时候都涉及到哪些内存拷贝操作？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的内存拷贝，我们只特指待发送数据的内存拷贝。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次拷贝操作是内核申请完 skb 之后，这时候会将用户传递进来的 buffer 里的数据内容都拷贝到 skb 中。如果要发送的数据量比较大的话，这个拷贝操作开销还是不小的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二次拷贝操作是从传输层进入网络层的时候，每一个 skb 都会被克隆一个新的副本出来。网络层以及下面的驱动、软中断等组件在发送完成的时候会将这个副本删除。传输层保存着原始的 skb，在当网络对方没有 ack 的时候，还可以重新发送，以实现 TCP 中要求的可靠传输。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三次拷贝不是必须的，只有当 IP 层发现 skb 大于 MTU 时才需要进行。会再申请额外的 skb，并将原来的 skb 拷贝为多个小的 skb。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里插入个题外话，大家在网络性能优化中经常听到的零拷贝，我觉得这有点点夸张的成分。TCP 为了保证可靠性，第二次的拷贝根本就没法省。如果包再大于 MTU 的话，分片时的拷贝同样也避免不了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里，相信内核发送数据包对于你来说，已经不再是一个完全不懂的黑盒了。本文哪怕你只看懂十分之一，你也已经掌握了这个黑盒的打开方式。这在你将来优化网络性能时你就会知道从哪儿下手了。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>21484c824da3ebc3ee739666254b1e1a</guid>
<title>从源码角度研究 Java 动态代理</title>
<link>https://toutiao.io/k/uq1g9e6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBUjjhibDYY3cmoaeFQic49V1CKkdiaJkrUORUp32TicCwosMhcn0xVlyLibg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot;/&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近，看了一下关于RMI(Remote Method Invocation)相关的知识，遇到了一个动态代理的问题，然后就决定探究一下动态代理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里先科普一下RMI。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;RMI&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像我们平时写的程序，对象之间互相调用方法都是在同一个JVM中进行，而RMI可以实现一个JVM上的对象调用另一个JVM上对象的方法，即远程调用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;接口定义&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义一个远程对象接口，实现Remote接口来进行标记。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;UserInterface&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Remote&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;sayHello&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; RemoteException&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;远程对象定义&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定义一个远程对象类，继承UnicastRemoteObject来实现Serializable和Remote接口，并实现接口方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;UnicastRemoteObject&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;UserInterface&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;User&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; RemoteException &lt;/span&gt;{}&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sayHello&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Hello World&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;服务端&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动服务端，将user对象在注册表上进行注册。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RmiServer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; RemoteException, AlreadyBoundException, MalformedURLException &lt;/span&gt;{&lt;br/&gt;        User user = &lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;        LocateRegistry.createRegistry(&lt;span&gt;8888&lt;/span&gt;);&lt;br/&gt;        Naming.bind(&lt;span&gt;&quot;rmi://127.0.0.1:8888/user&quot;&lt;/span&gt;, user);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;rmi server is starting...&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动服务端：&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBSibicduTBlGicqFqg3H9rVG26yzJ6PFa2vxwmibRQOVXqTpnVEKowZmsibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.3333333333333333&quot; data-w=&quot;672&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;客户端&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从服务端注册表获取远程对象，在服务端调用sayHello()方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RmiClient&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; RemoteException, NotBoundException, MalformedURLException &lt;/span&gt;{&lt;br/&gt;        UserInterface user = (UserInterface) Naming.lookup(&lt;span&gt;&quot;rmi://127.0.0.1:8888/user&quot;&lt;/span&gt;);&lt;br/&gt;        user.sayHello();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务端运行结果：&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBlm20Dow5wTQK32RtglHqIFmeBlxB2zoOPWia3CfMndO1ib0KNZibQIib5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.23201856148491878&quot; data-w=&quot;862&quot;/&gt;至此，一个简单的RMI demo完成。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;动态代理&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;提出问题&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看了看RMI代码，觉得UserInterface这个接口有点多余，如果客户端使用Naming.lookup()获取的对象不强转成UserInterface，直接强转成User是不是也可以，于是试了一下，就报了以下错误：&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBs2pBw2aAKHLG2M8rPaetlc1euxvAdsq9BYg1XkSE91rotnJVgian5Ag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.05462962962962963&quot; data-w=&quot;1080&quot;/&gt;似曾相识又有点陌生的$Proxy0，翻了翻尘封的笔记找到了是动态代理的知识点，寥寥几笔带过，所以决定梳理一下动态代理，重新整理一份笔记。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;动态代理Demo&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;接口定义&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;UserInterface&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;sayHello&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;真实角色定义&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;UserInterface&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sayHello&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;Hello World&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;调用处理类定义&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代理类调用真实角色的方法时，其实是调用与真实角色绑定的处理类对象的invoke()方法，而invoke()调用的是真实角色的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里需要实现 &lt;span&gt;InvocationHandler&lt;/span&gt; 接口以及invoke()方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserHandler&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;InvocationHandler&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; User user;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;UserProxy&lt;/span&gt;&lt;span&gt;(User user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.user = user;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;invoke&lt;/span&gt;&lt;span&gt;(Object proxy, Method method, Object[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Throwable &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;invoking start....&quot;&lt;/span&gt;);&lt;br/&gt;        method.invoke(user);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;invoking stop....&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; user;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;执行类&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Main&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        User user = &lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;        &lt;span&gt;// 处理类和真实角色绑定&lt;/span&gt;&lt;br/&gt;        UserHandler userHandler = &lt;span&gt;new&lt;/span&gt; UserHandler(user);&lt;br/&gt;        &lt;span&gt;// 开启将代理类class文件保存到本地模式，平时可以省略&lt;/span&gt;&lt;br/&gt;        System.getProperties().put(&lt;span&gt;&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;&lt;/span&gt;, &lt;span&gt;&quot;true&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 动态代理生成代理对象$Proxy0&lt;/span&gt;&lt;br/&gt;        Object o = Proxy.newProxyInstance(Main&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;getClassLoader&lt;/span&gt;(), &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Class&lt;/span&gt;[]&lt;/span&gt;{UserInterface&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;}, &lt;span&gt;userHandler&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;// 调用的其实是invoke()&lt;/span&gt;&lt;br/&gt;        ((UserInterface)o).sayHello();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果：&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBoUib5KPHJebH3mwAWuwyLRoMkRiaJZFvSJmmSCuWxpCYFkrKuUWNW7dw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.2631578947368421&quot; data-w=&quot;1026&quot;/&gt;这样动态代理的基本用法就学完了，可是还有好多问题不明白。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;动态代理是怎么调用的invoke()方法？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;处理类UserHandler有什么作用？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为什么要将类加载器和接口类数组当作参数传入newProxyInstance？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假如让你去实现动态代理，你有什么设计思路？&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;猜想&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;动态代理，是不是和静态代理，即设计模式的代理模式有相同之处呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单捋一捋代理模式实现原理：真实角色和代理角色共同实现一个接口并实现抽象方法A，代理类持有真实角色对象，代理类在A方法中调用真实角色对象的A方法。在Main中实例化代理对象，调用其A方法，间接调用了真实角色的A方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「实现代码」&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 接口和真实角色对象就用上面代码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 代理类，实现UserInterface接口&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserProxy&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;UserInterface&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;// 持有真实角色对象&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; User user = &lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sayHello&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;invoking start....&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 在代理对象的sayHello()里调用真实角色的sayHello()&lt;/span&gt;&lt;br/&gt;        user.sayHello();&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;invoking stop....&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 运行类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Main&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       &lt;span&gt;// 实例化代理角色对象&lt;/span&gt;&lt;br/&gt;        UserInterface userProxy = &lt;span&gt;new&lt;/span&gt; UserProxy();&lt;br/&gt;        &lt;span&gt;// 调用了代理对象的sayHello()，其实是调用了真实角色的sayHello()&lt;/span&gt;&lt;br/&gt;        userProxy.sayHello();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拿开始的动态代理代码和静态代理比较，接口、真实角色都有了，区别就是多了一个UserHandler处理类，少了一个UserProxy代理类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着对比一下两者的处理类和代理类，发现UserHandler的invoke()和UserProxy的sayHello()这两个方法的代码都是一样的。那么，是不是新建一个UserProxy类，然后实现UserInterface接口并持有UserHandler的对象，在sayHello()方法中调用UserHandler的invoke()方法，就可以动态代理了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「代码大概就是这样的」&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 猜想的代理类结构，动态代理生成的代理是com.sun.proxy.$Proxy0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserProxy&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;UserInterface&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;// 持有处理类的对象&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; InvocationHandler handler;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;UserProxy&lt;/span&gt;&lt;span&gt;(InvocationHandler handler)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.handler = handler;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;// 实现sayHello()方法，并调用invoke()&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sayHello&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            handler.invoke(&lt;span&gt;this&lt;/span&gt;, UserInterface&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;getMethod&lt;/span&gt;(&quot;&lt;span&gt;sayHello&lt;/span&gt;&quot;), &lt;span&gt;null&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Throwable throwable) {&lt;br/&gt;            throwable.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// 执行类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        User user = &lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;        UserHandler userHandler = &lt;span&gt;new&lt;/span&gt; UserHandler(user);&lt;br/&gt;        UserProxy proxy = &lt;span&gt;new&lt;/span&gt; UserProxy(userHandler);&lt;br/&gt;        proxy.sayHello();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果：&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBaFOib5PG9Pzr8osOASjvYMgBQUWtVTE0pXRIXIGOAOibwvoE3iaicpZzPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.20190023752969122&quot; data-w=&quot;842&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代理类代码是写死的，而动态代理是当你调用Proxy.newProxyInstance()时，会根据你传入的参数来动态生成这个代理类代码，如果让我实现，会是以下这个流程。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;根据你传入的Class[]接口数组，代理类会来实现这些接口及其方法(这里就是sayHello())，并且持有你传入的userHandler对象，使用文件流将预先设定的包名、类名、方法名等一行行代码写到本地磁盘，生成$Proxy0.java文件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用编译器将&lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;Proxy0.java编译成&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 8564.8 955&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;50&quot; d=&quot;M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(751, 0)&quot;&gt;&lt;path data-c=&quot;72&quot; d=&quot;M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1202, 0)&quot;&gt;&lt;path data-c=&quot;6F&quot; d=&quot;M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1687, 0)&quot;&gt;&lt;path data-c=&quot;78&quot; d=&quot;M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2259, 0)&quot;&gt;&lt;path data-c=&quot;79&quot; d=&quot;M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(2749, 0)&quot;&gt;&lt;path data-c=&quot;30&quot; d=&quot;M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z&quot;/&gt;&lt;path data-c=&quot;2E&quot; d=&quot;M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z&quot; transform=&quot;translate(500, 0)&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3527, 0)&quot;&gt;&lt;path data-c=&quot;6A&quot; d=&quot;M297 596Q297 627 318 644T361 661Q378 661 389 651T403 623Q403 595 384 576T340 557Q322 557 310 567T297 596ZM288 376Q288 405 262 405Q240 405 220 393T185 362T161 325T144 293L137 279Q135 278 121 278H107Q101 284 101 286T105 299Q126 348 164 391T252 441Q253 441 260 441T272 442Q296 441 316 432Q341 418 354 401T367 348V332L318 133Q267 -67 264 -75Q246 -125 194 -164T75 -204Q25 -204 7 -183T-12 -137Q-12 -110 7 -91T53 -71Q70 -71 82 -81T95 -112Q95 -148 63 -167Q69 -168 77 -168Q111 -168 139 -140T182 -74L193 -32Q204 11 219 72T251 197T278 308T289 365Q289 372 288 376Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3939, 0)&quot;&gt;&lt;path data-c=&quot;61&quot; d=&quot;M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(4468, 0)&quot;&gt;&lt;path data-c=&quot;76&quot; d=&quot;M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(4953, 0)&quot;&gt;&lt;path data-c=&quot;61&quot; d=&quot;M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(5759.8, 0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot; font-size=&quot;935.2px&quot; font-family=&quot;serif&quot;&gt;编&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(935, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;935.2px&quot; font-family=&quot;serif&quot;&gt;译&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(1870, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;935.2px&quot; font-family=&quot;serif&quot;&gt;成&lt;/text&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;Proxy0.class&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据你传入的ClassLoader将$Proxy0.class加载到JMV中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用Proxy.newProxyInstance()就会返回一个$Proxy0的对象，然后调用sayHello()，就执行了里面userHandler的invoke()&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是对动态代理的一个猜想过程，下面就通过debug看看源码是怎么实现的。&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;在困惑的日子里学会拥抱源码&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBnO2gic8fJ06jHDLwrmE4hfwS1Yfb8xiaMHzEJ3HsLEAGT3r32k4aECZQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.47129629629629627&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;拥抱源码&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;调用流程图&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里先用PPT画一个流程图，可以跟着流程图来看后面的源码。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBbFc1JS0O3pwJmo4cV8S3N7uAg8hK3AiaU9aTCnibSc4Z6S1zb1Q50R6w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.5703703703703704&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;流程图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「从newProxyInstance()设置断点」&lt;/strong&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBoIvC95qYckppLL4A7mv6D1hh3UvKUmgBib5DrazIjSCMBjKscpia3BTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.13055555555555556&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;newProxyInstance()&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;newProxyInstance()代码分为上下两部分，上部分是获取类&lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;Proxy0.class，下部分是通过反射构建&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 16287.9 955&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;50&quot; d=&quot;M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(751, 0)&quot;&gt;&lt;path data-c=&quot;72&quot; d=&quot;M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1202, 0)&quot;&gt;&lt;path data-c=&quot;6F&quot; d=&quot;M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1687, 0)&quot;&gt;&lt;path data-c=&quot;78&quot; d=&quot;M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2259, 0)&quot;&gt;&lt;path data-c=&quot;79&quot; d=&quot;M21 287Q21 301 36 335T84 406T158 442Q199 442 224 419T250 355Q248 336 247 334Q247 331 231 288T198 191T182 105Q182 62 196 45T238 27Q261 27 281 38T312 61T339 94Q339 95 344 114T358 173T377 247Q415 397 419 404Q432 431 462 431Q475 431 483 424T494 412T496 403Q496 390 447 193T391 -23Q363 -106 294 -155T156 -205Q111 -205 77 -183T43 -117Q43 -95 50 -80T69 -58T89 -48T106 -45Q150 -45 150 -87Q150 -107 138 -122T115 -142T102 -147L99 -148Q101 -153 118 -160T152 -167H160Q177 -167 186 -165Q219 -156 247 -127T290 -65T313 -9T321 21L315 17Q309 13 296 6T270 -6Q250 -11 231 -11Q185 -11 150 11T104 82Q103 89 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(2749, 0)&quot;&gt;&lt;path data-c=&quot;30&quot; d=&quot;M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z&quot;/&gt;&lt;path data-c=&quot;2E&quot; d=&quot;M78 60Q78 84 95 102T138 120Q162 120 180 104T199 61Q199 36 182 18T139 0T96 17T78 60Z&quot; transform=&quot;translate(500, 0)&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3527, 0)&quot;&gt;&lt;path data-c=&quot;63&quot; d=&quot;M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3960, 0)&quot;&gt;&lt;path data-c=&quot;6C&quot; d=&quot;M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(4258, 0)&quot;&gt;&lt;path data-c=&quot;61&quot; d=&quot;M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(4787, 0)&quot;&gt;&lt;path data-c=&quot;73&quot; d=&quot;M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(5256, 0)&quot;&gt;&lt;path data-c=&quot;73&quot; d=&quot;M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(6002.8, 0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot; font-size=&quot;932.9px&quot; font-family=&quot;serif&quot;&gt;，&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(935, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;932.9px&quot; font-family=&quot;serif&quot;&gt;下&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(1870, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;932.9px&quot; font-family=&quot;serif&quot;&gt;部&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(2805, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;932.9px&quot; font-family=&quot;serif&quot;&gt;分&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(3740.1, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;932.9px&quot; font-family=&quot;serif&quot;&gt;是&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(4675.1, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;932.9px&quot; font-family=&quot;serif&quot;&gt;通&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(5610.1, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;932.9px&quot; font-family=&quot;serif&quot;&gt;过&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(6545.1, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;932.9px&quot; font-family=&quot;serif&quot;&gt;反&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(7480.1, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;932.9px&quot; font-family=&quot;serif&quot;&gt;射&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(8415.1, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;932.9px&quot; font-family=&quot;serif&quot;&gt;构&lt;/text&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;translate(9350.2, 0) matrix(1 0 0 -1 0 0)&quot; font-size=&quot;932.9px&quot; font-family=&quot;serif&quot;&gt;建&lt;/text&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;Proxy0对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「上部分代码」&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBv22fZnOvicibUlYLa5rdC47mQuOlOa6wyf2c8aSfZgOqOmrQibJE9AKHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.35648148148148145&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;newProxyInstance()&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从名字看就知道getProxyClass0()是核心方法，step into&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;getProxyClass0()&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBS0bzNryO7ib6BKpQicMsC30T8lZViaibOXxZfxTlSRItgibj8XiapbZcaZaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.3&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;getProxyClass()&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;里面调用了WeakCache对象的get()方法，这里暂停一下debug，先讲讲WeakCache类。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;WeakCache&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顾名思义，它是一个弱引用缓存。那什么是是弱引用呢，是不是还有强引用呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;弱引用&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;WeakReference就是弱引用类，作为包装类来包装其他对象，在进行GC时，其中的包装对象会被回收，而WeakReference对象会被放到引用队列中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个栗子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;// 这就是强引用，只要不写str1 = null，str1指向的这个字符串不就会被垃圾回收&lt;/span&gt;&lt;br/&gt; String str1 = &lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;hello&quot;&lt;/span&gt;);&lt;br/&gt; ReferenceQueue referenceQueue = &lt;span&gt;new&lt;/span&gt; ReferenceQueue();&lt;br/&gt; &lt;span&gt;// 只要垃圾回收，这个str2里面包装的对象就会被回收，但是这个弱引用对象不会被回收，即word会被回收，但是str2指向的弱引用对象不会&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// 每个弱引用关联一个ReferenceQueue，当包装的对象被回收，这个弱引用对象会被放入引用队列中&lt;/span&gt;&lt;br/&gt; WeakReference&amp;lt;String&amp;gt; str2 = &lt;span&gt;new&lt;/span&gt; WeakReference&amp;lt;&amp;gt;(&lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;world&quot;&lt;/span&gt;), referenceQueue);&lt;br/&gt; &lt;span&gt;// 执行gc&lt;/span&gt;&lt;br/&gt; System.gc();&lt;br/&gt; Thread.sleep(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt; &lt;span&gt;// 输出被回收包装对象的弱引用对象：java.lang.ref.WeakReference@2077d4de&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// 可以debug看一下，弱引用对象的referent变量指向的包装对象已经为null&lt;/span&gt;&lt;br/&gt; System.out.println(referenceQueue.poll());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;WeakCache的结构&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实整个WeakCache的都是围绕着成员变量map来工作的，构建了一个一个&amp;lt;K,&amp;lt;K,V&amp;gt;&amp;gt;格式的二级缓存，在动态代理中对应的类型是&amp;lt;类加载器, &amp;lt;接口Class, 代理Class&amp;gt;&amp;gt;，它们都使用了弱引用进行包装，这样在垃圾回收的时候就可以直接回收，减少了堆内存占用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 存放已回收弱引用的队列&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ReferenceQueue&amp;lt;K&amp;gt; refQueue = &lt;span&gt;new&lt;/span&gt; ReferenceQueue&amp;lt;&amp;gt;();&lt;br/&gt;&lt;span&gt;// 使用ConcurrentMap实现的二级缓存结构&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ConcurrentMap&amp;lt;Object, ConcurrentMap&amp;lt;Object, Supplier&amp;lt;V&amp;gt;&amp;gt;&amp;gt; map = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;span&gt;// 可以不关注这个，这个是用来标识二级缓存中的value是否存在的，即Supplier是否被回收&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ConcurrentMap&amp;lt;Supplier&amp;lt;V&amp;gt;, Boolean&amp;gt; reverseMap = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;&lt;span&gt;// 包装传入的接口class，生成二级缓存的Key&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; BiFunction&amp;lt;K, P, ?&amp;gt; subKeyFactory = &lt;span&gt;new&lt;/span&gt; KeyFactory();&lt;br/&gt;&lt;span&gt;// 包装$Proxy0，生成二级缓存的Value&lt;/span&gt;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; BiFunction&amp;lt;K, P, V&amp;gt; valueFactory = &lt;span&gt;new&lt;/span&gt; ProxyClassFactory();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;WeakCache的get()&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到debug，接着进入get()方法，看看map二级缓存是怎么生成KV的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; V &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(K key, P parameter)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Objects.requireNonNull(parameter);&lt;br/&gt;        &lt;span&gt;// 遍历refQueue，然后将缓存map中对应的失效value删除&lt;/span&gt;&lt;br/&gt;        expungeStaleEntries();&lt;br/&gt;        &lt;span&gt;// 以ClassLoader为key，构建map的一级缓存的Key，是CacheKey对象&lt;/span&gt;&lt;br/&gt;        Object cacheKey = CacheK.valueOf(key, refQueue);&lt;br/&gt;        &lt;span&gt;// 通过Key从map中获取一级缓存的value，即ConcurrentMap&lt;/span&gt;&lt;br/&gt;        ConcurrentMap&amp;lt;Object, Supplier&amp;lt;V&amp;gt;&amp;gt; valuesMap = map.get(cacheKey);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (valuesMap == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;         &lt;span&gt;// 如果Key不存在，就新建一个ConCurrentMap放入map，这里使用的是putIfAbsent&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;// 如果key已经存在了，就不覆盖并返回里面的value，不存在就返回null并放入Key&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;// 现在缓存map的结构就是ConCurrentMap&amp;lt;CacheKey, ConCurrentMap&amp;lt;Object, Supplier&amp;gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            ConcurrentMap&amp;lt;Object, Supplier&amp;lt;V&amp;gt;&amp;gt; oldValuesMap = map.putIfAbsent(cacheKey, valuesMap = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;());&lt;br/&gt;            &lt;span&gt;// 如果其他线程已经创建了这个Key并放入就可以复用了&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (oldValuesMap != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                valuesMap = oldValuesMap;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 生成二级缓存的subKey，现在缓存map的结构就是ConCurrentMap&amp;lt;CacheKey, ConCurrentMap&amp;lt;Key1, Supplier&amp;gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 看后面的&amp;lt;生成二级缓存Key&amp;gt;！！！&lt;/span&gt;&lt;br/&gt;        Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));&lt;br/&gt;        &lt;span&gt;// 根据二级缓存的subKey获取value&lt;/span&gt;&lt;br/&gt;        Supplier&amp;lt;V&amp;gt; supplier = valuesMap.get(subKey);&lt;br/&gt;        Factory factory = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        &lt;br/&gt;&lt;span&gt;// ！！！直到完成二级缓存Value的构建才结束，Value是弱引用的$Proxy0.class！！！&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;           &lt;span&gt;// 第一次循环：suppiler肯定是null，因为还没有将放入二级缓存的KV值&lt;/span&gt;&lt;br/&gt;           &lt;span&gt;// 第二次循环：这里suppiler不为null了！！！进入if&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (supplier != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;// 第二次循环：真正生成代理对象，&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 往后翻，看&amp;lt;生成二级缓存Value&amp;gt;，核心!!!!!&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 看完后面回到这里：value就是弱引用后的$Proxy0.class&lt;/span&gt;&lt;br/&gt;                V value = supplier.get();&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (value != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;             &lt;span&gt;// 本方法及上部分的最后一行代码，跳转最后的&amp;lt;构建$Proxy对象&amp;gt;&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; value;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;          &lt;span&gt;// 第一次循环：factory肯定为null，生成二级缓存的Value&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (factory == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                factory = &lt;span&gt;new&lt;/span&gt; Factory(key, parameter, subKey, valuesMap);&lt;br/&gt;            }&lt;br/&gt;         &lt;span&gt;// 第一次循环：将subKey和factory作为KV放入二级缓存&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (supplier == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                supplier = valuesMap.putIfAbsent(subKey, factory);&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (supplier == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    &lt;span&gt;// 第一次循环：赋值之后suppiler就不为空了，记住！！！！！&lt;/span&gt;&lt;br/&gt;                    supplier = factory;&lt;br/&gt;                }&lt;br/&gt;            } &lt;br/&gt;           }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;生成二级缓存Key&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在get()中调用subKeyFactory.apply(key, parameter)，根据你newProxyInstance()传入的接口Class[]的个数来生成二级缓存的Key，这里我们就传入了一个UserInterface.class，所以就返回了Key1对象。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBL51Su1TmuFzeqN5UZGziaibmpbwDmtsxpXTRY5ic86pzN4jCIVQmWKEeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.2777777777777778&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;KeyFactory.apply()&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不论是Key1、Key2还是KeyX，他们都继承了WeakReference，都是包装对象是Class的弱引用类。这里看看Key1的代码。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBBwPOk0XeOiaIzxVjkhTvpLVfVKFg8cP0sYzyU8r6IndkQc5ic5r3fdOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.2638888888888889&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Key1&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;生成二级缓存Value&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的while循环中，第一次循环只是生成了一个空的Factory对象放入了二级缓存的ConcurrentMap中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在第二次循环中，才开始通过get()方法来真正的构建value。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;别回头，接着往下看。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Factory.get()生成弱引用value&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「CacheValue」&lt;/strong&gt;类是一个弱引用，是二级缓存的Value值，包装的是class，在这里就是$Proxy0.class，至于这个类如何生成的，根据下面代码注释一直看完&lt;span&gt;Class文件的生成&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; V &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;// 检查是否被回收，如果被回收，会继续执行上面的while循环，重新生成Factory&lt;/span&gt;&lt;br/&gt;            Supplier&amp;lt;V&amp;gt; supplier = valuesMap.get(subKey);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (supplier != &lt;span&gt;this&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;// 这里的V的类型是Class&lt;/span&gt;&lt;br/&gt;            V value = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;// 这行是核心代码，看后面&amp;lt;class文件的生成&amp;gt;，记住这里返回的是Class&lt;/span&gt;&lt;br/&gt;            value = Objects.requireNonNull(valueFactory.apply(key, parameter));&lt;br/&gt;            &lt;span&gt;// 将Class对象包装成弱引用&lt;/span&gt;&lt;br/&gt;            CacheValue&amp;lt;V&amp;gt; cacheValue = &lt;span&gt;new&lt;/span&gt; CacheValue&amp;lt;&amp;gt;(value);&lt;br/&gt;            &lt;span&gt;// 回到上面&amp;lt;WeakCache的get()方法&amp;gt;V value = supplier.get();&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; value;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBOmLibWicqxsTqz5Wo1Eb5OsY4FicslO36Qd6D5zpUFh48Gl5yjoGewXnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.4212962962962963&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;CacheValue&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;Class文件的生成&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;包名类名的定义与验证&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进入valueFactory.apply(key, parameter)方法，看看class文件是怎么生成的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String proxyClassNamePrefix = &lt;span&gt;&quot;$Proxy&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt; Class&amp;lt;?&amp;gt; apply(ClassLoader loader, Class&amp;lt;?&amp;gt;[] interfaces) {&lt;br/&gt;            Map&amp;lt;Class&amp;lt;?&amp;gt;, Boolean&amp;gt; interfaceSet = &lt;span&gt;new&lt;/span&gt; IdentityHashMap&amp;lt;&amp;gt;(interfaces.length);&lt;br/&gt;            &lt;span&gt;// 遍历你传入的Class[]，我们只传入了UserInterface.class&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (Class&amp;lt;?&amp;gt; intf : interfaces) {&lt;br/&gt;                Class&amp;lt;?&amp;gt; interfaceClass = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;                 &lt;span&gt;// 获取接口类&lt;/span&gt;&lt;br/&gt;                interfaceClass = Class.forName(intf.getName(), &lt;span&gt;false&lt;/span&gt;, loader);&lt;br/&gt;                 &lt;span&gt;// 这里就很明确为什么只能传入接口类，不是接口类会报错&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (!interfaceClass.isInterface()) {&lt;br/&gt;                    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;br/&gt;                        interfaceClass.getName() + &lt;span&gt;&quot; is not an interface&quot;&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            String proxyPkg = &lt;span&gt;null&lt;/span&gt;; &lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; accessFlags = Modifier.PUBLIC | Modifier.FINAL;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (Class&amp;lt;?&amp;gt; intf : interfaces) {&lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; flags = intf.getModifiers();&lt;br/&gt;                &lt;span&gt;// 验证接口是否是public，不是public代理类会用接口的package，因为只有在同一包内才能继承&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 我们的UserInterface是public，所以跳过&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (!Modifier.isPublic(flags)) {&lt;br/&gt;                    accessFlags = Modifier.FINAL;&lt;br/&gt;                    String name = intf.getName();&lt;br/&gt;                    &lt;span&gt;int&lt;/span&gt; n = name.lastIndexOf(&lt;span&gt;&#x27;.&#x27;&lt;/span&gt;);&lt;br/&gt;                    String pkg = ((n == -&lt;span&gt;1&lt;/span&gt;) ? &lt;span&gt;&quot;&quot;&lt;/span&gt; : name.substring(&lt;span&gt;0&lt;/span&gt;, n + &lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; (proxyPkg == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                        proxyPkg = pkg;&lt;br/&gt;                    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (!pkg.equals(proxyPkg)) {&lt;br/&gt;                        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;br/&gt;                            &lt;span&gt;&quot;non-public interfaces from different packages&quot;&lt;/span&gt;);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;         &lt;span&gt;// 如果接口类是public，则用默认的包&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (proxyPkg == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;// PROXY_PACKAGE = &quot;com.sun.proxy&quot;;&lt;/span&gt;&lt;br/&gt;                proxyPkg = ReflectUtil.PROXY_PACKAGE + &lt;span&gt;&quot;.&quot;&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;         &lt;span&gt;// 原子Int，此时num = 0&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;long&lt;/span&gt; num = nextUniqueNumber.getAndIncrement();&lt;br/&gt;            &lt;span&gt;// com.sun.proxy.$Proxy0，这里包名和类名就出现了！！！&lt;/span&gt;&lt;br/&gt;            String proxyName = proxyPkg + proxyClassNamePrefix + num;&lt;br/&gt;         &lt;span&gt;// ！！！！生成class文件，查看后面&amp;lt;class文件写入本地&amp;gt; 核心！！！！&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;byte&lt;/span&gt;[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);&lt;br/&gt;            &lt;span&gt;// ！！！看完下面再回来看这行！！！！&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// 获取了字节数组之后，获取了class的二进制流将类加载到了JVM中&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// 并且返回了$Proxy0.class，返回给Factory.get()来包装&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; defineClass0(loader, proxyName,proxyClassFile, &lt;span&gt;0&lt;/span&gt;, proxyClassFile.length);&lt;br/&gt;           &lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;defineClass0()是Proxy类自定义的类加载的native方法，会获取class文件的二进制流加载到JVM中，以获取对应的Class对象，这一块可以参考JVM类加载器。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;class文件写入本地&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;generateProxyClass()方法会将class二进制文件写入本地目录，并返回class文件的二进制流，使用你传入的类加载器加载，&lt;strong&gt;「这里你知道类加载器的作用了么」&lt;/strong&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] generateProxyClass(&lt;span&gt;final&lt;/span&gt; String name,&lt;br/&gt;                                            Class[] interfaces)&lt;br/&gt;    {&lt;br/&gt;        ProxyGenerator gen = &lt;span&gt;new&lt;/span&gt; ProxyGenerator(name, interfaces);&lt;br/&gt;        &lt;span&gt;// 生成class文件的二进制，查看后面&amp;lt;生成class文件二进制&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;final&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] classFile = gen.generateClassFile();&lt;br/&gt;      &lt;span&gt;// 将class文件写入本地  &lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (saveGeneratedFiles) {&lt;br/&gt;            java.security.AccessController.doPrivileged(&lt;br/&gt;            &lt;span&gt;new&lt;/span&gt; java.security.PrivilegedAction&amp;lt;Void&amp;gt;() {&lt;br/&gt;                &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Void &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        FileOutputStream file =&lt;br/&gt;                            &lt;span&gt;new&lt;/span&gt; FileOutputStream(dotToSlash(name) + &lt;span&gt;&quot;.class&quot;&lt;/span&gt;);&lt;br/&gt;                        file.write(classFile);&lt;br/&gt;                        file.close();&lt;br/&gt;                        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;                    } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InternalError(&lt;br/&gt;                            &lt;span&gt;&quot;I/O exception saving generated file: &quot;&lt;/span&gt; + e);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            });&lt;br/&gt;        }&lt;br/&gt;      &lt;span&gt;// 返回$Proxy0.class字节数组，回到上面&amp;lt;class文件生成&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; classFile;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;生成class文件二进制流&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;generateClassFile()生成class文件，并存放到字节数组，&lt;strong&gt;「可以顺便学一下class结构，这里也体现了你传入的class[]的作用」&lt;/strong&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] generateClassFile() {&lt;br/&gt;      &lt;span&gt;// 将hashcode、equals、toString是三个方法放入代理类中&lt;/span&gt;&lt;br/&gt;        addProxyMethod(hashCodeMethod, Object&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        addProxyMethod(equalsMethod, Object&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        addProxyMethod(toStringMethod, Object&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; interfaces.length; i++) {&lt;br/&gt;            Method[] methods = interfaces[i].getMethods();&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; methods.length; j++) {&lt;br/&gt;             &lt;span&gt;// 将接口类的方法放入新建的代理类中，这里就是sayHello()&lt;/span&gt;&lt;br/&gt;                addProxyMethod(methods[j], interfaces[i]);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (List&amp;lt;ProxyMethod&amp;gt; sigmethods : proxyMethods.values()) {&lt;br/&gt;            checkReturnTypes(sigmethods);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 给代理类增加构造方法&lt;/span&gt;&lt;br/&gt;        methods.add(generateConstructor());&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (List&amp;lt;ProxyMethod&amp;gt; sigmethods : proxyMethods.values()) {&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (ProxyMethod pm : sigmethods) {&lt;br/&gt;                   &lt;span&gt;// 将上面的四个方法都封装成Method类型成员变量&lt;/span&gt;&lt;br/&gt;                    fields.add(&lt;span&gt;new&lt;/span&gt; FieldInfo(pm.methodFieldName,&lt;br/&gt;                        &lt;span&gt;&quot;Ljava/lang/reflect/Method;&quot;&lt;/span&gt;,&lt;br/&gt;                         ACC_PRIVATE | ACC_STATIC));&lt;br/&gt;                    &lt;span&gt;// generate code for proxy method and add it&lt;/span&gt;&lt;br/&gt;                    methods.add(pm.generateMethod());&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;      &lt;span&gt;// static静态块构造&lt;/span&gt;&lt;br/&gt;        methods.add(generateStaticInitializer());&lt;br/&gt;        cp.getClass(dotToSlash(className));&lt;br/&gt;        cp.getClass(superclassName);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; interfaces.length; i++) {&lt;br/&gt;            cp.getClass(dotToSlash(interfaces[i].getName()));&lt;br/&gt;        }&lt;br/&gt;        cp.setReadOnly();&lt;br/&gt;        ByteArrayOutputStream bout = &lt;span&gt;new&lt;/span&gt; ByteArrayOutputStream();&lt;br/&gt;        DataOutputStream dout = &lt;span&gt;new&lt;/span&gt; DataOutputStream(bout);&lt;br/&gt;      &lt;span&gt;// !!!核心点来了！这里就开始构建class文件了，以下都是class的结构，只写一部分&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {   &lt;br/&gt;            &lt;span&gt;// u4 magic，class文件的魔数，确认是否为一个能被JVM接受的class&lt;/span&gt;&lt;br/&gt;            dout.writeInt(&lt;span&gt;0xCAFEBABE&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;// u2 minor_version，0&lt;/span&gt;&lt;br/&gt;            dout.writeShort(CLASSFILE_MINOR_VERSION);&lt;br/&gt;            &lt;span&gt;// u2 major_version，主版本号，Java8对应的是52;&lt;/span&gt;&lt;br/&gt;            dout.writeShort(CLASSFILE_MAJOR_VERSION);&lt;br/&gt;            &lt;span&gt;// 常量池&lt;/span&gt;&lt;br/&gt;            cp.write(dout);&lt;br/&gt;            &lt;span&gt;// 其他结构，可参考class文件结构&lt;/span&gt;&lt;br/&gt;            dout.writeShort(ACC_PUBLIC | ACC_FINAL | ACC_SUPER);&lt;br/&gt;            dout.writeShort(cp.getClass(dotToSlash(className)));&lt;br/&gt;            dout.writeShort(cp.getClass(superclassName));&lt;br/&gt;            dout.writeShort(interfaces.length);&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; interfaces.length; i++) {&lt;br/&gt;                dout.writeShort(cp.getClass(&lt;br/&gt;                    dotToSlash(interfaces[i].getName())));&lt;br/&gt;            }&lt;br/&gt;            dout.writeShort(fields.size());&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (FieldInfo f : fields) {&lt;br/&gt;                f.write(dout);&lt;br/&gt;            }&lt;br/&gt;            dout.writeShort(methods.size());           &lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (MethodInfo m : methods) {&lt;br/&gt;                m.write(dout);&lt;br/&gt;            }&lt;br/&gt;            dout.writeShort(&lt;span&gt;0&lt;/span&gt;); &lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InternalError(&lt;span&gt;&quot;unexpected I/O Exception&quot;&lt;/span&gt;, e);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;// 将class文件字节数组返回&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; bout.toByteArray();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;构建$Proxy对象&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;newProxyInstance()上半部分经过上面层层代码调用，获取了$Proxy0.class，接下来看下部分代码：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KM1NunBnCjt3cwBPz3IHBO4mupzGNnpBicGjrXvBEiaeqBzxT2dUa19TtdpJZUCq2MmichvAIjiaiaBqSDu23ksqGpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.3861111111111111&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;newInstance&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;cl就是上面获取的Proxy0.class，h就是上面传入的userHandler，被当做构造参数来创建$Proxy0对象。然后获取这个动态代理对象，调用sayHello()方法，相当于调用了UserHandler的invoke()，&lt;strong&gt;「这里就是UserHandler的作用」&lt;/strong&gt;！&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;$Proxy.class文件&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们开启了将代理class写到本地目录的功能，在项目下的com/sum/proxy目录下找到了$Proxy0的class文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「看一下反编译的class」&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; com.sun.proxy;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; com.test.proxy.UserInterface;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.lang.reflect.InvocationHandler;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.lang.reflect.Method;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.lang.reflect.Proxy;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.lang.reflect.UndeclaredThrowableException;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; $&lt;span&gt;Proxy0&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Proxy&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;UserInterface&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Method m1;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Method m3;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Method m2;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Method m0;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; $Proxy0(InvocationHandler var1) &lt;span&gt;throws&lt;/span&gt;  {&lt;br/&gt;        &lt;span&gt;super&lt;/span&gt;(var1);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;equals&lt;/span&gt;&lt;span&gt;(Object var1)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; (Boolean)&lt;span&gt;super&lt;/span&gt;.h.invoke(&lt;span&gt;this&lt;/span&gt;, m1, &lt;span&gt;new&lt;/span&gt; Object[]{var1});&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (RuntimeException | Error var3) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; var3;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Throwable var4) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UndeclaredThrowableException(var4);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sayHello&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;super&lt;/span&gt;.h.invoke(&lt;span&gt;this&lt;/span&gt;, m3, (Object[])&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (RuntimeException | Error var2) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; var2;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Throwable var3) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UndeclaredThrowableException(var3);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; (String)&lt;span&gt;super&lt;/span&gt;.h.invoke(&lt;span&gt;this&lt;/span&gt;, m2, (Object[])&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (RuntimeException | Error var2) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; var2;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Throwable var3) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UndeclaredThrowableException(var3);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;hashCode&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt;  &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; (Integer)&lt;span&gt;super&lt;/span&gt;.h.invoke(&lt;span&gt;this&lt;/span&gt;, m0, (Object[])&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (RuntimeException | Error var2) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; var2;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Throwable var3) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UndeclaredThrowableException(var3);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            m1 = Class.forName(&lt;span&gt;&quot;java.lang.Object&quot;&lt;/span&gt;).getMethod(&lt;span&gt;&quot;equals&quot;&lt;/span&gt;, Class.forName(&lt;span&gt;&quot;java.lang.Object&quot;&lt;/span&gt;));&lt;br/&gt;            m3 = Class.forName(&lt;span&gt;&quot;com.test.proxy.UserInterface&quot;&lt;/span&gt;).getMethod(&lt;span&gt;&quot;sayHello&quot;&lt;/span&gt;);&lt;br/&gt;            m2 = Class.forName(&lt;span&gt;&quot;java.lang.Object&quot;&lt;/span&gt;).getMethod(&lt;span&gt;&quot;toString&quot;&lt;/span&gt;);&lt;br/&gt;            m0 = Class.forName(&lt;span&gt;&quot;java.lang.Object&quot;&lt;/span&gt;).getMethod(&lt;span&gt;&quot;hashCode&quot;&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (NoSuchMethodException var2) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NoSuchMethodError(var2.getMessage());&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (ClassNotFoundException var3) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NoClassDefFoundError(var3.getMessage());&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;结语&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面就是动态代理源码的调试过程，与之前的猜想的代理类的生成过程比较，动态代理是直接生成class文件，省去了java文件和编译这一块。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚开始看可能比较绕，跟着注释及跳转指引，耐心多看两遍就明白了。动态代理涉及的知识点比较多，我自己看的时候，在WeakCache这一块纠结了一阵，其实把它当成一个两层的map对待即可，只不过里面所有的KV都被弱引用包装。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>34f212d7a2fe04dde4b5b0854999063a</guid>
<title>美团外卖美食知识图谱的迭代及应用</title>
<link>https://toutiao.io/k/hlwpt15</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1. 背景&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2. 需求及挑战&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3. 外卖美食知识图谱的迭代&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.1 菜品类目&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.2 类目、口味、食材、荤素、做法等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.3 健康餐&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.4 菜品实体对齐&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4. 应用&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.1 套餐搭配-表征菜品&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.2 交互式推荐&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.3 搜索&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;5. 未来规划&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;5.1 场景化标签的挖掘&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;5.2 基于图谱的推荐技术研究&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;6. 参考文献&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;7. 作者简介&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文系外卖美食知识图谱系列的第一篇文章，这篇文章系统地介绍了美团外卖美食知识图谱的标签体系结构，包括菜品类目标签、标准菜品名、美食基础属性（&lt;span&gt;食材、口味等&lt;/span&gt;）和美食业务主题属性（&lt;span&gt;商家招牌、类目经典等&lt;/span&gt;）。在技术层面，举例对标签体系的具体构建方法进行介绍，例如基于BERT预训练的分类模型。在应用方面，介绍了美食知识图谱在美团外卖业务的具体应用，包括支撑套餐搭配的菜品表征、提升搜索和商家推荐等业务的用户体验。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 背景&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;知识图谱，旨在描述真实世界中存在的各种实体和实体之间的关系。在美团外卖业务中，美食商品是美团向用户提供服务的基础，美食知识图谱的建设，可以帮助我们向用户提供更加准确、更加丰富、更加个性化的美食服务。另外，美团外卖业务向用户提供“到家”吃饭的服务，到店餐饮业务则向用户提供“到店”吃饭的服务，而外卖和到店的商家和菜品有相当程度的重合，菜品数据的对齐，为我们进行线上（&lt;/span&gt;&lt;span&gt;外卖场景&lt;/span&gt;&lt;span&gt;）线下（&lt;/span&gt;&lt;span&gt;到店场景&lt;/span&gt;&lt;span&gt;）数据的对比分析也提供了一个很好的“抓手”。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文介绍了外卖美食知识图谱的建设，基于对外卖业务数据（&lt;/span&gt;&lt;span&gt;外卖交易数据、商家录入的商品标签信息、专业描述PGC、用户评论UGC、商品图片等&lt;/span&gt;&lt;span&gt;）的挖掘和分析，形成了针对外卖美食的分类体系（&lt;/span&gt;&lt;span&gt;美食类目标签&lt;/span&gt;&lt;span&gt;）和标准化体系（&lt;/span&gt;&lt;span&gt;标准菜品名标签&lt;/span&gt;&lt;span&gt;），并进一步针对不同类型的美食商品，构建包含口味、食材等众多美食基础属性体系。同时，依托美团外卖的业务特性，构建美食商品在外卖业务中涉及的主题属性体系，例如商家招牌、商家主营、类目经典等。目前，外卖美食知识图谱的标签结构如下图1所示：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;466&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;226&quot; data-ratio=&quot;0.510989010989011&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWfyMTop4riaWsUY4lToThgg0Ywjad8ezca1WXTCl3mGZKXrq0XwYcAiapibuSIBR2wkoIjyXXztPJ8g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;728&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图1 美食知识图谱标签体系&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;外卖美食知识图谱包含以下四种维度的标签（&lt;/span&gt;&lt;span&gt;以“宫保鸡丁”为例，如下图2所示&lt;/span&gt;&lt;span&gt;）：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;类目标签&lt;/strong&gt;：包括主食、小吃、菜品等类目，并在每个类目下，形成了层级化的三百多种细分类目。例如“宫保鸡丁”的类目是“菜品”。类目标签是美食商品的基础分类信息，根据类目的不同，美食商品的基础属性也不同。例如“菜品”类目存在“荤素”、“菜系”之分，而“酒水饮品”类目则没有这种属性标签。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;标准菜品名标签&lt;/strong&gt;：标准菜品名标签主要为标准商品信息，例如“宫保鸡丁（&lt;/span&gt;&lt;span&gt;招牌必点&lt;/span&gt;&lt;span&gt;）”的标准商品是“宫保鸡丁”。因商家输入商品的多样性，标准菜标签的建设，实现了相同美食的聚合。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;基础属性&lt;/strong&gt;：根据美食商品的类目不同，构建包括美食的食材、菜系、口味、制作方法、荤素等基础属性。例如“宫保鸡丁”的菜系是“川菜”，食材有“鸡胸”和“花生”，荤素标签是“荤”。基础属性的挖掘对我们理解商品起到关键作用，在商品的筛选、展示、商品表征等业务需求方面，提供基本的数据特征。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;主题属性&lt;/strong&gt;：主题属性主要体现美食的业务主题，包括美食在外卖的交易行为、美食在商家的定位、美食在用户反馈中的好评度等。例如某商家的“宫保鸡丁（&lt;/span&gt;&lt;span&gt;招牌必点&lt;/span&gt;&lt;span&gt;）”是该商家的“招牌菜”。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;333&quot; data-ratio=&quot;0.6906019007391764&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWfyMTop4riaWsUY4lToThggGxqyNYnvgrpnaPvp0bA4Sjso4kA0K2ydUtgKEgvuAp6teaz5TaleXA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;947&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图2 外卖美食知识图谱样例&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;菜品对齐，涉及到菜品数据，来自外卖在线菜品、点评推荐菜品、美团商家套餐等。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. 需求及挑战&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;目前，外卖美食知识图谱已经应用于美团外卖的多个场景，例如推荐、搜索、套餐搭配、运营分析等。业务的深入发展，对美食知识图谱的建设和迭代也提出了更加复杂的要求，例如：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;美食商品越来越多样，相应的美食知识图谱则需要越来越精细和准确。例如美食知识图谱的类目标签从零开始，建设了包含一百多种类目的类目标签体系。但随着业务发展，部分类目存在明显的可细化空间。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;图谱标签的挖掘，偏向于静态标签的挖掘，对于相同图谱标签下的美食，缺少业务相关的主题属性描述。例如同样包含“花生”的“酒鬼花生”，相比“宫保鸡丁”，更能代表“花生”相关的美食。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;外卖美食知识图谱主要描述外卖美食商品，而同一商家的美食商品，也可能会出现在该店的线下收银等业务中。通过对齐不同业务的美食商品，可以在美食实体层面，完善美食知识图谱对商家美食的描述，从而指导商品和商家运营。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为满足业务需求，我们对类目标签和基础属性进行了迭代和优化；同时，构建了业务相关的主题属性。另外，我们将外卖菜品和到餐菜品进行了实体对齐。其中，挖掘主题属性，即挖掘业务相关的图谱知识，是一个需要综合考虑外卖业务和商品本身属性的复杂过程。外卖菜品和到餐菜品的对齐，则需要综合考虑菜品多样性表述和菜品主体归一。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;外卖美食知识图谱的迭代难点主要体现在以下几点：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;业务相关的主题属性挖掘，并没有现成的体系可以参考，在构建过程中，涉及大量的分析和体系设计工作。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;主题属性的挖掘，最重要的是需要从用户的需求出发，分析用户对商品的需求点，并将其反映在商品的图谱层面，形成相应的主题属性标签。同时，商家的商品信息是一个动态变化的过程，例如销量、供给、商品标签等，前后两天的信息可能就会完全不同。因此业务性主题属性的挖掘，一方面需要建设相对完善的体系，另一方面也需要适配业务数据的动态变化过程，也就在图谱挖掘和需求匹配上带来了极大的挑战。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;商家录入菜品时，对菜品存在多样性表述，例如同一道菜在分量、口味、食材等方面存在的差异。菜品对齐时，则需要对这些多样性表述进行平衡，例如是否忽略分量因素等。但目前并没有现成的对齐标准可以参考。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 外卖美食知识图谱的迭代&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因篇幅受限，本文主要对其中菜品类目，不同类目、口味、食材、荤素、做法下的经典美食，健康餐等图谱标签的挖掘进行介绍。其中，在图谱标签挖掘中涉及到的数据来源和采用的技术，大致如下表所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3159509202453988&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWfyMTop4riaWsUY4lToThgg3F0oVlWnXEfzgxXG92r0a4ichoTiblViaTmJCY3Yw8am9vlibOGf7veXnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1304&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.1 菜品类目&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;菜品类目标签的挖掘，主要解决美食菜品是什么类别的问题。实现这一目标的挑战有两方面：首先是类目体系如何建立，其次是如何将商品链接到相应的类目节点。在最开始的体系构建时，我们从美食商品的特点以及业务的具体需求出发，从零开始建立起包含一百多种类别的层次化类别体系，部分实例如图3（&lt;/span&gt;&lt;span&gt;左&lt;/span&gt;&lt;span&gt;）所示。同时，构建基于CNN+CRF的分类模型，对美食商品进行类目分类，如图4（&lt;/span&gt;&lt;span&gt;左&lt;/span&gt;&lt;span&gt;）所示。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然而，随着业务的发展，已有分类目已经无法支持现有业务的需求。例如：原先的类目体系，对热菜描述不够详细，譬如没有区分热菜的做法等。为此，我们与外卖的供给规划部合作，将类目体系扩充到细分的三百多种类目标签，划分更加详细，覆盖也更加全面，部分实例如图3（&lt;/span&gt;&lt;span&gt;右&lt;/span&gt;&lt;span&gt;）所示。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24324324324324326&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWfyMTop4riaWsUY4lToThgg1uOKMd5sFd5UibT3NxaxkjPu5ytib2mTSVtMibOIKwB6rASXMWxPj1R6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1073&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图3 类目体系的迭代&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;类目的细分，要求模型更加精确。在进行类目识别时，可用的数据包括菜品名、商家店内侧边栏分类名称、商家名等。考虑到可使用的信息大多为文本信息，并且，商家录入的文本并没有一定的规范，菜品名也多种多样，为提高模型精度，我们将原先的CNN+CRF的分类模型进行了升级，采用模型容量更大的BERT预训练+Fine-Tuning的模型。模型结构如下图4（&lt;/span&gt;&lt;span&gt;右&lt;/span&gt;&lt;span&gt;）所示。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;1&quot; data-cropselx2=&quot;522&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;179&quot; data-ratio=&quot;0.3569350145489816&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWfyMTop4riaWsUY4lToThggiaBgSibxLGpMb3YwiaiaVesdKWHCNVHGRhhdvYrno4juIuFAAULuicupP9Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1031&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图4 类目模型迭代&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.2 不同类目、口味、食材、荤素、做法下的经典美食标签&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们在建设主题属性时，首先在基础属性标签维度，综合考虑商品的销量和供给情况，对菜品进行选优。例如类目下的经典美食等。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;类目经典美食等指的是销量较高、供给量丰富的类目美食商品，例如主食经典美食、小吃经典美食。口味、食材、做法经典美食标签等也是相似的定义。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在建设过程中，我们发现，假如直接在商品维度进行识别，因为商品的更新频率相对较高，对新录入的暂时没有销量或者暂时销量低的美食商品不友好，销量水平需要考虑在线时间的影响。因此我们使用标准菜品进行类目、口味经典等的识别，并通过标准菜品，泛化到具体的美食商品上。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其中，“标准菜品”借用其它类电商业务中的“标品”概念，虽然绝大部分菜品的生产都不是标准化的过程，但是这里我们只关注主要的共性部分，忽略次要的差异部分。例如“西红柿鸡蛋”、“番茄炒蛋”都是同一类菜品。从结果上看，目前我们聚合出来的“标准菜品”达到几十万的量级，并且能够覆盖大部分美食商品。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;借助标准菜品，我们将类目、口味、食材、荤素、做法等标签聚合到标准菜品维度，并将销量、供给量进行标准菜品维度计算，这样就解决了商品在线时间长短的问题。在具体打标过程中，例如类目经典，我们基于销量和供给，在类目维度对标准菜进行排序，并选择Top n%标准菜进行打标，作为类目经典下的商品。例如在“面食”类目下，“西红柿鸡蛋面”的销量和供给量均在Top n%的水平，因此就认为“西红柿鸡蛋面”是一个面食类经典美食。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.3 健康餐&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里的健康餐主要指低脂低卡餐，即低卡路里、低脂肪、高纤维、制作简单、原汁原味、健康营养的食物，一般为蔬菜水果（&lt;/span&gt;&lt;span&gt;如罗勒、甘蓝、秋葵、牛油果等&lt;/span&gt;&lt;span&gt;），富含优质蛋白的肉类（&lt;/span&gt;&lt;span&gt;如三文鱼、虾、贝类、鸡胸等&lt;/span&gt;&lt;span&gt;），谷物（&lt;/span&gt;&lt;span&gt;主要以粗粮为主，如燕麦、高粱、藜麦等&lt;/span&gt;&lt;span&gt;）。烹饪方法也坚持“少油，少盐，少糖”的原则，主要做法为蒸、煮、少煎、凉拌等。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;健康餐的识别，主要挑战在于本身的样本较少，但是因为健康餐的特殊性，商家在进行商品录入时，一般会对其进行描述，例如指出这个美食商品是“健康”的、“低卡”的、“健身”类型的，因此我们构建了一个分类模型，对健康餐进行识别。可使用的数据，包括商品名、商家导航栏、商家名称、商家对商品的描述等。而商家类目与商品的类目处于迭代状态，因此并没有对这部分信息进行使用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;识别过程如下&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;训练数据构建&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：因健康餐本身的占比相对较少，因此首先总结和健康餐相关的关键词，使用关键词进行文本匹配，采样概率相对较高的健康餐数据，进行外包数据标注。此处，我们总结出“沙拉、谷物饭、谷物碗、低油、低卡、无糖、减脂、减肥、轻食、轻卡”等关键词。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;模型构建&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：同一个商品因其中使用的配料不同，在健康餐识别方面也会不同，例如菜名为“招牌沙拉”的商品，假如沙拉中添加了芝士，则有可能商品就不会被识别成健康餐。为了综合考虑商家录入的商品信息，使用商品名、商家名、导航栏名称、商家录入的商品描述等。这四种数据为不同尺度的数据源，商品名等为相对较短的文本，因此在模型构建时，考虑使用类似Text-CNN[1]的结构进行字级别的特征提取；商品描述则是相对较长的文本，因此在构建时，考虑使用类似Transformer[3]的结构进行特征提取，使用Multi-head Attention的机制，提取长文本中，“字”层面的特征。具体结构如下：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据迭代增强&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：因为使用关键词进行样本构建，在模型训练时，模型会朝着包含这些关键词的方向学习，因此存在漏召回的情况。在这里，我们进行了一定的训练数据增强，例如在评估时，选取可识别出健康餐的商家，对该商家中漏召回的数据进行训练数据补充；同时，对部分特征明显的关键词，进行补充并扩充正例。通过对训练样本的多次扩充，最终完成健康餐的高准确率识别。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;452&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;266&quot; data-ratio=&quot;0.6045197740112994&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWfyMTop4riaWsUY4lToThggrarWgrmNEoNsy8Vmkl78FQ18PJb4oTYSMgyyTVBaxUWy04OPhmcxpg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;708&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图5 健康餐识别模型&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.4 菜品实体对齐&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;考虑到同一商家菜品在不同业务线的菜品名可能略有差异，我们设计了一套菜品名匹配的算法，通过拆解菜品名称的量词、拼音、前后缀、子字符串、顺序等特征，利用美食类目识别、标准菜品名抽取、同义关系匹配等进行菜品实体对齐。例如：碳烧鸽=炭烧鸽、重庆辣子鸡=重庆歌乐山辣子鸡、茄子肉泥盖饭=茄子肉泥盖浇饭、番茄炒蛋=西红柿炒蛋等。目前，形成如下图的菜品归一体系：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;511&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;221&quot; data-ratio=&quot;0.45420326223337515&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWfyMTop4riaWsUY4lToThggrjNjUNvuUUDu1BzFFCgpXWfaSIF1gJTUHbnZOrFr7kdxoItLCbMcAw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;797&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图6 菜品归一体系&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4. 应用&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里对外卖美食知识图谱的应用，进行举例说明。主要涉及套餐搭配、美食商品展示等。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.1 套餐搭配-表征菜品&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为满足用户的搭配成单需求，进行套餐搭配技术的探索。套餐搭配技术的关键在于，对美食商品的认知，而外卖美食知识图谱，则提供了最全面的数据基础。我们基于同商家内的商品信息和历史成单信息，对商品的搭配关系进行拟合，参考指针网络[2]等结构，构建了基于Multi-Head Attention[3]的Enc-Dec模型，具体的模型结构如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;① &lt;strong&gt;Encoder&lt;/strong&gt;：对商家菜单进行建模，因菜单为无序数据，因此采用Attention的方式进行建模。商品的信息主要包括商品名、商品图谱标签、交易统计数据等三部分。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;a. 对菜名、商品标签分别进行Self-Attention计算，得到菜名和商品标签对应的向量信息，然后与交易统计数据进行Concat，作为商品的初步表示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;b. 对商品的初步表示进行Self-Attention计算，以对同商家的商品有所感知。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;② &lt;strong&gt;Deocoder&lt;/strong&gt;：对搭配关系进行学习，基于当前已选择的商品，对下一个可能的搭配进行预估。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;a. 在搭配输出时，使用Beam-Search进行多种搭配结果的输出。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;b. 为了保证输出搭配中的商品的多样性，添加Coverage机制[2]。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;③ 训练之后，将Encoder部分分离，进行离线调度，可实现每天的向量产出。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;具体的模型结构如下图7所示：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5400763358778626&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hEx03cFgUsWfyMTop4riaWsUY4lToThggTgmyJRN64mCmrvv2t9eQEtNIWHOAic1M54VXh9ywTRxYow1MuaJe7Ww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;524&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图7 套餐搭配模型&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基于外卖美食知识图谱构建的套餐搭配模型，在多个入口（&lt;/span&gt;&lt;span&gt;“满减神器”、“对话点餐”、“菜品详情页”等&lt;/span&gt;&lt;span&gt;）取得转化的提升。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.2 交互式推荐&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过分析外卖用户的需求，发现用户存在跨店相似商品对比的需求，为打破商家界限的选购流程特点，提供便捷的跨店对比决策方式。交互式推荐，通过新的交互模式，打造推荐产品的突破点。在用户的交互过程中，根据用户的历史偏好、实时的点击行为，向用户推荐可能喜欢的美食商品。如下图8（&lt;/span&gt;&lt;span&gt;左&lt;/span&gt;&lt;span&gt;）所示，在向用户进行同类美食的推荐时，美食知识图谱中的标准菜品标签提供了主要的数据支撑。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.3 搜索&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;搜索作为外卖核心流量入口，承载了用户明确的外卖需求。用户通过输入关键词，进行菜品检索。在实际使用中，从搜索的关键词类型看，可能是某个具体的菜品，也可能是某种食材、某种菜系。在美食知识图谱中，图谱标签的高准确率和高覆盖，有助于提升搜索入口的用户体验，最新的实验也表明了这一点（新增部分食材、菜系、功效等标签，在搜索的线上实验效果正向）。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;521&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;384&quot; data-ratio=&quot;0.4769392033542977&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hEx03cFgUsWfyMTop4riaWsUY4lToThggrFLRicOaM8YIcXl5X1xrubVKGOwMCeDzzvNk9tJIdGe9fK58tricp6OQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;954&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;图8 交互式推荐和搜索&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5. 未来规划&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.1 场景化标签的挖掘&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;美食与我们的生活息息相关，美团外卖每天为千万用户提供美食方面的服务。然而，用户的需求是多种多样的，在不同的环境、不同的场景下，对美食的需求也不尽相同。目前美食知识图谱挖掘，在场景相关的标签较为缺失，例如某些节气、节日等图谱知识；特定天气情况下的图谱知识；特定人群（增肌人群、减肥人群）等的图谱知识。接下来我们会在场景化标签的挖掘方面进行探索。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在挖掘方法方面，目前的挖掘数据主要为文本信息。在商品图片、描述、结构化标签等信息的融合方面，挖掘不够深入，模型的效果也有待提升。因此在多模态识别模型方面，我们也会进行相应的探索。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.2 基于图谱的推荐技术研究&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;美团外卖在理解美食的基础上，向用户进行美食推荐，以更好地满足用户对美食的需求。外卖美食知识图谱和外卖业务数据，作为实现这一点的数据基础，包含上亿的节点信息和十几亿的关系数据。通过对用户的商品搜索、点击、购买等行为进行建模分析，可以更加贴合用户的需求，向用户进行商品推荐，例如，将美食知识图谱和外卖行为数据融合，以用户为起点，进行随机游走，向用户推荐相关的美食。在接下来的图谱应用方面的探索中，我们也会更加深入的探索基于美食知识图谱和用户行为的推荐技术。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6. 参考文献&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;[1] Kim Y. Convolutional neural networks for sentence classification[J]. arXiv preprint arXiv:1408.5882, 2014.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[2] See A, Liu P J, Manning C D. Get to the point: Summarization with pointer-generator networks[J]. arXiv preprint arXiv:1704.04368, 2017.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[3] Vaswani A, Shazeer N, Parmar N, et al. Attention is all you need[C]//Advances in neural information processing systems. 2017: 5998-6008.&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;[4] Hamilton W, Ying Z, Leskovec J. Inductive representation learning on large graphs[C]//Advances in Neural Information Processing Systems. 2017: 1024-1034.&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7. 作者简介&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;杨林、郭同、海超、懋地等，均来自美团外卖技术团队。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;阅读更多&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;---&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7r&quot; textvalue=&quot;前端&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;前端&lt;/a&gt;&lt;strong&gt;&lt;span&gt; |&lt;/span&gt;&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7v&quot; textvalue=&quot; 安全&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;strong&gt; &lt;/strong&gt; &lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jsdG&quot; textvalue=&quot;算法&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;算法&lt;/a&gt;&lt;strong&gt; |&lt;/strong&gt;&lt;span&gt; &lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jsWK&quot; textvalue=&quot;后端&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;后端&lt;/a&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt; | &lt;/span&gt;&lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jqRZ&quot; textvalue=&quot;数据&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;数据&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7v&quot; textvalue=&quot; 安全&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;安全&lt;/a&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jui4&quot; textvalue=&quot;Android&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;Android&lt;/a&gt;&lt;strong&gt; |&lt;/strong&gt; &lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jtXE&quot; textvalue=&quot;iOS&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;iOS&lt;/a&gt; &lt;strong&gt; |&lt;/strong&gt; &lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jo7K&quot; textvalue=&quot;运维&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;运维&lt;/a&gt;&lt;strong&gt; | &lt;/strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://t.1yb.co/jtsX&quot; textvalue=&quot;测试&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;测试&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>df1793dc53e7036978b253468089a201</guid>
<title>Linux 下的防火墙</title>
<link>https://toutiao.io/k/ygxad38</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content&quot;&gt;

&lt;p&gt;使用过Linux系统的人对iptables一定不陌生，它是Linux从2.4.x版本内核开始，系统自带的防火墙。如今Linux内核已经更新至5.11.x版本，Linux的防火墙在iptables基础上泛生出UFW和Firewalld，并且在一些发行版中已经替代iptables。&lt;/p&gt;



&lt;h3 id=&quot;netfilteriptables&quot;&gt;Netfilter/Iptables&lt;/h3&gt;



&lt;p&gt;Netfilter/Iptables 是Linux系统自带的防火墙，Iptables管理规则，Netfilter是规则的执行者，它们一起组成Linux下包过滤防火墙。&lt;/p&gt;



&lt;p&gt;iptables内置4个表，即filter表、nat表、mangle表和raw表，分别用于实现包过滤，网络地址转换、包重构(修改)和数据跟踪处理。每个表都会有相应的链。下图是iptables中的四表五链：&lt;/p&gt;







&lt;p&gt;链（chains）是数据包传播的路径。每一条链中可以有一条或多条规则，当一个数据包到达一个链时，iptables就会从链中第一条规则开始检查，看该数据包是否满足规则所定义的条件。如果满足，系统就会根据该条规则所定义的方法处理该数据包；否则iptables将继续检查下一条规则。如果该数据包不符合链中任一条规则，iptables就会根据该链预先定义的默认策略来处理数据包。&lt;/p&gt;







&lt;blockquote class=&quot;wp-block-quote&quot;&gt;&lt;p&gt;关于iptables的原理这篇文章讲得很清楚：&lt;a href=&quot;https://blog.csdn.net/tennysonsky/article/details/44596515&quot;&gt;https://blog.csdn.net/tennysonsky/article/details/44596515&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;



&lt;p&gt;在Linux中，可以使用如下命令启用或关闭iptables&lt;/p&gt;



&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code&gt;// 启动iptables
systemctl start iptables

// 停止iptables
systemctl stop iptables&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;以下是常用命令：&lt;/p&gt;



&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code&gt;// 列出 INPUT 表中规则
iptables -L INPUT

// 允许3306端口TCP协议访问
iptables -I INPUT -p tcp --dport 3306 -j ACCEPT

// 允许IP为xxx.xxx.xxx.xxx通过udp访问本地500端口
iptables -I INPUT -p udp --dport 500 -s xxx.xxx.xxx.xxx -j ACCEPT

// -I参数是将规则插入表开头，-A是把规则添加到表未尾，优先级最低，可做为默认规则
// 当不符合前面规则后拒绝所有请求
iptables -A INPUT -p tcp -j REJECT

// 删除INPUT表中第1条规则
iptables -D INPUT 1

// 清空规则列表
iptables -F&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;iptables还能做基于内核的包转发。关于iptables用法网上文章太多了，就不多写。&lt;/p&gt;



&lt;p&gt;需要注意的是，iptables规则虽然能即时生效，但并未保存。开机后会丢失。&lt;/p&gt;



&lt;p&gt;RedHat系执行保存：&lt;/p&gt;



&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code&gt;service iptables save&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;Debian系执行 iptables-save 列出所有规则，输出到文件中保存。系统启动时用 iptables-restore 恢复。&lt;/p&gt;



&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code&gt;// 保存
iptables-save &amp;gt; /etc/iptables.conf

// 恢复
iptables-restore &amp;lt; /etc/iptables.conf&lt;/code&gt;&lt;/pre&gt;



&lt;h3 id=&quot;ufw-和-firewalld&quot;&gt;UFW 和 Firewalld&lt;/h3&gt;



&lt;p&gt;iptables很强大也很复杂，于是便有UFW和Firewalld。它们的命令简单清晰很多，底层都是调用iptables。&lt;/p&gt;







&lt;p&gt;UFW是Ubuntu下防火墙：&lt;/p&gt;



&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code&gt;// 启动ufw
systemctl start ufw

// 停用ufw
systemctl stop ufw&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;以下是常用命令：&lt;/p&gt;



&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code&gt;// 查询ufw开启状态，打印规则
ufw status

// 允许80端口访问
ufw allow 80

// 拒绝8000端口访问
ufw deny 9000

// 拒绝ip为xxx.xxx.xxx.xxx访问
ufw deny from xxx.xxx.xxx.xxx

// 允许通过tcp协议，9000-9002访问
ufw allow 9000:9002/tcp

// 删除规则
ufw delete allow http&lt;/code&gt;&lt;/pre&gt;







&lt;p&gt;Firewalld是Fedora/CentOS 8之后版本自带的防火墙：&lt;/p&gt;



&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code&gt;// 启动firewalld
systemctl start firewalld

// 停用firewalld
systemctl stop firewalld&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;以下是常用命令：&lt;/p&gt;



&lt;pre class=&quot;wp-block-code&quot;&gt;&lt;code&gt;&lt;em&gt;// 允许tcp协议8161端口访问，--zone(作用域)，--permanent(永久生效)&lt;/em&gt;
firewall-cmd --zone=public --add-port=8161/tcp --permanent

&lt;em&gt;// 重新加载规则&lt;/em&gt;
firewall-cmd --reload

&lt;em&gt;// 将80端口的流量转发至8080&lt;/em&gt;
firewall-cmd --add-forward-port=port=80:proto=tcp:toport=8080

&lt;em&gt;// 将80端口的流量转发至192.168.0.1&lt;/em&gt;
firewall-cmd --add-forward-port=proto=80:proto=tcp:toaddr=192.168.1.0.1

&lt;em&gt;// 将80端口的流量转发至192.168.0.1的8080端口&lt;/em&gt;
firewall-cmd --add-forward-port=proto=80:proto=tcp:toaddr=192.168.0.1:toport=8080&lt;/code&gt;&lt;/pre&gt;



&lt;p&gt;Firewalld也有图形界面：&lt;/p&gt;




&lt;hr/&gt;&lt;/div&gt;

&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8092c1bfc734471485c44924167e95d0</guid>
<title>用 Kubernetes 搭建 Etcd 集群和 WebUI</title>
<link>https://toutiao.io/k/ehn7pjw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天用这篇文章带大家在自己的电脑上搭建一个Kubernetes Etcd集群，Kubernetes本身的功能就依赖Etcd实现，不过并不会开放给我们的程序使用，所以需要自己单独搭建。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Etcd现在是分布式服务架构中的重要组件，它由 CNCF 孵化托管， 在微服务和 Kubernates 集群中不仅可以作为服务注册与发现，还是一个用于配置共享的分布式键值存储，采用 raft 算法，实现分布式系统数据的可用性和一致性。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般用Go语言开发的gRPC服务会使用Etcd实现服务发现和注册。此外一些重要的配置也会存储在Etcd里通过让程序监听Key的变更来实现无需重启应用的配置更新。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于为什么要使用Etcd我们不做过多介绍，现在切入正题。安装Etcd的方式比较多，如果想直接把Etcd集群安装在机器上而不是Kubernetes里可以通过 &lt;code&gt;goreman&lt;/code&gt; 工具。不过因为我电脑上安装了Minikube，所以想尽量把所有东西都运行在Kubernetes里这样未来换电脑也就不用发愁需要安装那么多工具集了。除了演示在Kubernetes里安装运行Etcd集群外，还会安装一个Etcd的Web UI服务，让我们能够通过浏览器查询和设置Etcd的Key-Value，这个Etcd Web UI服务同样是运行在Kubernetes里，相信通过今天文章的学习你也一定感受到Kubernetes的便捷和学到不少知识。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;准备工作&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在开始跟着文章里的步骤安装Etcd前，需要先确保自己的电脑里安装了Minikube 这个单节点Kubernetes集群。我以前的文章里有详细介绍过安装步骤，我把他放在这里供大家参考。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247485235&amp;amp;idx=1&amp;amp;sn=0cdd31c25b13790b336e0a8222f00b64&amp;amp;chksm=fa80d6a4cdf75fb27a64c7f06f9a33ed4e644624d3fcf73d791274d03b071467ebb4e292ac95&amp;amp;token=1423297622&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Minikube-运行在笔记本上的Kubernetes集群&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Kubernetes 安装Etcd&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Kubernetes里安装Etcd的方法有两种，一种是原始的通过StatefulSet控制器，也就是有状态应用来编排Etcd的节点，这种需要配置Pod使用的镜像，配置文件和启动命令。通过无头服务，在集群内部为Pod提供名称到IP的映射，以及NodePort类型的服务向集群外暴露客户端端口。还有一种是使用coreos提供Etcd Operator直接安装，很多细节都为我们直接处理好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里我们使用第一种用StatefulSet创建Etcd节点和Service对外暴露客户端端口的安装方式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;Service 设置DNS和暴露端口&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们来创建为Etcd集群的Pod提供Pod名称到IP映射的无头服务。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;---&lt;/span&gt;&lt;br/&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;etcd&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;namespace:&lt;/span&gt; &lt;span&gt;etcd&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;annotations:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# Create endpoints also if the related pod isn&#x27;t ready&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;service.alpha.kubernetes.io/tolerate-unready-endpoints:&lt;/span&gt; &lt;span&gt;&quot;true&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;2379&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;client&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;2380&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;peer&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;clusterIP:&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;selector:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;component:&lt;/span&gt; &lt;span&gt;etcd&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里要创建的无头服务的名称是 etcd 。因为StatefulSet编排的Pod名称永远是PodName-序号，到时候集群内部各个Etcd节点配置的通信方式就可以用  &quot;PodName-序号.etcd:2380&quot; 这种形式来代替使用&quot;节点IP:2380&quot;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2380是Etcd服务端的端口，而对外提供服务的客户端端口是2379，因此还需要有一个NodePort类型的Service向集群外部暴露客户端对2379端口的访问。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;---&lt;/span&gt;&lt;br/&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;etcd-client&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;namespace:&lt;/span&gt; &lt;span&gt;etcd&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;http&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;nodePort:&lt;/span&gt; &lt;span&gt;30453&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;2379&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;targetPort:&lt;/span&gt; &lt;span&gt;2379&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;protocol:&lt;/span&gt; &lt;span&gt;TCP&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;type:&lt;/span&gt; &lt;span&gt;NodePort&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;selector:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;component:&lt;/span&gt; &lt;span&gt;etcd&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;创建这两个Service：kubectl apply -f resources/services.yml -n etcd&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于Kubernetes Service 和 StatefulSet 的作用原理、各种配置的详细解释可以参考我公众号里以前的文章：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247486082&amp;amp;idx=1&amp;amp;sn=42a9bc8fcfc9da09445e9e2f4cf2fb96&amp;amp;chksm=fa80db15cdf752039494992f71a3bc488cf386841bd1aaaa44115f5e7f155ba55ce468ec89ee&amp;amp;token=1423297622&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Kubernetes Service学习笔记和实践练习&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247486737&amp;amp;idx=1&amp;amp;sn=e7d0689fa74b108bae734515837c68e1&amp;amp;chksm=fa80dc86cdf755909f2f29ee8cb9dce930b95a837cb045be5c9700a9000743c9cb7f8eed6731&amp;amp;token=1423297622&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;深入理解StatefulSet，用Kubernetes编排有状态应用&lt;/a&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;配置Etcd节点Pod&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过StatefulSet编排创建3个Etcd节点的Pod，创建出来后上面的那两个Service会根据Pod的标签&lt;code&gt;component=etcd&lt;/code&gt;找到它们，把节点加入到自己的服务端点列表中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;---&lt;/span&gt;&lt;br/&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;apps/v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;StatefulSet&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;etcd&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;labels:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;component:&lt;/span&gt; &lt;span&gt;etcd&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;serviceName:&lt;/span&gt; &lt;span&gt;etcd&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;replicas:&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;selector:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;matchLabels:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;component:&lt;/span&gt; &lt;span&gt;etcd&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;template:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;etcd&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;labels:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;component:&lt;/span&gt; &lt;span&gt;etcd&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;volumes:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;etcd-storage&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;emptyDir:&lt;/span&gt; &lt;span&gt;{}&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;containers:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;etcd&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;image:&lt;/span&gt; &lt;span&gt;quay.io/coreos/etcd:latest&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;containerPort:&lt;/span&gt; &lt;span&gt;2379&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;client&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;containerPort:&lt;/span&gt; &lt;span&gt;2380&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;peer&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;volumeMounts:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;etcd-storage&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;mountPath:&lt;/span&gt; &lt;span&gt;/var/run/etcd/default.etcd&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pod的启动命令里要配置上每个节点点的IP和端口，上面说了无头服务的配置可以通过PodName-序号.etcd 的方式解析出IP，这里对应的就是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;etcd-0.etcd&lt;br/&gt;etcd-1.etcd&lt;br/&gt;etcd-2.etcd&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过为了灵活性，我参考了国外一位网友分享的方式通过启动时执行shell脚本的方式，动态根据Etcd集群节点数量来设置启动命令里的 PeersUrl等配置&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;          &lt;span&gt;env:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;CLUSTER_SIZE&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;value:&lt;/span&gt; &lt;span&gt;&quot;3&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;SET_NAME&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;value:&lt;/span&gt; &lt;span&gt;&quot;etcd&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;MINIKUBE_IP&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;value:&lt;/span&gt; &lt;span&gt;&quot;$MINIKUBE_IP&quot;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;MINIKUBE_PORT&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;value:&lt;/span&gt; &lt;span&gt;&quot;$MINIKUBE_PORT&quot;&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;command:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;/bin/sh&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;-ecx&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;|&lt;br/&gt;              IP=$(hostname -i)&lt;br/&gt;              PEERS=&quot;&quot;&lt;br/&gt;              for i in $(seq 0 $((${CLUSTER_SIZE} - 1))); do&lt;br/&gt;                  PEERS=&quot;${PEERS}${PEERS:+,}${SET_NAME}-${i}=http://${SET_NAME}-${i}.${SET_NAME}:2380&quot;&lt;br/&gt;              done&lt;br/&gt;              exec etcd --name ${HOSTNAME} \&lt;br/&gt;                --listen-peer-urls http://${IP}:2380 \&lt;br/&gt;                --listen-client-urls http://${IP}:2379,http://127.0.0.1:2379 \&lt;br/&gt;                --advertise-client-urls http://${HOSTNAME}.${SET_NAME}:2379,http://${MINIKUBE_IP}:${MINIKUBE_PORT} \&lt;br/&gt;                --initial-advertise-peer-urls http://${HOSTNAME}.${SET_NAME}:2380 \&lt;br/&gt;                --initial-cluster-token etcd-cluster-1 \&lt;br/&gt;                --initial-cluster ${PEERS} \&lt;br/&gt;                --initial-cluster-state new \&lt;br/&gt;                --data-dir /var/run/etcd/default.etcd&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;StatefulSet的创建命令为：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;cat&lt;/span&gt; &lt;span&gt;resources/etcd.yml.tmpl&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;resources/config.bash&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;kubectl&lt;/span&gt; &lt;span&gt;apply&lt;/span&gt; &lt;span&gt;-n&lt;/span&gt; &lt;span&gt;etcd&lt;/span&gt; &lt;span&gt;-f&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;提供了一个shell脚本来设置&lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;MINIKUBE_IP和&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; role=&quot;img&quot; focusable=&quot;false&quot; viewbox=&quot;0 -750 8468.7 950&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4D&quot; d=&quot;M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1051, 0)&quot;&gt;&lt;path data-c=&quot;49&quot; d=&quot;M43 1Q26 1 26 10Q26 12 29 24Q34 43 39 45Q42 46 54 46H60Q120 46 136 53Q137 53 138 54Q143 56 149 77T198 273Q210 318 216 344Q286 624 286 626Q284 630 284 631Q274 637 213 637H193Q184 643 189 662Q193 677 195 680T209 683H213Q285 681 359 681Q481 681 487 683H497Q504 676 504 672T501 655T494 639Q491 637 471 637Q440 637 407 634Q393 631 388 623Q381 609 337 432Q326 385 315 341Q245 65 245 59Q245 52 255 50T307 46H339Q345 38 345 37T342 19Q338 6 332 0H316Q279 2 179 2Q143 2 113 2T65 2T43 1Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1555, 0)&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2443, 0)&quot;&gt;&lt;path data-c=&quot;49&quot; d=&quot;M43 1Q26 1 26 10Q26 12 29 24Q34 43 39 45Q42 46 54 46H60Q120 46 136 53Q137 53 138 54Q143 56 149 77T198 273Q210 318 216 344Q286 624 286 626Q284 630 284 631Q274 637 213 637H193Q184 643 189 662Q193 677 195 680T209 683H213Q285 681 359 681Q481 681 487 683H497Q504 676 504 672T501 655T494 639Q491 637 471 637Q440 637 407 634Q393 631 388 623Q381 609 337 432Q326 385 315 341Q245 65 245 59Q245 52 255 50T307 46H339Q345 38 345 37T342 19Q338 6 332 0H316Q279 2 179 2Q143 2 113 2T65 2T43 1Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2947, 0)&quot;&gt;&lt;path data-c=&quot;4B&quot; d=&quot;M285 628Q285 635 228 637Q205 637 198 638T191 647Q191 649 193 661Q199 681 203 682Q205 683 214 683H219Q260 681 355 681Q389 681 418 681T463 682T483 682Q500 682 500 674Q500 669 497 660Q496 658 496 654T495 648T493 644T490 641T486 639T479 638T470 637T456 637Q416 636 405 634T387 623L306 305Q307 305 490 449T678 597Q692 611 692 620Q692 635 667 637Q651 637 651 648Q651 650 654 662T659 677Q662 682 676 682Q680 682 711 681T791 680Q814 680 839 681T869 682Q889 682 889 672Q889 650 881 642Q878 637 862 637Q787 632 726 586Q710 576 656 534T556 455L509 418L518 396Q527 374 546 329T581 244Q656 67 661 61Q663 59 666 57Q680 47 717 46H738Q744 38 744 37T741 19Q737 6 731 0H720Q680 3 625 3Q503 3 488 0H478Q472 6 472 9T474 27Q478 40 480 43T491 46H494Q544 46 544 71Q544 75 517 141T485 216L427 354L359 301L291 248L268 155Q245 63 245 58Q245 51 253 49T303 46H334Q340 37 340 35Q340 19 333 5Q328 0 317 0Q314 0 280 1T180 2Q118 2 85 2T49 1Q31 1 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3836, 0)&quot;&gt;&lt;path data-c=&quot;55&quot; d=&quot;M107 637Q73 637 71 641Q70 643 70 649Q70 673 81 682Q83 683 98 683Q139 681 234 681Q268 681 297 681T342 682T362 682Q378 682 378 672Q378 670 376 658Q371 641 366 638H364Q362 638 359 638T352 638T343 637T334 637Q295 636 284 634T266 623Q265 621 238 518T184 302T154 169Q152 155 152 140Q152 86 183 55T269 24Q336 24 403 69T501 205L552 406Q599 598 599 606Q599 633 535 637Q511 637 511 648Q511 650 513 660Q517 676 519 679T529 683Q532 683 561 682T645 680Q696 680 723 681T752 682Q767 682 767 672Q767 650 759 642Q756 637 737 637Q666 633 648 597Q646 592 598 404Q557 235 548 205Q515 105 433 42T263 -22Q171 -22 116 34T60 167V183Q60 201 115 421Q164 622 164 628Q164 635 107 637Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(4603, 0)&quot;&gt;&lt;path data-c=&quot;42&quot; d=&quot;M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;msub&quot; transform=&quot;translate(5362, 0)&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;45&quot; d=&quot;M492 213Q472 213 472 226Q472 230 477 250T482 285Q482 316 461 323T364 330H312Q311 328 277 192T243 52Q243 48 254 48T334 46Q428 46 458 48T518 61Q567 77 599 117T670 248Q680 270 683 272Q690 274 698 274Q718 274 718 261Q613 7 608 2Q605 0 322 0H133Q31 0 31 11Q31 13 34 25Q38 41 42 43T65 46Q92 46 125 49Q139 52 144 61Q146 66 215 342T285 622Q285 629 281 629Q273 632 228 634H197Q191 640 191 642T193 659Q197 676 203 680H757Q764 676 764 669Q764 664 751 557T737 447Q735 440 717 440H705Q698 445 698 453L701 476Q704 500 704 528Q704 558 697 578T678 609T643 625T596 632T532 634H485Q397 633 392 631Q388 629 386 622Q385 619 355 499T324 377Q347 376 372 376H398Q464 376 489 391T534 472Q538 488 540 490T557 493Q562 493 565 493T570 492T572 491T574 487T577 483L544 351Q511 218 508 216Q505 213 492 213Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(738, -150) scale(0.707)&quot;&gt;&lt;path data-c=&quot;49&quot; d=&quot;M43 1Q26 1 26 10Q26 12 29 24Q34 43 39 45Q42 46 54 46H60Q120 46 136 53Q137 53 138 54Q143 56 149 77T198 273Q210 318 216 344Q286 624 286 626Q284 630 284 631Q274 637 213 637H193Q184 643 189 662Q193 677 195 680T209 683H213Q285 681 359 681Q481 681 487 683H497Q504 676 504 672T501 655T494 639Q491 637 471 637Q440 637 407 634Q393 631 388 623Q381 609 337 432Q326 385 315 341Q245 65 245 59Q245 52 255 50T307 46H339Q345 38 345 37T342 19Q338 6 332 0H316Q279 2 179 2Q143 2 113 2T65 2T43 1Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(6506.4, 0)&quot;&gt;&lt;path data-c=&quot;50&quot; d=&quot;M287 628Q287 635 230 637Q206 637 199 638T192 648Q192 649 194 659Q200 679 203 681T397 683Q587 682 600 680Q664 669 707 631T751 530Q751 453 685 389Q616 321 507 303Q500 302 402 301H307L277 182Q247 66 247 59Q247 55 248 54T255 50T272 48T305 46H336Q342 37 342 35Q342 19 335 5Q330 0 319 0Q316 0 282 1T182 2Q120 2 87 2T51 1Q33 1 33 11Q33 13 36 25Q40 41 44 43T67 46Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628ZM645 554Q645 567 643 575T634 597T609 619T560 635Q553 636 480 637Q463 637 445 637T416 636T404 636Q391 635 386 627Q384 621 367 550T332 412T314 344Q314 342 395 342H407H430Q542 342 590 392Q617 419 631 471T645 554Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(7535.2, 0)&quot;&gt;&lt;text data-variant=&quot;normal&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot; font-size=&quot;933.8px&quot; font-family=&quot;serif&quot;&gt;和&lt;/text&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;MINIKUBE_PORT 这两个在容器里无法获得的环境变量。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建Etcd集群所使用的 yaml 资源声明文件和具体的操作步骤都已经放到了Github上，大家可以按照里面的命令进行操作。链接地址：https://github.com/kevinyan815/LearningKubernetes/tree/master/etcd&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;测试安装成果&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试安装是否成功也简单，观测Pod在Kubernetes里都正常启动起来后我们往Etcd里 set 一个键值，看能不能再查询出来就行了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2263888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f7zouSianPhKLrYbP4VQuZXRiaRzzWBfZyZcYnwfXS88diauj6hEnqC1GdgcTO6ouNiauiauFe5iaDRD7uQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1440&quot;/&gt;&lt;figcaption&gt;用etcdctl 测试成果&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们在说说怎么给Etcd做个Web UI，毕竟一些为应用程序预准备的配置如果要用命令行一条条 set 进去的话也太麻烦了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;给Etcd集群做个Web UI&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;做这个Web UI，说来话长，花的时间比上面搭建Etcd集群多多了，大概花了两三天反复尝试才搞定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Web UI我使用了 e3w 这个项目&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;项目地址：https://github.com/soyking/e3w&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原本这个项目是有提供docker镜像和docker-compose容器编排运行的，不过我实在不想再在我电脑上安装这么多工具集了就一直想把它改造成能在 Kubernetes 里运行的方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看了下这个项目的源码，启动的时候会去读取 &lt;code&gt;/app/conf&lt;/code&gt;  目录下的&lt;code&gt;config.default.ini&lt;/code&gt; 配置文件，WebUI服务的端口号默认配置的是8080，有了这两个信息后我们就可以通过Deployment创建Pod来放置Web UI服务，通过Service暴露Web UI服务供集群外部访问的端口了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;---&lt;/span&gt;&lt;br/&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;apps/v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Deployment&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;e3w-deployment&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;namespace:&lt;/span&gt; &lt;span&gt;etcd&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;labels:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;app:&lt;/span&gt; &lt;span&gt;e3w&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;replicas:&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;selector:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;matchLabels:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;app:&lt;/span&gt; &lt;span&gt;etcd-client-e3w&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;template:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;labels:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;app:&lt;/span&gt; &lt;span&gt;etcd-client-e3w&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;containers:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;e3w-app-container&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;image:&lt;/span&gt; &lt;span&gt;soyking/e3w:latest&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;e3w-server-port&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;containerPort:&lt;/span&gt; &lt;span&gt;8080&lt;/span&gt;&lt;br/&gt;&lt;span&gt;---&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;e3w-service&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;namespace:&lt;/span&gt; &lt;span&gt;etcd&lt;/span&gt;&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;type:&lt;/span&gt; &lt;span&gt;NodePort&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;selector:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;app:&lt;/span&gt; &lt;span&gt;etcd-client-e3w&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;-&lt;/span&gt; &lt;span&gt;protocol:&lt;/span&gt; &lt;span&gt;TCP&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;targetPort:&lt;/span&gt; &lt;span&gt;e3w-server-port&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;nodePort:&lt;/span&gt; &lt;span&gt;30081&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;80&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于配置文件，我的设想是把配置放到ConfigMap里，再把ConfigMap里的配置项作为文件挂载在原来配置文件的路径上。这样做的好处有两个：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不需要单独在机器上创建一个具体路径的配置文件，减少了Pod对宿主机上hostPath的依赖。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不需要按照e3w项目里推荐的自定义方式那样修改项目里的配置文件重新打Docker镜像才能连接上自己的Etcd集群。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面 ConfigMap 里的 e3w-config.default.ini 就是我们要作为文件挂载到容器里的配置项。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;apiVersion:&lt;/span&gt; &lt;span&gt;v1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;kind:&lt;/span&gt; &lt;span&gt;ConfigMap&lt;/span&gt;&lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;e3w-configmap&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;namespace:&lt;/span&gt; &lt;span&gt;etcd&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;labels:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;config:&lt;/span&gt; &lt;span&gt;e3w.ini&lt;/span&gt;&lt;br/&gt;&lt;span&gt;data:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;e3w-config.default.ini:&lt;/span&gt; &lt;span&gt;|&lt;br/&gt;    [app]&lt;br/&gt;    port=8080&lt;br/&gt;    auth=false&lt;br/&gt;    [etcd]&lt;br/&gt;    root_key=root&lt;br/&gt;    dir_value=&lt;br/&gt;    addr=etcd-0.etcd.etcd.svc.cluster.local:2379,etcd-1.etcd.etcd.svc.cluster.local:2379,etcd-2.etcd.etcd.svc.cluster.local:2379&lt;br/&gt;    username=&lt;br/&gt;    password=&lt;br/&gt;    cert_file=&lt;br/&gt;    key_file=&lt;br/&gt;    ca_file=&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，在这一步上实属费了不少时间，主要是把 ConfigMap 的一个配置项作为文件挂载到容器里除了需要在 volumeMounts.MountPath 上配置完整的目录和文件名外还需要用上 subPath 这个配置。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;    &lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;containers:&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;volumeMounts:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;e3w-configmap-volume&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;mountPath:&lt;/span&gt; &lt;span&gt;/app/conf/config.default.ini&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;subPath:&lt;/span&gt; &lt;span&gt;config.default.ini&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;volumes:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;-&lt;/span&gt; &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;e3w-configmap-volume&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;configMap:&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;name:&lt;/span&gt; &lt;span&gt;e3w-configmap&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;items:&lt;/span&gt;&lt;br/&gt;              &lt;span&gt;-&lt;/span&gt; &lt;span&gt;key:&lt;/span&gt; &lt;span&gt;e3w-config.default.ini&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;path:&lt;/span&gt; &lt;span&gt;config.default.ini&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这又是一个小知识点，关于Volume挂载时 subPath 的应用场景等后面再说（大家想听的话下篇就安排，记得点赞啊）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置文件搞定后，再看一下Pod运行的状态，就不再是Error了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.20634920634920634&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f7zouSianPhKLrYbP4VQuZXR8INJ1nTK8rUiahJxI8hyZI0LkBUVIKhRfKf79Q9TucWc2fvibpl8wbhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1386&quot;/&gt;&lt;figcaption&gt;Etcd &amp;amp; WebUI Pod&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面创建的Etcd集群里的三个基点和e3w的WebUI服务都能正常运行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过WebUI我们可以查看Etcd集群的运行状态&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5961145194274029&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f7zouSianPhKLrYbP4VQuZXRBZVVAo8DAyRCxdmnVErPaibWRVCzCnAnhS7VKC7BeeAn7wIKppumSiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1956&quot;/&gt;&lt;figcaption&gt;节点状态界面&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以及更方便地通过UI界面管理Key-Value：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4099616858237548&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f7zouSianPhKLrYbP4VQuZXRjlWicMWrk4H8P5wUB8j9mDHeQXksXRMIjEMtpuIKws2nC2h4Vl9rhAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2088&quot;/&gt;&lt;figcaption&gt;键值管理界面&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体上感觉这个Web UI服务体验上还不错，很多功能都有。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Etcd Web UI服务的 yaml 定义文件我也放到了GitHub上，链接地址：https://github.com/kevinyan815/LearningKubernetes/tree/master/e3w&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天的文章，感觉前面安装Etcd集群的内容没有什么新鲜的知识，都是以前讲过的知识点的实际应用。在介绍安装Etcd Web UI服务时倒是用到了两个新的知识点，我们通过将 configMap 的某一个配置项作为配置文件挂载到容器里的方式既避免了修改 e3w 项目源代代码重新打Docker镜像，也避免了在宿主机上单独管理配置文件的麻烦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了今天文章的内容就这么多，求关注，求三连，下期再见吧。拜拜～&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUzNTY5MzU2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f4pGhLz2xEbRFHnAQon2QLYgbBibCJo1ibJHesLWshPJeRibateRtAqkaf6BgjlbhYiaxHLq6Zu07CRPw/0?wx_fmt=png&quot; data-nickname=&quot;网管叨bi叨&quot; data-alias=&quot;kevin_tech&quot; data-signature=&quot;每周分享技术类原创文章&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>