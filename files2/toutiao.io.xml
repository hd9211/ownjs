<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b93b512443ed8f91b10007c6fa41f47e</guid>
<title>秋天的第一份 IT 技术周刊 | 码农周刊第 320 期</title>
<link>https://toutiao.io/k/9ew44gv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;秋天的第一份 IT 技术周刊 | 码农周刊第 320 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第320期（2020-09-29）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3200&quot; target=&quot;_blank&quot;&gt;秋天的第一份 IT 技术周刊，请查收！&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3200&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_320.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;思考和实践&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;由 JavaScript 之父 Brendan Eich 与 ES6 规范首席作者 Allen Wirfs-Brock 联合编写，详细记载和解读了自 1995 年语言诞生到 2015 年 ES6 规范制定为止，共计 20 年的 JavaScript 语言演化经历。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;支持 mp4, flv, m3u8 及 rtmp 协议的直播，支持移动端，PC 端。&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;利器&lt;/p&gt;
        
        &lt;p&gt;实打实的干货&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;容易踩的坑&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;细致分析&lt;/p&gt;
        
        &lt;p&gt;方案和思路&lt;/p&gt;
        
        &lt;p&gt;一些实践和工具&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;报告详情&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;深入探讨&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;java相关技术分享&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 444692 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 444414 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 435415 即可&lt;/p&gt;
        
        &lt;p&gt;不定期更新一些机器学习算法，方便大家浏览，然后一起学习，一起进步&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 104739 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 99181 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;本书深入地讲解了 Go 语言常见特性的内部机制和实现方式，大部分内容源自对 Go 语言源码的分析，并从中提炼出实现原理。欢迎到&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;兑换阅读。&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;值得推荐&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;无代码开发平台&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8afa87ddeecb052b13f84d0492e0bd62</guid>
<title>Java 的强引用、软引用、弱引用、虚引用</title>
<link>https://toutiao.io/k/aqeo426</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;工程中用到guava的本地缓存。它底层实现和API接口上使用了强引用、软引用、弱引用。所以温故知新下，也夯实下基础。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;预备知识&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;先来看下GC日志每个字段的含义&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Young GC示例解释&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;[GC (Allocation Failure) [PSYoungGen: 273405K-&amp;gt;20968K(278016K)] 480289K-&amp;gt;473619K(737792K), 0.1090103 secs] [Times: user=0.19 sys=0.27, real=0.11 secs] &lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;解释&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;[GC(产生GC的原因，例子中是由于分配内存失败)  [PSYoungGen: 年轻代回收前空间-&amp;gt;年轻代回收后空间(年轻代总空间)] 堆区的回收前空间-&amp;gt;堆区的回收后空间(堆区的总空间), GC耗时] [Times: 用户空间耗时 系统空间耗时, 实际耗时]&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Full GC示例解释 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;[Full GC (Ergonomics) [PSYoungGen: 20968K-&amp;gt;20805K(278016K)] [ParOldGen: 452651K-&amp;gt;451654K(864256K)] 473619K-&amp;gt;472460K(1142272K), [Metaspace: 5793K-&amp;gt;5793K(1056768K)], 0.1565987 secs] [Times: user=0.70 sys=0.00, real=0.16 secs] &lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;解释&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;[Full GC (产生GC原因，例子中是由于要放入老年代的对象超过了老年代的剩余空间) [PSYoungGen: -&amp;gt;年轻代回收前空间-&amp;gt;年轻代回收后空间(年轻代总空间)] [ParOldGen: 老年代回收前空间-&amp;gt;老年代回收后空间(老年代总空间)] 堆区的回收前空间-&amp;gt;堆区的回收后空间(堆区的总空间), [Metaspace: 元空间的回收前空间-&amp;gt;元空间的回收后空间(元空间的总空间)],  GC耗时] [Times: 用户空间耗时 系统空间耗时, 实际耗时]&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;创建一个10M的大对象，重写finalize方法。&lt;span&gt;finalize()方法会在对象被回收前调用&lt;/span&gt;，一个对象只有一次被调用的机会。对象可以在这个方法里进行自救，逃过被垃圾回收。Java设计这个方法可以被覆写是为了让有些对象在回收前做一些检查，完成一些前置条件再被垃圾回收。正式代码不建议使用。因为是测试，所以为了验证效果，这里打印GC日志信息。&lt;/p&gt;&lt;pre&gt;   &lt;span&gt;byte&lt;/span&gt;[] &lt;span&gt;bytes &lt;/span&gt;= &lt;span&gt;new byte&lt;/span&gt;[&lt;span&gt;10 &lt;/span&gt;* &lt;span&gt;1024 &lt;/span&gt;* &lt;span&gt;1024&lt;/span&gt;]&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    int &lt;/span&gt;&lt;span&gt;index&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    public &lt;/span&gt;&lt;span&gt;Ref&lt;/span&gt;(&lt;span&gt;int &lt;/span&gt;index) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.&lt;span&gt;index &lt;/span&gt;= index&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public byte&lt;/span&gt;[] &lt;span&gt;getBytes&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return &lt;/span&gt;&lt;span&gt;bytes&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;public void &lt;/span&gt;&lt;span&gt;finalize&lt;/span&gt;() {&lt;br/&gt;        System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;index &quot; &lt;/span&gt;+ &lt;span&gt;index &lt;/span&gt;+ &lt;span&gt;&quot;&#x27;s &quot; &lt;/span&gt;+ &lt;span&gt;bytes&lt;/span&gt;.&lt;span&gt;length &lt;/span&gt;+ &lt;span&gt;&quot;is going to be GG&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了测试，JVM参数统一为-Xms20M -XX:+PrintGCDetails。Xms20M表示堆内存设置最大为20M，-XX:+PrintGCDetails代表打印详细的GC信息。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.27121212121212124&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8BX6jNE4EIJlWcdOVshEOc4PO0LwuH19d9VRabzeL6524srlElTlES8uDQH38tOteHO38ZRd7qMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;660&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;强引用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;先来做个实验(代码已经上传github:https://github.com/xiexiaojing/yuna)&lt;/p&gt;&lt;pre&gt;&lt;span&gt;@Test&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public void  &lt;/span&gt;&lt;span&gt;testRawStrong&lt;/span&gt;() {&lt;br/&gt;    List&amp;lt;Ref&amp;gt; list = Lists.&lt;span&gt;newArrayList&lt;/span&gt;()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    for&lt;/span&gt;(&lt;span&gt;int &lt;/span&gt;i=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i&amp;lt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i++) {&lt;br/&gt;        list.add(&lt;span&gt;new &lt;/span&gt;Ref(i))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(list.get(i))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;这段代码由上线的设置可知，由于最大设置20M堆空间，所以很快触发了GC。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5420560747663551&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8BX6jNE4EIJlWcdOVshEOcys5BbW6mNf2VM22RNpUzhicQH4dc5rl1f7vhszq5T6FibEKdNv8FWySQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1498&quot;/&gt;&lt;/p&gt;&lt;p&gt;不过Xmx这个值是建议内存最大使用值。如果内存使用超过这个值，jvm认为还有内存可以使用，也会将对象一直往堆里面放。所以2次GC之后JVM自动扩容了，之后就不再频繁GC。最终用到了满足程序需要的内存。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.29752770673486784&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8BX6jNE4EIJlWcdOVshEOcFVl5HYPNDRe5Z2LLoUnLCwXxxWibdNp5XVRBVO9q7j7EPM12iay0vXpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1173&quot;/&gt;&lt;/p&gt;&lt;p&gt;强引用是直接new出来调用的对象，大家都知道。由上面实验可知，在系统内存很富裕的情况下，因为强引用内存不能被释放，所以会多申请了很多内存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;软引用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;软引用会&lt;span&gt;在系统将要发生内存溢出异常之前，将会把这些软引用对象列进回收范围进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用实验说明一下，为了防止JVM自动调整堆大小，我们把堆设置-Xmx200M。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;span&gt;@Test&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public void  &lt;/span&gt;&lt;span&gt;testRawSoft&lt;/span&gt;() {&lt;br/&gt;    List&amp;lt;SoftReference&amp;lt;Ref&amp;gt;&amp;gt; list = Lists.&lt;span&gt;newArrayList&lt;/span&gt;()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    for&lt;/span&gt;(&lt;span&gt;int &lt;/span&gt;i=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i&amp;lt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i++) {&lt;br/&gt;        list.add(&lt;span&gt;new &lt;/span&gt;SoftReference&amp;lt;&amp;gt;(&lt;span&gt;new &lt;/span&gt;Ref(i)))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(list.get(i).get())&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从下面实验结果可以看到数次的 GC之后，内存要撑不住的时候，Ref的软引用对象触发了finalize方法。这意味着它将要被内存回收了。说明GC会引发软引用里对象的内存回收，即使这个软引用本身还被强引用(list调用)着。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5596885813148789&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9Mq8jxswkOiaGFdC9LKfBgEMBWMeuicibVAaxgveYtHbpy4yludiasSxia4h5dKBlhZSqOhiconCqhJ7OA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1156&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终回收了这些内存也不能避免OOM的结局：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.659963436928702&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9Mq8jxswkOiaGFdC9LKfBgEHjg7CTT4wcEv5zBAGPqYY87gDamQhFk6S7VlcJt2tDcCuRMiaVibG6AQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1094&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;因为软引用通常情况下就是这样，只有内存马上要溢出了才触发它的GC。就好像扁鹊见蔡桓公的时候，蔡桓公的病已经很深了，马上就没救了。所以有了下面弱引用的方法：有病早治。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;弱引用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;弱引用是发生了一次垃圾回收后，既存的弱引用对象就开始回收。通常，一个弱引用对象仅能生存到下一次垃圾回收前。&lt;/p&gt;&lt;p&gt;用实验说明一下，为了防止JVM自动调整堆大小，我们把堆设置-Xmx200M。&lt;/p&gt;&lt;pre&gt;&lt;span&gt;@Test&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public void  &lt;/span&gt;&lt;span&gt;testRawWeak&lt;/span&gt;() {&lt;br/&gt;    List&amp;lt;WeakReference&amp;lt;Ref&amp;gt;&amp;gt; list = Lists.&lt;span&gt;newArrayList&lt;/span&gt;()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    for&lt;/span&gt;(&lt;span&gt;int &lt;/span&gt;i=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i&amp;lt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i++) {&lt;br/&gt;        list.add(&lt;span&gt;new &lt;/span&gt;WeakReference&amp;lt;&amp;gt;(&lt;span&gt;new &lt;/span&gt;Ref(i)))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(list.get(i).get())&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从下面的实验结果可知在发生了一次GC之后，已经生成的软引用对象都都回收了。下一次GC，这中间产生的软引用对象也都被回收了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.37986577181208053&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9Mq8jxswkOiaGFdC9LKfBgE7XjK6eOTQ3rD47hPAKia413gCBhO1HibM9hxibRl5xVnnxQZ985yheZdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1490&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;最终，由于GC及时，整个过程没有爆发OOM，平安的结束了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5738893925657298&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9Mq8jxswkOiaGFdC9LKfBgErrPAZvnTjcGufVGOl1RV3pxGMuXtHBbeOaYzOrZnpB2vshAe01Zttg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1103&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;虚引用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;虚引用也叫幻影引用。任何时候可能被GC回收，就像没有引用一样。&lt;/p&gt;&lt;p&gt;并且他必须和引用队列一起使用，用于跟踪垃圾回收过程，当垃圾回收器回收一个持有虚引用的对象时，在回收对象后，将这个虚引用对象加入到引用队列中，用来通知应用程序垃圾的回收情况。&lt;/p&gt;&lt;p&gt;&lt;span&gt;先来实验一下，从下面结果可看到从一开始取出来就是空对象，基本上刚创建出来就被回收了。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0977835723598435&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8BX6jNE4EIJlWcdOVshEOcwiaeLBciagSbORicnAYC2pvg6AVftA7aKpyjFK36AK8rQ1ibgUIFadbTgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;767&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;一个像是从来没有存在过的幻影有什么用呢？Java的Unsafe类和NIO都可以直接访问堆外内存。堆外内存GC管不了，这时候虚引用就排上用场了。我们可以通过引用队列跟踪垃圾回收，做好善后。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;在Guava中使用强软弱引用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;span&gt;@Test&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public void &lt;/span&gt;&lt;span&gt;testStrong&lt;/span&gt;() {&lt;br/&gt;    Cache&amp;lt;Integer&lt;span&gt;, &lt;/span&gt;Ref&amp;gt; cache = CacheBuilder.&lt;span&gt;newBuilder&lt;/span&gt;().expireAfterAccess(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;TimeUnit.&lt;span&gt;DAYS&lt;/span&gt;).build()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    for&lt;/span&gt;(&lt;span&gt;int &lt;/span&gt;i=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i&amp;lt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i++) {&lt;br/&gt;        cache.put(i&lt;span&gt;, new &lt;/span&gt;Ref(i))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(cache.getIfPresent(i))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;    System.&lt;span&gt;out&lt;/span&gt;.println(cache.stats().loadSuccessCount())&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Test&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public void &lt;/span&gt;&lt;span&gt;testSoft&lt;/span&gt;() {&lt;br/&gt;    Cache&amp;lt;Integer&lt;span&gt;, &lt;/span&gt;Ref&amp;gt; cache = CacheBuilder.&lt;span&gt;newBuilder&lt;/span&gt;().softValues().build()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    for&lt;/span&gt;(&lt;span&gt;int &lt;/span&gt;i=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i&amp;lt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i++) {&lt;br/&gt;        cache.put(i&lt;span&gt;, new &lt;/span&gt;Ref(i))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(cache.getIfPresent(i))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Test&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public void &lt;/span&gt;&lt;span&gt;testWeak&lt;/span&gt;() {&lt;br/&gt;    Cache&amp;lt;Integer&lt;span&gt;, &lt;/span&gt;Ref&amp;gt; cache = CacheBuilder.&lt;span&gt;newBuilder&lt;/span&gt;().weakKeys().weakValues().build()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    for&lt;/span&gt;(&lt;span&gt;int &lt;/span&gt;i=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i&amp;lt;&lt;span&gt;100&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i++) {&lt;br/&gt;        cache.put(i&lt;span&gt;, new &lt;/span&gt;Ref(i))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(cache.getIfPresent(i))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Guava在没有显示设置强、软、弱引用的情况下默认是强引用。这个结论我没有看任何书，而是通过跟踪源码，debug得到的结论。当显示设置为软引用或者弱引用时，运行时GC触发和对象回收之间的关系和自己手动直接测试的结果是一样的，大家可以动手实践下。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Java的强软弱虚引用被回收的时机不同：强引用是引用被释放才会回收；软引用是没释放，但是快OOM了就会被回收；弱引用是引用没释放，但是发生了GC后就会被回收；虚引用随时会回收，好像没有存在过，但是会有一个队列来跟踪它的垃圾回收情况。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;相关阅读&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>75aed32f35935926e4bf5255fd01bc7a</guid>
<title>[译] GraphQL 初体验，Node.js 构建 GraphQL API 指南</title>
<link>https://toutiao.io/k/kovcdmb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;299&quot; data-ratio=&quot;0.5009765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AOPiaqWez1sKrh7Hffjoia7y8nrFicmqjPJjviabZLNoR1SvrQW94a1OJHxqXibkWaXKVfiaSdvTbj61IIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来源：https://blog.heroku.com，作者：CHRIS CASTLE&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在过去的几年中，&lt;span&gt;GraphQL[1]&lt;/span&gt;已经成为一种非常流行的API规范，该规范专注于使客户端（无论客户端是前端还是第三方）的数据获取更加容易。&lt;/span&gt;&lt;/section&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;目录：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;为什么选择GraphQL？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;定义一个GraphQL schema&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;设置解析器&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;运行服务器&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;性能考量&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Schema最佳实践&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;GraphQL什么时候不合适？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;了解更多&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;section&gt;&lt;span&gt;在传统的基于REST的API方法中，客户端发出请求，而服务器决定响应：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;curl https:&lt;span&gt;//api.heroku.space/users/1&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;id&quot;&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;Luke&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;email&quot;&lt;/span&gt;: &lt;span&gt;&quot;luke@heroku.space&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;addresses&quot;&lt;/span&gt;: [&lt;br/&gt;    {&lt;br/&gt;    &lt;span&gt;&quot;street&quot;&lt;/span&gt;: &lt;span&gt;&quot;1234 Rodeo Drive&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;city&quot;&lt;/span&gt;: &lt;span&gt;&quot;Los Angeles&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;country&quot;&lt;/span&gt;: &lt;span&gt;&quot;USA&quot;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  ]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;但是，在GraphQL中，客户端可以精确地确定其从服务器获取的数据。例如，客户端可能只需要用户名和电子邮件，而不需要任何地址信息：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;curl -X POST https:&lt;span&gt;//api.heroku.space/graphql -d &#x27;&lt;/span&gt;&lt;br/&gt;query {&lt;br/&gt;  user(id: &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;    name&lt;br/&gt;    email&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;data&quot;&lt;/span&gt;:&lt;br/&gt;    {&lt;br/&gt;    &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;Luke&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;email&quot;&lt;/span&gt;: &lt;span&gt;&quot;luke@heroku.space&quot;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;通过这种新的模式，客户可以通过缩减响应来满足他们的需求，从而向服务器进行更高效的查询。对于单页应用(SPA)或其他前端重度客户端应用，可以通过减少有效载荷大小来加快渲染时间。但是，与任何框架或语言一样，GraphQL也需要权衡取舍。在本文中，我们将探讨使用GraphQL作为API的查询语言的利弊，以及如何开始构建实现。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;为什么选择GraphQL？&lt;/h2&gt;&lt;section&gt;&lt;span&gt;与任何技术决策一样，了解GraphQL为你的项目提供了哪些优势是很重要的，而不是简单地因为它是一个流行词而选择它。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;考虑一个使用API连接到远程数据库的SaaS应用程序。你想要呈现用户的个人资料页面，你可能需要进行一次API &lt;/span&gt;&lt;code&gt;&lt;span&gt;GET&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 调用，以获取有关用户的信息，例如用户名或电子邮件。然后，你可能需要进行另一个API调用以获取有关地址的信息，该信息存储在另一个表中。随着应用程序的发展，由于其构建方式的原因，你可能需要继续对不同位置进行更多的API调用。虽然每一个API调用都可以异步完成，但你也必须处理它们的响应，无论是错误、网络超时，甚至暂停页面渲染，直到收到所有数据。如上所述，这些响应的有效载荷可能超过了渲染你当前页面的需要，而且每个API调用都有网络延迟，总的延迟加起来可能很可观。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用GraphQL，你无需进行多个API调用（例如 &lt;/span&gt;&lt;code&gt;&lt;span&gt;GET /user/:id&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;GET /user/:id/addresses&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ），而是进行一次API调用并将查询提交到单个端点：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;query {&lt;br/&gt;  user(id: &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;    name&lt;br/&gt;    email&lt;br/&gt;    addresses {&lt;br/&gt;    street&lt;br/&gt;    city&lt;br/&gt;    country&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;然后，GraphQL仅提供一个端点来查询所需的所有域逻辑。如果你的应用程序不断增长，你会发现自己在你的架构中添加了更多的数据存储——PostgreSQL可能是存储用户信息的好地方，而Redis可能是存储其他种类信息的好地方——对GraphQL端点的一次调用将解决所有这些不同的位置，并以他们所请求的数据响应客户端。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你不确定应用程序的需求以及将来如何存储数据，则GraphQL在这里也很有用。要修改查询，你只需添加所需字段的名称：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    addresses {&lt;br/&gt;      street&lt;br/&gt;+     apartmentNumber   # new information&lt;br/&gt;      city&lt;br/&gt;      country&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这极大地简化了随着时间的推移而发展你的应用程序的过程。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;定义一个GraphQL schema&lt;/h2&gt;&lt;section&gt;&lt;span&gt;有各种编程语言的GraphQL服务器实现，但在你开始之前，你需要识别你的业务域中的对象，就像任何API一样。就像REST API可能会使用JSON模式一样，GraphQL使用SDL或Schema定义语言来定义它的模式，这是一种描述GraphQL API可用的所有对象和字段的幂等方式。SDL条目的一般格式如下：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; $OBJECT_TYPE {&lt;br/&gt;  $FIELD_NAME($ARGUMENTS): $FIELD_TYPE&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;让我们以前面的例子为基础，定义一下user和address的条目是什么样子的。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; User {&lt;br/&gt;  name:     &lt;span&gt;String&lt;/span&gt;&lt;br/&gt;  email:    &lt;span&gt;String&lt;/span&gt;&lt;br/&gt;  addresses:   [Address]&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Address {&lt;br/&gt;  street:   &lt;span&gt;String&lt;/span&gt;&lt;br/&gt;  city:     &lt;span&gt;String&lt;/span&gt;&lt;br/&gt;  country:  &lt;span&gt;String&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;user&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 定义了两个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;String&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 字段，分别是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;name&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;code&gt;&lt;span&gt;email&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ，它还包括一个称为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;addresses&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的字段，它是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Addresses&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对象的数组。&lt;/span&gt;&lt;code&gt;&lt;span&gt;Addresses&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 还定义了它自己的几个字段。（顺便说一下，GraphQL模式不仅有对象，字段和标量类型，还有更多，你也可以合并接口，联合和参数，以构建更复杂的模型，但本文中不会介绍。）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们还需要定义一个类型，这是我们GraphQL API的入口点。你还记得，前面我们说过，GraphQL查询是这样的：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;query {&lt;br/&gt;  user(id: &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;    name&lt;br/&gt;    email&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;该 &lt;/span&gt;&lt;code&gt;&lt;span&gt;query&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 字段属于一种特殊的保留类型，称为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Query&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ，这指定了获取对象的主要入口点。（还有用于修改对象的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Mutation&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 类型。）在这里，我们定义了一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;user&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 字段，该字段返回一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;User&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对象，因此我们的架构也需要定义此字段：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;type Query {&lt;br/&gt;  user(id: Int!): User&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;type User { ... }&lt;br/&gt;type Address { ... }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;字段中的参数是逗号分隔的列表，格式为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;$NAME: $TYPE&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;code&gt;&lt;span&gt;!&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是GraphQL表示该参数是必需的方式，省略表示它是可选的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;根据你选择的语言，将此模式合并到服务器中的过程会有所不同，但通常，将信息用作字符串就足够了。Node.js有 &lt;span&gt;graphql&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt; 包来准备GraphQL模式，但我们将使用 &lt;span&gt;graphql-tools&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt; 包来代替，因为它提供了一些更多的好处。让我们导入该软件包并阅读我们的类型定义，以为将来的开发做准备：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; fs = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;fs&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; { makeExecutableSchema } = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;graphql-tools&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; typeDefs = fs.readFileSync(&lt;span&gt;&quot;schema.graphql&quot;&lt;/span&gt;, {&lt;br/&gt;  &lt;span&gt;encoding&lt;/span&gt;: &lt;span&gt;&quot;utf8&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;flag&lt;/span&gt;: &lt;span&gt;&quot;r&quot;&lt;/span&gt;,&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;设置解析器&lt;/h2&gt;&lt;section&gt;&lt;span&gt;schema设置了构建查询的方式，但建立schema来定义数据模型只是GraphQL规范的一部分。另一部分涉及实际获取数据，这是通过使用解析器完成的，解析器是一个返回字段基础值的函数。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;让我们看一下如何在Node.js中实现解析器。我们的目的是围绕着解析器如何与模式一起操作来巩固概念，所以我们不会围绕着如何设置数据存储来做太详细的介绍。在“现实世界”中，我们可能会使用诸如&lt;span&gt;knex&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;之类的东西建立数据库连接。现在，让我们设置一些虚拟数据：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; users = {&lt;br/&gt;  &lt;span&gt;1&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&quot;Luke&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;email&lt;/span&gt;: &lt;span&gt;&quot;luke@heroku.space&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;addresses&lt;/span&gt;: [&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;street&lt;/span&gt;: &lt;span&gt;&quot;1234 Rodeo Drive&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;city&lt;/span&gt;: &lt;span&gt;&quot;Los Angeles&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;country&lt;/span&gt;: &lt;span&gt;&quot;USA&quot;&lt;/span&gt;,&lt;br/&gt;    },&lt;br/&gt;    ],&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;2&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&quot;Jane&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;email&lt;/span&gt;: &lt;span&gt;&quot;jane@heroku.space&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;addresses&lt;/span&gt;: [&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;street&lt;/span&gt;: &lt;span&gt;&quot;1234 Lincoln Place&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;city&lt;/span&gt;: &lt;span&gt;&quot;Brooklyn&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;country&lt;/span&gt;: &lt;span&gt;&quot;USA&quot;&lt;/span&gt;,&lt;br/&gt;    },&lt;br/&gt;    ],&lt;br/&gt;  },&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;Node.js中的GraphQL解析器相当于一个Object，key是要检索的字段名，value是返回数据的函数。让我们从初始 &lt;/span&gt;&lt;code&gt;&lt;span&gt;user&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  按id查找的一个简单示例开始:&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; resolvers = {&lt;br/&gt;  &lt;span&gt;Query&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;user&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;parent, { id }&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;// 用户查找逻辑&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;  },&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这个解析器需要两个参数：一个代表父的对象（在最初的根查询中，这个对象通常是未使用的），一个包含传递给你的字段的参数的JSON对象。并非每个字段都具有参数，但是在这种情况下，我们将拥有参数，因为我们需要通过用户ID来检索其用户。该函数的其余部分很简单：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; resolvers = {&lt;br/&gt;  &lt;span&gt;Query&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;user&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;_, { id }&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; users[id];&lt;br/&gt;    },&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;你会注意到，我们没有明确定义 &lt;/span&gt;&lt;code&gt;&lt;span&gt;User&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 或 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Addresses&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的解析器，&lt;/span&gt;&lt;code&gt;&lt;span&gt;graphql-tools&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 包足够智能，可以自动为我们映射这些。如果我们选择的话，我们可以覆盖这些，但是现在我们已经定义了我们的类型定义和解析器，我们可以建立我们完整的模式：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; schema = makeExecutableSchema({ typeDefs, resolvers });&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;运行服务器&lt;/h2&gt;&lt;section&gt;&lt;span&gt;最后，让我们来运行这个demo吧！因为我们使用的是Express，所以我们可以使用 &lt;span&gt;express-graphql&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt; 包来暴露我们的模式作为端点。该程序包需要两个参数：schema和根value，它有一个可选参数 &lt;/span&gt;&lt;code&gt;&lt;span&gt;graphiql&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，我们将稍后讨论。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;使用GraphQL中间件在你喜欢的端口上设置Express服务器，如下所示：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; express = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;express&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; express_graphql = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&quot;express-graphql&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; app = express();&lt;br/&gt;app.use(&lt;br/&gt;  &lt;span&gt;&quot;/graphql&quot;&lt;/span&gt;,&lt;br/&gt;  express_graphql({&lt;br/&gt;    &lt;span&gt;schema&lt;/span&gt;: schema,&lt;br/&gt;    &lt;span&gt;graphiql&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;  })&lt;br/&gt;);&lt;br/&gt;app.listen(&lt;span&gt;5000&lt;/span&gt;, () =&amp;gt; &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;Express is now live at localhost:5000&quot;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;将浏览器导航到 http://localhost:5000/graphql，你应该会看到一种IDE界面。在左侧窗格中，你可以输入所需的任何有效GraphQL查询，而在右侧你将获得结果。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这就是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;graphiql: true&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 所提供的：一种方便的方式来测试你的查询，你可能不想在生产环境中公开它，但是它使测试变得容易得多。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;尝试输入上面展示的查询：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;query {&lt;br/&gt;  user(id: &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;    name&lt;br/&gt;    email&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;要探索GraphQL的类型化功能，请尝试为ID参数传递一个字符串而不是一个整数。&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;# 这不起作用&lt;br/&gt;query {&lt;br/&gt;  user(id: &lt;span&gt;&quot;1&quot;&lt;/span&gt;) {&lt;br/&gt;    name&lt;br/&gt;    email&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;你甚至可以尝试请求不存在的字段：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;# 这不起作用&lt;br/&gt;query {&lt;br/&gt;  user(id: &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;    name&lt;br/&gt;    zodiac&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;只需用schema表达几行清晰的代码，就可以在客户机和服务器之间建立强类型的契约。这样可以防止你的服务接收虚假数据，并向请求者清楚地表明错误。&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1601209294677&quot; data-category_id_list=&quot;48|26|49|1|55|8|47|35|5|31|6|7|24|37|11|50|54|53|52|42|29|43|16|51|36&quot; data-id=&quot;1601209294677&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;性能考量&lt;/h2&gt;&lt;section&gt;&lt;span&gt;尽管GraphQL为你解决了很多问题，但它并不能解决构建API的所有固有问题。特别是缓存和授权这两个方面，只是需要一些预案来防止性能问题。GraphQL规范并没有为实现这两种方法提供任何指导，这意味着构建它们的责任落在了你身上。&lt;/span&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;缓存&lt;/h3&gt;&lt;section&gt;&lt;span&gt;基于REST的API在缓存时不需要过度关注，因为它们可以构建在web的其他部分使用的现有HTTP头策略之上。GraphQL不具有这些缓存机制，这会对重复请求造成不必要的处理负担。考虑以下两个查询：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;query {&lt;br/&gt;  user(id: &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;    name&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;query {&lt;br/&gt;  user(id: &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;    email&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;在没有某种缓存的情况下，只是为了检索两个不同的列，会导致两个数据库查询来获取ID为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;User&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。实际上，由于GraphQL还允许使用别名，因此以下查询有效，并且还执行两次查找：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;query {&lt;br/&gt;  &lt;span&gt;one&lt;/span&gt;: user(id: &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;    name&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;two&lt;/span&gt;: user(id: &lt;span&gt;2&lt;/span&gt;) {&lt;br/&gt;    name&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;第二个示例暴露了如何批处理查询的问题。为了快速高效，我们希望GraphQL以尽可能少的往返次数访问相同的数据库行。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;dataloader&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;程序包旨在解决这两个问题。给定一个ID数组，我们将一次性从数据库中获取所有这些ID；同样，后续对同一ID的调用也将从缓存中获取该项目。要使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;dataloader&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来构建这个，我们需要两样东西。首先，我们需要一个函数来加载所有请求的对象。在我们的示例中，看起来像这样：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; DataLoader = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;dataloader&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; batchGetUserById = &lt;span&gt;async&lt;/span&gt; (ids) =&amp;gt; {&lt;br/&gt;   &lt;span&gt;// 在现实生活中，这将是数据库调用&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; ids.map(&lt;span&gt;&lt;span&gt;id&lt;/span&gt; =&amp;gt;&lt;/span&gt; users[id]);&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;// userLoader现在是我们的“批量加载功能”&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; userLoader = &lt;span&gt;new&lt;/span&gt; DataLoader(batchGetUserById);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这样可以解决批处理的问题。要加载数据并使用缓存，我们将使用对 &lt;/span&gt;&lt;code&gt;&lt;span&gt;load&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法的调用来替换之前的数据查找，并传入我们的用户ID：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; resolvers = {&lt;br/&gt;  &lt;span&gt;Query&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;user&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;_, { id }&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; userLoader.load(id);&lt;br/&gt;    },&lt;br/&gt;  },&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;授权&lt;/h3&gt;&lt;section&gt;&lt;span&gt;对于GraphQL来说，授权是一个完全不同的问题。简而言之，它是识别给定用户是否有权查看某些数据的过程。我们可以想象一下这样的场景：经过认证的用户可以执行查询来获取自己的地址信息，但应该无法获取其他用户的地址。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了解决这个问题，我们需要修改解析器函数。除了字段的参数外，解析器还可以访问它的父节点，以及传入的特殊&lt;strong&gt;上下文&lt;/strong&gt;值，这些值可以提供有关当前已认证用户的信息。因为我们知道地址是一个敏感字段，所以我们需要修改我们的代码，使对用户的调用不只是返回一个地址列表，而是实际调用一些业务逻辑来验证请求：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; getAddresses = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;currUser, user&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (currUser.id == user.id) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; user.addresses&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; [];&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; resolvers = {&lt;br/&gt;  &lt;span&gt;Query&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;user&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;_, { id }&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; users[id];&lt;br/&gt;    },&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;User&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;addresses&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;parentObj, {}, context&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; getAddresses(context.currUser, parentObj);&lt;br/&gt;    },&lt;br/&gt;  },&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;同样，我们不需要为每个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;User&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 字段显式定义一个解析程序，只需定义一个我们要修改的解析程序即可。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;默认情况下，&lt;/span&gt;&lt;code&gt;&lt;span&gt;express-graphql&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 会将当前的&lt;strong&gt;HTTP请求&lt;/strong&gt;作为&lt;strong&gt;上下文&lt;/strong&gt;的值来传递，但在设置服务器时可以更改：&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;app.use(&lt;br/&gt;  &lt;span&gt;&quot;/graphql&quot;&lt;/span&gt;,&lt;br/&gt;  express_graphql({&lt;br/&gt;    &lt;span&gt;schema&lt;/span&gt;: schema,&lt;br/&gt;    &lt;span&gt;graphiql&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;context&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;currUser&lt;/span&gt;: user &lt;span&gt;// 当前经过身份验证的用户&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  })&lt;br/&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;Schema最佳实践&lt;/h2&gt;&lt;section&gt;&lt;span&gt;GraphQL规范中缺少的一个方面是缺乏对版本控制模式的指导。随着应用程序的成长和变化，它们的API也会随之变化，很可能需要删除或修改GraphQL字段和对象。但这个缺点也是积极的：通过仔细设计你的GraphQL schema，你可以避免在更容易实现（也更容易破坏）的REST端点中明显的陷阱，如命名的不一致和混乱的关系。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;此外，你应该尽量将业务逻辑与解析器逻辑分开。你的业务逻辑应该是整个应用程序的单一事实来源。在解析器中执行验证检查是很有诱惑力的，但随着模式的增长，这将成为一种难以维持的策略。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;GraphQL什么时候不合适？&lt;/h2&gt;&lt;section&gt;&lt;span&gt;GraphQL不能像REST一样精确地满足HTTP通信的需求。例如，无论查询成功与否，GraphQL仅指定一个状态码——&lt;/span&gt;&lt;code&gt;&lt;span&gt;200 OK&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。在这个响应中会返回一个特殊的错误键，供客户端解析和识别出错的地方，因此，错误处理可能会有些棘手。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同样，GraphQL只是一个规范，它不会自动解决你的应用程序面临的每个问题。性能问题不会消失，数据库查询不会变得更快，总的来说，你需要重新思考关于你的API的一切：授权、日志、监控、缓存。版本化你的GraphQL API也可能是一个挑战，因为官方规范目前不支持处理中断的变化，这是构建任何软件不可避免的一部分。如果你有兴趣探索GraphQL，你需要投入一些时间来学习如何将其与你的需求进行最佳整合。&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;了解更多&lt;/h2&gt;&lt;section&gt;&lt;span&gt;社区围绕这个新范例聚集，并为前端和后端工程师提供了&lt;span&gt;很棒的GraphQL资源列表&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;。前端和后端工程师都可以使用。你也可以通过在&lt;span&gt;官方的游乐场&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;上提出真实的请求来查看查询和类型是什么样子的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们还有一个&lt;span&gt;Code[ish]播客集&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;，专门介绍GraphQL的好处和成本。&lt;/span&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MDIwNTQ1Mg==&amp;amp;mid=2676494703&amp;amp;idx=1&amp;amp;sn=093342b1a624576187ec4a89d033082b&amp;amp;chksm=f362da8cc415539a021116a15dd7fac850140bb67977faca591ee65c0ee37ce03dd2ec13642f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span/&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/WYoaOn5t0AMNlR4lN4siawiaqWFb36Ct1nfUBczZ8C8xnT7rYrTrVt0PsicskFv7gwkWfam1unKkvJOJUtcFs8xicA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0MDIwNTQ1Mg==&amp;amp;mid=2676494632&amp;amp;idx=1&amp;amp;sn=194e712b6ab369c935cdd5825c022822&amp;amp;chksm=f362dacbc41553dd455d7dd881812181ac4349913e75a231db8b4f6c922168e6d6f69406ed5a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/WYoaOn5t0AM3SibO1W18xRgImMuW6R1mZFkbHktRdysys60uJD63tO3jGIMmkvicyt6qsmwSJMPRekLTAVmUtGKQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;福利资料&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;《&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;程序员成长攻略（价值1998）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;》&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;获取地址&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;密码&lt;/span&gt;&lt;span&gt;请&lt;/span&gt;&lt;span&gt;在公众号中回复关&lt;/span&gt;&lt;span&gt;键字&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;strong&gt;001&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;weapp_text_link js_weapp_entry&quot; data-miniprogram-appid=&quot;wxe43f931b4099b39c&quot; data-miniprogram-path=&quot;__plugin__/wx34345ae5855f892d/pages/productDetail/productDetail?productId=859909&quot; data-miniprogram-nickname=&quot;张张的小铺&quot; href=&quot;&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-servicetype=&quot;10&quot;&gt;全新2020版Webstorm、IntelliJ IDEA 等Jetbrains全家桶激活&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关注即送&lt;/span&gt;&lt;span&gt;大礼包&lt;/span&gt;&lt;span&gt;，高价值精品视频课程网盘资料，准能为你节省不少钱！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0AOPiaqWez1sKrh7Hffjoia7y8zkhic56DPic8FsoheTZljsrr5rpFMFcp7OgSZoOuuLKdXkWmhKibHia0fQ/0?wx_fmt=png&quot; data-cropx1=&quot;61.29032258064516&quot; data-cropx2=&quot;832.258064516129&quot; data-cropy1=&quot;40.32258064516129&quot; data-cropy2=&quot;443.54838709677415&quot; data-ratio=&quot;0.522697795071336&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/WYoaOn5t0AOPiaqWez1sKrh7Hffjoia7y8JicicRtO0ZCXic07QKNhrTsD8l77Iq50ce0gkxfHSmic7iaLoT3buDYibIRw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;771&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/aVp1YC8UV0fXSy8oK0h6qL36nlWgib6lHDTj0Ykkiab2FufBJIumwMrDEBZ1wHteh6pzsQiaP4007ox4ichic8pNw3Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-ratio=&quot;0.1732283464566929&quot; data-w=&quot;635&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;GraphQL: &lt;em&gt;https://graphql.org/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;graphql: &lt;em&gt;https://www.npmjs.com/package/graphql&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;graphql-tools: &lt;em&gt;https://www.npmjs.com/package/graphql-tools&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;knex: &lt;em&gt;https://knexjs.org/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;express-graphql: &lt;em&gt;https://www.npmjs.com/package/express-graphql&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;dataloader: &lt;em&gt;https://github.com/graphql/dataloader&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;很棒的GraphQL资源列表: &lt;em&gt;https://github.com/chentsulin/awesome-graphql&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;官方的游乐场: &lt;em&gt;https://graphql.org/swapi-graphql/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;Code[ish]播客集: &lt;em&gt;https://www.heroku.com/podcasts/codeish/44-graphqls-benefits-and-costs&lt;/em&gt;&lt;span/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3cda43ab09b9af1528030662f4da2190</guid>
<title>离开华为换种生活，它不香吗？</title>
<link>https://toutiao.io/k/ixqtnal</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;菜架：雷架雷架，听说咱们同学甄香从华为离职了啊？ &lt;/p&gt;&lt;p&gt;雷架：知道啊！ &lt;/p&gt;&lt;p&gt;菜架：难得你消息这么灵通！你说都已经升到领导了，股票都已经拿了，咋还跳槽呢？ &lt;/p&gt;&lt;p&gt;雷架：换种生活它不香吗？😁&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;甄香，一名985的计算机高材本硕，也有着优异的学校背景和个人漂亮的履历，有才华还有程序员少有的公子帅。朋友间聚会时他跟雷架聊起，说是毕业那年为了离家近，选择了留在华为。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9393939393939394&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EptIkE77NXB6R5ic2aicpOsWxxR9QicB8WF2T2UfkKguwcFZLvffIOpgOJUgy7guQ1kfVgiaxDSevExRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;264&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;能进入这样一个中外驰名的super厂厂，甄老板（我们私底下的绰号啦）摩拳擦掌，一副准备大干一场的派头。那时候我们的好友基本都选择了互联网大厂，对于甄老板的决定没说多的话，竖起大拇指，一个字☝️“干就完事了”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是啊，正所谓“三十登高科，前途浩难测”，前途这事，谁能说谁的决定一定正确，或者谁的选择一定不正确呢？华为虽不算在互联网大厂体系，但不可不谓也是一个不错的去处！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9214285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EptIkE77NXB6R5ic2aicpOsWxO1BJUpnj24NvznsWGrekBdkuic0ZQj6nugarPYyK6EOQ3qE9ksKpKRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;作为一名优秀的“三好学生”（成绩好、技术好、长得好～乖乖，这不是父母口中别人家的小孩儿嘛！慕了慕了！），并且通过甄老板饱含着300%的热情+200%的努力，没多久就当上了小领导。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要知道外面的人看华为那都是光环呐，不论是出自爱国情怀，还是华为在通讯业的地位。架架读书时可是有好几个朋友都是非常想进华为，不是想进而是那种非进华为不可哦，就像周杰伦对优乐美的那种热衷，杰迷都懂的（放电）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EptIkE77NXB6R5ic2aicpOsWxyR1SjicVc4A0onEnicK5L0vMP04Nu54uIF4fUwx0oibCzcHMIQ4p5IrTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;284&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;华为的员工是奋斗者，是拼搏者，不知疲倦和决战XX天都是那里的信仰。好笑却也不好笑，做软件这一行，我们不都是身怀赤子之心的追梦人吗。那些年朋友聚会鲜少见到甄老板，打电话给他不是在加班中就是在去加班的路上。雷架对华为也是非常的熟悉，可能是在那里的朋友比较多的缘故，因此明白在那里一个战斗目标就能激起24h奋斗的激情，领导下达一个任务，大家哪怕已经加班很久，爬起来还能战斗几天几夜的状态，这不是被洗脑了，而是习惯（要不怎么说习惯很可怕呢，不夸张，华为的人真狼）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.975&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EptIkE77NXB6R5ic2aicpOsWxkEJ08VjBSOXH1L33MI27ZcXlbsIVCBHbXlh1OKRJWmIzeeHb5cPC0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小伙伴们看了这么久的闲话，肯定着急咋还没说为啥甄老板从华为离职呀！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了好了，啰嗦也不是架架一贯的风格。好了，说完了甄老板对华为的情愫，也该谈谈他离职的始末。前面不是说了嘛，甄老板已经早早混到领导层，工资upup的同时也拥有了再也忙不完的工作（永动机也不过如此，笑cry）。沟通对齐、安排员工日清bug、开不完的会议（对了，在华为，白天基本被会议填满，真正的精彩从夜里开始，夜生活不是只有炸鸡和啤酒，还有working哦）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;华为的工资不是传说，都是真的，不吹不黑，这点还是值得大多数公司学习的，劳动力应当转化为对应的价值，架架还是很羡慕的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9763779527559056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EptIkE77NXB6R5ic2aicpOsWxb688iaD52aA9jhnj4n1kJh2Pke9h3wp6r09ibUMqM94Pozk56iaSuRDng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;254&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;甄老板说，进入华为后基本就没有私人时间了，需要24h手机保持开机，不管你是在吃饭，还是在过节回家的高速路上......也就是繁忙而零碎的工作，超负荷的工作强度，使得甄老板患上“神经衰弱”，夜里失眠是常态。（也不知道大家对华为有什么好奇的地方，可以留言或者私信架架，架架可以为大家来一次深度揭秘，你想知道这一次统统告诉你）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;男人的成熟往往不是千锤百炼，而是一瞬间，如“简蒙指教，豁然大悟”，甄老板放下在华为努力拼来的一切，提了离职申请。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9259259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EptIkE77NXB6R5ic2aicpOsWxc1twPzbntFnO8JgLSgtNpNY5affl8lQrTRaSOKNEQ2JjuJPib6dbVqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;270&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;离别去往杭州时，他说大多数人在华为买了人生的第一辆车、买了人生的第一套房子，他也是这样。也算是每一滴汗水都没有白流，走过的每一步都在人生留下了痕迹。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对了，甄老板最后去了阿里，杭州，那个山清水秀的城市，工作之余坚持锻炼，目前发来的照片仍然是曾经的少年，是三好也是三高（个子高、工资高、理想高）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9452054794520548&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EptIkE77NXB6R5ic2aicpOsWxo3o8Ph4GHEISuRlSOqbmhZUbhXmz9fT1GM9dthJBztlS9O818ZbtWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;292&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e8b35e475831a8bd3861022f63bf56d2</guid>
<title>工具 | 一款高可用，高性能，简单易用的，金融级的分布式事务解决方案</title>
<link>https://toutiao.io/k/3cjyfym</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>