<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1e22e4414b07b7f0d29b33c0799106a1</guid>
<title>2022 年别再焦虑啦！加入我们！</title>
<link>https://toutiao.io/k/obimloc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3d72e318487d132076cd450672afbf2b</guid>
<title>2022春节贺岁档电影开分，水门桥不理想，四海崩了！用Python一探究竟</title>
<link>https://toutiao.io/k/877cd6d</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管受到疫情影响，部分地区被迫关闭了电影院，但从大年初一中国影史第二单日总票房的数据来看，2022 年春节期间大家的观影热情还是十分高涨的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大年初一上映当天，从票房数据来看，《长津湖之水门桥》一马当先，《四海》《这个杀手不太冷静》《奇迹·笨小孩》你追我赶，动画片《熊出没》表现强势，《狙击手》令人遗憾。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.902687673772011&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2ozNacoHjicGBv5GWSAUWzUcDsPcwLNdFhJf9YOU3VTBib67xh8fYb9qHQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1079&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前，几部真人电影豆瓣已经开分了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32421875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2opOvlOiabnvTV7V4pFT65gBINUefyz5co2fLwp7mtMs8eDtqosJHTHrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们用 Python 爬取这几部豆瓣开分的电影评论，爬取的具体分析过程这里就不说了，不了解的可以参考一下：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU3Mzk1ODA5OQ==&amp;amp;mid=2247484101&amp;amp;idx=1&amp;amp;sn=2367e5f51ca00e35717d8ab7340c5aad&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;豆瓣影评爬取参考&lt;/a&gt;，主要实现代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;spider&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    url = &lt;span&gt;&#x27;https://accounts.douban.com/j/mobile/login/basic&#x27;&lt;/span&gt;&lt;br/&gt;    headers = {&lt;span&gt;&quot;User-Agent&quot;&lt;/span&gt;: &lt;span&gt;&#x27;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)&#x27;&lt;/span&gt;}&lt;br/&gt;    &lt;span&gt;# 龙岭迷窟网址，为了动态翻页，start 后加了格式化数字，短评页面有 20 条数据，每页增加 20 条&lt;/span&gt;&lt;br/&gt;    url_comment = &lt;span&gt;&#x27;https://movie.douban.com/subject/35215390/comments?start=%d&amp;amp;limit=20&amp;amp;sort=new_score&amp;amp;status=P&#x27;&lt;/span&gt;&lt;br/&gt;    data = {&lt;br/&gt;        &lt;span&gt;&#x27;ck&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;用户名&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&#x27;password&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;密码&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&#x27;remember&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;false&#x27;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&#x27;ticket&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    session = requests.session()&lt;br/&gt;    session.post(url=url, headers=headers, data=data)&lt;br/&gt;    &lt;span&gt;# 初始化 4 个 list 分别存用户名、评星、时间、评论文字&lt;/span&gt;&lt;br/&gt;    users = []&lt;br/&gt;    stars = []&lt;br/&gt;    times = []&lt;br/&gt;    content = []&lt;br/&gt;    &lt;span&gt;# 抓取 500 条，每页 20 条，这也是豆瓣给的上限&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;500&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;):&lt;br/&gt;        &lt;span&gt;# 获取 HTML&lt;/span&gt;&lt;br/&gt;        data = session.get(url_comment % i, headers=headers)&lt;br/&gt;        &lt;span&gt;# 状态码 200 表是成功&lt;/span&gt;&lt;br/&gt;        print(&lt;span&gt;&#x27;第&#x27;&lt;/span&gt;, i, &lt;span&gt;&#x27;页&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;状态码：&#x27;&lt;/span&gt;,data.status_code)&lt;br/&gt;        &lt;span&gt;# 暂停 0-1 秒时间，防止IP被封&lt;/span&gt;&lt;br/&gt;        time.sleep(random.random())&lt;br/&gt;        &lt;span&gt;# 解析 HTML&lt;/span&gt;&lt;br/&gt;        selector = etree.HTML(data.text)&lt;br/&gt;        &lt;span&gt;# 用 xpath 获取单页所有评论&lt;/span&gt;&lt;br/&gt;        comments = selector.xpath(&lt;span&gt;&#x27;//div[@class=&quot;comment&quot;]&#x27;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;# 遍历所有评论，获取详细信息&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; comment &lt;span&gt;in&lt;/span&gt; comments:&lt;br/&gt;            &lt;span&gt;# 获取用户名&lt;/span&gt;&lt;br/&gt;            user = comment.xpath(&lt;span&gt;&#x27;.//h3/span[2]/a/text()&#x27;&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;            &lt;span&gt;# 获取评星&lt;/span&gt;&lt;br/&gt;            star = comment.xpath(&lt;span&gt;&#x27;.//h3/span[2]/span[2]/@class&#x27;&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;7&lt;/span&gt;:&lt;span&gt;8&lt;/span&gt;]&lt;br/&gt;            &lt;span&gt;# 获取时间&lt;/span&gt;&lt;br/&gt;            date_time = comment.xpath(&lt;span&gt;&#x27;.//h3/span[2]/span[3]/@title&#x27;&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;# 有的时间为空，需要判断下&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; len(date_time) != &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;                date_time = date_time[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;                date_time = date_time[:&lt;span&gt;10&lt;/span&gt;]&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;                date_time = &lt;span&gt;None&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;# 获取评论文字&lt;/span&gt;&lt;br/&gt;            comment_text = comment.xpath(&lt;span&gt;&#x27;.//p/span/text()&#x27;&lt;/span&gt;)[&lt;span&gt;0&lt;/span&gt;].strip()&lt;br/&gt;            &lt;span&gt;# 添加所有信息到列表&lt;/span&gt;&lt;br/&gt;            users.append(user)&lt;br/&gt;            stars.append(star)&lt;br/&gt;            times.append(date_time)&lt;br/&gt;            content.append(comment_text)&lt;br/&gt;    &lt;span&gt;# 用字典包装&lt;/span&gt;&lt;br/&gt;    comment_dic = {&lt;span&gt;&#x27;user&#x27;&lt;/span&gt;: users, &lt;span&gt;&#x27;star&#x27;&lt;/span&gt;: stars, &lt;span&gt;&#x27;time&#x27;&lt;/span&gt;: times, &lt;span&gt;&#x27;comments&#x27;&lt;/span&gt;: content}&lt;br/&gt;    &lt;span&gt;# 转换成 DataFrame 格式&lt;/span&gt;&lt;br/&gt;    comment_df = pd.DataFrame(comment_dic)&lt;br/&gt;    &lt;span&gt;# 保存数据&lt;/span&gt;&lt;br/&gt;    comment_df.to_csv(&lt;span&gt;&#x27;data.csv&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了评论数据，我们再通过词云直观的感受一下，主要代码实现如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;df = pd.read_csv(&lt;span&gt;&quot;comment.csv&quot;&lt;/span&gt;, index_col = &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;cts_list = df[&lt;span&gt;&#x27;comments&#x27;&lt;/span&gt;].values.tolist()&lt;br/&gt;cts_str =&lt;span&gt;&quot;&quot;&lt;/span&gt;.join([str(i).replace(&lt;span&gt;&#x27;\n&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;&#x27;&lt;/span&gt;).replace(&lt;span&gt;&#x27; &#x27;&lt;/span&gt;, &lt;span&gt;&#x27;&#x27;&lt;/span&gt;) &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; cts_list])&lt;br/&gt;stop_words = []&lt;br/&gt;&lt;span&gt;with&lt;/span&gt; open(&lt;span&gt;&#x27;stop_words.txt&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;r&#x27;&lt;/span&gt;, encoding=&lt;span&gt;&#x27;utf-8&#x27;&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; f:&lt;br/&gt;    lines = f.readlines()&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt; lines:&lt;br/&gt;        stop_words.append(line.strip())&lt;br/&gt;&lt;span&gt;# jieba 分词&lt;/span&gt;&lt;br/&gt;word_list = jieba.cut(cts_str)&lt;br/&gt;words = []&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; word &lt;span&gt;in&lt;/span&gt; word_list:&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; word &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; stop_words:&lt;br/&gt;        words.append(word)&lt;br/&gt;cts_str = &lt;span&gt;&#x27;，&#x27;&lt;/span&gt;.join(words)&lt;br/&gt;print(cts_str)&lt;br/&gt;stylecloud.gen_stylecloud(text=cts_str, max_words=&lt;span&gt;300&lt;/span&gt;,&lt;br/&gt;                          collocations=&lt;span&gt;False&lt;/span&gt;,&lt;br/&gt;                          font_path=&lt;span&gt;&quot;SIMLI.TTF&quot;&lt;/span&gt;,&lt;br/&gt;                          icon_name=&lt;span&gt;&quot;fas fa-arrow-circle-right&quot;&lt;/span&gt;,&lt;br/&gt;                          size=&lt;span&gt;800&lt;/span&gt;,&lt;br/&gt;                          output_name=&lt;span&gt;&quot;comment.png&quot;&lt;/span&gt;)&lt;br/&gt;Image(filename=&lt;span&gt;&quot;comment.png&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们来看《四海》，《四海》的口碑为什么没有纵横四海？看看观众怎么说的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2oakEHR4kNg4GhTmaNibeNj1myqrop4wor1HgjWHAQMylrjWhRxFCpFaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着看《这个杀手不太冷静》，作为一部喜剧片，豆瓣这个评分还算可以，看看观众怎么说的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2oJhxrv81ibiapiaGNd9vw8Z7LHJZNow1BRoJb56TotK16Pw38G9OqrRHDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再接着看《长津湖之水门桥》，目前评分是低于第一部的，看看观众怎么说的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2oicHZecIeGxqlTd7KYaOylx4297QdeLJonpTpdufHO6EablaZGZ1rMeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再接着看《奇迹·笨小孩》，评分和票房都算是中规中矩，看看观众怎么说的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2oc2zJS8V2YoDfCUaP3pkBibFSEkgkOLUcRz8OeMN9oKLBpNtN3mTDY6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再接着看《狙击手》，国师父女指导，票房不佳，评分暂列第一，看看观众怎么说的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIqeMuN4KiahkpNaygVugxr2ok6LupiaY4Svw5VY3zET2Q2w8J3UJ4cUOnstKLrmCiczicTYd5tzGI3RpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码已经打包整理好了，有需要的小伙伴可以在公众号&lt;strong&gt;Python数据分析之美&lt;/strong&gt;后台回复&lt;strong&gt;m2022&lt;/strong&gt;直接获取~&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b796d9b52880f42c972215177fad7684</guid>
<title>网易云音乐广告CTR预估模型演进过程</title>
<link>https://toutiao.io/k/ajdmqsp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section label=&quot;Copyright Reserved by PLAYHUDONG.&quot; donone=&quot;shifuMouseDownCard(&amp;quot;shifu_c_008&amp;quot;)&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;导读：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文先介绍了效果广告的基本原理，然后以云音乐广告系统从浅层模型到深度模型的演进为主线，介绍了广告算法团队在算法优化过程中遇到的问题、思考和解决的过程。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;广告是云音乐的重要收入来源之一，最近两年云音乐广告平台在深度（机器）学习技术上做了很大的投入，期间也遇到了许多问题，也取得了一些不错的成果。本文将以模型演进为主线，重点介绍遇到的问题、思考和解决问题的过程，希望能为其他同学在类似的算法场景下提供一些参考。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;广告系统最典型的机器学习应用场景是广告点击率（CTR）预估，另外在广告主需要考核成本的时候还会用到转化率（CVR）预估，其中也有大量的深度学习实践，考虑到篇幅，本文聚焦在CTR预估，以后再单独介绍CVR的相关实践。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;1&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p hm_fix=&quot;360:461&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;云音乐广告系统的特点&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;广告作为互联网的主要商业模式之一，是各大互联网公司的重要业务。云音乐广告平台是国内第一个专注于基于音频流量变现的广告平台，有一些自己的特点，比如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些基本特点决定了算法模型的选择、优化等基本面，后续会穿插着提到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;2&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p hm_fix=&quot;360:461&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;广告系统为什么需要CTR预估&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 广告主和媒体的博弈问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我前面提到广告点击率（CTR）预估是典型的机器学习应用场景，但为什么需要CTR预估呢，为了解释清楚这个问题，需要先了解效果广告的机制。效果广告要的是直接转化率，这一点跟品牌广告不同，品牌广告主要打品牌知名度，比如汽车广告，房产广告等，广告主不指望用户看完这个广告之后立刻去买一辆车子或者房子，而是先让用户熟悉这个品牌。而效果广告则希望用户看完广告之后立刻去成交，例如淘宝上的商品搜索广告，百度搜索广告等，都以转化为目的。效果广告的主要博弈方是广告主和媒体方，扩展一下也包含了广告平台、用户等参与方，但为了简化问题我们只考虑最主要的部分，双方的利益如下图所示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5308464849354376&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmdjGiazJ8nRH7oc0GJEvQE5Gp2ZtxmPaz7nsbOGsxb2c1qCV1raxibEtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;697&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;广告主最关注ROI，希望用最低的成本拿到自己的目标用户，底线是不能长期做亏本生意。媒体方则希望提高点击率（按点击率计费时，点击越多收入越多）、通过竞争提升单次点击价格，关注的是流量变现价值的最大化。这两方的诉求目标是矛盾的，解决办法是引入经济学的拍卖机制，然后用计算机程序来实现自动竞价，把经济学和计算机科学结合起来解决这个博弈问题，下面详细介绍一下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. GFP vs GSP&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大家应该在电视里面看过拍卖的场景，比如拍卖某个古董时，从低价开始喊，然后不断加价，直到没人再加为止，这时候锤子一敲就成交了，这个模式叫做英式拍卖，这种公开叫价的形式叫明拍。还有一种叫暗拍，情况类似于每个竞买人把自己的价格写好，等全部交上去后按价格的高低排序，价格最高者得。如果是第一价格模式则按第一价格支付，按第二价格模式则出价最高的人按照第二名的价格支付。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8515901060070671&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmAmA1pVhdQgicYIibj2dUftsLYLHYIIjEZ4har8Gq2w3D76c8YCZGNrQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;283&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;GFP（Generalized First Price）广义第一价格模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;早期的互联网产品，比如Yahoo和MSN采用的是GFP，广告主针对某个关键词出价，价高者得且按自己的出价支付。早期百度的竞价排名也是类似的规则。但这种模式最大的问题是系统收入非常不稳定，竞买人需要频繁修改出价以拿到流量或者希望以更低的价格拿到流量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;GSP（Generalized Second Price）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2002年Google在Adwords业务中采用了GSP机制，即出价最高者按照第二名的出价来支付。GSP模式由于看不到其他人的出价，可以鼓励广告主按照自己认为的真实价值来出价，鼓励“讲真话”。并且排序时还引入了质量得分，通常是pCTR，即预估的广告点击率，然后按照Price * pCTR排序，这样可以惩罚广告质量差的广告。用Bid来表示出价，则按eCPM排序的规则为：eCPM = Bid * pCTR * 1000 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于在竞拍的过程中，不可能所有参与竞买的广告都能得到曝光，并且不同的人对于不同的广告点击率也不一样，所以CTR不能使用历史统计值，而且即使有历史统计值也解决不了新广告的问题，因此CTR只能预估，但如何预估呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 经济学+机器学习&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;机器学习为CTR预估找到了一个解决方案：利用机器学习的回归技术来预测点击概率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以用一个公式来表示，点击概率 p = f(user features, context features, ad features)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样一来，就比较完美地平衡了广告主和媒体方的利益：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;精准投放保障广告主的ROI；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;拍卖机制保障媒体方流量价值的最大化；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在这过程中，CTR预估扮演着非常关键的桥梁作用。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmkPOsa6w3fAA3wmcImJIPkmAvJ5vKSuicWTNW01jPObH5V76ThNT7JuA/640?wx_fmt=jpeg&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1034&quot; data-cropy1=&quot;57.245674740484425&quot; data-cropy2=&quot;441.86505190311414&quot; data-ratio=&quot;0.3723404255319149&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sYBGQlzfEOWQvvKU1Uicm15ERq0qqwTFD4WZWX2suEpzLbicav7RhBNGtkKjib7OvRauYs4pXyhDbXPqAMz8BbWjQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1034&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;3&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p hm_fix=&quot;360:461&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;浅层学习CTR预估模型优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;业界早期阶段，在2012年以前，几乎主流公司都使用LR模型来预估CTR。LR有很多优点，比如简单、易于并行化、可解释性强。比较适合处理广告场景高维、稀疏的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6869565217391305&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmuORuRmM9Y8YmoPfpqNJzIPmVNgiaY1XpwyswVeIibrcmD4E0NCntOQnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;345&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（利用sigmoid函数映射点击概率）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;云音乐广告系统最初采用的是LR模型，至今也还作为基线在跑着。后来尝试了FM，以及LR+GBDT，FM+GBDT，如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmrejoJ6aaRYQhZWj3CVVUIbmkFkk8TiaiajJKhZHYr5xPXiaPs2oCR2RGA/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;572&quot; data-cropy1=&quot;37&quot; data-cropy2=&quot;502&quot; data-ratio=&quot;0.8111888111888111&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sYBGQlzfEOWQvvKU1Uicm15ERq0qqwTFDpO5mibLkbAvdNPjvuRibWkpaJibCzficxQIia1h63CRHyWibibh4Mw7OViaPQw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;572&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;LR模型阶段打下了很多基础，做了很多数据和特征工程的事情，避免Garbage in, garbage out，争取达到效果的上限。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 数据采样&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;（1）样本正确选取问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最开始，各个广告位的历史数据是放在一起训练的，最终训练出一个模型。启动画也包含其中，并且数据量占了很大比例，但启动画有一个很大的问题，就是误点率很高，误点数据基本上是随机分布，没办法体现出用户的真实意图，很多数据都是噪声，严重影响模型的准确性。因此需要去除不能真实反应用户意图的场景数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，最初的版本iOS和Android双端数据也是放在一起训练的，但通过一段时间的运行发现，双端的广告主数据几乎完全不一样，基本上可以看做是两个数据集，并且在同样的广告位，其CTR和CVR的表现也有显著差异。所以需要拆分不同的数据分布。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，对于训练样本的选择来说，我们把开机画数据拆了出去，同时iOS和Android分端训练，这样一来，模型效果得到了大幅提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;AB实验中，iOS端eCPM提升了11.12%，Android端eCPM提升了10.50%，全流量后效果表现一致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;（2）样本不平衡问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在我们的CTR场景，尤其是CVR场景，正负样本比例相差非常大。CTR正负样本比例大约从1:1000至1:100，CVR从曝光到转化则是1:10000，甚至更低。在模型的训练过程中，正样本变成了小概率事件，很容易被模型当作噪声而忽略了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们在CTR模型中，把正样本上采样了10倍，效果上Android端AUC提升1.02%，iOS端AUC提升0.75% 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对CVR模型（深度模型）的训练数据，我们对负样本降采样10倍，AUC提升了1.06%，线上效果也表现显著。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;（3）其它的样本问题&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过优化，离线AUC提高了1.4%， eCPM相对基线提高了3.73% 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 特征组合&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们有一个CASE分析工具，可以分析不同权重对结果的影响程度。我们发现模型并没有学出用户侧与广告侧的匹配关系，主要依靠单特征在影响pCTR打分。尽管做了一些人工特征组合，比如广告主+年龄，但由于太稀疏没有学出来。很自然我们想用FM模型来尝试一下自动特征组合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;（1）尝试FM&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;FM引入了隐向量，为每一个特征学习一个隐权重向量。在做特征交叉时，使用两个特征隐向量的内积作为交叉特征的权重。与直接特征组合（用POLY2模型的方式）需要该组合的所有特征同时存在才更新参数不同，对训练数据中没有出现的组合FM也能够学到。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.1788793103448276&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmUf265CiaDCua9CwFXJmqcfWIKibQdE4UxQmvE97WvW0Gibo1KicrFuzorQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;464&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;举例来说：用直接特征组合时，只有当广告主为“潭州教育”且“用户年龄为20岁”时才会更新该组合特征的参数（否则其中一个为0，则相乘后也为0），但这种组合太稀疏，基本上训练不充分。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;FM由于使用两个特征向量的内积来表示权重，比如广告主（潭州教育）的特征向量为v_i，年龄为20岁的特征向量为v_j，权重w=向量积&amp;lt;v_i,v_j&amp;gt;，只要出现了广告主（潭州教育）或年龄为20岁的样本，都可以共享更新相应的特征向量。解决了稀疏特征组合的问题。FM的不足是只有二阶特征组合，非线性表达能力依然不足。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;效果：线下AUC提升0.75%，但线上效果不稳定，因此只做了小流量上线，不符合全流量的标准。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们推断了效果不理想的原因：一是我们的特征中，连续特征很多，将其离散化取决于经验，因此即使做了二阶交叉，解决的可能不是关键问题；第二，云音乐的广告推荐场景属于弱个性化推荐场景。相对来说云音乐的歌曲推荐属于强个性化推荐，淘宝的商品推荐也属于强个性化推荐，不仅拥有足够的样本数据做训练，每个人的偏好也相对更明显。而个人对广告的喜爱与否并不是那么明显（有时候说喜欢广告，不如说不那么讨厌的广告）。在这种场景下，二阶特征组合的记忆力并不算太好，基于这种推断，我们自然开始尝试GBDT。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;（2）尝试GBDT&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;GBDT的引入带来了如下优点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7710144927536232&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmbZGaCY194NJezduD7Q16G93VtMtdnu7LA4unk6D1oOhmcsqQmWPicoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;345&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;LR+GBDT模型相比基线LR模型，AUC绝对值提升1.03%，相对提升1.71%，效果非常显著。线上CTR和eCPM提升稳定，符合全流量标准。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;之后我们又尝试了FM+GBDT，但效果不如LR+GBDT。浅层学习阶段，最终LR+GBDT胜出，成为了效果最好的模型。我们的推测原因是：弱个性化场景下需要有深度记忆功能。LR处理了稀疏特征记忆能力，GBDT处理好了深度组合特征以及连续特征的记忆能力，这正是我们音频流量广告场景（结合我们的广告主特点）所适合的。我们这个思路会持续到深度学习阶段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如喜欢听儿童歌曲的用户，年龄可能在25岁以上，并且可能喜欢购买化妆品，可能是年轻的妈妈们。喜欢听英文歌曲的用户，也许是爱好英文歌曲，也许正在锻炼自己的听力，喜欢点击英语培训广告，需要多种特征组合起来才能更精确。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;4&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p hm_fix=&quot;360:461&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;人类行为可预测的认知 – 个人理论总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;人类行为有93%是可预测的，这是美国东北大学科学家的一项研究结论。我认为这一基本原则是很多优化工作的指导基础。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 个体人格相对稳定，才能用历史预测未来&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;人类行为可预测是因为人格的相对稳定性，人格包含性格、气质、能力、兴趣、爱好等成分，是由先天的遗传和后天的环境因素共同决定的。招聘面试也是采用了这个原理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 人类具有共同的行为模式，可以用群体预测个体&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由此原理引出了协同过滤算法，即利用某种共同兴趣或共同经历的群体行为来预测个体的行为。比如大多数读过笑傲江湖和神雕侠侣的人，都读过倚天屠龙记，假如有某个人读了笑傲江湖和神雕侠侣，我们可以推断他很大概率会喜欢倚天屠龙记。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;做算法上的任何优化，都应该遵循这两个基本原则。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;5&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p hm_fix=&quot;360:461&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;深度模型演进和优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;深度模型的引入，一方面是由于业界已经有很多公司成功把深度学习应用到了CTR预估，并取得了效果；其实更重要的原因是延续LR+GBDT的优化思路，需要持续做，上面提到了用LR处理稀疏特征记忆，用GBDT处理深度组合特征和连续特征记忆，自然会想到Wide&amp;amp;Deep模型，即使用Wide的记忆能力，以及Deep的泛化能力。我们从Wide&amp;amp;Deep切入深度学习，并且做了很多尝试。如图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVm1gITTTcDCe376bXJicSiaibmgOEMx1gjUk584kEKPrvL0OAFnnHW4ut6A/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;306&quot; data-cropy1=&quot;41&quot; data-cropy2=&quot;784&quot; data-ratio=&quot;2.4248366013071894&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sYBGQlzfEOWQvvKU1Uicm15ERq0qqwTFDpV2Ek9hT9BvlPbibTibCqCF4toLVk2aEAdwhIJGqlIS7fjsfAGOlLSKQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;306&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Wide&amp;amp;Deep、DeepFM、DCN都没有全流量，第一个全流量的深度模型是DCN+Wide，目前（2020年10月）正在跑的是DICN+Wide。下面介绍一下这些模型的特点和问题，以及做的优化工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. Wide&amp;amp;Deep&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在讲Wide&amp;amp;Deep之前，我先讲一下业界早期尝试将深度学习应用于广告CTR预估的情况。业界早期的时候，使用的是纯DNN模型（MLP），但无论怎么优化都很难超越LR+GBDT，主要原因是广告场景有大量的长尾稀疏数据，DNN采用Embedding的方式训练不出来，后来尝试了很多方法把DNN和LR以及其它浅层模型融合起来，融合之后的效果才超过了LR，比如采用LR训练后的权重参数，或者进一步将FM的隐向量作为Embedding输入等。Wide&amp;amp;Deep就是在这种情况下作为一种融合方案之一，由Google在2016年发布出来的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVms5ZGbomY20FTqEicr49Hbu4CicnoPZ9e8u6cOLsKQLKltZnxicvmHrnNw/640?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;522&quot; data-cropy1=&quot;42&quot; data-cropy2=&quot;350&quot; data-ratio=&quot;0.5919540229885057&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sYBGQlzfEOWQvvKU1Uicm15ERq0qqwTFDvHKp5ynOxk8zIUHnxE1jFn26RRTS20r8QVTuDDozkXAGTaA0uIgYZA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;522&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;W&amp;amp;D通过将浅层模型和深层模型联合训练，融合了浅层模型的记忆能力和深层模型的泛化能力。通过Wide侧较好地解决了长尾数据的拟合，弥补了纯DNN的不足。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过理论归理论，有没有效果还要看实际场景，我们最开始W&amp;amp;D的效果始终没有赶上LR，后来做了一些特征优化，比如连续特征同时做离散化处理，用全连接代替Wide和Deep融合时直接相加，最后的效果只是与LR模型打平。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们根据浅层学习时的经验，认为是Deep侧对特征交叉训练不够，纯DNN模型只是隐性交叉，并且是稀疏的场景，隐性交叉需要足够的样本和足够多的训练时间。因此后续的思路是需要在Deep侧做特征交叉方面的尝试。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于是第一个深度模型，也让我们体会到了，并不是所有深度模型的效果都会优于浅层模型，尤其是做过良好特征工程的LR模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. DeepFM&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本来顺着上面的思路应该优化Deep侧，但由于根据以往的经验，DeepFM模型的效果可能还不错，我们还尝试了DeepFM模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.49550898203592814&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmiaiapPMlgGQHISttlcfgxiaJtIWStCS5uu259tejwQPTZSZ2ia7JpzokDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;668&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;优化了特征、正则项、模型层数和embedding size等调优，最终效果与基线LR的AUC相差千分位，依然不好，与浅层模型时单独尝试FM的效果表现一致，这坚定了我们往优化Deep侧的方向去尝试。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. DCN&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DCN的引入主要是为了解决纯DNN没有特征显式交叉的问题，它在Wide&amp;amp;Deep的基础上，把Wide侧改成了Cross Network，示意如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.978343949044586&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVm4DmfiabLhnCNwPLQQKLicoyCoyHy2zia5UhEgzA0QeSUaQ6JIoTic1NInQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;785&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该模型的核心是Cross Network，设计用来高效地进行特征交叉，公式如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.11826086956521739&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmib2TE4CJocfhiaUGAmQiaTcHZJHrickaZIVF1K6nQBMQY1b954xbhr0icFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;575&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;xl表示第l层的cross layer输出，wl是参数，bl是偏置，都是列向量。其实是应用了残差网络的思想，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3806646525679758&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmLhvgWD6A25VuicpIf1lV1NabvicoV4bU1A5o0r9FALrgJhIbHmQDeg3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;662&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这样模型就能够高效地学习到高阶的非线性特征组合了。DCN的效果：离线AUC比LR高0.69%，线上eCPM提升幅度稳定达到3%，达到了上线标准。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们观察到的现象是当特征显性高阶交叉时效果就会更好，与LR采用GBDT组合特征时效果会更好的表现是一致的。应该是挖掘出了音乐场景下深层次的关系。后来我们还在DCN上面引入了Attention机制，也取得了一定的效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4. DCIN+Wide&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;顺着前面的优化思路，DCN已经解决了特征深度交叉，以及泛化的功能，DIN解决了用户短期兴趣问题，这些解决的都是头部数据的问题，这些数据有一定的量来训练，而广告场景的长尾数据问题依然没有解决。因此我们很自然地把Wide侧增加了进去，模型示意图如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8576388888888888&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmGfqHZDLh89946DHKibQqM26LHTWiaaLECluIHpxD78IfqSM7t0vZq1YQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;864&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Wide的加入，使得长尾数据的记忆能力得到了一定的加强，线下AUC和线上效果都有一定的提升，虽然提升量不算太大，但为人工特征工程提供了可能。这是我们现在的线上模型（2020年10月）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面介绍一些我们对深度模型做的优化点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5. 激活函数的优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在优化DeepFM的过程中，最初Deep模型的隐藏层激活函数用的是ReLU，但我们发现Deep侧不起作用，进一步发现隐藏层的很多输出为0。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.24742268041237114&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmAZuarfAXfoLf0srUcicmVutvIOhWicEDupPkKWsYqc9VZHmtkZXlxicYw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;388&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从ReLU函数的定义可以知道，负梯度时该ReLU单元会被置为0，这是它单侧抑制的能力。但由于我们的数据特点，ReLU的这个特点变成了局限，在训练过程中导致大量神经元不可逆死亡，进而使大量参数无法更新，从而训练过程失败。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;后来我们把激活函数换成了PReLU，公式如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.23834196891191708&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmZHR6U20T2RsBnqlf8x40QrrTSoXzA2fzJURvhLIqZVKzxXnVgwaSNg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;386&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当x小于0时，用了一个很小的正数a实现一个斜率为a的线性函数ax，这样既实现了单侧抑制功能，又不至于导致大量神经元不可逆死亡。a可以作为网络中的参数通过训练更新。当a=0时，PReLU退化成ReLU；如果a是一个固定值，则PReLU退化成Leaky ReLU（LReLU）。BP更新a时，采用的是带动量的更新方式：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.294478527607362&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmd2koSXia6cIkyoiaSO8SyicxyysZ85sDT6gO6cxljOGUhPHhEqoDibrn5w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;326&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ReLU和PreLU的函数曲线图对比如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4236111111111111&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmkKw3KYc7M5jUiaVfFUwAMU0iaAhFwSEvyKrkr3Tk28gpvCZWOYibicAiaibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;864&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;采用PReLU作为激活函数之后，解决了神经元死亡的问题，AUC提升了千分之五。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;6. 递减学习率和Batch size的优化&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们使用adam优化器，学习率初始值设置为 a，之后每n步降低0.96，AUC提升了千分之二。我们的Batch size设置为10000，比起很多公司的CTR场景设置来说偏大，主要是由于我们很多场景的CTR是千分位，需要考虑每个batch里有一定数据的正样本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8775894538606404&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOVbl8Zyp2CbB2KRECOnolVmP0rGNSOzZ0lHib3A44JThfN2qUD34j6s6qjWZLq8kYU3Ik7lvZRiazgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;531&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上图看到，太高的学习率会导致不收敛或者震荡，太低的学习率则收敛速度太慢，递降的学习率一开始比较大可以让模型快速收敛，后面逐步减少则可以精确收敛。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;7. 缺失值处理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于我们的数据稀疏，很多属性和特征的覆盖率不高，经常会存在样本中域缺失的情况。我们给缺失的域一个单独的Embedding向量，使缺失值不对该域其他的Embedding向量产生影响。处理流程如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; x1缺失:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  x’= w1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  x’= w2 * x1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;x’作为Embedding向量输入模型。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;8. 深度模型时代，特征工程依然重要&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;深度模型时代并非不需要特征工程了，尽量理论上说DNN能够拟合任意函数，但那只是理论上的，前提是有稠密的数据、充足的样本、足够长的训练时间。而现实中上述条件可能一项都不具备，因此在如何让模型更有效率训练这个问题上，需要考虑不同数据的特点，比如图像处理需要用CNN，时序处理用RNN，广告及推荐场景可能用DeepFM，DCN，DIN等，都是在采用更适合的模型来做“特征工程”，找到适合自己数据特征的交叉方式来提升训练的有效性。另外在对长尾数据的处理方面，依然把浅层模型融合进来，把之前有效的人工组合特征工程继续用上。深层浅层学习结合起来提升效果，目前看起来还比较有效。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;6&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p hm_fix=&quot;360:461&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;优化建议&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们在算法改进的过程中遇到了非常多的问题，上面只是列了其中的一部分。我认为最重要的是做事方法，正确的方法可以少走弯路，对此我有三点建议：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;抓住本源。采用的数据要能真实反应用户的意图，并且数据一定要正确，这是所有后续工作的基础。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;围绕解决业务问题去思考和创新。别人的方法只能参考，每个业务的特点不同，数据分布肯定也不一样，必须要针对自己的业务和数据特点做优化。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;看细节。从细节中去找问题和找改进点，CASE分析很重要，否则容易高来高去不接地气。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;网易有数为云音乐广告变现业务提供一站式机器学习平台服务，欢迎点击“阅读原文”了解产品。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101582&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;作者简介&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p hm_fix=&quot;322:369&quot;&gt;&lt;span&gt;Neil，网易云音乐营收技术负责人，曾任百度国际移动广告平台技术负责人，十多年互联网行业经验，专注于广告算法和后端系统架构。获北京大学学士学位，马里兰大学硕士学位。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIwNTUxNTI1Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOV4Bfic2e5zqTMCl0XxmMuVq1XpDOBrbXicVB4KmrEXglsWcnMREoQXfX24sscdvQIR74ic3SiciaLoMFA/0?wx_fmt=png&quot; data-nickname=&quot;网易有数&quot; data-alias=&quot;Youdata_Netease&quot; data-signature=&quot;网易有数是网易数帆旗下大数据技术与服务品牌，以“数据价值”为导向，聚焦于企业 “看数”、“管数”、“用数”等业务场景，提供全链路大数据技术及产品服务，致力于盘活企业数据生产力，加速实现数字化转型。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;__bg_gif rich_pages wxw-img&quot; data-fileid=&quot;100003451&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/sYBGQlzfEOXECeWKgyIia3c7bom7Ir4rh4qI4XdxuRW4lyHudFyglytmLrOM4yYOWs3XNqqj0XlXTEw8icZ2Eb1Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;317:401&quot;&gt;分享，点赞，在看，安排一下？&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4a2ecfd101c9a8b157a7eded7768cf07</guid>
<title>腾讯课堂 H5 直播间点赞动效实现</title>
<link>https://toutiao.io/k/s9wmei7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section class=&quot;mp_profile_iframe_wrp&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU2Mzk1NzkwOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ibpVQtdHw0UaW5glBQ3RRqy8rYolxkF0tOaAqTUGW9MXPIGvLUGAJ7jB2JicLxJd6xvvWicThNSWFgg/0?wx_fmt=png&quot; data-nickname=&quot;趣谈前端&quot; data-alias=&quot;beautifulFront&quot; data-signature=&quot;徐小夕【知乎专栏作家】掘金签约作者，定期分享前端工程化，可视化，企业实战项目知识，深度复盘企业中经常遇到的500+技术问题解决方案。【关注趣谈前端，前端路上不迷茫】&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;职业规划&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;高级前端&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;可视化低代码&lt;/span&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;点击上方 &lt;strong&gt;趣谈前端&lt;/strong&gt;&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;，关注公众号&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回复&lt;/span&gt;&lt;span&gt;&lt;span&gt;进群&lt;/span&gt;&lt;/span&gt;&lt;span&gt;，加入前端交流群&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;1. 前言&lt;/strong&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;以前在看微信视频号直播的时候，经常点击右下角的点赞按钮。看着它的数字慢慢从一位数变成五位数，还是挺有氛围感的。特别是长按的时候，有个手机震动的反馈，很带感。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.14375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnZAVNKXV6pohRgZHxYe68hicnejt0jqiaJQ4Dr9FLdJFJicb199s9RcOrQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;320&quot;/&gt;&lt;/p&gt;&lt;p&gt;虽然之前很好奇这些飘动的点赞动效是怎么实现的，但没有特别去钻研。直到前阵子投入腾讯课堂 H5 直播间的需求，需要自己去实现一个这样的效果时，才开始摸索。&lt;/p&gt;&lt;p&gt;先看看最后的效果：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.7890625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnNYSbDhHmnWxASR45B7zGmFbnRjsiaolyCEXj9trb2XI35UzMNlibbZpg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;256&quot;/&gt;&lt;/p&gt;&lt;p&gt;相比视频号的点赞动效，轨迹复杂了很多。可以看到课堂直播间的这一段点赞动效，大概分为这么三个阶段：&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;从无到有，在上升过程中&lt;strong&gt;放大&lt;/strong&gt;成正常大小&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;上升过程中&lt;strong&gt;左右摇曳&lt;/strong&gt;，且&lt;strong&gt;摇曳的幅度随机&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;左右摇曳上升的过程中，&lt;strong&gt;渐隐并缩小&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;p&gt;在动手之前，我先想到了使用 &lt;strong&gt;CSS animation&lt;/strong&gt; 去实现这种运动轨迹。在完成之后，又用 &lt;strong&gt;Canvas&lt;/strong&gt; 重构了一版，优化了性能。&lt;/p&gt;&lt;p&gt;接下来我们分别来看看这两种实现方式。&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;2. CSS 实现点赞动效&lt;/strong&gt;&lt;/h2&gt;&lt;h3&gt;&lt;strong&gt;2.1 轨迹分析&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;由于点赞动画是在一个二维平面上的，我们可以将它的运动轨迹拆分为 &lt;strong&gt;x 轴&lt;/strong&gt; 和 &lt;strong&gt;y 轴&lt;/strong&gt; 上的两段。&lt;/p&gt;&lt;p&gt;在 &lt;strong&gt;y 轴&lt;/strong&gt; 上非常简单，我们的点赞图标会做一段&lt;span&gt;垂直上升的&lt;/span&gt;匀速运动，从容器底部上升到容器顶部。&lt;/p&gt;&lt;p&gt;而 &lt;strong&gt;x 轴&lt;/strong&gt; 上是左右摇曳的，用数学的角度说，是一段简谐运动。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5864485981308412&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3Cn2ZYgnv2KkzoW2WoNHFD5PSDsaAiabyfxA6qK8MwRfyWWL1U0Ab8M0Ow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;428&quot;/&gt;&lt;/p&gt;&lt;p&gt;但用 css 实现的时候，其实不用这么精细。为了简化计算，我们可以用几个关键帧来串联这段运动轨迹，例如：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;@keyframes&lt;/strong&gt;&lt;/span&gt; bubble_swing {&lt;br/&gt;  &lt;span&gt;0%&lt;/span&gt; {&lt;br/&gt;    中间&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;25%&lt;/span&gt; {&lt;br/&gt;    最左&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;75%&lt;/span&gt; {&lt;br/&gt;    最右&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;100%&lt;/span&gt; {&lt;br/&gt;    中间&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;2.2 轨迹设计&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;根据上面的分析，我们可以设计一段相同的上升轨迹，以及几段不同的左右摇曳轨迹。&lt;/p&gt;&lt;p&gt;上升轨迹很简单，&lt;span&gt;同时&lt;/span&gt;我们还可以加上透明度（opacity）、大小（transform）的变化，如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;@keyframes&lt;/strong&gt;&lt;/span&gt; bubble_y {&lt;br/&gt;  &lt;span&gt;0%&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;transform&lt;/span&gt;: &lt;span&gt;scale&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;margin-bottom&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;5%&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;transform&lt;/span&gt;: &lt;span&gt;scale&lt;/span&gt;(&lt;span&gt;1.5&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;80%&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;transform&lt;/span&gt;: &lt;span&gt;scale&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;100%&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;margin-bottom&lt;/span&gt;: &lt;span&gt;var&lt;/span&gt;(--cntHeight);&lt;br/&gt;    &lt;span&gt;transform&lt;/span&gt;: &lt;span&gt;scale&lt;/span&gt;(&lt;span&gt;0.8&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中，--cntHeight 指的是容器的高度。也就是说，我们通过让 margin-bottom 不断增大，来控制点赞图标从容器底部上升到容器顶部。&lt;/p&gt;&lt;p&gt;而对于横向运动的轨迹，为了增加运动轨迹的多样性，我们&lt;span&gt;可&lt;/span&gt;&lt;span&gt;以设计多段&lt;/span&gt;左右摇曳的轨迹，比如说一段 “中间 -&amp;gt; 最左 -&amp;gt; 中间 -&amp;gt; 最右” 的轨迹：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;@keyframes&lt;/strong&gt;&lt;/span&gt; bubble_swing_1 {&lt;br/&gt;  &lt;span&gt;0%&lt;/span&gt; {&lt;br/&gt;    // 中间&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;25%&lt;/span&gt; {&lt;br/&gt;    // 最左&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: -&lt;span&gt;12px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;75%&lt;/span&gt; {&lt;br/&gt;    // 最右&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;12px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;100%&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里同样使用 margin 来控制图标的左右移动。类似的，我们还可以设计几段别的轨迹：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 任意轨迹&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;@keyframes&lt;/strong&gt;&lt;/span&gt; bubble_swing_2 {&lt;br/&gt;  0% {&lt;br/&gt;    &lt;span&gt;// 中间&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  33% {&lt;br/&gt;    &lt;span&gt;// 最左&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: -&lt;span&gt;12px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  100% {&lt;br/&gt;    &lt;span&gt;// 随机位置&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;6px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 简谐反向&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;@keyframes&lt;/strong&gt;&lt;/span&gt; bubble_swing_3 {&lt;br/&gt;  0% {&lt;br/&gt;    &lt;span&gt;// 中间&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  25% {&lt;br/&gt;    &lt;span&gt;// 最右&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;12px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  75% {&lt;br/&gt;    &lt;span&gt;// 最左&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: -&lt;span&gt;12px&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  100% {&lt;br/&gt;    &lt;span&gt;margin-left&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来我们把 &lt;strong&gt;x 轴&lt;/strong&gt; 和 &lt;strong&gt;y 轴&lt;/strong&gt; 的轨迹（@keyframes）结合起来，并设置一个随机的动画时间，比如说：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;@for&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;$i&lt;/span&gt; from &lt;span&gt;1&lt;/span&gt; through &lt;span&gt;3&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;@for&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;$j&lt;/span&gt; from &lt;span&gt;1&lt;/span&gt; through &lt;span&gt;2&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;.bl_&lt;/span&gt;#{&lt;span&gt;$i&lt;/span&gt;}_#{&lt;span&gt;$j&lt;/span&gt;} {&lt;br/&gt;      &lt;span&gt;animation&lt;/span&gt;: bubble_y calc(&lt;span&gt;1.5s&lt;/span&gt; + &lt;span&gt;$j&lt;/span&gt; * &lt;span&gt;0.5s&lt;/span&gt;) linear &lt;span&gt;1&lt;/span&gt; forwards,&lt;br/&gt;        bubble_swing_#{&lt;span&gt;$i&lt;/span&gt;} calc(&lt;span&gt;1.5s&lt;/span&gt; + &lt;span&gt;$j&lt;/span&gt; * &lt;span&gt;0.5s&lt;/span&gt;) linear &lt;span&gt;1&lt;/span&gt; forwards;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里生成了 3 * 2 = 6 种不同的轨迹。针对这类重复的选择器，用 SCSS 中的循环语法，可以少写很多代码。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;2.3 随机选择图片（雪碧图）&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;我们每次点赞会出现不同的图标，于是这里设计了一系列选择器给不同的图标，让它们呈现不同的图片。首先我们要准备一张雪碧图，保持所有图标的大小一致，然后同样使用 SCSS 的循环语法：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;@for&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;$i&lt;/span&gt; from &lt;span&gt;0&lt;/span&gt; through &lt;span&gt;7&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;.b&lt;/span&gt;#{&lt;span&gt;$i&lt;/span&gt;} {&lt;br/&gt;    &lt;span&gt;background&lt;/span&gt;: url(&lt;span&gt;&#x27;../../images/like_sprites.png&#x27;&lt;/span&gt;) calc(#{&lt;span&gt;$i&lt;/span&gt;} * -&lt;span&gt;24px&lt;/span&gt;) &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;像上面生成了 8 个选择器，我们在程序执行时就可以随机给图标赋予一个选择器。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;2.4 生成一个点赞图标&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;CSS 的部分差不多了，我们现在来看 JS 是怎么执行的。我们需要有一个容器 div，让它来装载要生成的点赞图标。以及一个按钮来绑定点击事件：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;const cacheRef = useRef&amp;lt;LikeCache&amp;gt;({&lt;br/&gt;    bubbleCnt: &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;    likeIcon: &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;    bubbleIndex: &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;    timer: &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;});&lt;br/&gt;&lt;br/&gt;useEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    cacheRef.current.bubbleCnt = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;like-bubble-cnt&#x27;&lt;/span&gt;);&lt;br/&gt;    cacheRef.current.likeIcon = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;like-icon&#x27;&lt;/span&gt;);&lt;br/&gt;}, []);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在点击事件中，生成一个新的 div 元素，并为它设置 className。接着将它 append 到容器下，最后在一段时间后销毁这个点赞图标元素。如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 添加 bubble&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; addBubble = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; { bubbleCnt } = cacheRef.current;&lt;br/&gt;&lt;br/&gt;  cacheRef.current.bubbleIndex %= maxBubble;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; d = &lt;span&gt;document&lt;/span&gt;.createElement(&lt;span&gt;&#x27;div&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 图片类 b0 - b7&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 随机动画类 bl_1_1 - bl_3_2&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; swing = &lt;span&gt;Math&lt;/span&gt;.floor(&lt;span&gt;Math&lt;/span&gt;.random() * &lt;span&gt;3&lt;/span&gt;) + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; speed = &lt;span&gt;Math&lt;/span&gt;.floor(&lt;span&gt;Math&lt;/span&gt;.random() * &lt;span&gt;2&lt;/span&gt;) + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  d.className = &lt;span&gt;`like-bubble b&lt;span&gt;${cacheRef.current.bubbleIndex}&lt;/span&gt; bl_&lt;span&gt;${swing}&lt;/span&gt;_&lt;span&gt;${speed}&lt;/span&gt;`&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  bubbleCnt?.appendChild(d);&lt;br/&gt;  cacheRef.current.bubbleIndex++;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 动画结束后销毁元素&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;setTimeout&lt;/span&gt;(&lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    bubbleCnt?.removeChild(d);&lt;br/&gt;  }, &lt;span&gt;2600&lt;/span&gt;);&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;到这里，我们就实现得差不多了。不过，我们还可以给点击的图标加点动画，让它有一个被按压后弹起的效果：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 点击“喜欢”&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; onClick = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; { timer, likeIcon } = cacheRef.current;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (!likeIcon) {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (timer) {&lt;br/&gt;    &lt;span&gt;clearTimeout&lt;/span&gt;(timer);&lt;br/&gt;    cacheRef.current.timer = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  likeIcon.classList.remove(&lt;span&gt;&#x27;bounce-click&#x27;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;// 删除并重新添加类，需要延迟添加&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;setTimeout&lt;/span&gt;(&lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    likeIcon.classList.add(&lt;span&gt;&#x27;bounce-click&#x27;&lt;/span&gt;);&lt;br/&gt;  }, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;  cacheRef.current.timer = &lt;span&gt;window&lt;/span&gt;.setTimeout(&lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    likeIcon.classList.remove(&lt;span&gt;&#x27;bounce-click&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;clearTimeout&lt;/span&gt;(timer!);&lt;br/&gt;    cacheRef.current.timer = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  }, &lt;span&gt;300&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  addBubble();&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;2.5 最终效果&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;最后来看看效果吧！&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.3728813559322033&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnKMM9EDicGnPXbFbLpMNpr4JMGcT53f2hbKZjW68KbtSACvXxibu3gI3g/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;177&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;3. Canvas 实现点赞动效&lt;/strong&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;我们都知道 Canvas 的绘制更流畅一些，能够带来更好的体验。但苦于编码比较复杂，也有一定的学习成本，实现起来要比 CSS 复杂不少。&lt;/p&gt;&lt;p&gt;接下来我们看看基于 &lt;span&gt;C&lt;/span&gt;&lt;span&gt;anvas&lt;/span&gt; 的点赞动效实现。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;3.1 画布创建&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;首先我们读取一个 &lt;span&gt;C&lt;/span&gt;&lt;span&gt;anvas&lt;/span&gt; 元素的 id，并通过 getContext 获取它的上下文。除此之外，还传入了一个 canvasScale，指的是画布放大的比例，这个在之后会用到：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;constructor&lt;/strong&gt;&lt;/span&gt;(&lt;span&gt;canvasId: string, canvasScale: number&lt;/span&gt;)&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; canvas = &lt;span&gt;document&lt;/span&gt;.getElementById(canvasId) &lt;span&gt;&lt;strong&gt;as&lt;/strong&gt;&lt;/span&gt; HTMLCanvasElement;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.context = canvas.getContext(&lt;span&gt;&#x27;2d&#x27;&lt;/span&gt;)!;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.width = canvas.width;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.height = canvas.height;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.canvasScale = canvasScale;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.img = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.loadImages();&lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.2 预加载图片（雪碧图）&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;在 constructor 这里，我们还通过 loadImages 这个函数，预加载了雪碧图：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;import&lt;/strong&gt;&lt;/span&gt; likeSprites &lt;span&gt;&lt;strong&gt;from&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&#x27;../../images/like_sprites.png&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 预加载图片&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;loadImages = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; p = &lt;span&gt;&lt;strong&gt;new&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve: (image: HTMLImageElement) =&amp;gt; &lt;span&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; img = &lt;span&gt;&lt;strong&gt;new&lt;/strong&gt;&lt;/span&gt; Image();&lt;br/&gt;    img.onerror = &lt;span&gt;() =&amp;gt;&lt;/span&gt; resolve(img);&lt;br/&gt;    img.onload = &lt;span&gt;() =&amp;gt;&lt;/span&gt; resolve(img);&lt;br/&gt;    img.src = likeSprites;&lt;br/&gt;  });&lt;br/&gt;  p.then(&lt;span&gt;(&lt;span&gt;img&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (img &amp;amp;&amp;amp; img.width &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.img = img;&lt;br/&gt;    } &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;// error(&#x27;[live-connect]预加载喜欢动效图片失败&#x27;);&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  });&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.3 轨迹拆解&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;同样的，我们需要从 Canvas 的视角来拆解点赞图标的运动轨迹。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;y 轴&lt;/strong&gt; 的运动和 CSS 一样，我们知道起始位置和终止位置就可以得出。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;x 轴&lt;/strong&gt; 的运动可以好好推敲。由于 Canvas 是逐帧绘制的，我们可以模拟出一个比较逼真的简谐运动。这里要来讲一讲大家耳熟能详的初中数学了，下面是我们要使用的一条正弦函数的公式：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;y = A sin(Bx + C) + D&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参数说明：&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;振幅是 &lt;strong&gt;A&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;周期是 &lt;strong&gt;2π/B&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;相移是 &lt;strong&gt;−C/B&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;垂直移位是 &lt;strong&gt;D&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;套入点赞动效：&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;赋予图标元素随机的振幅 A。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;赋予图标元素随机的周期，即 B 是随机的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;取 C = 0，即相移为 0。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;取 D = 0，即不需要垂直移位。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;y = A sinBx。&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.4 横竖位移计算&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;确定位移轨迹之后，我们先定义一些常量，如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/** 图片显示宽高 */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; IMAGE_WIDTH = &lt;span&gt;30&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/** 图片原始宽高 */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; SOURCE_IMAGE_WIDTH = &lt;span&gt;144&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/** 图片数量 */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; IMG_NUM = &lt;span&gt;8&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/** 放大阶段（百分比）*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; ENLARGE_STAGE = &lt;span&gt;0.1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/** 收缩渐隐阶段（百分比）*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; FADE_OUT_STAGE = &lt;span&gt;0.8&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先我们可以设计 &lt;strong&gt;x 轴&lt;/strong&gt; 和 &lt;strong&gt;y 轴&lt;/strong&gt; 两个方向上的位移计算函数，函数参数 progress 是 0 到 1 之间的数值，表示一个过程量（0 -&amp;gt; 1）。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 起始位置&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; basicX = &lt;span&gt;this&lt;/span&gt;.width / &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 正弦频率&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; frequency = random(&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 正弦振幅&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; amplitude = random(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;20&lt;/span&gt;) * (random(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) ? &lt;span&gt;1&lt;/span&gt; : -&lt;span&gt;1&lt;/span&gt;) * &lt;span&gt;this&lt;/span&gt;.canvasScale;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 获取横向位移（x轴）&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; getTranslateX = &lt;span&gt;(&lt;span&gt;progress: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (progress &amp;lt; ENLARGE_STAGE) {&lt;br/&gt;    &lt;span&gt;// 放大期间，不进行摇摆位移&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; basicX;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; basicX + amplitude * &lt;span&gt;Math&lt;/span&gt;.sin(frequency * (progress - ENLARGE_STAGE));&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 获取竖向位移（y轴）&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; getTranslateY = &lt;span&gt;(&lt;span&gt;progress: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; IMAGE_WIDTH / &lt;span&gt;2&lt;/span&gt; + (&lt;span&gt;this&lt;/span&gt;.height - IMAGE_WIDTH / &lt;span&gt;2&lt;/span&gt;) * (&lt;span&gt;1&lt;/span&gt; - progress);&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.5 大小和透明度计算&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;要绘制的图标大小怎么控制呢？在 Canvas 中，其实就是计算一个 scale，表示放缩的比例。&lt;/p&gt;&lt;p&gt;我们根据放大/收缩阶段的过程常量和 progress 变量来调节它的大小。起始阶段先线性放大至 1，最后阶段再线性缩小至 0。&lt;/p&gt;&lt;p&gt;透明度同理，在消失之前都是返回 1，其余时刻线性缩小。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 获取放缩比例&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; getScale = &lt;span&gt;(&lt;span&gt;progress: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;let&lt;/strong&gt;&lt;/span&gt; r = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (progress &amp;lt; ENLARGE_STAGE) {&lt;br/&gt;    &lt;span&gt;// 放大&lt;/span&gt;&lt;br/&gt;    r = progress / ENLARGE_STAGE;&lt;br/&gt;  } &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (progress &amp;gt; FADE_OUT_STAGE) {&lt;br/&gt;    &lt;span&gt;// 缩小&lt;/span&gt;&lt;br/&gt;    r = (&lt;span&gt;1&lt;/span&gt; - progress) / (&lt;span&gt;1&lt;/span&gt; - FADE_OUT_STAGE);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; r;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 获取透明度&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; getAlpha = &lt;span&gt;(&lt;span&gt;progress: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (progress &amp;lt; FADE_OUT_STAGE) {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;return &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt; - (progress - FADE_OUT_STAGE) / (&lt;span&gt;1&lt;/span&gt; - FADE_OUT_STAGE);&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.6 Canvas 绘制&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;绘制时，我们先挑选一张图片。如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// 按顺序读取图片&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; { curImgIndex } = &lt;span&gt;&lt;strong&gt;this&lt;/strong&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 更新顺序&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;this&lt;/strong&gt;&lt;/span&gt;.curImgIndex = ++&lt;span&gt;&lt;strong&gt;this&lt;/strong&gt;&lt;/span&gt;.curImgIndex % IMG_NUM;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;strong&gt;3.6.1 画布元素清晰度&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;接下来需要用到我们之前提到的 canvasScale 了：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; newWidth = IMAGE_WIDTH * &lt;span&gt;this&lt;/span&gt;.canvasScale;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为什么这里要乘以一个 canvasScale 呢？因为 Canvas 是&lt;strong&gt;位图模式&lt;/strong&gt;的，它会根据设备的 &lt;strong&gt;dpi&lt;/strong&gt; 来渲染图片。&lt;/p&gt;&lt;p&gt;首先先介绍一下高分屏的概念：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;高分屏：在同样大小的屏幕面积上显示更多的像素点，也就是更多的可视信息。常见的就是 SXGA（1400 * 1050），UXGA（1600 * 1200）。1024 * 768 分辨率的屏幕叫普通屏，也就是 XGA 的屏幕，这个分辨率以上的屏幕叫高分屏。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在高分屏上，每平方英寸会有更多的像素。原来在普通屏上绘制的 1 个像素，为了适应高分屏，被迫放大，变成了 4 个像素或者更多。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;可以想象成，一张清晰度正常的普通图片为了布满整个背景被强行放大 n 倍，所以看起来模糊了&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7434869739478958&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnbPNrjWlfSpuw7eSdysHUzPsroUKbjBBCf0f6Ik4MAkF99lOAqf1gRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;499&quot;/&gt;&lt;/p&gt;&lt;p&gt;为了解决这个问题，就需要我们将绘制的图片放大。同时还要控制 Canvas 画布在 CSS 中的宽高。做到绘制内容变大的同时，画布依然呈现原来的大小。这样一来，图片就会因为绘制了更多的内容，而在高分屏上变得清晰且细腻。&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;3.6.2 绘制元素&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;绘制我们用到了 drawImage。在调用它之前，我们需要&lt;span&gt;根据计算出的 translateX 和 translateY，&lt;/span&gt;&lt;span&gt;调&lt;/span&gt;&lt;span&gt;整绘制的起&lt;/span&gt;&lt;span&gt;点&lt;/span&gt;。并且调整放缩比例和透明度，即 &lt;code&gt;context.scale()&lt;/code&gt; 和 &lt;code&gt;context.globalAlpha&lt;/code&gt;。如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;(&lt;span&gt;progress: number&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 动画过程 0 -&amp;gt; 1&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (progress &amp;gt;= &lt;span&gt;1&lt;/span&gt;) &lt;span&gt;&lt;strong&gt;return &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  context.save();&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; scale = getScale(progress);&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; translateX = getTranslateX(progress);&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; translateY = getTranslateY(progress);&lt;br/&gt;  context.translate(translateX, translateY);&lt;br/&gt;  context.scale(scale, scale);&lt;br/&gt;  context.globalAlpha = getAlpha(progress);&lt;br/&gt;  context.drawImage(&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.img!,&lt;br/&gt;    SOURCE_IMAGE_WIDTH * curImgIndex,&lt;br/&gt;    &lt;span&gt;0&lt;/span&gt;,&lt;br/&gt;    SOURCE_IMAGE_WIDTH,&lt;br/&gt;    SOURCE_IMAGE_WIDTH,&lt;br/&gt;    -newWidth / &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt;    -newWidth / &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt;    newWidth,&lt;br/&gt;    newWidth,&lt;br/&gt;  );&lt;br/&gt;  context.restore();&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;strong&gt;3.6.3 创建绘制实例&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;我们用一个 start 函数来生成点赞动画，每当调用它时，都会创建一个 render 方法，并塞入一个 renderList。renderList 中存放的就是当前所有点赞图标的绘制任务。如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;start = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; render = &lt;span&gt;this&lt;/span&gt;.createRender();&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; duration = random(&lt;span&gt;2100&lt;/span&gt;, &lt;span&gt;2600&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (!render) {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.renderList.push({&lt;br/&gt;    render,&lt;br/&gt;    duration,&lt;br/&gt;    &lt;span&gt;timestamp&lt;/span&gt;: &lt;span&gt;Date&lt;/span&gt;.now(),&lt;br/&gt;  });&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.scanning) {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.scanning = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    requestAnimationFrame(&lt;span&gt;this&lt;/span&gt;.scan);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;return &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;;&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;strong&gt;3.6.4 实时绘制&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;知道了需要绘制哪些对象之后，就需要通过下面的 scan 方法，让 Canvas 在每一帧都去绘制内容。&lt;/p&gt;&lt;p&gt;每次绘制分为这么几个过程：&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;清空画布为透明。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;从绘制列表中取出一个点赞图标的 render 方法，并调用它。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;假如它返回了 true，代表点赞图标已经完整经历了整个动效的过程，需要将它从绘制列表中剔除出去。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;重复 2、3 过程，直至列表中没有任务需要执行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;requestAnimationFrame&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 调用 scan 方法自身，等待下一帧重新调用 scan 绘制内容。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;pre&gt;&lt;code&gt;scan = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.context.clearRect(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.width, &lt;span&gt;this&lt;/span&gt;.height);&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;let&lt;/strong&gt;&lt;/span&gt; index = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;let&lt;/strong&gt;&lt;/span&gt; { length } = &lt;span&gt;this&lt;/span&gt;.renderList;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (length &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    requestAnimationFrame(&lt;span&gt;this&lt;/span&gt;.scan);&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.scanning = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  } &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.scanning = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;while&lt;/strong&gt;&lt;/span&gt; (index &amp;lt; length) {&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; child = &lt;span&gt;this&lt;/span&gt;.renderList[index];&lt;br/&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;/span&gt; (!child || !child.render || child.render.call(&lt;span&gt;null&lt;/span&gt;, (&lt;span&gt;Date&lt;/span&gt;.now() - child.timestamp) / child.duration)) {&lt;br/&gt;      &lt;span&gt;// 结束了，删除该动画&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;this&lt;/span&gt;.renderList.splice(index, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;      length--;&lt;br/&gt;    } &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;/span&gt; {&lt;br/&gt;      index++;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;};&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;3.7 调用&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;接下来我们只需要在点击的时候，调用一下 &lt;code&gt;start&lt;/code&gt; 方法即可。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 点击“喜欢”&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;const&lt;/strong&gt;&lt;/span&gt; onClick = &lt;span&gt;() =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  cacheRef.current.LikeAni?.start?.();&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;/span&gt; (&lt;br/&gt;  &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;{cn(&lt;/span&gt;&#x27;&lt;span&gt;like-wrap&lt;/span&gt;&#x27;, &lt;span&gt;className&lt;/span&gt;)}&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;canvas&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;{CANVAS_ID}&lt;/span&gt; &lt;span&gt;width&lt;/span&gt;=&lt;span&gt;{CANVAS_WIDTH}&lt;/span&gt; &lt;span&gt;height&lt;/span&gt;=&lt;span&gt;{CANVAS_HEIGHT}&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;like-bubble-cnt&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;{cn(&lt;/span&gt;&#x27;&lt;span&gt;like-icon-cnt&lt;/span&gt;&#x27;, &lt;span&gt;className&lt;/span&gt;)} &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{onClick}&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;i&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;like-icon&quot;&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;like-icon&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;);&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在直播场景下，还有很多不同的触发方式。除了自己点击，我们还可以接受来自其他用户的反馈（网络请求）来触发&lt;span&gt; &lt;/span&gt;&lt;code&gt;start&lt;/code&gt;&lt;span&gt; 方法&lt;/span&gt;。或者根据在线人数，多次调用 &lt;code&gt;start&lt;/code&gt; 方法来生成一定数量的点赞图标。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;3.8 最终效果&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;2.3728813559322033&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnYP7LBJLR62gxgcnGSICWb4VWTXCy1PFJEvticiaLXO5TWh19eA5M2xZQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;177&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;4. 性能比较&lt;/strong&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;以下内容是在 MacBook Pro 16 的屏幕上测试的。&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;4.1 Frame Rendering Stats&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;在 chrome devtools 中，有两个小功能可以来观察我们绘制的性能情况：&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;这两个功能，可以在 chrome devtools 中使用快捷键 Command + Shift + P，呼起命令搜索的 Panel 来搜索到。&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;CSS 性能&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;我们可以看到高亮区域在频繁闪动，以及 GPU 内存的使用比率较高，这是因为 CSS 的实现方式是不断生成新的元素（并在随后销毁），会消耗更多的内存。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0235690235690236&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3Cn61PuKHuVcJY64I0ciaw5Yib7aKR0QeczWS6w7Vov2EtcKhruOHEXIuAw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;297&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Canvas 性能&lt;/strong&gt;&lt;br/&gt;&lt;/h4&gt;&lt;p&gt;相反，Canvas 是集中在画布上绘制并输出的，不会反复创建和销毁元素。会比 CSS 的实现更加流畅，性能更好一点。&lt;/p&gt;&lt;p&gt;除了流畅以外，Canvas 还能够放大画布和画布元素，这也是一个非常重要的优势。这意味着 Canvas 能够绘制出更清晰的内容，生成出来的点赞图标更加细腻。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0235690235690236&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CneXgmLZDgbvcd17KZ2etPibicNN9GTMoSaib6cFxiaHuCRAlrB4tkvuibrLw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;297&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;4.2 Performance&lt;/strong&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;在 chrome devtools 中切换到 Performance 面板，还可以观察动画绘制过程中，页面的一些性能指标。&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;CSS 性能&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;CSS 的实现之所以看起比较卡顿，主要是因为绘制任务太频繁。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1705790297339593&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnUB3NiciafG8nmTuKibbRQ4OKZVeJicHbvMxclwKsmicZ6k6jQwumiaFCb9Wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1278&quot;/&gt;&lt;/p&gt;&lt;p&gt;具体到每一帧，我们可以观察到 LayoutShift 的警告。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.50431654676259&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3Cnh2hVHf4azOrrBKM4A1mHibNyeGI0x6ad3ze5OtdPuPBZuBQ5ogzfYaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1390&quot;/&gt;&lt;/p&gt;&lt;p&gt;每次可视元素在两次渲染帧中的起始位置不同时，就说是发生了 LS（Layout Shift）。&lt;strong&gt;改变了起始位置的元素被认为是不稳定元素&lt;/strong&gt;。&lt;/p&gt;&lt;h4&gt;&lt;strong&gt;Canvas 性能&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;Canvas 实现的性能情况看起来就比较正常，即使绘制清晰一些的图片也不在话下。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0332409972299168&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xsw6Lt5pDCvGbVh9zOW0l3yibU3vLq3CnKibqyoXGwzYP3IPzDj3bfosticSBNhal4Nr1rrz5HjibvRDqsJ1kHT5iag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1444&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;5. 相关&lt;/strong&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;实现参考：&lt;a class=&quot;weapp_text_link&quot; data-miniprogram-appid=&quot;wxae224e32990b0036&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-path=&quot;pages/a?link=https%3A%2F%2Fgithub.com%2Fantiter%2Fpraise-animation&amp;amp;title=&quot; href=&quot;&quot;&gt;https://github.com/antiter/praise-animation&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;更多推荐&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;点个在看 你最好看&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.8&quot; data-type=&quot;png&quot; data-w=&quot;50&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ImtD1PjRzRibmwqBpXL6icIKqbwdwwR26NfB89hJ09AJCorfLHxNdGlIIKr02IiajJ3O6t3qzXFXcJZ1lUxUnibTIA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3a2fc991493678f4ac8cc32ff53d1240</guid>
<title>[推荐] 面试官问: 如何设计一个高并发系统?</title>
<link>https://toutiao.io/k/7hrrplb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h2&gt;题目描述&lt;/h2&gt;

&lt;p&gt;面试官有时在面试中会直接问你：你是如何设计一个高并发系统？&lt;/p&gt;

&lt;h2&gt;面试官心理分析（解题思维方向）&lt;/h2&gt;

&lt;p&gt;说实话，如果面试官问你这个题目，那么你必须要使出全身吃奶劲了。为啥？因为你没看到现在很多公司招聘的 JD 里都是说啥，有高并发就经验者优先。&lt;/p&gt;

&lt;p&gt;如果你确实有真才实学，在互联网公司里干过高并发系统，那你确实拿 offer 基本如探囊取物，没啥问题。面试官也绝对不会这样来问你，否则他就是蠢。&lt;/p&gt;

&lt;p&gt;假设你在某知名电商公司干过高并发系统，用户上亿，一天流量几十亿，高峰期并发量上万，甚至是十万。那么人家一定会仔细盘问你的系统架构，你们系统啥架构？怎么部署的？部署了多少台机器？缓存咋用的？MQ 咋用的？数据库咋用的？就是深挖你到底是如何扛住高并发的。&lt;/p&gt;

&lt;p&gt;因为真正干过高并发的人一定知道，脱离了业务的系统架构都是在纸上谈兵，真正在复杂业务场景而且还高并发的时候，那系统架构一定不是那么简单的，用个 redis，用 mq 就能搞定？当然不是，真实的系统架构搭配上业务之后，会比这种简单的所谓“高并发架构”要复杂很多倍。&lt;/p&gt;

&lt;p&gt;如果有面试官问你个问题说，如何设计一个高并发系统？那么不好意思，一定是因为你实际上没干过高并发系统。面试官看你简历就没啥出彩的，感觉就不咋地，所以就会问问你，如何设计一个高并发系统？其实说白了本质就是看看你有没有自己研究过，有没有一定的知识积累。&lt;/p&gt;

&lt;p&gt;最好的当然是招聘个真正干过高并发的哥儿们咯，但是这种哥儿们人数稀缺，不好招。所以可能次一点的就是招一个自己研究过的哥儿们，总比招一个啥也不会的哥儿们好吧！
所以这个时候你必须得做一把个人秀了，秀出你所有关于高并发的知识！&lt;/p&gt;

&lt;h2&gt;面试题剖析&lt;/h2&gt;

&lt;p&gt;其实所谓的高并发，如果你要理解这个问题呢，其实就得从高并发的根源出发，为啥会有高并发？为啥高并发就很牛逼？&lt;/p&gt;

&lt;p&gt;我说的浅显一点，很简单，就是因为刚开始系统都是连接数据库的，但是要知道数据库支撑到每秒并发两三千的时候，基本就快完了。所以才有说，很多公司，刚开始干的时候，技术比较 low，结果业务发展太快，有的时候系统扛不住压力就挂了。&lt;/p&gt;

&lt;p&gt;当然会挂了，凭什么不挂？你数据库如果瞬间承载每秒 5000/8000，甚至上万的并发，一定会宕机，因为比如 mysql 就压根儿扛不住这么高的并发量。&lt;/p&gt;

&lt;p&gt;所以为啥高并发牛逼？就是因为现在用互联网的人越来越多，很多 app、网站、系统承载的都是高并发请求，可能高峰期每秒并发量几千，很正常的。如果是什么双十一之类的，每秒并发几万几十万都有可能。&lt;/p&gt;

&lt;p&gt;那么如此之高的并发量，加上原本就如此之复杂的业务，咋玩儿？真正厉害的，一定是在复杂业务系统里玩儿过高并发架构的人，但是你没有，那么我给你说一下你该怎么回答这个问题：&lt;/p&gt;

&lt;p&gt;可以分为以下 6 点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;系统拆分&lt;/li&gt;
&lt;li&gt;缓存&lt;/li&gt;
&lt;li&gt;MQ&lt;/li&gt;
&lt;li&gt;分库分表&lt;/li&gt;
&lt;li&gt;读写分离&lt;/li&gt;
&lt;li&gt;ElasticSearch&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;系统拆分&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;将一个系统拆分为多个子系统，用 dubbo 来搞。然后每个系统连一个数据库，这样本来就一个库，现
在多个数据库，不也可以扛高并发么。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;缓存&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;缓存，必须得用缓存。大部分的高并发场景，都是读多写少，那你完全可以在数据库和缓存里都写一
份，然后读的时候大量走缓存不就得了。毕竟人家 redis 轻轻松松单机几万的并发。所以你可以考虑考
虑你的项目里，那些承载主要请求的读场景，怎么用缓存来抗高并发。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;MQ&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;MQ，必须得用 MQ。可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统，你要是用 redis 来承载写那肯定不行，人家是缓存，数据随时就被 LRU 了，数据格式还无比简单，没有事务支持。所以该用 mysql 还得用 mysql啊。那你咋办？用 MQ 吧，大量的写请求灌入 MQ 里，排队慢慢玩儿，后边系统消费后慢慢写，控制在 mysql 承载范围之内。所以你得考虑考虑你的项目里，那些承载复杂写业务逻辑的场景里，如何用MQ 来异步写，提升并发性。MQ 单机抗几万并发也是 ok 的，这个之前还特意说过。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;分库分表&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来扛更高的并发；然后将一个表拆分为多个表，每个表的数据量保持少一点，提高 sql 跑的性能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;读写分离&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。读流量太多的时候，还可以加更多的从库。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ElasticSearch&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Elasticsearch，简称 es。es 是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来扛更高的并发。那么一些比较简单的查询、统计类的操作，可以考虑用 es 来承载，还有一些全文搜索类的操作，也可以考虑用 es 来承载。&lt;/p&gt;

&lt;p&gt;上面的 6 点，基本就是高并发系统肯定要干的一些事儿，大家可以仔细结合之前讲过的知识考虑一下，到时候你可以系统的把这块阐述一下，然后每个部分要注意哪些问题，之前都讲过了，你都可以阐述阐述，表明你对这块是有点积累的。&lt;/p&gt;

&lt;h2&gt;考题变形&lt;/h2&gt;



&lt;h2&gt;总结&lt;/h2&gt;

&lt;p&gt;其实实际上在真正的复杂的业务系统里，做高并发要远远比上面提到的点要复杂几十倍到上百倍。你需要考虑：哪些需要分库分表，哪些不需要分库分表，单库单表跟分库分表如何 join，哪些数据要放到缓存里去，放哪些数据才可以扛住高并发的请求，你需要完成对一个复杂业务系统的分析之后，然后逐步逐步的加入高并发的系统架构的改造&lt;/p&gt;

&lt;h2&gt;号外号外&lt;/h2&gt;

&lt;p&gt;给大家整理了Java最新大厂面试题及答案，并且整理成了PDF格式方便阅读。 欢迎大家关注”浅谈架构“ 公众号 (后台私信”面试“即可获取)。另外需要大厂内推同学也可以私信我。 &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.bytearch.com/images/mianshiti.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://storage.bytearch.com/images/wxgzh.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>