<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>d073a2764d4084b6a06c7240b0a44f59</guid>
<title>[推荐] 《我想进大厂》之 JVM 夺命连环 10 问</title>
<link>https://toutiao.io/k/swi8lo6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;（给&lt;/span&gt;&lt;span&gt;ImportNew&lt;/span&gt;&lt;span&gt;加星标，提高Java技能）&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;作者： 科技缪缪（本文来自作者投稿）&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 说说 JVM 的内存布局？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.37890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlaX1kzmfeFkqNiaDiar0WVkM9WqfBbh6BW3EmEgTCVCW4XbhYQGBzhSXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Java 虚拟机主要包含几个区域：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;堆&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：堆是 Java 虚拟机中最大的一块内存，是线程共享的内存区域，基本上所有的对象实例数组都是在堆上分配空间。堆区细分为 Young&lt;/span&gt;&lt;span&gt; 区年轻代和 Old 区老年代，其中年轻代又分为 Eden、S0、S1 3个部分，他们默认的比例是 8:1:1 的大小。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;栈&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：栈是线程私有的内存区域，每个方法执行的时候都会在栈创建一个栈帧，方法的调用过程就对应着栈的入栈和出栈的过程。每个栈帧的结构又包含局部变量表、操作数栈、动态连接、方法返回地址。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;局部变量表用于存储方法参数和局部变量。当第一个方法被调用的时候，它的参数会被传递至从0开始的连续的局部变量表中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;操作数栈用于一些字节码指令从局部变量表中传递至操作数栈，也用来准备方法调用的参数以及接收方法返回结果。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;动态连接用于将符号引用表示的方法转换为实际方法的直接引用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;元数据&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：在 Java1.7 之前，包含方法区的概念，常量池就存在于方法区（永久代）中，而方法区本身是一个逻辑上的概念，在1.7之后则是把常量池移到了堆内，1.8之后移出了永久代的概念(方法区的概念仍然保留)，实现方式则是现在的元数据。它包含类的元信息和运行时常量池。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;class 文件就是类和接口的定义信息。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;运行时常量池就是类和接口的常量池运行时的表现形式。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;本地方法栈&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：主要用于执行本地 native 方法的区域。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;程序计数器&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：也是线程私有的区域，用于记录当前线程下虚拟机正在执行的字节码的指令地址。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. 知道 new 一个对象的过程吗？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.40390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlOvda0KYHkCicWv9Libm8FpZgRKScK30oQxYPNIOsfMgjEvMmq8Isb6Rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当虚拟机遇见 &lt;strong&gt;new &lt;/strong&gt;关键字时候，实现判断当前类是否已经加载。如果类没有加载，首先执行类的加载机制，加载完成后再为对象分配空间、初始化等。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;首先&lt;strong&gt;校验当前类是否被加载&lt;/strong&gt;，如果没有加载，执行类加载机制；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;加载&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：就是从字节码加载成二进制流的过程；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;验证&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：当然加载完成之后，当然需要校验 class 文件是否符合虚拟机规范，跟我们接口请求一样，第一件事情当然是先做个参数校验了；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;准备&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：为静态变量、常量赋默认值；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;解析&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：把常量池中符号引用(以符号描述引用的目标)替换为直接引用(指向目标的指针或者句柄等)的过程；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;初始化&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：执行 static 代码块 (cinit) 进行初始化，如果存在父类，先对父类进行初始化。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;注意&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：静态代码块是绝对线程安全的，只能隐式被 Java 虚拟机在类加载过程中初始化调用！(此处该有问题：&lt;strong&gt;static 代码块线程安全吗？&lt;/strong&gt;)&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当类加载完成之后，紧接着就是对象分配内存空间和初始化的过程：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;首先为对象分配合适大小的内存空间；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;接着为实例变量赋默认值；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;设置对象的头信息，对象 hashcode、GC 分代年龄、元数据信息等；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;执行构造函数 (init) 初始化。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3. 知道双亲委派模型吗？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;类加载器自顶向下分为：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Bootstrap ClassLoader&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;（启动类加载器）：默认会去加载 JAVA_HOME/lib 目录下的 jar；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Extention ClassLoader&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;（扩展类加载器）：默认去加载 JAVA_HOME/lib/ext 目录下的 jar；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Application ClassLoader&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;（应用程序类加载器）：比如我们的 Web 应用，会加载 Web 程序中 ClassPath 下的类；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;User ClassLoader&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;（用户自定义类加载器）：由用户自己定义。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当我们在加载类的时候，首先都会向上询问自己的父加载器是否已经加载。如果没有则依次向上询问；如果没有加载，则从上到下依次尝试是否能加载当前类，直到加载成功。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.64609375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlZKccYiccqpOGYdIUwltUNPmmyib6Gz2W6IWH6FCIIxojeQpyjXpw6T5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;4. 说说有哪些垃圾回收算法？&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;标记-清除&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;统一标记出需要回收的对象，标记完成之后统一回收所有被标记的对象。而由于标记的过程需要遍历所有的 GC ROOT，清除的过程也要遍历堆中所有的对象，所以标记-清除算法的效率低下，同时也带来了内存碎片的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;复制算法&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了解决性能的问题，复制算法应运而生。它将内存分为大小相等的两块区域，每次使用其中的一块。当一块内存使用完之后，将还存活的对象拷贝到另外一块内存区域中，然后把当前内存清空。这样性能和内存碎片的问题得以解决。但是同时带来了另外一个问题，可使用的内存空间缩小了一半！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此，诞生了我们现在的常见的&lt;strong&gt;年轻代+老年代&lt;/strong&gt;的内存结构：Eden+S0+S1 组成。因为根据 IBM 的研究显示，98%的对象都是朝生夕死，所以实际上存活的对象并不是很多，完全不需要用到一半内存浪费，所以默认的比例是 8:1:1。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样，在使用的时候只使用 Eden 区和 S0、S1 中的一个，每次都把存活的对象拷贝另外一个未使用的 Survivor 区，同时清空 Eden 和使用的 Survivor，这样下来内存的浪费就只有10%了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果最后未使用的 Survivor 放不下存活的对象，这些对象就进入 Old 老年代了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;注意&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：所以有一些初级点的问题会问你，为什么要分为 Eden 区和2个 Survior 区？有什么作用？就是为了节省内存和解决内存碎片的问题。这些算法都是为了解决问题而产生的，如果理解原因你就不需要死记硬背了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;标记-整理&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;针对老年代再用复制算法显然不合适，因为进入老年代的对象都存活率比较高了，这时候再频繁的复制对性能影响就比较大，而且也不会再有另外的空间进行兜底。所以针对老年代的特点，通过&lt;strong&gt;标记-整理&lt;/strong&gt;算法，标记出所有的存活对象，让所有存活的对象都向一端移动，然后清理掉边界以外的内存空间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;5. 什么是 GC ROOT？有哪些 GC ROOT？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面提到的标记的算法，怎么标记一个对象是否存活？简单的通过引用计数法，给对象设置一个引用计数器，每当有一个地方引用他，就给计数器+1，反之则计数器-1，但是这个简单的算法&lt;strong&gt;无法解决循环引用的问题&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Java 通过可达性分析算法来达到标记存活对象的目的，定义一系列的 GC ROOT 为起点。从起点开始向下开始搜索，搜索走过的路径称为引用链。当一个对象到 GC ROOT没有任何引用链相连的话，则对象可以判定是可以被回收的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而可以作为 GC ROOT 的对象包括：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;栈中引用的对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;静态变量、常量引用的对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;本地方法栈 native 方法引用的对象。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;6. 垃圾回收器了解吗？年轻代和老年代都有哪些垃圾回收器？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.41953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlS2swjribk4EibNmDPwGf1o5gqeRbkSdEKic67pibPqMEDGPf857pP2G1YA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;年轻代的垃圾收集器包含有 Serial、ParNew、Parallell。老年代则包括 Serial Old 老年代版本、CMS、Parallel Old 老年代版本和 JDK11 中全新的 G1 收集器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Serial&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：单线程版本收集器，进行垃圾回收的时候会 STW（Stop The World），也就是进行垃圾回收的时候其他的工作线程都必须暂停。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;ParNew&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Serial 的多线程版本，用于和 CMS 配合使用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Parallel Scavenge&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：可以并行收集的多线程垃圾收集器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Serial Old&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Serial 的老年代版本，也是单线程。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;Parallel Old&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Parallel Scavenge 的老年代版本。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;CMS（Concurrent Mark Sweep）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：CMS 收集器是以获取最短停顿时间为目标的收集器。相对于其他的收集器 STW 的时间更短暂，可以并行收集是它的特点，同时它基于&lt;strong&gt;标记-清除&lt;/strong&gt;算法。整个 GC 过程分为4步：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;初始标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：标记 GC ROOT 能关联到的对象，需要 STW；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;并发标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：从 GCRoots 的直接关联对象开始遍历整个对象图的过程，不需要 STW；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;重新标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：为了修正并发标记期间，因用户程序继续运作而导致标记产生改变的标记，需要 STW；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;并发清除&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：清理删除掉标记阶段判断的已经死亡的对象，不需要 STW。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从整个过程来看，并发标记和并发清除的耗时最长，但是不需要停止用户线程。而初始标记和重新标记的耗时较短，但是需要停止用户线程。总体而言，整个过程造成的停顿时间较短，大部分时候是可以和用户线程一起工作的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;G1（Garbage First）&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：G1 收集器是 JDK9 的默认垃圾收集器，不再区分年轻代和老年代进行回收。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;7. G1的原理了解吗？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.54453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlclwUSgRl1TKmdLvuBoicahRpa48GWyMADXRrVQhAiaryF7LPkLCC1TeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;G1 作为 JDK9 之后的服务端默认收集器，不再区分年轻代和老年代进行垃圾回收。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;把内存划分为多个 Region，每个 Region 的大小可以通过 &lt;strong&gt;-XX：G1HeapRegionSize&lt;/strong&gt; 设置，大小为1~32M。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于大对象的存储则衍生出 &lt;strong&gt;Humongous &lt;/strong&gt;的概念。超过 Region 大小一半的对象会被认为是大对象，而超过整个 Region 大小的对象被认为是超级大对象，将会被存储在连续的 N 个 Humongous Region 中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;G1 在进行回收的时候会在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间优先回收收益最大的 Region。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;G1 的回收过程分为以下四个步骤：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;初始标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：标记 GC ROOT 能关联到的对象，需要 STW；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;并发标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：从 GCRoots 的直接关联对象开始遍历整个对象图的过程，扫描完成后还会重新处理并发标记过程中产生变动的对象；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;最终标记&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：短暂暂停用户线程，再处理一次，需要 STW；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;筛选回收&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：更新 Region 的统计数据，对每个 Region 的回收价值和成本排序，根据用户设置的停顿时间制定回收计划。再把需要回收的 Region 中存活对象复制到空的 Region，同时清理旧的 Region。需要 STW。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总的来说除了并发标记之外，其他几个过程也还是需要短暂的 STW。G1 的目标是在停顿和延迟可控的情况下尽可能提高吞吐量。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;8. 什么时候会触发 YGC 和 FGC？对象什么时候会进入老年代？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当一个新的对象来申请内存空间的时候，如果 Eden 区无法满足内存分配需求，则触发 YGC。使用中的 Survivor 区和 Eden 区存活对象送到未使用的 Survivor 区。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果 YGC 之后还是没有足够空间，则直接进入老年代分配。如果老年代也无法分配空间，触发 FGC，FGC 之后还是放不下则报出 OOM 异常。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.03125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlDlicFGn9Z2ic9ABVnrxWE9qzl4p4QOrbWyeZ1nEYqxGibianVicET1BqnLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;YGC 之后，存活的对象将会被复制到未使用的 Survivor 区。如果 S 区放不下，则直接晋升至老年代。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而对于那些一直在 Survivor 区来回复制的对象，通过 &lt;strong&gt;-XX：MaxTenuringThreshold&lt;/strong&gt; 配置交换阈值，默认15次。如果超过次数同样进入老年代。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此外，还有一种动态年龄的判断机制，不需要等到 MaxTenuringThreshold 就能晋升老年代。如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;9. 频繁 FullGC 怎么排查？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种问题最好的办法就是结合有具体的例子举例分析，如果没有就说一般的分析步骤。发生 FGC 有可能是内存分配不合理，比如 Eden 区太小，导致对象频繁进入老年代，这时候通过启动参数配置就能看出来，另外有可能就是存在内存泄露，可以通过以下的步骤进行排查：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;1. &lt;strong&gt;jstat -gcutil&lt;/strong&gt; 或者查看 gc.log 日志，查看内存回收情况。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.35078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlNzhFQZlnLpOEIWkoPIgE4pPQYFcZ8OVdAu4ibOBtawqVJOaLficd7icXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;S0、S1 分别代表两个 Survivor 区占比；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;E 代表 Eden 区占比，图中可以看到使用了78%；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;O 代表老年代，M 代表元空间，YGC 发生54次，YGCT 代表 YGC 累计耗时，GCT 代表 GC 累计耗时。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.196875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSllkLHHPvwzafVdDDsvk6lPxdJPUQ5M2uV0Cch5HD8LfnjWrjBGPJj0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;[GC&lt;/span&gt;&lt;span&gt; 或 &lt;/span&gt;&lt;span&gt;[FGC&lt;/span&gt;&lt;span&gt; 开头代表垃圾回收的类型；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;PSYoungGen: 6130K-&amp;gt;6130K(9216K)] 12274K-&amp;gt;14330K(19456K), 0.0034895 secs&lt;/span&gt;&lt;span&gt; 代表 YGC 前后内存使用情况；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Times: user=0.02 sys=0.00, real=0.00 secs&lt;/span&gt;&lt;span&gt;：user 表示用户态消耗的 CPU 时间，sys 表示内核态消耗的 CPU 时间，real 表示各种墙时钟的等待时间；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这两张图只是举例并没有关联关系。比如你从图里面看能到是否进行 FGC、FGC 的时间花费多长；GC 后老年代，年轻代内存是否有减少；得到一些初步的情况来做出判断。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. dump 出内存文件在具体分析。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如通过 jmap 命令 &lt;strong&gt;jmap -dump:format=b,file=dumpfile pid&lt;/strong&gt;。&lt;/span&gt;&lt;span&gt;导出之后再&lt;/span&gt;&lt;span&gt;通过 &lt;/span&gt;&lt;span&gt;Eclipse Memory Analyze&lt;/span&gt;&lt;span&gt;r &lt;/span&gt;&lt;span&gt;等工具进行分析，定位到代码、&lt;/span&gt;&lt;span&gt;修复。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里还会可能存在一个提问的点，比如 &lt;strong&gt;CPU 飙高，同时 FGC 怎么办&lt;/strong&gt;？办法比较类似：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;找到当前进程的 pid，&lt;strong&gt;top -p pid -H&lt;/strong&gt; 查看资源占用，找到问题线程；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;printf “%x\n” pid&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，把线程 pid 转为16进制，比如 0x32d；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;jstack pid|grep -A 10 0x32d &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;查看线程的堆栈日志，还找不到问题继续下一步；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;dump 出内存文件用 MAT 等工具进行分析，定位到代码、修复。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;10. JVM调优有什么经验吗？&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;要明白一点，所有的调优的目的都是为了用更小的硬件成本达到更高的吞吐，JVM 的调优也是一样。通过对垃圾收集器和内存分配的调优达到性能的最佳。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;简单的参数含义&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，需要知道几个主要的参数含义。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eZzl4LXykQwFGhp07TlUR0uvZJhntKSlLWMnkcBxCTMcdsOu97iaiaSbOv87f3heq6PbIWTnZOtQIaEy96HZxj8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-Xms&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 设置初始堆的大小，&lt;strong&gt;-Xmx &lt;/strong&gt;设置最大堆的大小；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:NewSize&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 年轻代大小，&lt;strong&gt;-XX:MaxNewSize&lt;/strong&gt; 年轻代最大值，&lt;strong&gt;-Xmn&lt;/strong&gt; 则是相当于同时配置 -XX:NewSize 和 -XX:MaxNewSize 为一样的值；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:NewRatio&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 设置年轻代和年老代的比值。如果为3，表示年轻代与老年代比值为 1:3，默认值为2；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:SurvivorRatio&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 年轻代和两个 Survivor 的比值。默认值为8，代表比值为 8:1:1；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:PretenureSizeThreshold&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 当创建的对象超过指定大小时，直接把对象分配在老年代；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:MaxTenuringThreshold&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 设定对象在 Survivor 复制的最大年龄阈值，超过阈值转移到老年代；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:MaxDirectMemorySize&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 当 Direct ByteBuffer 分配的堆外内存到达指定大小后，即触发 Full GC。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;调优&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;为了打印日志方便排查问题最好开启GC日志。开启GC日志对性能影响微乎其微，但是能帮助我们快速排查定位问题。&lt;strong&gt;-XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:gc.log&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;一般设置 &lt;strong&gt;-Xms=-Xmx&lt;/strong&gt;。这样可以获得固定大小的堆内存，减少 GC 次数和耗时，可以使得堆相对稳定；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 让 JVM 在发生内存溢出的时候自动生成内存快照，方便排查问题；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;-Xmn&lt;/strong&gt; 设置新生代的大小。太小会增加 YGC，太大会减小老年代大小，一般设置为&lt;strong&gt;整个堆的1/4到1/3&lt;/strong&gt;；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;设置 &lt;strong&gt;-XX:+DisableExplicitGC &lt;/strong&gt;禁止系统 System.gc()。防止手动误触发 FGC 造成问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651482823&amp;amp;idx=1&amp;amp;sn=cd623fbfa900f1217b34d34f980b2e82&amp;amp;chksm=bd2506b88a528faea643840bb2613ae67252085c24faaba2359006cc37335dc4fe042f1ca66d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;关于 JVM 内存的 N 个问题&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651488039&amp;amp;idx=1&amp;amp;sn=b812f2bd8b3e0e7edfdb2bb6c050894e&amp;amp;chksm=bd2513588a529a4e02c41f59fa78adc2c064b48b112a5120d53687b8ee84aff87524acecb479&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;JVM 史上最最最完整深入解析&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651486318&amp;amp;idx=1&amp;amp;sn=a0bf7b6896cc30cff1581243193200fc&amp;amp;chksm=bd2514118a529d0769979c50eaac2c8b5fef25cb8fdf550d9e24534d211700d0bd6befae2b64&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Spring Boot项目优化和JVM调优&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;好文章，我&lt;/span&gt;&lt;span&gt;在看&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>01a4ff9dfc9d4f11900bdc0fdc62ffc9</guid>
<title>[推荐] 我做了一个 240 天的计划来解救自己，还剩 174 天，寻找伙伴中</title>
<link>https://toutiao.io/k/3jkd39p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;人脑很难推断感受。即使是乔布斯告诉你每天都要像是生命最后一天一样活着，你也很难想象最后一天你到底想干什么。但 2020 这特殊的一年对我来说，把所有的事情都催化了一点，把很多感受都变得了现实一点。&lt;/p&gt;&lt;p&gt;这一年里我清晰地看到了自己的职业际遇是如何和大环境关联起来的。我组建了三年的团队，在承担了公司零到一的重要战役之后，因为战略调整瞬间就分崩离析了。公司当然不是针对我，面对今非昔比的国际关系，必须做出战略调整才能应对，我顶多算是 collateral damage。除了我，还有很多同样的人，无论能力、努力程度，也在遭受着 collateral damage。&lt;/p&gt;&lt;p&gt;世界并不是以前认为的那么稳定，或许早就已经岌岌可危。生命也是，虽然非典时就见识过疫情很危险，但也只有当家里人是医务工作者，过年跟我说别回家时，才又真正感受到他们会有危险，真的有可能见面即是最后一面。还有很多很多事情让我真切感受到，自己的生命在流逝，虽然无法想象人生的最后一天，但往后每一天都是余生最年轻的一天，不妨去想这一天想要干什么。&lt;/p&gt;&lt;p&gt;我想要完全改变自己的工作方式，去做喜欢的事并且创造巨大的价值，永远追求更健康更科学地工作，找到有梦想、能深度交流的伙伴，为我的宝宝提供更好的教育、更好地照顾家庭。&lt;/p&gt;&lt;p&gt;这就是这个计划的目标，240 天是它的期限。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;第一部分&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;过去的创业和大公司经历，让我看到目前的公司环境给不了我想要的，并不是因为做不到，而是因为帮助员工实现价值、好好照顾员工并不是公司的核心目标。例如远程办公这件事，只要有好的工具、约定，就能做到，还能规避掉很多无效的会议。但若不是疫情，老板是不会主动去推进实施的，这不是他的核心目标。还有更多地例子可以参照《&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//book.douban.com/subject/35135787/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;重来 3&lt;/a&gt;》。关于组织和员工关系的本质我也花了很长时间思考和学习管理学，参见《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/166099294&quot; class=&quot;internal&quot;&gt;技术管理的世界观&lt;/a&gt;》。&lt;/p&gt;&lt;p&gt;这让我意识到想要改变，必须自己去创造。Wolfram 的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//writings.stephenwolfram.com/2019/02/seeking-the-productive-life-some-details-of-my-personal-infrastructure/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Seeking the Productive Life&lt;/a&gt; 给了我很大的启发。作为工程师我首先要以工程的方式改善自己，要造工具让自己写代码更快、更少、更容易。于是我花了很长时间来梳理我的知识体系。这里要顺便介绍一下我的经历了，便于理解我要做这些，为什么做这些。&lt;/p&gt;&lt;p&gt;我是学存储的、数据库方向。读研时就开始写云存储软件，当时实验室和一家北京的教育软件集成公司合作，软件卖给了很多高校，现在应该还在跑。快毕业时去百度实习，想着自己未来要做独立做产品只差前端没系统学习过了，于是拒了 php 的职位选了前端。毕业后收到邀请和新浪的师兄开始创业做云计算，成立了国内第一家做 Openstack 的公司，我负责前端和设计团队、兼任产品经理。又补齐了很多产品知识，写的博客被华章出版社的编辑看到，受邀写了本小小的电子书《产品设计七日修行》。再后来公司资金出现问题，我离职到了支付宝做前端。在工作中我庆幸从来没有以工作的标准来指导自己的发展，不管本职工做什么，我一直在关注框架，AngularJS 的第一版 developer guide 就是我翻译的，也在写框架，参见我的 github &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/sskyy&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/sskyy&lt;/span&gt;&lt;span class=&quot;invisible&quot;/&gt;&lt;/a&gt;。同时也在用自己的框架写产品，在我的 github 里面可以找到博客、论坛等等。其他其他事情可以通过我的知乎文章 &lt;a href=&quot;https://www.zhihu.com/people/hou-zhen-yu/posts&quot; class=&quot;internal&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;zhihu.com/people/hou-zh&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;en-yu/posts&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt; 和以前的博客&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.cnblogs.com/sskyy&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://www.&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;cnblogs.com/sskyy&lt;/span&gt;&lt;span class=&quot;invisible&quot;/&gt;&lt;/a&gt;找到。&lt;/p&gt;&lt;p&gt;我发现我不管是初心还是知识体系，其实都是围绕着“做完整产品”的。我应该不为公司，不为任何人，而是为自己打造一条生产线，让我做下一个产品时，不用再写那么多 crud，不断实现 rbac，不断写前端组件了。当然我不可能造出银弹，这个生产线是有一个明确应用范围的，即“单一数据中心，多用户，以数据操作为主”的应用。围绕这个范围我进行了长达一年时间的推导以及和朋友的讨论。目前已经全部完结，核心是以“需求描述”为中心来构建系统，这样能极大地复用已有的能力。&lt;/p&gt;&lt;p&gt;&lt;b&gt;这就是计划的第一部分，打造自己的软件生产线。&lt;/b&gt;以下思维导图仅供参考。(当然没有我的解释是不可能完全看懂的，期待你加入我会好好解释给你听。)&lt;/p&gt;&lt;p&gt;整体思维导图&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-bf6e474c0c82576bf1632e219ad138e4_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;4000&quot; data-rawheight=&quot;3123&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-bf6e474c0c82576bf1632e219ad138e4_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;4000&quot; data-rawheight=&quot;3123&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-bf6e474c0c82576bf1632e219ad138e4_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-bf6e474c0c82576bf1632e219ad138e4_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;后端的设计&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-95a8daa48593856aaf000140d7dd3990_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3066&quot; data-rawheight=&quot;2422&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-95a8daa48593856aaf000140d7dd3990_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3066&quot; data-rawheight=&quot;2422&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-95a8daa48593856aaf000140d7dd3990_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-95a8daa48593856aaf000140d7dd3990_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;前端的设计&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d03fb5c48f3940e235414f4e7787d5eb_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;7117&quot; data-rawheight=&quot;2892&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-d03fb5c48f3940e235414f4e7787d5eb_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;7117&quot; data-rawheight=&quot;2892&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-d03fb5c48f3940e235414f4e7787d5eb_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-d03fb5c48f3940e235414f4e7787d5eb_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;基本上系统整体推导已经完成。前端部分实施已经完成，准备开源中，关于前端开源的招募建我另一篇帖子。除了系统本身，我也写了个 IDE，主要目的有两个：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;提供与项目相关的更好的编辑体验。例如我想要知道哪一行代码会引起数据库的写操作，如果没有工具完全理解代码语义就很难做到。理解语义需要 AST，而 VS Code 在官方的 Issue 里面明确回复了不会开发内部的 AST，这意味着我要想得到 AST 就要自己 parse，代码变化就得重新 parse。算了吧，相比于之前我参与过的 Drupal、Openstack、Chromium，我对 VS Code 的架构设计也不是很满意，为什么不自己写呢。在插件体系上我要做成类似于 meteor 的写法，写插件代码的人不分前后端，系统自动判断代码运行在哪里。在编辑能力上我要做成天然以 AST 的树形数据结构来显示，而不是行列字符的形式，天然开放 AST 给所有插件。在这个是线下还可以做很多有意思的事情，例如可以取消掉所有空格缩进，直接用 padding 实现。&lt;/li&gt;&lt;li&gt;突破以文件树的方式保存代码的形式。都已经 2020 年了，我们还在以过去几十年前的方式来保存代码，以文件的方式来区分模块。为什么不能突破，我们现在的大部分代码都是某个框架的一部分，语义是相当容易分析的。当有了对代码语义的完全掌控后，完全可以框架的概念来保存和索引代码。例如我可以通过数据反向查询所有对其操作的 model 的代码，也可以通过 service 方向查询须有进行了调用的 model。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这个 IDE 我已经完成了第一部分。&lt;/p&gt;&lt;p&gt;IDE 图。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-72069736a2ee79704fbc1404616c4d43_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;4022&quot; data-rawheight=&quot;3077&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-72069736a2ee79704fbc1404616c4d43_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;4022&quot; data-rawheight=&quot;3077&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-72069736a2ee79704fbc1404616c4d43_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-72069736a2ee79704fbc1404616c4d43_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-e44ae0474d336578e76a175bf841f37d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3232&quot; data-rawheight=&quot;1884&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-e44ae0474d336578e76a175bf841f37d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;3232&quot; data-rawheight=&quot;1884&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-e44ae0474d336578e76a175bf841f37d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-e44ae0474d336578e76a175bf841f37d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;第二部分&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;第二部分，关于我期望达成的工作方式，这设计到了我对组织、项目管理的理解。&lt;/p&gt;&lt;p&gt;先说项目管理，这几年里一直承担着一线管理者的工作，并且参与了公司当时号称最重要的战役。我看到现在一线项目管理的最大的问题就是“解决错了问题”。可能很多公司和我们一样，是遵循着传统的项目管理方式围绕图文形式的“任务”概念去做项目管理的。这就有三个很大的问题：&lt;/p&gt;&lt;p&gt;一是图文形式任务实际上很难直观的体现出进度。任务可大可小，靠完成的任务数量是很不客观的。&lt;/p&gt;&lt;p&gt;二是你怎么去衡量一个任务到底应该投入多少人算是合理的？任务既可以写得精确也可以写得模糊，具体的技术需求还要靠一线评估，最后就变成了一线上报，最终成了统计，而不是管理。&lt;/p&gt;&lt;p&gt;三是对于任务的理解和传达其实都是靠的人肉。都 2020 了我们还在像人工耕地一样生产软件。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;正确地方式应该是围绕“交付物”来打造项目管理体系。一个项目里面已经建立了哪些模型，完成了哪些页面，由谁在何时完成的，都应该有系统能够可视化地自动展示出来，而不是文字形式的任务或者人肉通知。应该可以在”活的“系统的架构图上看到所有的进度，而不只是一张 ppt。&lt;/p&gt;&lt;p&gt;对于交付物复杂度的评估参考 2000 年后出现的”基于认知的复杂度评估“方法已经可以比较客观地进行评价，这样投入的人力是否合理也可以算出来。&lt;/p&gt;&lt;p&gt;最后围绕这交互物的管理系统，也能非常轻松的实现自动化。当一个页面的交互稿完成后、一个接口完成后，可以由管理交付物的系统来自动对受影响的下游流程实施者进行通知。&lt;/p&gt;&lt;p&gt;围绕我第一部分描述的产品生产线的”交付物“管理系统我也设计完了，目前已经实现了”视图“部分的交付物管理。预计全部完成后，在开发阶段，它是架构说明书，并且能看到每个人在做什么，做到什么程度。而完成开发后，它就会像一张活的产品说明书，帮助后续维护迭代。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;再说组织，由于现在还不是创业状态，为了避免不必要的麻烦请大家主要从《&lt;a href=&quot;https://zhuanlan.zhihu.com/p/166099294&quot; class=&quot;internal&quot;&gt;技术管理的世界观&lt;/a&gt;》来了解吧。这里只说两个结论：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;从资本的角度来说，现代程序员的投入产出比，是可以达到商业体育运动员水平的。因此我们其实是可以像球队一样去建立组织，为其提供专业的技能培训、医疗等健康管理。想要他提高更高的效率或者释放更大的创造力，就更不应该把他丢进闭关室。应该更科学地为他提供秘书、厨师、医生甚至司机。何况国内其他服务行业相对便宜，互联网相对于其他行业已经处于过发达水平，完全可以变成工程师的天堂。&lt;/li&gt;&lt;li&gt;组织的核心就是”利益分配制度“、”决策权分配制度“。很多公司已经开始进行决策权分配制度的改革，例如去掉 title 等。但还远远不够，真正要让决策权到最正确人手中，至少还要在组织内先建立”科学地讨论方法“才行。利益分配制度也是如此，组织的创始人应当扮演组织发展方向的最后看门人角色，而不是组织中最富有的人。财富应该更多地留给后来加入但贡献了专业能力的人，这样才可能源源不断地扩大组织，寻求更远大的梦想。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;其实关于组织，以及如何实现”最喜欢的事并创造巨大价值“我还有很多想说，但现在还不是时候，就当做是隐藏的第三部分吧。要开启的话，你只能加入我了。&lt;/p&gt;&lt;p&gt;最后奉上我的书单，也算是从侧面介绍我是谁吧。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-3d7eb3ec985fbea95962083cc59a2f33_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-3d7eb3ec985fbea95962083cc59a2f33_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-3d7eb3ec985fbea95962083cc59a2f33_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-3d7eb3ec985fbea95962083cc59a2f33_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-41fb26ef8f3df7995a018b99647d5a4b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-41fb26ef8f3df7995a018b99647d5a4b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-41fb26ef8f3df7995a018b99647d5a4b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-41fb26ef8f3df7995a018b99647d5a4b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-24452bb121d0073db4fa369b3875f02a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-24452bb121d0073db4fa369b3875f02a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-24452bb121d0073db4fa369b3875f02a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-24452bb121d0073db4fa369b3875f02a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cfe74cc80a31bba7f3b28f7d863f7774_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-cfe74cc80a31bba7f3b28f7d863f7774_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1440&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-cfe74cc80a31bba7f3b28f7d863f7774_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-cfe74cc80a31bba7f3b28f7d863f7774_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;请联系我。我的微信 rainer_H。&lt;/p&gt;&lt;h2&gt;以下是本来隐藏在其他地方的第三部分，已经被发现了，就同步到这里来吧。&lt;/h2&gt;&lt;h2&gt;0. 这个计划怎就能实现“做喜欢的事情并创造巨大财富了”？&lt;/h2&gt;&lt;p&gt;隐藏了第三部分所以感觉没连起来。实际上完整地逻辑是：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-bcc74e7a07996d0817eeb9257c5839b5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1942&quot; data-rawheight=&quot;836&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-bcc74e7a07996d0817eeb9257c5839b5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1942&quot; data-rawheight=&quot;836&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-bcc74e7a07996d0817eeb9257c5839b5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-bcc74e7a07996d0817eeb9257c5839b5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;“现象级的产品 Idea” 和“新的组织扩展方式”算是第三部分，涉及到了未来可能要创业的内容。&lt;/p&gt;&lt;p&gt;产品实际上去年已经完成了第一版并自己测试了一段时间，因为下面描述的原因所以暂时隐藏了。&lt;/p&gt;&lt;p&gt;新的组织扩展方式是指假设产品成功存活了下来并且有了发展，我不想再过十年八年才能像阿里或者腾讯一样成为一种可以抵抗危机的“经济体”，想要有更快速的方法具备保护自己团队的能力。我确实找到了，并且意外的是真的有一家国外的公司是这样发展起来。&lt;/p&gt;&lt;p&gt;因为我并没有离职，所以不公开讨论了，同样对产品感兴趣的小伙伴请单独联系我。&lt;/p&gt;&lt;p&gt;这个计划中考虑了即使不创业，我也可以用创造出来的研发基建去寻找自己更好的职业发展。实际上我所知的创业，也并不一定是传统意义上的离职开公司，而是不局限在当前工作和生活的圈子里。从数据库到视图的基建可以全面的应用我的知识体系，提供更多地机遇。过去的经验让我看到技术深度和广度是互相支撑的。广度为深度指明方向，深度为广度指明价值。唯有如此才能上升到更高的层次。&lt;/p&gt;&lt;h2&gt;1. 制定计划背后的逻辑&lt;/h2&gt;&lt;p&gt;为什么不直接做产品创业，为什么是这样的计划，我为什么认为这个计划能改变自己的未来？这背后的逻辑来自于这几年我了解到几个关于世界真相：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;一、关于公司的秩序和上升通道&lt;/p&gt;&lt;p&gt;我们习惯于用国家和社会的思维来理解公司，这其实是有问题的。国家机器是以保护其成员，满足成员需求为目标来运转的。现代社会中，对公平、文明等要求已经变成了人的基本需求，国家有义务满足。以营利为目标的组公司，是以满足组织所有者的利益需求为目标的，没有维持公平环境的义务，更没有帮助员工实现自我价值的义务。&lt;/p&gt;&lt;p&gt;理论上维持公平环境，关心员工可以更好地吸引人才。但能起决定性作用的人才非常少，关心他们，为他们创造公平环境甚至让他们掌握特权，投入产出比最高。&lt;/p&gt;&lt;p&gt;对大量非决定性的员工，公司维持公平的投入只要达到“不引起舆情”的程度就可以保障正常运转。这样投入产出比最高。&lt;/p&gt;&lt;p&gt;实际上，如果真正见识过公司很多机制背后的决策，例如统一的委员会的晋升评价，就会发现背后可操作的空间极大，一切都是以当前公司主要利益集团利益最大化为标准。这个最大化的操作过程中，还是“公不公平，只要做到不引起舆情”就够了。但这并没有什么问题，因为不同于国家，在公司中人失去了利益就会走，组织就可能覆灭，在组织中的管理者追求利益最大化某种程度上是保障组织存活的必要手段。&lt;/p&gt;&lt;p&gt;未看到真相之前，人很容易把成功归功于自己的能力。实际上成功并不一定是能力，更可能是因为满足了当权者的利益。同样把失败怪罪于环境不公，可是环境并没有允诺要公平。和公司的劳动合同上没写。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;二、财富的来源&lt;/p&gt;&lt;p&gt;我在几年前做过一段私募的投资顾问。这里面有意思的是，在创业者看来，创业是成王败寇，失败了就什么也没有。但对投资人来说投资收益其实是相对比较稳健的。因为投资人是反过来看的，先看市场，看领域，算到底有多少钱能赚。例如很多互联网公司的主要收入来源——广告。广告的钱来自于各大广告主的年度预算，这都是确定的数字，总有人会要赚走。只要这个钱足够多、足够确定，那么投资人找到相对背景好的团队，按比例押注多个，就可以赚走这笔钱。&lt;/p&gt;&lt;p&gt;在未变成资方之前，只要同样选对市场和领域，做得比别人更好一点，就很有可能通过投资人的前活下来。很多现在看起来创业成功的大佬，之前也失败过很多次，为什么还一直有人投呢？因为即使失败过很多次，但到了新领域，还是只要别其他人还一点就够了。&lt;/p&gt;&lt;p&gt;创业要成功很难，但很多时候靠投资人的钱活着，和公司发工资并无二致。甚至风险也是一样，公司并没有保证过不裁掉你，当你生病失去劳动能力，当你的年龄、工资涨到一定程度，性价比低于了刚入职的年轻人。公司裁掉你只要不违反法律，没有任何不妥。这和投资人的钱耗尽了是同样的风险。我们这一代人会遇到过去没有遇见过的风险，父辈很多人可以在一个单位做到退休，很多互联网公司能不能活到你退休都不一定。加上国家养老基金的问题(请自行了解)，在没有什么成长、只是把自己知道的知识应用出来的环境里待着，风险比创业更大。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;三、人的可塑性&lt;/p&gt;&lt;p&gt;在不考虑衰老疾病的情况下，人其实是年龄越大学习能力越强。你的阅历可以不断增强你的理解能力。你碰到过题会把你的头脑变成一块干海绵，再碰到相应的知识时会疯狂地吸收。这段话出自于我老婆，她在29岁已经工作了4年的情况下做出了目前人生最重要的决定，去日本读博。她毕业于一个二本小学校设计相关专业，在我看来思维不严谨，逻辑常常混乱。但她用一年时间就考过了 N1，申请上了千叶大学，专业貌似是日本前三。学的是园林相关，自己却从园林研究到城市规划，再从城市规划研究到经济，从国内的张五常、温铁军再到诺奖的著作。她边看《中国经济50人论坛》边跟我侃侃而谈里面某些人一看就是没研究 XXX 问题时，我突然想到，我们什么时候就相信了“人的可塑性越年轻越强”？&lt;/p&gt;&lt;p&gt;根本不是“可塑性”的问题，绝大部分的人的问题是脱离校园之后，就不再进行系统性的学习，就算学习也只是围绕着工作专业。真正有价值的，能对人产生终生影响的还是那些系统性的学科知识。在这几年我自己的转变里，我至少发现了——认知心理学、社会心理学、逻辑学、博弈论、微观经济学、政治学通识——对我的思维产生了巨大影响，这些，才构成了现在的“我”。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;一个人，需要产生“质”的改变需要多久。一个普通的年轻人，变成我认为有独立思考能力，值得成为真正的伙伴需要多久？为了找到这个答案我找了团队里的一个年轻人作了一个小小的实验，我每个月大概只花了不到 4 个小时，只是告诉他要学什么，当前思维有什么问题，3 个月之后他就已经让我感觉完全不同了，半年之后我认为他是有所谓“潜力”的了。&lt;/p&gt;&lt;p&gt;我老婆的经历和这个实验结果构成了这个计划的一部分信心。即使一开始没有豪华的团队，我只要提供成长的环境，只要成员智力正常，愿意系统性地学习，真的想要不断提升自己的思维，团队就能在理想的时间内产生质变，脱颖而出。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;四、工程师的乐趣，创造的力量&lt;/p&gt;&lt;p&gt;马斯克确实给了我关于工程师的乐趣和创造力量的极大启发。他最近在介绍自己的 boring campany 的访谈中，又一次提到了第一性原理，又一次描述了如何拆解复杂问题，将其理解到物理或者数学层面。当理解到那个层面时，很多外界看起来的“颠覆性创新”其实对他来说并不是什么创新，只不是从原理用更好的方法重新构造了一遍。构造完之后，之前的问题也都不存在了。&lt;/p&gt;&lt;p&gt;这才是真正工程师的思维和乐趣，有了这样的思维再去看这个世界，有太多可以去重新理解和创造的了，包括现代的公司制度、教育甚至人对自己的理解。之前提到的 Wolfram 的文章，其实也是将自己拆解了。《重来3》也是同样原理将公司拆解了。这个计划追寻着他们同样的脚步，其实远远不只是做一个“研发基建”而已，“新的协作方式”和“组织协作工具”等都是在 240 天计划之前就已经花了很长时间进行拆解完并重新构造。我对它的信心完全来自于背后每一步验证过的推理。&lt;/p&gt;&lt;p&gt;同时不得不说，我在这个过程中感受到了极大的乐趣，前面所指的创造巨大的价值并不是指单纯的钱，而是组织形成之后，这个组织所产生的创造力，是成百上千个真正有这样拆解世界的思维和能力的工程师的力量。往后的每一天都是我余生最年轻的一天，这一天我希望和这样的伙伴一起，再创造些什么，把这个世界的科技、甚至文明再推进一点点吧。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;五、人活着的意义？&lt;/p&gt;&lt;p&gt;有一种心理学现象叫做“死亡恐惧”，不是指突然受到了危险感到的害怕，而是指到了某一时刻开始思考自己的活着的意义，因为找不到意义而产生的巨大焦虑。一般因各方面的压力终日疲于奔命的中年人容易遭遇这种现象。&lt;/p&gt;&lt;p&gt;我在较小的时候因为健康原因受到过很长时间的死亡恐惧的困扰。更残酷的是，某一日我读到毕淑敏的文章看到，人生确实是没有意义的，所有意义都是人自己赋予的。这对当时的我产生了巨大的冲击。谁都不想没有意义的死掉，可如果本来没有意义，我该赋予它什么意义呢？可能是由于长期思虑这个问题，有一天晚上我突然梦见了全世界所有人都死了，只剩下了我一个人。当时的感觉太真实了，且非常复杂，似乎想哭却连哭也没有意义，没有人听见，也没有人关心。那个震撼的梦让我顿悟到人作为个体活着是没有意义的，但作为群体中的一部分是有意义的，我们为自己的家人、朋友等等一切有关联的人活着，我们构成了他们的生活和喜怒哀乐。同样，他们也是我的意义。人与人之间的联系即是意义，这是我的结论。&lt;/p&gt;&lt;p&gt;但可惜的是，我观察到的大部分人，除了寻找伴侣的时候，都没有再去深入挖掘探索这种联系。我们认识的“朋友”往往都只是学习、工作时的同伴，通常也就是交流专业、交流兴趣。有多少人会主动再去挖掘对方思维、价值观，做更深度的交流呢？我在查理芒格的《穷查理宝典》中看到了他是如何和巴菲特交流，如何成为一辈子真正意义上的灵魂伙伴(说灵魂伴侣有点恶心...)的。人在深入交流之后，是可以达到思维和价值观的融合的，再因融合产生了无可比拟的信任和默契。达到他就像你的一部分大脑，一部分感官，你绝对信任他的决策，随时可以从他那里吸收新的有价值的思考。你们互相“关心”，不是出于朋友或者礼貌性的关心，而是因为你们已经习惯了把对方当成自己的思维的一部分，这种关心只是在为他思考，也就是为自己思考一样。从朋友到挚友，这种关系大部分人只在书里见过，但是如果想到自己的人生也只有一次，难道不想试试吗？&lt;/p&gt;&lt;p&gt;对我来说，唯有建立这样的联系，可以给人生增加一点点意义。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;2. 目前的进度 &amp;amp; 什么是“组织基建”&lt;/h2&gt;&lt;p&gt;这个计划里大部分内容其实开始于两年前，240 天开始的时候是我确认所有细节都想清楚了，所有方案都推导过了，这 240 已经是实施阶段。&lt;/p&gt;&lt;p&gt;其中研发基建就是我所提到的软件生成线，是目前最有现实意义的资产。也是目前投入的主线。它的大概构成按重要程度如下：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;一、适用于“单数据中心，多用户，以数据操作为主”的应用描述语言（待实施）。&lt;/p&gt;&lt;p&gt;它是一种描述需求的语言（当然没有必要重新实现语法，复用已有的语言即可，我们只是需要 ast）。描述的内容是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;应用有哪些页面，跳转关系是什么样的。&lt;/li&gt;&lt;li&gt;页面上承载了哪些交互，这些交互使用什么样的系统能力和模型。在描述交互时又将交互的规模从小到大分成了三层：&lt;/li&gt;&lt;ul&gt;&lt;li&gt;Interaction Interface Language：单次交互。(不完全等同于一次接口调用)&lt;/li&gt;&lt;li&gt;Interaction Session Language：跨交互、跨角色、共享 context 的交互描述&lt;/li&gt;&lt;li&gt;Business Process modeling language：跨 session、跨角色、共享 context 的系统交互描述&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;系统提供了哪些能力(如 p2p 通信，定时任务等)，哪些模型。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;笼统地来说，这个语言相当于把产品的需求文档结构化了。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;二、应用描述语言的生成系统（待实施）。&lt;/p&gt;&lt;p&gt;有了描述语言之后，还需要生成系统取读取形成 runtime。类似于自动生成我们现在手动创建的数据库、手写的接口等。举个简单的例子，对于“交友”这样一个交互，我们可能的描述是：&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;User a: any;&lt;/p&gt;&lt;p&gt;User b: not(a);&lt;/p&gt;&lt;p&gt;const request = a.sendRequest(friend).to(b);&lt;/p&gt;&lt;p&gt;await result = b.handle();&lt;/p&gt;&lt;p&gt;if (result.approved) {&lt;/p&gt;&lt;p&gt;system.applyRelation(friend, a, b)&lt;/p&gt;&lt;p&gt;} else if (result.reject) {&lt;/p&gt;&lt;p&gt;system.notify(a, request.rejected)&lt;/p&gt;&lt;p&gt;system.end(request)&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;那么根据语义分析，生成系统会自动生成 makeRequest/handleRequest 两个接口。过去我们的手写接口时，对于这种有多个接口调用的流程，逻辑都是分散在各个接口里，流程越复杂维护成本也越高，渐渐系统就失去了原貌。&lt;/p&gt;&lt;p&gt;让需求保持原貌，使用生成系统来生成具体的实现是这样设计的初衷之一。还有另一个初衷是过去很多的代码经验、数据经验都是在人脑中，每个需求来一次都是把这些经验重复应用一下。当我们把需求和实现完全分开后，这些经验就可以放到生成系统中，一次就够了。例如简单的分库分表，实际上就是判断哪些字段常查询、哪些表数据量会特别多。需求和实现分开后，这些信息是可以承载到需求语言中，生成系统只要读到了关键的需求，那么就自动应用这些操作。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;三、前端框架（主体实施结束，devtools、组件库、开源工作进行中）&lt;/p&gt;&lt;p&gt;前端的领域问题不同，它处理的是单用户，天然事件驱动的场景。里面的关键问题是设计资源到前端的自动化、组件的复用等。这一部分之后再单独写一篇说明吧。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;四、系统的可视化工具（部分已实施）&lt;/p&gt;&lt;p&gt;需求描述语言中的大部分其实都是可以可视化的，例如有哪些页面，他们之间的跳转关系，这些信息可以生成一张产品地图。这个可视化系统的重点不是用可视化地方式去搭建(当然搭建也是可以做得)，而是它既可以像一张产品说明书来引导维护系统，也可以作为中枢来串联其他信息。例如测试发现了某个页面有问题，我们完全可以在这个可视化工具上找到相应的页面，标注问题，省去了截图、复制链接等繁琐的操作。同样开发的时候也可以把那个页面已经开发完了，模型开发完了等信息自动同步到这个工具上。省去了人肉的沟通。&lt;/p&gt;&lt;p&gt;这也就是前面提到过的“围绕交付物”的项目管理和协作。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;五、IDE（原型版，需要部分重构使用新前端框架）&lt;/p&gt;&lt;p&gt;为了更好地让用户写需求描述语言，基于它的语义提供更好的提示。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;“&lt;b&gt;组织基建&lt;/b&gt;”指的是用来帮助进行组织管理、通信、软件交付的工具，传统的内部文档系统、项目管理系统都算。在更远的未来我认为它比研发基建更加重要，它决定了我是否能达成不管在哪里办公都很好的和交流协作。是否能达成真正摆脱工作地点、时间的限制。&lt;/p&gt;&lt;p&gt;目前规划的组织基建中一部分就是是和上面研发基建中的系统可视化工具结合的任务管理。&lt;/p&gt;&lt;p&gt;另一部分是“组织的思维交流协作工具(未实施)”，可以暂时理解为在线多用户可编辑的脑图，但其联系方式等要远多于脑图。意图取代掉传统的文件树形式的组织内知识管理、需求等信息的传递。期望达到架构图不是在 ppt 上，而是在这个活着的系统中，能看到进度、演化历史。需求也是，战略也是。让所有信息都不再是碎片化地零散的。&lt;/p&gt;&lt;p&gt;对此感兴趣的请单独联系我，这个可以独立开发。&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;3. 怎么参与&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;请简单介绍你自己（如果有任何公开的文章或者资料可以直接发链接给我，我会认真读）：&lt;/li&gt;&lt;ol&gt;&lt;li&gt;你的能力和主要经历&lt;/li&gt;&lt;li&gt;你目前的工作、状态&lt;/li&gt;&lt;li&gt;你对这个计划的想法，想了解或者参与的部分&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;请以面试官的角度来想想你要问我什么问题(是的，反向以你面试我的角度来提问)，把你自己当做投资人，你投入的是你的精力和时间。&lt;/li&gt;&lt;li&gt;在我上面的会打中其实有一部分我对伙伴的“契约”，例如进行系统性地学科学习，追求创造的力量等等。请确保你能接受并且想象你是否也有“契约”要我达成。&lt;/li&gt;&lt;li&gt;感谢你看到这里。&lt;/li&gt;&lt;/ol&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>072f806aca3d3e7da4e008d338713929</guid>
<title>[推荐] 一篇教会你写 90% 的 Shell 脚本</title>
<link>https://toutiao.io/k/l216gug</link>
<content:encoded>&lt;div&gt;&lt;div/&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3cc57db6a2392babe9b66429d89e2500</guid>
<title>[推荐] 微信研发体系下的分布式配置系统设计概要</title>
<link>https://toutiao.io/k/43s9snk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;作者：ypaapyyang，腾讯 WXG 后台开发工程师，个人公众号：码农课代表。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本文旨在分析分布式配置系统的必要性、可行性，及其关键约束，并介绍一款基于该系列分析，在微信研发体系下的实践尝试。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对很多的业务开发同学而言，对运营素材的处理不是一件轻松的事，通常需要定制化的进行数据的清理、格式的转换、工具的开发。笔者就曾过这样一段不愉快的回忆，为了导入一次性的近十种类型的配置数据，就耗去了两天的时间。如果说这段经历有何价值的话，那就是促使我思考分布式配置系统，并且在工作中实践，使自己避免再次陷入如此槽糕的过程中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文正是旨在分析分布式配置系统的必要性、可行性，及其关键约束，并介绍一款基于该系列分析，在微信研发体系下的实践尝试。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;配置的定义&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们清楚软件建模的本质是对现实世界（人、事、物及规则）的映射，映射的产出物即包括编程系统和配置。配置为我们提供了&lt;strong&gt;动态修改程序运行时行为的能力&lt;/strong&gt;，即常说的“系统运行时飞行姿态的动态调整”，究其根源则是“我们人类无法掌控和预知一切，映射到软件领域上，我们总是需要对系统的某些功能特性预留出一些控制的线头，以便我们在未来需要的时候，可以人为的拨弄这些线头从而控制系统的行为特征。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，本文所指的配置特指内部运营人员产生的数据（广义的系统运营人员，包括产品、运营、研发等），并且作为输入参数而作用于编程系统（包括实时系统、批跑程序以及数据任务等）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;归纳而言，配置通常包含如下三种：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;a. 环境配置，定义了应用程序运行的环境相关参数，如 IP、Port 等；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;b. 应用配置，定义了应用程序自身相关的参数或者信息安全控制等，如初始内存分配大小、数据库连接池大小、日志级别、账号密码等；&lt;strong&gt;（密码、证书这类东西肯定不要放在配置系统中，而应当走统一加解密服务）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;c. 业务配置，定义了应用程序所执行的业务行为数据，比如最常见的&lt;strong&gt;功能开关&lt;/strong&gt;，参与活动的商户名单等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;系统约束&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据模型&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置最基本的数据单元是&lt;code&gt;key=value&lt;/code&gt;（即配置项），比如功能开关通常就是最简单的类型，用 boolean 型值来影响程序执行链路（不考虑灰度的情况）。然而只有 key-value 类型是不足的，比如 DB 的连接配置就包含了 ip、port、username、password 等字段，在 ini 文件的实现中即是不同配置项来组成，它们在逻辑上是属于同一个配置对象，因此基于面向对象的设计思路，&lt;code&gt;key=object&lt;/code&gt;才是更通用的配置模型，在物理实现中可以为 json 或者 xml，或者 protobuf message。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;object 类型的数据即可以是&lt;strong&gt;平坦的&lt;/strong&gt;，也可以是&lt;strong&gt;多层次（嵌套）的&lt;/strong&gt;。在实际的业务应用中，&lt;strong&gt;平坦&lt;/strong&gt;类型的数据有其特殊性，即其通常条目较多，最典型的数据是&lt;strong&gt;白名单&lt;/strong&gt;，可能多达上万条。线下，内部运营人员通过&lt;strong&gt;excel&lt;/strong&gt;进行这类数据的管理，如果我们只是粗暴的将其打包成一个对象，那么过大的数据可能会导致系统效率的下降（不是配置的写入效率下降，就是配置读出效率下降），因此我们会使用&lt;code&gt;array of plain object&lt;/code&gt;来表达，即&lt;code&gt;key=table&lt;/code&gt;类型的数据。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;访问模型&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相别于产品用户产生的数据，&lt;strong&gt;配置系统的数据流是单向的，离线系统与实时系统结合而读写分离（异步写、实时读）的&lt;/strong&gt;。最终我们要搭建的分布式配置系统，它的系统设计，也必然是建立在这类访问模型上的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.35428571428571426&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavVZf7eHBnCicVCPkFCwjfVlgDzXqicX6ZBiasNcltZ5saclia6dedQAN93IN6HVZUAf4WOJBvcSSh3TA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2100&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;系统约束&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然，内部运营人员作为生产者，所有的&lt;strong&gt;配置肯定都是文本类型的（Readable）&lt;/strong&gt;，并且&lt;strong&gt;数据量少&lt;/strong&gt;(相对于用户、系统等生产数据而言），对存储空间需求少，&lt;strong&gt;更新频次低&lt;/strong&gt;。可以这么理解，在整个配置系统架构中，输入方就如同键盘相对于 CPU 而言是超慢速设备，他们对系统的&lt;strong&gt;易用性、易操作性、安全性&lt;/strong&gt;要求更高。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;em&gt;我们思考下用户画像系统，它部分满足配置系统的访问模型，即数据流是单向的，离线系统负责写入画像数据，而实时系统读数据。但是首先它的数据生产者通常是离线任务，而非运营人员；再次，它涉及到的数据量是巨大的，通常需要定制的存储引擎。配置系统与之相比，不可同日而语。&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相较而言，配置系统的消费者则是&lt;strong&gt;高频&lt;/strong&gt;的读访问，对系统的&lt;strong&gt;吞吐量&lt;/strong&gt;、&lt;strong&gt;延时&lt;/strong&gt;、&lt;strong&gt;网络流量&lt;/strong&gt;、&lt;strong&gt;可用性、一致性、请求单调性&lt;/strong&gt;都有更高的要求。后续我们逐一展开深入的思考。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置系统的设计应当充分考虑到上述的数据模型、访问模型以及系统约束。（比较奇怪的是，笔者在查阅相关配置系统实现时，鲜少看到有针对一致性、请求单调性的讨论。这也是促使笔者撰写本文的原因）&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;安全约束&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正因为配置可以轻易的调整系统运行期行为，因此配置的安全性至关重要。实现安全的必要条件是：&lt;strong&gt;让正确的人，以正确的方式，在正确的时机，发布正确的配置&lt;/strong&gt;。因此，配置系统不但要&lt;strong&gt;支持灰度发布&lt;/strong&gt;的基本能力，还要在&lt;strong&gt;权限管理、权限粒度管理、配置变更审核、审计、历史版本&lt;/strong&gt;等方面都要加强建设。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;系统的演进&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;单机配置文件&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在单机系统时代，我们基本上都是使用配置文件来存储配置数据（比如 ini 文件、xml 文件等）。配置文件易于理解、便于实现、可用性高，因此进入分布式集群时代，仍在广泛使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而配置文件存在诸多的缺点，包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;易用性差&lt;/strong&gt;，主要体现为表达的数据类型单一，比如 ini 只能管理配置项，即 key=value 类型数据；而如果使用 xml 文件来管理 key=table 类型数据，那么文件内容的初始化效率低下，容易出错，难以维护；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;可操作性差&lt;/strong&gt;，配置文件基本只能由开发来进行修改并且发布，产品、运营的常规业务素材变更工作就不得不卷入开发执行，对业务的流程效率有严重的影响；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;正确性、安全性难以保障&lt;/strong&gt;，正因为配置文件的易于实现，导致很多团队疏忽了运营系统的建设，研发人员随意修改、恶意修改配置文件的情况无法杜绝，细粒度的权限管理、操作的审核、审计无从谈起；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;发布效率低下&lt;/strong&gt;，配置文件是单机部署的，在集群规模较大的情况下，配置文件的任意变更都需要经过漫长的灰度发布过程发布到全网，如果配置文件是静态加载的，还需要重启二进制，需要消耗研发、运维人员较多的精力；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;文件一致性难以保障&lt;/strong&gt;，在发布配置变更的过程中，如果集群中出现宕机情况，会导致不同机器间的配置出现差异，而没有自动校正的能力，依赖于人员或者运维系统的支持，从而导致业务进入未定义的行为。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24298621017593913&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavVZf7eHBnCicVCPkFCwjfVlkicukmCCP39ON0A94aVicxcAMqt5vvlMnQn2u2gibf4y3S4c3qXKTyROw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2103&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果说易用性、可操作性、正确性、安全性可以通过搭建运营系统来进行改进，而发布效率低下、文件一致性难以保障则是单机配置文件的致命弱点，究其本质，是因为单机配置文件系统是被动的、离散的接受外界的变更，而没有主动的能力。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;集中式配置文件中心&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此，出现了集中式的配置文件系统，针对性的解决了上述的问题，开发人员将配置文件存储到独立的第三方服务（典型的由 ZooKeeper 进行管理，也有部分团队自行实现微服务管理），然后由 agent 周期性的将配置拉取到本地进行缓存（&lt;strong&gt;拉&lt;/strong&gt;），或者通过事件的订阅通知能力来将变更发布到相应集群（&lt;strong&gt;推&lt;/strong&gt;）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.31351094196003804&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavVZf7eHBnCicVCPkFCwjfVlzyMMyKiadSc5IxPWqEjibzfdYpS06vanyEEHfhE2aT8Fw1HQ8QcQ0atQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2102&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;集中式配置文件系统针对性的解决了发布变更效率问题以及配置文件一致性保障问题。然而在笔者所知的应用案例中，仍然存在如下的问题亟需解决：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;一致性粒度粗&lt;/strong&gt;，集中式配置文件只能确保分布式集群达到最终一致（时间取决于拉、推的频率及速率），却无法保证任一时刻，对任一配置，所有进程、线程、协程看到相同的数据，而这通常会导致出现不预期的业务失败；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;无法保证请求单调性&lt;/strong&gt;，在一次业务请求中，我们希望用户看到的配置内容是静态的，如果中间发生变更，可能带来业务失败，严重的导致用户数据状态错乱；而基于集中式配置文件系统的配置通常是动态加载的，配置的变更可能随时的反应到实时系统中，导致一次业务请求先后看到不同的数据状态；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;安全性仍无法彻底保障&lt;/strong&gt;，虽然集中式配置文件的修改可以控制权限，但是在消费者机器上，开发者仍然可以手动的修改本地配置文件 cache 来影响程序的运行行为；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;无法支持灰度能力&lt;/strong&gt;，配置文件变更的下发是全量的，如果要支持灰度发布的能力，就需要卷入业务方自行实现；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置文件系统，无论是单机配置文件，还是集中式配置文件，存在的问题，归根结底，是由于配置文件这个载体以及集中式配置文件系统的管道定位决定的，从而导致进行精细化管理的成本高：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;配置文件的可视可读能力对生产者而言是重要的，但对消费者却是无关紧要的，因此全链路都由配置文件作为载体反而可能导致&lt;strong&gt;加载效率低下&lt;/strong&gt;（比如应对千万级黑白名单，或者业务方实时请求链路动态加载）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置文件难以安全、便利管理元信息，为了实现一致性、单调性、安全性，配置需要一些元数据信息管理（下文展开详述），但是配置文件系统没有这种能力，除非业务方使用高成本自行实现；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置文件的数目与配置的数量息息相关，随着时间的发展，&lt;strong&gt;配置文件数目膨胀&lt;/strong&gt;，带来新的运营问题；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;集中式配置文件系统通常只把自己定位成&lt;strong&gt;管道&lt;/strong&gt;（据笔者所知），即不理解也不维护配置文件的内容，agent 功能单一，业务消费方不与系统直接交互，而是只看到配置文件，虽然松耦合可以提高可用性，但也让业务方仍然投入不少的开发成本来处理配置文件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置文件只是配置的物理载体，上述缺点并非无法克服，只是在基于配置文件的配置系统下，实现上述能力的成本高，需要更多的使用约束，以及外围配套。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据库配置存储&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对结构复杂、类型较多的配置，业务研发同学通常也不会直接使用配置文件来承载，而是使用数据库（关系型或非关系型）库表来存储配置，然后再编写工具进行数据的导入。这种存储方案克服了配置文件的部分问题，对配置有更精细化的管理。但是也存在明显的不足，即高度的定制化，不可复用，重复开发高。因此，我们需要对此进行完善，将配置的存储、读、写、管理等过程提炼共性，通用化、平台化。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;方案思考&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;物理模型&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然配置文件难以精细化管理，且具备易侵入的物理实体（本地文件），我们需要新的数据结构来承载配置。前文我们讨论过，配置有两种数据模型，分别是&lt;code&gt;key=object&lt;/code&gt;以及&lt;code&gt;key=table&lt;/code&gt;。对使用者而言，配置必须是可视、可读、易管理的。为了达成这目的，我们只需在内部运营人员与配置系统核心之间搭一套设计良好的&lt;strong&gt;运营系统&lt;/strong&gt;即可。那么在后端呢？对消费者而言，最注重传输、计算的效率，同时为了与微服务框架的对齐，&lt;strong&gt;protobuf message&lt;/strong&gt;无疑是最佳的形式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而 protobuf 无法自解释，在没有 message 定义的情况下，我们即没办法将文本性的配置转换成 pb 二进制流，也没办法反序列化。因此必须将业务的 message 定义上提到运营系统，然而 protobuf 却对可视化编辑不太友好。因此一个可行的思路是基于&lt;strong&gt;JSON 数据&lt;/strong&gt;进行配置的定义、可视化操作、传输及存储。只有到达业务侧才进行数据类型的转换。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.14469300333174678&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavVZf7eHBnCicVCPkFCwjfVlPPCH15korB8frykYMU7VpxfDcicCuIMQ2KmEAMiaUXvbaicZmLSwoVdicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2101&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;安全管理&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;搭建一套配置运营系统，让之成为运营人员管理配置的唯一入口，轻松就可以得到很高的回报。我们可以基于运营系统进行各种配置安全加固，如配置的变更必须具备相应的权限，而且只有通过审核才能应用到系统，所有的操作都要有审计的能力，配置的历史版本快速可查等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时灰度、回退等能力也需要基于运营系统进行操作。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2557142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavVZf7eHBnCicVCPkFCwjfVlpq3KDhJSuzTWVXWic8R7sjnpoDvicndW25gK9rkQr2xnmhe4wj3icBvWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2100&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;配置系统 SDK&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文提及，集中式配置文件系统的管道定位，agent 只负责定期的拉取配置然后缓存到本地的文件系统。业务系统与配置系统松耦合。我们认为配置文件仍然具有较高的开发成本，对业务方而言，最佳的开发形式应当是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; GetConfig&amp;lt;Message&amp;gt;(&lt;span&gt;const&lt;/span&gt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;string&lt;/span&gt;&amp;amp; key, ::google::protobuf::Message&amp;amp; msg);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而不需要再去理解文件内容、形式。那么我们就有必要为业务方提供一套配置系统的 SDK，将配置系统的细节、数据结构等信息都屏蔽起来，让业务只看到配置的 Protobuf Message 对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 SDK 的基础上，消费者只需轻度介入（业务插件，见下），我们就可以完成协议转换、配置缓存、进程，线程，协程快速最终一致、请求单调、灰度发布的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;配置系统 SDK 是精细化管理的基础&lt;/strong&gt;，我们可以通过维护配置本身内容之外的&lt;strong&gt;配置元数据信息&lt;/strong&gt;来完成上述能力。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.21751546882436934&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavVZf7eHBnCicVCPkFCwjfVlvjlpuupZ9SqXNAFzgwniciakY68sQrgwmGwWlyAthcEficnT2sIvpic90w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2101&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;异步化&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;异步化是配置 SDK 的关键&lt;/strong&gt;。很多本地缓存的更新是周期性的由实时链路请求负责，易于实现，但效率上存在问题，尤其考虑到我们还需要对配置进行配置业务逻辑的处理。因此，最佳方案应当是通过异步过程来进行配置的加载、初始化及其它逻辑处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步带来的问题是异步过程与实时请求的并发问题，即异步过程在进行配置变更过程中，应如何处理实时链路的读请求，这是一个工程问题，我们会另文讨论，一个可行的思路是&lt;strong&gt;多版本及引用计数技术&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.37957244655581945&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavVZf7eHBnCicVCPkFCwjfVlI9OYbu8UfFJDBncIEzVBDnyfFwxDkF5qG9kFd56YbD9V4fvjiaqooCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2105&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;业务插件&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步为我们提供的另外一个好处是，业务可以在配置生效的时候进行一些初始化动作，比如进行进行&lt;strong&gt;配置正确性校验&lt;/strong&gt;，以及&lt;strong&gt;搭建业务适合的数据结构&lt;/strong&gt;。比如业务白名单在 pb 中只是一个数组，如果业务进行命中查找，代价比较高。业务最期望的方式肯定还是使用 map 来存储。因此配置 SDK 异步化，就为业务插件能力提供了基础。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.27423954372623577&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavVZf7eHBnCicVCPkFCwjfVlEe3UuNxQvicQYwGkGbAia0AsZWMInicmVNLdq8kMzhJzH0IdZJy33wSpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2104&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;推与拉&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们更倾向于配置 SDK 主动拉取配置的更新。推与拉的辩证在于效率和可用性。推比较高效，不存在无用的网络消耗。但是推又引入了新的系统依赖（即事件中心）。如无必要，勿增实体，基于这样的思想，我们倾向于由&lt;strong&gt;SDK 周期性主动拉取&lt;/strong&gt;。至于效率，完全可以通过各种工程的手段加以优化，达到可以接受的程度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这也取决于系统规模，如果我们要讨论的是公司机的配置系统，而不是部分中心级，那么我们也会认真的思考推或者推拉结合的模式。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;快速最终一致&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是单机配置文件系统，还是集中配置文件系统，都存在严重的不一致问题。对一次配置变更，基本上都需要很长的时间才能达到最终一致（即所有并发看到相同的数据状态）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个可行的思路是&lt;strong&gt;多版本以及定时生效&lt;/strong&gt;。配置只有在未来的某个时间（该时间内 SDK 已经拉到了最新数据）才对外可见。至于如何确保所有 SDK 都拉到了数据，这涉及到可用性的问题，我们另文讨论。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23750594954783436&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavVZf7eHBnCicVCPkFCwjfVl29mZXf7lWEf0pSYuHIcHD02NKhcuiavjcg6adFn2ia2WzIkeia5L0IibVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2101&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;请求单调&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定时生效没办法解决请求单调性的问题。&lt;strong&gt;请求单调性&lt;/strong&gt;是指，实时服务处理一次请求，在请求的调用栈过程中，读到的配置内容必须是静态、没有变动的，即使中间有待生效数据变成了生效数据。一个思路是我们可以通过&lt;strong&gt;线程私有变量&lt;/strong&gt;（协程私有变量）缓存配置版本即可。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;灰度发布&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在配置 SDK 多版本能力的基础上，实现灰度发布的能力也是轻而易举的。灰度发布的能力，不过就是选择生效配置版本的能力，如果本机、本角色、本请求业务 key（如用户、商户、订单）等命中灰度范围，则使用新版本，否则使用原版本。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.25131139723414403&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavVZf7eHBnCicVCPkFCwjfVlAx8MviaG69BBgempD5xMRnAmvObETXCDT9gxow541qCiajNCKObiaFIeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2097&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;效率提升&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;效率提升包括降低网络传输数据量、降低配置存储服务的压力，这些都是具体的工程手段，我们不在本理论篇内讨论。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可用性提升&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式系统的可用性提升是老生常谈的话题，为了聚焦于配置系统独特的能力，我们本篇不专门进行讨论。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（However，尽量减少系统中的单点，是一个重要的原则。在前节”推与拉“中也有涉及。同时为了业务的可用性，第三方配置系统的运营能力、故障主动发现能力、故障通知能力、再现及定位能力也非常重要。也这是重复造轮子的一个不得已的重要原因，很多团队软件可能作的不错，但服务能力（主要指运营能力）却有点差强人意。）&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;加入我们&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;境外支付团队在不断追求卓越的路上寻找同路人，岗位需求：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://careers.tencent.com/m/jobdesc.html?postId=1298934958332583936&quot; data-linktype=&quot;2&quot;&gt;28605-微信支付境外支付前端开发工程师（深圳）&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;10月24日，约你来腾讯滨海大厦&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;3.5164835164835164&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvathJtXibmj1iaEQC217HgGPiawibKQ8coQib2FW96OSmVdOOZrsbtP29pPEwqMLsUx30RI8K66pktzDhpw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;728&quot;/&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;10.16 世界粮食日&lt;/span&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们用AI技术助力了一场光盘行动&lt;/span&gt;&lt;/h4&gt;&lt;span&gt;‍&lt;/span&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAqH0WReF1EgAAAAstQy6ubaLX4KHWvLEZgBPEx6EwJkhHT6L5zNPgMItSRNKrAt6Gsw0ShaWLH3DR&quot; data-url=&quot;https://findermp.video.qq.com/251/20350/stodownload?encfilekey=jEXicia3muM3GjTlk1Z3kYCefzc4VU4EAS349rsIhicRvwqMY1rPNVs7Mr3Zw2uQVyb2m8ASiaPO2kP67BJ4uzUWPzmqibPJLc4rLesJ7PmbCL84RImw611wYdnksbbvLCM1nF2EFKiafW44PT54iabG7F4a1icG6qZ3ibHyODd6oY3kobK0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=a6dea7fde49f377219ff2eab5724d45f&amp;amp;token=x5Y29zUxcibA4jnHycsS44PCgdLMqKXOg3XBUx1pDrvFx4AKhCcF8tWzlsv1SPcqy&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xEecUymmic8cw4v7Y2zbnVDuo/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;拍照也能助力光盘行动？关于节约粮食，大家有什么妙招呢？  @腾讯公益  @微信派 #光盘行动#  #世界粮食日#  #节约粮食#  #技术公益# &quot; data-nonceid=&quot;4871113052233066306&quot; data-type=&quot;video&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;‍&lt;/span&gt;欢迎关注视频号 腾讯程序员&lt;/span&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为你分享有趣、实用的腾讯产品&amp;amp;技术&lt;span&gt;‍&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;&lt;span&gt;‍&lt;/span&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.729264475743349&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvatricjRxhpM1x45aB6doaVg7WMhINPwOiaqpskia1kH7hgibO0dicW2HLcW8HRGMzESQwehIcyckLXtwsA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;639&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>35b7635a5338faf92d3ba0f15660bc69</guid>
<title>[推荐] 想自己写框架？不会写 Java 注解可不行</title>
<link>https://toutiao.io/k/9j801i6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;img data-ratio=&quot;0.5107066381156317&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoF5meUibw0yzDr8WJvWZZdqOIIwTs8SQTGtujhpO4wUf2bPiaCMDMfPJBydvqLFYSAFEHHOLekPcIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1868&quot;/&gt;&lt;/h1&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;用注解一时爽，一直用一直爽&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java后端开发进入spring全家桶时代后，开发一个微服务提供简单的增删改查接口跟玩泥巴似的非常简单，一顿操作猛如虎，回头一看代码加了一堆注解：@Controller @Autowired @Value，面向注解编程变成了大家不可缺少的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想象一下如果没有注解Java程序员可以要哭瞎😭&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然注解（annotation）这么重要，用的这么爽，那注解的实现原理你知道么？我猜你只会用注解不会自己写注解（手动滑稽）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，下面的内容带大家从零开始写一个注解，揭开注解神秘的面纱。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;原来注解不神秘&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注解用大白话来说就是一个标记或者说是特殊的注释，如果没有解析这些标记的操作那它啥也不是。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注解的格式如同类或者方法一样有自己特殊的语法，这个语法下文会详细介绍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那如何去解析注解呢？这就要用到Java强大的反射功能了。反射大家应该都用过，可以通过类对象获取到这个类的各种信息比如成员变量、方法等，那注解标记能不能通过反射获取呢？当然可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以注解的原理其实很简单，本质上是通过反射功能动态获取注解标记，然后按照不同的注解执行不同的操作，比如@Autowired可以注入一个对象给变量赋值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里是不是很躁动啊，来吧自己也撸一个注解。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;造火箭啦，自己动手写一个注解&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;便于大家理解，这里先引入一个场景：在线教育火了，经理让我写一个模块实现学生信息管理功能，考虑到分布式并发问题，经理让我务必加上分布式锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经理问我几天能搞定？我说至少3天。如是脑补了以下代码：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6792452830188679&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoF5meUibw0yzDr8WJvWZZdqqlLKjLNNCtPCHibIuk1mn2diaf8Klgconujc6bl0oUkt0LnwnBZkFiarQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1060&quot;/&gt;&lt;figcaption&gt;未使用注解前&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经理走后我在思考，我能不能只花一天时间写完，剩下两天时间用来写博客划水呢？突然灵感来了，我可以把重复的代码逻辑抽出来用注解实现不就节省代码了，哈哈，赶紧写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用注解之后整个方法清爽了很多，HR小姐姐都夸我写的好呢。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34057971014492755&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoF5meUibw0yzDr8WJvWZZdqEmXvlkS1Os6hgkYAP7icgjSbNhw9dZY3kANTX6G2rGklJibFJDEkPE1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1104&quot;/&gt;&lt;figcaption&gt;使用注解后&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码已经写完上库了，现在我在划水写博客呢。是不是很简洁很优雅很牛逼，怎么做到的呢，主要分为三步：&lt;span&gt;1打开冰箱门，2把大象放进去，3把冰箱门关好&lt;/span&gt;。好了，扯远了，大家接着往下看。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第一步定义一个注解&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5019455252918288&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoF5meUibw0yzDr8WJvWZZdqMZ5FFRhuPEK5IFahHnN9HVuDN0Fg8g5dHTct84u3q32SWqVUl9hMWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1028&quot;/&gt;&lt;figcaption&gt;注解的三大组成部分&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个注解可以简单拆解为三个部分：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一部分：注解体&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注解的定义有点类似于接口（interface），只不过前面一个加了一个@符号，这个千万不能省。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二部分：注解变量&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注解变量的语法有点类似于接口里面定义的方法，变量名后面带一对括号，不同的是注解变量后面可以有默认值。另外返回值只能是Java基本类型、String类型或者枚举类，不可以是对象类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三部分：元注解&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;元注解（meta-annotation）说白了就是给注解加注解的注解，是不是有点晕了，这种注解是JDK提前内置好的，可以直接拿来用的。不太懂也没有关系反正数量也不多，总共就4个，我们背下来吧：@Target @Retention @Documented @Inherited&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用来描述注解的使用范围，即被修饰的注解可以用在什么地方 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数），在定义注解类时使用了@Target 能够更加清晰的知道它能够被用来修饰哪些对象，具体的取值范围定义在ElementType.java 枚举类中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如上面我们写的Redis锁的注解就只能用于方法上了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用来描述注解保留的时间范围，即注解的生命周期。在 RetentionPolicy 枚举类中定义了三个周期：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; RetentionPolicy {&lt;br/&gt;    SOURCE, &lt;span&gt;// 源文件保留&lt;/span&gt;&lt;br/&gt;    CLASS,  &lt;span&gt;// 编译期保留，默认值&lt;/span&gt;&lt;br/&gt;    RUNTIME &lt;span&gt;// 运行期保留，可通过反射去获取注解信息&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像我们熟知的@Override注解就只能保留在源文件中，代码编译后注解就消失了。比如上面我们写的Redis锁的注解就保留到了运行期，运行的时候可以通过反射获取信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用来描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息，很简单不多解释了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;被Inherited注解修饰的注解具有继承性，如果父类使用了被@Inherited修饰的注解，则其子类将自动继承该注解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，这一步我们已经将注解定义好了，但是这个注解如何工作呢？接着看。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第二步实现注解的业务逻辑&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在第一步中我们发现定义的注解（@EnableRedisLock）中没有业务逻辑，只有一些变量，别忘了我们的注解是要使能Redis分布式锁的功能，那这个注解到底是怎么实现加锁和释放锁的功能呢？这个就需要我们借助反射的强大功能了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8320987654320988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoF5meUibw0yzDr8WJvWZZdqUn3Q8519JibztRk3QLv37icMBdN7k9bGpbUSHaa1aWTxXc2Vv8z8JHXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1620&quot;/&gt;&lt;figcaption&gt;注解的操作&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里借助了切面的功能，将EnableRedisLock注解作为一个切点，只要方法上标注了这个注解就会自动执行这里的代码逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过反射机制拿到注解对象后就可以执行加锁解锁的常用逻辑啦。Redis实现分布式锁相信大家已经很熟悉了，这里就不在啰嗦了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第三步在业务代码中尽情的使用注解&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@EnableRedisLock&lt;/span&gt;(lockKey = &lt;span&gt;&quot;student&quot;&lt;/span&gt;, expireTime = &lt;span&gt;10&lt;/span&gt;, timeUnit = TimeUnit.SECONDS, retryTimes = &lt;span&gt;5&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;method1&lt;/span&gt;&lt;span&gt;(Student student)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 这里写业务逻辑&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在需要加锁的方法上直接加上注解就可以啦，怎么样是不是很简单呀，赶紧在你的项目中运用起来吧。 &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，自己写一个注解的内容就介绍到这里了，学会了吗？&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>