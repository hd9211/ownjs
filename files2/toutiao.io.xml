<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f8028b4fcba6fdffdceecadd411cf538</guid>
<title>欢迎加入读者圈子，一起交流！</title>
<link>https://toutiao.io/k/juhy4n7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;欢迎加入读者圈子，一起交流！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;307&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavich3VaNkKeiaAwUhz7TQbQmic4fFsr58X9PAYleYzxqc1K1vZjeBoZDMUsmia0xH67EQYINGRvNOtLmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;圈子剧透&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、600+圈子成员，以中高级程序员为主，更有架构师、CTO坐镇交流；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、1000+优质主题，数十G独家资料，每日分享，精挑细选；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、全年52期专属邮件周报，让你轻松掌握业界资讯、技术干货，提升认知水平；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、全年52本好书共读，让你花最少的时间，获取更好的知识；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;心动不如行动，赶快加入吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f55df2fcfc1ec86c5afb652d8e3ef649</guid>
<title>技术人 | “一直写代码会丧失竞争力吗？”</title>
<link>https://toutiao.io/k/dvu60jc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;

          

          
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c2222282ac18b6ec86009bcebc2597f0</guid>
<title>腾讯妹子图解Golang内存分配和垃圾回收</title>
<link>https://toutiao.io/k/1nrxnmu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section&gt;&lt;span&gt;导语 |&lt;/span&gt;&lt;span&gt; 现代高级编程语言管理内存的方式分自动和手动两种。手动管理内存的典型代表是C和C++，编写代码过程中需要主动申请或者释放内存；而PHP、Java 和Go等语言使用自动的内存管理系统，由内存分配器和垃圾收集器来代为分配和回收内存，其中垃圾收集器就是我们常说的GC。今天&lt;span&gt;腾讯后台开发工程师汪汇&lt;/span&gt;向大家分享 Golang 垃圾回收算法。（当然，Rust 是另一种）&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从Go v1.12版本开始，Go使用了&lt;/span&gt;&lt;span&gt;&lt;strong&gt;非分代的、并发的、基于三色标记清除的垃圾回收器&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。相关标记清除算法可以参考C/C++，而Go是一种静态类型的编译型语言。因此，Go不需要VM，Go应用程序二进制文件中嵌入了一个小型运行时(Go runtime)，可以处理诸如垃圾收集(GC)、调度和并发之类的语言功能。首先让我们看一下Go内部的内存管理是什么样子的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;一、 Golang内存管理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里先简单介绍一下 Golang 运行调度。在 Golang 里面有三个基本的概念：G, M, P。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个 Goroutine 的运行需要G+P+M三部分结合起来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6171875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94Cjxng5VbT4M7FkUgyAfhpQu2e0dr5z6Za2b2aIw9peb8icIQyc29bC7VNuYfPh81ibaUdoSJg6ibicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;图源&lt;/span&gt;&lt;span&gt;：《Golang---内存管理(内存分配)》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(http://t.zoukankan.com/zpcoding-p-13259943.html)&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（一）TCMalloc&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Go将内存划分和分组为页（Page），这和Java的内存结构完全不同，没有分代内存，这样的原因是Go的内存分配器采用了TCMalloc的设计思想：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1.Page&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与TCMalloc中的Page相同，x64下1个Page的大小是8KB。&lt;/span&gt;&lt;span&gt;上图的最下方，1个浅蓝色的长方形代表1个Page。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.Span&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与TCMalloc中的Span相同，Span是内存管理的基本单位，代码中为mspan，一组连续的Page组成1个Span，所以上图一组连续的浅蓝色长方形代表的是一组Page组成的1个Span，另外，1个淡紫色长方形为1个Span。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3.mcache&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;mcache是提供给P（逻辑处理器）的高速缓存，用于存储小对象（对象大小&amp;lt;= 32Kb）。尽管这类似于线程堆栈，但它是堆的一部分，用于动态数据。所有类大小的mcache包含scan和noscan类型mspan。Goroutine可以从mcache没有任何锁的情况下获取内存，因为一次P只能有一个锁G。因此，这更有效。mcache从mcentral需要时请求新的span。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4.mcentral&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;mcentral与TCMalloc中的CentralCache类似，是所有线程共享的缓存，需要加锁访问，它按Span class对Span分类，串联成链表，当mcache的某个级别Span的内存被分配光时，它会向mcentral申请1个当前级别的Span。&lt;/span&gt;&lt;span&gt;每个mcentral包含两个mspanList：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;5.mheap&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;mheap与TCMalloc中的PageHeap类似，它是堆内存的抽象，也是垃圾回收的重点区域，把从OS申请出的内存页组织成Span，并保存起来。当mcentral的Span不够用时会向mheap申请，mheap的Span不够用时会向OS申请，向OS的内存申请是按页来的，然后把申请来的内存页生成Span组织起来，同样也是需要加锁访问的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;6.栈&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是栈存储区，每个Goroutine（G）有一个栈。&lt;/span&gt;&lt;span&gt;在这里存储了静态数据，包括函数栈帧，静态结构，原生类型值和指向动态结构的指针。&lt;/span&gt;&lt;span&gt;这与分配给每个P的mcache不是一回事。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（二）内存分配&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;G&lt;/span&gt;&lt;span&gt;o 中的内存分类并不像TCMalloc那样分成小、中、大对象，但是它的小对&lt;/span&gt;&lt;span&gt;象里又细分了一个Tiny对象，Tiny对象指大小在1Byte到16Byte之间并且不包含指针的对象。&lt;/span&gt;&lt;span&gt;小对象和大对象只用大小划定，无其他区分。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;核心思想&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;把内存分为多级管理，降低锁的粒度(只是去mcentral和mheap会申请锁), 以及多种对象大小类型，减少分配产生的内存碎片。&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;使用mcache的微小分配器分配小于16个字节的对象，并且在单个16&lt;/span&gt;&lt;span&gt;字节块上可完成多个微小分配。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;大小在16个字节和32k字节之间的对象被分配在G运行所在的P的mcache的对应的mspan size class上。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大于32 KB的对象直接分配在mheap的相应大小类上(size class)。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果mheap为空或没有足够大的页面满足分配请求，则它将从操作系统中分配一组新的页（至少1MB）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如&lt;/span&gt;&lt;span&gt;果对应的大小规格在mcache中没有可用的块，则向mcentral申请。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果mcentral中没有可用的块，则向mheap申请，并根据BestFit 算法找到最合适的mspan。如果申请到的mspan超出申请大小，将会根据需求进行切分，以返回用户所需的页数。剩余的页构成一个新的mspan放回mheap的空闲列表。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果mheap中没有可用span，则向操作系统申请一系列新的页（最小 1MB）。Go 会在操作系统分配超大的页（称作arena）。分配一大批页会减少和操作系统通信的成本。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（三）内存回收&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;go内存会分成堆区（Heap）和栈区（Stack）两个部分，程序在运行期间可以主动从堆区申请内存空间，这些内存由内存分配器分配并由垃圾收集器负责回收。栈区的内存由编译器自动进行分配和释放，栈区中存储着函数的参数以及局部变量，它们会随着函数的创建而创建，函数的返回而销毁。如果只申请和分配内存，内存终将枯竭。Go使用垃圾回收收集不再使用的span，把span释放交给mheap，mheap对span进行span的合并，把合并后的span加入scav树中，等待再分配内存时，由mheap进行内存再分配。&lt;/span&gt;&lt;strong&gt;因此，Go堆是Go垃圾收集器管理的主要区域&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;二、 标记清除算法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当成功区分出 Go 垃圾收集器管理区域的存活对象和死亡对象后，Go 垃圾收集器接下来的任务就是执行GC，释放无用对象占用的内存空间，以便有足够的可用内存空间为新对象分配内存。目前常见的垃圾回收算法在上篇《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247518133&amp;amp;idx=1&amp;amp;sn=186ef93a6add47b01cac2f355211f6cd&amp;amp;chksm=eaa89de5dddf14f39b4172adb6bf1f964252a244f9887286a6cae30aefe2b27833db9407d58f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;自动的内存管理系统实操手册——Java垃圾回收篇&lt;/a&gt;》一文&lt;/span&gt;&lt;span&gt;中的“垃圾收集算法”部分已有介绍，而&lt;/span&gt;&lt;strong&gt;Go使用的是标记清除算法&lt;/strong&gt;&lt;span&gt;，这是一种非常基础和常见的垃圾收集算法，于1960年被J.McCarthy等&lt;/span&gt;&lt;span&gt;人提出。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当堆空间被耗尽的时，就会STW(也被称为stop the world)，其执行过程可以分成标记和清除两个阶段。Go 垃圾收集器从根结点开始遍历，执行可达性分析算法，递归标记所有被引用的对象为存活状态；标记阶段结束后，垃圾收集器会依次遍历堆中的对象并清除其中的未被标记为存活的对象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于用户程序在垃圾收集的过程中也不能执行（STW）。在可达性分析算法中，Go 的GC Roots一般为全局变量和G Stack中的引用指针，和整堆的对象相比只是极少数，因此它带来的停顿是非常短暂且相对固定的，不随堆容量增长。在从GC Roots往下遍历对象的过程，堆越大，存储对象越多，递归遍历越复杂，要标记更多对象而产生的停顿时间自然就更长。因此我们需要用到更复杂的机制来解决STW的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;三、三色可达性分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了解决标记清除算法带来的STW问题，Go和Java都会实现三色可达性分析标记算法的变种以缩短STW的时间。三色可达性分析标记算法按“是否被访问过”将程序中的对象分成白色、黑色和灰色：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;白色对象 — 对象尚未被垃圾收集器访问过，在可达性分析刚开始的阶段，所有的对象都是白色的，若在分析结束阶段，仍然是白色的对象，即代表不可达。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;黑色对象 — 表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经被扫描过，黑色的对象代表已经被扫描过而且是安全存活的，如果有其他对象只想黑色对象无需再扫描一遍，黑色对象不可能直接（不经过灰色对象）指向某个白色对象。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;灰色对象 — 表示对象已经被垃圾收集器访问过，但是这个对象上至少存在一个引用还没有被扫描过，因为存在指向白色对象的外部指针，垃圾收集器会扫描这些对象的子对象。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;三色可达性分析算法大致的流程是（初始状态所有对象都是白色）：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.从GC Roots开始枚举，它们所有的直接引用变为灰色（移入灰色集合&lt;/span&gt;&lt;span&gt;），GC Roots变为黑色。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.从灰色集合中取出一个灰色对象进行分析：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.重复步骤2，一直重复直到灰色集合为空。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.分析完成，仍然是白色的对象就是GC Roots不可达的对象，可以作为垃圾被清理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体例子如下图所示，经过三色可达性分析，最后白色H为不可达的对象，是需要垃圾回收的对象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8921875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94Cjxng5VbT4M7FkUgyAfhpTg82w6bpdH5FmHRajnIIJTbqbEAqJUZYYUw59vkeOzoxYkHjhOPTCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;三色标记清除算法本身是不可以并发或者增量执行的，它需要STW，而如果并发执行，用户程序可能在标记执行的过程中修改对象的指针。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.9483204134366925&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94Cjxng5VbT4M7FkUgyAfhpDGBI8liaibcvyXxOjP7kowzG1TnVmgAJefhegPo2IJiabXQ6IxnRdVqPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;774&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种情况一般会有2种：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.一种是把原本应该垃圾回收的死亡对象错误的标记为存活。&lt;/span&gt;&lt;span&gt;虽然这不好，但是不会导致严重后果，只不过产生了一点逃过本次回收的浮动垃圾而已，下次清理就可以，比如上图所示的三色标记过程中，用户程序取消了从B对象到E对象的引用，但是因为B到E已经被标记完成不会继续执行步骤2，所以E对象最终会被错误的标记成黑色，不会被回收，这个D就是浮动垃圾，会在下次垃圾收集中清理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.一种是把原本存活的对象错误的标记为已死亡，导致“对象消失”，这在内存管理中是非常严重的错误。&lt;/span&gt;&lt;span&gt;比如上图所示的三色标记过程中，用户程序建立了从B对象到H对象的引用(例如&lt;/span&gt;&lt;strong&gt;B.next =H&lt;/strong&gt;&lt;span&gt;)，接着执行&lt;/span&gt;&lt;strong&gt;D.next=nil&lt;/strong&gt;&lt;span&gt;，但是因为B到H中不存在灰色对象，因此在这之间不会继续执行三色并发标记中的步骤2，D到H之间的链接被断开，所以H对象最终会被标记成白色，会被垃圾收集器错误地回收。&lt;/span&gt;&lt;span&gt;我们将这种错误称为&lt;/span&gt;&lt;strong&gt;悬挂指针&lt;/strong&gt;&lt;span&gt;，即指针没有指向特定类型的合法对象，影响了内存的安全性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe94Cjxng5VbT4M7FkUgyAfhppbkNLCsxLXVjMvfNibqGS5gVvdTDU7hYVCTbkbxq6U74Jia7ocyibP0KA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;四、屏障技术&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了解决上述的“对象消失”的现象，Wilson于1994年在理论上证明了，当且仅当以下两个条件同时满足时，会产生“对象消失”的问题，即原本应该是黑色的对象被误标为白色：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此为了我们要解决并发扫描时的对象消失问题，保证垃圾收集算法的正确性，只需破坏这两个条件的任意一个即可，&lt;/span&gt;&lt;strong&gt;屏障技术&lt;/strong&gt;&lt;span&gt;就是在并发或者增量标记过程中保证三色不变性的重要技术。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;内存屏障技术是一种屏障指令，它可以让CPU或者编译器在执行内存相关操作时遵循特定的约束，目前多数的现代处理器都会乱序执行指令以最大化性能，但是该技术能够保证内存操作的顺序性，在内存屏障前执行的操作一定会先于内存屏障后执行的操作。垃圾收集中的屏障技术更像是一个钩子方法，它是在用户程序读取对象、创建新对象以及更新对象指针时执行的一段代码，根据操作类型的不同，我们可以将它们分成读屏障（Read barrier）和写屏障（Write barrier）两种，因为读屏障需要在读操作中加入代码片段，对用户程序的性能影响很大，所以编程语言往往都会采用写屏障保证三色不变性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（一）插入写屏障&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Dijkstra在1978年提出了插入写屏障，也被叫做增量更新，通过如下所示的写屏障，破坏上述第一个条件（赋值器插入了一条或多条从黑色对象到白色对象的新引用）：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;DijkstraWritePointer&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(slot *unsafe.Pointer, ptr unsafe.Pointer)&lt;/span&gt;&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     shade(ptr)  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     *slot = ptr&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;添加下游对象(当前下游对象slot, 新下游对象ptr) { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; 标记灰色(新下游对象ptr) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; 当前下游对象slot = 新下游对象ptr &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__type&quot;&gt;A&lt;/span&gt;.添加下游对象(&lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;, &lt;span class=&quot;code-snippet__type&quot;&gt;B&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__type&quot;&gt;A&lt;/span&gt;.添加下游对象(&lt;span class=&quot;code-snippet__type&quot;&gt;C&lt;/span&gt;, &lt;span class=&quot;code-snippet__type&quot;&gt;B&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上&lt;/span&gt;&lt;span&gt;述伪代码非常好理解，当黑色对象（slot）插入新的指向白色对象（ptr）的引用关系时，就尝试使用shade函数将这个新插入的引用（ptr）标记为灰色。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3171875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94Cjxng5VbT4M7FkUgyAfhpj99S1E3KkyG9kbgAWz9mcJeJthjrVDZZ47DHBs3IgiaicSxjVvhlKUsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设我们上图的例子并发可达性分析中使用插入写屏障：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.GC 将根对象Root2指向的B对象标记成黑色并将B对象指向的对象D标记成灰色；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.用户程序修改指针，&lt;/span&gt;&lt;strong&gt;B.next=H&lt;/strong&gt;&lt;span&gt;这时触发写屏障将H对象标记成灰色；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.用户程序修改指针&lt;/span&gt;&lt;strong&gt;D.next=null&lt;/strong&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.GC依次遍历程序中的H和D将它们分别标记成黑色。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于栈上的对象在垃圾回收中被认为是根对象，并没有写屏障，那么导致黑色的栈可能指向白色的堆对象，例如上图1中Root2指向H，且删除了由D指向H的引用，由于没有写屏障，那么H将会被删除。为了保障内存安全，Dijkstra必须为栈上的对象增加写屏障或者在标记阶段完成重新对栈上的对象进行扫描，这两种方法各有各的缺点，前者会大幅度增加写入指针的额外开销，后者重新扫描栈对象时需要暂停程序，垃圾收集算法的设计者需要在这两者之前做出权衡。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（二）删除写屏障&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Yuasa在1990年的论文Real-time garbage collection on general-purpose machines 中提出了删除写屏障，因为一旦该写屏障开始工作，它会保证开启写屏障时堆上所有对象的可达。&lt;/span&gt;&lt;span&gt;起始时STW扫描所有的goroutine栈，保证所有堆上在用的对象都处于灰色保护下，所以也被称作快照垃圾收集（Snapshot GC），这是破坏了“对象消失”的第二个条件（赋值器删除了全部从灰色对象到该白色对象的直接或间接引用）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;YuasaWritePointer&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(slot *unsafe.Pointer, ptr unsafe.Pointer)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    shade(*slot) 先将*slot标记为灰色&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    *slot = ptr&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;添加下游对象(当前下游对象slot， 新下游对象ptr) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (当前下游对象slot是灰色 || 当前下游对象slot是白色) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          标记灰色(当前下游对象slot)     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  当前下游对象slot = 新下游对象ptr&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;A.添加下游对象(B, &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;)   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;A.添加下游对象(B, C)     &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;上述代码会在老对象的引用被删除时，将白色的老对象涂成灰色，这样删除写屏障就可以保证弱三色不变性，老对象引用的下游对象一定可以被灰色对象引用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是这样也会导致一个问题，由于会将&lt;/span&gt;&lt;strong&gt;有存活可能的对象都标记成灰色&lt;/strong&gt;&lt;span&gt;，因此最后可能会导致应该回收的对象未被回收，这个对象只有在下一个循环才会被回收，比如下图的D对象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.31640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe94Cjxng5VbT4M7FkUgyAfhpTuHVXfE7fSIbu8yNpJt877FyhAQuBB96eYr2wH7QcxKBIVxNrssIyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于原始快照的原因，起始也是执行STW，删除写屏障不适用于栈特别大的场景，栈越大，STW扫描时间越长。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（三）混合写屏障&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 Go 语言 v1.7版本之前，运行时会使用Dijkstra插入写屏障保证强三色不变性，但是运行时并没有在所有的垃圾收集根对象上开启插入写屏障。&lt;/span&gt;&lt;span&gt;因为应用程序可能包含成百上千的Goroutine，而垃圾收集的根对象一般包括全局变量和栈对象，如果运行时需要在几百个Goroutine的栈上都开启写屏障，会带来巨大的额外开销，所以 Go 团队在v1.8结合上述2种写屏障构成了混合写屏障，实现上选择了在标记阶段完成时暂停程序、将所有栈对象标记为灰色并重新扫描。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Go 语言在v1.8组合Dijkstra插入写屏障和Yuasa删除写屏障构成了如下所示的混合写屏障，该写屏障会将被覆盖的对象标记成灰色并在当前栈没有扫描时将新对象也标记成灰色：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;writePointer(slot, ptr):&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    shade(*slot)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; current stack &lt;span class=&quot;code-snippet__keyword&quot;&gt;is&lt;/span&gt; grey:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        shade(ptr)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    *slot = ptr&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;为了移除栈的重扫描过程，除了引入混合写屏障之外，在垃圾收集的标记阶段，我们还需要将创建的所有新对象都标记成黑色，防止新分配的栈内存和堆内存中的对象被错误地回收，因为栈内存在标记阶段最终都会变为黑色，所以不再需要重新扫描栈空间。总结来说主要有这几点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;G&lt;/span&gt;&lt;span&gt;C开始将栈上的对象全部扫描并标记为黑色；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;GC期间，任何在栈上创建的新对象，均为黑色；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;被删除的堆对象标记为灰色；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;被添加的堆对象标记为灰色。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;五、GC演进过程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;v1.0 — 完全串行的标记和清除过程，需要暂停整个程序；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;v1.1 — 在多核主机并行执行垃圾收集的标记和清除阶段；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;v1.3 — 运行时&lt;/span&gt;&lt;strong&gt;基于只有指针类型的值包含指针&lt;/strong&gt;&lt;span&gt;的假设增加了对栈内存的精确扫描支持，实现了真正精确的垃圾收集；&lt;/span&gt;&lt;span&gt;将unsafe.Pointer类型转换成整数类型的值认定为不合法的，可能会造成悬挂指针等严重问题；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;v1.5 — 实现了基于&lt;/span&gt;&lt;strong&gt;三色标记清扫的并发&lt;/strong&gt;&lt;span&gt;垃圾收集器：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;v1.6 — 实现了去中心化的垃圾收集协调器：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;v1.7 — 通过&lt;/span&gt;&lt;strong&gt;并行栈收缩&lt;/strong&gt;&lt;span&gt;将垃圾收集的时间缩短至2ms以内；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;v1.8 — 使用&lt;/span&gt;&lt;strong&gt;混合写屏障&lt;/strong&gt;&lt;span&gt;将垃圾收集的时间缩短至0.5ms以内；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;v1.9 — 彻底移除暂停程序的重新扫描栈的过程；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;v1.10 — 更新了垃圾收集调频器（Pacer）的实现，分离软硬堆大小的目标；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;v1.12 — 使用&lt;/span&gt;&lt;strong&gt;新的标记终止算法&lt;/strong&gt;&lt;span&gt;简化垃圾收集器的几个阶段；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;v1.13 — 通过新的 Scavenger 解决瞬时内存占用过高的应用程序向操作系统归还内存的问题；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;v1.14 — 使用全新的页分配器&lt;/span&gt;&lt;strong&gt;优化内存分配的速度&lt;/strong&gt;&lt;span&gt;；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;v1.15 — 改进编译器和运行时内部的CL 226367，它使编译器可以将更多的x86寄存器用于垃圾收集器的写屏障调用；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;v1.16 — Go runtime默认使用MADV_DONTNEED更积极的将不用的内存释放给OS。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;六、GC过程&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Golang GC 相关的代码在&lt;/span&gt;&lt;strong&gt;runtime/mgc.go&lt;/strong&gt;&lt;span&gt;文件下，可以看见GC总共分为4个阶段(翻译自Golang v1.16版本源码)：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1.sweep termination（清理终止）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.the mark phase（标记阶段）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;将&lt;/span&gt;&lt;strong&gt;GC状态gcphase从_GCoff改成_GCmark&lt;/strong&gt;&lt;span&gt;、开启写屏障、启用协助线程（mutator assists）、将根对象入队；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;恢复程序执行，标记进程（mark workers）和协助程序会开始并发标记内存中的对象，写屏障会覆盖的重写指针和新指针（标记成灰色），而所有新创建的对象都会被直接标记成黑色；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;GC执行根节点的标记，这包括扫描所有的栈、全局对象以及不在堆中的运行时数据结构。&lt;/span&gt;&lt;span&gt;扫描goroutine栈会导致goroutine停止，并对栈上找到的所有指针加置灰，然后继续执行goroutine；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;GC遍历灰色对象队列，会将灰色对象变成黑色，并将该指针指向的对象置灰；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;由于GC工作分布在本地缓存中，GC会使用分布式终止算法（distributed termination algorithm）来检测何时不再有根标记作业或灰色对象，如果没有了GC会转为mark termination（标记终止）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3. mark termination（标记终止）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4. the sweep phase（清理阶段）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;strong&gt;GC过程代码示例&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;gcfinished&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; *&lt;span class=&quot;code-snippet__title&quot;&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  p := &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  runtime.SetFinalizer(&amp;amp;p, &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(_ *&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;gc finished&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  })&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &amp;amp;p&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;allocate&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  _ = &lt;span class=&quot;code-snippet__built_in&quot;&gt;make&lt;/span&gt;([]&lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;((&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;&amp;lt;&amp;lt;&lt;span class=&quot;code-snippet__number&quot;&gt;20&lt;/span&gt;)*&lt;span class=&quot;code-snippet__number&quot;&gt;0.25&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  f, _ := os.Create(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;trace.out&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;defer&lt;/span&gt; f.Close()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  trace.Start(f)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;defer&lt;/span&gt; trace.Stop()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  gcfinished()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; n := &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;; n &amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;50&lt;/span&gt;; n++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;#allocate: &quot;&lt;/span&gt;, n)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    allocate()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__built_in&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;terminate&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;运行程序&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;hewittwang&lt;/span&gt;@&lt;span class=&quot;code-snippet__keyword&quot;&gt;HEWITTWANG&lt;/span&gt;-&lt;span class=&quot;code-snippet__keyword&quot;&gt;MB0&lt;/span&gt; rtx % GODEBUG=gctrace=&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; go run new1.go  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;gc &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; @&lt;span class=&quot;code-snippet__number&quot;&gt;0.015s&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0%&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;0.015&lt;/span&gt;+&lt;span class=&quot;code-snippet__number&quot;&gt;0.36&lt;/span&gt;+&lt;span class=&quot;code-snippet__number&quot;&gt;0.043&lt;/span&gt; ms clock, &lt;span class=&quot;code-snippet__number&quot;&gt;0.18&lt;/span&gt;+&lt;span class=&quot;code-snippet__number&quot;&gt;0.55&lt;/span&gt;/&lt;span class=&quot;code-snippet__number&quot;&gt;0.64&lt;/span&gt;/&lt;span class=&quot;code-snippet__number&quot;&gt;0.13&lt;/span&gt;+&lt;span class=&quot;code-snippet__number&quot;&gt;0.52&lt;/span&gt; ms cpu, &lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;-&amp;gt;&lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;-&amp;gt;&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; MB, &lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt; MB goal, &lt;span class=&quot;code-snippet__number&quot;&gt;12&lt;/span&gt; P&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;gc &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt; @&lt;span class=&quot;code-snippet__number&quot;&gt;0.024s&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;1%&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;0.045&lt;/span&gt;+&lt;span class=&quot;code-snippet__number&quot;&gt;0.19&lt;/span&gt;+&lt;span class=&quot;code-snippet__number&quot;&gt;0.018&lt;/span&gt; ms clock, &lt;span class=&quot;code-snippet__number&quot;&gt;0.54&lt;/span&gt;+&lt;span class=&quot;code-snippet__number&quot;&gt;0.37&lt;/span&gt;/&lt;span class=&quot;code-snippet__number&quot;&gt;0.31&lt;/span&gt;/&lt;span class=&quot;code-snippet__number&quot;&gt;0.041&lt;/span&gt;+&lt;span class=&quot;code-snippet__number&quot;&gt;0.22&lt;/span&gt; ms cpu, &lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;-&amp;gt;&lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;-&amp;gt;&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; MB, &lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt; MB goal, &lt;span class=&quot;code-snippet__number&quot;&gt;12&lt;/span&gt; P&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;....&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;栈分析&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;gc&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;2      : 第一个GC周期&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@0.024s&lt;/span&gt;   : &lt;span class=&quot;code-snippet__string&quot;&gt;从程序开始运行到第一次GC时间为0.024 秒&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;1%&lt;/span&gt;        : &lt;span class=&quot;code-snippet__string&quot;&gt;此次GC过程中CPU 占用率&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;wall&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;clock&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;0.045+0.19+0.018&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;ms clock&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;0.045&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;ms  : STW，Marking Start, 开启写屏障&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;0.19&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;ms   : Marking阶段&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;0.018&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;ms  : STW，Marking终止，关闭写屏障&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;CPU&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;time&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;0.54+0.37/0.31/0.041+0.22&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;ms cpu&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;0.54&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;ms   : STW，Marking Start&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;0.37&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;ms  : 辅助标记时间&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;0.31&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;ms  : 并发标记时间&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;0.041&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;ms   : GC 空闲时间&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;0.22&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;ms   : Mark 终止时间&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;4-&amp;gt;4-&amp;gt;0&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;MB， 5 MB goal&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;MB      ：标记开始时，堆大小实际值&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;MB      ：标记结束时，堆大小实际值&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;MB      ：标记结束时，标记为存活对象大小&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;MB      ：标记结束时，堆大小预测值&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;12&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;P      ：本次GC过程中使用的goroutine 数量&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;七、GC触发条件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;运行时会通过runtime.gcTrigger.test方法决定是否需要触发垃圾收集，当满足触发垃圾收集的基本条件（即满足_GCoff阶段的退出条件）时——允许垃圾收集、程序没有崩溃并且没有处于垃圾收集循环，该方法会根据三种不同方式触发进行不同的检查：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(t gcTrigger)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; !memstats.enablegc || panicking != &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; || gcphase != _GCoff {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;switch&lt;/span&gt; t.kind {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; gcTriggerHeap:    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; gcController.heapLive &amp;gt;= gcController.trigger&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; gcTriggerTime:      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; gcController.gcPercent &amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         lastgc := &lt;span class=&quot;code-snippet__keyword&quot;&gt;int64&lt;/span&gt;(atomic.Load64(&amp;amp;memstats.last_gc_nanotime))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; lastgc != &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; &amp;amp;&amp;amp; t.now-lastgc &amp;gt; forcegcperiod&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; gcTriggerCycle:      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int32&lt;/span&gt;(t.n-work.cycles) &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;用于开启垃圾回收的方法为runtime.gcStart，因此所有调用该函数的地方都是触发GC的代码：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（一）申请内存触发runtime.mallocgc&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Go运行时会将堆上的对象按大小分成微对象、小对象和大对象三类，这三类对象的创建都可能会触发新的GC。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.当前线程的内存管理单元中不存在空闲空间时，创建微对象(noscan &amp;amp;&amp;amp;size&amp;lt;maxTinySize)和小对象需要调用 runtime.mcache.&lt;/span&gt;&lt;span&gt;nextFree&lt;/span&gt;&lt;span&gt;从中心缓存或者页堆中获取新的管理单元，这时如果span满了就会导致返回的shouldhelpgc=true，就可能触发垃圾收集；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.当用户程序申请分配32KB以上的大对象时，一定会构建 runtime.gcTrigger结构体尝试触发垃圾收集。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;mallocgc&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(size &lt;span class=&quot;code-snippet__keyword&quot;&gt;uintptr&lt;/span&gt;, typ *_type, needzero &lt;span class=&quot;code-snippet__keyword&quot;&gt;bool&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;unsafe&lt;/span&gt;.&lt;span class=&quot;code-snippet__title&quot;&gt;Pointer&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    省略代码 ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    shouldhelpgc := &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  dataSize := size&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  c := getMCache()       &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    省略代码 ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; size &amp;lt;= maxSmallSize {  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; noscan &amp;amp;&amp;amp; size &amp;lt; maxTinySize { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  省略代码 ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          v := nextFreeFast(span)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; v == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;             v, span, shouldhelpgc = c.nextFree(tinySpanClass)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      省略代码 ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         省略代码 ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; v == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;             v, span, shouldhelpgc = c.nextFree(spc)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        省略代码 ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       shouldhelpgc = &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       省略代码 ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  省略代码 ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; shouldhelpgc {      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; t := (gcTrigger{kind: gcTriggerHeap}); t.test() {   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          gcStart(t)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  省略代码 ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; x&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这个时候调用t.test()执行的是gcTriggerHeap情况，只需要判断gcController.heapLive &amp;gt;= gcController.trigger的真假就可以了。&lt;/span&gt;&lt;span&gt; heapLive表示垃圾收集中存活对象字节数，trigger表示触发标记的堆内存大小的；&lt;/span&gt;&lt;span&gt;当内存中存活的对象字节数大于触发垃圾收集的堆大小时，新一轮的垃圾收集就会开始。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.heapLive — 为了减少锁竞争，运行时只会在中心缓存分配或者释放内存管理单元以及在堆上分配大对象时才会更新；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.trigger — 在标记终止阶段调用runtime.gcSetTriggerRatio更新触发下一次垃圾收集的堆大小，它能够决定触发垃圾收集的时间以及用户程序和后台处理的标记任务的多少，利用反馈控制的算法根据堆的增长情况和垃圾收集CPU利用率确定触发垃圾收集的时机。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（二）手动触发runtime.GC&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户程序会通过runtime.GC函数在程序运行期间主动通知运行时执行，该方法在调用时会阻塞调用方直到当前垃圾收集循环完成，在垃圾收集期间也可能会通过STW暂停整个程序：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;GC&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    n := atomic.Load(&amp;amp;work.cycles)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    gcWaitOnMark(n)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    gcStart(gcTrigger{kind: gcTriggerCycle, n: n + &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    gcWaitOnMark(n + &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; atomic.Load(&amp;amp;work.cycles) == n+&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; &amp;amp;&amp;amp; sweepone() != ^&lt;span class=&quot;code-snippet__keyword&quot;&gt;uintptr&lt;/span&gt;(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        sweep.nbgsweep++&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Gosched()  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; atomic.Load(&amp;amp;work.cycles) == n+&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; &amp;amp;&amp;amp; !isSweepDone() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Gosched()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    mp := acquirem()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    cycle := atomic.Load(&amp;amp;work.cycles)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; cycle == n+&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt; || (gcphase == _GCmark &amp;amp;&amp;amp; cycle == n+&lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;) {   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mProf_PostSweep()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    releasem(mp)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;（三）后台运行定时检查触发runtime.forcegchelper&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;运行时会在应用程序启动时在后台开启一个用于强制触发垃圾收集的Goroutine，该Goroutine调用runtime.gcStart尝试启动新一轮的垃圾收集：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   go forcegchelper()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;forcegchelper&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   forcegc.g = getg()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   lockInit(&amp;amp;forcegc.lock, lockRankForcegc)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      lock(&amp;amp;forcegc.lock)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; forcegc.idle != &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;forcegc: phase error&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      atomic.&lt;span class=&quot;code-snippet__type&quot;&gt;Store&lt;/span&gt;(&amp;amp;forcegc.idle, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      goparkunlock(&amp;amp;forcegc.lock, waitReasonForceGCIdle, traceEvGoBlock, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; debug.gctrace &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__built_in&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;GC forced&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      gcStart(gcTrigger{kind: gcTriggerTime, now: nanotime()})&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;参考文献&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.《Go语言设计与实现》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(https://draveness.me/golang/docs/part3-runtime/ch&lt;/span&gt;&lt;span&gt;07-memory/golang-garbage-collector/)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.《一个专家眼中的Go与Java垃圾回收算法大对比》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(https://blog.csdn.net/u011277123/article/details/53991572)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.《Go语言问题集》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(https://www.bookstack.cn/read/qcrao-Go-Questions/spilt.19.GC-GC.md)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.《CMS垃圾收集器》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(https://juejin.cn/post/6844903782107578382)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5.《Golang v 1.16版本源码》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(https://github.com/golang/go)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;6.《Golang---内存管理(内存分配)》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;(http://t.zoukankan.com/zpcoding-p-13259943.html)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;7.《深入理解Java虚拟机：JVM高级特性与最佳实践（第3版）》—机械工业出版社&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt; 作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;105&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;105&quot; data-ratio=&quot;1.0013812154696133&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe96PLXT41sib6B9DvX60G2ZXWObaNr6OvXhzwtO1uVlehhbnWb4FELaKGC8tSicZjCutjQtuNiaFfkQKQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;724&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;汪汇&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;腾讯后台开发工程师&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;腾讯后台开发工程师，负责腾讯看点相关后端业务，毕业于南京大学软件学院。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span&gt;&lt;strong&gt;福利&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span/&gt;&lt;span&gt;我为大家整理了一份&lt;/span&gt;&lt;span&gt;从入门到进阶的Go学习资料礼包&lt;/span&gt;&lt;span&gt;，包含学习建议：入门看什么，进阶看什么。&lt;/span&gt;&lt;span&gt;关注公众号 「polarisxu」，回复 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;ebook&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 获取；还可以回复「&lt;strong&gt;进群&lt;/strong&gt;」，和数万 Gopher 交流学习。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UWba2ryLMqm8cgtrMXjG1BLGg46vQNmUompBL02uYYwic9RicPbCnlKdZiacBF5Wv6RLgmGIqnBnwuWyP82ibYusiag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a568c3b9dee778dd3187a122fd893530</guid>
<title>万字长文详解HBase读写性能优化</title>
<link>https://toutiao.io/k/5c58a6t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101593&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;HBase读优化&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;1. HBase客户端优化&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;和大多数系统一样，客户端作为业务读写的入口，姿势使用不正确通常会导致本业务读延迟较高实际上存在一些使用姿势的推荐用法，这里一般需要关注四个问题：&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1) scan缓存是否设置合理？&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;优化原理&lt;/strong&gt;：&lt;/span&gt;在解释这个问题之前，首先需要解释什么是scan缓存，通常来讲一次scan会返回大量数据，因此客户端发起一次scan请求，实际并不会一次就将所有数据加载到本地，而是分成多次RPC请求进行加载，这样设计一方面是因为大量数据请求可能会导致网络带宽严重消耗进而影响其他业务，另一方面也有可能因为数据量太大导致本地客户端发生OOM。在这样的设计体系下用户会首先加载一部分数据到本地，然后遍历处理，再加载下一部分数据到本地处理，如此往复，直至所有数据都加载完成。数据加载到本地就存放在scan缓存中，默认100条数据大小。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通常情况下，默认的scan缓存设置就可以正常工作的。但是在一些大scan（一次scan可能需要查询几万甚至几十万行数据）来说，每次请求100条数据意味着一次scan需要几百甚至几千次RPC请求，这种交互的代价无疑是很大的。因此可以考虑将scan缓存设置增大，比如设为500或者1000就可能更加合适。笔者之前做过一次试验，在一次scan扫描10w+条数据量的条件下，将scan缓存从100增加到1000，可以有效降低scan请求的总体延迟，延迟基本降低了25%左右。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优化建议&lt;/strong&gt;：大scan场景下将scan缓存从100增大到500或者1000，用以减少RPC次数&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2) get请求是否可以使用批量请求？&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优化原理&lt;/strong&gt;：HBase分别提供了单条get以及批量get的API接口，使用批量get接口可以减少客户端到RegionServer之间的RPC连接数，提高读取性能。另外需要注意的是，批量get请求要么成功返回所有请求数据，要么抛出异常。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优化建议&lt;/strong&gt;：使用批量get进行读取请求&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3) 请求是否可以显示指定列族或者列？&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优化原理&lt;/strong&gt;：HBase是典型的列族数据库，意味着同一列族的数据存储在一起，不同列族的数据分开存储在不同的目录下。如果一个表有多个列族，只是根据Rowkey而不指定列族进行检索的话不同列族的数据需要独立进行检索，性能必然会比指定列族的查询差很多，很多情况下甚至会有2倍～3倍的性能损失。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优化建议&lt;/strong&gt;：可以指定列族或者列进行精确查找的尽量指定查找&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4) 离线批量读取请求是否设置禁止缓存？&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优化原理&lt;/strong&gt;：通常离线批量读取数据会进行一次性全表扫描，一方面数据量很大，另一方面请求只会执行一次。这种场景下如果使用scan默认设置，就会将数据从HDFS加载出来之后放到缓存。可想而知，大量数据进入缓存必将其他实时业务热点数据挤出，其他业务不得不从HDFS加载，进而会造成明显的读延迟毛刺&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优化建议&lt;/strong&gt;：离线批量读取请求设置禁用缓存，&lt;/span&gt;&lt;code&gt;&lt;span&gt;scan.setBlockCache(false)&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;2. HBase服务器端优化&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一般服务端端问题一旦导致业务读请求延迟较大的话，通常是集群级别的，即整个集群的业务都会反映读延迟较大。可以从4个方面入手：&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1) 读请求是否均衡？&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优化原理&lt;/strong&gt;：极端情况下假如所有的读请求都落在一台RegionServer的某几个Region上，这一方面不能发挥整个集群的并发处理能力，另一方面势必造成此台RegionServer资源严重消耗（比如IO耗尽、handler耗尽等），落在该台RegionServer上的其他业务会因此受到很大的波及。可见，读请求不均衡不仅会造成本身业务性能很差，还会严重影响其他业务。当然，写请求不均衡也会造成类似的问题，可见负载不均衡是HBase的大忌。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;观察确认&lt;/strong&gt;：观察所有RegionServer的读请求QPS曲线，确认是否存在读请求不均衡现象&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优化建议&lt;/strong&gt;：RowKey必须进行散列化处理（比如MD5散列），同时建表必须进行预分区处理&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2) BlockCache是否设置合理？&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优化原理&lt;/strong&gt;：BlockCache作为读缓存，对于读性能来说至关重要。默认情况下BlockCache和Memstore的配置相对比较均衡（各占40%），可以根据集群业务进行修正，比如读多写少业务可以将BlockCache占比调大。另一方面，BlockCache的策略选择也很重要，不同策略对读性能来说影响并不是很大，但是对GC的影响却相当显著，尤其BucketCache的offheap模式下GC表现很优越。另外，HBase 2.0对offheap的改造（HBASE-11425）将会使HBase的读性能得到2～4倍的提升，同时GC表现会更好！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;观察确认&lt;/strong&gt;：观察所有RegionServer的缓存未命中率、配置文件相关配置项一级GC日志，确认BlockCache是否可以优化&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优化建议&lt;/strong&gt;：JVM内存配置量 &amp;lt; 20G，BlockCache策略选择LRUBlockCache；否则选择BucketCache策略的offheap模式；期待HBase 2.0的到来！&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3) HFile文件是否太多？&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优化原理&lt;/strong&gt;：HBase读取数据通常首先会到Memstore和BlockCache中检索（读取最近写入数据&amp;amp;热点数据），如果查找不到就会到文件中检索。HBase的类LSM结构会导致每个store包含多数HFile文件，文件越多，检索所需的IO次数必然越多，读取延迟也就越高。文件数量通常取决于Compaction的执行策略，一般和两个配置参数有关：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;hbase.hstore.compactionThreshold&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;hbase.hstore.compaction.max.size&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前者表示一个store中的文件数超过多少就应该进行合并，后者表示参数合并的文件大小最大是多少，超过此大小的文件不能参与合并。这两个参数不能设置太’松’（前者不能设置太大，后者不能设置太小），导致Compaction合并文件的实际效果不明显，进而很多文件得不到合并。这样就会导致HFile文件数变多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;观察确认&lt;/strong&gt;：观察RegionServer级别以及Region级别的storefile数，确认HFile文件是否过多&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优化建议&lt;/strong&gt;：&lt;code&gt;hbase.hstore.compactionThreshold&lt;/code&gt;设置不能太大，默认是3个；设置需要根据Region大小确定，通常可以简单的认为 &lt;code&gt;hbase.hstore.compaction.max.size = RegionSize / hbase.hstore.compactionThreshold&lt;/code&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4) Compaction是否消耗系统资源过多？&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优化原理&lt;/strong&gt;：Compaction是将小文件合并为大文件，提高后续业务随机读性能，但是也会带来IO放大以及带宽消耗问题（数据远程读取以及三副本写入都会消耗系统带宽）。正常配置情况下Minor Compaction并不会带来很大的系统资源消耗，除非因为配置不合理导致Minor Compaction太过频繁，或者Region设置太大情况下发生Major Compaction。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;观察确认&lt;/strong&gt;：观察系统IO资源以及带宽资源使用情况，再观察Compaction队列长度，确认是否由于Compaction导致系统资源消耗过多&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优化建议&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）Minor Compaction设置：hbase.hstore.compactionThreshold设置不能太小，又不能设置太大，因此建议设置为5～6；hbase.hstore.compaction.max.size = RegionSize / hbase.hstore.compactionThreshold&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）Major Compaction设置：大Region读延迟敏感业务（ 100G以上）通常不建议开启自动Major Compaction，手动低峰期触发。小Region或者延迟不敏感业务可以开启Major Compaction，但建议限制流量；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3）期待更多的优秀Compaction策略，类似于stripe-compaction尽早提供稳定服务&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;3. HBase列族设计优化&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;HBase列族设计对读性能影响也至关重要，其特点是只影响单个业务，并不会对整个集群产生太大影响。列族设计主要从以下方面检查：&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1) Bloomfilter是否设置？是否设置合理？&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优化原理&lt;/strong&gt;：Bloomfilter主要用来过滤不存在待检索RowKey或者Row-Col的HFile文件，避免无用的IO操作。它会告诉你在这个HFile文件中是否可能存在待检索的KV，如果不存在，就可以不用消耗IO打开文件进行seek。很显然，通过设置Bloomfilter可以提升随机读写的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Bloomfilter取值有两个，row以及rowcol，需要根据业务来确定具体使用哪种。如果业务大多数随机查询仅仅使用row作为查询条件，Bloomfilter一定要设置为row，否则如果大多数随机查询使用row+cf作为查询条件，Bloomfilter需要设置为rowcol。如果不确定业务查询类型，设置为row。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优化建议&lt;/strong&gt;：任何业务都应该设置Bloomfilter，通常设置为row就可以，除非确认业务随机查询类型为row+cf，可以设置为rowcol&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;4. HDFS相关优化&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;HDFS作为HBase最终数据存储系统，通常会使用三副本策略存储HBase数据文件以及日志文件。从HDFS的角度望上层看，HBase即是它的客户端，HBase通过调用它的客户端进行数据读写操作，因此HDFS的相关优化也会影响HBase的读写性能。这里主要关注如下三个方面：&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1) Short-Circuit Local Read功能是否开启？&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优化原理&lt;/strong&gt;：当前HDFS读取数据都需要经过DataNode，客户端会向DataNode发送读取数据的请求，DataNode接受到请求之后从硬盘中将文件读出来，再通过TPC发送给客户端。Short Circuit策略允许客户端绕过DataNode直接读取本地数据。（具体原理参考此处）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优化建议&lt;/strong&gt;：开启Short Circuit Local Read功能，具体配置戳这里&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2) Hedged Read功能是否开启？&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优化原理&lt;/strong&gt;：HBase数据在HDFS中一般都会存储三份，而且优先会通过Short-Circuit Local Read功能尝试本地读。但是在某些特殊情况下，有可能会出现因为磁盘问题或者网络问题引起的短时间本地读取失败，为了应对这类问题，社区开发者提出了补偿重试机制 – Hedged Read。该机制基本工作原理为：客户端发起一个本地读，一旦一段时间之后还没有返回，客户端将会向其他DataNode发送相同数据的请求。哪一个请求先返回，另一个就会被丢弃。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优化建议&lt;/strong&gt;：开启Hedged Read功能，具体配置参考这里&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3) 数据本地率是否太低？&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;数据本地率&lt;/strong&gt;：HDFS数据通常存储三份，假如当前RegionA处于Node1上，数据a写入的时候三副本为(Node1,Node2,Node3)，数据b写入三副本是(Node1,Node4,Node5)，数据c写入三副本(Node1,Node3,Node5)，可以看出来所有数据写入本地Node1肯定会写一份，数据都在本地可以读到，因此数据本地率是100%。现在假设RegionA被迁移到了Node2上，只有数据a在该节点上，其他数据（b和c）读取只能远程跨节点读，本地率就为33%（假设a，b和c的数据大小相同）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优化原理&lt;/strong&gt;：数据本地率太低很显然会产生大量的跨网络IO请求，必然会导致读请求延迟较高，因此提高数据本地率可以有效优化随机读性能。数据本地率低的原因一般是因为Region迁移（自动balance开启、RegionServer宕机迁移、手动迁移等）,因此一方面可以通过避免Region无故迁移来保持数据本地率，另一方面如果数据本地率很低，也可以通过执行major_compact提升数据本地率到100%。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优化建议&lt;/strong&gt;：避免Region无故迁移，比如关闭自动balance、RS宕机及时拉起并迁回飘走的Region等；在业务低峰期执行major_compact提升数据本地率&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;5. HBase读性能优化归纳&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在本文开始的时候提到读延迟较大无非三种常见的表象，单个业务慢、集群随机读慢以及某个业务随机读之后其他业务受到影响导致随机读延迟很大。了解完常见的可能导致读延迟较大的一些问题之后，我们将这些问题进行如下归类，读者可以在看到现象之后在对应的问题列表中进行具体定位：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2870748299319728&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zFa36GZXaAauTQ7bxZ1m9XsyTibVywMpuE998icLdYlVZJjqlz5b1vkrt5LC2MOjfI03n70gh2oRCKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;735&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31393775372124494&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zFa36GZXaAauTQ7bxZ1m9XsZcMTM3rwicLFgvYICsvb1A3WwTcutoIIOYCAicFibCUFmYyw50OXiaicNpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;739&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21715817694369974&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zFa36GZXaAauTQ7bxZ1m9XsvYe2bYUUibHLbvic2BIMs7O7n527BjeHcQrBtvK7ua8lRKw5h7jPIWsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;746&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101593&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;strong&gt;02&lt;/strong&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;HBase写优化&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;和读相比，HBase写数据流程倒是显得很简单：数据先顺序写入HLog，再写入对应的缓存Memstore，当Memstore中数据大小达到一定阈值（128M）之后，系统会异步将Memstore中数据flush到HDFS形成小文件。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;HBase数据写入通常会遇到两类问题，一类是写性能较差，另一类是数据根本写不进去。这两类问题的切入点也不尽相同，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3716295427901524&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zFa36GZXaAauTQ7bxZ1m9XsEfo1p9BJ7rCGjF51eVhd0miaVSrMPn2Ho48TYxjexkicQsFbMMj3KuOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;853&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;1. 写性能优化切入点&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1) 是否需要写WAL？WAL是否需要同步写入？&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优化原理&lt;/strong&gt;：数据写入流程可以理解为一次顺序写WAL+一次写缓存，通常情况下写缓存延迟很低，因此提升写性能就只能从WAL入手。WAL机制一方面是为了确保数据即使写入缓存丢失也可以恢复，另一方面是为了集群之间异步复制。默认WAL机制开启且使用同步机制写入WAL。首先考虑业务是否需要写WAL，通常情况下大多数业务都会开启WAL机制（默认），但是对于部分业务可能并不特别关心异常情况下部分数据的丢失，而更关心数据写入吞吐量，比如某些推荐业务，这类业务即使丢失一部分用户行为数据可能对推荐结果并不构成很大影响，但是对于写入吞吐量要求很高，不能造成数据队列阻塞。这种场景下可以考虑关闭WAL写入，写入吞吐量可以提升2x~3x。退而求其次，有些业务不能接受不写WAL，但可以接受WAL异步写入，也是可以考虑优化的，通常也会带来1x～2x的性能提升。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优化推荐&lt;/strong&gt;：根据业务关注点在WAL机制与写入吞吐量之间做出选择&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;其他注意点&lt;/strong&gt;：对于使用Increment操作的业务，WAL可以设置关闭，也可以设置异步写入，方法同Put类似。相信大多数Increment操作业务对WAL可能都不是那么敏感～&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2) Put是否可以同步批量提交？&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优化原理&lt;/strong&gt;：HBase分别提供了单条put以及批量put的API接口，使用批量put接口可以减少客户端到RegionServer之间的RPC连接数，提高写入性能。另外需要注意的是，批量put请求要么全部成功返回，要么抛出异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优化建议&lt;/strong&gt;：使用批量put进行写入请求&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3) Put是否可以异步批量提交？&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优化原理&lt;/strong&gt;：业务如果可以接受异常情况下少量数据丢失的话，还可以使用异步批量提交的方式提交请求。提交分为两阶段执行：用户提交写请求之后，数据会写入客户端缓存，并返回用户写入成功；当客户端缓存达到阈值（默认2M）之后批量提交给RegionServer。需要注意的是，在某些情况下客户端异常的情况下缓存数据有可能丢失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优化建议&lt;/strong&gt;：在业务可以接受的情况下开启异步批量提交&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;使用方式&lt;/strong&gt;：setAutoFlush(false)&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4) Region是否太少？&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优化原理&lt;/strong&gt;：当前集群中表的Region个数如果小于RegionServer个数，即Num(Region of Table) &amp;lt; Num(RegionServer)，可以考虑切分Region并尽可能分布到不同RegionServer来提高系统请求并发度，如果Num(Region of Table) &amp;gt; Num(RegionServer)，再增加Region个数效果并不明显。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;优化建议&lt;/strong&gt;：在Num(Region of Table) &amp;lt; Num(RegionServer)的场景下切分部分请求负载高的Region并迁移到其他RegionServer；&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5) 写入请求是否不均衡？&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优化原理&lt;/strong&gt;：另一个需要考虑的问题是写入请求是否均衡，如果不均衡，一方面会导致系统并发度较低，另一方面也有可能造成部分节点负载很高，进而影响其他业务。分布式系统中特别害怕一个节点负载很高的情况，一个节点负载很高可能会拖慢整个集群，这是因为很多业务会使用Mutli批量提交读写请求，一旦其中一部分请求落到该节点无法得到及时响应，就会导致整个批量请求超时。因此不怕节点宕掉，就怕节点奄奄一息！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;优化建议&lt;/strong&gt;：检查RowKey设计以及预分区策略，保证写入请求均衡。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6) 写入KeyValue数据是否太大？&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;KeyValue大小对写入性能的影响巨大，一旦遇到写入性能比较差的情况，需要考虑是否由于写入KeyValue数据太大导致。KeyValue大小对写入性能影响曲线图如下：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4552590266875981&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zFa36GZXaAauTQ7bxZ1m9XshibydRMXDffWvgx55bx3eVeCib6iaYzGW115nOTUcxtP8icdMdiadXvexOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;637&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;图中横坐标是写入的一行数据（每行数据10列）大小，左纵坐标是写入吞吐量，右坐标是写入平均延迟（ms）。可以看出随着单行数据大小不断变大，写入吞吐量急剧下降，写入延迟在100K之后急剧增大。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;说到这里，有必要和大家分享两起在生产线环境因为业务KeyValue较大导致的严重问题，一起是因为大字段业务写入导致其他业务吞吐量急剧下降，另一起是因为大字段业务scan导致RegionServer宕机。&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;案件一：大字段写入导致其他业务吞吐量急剧下降&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;部分业务反馈集群写入忽然变慢、数据开始堆积的情况，查看集群表级别的数据读写QPS监控，发现问题的第一个关键点：业务A开始写入之后整个集群其他部分业务写入QPS都几乎断崖式下跌，初步怀疑黑手就是业务A。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下图是当时业务A的写入QPS（事后发现脑残忘了截取其他表QPS断崖式下跌的惨象），但是第一感觉是QPS并不高啊，凭什么去影响别人！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4421768707482993&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/ZubDbBye0zFa36GZXaAauTQ7bxZ1m9XsEJibuDo1rgSiceySZ9fA0y0D4SrWxD5Y2bxFUHBpLJJtufiapTujAO28w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;588&quot;/&gt;&lt;span&gt;于是就继续查看其他监控信息，首先确认系统资源（主要是IO）并没有到达瓶颈，其次确认了写入的均衡性，直至看到下图，才追踪到影响其他业务写入的第二个关键点：RegionServer的handler（配置150）被残暴耗尽：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.43728813559322033&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/ZubDbBye0zFa36GZXaAauTQ7bxZ1m9Xsiavia9rPsZj5xm6gndhbtIHcTu2k0OyRNvweeSdJ1whv0vd5ISrKbvFA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;590&quot;/&gt;&lt;span&gt;对比上面两张图，是不是发现出奇的一致，那就可以基本确认是由于该业务写入导致这台RegionServer的handler被耗尽，进而其他业务拿不到handler，自然写不进去。那问题来了，为什么会这样？正常情况下handler在处理完客户端请求之后会立马释放，唯一的解释是这些请求的延迟实在太大。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;试想，我们去汉堡店排队买汉堡，有150个窗口服务，正常情况下大家买一个很快，这样150个窗口可能只需要50个服务。假设忽然来了一批大汉，要定制超大汉堡，好了，所有的窗口都工作起来，而且因为大汉堡不好制作导致服务很慢，这样必然会导致其他排队的用户长时间等待，直至超时。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可回头一想这可是写请求啊，怎么会有这么大的请求延迟！和业务方沟通之后确认该表主要存储语料库文档信息，都是平均100K左右的数据，是不是已经猜到了结果，没错，就是因为这个业务KeyValue太大导致。KeyValue太大会导致HLog文件写入频繁切换、flush以及compaction频繁触发，写入性能急剧下降。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;目前针对这种较大KeyValue写入性能较差的问题还没有直接的解决方案，好在社区已经意识到这个问题，在接下来即将发布的下一个大版本HBase 2.0.0版本会针对该问题进行深入优化，详见HBase MOB，优化后用户使用HBase存储文档、图片等二进制数据都会有极佳的性能体验。&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;案件二：大字段scan导致RegionServer宕机&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;案件现场&lt;/strong&gt;：有段时间有个0.98集群的RegionServer经常频繁宕机，查看日志是由于”java.lang.OutOfMemoryError: Requested array size exceeds VM limit”，如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.17407407407407408&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/ZubDbBye0zFa36GZXaAauTQ7bxZ1m9XsJ8DrgGXv0DTfUFQvjjtCn23qvhJ0VAEK78rj7QTM7NxZJkGOicqwfWQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;原因分析&lt;/strong&gt;：通过查看源码以及相关文档，确认该异常发生在scan结果数据回传给客户端时由于数据量太大导致申请的array大小超过JVM规定的最大值（ Interge.Max_Value-2）。造成该异常的两种最常见原因分别是：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;表列太宽（几十万列或者上百万列），并且scan返回没有对列数量做任何限制，导致一行数据就可能因为包含大量列而数据超过array大小阈值&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;KeyValue太大，并且scan返回没有对返回结果大小做任何限制，导致返回数据结果大小超过array大小阈值&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有的童鞋就要提问啦，说如果已经对返回结果大小做了限制，在表列太宽的情况下是不是就可以不对列数量做限制呢。这里需要澄清一下，如果不对列数据做限制，数据总是一行一行返回的，即使一行数据大小大于设置的返回结果限制大小，也会返回完整的一行数据。在这种情况下，如果这一行数据已经超过array大小阈值，也会触发OOM异常。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：目前针对该异常有两种解决方案，其一是升级集群到1.0，问题都解决了。其二是要求客户端访问的时候对返回结果大小做限制(scan.setMaxResultSize(2&lt;span&gt;1024&lt;/span&gt;1024))、并且对列数量做限制(scan.setBatch(100))，当然，0.98.13版本以后也可以对返回结果大小在服务器端进行限制，设置参数hbase.server.scanner.max.result.size即可&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;2. 写异常问题检查点&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上述几点主要针对写性能优化进行了介绍，除此之外，在一些情况下还会出现写异常，一旦发生需要考虑下面两种情况（GC引起的不做介绍）：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;Memstore设置是否会触发Region级别或者RegionServer级别flush操作？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;问题解析&lt;/span&gt;：以RegionServer级别flush进行解析，HBase设定一旦整个RegionServer上所有Memstore占用内存大小总和大于配置文件中upperlimit时，系统就会执行RegionServer级别flush，flush算法会首先按照Region大小进行排序，再按照该顺序依次进行flush，直至总Memstore大小低至lowerlimit。这种flush通常会block较长时间，在日志中会发现“Memstore is above high water mark and block 7452 ms”，表示这次flush将会阻塞7s左右。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;问题检查点&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;Region规模与Memstore总大小设置是否合理？如果RegionServer上Region较多，而Memstore总大小设置的很小（JVM设置较小或者upper.limit设置较小），就会触发RegionServer级别flush。集群规划相关内容可以参考文章《HBase最佳实践－集群规划》&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;列族是否设置过多，通常情况下表列族建议设置在1～3个之间，最好一个。如果设置过多，会导致一个Region中包含很多Memstore，导致更容易触到高水位upperlimit&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;Store中HFile数量是否大于配置参数blockingStoreFile?&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;问题解析&lt;/span&gt;：对于数据写入很快的集群，还需要特别关注一个参数：hbase.hstore.blockingStoreFiles，此参数表示如果当前hstore中文件数大于该值，系统将会强制执行compaction操作进行文件合并，合并的过程会阻塞整个hstore的写入。通常情况下该场景发生在数据写入很快的情况下，在日志中可以发现”Waited 3722ms on a compaction to clean up ‘too many store  files“&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;问题检查点&lt;/span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;参数设置是否合理？hbase.hstore.compactionThreshold表示启动compaction的最低阈值，该值不能太大，否则会积累太多文件，一般建议设置为5～8左右。hbase.hstore.blockingStoreFiles默认设置为7，可以适当调大一些。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>590d02ba7dceefd372a679ca094ba9cb</guid>
<title>[推荐] ThreadLocal夺命11连问</title>
<link>https://toutiao.io/k/p8lpi5z</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前一段时间，有同事使用&lt;code&gt;ThreadLocal&lt;/code&gt;踩坑了，正好引起了我的兴趣。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以近期，我抽空把ThreadLocal的源码再研究了一下，越看越有意思，发现里面的东西还真不少。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我把精华浓缩了一下，汇集成了下面11个问题，看看你能顶住第几个？&lt;img data-ratio=&quot;0.8727810650887574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPwOE8aUPLISj0JWBM96Uhcfib0xSBpBPteS3icH0sPsicEoLBwoLmqc2Qg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1352&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 为什么要用ThreadLocal?&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发编程是一项非常重要的技术，它让我们的程序变得更加高效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但在并发的场景中，如果有多个线程同时修改公共变量，可能会出现线程安全问题，即该变量最终结果可能出现异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决线程安全问题，&lt;code&gt;JDK&lt;/code&gt;出现了很多技术手段，比如：使用&lt;code&gt;synchronized&lt;/code&gt;或&lt;code&gt;Lock&lt;/code&gt;，给访问公共资源的代码上锁，保证了代码的&lt;code&gt;原子性&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但在高并发的场景中，如果多个线程同时竞争一把锁，这时会存在大量的锁等待，可能会浪费很多时间，让系统的响应时间一下子变慢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，&lt;code&gt;JDK&lt;/code&gt;还提供了另外一种用空间换时间的新思路：&lt;code&gt;ThreadLocal&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的核心思想是：共享变量在每个&lt;code&gt;线程&lt;/code&gt;都有一个&lt;code&gt;副本&lt;/code&gt;，每个线程操作的都是自己的副本，对另外的线程没有影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        threadLocal.set(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        doSamething();&lt;br/&gt;        Integer integer = threadLocal.get();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. ThreadLocal的原理是什么？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了搞清楚ThreadLocal的底层实现原理，我们不得不扒一下源码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;的内部有一个静态的内部类叫：&lt;code&gt;ThreadLocalMap&lt;/code&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocal&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;     ...&lt;br/&gt;     &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//获取当前线程&lt;/span&gt;&lt;br/&gt;        Thread t = Thread.currentThread();&lt;br/&gt;        &lt;span&gt;//获取当前线程的成员变量ThreadLocalMap对象&lt;/span&gt;&lt;br/&gt;        ThreadLocalMap map = getMap(t);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (map != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;//根据threadLocal对象从map中获取Entry对象&lt;/span&gt;&lt;br/&gt;            ThreadLocalMap.Entry e = map.getEntry(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;@SuppressWarnings&lt;/span&gt;(&lt;span&gt;&quot;unchecked&quot;&lt;/span&gt;)&lt;br/&gt;                &lt;span&gt;//获取保存的数据&lt;/span&gt;&lt;br/&gt;                T result = (T)e.value;&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//初始化数据&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; setInitialValue();&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; T &lt;span&gt;setInitialValue&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//获取要初始化的数据&lt;/span&gt;&lt;br/&gt;        T value = initialValue();&lt;br/&gt;        &lt;span&gt;//获取当前线程&lt;/span&gt;&lt;br/&gt;        Thread t = Thread.currentThread();&lt;br/&gt;        &lt;span&gt;//获取当前线程的成员变量ThreadLocalMap对象&lt;/span&gt;&lt;br/&gt;        ThreadLocalMap map = getMap(t);&lt;br/&gt;        &lt;span&gt;//如果map不为空&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (map != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;//将初始值设置到map中，key是this，即threadLocal对象，value是初始值&lt;/span&gt;&lt;br/&gt;            map.set(&lt;span&gt;this&lt;/span&gt;, value);&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;           &lt;span&gt;//如果map为空，则需要创建新的map对象&lt;/span&gt;&lt;br/&gt;            createMap(t, value);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; value;&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(T value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//获取当前线程&lt;/span&gt;&lt;br/&gt;        Thread t = Thread.currentThread();&lt;br/&gt;        &lt;span&gt;//获取当前线程的成员变量ThreadLocalMap对象&lt;/span&gt;&lt;br/&gt;        ThreadLocalMap map = getMap(t);&lt;br/&gt;        &lt;span&gt;//如果map不为空&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (map != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;//将值设置到map中，key是this，即threadLocal对象，value是传入的value值&lt;/span&gt;&lt;br/&gt;            map.set(&lt;span&gt;this&lt;/span&gt;, value);&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;           &lt;span&gt;//如果map为空，则需要创建新的map对象&lt;/span&gt;&lt;br/&gt;            createMap(t, value);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;     &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalMap&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ...&lt;br/&gt;     }&lt;br/&gt;     ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;的&lt;code&gt;get&lt;/code&gt;方法、&lt;code&gt;set&lt;/code&gt;方法和&lt;code&gt;setInitialValue&lt;/code&gt;方法，其实最终操作的都是&lt;code&gt;ThreadLocalMap&lt;/code&gt;类中的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中&lt;code&gt;ThreadLocalMap&lt;/code&gt;类的内部如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalMap&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Entry&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;WeakReference&lt;/span&gt;&amp;lt;&lt;span&gt;ThreadLocal&lt;/span&gt;&amp;lt;?&amp;gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;        Object value;&lt;br/&gt;&lt;br/&gt;        Entry(ThreadLocal&amp;lt;?&amp;gt; k, Object v) {&lt;br/&gt;            &lt;span&gt;super&lt;/span&gt;(k);&lt;br/&gt;            value = v;&lt;br/&gt;        }&lt;br/&gt;   }&lt;br/&gt;   ...&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; Entry[] table;&lt;br/&gt;   ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ThreadLocalMap&lt;/code&gt;里面包含一个静态的内部类&lt;code&gt;Entry&lt;/code&gt;，该类继承于&lt;code&gt;WeakReference&lt;/code&gt;类，说明&lt;code&gt;Entry&lt;/code&gt;是一个弱引用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ThreadLocalMap&lt;/code&gt;内部还包含了一个&lt;code&gt;Entry&lt;/code&gt;数组，其中：&lt;code&gt;Entry&lt;/code&gt; = &lt;code&gt;ThreadLocal&lt;/code&gt; + &lt;code&gt;value&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而&lt;code&gt;ThreadLocalMap&lt;/code&gt;被定义成了&lt;code&gt;Thread&lt;/code&gt;类的成员变量。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    ThreadLocal.ThreadLocalMap threadLocals = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面用一张图从宏观上，认识一下ThreadLocal的整体结构：&lt;img data-ratio=&quot;0.6101398601398601&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPibvIt0m0xgZ5xPBg9icLaYJ2tpewlXIia04nCgAWicuVolVEdb6CJ469PQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1144&quot;/&gt;从上图中看出，在每个&lt;code&gt;Thread&lt;/code&gt;类中，都有一个&lt;code&gt;ThreadLocalMap&lt;/code&gt;的成员变量，该变量包含了一个&lt;code&gt;Entry数组&lt;/code&gt;，该数组真正保存了ThreadLocal类set的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Entry&lt;/code&gt;是由threadLocal和value组成，其中threadLocal对象是弱引用，在&lt;code&gt;GC&lt;/code&gt;的时候，会被自动回收。而value就是ThreadLocal类set的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面用一张图总结一下引用关系：&lt;img data-ratio=&quot;0.3882646691635456&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPDV2MbZtHgetjCIm03QW2iasXjia96wr8RKictVUgIJ5y8WLWQNia09H72w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1602&quot;/&gt;上图中除了Entry的key对ThreadLocal对象是&lt;code&gt;弱引用&lt;/code&gt;，其他的引用都是&lt;code&gt;强引用&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要特别说明的是，上图中ThreadLocal对象我画到了堆上，其实在实际的业务场景中不一定在堆上。因为如果ThreadLocal被定义成了static的，ThreadLocal的对象是类共用的，可能出现在方法区。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 为什么用ThreadLocal做key？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道你有没有思考过这样一个问题：&lt;code&gt;ThreadLocalMap&lt;/code&gt;为什么要用&lt;code&gt;ThreadLocal&lt;/code&gt;做key，而不是用&lt;code&gt;Thread&lt;/code&gt;做key？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在你的应用中，一个线程中只使用了一个&lt;code&gt;ThreadLocal&lt;/code&gt;对象，那么使用&lt;code&gt;Thread&lt;/code&gt;做key也未尝不可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;}    &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但实际情况中，你的应用，一个线程中很有可能不只使用了一个ThreadLocal对象。这时使用&lt;code&gt;Thread&lt;/code&gt;做key不就出有问题？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Integer&amp;gt; threadLocal1 = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Integer&amp;gt; threadLocal2 = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Integer&amp;gt; threadLocal3 = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;}    &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如使用&lt;code&gt;Thread&lt;/code&gt;做key时，你的代码中定义了3个ThreadLocal对象，那么，通过Thread对象，它怎么知道要获取哪个ThreadLocal对象呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img data-ratio=&quot;0.5417298937784522&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPRNiaWw5iamw6OhpvhSHTtjf8z69UhmVxTOKhAm1ykGAARfXNqjBgicEng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1318&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，不能使用&lt;code&gt;Thread&lt;/code&gt;做key，而应该改成用&lt;code&gt;ThreadLocal&lt;/code&gt;对象做key，这样才能通过具体ThreadLocal对象的&lt;code&gt;get&lt;/code&gt;方法，轻松获取到你想要的ThreadLocal对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img data-ratio=&quot;0.625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPddzQJKggvqA7bjyPYUBbnoBMROAlJ7SxlicJTNFREJHzia6ACV1r8saQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1136&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. Entry的key为什么设计成弱引用？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面说过，Entry的key，传入的是ThreadLocal对象，使用了&lt;code&gt;WeakReference&lt;/code&gt;对象，即被设计成了弱引用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，为什么要这样设计呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如key对ThreadLocal对象的弱引用，改为强引用。&lt;img data-ratio=&quot;0.39420654911838793&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPT8KKEnrticic4sSRcDpOH51tzibCiadrlKGvUxndul4zGe613FRhG6icbkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1588&quot;/&gt;我们都知道ThreadLocal变量对ThreadLocal对象是有强引用存在的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使ThreadLocal变量生命周期完了，设置成null了，但由于key对ThreadLocal还是强引用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，如果执行该代码的&lt;code&gt;线程&lt;/code&gt;使用了&lt;code&gt;线程池&lt;/code&gt;，一直长期存在，不会被销毁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就会存在这样的&lt;code&gt;强引用链&lt;/code&gt;：Thread变量 -&amp;gt; Thread对象 -&amp;gt; ThreadLocalMap -&amp;gt; Entry -&amp;gt; key -&amp;gt; ThreadLocal对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，ThreadLocal对象和ThreadLocalMap都将不会被&lt;code&gt;GC&lt;/code&gt;回收，于是产生了&lt;code&gt;内存泄露&lt;/code&gt;问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，JDK的开发者们把Entry的key设计成了&lt;code&gt;弱引用&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;弱引用&lt;/code&gt;的对象，在GC做垃圾清理的时候，就会被自动回收了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果key是弱引用，当ThreadLocal变量指向null之后，在GC做垃圾清理的时候，key会被自动回收，其值也被设置成null。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img data-ratio=&quot;0.40960809102402024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPuibZibcVKRd0ZNPpa1U6YYSvgfYa31EILjkpyKibq3NDibtuVBv4lZbs3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1582&quot;/&gt;&lt;strong&gt;接下来，最关键的地方来了。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于当前的ThreadLocal变量已经被指向&lt;code&gt;null&lt;/code&gt;了，但如果直接调用它的&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;或&lt;code&gt;remove&lt;/code&gt;方法，很显然会出现&lt;code&gt;空指针异常&lt;/code&gt;。因为它的生命已经结束了，再调用它的方法也没啥意义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，如果系统中还定义了另外一个ThreadLocal变量b，调用了它的&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;或&lt;code&gt;remove&lt;/code&gt;，三个方法中的任何一个方法，都会自动触发清理机制，将key为null的value值清空。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果key和value都是null，那么Entry对象会被GC回收。如果所有的Entry对象都被回收了，ThreadLocalMap也会被回收了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就能最大程度的解决&lt;code&gt;内存泄露&lt;/code&gt;问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要特别注意的地方是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;key为null的条件是，ThreadLocal变量指向&lt;code&gt;null&lt;/code&gt;，并且key是弱引用。如果ThreadLocal变量没有断开对ThreadLocal的强引用，即ThreadLocal变量没有指向null，GC就贸然的把弱引用的key回收了，不就会影响正常用户的使用？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果当前ThreadLocal变量指向&lt;code&gt;null&lt;/code&gt;了，并且key也为null了，但如果没有其他ThreadLocal变量触发&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;或&lt;code&gt;remove&lt;/code&gt;方法，也会造成内存泄露。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面看看弱引用的例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    WeakReference&amp;lt;Object&amp;gt; weakReference0 = &lt;span&gt;new&lt;/span&gt; WeakReference&amp;lt;&amp;gt;(&lt;span&gt;new&lt;/span&gt; Object());&lt;br/&gt;    System.out.println(weakReference0.get());&lt;br/&gt;    System.gc();&lt;br/&gt;    System.out.println(weakReference0.get());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打印结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java.lang.Object@&lt;span&gt;1&lt;/span&gt;ef7fe8e&lt;br/&gt;&lt;span&gt;null&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传入WeakReference构造方法的是直接new处理的对象，没有其他引用，在调用gc方法后，弱引用对象会被自动回收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果出现下面这种情况：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Object object = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;    WeakReference&amp;lt;Object&amp;gt; weakReference1 = &lt;span&gt;new&lt;/span&gt; WeakReference&amp;lt;&amp;gt;(object);&lt;br/&gt;    System.out.println(weakReference1.get());&lt;br/&gt;    System.gc();&lt;br/&gt;    System.out.println(weakReference1.get());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java.lang.Object@&lt;span&gt;1&lt;/span&gt;ef7fe8e&lt;br/&gt;java.lang.Object@&lt;span&gt;1&lt;/span&gt;ef7fe8e&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先定义了一个强引用object对象，在WeakReference构造方法中将object对象的引用作为参数传入。这时，调用gc后，弱引用对象不会被自动回收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的Entry对象中的key不就是第二种情况吗？在Entry构造方法中传入的是ThreadLocal对象的引用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果将object强引用设置为null：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Object object = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;    WeakReference&amp;lt;Object&amp;gt; weakReference1 = &lt;span&gt;new&lt;/span&gt; WeakReference&amp;lt;&amp;gt;(object);&lt;br/&gt;    System.out.println(weakReference1.get());&lt;br/&gt;    System.gc();&lt;br/&gt;    System.out.println(weakReference1.get());&lt;br/&gt;&lt;br/&gt;    object=&lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    System.gc();&lt;br/&gt;    System.out.println(weakReference1.get());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;java.lang.Object@&lt;span&gt;6f&lt;/span&gt;496d9f&lt;br/&gt;java.lang.Object@&lt;span&gt;6f&lt;/span&gt;496d9f&lt;br/&gt;&lt;span&gt;null&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二次gc之后，弱引用能够被正常回收。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;由此可见，如果强引用和弱引用同时关联一个对象，那么这个对象是不会被GC回收。也就是说这种情况下Entry的key，一直都不会为null，除非强引用主动断开关联。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，你可能还会问这样一个问题：&lt;strong&gt;Entry的value为什么不设计成弱引用？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：Entry的value假如只是被Entry引用，有可能没被业务系统中的其他地方引用。如果将value改成了弱引用，被GC贸然回收了（数据突然没了），可能会导致业务系统出现异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而相比之下，Entry的key，管理的地方就非常明确了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是Entry的key被设计成弱引用，而value没被设计成弱引用的原因。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. ThreadLocal真的会导致内存泄露？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的Entry对象中的key设置成弱引用，并且使用&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;或&lt;code&gt;remove&lt;/code&gt;方法清理key为null的value值，就能彻底解决内存泄露问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是否定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40960809102402024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPuibZibcVKRd0ZNPpa1U6YYSvgfYa31EILjkpyKibq3NDibtuVBv4lZbs3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1582&quot;/&gt;假如ThreadLocalMap中存在很多key为null的Entry，但后面的程序，一直都没有调用过有效的ThreadLocal的&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;set&lt;/code&gt;或&lt;code&gt;remove&lt;/code&gt;方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，Entry的value值一直都没被清空。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以会存在这样一条&lt;code&gt;强引用链&lt;/code&gt;：Thread变量 -&amp;gt; Thread对象 -&amp;gt; ThreadLocalMap -&amp;gt; Entry -&amp;gt; value -&amp;gt; Object。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其结果就是：Entry和ThreadLocalMap将会长期存在下去，会导致&lt;code&gt;内存泄露&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 如何解决内存泄露问题？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面说过的ThreadLocal还是会导致内存泄露的问题，我们有没有解决办法呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：有办法，调用ThreadLocal对象的&lt;code&gt;remove&lt;/code&gt;方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不是在一开始就调用remove方法，而是在使用完ThreadLocal对象之后。列如：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先创建一个CurrentUser类，其中包含了ThreadLocal的逻辑。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CurrentUser&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;UserInfo&amp;gt; THREA_LOCAL = &lt;span&gt;new&lt;/span&gt; ThreadLocal();&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(UserInfo userInfo)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        THREA_LOCAL.set(userInfo);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; UserInfo &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       THREA_LOCAL.get();&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;remove&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       THREA_LOCAL.remove();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在业务代码中调用相关方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSamething&lt;/span&gt;&lt;span&gt;(UserDto userDto)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   UserInfo userInfo = convert(userDto);&lt;br/&gt;   &lt;br/&gt;   &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;     CurrentUser.set(userInfo);&lt;br/&gt;     ...&lt;br/&gt;     &lt;br/&gt;     &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;     UserInfo userInfo = CurrentUser.get();&lt;br/&gt;     ...&lt;br/&gt;   } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;      CurrentUser.remove();&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要我们特别注意的地方是：一定要在&lt;code&gt;finally&lt;/code&gt;代码块中，调用&lt;code&gt;remove&lt;/code&gt;方法清理没用的数据。如果业务代码出现异常，也能及时清理没用的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;remove&lt;/code&gt;方法中会把Entry中的key和value都设置成null，这样就能被GC及时回收，无需触发额外的清理机制，所以它能解决内存泄露问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. ThreadLocal是如何定位数据的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面说过ThreadLocalMap对象底层是用Entry数组保存数据的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了，ThreadLocal是如何定位Entry数组数据的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在ThreadLocal的get、set、remove方法中都有这样一行代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (len-&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过key的hashCode值，&lt;code&gt;与&lt;/code&gt;数组的长度减1。其中key就是ThreadLocal对象，&lt;code&gt;与&lt;/code&gt;数组的长度减1，相当于除以数组的长度减1，然后&lt;code&gt;取模&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一种hash算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来给大家举个例子：假设len=16，key.threadLocalHashCode=31，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是： int i = 31 &amp;amp; 15 = 15&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相当于：int i = 31 % 16 = 15&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算的结果是一样的，但是使用&lt;code&gt;与运算&lt;/code&gt;效率跟高一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么与运算效率更高？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：因为ThreadLocal的初始大小是&lt;code&gt;16&lt;/code&gt;，每次都是按&lt;code&gt;2&lt;/code&gt;倍扩容，数组的大小其实一直都是2的n次方。这种数据有个规律就是高位是0，低位都是1。在做与运算时，可以不用考虑高位，因为与运算的结果必定是0。只需考虑低位的与运算，所以效率更高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果使用hash算法定位具体位置的话，就可能会出现&lt;code&gt;hash冲突&lt;/code&gt;的情况，即两个不同的hashCode取模后的值相同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal是如何解决hash冲突的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看看&lt;code&gt;getEntry&lt;/code&gt;是怎么做的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; Entry &lt;span&gt;getEntry&lt;/span&gt;&lt;span&gt;(ThreadLocal&amp;lt;?&amp;gt; key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//通过hash算法获取下标值&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (table.length - &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    Entry e = table[i];&lt;br/&gt;    &lt;span&gt;//如果下标位置上的key正好是我们所需要寻找的key&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; e.get() == key)&lt;br/&gt;        &lt;span&gt;//说明找到数据了，直接返回&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; e;&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;//说明出现hash冲突了，继续往后找&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; getEntryAfterMiss(key, i, e);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再看看&lt;code&gt;getEntryAfterMiss&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; Entry &lt;span&gt;getEntryAfterMiss&lt;/span&gt;&lt;span&gt;(ThreadLocal&amp;lt;?&amp;gt; key, &lt;span&gt;int&lt;/span&gt; i, Entry e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Entry[] tab = table;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; len = tab.length;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//判断Entry对象如果不为空，则一直循环&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        ThreadLocal&amp;lt;?&amp;gt; k = e.get();&lt;br/&gt;        &lt;span&gt;//如果当前Entry的key正好是我们所需要寻找的key&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (k == key)&lt;br/&gt;            &lt;span&gt;//说明这次真的找到数据了&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; e;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;//如果key为空，则清理脏数据&lt;/span&gt;&lt;br/&gt;            expungeStaleEntry(i);&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;//如果还是没找到数据，则继续往后找&lt;/span&gt;&lt;br/&gt;            i = nextIndex(i, len);&lt;br/&gt;        e = tab[i];&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关键看看&lt;code&gt;nextIndex&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;nextIndex&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt; len)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; ((i + &lt;span&gt;1&lt;/span&gt; &amp;lt; len) ? i + &lt;span&gt;1&lt;/span&gt; : &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当通过hash算法计算出的下标小于数组大小，则将下标值加1。否则，即下标大于等于数组大小，下标变成0了。下标变成0之后，则循环一次，下标又变成1。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;寻找的大致过程如下图所示：&lt;img data-ratio=&quot;0.4837758112094395&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPhoM9mFH5eXkorCiaiagK2mtxd4iaLxyQBRPwqBSu9t7j6WU1icbqXJwcrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;678&quot;/&gt;如果找到最后一个，还是没有找到，则再从头开始找。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4214876033057851&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgPxsTqeQ2lAVj4Hp8pqodHZtRenJne946HaFFY5xaDciaLibyafFyevIicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;726&quot;/&gt;不知道你有没有发现，它构成了一个：&lt;code&gt;环形&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal从数组中找数据的过程大致是这样的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;通过key的hashCode取余计算出一个下标。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过下标，在数组中定位具体Entry，如果key正好是我们所需要的key，说明找到了，则直接返回数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果第2步没有找到我们想要的数据，则从数组的下标位置，继续往后面找。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果第3步中找key的正好是我们所需要的key，说明找到了，则直接返回数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果还是没有找到数据，再继续往后面找。如果找到最后一个位置，还是没有找到数据，则再从头，即下标为0的位置，继续从前往后找数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;直到找到第一个Entry为空为止。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8. ThreadLocal是如何扩容的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面得知，ThreadLocal的初始大小是&lt;code&gt;16&lt;/code&gt;。那么问题来了，ThreadLocal是如何扩容的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;set&lt;/code&gt;方法中会调用&lt;code&gt;rehash&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;(ThreadLocal&amp;lt;?&amp;gt; key, Object value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Entry[] tab = table;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; len = tab.length;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = key.threadLocalHashCode &amp;amp; (len-&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (Entry e = tab[i];&lt;br/&gt;         e != &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;         e = tab[i = nextIndex(i, len)]) {&lt;br/&gt;        ThreadLocal&amp;lt;?&amp;gt; k = e.get();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (k == key) {&lt;br/&gt;            e.value = value;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            replaceStaleEntry(key, value, i);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    tab[i] = &lt;span&gt;new&lt;/span&gt; Entry(key, value);&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; sz = ++size;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!cleanSomeSlots(i, sz) &amp;amp;&amp;amp; sz &amp;gt;= threshold)&lt;br/&gt;        rehash();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意一下，其中有个判断条件是：sz(之前的size+1)如果大于或等于threshold的话，则调用rehash方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;threshold默认是0，在创建ThreadLocalMap时，调用它的构造方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ThreadLocalMap(ThreadLocal&amp;lt;?&amp;gt; firstKey, Object firstValue) {&lt;br/&gt;    table = &lt;span&gt;new&lt;/span&gt; Entry[INITIAL_CAPACITY];&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i = firstKey.threadLocalHashCode &amp;amp; (INITIAL_CAPACITY - &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;    table[i] = &lt;span&gt;new&lt;/span&gt; Entry(firstKey, firstValue);&lt;br/&gt;    size = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    setThreshold(INITIAL_CAPACITY);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用setThreshold方法给threshold设置一个值，而这个值INITIAL_CAPACITY是默认的大小16。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setThreshold&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; len)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    threshold = len * &lt;span&gt;2&lt;/span&gt; / &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是第一次设置的threshold = 16 * 2 / 3， 取整后的值是：10。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换句话说当sz大于等于10时，就可以考虑扩容了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;rehash代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;rehash&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//先尝试回收一次key为null的值，腾出一些空间&lt;/span&gt;&lt;br/&gt;    expungeStaleEntries();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (size &amp;gt;= threshold - threshold / &lt;span&gt;4&lt;/span&gt;)&lt;br/&gt;        resize();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在真正扩容之前，先尝试回收一次key为null的值，腾出一些空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果回收之后的size大于等于threshold的3/4时，才需要真正的扩容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算公式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;16&lt;/span&gt; * &lt;span&gt;2&lt;/span&gt; * &lt;span&gt;4&lt;/span&gt; / &lt;span&gt;3&lt;/span&gt; * &lt;span&gt;4&lt;/span&gt; - &lt;span&gt;16&lt;/span&gt; * &lt;span&gt;2&lt;/span&gt; / &lt;span&gt;3&lt;/span&gt; * &lt;span&gt;4&lt;/span&gt; = &lt;span&gt;8&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说添加数据后，新的size大于等于老size的&lt;code&gt;1/2&lt;/code&gt;时，才需要扩容。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;resize&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Entry[] oldTab = table;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; oldLen = oldTab.length;&lt;br/&gt;    &lt;span&gt;//按2倍的大小扩容&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; newLen = oldLen * &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;    Entry[] newTab = &lt;span&gt;new&lt;/span&gt; Entry[newLen];&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; oldLen; ++j) {&lt;br/&gt;        Entry e = oldTab[j];&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (e != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            ThreadLocal&amp;lt;?&amp;gt; k = e.get();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (k == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                e.value = &lt;span&gt;null&lt;/span&gt;; &lt;span&gt;// Help the GC&lt;/span&gt;&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;int&lt;/span&gt; h = k.threadLocalHashCode &amp;amp; (newLen - &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (newTab[h] != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;                    h = nextIndex(h, newLen);&lt;br/&gt;                newTab[h] = e;&lt;br/&gt;                count++;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    setThreshold(newLen);&lt;br/&gt;    size = count;&lt;br/&gt;    table = newTab;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;resize中每次都是按2倍的大小扩容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩容的过程如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.9527272727272726&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jf80S0iav4wJGqAyYxWmqgP6HufRYWSy9DqCibKtibW5pPkaVhVGibyvbt6tUssr9ZCdKAWzChxC83mw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;扩容的关键步骤如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;老size + 1 = 新size&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果新size大于等于老size的2/3时，需要考虑扩容。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;扩容前先尝试回收一次key为null的值，腾出一些空间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果回收之后发现size还是大于等于老size的1/2时，才需要真正的扩容。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每次都是按2倍的大小扩容。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9. 父子线程如何共享数据？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面介绍的ThreadLocal都是在&lt;code&gt;一个线程&lt;/code&gt;中保存和获取数据的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但在实际工作中，有可能是在父子线程中共享数据的。即在父线程中往ThreadLocal设置了值，在子线程中能够获取到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;        threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;父线程获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;子线程获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;        }).start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;父线程获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;子线程获取数据：&lt;span&gt;null&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你会发现，在这种情况下使用ThreadLocal是行不通的。main方法是在主线程中执行的，相当于父线程。在main方法中开启了另外一个线程，相当于子线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然通过ThreadLocal，无法在父子线程中共享数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;InheritableThreadLocal&lt;/code&gt;，它是JDK自带的类，继承了ThreadLocal类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改代码之后：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        InheritableThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; InheritableThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;        threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;父线程获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;子线程获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;        }).start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;父线程获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;子线程获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;果然，在换成InheritableThreadLocal之后，在子线程中能够正常获取父线程中设置的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，在Thread类中除了成员变量threadLocals之外，还有另一个成员变量：inheritableThreadLocals。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Thread类的部分代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ThreadLocal.ThreadLocalMap threadLocals = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;ThreadLocal.ThreadLocalMap inheritableThreadLocals = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最关键的一点是，在它的&lt;code&gt;init&lt;/code&gt;方法中会将父线程中往ThreadLocal设置的值，拷贝一份到子线程中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;感兴趣的小伙伴，可以找我私聊。或者看看我后面的文章，后面还会有专栏。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10. 线程池中如何共享数据？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在真实的业务场景中，一般很少用&lt;code&gt;单独的线程&lt;/code&gt;，绝大多数，都是用的&lt;code&gt;线程池&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，在线程池中如何共享ThreadLocal对象生成的数据呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为涉及到不同的线程，如果直接使用ThreadLocal，显然是不合适的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们应该使用InheritableThreadLocal，具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fun1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    InheritableThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; InheritableThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;    threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;父线程获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;&lt;br/&gt;    ExecutorService executorService = Executors.newSingleThreadExecutor();&lt;br/&gt;&lt;br/&gt;    threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    executorService.submit(() -&amp;gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;第一次从线程池中获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    threadLocal.set(&lt;span&gt;7&lt;/span&gt;);&lt;br/&gt;    executorService.submit(() -&amp;gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;第二次从线程池中获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;    });&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;父线程获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;第一次从线程池中获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;第二次从线程池中获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于这个例子中使用了单例线程池，固定线程数是1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次submit任务的时候，该线程池会自动创建一个线程。因为使用了InheritableThreadLocal，所以创建线程时，会调用它的init方法，将父线程中的inheritableThreadLocals数据复制到子线程中。所以我们看到，在主线程中将数据设置成6，第一次从线程池中获取了正确的数据6。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后，在主线程中又将数据改成7，但在第二次从线程池中获取数据却依然是6。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为第二次submit任务的时候，线程池中已经有一个线程了，就直接拿过来复用，不会再重新创建线程了。所以不会再调用线程的init方法，所以第二次其实没有获取到最新的数据7，还是获取的老数据6。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，这该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;TransmittableThreadLocal&lt;/code&gt;，它并非JDK自带的类，而是阿里巴巴开源jar包中的类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过如下pom文件引入该jar包：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;com.alibaba&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;transmittable-thread-local&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.11.0&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;compile&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码调整如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fun2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;    TransmittableThreadLocal&amp;lt;Integer&amp;gt; threadLocal = &lt;span&gt;new&lt;/span&gt; TransmittableThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;    threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;父线程获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;&lt;br/&gt;    ExecutorService ttlExecutorService = TtlExecutors.getTtlExecutorService(Executors.newFixedThreadPool(&lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    threadLocal.set(&lt;span&gt;6&lt;/span&gt;);&lt;br/&gt;    ttlExecutorService.submit(() -&amp;gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;第一次从线程池中获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    threadLocal.set(&lt;span&gt;7&lt;/span&gt;);&lt;br/&gt;    ttlExecutorService.submit(() -&amp;gt; {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;第二次从线程池中获取数据：&quot;&lt;/span&gt; + threadLocal.get());&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;父线程获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;第一次从线程池中获取数据：&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;第二次从线程池中获取数据：&lt;span&gt;7&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到，使用了TransmittableThreadLocal之后，第二次从线程中也能正确获取最新的数据7了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;nice。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你仔细观察这个例子，你可能会发现，代码中除了使用&lt;code&gt;TransmittableThreadLocal&lt;/code&gt;类之外，还使用了&lt;code&gt;TtlExecutors.getTtlExecutorService&lt;/code&gt;方法，去创建&lt;code&gt;ExecutorService&lt;/code&gt;对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是非常重要的地方，如果没有这一步，&lt;code&gt;TransmittableThreadLocal&lt;/code&gt;在线程池中共享数据将不会起作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建&lt;code&gt;ExecutorService&lt;/code&gt;对象，底层的submit方法会&lt;code&gt;TtlRunnable&lt;/code&gt;或&lt;code&gt;TtlCallable&lt;/code&gt;对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以TtlRunnable类为例，它实现了&lt;code&gt;Runnable&lt;/code&gt;接口，同时还实现了它的run方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    Map&amp;lt;TransmittableThreadLocal&amp;lt;?&amp;gt;, Object&amp;gt; copied = (Map)&lt;span&gt;this&lt;/span&gt;.copiedRef.get();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (copied != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; (!&lt;span&gt;this&lt;/span&gt;.releaseTtlValueReferenceAfterRun || &lt;span&gt;this&lt;/span&gt;.copiedRef.compareAndSet(copied, (Object)&lt;span&gt;null&lt;/span&gt;))) {&lt;br/&gt;        Map backup = TransmittableThreadLocal.backupAndSetToCopied(copied);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.runnable.run();&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            TransmittableThreadLocal.restoreBackup(backup);&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&lt;span&gt;&quot;TTL value reference is released after run!&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码的主要逻辑如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;把当时的ThreadLocal做个备份，然后将父类的ThreadLocal拷贝过来。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行真正的run方法，可以获取到父类最新的ThreadLocal数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从备份的数据中，恢复当时的ThreadLocal数据。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11. ThreadLocal有哪些用途？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，一起聊聊ThreadLocal有哪些用途？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老实说，使用ThreadLocal的场景挺多的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面列举几个常见的场景：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在spring事务中，保证一个线程下，一个事务的多个操作拿到的是一个Connection。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在hiberate中管理session。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在JDK8之前，为了解决SimpleDateFormat的线程安全问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取当前登录用户上下文。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;临时保存权限数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用MDC保存日志信息。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;等等，还有很多业务场景，这里就不一一列举了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于篇幅有限，今天的内容先分享到这里。希望你看了这篇文章，会有所收获。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来留几个问题给大家思考一下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;ThreadLocal变量为什么建议要定义成static的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Entry数组为什么要通过hash算法计算下标，即直线寻址法，而不直接使用下标值？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;强引用和弱引用有什么区别？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Entry数组大小，为什么是2的N次方？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用InheritableThreadLocal时，如果父线程中重新set值，在子线程中能够正确的获取修改后的新值吗？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;敬请期待我的下一篇文章，谢谢。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>