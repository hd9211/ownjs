<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>dc05c13cb0614d6cdcae7b43cb9c5e2c</guid>
<title>文末送福利｜十一长假干嘛呢？快来吧！</title>
<link>https://toutiao.io/k/8pbs9cx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;34&quot; data-cropselx2=&quot;356&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;425&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ6h6x4EnYInRLic6PibFNWw4zSv28rAxcJu9dumVJF03PwHGOWxOzeJKIsydVa7UJuTo4jOjrct9NZw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d8943d26063876746f16d6591cc61118</guid>
<title>在 WebRTC 应用中，通过 Capture Handle 识别共享标签页</title>
<link>https://toutiao.io/k/6n33tkn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;elementor-widget-container&quot;&gt;

&lt;p&gt;我一直不太赞同在演示的同时共享屏幕。大家进入视频会议应用程序，跟大家打招呼，然后开始分享自己在另一个标签或窗口的ppt。那你要看什么呢？ppt吗？但我更想面对观众并与其互动。确实，有些工具可以让你预览所分享的内容，但你仍然需要来回滑动每张ppt。理应采用一个更好的办法，那就是capture handle。&lt;/p&gt;



&lt;p&gt;Capture Handle是origin trial中一个用于屏幕共享（getDisplayMedia）的新的API。它可以让屏幕共享app识别，与用户选择的标签相协调。&lt;/p&gt;



&lt;p&gt;Elad Alon是一位对接webrtc.org团队的谷歌员工。他负责整理capture handle规范，并推动其通过W3C的标准化过程。&lt;/p&gt;



&lt;p&gt;在这篇文章中，Elad向我们介绍了capture handle，并列举了一些关于防止“镜室 （hall of mirrors）效应”的例子。另外他也回答了我在文章开头所说，屏幕共享时切换幻灯片的问题。capture handle也有很多其他用途。下面会对此进行详述。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://webrtc.org.cn/wp-content/uploads/2021/09/1.jpeg&quot; alt=&quot;&quot; class=&quot;wp-image-3099&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;在过去的一年里，屏幕共享逐渐成为大家生活中必不可少的一部分。其原因自然不言而喻。对于基于Web的产品，该操作通常是通过调用getDisplayMedia来实现的。一旦getDisplayMedia被调用，浏览器就会向用户展示他们自己的媒体选择器。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://webrtc.org.cn/wp-content/uploads/2021/09/2.jpeg&quot; alt=&quot;&quot; class=&quot;wp-image-3100&quot;/&gt;&lt;figcaption&gt;不同浏览器中，&lt;a href=&quot;https://webrtc.github.io/samples/src/content/getusermedia/getdisplaymedia/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;getDisplayMedia示例页面&lt;/a&gt;上的屏幕共享选择器&lt;/figcaption&gt;&lt;/figure&gt;



&lt;p&gt;目前，该API允许捕获三种不同的界面展示选项——屏幕、窗口或标签。用户拥有该选择权。（这种选择可能受到用户选择的浏览器的限制。比如Firefox还不支持标签捕捉，而Safari只提供全屏捕捉。）&lt;/p&gt;



&lt;p&gt;getDisplayMedia返回一个Promise。当用户做出选择后，Promise被解决，应用程序可以开始使用返回的MediaStream，该stream有一个视频轨道，可能还有一个音频轨道。但是，应用程序还能较容易地发现捕获界面的哪些内容呢？为什么需要应用程序这样做呢？让我们来解决这两个问题。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;识别捕获的显示界面&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;以前，应用程序只能区分屏幕/窗口/标签捕获。&lt;/p&gt;







&lt;p&gt;所以，并没有标准的方法来真正识别捕获的web应用。被捕获的标签是一个YouTube视频？还是一个演示文稿？如果是演示文稿的话，它又来自哪个应用呢？如果捕获的应用程序和被捕获的应用程序甚至不能识别对方，那么它们如何进行协作？是否应该通过嵌入二维码的方式进行&lt;a href=&quot;https://en.wikipedia.org/wiki/Steganography&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;隐写&lt;/a&gt;？&lt;/p&gt;



&lt;p&gt;输入“&lt;a href=&quot;https://github.com/wicg/capture-handle/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot; title=&quot;https://github.com/wicg/capture-handle/&quot;&gt;Capture Handle&lt;/a&gt;”。让我们看几个示例来说明Capture Handle如何工作。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;检测自我抓取&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;我们可以从最简单的Capture Handle示例讲起——一个单一标签（应用程序里预期是两个）。设想现在有一个将捕获的视频呈现给本地用户的应用程序。自我捕获会导致镜厅效应。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://webrtc.org.cn/wp-content/uploads/2021/09/3.jpeg&quot; alt=&quot;&quot; class=&quot;wp-image-3101&quot;/&gt;&lt;figcaption&gt;显示被捕获屏幕时出现的镜室效应&lt;/figcaption&gt;&lt;/figure&gt;



&lt;p&gt;如果web应用能够检测到这一点，它就可以避免将视频回放给本地用户，从而避免令人不适的这种效果。&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;const TOTALLY_RANDOM_ID = “42”;  // Or actually randomize...
const ownId = TOTALLY_RANDOM_ID;

// Set the capture handle of the web application.
navigator.mediaDevices.setCaptureHandleConfig(
  { handle: ownId, permittedOrigins: [&quot;*&quot;] }
);
// ...
const stream = await navigator.mediaDevices.getDisplayMedia();
const [track] = stream.getVideoTracks();

// Check to see if the captured tab has the same handle.
const isSelfCapture =
    track.getCaptureHandle &amp;amp;&amp;amp;
    track.getCaptureHandle() &amp;amp;&amp;amp;
    track.getCaptureHandle().handle == ownId;
// Then mitigate the hall-of-mirrors as you see fit,
// e.g. hide the element using CSS.&lt;/pre&gt;



&lt;p&gt;在这种情况下，Web应用程序可以很轻易地在当前标签上设置一个ID。然后这个captureHandle().handle可以用来检查用户是否在屏幕共享选择器中选择了他们自己的标签。&lt;/p&gt;



&lt;p&gt;点击&lt;a href=&quot;https://wicg.github.io/capture-handle/demos/self_capture_detection/index.html&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;此处&lt;/a&gt;，你可以看到这个概念的完整演示。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;引导协作&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;如果一个应用程序可以识别它正在捕获的应用程序，它就可以与之协作。它们之间无论使用多传统的方法，都可以进行消息交流，并添加包括任何种类的语义。例如，一个VC应用可以远程控制幻灯片。&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://webrtc.org.cn/wp-content/uploads/2021/09/4.jpeg&quot; alt=&quot;&quot; class=&quot;wp-image-3102&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;如需观看演示请点击&lt;a href=&quot;https://wicg.github.io/capture-handle/demos/remote_control/capturer.html&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;此处&lt;/a&gt;。请注意，它是由一个C++开发人员制作的，并不是一个web开发人员。TL;DR是指，被捕获的应用程序设置一个handle，而捕获的应用程序从中提取会话ID。可以想象一个名为Slides 3000的幻灯片web应用程序：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;////////////////////////////////////////
// Captured application (Slides 3000) //
////////////////////////////////////////

function getLoonySessionId() {
  ...  // Returns some ID which is meaningful using loonyAPI.
}

function onPageLoaded() {
  // Expose and add info as you like, including the origin.
  ...
  setCaptureHandleConfig({
    exposeOrigin: true,
    handle: JSON.stringify({
      description: &quot;See slides-3000.com for our API.&quot;,
      protocol: &quot;loonyAPI&quot;,
      version: &quot;1.983&quot;,
      sessionId: getLoonySessionId(),
    }),
    permittedOrigins = [&#x27;*&#x27;]
  });
  ...
}&lt;/pre&gt;



&lt;p&gt;和一个名为VC-MAX的视频通话web应用：&lt;/p&gt;



&lt;pre class=&quot;EnlighterJSRAW&quot; data-enlighter-language=&quot;generic&quot; data-enlighter-theme=&quot;&quot; data-enlighter-highlight=&quot;&quot; data-enlighter-linenumbers=&quot;&quot; data-enlighter-lineoffset=&quot;&quot; data-enlighter-title=&quot;&quot; data-enlighter-group=&quot;&quot;&gt;////////////////////////////////////
// Capturing application (VC-MAX) //
////////////////////////////////////

async function startCapture() {
  // ...
  const stream = await navigator.mediaDevices.getDisplayMedia();
  const [track] = stream.getVideoTracks();
  if (track.getCaptureHandle) {  // Feature detection.
    // Subscribe to notifications of the capture-handle changing.
    track.oncapturehandlechange = (event) =&amp;gt; {
      onNewCaptureHandle(event.captureHandle());
    };
    // Read the current capture-handle.
    onNewCaptureHandle(track.getCaptureHandle());
  }
  ...
}

function onNewCaptureHandle(captureHandle) {
  if (captureHandle.origin == &#x27;slides-3000.com&#x27;) {
    const parsed = JSON.parse(captureHandle.handle);
    onNewSlides300Session(parsed.protocol, parsed.version, parsed.sessionId);
  }
}

function onNewSlides300Session(protocol, version, sessionId) {
  if (protocol != &quot;loonyAPI&quot; || version &amp;gt; &quot;2.02&quot;) {
    return;
  }
  // Exposes prev/next buttons to the user. When clicked, these send
  // a message to some REST API, where |sessionId| indicates that the
  // message has to be relayed to the Slides 3000 session in question.
  ExposeSlides300Controls(sessionId);
}&lt;/pre&gt;



&lt;p&gt;&lt;strong&gt;选择你自己的信令&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;capture handle可以提供识别，但并不提供通信。它并不涉及两个标签之间如何交换消息。你可以设想是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;BroadcastChannel&lt;/a&gt;，或者共享云基础设施被启用，即信令服务器（在比通常使用WebRTC情景更广泛的情况里）。所有合理的通信手段都有一个共同特点——它们要求捕获者知道被捕获的应用程序的ID，而这正是capture handle所能提供的。&lt;/p&gt;



&lt;p&gt;这为开发者实现其应用提供了方式上的灵活性。比如，如果用户打开多个幻灯片标签，多个标签是否都会被指示翻到下一张幻灯片呢？不可思议！&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;使用capture handle&lt;/strong&gt;&lt;strong&gt;优化capture&lt;/strong&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;假设有两个用户，一个用户正在和朋友分享一个1080p的预告片，提议大家一起看这部电影。另一个用户正在向同事们展示一个基本都是静态的文件。这两个用户都使用了同一种视频通话应用程序来分享另一个标签。那么在这两个capture场景中，是否应该使用相同的帧率和分辨率呢？&lt;/p&gt;



&lt;p&gt;将来，可以直接提示内容类型的机制才是主流。但作为现在的一种权宜之计，Capture Handle能帮助用户检查标签的来源是否是已知的视频服务网站、已知的生产力套装等。然后，应用程序就可以设置帧速率、分辨率属性以及&lt;a href=&quot;https://webrtc.github.io/samples/src/content/capture/video-contenthint/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;contentHint&lt;/a&gt;了。&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;Capture Handle&lt;/strong&gt;&lt;strong&gt;何时能用？&lt;/strong&gt;&lt;/p&gt;



&lt;p&gt;从M92版开始，Chrome进行Capture Handle &lt;a href=&quot;https://developer.chrome.com/blog/origin-trials/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;origin trial&lt;/a&gt;。&lt;/p&gt;



&lt;p&gt;M92版和M93版相比，API有细微差别：&lt;/p&gt;



&lt;figure class=&quot;wp-block-image size-large&quot;&gt;&lt;img src=&quot;https://webrtc.org.cn/wp-content/uploads/2021/09/5.png&quot; alt=&quot;&quot; class=&quot;wp-image-3103&quot;/&gt;&lt;/figure&gt;



&lt;p&gt;除此之外，Chrome目前没有计划进行额外的修改。如果有，我们可以在&lt;a href=&quot;https://github.com/WICG/capture-handle/blob/main/CHANGELOG.md&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;变更日志&lt;/a&gt;中找到。然而，我们确实在计划进行一项扩展，将该API扩展到窗口级capture。&lt;/p&gt;



&lt;p&gt;Chrome浏览器正在收集公共web开发人员的支持意见，以说服其他浏览器供应商了解这一功能的重要性。&lt;/p&gt;



&lt;blockquote class=&quot;wp-block-quote&quot;&gt;&lt;p&gt;文章地址：&lt;a href=&quot;https://webrtchacks.com/capture-handle/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;https://webrtchacks.com/capture-handle/&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;



&lt;blockquote class=&quot;wp-block-quote&quot;&gt;&lt;p&gt;原文作者：&lt;a href=&quot;https://www.linkedin.com/in/elad-alon/&quot; target=&quot;_blank&quot; rel=&quot;noreferrer noopener&quot;&gt;Elad Alon&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2ef75d49c15b401b71255c1edad1b900</guid>
<title>TracIn：一种估计训练数据影响的简单方法</title>
<link>https://toutiao.io/k/5diady5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;机器学习 (ML) 模型训练数据的质量可能对其性能产生重大影响。数据质量的一种衡量标准是影响的概念，即给定训练示例影响模型及其预测性能的程度。虽然影响力对于机器学习研究人员来说是一个众所周知的概念，但深度学习模型背后的复杂性，加上其不断增长的规模、特征和数据集，使得影响力的量化变得困难。&lt;/p&gt;&lt;p&gt;最近提出了一些方法来量化影响。有些依赖于在删除一个或多个数据点的情况下重新训练时准确度的变化，有些使用已建立的统计方法，例如估计扰动输入点影响的影响函数或将预测分解为训练示例重要性加权组合的表示方法. 还有其他方法需要使用额外的估计器，例如使用强化学习的数据评估。尽管这些方法在理论上是合理的，但它们在产品中的使用受到了大规模运行它们所需的资源或它们给培训带来的额外负担的限制。&lt;/p&gt;&lt;p&gt;在NeurIPS 2020 上作为焦点论文发表的“通过跟踪梯度下降估计训练数据影响”中，我们提出了TracIn，这是一种简单的可扩展方法来应对这一挑战。TracIn 背后的想法很简单——跟踪训练过程以在访问单个训练示例时捕获预测的变化。TracIn 可有效地从各种数据集中查找错误标记的示例和异常值，并且通过为每个训练示例分配影响分数，可用于根据训练示例（而不是特征）解释预测。&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;em&gt;TracIn&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;深度学习算法的基本思想通常使用称为随机梯度下降(SGD)的算法或其变体进行训练。SGD 通过对数据进行多次传递并对模型参数进行修改，从而在每次传递中局部减少损失（即模型的目标）。下图中的图像分类任务演示了一个示例，其中模型的任务是预测左侧测试图像的主题（“西葫芦”）。随着模型在训练中取得进展，它会接触到影响测试图像损失的各种训练示例，其中损失 是预测分数和实际标签的函数——西葫芦的预测分数越高，损失越低。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceFRyyLH7Y0mVtKsRvs2lsH3Z8abuPxLbTlbLEIlxjkjVYttls12fC1RltRdBflDJOynrQiaX4gvT4w/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;p&gt;假设在训练时已知测试样例，并且训练过程一次访问每个训练样例。在训练期间，访问特定的训练示例会更改模型的参数，然后该更改将修改测试示例的预测/损失。如果可以在整个过程中跟踪训练示例，那么测试示例的损失或预测的变化可以归因于所讨论的训练示例，其中训练示例的影响将是对训练示例的访问的累积归因.&lt;/p&gt;&lt;p&gt;有两种类型的相关训练示例。那些减少损失的，如上面的西葫芦的形象，被称为支持者，而那些增加损失的，如安全带的形象，被称为反对者。在上面的示例中，标记为“太阳镜”的图像也是一个支持者，因为它在图像中带有安全带，但被标记为“太阳镜”，从而促使模型更好地区分西葫芦和安全带。&lt;/p&gt;&lt;p&gt;在实践中，测试示例在训练时是未知的，这个限制可以通过使用学习算法输出的检查点作为训练过程的草图来克服。另一个挑战是学习算法通常一次访问多个点，而不是单独访问，这需要一种方法来解开每个训练示例的相对贡献。这可以通过应用逐点损失梯度来完成。这两种策略一起捕获了 TracIn 方法，该方法可以简化为测试和训练示例的损失梯度的点积的简单形式，由学习率加权，并跨检查点求和。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceFRyyLH7Y0mVtKsRvs2lsH3eSO5yY0ZCcqV72CEe48LfM9l93kaicIiataQ6BGbFgx0aiaDJOFq2dibOg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;p&gt;或者，可以改为检查对预测分数的影响，如果测试示例没有标签，这将很有用。这种形式只需要用预测梯度替换测试示例中的损失梯度。&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;em&gt;计算顶级影响示例&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;我们首先通过计算一些训练数据的损失梯度向量和特定分类的测试示例（变色龙的图像）来说明 TracIn 的效用，然后利用标准的k-最近邻库来检索顶部支持者和反对者。顶级对手说明变色龙的混血能力！为了进行比较，我们还展示了k 个最近邻，以及来自倒数第二层的嵌入。支持者是不仅相似而且属于同一类的图像，反对者是相似的图像但属于不同的类。请注意，没有明确规定支持者或反对者是否属于同一类。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3956043956043956&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceFRyyLH7Y0mVtKsRvs2lsH38yruktClE0AYqwnAWVFaPdjGV1iaF1ymfrdfxcqY4gibB3wCbzWhWBpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;637&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;em&gt;聚类&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;由 TracIn 给出的将测试样例的损失简单分解为训练样例的影响也表明，任何基于梯度下降的神经模型的损失（或预测）都可以表示为梯度空间中相似性的总和。最近的工作表明，这种函数形式类似于内核的函数形式，这意味着这里描述的这种梯度相似性可以应用于其他相似性任务，如聚类。&lt;/p&gt;&lt;p&gt;在这种情况下，TracIn可以是作为所用的相似功能一个内聚类算法。为了限制相似性度量以便将其转换为距离度量（1 - 相似性），我们将梯度向量归一化为具有单位范数。下面，我们在西葫芦图像上应用 TracIn 聚类以获得更精细的聚类。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.835&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceFRyyLH7Y0mVtKsRvs2lsH3wMuenVHoCicDCy2NZkRCw2PraibN8bucK8SiaMRdu7rnHVB3jvB7f1VTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;em&gt;识别具有自我影响的异常值&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;最后，我们还可以使用 TracIn 来识别表现出高度自我影响的异常值，即训练点对其自身预测的影响。当示例被错误标记或罕见时会发生这种情况，这两种情况都会使模型难以对示例进行泛化。以下是一些自我影响力高的例子。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceFRyyLH7Y0mVtKsRvs2lsH3HxskfwVa7MrDCu7RGrttU9G4iavZA0mOtmXibfIyZZvNeOSA6wXBn8DA/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceFRyyLH7Y0mVtKsRvs2lsH3Svic9rKtxEelphZ4P6hwWSj5VFd0ibjrY4U7icHoA3icTEAmMgx09WbHjw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;em&gt;应用程序&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;除了使用 SGD（或相关变体）进行训练外，没有其他要求，TracIn 与任务无关，适用于各种模型。例如，我们使用 TracIn 研究了深度学习模型的训练数据，该模型用于解析对 Google 智能助理的查询，即“将我的闹钟设置为早上 7 点”类型的查询。我们很感兴趣地看到查询“禁用我的警报”的最大对手是“禁用我的计时器”，同时设备上的警报也处于活动状态。这表明助理用户经常互换“计时器”和“闹钟”这两个词。TracIn 帮助我们解释了 Assistant 数据。&lt;/p&gt;&lt;p&gt;更多的例子可以在论文中找到，包括一个结构化数据的回归任务和一些文本分类任务。&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;em&gt;结论&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;TracIn 是一种简单、易于实施、可扩展的方法，用于计算训练数据示例对单个预测的影响或查找稀有和错误标记的训练示例。对于该方法的实现参考，您可以在论文中链接的 github 中找到指向图像代码示例的链接。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4180568d6f91fb3539eea4409c75a203</guid>
<title>深入浅出 Performance 工具 &amp; API</title>
<link>https://toutiao.io/k/4n7i89u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p class=&quot;js_reprint_biz_profile_description&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkxNTIwMzU5OQ==&amp;amp;mid=2247487883&amp;amp;idx=1&amp;amp;sn=32994040ecf88dbe2dca49eba8cfb7fd&amp;amp;chksm=c163e2ebf6146bfd60fde4ab8b32a4e2ebd7ce9e99cc403479cc7eab991be98539237221aa9c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;深入浅出 Performance 工具 &amp;amp; API&lt;/a&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;概述&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日常开发任务中，对于性能优化或多或少会接触到一些内容，可能也参照过&lt;span&gt;雅虎 35 条军规&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;进行过相关的性能优化，但是具体的优化结果以及实际的页面速度如何，我们怎么去看呢？以及出现性能问题了，我们如何通过现有工具进行定位&amp;amp;解决？也就是今天我要给大家介绍的内容主题了「Performance」，主题偏向工具介绍，主要从下面 4 个方面介绍今天的内容。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Chrome Perormance 工具使用：介绍如何使用浏览器提供的工具定位&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Performance Api 监测网页性能：介绍如何自己去做性能数据的提取&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;现存检测工具：三方性能检测工具介绍&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Performance 工具小试：通过一个小例子运用 Performance&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Chrome Performance 工具使用&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7419962335216572&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASibiaquXSTMYDMmyqGuyFKvuWPf6xeQWH1Rqx1sma1XBUD9R6UX0wAP7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2124&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Chrome 中 Performance 可以在上图中看到，主要分了几个板块&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;控制面板（Controls）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开启记录，停止记录，配置记录期间需要记录的内容。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.14015151515151514&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASnKPUiaic98HfyuY1uXoZpbNHTU5Ericd00iaBV3JNCp93NM5AlcIS8gBAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2112&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作主要分了 2 个区域，操作 1 区从左到右依次是 &quot;Record/Stop&quot;、&quot;Reload&quot;和&quot;Clear&quot;，&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&quot;Record/Stop&quot;：一般用于录制页面交互过程的性能变化数据，选择任意想要测试的过程，点击&quot;Record&quot;，并在测量结束之后，点击&quot;Stop&quot;，之后 Chrome 就会自动解析这段时间内抓取的数据，并生成报告。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&quot;Reload&quot;：一般用于录制首屏加载的性能变化数据，它会自动刷新整个页面，并开始记录性能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&quot;Clear&quot;：用于清除性能报告数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;操作 2 区可以选择报告展示内容，从左到右依次是 Screenshots、Memory、Web Vitals&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Screenshots：打开后可以在概览区看到屏幕的截图&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Memory：打开内存监控&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;WebVitals&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;概览面板（Overview）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要是对页面表现行为的一个概述，区域由三个图形记录组成。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;FPS（Frames Per Second）:绿色的柱越高， FPS 值也越高。FPS 图表上方的红色小块指明了长帧(long frame)，这些可能是卡顿。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.265625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszAS3vey6xmBTFtqI6vUJLbp5B7p24WZPMTV66nncDkq5lOINh4eW4WWrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;CPU(CPU Resources):这个面积图(area chart)表明了哪种事件在消耗 CPU 资源。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;NET:每种不同颜色的条代表一种资源。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;每个条中的浅色部分代表等待时间（资源请求被发送到收到第一个响应字节的时间），深色部分代表文件传输时间（从收到第一个字节到这个资源完全被下载好）&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;蓝色 代表 HTML 文件，黄色 代表 Script 文件，紫色 代表 Stylesheets 文件， 绿色 代表 Media 文件，灰色 代表其他资源。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;火焰图（Flame Chart）&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;火焰图（Flame Chart）: 可视化 CPU 堆栈(stack)信息记录。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从不同的角度分析框选区域 。例如：Network，Frames, Interactions, Main 等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在火焰图面板上你可能看到三根垂直的线，蓝线代表 DOMContentLoaded 事件，绿线代表渲染开始的时间( time to first paint)，红线代表 load 事件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.38984375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASnkgSWZwVV6RUibAe9dib20ibSQ3piblSz4NfTHWzhautD3qKkib3uEa6SfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这里我们主要需要关注 Main，因为他是主线程的一个执行情况的监控。点开后，我们可以看当前线程里面一些任务的执行堆栈耗时，我们需要重点关注一些标红（也就是有较高耗时）的任务。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;详细信息（Detail）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当有具体事件被选择时，该面板展示这个事件的更多详细信息。如果没有事件被选择，该面板展示当前所选时间段的一些信息。详细面板支持精确到毫秒级别的分析，详细面板主要分了&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5731922398589065&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASsricNSFPAtnzXtcjOrDP1KGDicticSHx1kiaDxsJMSUaKpFL6NDoliaJGHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1134&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Summary 面板：从宏观层面概括了浏览器加载的总时间，主要记录了各个阶段的名称、占用时间、颜色信息。这里一般来说，需要着重关注的有两个：一是黄色的区域，代表脚本执行时间，另一个是紫色的渲染时间。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;颜色：蓝色 ；英文：Loading；含义：加载&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;颜色：黄色 ；英文：Scripting；含义：脚本&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;颜色：紫色 ；英文：Rendering；含义：渲染&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;颜色：绿色 ；英文：Painting；含义：绘制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;颜色：深灰 ；英文：Other；含义：其他&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;颜色：浅灰 ；英文：Idle；含义：空闲&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Bottom-Up 面板：Bottom-Up 中一共三列数据&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Self Time：代表任务自身执行所消耗的时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Total Time：代表此任务及其调用的附属子任务一共消耗的时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Activity：具体的活动，部分带有 Source Map 链接，可以直接定位到花费时间的具体源码，方便我们进行定位和优化。Activity 中也有标注各自的颜色，和 Summary 中颜色是对应的。可以根据颜色快速判断是脚本执行、加载、还是渲染过程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASRh24ZzItrbYcupdyTYQ4QtkT3QGZK402dln7VWUrlUtgeY3cdcUN8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Call-Tree 面板：Bottom-Up 类似事件冒泡，Call Tree 类似事件捕获。自上而下的 Call-Tree 更符合我们的人类正常思维，可以更直观地分析浏览器对页面的 build 精确到毫秒级的情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Event-Log 面板：展示所有阶段包括 loading、javascripting、rendering、painting 中各事件的耗时情况，并提供了 filter 输入框和按钮供你快速过滤，常见的优化级别中一般用不到它。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASRh24ZzItrbYcupdyTYQ4QtkT3QGZK402dln7VWUrlUtgeY3cdcUN8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Performance Api 监测网页性能&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了浏览器为我们提供的 Performance 性能检测调试工具外，W3C 也定义了一套 Performance 标准，各个浏览器厂商基于标准提供了监控网络性能的一系列基础 Api，这些 Api 可以提供检测白屏时间、首屏时间、用户可操作的时间节点，页面总下载的时间、DNS 查询的时间、TCP 链接的时间等。我们完全可以利用这个搭建一个简易的性能监控工具，当然监控系统包含了数据采集-&amp;gt;数据存储-&amp;gt;清洗-&amp;gt;监控几个过程，不过目前我们这里简单运用一下 Performance Api 就只考虑采集阶段。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;提供的能力&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;属性篇&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;performance 的所有 Api&amp;amp;property 挂载在 window 下面的 performance 属性中，可以看到目前提供的一系列属性，关于各个属性的介绍，参照网上对 aip 的解释，有大量资料可供查询。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2703125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASC8E5WNibFrs4XSGyzib5DVXzOQVzBthECF04IymN9B6GM6HKjcnC7Pww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所展现，performance 包含三个对象，分别为&lt;strong&gt;memory、navigation、timing&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;memory：是和内存相关的，其提供对内存使用情况的描述，我们可以使用这个属性来订阅页面内存变化情况&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;jsHeapSizeLimit：堆内存大小的限制&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;totalJSHeapSize：总堆内存的大小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;usedJSHeapSize：已经使用的堆内存大小&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;navigation：含义是页面的来源信息，表述页面怎么跳转过来的，该对象有 2 个属性值&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;redirectCount**：**记录重定向次数，如果有重定向的话，页面通过几次重定向跳转而来，默认为 0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;type**：**页面打开的方式，默认为 0，可取值为「0：表示正常进入该页面(非刷新、非重定向)」、「1：表示通过 window.location.reload 刷新的页面」、「2：表示通过浏览器的前进、后退按钮进入的页面」、「255：表示非以上的方式进入页面的」&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;timing：提供页面加载过程中一系列关键时间点的高精度测量，它包含了网络、解析、加载等一系列的时间数据，我们监控网页性能也是基于此提供的属性。为了方便理解，从网上找了一张图片来解释关键节点的含义。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7046875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASGPMlCXtvzVn1JkYuE3vTTTN6R1KYEpk8Oh8eMajNxJ49QQ9ShYaBhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;navigationStart**：**一个页面卸载结束时的时间戳。如果没有上一个页面的话，那么该值会和 fetchStart 的值相同&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;redirectStart**:**第一个 http 重定向开始的时间戳，如果没有重定向，或者重定向到一个不同源的话，那么该值返回为 0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;redirectEnd**:**最后一个 HTTP 重定向完成时的时间戳。如果没有重定向，或者重定向到一个不同的源，该值也返回为 0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;fetchStart**:**浏览器准备好使用 http 请求抓取文档的时间(发生在检查本地缓存之前)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;domainLookupStart**:**DNS 域名查询开始的时间，如果使用了本地缓存话，或持久链接，该值则与 fetchStart 值相同&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;domainLookupEnd**:**DNS 域名查询完成的时间，如果使用了本地缓存话，或 持久链接，该值则与 fetchStart 值相同&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;connectStart**:**HTTP 开始建立连接的时间，如果是持久链接的话，该值则和 fetchStart 值相同，如果在传输层发生了错误且需要重新建立连接的话，那么在这里显示的是新建立的链接开始时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;secureConnectionStart**:**HTTPS 连接开始的时间，如果不是安全连接，则值为 0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;connectEnd：HTTP 完成建立连接的时间(完成握手)。如果是持久链接的话，该值则和 fetchStart 值相同，如果在传输层发生了错误且需要重新建立连接的话，那么在这里显示的是新建立的链接完成时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;requestStart**:**http 请求读取真实文档开始的时间，包括从本地读取缓存，链接错误重连时&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;responseStart**:**开始接收到响应的时间(获取到第一个字节的那个时候)。包括从本地读取缓存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;responseEnd**：**HTTP 响应全部接收完成时的时间(获取到最后一个字节)。包括从本地读取缓存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;unloadEventStart**:**前一个网页（和当前页面同域）unload 的时间戳，如果没有前一个网页或前一个网页是不同的域的话，那么该值为 0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;unloadEventEnd**:**和 unloadEventStart 相对应，返回是前一个网页 unload 事件绑定的回调函数执行完毕的时间戳。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;domLoading**:**开始解析渲染 DOM 树的时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;domInteractive**:**完成解析 DOM 树的时间（只是 DOM 树解析完成，但是并没有开始加载网页的资源）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;domContentLoadedEventStart**：**DOM 解析完成后，网页内资源加载开始的时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;domContentLoadedEventEnd**:**DOM 解析完成后，网页内资源加载完成的时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;domComplete**:**DOM 树解析完成，且资源也准备就绪的时间。Document.readyState 变为 complete，并将抛出 readystatechange 相关事件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;loadEventStart**:**load 事件发送给文档。也即 load 回调函数开始执行的时间，如果没有绑定 load 事件，则该值为 0&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;loadEventEnd**:**load 事件的回调函数执行完毕的时间，如果没有绑定 load 事件，该值为 0&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;方法篇&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34765625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASibiakEclDcfD7QDVfWwZoBick6kO1wSO2VFCia4rZ3KqY2oabA759vEuXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图，截取的图片，Performance 提供了一些，这里我主要介绍一下 now()方法和 getEntries()方法。其他的网上资料也比较多和全，可以查阅 https://juejin.cn/post/6844903801518981133#heading-54&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;now 方法：提供精度相对较高的时间计算主要有下面两个特点&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;和 JavaScript 中其他可用的时间类函数（比如&lt;code&gt;Date.now&lt;/code&gt;）不同的是，&lt;code&gt;window.performance.now()&lt;/code&gt;返回的时间戳没有被限制在一毫秒的精确度内，相反，它们以浮点数的形式表示时间，精度最高可达微秒级。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;另外一个不同点是，&lt;code&gt;window.performance.now()&lt;/code&gt;是以一个恒定的速率慢慢增加的，它不会受到系统时间的影响（系统时钟可能会被手动调整或被 NTP 等软件篡改）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以用这个方法来衡量函数执行的时间，达到监控函数执行效率的效果&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;`const fun = () =&amp;gt; {&lt;br/&gt;&lt;br/&gt;// do something&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;const startExcuteTime = window.performance.now();&lt;br/&gt;&lt;br/&gt;fun();&lt;br/&gt;&lt;br/&gt;const endExcuteTime = window.performance.now();&lt;br/&gt;&lt;br/&gt;console.log(&quot;fun 函数执行了&quot; + (endExcuteTime - startExcuteTime) + &quot;毫秒.&quot;)  &lt;br/&gt;`&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;getEntries 方法：通过该方法，我们能够拿到页面所有资源请求的详细情况，这个方法返回值根据传入的参数不同会有不同。但返回值的结构都是一样的，都是一个对象数组，每个对象是对资源的请求过程的描述，在 console 调用 performance.getEntries()，可以直接看到当前页面所有资源的加载过程。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszAS1zTGZI3aLNwLtSqBduuwbz7YxiaH3JHBDyh2hiaYRVMwV4vIoOC1GuHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点开数组中的元素，每个元素详细记录了资源请求关键节点的时间，所以我们完全可以利用这个来实现对资源的请求监控。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.50234375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASqTFRAvTe58mGwgaG3RvcUhOqqcdN8Q0icC0W8APLbjFMwybBiaqP1NUA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多 Api 细节，可以参考司内文章&lt;span&gt;再看一次 Performance 接口&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;简单实现指标计算&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个监控系统大致可以分为这个下面阶段，我们这里就先关注一下数据的采集阶段。数据采集阶段设计到两点，一个是数据的搜集，一个是数据的上报。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.12732919254658384&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASMwgfI6pm2NY5FtNOMpmwFYZnQib63JDvOkxOJJ0Bic0EnZBFkibgzOzicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1288&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据的搜集：数据搜集依赖于 Performance Api 拿到性能数据，我们参照一定的计算指标，得到计算值的集合。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据的上报：将搜集到的数据上报到服务器，上报使用的方式也就是发送一个 http 请求， 不过目前因为监控数据采用 XHR 的请求上报，受到条件限制比较多，数据容易丢失，容易漏报，且对页面性能有一定的影响。而 sendBecan 是浏览器为了解决这些问题，它会使用户代理在有机会时异步地向服务器发送数据，同时不会延迟页面的卸载或影响下一导航的载入性能。这就解决了提交分析数据时的所有的问题：数据可靠，传输异步并且不会影响下一页面的加载。具体可以参考：https://developer.mozilla.org/zh-CN/docs/Web/API/Navigator/sendBeacon&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是 Slardar 源码截图，可以看到他们上报监控数据优先采用的 sendBecan，降级策略为 XHR 请求。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.56328125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASDEEeMNxkcGFveaffNxkr6yLDUbnvLGm3RWgfsIL6pvHYJ5eqrY5rbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过 performance api 来实现我们经常关注的一些指标的计算和上报&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;`重定向耗时  = redirectEnd - redirectStart;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DNS 查询耗时  = domainLookupEnd - domainLookupStart;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP 链接耗时  = connectEnd - connectStart;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 请求耗时  = responseEnd - responseStart;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解析 dom 树耗时  = domComplete - domInteractive;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;白屏时间  = responseStart - navigationStart;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DOMready 时间  = domContentLoadedEventEnd - navigationStart;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;onload 时间  = loadEventEnd - navigationStart;&lt;br/&gt;`&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;现存的一些网页性能检测工具&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了前面两种方式能够检测页面性能外，还有一些三方的工具 or 平台为我们提供了检测能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是使用 LightHouse 的截图，Lighthouse 生成的不仅仅是一些性能相关的数据，他除了能给我们提供页面性能检测外，还为我们列出了一系列的优化建议，我们对网站或者页面的优化，可以参照建议一步步进行优化。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48359375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszAS9SoMcvR9GGNObic6Qk6eph0RC7Mn7uUGPgNDFsvcib5MRpfd8b4l8Hibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提供组件级别的渲染分析&lt;span&gt;React 性能测量和分析&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;span&gt;React Profiler 介绍 – React Blog&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Performance 工具小试&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学浪老师端项目代码目前跑在两个大的宿主环境中「CEF 套壳」「浏览器」，项目一期的时候，整体项目是采用的单入口多路有方式，并且来说项目的打包也没有优化，整体上呈现出&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;访问混乱（浏览器能访问 CEF 壳子内的一系列路由）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;打包混乱（出现多种重复打包，导致编译慢）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引用混乱（因为是是一套入口，很多只是在 CEF 内引用的文件，在单入口文件中引用了，导致浏览器加载了一系列不必要的静态资源）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的一系列问题，导致学浪整体页面加载速度非常的慢，后续学浪侧专门组织了一次大的重构优化，进行了项目入口的拆分&amp;amp;打包过程的的拆分，整体上现的学浪项目结构是多入口多路由，且区分宿主环境的。从目前的表现来看，页面的加载速度相对于以前提升了非常多。目前的加载时长度在我当前网络情况下 DomContentLoad 大概在 2S 左右&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.546875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszAShj5xeludLZYc8UdxZzrGyTonPsAtta1CFSDcQZJelicMVPSTNNYoRfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是否还有优化空间，将页面加载时间降得更低？我们可以通过 Performance 的 NetWork 火焰图看看到底是哪些文件的加载耗时长，延长了 DomContentLoad 触发时机。首先 DomContentLoad 事件触发影响因素有 html 下载、dom 解析、js 脚本下载&amp;amp;执行，都会影响 DomContentLoad 触发。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.38671875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASSibshAkqONSKsuogUQJ8Hx6jBXibyf1CiazyAdXibIsFyKuRiaZqWicvx1hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过观察 NetWork 的情况，很明显看到 DCL 的时机，在一个 encoding.js 文件加载完成后，再触发的，而这个文件的加载时间长达 2.13s，可谓是占据了首页加载的 80%左右的时间，那么就想如何优化这个脚本的加载时长？有几种思路&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;压缩 encoding.js 使得体积减小（前提是没有压缩的情况下）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;看是否是首页强依赖文件（如果是后续依赖，可以采用异步脚本 defer or async 来解决下载阻塞了 DomContentLoad 问题）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;看是否真正有使用（最好的办法就是不用 😈，这样就完全省去了时间）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当然还有其他一系列客户端缓存、cdn 加速等一系列策略&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;找到了原因和思路，于是开始先对文件背景溯源，发现由于这个文件是为了处理一些教室内 sdk 在不同浏览器內的 pollfiy，但是目前因为通过阶段一的大包&amp;amp;入口的拆分，教室内 sdk 的相关资源不会出现在浏览器环境加载了，因此在浏览器环境内实际不再使用，godless 我们可以直接删除，看下效果。（实际看 encoding.js 文件也是没有压缩过的，如果实际文件有在用，我们可以采取使用压缩文件）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5328125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASWEPA0QCOtDIy8dHpsCBQQD9eemp1FS88WQHsyfgalZlF6bF34CZebA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5484375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/lP9iauFI73z9hTP4vNprRuhJAU5AsszASeJy0gjSWfdnXiaKQfGNt7FdsmZFjfKXsyPu32QiaSePliaKgNhDRCEtbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体上 DCL 的触发时间由 2.13s 降低为 972ms，效果还是比较明显的。通过一个很小的分析案例+很小的优化说明下 Performance 面板中相关模块的使用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要介绍了通过工具的使用来定位性能问题以及通过 Performance Api 来自己做一些指标的计算统计，目前公司内的 Sladar 已经为我们提供了比较全面的数据分析，但是对于一些定位页面性能的基础工具和基础能力的了解对于日常的工作中也是有帮助的&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[1]雅虎 35 条军规:&lt;em&gt;https://juejin.cn/post/6844903657318645767&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[2]再看一次 Performance 接口:&lt;em&gt;https://bytedance.feishu.cn/docs/doccnZoHj24ab8HVh42aQEowZGh#&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[3]React 性能测量和分析:&lt;em&gt;https://juejin.cn/post/6844903869378641933#heading-4&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[4]React Profiler 介绍 – React Blog:&lt;em&gt;https://zh-hans.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[5]React 性能测量和分析:&lt;em&gt;https://juejin.cn/post/6844903869378641933#heading-4&lt;/em&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[6]React Profiler 介绍 – React Blog:&lt;em&gt;https://zh-hans.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/lP9iauFI73zicqIKtS2GZJAscn2mSicDf8VE06OjPC9K6ibFHdqwh1bjnd7wia6ib70giazDoeVoxBg5ibxQl8jq8n1qsw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;p&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>318b487fca4bb225e379d223788acd17</guid>
<title>独立开发变现周刊（第 22 期）：回复消息来辨别鞋子真假，年收入 20 万美金？</title>
<link>https://toutiao.io/k/x7k8vny</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left&quot; aria-describedby=&quot;js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MjM5OTM3NzAwNg==&amp;amp;action=getalbum&amp;amp;album_id=1857680644290478080#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;1857680644290478080&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#独立开发变现周刊&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;22个&lt;span class=&quot;weui-hidden_abs&quot;&gt;内容&lt;/span&gt;&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;strong&gt;&lt;span&gt;分享独立开发产品变现相关有价值的内容，每周五发布。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目录&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;1、Notion-avatar：一个生成 Notion 风格头像的在线工具&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;2、WxPusher：微信消息实时推送服务&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;3、Ch Daniel: 回复消息来辨别鞋子真假，年收入20万美金？&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;4、Anne-Laure Le Cunff: 100天发布100篇文章挑战，年收入10万美金&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;5、AI拟声: 5秒内克隆您的声音并生成任意语音内容&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;1、Notion-avatar：一个生成 Notion 风格头像的在线工具&lt;/h2&gt;&lt;p&gt;这是一个开源项目，可以在线生成Notion风格的头像，网站搭建用：Nextjs、Tailwind、Vercel。这个小工具虽然功能简单，但是很受欢迎。其实实现这个小产品更重要的是头像的素材。作者找到一位设计师，并获得了他的授权，而这些头像可以从gumroad上花$10买到，购买后可以用于任何用途。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.47333333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/G4umk62oPLpYia2ckKG1Iicofps1HD99BaA3wN6QYrNlUdjDjmZmEeH2ia09rexZX6ibevGEBtV1BXzrgeiaxTo62Og/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;Notion-avatar开源代码地址&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;&lt;h2&gt;2、WxPusher：微信消息实时推送服务&lt;/h2&gt;&lt;p&gt;先说下我为什么会找到这个产品？发现这个产品是因为我个人做产品的过程中，有一个需求痛点，就是想收到用户付款的通知提醒。我想找到一个可以在用户给我的产品付款后，能及时的收到付款通知，这样我就会感觉很爽~。&lt;/p&gt;&lt;p&gt;WxPusher (微信推送服务)是一个使用微信公众号作为通道的，实时信息推送平台，你可以通过调用API的方式，把信息推送到微信上，无需安装额外的软件，即可做到信息实时通知。你可以使用WxPusher来做服务器报警通知、抢课通知、抢票通知，信息更新提示等。&lt;/p&gt;&lt;p&gt;这些功能基本满足我的需求，而且是免费的，只需要在它的后台配置好Key，然后通过http请求就可以了。而且有其它语言Java、Go、Phyton、PHP的SDK。如果你也有类似我这样的需求，可以加入自己的收藏夹，以备后用。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.48333333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/G4umk62oPLpYia2ckKG1Iicofps1HD99Ba9ec4deRLiaR8iaPtaW4vUbMCVGlvyUypiaSicpEb5ibA19KoTF3YWo0toaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;One more thing...&lt;/span&gt;&lt;/p&gt;&lt;p&gt;基于好奇心理，我又搜了搜相关资料，也有人有我类似的痛点，发现了一个帖子，感觉讨论还是挺有价值的，如何实现在手机通知Push上实现个人即时的消息通知呢？现有的解决方案貌似没有一个令人满意的。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;邮箱：拉取有延迟，发送不便&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Server 酱的 APP，基本残废，无法使用&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;PushOver 收费&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Slark，钉钉：太重，我只想要一个消息栏通知&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;短信接口，不想上传各种身份证户口本&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;下面评论给出的解决方案也有很多：&lt;/p&gt;&lt;section&gt;1、ifttt+telegram&lt;/section&gt;&lt;section&gt;2、mipush 自己写个空壳 app&lt;/section&gt;&lt;section&gt;3、Chrome webpush 做的一个&lt;/section&gt;&lt;section&gt;4、Pushover or Bark&lt;/section&gt;&lt;p&gt;不过这些解决方案都不是很好，要么鸡肋，要么国内使用不够友好。&lt;/p&gt;&lt;p&gt;WxPusher微信推送服务&lt;sup&gt;[2]&lt;/sup&gt;&lt;/p&gt;&lt;p&gt;手机Push个人通知讨论实现&lt;sup&gt;[3]&lt;/sup&gt;&lt;/p&gt;&lt;h2&gt;3、Ch Daniel: 回复消息来辨别鞋子真假，年收入20万美金？&lt;/h2&gt;&lt;p&gt;我叫Ch Deniel，简单来说，用户付费，我通过回复一些消息告诉用户购买的商品是真品还是假的，类似下面这样的，一年收入了20万美金。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5633333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/G4umk62oPLpYia2ckKG1Iicofps1HD99BaSgLZbzQom8g25FZSeLM6ZbZvQQyibbBmjTyVPficZwwYtiaFibv1QccTcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;这样一条消息, 从20美金到100美金不等~&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;semantics&gt;&lt;annotation encoding=&quot;application/x-tex&quot;&gt;20，最高的时候一条&lt;/annotation&gt;&lt;/semantics&gt;&lt;span&gt;&lt;span&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&lt;span&gt;&lt;span&gt;候&lt;/span&gt;&lt;span&gt;一&lt;/span&gt;&lt;span&gt;条&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;100，取决于商品的价格高低。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那我们是怎么做到的呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2017年的时候，我19岁，我想做个App，这个App很简单，用户只是选择品牌，然后引导用户到我的个人网站上去查看辨别真假指导手册。&lt;/p&gt;&lt;p&gt;这样的App+website组合，然后将这个产品发布在了Reddit上，不断的有新用户来浏览，用户数不断的增长5,000、10,000、40,000、300,000&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5633333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/G4umk62oPLpYia2ckKG1Iicofps1HD99BaLLchBm64pQRjJVOEDsU3TtgtTegXXlyuwxiavxFjAXYMkCZmXeHGicVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;到350,000用户的用户的时候，每天都会收到3~10封邮件，让我帮他们鉴定产品真假，一开始我还是免费回复，后来觉得我需要通过向用户收取一定的费用，来安排用户优先级，并验证这样模式是否可持续的。并叫了我15岁的弟弟过来帮忙。&lt;/p&gt;&lt;p&gt;后来就在指导手册上加上了Stripe的付款链接，就不断的有收到付款。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5633333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/G4umk62oPLpYia2ckKG1Iicofps1HD99BaB2HNhN33xkZSlZEgeiazLJgxcL1vzGgSskTvYrAHUiaL6kOOf5wDu4vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;为的看起来更像一个产品，做了现在的网站 legitcheck.app&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4166666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/G4umk62oPLpYia2ckKG1Iicofps1HD99Ba82LUpFjeicxWvibcLfOPG5jVibBpc0cWdzXeYTkOay9fwtdef1fj2RObw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们是如何获取流量并保持增长的呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;我们每个月有30 -40万独立用户。&lt;/p&gt;&lt;p&gt;我很幸运做了下面的事情。&lt;/p&gt;&lt;p&gt;1、当我什么都没做的时候，流量一直在增长。我甚至在不知道SEO的情况下就找到了一个SEO金矿&lt;/p&gt;&lt;p&gt;2、我学习了SEO，在“假vs真(物品名称)”搜索中保持排名第一的位置 3、用户对物品认证的需求不断增长&lt;/p&gt;&lt;p&gt;4、我们用它打造了一个品牌，并尽最大努力让它变得更加可信和专业&lt;/p&gt;&lt;p&gt;5、高利润率、低批量、基于时间的服务(如果需要，利润率为95%)&lt;/p&gt;&lt;p&gt;6、提供出色的客户支持，在必要的时候做正确的事情(退款)，为客户超额交付服务等等。&lt;/p&gt;&lt;p&gt;Ch Deniel和弟弟的故事&lt;sup&gt;[4]&lt;/sup&gt;&lt;/p&gt;&lt;h2&gt;4、Anne-Laure Le Cunff: 100天发布100篇文章挑战，年收入10万美金&lt;/h2&gt;&lt;p&gt;Anne-Laure Le Cunff是一个移民的孩子，在Google工作让她觉得眼前的工作一眼就能看到底，这不是她想要的，于是辞职做开始做自己的事，那一年压力很大，因为不想让自己的妈妈失望，但还是失败了。那时Anne-Laure可以继续回大公司上班，但是内心深处知道那不是自己想要的，于是决定继续往前走。&lt;/p&gt;&lt;p&gt;Ness Labs最初在2019年9月份开始的一个订阅服务，社区功能上线是在2020年的3月份。希望能提供一个大家互相连接，共同学习提高，有共同话题的空间。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.765&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/G4umk62oPLpYia2ckKG1Iicofps1HD99BaEUhHrOHWJww43yr5LgpsL5qs4jM8R1oPic4eX9icib7PgQHtLW6cPOaEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;在2019年的时候，Anne-Laure想做一个挑战，100天写100篇文章，练习用英语写作，并将过程公开。这样既是对自己的促进，同时也吸引了很多人的关注。后来有很多的媒体、播客也开始采访Anne-Laure。&lt;/p&gt;&lt;p&gt;一开始需要调整自己的心态，觉得有压力，后面逐渐就变成了一种习惯，再后来就逐渐享受这个过程了。虽然感到害怕，但仍然追求你相信的东西。&lt;/p&gt;&lt;p&gt;Anne-Laure说：”我妈妈没有接受过正规教育，但每当她看到有人在做有趣的事情，她就会想，如果他们能做，为什么我不能?“&lt;/p&gt;&lt;p&gt;100天发布100篇文章挑战故事&lt;sup&gt;[5]&lt;/sup&gt;&lt;/p&gt;&lt;h2&gt;5、AI拟声: 5秒内克隆您的声音并生成任意语音内容&lt;/h2&gt;&lt;p&gt;借助深度学习算法，通过个人输入的语音，然后通过算法生成完全模拟某个人的声音，而且由机器合成的语音连情绪都能够完美表达出来，基本可以以假乱真。&lt;/p&gt;&lt;p&gt;MockingBird已经登上Github热榜，收获3.5K的Star.&lt;/p&gt;&lt;p&gt;MockingBird具有如下特性：&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/G4umk62oPLpYia2ckKG1Iicofps1HD99Ba2I8uRGJ8rXkUAXa8FFxaP3xdhpbHmpu1wG6yZeOYRk7GFQGy4Nibiahg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;MockingBird开源项目地址&lt;sup&gt;[6]&lt;/sup&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Notion-avatar开源代码地址: https://github.com/Mayandev/notion-avatar&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;WxPusher微信推送服务: https://wxpusher.zjiecode.com/docs/#/&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;手机Push个人通知讨论实现: https://www.v2ex.com/t/529852&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Ch Deniel和弟弟的故事: https://www.simple.ink/blog/200-000-year-writing-order-messages&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;100天发布100篇文章挑战故事: https://www.indiehackers.com/post/on-publishing-100-articles-in-100-days-and-crossing-100k-arr-anne-laure-le-cunffs-story-f99d8130c9&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;MockingBird开源项目地址: https://github.com/babysor/MockingBird&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5OTM3NzAwNg==&amp;amp;mid=2649283222&amp;amp;idx=1&amp;amp;sn=0946d478eb9afeac75e0bdbef6df8949&amp;amp;chksm=bf201b9788579281980f390cac97fce54b349a03e4792ba0175e7aefd84c5e07505af4ecc314&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;（第 21 期）：辞职后做了3个产品，终于不用回去上班了&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5OTM3NzAwNg==&amp;amp;mid=2649283209&amp;amp;idx=1&amp;amp;sn=6f8863653b61f32fae5ffce1f4d60eca&amp;amp;chksm=bf201b888857929e6537475f47d3c742540e903247754cf24dbb9ad6366054f1a5bd423e8f62&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;（第 20 期）：和2个朋友做的产品以8位数美金的价格卖给了微软&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5OTM3NzAwNg==&amp;amp;mid=2649283080&amp;amp;idx=1&amp;amp;sn=e19b3a6d3951d1abd4a13ac54360b130&amp;amp;chksm=bf201b098857921fee8a38d135674b6aeaacc02ebd3bd88ceec8df48e41de7f00407495b173e&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Electron实战开发课程上线&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.52&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/G4umk62oPLreAJeFqhwhr5x2CVZkgNaIjhHdL2SZTB8x8677GL0gtaYrNM0Qia7ibAeBwheB9q01RURlChwR4GibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;加入知识星球，和我一起做自己产品的独立变现&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>