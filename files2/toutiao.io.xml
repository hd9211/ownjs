<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1e22e4414b07b7f0d29b33c0799106a1</guid>
<title>2022 年别再焦虑啦！加入我们！</title>
<link>https://toutiao.io/k/obimloc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e02057a2a3be14103e0a4c397f51565b</guid>
<title>基于Skywalking全链路行业解决方案</title>
<link>https://toutiao.io/k/qsiqiua</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h1 data-source-line=&quot;1&quot;&gt;1. 全链路监控行业介绍&lt;/h1&gt;&lt;h2 data-source-line=&quot;2&quot;&gt;1.1 全链路监控行业背景&lt;/h2&gt;&lt;pre data-source-line=&quot;3&quot;&gt;&lt;code class=&quot;hljs&quot;&gt;微服务架构盛行，服务拆分边界更加细粒度，完成一次完整的业务逻辑，需要调用不同的微服务，
微服务有可能是由不同的团队开发、可能使用不同的编程语言来实现、有可能布在了几千台服务器，
横跨多个不同的数据中心，因此，就需要一些可以帮助理解系统行为、用于分析性能问题的工具，
以便发生故障的时候，能够快速定位和解决问题。&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-source-line=&quot;7&quot;&gt;1.1.1 业务负责人快速check的关键点&lt;/h3&gt;&lt;ul data-source-line=&quot;8&quot; class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;如何快速发现问题？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;如何判断故障影响范围？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;如何梳理服务依赖以及依赖的合理性？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;如何分析链路性能问题以及实时容量规划？&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-source-line=&quot;12&quot;&gt;1.1.2 业务负责人目标可达性&lt;/h3&gt;&lt;ul data-source-line=&quot;13&quot; class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;请求链路追踪，故障快速定位，可以通过调用链结合业务日志快速定位错误信息&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;可视化，各个阶段耗时，进行性能分析&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;依赖优化，各个调用环节的可用性、梳理服务依赖关系以及优化&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;数据分析，优化链路，可以得到用户的行为路径，汇总分析应用在很多业务场景&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-source-line=&quot;17&quot;&gt;1.2 全链路监控目标&lt;/h2&gt;&lt;h2 data-source-line=&quot;22&quot;&gt;1.3 链路监控基本功能&lt;/h2&gt;&lt;ul data-source-line=&quot;23&quot; class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;埋点和生成日志&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;收集和存储日志&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;分析和统计调用链路数据，以及时效性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;UI展现及决策支持&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-source-line=&quot;27&quot;&gt;2. 全链路监控行业应用&lt;/h1&gt;&lt;pre data-source-line=&quot;28&quot;&gt;&lt;code class=&quot;hljs&quot;&gt;全链路监控理论模型基本都是依赖于Google Dapper论文&lt;/code&gt;&lt;/pre&gt;&lt;ul data-source-line=&quot;29&quot; class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;Zipkin：由Twitter公司开源，开放源代码分布式的跟踪系统，用于收集服务的定时数据，以解决微服务架构中的延迟问题，包括：数据的收集、存储、查找和展现。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;Pinpoint：一款对Java编写的大规模分布式系统的APM工具，由韩国人开源的分布式跟踪组件。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;Skywalking：国产的优秀APM组件，是一个对JAVA分布式应用程序集群的业务运行情况进行追踪、告警和分析的系统。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;Appdash：Appdash是Go的应用程序跟踪系统，基于Google的Dapper和Twitter的Zipkin&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;Lightstep：Lightstep全链路解决方案非常完整，整体解决方案和微服务架构生态完美的匹配，如果技术栈匹配，可以开箱即用，维护一个稳定的基线版本，Lightstep学习成本较高，可以复用Lightstep的架构思想，自研全链路框架。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;Jaeger支持语言：Java、Go、Node、Python和C++，Jaeger支持OpenTracing API及规范, Jaeger是Uber开源的全链路监控框架，解决方案的完整性的程度和Lightstep差不多，整体学习成本要低，提供了丰富的探针客户端。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-source-line=&quot;35&quot;&gt;3. SkyWalking实践产出和规划&lt;/h1&gt;&lt;h2 data-source-line=&quot;36&quot;&gt;3.1 实践体验&lt;/h2&gt;&lt;h2 data-source-line=&quot;41&quot;&gt;3.2 实践产出&lt;/h2&gt;&lt;h2 data-source-line=&quot;48&quot;&gt;3.3 功能规划&lt;/h2&gt;&lt;ul data-source-line=&quot;49&quot; class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 持续业务迭代&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;SLA全局应用排名&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;UI优化&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;智能大数据清洗平台（整合6.0版本新功能）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;业务全链路监控（基于业务定制）&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-source-line=&quot;54&quot;&gt;4. 问题答疑&lt;/h1&gt;&lt;h2 data-source-line=&quot;55&quot;&gt;4.1 如何解决链路异步问题&lt;/h2&gt;&lt;h2 data-source-line=&quot;57&quot;&gt;4.2 链路数据和拓扑不一致（官方技术解释）&lt;/h2&gt;&lt;h1 data-source-line=&quot;61&quot;&gt;5.SkyWalking架构细节&lt;/h1&gt;&lt;h2 data-source-line=&quot;62&quot;&gt;5.1 版本5.0.X&lt;/h2&gt;&lt;h3 data-source-line=&quot;63&quot;&gt;5.1.1 基本原则&lt;/h3&gt;&lt;p data-source-line=&quot;64&quot;&gt;SkyWalking架构的基本设计原则包括易于维护、可控和流式处理。 为了实现这些目标，SkyWalking后端采用以下设计。&lt;/p&gt;&lt;ul data-source-line=&quot;66&quot; class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;模块化设计。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;多种客户端连接方式。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;后端集群服务发现机制。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;流模式。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;可切换的存储模块。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-source-line=&quot;71&quot;&gt;5.1.2 模块化&lt;/h3&gt;&lt;p data-source-line=&quot;72&quot;&gt;SkyWalking后端基于纯模块化设计。用户可以根据自己的需求切换或组装后端功能。&lt;/p&gt;&lt;p data-source-line=&quot;74&quot;&gt;模块定义了一组特性，这些特性q可以包括技术库(如:gRPC/Jetty服务器管理)、跟踪分析(如:跟踪段或zipkin span解析器)或聚合特性。 这些完全由模块定义及其模块实现来决定。&lt;/p&gt;&lt;p data-source-line=&quot;76&quot;&gt;每个模块都可以在Java接口中定义它们的服务，每个模块的提供者都必须为这些服务提供实现者。 提供者应该基于自己的实现定义依赖模块。这意味着，即使两个不同的模块实现者，也可以依赖不同的模块。&lt;/p&gt;&lt;p data-source-line=&quot;78&quot;&gt;此外，后端模块化core还检查启动序列，如果没有发现周期依赖或依赖，后端应该被core终止。&lt;/p&gt;&lt;p data-source-line=&quot;80&quot;&gt;后端启动所有模块，这些模块的配置在application.yml中是分离的。在这个yaml文件中：根级别是模块名称，例如cluster、naming等。 第二级别是模块的实现者的名称，例如zookeeper是cluster等模块。第三级是实现者的具体属性。例如hostPort和sessionTimeout是zookepper的必需属性。&lt;/p&gt;&lt;h3 data-source-line=&quot;82&quot;&gt;5.1.2 多种连接方式&lt;/h3&gt;&lt;p data-source-line=&quot;83&quot;&gt;首先，后端提供两种类型的连接，也即提供两种协议（HTTP和gRPC）: HTTP中的命名服务，它返回后端群集中的所有可用collector地址。 在gRPC(SkyWalking原生探针的主要部分)和HTTP中使用上行链路服务，它将跟踪和度量数据上传到后端。 每个客户端将只向单个collector发送监视数据(跟踪和度量)。如果与连接的后端在某个时刻断开连接将会尝试连接其它的后端。比如在SkyWalking Java探针中collector.servers表示命名服务，将naming/jetty/ip:port映射为HTTP请求地址。collector.direct_servers表示直接设置上行服务，并使用gRPC发送监控数据。&lt;/p&gt;&lt;h3 data-source-line=&quot;86&quot;&gt;5.1.3 Collector 集群发现&lt;/h3&gt;&lt;p data-source-line=&quot;87&quot;&gt;当Collector以群集模式运行时，后端必须以某种方式相互发现。默认情况下，SkyWalking使用Zookeeper进行协调，并作为实例发现的注册中心。&lt;/p&gt;&lt;p data-source-line=&quot;89&quot;&gt;通过以上部分(多个连接方式)，客户端库将不会使用Zookeeper来查找集群。我们建议客户不要这么做。因为集群发现机制是可切换的，由模块化核心提供。依赖它会破坏可切换能力。 我们希望社区提供更多的实现者来进行集群发现，例如Eureka，Consul，Kubernate等。&lt;/p&gt;&lt;h3 data-source-line=&quot;90&quot;&gt;5.1.4 流模式&lt;/h3&gt;&lt;p data-source-line=&quot;91&quot;&gt;流模式类似轻量级storm/spark的实现，它允许使用API构建流处理图（DAG）以及每个节点的输入/输出数据协定。&lt;/p&gt;&lt;p data-source-line=&quot;93&quot;&gt;新模块可以查找和扩展现有的流程图。&lt;/p&gt;&lt;p data-source-line=&quot;95&quot;&gt;处理中有三种情况&lt;/p&gt;&lt;p data-source-line=&quot;97&quot;&gt;同步过程，传统方法调用。 异步过程，又叫做基于队列缓冲区的批处理。 远程过程，汇总后端的汇总。以这种方式，在节点中定义选择器以决定如何在集群中找到collector。（HashCode，Rolling，ForeverFirst是支持的三种方式） 通过具备的这些功能，collector集群像流式网络一样运行着去聚合、度量标准监控信息，并且不依赖于存储模块的实现来支持并发地编写相同的度量id。&lt;/p&gt;&lt;h3 data-source-line=&quot;101&quot;&gt;5.1.5 可切换存储实现器&lt;/h3&gt;&lt;p data-source-line=&quot;102&quot;&gt;由于流模式负责并发，因此存储模块的实现的职责是提供高速写入和组合查询。&lt;/p&gt;&lt;p data-source-line=&quot;104&quot;&gt;目前，我们支持ElasticSearch作为主要实现模块，H2用于预览版本，以及由Sharding Shpere项目管理的MySQL关系数据库集群。&lt;/p&gt;&lt;h3 data-source-line=&quot;105&quot;&gt;5.1.6 Web 界面&lt;/h3&gt;&lt;p data-source-line=&quot;106&quot;&gt;除了后端设计的原则，UI是SkyWalking的另一个核心组件。它基于React，Antd和Zuul代理实现，提供后端集群发现、查询调度和可视化的功能。&lt;/p&gt;&lt;p data-source-line=&quot;108&quot;&gt;Web UI以多连接方式中的相似的流程机制作为客户端的1.naming、2.uplink。唯一的区别是，在ui/jetty/yaml定义下的主机和端口上(默认值:localhost:12800)用HTTP绑定中的GraphQL查询协议替换上行。&lt;/p&gt;&lt;h2 data-source-line=&quot;109&quot;&gt;5.2 版本6.0.X&lt;/h2&gt;&lt;h3 data-source-line=&quot;110&quot;&gt;5.2.1 可观测性分析平台&lt;/h3&gt;&lt;p data-source-line=&quot;111&quot;&gt;OAP（可观察性分析平台）是一个新概念，从SkyWalking 6.x开始。 OAP取代旧的SkyWalking整个后端。该平台的功能如下。&lt;/p&gt;&lt;p data-source-line=&quot;113&quot;&gt;OAP功能 OAP接受来自更多来源的数据，这些来源属于两个组：跟踪和指标。&lt;/p&gt;&lt;ul data-source-line=&quot;116&quot; class=&quot; list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;跟踪 包括SkyWalking原生数据格式。 Zipkin v1，v2数据格式和Jaeger数据格式。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;指标 SkyWalking集成了Service Mesh平台，如Istio，Envoy，Linkerd，可通过数据面板或控制面板提供可观察性。此外，SkyWalking本机代理可以在公制模式下运行，从而大大提高了性能。 同时，通过使用提供的任何集成解决方案，例如SkyWalking日志插件或工具包，SkyWalking通过使用跟踪ID和跨度id为绑定跟踪和日志记录提供可视化集成。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-source-line=&quot;121&quot;&gt;像往常一样，gRPC和HTTP协议提供的所有服务使得不受支持的生态系统更容易集成。&lt;/p&gt;&lt;p data-source-line=&quot;125&quot;&gt;SkyWalking 5系列的传统方式。使用SkyWalking跟踪段和跨度格式格式化跟踪数据，甚至是Zipkin数据格式。 AOP分析段以获取度量，并将度量数据推送到流聚合中。 考虑仅跟踪某些类型的日志记录。只需为跟踪提供保存和可视化功能。 此外，SkyWalking接受来自其他项目的跟踪格式，例如Zipkin，Jeager，OpenCensus。这些格式也可以用两种方式处理。&lt;/p&gt;&lt;p data-source-line=&quot;132&quot;&gt;度量数据在流模式下在AOP集群内聚合。请参阅Observability Analysis Language，它提供了以脚本样式进行聚合和分析的简便方法。&lt;/p&gt;&lt;h3 data-source-line=&quot;133&quot;&gt;5.2.2 可观察性分析语言&lt;/h3&gt;&lt;p data-source-line=&quot;134&quot;&gt;提供OAL（可观察性分析语言）以分析流模式下的传入数据。OAL侧重于服务，服务实例和端点中的度量。因此，语言易于学习和使用。考虑到性能，读取和调试，OAL被定义为编译语言。 OAL scrips将在包阶段编译为普通Java代码。&lt;/p&gt;&lt;h3 data-source-line=&quot;135&quot;&gt;5.2.3 服务探针&lt;/h3&gt;&lt;p data-source-line=&quot;136&quot;&gt;在SkyWalking中，探测意味着集成到目标系统中的代理或SDK库，负责收集包括跟踪和度量的遥测数据。基于目标系统技术堆栈，探针可以使用非常不同的方法来实现。但最终它们是相同的，只需收集并重新格式化数据，然后发送到后端。&lt;/p&gt;&lt;p data-source-line=&quot;138&quot;&gt;在高级别中，所有SkyWalking探测器中都有三个典型组。&lt;/p&gt;&lt;p data-source-line=&quot;140&quot;&gt;基于语言的本地代理。这种代理在目标服务用户空间中运行，就像用户代码的一部分一样。如SkyWalking Java代理，使用-javaagent命令行参数在运行时操作代码，操作意味着更改并注入用户代码。另一种代理使用目标库提供的一些钩子或拦截机制。所以你可以看到，这些基于语言和库的代理。&lt;/p&gt;&lt;p data-source-line=&quot;142&quot;&gt;服务网格探测器。 ServiceMesh探针从服务网格或代理中的边车，控制面板收集数据。在过去，代理仅用作整个集群的入口，但是使用ServiceMesh和sidecar，现在我们可以基于此进行观察。&lt;/p&gt;&lt;p data-source-line=&quot;144&quot;&gt;第三方探针库。 SkyWalking接受其他链路数据格式。它分析数据，将其转换为跟踪，度量或两者的SkyWalking格式。此功能从接受Zipkin跨度数据开始。有关其他示踪剂的信息，请参阅Receiver以了解更多信&lt;/p&gt;&lt;p data-source-line=&quot;146&quot;&gt;您不需要同时使用基于语言的本机代理和ServiceMesh探针，因为它们都收集度量标准数据。因此，您的系统会遭受两倍的有效负载，并且分析数量会翻倍。&lt;/p&gt;&lt;p data-source-line=&quot;148&quot;&gt;使用这些探针有几种推荐方法： 仅使用基于语言的本机代理。 仅使用第三方探针库，如Zipkin探针生态系统。 仅使用Service Mesh探针。 在跟踪状态中使用Service Mesh探针与基于语言的本机代理或第三方仪器库。 （高级用法） 另外，举个例子，跟踪状态是什么意思？&lt;/p&gt;&lt;p data-source-line=&quot;155&quot;&gt;默认情况下，基于语言的本机代理和第三方探针库都会将分布式跟踪发送到后端，后端会对这些跟踪进行分析和聚合。在跟踪状态意味着，后端将这些跟踪视为日志，只保存它们，并构建跟踪和指标之间的链接，例如跟踪所属的端点和服务？&lt;/p&gt;&lt;p data-source-line=&quot;157&quot;&gt;接下来是什么？ 在Service auto instrument agent，Manual instrument SDK，Service Mesh probe和Zipkin receiver中学习SkyWalking支持的探针。 在了解了探针之后，请阅读后端概述以了解分析和持久性。&lt;/p&gt;&lt;h3 data-source-line=&quot;160&quot;&gt;5.2.4 服务自动探针代理&lt;/h3&gt;&lt;p data-source-line=&quot;161&quot;&gt;服务自动工具代理是基于语言的本机代理的子集。在这种代理中，它基于某些语言特定的功能，通常是基于VM的语言。&lt;/p&gt;&lt;p data-source-line=&quot;163&quot;&gt;Auto Instrument是什么意思？ 很多用户都知道这些代理人听到他们说不需要改变任何一行代码，SkyWalking过去常常把这些话放在我们的自述文件中。但实际上，这是对与错。对于最终用户，YES，他们不需要更改代码，至少在大多数情况下。但也是NO，代码仍然由代理更改，通常在运行时称为操作代码。基础上，它只是自动探针代理，包括有关如何通过VM接口更改代码的代码，例如通过javaagent premain在Java中更改类。&lt;/p&gt;&lt;p data-source-line=&quot;166&quot;&gt;此外，我们说大多数自动探针代理都是基于VM的，但实际上，您可以在编译时构建工具，而不是运行时。&lt;/p&gt;&lt;p data-source-line=&quot;168&quot;&gt;有什么限制？自动探针非常酷，您也可以在编译时创建它们，不依赖于VM功能，那么有没有限制？&lt;/p&gt;&lt;p data-source-line=&quot;170&quot;&gt;答案肯定是肯定的。它们是： 在大多数情况下可以进行过程传播。在许多高级语言中，它们用于构建业务系统，例如Java和.NET。大多数业务逻辑代码在每个请求的同一个线程中运行，这使得传播可以基于线程Id和堆栈模块以确保上下文是安全的。&lt;/p&gt;&lt;p data-source-line=&quot;173&quot;&gt;只是影响框架或库。由于代理更改代码，这也意味着代理插件开发人员已经知道代码。因此，这种探测器中始终存在受支持的列表。像SkyWalking Java代理支持的列表。&lt;/p&gt;&lt;p data-source-line=&quot;175&quot;&gt;跨线程不能一直支持。就像我们在流程传播中所说的那样，大多数代码在每个请求的单个线程中运行，尤其是业务代码。但在其他一些场景中，他们在不同的线程中执行操作，例如作业分配，任务池或批处理。或者某些语言提供协同程序或类似的东西，如Goroutine，然后开发人员可以运行低负载的异步过程，甚至鼓励。在这些情况下，仪表大盘将面临问题。&lt;/p&gt;&lt;p data-source-line=&quot;177&quot;&gt;因此，对于汽车仪表来说，没有什么神秘之处，简而言之，代理开发人员会编写激活程序来使仪器代码工作。就这些。&lt;/p&gt;&lt;p data-source-line=&quot;179&quot;&gt;接下来是什么？ 如果您想了解SkyWalking中的手动仪器库，请参阅手动仪器SDK部分&lt;/p&gt;&lt;h1 data-source-line=&quot;181&quot;&gt;6.全链路基础&lt;/h1&gt;&lt;p data-source-line=&quot;182&quot;&gt;理论基础&lt;/p&gt;&lt;h2 data-source-line=&quot;183&quot;&gt;6.1 OpenTracing规范&lt;/h2&gt;&lt;p data-source-line=&quot;184&quot;&gt;核心概念 trace和traceId：trace是全局监控系统的一次跟踪（用traceId标示一次跟踪，贯穿整个跨进程请求），多个span信息，及其关系信息。&lt;/p&gt;&lt;p data-source-line=&quot;187&quot;&gt;span：一个span代表系统中具有开始时间和执行时长的逻辑运行单元。span之间通过嵌套或者顺序排列建立逻辑因果关系，包含logs和tags。&lt;/p&gt;&lt;p data-source-line=&quot;189&quot;&gt;Logs：每个span可以进行多次Logs操作，每一次Logs操作，都需要一个带时间戳的时间名称，以及可选的任意大小的存储结构。&lt;/p&gt;&lt;p data-source-line=&quot;191&quot;&gt;tags: 每个span可以有多个键值对（key:value）形式的Tags，Tags是没有时间戳的，支持简单的对span进行注解和补充，在一个span的生命周期有效不能跨越span传递。&lt;/p&gt;&lt;p data-source-line=&quot;193&quot;&gt;SpanContext: SpanContext跨越进程边界，传递到下级span的状态。(例如，包含trace_id, span_id, sampled、baggage等数据)，并用于封装Baggage.&lt;/p&gt;&lt;p data-source-line=&quot;195&quot;&gt;Baggage: 存储在SpanContext中的一个键值对集合，在整个trace链路生命周期有效，可以跨越span、跨越进程进行传递.&lt;/p&gt;&lt;p data-source-line=&quot;197&quot;&gt;ActiveSpan: 当前线程的活跃Span，对Span做了封装，也可以理解为一个Span的指针.&lt;/p&gt;&lt;p data-source-line=&quot;199&quot;&gt;inject: SpanContext要做跨进程（如RPC）传输的时候,把SpanContext中的数据序列化到传输协议中。&lt;/p&gt;&lt;p data-source-line=&quot;201&quot;&gt;extract: 与inject对应，从传输协议里，抽取数据反序列化成SpanContext。&lt;/p&gt;&lt;hr/&gt;&lt;p data-source-line=&quot;201&quot;&gt;&lt;span&gt;往期文章链接&lt;/span&gt;&lt;/p&gt;&lt;p data-source-line=&quot;201&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1ODAyNQ==&amp;amp;mid=2247483719&amp;amp;idx=1&amp;amp;sn=34fdd8760a95d2e89dca5cbdc3aa4ad6&amp;amp;chksm=fc333b81cb44b29722e9730b46ea0e5892f67f64e617b0d8822a420b1b5f128bfded73a4fbd7&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;基础能力框架演进&lt;/a&gt;&lt;/p&gt;&lt;p data-source-line=&quot;201&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1ODAyNQ==&amp;amp;mid=2247483706&amp;amp;idx=1&amp;amp;sn=4cd0e51fc5f5d62f83f68fc412860520&amp;amp;chksm=fc333bfccb44b2ea9be7cd109fa4fb8e619d43cd99fbfd3ef5e541796fdb22caa897f9676094&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;冗余和故障转移&lt;/a&gt;&lt;/p&gt;&lt;p data-source-line=&quot;201&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1ODAyNQ==&amp;amp;mid=2247483702&amp;amp;idx=1&amp;amp;sn=058a34ce9b7b2c898cfca74cefbbe48b&amp;amp;chksm=fc333bf0cb44b2e69b9d4ad3667062a112190fdae908a31ee04eb7ba7f0bbb59131f397c37d3&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;全链路监控系统整合业务系统如何高可用&lt;/a&gt;&lt;/p&gt;&lt;p data-source-line=&quot;201&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1ODAyNQ==&amp;amp;mid=2247483699&amp;amp;idx=1&amp;amp;sn=46894d86d0793f97d6a23d1239de01b7&amp;amp;chksm=fc333bf5cb44b2e3d5dd2bcf3c922c974b997d5c0735944ced4383469c9bf414e9ab7b115a33&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;分布式架构-SpringCloud如何实现CAP&lt;/a&gt;&lt;/p&gt;&lt;p data-source-line=&quot;201&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1ODAyNQ==&amp;amp;mid=2247483696&amp;amp;idx=1&amp;amp;sn=02c47beeb969be674ad87da5c898a7c5&amp;amp;chksm=fc333bf6cb44b2e056ec76489d55a0e92af09ff0675c0ff4d1b8a602772cd821c338fdf3804f&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;高并发系统设计-redis技术梳理&lt;/a&gt;&lt;/p&gt;&lt;p data-source-line=&quot;201&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1ODAyNQ==&amp;amp;mid=2247483689&amp;amp;idx=1&amp;amp;sn=3e23913ba557e2933fa1bc2976954c20&amp;amp;chksm=fc333befcb44b2f96e885cd89e0d63022c0ce96f054f8e51cbf5c10dd8af883e93bff1113f59&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;基于RocketMq的事务消息设计&lt;/a&gt;&lt;/p&gt;&lt;p data-source-line=&quot;201&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1ODAyNQ==&amp;amp;mid=2247483672&amp;amp;idx=1&amp;amp;sn=b69bb42d7a879006b18f3282d9fd3aa2&amp;amp;chksm=fc333bdecb44b2c82a312d2799df56f03e696e0f86d8c2aa8715ae5abec68ce0c123031c912d&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;Dubbo核心架构&lt;/a&gt;&lt;/p&gt;&lt;p data-source-line=&quot;201&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1ODAyNQ==&amp;amp;mid=2247483682&amp;amp;idx=1&amp;amp;sn=ad23b82cf590e6c09e45a7009c0df371&amp;amp;chksm=fc333be4cb44b2f201e8226d5d711ef10a03d815a4e7baf4075fb4fd5a7462fd686dad6b5201&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;RocketMq消息中间件及分布式事务消息实现原理&lt;/a&gt;&lt;/p&gt;&lt;p data-source-line=&quot;201&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1ODAyNQ==&amp;amp;mid=2247483665&amp;amp;idx=1&amp;amp;sn=4dd158bd82ce1627f62d5433ddd1f053&amp;amp;chksm=fc333bd7cb44b2c18e48b4be6d42387b8cc71f59495291c09caf05f1b518eaa11d7df198de6a&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;微服务架构-SpringBoot2.0.3源码之web容器篇(二)&lt;/a&gt;&lt;/p&gt;&lt;p data-source-line=&quot;201&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1ODAyNQ==&amp;amp;mid=2247483657&amp;amp;idx=1&amp;amp;sn=dd7df195b64fc9d9af98614883750451&amp;amp;chksm=fc333bcfcb44b2d9cd1d99a36c38ea3bf1a7aa5287fe44a11ceefc6579dd458b888226f15ff0&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;微服务架构-SpringBoot2.0.3源码之web容器篇(一)&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nuXs4mvp08DaUkh7YpMDmTQVyTqffia8K8L2Q1HVjM33YVAeXhqLibshjhRZ6WPmpQksfSe55Zc7WBkZJQzmqT1g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cbe319a0f9a2d8d5559d03d770ee8758</guid>
<title>贝壳 Go 实现的 IM 群聊优化之路</title>
<link>https://toutiao.io/k/pgjxjvc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;介绍&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;贝壳IM为贝壳找房提供了70%以上的线上商机。为上百万的经纪人提供了快捷的线上获客渠道。日新增会话300万+。其既有互联网TO C产品的属性，又具有浓厚的房地产行业特色，是贝壳找房所属的产业互联网中重要的一环。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;IM系统相比其他服务有其特殊的特点，主要包括实时性、有序性、可靠性（不重复不丢失）、一致性（多端漫游同步）、安全性。为保证这些特性的实现，良好的性能是必不可少的。本文主要阐述了针对贝壳IM单聊群聊消息的优化思路，通过压测、寻找瓶颈点、提出优化方案、验证优化方案、代码实现的多轮次迭代，最终实现了20倍以上的性能提升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2020年底的时候有业务方提出使用群聊消息进行推广活动，该场景预估300人大群需要满足100QPS的性能要求。接到需求，我们首先对群聊场景进行了摸底压测，效果为300人大群QPS为15的时候系统内消息处理就会出现积压,投递能力到达瓶颈。因此拉开了优化的序幕。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;IM系统整体概览&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们首先简要介绍下贝壳IM的整体架构，一是便于理解IM消息服务难在哪，二是便于看出IM消息服务的瓶颈点在哪。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3953704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Rcon9f6LyEuCPTpS9RQldrA0CXJge104OFrfqcTEd7zt1c58vzsAvJZ0qZtCjaH0SWLLEUHfwLTmw5HKiaY7kBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;上图是IM消息发送的整体流程：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;发送者通过http接口发送消息，接口处理完成写入发送队列后返回给用户成功信息。此时后台的投递服务实时从队列获取待投递消息，然后进行如下四步操作：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;写入用户的收件箱&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;写入持久化的历史消息库&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通过长连接服务通知接收者拉取消息&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通过PUSH服务通知接收者有消息到达&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;通过贝壳IM架构，可以看到消息发送到消息送达整体是一个异步服务，分为两个部分，一是接口层，二是投递服务，两者之间通过队列通信。接口层只需要写入队列即返回成功，无状态可以横向扩展，不会成为群聊的瓶颈。投递服务功能复杂并且会直接影响消息处理的及时性、可靠性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;了解过IM的同学可能会问，是否可以将写扩散模式更改为读扩散，即300人大群中发送一条消息之后，不再写入每个人的收件箱，而是只记录到一个发件箱中，读取的时候每个人去发件箱中读取。读扩散方式下，假设一个人加入了100个群，那么读取时需要将100个群的发件箱都读取一遍，而之前的写扩散模式，只需要在收件箱中按序列号读取一次即可。两者各有优劣势，通过调研发现云厂商以及微信服务群聊均是在写扩散模式下实现，证明写扩散可行，并且对贝壳IM来说，继续使用写扩散成本可控。因此在整体架构不变的情形下我们进行了一系列优化，最终也达到了预期效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;优化措施一: 业务隔离&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;IM的消息按照业务属性主要分为三种:&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;单聊消息，即双人聊天会话，包括C2B和B2B，涉及商机获取，最核心的功能&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;群聊消息，即多人聊天会话， 特点是参与人数多，涉及活动推广及消息通知&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;公众号消息，即各种业务公众号群发消息，推送量大，已经做了隔离，并且历史消息库使用TiDB&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;消息投递服务负责从redis队列消费用户发送的消息，进行处理。举个例子, A/B/C三人在同一会话中, A向会话中发送一条消息, 投递服务需要保证这条消息被写入A/B/C三人各自的收件箱和历史消息库, 并通过(push/长连接)通知A/B/C。第一次摸底压测出现redis队列积压，会导致用户不能及时收到消息，这个是不可接受的。在业务侧，针对我们公司的业务场景特点，最重要的是客户和经纪人的单聊消息。从业务隔离角度考量，进行的第一个优化措施，是对单聊和群聊进行垂直拆分，分级隔离后的效果图如下:&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9790698&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Rcon9f6LyEuCPTpS9RQldrA0CXJge104Dyhr0fjmhF1BupZ542cfaiagfob9ibqqBczIB8n2KBibmdJWq9xaNCosw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;430&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;优化措施二: 提高并发&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们继续深入投递服务的细节，看看投递服务的代码实现逻辑。总体来看，投递服务消费一条消息后，会经历两个阶段，每个阶段分别由对应的goroutine来完成, 阶段一有256个goroutine, 阶段二 有1000个goroutine，两个处理流程之间通过channel进行通信。两阶段的流程图如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4311377&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Rcon9f6LyEuCPTpS9RQldrA0CXJge104LY1M9xc2PO2fsrDBnUD9tqn81fBuNJAE72iaVaXDAYFLJGXd25N5Zcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;835&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;还是以一个300人的群GroupA为例，假设发送者 SenderA发送了一个消息，阶段一获取到的消息是会话维度，即GroupA（会话ID标识）的SenderA（UCID标识）发送了一条内容为xxx的消息，阶段一的主要工作是根据会话ID获取到群内的所有成员UCID，然后将UCID哈希之后打散放到1000个channel中，此时channel中的消息是用户维度，即用户ReceiveB收到了一条内容为xxx的消息。注意阶段一此时还进行了一个扩散操作，即将每个收件人的未读数计数进行了更新操作。阶段二从channel中获取消息之后将其放入群内300个成员各自的收件箱，然后给每个人发送push以及长连接信息，通知收件人拉取消息。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;可以看到阶段一是会话消息维度的处理，IO操作较少，写扩散主要有两步，一是进行一个内存channel的写入，二是以收件人维度进行了未读数的更新。阶段二是收件人维度的消息处理，并发度更大（1000个goroutine)，IO操作也较多，例如写入收件人收件箱，更新会话顺序，向每个收件人都发送push通知和长连接通知。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;优化措施&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;压测时观察到只有发送Redis队列有积压，channel队列没有积压，并且阶段二并发能力更强，考虑将阶段一中比较耗时的更新用户未读数操作放在在阶段二进行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;效果&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过将更新用户未读数放到阶段二，其实相当于增大了处理未读数的并发能力，上线后进行压测，数据为300人群，群聊消息发送可以达到75QPS，有5倍的性能提升。当300人大群发送QPS达到70时，Redis侧QPS为21000，此时IM中使用的一组缓存redis cpu被打满，单核使用率达到92%（注意redis6.0版本之前只能使用单核，因此单核cpu使用率是redis一个很重要的观察维度）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;优化措施三: 减少计算&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;进行第二项优化后，300人的群聊可以达到75QPS，此时一组缓存的redis实例cpu基本被打满。该组redis主要负责存储用户关系, 在投递服务阶段二发送push的业务逻辑中会大量使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;问题&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以投递一条消息到300人的大群为例，假设群为GroupA，发送者 SenderA发送了一个消息，阶段二中给每个收件人发送push的业务逻辑中存在重复获取数据的情况，例如：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;SenderA的用户信息：会针对群内每个成员获取一次，即获取了300次SenderA的用户信息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;GroupA的会话信息：会针对群内每个成员获取一次，即获取了300次会话信息。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;用户是否设置了免打扰：会针对群内每个成员获取一次，即获取了300次免打扰设置。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;p&gt;&lt;/p&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;由于群聊是从单聊代码改造而来，可以看到简单重复单聊的逻辑，会造成写扩散的放大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;优化措施&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对重复获取数据，进行相应的优化措施，SenderA的用户信息和GroupA的会话信息可以提前获取一次，发送push时直接使用。用户是否设置了免打扰，原来是从用户到群组的映射关系，通过增加一个群组到用户的反向映射关系，可以通过一个群组直接获取到全部设置了免打扰的用户，减少计算量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;效果&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过合并业务数据，相当于减少了业务处理的计算量，该改进上线后进行压测，300人群, 发消息150QPS，对比优化二有了2倍的性能提升，对比初始值有10倍的性能提升。此时写入信箱QPS可以达到45k。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此时，IM使用的另一组Redis出现了告警，单核CPU使用率超出90%，并且有大量redis慢查和超时报警。通过监控发现，CPU被打满时，redis每秒建连数达到8k/s, 总连接数增长至20k，QPS为45k，通过和DBA同学沟通，这种情况下redis有一大部分cpu都被消耗在连接的建立与销毁。奇怪的是IM中使用了Redis连接池，为什么还会有大量的新建连接呢？Redis的极限QPS能够达到多少？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;优化措施四: Redis连接池优化&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;排查过程&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;贝壳IM中redis库是使用连接池，目的就是为了避免新建销毁连接带来的消耗。目前使用的redis库比较老，结合之前线上存在偶发的redis慢查报错，首先怀疑是连接池的实现问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;验证&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了方便在测试环境模拟复现redis大量建连问题，开发了一个模拟投递程序可以指定发消息qps和参与会话人数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下是im使用的redis库（简写为imredis）与业界比较成熟的goredis库数据对比&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.812963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Rcon9f6LyEuCPTpS9RQldrA0CXJge104L0f3fXULPeUicYicnB3DH5DFQFMKwJZHHzicz4ztQ61llQT82ggCEu7Ng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过测试数据发现如下三点：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在发送端qps相同的情况下，如果没有大量的新建连接，则redis CPU使用率会大幅下降&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;发送端qps到达120时，使用goredis，此时CPU使用率93%，接近打满，redis qps 144k。（注意此处的模拟程序只使用了一个redis实例。IM线上服务首先按功能分组，每组Redis一般是4个实例起步。分组和分实例的逻辑都在imredis代码中实现）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通过模拟测试，可以证明imredis库连接池实现确实有问题，并且验证出redis在我们的场景下极限QPS可以达到140k。因此通过改造连接池，可以达到优化效果。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;连接池缺陷&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;// Get retrieves an available redis client. If there are none available it will  &lt;/span&gt;&lt;br/&gt;&lt;span&gt;// create a new one on the fly  &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(p *Pool)&lt;/span&gt; &lt;span&gt;Get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;(*redis.Client, error)&lt;/span&gt;&lt;/span&gt; {    &lt;br/&gt;  &lt;span&gt;select&lt;/span&gt; {    &lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; conn := &amp;lt;-p.pool:      &lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; conn, &lt;span&gt;nil&lt;/span&gt;    &lt;br/&gt;    &lt;span&gt;default&lt;/span&gt;:      &lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; p.df(p.Network, p.Addr, p.Auth, p.Db, p.Timeout)    &lt;br/&gt;  }  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过查看imredis连接池代码，发现虽然初始化时会指定最大连接数量，但当QPS升高并且接池中获取不到连接时，会新建连接进行处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;优化措施&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考goredis和其他连接池实现, 采取以下优化措施:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;备用连接池。大小是默认连接池的10倍，如果默认连接池满了， 连接会暂时存放在备用连接池，每过固定时间对备用连接池内的连接进行释放。避免在大量并发时频繁新建和关闭连接。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对新建连接通过令牌桶进行限制，避免短时间内无限制大量建立连接，导致拖垮服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最终效果&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;压测验证300人大群可以达到320qps左右。投递能力较优化三有两倍的性能提升，较去年年底有20倍的性能提升&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;群聊300人大群达到320qps，已经能够满足未来两年内的业务需求。并且随着群聊的优化，尤其是Redis连接池的优化，单聊的性能也有了显著提升，从年初的2000达到了12000。未来如果有继续提高性能的需求，只需要对redis进行双倍扩容，并且将投递服务也进行扩容即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过本次优化，可以看到，大部分的性能优化只需要进行代码层面的改造，通过压测找到瓶颈点，摸清整个链路的短板并改造这个短板。此时QPS就只是一个数值。需要更高的QPS时只需要扩容、扩容、再扩容即可。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span&gt;&lt;strong&gt;福利&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-darkmode-bgcolor-15906318746582=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15906318746582=&quot;rgb(255, 255, 255)&quot; data-style=&quot;width: 30px; height: 30px; background-color: rgb(255, 255, 255); box-shadow: rgb(87, 187, 255) -7px -7px 0px; margin-left: 7px;&quot;&gt;&lt;span/&gt;&lt;span&gt;我为大家整理了一份&lt;/span&gt;&lt;span&gt;从入门到进阶的Go学习资料礼包&lt;/span&gt;&lt;span&gt;，包含学习建议：入门看什么，进阶看什么。&lt;/span&gt;&lt;span&gt;关注公众号 「polarisxu」，回复 &lt;/span&gt;&lt;strong&gt;&lt;span&gt;ebook&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 获取；还可以回复「&lt;strong&gt;进群&lt;/strong&gt;」，和数万 Gopher 交流学习。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UWba2ryLMqm8cgtrMXjG1BLGg46vQNmUompBL02uYYwic9RicPbCnlKdZiacBF5Wv6RLgmGIqnBnwuWyP82ibYusiag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>33371ba103bc387c139e44cd7486d8b6</guid>
<title>一种比线段树还高效的区间算法</title>
<link>https://toutiao.io/k/g1apymz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7b010136c37bf5c3e8591841f4bcefe8</guid>
<title>从头到尾再讲一遍ThreadLocal</title>
<link>https://toutiao.io/k/2vpircg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2 data-tool=&quot;mdnice编辑器&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;引言&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;其实网上有很多关于ThreadLocal的文章了，有不少文章也已经写&lt;/span&gt;&lt;span&gt;得&lt;span&gt;非常好了。但是很多同学反映还有一些部分没有讲解的十分清楚，总觉得有一些疑惑没有理解的十分清楚。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此本文主要结合常见的一些疑问、ThreadLocal源码、应用实例以注意事项来全面而深入地再详细讲解一遍ThreadLocal。希望大家看完本文后可以彻底掌握ThreadLocal。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ThreadLocal是什么？它能干什么&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;在阐述ThreadLocal之前，我们先来看下它的设计者是怎么描述ThreadLocal的吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.45037220843672454&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NwjSqraNTGnNYPV2JqRic125P7Kt81YjaMVsCQXfiajPwmLnNvHQibnHqaXibHQecHmlqxzSWqQCFbfnTtnzZzOw2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;806&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;看完官方的描述后，结合自己的理解，ThreadLocal提供了一种对应独立线程内的数据访问机制，实现了变量在线程之间隔离，在线程生命周期内独立获取或者设置的能力。如果我们想在线程内传递参数但是有不想作为方法参数的时候，ThreadLocal就可以&lt;/span&gt;&lt;span&gt;派&lt;span&gt;上用场了。不过值得注意的是ThreadLocal并不会解决变量共享问题。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际上从ThreadLocal的名称上面来看，线程本地变量也已经大致说明了它的作用，所以变量的命名还是非常重要的，要做到顾名思义。如果觉得还不是很理解，没关系，我们可以通过以下的场景再加深下理解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假如有以下的场景，假设只有一个数据库连接，客户端1、2、3都需要获取数据库连接来进行具体的数据库操作，但是同一时间点只能有一个线程获取连接，其他线程只能等待。因此就会出现数据库访问效率不高的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.428087986463621&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NwjSqraNTGnNYPV2JqRic125P7Kt81Yja97qBFvJIfHmYeElLpDtvHotABzkQleHxheksdXHKlxxKck0sPWibfhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;591&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;那我们有没有什么办法能够避免线程等待的情况呢？上述问题的根本原因是数据库连接是共享变量，同&lt;/span&gt;&lt;span&gt;时&lt;span&gt;只能有一个线程可以进行操作。那如果三个线程都有自己的数据库连接，互相隔离，那不就不会出现等待的问题了嘛。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;那么此时我&lt;/span&gt;们&lt;span&gt;可以使用ThreadLocal实现在不同线程中的变量隔离。可以看出来，ThreadLocal是一种&lt;/span&gt;以&lt;span&gt;空间换取时间的做法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4009216589861751&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NwjSqraNTGnNYPV2JqRic125P7Kt81YjaXQZuAuN3LVicoD14z5mVy3yUUaQVFg5mV1SQH6icPtmorkUuqR6nuFbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;651&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ThreadLocal实现线程隔离的秘密&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;从上文中，我们了解到ThreadLocal可以实现变量访问的线程级别的隔离。那么它是到底如何实现的呢？这还需要结合Thread以及ThreadLocal的源码来分析才能揭开ThreadLocal实现线程隔离的神秘面纱。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    ...&lt;br/&gt;    &lt;span&gt;/* ThreadLocal values pertaining to this thread. This map is maintained&lt;br/&gt;     * by the ThreadLocal class. */&lt;/span&gt;&lt;br/&gt;    ThreadLocal.ThreadLocalMap threadLocals = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    ...&lt;br/&gt;    &lt;br/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Thread源码中我们发现，它有一个threadLocals变量，它的类型是ThreadLocal中的内部类ThreadLocalMap。我们再看下ThreadLocalMap的定义是怎样的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从源码中我们可以看出来，ThreadLocalMap实际上就是Entry数组，这个Entry对应的key实际就是ThreadLocal的实例，value就是实际的变量值。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocal&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;    &lt;br/&gt;   &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalMap&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;     &lt;br/&gt;      &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Entry&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;WeakReference&lt;/span&gt;&amp;lt;&lt;span&gt;ThreadLocal&lt;/span&gt;&amp;lt;?&amp;gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;/** The value associated with this ThreadLocal. */&lt;/span&gt;&lt;br/&gt;            Object value;&lt;br/&gt;&lt;br/&gt;            Entry(ThreadLocal&amp;lt;?&amp;gt; k, Object v) {&lt;br/&gt;                &lt;span&gt;super&lt;/span&gt;(k);&lt;br/&gt;                value = v;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;       ...&lt;br/&gt;       &lt;span&gt;//底层数据结构是数组&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;private&lt;/span&gt; Entry[] table;&lt;br/&gt;       ...&lt;br/&gt;     &lt;br/&gt;   }&lt;br/&gt;  ...&lt;br/&gt;  &lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过查看上述的源码，如果还不太好理解的话，我们再结合下现实中的例子来理解。大家都有支付宝账户，我们通过它来管理着我们的银行卡、余额、花呗这些金融服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8080808080808081&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NwjSqraNTGnNYPV2JqRic125P7Kt81YjadfDBQcUxOIIdJLg38YxiaDeNibMjkezDfnuhYTfOJ4zSEdOOhU9clshw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;693&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们以支付宝以及支付宝账户进行类比，假设ThreadLocal就是支付宝，每个支付宝账户实际就是单独的线程，而账户中的余额属性就相当于Thread的私有属性ThreadLocalMap。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们在日常生活中，进行账户余额的充值或者消费，并不是直接通过账户进行操作的，而是借助于支付宝进行维护的。这就相当于每个线程对ThreadLocalMap进行操作的时候也不是直接操作的，而是借助于ThreadLocal来操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8839285714285714&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NwjSqraNTGnNYPV2JqRic125P7Kt81Yjazf9FrptPibA6G1uGf1XBumpztEH6ETcp8dn8doz2YVg4JRzpJ7rBaFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;672&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么Thread到底是怎么借助ThreadLocal进行私有属性管理的呢？还是需要进一步查看Thread进行set以及get操作的源码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从以下的ThreadLocal的源码中我们可以看出，在进行操作之前，需要获取当前的执行操作的线程，再根据线程或者线程中私有的ThreadLocalMap属性来进行操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6657608695652174&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NwjSqraNTGnNYPV2JqRic125P7Kt81Yjadqhsw2n35Rxb48dVZePSH364VzYDSTO2qXeAoJAhuQQjzt3v7mOq4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;736&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在进行数据获取的时候，也是按照同样的流程，先获取当前的线程，再获取线程中对应的ThreadLocalMap属性来进行后续的值的获取。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6464237516869096&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NwjSqraNTGnNYPV2JqRic125P7Kt81YjafmGODQeyvop28TVjhdbG8eZviaCiaJFdCEZOVpaMma3cytYOgKDXa2hg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;741&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过上述的源码的分析，我们可以得出这样的结论，ThreadLocal之所以可以实现变量的线程隔离访问，实际上就是借助于Thread中的ThreadLocalMap属性来进行操作。由于都是操作线程本身的属性，因此并不会影响其他线程中的变量值，因此可以实现线程级别的数据修改隔离。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5363276089828269&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NwjSqraNTGnNYPV2JqRic125P7Kt81Yjaqd5DfaIwjMm5jQ6UibbLWB8MuclkPF4XtF9LpiaHPibpwMQEbEoq8aFKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;757&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么会出现OOM？&lt;/span&gt;&lt;/h2&gt;&lt;h3&gt;&lt;span&gt;内存泄漏演示&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;我们都知道，ThreadLocal如果使用不当的话会出现内存泄漏的问题，那么我们就通过下面的这段代码来分析下，内存泄漏的原因到底是什么。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; mufeng&lt;br/&gt; * &lt;span&gt;@description&lt;/span&gt; 测试ThreadLocal内存溢出&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2022/1/16 19:01&lt;br/&gt; * &lt;span&gt;@since&lt;/span&gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThreadLocalOOM&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 测试线程池&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Executor threadPool = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;40&lt;/span&gt;,&lt;br/&gt;            TimeUnit.SECONDS, &lt;span&gt;new&lt;/span&gt; LinkedBlockingDeque&amp;lt;&amp;gt;());&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Info&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] info = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;10&lt;/span&gt; * &lt;span&gt;1024&lt;/span&gt; * &lt;span&gt;1024&lt;/span&gt;];&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt;  &lt;span&gt;static&lt;/span&gt; ThreadLocal&amp;lt;Info&amp;gt; infoThreadLocal = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++) {&lt;br/&gt;            threadPool.execute(() -&amp;gt; {&lt;br/&gt;                infoThreadLocal.set(&lt;span&gt;new&lt;/span&gt; Info());&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;Thread started:&quot;&lt;/span&gt; + Thread.currentThread().getName());&lt;br/&gt;            });&lt;br/&gt;            Thread.sleep(&lt;span&gt;100&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;手动进行GC之后，我们可以发现堆中仍然有超过30M的堆内存占用，如上面的代码，在线程池中活跃的线程会有三个，对应的value为10M，说明在线程还存活的情况下，对应的value并没有被回收，因此存在内存泄漏的情况，如果存在大量线程的情况，就会出现OOM。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5474006116207951&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NwjSqraNTGnNYPV2JqRic125P7Kt81Yjad9zHiceoorPhMJzpNlx1t9RicytqnblQ7L2aic3T2L1vygMr5hxFYLAqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;654&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当我们修改代码在线程中进行remove操作，手动GC之后我们发现堆内存趋近于0了，之前没有被回收的对象已经被回收了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4907692307692308&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NwjSqraNTGnNYPV2JqRic125P7Kt81Yjarc8pzeCASTz820FiauXIF2Gzl5h9WdYJlUsjwwML2FdZUAWwic30MicFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;650&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;内存泄漏问题分析&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上是对于ThreadLocal发生内存泄漏问题的演示，那么再来仔细分析下背后的原因是什么。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ThreadLocal中实际存储数据的是ThreadLocalMap，实际上Map对应的key是一个虚引用，在GC的时候可以被回收掉，但是问题就在于key所对应的value，它是强引用，只要线程存活，那么这条引用链就会一致存在，如果出现大量线程的时候就会有OOM的风险。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以在使用ThreadLocal的时候一定记得要显式的调用remove方法进行清理，防止内存泄漏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.48005502063273725&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NwjSqraNTGnNYPV2JqRic125P7Kt81YjaEjGibnbj8tibvEhv2ZxYFOicMa0Bnq6ibUziaALmFBHfObXJqzbywrh193w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;727&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;父子线程的参数传递&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;到这里，我相信大家对于ThreadLocal的原理有了比较深入的理解了。结合上文中的ThreadLocal代码，不知道大家有没有思考过一个问题，我们在使用ThreadLocal的时候都是在同一个线程内进行了set以及get操作，那么如果set操作与get操作在父子线程中是否还可以正常地获取呢？带着这样的疑问，我们来看下如下的代码。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; mufeng&lt;br/&gt; * &lt;span&gt;@description&lt;/span&gt; 父子线程参数传递&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2022/1/16 9:54&lt;br/&gt; * &lt;span&gt;@since&lt;/span&gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;InheritableThreadLocalMain&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;String&amp;gt; count = &lt;span&gt;new&lt;/span&gt; ThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        count.set(&lt;span&gt;&quot;父子线程参数传递！！！&quot;&lt;/span&gt;);&lt;br/&gt;        System.out.println(Thread.currentThread().getName() + &lt;span&gt;&quot;:&quot;&lt;/span&gt; + count.get());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;            System.out.println(Thread.currentThread().getName() + &lt;span&gt;&quot;:&quot;&lt;/span&gt; + count.get());&lt;br/&gt;        }).start();&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与之前代码有所不同，ThreadLocal的设值是在main线程中进行的，但是获取操作实际是在主线程下的子线程中进行的，大家可以分析一下运行结果是怎么样的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3541666666666667&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NwjSqraNTGnNYPV2JqRic125P7Kt81Yja6mWCL6xicCU7iarL8MBvFJWhWvIk4ficvgz73n0Op53sVQ29albmYHu4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;336&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看到这个运行结果，不知道大家分析地对不对呢。实际上如果理解了上文的核心的话，这个问题应该很好分析的。ThreadLocal获取数据的时候，首先是需要获取当前的线程的，根据线程获取实际存储数据的ThreadLocalMap，上文代码中设置和获取在父子线程中进行，那肯定是获取不到设置的数据的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是在现实的项目开发中，我们会经常遇到需要将父线程的变量值传递给子线程进行处理，那么应该要怎么来实现呢？这个时候InheritableThreadLocal就派上用场了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@author&lt;/span&gt; mufeng&lt;br/&gt; * &lt;span&gt;@description&lt;/span&gt; 父子线程参数传递&lt;br/&gt; * &lt;span&gt;@date&lt;/span&gt; 2022/1/16 9:54&lt;br/&gt; * &lt;span&gt;@since&lt;/span&gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;InheritableThreadLocalMain&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;String&amp;gt; count = &lt;span&gt;new&lt;/span&gt; InheritableThreadLocal&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        count.set(&lt;span&gt;&quot;父子线程参数传递！！！&quot;&lt;/span&gt;);&lt;br/&gt;        System.out.println(Thread.currentThread().getName() + &lt;span&gt;&quot;:&quot;&lt;/span&gt; + count.get());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;            System.out.println(Thread.currentThread().getName() + &lt;span&gt;&quot;:&quot;&lt;/span&gt; + count.get());&lt;br/&gt;        }).start();&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3062730627306273&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NwjSqraNTGnNYPV2JqRic125P7Kt81YjagEffCOfILiaicKxO62R7SAicHtsa6LWT19dIiahC8tvIrvAXZibgPVGdb1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;271&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么InheritableThreadLocal到底是如何实现父子线程的参数传递的呢？我们还是看看源码中的实现原理。实际上在Thread源码中，除了有Threadlocal私有属性还有InheritableThreadLocal私有属性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;     &lt;span&gt;/* ThreadLocal values pertaining to this thread. This map is maintained&lt;br/&gt;     * by the ThreadLocal class. */&lt;/span&gt;&lt;br/&gt;    ThreadLocal.ThreadLocalMap threadLocals = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/*&lt;br/&gt;     * InheritableThreadLocal values pertaining to this thread. This map is&lt;br/&gt;     * maintained by the InheritableThreadLocal class.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    ThreadLocal.ThreadLocalMap inheritableThreadLocals = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;...&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Thread&lt;/span&gt;&lt;span&gt;(Runnable target)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        init(&lt;span&gt;null&lt;/span&gt;, target, &lt;span&gt;&quot;Thread-&quot;&lt;/span&gt; + nextThreadNum(), &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;(ThreadGroup g, Runnable target, String name,&lt;br/&gt;                      &lt;span&gt;long&lt;/span&gt; stackSize)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        init(g, target, name, stackSize, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;(ThreadGroup g, Runnable target, String name,&lt;br/&gt;                      &lt;span&gt;long&lt;/span&gt; stackSize, AccessControlContext acc,&lt;br/&gt;                      &lt;span&gt;boolean&lt;/span&gt; inheritThreadLocals)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ...&lt;br/&gt;        &lt;span&gt;//关键&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;if&lt;/span&gt; (inheritThreadLocals &amp;amp;&amp;amp; parent.inheritableThreadLocals != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.inheritableThreadLocals =&lt;br/&gt;                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); &lt;br/&gt;        ...    &lt;br/&gt;        &lt;br/&gt;    }&lt;br/&gt;    ...&lt;br/&gt;    &lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;实际在进行子线程创建的时候，在线程初始化过程中，判断了父线程中的inheritableThreadLocals属性是否为空，如果不为空的话需要进行值的复制，这样便实现了父子线程的值传递。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.871900826446281&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/NwjSqraNTGnNYPV2JqRic125P7Kt81Yja0Sd8xhfnXeIgNZP3wuvamiaAmBNwov7bUEvpD5YvWJ4OjVjDMibAIeyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;726&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;本文主要对ThreadLocal进行了相对全面的分析，从它的使用场景、原理以及源码分析、产生OOM的原因以及一些使用上的注意，相信通过本文的学习，大家对于ThreadLocal会有更加深刻的理解。&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;推荐：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MTI4MjI0MQ==&amp;amp;mid=2247506972&amp;amp;idx=2&amp;amp;sn=790959d9ee2b74e0d0c8a0a5395bc665&amp;amp;chksm=fc79b1b2cb0e38a498933a034926df45b51524b044762583488d498ae2112c06cf35d412fb3b&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;主流Java进阶技术（学习资料分享）&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100026048&quot; data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JfTPiahTHJhpqXIKV3icLwTcOzYBrWMq2XfdMVmt1XU6cIicfFIjtvVYWPuwu6TaBrdeomQfNPfgWSibLZiarZrMyvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;PS：因为公众号平台更改了推送规则，如果不想错过内容，记得读完点一下&lt;/span&gt;&lt;strong&gt;“在看”&lt;/strong&gt;&lt;span&gt;，加个&lt;/span&gt;&lt;strong&gt;“星标”&lt;/strong&gt;&lt;span&gt;，这样每次新文章推送才会第一时间出现在你的订阅列表里。&lt;/span&gt;&lt;span&gt;点&lt;strong&gt;“在看”&lt;/strong&gt;支持我们吧！&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>