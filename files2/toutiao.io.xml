<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b5af55b0d163895dd2bfed56430a1c0e</guid>
<title>Go 工程化（九）：项目重构实践</title>
<link>https://toutiao.io/k/et0t2lk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;markdown-body&quot;&gt;&lt;h2 id=&quot;序&quot;&gt;&lt;a href=&quot;#序&quot; class=&quot;headerlink&quot; title=&quot;序&quot;/&gt;序&lt;/h2&gt;&lt;p&gt;本系列为 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://u.geekbang.org/subject/go?utm_source=lailin.xyz&amp;amp;utm_medium=lailin.xyz&quot;&gt;Go 进阶训练营&lt;/a&gt; 笔记，预计 2021Q2 完成更新，访问 &lt;a href=&quot;https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/&quot;&gt;博客: Go 进阶训练营&lt;/a&gt; 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。&lt;strong&gt;3 月进度: 06/15&lt;/strong&gt; 3 月开始会尝试爆更模式，争取做到两天更新一篇文章，如果感兴趣可以拉到文章最下方获取关注方式。&lt;/p&gt;&lt;p&gt;这是《Go 工程化》系列的最后一篇文章了，其实在 Go 并发编程完结的时候我想的工程化这一章节不要写这么多，以听课笔记为主就可以了，但是最后还是展开讲了很多内容，与其说是为了做笔记或者是写文章，不如说是为了整理一下过去几年我的一些微不足道的经验，结合毛老师课上讲的内容与自己的情况重新对已有的知识进行了一遍梳理。&lt;/p&gt;&lt;p&gt;在前面的八篇文章当中我们讲到了，项目结构、依赖注入，API 设计、配置管理、包管理、单元测试，基本上还是将工程化当中的大部分东西都讲到了，不求尽善尽美，但求对你有所帮助，我们今天就来结合前面文章中提到的各种知识来看一下如何将一个老的项目迁移到新的项目结构当中来，这里面的坑也非常的多。&lt;/p&gt;&lt;p&gt;这篇文章是从之前重构的一个真实项目映射而来，里面讲到的坑基本上在迁移重构的过程中都趟了不止一次。&lt;/p&gt;&lt;h2 id=&quot;迁移前&quot;&gt;&lt;a href=&quot;#迁移前&quot; class=&quot;headerlink&quot; title=&quot;迁移前&quot;/&gt;迁移前&lt;/h2&gt;&lt;h3 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;/&gt;目录结构&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;.&lt;br/&gt;├── app&lt;br/&gt;│   ├── controller&lt;br/&gt;│   ├── lib&lt;br/&gt;│   ├── middleware&lt;br/&gt;│   ├── model&lt;br/&gt;│   └── router&lt;br/&gt;├── cmd&lt;br/&gt;│   ├── cron&lt;br/&gt;│   └── server&lt;br/&gt;├── config&lt;br/&gt;│   └── initializer&lt;br/&gt;├── db&lt;br/&gt;│   └── migrate&lt;br/&gt;│   └── migrate.go&lt;br/&gt;├── go.mod&lt;br/&gt;├── mock&lt;br/&gt;├── &lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;&lt;br/&gt;└── third_party&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;这是我们最开始的目录结构，这个结构是仿照 rails 框架设计而来的，这个结构在很长一段时间都是挺好用的，我先大概解释一下每个目录的含义&lt;/p&gt;&lt;ul&gt;&lt;li&gt;app: 应用逻辑相关的代码都在这里&lt;ul&gt;&lt;li&gt;controller: 控制器层，主要负责路由&lt;/li&gt;&lt;li&gt;lib: 一些工具库函数&lt;/li&gt;&lt;li&gt;middleware: 路由中间件&lt;/li&gt;&lt;li&gt;router: 路由注册&lt;/li&gt;&lt;li&gt;model: 由于我们使用的是充血模型，所以这一层的内容比较多，包含了领域对象，业务逻辑，数据存储等都在这里&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;cmd: 二进制文件目录&lt;ul&gt;&lt;li&gt;cron: 定时任务&lt;/li&gt;&lt;li&gt;server: http server 服务&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;db: migration 目录&lt;/li&gt;&lt;li&gt;mock: gomock 生成的文件&lt;/li&gt;&lt;li&gt;test: 测试工具库&lt;/li&gt;&lt;li&gt;third_party: 第三方文件&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;调用关系如下图所示&lt;br/&gt;&lt;img src=&quot;https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1615219210365-000fcd85-392a-41da-b7e4-8b4fc583123f.jpeg&quot; srcset=&quot;/img/loading.gif&quot; alt=&quot;Frame 1 (4).jpg&quot;/&gt;&lt;/p&gt;&lt;h3 id=&quot;存在的问题&quot;&gt;&lt;a href=&quot;#存在的问题&quot; class=&quot;headerlink&quot; title=&quot;存在的问题&quot;/&gt;存在的问题&lt;/h3&gt;&lt;p&gt;其实在报名参加 Go 进阶训练营 之前我就因为在提高这个项目的单元测试覆盖率的时候发现了很多问题，当时我用了各种操作，非常难受的将单元测试覆盖率写到 85% 左右的时候就写不上去了，因为我们的项目的历史包袱太严重了，很多代码写的基本就不可测试，想要提高测试覆盖率也就无从谈起了。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;cmd&lt;ul&gt;&lt;li&gt;我们之前在这一层当中最大的问题就是我们手写了大量启动代码，全手动依赖注入，还有一些隐式的依赖，这就导致在项目后期的时候启动的代码已经非常长了，而且很容易遗漏依赖关系的处理，建议如果不是特别小的项目还是使用 wire 比较香。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;initializer&lt;ul&gt;&lt;li&gt;我们之前所有的初始化都在这个包内完成，这个不是太大的问题，但是要命的是这里面有大量的全局变量，各种各样，过多的全局变量导致我们的单元测试非常难写。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;model&lt;ul&gt;&lt;li&gt;这一层的事情特别多，业务逻辑，领域对象，持久化存储等都在这一层完成，这就导致了后面我们 model 层的代码特别多，变成了一团乱麻，真的是剪不断理还乱，慢慢的这一层的逻辑我自己都理不清了。&lt;/li&gt;&lt;li&gt;这一层的代码耦合也很严重，无论是什么定时任务还是消息队列还是 server 的代码都放到了这里，导致出现了很多坑，举个例子，可能我有一个函数是 &lt;code&gt;GetArticles&lt;/code&gt; 这个函数最开始是为了 api 接口返回一些简要的列表数据，只需要查询一张表，返回速度非常快，但是我定时任务有一个地方也需要这个函数，然后我一看，真好这里已经有这个函数了我们就直接复用，但是数据内容不满足需求，我们就直接在这个函数当中加逻辑，然后需求满足了，过一段时间我们突然要求所有的接口必须要在 500ms 以内，结果发现坑来了，很多地方依赖这个函数，看 APM，就这一个函数的查询就需要耗费超过 500ms 🤣&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;controller&lt;ul&gt;&lt;li&gt;这一层主要做参数的处理还有部分业务逻辑，我们的 Controller 层和 model 层的界定比较模糊，有的主要业务逻辑放到了 model 有的有部分业务逻辑又放到了 Controller 了，到后面就是一点一点的找问题&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;错误处理&lt;ul&gt;&lt;li&gt;我们之前在项目内统一了错误码，但是存在两个问题&lt;/li&gt;&lt;li&gt;一个是要么处处 wrap，要么忘记 wrap 没有一个统一准则，这就导致要么错误堆栈长的没法看，要么就没有太多的错误信息没法排查&lt;/li&gt;&lt;li&gt;另一个是我们之前在 Controller 层跑业务错误代码，这就导致了很多时候想要返回一些细节的错误信息就无能为力，即使在 model 层抛了也会被 Controller 层吞掉&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;接口文档&lt;ul&gt;&lt;li&gt;这也是一个很大的痛点，之前想了很多方式都不能很好的解决，毛老师给出这个方案后，我没多久就用上了非常爽。&lt;/li&gt;&lt;li&gt;之前我们的文档分布五花八门，最开始使用 gin swagger 通过写注释的方式来生成相关接口文档，说实话可以用但是比较难用，因为这个注释其实和代码逻辑是两套东西，相当于写一遍代码再写一遍注释，慢慢的就没有人写了，或者还有写的是错误的。最麻烦的是在方案设计阶段我们不会直接写代码注释，所以测试同学在写测试方案的时候会比较麻烦，也不符合我们后续技术方案评审的要求所以后面也就废弃了&lt;/li&gt;&lt;li&gt;后面我们写到内部的文档平台上，还不如之前的 swagger，虽然解决了方案阶段没接口文档的问题，但是接口文档总是在变化当中的，特别是在开发的时候，这就让前后端对接联调，以及测试同学测试的非常难受，特别是经常会出现和前端同学沟通好了但是忘记和测试说的情况。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;迁移&quot;&gt;&lt;a href=&quot;#迁移&quot; class=&quot;headerlink&quot; title=&quot;迁移&quot;/&gt;迁移&lt;/h2&gt;&lt;p&gt;&lt;em&gt;迁移要三思，处处都是坑, 重构要小心，TDD 大法好&lt;/em&gt;&lt;/p&gt;&lt;h3 id=&quot;迁移后目录结构&quot;&gt;&lt;a href=&quot;#迁移后目录结构&quot; class=&quot;headerlink&quot; title=&quot;迁移后目录结构&quot;/&gt;迁移后目录结构&lt;/h3&gt;&lt;p&gt;为了能够更加直观，我们先来复习一下之前提到过的项目目录结构看一下迁移前后有哪些不同&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;.&lt;br/&gt;├── api&lt;br/&gt;│   └── product&lt;br/&gt;│       └── app&lt;br/&gt;│           ├── errcode&lt;br/&gt;│           └── v1&lt;br/&gt;│               └── v1.proto&lt;br/&gt;├── cmd&lt;br/&gt;│   ├── cron&lt;br/&gt;│   │   ├── main.go&lt;br/&gt;│   │   └── wire.go&lt;br/&gt;│   ├── migrate&lt;br/&gt;│   └── server&lt;br/&gt;├── config&lt;br/&gt;├── go.mod&lt;br/&gt;├── internal&lt;br/&gt;│   ├── cron&lt;br/&gt;│   │   ├── repo&lt;br/&gt;│   │   ├── service&lt;br/&gt;│   │   ├── usecase&lt;br/&gt;│   │   └── wire_set.go&lt;br/&gt;│   ├── domain&lt;br/&gt;│   ├── pkg&lt;br/&gt;│   │   ├── copier&lt;br/&gt;│   │   ├── mock&lt;br/&gt;│   │   └── &lt;span class=&quot;hljs-built_in&quot;&gt;test&lt;/span&gt;&lt;br/&gt;│   └── server&lt;br/&gt;│       ├── repo&lt;br/&gt;│       ├── service&lt;br/&gt;│       ├── usecase&lt;br/&gt;│       └── wire_set.go&lt;br/&gt;└── third_party&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;具体每个文件夹的含义就不再赘述，如果不太清楚可以查看 &lt;a href=&quot;https://lailin.xyz/post/go-training-week4-project-layout.html&quot;&gt;Go 工程化(二) 项目目录结构&lt;/a&gt;&lt;br/&gt;我们看一下新的目录结构的调用链路&lt;br/&gt;&lt;img src=&quot;https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1615268889054-251a4e39-c8d9-410f-950c-5262b368ae34.jpeg&quot; srcset=&quot;/img/loading.gif&quot; alt=&quot;Frame 2 (1).jpg&quot;/&gt;&lt;br/&gt;注意，在这里 service 和 usecase 实际调用的都是 domain 中的接口，只是 usecase 和 repo 实现这些接口而已，所以我们这里用虚线画出来&lt;/p&gt;&lt;h3 id=&quot;迁移重构原则&quot;&gt;&lt;a href=&quot;#迁移重构原则&quot; class=&quot;headerlink&quot; title=&quot;迁移重构原则&quot;/&gt;迁移重构原则&lt;/h3&gt;&lt;p&gt;接下来我会从各个模块来阐述我在重构这个项目的时候是怎么做的，每个模块都有每个模块自己的坑。开始之前呢我们先来看一下几个总的原则:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;结构简单的应用优先&lt;/li&gt;&lt;li&gt;有充分的单元测试的应用优先&lt;/li&gt;&lt;li&gt;先写测试，测试需要在新老代码同时通过&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;api&quot;&gt;&lt;a href=&quot;#api&quot; class=&quot;headerlink&quot; title=&quot;api&quot;/&gt;api&lt;/h3&gt;&lt;p&gt;api 当中主要写的就是 proto 文件，这个 proto 文件替代了我们在之前的 &lt;code&gt;router&lt;/code&gt; 以及部分 &lt;code&gt;controller&lt;/code&gt; 中的逻辑，定义了 proto 文件之后，生成的代码当中主要要完成的就是，路由的注册，参数绑定，返回值结构填充。&lt;/p&gt;&lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;/&gt;背景&lt;/h4&gt;&lt;p&gt;先补充一下背景，我们之前的项目采用的是 gin 作为路由框架，返回值采用下面这种统一的结构&lt;/p&gt;&lt;figure class=&quot;highlight json&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs json&quot;&gt;{&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;code&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;,&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;msg&quot;&lt;/span&gt;: &lt;span class=&quot;hljs-string&quot;&gt;&quot;成功&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span class=&quot;hljs-attr&quot;&gt;&quot;data&quot;&lt;/span&gt;: {}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;在 api 层的路由注册，参数绑定，返回值结构填充我们都使用工具进行统一处理，详细介绍可以看之前的文章: &lt;a href=&quot;https://lailin.xyz/post/go-training-week4-protoc-gen-go-gin.html&quot;&gt;Go 工程化(五) API 设计下: 基于 protobuf 自动生成 gin 代码&lt;/a&gt;&lt;/p&gt;&lt;h4 id=&quot;简单案例&quot;&gt;&lt;a href=&quot;#简单案例&quot; class=&quot;headerlink&quot; title=&quot;简单案例&quot;/&gt;简单案例&lt;/h4&gt;&lt;p&gt;先来看一个基本的例子&lt;/p&gt;&lt;figure class=&quot;highlight protobuf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs protobuf&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 这里指定了 proto 文件的版本&lt;/span&gt;&lt;br/&gt;syntax = &lt;span class=&quot;hljs-string&quot;&gt;&quot;proto3&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// package 命名规则: product.application.version&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; product.app.v1;&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// go_package 生成 go 文件当中的包名&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;option&lt;/span&gt; go_package = &lt;span class=&quot;hljs-string&quot;&gt;&quot;github.com/mohuishou/new-project/api/product/app/v1&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;google/api/annotations.proto&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;service&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;BlogService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;// 创建文章&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;rpc&lt;/span&gt; CreateArticle(CreateArticleReq) &lt;span class=&quot;hljs-keyword&quot;&gt;returns&lt;/span&gt; (CreateArticleResp) &lt;/span&gt;{&lt;br/&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;// option 还是都加上，可以利用插件自动生成 swagger 文档&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-keyword&quot;&gt;option&lt;/span&gt; (google.api.http) = {&lt;br/&gt;      post: &lt;span class=&quot;hljs-string&quot;&gt;&quot;/article&quot;&lt;/span&gt;&lt;br/&gt;      body: &lt;span class=&quot;hljs-string&quot;&gt;&quot;*&quot;&lt;/span&gt;&lt;br/&gt;    };&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 参数和返回值定义，这里就不详细列了&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;CreateArticleReq&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;CreateArticleResp&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;成功的例子千篇一律，路上的坑各不相同，我们来看一下几个典型的坑(问题)，以及该如何解决&lt;/p&gt;&lt;h4 id=&quot;Q1-Get-请求参数如何进行绑定，默认无法修改-struct-tag&quot;&gt;&lt;a href=&quot;#Q1-Get-请求参数如何进行绑定，默认无法修改-struct-tag&quot; class=&quot;headerlink&quot; title=&quot;Q1: Get 请求参数如何进行绑定，默认无法修改 struct tag&quot;/&gt;Q1: Get 请求参数如何进行绑定，默认无法修改 struct tag&lt;/h4&gt;&lt;p&gt;这个稳定同样适用于参数校验，原来 gin 参数校验可以在 struct 上加 tag 解决，这个有两种解决方案，一种是使用 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/favadi/protoc-go-inject-tag&quot;&gt;protoc-go-inject-tag&lt;/a&gt; 加注释解决，另外一种是使用 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/gogo/protobuf&quot;&gt;gogo/protobuf&lt;/a&gt; 支持添加 option 的方式来添加 tag，目前我采用的是第一种&lt;/p&gt;&lt;p&gt;只需要在定义 message 的时候添加注释 &lt;code&gt;// @inject_tag:&lt;/code&gt; 后面是具体的 tag&lt;/p&gt;&lt;figure class=&quot;highlight protobuf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs protobuf&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;GetArticleReq&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span class=&quot;hljs-comment&quot;&gt;// @inject_tag: form:&quot;id&quot; binding:&quot;required&quot;&lt;/span&gt;&lt;br/&gt;  &lt;span class=&quot;hljs-built_in&quot;&gt;int32&lt;/span&gt; id = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;然后我们在生成好对应的 go 文件之后执行一下 &lt;code&gt;protoc-go-inject-tag -input=filepath&lt;/code&gt; 就可以了&lt;/p&gt;&lt;h4 id=&quot;Q2-返回值是一个数组&quot;&gt;&lt;a href=&quot;#Q2-返回值是一个数组&quot; class=&quot;headerlink&quot; title=&quot;Q2: 返回值是一个数组&quot;/&gt;Q2: 返回值是一个数组&lt;/h4&gt;&lt;p&gt;举个例子，我们之前可能有一个 &lt;code&gt;get: /article/tags&lt;/code&gt; 的接口，由于一篇文章当中的标签不会很多，所以我们没有做分页，返回数据的时候直接在 data 里面塞了一个数组，然后我们迁移的时候就麻烦了 o(╥﹏╥)o&lt;/p&gt;&lt;p&gt;因为在 protobuf 的 rpc 方法定义当中，只能返回一个结构体，无法返回一个数组结构，但是我们做重构的时候又不想有 api 的破坏性变更，因为这项所有的依赖方都需要进行修改成本太大了，那我们如何兼容呢？&lt;/p&gt;&lt;p&gt;我的解决方案是先生成对应的 go 结构体，然后在同一个包内创建一个 &lt;code&gt;xx_type.pb.go&lt;/code&gt; 里面实现 json 的解析接口，让我们虽然定义的是一个结构体，但是返回接口数据的时候返回的是一个数组&lt;/p&gt;&lt;p&gt;举个例子，下面是我定义的 pb&lt;/p&gt;&lt;figure class=&quot;highlight protobuf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs protobuf&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ListArticleTagsResp&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;repeated&lt;/span&gt; Tag tags = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Tag&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; key = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; value = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;然后生成了 &lt;code&gt;v1.pb.go&lt;/code&gt; ，我创建了一个 &lt;code&gt;v1_type.pb.go&lt;/code&gt;&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// UnmarshalJSON sets *m to a copy of data.&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(m *ListArticleTagsResp)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;UnmarshalJSON&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(data []&lt;span class=&quot;hljs-keyword&quot;&gt;byte&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; m == &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; errors.New(&lt;span class=&quot;hljs-string&quot;&gt;&quot;json.RawMessage: UnmarshalJSON on nil pointer&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; json.Unmarshal(data, &amp;amp;m.Tags)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// MarshalJSON returns m as the JSON encoding of m.&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(m *ListArticleTagsResp)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MarshalJSON&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;([]&lt;span class=&quot;hljs-keyword&quot;&gt;byte&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; m == &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; []&lt;span class=&quot;hljs-keyword&quot;&gt;byte&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;null&quot;&lt;/span&gt;), &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; json.Marshal(m.Tags)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;当然后续最好还是修改一下，但是重构的时候还是建议不要做破坏性的变动&lt;/p&gt;&lt;h4 id=&quot;Q3-返回值当中包含时间&quot;&gt;&lt;a href=&quot;#Q3-返回值当中包含时间&quot; class=&quot;headerlink&quot; title=&quot;Q3: 返回值当中包含时间&quot;/&gt;Q3: 返回值当中包含时间&lt;/h4&gt;&lt;p&gt;除了数组之外，返回值当中包含时间也是挺麻烦的一件事情，首先 pb 的基础类型里面没有时间类型，然后 google 官方的库当中有一个 timestamp 包，可以使用，但是使用的时候就会发现，在 json 序列话的时候不是一个时间字段，而是一个对象值，和我们之前直接使用 &lt;code&gt;time.Time&lt;/code&gt; 的行为不一致。&lt;/p&gt;&lt;p&gt;我的做法是仿照 google 的包自己搞一个然后实现 json 的相关方法，让 json 序列化的时候的行为和 &lt;code&gt;time.Time&lt;/code&gt; 保持一致&lt;/p&gt;&lt;p&gt;首先定义 &lt;code&gt;timestamp.proto&lt;/code&gt;&lt;/p&gt;&lt;figure class=&quot;highlight protobuf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs protobuf&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 这里指定了 proto 文件的版本&lt;/span&gt;&lt;br/&gt;syntax = &lt;span class=&quot;hljs-string&quot;&gt;&quot;proto3&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// package 命名规则: product.application.version&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; product.app.v1;&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// go_package 生成 go 文件当中的包名&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;option&lt;/span&gt; go_package = &lt;span class=&quot;hljs-string&quot;&gt;&quot;github.com/mohuishou/new-project/api/product/app/v1&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Timestamp&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;// Represents seconds of UTC time since Unix epoch&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;// 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;// 9999-12-31T23:59:59Z inclusive.&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;int64&lt;/span&gt; seconds = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;// Non-negative fractions of a second at nanosecond resolution. Negative&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;// second values with fractions must still have non-negative nanos values&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;// that count forward in time. Must be from 0 to 999,999,999&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;// inclusive.&lt;/span&gt;&lt;br/&gt;    &lt;span class=&quot;hljs-built_in&quot;&gt;int32&lt;/span&gt; nanos = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;和上面一样，创建一个 &lt;code&gt;timestamp_type.pb.go&lt;/code&gt; ，除了实现 json 的接口以外还实现了两个转换方法，用于 service 层调用&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// NewTimestamp NewTimestamp&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;NewTimestamp&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(t time.Time)&lt;/span&gt; *&lt;span class=&quot;hljs-title&quot;&gt;Timestamp&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &amp;amp;Timestamp{&lt;br/&gt;Seconds: t.Unix(),&lt;br/&gt;Nanos:   &lt;span class=&quot;hljs-keyword&quot;&gt;int32&lt;/span&gt;(t.Nanosecond()),&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Time 类型转换&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(m *Timestamp)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Time&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;time&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;Time&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Don&#x27;t return the zero value on error, because corresponds to a valid&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// timestamp. Instead return whatever time.Unix gives us.&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; m == &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; time.Unix(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;).UTC() &lt;span class=&quot;hljs-comment&quot;&gt;// treat nil like the empty Timestamp&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; time.Unix(m.Seconds, &lt;span class=&quot;hljs-keyword&quot;&gt;int64&lt;/span&gt;(m.Nanos)).UTC()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// UnmarshalJSON sets *m to a copy of data.&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(m *Timestamp)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;UnmarshalJSON&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(data []&lt;span class=&quot;hljs-keyword&quot;&gt;byte&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; m == &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; errors.New(&lt;span class=&quot;hljs-string&quot;&gt;&quot;json.RawMessage: UnmarshalJSON on nil pointer&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; t time.Time&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err := json.Unmarshal(data, &amp;amp;t); err != &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; err&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;*m = *NewTimestamp(t)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// MarshalJSON returns m as the JSON encoding of m.&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(m *Timestamp)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MarshalJSON&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;([]&lt;span class=&quot;hljs-keyword&quot;&gt;byte&lt;/span&gt;, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; m == &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; []&lt;span class=&quot;hljs-keyword&quot;&gt;byte&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;null&quot;&lt;/span&gt;), &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; json.Marshal(m.Time())&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&quot;domain&quot;&gt;&lt;a href=&quot;#domain&quot; class=&quot;headerlink&quot; title=&quot;domain&quot;/&gt;domain&lt;/h3&gt;&lt;p&gt;domain 这一层主要是包含 do 对象的定义，以及 usecase 和 repo 层的接口定义，由于我们现在使用的 gorm 所以，也会在这里给 do 对象加上一些 tag 用于标志索引，关联关系等。&lt;/p&gt;&lt;h4 id=&quot;domain-example&quot;&gt;&lt;a href=&quot;#domain-example&quot; class=&quot;headerlink&quot; title=&quot;domain example&quot;/&gt;domain example&lt;/h4&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// article.go&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Article 文章&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; Article &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {&lt;br/&gt;Model &lt;span class=&quot;hljs-comment&quot;&gt;// 基础结构体，包含 id, created_at, deleted_at, updated_at&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;Title   &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;`json:&quot;title&quot;`&lt;/span&gt;&lt;br/&gt;Content &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;`json:&quot;content&quot;`&lt;/span&gt;&lt;br/&gt;Tags    []Tag  &lt;span class=&quot;hljs-string&quot;&gt;`json:&quot;tags&quot; gorm:&quot;many2many:article_tags&quot;`&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// IArticleUsecase IArticleUsecase&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; IArticleUsecase &lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; {&lt;br/&gt;    &lt;span class=&quot;hljs-comment&quot;&gt;// 获取文章详情&lt;/span&gt;&lt;br/&gt;GetArticle(ctx context.Context, id &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;) (*Article, error)&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 创建一篇文章&lt;/span&gt;&lt;br/&gt;    CreateArticle(ctx context.Context, article *Article) error&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// IArticleRepo IArticleRepo&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; IArticleRepo &lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt; {&lt;br/&gt;GetArticle(ctx context.Context, id &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;) (*Article, error)&lt;br/&gt;CreateArticle(ctx context.Context, article *Article) error&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// tag.go&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Tag 标签数据&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; Tag &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {&lt;br/&gt;Model&lt;br/&gt;&lt;br/&gt;Key   &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;`json:&quot;key&quot;`&lt;/span&gt;&lt;br/&gt;Value &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;`json:&quot;value&quot;`&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;这一层的坑稍微少一些，主要是接口定义的相关事情&lt;/p&gt;&lt;h4 id=&quot;小技巧-批量-mock-接口&quot;&gt;&lt;a href=&quot;#小技巧-批量-mock-接口&quot; class=&quot;headerlink&quot; title=&quot;小技巧: 批量 mock 接口&quot;/&gt;小技巧: 批量 mock 接口&lt;/h4&gt;&lt;p&gt;使用最新的项目结构我们会在 domain 中创建大量接口，之前在 &lt;a href=&quot;https://lailin.xyz/post/go-training-week4-unit-test.html&quot;&gt;Go 工程化(八) 单元测试&lt;/a&gt; 中我们提到了，在每一层的单元测试的时候，我们都会把依赖的接口用 gomock 给 mock 掉，让测试尽量轻量级一些，为了简化 gomock 的创建，我们可以在 &lt;code&gt;makefile&lt;/code&gt; 当中写一个 &lt;code&gt;shell&lt;/code&gt; 脚本，找出含有 &lt;code&gt;interface&lt;/code&gt; 定义的文件，然后我们用 gomock 生成对应的 mock 文件&lt;/p&gt;&lt;figure class=&quot;highlight makefile&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs makefile&quot;&gt;&lt;span class=&quot;hljs-section&quot;&gt;mockgen:&lt;/span&gt;&lt;br/&gt;cd ./internal &amp;amp;&amp;amp; for file in `egrep -rnl &lt;span class=&quot;hljs-string&quot;&gt;&quot;type.*?interface&quot;&lt;/span&gt; ./domain | grep -v &lt;span class=&quot;hljs-string&quot;&gt;&quot;_test&quot;&lt;/span&gt; `; do \&lt;br/&gt;echo $$file ; \&lt;br/&gt;cd .. &amp;amp;&amp;amp; mockgen -destination=&lt;span class=&quot;hljs-string&quot;&gt;&quot;./internal/pkg/mock/$$file&quot;&lt;/span&gt; -source=&lt;span class=&quot;hljs-string&quot;&gt;&quot;./internal/$$file&quot;&lt;/span&gt; &amp;amp;&amp;amp; cd ./internal ; \&lt;br/&gt;done&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&quot;service&quot;&gt;&lt;a href=&quot;#service&quot; class=&quot;headerlink&quot; title=&quot;service&quot;/&gt;service&lt;/h3&gt;&lt;p&gt;新的 service 层的主要左右就是 dto 数据和 do 数据的相互转换，它实现了 &lt;code&gt;v1&lt;/code&gt; 包中的相关接口，service 的代码比较简单，我们直接看一个例子&lt;/p&gt;&lt;h4 id=&quot;service-example&quot;&gt;&lt;a href=&quot;#service-example&quot; class=&quot;headerlink&quot; title=&quot;service example&quot;/&gt;service example&lt;/h4&gt;&lt;p&gt;注意，我们在迁移 service、usecase、repo 的时候，都应该先写对应的单元测试，本文当中由于篇幅原因我就没有再列了，感兴趣可以查看上一篇文章 &lt;a href=&quot;https://lailin.xyz/post/go-training-week4-unit-test.html&quot;&gt;Go 工程化(八) 单元测试&lt;/a&gt; 对应章节的内容&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 确保实现了对应的接口&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; _ v1.BlogServiceHTTPServer = &amp;amp;Artcile{}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Artcile Artcile&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; Artcile &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {&lt;br/&gt;usecase domain.IArticleUsecase&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// NewArticleService 初始化方法&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;NewArticleService&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(usecase domain.IArticleUsecase)&lt;/span&gt; *&lt;span class=&quot;hljs-title&quot;&gt;Artcile&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &amp;amp;Artcile{usecase: usecase}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// CreateArticle 创建一篇文章&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(a *Artcile)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;CreateArticle&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ctx context.Context, req *v1.CreateArticleReq)&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(*v1.CreateArticleResp, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;article := &amp;amp;domain.Article{&lt;br/&gt;Title:   req.Title,&lt;br/&gt;Content: req.Content,&lt;br/&gt;}&lt;br/&gt;err := a.usecase.CreateArticle(ctx, article)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &amp;amp;v1.CreateArticleResp{}, err&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h4 id=&quot;小技巧-copier-减少重复的复制粘贴操作&quot;&gt;&lt;a href=&quot;#小技巧-copier-减少重复的复制粘贴操作&quot; class=&quot;headerlink&quot; title=&quot;小技巧: copier 减少重复的复制粘贴操作&quot;/&gt;小技巧: copier 减少重复的复制粘贴操作&lt;/h4&gt;&lt;p&gt;在上面的例子我们可以看到，我们的数据转换是手动写的，这种方法不是不行，但是示例当中的字段比较少，如果字段多了起来，并且还有各种数组类型的存在的时候，数据转换的这部分代码写的就会比较难受了，如果你的应用和我的一样对性能的要求不是很高的话可以试试下面这种方式。&lt;/p&gt;&lt;p&gt;我最开始是用了 jinzhu 大佬的 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://pkg.go.dev/github.com/jinzhu/copier&quot;&gt;copier&lt;/a&gt; 包来做的数据转换，但是这个包比较局限，它主要是在两个结构的之间的字段名以及类型相同的时候有用，向出现我们上面在 api 部分讲的那种骚操作就不适用了，并且我还出现过由于两边字段的大小写不一致导致最后有一个字段没有复制成功导致的问题（所以用这个一定要写对应的单元测试）。&lt;/p&gt;&lt;p&gt;所以结合我们之前的操作，我自己手动写了一个 copier 函数签名一样，实现非常简单，当然性能不太好，但是如果对性能要求不高的话也能用.&lt;/p&gt;&lt;p&gt;如下所示，就是用 json 来回倒腾两次就行了&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Copy 从一个结构体复制到另一个结构体&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Copy&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(to, from &lt;span class=&quot;hljs-keyword&quot;&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;b, err := json.Marshal(from)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; errors.Wrap(err, &lt;span class=&quot;hljs-string&quot;&gt;&quot;marshal from data err&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;err = json.Unmarshal(b, to)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; errors.Wrap(err, &lt;span class=&quot;hljs-string&quot;&gt;&quot;unmarshal to data err&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;如果使用这个函数的话，我们上面的代码就可以改成&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// CreateArticle 创建一篇文章&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(a *Artcile)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;CreateArticle&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ctx context.Context, req *v1.CreateArticleReq)&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(*v1.CreateArticleResp, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; article domain.Article&lt;br/&gt;err := copier.Copy(&amp;amp;article, req)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;, err&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;err = a.usecase.CreateArticle(ctx, &amp;amp;article)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &amp;amp;v1.CreateArticleResp{}, err&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&quot;usecase&quot;&gt;&lt;a href=&quot;#usecase&quot; class=&quot;headerlink&quot; title=&quot;usecase&quot;/&gt;usecase&lt;/h3&gt;&lt;p&gt;这一层主要是业务逻辑，业务逻辑相关代码都应该在这一层写，当然有时候我们的代码可能就只是保存一下数据没啥业务逻辑，可能是直接调用一下 repo 的方式&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; article &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {&lt;br/&gt;repo domain.IArticleRepo&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// NewArticleUsecase init&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;NewArticleUsecase&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(repo domain.IArticleRepo)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;domain&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;IArticleUsecase&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &amp;amp;article{repo: repo}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(u *article)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;GetArticle&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ctx context.Context, id &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(*domain.Article, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 这里可能有其他业务逻辑...&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; u.repo.GetArticle(ctx, id)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(u *article)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;CreateArticle&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ctx context.Context, article *domain.Article)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; u.repo.CreateArticle(ctx, article)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&quot;repo&quot;&gt;&lt;a href=&quot;#repo&quot; class=&quot;headerlink&quot; title=&quot;repo&quot;/&gt;repo&lt;/h3&gt;&lt;p&gt;这一层是数据持久层，像数据库存取，缓存的处理应该都在这一层做掉，还有可能后续我们变成调用一个微服务来实现，那么这个被调用的微服务也应该在这里做。&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; article &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {&lt;br/&gt;db *gorm.DB&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// NewArticleRepo init&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;NewArticleRepo&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(db *gorm.DB)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;domain&lt;/span&gt;.&lt;span class=&quot;hljs-title&quot;&gt;IArticleRepo&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &amp;amp;article{db: db}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(r *article)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;GetArticle&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ctx context.Context, id &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(*domain.Article, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; a domain.Article&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err := r.db.WithContext(ctx).Find(&amp;amp;a, id); err != &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 这里返回业务错误码&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &amp;amp;a, &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(r *article)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;CreateArticle&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ctx context.Context, article *domain.Article)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err := r.db.WithContext(ctx).Create(article); err != &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 这里返回业务错误码&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&quot;wire-set-go&quot;&gt;&lt;a href=&quot;#wire-set-go&quot; class=&quot;headerlink&quot; title=&quot;wire_set.go&quot;/&gt;wire_set.go&lt;/h3&gt;&lt;p&gt;之前在 &lt;a href=&quot;https://lailin.xyz/post/go-training-week4-wire.html&quot;&gt;Go 工程化(三) 依赖注入框架 wire&lt;/a&gt; 这一节讲到过，我们使用 wire 作为我们的依赖注入框架，由于 wire 不能出现相同的 Provider 所以我们会在 internal 的每个子目录下创建一下 wire_set.go 用于构建 wire.Set 结构，到时我们在 cmd 下直接应用这个文件的内容就可以了&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; server&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; (&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;github.com/google/wire&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;github.com/mohuishou/new-project/internal/server/repo&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;github.com/mohuishou/new-project/internal/server/service&quot;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-string&quot;&gt;&quot;github.com/mohuishou/new-project/internal/server/usecase&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// Set for di&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; Set = wire.NewSet(&lt;br/&gt;service.NewArticleService,&lt;br/&gt;usecase.NewArticleUsecase,&lt;br/&gt;repo.NewArticleRepo,&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&quot;cmd&quot;&gt;&lt;a href=&quot;#cmd&quot; class=&quot;headerlink&quot; title=&quot;cmd&quot;/&gt;cmd&lt;/h3&gt;&lt;p&gt;cmd 下的二进制目录，我一般会包含四个文件&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs bash&quot;&gt;.&lt;br/&gt;├── main.go &lt;span class=&quot;hljs-comment&quot;&gt;# 包含 main 函数&lt;/span&gt;&lt;br/&gt;├── server.go &lt;span class=&quot;hljs-comment&quot;&gt;# 包含 wire set 等&lt;/span&gt;&lt;br/&gt;├── wire.go &lt;span class=&quot;hljs-comment&quot;&gt;# for wire build&lt;/span&gt;&lt;br/&gt;└── wire_gen.go &lt;span class=&quot;hljs-comment&quot;&gt;# wire 自动生成的&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;server.go&lt;/strong&gt; 在真实的项目当中我们 service 包下面一般会有多个 service 文件，对应不同的结构体，并且除了 internal 中的依赖外我们可能还会有很多公共的依赖，例如配置中心，日志，数据库等，我的习惯是构建一个新的结构，在这个结构当中我们把所有的注册还还有 wire.set 搞好，这样 main 函数就会很清爽，整体上也会比较整洁&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; set = wire.NewSet(&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// domains&lt;/span&gt;&lt;br/&gt;server.Set,&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// common&lt;/span&gt;&lt;br/&gt;initializer.Set,&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;type&lt;/span&gt; services &lt;span class=&quot;hljs-keyword&quot;&gt;struct&lt;/span&gt; {&lt;br/&gt;article *service.Artcile&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(s *services)&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;register&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(r gin.IRouter)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;v1.RegisterBlogServiceHTTPServer(r, s.article)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;wire.go&lt;/strong&gt; 经过 server.go 封装之后，wire.go 的代码就非常简单了&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// NewServices NewServices&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;NewServices&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-params&quot;&gt;(*services, error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;panic&lt;/span&gt;(wire.Build(&lt;br/&gt;wire.Struct(&lt;span class=&quot;hljs-built_in&quot;&gt;new&lt;/span&gt;(services), &lt;span class=&quot;hljs-string&quot;&gt;&quot;*&quot;&lt;/span&gt;),&lt;br/&gt;set,&lt;br/&gt;))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;main.go&lt;/strong&gt; 我这里还没有像 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/go-kratos/kratos/blob/main/app.go&quot;&gt;kratos&lt;/a&gt; 把程序的启动和退出封装起来，如果封装了会更加优雅一点&lt;/p&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs go&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;s, err := NewServices()&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;hljs-literal&quot;&gt;nil&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-built_in&quot;&gt;panic&lt;/span&gt;(err)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;e := gin.Default()&lt;br/&gt;s.register(e)&lt;br/&gt;&lt;br/&gt;&lt;span class=&quot;hljs-comment&quot;&gt;// 这里还有优雅中止的一些代码，就不贴了&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;/&gt;总结&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1615219210365-000fcd85-392a-41da-b7e4-8b4fc583123f.jpeg&quot; srcset=&quot;/img/loading.gif&quot; alt=&quot;Frame 1 (4).jpg&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/1615268889054-251a4e39-c8d9-410f-950c-5262b368ae34.jpeg&quot; srcset=&quot;/img/loading.gif&quot; alt=&quot;Frame 2 (1).jpg&quot;/&gt;&lt;br/&gt;我们回过头来看上面这两种结构，可以发现，第一种结构整体上职责相对没有那么清晰，就导致了在团队协作的过程中会出现很多二义性，导致最后越来越混乱，并且由于 model 层就是一个大锅饭，什么都往里面扔所以也就乱的不行了。&lt;/p&gt;&lt;p&gt;新的结构不仅仅进行了水平拆分还按照功能进行了垂直拆分，将定时任务和 http 服务的代码拆分开来，整体的结构都清晰了很多，并且由于我们大量使用依赖注入，所以代码的可测性非常的好，写单元测试非常容易。&lt;br/&gt;但是这里也有一个坑，拆分的时候要注意，我第一次拆分想按照领域进行拆分，并且拆分的非常细，导致出现了很多服务，后面听过毛老师课上的讲解后重新 review 了一下发现其实这些服务边界没有那么清晰，即使我们以后拆微服务，也不会把这些拆成两个不同的微服务，所以后面再改了一次才构成了现在的结构。所以我们在进行垂直拆分的时候一定要多问问自己，或者多和团队的同学讨论一下。&lt;/p&gt;&lt;p&gt;最后想要业务开发的比较开心愉快，那基础设施的建设非常重要，像本文提到的很多代码只要我们统一了规范和结构都可以通过工具来自动生成。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;我们下一篇文章见，加油打工人 💪（看完别忘了转发，订阅，点赞哦）&lt;/strong&gt;&lt;/p&gt;&lt;h2 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;/&gt;参考文献&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://u.geekbang.org/subject/go?utm_source=lailin.xyz&amp;amp;utm_medium=lailin.xyz&quot;&gt;Go 进阶训练营-极客时间&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://lailin.xyz/post/go-training-week4-clean-arch.html&quot;&gt;Go 工程化(一) 架构整洁之道阅读笔记 - Mohuishou&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://lailin.xyz/post/go-training-week4-project-layout.html&quot;&gt;Go 工程化(二) 项目目录结构 - Mohuishou&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://lailin.xyz/post/go-training-week4-wire.html&quot;&gt;Go 工程化(三) 依赖注入框架 wire - Mohuishou&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://lailin.xyz/post/go-training-week4-api-design.html&quot;&gt;Go 工程化(四) API 设计上: 项目结构 &amp;amp; 设计 - Mohuishou&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://lailin.xyz/post/go-training-week4-protoc-gen-go-gin.html&quot;&gt;Go 工程化(五) API 设计下: 基于 protobuf 自动生成 gin 代码 - Mohuishou&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://lailin.xyz/post/go-training-week4-config.html&quot;&gt;Go 工程化(六) 配置管理 - Mohuishou&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://lailin.xyz/post/go-training-week4-go-module.html&quot;&gt;Go 工程化(七) Go Module - Mohuishou&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://lailin.xyz/post/go-training-week4-unit-test.html&quot;&gt;Go 工程化(八) 单元测试 - Mohuishou&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/favadi/protoc-go-inject-tag&quot;&gt;https://github.com/favadi/protoc-go-inject-tag&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://pkg.go.dev/github.com/jinzhu/copier&quot;&gt;https://pkg.go.dev/github.com/jinzhu/copier&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/go-kratos/kratos/blob/main/app.go&quot;&gt;https://github.com/go-kratos/kratos/blob/main/app.go&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e2e1a6409258c0c4c1efe823d2839590</guid>
<title>Java 基础：日期与时间 API 用法详解</title>
<link>https://toutiao.io/k/soqwk0v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h1&gt;&lt;span&gt;一、时间和日期&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;在系统开发中，日期与时间作为重要的业务因素，起到十分关键的作用，例如同一个时间节点下的数据生成，基于时间范围的各种数据统计和分析，集群节点统一时间避免超时等。&lt;/p&gt;&lt;p&gt;在时间和日期中有几个关键概念：&lt;/p&gt;&lt;p&gt;日期和时间的用法在系统中通常是获取时间和一些常见的计算与格式转换处理，在一些垮时区的业务中就会变的复杂很多，例如在电商业务中的全球贸易或者海淘等。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、JDK原生API&lt;/span&gt;&lt;/h1&gt;&lt;h2&gt;&lt;span&gt;1、Date基础&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;基础用法&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;java.sql.Date继承java.util.Date，相关方法也大部分直接调用父类方法。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DateTime01&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; nowTime = System.currentTimeMillis() ;&lt;br/&gt;        java.util.Date data01 = &lt;span&gt;new&lt;/span&gt; java.util.Date(nowTime);&lt;br/&gt;        java.sql.Date date02 = &lt;span&gt;new&lt;/span&gt; java.sql.Date(nowTime);&lt;br/&gt;        System.out.println(data01);&lt;br/&gt;        System.out.println(date02.getTime());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;打印：&lt;br/&gt;Fri Jan &lt;span&gt;29&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;:&lt;span&gt;11&lt;/span&gt;:&lt;span&gt;25&lt;/span&gt; CST &lt;span&gt;2021&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1611904285848&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;计算规则&lt;/strong&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DateTime02&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Date nowDate = &lt;span&gt;new&lt;/span&gt; Date();&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;年:&quot;&lt;/span&gt;+nowDate.getYear());&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;月:&quot;&lt;/span&gt;+nowDate.getMonth());&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;日:&quot;&lt;/span&gt;+nowDate.getDay());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;年份：当前时间减去1900；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getYear&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; normalize().getYear() - &lt;span&gt;1900&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;月份：0-11表示1-12月份；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getMonth&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; normalize().getMonth() - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;天份：正常表示；&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getDay&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; normalize().getDayOfWeek() - BaseCalendar.SUNDAY;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;格式转换&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;非线程安全的日期转换API，该用法在规范的开发中是不允许使用的。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DateTime02&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 默认转换&lt;/span&gt;&lt;br/&gt;        DateFormat dateFormat01 = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat() ;&lt;br/&gt;        String nowDate01 = dateFormat01.format(&lt;span&gt;new&lt;/span&gt; Date()) ;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;nowDate01=&quot;&lt;/span&gt;+nowDate01);&lt;br/&gt;        &lt;span&gt;// 指定格式转换&lt;/span&gt;&lt;br/&gt;        String format = &lt;span&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;;&lt;br/&gt;        SimpleDateFormat dateFormat02 = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(format);&lt;br/&gt;        String nowDate02 = dateFormat02.format(&lt;span&gt;new&lt;/span&gt; Date()) ;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;nowDate02=&quot;&lt;/span&gt;+nowDate02);&lt;br/&gt;        &lt;span&gt;// 解析时间&lt;/span&gt;&lt;br/&gt;        String parse = &lt;span&gt;&quot;yyyy-MM-dd HH:mm&quot;&lt;/span&gt;;&lt;br/&gt;        SimpleDateFormat dateFormat03 = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(parse);&lt;br/&gt;        Date parseDate = dateFormat03.parse(&lt;span&gt;&quot;2021-01-18 16:59:59&quot;&lt;/span&gt;) ;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;parseDate=&quot;&lt;/span&gt;+parseDate);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;作为JDK初始版本就使用的日期和时间，Date类一直在项目中使用，但是相关API的方法都已经基本废弃，通常使用一些二次封装的时间组件。该API的设计堪称Java中的最烂。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;2、Calendar升级&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;Calendar作为一个抽象类，定义日期时间相关转换与计算的方法，这个类目测&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DateTime04&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Calendar calendar = Calendar.getInstance();&lt;br/&gt;        calendar.set(Calendar.YEAR,&lt;span&gt;2021&lt;/span&gt;);&lt;br/&gt;        calendar.set(Calendar.MONTH,&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        calendar.set(Calendar.DAY_OF_MONTH,&lt;span&gt;12&lt;/span&gt;);&lt;br/&gt;        calendar.set(Calendar.HOUR_OF_DAY,&lt;span&gt;23&lt;/span&gt;);&lt;br/&gt;        calendar.set(Calendar.MINUTE,&lt;span&gt;59&lt;/span&gt;);&lt;br/&gt;        calendar.set(Calendar.SECOND,&lt;span&gt;59&lt;/span&gt;);&lt;br/&gt;        calendar.set(Calendar.MILLISECOND,&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        DateFormat dateFormat = &lt;span&gt;new&lt;/span&gt; SimpleDateFormat(&lt;span&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;) ;&lt;br/&gt;        Date defDate = calendar.getTime();&lt;br/&gt;        System.out.println(defDate+&lt;span&gt;&quot;||&quot;&lt;/span&gt;+dateFormat.format(defDate));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;输出：Fri Feb &lt;span&gt;12&lt;/span&gt; &lt;span&gt;23&lt;/span&gt;:&lt;span&gt;59&lt;/span&gt;:&lt;span&gt;59&lt;/span&gt; CST &lt;span&gt;2021&lt;/span&gt;||&lt;span&gt;2021&lt;/span&gt;-&lt;span&gt;02&lt;/span&gt;-&lt;span&gt;12&lt;/span&gt; &lt;span&gt;23&lt;/span&gt;:&lt;span&gt;59&lt;/span&gt;:&lt;span&gt;59&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;直观感觉，Date中相关方法迁移Calendar实现，简化Date的功能侧重对日期与时间的实体封装，Calendar复杂相关计算策略，DateFormat依旧用来做格式处理。但是Calendar依旧很少被使用，上述基础API就已经是很好的说明了。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;3、JDK1.8升级API&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;Java8之后的版本中，核心API类包括LocalDate-日期、LocalTime-时间、LocalDateTime-日期加时间。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;LocalDate：日期描述是final修饰的不可变类，默认格式yyyy-MM-dd。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;LocalTime：时间描述是final修饰的不可变类，默认格式hh:mm:ss.zzz。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;LocalDateTime：日期与时间描述final修饰的不可变类。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DateTime05&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 日期：年-月-日&lt;/span&gt;&lt;br/&gt;        System.out.println(LocalDate.now());&lt;br/&gt;        &lt;span&gt;// 时间：时-分-秒-毫秒&lt;/span&gt;&lt;br/&gt;        System.out.println(LocalTime.now());&lt;br/&gt;        &lt;span&gt;// 日期时间：年-月-日 时-分-秒-毫秒&lt;/span&gt;&lt;br/&gt;        System.out.println(LocalDateTime.now());&lt;br/&gt;        &lt;span&gt;// 日期节点获取&lt;/span&gt;&lt;br/&gt;        LocalDate localDate = LocalDate.now();&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;[&quot;&lt;/span&gt; + localDate.getYear() +&lt;br/&gt;                &lt;span&gt;&quot;年]；[&quot;&lt;/span&gt; + localDate.getMonthValue() +&lt;br/&gt;                &lt;span&gt;&quot;月]；[&quot;&lt;/span&gt; + localDate.getDayOfMonth()+&lt;span&gt;&quot;日]&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 计算方法&lt;/span&gt;&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;1年后：&quot;&lt;/span&gt; + localDate.plusYears(&lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;2月前：&quot;&lt;/span&gt; + localDate.minusMonths(&lt;span&gt;2&lt;/span&gt;));&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;3周后：&quot;&lt;/span&gt; + localDate.plusWeeks(&lt;span&gt;3&lt;/span&gt;));&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;3天前：&quot;&lt;/span&gt; + localDate.minusDays(&lt;span&gt;3&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 时间比较&lt;/span&gt;&lt;br/&gt;        LocalTime localTime1 = LocalTime.of(&lt;span&gt;12&lt;/span&gt;, &lt;span&gt;45&lt;/span&gt;, &lt;span&gt;45&lt;/span&gt;); ;&lt;br/&gt;        LocalTime localTime2 = LocalTime.of(&lt;span&gt;16&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;, &lt;span&gt;30&lt;/span&gt;); ;&lt;br/&gt;        System.out.println(localTime1.isAfter(localTime2));&lt;br/&gt;        System.out.println(localTime2.isAfter(localTime1));&lt;br/&gt;        System.out.println(localTime2.equals(localTime1));&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 日期和时间格式&lt;/span&gt;&lt;br/&gt;        LocalDateTime localDateTime = LocalDateTime.now() ;&lt;br/&gt;        LocalDate myLocalDate = localDateTime.toLocalDate();&lt;br/&gt;        LocalTime myLocalTime = localDateTime.toLocalTime();&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;日期：&quot;&lt;/span&gt; + myLocalDate);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;时间：&quot;&lt;/span&gt; + myLocalTime);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果作为JodaTime组件的深度用户，对这个几个API使用基本无压力。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;4、时间戳&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;时间戳也是业务中常用的方式，基于Long类型表示时间，在很多时候远比常规日期与时间的格式更好用。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DateTime06&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 精确到毫秒级别&lt;/span&gt;&lt;br/&gt;        System.out.println(System.currentTimeMillis());&lt;br/&gt;        System.out.println(&lt;span&gt;new&lt;/span&gt; Date().getTime());&lt;br/&gt;        System.out.println(Calendar.getInstance().getTime().getTime());&lt;br/&gt;        System.out.println(LocalDateTime.now().toInstant(&lt;br/&gt;                ZoneOffset.of(&lt;span&gt;&quot;+8&quot;&lt;/span&gt;)).toEpochMilli());&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里需要注意的是在实际业务中由于获取时间戳的方式是多样的，所以建议统一工具方法，和规定精确度，避免部分精确到秒部分精确到毫秒的问题，这样可以规避在使用时相互转换的情况。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、JodaTime组件&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;在Java8之前JodaTime组件是大部分系统中的常见选择，有很多方便好用的日期与时间的处理方法封装。&lt;/p&gt;&lt;p&gt;基础依赖：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;joda-time&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;joda-time&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在joda-time提供的组件之上做一个简单的工具类封装，保证业务处理风格统一。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;JodaTimeUtil&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 时间格式&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DATE_FORMAT = &lt;span&gt;&quot;yyyy-MM-dd HH:mm:ss&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;JodaTimeUtil&lt;/span&gt; &lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取当前时间&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DateTime &lt;span&gt;getCurrentTime&lt;/span&gt; &lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; DateTime() ;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取指定时间&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DateTime &lt;span&gt;getDateTime&lt;/span&gt; &lt;span&gt;(Object obj)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; DateTime(obj) ;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 把时间以指定格式转换为字符串&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String &lt;span&gt;getNowDate&lt;/span&gt; &lt;span&gt;(Date date, String format)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; DateTime(date).toString(format) ;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 获取星期时间&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String &lt;span&gt;getWeek&lt;/span&gt; &lt;span&gt;(Object date)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        DateTime time = getDateTime (date) ;&lt;br/&gt;        String week = &lt;span&gt;null&lt;/span&gt; ;&lt;br/&gt;        &lt;span&gt;switch&lt;/span&gt; (time.getDayOfWeek()) {&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; DateTimeConstants.SUNDAY:&lt;br/&gt;                week = &lt;span&gt;&quot;星期日&quot;&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; DateTimeConstants.MONDAY:&lt;br/&gt;                week = &lt;span&gt;&quot;星期一&quot;&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; DateTimeConstants.TUESDAY:&lt;br/&gt;                week = &lt;span&gt;&quot;星期二&quot;&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; DateTimeConstants.WEDNESDAY:&lt;br/&gt;                week = &lt;span&gt;&quot;星期三&quot;&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; DateTimeConstants.THURSDAY:&lt;br/&gt;                week = &lt;span&gt;&quot;星期四&quot;&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; DateTimeConstants.FRIDAY:&lt;br/&gt;                week = &lt;span&gt;&quot;星期五&quot;&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;case&lt;/span&gt; DateTimeConstants.SATURDAY:&lt;br/&gt;                week = &lt;span&gt;&quot;星期六&quot;&lt;/span&gt;;&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;                &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; week ;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1&gt;&lt;span&gt;四、源代码地址&lt;/span&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;GitHub·地址&lt;br/&gt;https:&lt;span&gt;//github.com/cicadasmile/java-base-parent&lt;/span&gt;&lt;br/&gt;GitEE·地址&lt;br/&gt;https:&lt;span&gt;//gitee.com/cicadasmile/java-base-parent&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3783359497645212&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCjMheLZtcM2iaVMBOpIUKR4CDRCG9FLT5K6NmGXvG7exrW0TSuDjnTKJQ5PDq8j8Y7PHDd17Z3gicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>32d99c2a832139d7597175f634cba838</guid>
<title>Linux 文件 I/O 进化史（三）：Direct I/O 和 Linux AIO</title>
<link>https://toutiao.io/k/peychra</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Direct I/O&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面介绍的 buffered I/O 和 mmap，访问文件都是需要经过内核的 page cache。这对于数据库这种 self-caching 的应用可能不是特别友好：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户层的 cache 和内核的 page cache 其实是重复的，导致内存浪费。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据的传输：disk -&amp;gt; page cache -&amp;gt; user buffer 需要两次内存拷贝。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为此，Linux 提供了一种绕过 page cache 读写文件的方式：direct I/O。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要使用 direct I/O 需要在 open 文件的时候加上 O_DIRECT 的 flag。比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; fd = open(fname, O_RDWR | O_DIRECT);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;使用 direct I/O 有一个很大的限制：buffer 的内存地址、每次读写数据的大小、文件的 offset 三者都要与底层设备的逻辑块大小对齐（一般是 512 字节）。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Since Linux 2.6.0, alignment to the logical block size of the underlying storage (typically 512 bytes) suffices. The logical block size can be determined using the ioctl(2) BLKSSZGET operation or from the shell using the command:
blockdev --getss&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ blockdev --getss /dev/vdb1 &lt;br/&gt;&lt;span&gt;512&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不满足对齐要求，系统会报 EINVAL（Invalid argument。） 错误：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;assert.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;sys/stat.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;sys/types.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; fd = open(&lt;span&gt;&quot;/tmp/direct_io_test&quot;&lt;/span&gt;, O_CREAT | O_RDWR | O_DIRECT);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (fd &amp;lt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    perror(&lt;span&gt;&quot;open&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;constexpr&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; kBlockSize = &lt;span&gt;512&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// buffer 地址不对齐&lt;/span&gt;&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt;* p = &lt;span&gt;nullptr&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; ret = posix_memalign(&lt;br/&gt;        (&lt;span&gt;void&lt;/span&gt;**)&amp;amp;p, kBlockSize / &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt;        kBlockSize);  &lt;span&gt;// 这里有一定概率可以分配出与 kBlockSize 对齐的内存&lt;/span&gt;&lt;br/&gt;    assert(ret == &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; n = write(fd, p, kBlockSize);&lt;br/&gt;    assert(n &amp;lt; &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    perror(&lt;span&gt;&quot;write&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;free&lt;/span&gt;(p);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// buffer 大小不对齐&lt;/span&gt;&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt;* p = &lt;span&gt;nullptr&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; ret = posix_memalign((&lt;span&gt;void&lt;/span&gt;**)&amp;amp;p, kBlockSize, kBlockSize / &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;    assert(ret == &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; n = write(fd, p, kBlockSize / &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;    assert(n &amp;lt; &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    perror(&lt;span&gt;&quot;write&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;free&lt;/span&gt;(p);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 文件 offset 不对齐&lt;/span&gt;&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt;* p = &lt;span&gt;nullptr&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; ret = posix_memalign((&lt;span&gt;void&lt;/span&gt;**)&amp;amp;p, kBlockSize, kBlockSize);&lt;br/&gt;    assert(ret == &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;off_t&lt;/span&gt; offset = lseek(fd, kBlockSize / &lt;span&gt;2&lt;/span&gt;, SEEK_SET);&lt;br/&gt;    assert(offset == kBlockSize / &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; n = write(fd, p, kBlockSize);&lt;br/&gt;    assert(n &amp;lt; &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    perror(&lt;span&gt;&quot;write&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;free&lt;/span&gt;(p);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 三者对齐&lt;/span&gt;&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt;* p = &lt;span&gt;nullptr&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; ret = posix_memalign((&lt;span&gt;void&lt;/span&gt;**)&amp;amp;p, kBlockSize, kBlockSize);&lt;br/&gt;    assert(ret == &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;off_t&lt;/span&gt; offset = lseek(fd, &lt;span&gt;0&lt;/span&gt;, SEEK_SET);&lt;br/&gt;    assert(offset == &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; n = write(fd, p, kBlockSize);&lt;br/&gt;    assert(n == kBlockSize);&lt;br/&gt;    &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;write ok\n&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;free&lt;/span&gt;(p);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Direct I/O 与数据持久化&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 buffered I/O 写入数据，write 返回之后，数据实际上只到达 page cache —— 还在内存中，需要等内核线程周期性将脏页刷新到持久化存储上，或应用程序调用 fsync 主动将数据刷新脏页。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理论上，使用 direct I/O 不会经过 page cache，当 write 返回之后，数据应该达到持久化存储。但是，除了文件数据本身，文件的一些重要的元数据，比如文件的大小，也会影响数据的完整性。而 direct I/O 只是对文件数据本身有效，文件的元数据读写还是会经过内核缓存 —— 使用 direct I/O 读写文件，依然需要使用 fsync 来刷新文件的元数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，并不是所有文件元数据都会影响到数据的完整性，比如文件的修改时间。为此，MySQL 提供了一个新的刷盘参数：O_DIRECT_NO_FSYNC —— 使用 O_DIRECT  读写数据，只有在必要的使用进行 fsync。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;As of MySQL 8.0.14, fsync() is called after creating a new file, after increasing file size, and after closing a file, to ensure that file system metadata changes are synchronized. The fsync() system call is still skipped after each write operation.&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Linux AIO&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面介绍的，无论是调用 read/write 读写文件（包括 buffered I/O 和 direct I/O），还是使用 mmap 映射文件，都是属于同步文件 I/O。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同步 I/O 接口的优点是：简单易用、逻辑清晰。但是除了这个，同步 I/O 似乎没别的优点了。同步的 I/O 接口，如果没有命中 page cache，会导致线程阻塞 =&amp;gt; 这种情况下，往往会使用多线程来解决 =&amp;gt; 随着 SSD 等持久化设备的性能提升，继续增加线程数 =&amp;gt; 大量线程的基础开销 + 大量上下文切换 + 内核调度器的负载 =&amp;gt; 系统性能很差 =&amp;gt; 需要异步文件 I/O 来提升高并发读写时的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux AIO 是内核提供的一套支持文件异步 I/O 的接口（只支持使用 O_DIRECT 的方式来读写文件）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;io_setup&lt;/span&gt;&lt;span&gt;(&lt;span&gt;unsigned&lt;/span&gt; nr_events, &lt;span&gt;aio_context_t&lt;/span&gt; *ctx_idp)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;io_submit&lt;/span&gt;&lt;span&gt;(&lt;span&gt;aio_context_t&lt;/span&gt; ctx_id, &lt;span&gt;long&lt;/span&gt; nr, struct iocb **iocbpp)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;io_getevents&lt;/span&gt;&lt;span&gt;(&lt;span&gt;aio_context_t&lt;/span&gt; ctx_id, &lt;span&gt;long&lt;/span&gt; min_nr, &lt;span&gt;long&lt;/span&gt; nr,&lt;br/&gt;                 struct io_event *events, struct timespec *timeout)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;io_cancel&lt;/span&gt;&lt;span&gt;(&lt;span&gt;aio_context_t&lt;/span&gt; ctx_id, struct iocb *iocb,&lt;br/&gt;                     struct io_event *result)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;io_destroy&lt;/span&gt;&lt;span&gt;(&lt;span&gt;aio_context_t&lt;/span&gt; ctx_id)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;io_setup&lt;/code&gt; 创建一个能支持 &lt;code&gt;nr_events&lt;/code&gt; 个操作的异步 I/O context。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;io_submit&lt;/code&gt; 提交异步 I/O 请求。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;io_getevents&lt;/code&gt; 获取已完成的异步 I/O 结果。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;io_cancel&lt;/code&gt; 取消之前提交的某个异步 I/O 请求。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;io_destroy&lt;/code&gt; 取消所有提交的异步 I/O 请求，并销毁异步 I/O context。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常情况下，Linux AIO 的流程如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;io_setup&lt;/code&gt; 创建一个 I/O context 用于提交和收割 I/O 请求。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建 1~n 和 I/O 请求，调用 &lt;code&gt;io_submit&lt;/code&gt; 提交请求。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;I/O 请求执行完成，通过 DMA 直接将数据传输到 user buffer。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用 &lt;code&gt;io_getevents&lt;/code&gt; 收割已完成的 I/O。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重新执行第 2 步，或者确认不需要继续执行 AIO，调用 &lt;code&gt;io_destroy&lt;/code&gt; 销毁 I/O context。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.50375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9637P74IBOEOmWPg8AtGYYOAtIAuDEXDvdGvce8IacUq2sMHkb3bXCxYUFNluOztcYIJWvZtMmOaRCz3PqN1iaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1600&quot;/&gt;&lt;/figure&gt;&lt;center data-tool=&quot;mdnice编辑器&quot;&gt;（图片来自 https://www.scylladb.com/2017/10/05/io-access-methods-scylla/）&lt;/center&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里用一个简单的例子介绍一下 Linux AIO 接口的基本使用方法。各个 Linux AIO 接口的详细介绍，建议参考相关的 Linux Manual Page。这里要注意的是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;glibc 并没有提供 Linux AIO 系统调用接口的封装，使用的时候需要使用 syscall 简单封装一下。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;libaio 是对 Linux AIO 的封装，接口很像但是不完全一样，不要混淆。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;assert.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;fcntl.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;inttypes.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;linux/aio_abi.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;sys/syscall.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;io_setup&lt;/span&gt;&lt;span&gt;(&lt;span&gt;unsigned&lt;/span&gt; nr, &lt;span&gt;aio_context_t&lt;/span&gt; *ctxp)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; syscall(__NR_io_setup, nr, ctxp);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;io_destroy&lt;/span&gt;&lt;span&gt;(&lt;span&gt;aio_context_t&lt;/span&gt; ctx)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; syscall(__NR_io_destroy, ctx); }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;io_submit&lt;/span&gt;&lt;span&gt;(&lt;span&gt;aio_context_t&lt;/span&gt; ctx, &lt;span&gt;long&lt;/span&gt; nr, struct iocb **iocbpp)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; syscall(__NR_io_submit, ctx, nr, iocbpp);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;io_getevents&lt;/span&gt;&lt;span&gt;(&lt;span&gt;aio_context_t&lt;/span&gt; ctx, &lt;span&gt;long&lt;/span&gt; min_nr, &lt;span&gt;long&lt;/span&gt; max_nr,&lt;br/&gt;                 struct io_event *events, struct timespec *timeout)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; syscall(__NR_io_getevents, ctx, min_nr, max_nr, events, timeout);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *argv[])&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; fd = open(&lt;span&gt;&quot;/tmp/linux_aio_test&quot;&lt;/span&gt;, O_RDWR | O_CREAT | O_DIRECT, &lt;span&gt;0666&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (fd &amp;lt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    perror(&lt;span&gt;&quot;open&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;aio_context_t&lt;/span&gt; ctx = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; ret = io_setup(&lt;span&gt;128&lt;/span&gt;, &amp;amp;ctx);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (ret &amp;lt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    perror(&lt;span&gt;&quot;io_setup&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;iocb&lt;/span&gt; &lt;span&gt;cb&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;memset&lt;/span&gt;(&amp;amp;cb, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(cb));&lt;br/&gt;  cb.aio_fildes = fd;&lt;br/&gt;  cb.aio_lio_opcode = IOCB_CMD_PWRITE;&lt;br/&gt;  &lt;span&gt;char&lt;/span&gt; *data = &lt;span&gt;nullptr&lt;/span&gt;;&lt;br/&gt;  ret = posix_memalign((&lt;span&gt;void&lt;/span&gt; **)&amp;amp;data, &lt;span&gt;512&lt;/span&gt;, &lt;span&gt;4096&lt;/span&gt;);&lt;br/&gt;  assert(ret == &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;memset&lt;/span&gt;(data, &lt;span&gt;&#x27;A&#x27;&lt;/span&gt;, &lt;span&gt;4096&lt;/span&gt;);&lt;br/&gt;  cb.aio_buf = (&lt;span&gt;uint64_t&lt;/span&gt;)data;&lt;br/&gt;  cb.aio_offset = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  cb.aio_nbytes = &lt;span&gt;4096&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;iocb&lt;/span&gt; *&lt;span&gt;cbs&lt;/span&gt;[1];&lt;/span&gt;&lt;br/&gt;  cbs[&lt;span&gt;0&lt;/span&gt;] = &amp;amp;cb;&lt;br/&gt;  ret = io_submit(ctx, &lt;span&gt;1&lt;/span&gt;, cbs);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (ret != &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;free&lt;/span&gt;(data);&lt;br/&gt;    perror(&lt;span&gt;&quot;io_submit&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;io_event&lt;/span&gt; &lt;span&gt;events&lt;/span&gt;[1];&lt;/span&gt;&lt;br/&gt;  ret = io_getevents(ctx, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, events, &lt;span&gt;nullptr&lt;/span&gt;);&lt;br/&gt;  assert(ret == &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;%ld %ld\n&quot;&lt;/span&gt;, events[&lt;span&gt;0&lt;/span&gt;].res, events[&lt;span&gt;0&lt;/span&gt;].res2);&lt;br/&gt;  &lt;span&gt;free&lt;/span&gt;(data);&lt;br/&gt;  ret = io_destroy(ctx);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (ret &amp;lt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    perror(&lt;span&gt;&quot;io_destroy&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小结&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux AIO 是 Linux 下一个尝试解决文件异步 I/O 的解决方案，但是这个方案并不彻底、不完美。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Linux AIO 只支持 direct I/O。&lt;/strong&gt; 这意味着使用 Linux AIO 的所有读写操作都要受到 direct I/O 的限制：1）buffer 地址、buffer 大小、文件 offset 的对齐限制；2）无法使用 page cache。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;不完备的异步，仍然有可能被阻塞。&lt;/strong&gt; 比如在 ext4 文件系统上，如果需要读取文件的元数据，此时调用可能会被阻塞。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;较大的参数拷贝开销。&lt;/strong&gt; 每个 I/O 提交需要拷贝一个 64 字节的 &lt;code&gt;struct iocb&lt;/code&gt; 对象；每个 I/O 完成需要拷贝一个 32 字节的 &lt;code&gt;struct io_event&lt;/code&gt; 对象；一个 I/O 请求总共需要 96 字节的拷贝。这个拷贝开销是否可以承受，和单次 I/O 的大小有关：如果单次 I/O 本身就很大，相较之下，这点消耗可以忽略；而在大量小 I/O 的场景下，这样的拷贝影响比较大。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多线程提交或收割 I/O 请求会对 io_context_t 造成比较大的&lt;strong&gt;锁竞争&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个 I/O 需要两次系统调用才能完成（ &lt;code&gt;io_submit&lt;/code&gt;  和 &lt;code&gt;io_getevents&lt;/code&gt; )，大量小 I/O 难以接受 —— 不过 &lt;code&gt;io_submit&lt;/code&gt; 和 &lt;code&gt;io_getevents&lt;/code&gt; 都支持批量操作，可以通过批量提交和批量收割来减少系统调用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux AIO 从诞生之日（内核 2.5 版本）起到现在（2021 年），一直在不断完善。但大部分情况下，都是一些修修补补的工作，Linux AIO 一直都没有被实现完整 —— 特别是只支持 direct I/O，异步接口仍然可能被阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了彻底解决 Linux AIO 在设计上的不完善，Linux 5.1 开始引入了全新的异步 I/O 接口：io_uring —— 希望 io_uring 能彻底解决 Linux 下的异步 I/O 问题。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;参考资料&lt;/h1&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Linux Programmer&#x27;s Manual - open (2)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Page-based direct I/O&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;InnoDB innodb_flush_method 配置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Why does O_DIRECT require I/O to be 512-byte aligned?&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;linux-aio&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>86cb8e39b795dd070946324de4a7c83c</guid>
<title>聊一聊设计模式究竟是什么</title>
<link>https://toutiao.io/k/yqyaefq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;大家好，我是流沙。设计模式是每个程序员都会经常接触到的东西，但是相信很多人对于设计模式究竟是什么还会有些疑问。所以，我们今天就聊聊这个，主要目标是帮大家理解设计模式的作用，以及要用什么样的心态对待设计模式。&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;h1&gt;前置知识&lt;/h1&gt;&lt;p&gt;提到设计模式，其实首先需要理解清楚的是面向对象思想。相信大家即使不能非常清晰的描述出来，对面向对象也应该是比较熟悉的。&lt;/p&gt;&lt;p&gt;我们就快速讲一下，面向对象有四大基本特性：封装、抽象、继承、多态；&lt;/p&gt;&lt;p&gt;封装：仅暴露有限的接口，授权外部来访问。将逻辑集中，因此更可控；可读性、可维护性也更好；易用性也更好。&lt;/p&gt;&lt;p&gt;抽象：隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。&lt;/p&gt;&lt;p&gt;继承：好处就是代码复用。&lt;/p&gt;&lt;p&gt;多态：子类可以替换父类。提高代码的可扩展和可复用性。&lt;/p&gt;&lt;h1&gt;什么是设计模式&lt;/h1&gt;&lt;p&gt;设计模式是针对软件开发中经常遇到的一些设计问题，根据基本的设计原则，总结出来的一套实用的解决方案或者设计思路。&lt;/p&gt;&lt;p&gt;可以看到，设计模式是非常偏实际应用的，相比设计原则更加具体、可执行。&lt;/p&gt;&lt;p&gt;因此，在了解设计模式之前，就需要了解一些基本的设计原则。这些原则才是指导我们写出好代码的关键。&lt;/p&gt;&lt;p&gt;那么什么是好代码呢？&lt;/p&gt;&lt;h2&gt;好代码的标准&lt;/h2&gt;&lt;p&gt;这个其实很难描述，我们可以试着归纳一些好代码的特征，比如下面这些：&lt;/p&gt;&lt;p&gt;可维护、可扩展、可读、可测、可复用、简洁。&lt;/p&gt;&lt;p&gt;为了达到这些标准，就需要现有一些基本的设计原则。&lt;/p&gt;&lt;h1&gt;基本设计原则&lt;/h1&gt;&lt;h2&gt;SOLID&lt;/h2&gt;&lt;h3&gt;单一职责 Single Responsibility Principle&lt;/h3&gt;&lt;p&gt;描述很简单，一个类只负责完成一个职责或者功能。但是实际要做好其实还是很难的。&lt;/p&gt;&lt;p&gt;关于怎么样才算职责单一，可以定出一些简单的标准，比如代码行数过多；依赖的其他类过多；私有方法过多；难以给类起名；类中大量方法功能集中等。但是无法定义出一个普适的标准，一定要结合实际情况去考虑。&lt;/p&gt;&lt;p&gt;比如这样一个类&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;Student {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    int id;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;String&lt;/span&gt; name;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;String&lt;/span&gt; age;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;String&lt;/span&gt; province;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;String&lt;/span&gt; city;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;String&lt;/span&gt; county;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;String&lt;/span&gt; detailAddress;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;在其中至少有四个字段是和地址有关的，那么是否需要把地址相关的职责抽离出来，封装一个新的Address类?&lt;/p&gt;&lt;p&gt;其实，是要视情况而定的，如果地址这些属性只是单纯的展示信息，那么直接放在Student类里，就没有问题；如果在这背后还有一套复杂的物流系统，也就是有很多地址相关的复杂逻辑，那么这一部分就应当单独抽离出来。&lt;/p&gt;&lt;p&gt;在实际的开发中，我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构。&lt;/p&gt;&lt;h3&gt;开闭原则 Open Closed Principle&lt;/h3&gt;&lt;p&gt;对扩展开放、对修改关闭。&lt;/p&gt;&lt;p&gt;添加一个新的功能，应该是通过在已有代码基础上扩展代码（新增模块、类、方法、属性等），而非修改已有代码（修改模块、类、方法、属性等）的方式来完成。&lt;/p&gt;&lt;p&gt;开闭原则是相对难理解的一条原则。&lt;/p&gt;&lt;p&gt;“怎样的代码改动才被定义为‘扩展’？怎样的代码改动才被定义为‘修改’？怎么才算满足或违反‘开闭原则’？修改代码就一定意味着违反‘开闭原则’吗？”等问题，都很难回答。&lt;/p&gt;&lt;p&gt;而这条原则又是最有用，因为扩展性是代码质量最重要的衡量标准之一。&lt;/p&gt;&lt;p&gt;实际上，我们也没必要纠结某个代码改动是“修改”还是“扩展”，更没必要太纠结它是否违反“开闭原则”。我们应当回到它的初衷上，只要没有破坏原有代码的运行，就没有违反开闭原则。一个简单的判断标准，当功能没有变化时，对应的单元测试没被破坏，就是一次满足开闭原则的改动。&lt;/p&gt;&lt;p&gt;关于如何做到对扩展开放、修改关闭，也需要慢慢学习和积累。在 23 种经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则。&lt;/p&gt;&lt;p&gt;实际写代码时可以假定变化不会发生，当出现变化时，需要抽象以隔离将来的同类变化。&lt;/p&gt;&lt;h3&gt;里式替换原则 Liskov Substitution Principle&lt;/h3&gt;&lt;p&gt;子类能够在任何地方替换父类，并且保证原来程序的逻辑行为不变及正确性不被破坏。&lt;/p&gt;&lt;p&gt;里式替换原则还有另外一个更加能落地、更有指导意义的描述，那就是“Design By Contract”，中文翻译就是“按照协议来设计”。描述里子类和父类的关系，可以替换成接口和实现的关系。换一种方式描述里式替换原则，就是实现类不能违反接口声明要提供的功能、输入、输出、异常等。&lt;/p&gt;&lt;h3&gt;接口隔离原则 Interface Segregation Principle&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;Clients should not be forced to depend upon interfaces that they do not use。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;其核心要素就是一个「接口」的功能要尽量单一，调用方只需要依赖它需要的部分，而不需要去依赖或者调用整个「接口」。&lt;/p&gt;&lt;p&gt;这里的接口可以指代不同的含义，比如一组api接口集合（也就是我们用的一个proxy）。&lt;/p&gt;&lt;p&gt;比如有个项目，会做一些业务流程，生成一些数据，然后又要作为基础服务把数据提供出去，这时，最后就是提供了两个接口, 一个是用来处理内部流程；一个则是作为基础服务堆外提供。这样做的好处就是可以一定程度上避免误调用。&lt;/p&gt;&lt;p&gt;也可以将接口就理解为单独一个接口方法，这时候就是说一个方法的功能要单一。&lt;/p&gt;&lt;p&gt;接口隔离原则跟单一职责原则有点类似，不过稍微还是有点区别。单一职责原则针对的是模块、类、接口的设计。而接口隔离原则相对于单一职责原则，更侧重于接口的设计。接口隔离原则提供了一种判断接口的职责是否单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。&lt;/p&gt;&lt;h3&gt;依赖反转原则 Dependency Inversion Principle&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层.&lt;/p&gt;&lt;p&gt;这一原则更多针对框架开发，业务开发里，高层模块依赖底层模块，实际上没有任何问题。&lt;/p&gt;&lt;p&gt;以tomcat为例，tomcat调用web程序来运行，所以tomcat是高层模块。&lt;/p&gt;&lt;p&gt;Tomcat 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Servlet 规范。Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。&lt;/p&gt;&lt;h3&gt;KISS&lt;/h3&gt;&lt;p&gt;Keep It Simple and Stupid.&lt;/p&gt;&lt;p&gt;Keep It Short and Simple.&lt;/p&gt;&lt;p&gt;Keep It Simple and Straightforward&lt;/p&gt;&lt;p&gt;KISS原则有不同的表述方式，但是大体意思都差不多，就是要让代码尽量简单。&lt;/p&gt;&lt;p&gt;「简单」实际上是一个很主观的事情，code review是一种很好的间接评价代码是否简单的方式。如果同事review你的代码时，会有很多地方看不懂，这就很可能是代码不够简单。&lt;/p&gt;&lt;p&gt;一些简单的经验：不要重复造轮子；避免过度设计，无论是为了未来不确定的扩展性，还是细微的性能差别。&lt;/p&gt;&lt;p&gt;举个例子，StringUtils中的很多方法，在一个具体的场景中，我们是大概率可以写出一个性能更好的实现的，因为StringUtils中要考虑的很多通用性的问题，在具体的场景中就不需要考虑了。那么，我们是不是要真的这么去做？&lt;/p&gt;&lt;h3&gt;DRY 原则（Don’t Repeat Yourself）&lt;/h3&gt;&lt;p&gt;这一条本身很简单，不过要注意这里的repeat和单纯代码重复是有区别的。比如两个无关的方法，实现恰好一模一样，这时候就不认为它违反了DRY原则，因为语义上是不重复的。而两个方法，如果方法名到实现都完全不一样，但是是在做一件事，比如isValidIp(), checkIpValid(), 两个方法各自用不同的方法实现了，我们也认为违反了DRY原则。&lt;/p&gt;&lt;p&gt;另外要注意执行重复的问题，比如&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; run1() {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;b();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; run2() {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;a();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;c();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;main () {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;run1();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;run2();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;虽然看起来代码封装的很好，但是执行main方法时，a方法执行了两次。如果a是一个开销很大的方法，就会很有问题。&lt;/p&gt;&lt;h3&gt;迪米特法则&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;“高内聚、松耦合”是一个比较通用的设计思想，可以用来指导不同粒度代码的设计与开发，比如系统、模块、类、函数。&lt;/p&gt;&lt;p&gt;所谓高内聚，就是指相近的功能应该放到同一个类（模块、系统）中，不相近的功能不要放到同一个类（模块、系统）中。&lt;/p&gt;&lt;p&gt;所谓松耦合是说，在代码中，类（模块、系统）与类（模块、系统）之间的依赖关系简单清晰，只依赖必要的东西。&lt;/p&gt;&lt;p&gt;像qwerty中之前对作业相关逻辑的处理，需要了解每种类型作业的实现细节，就是一种违反了迪米特法则的做法。正确的做法是在作业这一侧定义一个通用的模型，模型中将各类作业的不同逻辑封装好，qwerty则只需要了解这个模型。&lt;/p&gt;&lt;p&gt;对于这些设计原则，不需要花费很多精力来扣它们的字眼。更重要的是，理解它们的思想，理解为什么这些原则能帮助我们写出来「可维护、可扩展、可读、可测、可复用、简洁」的代码。&lt;/p&gt;&lt;p&gt;接下来，我们就可以具体说设计模式了。&lt;/p&gt;&lt;h1&gt;常用设计模式&lt;/h1&gt;&lt;p&gt;经典的设计模式有 23 种。随着编程语言的演进，一些设计模式（比如 Singleton）也随之过时，甚至成了反模式，一些则被内置在编程语言中（比如 Iterator），另外还有一些新的模式诞生（比如 Monostate）&lt;/p&gt;&lt;p&gt;创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式&lt;/p&gt;&lt;p&gt;结构型模式，共七种：适配器模式、装饰者模式、代理模式、门面模式、桥接模式、组合模式、享元模式。&lt;/p&gt;&lt;p&gt;行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。&lt;/p&gt;&lt;p&gt;我们只挑其中一些重要的来讲吧。&lt;/p&gt;&lt;h2&gt;简单工厂&amp;amp;工厂方法&lt;/h2&gt;&lt;p&gt;比如一个需要根据文件格式来创建不同parser，将配置读取到RuleConfig中的功能，简单工厂模式的实现如下。&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span&gt;23&lt;/span&gt;&lt;br/&gt;&lt;span&gt;24&lt;/span&gt;&lt;br/&gt;&lt;span&gt;25&lt;/span&gt;&lt;br/&gt;&lt;span&gt;26&lt;/span&gt;&lt;br/&gt;&lt;span&gt;27&lt;/span&gt;&lt;br/&gt;&lt;span&gt;28&lt;/span&gt;&lt;br/&gt;&lt;span&gt;29&lt;/span&gt;&lt;br/&gt;&lt;span&gt;30&lt;/span&gt;&lt;br/&gt;&lt;span&gt;31&lt;/span&gt;&lt;br/&gt;&lt;span&gt;32&lt;/span&gt;&lt;br/&gt;&lt;span&gt;33&lt;/span&gt;&lt;br/&gt;&lt;span&gt;34&lt;/span&gt;&lt;br/&gt;&lt;span&gt;35&lt;/span&gt;&lt;br/&gt;&lt;span&gt;36&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RuleConfigSource&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; RuleConfig &lt;span&gt;load&lt;/span&gt;&lt;span&gt;(String ruleConfigFilePath)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfigFileExtension);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;if&lt;/span&gt; (parser == &lt;span&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InvalidRuleConfigException(&lt;/span&gt;&lt;br/&gt;&lt;span&gt;              &lt;span&gt;&quot;Rule config file format is not supported: &quot;&lt;/span&gt; + ruleConfigFilePath);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;    String configText = &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;//从ruleConfigFilePath文件中读取配置文本到configText中&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    RuleConfig ruleConfig = parser.parse(configText);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;return&lt;/span&gt; ruleConfig;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  }&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;  &lt;span&gt;&lt;span&gt;private&lt;/span&gt; String &lt;span&gt;getFileExtension&lt;/span&gt;&lt;span&gt;(String filePath)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;//...解析文件名获取扩展名，比如rule.json，返回json&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;json&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RuleConfigParserFactory&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IRuleConfigParser &lt;span&gt;createParser&lt;/span&gt;&lt;span&gt;(String configFormat)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    IRuleConfigParser parser = &lt;span&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;json&quot;&lt;/span&gt;.equalsIgnoreCase(configFormat)) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      parser = &lt;span&gt;new&lt;/span&gt; JsonRuleConfigParser();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;xml&quot;&lt;/span&gt;.equalsIgnoreCase(configFormat)) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      parser = &lt;span&gt;new&lt;/span&gt; XmlRuleConfigParser();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;yaml&quot;&lt;/span&gt;.equalsIgnoreCase(configFormat)) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      parser = &lt;span&gt;new&lt;/span&gt; YamlRuleConfigParser();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;properties&quot;&lt;/span&gt;.equalsIgnoreCase(configFormat)) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      parser = &lt;span&gt;new&lt;/span&gt; PropertiesRuleConfigParser();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;return&lt;/span&gt; parser;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;也就是创建一个工厂类，专门用来「生产」parser。&lt;/p&gt;&lt;p&gt;这里如果就把创建parser的过程，放到load方法里，其实也不是不行。之所以拆出来，就是要把创建这一部分逻辑拆分开。所以，只有当创建逻辑比较复杂的时候才会使用工厂模式。&lt;/p&gt;&lt;p&gt;上边的实现还可以进一步优化，去除大量的if-else。&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;&lt;br/&gt;&lt;span&gt;19&lt;/span&gt;&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;&lt;br/&gt;&lt;span&gt;21&lt;/span&gt;&lt;br/&gt;&lt;span&gt;22&lt;/span&gt;&lt;br/&gt;&lt;span&gt;23&lt;/span&gt;&lt;br/&gt;&lt;span&gt;24&lt;/span&gt;&lt;br/&gt;&lt;span&gt;25&lt;/span&gt;&lt;br/&gt;&lt;span&gt;26&lt;/span&gt;&lt;br/&gt;&lt;span&gt;27&lt;/span&gt;&lt;br/&gt;&lt;span&gt;28&lt;/span&gt;&lt;br/&gt;&lt;span&gt;29&lt;/span&gt;&lt;br/&gt;&lt;span&gt;30&lt;/span&gt;&lt;br/&gt;&lt;span&gt;31&lt;/span&gt;&lt;br/&gt;&lt;span&gt;32&lt;/span&gt;&lt;br/&gt;&lt;span&gt;33&lt;/span&gt;&lt;br/&gt;&lt;span&gt;34&lt;/span&gt;&lt;br/&gt;&lt;span&gt;35&lt;/span&gt;&lt;br/&gt;&lt;span&gt;36&lt;/span&gt;&lt;br/&gt;&lt;span&gt;37&lt;/span&gt;&lt;br/&gt;&lt;span&gt;38&lt;/span&gt;&lt;br/&gt;&lt;span&gt;39&lt;/span&gt;&lt;br/&gt;&lt;span&gt;40&lt;/span&gt;&lt;br/&gt;&lt;span&gt;41&lt;/span&gt;&lt;br/&gt;&lt;span&gt;42&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RuleConfigSource&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; RuleConfig &lt;span&gt;load&lt;/span&gt;&lt;span&gt;(String ruleConfigFilePath)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;    IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;if&lt;/span&gt; (parserFactory == &lt;span&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; InvalidRuleConfigException(&lt;span&gt;&quot;Rule config file format is not supported: &quot;&lt;/span&gt; + ruleConfigFilePath);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    IRuleConfigParser parser = parserFactory.createParser();&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;    String configText = &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;//从ruleConfigFilePath文件中读取配置文本到configText中&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    RuleConfig ruleConfig = parser.parse(configText);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;return&lt;/span&gt; ruleConfig;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  }&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;  &lt;span&gt;&lt;span&gt;private&lt;/span&gt; String &lt;span&gt;getFileExtension&lt;/span&gt;&lt;span&gt;(String filePath)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;//...解析文件名获取扩展名，比如rule.json，返回json&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;json&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;//因为工厂类只包含方法，不包含成员变量，完全可以复用，&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RuleConfigParserFactoryMap&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;//工厂的工厂&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Map&amp;lt;String, IRuleConfigParserFactory&amp;gt; cachedFactories = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;  &lt;span&gt;static&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    cachedFactories.put(&lt;span&gt;&quot;json&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; JsonRuleConfigParserFactory());&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    cachedFactories.put(&lt;span&gt;&quot;xml&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; XmlRuleConfigParserFactory());&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    cachedFactories.put(&lt;span&gt;&quot;yaml&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; YamlRuleConfigParserFactory());&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    cachedFactories.put(&lt;span&gt;&quot;properties&quot;&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; PropertiesRuleConfigParserFactory());&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  }&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IRuleConfigParserFactory &lt;span&gt;getParserFactory&lt;/span&gt;&lt;span&gt;(String type)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;if&lt;/span&gt; (type == &lt;span&gt;null&lt;/span&gt; || type.isEmpty()) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase());&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;return&lt;/span&gt; parserFactory;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;这就是工厂方法模式，工厂方法模式实质上是为工厂类再创建一个简单工厂，也就是工厂的工厂，用来创建工厂类对象。&lt;/p&gt;&lt;p&gt;工厂模式的原理和实现都很简单，在实现时其实还有很多可以探究的细节，但在这里就不细说了。我们探讨的关键还是理解什么场景下应该用这种模式，它解决了什么问题。&lt;/p&gt;&lt;p&gt;对于工厂模式来说，应用的场景就是创建类的逻辑比较复杂时，比如需要有一堆if-else, 动态的决定要创建什么对象；或者虽然创建单个对象，但是创建本身的过程很复杂，调用方无需了解如何去创建。&lt;/p&gt;&lt;h2&gt;建造者&lt;/h2&gt;&lt;p&gt;建造者模式(Builder), 其实应用非常广泛，我们打开任何一个项目，都可以看到很多XXXBuilder.&lt;/p&gt;&lt;p&gt;建造者模式使用的场景是：一个类有多个可配置项，使用方可以自由选择其中若干个进行配置。&lt;/p&gt;&lt;p&gt;如果采用不同构造方法来实现这种效果，面对的就会说无穷无尽的组合。&lt;/p&gt;&lt;p&gt;而如果采用set方法来配置，那么首先当前类就彻底失去了对配置项的控制，调用方可以随时随地调用set方法。另外，如果需要在配置项被配置好之后进行一些合法性的校验，这种方式也无法实现。&lt;/p&gt;&lt;p&gt;这种情况下的解决方案就是建造者模式。&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;ResourcePoolConfig config = &lt;span&gt;new&lt;/span&gt; ResourcePoolConfig.Builder()&lt;/span&gt;&lt;br/&gt;&lt;span&gt; .setName(&lt;span&gt;&quot;dbconnectionpool&quot;&lt;/span&gt;) &lt;/span&gt;&lt;br/&gt;&lt;span&gt; .setMaxTotal(&lt;span&gt;16&lt;/span&gt;) &lt;/span&gt;&lt;br/&gt;&lt;span&gt; .setMaxIdle(&lt;span&gt;10&lt;/span&gt;) &lt;/span&gt;&lt;br/&gt;&lt;span&gt; .setMinIdle(&lt;span&gt;12&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt; .build();&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;实现也比较简单。&lt;/p&gt;&lt;p&gt;工厂模式是用来创建一组相关但不同的的对象，建造者模式则是对同一个对象进行不同方式的定制。&lt;/p&gt;&lt;h2&gt;单例&lt;/h2&gt;&lt;p&gt;关于单例是什么，怎么实现单例，作为经典的面试题，就不多说了。只说一下单例的问题，为什么单例主键变成了一种反模式。&lt;/p&gt;&lt;p&gt;单例的问题：&lt;/p&gt;&lt;p&gt;隐藏类之间的依赖关系；&lt;/p&gt;&lt;p&gt;同时，依赖的直接就是单例的实现，违反了基于接口而非实现的设计原则；&lt;/p&gt;&lt;p&gt;可测性不好: 无法被mock(Mockito中)；全局变量有可能导致测试之间互相影响；&lt;/p&gt;&lt;p&gt;不支持有参数的构造函数。&lt;/p&gt;&lt;p&gt;但是，单例模式的优点是有些场景下使用起来更简洁方便，所以也没必要直接就认定不能使用单例。&lt;/p&gt;&lt;h2&gt;代理&amp;amp;装饰器&lt;/h2&gt;&lt;p&gt;代理模式和被代理类实现同一个接口，负责在业务代码执行前后附加其他逻辑代码（比如性能监控、计数等），然后用委托的形式调用被代理类完成业务功能，从而实现业务代码和框架代码的解耦。&lt;/p&gt;&lt;p&gt;装饰器模式是通过继承被装饰类，来实现功能的增强。比如java中inputStream系列类，就是装饰器模式的应用。&lt;/p&gt;&lt;p&gt;实现层面，代理模式和装饰器模式几乎一样，但是其意图不同。&lt;/p&gt;&lt;p&gt;代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。&lt;/p&gt;&lt;p&gt;还是这个观点，对于设计模式，我们没必要扣字眼深究每种设计模式到底是什么，只要知道有这么一种技巧，可以处理类似的这种场景就可以了。&lt;/p&gt;&lt;h2&gt;适配器&lt;/h2&gt;&lt;p&gt;适配器模式很简单，我们可以直接看例子。&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;debug&lt;/span&gt;&lt;span&gt;(String msg)&lt;/span&gt; &lt;/span&gt;{ &lt;/span&gt;&lt;br/&gt;&lt;span&gt;logger.log(FQCN, Level.DEBUG, msg, &lt;span&gt;null&lt;/span&gt;); &lt;/span&gt;&lt;br/&gt;&lt;span&gt;} &lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;debug&lt;/span&gt;&lt;span&gt;(String format, Object arg)&lt;/span&gt; &lt;/span&gt;{ &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; (logger.isDebugEnabled()) { &lt;/span&gt;&lt;br/&gt;&lt;span&gt;FormattingTuple ft = MessageFormatter.format(format, arg); &lt;/span&gt;&lt;br/&gt;&lt;span&gt;logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable()); &lt;/span&gt;&lt;br/&gt;&lt;span&gt;} &lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;应用场景包括：&lt;/p&gt;&lt;p&gt;兼容老版本接口；&lt;/p&gt;&lt;p&gt;应对不同的输入；&lt;/p&gt;&lt;p&gt;封装有缺陷的接口设计；&lt;/p&gt;&lt;p&gt;…&lt;/p&gt;&lt;h2&gt;门面&lt;/h2&gt;&lt;p&gt;门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。这里主要是关系到一个接口的粒度应该有多大，从而平衡接口的通用性和易用性。&lt;/p&gt;&lt;p&gt;通常，粒度小的接口通用性肯定会好一些，但这样调用方就需要调用多个方法，必然不太好用。相反，如果接口粒度太大，就会有通用性不足的问题。&lt;/p&gt;&lt;p&gt;门面模式的作用就是解决这个问题。我是做在线教育的，有一个场景是在B端展示各种各样的题目，比如课前的题、课中的题、课后的题，每类中又分很多具体类型，每个类型有不同的数据来源。&lt;/p&gt;&lt;p&gt;这里，就需要权衡接口的通用性和可用性了。而门面模式刚好可以解决我们的问题。首先，我们要定义一个通用的模型，包括题干、参考答案、用户作答等，然后实现一批具体类型的接口。在此之上根据业务场景，封装一些门面层，门面层中只是简单的将子系统的数据组合起来。&lt;/p&gt;&lt;h2&gt;策略&lt;/h2&gt;&lt;p&gt;定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。&lt;/p&gt;&lt;p&gt;实现方式是定义一个策略接口和一组实现这个接口的策略，运行时可以根据一些条件动态的选择执行哪个策略。&lt;/p&gt;&lt;h2&gt;模板方法&lt;/h2&gt;&lt;p&gt;模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。&lt;/p&gt;&lt;p&gt;比如java的AbstractList 的addAll方法就是一个模板方法。&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;&lt;br/&gt;&lt;span&gt;8&lt;/span&gt;&lt;br/&gt;&lt;span&gt;9&lt;/span&gt;&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;addAll&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index, Collection&amp;lt;? extends E&amp;gt; c)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    rangeCheckForAdd(index);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;boolean&lt;/span&gt; modified = &lt;span&gt;false&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;for&lt;/span&gt; (E e : c) {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        add(index++, e);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        modified = &lt;span&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;return&lt;/span&gt; modified;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; index, E element)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; UnsupportedOperationException();&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h2&gt;观察者&lt;/h2&gt;&lt;p&gt;在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。也就是发布订阅模式。&lt;/p&gt;&lt;p&gt;观察者模式是一个比较抽象的模式，根据不同的应用场景和需求，有完全不同的实现方式，但是思想很容易理解，所以也就不列代码了。像我们使用mq, 也就是在使用观察者模式。&lt;/p&gt;&lt;h2&gt;责任链&lt;/h2&gt;&lt;p&gt;将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。&lt;/p&gt;&lt;p&gt;实际使用中，责任链模式的一种变体应用也很广泛，就是让链上的每个接收对象都处理一遍这个请求。&lt;/p&gt;&lt;p&gt;比如我们有一个拼装数据的逻辑，就是责任链变体的一个应用。&lt;/p&gt;&lt;figure&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;7&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td&gt;&lt;pre&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;fillUserDataCollection&lt;/span&gt;&lt;span&gt;(Map&amp;lt;Integer, UserDataCollection&amp;gt; userExpandMap, Map&amp;lt;Integer, UserDataCollection&amp;gt; originUserExpandMap)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;        &lt;span&gt;return&lt;/span&gt; !fillingServices&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                .stream()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                .map(filler -&amp;gt; filler.fillUserDataWithFallback(userExpandMap, originUserExpandMap))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                .collect(toSet())&lt;/span&gt;&lt;br/&gt;&lt;span&gt;                .contains(&lt;span&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    }&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;UserDataCollection中包含大量字段，每个fillingService负责其中一部分数据的补充。&lt;/p&gt;&lt;p&gt;责任链的核心思路就是拆分，将大类拆成小类。这也是解决代码复杂度的重要手段之一。&lt;/p&gt;&lt;h1&gt;经验总结&lt;/h1&gt;&lt;p&gt;对于如何写出好的代码，最关键的是要先建立起心理上的认知，知道什么是好代码，也有写好代码的意愿。在此基础上，要对面向对象的思想和各类设计原则有充分的理解，知道为什么好代码要符合这些原则。&lt;/p&gt;&lt;p&gt;实践上，写出好代码的最佳方式就是持续重构。一开始业务发展不明朗的时候，代码无法设计到最好是很正常的。而随着业务的发展，我们会逐渐意识到代码里存在的问题，这时候可以翻翻设计模式中有没有什么现成的解决方案，然后应用到自己的项目中。&lt;/p&gt;&lt;p&gt;最后，说一下，这篇文章中的很多内容实际上来自极客时间的专栏《设计模式之美》。我觉得这个专栏是讲设计模式最好的一个专栏，推荐大家也可以去看看。点击下方图片购买即可。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.7785829307568437&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xxBW79XJVvTtMGE9YezxUCR7ibfPicAAAYbAibg6LEGCLUsTRFjYHPEmO9KyQArHsOMoUHyNsFZxKdJKQwnMQCRgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1242&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f2378a4ead252d7c8fe07154b52bc277</guid>
<title>CompletableFuture 让你的代码免受阻塞之苦</title>
<link>https://toutiao.io/k/6sgy0vy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在大部分的CPU都是多核，我们都知道想要提升我们应用程序的运行效率，就必须得充分利用多核CPU的计算能力；Java早已经为我们提供了多线程的API，但是实现方式略微麻烦，今天我们就来看看Java8在这方面提供的改善。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;假设场景&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在你需要为在线教育平台提供一个查询用户详情的API，该接口需要返回用户的基本信息，标签信息，这两个信息存放在不同位置，需要远程调用来获取这两个信息；为了模拟远程调用，我们需要在代码里面延迟 1s;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public interface RemoteLoader {&lt;br/&gt;&lt;br/&gt;    String load();&lt;br/&gt;&lt;br/&gt;    default void &lt;span&gt;&lt;span&gt;delay&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        try {&lt;br/&gt;            Thread.sleep(1000L);&lt;br/&gt;        } catch (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public class CustomerInfoService implements RemoteLoader {&lt;br/&gt;&lt;br/&gt;    public String &lt;span&gt;&lt;span&gt;load&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        this.delay();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;基本信息&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public class LearnRecordService implements RemoteLoader {&lt;br/&gt;&lt;br/&gt;    public String &lt;span&gt;&lt;span&gt;load&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        this.delay();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;学习信息&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;同步方式实现版本&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们采用同步的方式来完成这个API接口，我们的实现代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Test&lt;br/&gt;public void &lt;span&gt;&lt;span&gt;testSync&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    long start = System.currentTimeMillis();&lt;br/&gt;    List&amp;lt;RemoteLoader&amp;gt; remoteLoaders = Arrays.asList(new CustomerInfoService(), new LearnRecordService());&lt;br/&gt;    List&amp;lt;String&amp;gt; customerDetail = remoteLoaders.stream().map(RemoteLoader::load).collect(toList());&lt;br/&gt;    System.out.println(customerDetail);&lt;br/&gt;    long end = System.currentTimeMillis();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;总共花费时间:&quot;&lt;/span&gt; + (end - start));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不出所料，因为调用的两个接口都是延迟了 1s ，所以结果大于2秒&lt;img data-ratio=&quot;0.2&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zGicf6vk3kaemSzAD7bHhK4yQuJOuWrSTria1w2Cciaj42W4dWjPTzQ9gNt5cIKfQSBhiaUHkDzHuGCABw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Future实现的版本&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们把这个例子用Java7提供的&lt;code&gt;Future&lt;/code&gt;来实现异步的版本，看下效果如何呢？代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Test&lt;br/&gt;public void &lt;span&gt;&lt;span&gt;testFuture&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    long start = System.currentTimeMillis();&lt;br/&gt;    ExecutorService executorService = Executors.newFixedThreadPool(2);&lt;br/&gt;    List&amp;lt;RemoteLoader&amp;gt; remoteLoaders = Arrays.asList(new CustomerInfoService(), new LearnRecordService());&lt;br/&gt;    List&amp;lt;Future&amp;lt;String&amp;gt;&amp;gt; futures = remoteLoaders.stream()&lt;br/&gt;            .map(remoteLoader -&amp;gt; executorService.submit(remoteLoader::load))&lt;br/&gt;            .collect(toList());&lt;br/&gt;&lt;br/&gt;    List&amp;lt;String&amp;gt; customerDetail = futures.stream()&lt;br/&gt;            .map(future -&amp;gt; {&lt;br/&gt;                try {&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; future.get();&lt;br/&gt;                } catch (InterruptedException | ExecutionException e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                }&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; null;&lt;br/&gt;            })&lt;br/&gt;            .filter(Objects::nonNull)&lt;br/&gt;            .collect(toList());&lt;br/&gt;    System.out.println(customerDetail);&lt;br/&gt;    long end = System.currentTimeMillis();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;总共花费时间:&quot;&lt;/span&gt; + (end - start));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次我们采用多线程的方式来改造了我们这个例子，结果还是比较满意的，时间大概花费了1s多一点&lt;img data-ratio=&quot;0.18625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zGicf6vk3kaemSzAD7bHhK4yQ9ALROVdMT42QJwoNb3IkRmicGzhzh40GnOQN4wuIU9Y5lzrWcYy0Xjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;注意：这里我分成了两个Stream，如何合在一起用同一个Stream，那么在用&lt;code&gt;future.get()&lt;/code&gt;的时候会导致阻塞，相当于提交一个任务执行完后才提交下一个任务，这样达不到异步的效果&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们可以看到虽然&lt;code&gt;Future&lt;/code&gt;达到了我们预期的效果，但是如果需要实现将两个异步的结果进行合并处理就稍微麻一些，这里就不细说，后面主要看下&lt;code&gt;CompletableFuture&lt;/code&gt;在这方面的改进&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Java8并行流&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上我们用的是Java8之前提供的方法来实现，接下来我们来看下Java8中提供的并行流来实习我们这个例子效果怎样呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Test&lt;br/&gt;public void &lt;span&gt;&lt;span&gt;testParallelStream&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    long start = System.currentTimeMillis();&lt;br/&gt;    List&amp;lt;RemoteLoader&amp;gt; remoteLoaders = Arrays.asList(new CustomerInfoService(), new LearnRecordService());&lt;br/&gt;    List&amp;lt;String&amp;gt; customerDetail = remoteLoaders.parallelStream().map(RemoteLoader::load).collect(toList());&lt;br/&gt;    System.out.println(customerDetail);&lt;br/&gt;    long end = System.currentTimeMillis();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;总共花费时间:&quot;&lt;/span&gt; + (end - start));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行的结果还是相当的满意，花费时间 1s 多点&lt;img data-ratio=&quot;0.17875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zGicf6vk3kaemSzAD7bHhK4yQciaglARgQBPdiaEjaibDHCRF9A6uPoBf55LTsY1liaHhMlvjywlxBJPL8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和Java8之前的实现对比，我们发现整个代码会更加的简洁；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们把我们的例子改变一下，查询用户详情的接口还需要返回视频观看记录，用户的标签信息，购买订单&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class WatchRecordService implements RemoteLoader {&lt;br/&gt;    @Override&lt;br/&gt;    public String &lt;span&gt;&lt;span&gt;load&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        this.delay();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;观看记录&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public class OrderService implements RemoteLoader {&lt;br/&gt;    @Override&lt;br/&gt;    public String &lt;span&gt;&lt;span&gt;load&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        this.delay();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;订单信息&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public class LabelService implements RemoteLoader {&lt;br/&gt;    @Override&lt;br/&gt;    public String &lt;span&gt;&lt;span&gt;load&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        this.delay();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;标签信息&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们继续使用Java8提供的并行流来实现，看下运行的结果是否理想&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Test&lt;br/&gt;public void &lt;span&gt;&lt;span&gt;testParallelStream2&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    long start = System.currentTimeMillis();&lt;br/&gt;    List&amp;lt;RemoteLoader&amp;gt; remoteLoaders = Arrays.asList(&lt;br/&gt;            new CustomerInfoService(),&lt;br/&gt;            new LearnRecordService(),&lt;br/&gt;            new LabelService(),&lt;br/&gt;            new OrderService(),&lt;br/&gt;            new WatchRecordService());&lt;br/&gt;    List&amp;lt;String&amp;gt; customerDetail = remoteLoaders.parallelStream().map(RemoteLoader::load).collect(toList());&lt;br/&gt;    System.out.println(customerDetail);&lt;br/&gt;    long end = System.currentTimeMillis();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;总共花费时间:&quot;&lt;/span&gt; + (end - start));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这次运行的结果不是太理想，花费时间超过了2秒&lt;img data-ratio=&quot;0.20875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zGicf6vk3kaemSzAD7bHhK4yQ8hbOibacBe5etWF2zWnNNEKG5ze65pj9fh9SRWaamDZic8ibzldRrpyBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;CompletableFuture&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;基本的用法&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Test&lt;br/&gt;public void &lt;span&gt;&lt;span&gt;testCompletableFuture&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    CompletableFuture&amp;lt;String&amp;gt; future = new CompletableFuture&amp;lt;&amp;gt;();&lt;br/&gt;    new Thread(() -&amp;gt; {&lt;br/&gt;        doSomething();&lt;br/&gt;        future.complete(&lt;span&gt;&quot;Finish&quot;&lt;/span&gt;);          //任务执行完成后 设置返回的结果&lt;br/&gt;    }).start();&lt;br/&gt;    System.out.println(future.join());      //获取任务线程返回的结果&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;private void &lt;span&gt;&lt;span&gt;doSomething&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;doSomething...&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种用法还有个问题，就是任务出现了异常，主线程会无感知，任务线程不会把异常给抛出来；这会导致主线程会一直等待，通常我们也需要知道出现了什么异常，做出对应的响应；改进的方式是在任务中try-catch所有的异常，然后调用&lt;code&gt;future.completeExceptionally(e)&lt;/code&gt; ，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Test&lt;br/&gt;public void testCompletableFuture() throws ExecutionException, InterruptedException {&lt;br/&gt;    CompletableFuture&amp;lt;String&amp;gt; future = new CompletableFuture&amp;lt;&amp;gt;();&lt;br/&gt;    new Thread(() -&amp;gt; {&lt;br/&gt;        try {&lt;br/&gt;            doSomething();&lt;br/&gt;            future.complete(&lt;span&gt;&quot;Finish&quot;&lt;/span&gt;);&lt;br/&gt;        } catch (Exception e) {&lt;br/&gt;            future.completeExceptionally(e);&lt;br/&gt;        }&lt;br/&gt;    }).start();&lt;br/&gt;    System.out.println(future.get());&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;private void &lt;span&gt;&lt;span&gt;doSomething&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;doSomething...&quot;&lt;/span&gt;);&lt;br/&gt;    throw new RuntimeException(&lt;span&gt;&quot;Test Exception&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从现在来看&lt;code&gt;CompletableFuture&lt;/code&gt;的使用过程需要处理的事情很多，不太简洁，你会觉得看起来很麻烦；但是这只是表象，Java8其实对这个过程进行了封装，提供了很多简洁的操作方式；接下来我们看下如何改造上面的代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Test&lt;br/&gt;public void testCompletableFuture2() throws ExecutionException, InterruptedException {&lt;br/&gt;    CompletableFuture&amp;lt;String&amp;gt; future = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        doSomething();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Finish&quot;&lt;/span&gt;;&lt;br/&gt;    });&lt;br/&gt;    System.out.println(future.get());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们采用了&lt;code&gt;supplyAsync&lt;/code&gt;，这下看起来简洁了许多，世界都明亮了; Java8不仅提供允许任务返回结果的&lt;code&gt;supplyAsync&lt;/code&gt;，还提供了没有返回值的&lt;code&gt;runAsync&lt;/code&gt;；让我们可以更加的关注业务的开发，不需要处理异常错误的管理&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;CompletableFuture异常处理&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果说主线程需要关心任务到底发生了什么异常，需要对其作出相应操作，这个时候就需要用到&lt;code&gt;exceptionally&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Test&lt;br/&gt;public void testCompletableFuture2() throws ExecutionException, InterruptedException {&lt;br/&gt;    CompletableFuture&amp;lt;String&amp;gt; future = CompletableFuture&lt;br/&gt;            .supplyAsync(() -&amp;gt; {&lt;br/&gt;                doSomething();&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Finish&quot;&lt;/span&gt;;&lt;br/&gt;            })&lt;br/&gt;            .exceptionally(throwable -&amp;gt; &lt;span&gt;&quot;Throwable exception message:&quot;&lt;/span&gt; + throwable.getMessage());&lt;br/&gt;    System.out.println(future.get());&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;使用CompletableFuture来完成我们查询用户详情的API接口&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Test&lt;br/&gt;public void testCompletableFuture3() throws ExecutionException, InterruptedException {&lt;br/&gt;    long start = System.currentTimeMillis();&lt;br/&gt;    List&amp;lt;RemoteLoader&amp;gt; remoteLoaders = Arrays.asList(&lt;br/&gt;            new CustomerInfoService(),&lt;br/&gt;            new LearnRecordService(),&lt;br/&gt;            new LabelService(),&lt;br/&gt;            new OrderService(),&lt;br/&gt;            new WatchRecordService());&lt;br/&gt;    List&amp;lt;CompletableFuture&amp;lt;String&amp;gt;&amp;gt; completableFutures = remoteLoaders&lt;br/&gt;            .stream()&lt;br/&gt;            .map(loader -&amp;gt; CompletableFuture.supplyAsync(loader::load))&lt;br/&gt;            .collect(toList());&lt;br/&gt;&lt;br/&gt;    List&amp;lt;String&amp;gt; customerDetail = completableFutures&lt;br/&gt;            .stream()&lt;br/&gt;            .map(CompletableFuture::join)&lt;br/&gt;            .collect(toList());&lt;br/&gt;    &lt;br/&gt;    System.out.println(customerDetail);&lt;br/&gt;    long end = System.currentTimeMillis();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;总共花费时间:&quot;&lt;/span&gt; + (end - start));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里依然是采用的两个Stream来完成的，执行的结果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.26125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zGicf6vk3kaemSzAD7bHhK4yQFWovU0sGEmWGXjsbzLL6xOLwsuOHJxhQhXIM8u6y9CvTWPcP3ia9PgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;result&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个结果不太满意，和并行流的结果差不多，消耗时间 2秒多点；在这种场景下我们用&lt;code&gt;CompletableFuture&lt;/code&gt;做了这么多工作，但是效果不理想，难道就有没有其他的方式可以让它再快一点吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决这个问题，我们必须深入了解下并行流和&lt;code&gt;CompletableFuture&lt;/code&gt;的实现原理，它们底层使用的线程池的大小都是CPU的核数&lt;code&gt;Runtime.getRuntime().availableProcessors()&lt;/code&gt;；那么我们来尝试一下修改线程池的大小，看看效果如何？&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;自定义线程池，优化CompletableFuture&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用并行流无法自定义线程池，但是&lt;code&gt;CompletableFuture&lt;/code&gt;可以&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Test&lt;br/&gt;public void testCompletableFuture4() throws ExecutionException, InterruptedException {&lt;br/&gt;    long start = System.currentTimeMillis();&lt;br/&gt;    List&amp;lt;RemoteLoader&amp;gt; remoteLoaders = Arrays.asList(&lt;br/&gt;            new CustomerInfoService(),&lt;br/&gt;            new LearnRecordService(),&lt;br/&gt;            new LabelService(),&lt;br/&gt;            new OrderService(),&lt;br/&gt;            new WatchRecordService());&lt;br/&gt;    &lt;br/&gt;    ExecutorService executorService = Executors.newFixedThreadPool(Math.min(remoteLoaders.size(), 50));&lt;br/&gt;    &lt;br/&gt;    List&amp;lt;CompletableFuture&amp;lt;String&amp;gt;&amp;gt; completableFutures = remoteLoaders&lt;br/&gt;            .stream()&lt;br/&gt;            .map(loader -&amp;gt; CompletableFuture.supplyAsync(loader::load, executorService))&lt;br/&gt;            .collect(toList());&lt;br/&gt;&lt;br/&gt;    List&amp;lt;String&amp;gt; customerDetail = completableFutures&lt;br/&gt;            .stream()&lt;br/&gt;            .map(CompletableFuture::join)&lt;br/&gt;            .collect(toList());&lt;br/&gt;&lt;br/&gt;    System.out.println(customerDetail);&lt;br/&gt;    long end = System.currentTimeMillis();&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;总共花费时间:&quot;&lt;/span&gt; + (end - start));&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用自定义线程池，设置最大的线程池数量50，来看下执行的结果&lt;img data-ratio=&quot;0.27875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zGicf6vk3kaemSzAD7bHhK4yQib8giahCmNR2hfO15vCHiaycXajib6mKucjWJZvySduiahWiagFFDribicQC0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这下执行的结果比较满意了，1秒多点；理论上来说这个结果可以一直持续，直到达到线程池的大小50&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;并行流和&lt;code&gt;CompletableFuture&lt;/code&gt;两者该如何选择&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两者如何选择主要看任务类型，建议&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果你的任务是计算密集型的，并且没有I/O操作的话，那么推荐你选择Stream的并行流，实现简单并行效率也是最高的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果你的任务是有频繁的I/O或者网络连接等操作，那么推荐使用&lt;code&gt;CompletableFuture&lt;/code&gt;，采用自定义线程池的方式，根据服务器的情况设置线程池的大小，尽可能的让CPU忙碌起来&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;&lt;code&gt;CompletableFuture&lt;/code&gt;的其他常用方法&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;thenApply、thenApplyAsync: 假如任务执行完成后，还需要后续的操作，比如返回结果的解析等等；可以通过这两个方法来完成&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;thenCompose、thenComposeAsync: 允许你对两个异步操作进行流水线的操作，当第一个操作完成后，将其结果传入到第二个操作中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;thenCombine、thenCombineAsync：允许你把两个异步的操作整合；比如把第一个和第二个操作返回的结果做字符串的连接操作&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Java8并行流的使用方式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CompletableFuture的使用方式、异常处理机制，让我们有机会管理任务执行中发送的异常&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Java8并行流和&lt;code&gt;CompletableFuture&lt;/code&gt;两者该如何选择&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;CompletableFuture&lt;/code&gt;的常用方法&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>