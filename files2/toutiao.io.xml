<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>5965b77f84a8765a13b21e00b6c33903</guid>
<title>当下分布式文件系统架构对比</title>
<link>https://toutiao.io/k/nidzr35</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post_content markdown&quot;&gt;&lt;p&gt;本文源自 Juicedata 创始人 &amp;amp; CEO Davies 在上海 Linux 用户组（SHLUG）的月度分享（2018/6/23）。&lt;/p&gt;&lt;h1 id=&quot;什么是文件系统&quot;&gt;什么是文件系统？&lt;/h1&gt;&lt;p&gt;文件系统是计算机中一个非常重要的组件，为存储设备提供一致的访问和管理方式。在不同的操作系统中，文件系统会有一些差别，但也有一些共性几十年都没怎么变化：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;数据是以文件的形式存在，提供 Open、Read、Write、Seek、Close 等API 进行访问；&lt;/li&gt;&lt;li&gt;文件以树形目录进行组织，提供原子的重命名（Rename）操作改变文件或者目录的位置。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;文件系统提供的访问和管理方法支撑了绝大部分的计算机应用，Unix 的“万物皆文件”的理念更是凸显了它的重要地位。文件系统的复杂性使得它的可扩展性未能跟得上互联网的高速发展，极大简化了的对象存储及时填补了空缺得以快速发展起来。因为对象存储缺乏树状结构也不支持原子重命名操作，跟文件系统有很大的差别，本文暂不讨论。&lt;/p&gt;&lt;h1 id=&quot;单机文件系统的挑战&quot;&gt;单机文件系统的挑战&lt;/h1&gt;&lt;p&gt;绝大多数文件系统都是单机的，在单机操作系统内为一个或者多个存储设备提供访问和管理。随着互联网的高速发展，单机文件系统面临很多的挑战：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;共享：无法同时为分布在多个机器中的应用提供访问，于是有了 NFS 协议，可以将单机文件系统通过网络的方式同时提供给多个机器访问。&lt;/li&gt;&lt;li&gt;容量：无法提供足够空间来存储数据，数据只好分散在多个隔离的单机文件系统里。&lt;/li&gt;&lt;li&gt;性能：无法满足某些应用需要非常高的读写性能要求，应用只好做逻辑拆分同时读写多个文件系统。&lt;/li&gt;&lt;li&gt;可靠性：受限于单个机器的可靠性，机器故障可能导致数据丢失。&lt;/li&gt;&lt;li&gt;可用性：受限于单个操作系统的可用性，故障或者重启等运维操作会导致不可用。&lt;/li&gt;&lt;li&gt;随着互联网的高速发展，这些问题变得日益突出，涌现出了一些分布式文件系统来应对这些挑战。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;下面介绍几个我了解过的分布式文件系统的基本架构，并比较不同架构的优点和局限。&lt;/p&gt;&lt;h1 id=&quot;glusterfs&quot;&gt;GlusterFS&lt;/h1&gt;&lt;p&gt;GlusterFS 是由美国的 Gluster 公司开发的 POSIX 分布式文件系统（以 GPL 开源），2007年发布第一个公开版本，2011年被 Redhat 收购。&lt;/p&gt;&lt;p&gt;它的基本思路就是通过一个无状态的中间件把多个单机文件系统融合成统一的名字空间（namespace）提供给用户。这个中间件是由一系列可叠加的转换器（Translator）实现，每个转换器解决一个问题，比如数据分布、复制、拆分、缓存、锁等等，用户可以根据具体的应用场景需要灵活配置。比如一个典型的分布式卷如下图所示：&lt;/p&gt;&lt;p/&gt;&lt;small class=&quot;d-flex justify-content-center&quot;&gt;图片来源：&lt;a href=&quot;https://docs.gluster.org/en/latest/Quick-Start-Guide/Architecture/&quot;&gt;https://docs.gluster.org/en/latest/Quick-Start-Guide/Architecture/&lt;/a&gt;&lt;/small&gt;&lt;p&gt;Server1 和 Server2 构成有 2 副本的 Volume0，Server3 和 Server4 构成 Volume1，它们再融合成有更大空间的分布式卷。&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;数据文件最终以相同的目录结构保存在单机文件系统上，不用担心 GlusterFS 的不可用导致数据丢失。&lt;/li&gt;&lt;li&gt;没有明显的单点问题，可线性扩展。&lt;/li&gt;&lt;li&gt;对大量小文件的支持估计还不错。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;挑战：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;这种结构是相对静态的，不容易调整，也要求各个存储节点有相同的配置，当数据或者访问不均衡时没法进行空间或者负载调整。故障恢复能力也比较弱，比如 Server1 故障时，Server2 上的文件就没办法在健康的 3 或者 4上增加拷贝保障数据可靠。&lt;/li&gt;&lt;li&gt;因为缺乏独立的元数据服务，要求所有存储节点都会有完整的数据目录结构，遍历目录或者做目录结构调整时需要访问所有节点才能得到正确结果，导致整个系统的可扩展能力有限，扩展到几十个节点时还行，很难有效地管理上百个节点。&lt;/li&gt;&lt;/ol&gt;&lt;h1 id=&quot;cephfs&quot;&gt;CephFS&lt;/h1&gt;&lt;p&gt;CephFS 始于 Sage Weil 的博士论文研究，目标是实现分布式的元数据管理以支持 EB 级别数据规模。2012年，Sage Weil 成立了 InkTank 继续支持 CephFS 的开发，于 2014年被 Redhat 收购。直到 2016 年，CephFS 才发布可用于生产环境的稳定版（CephFS 的元数据部分仍然是单机的）。现在，CephFS 的分布式元数据仍然不成熟。&lt;/p&gt;&lt;p&gt;Ceph 是一个分层的架构，底层是一个基于 CRUSH（哈希）的分布式对象存储，上层提供对象存储（RADOSGW）、块存储（RDB）和文件系统（CephFS）三个API，如下图所示：&lt;/p&gt;&lt;p/&gt;&lt;small class=&quot;d-flex justify-content-center&quot;&gt;图片来源：&lt;a href=&quot;https://en.wikipedia.org/wiki/Ceph_(software)&quot;&gt;https://en.wikipedia.org/wiki/Ceph_(software)&lt;/a&gt;&lt;/small&gt;&lt;p&gt;用一套存储系统来满足多个不同场景的存储需求（虚拟机镜像、海量小文件和通用文件存储）还是非常吸引人的，但因为系统的复杂性需要很强的运维能力才能支撑，实际上目前只有块存储还是比较成熟应用得比较多，对象存储和文件系统都不太理想，听到一些使用案例用过一段时间后就放弃了。&lt;/p&gt;&lt;p&gt;CephFS 的架构如下图所示：&lt;/p&gt;&lt;p/&gt;&lt;small class=&quot;d-flex justify-content-center&quot;&gt;图片来源：&lt;a href=&quot;https://en.wikipedia.org/wiki/Ceph_(software)&quot;&gt;https://en.wikipedia.org/wiki/Ceph_(software)&lt;/a&gt;&lt;/small&gt;&lt;p&gt;CephFS 是由 MDS（Metadata Daemon) 实现的，它是一个或者多个无状态的元数据服务，从底层的 OSD 加载文件系统的元信息，并缓存到内存中以提高访问速度。因为 MDS 是无状态的，可以配置多个备用节点来实现 HA，相对比较容易。不过备份节点没有缓存，需要重新预热，有可能故障恢复时间会比较长。&lt;/p&gt;&lt;p&gt;因为从存储层加载或者写入数据会比较慢，MDS 必须使用多线程来提高吞吐量，各种并发的文件系统操作导致复杂度大大上升，容易发生死锁，或者因为 IO 比较慢导致的性能大幅下降。为了获得比较好的性能，MDS 往往需要有足够多的内存来缓存大部分元数据，这也限制了它实际的支撑能力。&lt;/p&gt;&lt;p&gt;当有多个活跃的 MDS 时，目录结构中的一部分（子树）可以动态的分配到某个MDS并完全由它来处理相关请求，以达到水平扩展的目的。多个活跃之前，不可避免地需要各自锁机制来协商对子树的所有权，以及通过分布式事务来实现跨子树的原子重命名，这些实现起来都是非常复杂的。目前最新的官方文档仍然不推荐使用多个 MDS（作为备份是可以的）。&lt;/p&gt;&lt;h1 id=&quot;gfs&quot;&gt;GFS&lt;/h1&gt;&lt;p&gt;Google 的 GFS 是分布式文件系统中的先驱和典型代表，由早期的 BigFiles 发展而来。在 2003 年发表的论文中详细阐述了它的设计理念和细节，对业界影响非常大，后来很多分布式文件系统都是参照它的设计。&lt;/p&gt;&lt;p&gt;顾名思义，BigFiles/GFS 是为大文件优化设计的，并不适合平均文件大小在 1MB 以内的场景。GFS的架构入下图所示。&lt;/p&gt;&lt;p/&gt;&lt;small class=&quot;d-flex justify-content-center&quot;&gt;图片来源：&lt;a href=&quot;https://en.wikipedia.org/wiki/Google_File_System&quot;&gt;https://en.wikipedia.org/wiki/Google_File_System&lt;/a&gt;&lt;/small&gt;&lt;p&gt;GFS 有一个 Master 节点来管理元数据（全部加载到内存，快照和更新日志写到磁盘），文件划分成 64MB 的 Chunk 存储到几个 ChunkServer 上（直接使用单机文件系统）。文件只能追加写，不用担心 Chunk 的版本和一致性问题（可以用长度当做版本）。这个使用完全不同的技术来解决元数据和数据的设计使得系统的复杂度大大简化，也有足够的扩展能力（如果平均文件大小大于 256MB，Master 节点每 GB 内存可以支撑约 1PB 的数据量）。放弃支持 POSIX 文件系统的部分功能（比如随机写、扩展属性、硬链接等）也进一步简化了系统复杂度，以换取更好的系统性能、鲁棒性和可扩展性。&lt;/p&gt;&lt;p&gt;因为 GFS 的成熟稳定，使得 Google 可以更容易地构建上层应用（MapReduce、BigTable等）。后来，Google 开发了拥有更强可扩展能力的下一代存储系统 Colossus，把元数据和数据存储彻底分离，实现了元数据的分布式（自动 Sharding），以及使用Reed Solomon编码来降低存储空间占用从而降低成本。&lt;/p&gt;&lt;h1 id=&quot;hdfs&quot;&gt;HDFS&lt;/h1&gt;&lt;p&gt;出自 Yahoo 的 Hadoop 算是 Google 的 GFS、MapReduce 等的开源Java实现版，HDFS 也是基本照搬 GFS 的设计，这里就不再重复了，下图是HDFS的架构图：&lt;/p&gt;&lt;p&gt;HDFS的可靠性和可扩展能力还是非常不错的，有不少几千节点和 100PB 级别的部署，支撑大数据应用表现还是很不错的，少有听说丢数据的案例（因为没有配置回收站导致数据被误删的除外）。&lt;/p&gt;&lt;p&gt;HDFS 的 HA 方案是后来补上的，做得比较复杂，以至于最早做这个 HA 方案的 Facebook 在很长一段时间（至少3年）内都是手动做故障切换（不信任自动故障切换）。&lt;/p&gt;&lt;p&gt;因为 NameNode 是 Java 实现的，依赖于预先分配的堆内存大小，分配不足容易触发 Full GC 而影响整个系统的性能。有一些团队尝试把它用 C++ 重写了，但还没看到有成熟的开源方案。&lt;/p&gt;&lt;p&gt;HDFS 也缺乏成熟的非 Java 客户端，使得大数据（Hadoop等工具）以外的场景（比如深度学习等）使用起来不太方便。&lt;/p&gt;&lt;h1 id=&quot;moosefs&quot;&gt;MooseFS&lt;/h1&gt;&lt;p&gt;MooseFS 是来自波兰的开源分布式 POSIX 文件系统，也是参照了 GFS 的架构，实现了绝大部分 POSIX 语义和 API，通过一个非常成熟的 FUSE 客户端挂载后可以像本地文件系统一样访问。MooseFS 的架构如下图所示：&lt;/p&gt;&lt;p&gt;MooseFS 支持快照，用它来做数据备份或者备份恢复等还是恢复方便的。&lt;/p&gt;&lt;p&gt;MooseFS 是由 C 实现的，Master 是个异步事件驱动的单线程，类似于 Redis。不过网络部分使用的是 poll 而不是更高效的 epoll，导致并发到 1000 左右时 CPU 消耗非常厉害。&lt;/p&gt;&lt;p&gt;开源的社区版没有HA，是通过 metalogger 来实现异步冷备，闭源的收费版有 HA。&lt;/p&gt;&lt;p&gt;为了支持随机写操作，MooseFS 中的 chunk 是可以修改的，通过一套版本管理机制来保证数据一致性，这个机制比较复杂容易出现诡异问题（比如集群重启后可能会有少数 chunk 实际副本数低于预期）。&lt;/p&gt;&lt;h1 id=&quot;juicefs&quot;&gt;JuiceFS&lt;/h1&gt;&lt;p&gt;上面说的 GFS、HDFS 和 MooseFS 都是针对自建机房这种软硬件环境设计的，将数据的可靠性和节点可用性合在一起用多机多副本的方式解决。但是在公有云或者私有云的虚拟机里，块设备已经是具有三副本可靠性设计的虚拟块设备，如果再通过多机多副本的方式来做，会导致数据的成本居高不下（实际上是 9 个拷贝）。&lt;/p&gt;&lt;p&gt;于是我们针对公有云，改进 HDFS 和 MooseFS 的架构，设计了 JuiceFS，架构如下图所示：&lt;/p&gt;&lt;p&gt;JuiceFS 使用公有云中已有的对象存储来替换 DataNode 和 ChunkServer，实现一个完全弹性的 Serverless 的存储系统。公有云的对象存储已经很好地解决了大规模数据的安全高效存储，JuiceFS 只需要专注元数据的管理，也大大降低了元数据服务的复杂度（GFS 和 MooseFS 的 master 要同时解决元数据的存储和数据块的健康管理）。我们也对元数据部分做了很多改进，从一开始就实现了基于 Raft 的高可用。要真正提供一个高可用高性能的服务，元数据的管理和运维仍然是很有挑战的，元数据是以服务的形式提供给用户。因为 POSIX 文件系统 API 是应用最最广泛的 API，我们基于 FUSE 实现了高度 POSIX 兼容的客户端，用户可以通过一个命令行工具把 JuiceFS 挂载到 Linux 或者 macOS 中，像本地文件系统一样快速访问。&lt;/p&gt;&lt;p&gt;上图中右边虚线部分是负责数据存储和访问的部分，涉及用户的数据隐私，它们是完全在客户自己的账号和网络环境中，不会跟元数据服务接触。我们（Juicedata）没有任何方法接触到客户的内容（元数据除外，请不要把敏感内容放到文件名里）。&lt;/p&gt;&lt;h1 id=&quot;小结&quot;&gt;小结&lt;/h1&gt;&lt;p&gt;以上简要介绍了下我所了解的几个分布式文件系统的架构，把他们按照出现的时间顺序放在下面的图里（箭头表示后参考了前者或者是新一代版本）：&lt;/p&gt;&lt;p&gt;上图中上部分蓝色的几个文件下主要是给大数据场景使用的，实现的是 POSIX 的子集，而下面绿色的几个是 POSIX 兼容的文件系统。&lt;/p&gt;&lt;p&gt;他们中以 GFS 为代表的元数据和数据分离的系统设计能够有效平衡系统的复杂度，有效解决大规模数据的存储问题（通常也都是大文件），有更好的可扩展性。这个架构下支持元数据的分布式存储的 Colossus 和 WarmStorage 更是具有无限的可扩展能力。&lt;/p&gt;&lt;p&gt;JuiceFS 作为后来者，学习了 MooseFS 实现分布式 POSIX 文件系统的方式，也学习了 Facebook 的 WarmStorage 等元数据和数据彻底分开的思路，希望为公有云或者私有云等场景下提供最好的分布式存储体验。JuiceFS 通过将数据存储到对象存储的方式，有效避免了使用以上分布式文件系统时的双层冗余（块存储的冗余和分布式系统的多机冗余）导致的成本过高问题。JuiceFS 还支持所有的公有云，不用担心某个云服务锁定，还能平滑地在公有云或者区之间迁移数据。&lt;/p&gt;&lt;p&gt;最后，如果你手上有公有云账号，&lt;a href=&quot;https://juicefs.com/accounts/register&quot;&gt;来 JuiceFS 注册一下&lt;/a&gt;，5 分钟就可以给你的虚拟机（甚至自己的 macOS）挂载上一个 PB 级容量的文件系统了。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9e68f96d6f43288819b895750e32705a</guid>
<title>面试官：为什么 Go 的负载因子是 6.5？</title>
<link>https://toutiao.io/k/mwuuo10</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是煎鱼。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近我有一个朋友，在网上看到一个有趣的&lt;strong&gt;段子&lt;/strong&gt;，引发了我一些兴趣。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5602536997885835&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4iaLMulj7LUetkJFyS01S7TqI4Ne3zaLaoDN0EibvVh1mqvRt01VmA5LNjnEp0maDgwmC8Rrib5Mfe4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;946&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;听说是在最后的闲聊、吹水、聊人生、乱扯环节了，不是在技术环节了，所以大家也不用太在意什么技术评估法则（别杠）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;煎鱼作为一名技术号主，&lt;strong&gt;看到这里的 6.5，就想给大家挖一挖&lt;/strong&gt;，这到底是何物，和大家一同学习和增长知识！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.5 是什么&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上在 Go 语言中，就存在 6.5 这一概念，与 map 存在直接关系，因此我们需要先了解 map 的基本数据结构，再介绍 6.5 的背景和由来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开始学习 6.5 的前世今生吧！&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;了解 map 底层&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我以前在写《深入理解 Go map：初始化和访问元素》时有介绍过 map 的基础数据结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本结构如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.086&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4iaLMulj7LUetkJFyS01S7TqUsKoqG4C5WKHu5Dms3ibLvkbXP3DsOibFjlTFsVlH0QUcIpW2pjUTHOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;figcaption&gt;map 基本数据结构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中重要的一个基本单位是 hmap：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; hmap &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; count     &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; flags     &lt;span&gt;uint8&lt;/span&gt;&lt;br/&gt; B         &lt;span&gt;uint8&lt;/span&gt;&lt;br/&gt; noverflow &lt;span&gt;uint16&lt;/span&gt;&lt;br/&gt; hash0     &lt;span&gt;uint32&lt;/span&gt;&lt;br/&gt; buckets    unsafe.Pointer&lt;br/&gt; oldbuckets unsafe.Pointer&lt;br/&gt; nevacuate  &lt;span&gt;uintptr&lt;/span&gt;&lt;br/&gt; extra *mapextra&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; mapextra &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; overflow    *[]*bmap&lt;br/&gt; oldoverflow *[]*bmap&lt;br/&gt; nextOverflow *bmap&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;count：map 的大小，也就是 len() 的值，代指 map 中的键值对个数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;flags：状态标识，主要是 goroutine 写入和扩容机制的相关状态控制。并发读写的判断条件之一就是该值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;B：&lt;strong&gt;桶，最大可容纳的元素数量，值为 负载因子（默认 6.5） * 2 ^ B，是 2 的指数&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;noverflow：溢出桶的数量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;hash0：哈希因子。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;buckets：保存当前桶数据的指针地址（指向一段连续的内存地址，主要存储键值对数据）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;oldbuckets，保存旧桶的指针地址。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;nevacuate：迁移进度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;extra：原有 buckets 满载后，会发生扩容动作，在 Go 的机制中使用了增量扩容，如下为细项：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;overflow 为 hmap.buckets （当前）溢出桶的指针地址。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;oldoverflow 为 hmap.oldbuckets （旧）溢出桶的指针地址。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;nextOverflow 为空闲溢出桶的指针地址。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们关注到 hmap 的 B 字段，其值就是 6.5，他就是我们在苦苦寻找的 6.5，但他又是什么呢？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是负载因子&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;B 值，这里就涉及到一个概念：&lt;strong&gt;负载因子（load factor），用于衡量当前哈希表中空间占用率的核心指标&lt;/strong&gt;，也就是每个 bucket 桶存储的平均元素个数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外负载因子&lt;strong&gt;与扩容、迁移&lt;/strong&gt;等重新散列（rehash）行为有直接关系：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在程序运行时，会不断地进行插入、删除等，会导致 bucket 不均，内存利用率低，需要迁移。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在程序运行时，出现负载因子过大，需要做扩容，解决 bucket 过大的问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;负载因子是哈希表中的一个重要指标，在各种版本的哈希表实现中都有类似的东西，主要目的是&lt;strong&gt;为了平衡 buckets 的存储空间大小和查找元素时的性能高低&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在接触各种哈希表时都可以关注一下，做不同的对比，看看各家的考量。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么是 6.5&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解是什么后，我们进一步深挖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么 Go 语言中哈希表的负载因子是 6.5，为什么不是 8 ，也不是 1。这里面有可靠的数据支撑吗？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;测试报告&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上这是 Go 官方的经过认真的测试得出的数字，一起来看看官方的这份测试报告。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;报告中共包含 4 个关键指标，如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;loadFactor&lt;/th&gt;&lt;th&gt;%overflow&lt;/th&gt;&lt;th&gt;bytes/entry&lt;/th&gt;&lt;th&gt;hitprobe&lt;/th&gt;&lt;th&gt;missprobe&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;4.00&lt;/td&gt;&lt;td&gt;2.13&lt;/td&gt;&lt;td&gt;20.77&lt;/td&gt;&lt;td&gt;3.00&lt;/td&gt;&lt;td&gt;4.00&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;4.50&lt;/td&gt;&lt;td&gt;4.05&lt;/td&gt;&lt;td&gt;17.30&lt;/td&gt;&lt;td&gt;3.25&lt;/td&gt;&lt;td&gt;4.50&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5.00&lt;/td&gt;&lt;td&gt;6.85&lt;/td&gt;&lt;td&gt;14.77&lt;/td&gt;&lt;td&gt;3.50&lt;/td&gt;&lt;td&gt;5.00&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;5.50&lt;/td&gt;&lt;td&gt;10.55&lt;/td&gt;&lt;td&gt;12.94&lt;/td&gt;&lt;td&gt;3.75&lt;/td&gt;&lt;td&gt;5.50&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;6.00&lt;/td&gt;&lt;td&gt;15.27&lt;/td&gt;&lt;td&gt;11.67&lt;/td&gt;&lt;td&gt;4.00&lt;/td&gt;&lt;td&gt;6.00&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;6.50&lt;/td&gt;&lt;td&gt;20.90&lt;/td&gt;&lt;td&gt;10.79&lt;/td&gt;&lt;td&gt;4.25&lt;/td&gt;&lt;td&gt;6.50&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;7.00&lt;/td&gt;&lt;td&gt;27.14&lt;/td&gt;&lt;td&gt;10.15&lt;/td&gt;&lt;td&gt;4.50&lt;/td&gt;&lt;td&gt;7.00&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;7.50&lt;/td&gt;&lt;td&gt;34.03&lt;/td&gt;&lt;td&gt;9.73&lt;/td&gt;&lt;td&gt;4.75&lt;/td&gt;&lt;td&gt;7.50&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;8.00&lt;/td&gt;&lt;td&gt;41.10&lt;/td&gt;&lt;td&gt;9.40&lt;/td&gt;&lt;td&gt;5.00&lt;/td&gt;&lt;td&gt;8.00&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;loadFactor：负载因子，也有叫装载因子。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;%overflow：溢出率，有溢出 bukcet 的百分比。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;bytes/entry：每对 key/elem 的开销字节数.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;hitprobe：查找一个存在的 key 时，要查找的平均个数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;missprobe：查找一个不存在的 key 时，要查找的平均个数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;选择数值&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结合测试报告一看，好家伙，不测不知道，一测吓一跳，有依据了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 官方发现：&lt;strong&gt;负载因子太大了，会有很多溢出的桶。太小了，就会浪费很多空间&lt;/strong&gt;（too large and we have lots of overflow buckets, too small and we waste a lot of space）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5058236272878536&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4iaLMulj7LUetkJFyS01S7TqwghNxRjViasYFrSkb45trFv1z3Z0BJT1yso6D59TnCqy1dojHScwtgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1202&quot;/&gt;&lt;figcaption&gt;来自 Go 官方源码说明&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据这份测试结果和讨论，Go 官方把 Go 中的 map 的负载因子硬编码为 6.5，这就是 6.5 的选择缘由。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这意味着在 Go 语言中，&lt;strong&gt;当 B（bucket）平均每个存储的元素大于或等于 6.5 时，就会触发扩容行为&lt;/strong&gt;，这是作为我们用户对这个数值最近的接触。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在今天这篇文章中，我们先快速了解了 Go 语言中 map 的基本数据结构和设计，这和我们要解释的问题紧密相关。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;紧接着针对开头所提出的 6.5，进行了介绍和说明，这其实是 map 中的负载因子。其数值的确定来源于 Go 官方的测试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么是 6.5，你懂了吗？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;参考&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;src/runtime/map.go&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;深度解析golang map&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;golang中map底层B值的计算逻辑&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxMDI4MDc1NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4iac2xQZIq5icSiaTepuae8zLIUMiaxibbUM8ic735ewo6e89GRtjGbUBlgNYibwCjAicglQcvz6dCQ6yTKOw/0?wx_fmt=png&quot; data-nickname=&quot;脑子进煎鱼了&quot; data-alias=&quot;eddycjy&quot; data-signature=&quot;分享计算机基础、Go 语言、微服务架构和系统设计；著有图书《Go 语言编程之旅》。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;关注煎鱼，吸取他的知识 👆&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.07106598984771574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/486RHs1WbcgGib6o96dHbvGUGGwPicd8wusUGH1cXR29tM4bO0lNzialzkQhvU6m5ZUdaKibmcF2OQayjMe9Bia6iaXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;394&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你好，我是煎鱼。高一折腾过前端，参加过国赛拿了奖，大学搞过 PHP。现在整 Go，在公司负责微服务架构等相关工作推进和研发。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;从大学开始靠自己赚生活费和学费，到出版 Go 畅销书《Go 语言编程之旅》，再到获得 GOP（Go 领域最有观点专家）荣誉，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUxMDI4MDc1NA==&amp;amp;mid=2247483854&amp;amp;idx=1&amp;amp;sn=ec422fbf4d846975f2930ddeb5e81373&amp;amp;chksm=f9041493ce739d85a4b987eece14da627206cdad798f645cc770868312e4a22b6df24804f186&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;点击蓝字查看我的出书之路&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;点击蓝字查看我的出书之路&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;日常分享高质量文章，输出 Go 面试、工作经验、架构设计，&lt;span&gt;加微信拉读者交流群，记得点赞！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot; aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_title&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p role=&quot;option&quot; aria-labelledby=&quot;js_a11y_reward_qr_word js_a11y_comma js_a11y_reward_qr_title js_a11y_reward_qr_money&quot; aria-describedby=&quot;js_a11y_reward_qr_tips &quot; class=&quot;reward_tips&quot; id=&quot;js_a11y_reward_qr_word&quot;&gt;来一个反馈！&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img alt=&quot;赞赏二维码&quot; class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_tips&quot; class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c915cda33454c2e2db11ecfd2ae11ee5</guid>
<title>流式计算框架 MegFlow 开源，帮助铲屎官实现花样宠溺</title>
<link>https://toutiao.io/k/gll08ju</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-hnrfcf&quot; options=&quot;[object Object]&quot;&gt;&lt;p&gt;关于程序员为什么喜欢养猫的回答，网友们给出了很多答案，比如一边吸猫一边写代码，效率更高；养猫不容易脱发；更容易交到女朋友……&lt;/p&gt;&lt;p&gt;当然，除了喜欢养猫，程序员也喜欢开脑洞，发挥自己的专长，给“猫主子们”安排上各种高科技——自动投喂机、自动饮食机、自动按摩仪……甚至在训模型的时候用猫来做测试，识别猫咪的情绪、听懂猫咪语言。&lt;/p&gt;&lt;p&gt;现在就有一款 AI 应用，研发初衷只是铲屎官程序员想要为“主子”实现猫咪围栏识别，开箱即用背后的能力正是来自 MegFlow 流式计算框架。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-2e5486cadac557160bb941d71842d304_b.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;600&quot; data-rawheight=&quot;1080&quot; data-thumbnail=&quot;https://pic1.zhimg.com/v2-2e5486cadac557160bb941d71842d304_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-2e5486cadac557160bb941d71842d304_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;600&quot; data-rawheight=&quot;1080&quot; data-thumbnail=&quot;https://pic1.zhimg.com/v2-2e5486cadac557160bb941d71842d304_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-2e5486cadac557160bb941d71842d304_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-2e5486cadac557160bb941d71842d304_b.gif&quot;/&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a443300aac19e1b65e9d741bb47147f1_b.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;744&quot; data-rawheight=&quot;1080&quot; data-thumbnail=&quot;https://pic2.zhimg.com/v2-a443300aac19e1b65e9d741bb47147f1_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-a443300aac19e1b65e9d741bb47147f1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;744&quot; data-rawheight=&quot;1080&quot; data-thumbnail=&quot;https://pic2.zhimg.com/v2-a443300aac19e1b65e9d741bb47147f1_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-a443300aac19e1b65e9d741bb47147f1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a443300aac19e1b65e9d741bb47147f1_b.gif&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;b&gt;近日，旷视开源深度学习框架 MegEngine 开源了 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/MegEngine/MegFlow&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MegFlow&lt;/a&gt; 流式计算框架，助力 AI 算法开发者快速完成 AI 模型的落地应用。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;MegFlow 是面向计算机视觉应用的流式计算框架，提供了一套可快速完成 AI 应用部署的视觉解析服务方案。AI 应用开发者可以基于 MegFlow 提供的图像和视频解析服务，最快 15 分钟即可完成客制化所需功能，例如发票扫描、明火检测等。&lt;/p&gt;&lt;p&gt;常规的 AI 算法交付流程一般分为模型训练、SDK 封装、业务集成和交付验收四个步骤，冗长繁杂。&lt;b&gt;而 MegFlow 提供了一种更为简洁的视觉应用落地流程，用户可以直接用 Python 搭建计算图，不必关心 C++、图优化相关问题，省去了 SDK 封装流程，可快速实现算法交付。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;MegFlow 针对 AI 算法工程落地中的频发问题，诸如性能调优、安全性、模型加密等，都能提供行之有效的解决方案并有效提升了工程效率。MegFlow 拥有安全可靠、简单易用、语义支持丰富等特性，可以帮助 AI 应用快速落地。&lt;/p&gt;&lt;p&gt;&lt;b&gt;安全可靠&lt;/b&gt;&lt;/p&gt;&lt;p&gt;技术选型上， MegFlow 的研发团队调研了多种技术方案，最终选择了安全且零额外开销的 Rust 异步生态，从基础上保证了 MegFlow 的安全性与性能。&lt;/p&gt;&lt;p&gt;&lt;b&gt;简单易用&lt;/b&gt;&lt;/p&gt;&lt;p&gt;MegFlow 支持 Python 插件，且仅需要开发者编写同步的 Python 程序，即可实现可以被MegFlow 异步调度的 Python 插件。同时 MegFlow 提供了一套基于 Web UI的可视化调试工具，可有效提升模型部署的工作效率。&lt;/p&gt;&lt;p&gt;&lt;b&gt;语义支持丰富&lt;/b&gt;&lt;/p&gt;&lt;p&gt;表达能力上，MegFlow 支持静态图、动态图和共享图，辅以 demux、reorder、transform等函数式语义的通用插件，为搭建多样化的 AI 服务提供了丰富的语义支持。&lt;/p&gt;&lt;p&gt;MegFlow 使用相关，欢迎参考社区开发者的实践文章：&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://zhuanlan.zhihu.com/p/408791160&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-text=&quot;SunnyCase：AI 应用落地利器 - MegFlow 尝鲜&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://zhuanlan.zhihu.com/p/409279000&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-text=&quot;BBuf：MegFlow尝鲜测试&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;p&gt;目前，MegFlow 已内置了开箱即用的 AI 应用，如电瓶车检测和宠物围栏检测：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;电瓶车检测应用则为物业管理者提供了智能化管理工具，如摄像头检测到电瓶车进入电梯，系统会发出通知，提醒管理人员，有效排除起火安全隐患。&lt;/li&gt;&lt;li&gt;宠物围栏检测目前支持猫咪检测，注册过的猫咪离开围栏会发出告警。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-2b6896ca06d6f5393b7db7d34e0192ba_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1020&quot; data-rawheight=&quot;1020&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-2b6896ca06d6f5393b7db7d34e0192ba_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1020&quot; data-rawheight=&quot;1020&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-2b6896ca06d6f5393b7db7d34e0192ba_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-2b6896ca06d6f5393b7db7d34e0192ba_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;附：&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/MegEngine&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/MegEngine&lt;/span&gt;&lt;span class=&quot;invisible&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/MegEngine/megflow&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/MegEngine/me&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;gflow&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;官网：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//megengine.org.cn/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;MegEngine-深度学习，简单开发&lt;/a&gt;&lt;/p&gt;&lt;p&gt;欢迎加入 MegEngine 技术交流 QQ 群：1029741705&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ee6d035c98915430fd1d24d20bab616f</guid>
<title>设计模式系列：工厂模式</title>
<link>https://toutiao.io/k/glcmo5r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;工厂模式属于创建型设计模式。是日常使用比较多的一种设计模式。比如&lt;code&gt;Logback&lt;/code&gt;，&lt;code&gt;Spring&lt;/code&gt;等框架中都大量使用该设计模式。&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247484174&amp;amp;idx=1&amp;amp;sn=5c382541660563b718ffde9470605110&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;上篇文章&lt;/a&gt;提到的&lt;strong&gt;简单工厂模式&lt;/strong&gt;虽然在简单系统可以用一用，但是因为工厂类本身包含太多业务逻辑，而且如果想增加新的图表类型，需要修改工厂类等缺点。所以我们真正生产系统更多的使用工厂模式。&lt;/p&gt;&lt;p&gt;工厂模式为每一个类都定义一个单独的工厂类，该工厂类只负责创建单一的产品。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;举个例子&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;通过工厂模式实现日志的创建，为不同种类的&lt;code&gt;Logger&lt;/code&gt;分别创建不同类型的工厂。&lt;/p&gt;&lt;p&gt;来看一下UML图:&lt;/p&gt;&lt;figure&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6126482213438735&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/jmjNkE9L9QjriahfkJibne3GYBranOyKaGz3EiavYQwW0bfgdiacUO8Dlo99O6ZGVchClDibpvwq85RpocI4bGhqCog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;759&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;来看一下代码如何实现&lt;/p&gt;&lt;p&gt;先来定义一个&lt;code&gt;Logger&lt;/code&gt;接口，以及&lt;code&gt;LoggerFactory&lt;/code&gt;接口&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;Logger&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;writeLogger&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;LoggerFactory&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;Logger &lt;span&gt;createLogger&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;分别定义&lt;code&gt;FileLogger&lt;/code&gt;和&lt;code&gt;FileLoggerFactory&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FileLogger&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Logger&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;writeLogger&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;File logger&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FileLoggerFactory&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;LoggerFactory&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Logger &lt;span&gt;createLogger&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//不同Logger的个性初始化工作&lt;/span&gt;&lt;br/&gt;        Logger logger =  &lt;span&gt;new&lt;/span&gt; FileLogger();&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; logger;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果想增加新的&lt;code&gt;Logger&lt;/code&gt;直接实现&lt;code&gt;Logger&lt;/code&gt;和&lt;code&gt;LoggerFactory&lt;/code&gt;就好了，看一下客户端如何使用&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Client&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        Logger logger;&lt;br/&gt;        LoggerFactory loggerFactory;&lt;br/&gt;&lt;br/&gt;        loggerFactory = &lt;span&gt;new&lt;/span&gt; FileLoggerFactory();&lt;br/&gt;        logger = loggerFactory.createLogger();&lt;br/&gt;        logger.writeLogger();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;工厂模式是创建型模式之一，日常使用比较多，每类产品都有对应的一个工厂类。工厂模式把简单工厂的内部逻辑迁移到了客户端，当需要对功能扩展时，只需要修改客户端就OK了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247484022&amp;amp;idx=1&amp;amp;sn=d3176ea73e48360b64c3f50e8fd622bf&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;1. Java并发编程那些事儿(十)——最后的总结&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247484130&amp;amp;idx=1&amp;amp;sn=eb09dd99d1a8e892a3de73d898c04b0c&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;2. 程序员应该掌握的常用网络问题定位工具&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247483893&amp;amp;idx=1&amp;amp;sn=85f6a2063048cc244aedde3172444e32&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;3. Awk这件上古神兵你会用了吗&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247483852&amp;amp;idx=1&amp;amp;sn=6efb0db3d5dff639fae2aaec978c2160&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;4. 手把手教你搭建一套ELK日志搜索运维平台&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ad447a6d3ecff494870c5abb93f3f473</guid>
<title>自荐一款 Redis 可视化管理工具</title>
<link>https://toutiao.io/k/yieiouu</link>
<content:encoded>&lt;div&gt;&lt;div/&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>