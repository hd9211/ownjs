<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1d4d4b44df832196f22d59defa74c8f3</guid>
<title>求抱抱，小王被这 10 道 Java 面试题虐哭了</title>
<link>https://toutiao.io/k/jnjaul9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一天，小王告诉我，他去一家公司面试 Java 岗，结果被面试官虐哭了。整整 10 道 Java 面试题，小王一道也没答正确。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他沮丧地给我说，“哥，说点我的情况，你愿意听吗？我和一个女孩相处，女孩大我两岁，我非科班。本来打算国庆换一家薪水高点的，好确认关系。我经验不多，技术一般般，之前在一家外包公司，有一个甲方内推，我就鲁莽地把外包的工作辞了，结果没想到面试被虐了，我担心女朋友会不会因为我没有工作和我分手。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;听他这么一说，确实挺虐心的。后来我就安慰他，要他端正心态，先把这些面试题整明白，然后继续找工作，不要想太多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;借这个机会，我就把小王遇到的这 10 道面试题分享出来，希望能对其他小伙伴一些帮助。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第一题，下面这串代码打印的结果是什么&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(Math.min(Double.MIN_VALUE, &lt;span&gt;0.0&lt;/span&gt;d));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他觉得 Double.MIN_VALUE 和 Integer.MIN_VALUE 一样，是个负数，应该小于 0.0d。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但事实上，Double. MIN_VALUE 和 Double. MAX_VALUE 一样，都是正数，Double. MIN_VALUE 的值是 &lt;code&gt;2^(-1074)&lt;/code&gt;，直接打印 Double. MIN_VALUE 的话，输出结果为 &lt;code&gt;4.9E-324&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此这道题的正确答案是输出 &lt;code&gt;0.0&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第二题，在 try 块或者 catch 语句中执行 return 语句或者 &lt;code&gt;System.exit()&lt;/code&gt; 会发生什么，finally 语句还会执行吗？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为在他的刻板印象中，finally 语句是无论如何都会执行的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但事实上，在 try 块或者 catch 语句中执行 return 语句时，finally 语句会执行；在 try 块或者 catch 语句中执行 &lt;code&gt;System.exit()&lt;/code&gt; 时，finally 语句不会执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        returnTryExec();&lt;br/&gt;        returnCatchExec();&lt;br/&gt;        exitTryExec();&lt;br/&gt;        exitCatchExec();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;returnTryExec&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;finally returnTryExec&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;returnCatchExec&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; { } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;finally returnCatchExec&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;exitTryExec&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            System.exit(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;finally exitTryExec&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;exitCatchExec&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; { } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            System.exit(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;finally exitCatchExec&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序执行结果如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;finally returnTryExec&lt;br/&gt;finally returnCatchExec&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第三题，私有方法或者静态方法能被重写（override）吗？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他不确定私有方法或者静态方法与重写之间的关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重写的两个方法名相同，方法参数的个数也相同；不过一个方法在父类中，另外一个在子类中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LaoWang&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;老王写了一本《基督山伯爵》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;XiaoWang&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;LaoWang&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;小王写了一本《茶花女》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;OverridingTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        LaoWang wang = &lt;span&gt;new&lt;/span&gt; XiaoWang();&lt;br/&gt;        wang.write();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;父类 LaoWang 有一个 &lt;code&gt;write()&lt;/code&gt; 方法（无参），方法体是写一本《基督山伯爵》；子类 XiaoWang 重写了父类的 &lt;code&gt;write()&lt;/code&gt; 方法（无参），但方法体是写一本《茶花女》。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 main 方法中，我们声明了一个类型为 LaoWang 的变量 wang。在编译期间，编译器会检查 LaoWang 类是否包含了 &lt;code&gt;write()&lt;/code&gt; 方法，发现 LaoWang 类有，于是编译通过。在运行期间，new 了一个 XiaoWang 对象，并将其赋值给 wang，此时 Java 虚拟机知道 wang 引用的是 XiaoWang 对象，所以调用的是子类 XiaoWang 中的 &lt;code&gt;write()&lt;/code&gt; 方法而不是父类 LaoWang  中的 &lt;code&gt;write()&lt;/code&gt; 方法，因此输出结果为“小王写了一本《茶花女》”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而私有方法对子类是不可见的，它仅在当前声明的类中可见，private 关键字满足了封装的最高级别要求。另外，Java 中的私有方法是通过编译期的静态绑定的方式绑定的，不依赖于特定引用变量所持有的对象类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法重写适用于动态绑定，因此私有方法无法被重写。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LaoWang&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;LaoWang&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        write();&lt;br/&gt;        read();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;老王写了一本《基督山伯爵》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;老王在读《哈姆雷特》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;XiaoWang&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;LaoWang&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;小王写了一本《茶花女》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;小王在读《威尼斯商人》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PrivateOrrideTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        LaoWang wang = &lt;span&gt;new&lt;/span&gt; XiaoWang();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序输出结果如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;小王写了一本《茶花女》&lt;br/&gt;老王在读《哈姆雷特》&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在父类的构造方法中，分别调用了 &lt;code&gt;write()&lt;/code&gt; 和 &lt;code&gt;read()&lt;/code&gt; 方法，&lt;code&gt;write()&lt;/code&gt;方法是 public 的，可以被重写，因此执行了子类的 &lt;code&gt;write()&lt;/code&gt; 方法，&lt;code&gt;read()&lt;/code&gt; 方法是私有的，无法被重写，因此执行的仍然是父类的 &lt;code&gt;read()&lt;/code&gt; 方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和私有方法类似，静态方法在编译期也是通过静态绑定的方式绑定的，不依赖于特定引用变量所持有的对象类型。方法重写适用于动态绑定，因此静态方法无法被重写。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;StaticOrrideTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Laozi zi = &lt;span&gt;new&lt;/span&gt; Xiaozi();&lt;br/&gt;        zi.write();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Laozi&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;老子写了一本《基督山伯爵》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Xiaozi&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Laozi&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;小子写了一本《茶花女》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序输出结果如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;老子写了一本《基督山伯爵》&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引用变量 zi 的类型为 Laozi，所以 &lt;code&gt;zi.write()&lt;/code&gt; 执行的是父类中的 &lt;code&gt;write()&lt;/code&gt; 方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;静态方法也叫类方法，直接通过类名就可以调用，通过对象调用的时候，IDE 会发出警告。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.21129032258064517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHplr7ZibLgLzL5cP90VDbAx0vjaQrDk8rK6mIlHibUKfIo2ahrauLT88w9ncxN74MfVEq6QWYmOdLyQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第四题，&lt;code&gt;1.0/0.0&lt;/code&gt; 得到的结果是什么？会抛出异常吗，还是会出现编译错误？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他没有深入研究过 double 类型和 int 类型的除法运算。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数字在 Java 中可以分为两种，一种是整形，一种是浮点型。不太清楚的小伙伴先去研究一下&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxNzQwNjM3NA==&amp;amp;mid=2247489521&amp;amp;idx=2&amp;amp;sn=869f20ba8b26b523b5b0d7d10f3ef87a&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;数据类型&lt;/a&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当浮点数除以 0 的时候，结果为 Infinity 或者 NaN。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;System.out.println(1.0 / 0.0); // Infinity&lt;br/&gt;System.out.println(0.0 / 0.0); // NaN&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Infinity 的中文意思是无穷大，NaN 的中文意思是这不是一个数字（Not a Number）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当整数除以 0 的时候（&lt;code&gt;10 / 0&lt;/code&gt;），会抛出异常：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Exception &lt;span&gt;in&lt;/span&gt; thread &lt;span&gt;&quot;main&quot;&lt;/span&gt; java.lang.ArithmeticException: / by zero&lt;br/&gt; at com.itwanger.eleven.ArithmeticOperator.main(ArithmeticOperator.java:32)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常，我们在进行整数的除法运算时，需要先判断除数是否为 0，以免程序抛出异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第五题，Java 支持多重继承吗？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他知道，通过接口可以达到多重继承的目的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来定义两个接口，Fly 会飞，Run 会跑。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public interface Fly {&lt;br/&gt;    void fly();&lt;br/&gt;}&lt;br/&gt;public interface Run {&lt;br/&gt;    void run();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后让一个类同时实现这两个接口。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Pig&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Fly&lt;/span&gt;,&lt;span&gt;Run&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fly&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;会飞的猪&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;会跑的猪&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但说到多重继承，讨论的关键字是 extends，而非 implements。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 只支持单一继承，是因为涉及到菱形问题。如果有两个类共同继承一个有特定方法的父类，那么该方法可能会被两个子类重写。然后，如果你决定同时继承这两个子类，那么在你调用该重写方法时，编译器不能识别你要调用哪个子类的方法。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7518939393939394&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHplr7ZibLgLzL5cP90VDbAx0vpLyyBPgeyaDBb4ic38y0Nt62WnH5lCqgojdcbfyUlg2wgToialPRnCibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1056&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类 C 同时继承了类 A 和类 B，类 C 的对象在调用类 A 和类 B 中重写的方法时，就不知道该调用类 A 的方法，还是类 B 的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第六题，当在 HashMap 中放入一个已经存在的 key 时，会发生什么？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他没有深入研究过 HashMap 的工作原理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hash，一般译作“散列”，也有直接音译为“哈希”的，这玩意什么意思呢？就是把任意长度的数据通过一种算法映射到固定长度的域上（散列值）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再直观一点，就是对一串数据 wang 进行杂糅，输出另外一段固定长度的数据 er——作为数据 wang 的特征。我们通常用一串指纹来映射某一个人，别小瞧手指头那么大点的指纹，在你所处的范围内很难找出第二个和你相同的（人的散列算法也好厉害，有没有）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于任意两个不同的数据块，其散列值相同的可能性极小，也就是说，对于一个给定的数据块，找到和它散列值相同的数据块极为困难。再者，对于一个数据块，哪怕只改动它的一个比特位，其散列值的改动也会非常的大——这正是 Hash 存在的价值！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家应该知道，HashMap 的底层数据结构是一个数组，通过 &lt;code&gt;hash()&lt;/code&gt; 方法来确定下标。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;hash&lt;/span&gt;&lt;span&gt;(Object key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; h;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;0&lt;/span&gt; : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们放入一个键值对的时候，会先调用 &lt;code&gt;hash()&lt;/code&gt; 方法对 key 进行哈希算法，如果 key 是相同的，那么哈希后的结果也是相同的，意味着数组中的下标是相同的，新放入的值就会覆盖原来的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第七题，下面这段代码将会打印出什么？&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;char&lt;/span&gt;[] chars = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[]{&lt;span&gt;&#x27;\u0097&#x27;&lt;/span&gt;};&lt;br/&gt;        String str = &lt;span&gt;new&lt;/span&gt; String(chars);&lt;br/&gt;        &lt;span&gt;byte&lt;/span&gt;[] bytes = str.getBytes();&lt;br/&gt;        System.out.println(Arrays.toString(bytes));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他没有深入研究过字符编码方面的一些知识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这段程序中，我们通过一个字符数组创建了一个字符串对象，然后调用 String 类的 &lt;code&gt;getByte()&lt;/code&gt; 方法得到字节数组并将其打印到控制台。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道面试题考察的核心并不是最终的打印结果（结果是不确定的），而是字符编码。通常情况下，我们在调用 &lt;code&gt;getBytes()&lt;/code&gt; 方法时，要指定编码，比如说 &lt;code&gt;str.getBytes(StandardCharsets.UTF_8)&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们没有指定编码的时候，JDK 会调用平台默认的字符编码，而不同的操作系统，编码不尽相同的，bytes 的结果也就会不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当使用 UTF_8 时，结果为 &lt;code&gt;-62, -105&lt;/code&gt;，当使用 GB2312 时，结果为 &lt;code&gt;63&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第八题，当方法在父类中抛出 &lt;code&gt;NullPointerException&lt;/code&gt; 时，是否可以使用抛出 &lt;code&gt;RuntimeException&lt;/code&gt; 的方法来重写它？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他被重写（overriding）和重载（overloading）的概念搞混了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法重写和方法重载时，方法名可以完全相同，但根本的不同在于方法重写时发生在运行时，方法重载时发生在编译时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，方法重写和方法重载时的规则也不尽相同。在 Java 中，不能重写 private、static 和 final 方法，但可以重载它们。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来重点看一下方法重写时的规则：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）方法签名必须相同，包括返回类型、参数的数量、参数的类型和参数的顺序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）重写后的方法不能抛出比父类中更高级别的异常。举例来说，如果父类中的方法抛出的是 IOException，那么子类中重写的方法不能抛出 Exception，可以是 IOException 的子类或者不抛出任何异常。这条规则只适用于可检查的异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可检查（checked）异常必须在源代码中显式地进行捕获处理，不检查（unchecked）异常就是所谓的运行时异常，比如说 NullPointerException、ArrayIndexOutOfBoundsException 之类的，不会在编译器强制要求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3）重写后的方法访问权限不能比父类中的方法低，比如说父类中的方法是 public，重写后的方法就不能是 protected。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ExceptionDemo&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Super s = &lt;span&gt;new&lt;/span&gt; Child();&lt;br/&gt;        s.write();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Super&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; NullPointerException &lt;/span&gt;{ }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Child&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Super&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; RuntimeException &lt;/span&gt;{ }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RuntimeException 和 NullPointerException 属于不检查异常，所以本题的答案是可以的。如果是可检查异常的话，IDE 就会发出警告。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2725806451612903&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHplr7ZibLgLzL5cP90VDbAx0vqiaNGoCuwE2WOibPSf0f5aicWWzt3tgIFGWcRnEticCSPlGCEZlB9Vr9QQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第九题，下面这段代码使用了 &lt;code&gt;compareTo()&lt;/code&gt; 方法，有问题吗？&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Employee&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Comparable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;compareTo&lt;/span&gt;&lt;span&gt;(Object o)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Employee emp = (Employee) o;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.id - emp.id;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他想当然地认为 id 的都是正整数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们需要按照一定的规则进行排序的时候，通常要实现 Comparable 接口，并实现 compareTo 方法，规则如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）如果当前对象小于另外一个对象，则 compareTo 方法必须返回负数；如果当前对象大于另外一个对象，则必须返回正数；如果两个对象相等，则返回零。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）通常来说，compareTo 方法必须和 equals 方法一致，如果两个对象通过 equals 方法判断的结果为 true，那么 compareTo 必须返回零。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，JDK 中有一个反例，就是 BigDecimal。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BigDecimal bd1 = &lt;span&gt;new&lt;/span&gt; BigDecimal(&lt;span&gt;&quot;2.0&quot;&lt;/span&gt;);&lt;br/&gt;BigDecimal bd2 = &lt;span&gt;new&lt;/span&gt; BigDecimal(&lt;span&gt;&quot;2.00&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;System.out.println(&lt;span&gt;&quot;equals: &quot;&lt;/span&gt; + bd1.equals(bd2));&lt;br/&gt;System.out.println(&lt;span&gt;&quot;compareTo: &quot;&lt;/span&gt; + bd1.compareTo(bd2));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;equals: &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;compareTo: 0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是因为 JDK 认为 2.0 和 2.00 的精度不一样，所以不能 equals，但值确实是相等的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3）不能使用减法来比较整数值，因为减法的结果可能溢出。应该使用 &lt;code&gt;Integer.compareTo()&lt;/code&gt; 来进行比较。如果你想通过减法操作来提高性能，必须得确保两个操作数是正整数，或者确保两者相差的值小于 Integer.MAX_VALUE。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CompareDemo&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;Employee&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        list.add(&lt;span&gt;new&lt;/span&gt; Employee(&lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;        list.add(&lt;span&gt;new&lt;/span&gt; Employee(Integer.MIN_VALUE));&lt;br/&gt;        list.add(&lt;span&gt;new&lt;/span&gt; Employee(Integer.MAX_VALUE));&lt;br/&gt;        Collections.sort(list);&lt;br/&gt;        System.out.println(list);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Employee&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Comparable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Employee&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; id)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.id = id;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;compareTo&lt;/span&gt;&lt;span&gt;(Object o)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Employee emp = (Employee) o;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.id - emp.id;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Employee{&quot;&lt;/span&gt; +&lt;br/&gt;                &lt;span&gt;&quot;id=&quot;&lt;/span&gt; + id +&lt;br/&gt;                &lt;span&gt;&#x27;}&#x27;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序的输出结果如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[Employee{id=1}, Employee{id=2147483647}, Employee{id=-2147483648}]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;排序就乱了。因为 &lt;code&gt;Integer.MIN_VALUE - 1&lt;/code&gt; 变成了正数 &lt;code&gt;2147483647&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第十题，StringBuffer 和 StringBuilder 之间有什么区别？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他觉得这道题太简单了，结果说反了，大意了啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;StringBuilder 是 JDK 1.5 之后引入的，它和 StringBuffer 最大的区别就在于它的一系列方法都是非同步的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5018867924528302&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHplr7ZibLgLzL5cP90VDbAx0vZ4VQSwpWC08xoJfx4ibOH2Ap3e7Fbgicu7DtxX7jGWY2Aq7yGASwUBrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1060&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，以上就是小王这次面试遇到的 10 道虐心的面试题，本来最后一道是送分题，结果大意说反了，让小王更加懊恼。年后是跳槽的高峰期，有打算的小伙伴要提前准备了，希望大家都能够顺利面上心仪的岗位。&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>04bc38bbea86d71b2d6e25bbcd995ba3</guid>
<title>白话科普系列：网站靠什么提升加载速度？</title>
<link>https://toutiao.io/k/h61rg9r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;随着生活节奏的不断加快，时间变得极其宝贵，等待页面加载的时间也随之缩短。这样一来如何留住客户变成了一项重要的考验。而减少页面加载等待时间，加快加载速度，就成了提高用户参与度S，提升业务可靠性的有效策略。&lt;/p&gt;&lt;p&gt;根据 Google 的一项研究，有 40％ 的人放弃了某网站，是因为该网站的加载时间超过 3 秒，而页面加载时间增加1 秒，转化就相应减少了 7％。可见，互联网中的每一秒都至关重要。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-dc195edacbcb9f33d918ca2fe35f3d97_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;519&quot; data-rawheight=&quot;300&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-dc195edacbcb9f33d918ca2fe35f3d97_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;519&quot; data-rawheight=&quot;300&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-dc195edacbcb9f33d918ca2fe35f3d97_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-dc195edacbcb9f33d918ca2fe35f3d97_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;那么如何提升网站速度呢？可以通过网页“压缩”也就减少网页体积来实现。至于要如何才能压缩网站，我们需要先了解两个算法，&lt;b&gt;Gzip 和 Brotli 压缩算法。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;                                         Gzip 压缩算法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Gzip 基于 DEFLATE 算法，它是 LZ77 和霍夫曼编码的组合，最早用于 UNIX 系统的文件压缩。HTTP 协议上的 Gzip 编码是一种用来改进 Web 应用程序性能的技术，它要求 Web 服务器和客户端（浏览器）必须共同支持 Gzip。而当下主流的浏览器，包括 IE6、IE7、IE8、IE9、FireFox、Google Chrome、Opera 等都已经开始支持 Gzip 压缩。可见 Gzip 的使用已经成为了互联网发展的必然趋势。&lt;/p&gt;&lt;p&gt;作为 Internet 上使用非常普遍的一种数据压缩格式，Gzip 对一般纯文本内容可压缩到原大小的 40％，这大大减少了网站文件中重复代码和空白的数量。它还可以提供 9 个压缩级别，可以方便使用者微调压缩量和压缩时间。&lt;/p&gt;&lt;p&gt;在用于提高 Web 应用程序的性能这一点上，Gzip 压缩一直是最受欢迎的。直到另一种压缩算法 Brotli 的出现，它成为了 Gzip 最大的竞争对手。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;                                         Brotli 压缩算法&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Brotli 是 Google 在 2015 年 9 月推出的一种压缩算法，Google 认为互联网用户的时间是宝贵的，他们的时间不应该消耗在漫长的网页加载中，因此与其他压缩算法相比，Brotli 有着更高的压缩效率。它通过变种的 LZ77 算法、Huffman 编码以及二阶文本建模等方式进行数据压缩。&lt;/p&gt;&lt;p&gt;根据 Google 发布的研究报告，Brotli 压缩算法具有多个特点，最典型的是以下 3 个：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;针对常见的 Web 资源内容，Brotli 的性能相比 Gzip 提高了 17-25%；&lt;/li&gt;&lt;li&gt;当 Brotli 压缩级别为 1 时，压缩率比 Gzip 压缩等级为 9（最高）时还要高；&lt;/li&gt;&lt;li&gt;在处理不同 HTML 文档时，Brotli 依然能够提供非常高的压缩率&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;依靠着自身卓越的压缩性能，Brotli 自推出后就迅速开始占领压缩市场，从下图可以看到，除了 IE 和 Opera Mini 之外，几乎所有的主流浏览器都已支持 Brotli 算法。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-e9ab7e95798faba589cc1f55e35034df_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1229&quot; data-rawheight=&quot;280&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-e9ab7e95798faba589cc1f55e35034df_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1229&quot; data-rawheight=&quot;280&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-e9ab7e95798faba589cc1f55e35034df_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-e9ab7e95798faba589cc1f55e35034df_b.jpg&quot;/&gt;&lt;figcaption&gt;△ Brotli 浏览器支持情况&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;在压缩效率上 Brotli 毫无疑问的遥遥领先。那么我们是否可以无脑盲选 Brotli 呢，Gzip 是不是应该就此退出市场？&lt;/p&gt;&lt;h2&gt;&lt;b&gt;                                    Brotli 比 Gzip 更好吗？&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;显然与 Gzip 相比，Brotli 压缩在研究中显示出了不俗的成果。，例如 Gzip 有 9 个压缩级别，而 Brotli 有 11 个。此外，Brotli 还使用一个预定义的 120 千字节字典，该字典包含超过 13000 个常用单词、短语和其他子字符串。这些因素都有效提高了 Brotli 的压缩率。根据 Certsimple 的研究，用 Brotli 压缩的 Javascript 文件比 Gzip 小 14％，HTML 文件比 Gzip 小 21％，CSS 文件比 Gzip 小 17％。&lt;/p&gt;&lt;p&gt;无论从哪方面看 Gzip 都已经被 Brotli 碾压，两者之间毫无对比的可能性，我们似乎也完全不需要考虑选择左边或者右边。&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot; data-row-style=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;注意：图像不应该被 Gzip 或 Brotli 压缩，因为它们已经被压缩，再次压缩将使其尺寸变大。&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;诚然 Brotli 在压缩程度上有着绝对的优势，但是这些优势是用其他代价换来的。Brotli 压缩操作所花费的时间会随着压缩级别的增加而增加。简而言之，就是 Brotli 需要更多的计算能力，而大家都知道计算能力需求的增加代表着设备和软件设施的成本上涨。另外 Brotli 要求浏览器必须支持与 HTTPS 一起使用，这也是他相比在浏览器支持量上比 Gzip 少的原因。毕竟 Gzip 同时支持 HTTP 和 HTTPS。&lt;/p&gt;&lt;p&gt;一边是压缩效果奇佳但是可能会因为浏览器的不支持而导致用户无法访问网站，另一边则是浏览器支持但是压缩效果降低用户加载网页时间依然略长，一个两难的抉择出现在了网站运营者面前。有机灵的小伙伴可能会说：“也不是所有用户都能使用 HTTPS，但是不是有功能判断么？难道压缩算法就不能整一个这种自动判断？让能使用 Brotli 的使用 Brotli，不能的使用 Gzip。”&lt;/p&gt;&lt;p&gt;bingo！华生，你发现了盲点。让我们愉快地掏出又拍云一站式减流量秘籍之智能压缩！&lt;/p&gt;&lt;h2&gt;&lt;b&gt;                                 又拍云秘籍——智能压缩&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;又拍云智能压缩功能旨在为网站减少了流量开支，减少资源加载时间，让终端用户的体验更上一层楼。它同时支持 Gzip 和 Brotli 压缩算法，可同时开启，也可开启其中一种。开启该功能，可对静态文件类型进行压缩，有效减少用户传输内容大小，加速分发效果。为了配置的灵活性，“智能压缩”功能支持压缩等级（1 到 5）的设置。两种压缩算法的压缩等级默认为 1，等级越高，压缩率越大。考虑到压缩等级越高，压缩速度会降低，实际生产环境，建议压缩等级控制在 3 以内，具体请以线上环境实测为准进行自主设置。&lt;/p&gt;&lt;p&gt;当用户在后台同时开启 Gzip 和 Brotli 压缩时，后台会自行判断浏览器是否支持 Brotli 来选择进行哪种压缩。&lt;/p&gt;&lt;p&gt;那么这个浏览器自行判断是怎么操作的呢？&lt;/p&gt;&lt;p&gt;其实支持 Brotli 的浏览器会在接受编码请求标头中发送“ br”和“ gzip”（例如：Accept-Encoding: gzip, deflate, br）。如果 Web 服务器上启用了 Brotli，则用户将获取到 Brotli 压缩格式的响应。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f0620bb612b5c9deb73925d825277c45_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;667&quot; data-rawheight=&quot;381&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-f0620bb612b5c9deb73925d825277c45_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;667&quot; data-rawheight=&quot;381&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-f0620bb612b5c9deb73925d825277c45_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-f0620bb612b5c9deb73925d825277c45_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这样就能有效避免选择 A 还是选择 B 的烦恼，你可以两者都拥有，在提升用户浏览体验的同时降低你的 CDN 流量。&lt;/p&gt;&lt;p&gt;当然对于“如果浏览器同时支持 Gzip 和 Brotli 会不会出现两次压缩，或者选择错误”的问题，又拍云也考虑到了哦。当客户端同时支持 Gzip 和 Brotli 算法的情况下，Brotli 的优先级高于 Gzip。&lt;/p&gt;&lt;p&gt;这么方便的功能，只需要登陆 CDN 控制台，进入 「性能优化」配置页面，找到「智能压缩」配置项，点击【管理】按钮，进入如下配置界面：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b54a719a3ac378367c37ad71df0d3038_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1077&quot; data-rawheight=&quot;473&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-b54a719a3ac378367c37ad71df0d3038_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1077&quot; data-rawheight=&quot;473&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-b54a719a3ac378367c37ad71df0d3038_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-b54a719a3ac378367c37ad71df0d3038_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;配置好压缩等级就可以愉快使用了。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-202d053a7bcd5118c9ce91d3e3a7fa69_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;892&quot; data-rawheight=&quot;486&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-202d053a7bcd5118c9ce91d3e3a7fa69_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;892&quot; data-rawheight=&quot;486&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-202d053a7bcd5118c9ce91d3e3a7fa69_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-202d053a7bcd5118c9ce91d3e3a7fa69_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 开启智能压缩前&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-305f9d635be7e11e48b8caea6a2c9688_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;888&quot; data-rawheight=&quot;485&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-305f9d635be7e11e48b8caea6a2c9688_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;888&quot; data-rawheight=&quot;485&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-305f9d635be7e11e48b8caea6a2c9688_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-305f9d635be7e11e48b8caea6a2c9688_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 开启智能压缩后&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;除了智能压缩，又拍云还提供了一系列“省带宽，压成本”的绝招，包括 Webp 自适应、H.265 自适应、码率适配限速、窄带高清 等等，从编码技术、网络架构等角度出发，结合又拍云的产品成果，为大家节省流量，降低成本。有兴趣可以随时联系我们了解哦！&lt;/p&gt;&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;/p&gt;&lt;h2&gt;推荐阅读：&lt;/h2&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/590/%25E7%2599%25BD%25E8%25AF%259D%25E7%25A7%2591%25E6%2599%25AE%25E7%25B3%25BB%25E5%2588%2597%25E2%2580%2594%25E2%2580%2594Chrome%2520%25E6%25B5%258F%25E8%25A7%2588%25E5%2599%25A8%25EF%25BC%258C%25E4%25BD%25A0%25E7%2594%25A8%25E4%25BA%2586%25E4%25B9%2588%25EF%25BC%259F.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic4.zhimg.com/v2-0ce93b77d899e27bf9e9fece8a7086db_180x120.jpg&quot; data-image-width=&quot;1272&quot; data-image-height=&quot;718&quot; class=&quot;LinkCard LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;白话科普系列--Chrome 浏览器，你用了么？&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.upyun.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic4.zhimg.com/v2-0ce93b77d899e27bf9e9fece8a7086db_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/588/%25E7%2599%25BD%25E8%25AF%259D%25E7%25A7%2591%25E6%2599%25AE%25EF%25BC%258C10s%2520%25E4%25BA%2586%25E8%25A7%25A3%2520API.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic3.zhimg.com/v2-e2a633e9f561dfa40182f0e6923268a6_180x120.jpg&quot; data-image-width=&quot;546&quot; data-image-height=&quot;346&quot; class=&quot;LinkCard LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;白话科普，10s 了解 API - 又拍云&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.upyun.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic3.zhimg.com/v2-e2a633e9f561dfa40182f0e6923268a6_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fb1bea933d337473ad3af416de6a2cee</guid>
<title>云游戏在革谁的命？</title>
<link>https://toutiao.io/k/160lo6y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.628125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHgfBRWw69LibJob3BMOPo2gfqJHVH4LzohaX3rr6l6zxpMMMq9ouzPaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;我上大学时的第一台电脑是微星的一款游戏本，当时买它的原因很简单，性能足够强大，无论是编程等日常任务还是游戏它都可以胜任。现在回想起来，依稀记得它炫酷的灯光、强悍的性能以及用它驰骋虚拟世界的快感。后来年纪渐长，打游戏的热情逐渐减少，虽然那台电脑仍在家中，但已经落后的性能让我鲜有机会“宠幸”它。再后来，读研之后换了 Mac 后更是没怎么碰过游戏了。&lt;/p&gt;&lt;p&gt;大家都说正经人谁用 Mac 打游戏，一开始我也是这么认为的，毕竟买来就是用来写代码的，可是最近发现的一个有趣玩意让我对这个问题有了新的想法，那就是——云游戏。&lt;/p&gt;&lt;h2&gt;云计算？云？&lt;/h2&gt;&lt;p&gt;以下内容摘自百度百科&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;云游戏是以&lt;strong&gt;云计算&lt;/strong&gt;为基础的游戏方式，在云游戏的运行模式下，所有游戏都在&lt;strong&gt;服务器端&lt;/strong&gt;运行，并将渲染完毕后的游戏画面&lt;strong&gt;压缩&lt;/strong&gt;后通过网络传送给用户。在客户端，用户的游戏设备&lt;strong&gt;不需要&lt;/strong&gt;任何高端处理器和显卡，只需要基本的&lt;strong&gt;视频解压能力&lt;/strong&gt;就可以了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我将上述内容中一些比较重要的点做了标注，百科在对于云游戏的描述时，第一句就直接阐明了云游戏的基础是云计算，那么「云计算」以及「云」指的是什么？&lt;/p&gt;&lt;p&gt;云计算（cloud computing），是一种基于互联网的计算方式，通过这种方式，&lt;strong&gt;共享的&lt;/strong&gt;软硬件资源和信息可以按需提供给计算机和其他设备。提供资源的网络被称为“云”。&lt;/p&gt;&lt;p&gt;看完上面一句话有些小伙伴还会不太清楚，我们先来回顾下之前的知识。我在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&amp;amp;mid=2247484553&amp;amp;idx=1&amp;amp;sn=132a24db34dc55a11be68cbb738a5631&amp;amp;scene=21#wechat_redirect&quot; title=&quot;《互联网是如何工作的》&quot; data-linktype=&quot;2&quot;&gt;《互联网是如何工作的》&lt;/a&gt;这一篇文章中提到：一台又一台的服务器通过“网线”连接在了一起，形成了类似下面这样的结构 👇&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;161&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.5113941018766756&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHQLthVgvia7dUianrTqqI0uQl6qxdtPibM7TKP189Qc2bExjoCxiakWFkNA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1492&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;众多服务器组成的这种结构被称为“互联网”，而其中每台服务器都被称作“节点”。&lt;/p&gt;&lt;p&gt;事实上这些节点都和你的本机无关但又和你的本机有关。&lt;/p&gt;&lt;p&gt;为什么这么说呢？&lt;/p&gt;&lt;p&gt;无关的原因是，这些节点所包含的计算能力（CPU、GPU）和存储文件都不是你的。有关的原因是，你可以通过某些方式运用这些能力和文件。&lt;/p&gt;&lt;p&gt;而上述所说的一个个节点便是云计算的核心，即「云」。&lt;/p&gt;&lt;p&gt;大量的水滴漂浮在空中，聚合成云。和我们所说的云很相似，只是这里的云是由&lt;strong&gt;大量的数据存储、计算资源和应用程序组成&lt;/strong&gt;，这便是云计算服务。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;210&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHSp9rauZrMSxicuDCuVNSic16w3TRRL7wc9oUc6xSONYQlibPhU7IQF5iaQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1620&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;「云」其实是一个抽象的概念，并不像服务器有一个具体的实物可以展示，我们可以把「云」理解为一个&lt;strong&gt;资源共享池&lt;/strong&gt;。举个例子就是，我有很多东西，家里放不下了，放到一个特定的地方存着，随时提取。大家都可以访问的就是「公有云」，只有特定的人可以访问的就是「私有云」。&lt;/p&gt;&lt;p&gt;这个“东西”一般是指&lt;strong&gt;数据、软件、服务&lt;/strong&gt;等，而“特定的地方”就是云。所以对于云计算我们也可以简单的理解为：将本地需要进行的计算任务迁移到云端进行。&lt;/p&gt;&lt;p&gt;如今云计算及其产物已经深入我们的生活，我们熟悉的百度网盘、iCloud 还有最近的阿里网盘就是「云存储」，以及本文要介绍的主角「云游戏」也是云计算的产物。&lt;/p&gt;&lt;h2&gt;云游戏&lt;/h2&gt;&lt;h3&gt;云游戏的原理&lt;/h3&gt;&lt;p&gt;在现在这个游戏变得越来越流行的时代，人们却仍然被低配设备所限制，比如我，虽然不差 298 买赛博朋克的钱，却苦于手头没有一台合适的机器用于玩耍。以往玩游戏我需要配一台游戏主机或者高性能游戏本，少说也要五六千，因为游戏对于计算机性能的要求是非常高的，这些都必须依赖玩家自己的电脑。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;167&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.531496062992126&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHz1nREHHT8oufyOhGx6uYWHJbKEKSonyQGKQicbo4iaIvIq0r1ltHZ7cg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2032&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;但是在云游戏模型中，所有的游戏逻辑和渲染都在&lt;strong&gt;服务器端&lt;/strong&gt;运行，然后再从服务器把压缩的画面传给用户，这样玩家就不需要一台高性能的计算机了，对于设备的要求便也就是&lt;strong&gt;基本的视频渲染能力&lt;/strong&gt;和&lt;strong&gt;可靠稳定的网络环境&lt;/strong&gt;了。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;123&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.39105504587155965&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpH70wfGgT8DalLuugwaclC5UJib7iacUzF7cWYRWOOpe6icFcCc3QNt2apA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1744&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;云游戏摆脱了对硬件的依赖。对服务器来说，仅仅需要提高服务器性能而不需要研发新主机；对用户来说，可以得到更高的画质而不用购买高性能的计算机。也就是说，用户可以花一小笔钱租一个更好的计算机来玩各种游戏，就像用机顶盒看电视一样，这意味着玩家可以在计算机硬件，特别是 GPU 上省下一大笔钱。&lt;/p&gt;&lt;h3&gt;云游戏需要什么？&lt;/h3&gt;&lt;h3&gt;低延时&lt;/h3&gt;&lt;p&gt;在解释云游戏的原理时，我们提到了云游戏的游戏逻辑和渲染都是在服务器端进行，然后将画面传送给用户，所以说一台可以高速上网的设备极其重要。如果网速不够快，不够稳定就无法及时接收到高质量的画面。&lt;/p&gt;&lt;p&gt;说到这我们需要介绍一下网络延时，所谓网络延时指一个数据包从用户的计算机发送到网站服务器，然后再立即从网站服务器返回用户计算机的来回时间。通俗的讲，就是数据从电脑这边传到那边往返所用的时间。&lt;/p&gt;&lt;p&gt;以我们现在还在普遍使用的 4G 网络而言，它的延时基本在 30ms ～ 70ms 波动，部分信号不好的地方延时还会更大。这还只是数据传输时的网络延时，如果算上画面编解码的时间，延时达到 100ms 是很容易的事情。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.0033444816053512&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHyfFnEl5tdhYI1bGkiaXh2nv1rXJdzvuFd5UGZuKKxbsGAuYtvnZctWg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;299&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们知道视频的原理就是每秒播放多张静态画面，画面越多，对于人的观感来说就是视频越流畅。这是因为对于人眼来说，我们的视觉神经是有一个反应速度的，并且对于不同频率的光有不同的暂留时间。其时值约是 1/16 秒，也就是 62.5ms。也就是说，如果网络传输所消耗的延时大于 62.5ms，我们就会觉得画面很不流畅（62.5 是一个理论值，实际情况下这个数值会小于 62.5ms，对延时的要求更苛刻）。&lt;/p&gt;&lt;h3&gt;高带宽&lt;/h3&gt;&lt;p&gt;现在我们来做一个简单的数学题。&lt;/p&gt;&lt;p&gt;刚才我们说到视频的原理是每秒播放多张静态图像。我们知道图像都是由一个个像素点构成的，对于一张非黑即白的二值图像，不压缩的情况下一个像素只需要 1 个 bit。如果是 256 种状态的灰度图像，不压缩的情况下一个像素需要 8bit（1 字节，256 种状态）。如果用 256 种状态标识屏幕上某种颜色的灰度，而屏幕采用三基色红绿蓝（RGB），不压缩的情况下一个像素需要占用 24bit（3 字节），这个就是常说的 24 位真彩色。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.83984375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHo6zCIEFFdHRic1zntGibWtvamoaT01oac4Srl6g0JUTiah5L2OKjBwJlA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;那么对于一张 1920×1080 的图像，在不压缩的情况下，所需要的大小为 1920×1080×24 = 49766400bit，约等于 48Mb（注意这里是小写的 b，表示位），那么假设对于一个 1080P 30FPS 的视频，每秒就会播放 30 张 1920×1080 的图像，所以在不压缩的情况下如果为了传输这么多画面，网络的带宽必须要达到 48×30=1440Mb/s，当然在视频传输的过程中，肯定会有压缩的过程，假设可以压缩 50%的数据，那网络的带宽也需要 720Mb/s，看到这你想一下，你家的网络带宽又有多少呢？&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;这里之所以用 Mb 作为单位是因为方便大家和自己家的宽带进行比较，因为通常我们所说的百兆带宽指的是 100Mb 而不是 100MB。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;如何实现低延时+高带宽&lt;/h3&gt;&lt;p&gt;从开源节流的角度去考虑问题，如果网络传输的速度有上限，那么想要在单位时间内传输更多的视频数据，最好的方式便是对视频进行编解码。&lt;/p&gt;&lt;h3&gt;视频编解码&lt;/h3&gt;&lt;p&gt;编码这一概念在通信与信息处理领域中广泛使用，其基本原理是将信息按照一定规则使用某种形式的码流表示与传输。常用的需要编码的信息主要有：文字、语音、视频和控制信息等。&lt;/p&gt;&lt;p&gt;刚才说了动态图像的像素形式表示数据量极为巨大，存储空间和传输带宽完全无法满足保存和传输的需求。所以要对视频进行编码，其最主要的目的就是为了对视频数据进行压缩。&lt;/p&gt;&lt;p&gt;而视频信息之所以存在大量可以被压缩的空间，是因为其中本身就存在大量的数据冗余。&lt;/p&gt;&lt;p&gt;举个简单的例子，下面这两张图片是一段视频的其中两个画面（寒食君友情出镜）&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;176&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.5582761998041136&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHbdFxG6jUuWfqGuW2rCicqI6pGZEGYfeicOrDAAwfrRxAaDHO9zxMWj5Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1021&quot; title=&quot;null&quot;/&gt;从这两张图片可以看出，其实变化的部分就是人物的动作，而不变的是后面的背景，所以后面的这块背景像素在对于视频来说就是一段冗余数据，可以被压缩。同样的，人物的脸部虽然有动作变化，但是人物的脸并没有变化，寒食君还是寒食君，因此不变的地方同样是冗余数据。&lt;/p&gt;&lt;p&gt;视频中的冗余数据的主要类型有：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;时间冗余：视频相邻的两帧之间内容相似，存在运动关系&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;空间冗余：视频的某一帧内部的相邻像素存在相似性&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;编码冗余：视频中不同数据出现的概率不同&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;视觉冗余：观众的视觉系统对视频中不同的部分敏感度不同&lt;/span&gt;&lt;/p&gt;&lt;p&gt;针对这些不同类型的冗余信息，在各种视频编码的标准算法中都有不同的技术专门应对，以通过不同的角度提高压缩的比率。这里我们简单说一下目前较为流行的两种编码 &lt;strong&gt;H.264 与 H.265&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;217&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.6902173913043478&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpH8aJVqgsNvUMkgVKB7unlu0QiaEI2Mppukg0fMQCvJo5DEyo5UeRGoEA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;736&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;这两个是 ITU-T VCEG 制定的视频编码标准。H.265 标准围绕着现有的视频编码标准 H.264，保留原来的某些技术，同时对一些相关的技术加以改进。新技术使用先进的技术用以改善码流、编码质量、延时和算法复杂度之间的关系，达到最优化设置。&lt;/p&gt;&lt;p&gt;具体的编码算法太过复杂，这里就不再多说，我们只要知道 H264 由于算法优化，可以低于 1Mbps 的速度实现标清数字图像传送；H265 则可以实现利用 1~2Mbps 的传输速度传送 720P（分辨率 1280*720）普通高清音视频传送。H.265 旨在在有限带宽下传输更高质量的网络视频，仅需 H.264 的一半带宽即可播放相同质量的视频。&lt;/p&gt;&lt;p&gt;经过测试，在相同的图像质量下，相比于 H.264，通过 H.265 编码的视频大小将减少大约 39-44%。在码率减少 51-74%的情况下，H.265 编码视频的质量还能与 H.264 编码视频近似甚至更好。&lt;/p&gt;&lt;h3&gt;5G 和 Wi-Fi6&lt;/h3&gt;&lt;p&gt;&lt;img data-backh=&quot;173&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.547699214365881&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHXfxdXfeReh9S3ricZRFmQHFM6UErVjKdtRSQLeoI5LXC7owibwpWjwrA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1782&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;有了视频解码可以在单位时间内传输更多的数据后，剩下要做的便是提高传输速率。这便引出了今年非常火的两个名词——5G 和 Wi-Fi6。&lt;/p&gt;&lt;p&gt;就目前公开的数据来看，5G 协议中的峰值速度已经达到 20Gbit/s，Wi-Fi 6 最高也可以达到 9.6Gbit/s，这也就意味着在网络传输中可以携带的数据包更大。而且由于技术的提升，这两者在网络延时上也做了非常多的优化，在同等条件下 5G 的延迟低于 1 毫秒，相较于 4G 的 30-70 毫秒可谓是质的飞升。而 WI-FI6 的网络延时虽然不及 5G 这么优秀，但也从 Wi-Fi5 的平均 30ms 降低至 20ms。&lt;/p&gt;&lt;h3&gt;小结&lt;/h3&gt;&lt;p&gt;云游戏的概念其实早在 2013 年就已提出，但一直不温不火，目前来看，得益于越来越先进的压缩算法和低延时高带宽的网络环境，云游戏真的有可能异军突起，那么目前已有的云游戏做到什么样了呢？恰好笔者最近收到消息，腾讯的 START 云游戏平台已经公测，接下来谈谈我的云游戏初体验。&lt;/p&gt;&lt;h2&gt;我的云游戏初体验&lt;/h2&gt;&lt;p&gt;我的第一次云游戏初体验是在腾讯的 START 平台上进行的，点击官网https://start.qq.com即可看到如下的页面。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;155&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.4913557779799818&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHxjUQHMhIAtVEotSw2kRCdxu3MXPs46oFe8s2giaFCiaW5XOtCuPUg5Gw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2198&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;如果不是因为他的域名里有 qq.com，这简洁的页面真的让我怀疑这是腾讯做的吗？而且这句「从此 Mac 也有庞大的游戏库」这句话真的让我很难不怀疑腾讯会那么好心提供那么多游戏吗？&lt;/p&gt;&lt;p&gt;抱着怀疑的态度我下载安装了这款云游戏平台，Mac 安装软件的方法一如既往的简单，下载完后直接将 app 文件拖入 Application 文件夹中即可。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;191&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.6060606060606061&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHiazltm77RZUR3ceHibj8ZMpRDvvX7pnaKIxHx2yRzXpSZ4MnGg5dQoPg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1320&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;打开之后我们可以看到腾讯提供的一些游戏，种类虽然不是很多，但是对于不能玩游戏的 Mac 来说已经很不错了。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;207&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.6564356435643565&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHKDvhlUYKyzvIvkibUmql9Q50KDpnMYNiccibLg7JTgNWFbpEfI8iagMe0Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1010&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;我试玩了一下很久没玩的 QQ 飞车，体验一番后，我只能说：NB！！&lt;/p&gt;&lt;p&gt;我录了一段小视频，大家可以播放看一下（玩的比较菜，不要嫌弃）&lt;/p&gt;&lt;p/&gt;&lt;p&gt;之后我又玩了几把堡垒之夜和穿越火线，目前来看：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;腾讯 START 的整个流程已基本完备，使用门槛很低，下载一个客户端即可体验云游戏。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;虽然游戏种类不是很多，但有总比没有好&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;赛车类键盘操作游戏体验很好，能还原 PC 体验的 90%以上。画面流畅，帧率稳定，分辨率高。(网速要求并不是很苛刻，只要连接了 5G Wi-Fi 即可)&lt;/span&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;目前来看 START 是免费的，不知道公开运行时候是不是会收费。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;总的来说，这次的体验真的让我惊到了，因为按照之前的计算，现在的 5G Wi-Fi 的速率和延时其实是不足以带动云游戏，但体验下来，效果真的非常棒，我的 Macbook pro 终于也可以愉快的打游戏了，手里有 Mac 的小伙伴也可以下载体验下。&lt;/p&gt;&lt;h2&gt;浅谈云游戏&lt;/h2&gt;&lt;h3&gt;云游戏的影响&lt;/h3&gt;&lt;p&gt;对于玩家来说，云游戏并不需要高性能的显卡，连使用 MacBook Air 的小伙伴也可以畅玩，扩充了游戏品类，减少了高昂的硬件开支。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHNaNsLOXYNj99DnUDBcwadyFxf6cybP9A52icpG253keQb31fRHAxeuA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;而且由于游戏都在云端，可以有效的杜绝外挂（你总不能把外挂装到厂商的服务器里吧），同样的也可以防止盗版游戏的盛行（虽然并不知道这是好事还是坏事）。&lt;/p&gt;&lt;p&gt;同样的，对于游戏开发者来说，云游戏的出现可以是他们在开发游戏时可以减少对老设备、低性能设备的适配，提升了游戏呈现质量的同时降低了开发成本，提高了游戏开发的效率。&lt;/p&gt;&lt;h3&gt;云游戏会取代 PC 吗？&lt;/h3&gt;&lt;p&gt;说了那么多，一旦一项新技术兴起，就会面临一个老生常谈的问题：云游戏的出现会取代传统的游戏主机吗？肯定的说，不会。&lt;/p&gt;&lt;p&gt;就算未来网速再快、延时再低，也不可能达到 0 延迟。没办法，这是物理法则。当你在玩电竞游戏的时候，你需要的一定是几毫秒的延时而不是几百毫秒。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6416666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHV1wr7a5HXpYtUaNibZY7xHeZh0plLiccOrCia2pzQbzbv0zR59Vwf0Fag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;但同样的，云游戏给游戏玩家提供了新的选择，对于一些非重度游戏玩家，玩一些对延时要求不高的游戏来说，云游戏确实是一个新的选择。&lt;/p&gt;&lt;p&gt;所以，回到一开始的问题，云游戏在革谁的命？是英伟达、AMD 这样的显卡厂商吗？还是 Steam、Uplay 这样的游戏平台？我看都不是，它革的是「游戏本」、是「盗版游戏」的命。&lt;/p&gt;&lt;h2&gt;最后&lt;/h2&gt;&lt;p&gt;以上就是本篇文章的全部内容了，如果你觉得还不错的，欢迎点赞支持一波，你们的支持是我更新的最大动力！&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpH47ZQb0Qia7ibfUdueIsZVJMzPW9DXBor2xORyYzlpF6GtIRTkibRTUEQQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>16d4cc0a03424ffd42116d4593082651</guid>
<title>每个程序员都应该知道的 CPU 知识：NUMA</title>
<link>https://toutiao.io/k/b13e8n2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是 NUMA？&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;早期的计算机，内存控制器还没有整合进 CPU，所有的内存访问都需要经过北桥芯片来完成。如下图所示，CPU 通过前端总线（FSB，Front Side Bus）连接到北桥芯片，然后北桥芯片连接到内存——内存控制器集成在北桥芯片里面。&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;368&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;252&quot; data-ratio=&quot;0.7245508982035929&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9637P74IBOE3mOYRvZ13aE8ZFytOzExOK255TDstq8PiaqpZcGGUicjEgZykQOlEjRsjYWE0307wtoWg4ncmVKhg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;668&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种架构被称为 UMA&lt;sup&gt;1&lt;/sup&gt;（Uniform Memory Access, 一致性内存访问 ）：总线模型保证了 CPU 的所有内存访问都是一致的，不必考虑不同内存地址之间的差异。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 UMA 架构下，CPU 和内存之间的通信全部都要通过前端总线。而提高性能的方式，就是不断地提高 CPU、前端总线和内存的工作频率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面的故事，大部分人都很清楚：因为物理条件的限制，不断提高工作频率的路子走不下去了。CPU 性能的提升开始从提高主频转向增加 CPU 数量（多核、多 CPU）。越来越多的 CPU 对前端总线的争用，使前端总线成为了瓶颈。为了消除 UMA 架构的瓶颈，NUMA&lt;sup&gt;2&lt;/sup&gt;（Non-Uniform Memory Access, 非一致性内存访问）架构诞生了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-cropselx1=&quot;1&quot; data-cropselx2=&quot;374&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;226&quot; data-ratio=&quot;0.6021180030257186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9637P74IBOE3mOYRvZ13aE8ZFytOzExOA0POIUeuUnZpzmcWVU71CCRBu6tKPt0GftYx1Qu3lZvPWmny5StPaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;661&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;CPU 厂商把内存控制器集成到 CPU 内部，一般一个 CPU socket 会有一个独立的内存控制器。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个 CPU scoket 独立连接到一部分内存，这部分 CPU 直连的内存称为“本地内存”。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CPU 之间通过 QPI（Quick Path Interconnect） 总线进行连接。CPU 可以通过 QPI 总线访问不和自己直连的“远程内存”。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和 UMA 架构不同，在 NUMA 架构下，内存的访问出现了本地和远程的区别：访问远程内存的延时会明显高于访问本地内存。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;NUMA 的设置&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 有一个命令 numactl&lt;sup&gt;3&lt;/sup&gt; 可以查看或设置 NUMA 信息。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;执行 &lt;code&gt;numactl --hardware&lt;/code&gt; 可以查看硬件对 NUMA 的支持信息：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# numactl --hardware&lt;/span&gt;&lt;br/&gt;available: 2 nodes (0-1)&lt;br/&gt;node 0 cpus: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71&lt;br/&gt;node 0 size: 96920 MB&lt;br/&gt;node 0 free: 2951 MB&lt;br/&gt;node 1 cpus: 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95&lt;br/&gt;node 1 size: 98304 MB&lt;br/&gt;node 1 free: 33 MB&lt;br/&gt;node distances:&lt;br/&gt;node   0   1 &lt;br/&gt;  0:  10  21 &lt;br/&gt;  1:  21  10&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;CPU 被分成 node 0 和 node 1 两组（这台机器有两个 CPU Socket）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一组 CPU 分配到 96 GB 的内存（这台机器总共有 192GB 内存）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;node distances 是一个二维矩阵，node[i][j] 表示 node i 访问 node j 的内存的相对距离。比如 node 0 访问 node 0 的内存的距离是 10，而 node 0 访问 node 1 的内存的距离是 21。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;执行 &lt;code&gt;numactl --show&lt;/code&gt; 显示当前的 NUMA 设置：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# numactl --show&lt;/span&gt;&lt;br/&gt;policy: default&lt;br/&gt;preferred node: current&lt;br/&gt;physcpubind: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 &lt;br/&gt;cpubind: 0 1 &lt;br/&gt;nodebind: 0 1 &lt;br/&gt;membind: 0 1 &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--cpubind=0&lt;/code&gt;：绑定到 node 0 的 CPU 上执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--membind=1&lt;/code&gt;：只在 node 1 上分配内存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--interleave=nodes&lt;/code&gt;：nodes 可以是 all、N,N,N 或 N-N，表示在 nodes 上轮循（round robin）分配内存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--physcpubind=cpus&lt;/code&gt;：cpus 是 /proc/cpuinfo 中的 processor（超线程） 字段，cpus 的格式与 --interleave=nodes 一样，表示绑定到 cpus 上运行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--preferred=1&lt;/code&gt;：优先考虑从 node 1 上分配内存。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# 运行 test_program 程序，参数是 argument，绑定到 node 0 的 CPU 和 node 1 的内存&lt;/span&gt;&lt;br/&gt;numactl --cpubind=0 --membind=1 test_program arguments&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 在 processor 0-4，8-12 上运行 test_program&lt;/span&gt;&lt;br/&gt;numactl --physcpubind=0-4,8-12 test_program arguments&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 轮询分配内存&lt;/span&gt;&lt;br/&gt;numactl --interleave=all test_program arguments&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 优先考虑从 node 1 上分配内存&lt;/span&gt;&lt;br/&gt;numactl --preferred=1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;测试 NUMA&lt;/h1&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;sys/time.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;vector&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt;** argv)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; size = &lt;span&gt;std&lt;/span&gt;::stoi(argv[&lt;span&gt;1&lt;/span&gt;]);&lt;br/&gt;  &lt;span&gt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;&lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;&lt;span&gt;uint64_t&lt;/span&gt;&amp;gt;&amp;gt; &lt;span&gt;data&lt;/span&gt;&lt;span&gt;(size, &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;vector&lt;/span&gt;&amp;lt;&lt;span&gt;uint64_t&lt;/span&gt;&amp;gt;(size))&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;timeval&lt;/span&gt; &lt;span&gt;b&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;  gettimeofday(&amp;amp;b, &lt;span&gt;nullptr&lt;/span&gt;);&lt;br/&gt;  # 按列遍历，避免 CPU cache 的影响&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; col = &lt;span&gt;0&lt;/span&gt;; col &amp;lt; size; ++col) {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; row = &lt;span&gt;0&lt;/span&gt;; row &amp;lt; size; ++row) {&lt;br/&gt;      data[row][col] = rand();&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; &lt;span&gt;timeval&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;  gettimeofday(&amp;amp;e, &lt;span&gt;nullptr&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;Use time &quot;&lt;/span&gt;&lt;br/&gt;            &amp;lt;&amp;lt; e.tv_sec * &lt;span&gt;1000000&lt;/span&gt; + e.tv_usec - b.tv_sec * &lt;span&gt;1000000&lt;/span&gt; - b.tv_usec&lt;br/&gt;            &amp;lt;&amp;lt; &lt;span&gt;&quot;us&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# numactl --cpubind=0 --membind=0 ./numa_test 20000&lt;/span&gt;&lt;br/&gt;Use time 16465637us&lt;br/&gt;&lt;span&gt;# numactl --cpubind=0 --membind=1 ./numa_test 20000 &lt;/span&gt;&lt;br/&gt;Use time 21402436us&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出，测试程序使用远程内存比使用本地内存慢了接近 30%&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Linux 的 NUMA 策略&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 识别到 NUMA 架构后，默认的内存分配方案是：优先从本地分配内存。如果本地内存不足，优先淘汰本地内存中无用的内存。使内存页尽可能地和调用线程处在同一个 node。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种默认策略在不需要分配大量内存的应用上一般没什么问题。但是对于数据库这种可能分配超过一个 NUMA node 的内存量的应用来说，可能会引起一些奇怪的性能问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是在网上看到的的例子：由于 Linux 默认的 NUMA 内存分配策略，导致 MySQL 在内存比较充足的情况下，出现大量内存页被换出，造成性能抖动的问题。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;The MySQL “swap insanity” problem and the effects of the NUMA architecture&lt;sup&gt;4&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;A brief update on NUMA and MySQL&lt;sup&gt;5&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;参考资料&lt;/h1&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;UMA（Uniform Memory Access, 一致性内存访问）：https://en.wikipedia.org/wiki/Uniform_memory_access&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NUMA（Non-Uniform Memory Access, 非一致性内存访问）：https://en.wikipedia.org/wiki/Non-uniform_memory_access&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;numactl：https://linux.die.net/man/8/numactl&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;The MySQL “swap insanity” problem and the effects of the NUMA architecture：http://blog.jcole.us/2010/09/28/mysql-swap-insanity-and-the-numa-architecture/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;A brief update on NUMA and MySQL：http://blog.jcole.us/2012/04/16/a-brief-update-on-numa-and-mysql/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NUMA架构的CPU -- 你真的用好了么？：http://cenalulu.github.io/linux/numa/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Thread and Memory Placement on NUMA Systems: Asymmetry Matters：https://www.usenix.org/conference/atc15/technical-session/presentation/lepers&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NUMA (Non-Uniform Memory Access): An Overview：https://queue.acm.org/detail.cfm?id=2513149&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NUMA Memory Policy：https://www.kernel.org/doc/html/latest/admin-guide/mm/numa_memory_policy.html&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;What is NUMA?：https://www.kernel.org/doc/html/latest/vm/numa.html&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0e0dd808728704db999b3a64292ec014</guid>
<title>好的重构方法才能摆脱 “屎山”</title>
<link>https://toutiao.io/k/rr23n1t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;strong&gt;&lt;span&gt;这里是Z哥的个人公众号&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;每周五11：45 按时送达&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;当然了，也会时不时加个餐～&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;我的第「171」篇原创敬上&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;大家好，我是Z哥。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最近在整理一些项目，所以相关的文章写的多了些。之前的相关文章有《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NzEwMDc4OQ==&amp;amp;mid=2247485351&amp;amp;idx=1&amp;amp;sn=63580ffa1d350032afab8aae7544adb8&amp;amp;chksm=fca313bdcbd49aab984df27355ef518c0ab6100bc96580a26fa1969042ad71093b6ba4282062&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;聊聊单元测试&lt;/a&gt;》，感兴趣的话可以点击文末链接去阅读。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这次整理项目的时候，做了比较多的codereview和重构。好久没做这么高强度了重构了，所以对重构这件事有了新的思考和理解。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;突然发现叫我们程序员“码农”还挺形象的，因为写代码和种田很像，想有个好收成，就要好好管理代码，让它们井井有条。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;吴军老师在《文明之光》里讲到一个「垄耕种植法」，它由中国人发明，后发扬到全球，影响了全世界的粮食生产。据说欧洲人民以前是把种子随意地撒在地里，任其自由生长，结果收成很低，如果种下20斤，大概只能收获60斤左右粮食。而中国早在先秦时期亩产最少都在240斤以上，最新的数据是今年11月初袁隆平的杂交水稻，早晚稻加起来达到3000斤，这都得益于「垄耕种植法」。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，当你看到那些被随意“播种”的糟糕代码，是改，还是不改？改吧，花时间；不改吧，就像上面的欧洲人民。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其实很多人对「重构」的理解还有些误区。「重构」仅仅是所谓的优化代码吗？并不是。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Martin Fowler大神在他的《重构》一书中对「重构」的定义就非常准确。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;95&quot; data-source-title=&quot;《重构》Martin Fowler&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;blockquote_info js_blockquote_source&quot; data-json=&quot;%7B%22type%22%3A%22out%22%2C%22source%22%3A%22url%22%2C%22digest%22%3A%22%22%2C%22digestLen%22%3A95%2C%22text%22%3A%22%E9%87%8D%E6%9E%84%EF%BC%88%E5%90%8D%E8%AF%8D%EF%BC%89%EF%BC%9A%E5%AF%B9%E8%BD%AF%E4%BB%B6%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%80%E7%A7%8D%E8%B0%83%E6%95%B4%EF%BC%8C%E7%9B%AE%E7%9A%84%E6%98%AF%E5%9C%A8%E4%B8%8D%E6%94%B9%E5%8F%98%E8%BD%AF%E4%BB%B6%E5%8F%AF%E8%A7%82%E5%AF%9F%E8%A1%8C%E4%B8%BA%E7%9A%84%E5%89%8D%E6%8F%90%E4%B8%8B%EF%BC%8C%E6%8F%90%E9%AB%98%E5%85%B6%E5%8F%AF%E7%90%86%E8%A7%A3%E6%80%A7%EF%BC%8C%E9%99%8D%E4%BD%8E%E5%85%B6%E4%BF%AE%E6%94%B9%E6%88%90%E6%9C%AC%E3%80%82%C2%A0%E9%87%8D%E6%9E%84%EF%BC%88%E5%8A%A8%E8%AF%8D%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%E4%B8%80%E7%B3%BB%E5%88%97%E9%87%8D%E6%9E%84%E6%89%8B%E6%B3%95%EF%BC%8C%E5%9C%A8%E4%B8%8D%E6%94%B9%E5%8F%98%E8%BD%AF%E4%BB%B6%E5%8F%AF%E8%A7%82%E5%AF%9F%E8%A1%8C%E4%B8%BA%E7%9A%84%E5%89%8D%E6%8F%90%E4%B8%8B%EF%BC%8C%E8%B0%83%E6%95%B4%E5%85%B6%E7%BB%93%E6%9E%84%E3%80%82%22%2C%22article%22%3A%7B%7D%2C%22hasReportOverSize%22%3Afalse%2C%22editorReportData%22%3A%5B%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2276%22%2C%22len%22%3A1%7D%5D%2C%22from%22%3A%22%E3%80%8A%E9%87%8D%E6%9E%84%E3%80%8BMartin%20Fowler%22%7D&quot;&gt;&lt;span class=&quot;blockquote_other&quot;&gt;《重构》Martin Fowler&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，重构不仅仅是修改代码，是对软件结构的调整，修改代码只是其中的一个手段而已。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么具体应该怎么做呢？在这之前，需要考虑清楚以下几个问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;/01  什么时候重构？/&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;很多理想主义者认为的理想情况自然是随时发现坏代码就重构。但是这里存在两个问题：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以我们需要几个更加客观的外部标准，Z哥建议你可以从以下三个方面来观察，如果发现了类似的现象，说明它在给你发出需要重构的信号。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/02  怎么重构？/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了保证重构的质量，在你重构的过程中，一定要关注以下4个关键点：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以回想一下，你之前做过的重构是否都符合了以上的这些要求？反正Z哥最近做的重构是不符合的，所以感觉很累很痛苦～&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具体的重构工作其实说起来很简单，因为一段代码无非就是「输入参数」、「输出参数」、「方法体」3个东西，重构也自然以这几个地方展开。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/01  输入参数/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于输入参数的重构，主要关注在参数的个数上。那些优秀的开源项目里，你几乎看不到参数很多的方法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因为过多的参数个数，不但不容易理解，而且你在写调用这个方法的代码的时候也会很头疼，时不时要数一下这是第几个参数，对应的参数说明是什么。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有一些工具推荐的默认参数最大长度是7个（如SonarQube）。如果你没有更好的定义和理解，那么不妨以“7”这个标准来执行。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/02  输出参数/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;输出参数只有一个，能够出乱子的空间也很小，所以一般来说不需要怎么优化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;唯一值得提醒的两点是：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;参数类型尽量用强类型。弱类型的返回值虽然让你的Function向后兼容性很好，但是也带来了很多无法在编译期间被发现的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不返回不需要的参数。添加更多参数在最初肯定是为了“跑在业务前面”，但这份好心往往最终带来的是更多“意料之外的耦合”，导致后续的重构成本大增。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/03  方法体/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于方法体的重构是花费时间最多的地方，具体的方式方法也很多。但是我建议你一定要坚持一个核心要点，我将它称为「NRD重构法」，这3个字母分别表示：New、Replace、Delete。也就是说，做重构的时候不要直接在原来的方法体里改，重新建一个新的方法，然后等单测跑通之后再替换掉老方法，最后再把老方法删除。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;只要做到这点，要满足前面提到的4个关键点，就没那么困难了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具体的重构内容自然是以减少复杂度为核心思路去做。衡量代码复杂度有一个概念叫「圈复杂度」（也叫「循环复杂度」），在1976年由Thomas J. McCabe, Sr. 提出。现在有不少工具有统计这个指标。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;复杂度大说明程序代码可能质量低且难于测试和维护，根据经验，程序的可能错误和高的圈复杂度有着很大关系。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;复杂度大的代码往往伴随着大量的if/switch/for/foreach/try...catch/while等等。每一次试用都会让「圈复杂度」+1，并且其中的条件判断越多，增加的越快。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，常见的重构方式大多以降低代码的圈复杂度为主。比如，&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;还有很多小众的重构技巧这里就不赘述了，真是觉得大家都应该读一读《重构》这本书。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;多说一句，不提倡刻意降低代码行数的方法，因为你的复杂度不下降，减少代码行数只是“掩耳盗铃”而已。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外，重构有一个最佳伴侣，就是单元测试。你想象一个画面，当你重构之前通过率100%的单元测试在重构完成后跑一遍，发现了10%的失败。此时你的心情肯定是“真香，否则一堆bug等着我修”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不过，如果你的代码「圈复杂度」越高，单元测试写起来越费劲。如何写好单元测试可以看我之前写的文章《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NzEwMDc4OQ==&amp;amp;mid=2247485351&amp;amp;idx=1&amp;amp;sn=63580ffa1d350032afab8aae7544adb8&amp;amp;chksm=fca313bdcbd49aab984df27355ef518c0ab6100bc96580a26fa1969042ad71093b6ba4282062&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;聊聊单元测试&lt;/a&gt;》。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后，怎么判断重构的效果好不好呢？自然是工作效率是否提高了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;增加一个功能或者接口的时间是不是缩短了？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;测试那边回归测试的平均时间是不是缩短了？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;好了，就这么多。如果你还是觉得无从下手，不妨试试《重构》作者推荐的一种做法:&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;随机挑选一个目标，比如，“去掉一堆不必要的子类”。然后朝着目标前进，没把握就停下来。当你无法证明自己所做的修改能够保证原有程序的逻辑和语义时，立马停下来思考：当前做的重构是改善了？还是毫无成果需要撤销？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后再次强力推荐《重构》这本书，里面有很多非常具体的代码重构方法，值得每一位程序员入手一本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;mpcps frameborder=&quot;0&quot; class=&quot;js_editor_cps&quot; data-datakey=&quot;1604914048250_0.953375247605875&quot; data-uid=&quot;1604914048249&quot; data-type=&quot;1&quot; data-product=&quot;&quot; data-templateid=&quot;list&quot; data-pid=&quot;12584498&quot; data-categoryid=&quot;3&quot; data-appuin=&quot;3208869061&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;好了，总结一下。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这篇呢，Z哥和你分享了我对代码重构这件事的看法。要想提高你代码的“产出”，那么就得好好重视重构这件事。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在重构代码的「输入参数」、「输出参数」、「方法体」的时候需要持续保持以下4个关键点：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这才能使得你的重构工作平稳的进行，而不会是一场赌博。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;并且，重构方法体的时候要以降低「圈复杂度」为目的，而不是代码行数。如果条件允许，尽量多写一些单元测试来保障重构的稳定性。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;希望对你有所启发。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;重构可以使软件更容易地被修改和被理解，这个意义甚至大于所谓的“优化和改进”。Kent Beck大神曾也经说过：首先让代码架构易于改变，然后再进行简单的改进。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你想摆脱代码越改越痛苦的困境，那么赶紧行动起来吧。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原创不易，如果你觉得这篇文章还不错，就「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」或者「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;分享&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」一下吧。鼓励我的创作 ：）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.4428822495606327&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/oB5bd6W6hI1Xrkr3iaFRP5fErfmjHqlBw160icnia8yicWBlicnPEfqGE80alzGl9FLj6FxyuibIuliceoH9zicibj95loQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1138&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你有关于软件架构、分布式系统、产品、运营的困惑&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以试试点击「&lt;strong&gt;阅读原文&lt;/strong&gt;」&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>