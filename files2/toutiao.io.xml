<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>fae532b3c3603114df73d958063ce428</guid>
<title>2021 年马上就要结束了！抓紧啦！</title>
<link>https://toutiao.io/k/rf8ezjy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b4c9d0056972b85dbc21f2bf1acb67da</guid>
<title>最适合程序员的画图工具？</title>
<link>https://toutiao.io/k/ptc0yky</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;14&quot; data-source-title=&quot;&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;来自公众号：&lt;span&gt;小林coding&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;大家好，我是小林。&lt;/section&gt;&lt;p&gt;最近很多读者私信问我，我图解文章中用到的画图工具、思维导图工具、代码贴图工具是什么？&lt;/p&gt;&lt;p&gt;我在很早的时候提到过，不过时间有点久了，而且比较零散，可能现在大部分读者还不知道。&lt;/p&gt;&lt;p&gt;我今天统一整理一下，我图解文章用到的各类工具吧，这些工具我用了一年多了，没发现什么问题，所以是值得推荐的。&lt;/p&gt;&lt;p&gt;我这里先列一下：&lt;/p&gt;&lt;p&gt;接下来，详细聊一聊。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;画图工具&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;这篇文章的封面图就是 &lt;/span&gt;&lt;span&gt;draw&lt;/span&gt;&lt;span&gt;.io&lt;/span&gt;&lt;span&gt; 的开发团队。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;我的图解文章里的图片全是在 draw.io 这个工具画的，写了那么久的图解文章，再加上我工作中也有画图的习惯，累计也有在上面画了接近 1000+ 张图片。&lt;/p&gt;&lt;p&gt;选择它的原因很简单，因为是免费的，而且图片的源文件可以直接保存到 Github 的，这样非常方便，相当于直接云备份到了 Github 仓库里，然后用 Github 作为图床。&lt;/p&gt;&lt;p&gt;这一套操作下来，不管是画图工具，还是图床，都是不花一分钱的方案！&lt;/p&gt;&lt;p&gt;draw.io 画图工具可以在线画图，或者下载应用，或者作为 visual studio code 插件来使用。&lt;/p&gt;&lt;p&gt;我比较常用的方式是在线画图，就是直接在网站上画图。draw.io 一开始的画图网站地址就是直接在浏览器输入 draw.io  地址后，就会自动进入在线画图工具页面，现在它改版了， 改成重定向到官网地址了，所以现在想进入在线画图工具页面，地址是：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;https://app.diagrams.net&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当然，如果你想下载应用来使用，也可以在 Github 下载：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;https://github.com/jgraph/drawio-desktop/releases/&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们来看看这个画图工具的页面长什么样子，主要分为三个区域，从左往右的顺序是「图形选择区域、绘图区域、属性设置区域」。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5897435897435898&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWXMmITXMW0VDpIWFaD7VmPP9GFBpjWYcAtZUQrr4cjXQhajtz8kaJPRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1560&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;其中，最左边的「图形选择区域」可以选择的图案有很多种，常见的流程图、时序图、表格图都有，甚至还可以在最左下角的「更多图形」找到其他种类的图形，比如网络设备图标等。&lt;/p&gt;&lt;p&gt;具体的画图方法，我在之前的文章详细介绍过：「&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&amp;amp;mid=2247486263&amp;amp;idx=1&amp;amp;sn=90f7cb9782162f40e8b6aec1ad954491&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;我的 500 张图是怎么画的？&lt;/a&gt;」，这次我就不再赘述啦。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;之前没有详细介绍，怎么将文件保存到 Github，然后作为图床使用，这次补充下&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;1、在浏览器输入地址：https://app.diagrams.net，进入到在线画图网站后，就会弹出保存文件到什么地方的选择，可以保存到本地、Github、OneDrive等。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0342298288508558&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWXgmbtZozP4Pen1j505pMq12U0JdbFXE8l4sYC1nMYsxShXDUCaibEQDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;818&quot;/&gt;&lt;/p&gt;&lt;p&gt;2、选择保存到 Github 后，就选择创建一个新的画图文件。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.735224586288416&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWXXB8x01ewFaVrTsibT7aamjJ2zYQcBGgsiclcwv4dBQ1sI4xBGDWoHkAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;846&quot;/&gt;&lt;/p&gt;&lt;p&gt;3、选择创建一个空白的图片，然后可以给文件取个名字，画图的源文件后缀是 .drawio，最后点击创建。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7546897546897547&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWXCIUDmjvNHoy9a1MsicoXLKiapqyfGy6W0p26hfianvU5OhOH0G7TuqWXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1386&quot;/&gt;&lt;/p&gt;&lt;p&gt;4、点击创建后，就会弹出获取你的 Github 账号权限，点击同意就行。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8667992047713717&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWXezxVFiaIoPv2g7ictnD4ibicLJsG77QoHc7rlZmKGmiauvBAjjyxib4FWeibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1006&quot;/&gt;&lt;/p&gt;&lt;p&gt;5、接着输入你的 Github 账号密码。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2860360360360361&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWXI2leygFOWdZJVvyD0pL4iaKpUly23HOv3bCv4klXeaia4AKpy0WUuRfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;888&quot;/&gt;&lt;/p&gt;&lt;p&gt;5、登陆完后，选择你要保存的 Github 仓库，比如我选择这里：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7738998482549317&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWXYB0qeqHuBp2jiaHicCib22DqekgpmDDTTOPXpf2f5qH7xJrL8eQsTdyEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1318&quot;/&gt;&lt;/p&gt;&lt;p&gt;6、接着，点击同意授权。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3225225225225225&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWXhzTYbPD1nNNMdXSLzOUcx8soPencwTJ7plZbiafP51oLznjqJe7cWfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1110&quot;/&gt;&lt;/p&gt;&lt;p&gt;7、然后就会跳转到一个网站，在你的Github需要安装 draw.io App，直接点击安装即可，&lt;strong&gt;初次使用才会有这一步，后面就不用那么麻烦了&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4333034914950761&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWXavZkRqOBMhXat3YAsmJaL4fXKXpsjg3p5bM1K7rwBtGauHbkiaTqwjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2234&quot;/&gt;&lt;/p&gt;&lt;p&gt;8、然后选择你要授权的仓库，可以是某个仓库，也可以全部仓库，我这里为了方便，就直接选择了所有仓库。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8860182370820668&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWX1icZziabALQqoicO9DbQeRfia4HpvJK8Vu1r45sL4Ibp2gjF3bKicQHH81A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1316&quot;/&gt;&lt;/p&gt;&lt;p&gt;9、安装完成后，在回到在线画图网站，点击「try again」。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7541208791208791&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWXslR8Q7TkEV4eA037S5GUug8nrs9cQ5xREUePEKWp8B48rwcic6IPHcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1456&quot;/&gt;&lt;/p&gt;&lt;p&gt;10、到这一步，授权的工作就完成了。然后，就可以开始画图了。画完图后，就可以导出 png 图片。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.006631299734748&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWXic594RhzJJicYxlfHTf4TlFxbSQPH3TXu5zNhBvdTJKaCZUFLDK2DpGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1508&quot;/&gt;&lt;/p&gt;&lt;p&gt;11、我直接将 png 图片保存到 Github。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8957169459962756&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWXR6D3FPQCsmKMZWAWUF5HF5Q5cud7B23LMfZDc54oJ3mGggCCeKT5Zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1074&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8767395626242545&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWXBYlCdz5llb3L8icfsVvOo7hib1y7I2hBRZLVwkLy46Azmq4G6ytuCAww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1006&quot;/&gt;&lt;/p&gt;&lt;p&gt;12、保存好图片后，我们可以用以下地址作为图片的地址。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.71280276816609&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWXpwrkwbEMQct4eibL7poHlcQZLIAPyVAUEnDqpEIpclRAqCoiaRmjMouw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1734&quot;/&gt;&lt;/p&gt;&lt;p&gt;我这个地址是经过 jsdeliver cdn 加速的了，这个 cdn 也是免费的。地址的构成是这样的：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2161520190023753&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWX4rWzKCb03icibuUHo1tIuiaGLpNm9ErCliaAzejVd4AswVT0icPrSlB7CpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;842&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;也就是说，红色部分的前缀地址是固定的，绿色部分的地址是根据文件的保存仓库路径而变更就行。&lt;/p&gt;&lt;p&gt;如果你嫌这样替换地址麻烦，想自动化一点。可以搭配使用 pingo 工具来上传图片，上传完图片它会自动生成一个经过 jsdeliver cdn  加速的地址。网上的资料很多，关键词搜索「github + jsdeliver cdn + pingo」即可。&lt;/p&gt;&lt;p&gt;怎么样，这一套免费版的画图+Github云同步+图床的方案，还是很舒服的。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;思维导图工具&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;我用的思维导图工具是 xmind，是国产的。他们软件的交互设计做的很不错，很简洁明了。&lt;/p&gt;&lt;p&gt;它有很多种风格选择，基本都是五彩的，整体挺好看的。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.681912681912682&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWXTyu4ichuHwJicktpYCuMoSbHELk3icnE5Kc5XBltpxdAibb0wYqVibzN2ag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1924&quot;/&gt;&lt;/p&gt;&lt;p&gt;有意思的地方，这个思维导图工具的右侧会有一些图标图片选择，比如表情图片、标签图片、进度图图片等等。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5962897526501767&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWXkOjwqbj2YCibnMEkWWTre7fjbKz5m9HwJZ9NdylzYvEUqicg9zYtuALQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2264&quot;/&gt;&lt;/p&gt;&lt;p&gt;习惯用思维导图做笔记的同学， xmind 这个思维导图工具是个不错的选择。&lt;/p&gt;&lt;p&gt;另外，我有时会使用 Effie 这个工具来生成思维导图，它本身是一个写作的工具，但是自带一个根据文字内容生成思维导图的功能。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5198237885462555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWXTw6zXk1FovsoWE6BXpDN76er0cOhJp5MKKUFt51MDdzl3tDyW0sssA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3178&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;代码贴图工具&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;如果你想展示你的代码，又苦于源代码的样式不好看，则可以使用一个生成漂亮的代码贴图网站。&lt;/p&gt;&lt;p&gt;地址：&lt;strong&gt;&lt;span&gt;https://carbon.now.sh&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6901270772238515&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWXcDc9wAuwEw10VerbofheaYz2CBx8d735pPIGPUC0SUnzYy2CF8BUrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2046&quot;/&gt;&lt;/p&gt;&lt;p&gt;导出图片后，就一张漂亮的代码展示图。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;364&quot; data-backw=&quot;500&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7290552584670231&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWXOoZfpTqF6vibkqmIm0O876S1rWbDkRnsicCWCnLpKgSI3b9YQO6yCbNw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1122&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;文章编写工具&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;我写文章都是用 mardown 格式，这样的好处是能方便发布到各个博客平台。&lt;/p&gt;&lt;p&gt;刚好有道云笔记支持 mardown 格式，所以一直都在用这个，但是永久后，它的双屏显示体验不是很好，就是左边是 mardown 格式的文档，右边是显示渲染的效果。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5168539325842697&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWX0Vck6cVkiccmDbpu9UPHhJEWSwCpJnMzhrpnGPIzMNSdlnYGafuiaLGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2670&quot;/&gt;&lt;/p&gt;&lt;p&gt;最近就开始转到 typora 写文章了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7032871972318339&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWXS7wKM50E9sRUqSXt4FhpwyP1tShJjQZ2yrh5NZHsmMZ1UHmRkIlvuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2312&quot;/&gt;&lt;/p&gt;&lt;p&gt;因为 typora 自身没有云备份功能，所以我是将 md 文件直接保存到 iCoud 云盘的文件夹，这样相当于实现了文件内容自动备份功能，再也不怕文章内容丢失了，坏处就是无法跨平台，因为 iCoud 云盘只能用于 macOS 系统。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.47391304347826085&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWXDibA9oBwGicSEfQ1RFyw5vyKr19SvMLcJ5vNWuS2xic2icgiaziayYrS70aA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1840&quot;/&gt;&lt;/p&gt;&lt;p&gt;最新版本的 typora 已经开始要收费了，我一直没有更新，所以还是免费的状态。&lt;/p&gt;&lt;p&gt;还有一点，typora 有生成 pdf 的功能，我之前生成的图解系统和图解网络的 pdf，就是在 typora 生成的。&lt;/p&gt;&lt;p&gt;有时候写一些感想类的文章，我就直接在 Effie 这个工具写，因为它的页面非常简洁纯粹，就是一张大白纸页面，非常容易专注起来，而且是支持 mardown 格式的语法。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5645833333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWX6DIut0b8OlsFFZoCtbwr6ot1klkncr2JsM71YVB9yC0qmZ1v27auIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2880&quot;/&gt;&lt;/p&gt;&lt;p&gt;还有很多优秀的记笔记的软件，比如语雀、notion、wolai等等。我之前也分享过我用到的云笔记软件：&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzA3MjMzODExOA==&amp;amp;mid=2651726164&amp;amp;idx=2&amp;amp;sn=90823b8748b0d1e4670ea131bdc7cdac&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;最适合‍程序员的云笔记？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;最适合程序员的云笔记？&lt;/a&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;以上这些就是我写文章的时候，常用的工具了，看起来很多，其实用习惯的话还好，而且基本都是不花钱的工具，用起来也很 nice。&lt;/p&gt;&lt;p&gt;你们日常中有哪些好用神仙软件，也可以评论区说下，我来种种草&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZdkgpaJYKtsDrueUVianNYWX5TM3XQlBapflZOMZbUcPhb9TH2Kc6PI0IY6WkbTufSO7jqzGib6Dacw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;span&gt;--- EOF ---&lt;/span&gt;&lt;br/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;推荐↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIxNDEzMjQwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/KSFIvW4ibNQJTv76dfOBtwAcfghHzt7gO8LCR7ZaPjhg16e9X17GSMQWfMUnD3D2qaRPUsDGezZLdubCiagEzWOg/0?wx_fmt=png&quot; data-nickname=&quot;程序员头条&quot; data-alias=&quot;CoderTop&quot; data-signature=&quot;10:24 一起看程序员热点新闻。把握行业热点，紧跟行业脚步&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a02f4657f1635b4ecba0b7c365de8651</guid>
<title>存储架构：聊聊 LSM Tree 强悍的设计</title>
<link>https://toutiao.io/k/d8v52r0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6865520728008089&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4UtmXsuLoNfLMsMG19iaWiaSic9FnlsP58XwUHxbibOjuClFHicCEUjl8kRqh7MwTO6xwyBiaPshMRmVbjQhoBpcyiapg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1978&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 什么是 LSM Tree ？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LSM Tree 全名：Log Structured Merge Tree ，是一种在机械盘时代大放异彩的存储架构设计。LSM Tree 是一个把顺序写发挥到极致的设计架构。它的核心之一就是 log 文件。笔者以几个问答来看下它的设计思想：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;问题一：LSM Tree 存储引擎到底是什么？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不就是一个 key/value 存储引擎嘛。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;问题二：用户写是怎么一个流程？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;用户递交数据流程分为两步：写 log 文件，修改内存。所以会看到，写的流程是非常简单的，用户的时延正常情况下就只包含这两步。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;问题三：用户的删是怎么一个流程？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;LSM Tree 为了极致的写性能把所有的更新操作都化作顺序写。也就是说，删除也是写入。往存储里面写一条带删除标记的记录，而不是直接更新原来的数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;问题四：这是一个持久化的存储吗？能保证掉电不丢数据吗？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;是持久化的，因为 log 持久化了嘛。掉电不会丢数据，因为可以从 log 文件中恢复出来。恢复很简单，其实就是遍历 log 文件，然后解析出来就好。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那既然说到解析 log 文件，那么问题又来了，log 文件越大解析时间会越长，无限制增长这个是无法忍受的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;问题五：log 文件本身是不具备查找功能的，那怎么办？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;log 文件其实是一种有时间顺序的文件，新数据不断的往后 append 写入，这种结构利于实现顺序写。但是从用户 key/value 来讲是 log 的结构是一种无序的结构，它的查找效率非常低。所以，自然而然，LSM 的架构里就需要引入一种新型的有序的数据结构，这个就是 sst 文件（ 全名：sorted string  table ）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以，看到了，持久化的 log 数据向有序的 sst 文件转变是 LSM 的一个核心的流程。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;划重点：sst 为有序的结构。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;问题六：为什么 sst 文件经常很多个？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;log 文件转变到 sst 文件是持续不断发生的。所以，很自然的，所以，系统中不会只有一个不断变大 sst 文件。因为一个庞大的空间这种查找效率会很低，并且每次重建一个有序的 sst 文件的开销会很大。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以，在 LSM 的实践中，是划分了很多个有序的空间（sst 文件），每个文件内部又按照 block 划分，block 内部又按照 restart point 划分。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;问题七：冗余或被删除的空间怎么释放？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;把有效的数据从 sst 文件中读出来（删除或者被覆盖的旧数据丢弃）写到新的文件，然后修改指向关系，然后把旧的文件删掉。这个过程叫做 compact ，compact 是 LSM 设计中另一个核心流程。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2. LSM Tree 的设计思想？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;存储的核心是读写，针对读写有不同的优化手段，比如预读、缓存、批量、并发、聚合等等。但是优化读和优化写能采用的手段其实不同，在机械盘时代，机械盘一定是瓶颈，它的随机性能极差，顺序的性能还能将就。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果要优化 IO 读，有非常多的优化策略，比如使用多层缓存，CPU Cache、内存、SSD 等等，也可以采用丰富多彩的查询组织结构，比如各种平衡树型结构，提高读的效率。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但是，对于写，它一定是受限于磁盘的瓶颈。因为写的流程，数据落盘才算完。所以，对于写的优化手段非常有限，无论用什么手段，一定绕不过一点：保持顺序，因为只有这样才能压榨出机械盘的性能。在写保持顺序的基础上，才去考虑加上其他的优化手段，比如批量，聚合等操作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这正是 LSM Tree 的设计思想，考虑极致的提升写的性能，读的性能则靠其他的手段解决。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面介绍一些具体的 LSM Tree 项目的优秀实现。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;3. LSM Tree 的架构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;先声明一下，下面的架构设计就假定按照 leveldb 的实现介绍，虽然 rocksdb 也是 LSM 的实现但是加了很多复杂特性，介绍起来还挺麻烦的。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h3&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;3.1 整体架构&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;先看看 LSM 的架构里有哪些东西吧，我们一个个说说：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;CURRENT 是个文本文件，里面存的是一个文件名，记录当前可用的 MANIFEST 文件；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;MANIFEST 是一个二进制文件，里面存储的是整个集群的元数据；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;log 文件则是 wal 文件，是承接用户写 IO 的文件，这个文件的写性能直接关联用户的写性能；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Memtable 和 Immutable Memtable 是内存结构，一般实现为一个具备查询效率的数据结构，比如跳表结构；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;ssttable 文件是内部生成的文件，每个文件都是按照 key 排序的文件。sst 内容格式都是一样的，但是大小不一定；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Memtable（还有 Immutable Memtable）和 sstable 都是需要承接用户读 IO ，所以这两个里面都有大量的提升查询效率的手段。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5553202752779248&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4UtmXsuLoNfLMsMG19iaWiaSic9FnlsP58XBPDkRdkGVewUSbRJTcwFicuZu1jWvIQ9nVg6AjUDGuEbJ4liceibr4jUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1889&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从数据的格式转变来讲：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;log 的数据和 memtable 的数据是对应起来的（同一份数据），log 的数据结构本质是无序的，所以必须依赖于 memtable 的查询效率；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;log 和 memtable 的这份数据下一步的去路就是 sstable 文件喽，这些个 sstable 文件属于 Level 0 ；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Level 0 的 sstable 文件的去路是更底层 Level 的 sstable 文件喽，小的合并成大的，不断的往下沉喽。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;思考一个小问题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;log 存储的数据和 memtable 存储的数据量一般是一样大的？为什么？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;log 是时间上有序但是内容上无序的格式，它上面的数据就只能依赖于 memtable 来提高查询效率。换句话说，它两就是一份数据，自然一样大。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;3.2 写的流程&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;看了整体架构之后，简单看一眼用户的数据怎么存到系统的。步骤只有两步：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据先写 log 文件；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据再插入 memtable 结构中&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;就这样，用户的写流程就算完了。由于 log 是持久化的，所以能确保数据不丢。这是对写流程的极致优化，只有一个写 log 的 IO 消耗，并且是永远的 append 写入，简直是最理想的写流程。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;3.3 读的流程&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;数据读的流程就略显复杂了，因为数据的范围太大了，那么多 sst 文件，那么多 key 的范围，可得好好查一查。当然了，先从 memtable 开始，查不到就一步步往底层查，也就是到 Level 0，再到 Level 1、Level 2 等等。这里耗费的 IO 次数就不好说了，读的性能远比写要差多了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;既然聊到这里，大家都知道 sst 的读性能很差，那咋办？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;加“索引”喽。 和数据库的索引效果类似，都是为了提高读和查询效率的方法。所以，你仔细看会发现，在 leveldb、rocksdb 的实现离，有大量的索引结构。比如：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;leveldb 把整个 sst 文件划分成一个个 block 小段，然后在 sst 尾端都有一个 index block，用来索引数据块。这样就能快速定位到 key 在哪一个 block 里；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;sst 文件中还有个 bloom filter 的小块，布隆过滤器喽，又给读提升了一点性能；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;每个 block 里面呢，还有个 restart point 的数组，也能提高读性能&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;比如，sst 的图示如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6925223214285714&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4UtmXsuLoNfLMsMG19iaWiaSic9FnlsP58XoKUoA0ITBUoDs2rZ5ZGlnzq32oWBysaF6GxicT4M1nYfLVLa5tGZiaicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1792&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;整体设计就是把 sst 切成一个个有序的小块，极大的提高查询的效率。每一个 block 里面又有按照 restart point 数组划分：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3428345209817894&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4UtmXsuLoNfLMsMG19iaWiaSic9FnlsP58XIl8OW4cZp1icKCBiaxqccovIicsgv2I9RT8TGNdJYrVeeUvbstowL71mw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2526&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实，还有很多讲究哦。这就不提了，太多了，很多都是为了查询效率。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;3.4  compact 的流程&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;leveldb 的 compact 分为两种：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;minor compact ：这个是 memtable 到 Level 0 的转变；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;major compact ：这个是 Level 0 到底层或者底下的 Level 的 sstable 的相互转变&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里值得提一点的是，sstable 每个都是有序的。但是呢，Level 0 的文件之间可能是有范围交叉的，但是 Level 0 之下的 sstable 文件则绝对没有交叉。正因如此，Level 0 的文件个数就不能太多，不然会影响查询效率（因为相互覆盖嘛，所以每一个都要查的）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;为什么会这样呢？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为 Level 0 的文件是直接来源于 memtable，而没有去做合并。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;4. 优秀的开源实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;Leveldb&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;leveldb 是谷歌开源的一个 key/value 存储引擎，Github 地址：&lt;/span&gt;&lt;span&gt;https://github.com/google/leveldb&lt;/span&gt;&lt;span&gt; 。由大佬 Sanjay Ghemawat 和 Jeff Dean 开发并开源。整个项目 C++ 实现，代码精致优雅，值得学习。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;rocksdb&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;rocksdb 是 facebook 开源的一个 key/value 存储引擎，Github 地址：&lt;/span&gt;&lt;span&gt;https://github.com/facebook/rocksdb &lt;/span&gt;&lt;span&gt;。是基于 leveldb 项目的优化实现，适配 facebook 数据库团队的实际场景，特性要比 leveldb 多。整个项目 C++ 实现，代码实现也非常优秀，值得学习。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;goleveldb&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;考虑到奇伢的读者很多都是 gopher ，那自然要推荐一个 golang 的版本，就是 goleveldb ，github 地址：&lt;/span&gt;&lt;span&gt;https://github.com/syndtr/goleveldb &lt;/span&gt;&lt;span&gt;，这个项目实现的更小巧，值得学习推荐。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果说，你是个 gopher，并且对 LSM Tree 感兴趣，那么完全可以去撸一撸 gole&lt;/span&gt;&lt;span/&gt;&lt;span&gt;veldb 的源码。只要撸懂一个，那以后再深入就得心应手了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong&gt;更好的学习选择？用 Python 解析 LSM ？&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实，还有一个好选择，奇伢 fork 了 goleveldb ，会不定期更新一些代码注释，感兴趣的也可以看下，Github 地址：&lt;/span&gt;&lt;span&gt;https://github.com/liqingqiya/readcode-goleveldb-master&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;笔者在理解了 LSM 的结构之后，用 Python 脚本解析了一把 manifest 和 sst 文件，获益匪浅。贴上几个 python 解析 leveldb 的实例：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.48238897396630936&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4UtmXsuLoNfLMsMG19iaWiaSic9FnlsP58XEWJPlzzQB1ZJyT0GOsKsmzdcnWmtia8VUh0yaWdzWntsAuuoDq0QTHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2612&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当你从不同的角度去看到存储，可以获得更深入的理解。比如，从 python、golang 两个角度来看数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;比如，在 Go 里面写入一个 uint64 的整型到文件，如下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;binary&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.BigEndian&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.PutUint64&lt;/span&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;buf&lt;/span&gt;, 0&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;x123456789&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个编码出来就是：[ 0x00, 0x00, 0x00, 0x01, 0x23, 0x45, 0x67, 0x89 ] 这 8 个字节，然后把这个 []byte 数组写到文件即可。文件里是这样的：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;0x00, 0x00, 0x00, 0x01, 0x23, 0x45, 0x67, 0x89&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那怎么用 Python 读出来呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;读出来也是一个字节数组，怎么转化成 uint64 的类型呢？是这样的：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt;.unpack(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&amp;gt;Q&quot;&lt;/span&gt;, buf)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;划重点：&lt;strong&gt;只要是涉及到数据传输的场景，字节数组的形式才是通用的形式&lt;/strong&gt;。比如内存到磁盘，内存到网络等等，都是转成字节数组的形式，然后在别的地方按照特定规则构建出来就是无损的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里举这个例子，也只是想说明一点，LSM Tree 是一种有存储思想的架构设计，而不是跟具体的语言绑定的，一通百通。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么越来越多“唱衰” LSM 的声音呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;归根结底还是硬件发展起来了。在原先的机械盘（ HDD ）时代，leveldb/rocksdb 的最佳实践就是一个磁盘只有一个写入源（ wal ），所有的写请求都由这一个线程递交。这个是合理的，因为 HDD 最好的优化就是顺序化，并且一个线程串行递交请求也足以把 HDD 跑满。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但是自从 SSD 这种介质普及之后，一切都变了，单线程串行递交请求已经跑不满硬件了，比如 pcie 盘的通道就非常多，要并发全力压才能压的满。还有就是 SSD 盘随机性能太好了，单就性能数据来讲和顺序的差不多。那这个时候 LSM Tree 为了顺序化而做的复杂的东西可能就显得优先多余了，反倒让系统变得复杂。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;划重点：&lt;strong&gt;SSD 多通道并发、超高的随机性能是变革的核心因素&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;那存储引擎的架构会怎么演进呢？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;演进方向笔者也不确定。不过有一篇很出名的 FAST 上的论文 ：《WiscKey: Separating Keys from Values in SSD-Conscious Storage》就讨论了在 SSD 时代，LSM 架构的优化思路。并且立马就有开源的实现跟进了这个思路，比如 go 的 badger ，rocksdb 本身也有个集成了 BlobDB 的实验版本。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但实话说，LSM Tree 的架构会持续的优化，但会长时间持续存在，因为并不是所有场景都要用 SSD ，并且它不便宜。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;LSM Tree 是把写性能优化到极致的结构，当然了，这个极致的考虑就在于：顺序 IO、批量操作；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当顺序并不是性能的关键因素的时候，LSM Tree 的架构就有点冗余。这个想想最近不断出现的针对 SSD 盘的优化思路就知道了；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;LSM Tree 的架构中没有覆盖写，log 永远 append，sst 也是读旧的写新的。CURRENT，MANIFEST 也是先写临时文件，最后 rename 一下。所以 LSM Tree 的安全、一致性就得到了保证；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;LSM 牺牲了的读性能就靠各种“索引”结构、各种 cache 来解决；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;compact 有两种：minor，major compact 。minor compact 是有序的 mem 数据（对应无序的 log 文件）到 sst 的转变。major compact 是 sst 内部之间的转变；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在 SSD 没出来之前，写的有效优化手段只有顺序+批量，读的优化手段千奇百怪，从 LSM 的实现就可以窥见一二&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651480377&amp;amp;idx=2&amp;amp;sn=75a494b8d9a95c53e8f02ca622177262&amp;amp;chksm=bd250d468a528450b40ccb42288c18f93c86b0ec3674ac0201e8622eb24f1ba9e58a90bdafee&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;LSM-Tree 与 RocksDB&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;LSM-Tree 与 RocksDB&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651496416&amp;amp;idx=1&amp;amp;sn=c2e030b530b667b76e64850efa79ffab&amp;amp;chksm=bd25f39f8a527a896a082c89f391c7426d1f5890eb59c1fb28de04ec48770e11381c36a2b532&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Kafka 存储选型的奥秘&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Kafka 存储选型的奥秘&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651483483&amp;amp;idx=1&amp;amp;sn=4a76d8b346d0c21cff5000d4f934dbe1&amp;amp;chksm=bd2501248a528832fe6b52109980152786028d6dd11e663c3360b31760e2f210e8dcf880cdc8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Redis 为何这么快--数据存储角度&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Redis 为何这么快--数据存储角度&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; class=&quot;rich_pages wxw-img&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点赞和在看就是最大的支持❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3be7bbe64b5d31c59aa1427c5169b55a</guid>
<title>一文搞懂 Docker、Containerd、RunC 间的联系和区别</title>
<link>https://toutiao.io/k/01r96hf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;公众号关注 「&lt;span&gt;&lt;span&gt;奇妙的 Linux 世界&lt;/span&gt;&lt;/span&gt;」&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;设为「&lt;span&gt;星标&lt;/span&gt;」，每天带你玩转 Linux ！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;330&quot; data-fileid=&quot;100018142&quot; data-ratio=&quot;0.7411111111111112&quot; data-type=&quot;png&quot; data-w=&quot;900&quot; title=&quot;&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8ZFzrRjqatqXrOdCSa2hThu5Gg6HMCv6DdlZegicHFpPcvRoVSicfEqfgX84cSicqfoNt3hqf3ODSlFTkibB8yMg6Q/640?wx_fmt=png&quot;/&gt;&lt;br/&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;什么是RunC&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Docker、Google、CoreOS 和其他供应商创建了开放容器计划 (OCI)，目前主要有两个标准文档：容器运行时标准 （runtime spec）和 容器镜像标准（image spec）。&lt;/p&gt;&lt;section&gt;&lt;img data-fileid=&quot;100018144&quot; data-ratio=&quot;0.5130533484676504&quot; data-type=&quot;png&quot; data-w=&quot;881&quot; title=&quot;&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibD9iaaPDn99j6K4fEDVSvE6ficAhoLE4zqUeibAB9ia21GP6vJth7wFlcAYzFHqUUqOehrA9zXlU6gxmsyo5yNjjcg/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OCI 对容器 runtime 的标准主要是指定容器的运行状态，和 runtime 需要提供的命令。下图可以是容器状态转换图：&lt;img data-fileid=&quot;100018148&quot; data-ratio=&quot;0.6009132420091324&quot; data-type=&quot;png&quot; data-w=&quot;1095&quot; title=&quot;&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibD9iaaPDn99j6K4fEDVSvE6ficAhoLE4zqj0Znnf19vRk5dThuF4GIQHm1r2qPwLagc2znlorFBPEGhlE0d2pOCA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;init 状态：这个是我自己添加的状态，并不在标准中，表示没有容器存在的初始状态&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;creating：使用 create 命令创建容器，这个过程称为创建中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;created：容器创建出来，但是还没有运行，表示镜像和配置没有错误，容器能够运行在当前平台&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;running：容器的运行状态，里面的进程处于 up 状态，正在执行用户设定的任务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;stopped：容器运行完成，或者运行出错，或者 stop 命令之后，容器处于暂停状态。这个状态，容器还有很多信息保存在平台中，并没有完全被删除&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI3MTI2NzkxMA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/8ZFzrRjqatrP1H2ykr2xId1T1xNrZaVFuqGgQ3ycnJylh6A6h0vp2yqynejepUBcBufs3NWFKxl1QPsRxJ61YQ/0?wx_fmt=png&quot; data-nickname=&quot;奇妙的Linux世界&quot; data-alias=&quot;Hi-Linux&quot; data-signature=&quot;这里是 Linux 爱好者的聚集地，不仅有各种硬核干货文章和新奇内容推荐，还常常有福利红包等你来领哟。快快加入我们，一起愉快玩耍吧！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;Runc的来历&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RunC 是从 Docker 的 libcontainer 中迁移而来的，实现了容器启停、资源隔离等功能。Docker将RunC捐赠给 OCI 作为OCI 容器运行时标准的参考实现。Docker 默认提供了 docker-runc 实现。事实上，通过 containerd 的封装，可以在 Docker Daemon 启动的时候指定 RunC的实现。最初，人们对 Docker 对 OCI 的贡献感到困惑。他们贡献的是一种“运行”容器的标准方式，仅此而已。它们不包括镜像格式或注册表推/拉格式。当你运行一个 Docker 容器时，这些是 Docker 实际经历的步骤：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;下载镜像&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将镜像文件解开为bundle文件，将一个文件系统拆分成多层&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从bundle文件运行容器&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Docker标准化的仅仅是第三步。在此之前，每个人都认为容器运行时支持Docker支持的所有功能。最终，Docker方面澄清：原始OCI规范指出，只有“运行容器”的部分组成了runtime。这种“概念失联”一直持续到今天，并使“容器运行时”成为一个令人困惑的话题。希望我能证明双方都不是完全错误的，并且在本文中将广泛使用该术语。RunC 就可以按照这个 OCI 文档来创建一个符合规范的容器，既然是标准肯定就有其他 OCI 实现，比如 Kata、gVisor 这些容器运行时都是符合 OCI 标准的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;怎么使用 runc&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; create the bundle&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; mkdir -p /mycontainer/rootfs&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt; [ab]use Docker to copy a root fs into the bundle&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; docker &lt;span&gt;export&lt;/span&gt; $(docker create busybox) | tar -C /mycontainer/rootfs -xvf -&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt; create the specification, by default sh will be the entrypoint of the container&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; &lt;span&gt;cd&lt;/span&gt; /mycontainer&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; runc spec&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt; launch the container&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; sudo -i&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; &lt;span&gt;cd&lt;/span&gt; /mycontainer&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; runc run mycontainerid&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt; list containers&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; runc list&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt; stop the container&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; runc &lt;span&gt;kill&lt;/span&gt; mycontainerid&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;br/&gt;#&lt;/span&gt;&lt;span&gt; cleanup&lt;/span&gt;&lt;br/&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; runc delete mycontainerid&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在命令行中使用 runc，我们可以根据需要启动任意数量的容器。但是，如果我们想自动化这个过程，我们需要一个容器管理器。为什么这样？想象一下，我们需要启动数十个容器来跟踪它们的状态。其中一些需要在失败时重新启动，需要在终止时释放资源，必须从注册表中提取图像，需要配置容器间网络等等。就需要有Low-Level和High-Level容器运行时，runc就是Low-Level实现的实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; data-category_id_list=&quot;1|11|16|17|22|24|26|27|28|29|3|31|32|35|36|37|39|41|42|43|45|46|47|48|49|5|50|51|52|53|54|55|6|7|8&quot; data-id=&quot;1635413232590&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1635413232590&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;Low-Level和High-Level容器运行时&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当人们想到容器运行时，可能会想到一系列示例；runc、lxc、lmctfy、Docker（容器）、rkt、cri-o。这些中的每一个都是为不同的情况而构建的，并实现了不同的功能。有些，如 containerd 和 cri-o，实际上使用 runc 来运行容器，在High-Level实现镜像管理和 API。与 runc 的Low-Level实现相比，可以将这些功能（包括镜像传输、镜像管理、镜像解包和 API）视为High-Level功能。考虑到这一点，您可以看到容器运行时空间相当复杂。每个运行时都涵盖了这个Low-Level到High-Level频谱的不同部分。这是一个非常主观的图表：&lt;img data-fileid=&quot;100018145&quot; data-ratio=&quot;0.52&quot; data-type=&quot;png&quot; data-w=&quot;525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibD9iaaPDn99j6K4fEDVSvE6ficAhoLE4zq3X6gL7KDaAEAWpaibvrQ5tCt4iaEOGNmUoXNomb6kn4mVljEUpTB3dVQ/640?wx_fmt=png&quot;/&gt;因此，从实际出发，通常只专注于正在运行的容器的runtime通常称为“Low-Level容器运行时”，支持更多高级功能（如镜像管理和gRPC / Web API）的运行时通常称为“High-Level容器运行时”，“High-Level容器运行时”或通常仅称为“容器运行时”，我将它们称为“High-Level容器运行时”。值得注意的是，Low-Level容器运行时和High-Level容器运行时是解决不同问题的、从根本上不同的事物。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Low-Level容器运行时：容器是通过Linux nanespace和Cgroups实现的，Namespace能让你为每个容器提供虚拟化系统资源，像是文件系统和网络，Cgroups提供了限制每个容器所能使用的资源的如内存和CPU使用量的方法。在最低级别的运行时中，容器运行时负责为容器建立namespaces和cgroups,然后在其中运行命令，Low-Level容器运行时支持在容器中使用这些操作系统特性。目前来看低级容器运行时有：runc ：我们最熟悉也是被广泛使用的容器运行时，代表实现Docker。runv：runV 是一个基于虚拟机管理程序（OCI）的运行时。它通过虚拟化 guest kernel，将容器和主机隔离开来，使得其边界更加清晰，这种方式很容易就能帮助加强主机和容器的安全性。代表实现是kata和Firecracker。runsc：runsc = runc + safety ，典型实现就是谷歌的gvisor，通过拦截应用程序的所有系统调用，提供安全隔离的轻量级容器运行时沙箱。截止目前，貌似并不没有生产环境使用案例。wasm : Wasm的沙箱机制带来的隔离性和安全性，都比Docker做的更好。但是wasm 容器处于草案阶段，距离生产环境尚有很长的一段路。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;High-Level容器运行时：通常情况下，开发人员想要运行一个容器不仅仅需要Low-Level容器运行时提供的这些特性，同时也需要与镜像格式、镜像管理和共享镜像相关的API接口和特性，而这些特性一般由High-Level容器运行时提供。就日常使用来说，Low-Level容器运行时提供的这些特性可能满足不了日常所需，因为这个缘故，唯一会使用Low-Level容器运行时的人是那些实现High-Level容器运行时以及容器工具的开发人员。那些实现Low-Level容器运行时的开发者会说High-Level容器运行时比如containerd和cri-o不像真正的容器运行时，因为从他们的角度来看，他们将容器运行的实现外包给了runc。但是从用户的角度来看，它们只是提供容器功能的单个组件，可以被另一个的实现替换，因此从这个角度将其称为runtime仍然是有意义的。即使containerd和cri-o都使用runc，但是它们是截然不同的项目，支持的特性也是非常不同的。dockershim, containerd 和cri-o都是遵循CRI的容器运行时，我们称他们为高层级运行时（High-level Runtime）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kubernetes 只需支持 containerd 等high-level container runtime即可。由containerd 按照OCI 规范去对接不同的low-level container runtime，比如通用的runc，安全增强的gvisor，隔离性更好的runv。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;containerd&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与RunC_一样_，我们又可以在这里看到一个docker公司的开源产品containerd曾经是开源docker项目的一部分。尽管_containerd_是另一个自给自足的软件。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一方面，它称自己为容器运行时，但是与运行时__RunC_不同_。不仅_containerd_和_runc_的职责不同，组织形式也不同。显然_runc_是只是一个命令行工具，_containerd_是一个长期居住守护进程。_runc_的实例不能超过底层容器进程。通常它在create调用时开始它的生命，然后只是在容器的 rootfs 中的指定文件去运行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;另一方面，_containerd _可以管理超过数千个_runc_容器。它更像是一个服务器，它侦听传入请求以启动、停止或报告容器的状态。在引擎盖下_containerd_使用RunC。然而，_containerd_不仅仅是一个容器生命周期管理器。它还负责镜像管理（从注册中心拉取和推送镜像，在本地存储镜像等）、跨容器网络管理和其他一些功能。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100018147&quot; data-ratio=&quot;0.4851720047449585&quot; data-type=&quot;png&quot; data-w=&quot;1686&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibD9iaaPDn99j6K4fEDVSvE6ficAhoLE4zqNYZdOJk3vc2HQUsUjibegnsmNYoZJhvRiaHagSiby3BrD5c9CoksO84ibQ/640?wx_fmt=png&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;containerd 是一个工业级标准的容器运行时，它强调&lt;strong&gt;简单性&lt;/strong&gt;、&lt;strong&gt;健壮性&lt;/strong&gt;和&lt;strong&gt;可移植性&lt;/strong&gt;，containerd 可以负责干下面这些事情：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;管理容器的生命周期（从创建容器到销毁容器）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;拉取/推送容器镜像&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;存储管理（管理镜像及容器数据的存储）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用 runc 运行容器（与 runc 等容器运行时交互）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;管理容器网络接口及网络&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-fileid=&quot;100018149&quot; data-ratio=&quot;0.6060606060606061&quot; data-type=&quot;png&quot; data-w=&quot;1782&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibD9iaaPDn99j6K4fEDVSvE6ficAhoLE4zqUUKf2m7qC15XGcwE72hUIStia5H7tm6VeD2vcmUhvBMQ8pQibBibGwM5A/640?wx_fmt=png&quot;/&gt;上图是 Containerd 整体的架构。由下往上，Containerd支持的操作系统和架构有 Linux、Windows 以及像 ARM 的一些平台。在这些底层的操作系统之上运行的就是底层容器运行时，其中有上文提到的runc、gVisor 等。在底层容器运行时之上的是Containerd 相关的组件，比如 Containerd 的 runtime、core、API、backend、store 还有metadata 等等。构筑在 Containerd 组件之上以及跟这些组件做交互的都是 Containerd 的 client，Kubernetes 跟 Containerd 通过 CRI 做交互时，本身也作为 Containerd 的一个 client。Containerd 本身有提供了一个 CRI，叫 ctr，不过这个命令行工具并不是很好用。 &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这些组件之上就是真正的平台，Google Cloud、Docker、IBM、阿里云、微软云还有RANCHER等等都是，这些平台目前都已经支持 containerd， 并且有些已经作为自己的默认容器运行时了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 k8s 的角度看，选择 containerd作为运行时的组件，它调用链更短，组件更少，更稳定，占用节点资源更少。&lt;img data-fileid=&quot;100018150&quot; data-ratio=&quot;0.2935185185185185&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibD9iaaPDn99j6K4fEDVSvE6ficAhoLE4zqBRic9ZFYAFVBaqTgcqBCTc4hMJW9GicB4jtd7BZGB1gkkEiaPLl2QibHSg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; data-category_id_list=&quot;1|11|16|17|22|24|26|27|28|29|3|31|32|35|36|37|39|41|42|43|45|46|47|48|49|5|50|51|52|53|54|55|6|7|8&quot; data-id=&quot;1635413250190&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1635413250190&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;Docker&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Docker 于 2013 年发布，解决了开发人员在端到端运行容器时遇到的许多问题。这里是他包含的所有东西：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;容器镜像格式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一种构建容器镜像的方法（Dockerfile/docker build）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一种管理容器镜像（docker image、docker rm等）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一种管理容器实例的方法（docker ps, docker rm 等）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一种共享容器镜像的方法（docker push/pull）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一种运行容器的方式（docker run）；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当时，Docker 是一个单体系统。但是，这些功能中没有一个是真正相互依赖的。这些中的每一个都可以在可以一起使用的更小、更集中的工具中实现。每个工具都可以通过使用一种通用格式、一种容器标准来协同工作。从 Docker 1.11 之后，Docker Daemon 被分成了多个模块以适应 OCI 标准。拆分之后，结构分成了以下几个部分。&lt;img data-fileid=&quot;100018151&quot; data-ratio=&quot;0.628&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibD9iaaPDn99j6K4fEDVSvE6ficAhoLE4zq4XPDAWQQ5toCbibBtXJQ8YPAo6iaVCqYMdcjGu1JKabUz45GdVfkW1Kw/640?wx_fmt=png&quot;/&gt;&lt;br/&gt;其中，containerd 独立负责容器运行时和生命周期（如创建、启动、停止、中止、信号处理、删除等），其他一些如镜像构建、卷管理、日志等由 Docker Daemon 的其他模块处理。 &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Docker 的模块块拥抱了开放标准，希望通过 OCI 的标准化，容器技术能够有很快的发展。 &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在创建一个docker容器的时候，Docker Daemon 并不能直接帮我们创建了，而是请求 containerd 来创建一个容器。当containerd 收到请求后，也不会直接去操作容器，而是创建一个叫做 containerd-shim 的进程。让这个进程去操作容器，我们指定容器进程是需要一个父进程来做状态收集、维持 stdin 等 fd 打开等工作的，假如这个父进程就是 containerd，那如果 containerd 挂掉的话，整个宿主机上所有的容器都得退出了，而引入 containerd-shim 这个垫片就可以来规避这个问题了，就是提供的live-restore的功能。这里需要注意systemd的 MountFlags=slave。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后创建容器需要做一些 namespaces 和 cgroups 的配置，以及挂载 root 文件系统等操作。runc 就可以按照这个 OCI 文档来创建一个符合规范的容器。 &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;真正启动容器是通过 containerd-shim 去调用 runc 来启动容器的，runc 启动完容器后本身会直接退出，containerd-shim 则会成为容器进程的父进程, 负责收集容器进程的状态, 上报给 containerd, 并在容器中 pid 为 1 的进程退出后接管容器中的子进程进行清理, 确保不会出现僵尸进程。containerd，containerd-shim和容器进程(即容器主进程)三个进程，是有依赖关系的。可以参考《containerd,containerd-shim和runc的依存关系》[1],查看怎么保证live-restore的功能的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;reference&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://www.ianlewis.org/en/container-runtimes-part-1-introduction-container-r&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://iximiuz.com/en/posts/journey-from-containerization-to-orchestration-and-beyond/#container-management&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/moby/moby/issues/35873#issuecomment-386467562&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[1]https://fankangbest.github.io/2017/11/24/containerd-containerd-shim%E5%92%8Crunc%E7%9A%84%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB/&lt;br/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;本文转载自：「运维开发故事」，原文：https://tinyurl.com/skbbpr4j，版权归原作者所有。欢迎投稿，投稿邮箱: editor@hi-linux.com。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;__bg_gif&quot; data-fileid=&quot;100018141&quot; data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;55&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/V3ll7FMyGyMqQC7JRNgVZlsiaJibSyp27USlRia194K6Nqfvz8Wblg7HDceOn4Y3MekppS14lazRZTKLdt2BHuYGA/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-fileid=&quot;100018138&quot; data-ratio=&quot;0.19718309859154928&quot; data-type=&quot;png&quot; data-w=&quot;71&quot; data-width=&quot;100%&quot; title=&quot;&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/V3ll7FMyGyMSBQlhpwK0j3jOS5icKmFncGJdY8kL5kY6AswDpOBsz06GFowoDicL2dC2fr9haibnrwNdZ7rJLXqUA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;你可能还喜欢&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点击下方图片即可阅读&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247501647&amp;amp;idx=1&amp;amp;sn=20b5a0ecda942b5ba2166554eb045665&amp;amp;chksm=eac6e666ddb16f708e61423d1459d26b4f2d262cce7460bcc0ddced6cb37bee0ad56ef45fc4a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-fileid=&quot;100018153&quot; data-ratio=&quot;0.375&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8ZFzrRjqatqWpqDODU6e5tWXeR9ZB8APkleZalicTflzhfpU2ibFjCTKy3ICzoajK8AGgqmFCT7g38rymBiaBMNQg/640?wx_fmt=jpeg&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;GitHub 星标 2.1 K，可能是最简单好用的纯文本流程图制作工具&lt;br/&gt;&lt;br/&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;amp;mid=2247497936&amp;amp;idx=1&amp;amp;sn=ec9442c73de91c5ab35dbd21dfbedcbd&amp;amp;chksm=eac6d9f9ddb150ef9fc91129ab2b34d35ffef884a726fd90bc1fe9d4014456d910b3baa73afc&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img data-fileid=&quot;100018139&quot; data-ratio=&quot;0.5496957403651116&quot; data-type=&quot;png&quot; data-w=&quot;986&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8ZFzrRjqatp9P1fjdJcxb1j9gtuoFvu5tYF73myE4ZCLLUzO34rxQ1jruOX4XN3bpqWJWyZ47Mfh7UhvIOJwDA/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;点击上方图片，『美团|饿了么』外卖红包天天免费领&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-fileid=&quot;100018143&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;900&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8ZFzrRjqatpX5KlSvhARyBhcqYmvglSE9zMfzA8CSgNIibAiaFFNHBoXujK9vo2655gRWM5RibLzzF6jPhk4CuYAg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;更多有趣的互联网新鲜事，关注「奇妙的互联网」视频号全了解！&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c2ad1f035b1b145855ca3ff0732a9e47</guid>
<title>golang切片的一些自问自答</title>
<link>https://toutiao.io/k/7w6z7ad</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;br/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ffGGK0y3bBLj5sMauxUlyQqsUj9yFdqGHEF0PAsHtmJdlRz9egIltvkNo67p04breK29gibNymMRI1vLvzjyTYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5472222222222223&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;image-20211229094736903&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你好，我是轩脉刃。这篇是关于go切片的一些问题和回答。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;go的切片基本上是代码中使用最多的一种数据结构了，使用这种数据结构有哪些要注意的点，这个是非常必要了解的东西。基本上，以前写的一篇博客 https://www.cnblogs.com/yjf512/p/9531282.html  就说的很清楚了。这里再深挖一些。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;问题：go的切片数据结构是什么样子的？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;切片是有可能在编译器就被内联的，而如果在编译器没有被内联，进入运行期，就是直接使用SliceHeader数据结构。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; SliceHeader struct {&lt;br/&gt; Data uintptr&lt;br/&gt; Len  int&lt;br/&gt; Cap  int&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这三个字段分别表示指针，长度，容量。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;问题：为什么在初始化slice的时候尽量补全cap&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们要创建一个slice结构，并且往slice中append元素的时候，我们可能有两种写法来初始化这个slice。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法1:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; arr := []int{}&lt;br/&gt; arr = append(arr, 1,2,3,4, 5)&lt;br/&gt; fmt.Println(arr)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法2:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;package main&lt;br/&gt;&lt;br/&gt;import &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;   arr := make([]int, 0, 5)&lt;br/&gt;   arr = append(arr, 1,2,3,4, 5)&lt;br/&gt;   fmt.Println(arr)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法2相较于方法1，就只有一个区别：在初始化[]int slice的时候在make中设置了cap的长度，就是slice的大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两种方法对应的功能和输出结果是没有任何差别的，但是实际运行的时候，方法2会比少运行了一个growslice的命令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个我们可以通过打印汇编码进行查看：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法1：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ffGGK0y3bBLj5sMauxUlyQqsUj9yFdqG1kZOFzxNWTwJicUicbs1gsXwyic7CK6rjPHZH6FL32Tib90nOZfOibF0k7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.8802177858439202&quot; data-w=&quot;551&quot;/&gt;&lt;figcaption&gt;image-20211219173237557&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法2:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ffGGK0y3bBLj5sMauxUlyQqsUj9yFdqGeC31Ulnibo1Hd0x22xlWUR7QAZbHBXWLV5OVZDolAGCoBiaVicaQzT9Ug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.8797814207650273&quot; data-w=&quot;549&quot;/&gt;&lt;figcaption&gt;image-20211219174112164&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到方法1中使用了growsslice方法，而方法2中是没有调用这个方法的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个growslice的作用就是扩充slice的容量大小。就好比是原先我们没有定制容量，系统给了我们一个能装两个鞋子的盒子，但是当我们装到第三个鞋子的时候，这个盒子就不够了，我们就要换一个盒子，而换这个盒子，我们势必还需要将原先的盒子里面的鞋子也拿出来放到新的盒子里面。所以这个growsslice的操作是一个比较复杂的操作，它的表现和复杂度会高于最基本的初始化make方法。对追求性能的程序来说，应该能避免尽量避免。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体对growsslice函数具体实现同学有兴趣的可以参考源码src的 runtime/slice.go 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，我们并不是每次都能在slice初始化的时候就能准确预估到最终的使用容量的。所以这里使用了一个“尽量”。明白是否设置slice容量的区别，我们在能预估容量的时候，请尽量使用方法2那种预估容量后的slice初始化方式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;问题：如果不设置cap，make slice的时候，创建的cap为多大？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不设置cap，不管是使用make，还是直接使用[]slice 进行初始化，编译器都会计算初始化所需的空间，使用最小化的cap进行初始化。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;a := make([]int, 0)  // &lt;span&gt;cap&lt;/span&gt; 为0&lt;br/&gt;a := []int{1,2,3} // &lt;span&gt;cap&lt;/span&gt; 为3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以从ssa看出&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ffGGK0y3bBLj5sMauxUlyQqsUj9yFdqGBV4335XFlCDG2RxSg5T8t7JIM2QamCHJAiaoezrNnIkvgYoKHmt06Tg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.3007518796992481&quot; data-w=&quot;798&quot;/&gt;&lt;figcaption&gt;image-20211221095655104&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;问题：slice什么时候决定扩张？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前写过一篇文章 https://www.cnblogs.com/yjf512/p/10714792.html 里面得出的结论就是slice在编译期就决定是否要调用growslice。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个逻辑是正确的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译器在ssa的时候 对于append是会转换为 OAPPEND（cmd/compile/internal/typecheck/universe.go） 。而在 cmd/compile/internal/ssagen/ssa.go 中，对其进行判断。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6898148148148148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ffGGK0y3bBLj5sMauxUlyQqsUj9yFdqGJq3O14W4ib3roibl1o2Ef91xRZAZJ9BJvvmp3jGX7OiatsBYI5L7BG4Zg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;image-20211221101614497&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前还看不懂下面append下面的逻辑，不过基于这个注释，能了解到这里growslice的逻辑。比较扩容前后大小，如果原先cap小于扩容后需要cap，就growslice。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;琢磨了四个关于切片的问题：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题：go的切片数据结构是什么样子的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题：为什么在初始化slice的时候尽量补全cap？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题：如果不设置cap，make slice的时候，创建的cap为多大？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题：slice什么时候决定扩张？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;感觉第四个问题还没想透。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>