<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>53291337f0760e5fa26856f2b035c427</guid>
<title>为什么 Go 占用那么多的虚拟内存？</title>
<link>https://toutiao.io/k/0zyeufv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前段时间，某同学说某服务的容器因为超出内存限制，不断地重启，问我们是不是有内存泄露，赶紧排查，然后解决掉，省的出问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们大为震惊，赶紧查看监控+报警系统和性能分析，发现应用指标压根就不高，不像有泄露的样子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题到底是出在哪里了呢，我们进入某个容器里查看了 &lt;code&gt;top&lt;/code&gt; 的系统指标：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;PID       VSZ    RSS   ... COMMAND&lt;br/&gt;67459     2007m  136m  ... ./eddycjy-server&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看上去也没什么大开销的东西，就一个 Go 进程？就这？&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/KVl0giak5ib4htibhubl5wtrrJqdexvxTbXrZYlg4HFnHt2cfNvp73aUaBHuM3ic0ficGHOTGuWEGb4CHC67kWJ2JVQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再定眼一看，某同学就说 VSZ 那么高，而某云上的容器内存指标居然恰好和 VSZ 的值相接近，因此就怀疑是不是 VSZ 所导致的，觉得存在一定的关联关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个猜测的结果到底是否正确呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基础知识&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇文章将&lt;strong&gt;主要围绕 Go 进程的 VSZ 来进行剖析&lt;/strong&gt;，看看到底它为什么那么 &quot;高&quot;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一节为前置的补充知识，大家可按顺序阅读。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是 VSZ&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VSZ 是该进程所能使用的虚拟内存总大小，它包括进程可以访问的所有内存，其中包括了被换出的内存（Swap）、已分配但未使用的内存以及来自共享库的内存。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么要虚拟内存&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面我们有了解到 VSZ 其实就是该进程的虚拟内存总大小，那&lt;strong&gt;如果我们想了解 VSZ 的话，那我们得先了解 “为什么要虚拟内存？”&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本质上来讲，在一个系统中的进程是与其他进程共享 CPU 和主存资源的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此在现代的操作系统中，多进程的使用非常的常见，如果太多的进程需要太多的内存，在没有虚拟内存的情况下，物理内存很可能会不够用，就会导致其中有些任务无法运行，更甚至会出现一些很奇怪的现象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如 “某一个进程不小心写了另一个进程使用的内存”，就会造成内存破坏，因此虚拟内存是非常重要的一个媒介。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;虚拟内存包含了什么&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虚拟内存，又分为：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每一个进程的虚拟内存都是独立的， 内部结构如下图所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7496902106567535&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4htibhubl5wtrrJqdexvxTbXPV2vnCH3W9YyUKcjhsn7vSTWhh3TF6CQU2ianKmRq5fQbvdibYLzUTkA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1614&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在内核虚拟内存中，包含了内核中的代码和数据结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核虚拟内存中的某些区域会被映射到所有进程共享的物理页面中去，因此你会看到 ”内核虚拟内存“ 中实际上是包含了 ”物理内存“ 的，它们两者存在映射关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而从应用场景上来讲，每个进程也会去共享内核的代码和全局数据结构，因此就会被映射到所有进程的物理页面中去。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7496902106567535&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4htibhubl5wtrrJqdexvxTbXNH1leIy1liaqzHmMH75W1GcibLpUUH8FwZhTFYEl2IaG1eRMyPkFlEUg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1614&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;虚拟内存的重要能力&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更有效地管理内存并且减少出错，现代系统提供了一种对主存的抽象概念，也就是今天的主角，叫做虚拟内存（VM）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件交互的地方，它为每个进程提供了一个大的、一致的和私有的地址空间，虚拟内存提供了三个重要的能力：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;它为每个进程提供了一致的地址空间，从而简化了内存管理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;它保护了每个进程的地址空间不被其他进程破坏。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小结&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面发散的可能比较多，简单来讲，对于本文我们重点关注这些知识点，如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;虚拟内存它是有各式各样内存交互的地方，它包含的不仅仅是 &quot;自己&quot;，&lt;strong&gt;而在本文中，我们只需要关注 VSZ，也就是进程虚拟内存，它包含了你的代码、数据、堆、栈段和共享库&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;虚拟内存作为内存保护的工具，能够保证进程之间的内存空间独立，不受其他进程的影响，因此每一个进程的 VSZ 大小都不一样，互不影响。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;虚拟内存的存在，系统给各进程分配的内存之和是可以大于实际可用的物理内存的，因此你也会发现你进程的物理内存总是比虚拟内存低的多的多。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;排查问题&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在了解了基础知识后，我们正式开始排查问题，第一步我们先编写一个测试程序，看看没有什么业务逻辑的 Go 程序，它初始的 VSZ 是怎么样的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;测试&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; r := gin.Default()&lt;br/&gt; r.GET(&lt;span&gt;&quot;/ping&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(c *gin.Context)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  c.JSON(&lt;span&gt;200&lt;/span&gt;, gin.H{&lt;br/&gt;   &lt;span&gt;&quot;message&quot;&lt;/span&gt;: &lt;span&gt;&quot;pong&quot;&lt;/span&gt;,&lt;br/&gt;  })&lt;br/&gt; })&lt;br/&gt; r.Run(&lt;span&gt;&quot;:8001&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看进程情况：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; ps aux 67459&lt;/span&gt;&lt;br/&gt;USER      PID  %CPU %MEM      VSZ    RSS   ...&lt;br/&gt;eddycjy 67459   0.0  0.0  4297048    960   ...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从结果上来看，VSZ 为 4297048K，也就是 4G 左右，咋一眼看过去还是挺吓人的，明明没有什么业务逻辑，但是为什么那么高呢，真是令人感到好奇。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;确认有没有泄露&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在未知的情况下，我们可以首先看下 &lt;code&gt;runtime.MemStats&lt;/code&gt; 和 &lt;code&gt;pprof&lt;/code&gt;，确定应用到底有没有泄露。不过我们这块是演示程序，什么业务逻辑都没有，因此可以确定和应用没有直接关系。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# runtime.MemStats&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Alloc = 1298568&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# TotalAlloc = 1298568&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Sys = 71893240&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Lookups = 0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Mallocs = 10013&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Frees = 834&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# HeapAlloc = 1298568&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# HeapSys = 66551808&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# HeapIdle = 64012288&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# HeapInuse = 2539520&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# HeapReleased = 64012288&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# HeapObjects = 9179&lt;/span&gt;&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Go FAQ&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着我第一反应是去翻了 Go FAQ（因为看到过，有印象），其问题为 &quot;Why does my Go process use so much virtual memory?&quot;，回答如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;The Go memory allocator reserves a large region of virtual memory as an arena for allocations. This virtual memory is local to the specific Go process; the reservation does not deprive other processes of memory.&lt;/p&gt;&lt;p&gt;To find the amount of actual memory allocated to a Go process, use the Unix top command and consult the RES (Linux) or RSIZE (macOS) columns.&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个 FAQ 是在 2012 年 10 月 提交 的，这么多年了也没有更进一步的说明，再翻了 issues 和 forum，一些关闭掉的 issue 都指向了 FAQ，这显然无法满足我的求知欲，因此我继续往下探索，看看里面到底都摆了些什么。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;查看内存映射&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，我们有提到进程虚拟内存，主要包含了你的代码、数据、堆、栈段和共享库，那初步怀疑是不是进程做了什么内存映射，导致了大量的内存空间被保留呢，为了确定这一点，我们通过如下命令去排查：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ vmmap --wide 67459&lt;br/&gt;...&lt;br/&gt;==== Non-writable regions for process 67459&lt;br/&gt;REGION TYPE                      START - END             [ VSIZE  RSDNT  DIRTY   SWAP] PRT/MAX SHRMOD PURGE    REGION DETAIL&lt;br/&gt;__TEXT                 00000001065ff000-000000010667b000 [  496K   492K     0K     0K] r-x/rwx SM=COW          /bin/zsh&lt;br/&gt;__LINKEDIT             0000000106687000-0000000106699000 [   72K    44K     0K     0K] r--/rwx SM=COW          /bin/zsh&lt;br/&gt;MALLOC metadata        000000010669b000-000000010669c000 [    4K     4K     4K     0K] r--/rwx SM=COW          DefaultMallocZone_0x10669b000 zone structure&lt;br/&gt;...&lt;br/&gt;__TEXT                 00007fff76c31000-00007fff76c5f000 [  184K   168K     0K     0K] r-x/r-x SM=COW          /usr/lib/system/libxpc.dylib&lt;br/&gt;__LINKEDIT             00007fffe7232000-00007ffff32cb000 [192.6M  17.4M     0K     0K] r--/r-- SM=COW          dyld shared cache combined __LINKEDIT&lt;br/&gt;...        &lt;br/&gt;&lt;br/&gt;==== Writable regions for process 67459&lt;br/&gt;REGION TYPE                      START - END             [ VSIZE  RSDNT  DIRTY   SWAP] PRT/MAX SHRMOD PURGE    REGION DETAIL&lt;br/&gt;__DATA                 000000010667b000-0000000106682000 [   28K    28K    28K     0K] rw-/rwx SM=COW          /bin/zsh&lt;br/&gt;...   &lt;br/&gt;__DATA                 0000000106716000-000000010671e000 [   32K    28K    28K     4K] rw-/rwx SM=COW          /usr/lib/zsh/5.3/zsh/zle.so&lt;br/&gt;__DATA                 000000010671e000-000000010671f000 [    4K     4K     4K     0K] rw-/rwx SM=COW          /usr/lib/zsh/5.3/zsh/zle.so&lt;br/&gt;__DATA                 0000000106745000-0000000106747000 [    8K     8K     8K     0K] rw-/rwx SM=COW          /usr/lib/zsh/5.3/zsh/complete.so&lt;br/&gt;__DATA                 000000010675a000-000000010675b000 [    4K     4K     4K     0K] rw-&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这块主要是利用 macOS 的 &lt;code&gt;vmmap&lt;/code&gt; 命令去查看内存映射情况，这样就可以知道这个进程的内存映射情况，从输出分析来看，&lt;strong&gt;这些关联共享库占用的空间并不大，导致 VSZ 过高的根本原因不在共享库和二进制文件上，但是并没有发现大量保留内存空间的行为，这是一个问题点&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注：若是 Linux 系统，可使用 &lt;code&gt;cat /proc/PID/maps&lt;/code&gt; 或 &lt;code&gt;cat /proc/PID/smaps&lt;/code&gt; 查看。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;查看系统调用&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然在内存映射中，我们没有明确的看到保留内存空间的行为，那我们接下来看看该进程的系统调用，确定一下它是否存在内存操作的行为，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ sudo dtruss -a ./awesomeProject&lt;br/&gt;...&lt;br/&gt; 4374/0x206a2:     15620       6      3 mprotect(0x1BC4000, 0x1000, 0x0)   = 0 0&lt;br/&gt;...&lt;br/&gt; 4374/0x206a2:     15781       9      4 sysctl([CTL_HW, 3, 0, 0, 0, 0] (2), 0x7FFEEFBFFA64, 0x7FFEEFBFFA68, 0x0, 0x0)   = 0 0&lt;br/&gt; 4374/0x206a2:     15783       3      1 sysctl([CTL_HW, 7, 0, 0, 0, 0] (2), 0x7FFEEFBFFA64, 0x7FFEEFBFFA68, 0x0, 0x0)   = 0 0&lt;br/&gt; 4374/0x206a2:     15899       7      2 mmap(0x0, 0x40000, 0x3, 0x1002, 0xFFFFFFFFFFFFFFFF, 0x0)   = 0x4000000 0&lt;br/&gt; 4374/0x206a2:     15930       3      1 mmap(0xC000000000, 0x4000000, 0x0, 0x1002, 0xFFFFFFFFFFFFFFFF, 0x0)   = 0xC000000000 0&lt;br/&gt; 4374/0x206a2:     15934       4      2 mmap(0xC000000000, 0x4000000, 0x3, 0x1012, 0xFFFFFFFFFFFFFFFF, 0x0)   = 0xC000000000 0&lt;br/&gt; 4374/0x206a2:     15936       2      0 mmap(0x0, 0x2000000, 0x3, 0x1002, 0xFFFFFFFFFFFFFFFF, 0x0)   = 0x59B7000 0&lt;br/&gt; 4374/0x206a2:     15942       2      0 mmap(0x0, 0x210800, 0x3, 0x1002, 0xFFFFFFFFFFFFFFFF, 0x0)   = 0x4040000 0&lt;br/&gt; 4374/0x206a2:     15947       2      0 mmap(0x0, 0x10000, 0x3, 0x1002, 0xFFFFFFFFFFFFFFFF, 0x0)   = 0x1BD0000 0&lt;br/&gt; 4374/0x206a2:     15993       3      0 madvise(0xC000000000, 0x2000, 0x8)   = 0 0&lt;br/&gt; 4374/0x206a2:     16004       2      0 mmap(0x0, 0x10000, 0x3, 0x1002, 0xFFFFFFFFFFFFFFFF, 0x0)   = 0x1BE0000 0&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这小节中，我们通过 macOS 的 &lt;code&gt;dtruss&lt;/code&gt; 命令监听并查看了运行这个程序所进行的所有系统调用，发现了与内存管理有一定关系的方法如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;mmap：创建一个新的虚拟内存区域，但这里需要注意，&lt;strong&gt;就是当系统调用 mmap 时，它只是从虚拟内存中申请了一段空间出来，并不会去分配和映射真实的物理内存，而当你访问这段空间的时候，才会在当前时间真正的去分配物理内存&lt;/strong&gt;。那么对应到我们实际应用的进程中，那就是 VSZ 的增长后，而该内存空间又未正式使用的话，物理内存是不会有增长的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;madvise：提供有关使用内存的建议，例如：MADV_NORMAL、MADV_RANDOM、MADV_SEQUENTIAL、MADV_WILLNEED、MADV_DONTNEED 等等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mprotect：设置内存区域的保护情况，例如：PROT_NONE、PROT_READ、PROT_WRITE、PROT_EXEC、PROT_SEM、PROT_SAO、PROT_GROWSUP、PROT_GROWSDOWN 等等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sysctl：在内核运行时动态地修改内核的运行参数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在此比较可疑的是 &lt;code&gt;mmap&lt;/code&gt; 方法，它在 &lt;code&gt;dtruss&lt;/code&gt; 的最终统计中一共调用了 10 余次，我们可以相信它在 Go Runtime 的时候进行了大量的虚拟内存申请。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再接着往下看，看看到底是在什么阶段进行了虚拟内存空间的申请。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注：若是 Linux 系统，可使用 &lt;code&gt;strace&lt;/code&gt; 命令。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;查看 Go Runtime&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;启动流程&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上述的分析，我们可以知道在 Go 程序启动的时候 VSZ 就已经不低了，并且确定不是共享库等的原因，且程序在启动时系统调用确实存在 &lt;code&gt;mmap&lt;/code&gt; 等方法的调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们可以充分怀疑 Go 在初始化阶段就保留了该内存空间。那我们第一步要做的就是查看一下 Go 的引导启动流程，看看是在哪里申请的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引导过程如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;graph TD&lt;br/&gt;A(rt0_darwin_amd64.s:8&amp;lt;br/&amp;gt;_rt0_amd64_darwin) --&amp;gt;|JMP| B(asm_amd64.s:15&amp;lt;br/&amp;gt;_rt0_amd64)&lt;br/&gt;B --&amp;gt; |JMP|C(asm_amd64.s:87&amp;lt;br/&amp;gt;runtime-rt0_go)&lt;br/&gt;C --&amp;gt; D(runtime1.go:60&amp;lt;br/&amp;gt;runtime-args)&lt;br/&gt;D --&amp;gt; E(os_darwin.go:50&amp;lt;br/&amp;gt;runtime-osinit)&lt;br/&gt;E --&amp;gt; F(proc.go:472&amp;lt;br/&amp;gt;runtime-schedinit)&lt;br/&gt;F --&amp;gt; G(proc.go:3236&amp;lt;br/&amp;gt;runtime-newproc)&lt;br/&gt;G --&amp;gt; H(proc.go:1170&amp;lt;br/&amp;gt;runtime-mstart)&lt;br/&gt;H --&amp;gt; I(在新创建的 p 和 m 上运行 runtime-main)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;runtime-osinit：获取 CPU 核心数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;runtime-schedinit：初始化程序运行环境（包括栈、内存分配器、垃圾回收、P等）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;runtime-newproc：创建一个新的 G 和 绑定 runtime.main。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;runtime-mstart：启动线程 M。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注：来自@曹大的 《Go 程序的启动流程》和@全成的 《Go 程序是怎样跑起来的》，推荐大家阅读。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;初始化运行环境&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然，我们要研究的是 runtime 里的 &lt;code&gt;schedinit&lt;/code&gt; 方法，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func &lt;span&gt;&lt;span&gt;schedinit&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; ...&lt;br/&gt; stackinit()&lt;br/&gt; mallocinit()&lt;br/&gt; mcommoninit(_g_.m)&lt;br/&gt; cpuinit()       // must run before alginit&lt;br/&gt; alginit()       // maps must not be used before this call&lt;br/&gt; modulesinit()   // provides activeModules&lt;br/&gt; typelinksinit() // uses maps, activeModules&lt;br/&gt; itabsinit()     // uses activeModules&lt;br/&gt;&lt;br/&gt; msigsave(_g_.m)&lt;br/&gt; initSigmask = _g_.m.sigmask&lt;br/&gt;&lt;br/&gt; goargs()&lt;br/&gt; goenvs()&lt;br/&gt; parsedebugvars()&lt;br/&gt; gcinit()&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从用途来看，非常明显， &lt;code&gt;mallocinit&lt;/code&gt; 方法会进行内存分配器的初始化，我们继续往下看。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;初始化内存分配器&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;mallocinit&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们正式的分析一下 &lt;code&gt;mallocinit&lt;/code&gt; 方法，在引导流程中， &lt;code&gt;mallocinit&lt;/code&gt; 主要承担 Go 程序的内存分配器的初始化动作，而今天主要是针对虚拟内存地址这块进行拆解，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func &lt;span&gt;&lt;span&gt;mallocinit&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; ...&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; sys.PtrSize == 8 {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; i := 0x7f; i &amp;gt;= 0; i-- {&lt;br/&gt;   var p uintptr&lt;br/&gt;   switch {&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; GOARCH == &lt;span&gt;&quot;arm64&quot;&lt;/span&gt; &amp;amp;&amp;amp; GOOS == &lt;span&gt;&quot;darwin&quot;&lt;/span&gt;:&lt;br/&gt;    p = uintptr(i)&amp;lt;&amp;lt;40 | uintptrMask&amp;amp;(0x0013&amp;lt;&amp;lt;28)&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; GOARCH == &lt;span&gt;&quot;arm64&quot;&lt;/span&gt;:&lt;br/&gt;    p = uintptr(i)&amp;lt;&amp;lt;40 | uintptrMask&amp;amp;(0x0040&amp;lt;&amp;lt;32)&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; GOOS == &lt;span&gt;&quot;aix&quot;&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; i == 0 {&lt;br/&gt;     &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    p = uintptr(i)&amp;lt;&amp;lt;40 | uintptrMask&amp;amp;(0xa0&amp;lt;&amp;lt;52)&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; raceenabled:&lt;br/&gt;    ...&lt;br/&gt;   default:&lt;br/&gt;    p = uintptr(i)&amp;lt;&amp;lt;40 | uintptrMask&amp;amp;(0x00c0&amp;lt;&amp;lt;32)&lt;br/&gt;   }&lt;br/&gt;   hint := (*arenaHint)(mheap_.arenaHintAlloc.alloc())&lt;br/&gt;   hint.addr = p&lt;br/&gt;   hint.next, mheap_.arenaHints = mheap_.arenaHints, hint&lt;br/&gt;  }&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      ...&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;判断当前是 64 位还是 32 位的系统。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从 0x7fc000000000~0x1c000000000 开始设置保留地址。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;判断当前 &lt;code&gt;GOARCH&lt;/code&gt;、&lt;code&gt;GOOS&lt;/code&gt; 或是否开启了竞态检查，根据不同的情况申请不同大小的连续内存地址，而这里的 &lt;code&gt;p&lt;/code&gt; 是即将要要申请的连续内存地址的开始地址。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;保存刚刚计算的 arena 的信息到 &lt;code&gt;arenaHint&lt;/code&gt; 中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能会有小伙伴问，为什么要判断是 32 位还是 64 位的系统，这是因为不同位数的虚拟内存的寻址范围是不同的，因此要进行区分，否则会出现高位的虚拟内存映射问题。而在申请保留空间时，我们会经常提到 &lt;code&gt;arenaHint&lt;/code&gt; 结构体，它是 &lt;code&gt;arenaHints&lt;/code&gt;链表里的一个节点，结构如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; arenaHint struct {&lt;br/&gt; addr uintptr&lt;br/&gt; down bool&lt;br/&gt; next *arenaHint&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;addr：&lt;code&gt;arena&lt;/code&gt; 的起始地址&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;down：是否最后一个 &lt;code&gt;arena&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;next：下一个 &lt;code&gt;arenaHint&lt;/code&gt; 的指针地址&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这里疯狂提到的 &lt;code&gt;arena&lt;/code&gt; 又是什么东西呢，这其实是 Go 的内存管理中的概念，Go Runtime 会把申请的虚拟内存分为三个大块，如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5018587360594795&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4htibhubl5wtrrJqdexvxTbXdphQOjjGxD6m2JyDrpwMvZwRRGbouDkoZtgDc6siaR3ee3bS7eYcQNQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1614&quot;/&gt;&lt;figcaption&gt;image&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;spans：记录 arena 区域页号和 mspan 的映射关系。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;bitmap：标识 arena 的使用情况，在功能上来讲，会用于标识 arena 的哪些空间地址已经保存了对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;arean：arean 其实就是 Go 的堆区，是由 mheap 进行管理的，它的 MaxMem 是 512GB-1。而在功能上来讲，Go 会在初始化的时候申请一段连续的虚拟内存空间地址到 arean 保留下来，在真正需要申请堆上的空间时再从 arean 中取出来处理，这时候就会转变为物理内存了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里的话，你需要理解 arean 区域在 Go 内存里的作用就可以了。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;mmap&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们刚刚通过上述的分析，已经知道 &lt;code&gt;mallocinit&lt;/code&gt; 的用途了，但是你可能还是会有疑惑，就是我们之前所看到的 &lt;code&gt;mmap&lt;/code&gt; 系统调用，和它又有什么关系呢，怎么就关联到一起了，接下来我们先一起来看看更下层的代码，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func sysAlloc(n uintptr, sysStat *uint64) unsafe.Pointer {&lt;br/&gt; p, err := mmap(nil, n, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_PRIVATE, -1, 0)&lt;br/&gt; ...&lt;br/&gt; mSysStatInc(sysStat, n)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; p&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func sysReserve(v unsafe.Pointer, n uintptr) unsafe.Pointer {&lt;br/&gt; p, err := mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE, -1, 0)&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func sysMap(v unsafe.Pointer, n uintptr, sysStat *uint64) {&lt;br/&gt; ...&lt;br/&gt; munmap(v, n)&lt;br/&gt; p, err := mmap(v, n, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_FIXED|_MAP_PRIVATE, -1, 0)&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go Runtime 中存在着一系列的系统级内存调用方法，本文涉及的主要如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;sysAlloc：从 OS 系统上申请清零后的内存空间，调用参数是 &lt;code&gt;_PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_PRIVATE&lt;/code&gt;，得到的结果需进行内存对齐。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sysReserve：从 OS 系统中保留内存的地址空间，这时候还没有分配物理内存，调用参数是 &lt;code&gt;_PROT_NONE, _MAP_ANON|_MAP_PRIVATE&lt;/code&gt;，得到的结果需进行内存对齐。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sysMap：通知 OS 系统我们要使用已经保留了的内存空间，调用参数是 &lt;code&gt;_PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_FIXED|_MAP_PRIVATE&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看上去好像很有道理的样子，但是 &lt;code&gt;mallocinit&lt;/code&gt; 方法在初始化时，到底是在哪里涉及了 &lt;code&gt;mmap&lt;/code&gt; 方法呢，表面看不出来，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; i := 0x7f; i &amp;gt;= 0; i-- {&lt;br/&gt; ...&lt;br/&gt; hint := (*arenaHint)(mheap_.arenaHintAlloc.alloc())&lt;br/&gt; hint.addr = p&lt;br/&gt; hint.next, mheap_.arenaHints = mheap_.arenaHints, hint&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上在调用 &lt;code&gt;mheap_.arenaHintAlloc.alloc()&lt;/code&gt; 时，调用的是 &lt;code&gt;mheap&lt;/code&gt;  下的 &lt;code&gt;sysAlloc&lt;/code&gt; 方法，而 &lt;code&gt;sysAlloc&lt;/code&gt; 又会与 &lt;code&gt;mmap&lt;/code&gt; 方法产生调用关系，并且这个方法与常规的 &lt;code&gt;sysAlloc&lt;/code&gt; 还不大一样，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;var mheap_ mheap&lt;br/&gt;...&lt;br/&gt;func (h *mheap) sysAlloc(n uintptr) (v unsafe.Pointer, size uintptr) {&lt;br/&gt; ...&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; h.arenaHints != nil {&lt;br/&gt;  hint := h.arenaHints&lt;br/&gt;  p := hint.addr&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; hint.down {&lt;br/&gt;   p -= n&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; p+n &amp;lt; p {&lt;br/&gt;   v = nil&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; arenaIndex(p+n-1) &amp;gt;= 1&amp;lt;&amp;lt;arenaBits {&lt;br/&gt;   v = nil&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;   v = sysReserve(unsafe.Pointer(p), n)&lt;br/&gt;  }&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以惊喜的发现 &lt;code&gt;mheap.sysAlloc&lt;/code&gt; 里其实有调用 &lt;code&gt;sysReserve&lt;/code&gt; 方法，而 &lt;code&gt;sysReserve&lt;/code&gt; 方法又正正是从 OS 系统中保留内存的地址空间的特定方法，是不是很惊喜，一切似乎都串起来了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小结&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本节中，我们先写了一个测试程序，然后根据非常规的排查思路进行了一步步的跟踪怀疑，整体流程如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过 &lt;code&gt;top&lt;/code&gt; 或 &lt;code&gt;ps&lt;/code&gt; 等命令，查看进程运行情况，分析基础指标。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 &lt;code&gt;pprof&lt;/code&gt; 或 &lt;code&gt;runtime.MemStats&lt;/code&gt; 等工具链查看应用运行情况，分析应用层面是否有泄露或者哪儿高。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 &lt;code&gt;vmmap&lt;/code&gt; 命令，查看进程的内存映射情况，分析是不是进程虚拟空间内的某个区域比较高，例如：共享库等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 &lt;code&gt;dtruss&lt;/code&gt; 命令，查看程序的系统调用情况，分析可能出现的一些特殊行为，例如：在分析中我们发现  &lt;code&gt;mmap&lt;/code&gt; 方法调用的比例是比较高的，那我们有充分的理由怀疑 Go 在启动时就进行了大量的内存空间保留。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过上述的分析，确定可能是在哪个环节申请了那么多的内存空间后，再到 Go Runtime 中去做进一步的源码分析，因为源码面前，了无秘密，没必要靠猜。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从结论上而言，VSZ（进程虚拟内存大小）与共享库等没有太大的关系，主要与 Go Runtime 存在直接关联，也就是在前图中表示的运行时堆（malloc）。转换到 Go Runtime 里，就是在 &lt;code&gt;mallocinit&lt;/code&gt;  这个内存分配器的初始化阶段里进行了一定量的虚拟空间的保留。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而保留虚拟内存空间时，受什么影响，又是一个哲学问题。从源码上来看，主要如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;受不同的 OS 系统架构（GOARCH/GOOS）和位数（32/64 位）的影响。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;受内存对齐的影响，计算回来的内存空间大小是需要经过对齐才会进行保留。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过一步步地分析，讲解了 Go 会在哪里，又会受什么因素，去调用了什么方法保留了那么多的虚拟内存空间，但是我们肯定会忧心进程虚拟内存（VSZ）高，会不会存在问题呢，我分析如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;VSZ 并不意味着你真正使用了那些物理内存，因此是不需要担心的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;VSZ 并不会给 GC 带来压力，GC 管理的是进程实际使用的物理内存，而 VSZ 在你实际使用它之前，它并没有过多的代价。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;VSZ 基本都是不可访问的内存映射，也就是它并没有内存的访问权限（不允许读、写和执行）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;思考&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里舒一口气，因为 Go VSZ 的高，并不会对我们产生什么非常实质性的问题，但是又仔细一想，为什么 Go 要申请那么多的虚拟内存呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总体考虑如下：&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Go 的设计是考虑到 &lt;code&gt;arena&lt;/code&gt; 和  &lt;code&gt;bitmap&lt;/code&gt; 的后续使用，先提早保留了整个内存地址空间。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Go Runtime 和应用的逐步使用，肯定也会开始实际的申请和使用内存，这时候 &lt;code&gt;arena&lt;/code&gt; 和 &lt;code&gt;bitmap&lt;/code&gt; 的内存分配器就只需要将事先申请好的内存地址空间保留更改为实际可用的物理内存就好了，这样子可以极大的提高效能。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;High virtual memory allocation by golang&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;GO MEMORY MANAGEMENT&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;GoBigVirtualSize&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;GoProgramMemoryUse&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;曹大的 Go 程序的启动流程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;全成大佬的 Go 程序是怎样跑起来的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;欧神的 go-under-the-hood&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>91e7a13707e627392261990e7be27daf</guid>
<title>资料 | ThoughtWorks 技术雷达第 23 期.pdf</title>
<link>https://toutiao.io/k/7mdyut5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>850496bc4f5f8363ce9b3bb016804be9</guid>
<title>25 张图让你彻底掌握分布式事务原理</title>
<link>https://toutiao.io/k/gfxnfbk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文提纲如下&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;0. 前言&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;1. 单数据源事务 &amp;amp; 多数据源事务&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;2. 常见分布式事务解决方案&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;3. Seata in AT mode 的实现&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;4. 结束语&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5766793409378961&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLUicibBibJhpkgl32RrSLP1kyibibjFBOQ6vee80ia4cfSmZFuxX7bO5kiafxFBWeRJKHYuuPCHZoapZdNNA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;789&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;0. 前言&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 CPU 到内存、到磁盘、到操作系统、到网络，计算机系统处处存在不可靠因素。工程师和科学家努力使用各种软硬件方法对抗这种不可靠因素，保证数据和指令被正确地处理。在网络领域有 TCP 可靠传输协议、在存储领域有 Raid5 和 Raid6 算法、在数据库领域有基于 ARIES 算法理论实现的事务机制……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章先介绍单机数据库事务的 ACID 特性，然后指出分布式场景下操作多数据源面临的困境，引出分布式系统中常用的分布式事务解决方案，这些解决方案可以保证业务代码在操作多个数据源的时候，能够像操作单个数据源一样，具备 ACID 特性。文章在最后给出业界较为成熟的分布式事务框架——Seata 的 AT 模式全局事务的实现。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 单数据源事务 &amp;amp; 多数据源事务&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个应用程序在一次业务流中通过连接驱动和数据源接口只连接并查询（这里的查询是广义的，包括增删查改等）一个特定的数据库，该应用程序就可以利用数据库提供的事务机制（如果数据库支持事务的话）保证对库中记录所进行的操作的可靠性，这里的可靠性有四种语义：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;- 原子性，A&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;- 一致性，C&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;- 隔离性，I&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;- 持久性，D&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;笔者在这里不再对这四种语义进行解释，了解单数据源事务及其 ACID 特性是读者阅读这篇文章的前提。单个数据库实现自身的事务特性是一个复杂又微妙的过程，例如 MySQL 的 InnoDB 引擎通过 Undo Log + Redo Log + ARIES 算法来实现。这是一个很宏大的话题，不在本文的描述范围，读者有兴趣的话可自行研究。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单数据源事务也可以叫做单机事务，或者本地事务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式场景下，一个系统由多个子系统构成，每个子系统有独立的数据源。多个子系统之间通过互相调用来组合出更复杂的业务。在时下流行的微服务系统架构中，每一个子系统被称作一个微服务，同样每个微服务都维护自己的数据库，以保持独立性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，一个电商系统可能由购物微服务、库存微服务、订单微服务等组成。购物微服务通过调用库存微服务和订单微服务来整合出购物业务。用户请求购物微服务商完成下单时，购物微服务一方面调用库存微服务扣减相应商品的库存数量，另一方面调用订单微服务插入订单记录（为了后文描述分布式事务解决方案的方便，这里给出的是一个最简单的电商系统微服务划分和最简单的购物业务流程，后续的支付、物流等业务不在考虑范围内）。电商系统模型如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2506596306068603&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyibT9YktR9L88D4SARkeCfnKWANHoVfeDBdEbHjoWtVGmemxT8iaMxKsmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;379&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在用户购物的业务场景中，shopping-service 的业务涉及两个数据库：库存库（repo_db）和订单库（repo_db），也就是 g 购物业务是调用多数据源来组合而成的。作为一个面向消费者的系统，电商系统要保证购物业务的高度可靠性，这里的可靠性同样有 ACID 四种语义。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是一个数据库的本地事务机制仅仅对落到自己身上的查询操作（这里的查询是广义的，包括增删改查等）起作用，无法干涉对其他数据库的查询操作。所以，数据库自身提供的本地事务机制无法确保业务对多数据源全局操作的可靠性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于此，针对多数据源操作提出的分布式事务机制就出现了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式事务也可以叫做全局事务。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 常见分布式事务解决方案&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1. 分布式事务模型&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyib7UgEluy2uy58GhVz85y3hpsw3G5vibONHYN07Ge1v4bEibKibandeEEEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;描述分布式事务，常常会使用以下几个名词：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;- 事务参与者：例如每个数据库就是一个事务参与者&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;- 事务协调者：访问多个数据源的服务程序，例如 shopping-service 就是事务协调者&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;- 资源管理器（Resource Manager, RM）：通常与事务参与者同义&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;- 事务管理器（Transaction Manager, TM）：通常与事务协调者同义&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式事务模型中，一个 TM 管理多个 RM，即一个服务程序访问多个数据源；TM 是一个全局事务管理器，协调多方本地事务的进度，使其共同提交或回滚，最终达成一种全局的 ACID 特性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2. 二将军问题和幂等性&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;二将军问题是网络领域的一个经典问题，用于表达计算机网络中互联协议设计的微妙性和复杂性。这里给出一个二将军问题的简化版本：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一支白军被围困在一个山谷中，山谷的左右两侧是蓝军。困在山谷中的白军人数多于山谷两侧的任意一支蓝军，而少于两支蓝军的之和。若一支蓝军对白军单独发起进攻，则必败无疑；但若两支蓝军同时发起进攻，则可取胜。两只蓝军的总指挥位于山谷左侧，他希望两支蓝军同时发起进攻，这样就要把命令传到山谷右侧的蓝军，以告知发起进攻的具体时间。假设他们只能派遣士兵穿越白军所在的山谷（唯一的通信信道）来传递消息，那么在穿越山谷时，士兵有可能被俘虏。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.8775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyibibXqFFfoX1zfgXtKHNPq6wiciaGliaiaX1ErWyeU9JQib6cSJJaiaKJldx36g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;400&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有当送信士兵成功往返后，总指挥才能确认这场战争的胜利（上方图）。现在问题来了，派遣出去送信的士兵没有回来，则左侧蓝军中的总指挥能不能决定按命令中约定的时间发起进攻？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是不确定，派遣出去送信的士兵没有回来，他可能遇到两种状况：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）命令还没送达就被俘虏了（中间图），这时候右侧蓝军根本不知道要何时进攻；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）命令送达，但返回途中被俘虏了（下方图），这时候右侧蓝军知道要何时进攻，但左侧蓝军不知道右侧蓝军是否知晓进攻时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类似的问题在计算机网络中普遍存在，例如发送者给接受者发送一个 HTTP 请求，或者 MySQL 客户端向 MySQL 服务器发送一条插入语句，然后超时了没有得到响应。请问服务器是写入成功了还是失败了？答案是不确定，有以下几种情况：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）可能请求由于网络故障根本没有送到服务器，因此写入失败；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）可能服务器收到了，也写入成功了，但是向客户端发送响应前服务器宕机了；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3）可能服务器收到了，也写入成功了，也向客户端发送了响应，但是由于网络故障未送到客户端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论哪种场景，在客户端看来都是一样的结果：它发出的请求没有得到响应。为了确保服务端成功写入数据，客户端只能重发请求，直至接收到服务端的响应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类似的问题问题被称为网络二将军问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网络二将军问题的存在使得消息的发送者往往要重复发送消息，直到收到接收者的确认才认为发送成功，但这往往又会导致消息的重复发送。例如电商系统中订单模块调用支付模块扣款的时候，如果网络故障导致二将军问题出现，扣款请求重复发送，产生的重复扣款结果显然是不能被接受的。因此要保证一次事务中的扣款请求无论被发送多少次，接收方有且只执行一次扣款动作，这种保证机制叫做接收方的幂等性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyibFNwHQyiaHPFJMKmXKesic8w5Gp6dZ3PVyDwKw2wYrFqsuyb4ResIxLaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3. 两阶段提交（2PC） &amp;amp; 三阶段提交（3PC）方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2PC 是一种实现分布式事务的简单模型，这两个阶段是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）准备阶段：事务协调者向各个事务参与者发起询问请求：“我要执行全局事务了，这个事务涉及到的资源分布在你们这些数据源中，分别是……，你们准备好各自的资源（即各自执行本地事务到待提交阶段）”。各个参与者协调者回复 yes（表示已准备好，允许提交全局事务）或 no（表示本参与者无法拿到全局事务所需的本地资源，因为它被其他本地事务锁住了）或超时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）提交阶段：如果各个参与者回复的都是 yes，则协调者向所有参与者发起事务提交操作，然后所有参与者收到后各自执行本地事务提交操作并向协调者发送 ACK；如果任何一个参与者回复 no 或者超时，则协调者向所有参与者发起事务回滚操作，然后所有参与者收到后各自执行本地事务回滚操作并向协调者发送 ACK。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2PC 的流程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8847184986595175&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyibCs0Cv3zqCdAIjnU0eKxf9nvcjhsKg54MIs0LOKmQVR52yJmFPloVHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;746&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图可以看出，要实现 2PC，所有的参与者都要实现三个接口：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Prepare()：TM 调用该接口询问各个本地事务是否就绪&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Commit()：TM 调用该接口要求各个本地事务提交&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Rollback()：TM 调用该接口要求各个本地事务回滚&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以将这三个接口简单地（但不严谨地）理解成 XA 协议。XA 协议是 X/Open 提出的分布式事务处理标准。MySQL、Oracle、DB2 这些主流数据库都实现了 XA 协议，因此都能被用于实现 2PC 事务模型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2PC 简明易懂，但存在如下的问题：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）性能差，在准备阶段，要等待所有的参与者返回，才能进入阶段二，在这期间，各个参与者上面的相关资源被排他地锁住，参与者上面意图使用这些资源的本地事务只能等待。因为存在这种同步阻塞问题，所以影响了各个参与者的本地事务并发度；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）准备阶段完成后，如果协调者宕机，所有的参与者都收不到提交或回滚指令，导致所有参与者“不知所措”；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3）在提交阶段，协调者向所有的参与者发送了提交指令，如果一个参与者未返回 ACK，那么协调者不知道这个参与者内部发生了什么（由于网络二将军问题的存在，这个参与者可能根本没收到提交指令，一直处于等待接收提交指令的状态；也可能收到了，并成功执行了本地提交，但返回的 ACK 由于网络故障未送到协调者上），也就无法决定下一步是否进行全体参与者的回滚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2PC 之后又出现了 3PC，把两阶段过程变成了三阶段过程，分别是：询问阶段、准备阶段、提交或回滚阶段，这里不再详述。3PC 利用超时机制解决了 2PC 的同步阻塞问题，避免资源被永久锁定，进一步加强了整个事务过程的可靠性。但是 3PC 同样无法应对类似的宕机问题，只不过出现多数据源中数据不一致问题的概率更小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2PC 除了性能和可靠性上存在问题，它的适用场景也很局限，它要求参与者实现了 XA 协议，例如使用实现了 XA 协议的数据库作为参与者可以完成 2PC 过程。但是在多个系统服务利用 api 接口相互调用的时候，就不遵守 XA 协议了，这时候 2PC 就不适用了。所以 2PC 在分布式应用场景中很少使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以前文提到的电商场景无法使用 2PC，因为 shopping-service 通过 RPC 接口或者 Rest 接口调用 repo-service 和 order-service 间接访问 repo_db 和 order_db。除非 shopping-service 直接配置 repo_db 和 order_db 作为自己的数据库。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4. TCC 方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;描述 TCC 方案使用的电商微服务模型如下图所示，在这个模型中，shopping-service 是事务协调者，repo-service 和 order-service 是事务参与者。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2440944881889764&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyibkicg4IQVDS8wvNj4ibVWRuvibTtLy1l2Ry17iao1nHviaRIjFjPgb6I94SQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;381&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文提到，2PC 要求参与者实现了 XA 协议，通常用来解决多个数据库之间的事务问题，比较局限。在多个系统服务利用 api 接口相互调用的时候，就不遵守 XA 协议了，这时候 2PC 就不适用了。现代企业多采用分布式的微服务，因此更多的是要解决多个微服务之间的分布式事务问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCC 就是一种解决多个微服务之间的分布式事务问题的方案。TCC 是 Try、Confirm、Cancel 三个词的缩写，其本质是一个应用层面上的 2PC，同样分为两个阶段：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）阶段一：准备阶段。协调者调用所有的每个微服务提供的 try 接口，将整个全局事务涉及到的资源锁定住，若锁定成功 try 接口向协调者返回 yes。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）阶段二：提交阶段。若所有的服务的 try 接口在阶段一都返回 yes，则进入提交阶段，协调者调用所有服务的 confirm 接口，各个服务进行事务提交。如果有任何一个服务的 try 接口在阶段一返回 no 或者超时，则协调者调用所有服务的 cancel 接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCC 的流程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.871222076215506&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyibCVeSc9icNq3PDUjqIicRg48fZIMueyGbXicnUcfCI6S1xlXLIGm0GbvTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;761&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有个关键问题，既然 TCC 是一种服务层面上的 2PC，它是如何解决 2PC 无法应对宕机问题的缺陷的呢？答案是不断重试。由于 try 操作锁住了全局事务涉及的所有资源，保证了业务操作的所有前置条件得到满足，因此无论是 confirm 阶段失败还是 cancel 阶段失败都能通过不断重试直至 confirm 或 cancel 成功（所谓成功就是所有的服务都对 confirm 或者 cancel 返回了 ACK）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyibHXiaXWAwc23nby2vQ1eRUKKcjQETTBrSTkdtobTc2n3IIWwNCqeGKjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里还有个关键问题，在不断重试 confirm 和 cancel 的过程中（考虑到网络二将军问题的存在）有可能重复进行了 confirm 或 cancel，因此还要再保证 confirm 和 cancel 操作具有幂等性，也就是整个全局事务中，每个参与者只进行一次 confirm 或者 cancel。实现 confirm 和 cancel 操作的幂等性，有很多解决方案，例如每个参与者可以维护一个去重表（可以利用数据库表实现也可以使用内存型 KV 组件实现），记录每个全局事务（以全局事务标记 XID 区分）是否进行过 confirm 或 cancel 操作，若已经进行过，则不再重复执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCC 由支付宝团队提出，被广泛应用于金融系统中。我们用银行账户余额购买基金时，会注意到银行账户中用于购买基金的那部分余额首先会被冻结，由此我们可以猜想，这个过程大概就是 TCC 的第一阶段。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5. 事务状态表方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外有一种类似 TCC 的事务解决方案，借助事务状态表来实现。假设要在一个分布式事务中实现调用 repo-service 扣减库存、调用 order-service 生成订单两个过程。在这种方案中，协调者 shopping-service 维护一张如下的事务状态表：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;分布式事务 ID&lt;/th&gt;&lt;th&gt;事务内容&lt;/th&gt;&lt;th&gt;事务状态&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;global_trx_id_1&lt;/td&gt;&lt;td&gt;操作 1：调用 repo-service 扣减库存&lt;br/&gt;操作 2：调用 order-service 生成订单&lt;/td&gt;&lt;td&gt;状态 1：初始&lt;br/&gt;状态 2：操作 1 成功&lt;br/&gt;状态 3：操作 1、2 成功&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始状态为 1，每成功调用一个服务则更新一次状态，最后所有的服务调用成功，状态更新到 3。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这张表，就可以启动一个后台任务，扫描这张表中事务的状态，如果一个分布式事务一直（设置一个事务周期阈值）未到状态 3，说明这条事务没有成功执行，于是可以重新调用 repo-service 扣减库存、调用 order-service 生成订单。直至所有的调用成功，事务状态到 3。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果多次重试仍未使得状态到 3，可以将事务状态置为 error，通过人工介入进行干预。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于存在服务的调用重试，因此每个服务的接口要根据全局的分布式事务 ID 做幂等，原理同 2.4 节的幂等性实现。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.6. 基于消息中间件的最终一致性事务方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是 2PC &amp;amp; 3PC 还是 TCC、事务状态表，基本都遵守 XA 协议的思想，即这些方案本质上都是事务协调者协调各个事务参与者的本地事务的进度，使所有本地事务共同提交或回滚，最终达成一种全局的 ACID 特性。在协调的过程中，协调者需要收集各个本地事务的当前状态，并根据这些状态发出下一阶段的操作指令。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这些全局事务方案由于操作繁琐、时间跨度大，或者在全局事务期间会排他地锁住相关资源，使得整个分布式系统的全局事务的并发度不会太高。这很难满足电商等高并发场景对事务吞吐量的要求，因此互联网服务提供商探索出了很多与 XA 协议背道而驰的分布式事务解决方案。其中利用消息中间件实现的最终一致性全局事务就是一个经典方案。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyib3WvK4Ajlyv4CafVTibExbp0gFZzvictO7CPs5OoUR8nP6YvCNjFIKVEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了表现出这种方案的精髓，我将使用如下的电商系统微服务结构来进行描述：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.828752642706131&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyibibpgOkP52HEkTq9oOIQSTD0ZuicNw7vWkiaGU78o4ZqNJ8CvB2Izw9bxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;473&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个模型中，用户不再是请求整合后的 shopping-service 进行下单，而是直接请求 order-service 下单，order-service 一方面添加订单记录，另一方面会调用 repo-service 扣减库存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种基于消息中间件的最终一致性事务方案常常被误解成如下的实现方式：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4182939362795478&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyiblicxUKgiafygpgHzicBzuzM7uUNhqsSa9cEWjibRomrvwpkATlFV3N8ZEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;973&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种实现方式的流程是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）order-service 负责向 MQ server 发送扣减库存消息（repo_deduction_msg）；repo-service 订阅 MQ server 中的扣减库存消息，负责消费消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）用户下单后，order-service 先执行插入订单记录的查询语句，后将 repo_deduction_msg 发到消息中间件中，这两个过程放在一个本地事务中进行，一旦“执行插入订单记录的查询语句”失败，导致事务回滚，“将 repo_deduction_msg 发到消息中间件中”就不会发生；同样，一旦“将 repo_deduction_msg 发到消息中间件中”失败，抛出异常，也会导致“执行插入订单记录的查询语句”操作回滚，最终什么也没有发生。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9090909090909091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyibSqWLYgN4BX7mlum3mZaUGvZicNwvdIvEr0LTaczRI7TArTIWjukAIVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;198&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3）repo-service 接收到 repo_deduction_msg 之后，先执行库存扣减查询语句，后向 MQ sever 反馈消息消费完成 ACK，这两个过程放在一个本地事务中进行，一旦“执行库存扣减查询语句”失败，导致事务回滚，“向 MQ sever 反馈消息消费完成 ACK”就不会发生，MQ server 在 Confirm 机制的驱动下会继续向 repo-service 推送该消息，直到整个事务成功提交；同样，一旦“向 MQ sever 反馈消息消费完成 ACK”失败，抛出异常，也对导致“执行库存扣减查询语句”操作回滚，MQ server 在 Confirm 机制的驱动下会继续向 repo-service 推送该消息，直到整个事务成功提交。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.025974025974026&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyibvyqxOPFUxaSh92P9FtvlG4EkCUNyRCOicdtyG6n4ZpBJhXUd4IIpYmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;154&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种做法看似很可靠。但没有考虑到网络二将军问题的存在，有如下的缺陷：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）存在网络的 2 将军问题，上面第 2）步中 order-service 发送 repo_deduction_msg 消息失败，对于发送方 order-service 来说，可能是消息中间件没有收到消息；也可能是中间件收到了消息，但向发送方 order-service 响应的 ACK 由于网络故障没有被 order-service 收到。因此 order-service 贸然进行事务回滚，撤销“执行插入订单记录的查询语句”，是不对的，因为 repo-service 那边可能已经接收到 repo_deduction_msg 并成功进行了库存扣减，这样 order-service 和 repo-service 两方就产生了数据不一致问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）repo-service 和 order-service 把网络调用（与 MQ server 通信）放在本地数据库事务里，可能会因为网络延迟产生数据库长事务，影响数据库本地事务的并发度。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyibicR1ia8q3vV0bpbkOCYpXYNRTHmlTZU7DuTjpZOjBsZib1BBiaPJEz860g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;015&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上是被误解的实现方式，下面给出正确的实现方式，如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3600953895071542&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyib3tVMuahWyAA1Z7s7SfMY81OwoPiavicH2SX8OJfb6J5wCSrEyTbeh6dQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1258&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图所示的方案，利用消息中间件如 rabbitMQ 来实现分布式下单及库存扣减过程的最终一致性。对这幅图做以下说明：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）order-service 中，&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;在 t_order 表添加订单记录 &amp;amp;&amp;amp;&lt;br/&gt;&lt;br/&gt;在 t_local_msg 添加对应的扣减库存消息&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两个过程要在一个事务中完成，保证过程的原子性。同样，repo-service 中，&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;检查本次扣库存操作是否已经执行过 &amp;amp;&amp;amp;&lt;br/&gt;&lt;br/&gt;执行扣减库存如果本次扣减操作没有执行过 &amp;amp;&amp;amp;&lt;br/&gt;&lt;br/&gt;写判重表 &amp;amp;&amp;amp;&lt;br/&gt;&lt;br/&gt;向 MQ sever 反馈消息消费完成 ACK&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这四个过程也要在一个事务中完成，保证过程的原子性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）order-service 中有一个后台程序，源源不断地把消息表中的消息传送给消息中间件，成功后则删除消息表中对应的消息。如果失败了，也会不断尝试重传。由于存在网络 2 将军问题，即当 order-service 发送给消息中间件的消息网络超时时，这时候消息中间件可能收到了消息但响应 ACK 失败，也可能没收到，order-service 会再次发送该消息，直至消息中间件响应 ACK 成功，这样可能发生消息的重复发送，不过没关系，只要保证消息不丢失，不乱序就行，后面 repo-service 会做去重处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3）消息中间件向 repo-service 推送 repo_deduction_msg，repo-service 成功处理完成后会向中间件响应 ACK，消息中间件收到这个 ACK 才认为 repo-service 成功处理了这条消息，否则会重复推送该消息。但是有这样的情形：repo-service 成功处理了消息，向中间件发送的 ACK 在网络传输中由于网络故障丢失了，导致中间件没有收到 ACK 重新推送了该消息。这也要靠 repo-service 的消息去重特性来避免消息重复消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4）在 2）和 3）中提到了两种导致 repo-service 重复收到消息的原因，一是生产者重复生产，二是中间件重传。为了实现业务的幂等性，repo-service 中维护了一张判重表，这张表中记录了被成功处理的消息的 id。repo-service 每次接收到新的消息都先判断消息是否被成功处理过，若是的话不再重复处理。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9345794392523364&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyibV2Pwv7yLCUnRQ8GhSZ1UzPgHx8uiaS0gNnLe2o5icG6h9gGFTiblicm0Yg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;214&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这种设计，实现了消息在发送方不丢失，消息在接收方不被重复消费，联合起来就是消息不漏不重，严格实现了 order-service 和 repo-service 的两个数据库中数据的最终一致性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于消息中间件的最终一致性全局事务方案是互联网公司在高并发场景中探索出的一种创新型应用模式，利用 MQ 实现微服务之间的异步调用、解耦合和流量削峰，支持全局事务的高并发，并保证分布式数据记录的最终一致性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyib5RqsQaGWCaib0w5w09ZPTrYV2ocrrMEdu9kd15QqwZ2cltTC4vR5O8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. Seata in AT mode 的实现&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第 2 章给出了实现实现分布式事务的集中常见的理论模型。本章给出业界开源分布式事务框架 Seata 的实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Seata 为用户提供了 AT、TCC、SAGA 和 XA 事务模式。其中 AT 模式是 Seata 主推的事务模式，因此本章分析 Seata in AT mode 的实现。使用 AT 有一个前提，那就是微服务使用的数据库必须是支持事务的关系型数据库。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1. Seata in AT mode 工作流程概述&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Seata 的 AT 模式建立在关系型数据库的本地事务特性的基础之上，通过数据源代理类拦截并解析数据库执行的 SQL，记录自定义的回滚日志，如需回滚，则重放这些自定义的回滚日志即可。AT 模式虽然是根据 XA 事务模型（2PC）演进而来的，但是 AT 打破了 XA 协议的阻塞性制约，在一致性和性能上取得了平衡。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AT 模式是基于 XA 事务模型演进而来的，它的整体机制也是一个改进版本的两阶段提交协议。AT 模式的两个基本阶段是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）第一阶段：首先获取本地锁，执行本地事务，业务数据操作和记录回滚日志在同一个本地事务中提交，最后释放本地锁；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）第二阶段：如需全局提交，异步删除回滚日志即可，这个过程很快就能完成。如需要回滚，则通过第一阶段的回滚日志进行反向补偿。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本章描述 Seata in AT mode 的工作原理使用的电商微服务模型如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.2440944881889764&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyibkicg4IQVDS8wvNj4ibVWRuvibTtLy1l2Ry17iao1nHviaRIjFjPgb6I94SQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;381&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，协调者 shopping-service 先调用参与者 repo-service 扣减库存，后调用参与者 order-service 生成订单。这个业务流使用 Seata in XA mode 后的全局事务流程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9425113464447806&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyibV7bX104pLKKVrjlRRHvm7RRF7IwSZHLTzibwQPicOxSOKqEL2wKUOWnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;661&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图描述的全局事务执行流程为：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）shopping-service 向 Seata 注册全局事务，并产生一个全局事务标识 XID&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）将 repo-service.repo_db、order-service.order_db 的本地事务执行到待提交阶段，事务内容包含对 repo-service.repo_db、order-service.order_db 进行的查询操作以及写每个库的 undo_log 记录&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3）repo-service.repo_db、order-service.order_db 向 Seata 注册分支事务，并将其纳入该 XID 对应的全局事务范围&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4）提交 repo-service.repo_db、order-service.order_db 的本地事务&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5）repo-service.repo_db、order-service.order_db 向 Seata 汇报分支事务的提交状态&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6）Seata 汇总所有的 DB 的分支事务的提交状态，决定全局事务是该提交还是回滚&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7）Seata 通知 repo-service.repo_db、order-service.order_db 提交/回滚本地事务，若需要回滚，采取的是补偿式方法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 1）2）3）4）5）属于第一阶段，6）7）属于第二阶段。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2. Seata in AT mode 工作流程详述&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的电商业务场景中，购物服务调用库存服务扣减库存，调用订单服务创建订单，显然这两个调用过程要放在一个事务里面。即：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;start global_trx&lt;br/&gt;&lt;br/&gt; call 库存服务的扣减库存接口&lt;br/&gt;&lt;br/&gt; call 订单服务的创建订单接口&lt;br/&gt;&lt;br/&gt;commit global_trx&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在库存服务的数据库中，存在如下的库存表 t_repo：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;production_code&lt;/th&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;count&lt;/th&gt;&lt;th&gt;price&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;10001&lt;/td&gt;&lt;td&gt;20001&lt;/td&gt;&lt;td&gt;xx 键盘&lt;/td&gt;&lt;td&gt;98&lt;/td&gt;&lt;td&gt;200.0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;10002&lt;/td&gt;&lt;td&gt;20002&lt;/td&gt;&lt;td&gt;yy 鼠标&lt;/td&gt;&lt;td&gt;199&lt;/td&gt;&lt;td&gt;100.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在订单服务的数据库中，存在如下的订单表 t_order：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;order_code&lt;/th&gt;&lt;th&gt;user_id&lt;/th&gt;&lt;th&gt;production_code&lt;/th&gt;&lt;th&gt;count&lt;/th&gt;&lt;th&gt;price&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;30001&lt;/td&gt;&lt;td&gt;2020102500001&lt;/td&gt;&lt;td&gt;40001&lt;/td&gt;&lt;td&gt;20002&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;100.0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;30002&lt;/td&gt;&lt;td&gt;2020102500001&lt;/td&gt;&lt;td&gt;40001&lt;/td&gt;&lt;td&gt;20001&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;400.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，id 为 40002 的用户要购买一只商品代码为 20002 的鼠标，整个分布式事务的内容为：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）在库存服务的库存表中将记录&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;production_code&lt;/th&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;count&lt;/th&gt;&lt;th&gt;price&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;10002&lt;/td&gt;&lt;td&gt;20002&lt;/td&gt;&lt;td&gt;yy 鼠标&lt;/td&gt;&lt;td&gt;199&lt;/td&gt;&lt;td&gt;100.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改为&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;production_code&lt;/th&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;count&lt;/th&gt;&lt;th&gt;price&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;10002&lt;/td&gt;&lt;td&gt;20002&lt;/td&gt;&lt;td&gt;yy 鼠标&lt;/td&gt;&lt;td&gt;198&lt;/td&gt;&lt;td&gt;100.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）在订单服务的订单表中添加一条记录&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;order_code&lt;/th&gt;&lt;th&gt;user_id&lt;/th&gt;&lt;th&gt;production_code&lt;/th&gt;&lt;th&gt;count&lt;/th&gt;&lt;th&gt;price&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;30003&lt;/td&gt;&lt;td&gt;2020102500002&lt;/td&gt;&lt;td&gt;40002&lt;/td&gt;&lt;td&gt;20002&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;100.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上操作，在 AT 模式的第一阶段的流程图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.4167623421354765&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyibpyMee0ZUuQU9QFXyvRnM2W0J972rLkuY7HXGNYVxoNx9bD7ralZ1xg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;871&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 AT 模式第一阶段的流程来看，分支的本地事务在第一阶段提交完成之后，就会释放掉本地事务锁定的本地记录。这是 AT 模式和 XA 最大的不同点，在 XA 事务的两阶段提交中，被锁定的记录直到第二阶段结束才会被释放。所以 AT 模式减少了锁记录的时间，从而提高了分布式事务的处理效率。AT 模式之所以能够实现第一阶段完成就释放被锁定的记录，是因为 Seata 在每个服务的数据库中维护了一张 undo_log 表，其中记录了对 t_order / t_repo 进行操作前后记录的镜像数据，即便第二阶段发生异常，只需回放每个服务的 undo_log 中的相应记录即可实现全局回滚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;undo_log 的表结构：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;branch_id&lt;/th&gt;&lt;th&gt;xid&lt;/th&gt;&lt;th&gt;context&lt;/th&gt;&lt;th&gt;rollback_info&lt;/th&gt;&lt;th&gt;log_status&lt;/th&gt;&lt;th&gt;log_created&lt;/th&gt;&lt;th&gt;log_modified&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;……&lt;/td&gt;&lt;td&gt;分支事务 ID&lt;/td&gt;&lt;td&gt;全局事务 ID&lt;/td&gt;&lt;td&gt;……&lt;/td&gt;&lt;td&gt;分支事务操作的记录在事务前后的记录镜像，即 beforeImage 和 afterImage&lt;/td&gt;&lt;td&gt;……&lt;/td&gt;&lt;td&gt;……&lt;/td&gt;&lt;td&gt;……&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一阶段结束之后，Seata 会接收到所有分支事务的提交状态，然后决定是提交全局事务还是回滚全局事务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）若所有分支事务本地提交均成功，则 Seata 决定全局提交。Seata 将分支提交的消息发送给各个分支事务，各个分支事务收到分支提交消息后，会将消息放入一个缓冲队列，然后直接向 Seata 返回提交成功。之后，每个本地事务会慢慢处理分支提交消息，处理的方式为：删除相应分支事务的 undo_log 记录。之所以只需删除分支事务的 undo_log 记录，而不需要再做其他提交操作，是因为提交操作已经在第一阶段完成了（这也是 AT 和 XA 不同的地方）。这个过程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6545012165450121&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyibJ2NuHHE4HIxicsfsIVLkqZkTNKRTKhvKGqibv0ZZjcsLEviciahZiaQRghA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;822&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分支事务之所以能够直接返回成功给 Seata，是因为真正关键的提交操作在第一阶段已经完成了，清除 undo_log 日志只是收尾工作，即便清除失败了，也对整个分布式事务不产生实质影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）若任一分支事务本地提交失败，则 Seata 决定全局回滚，将分支事务回滚消息发送给各个分支事务，由于在第一阶段各个服务的数据库上记录了 undo_log 记录，分支事务回滚操作只需根据 undo_log 记录进行补偿即可。全局事务的回滚流程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7567298105682951&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyib2laGp1Qj5tRxEWBmttskicEiad6CxcX4qgN0qswCyWDTuniaUzC9Yc2fw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1003&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里对图中的 2、3 步做进一步的说明：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）由于上文给出了 undo_log 的表结构，所以可以通过 xid 和 branch_id 来找到当前分支事务的所有 undo_log 记录；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）拿到当前分支事务的 undo_log 记录之后，首先要做数据校验，如果 afterImage 中的记录与当前的表记录不一致，说明从第一阶段完成到此刻期间，有别的事务修改了这些记录，这会导致分支事务无法回滚，向 Seata 反馈回滚失败；如果 afterImage 中的记录与当前的表记录一致，说明从第一阶段完成到此刻期间，没有别的事务修改这些记录，分支事务可回滚，进而根据 beforeImage 和 afterImage 计算出补偿 SQL，执行补偿 SQL 进行回滚，然后删除相应 undo_log，向 Seata 反馈回滚成功。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyibC4US6rXYBaP2AJuQwwHPpzqrouCdTHmasVtGJksX4up7f5ZGpDPW9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务具有 ACID 特性，全局事务解决方案也在尽量实现这四个特性。以上关于 Seata in AT mode 的描述很显然体现出了 AT 的原子性、一致性和持久性。下面着重描述一下 AT 如何保证多个全局事务的隔离性的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 AT 中，当多个全局事务操作同一张表时，通过全局锁来保证事务的隔离性。下面描述一下全局锁在读隔离和写隔离两个场景中的作用原理：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）写隔离（若有全局事务在改/写/删记录，另一个全局事务对同一记录进行的改/写/删要被隔离起来，即写写互斥）：写隔离是为了在多个全局事务对同一张表的同一个字段进行更新操作时，避免一个全局事务在没有被提交成功之前所涉及的数据被其他全局事务修改。写隔离的基本原理是：在第一阶段本地事务（开启本地事务的时候，本地事务会对涉及到的记录加本地锁）提交之前，确保拿到全局锁。如果拿不到全局锁，就不能提交本地事务，并且不断尝试获取全局锁，直至超出重试次数，放弃获取全局锁，回滚本地事务，释放本地事务对记录加的本地锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设有两个全局事务 gtrx_1 和 gtrx_2 在并发操作库存服务，意图扣减如下记录的库存数量：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;id&lt;/th&gt;&lt;th&gt;production_code&lt;/th&gt;&lt;th&gt;name&lt;/th&gt;&lt;th&gt;count&lt;/th&gt;&lt;th&gt;price&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;10002&lt;/td&gt;&lt;td&gt;20002&lt;/td&gt;&lt;td&gt;yy 鼠标&lt;/td&gt;&lt;td&gt;198&lt;/td&gt;&lt;td&gt;100.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AT 实现写隔离过程的时序图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5651340996168582&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyibLMPDDFCSD7Ruo9MibibuyCTicib54XbMNHibZurfF4Q1zCoL1811AiagpDZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1044&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图中，1、2、3、4 属于第一阶段，5 属于第二阶段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中 gtrx_1 和 gtrx_2 均成功提交，如果 gtrx_1 在第二阶段执行回滚操作，那么 gtrx_1 需要重新发起本地事务获取本地锁，然后根据 undo_log 对这个 id=10002 的记录进行补偿式回滚。此时 gtrx_2 仍在等待全局锁，且持有这个 id=10002 的记录的本地锁，因此 gtrx_1 会回滚失败（gtrx_1 回滚需要同时持有全局锁和对 id=10002 的记录加的本地锁），回滚失败的 gtrx_1 会一直重试回滚。直到旁边的 gtrx_2 获取全局锁的尝试次数超过阈值，gtrx_2 会放弃获取全局锁，发起本地回滚，本地回滚结束后，自然会释放掉对这个 id=10002 的记录加的本地锁。此时，gtrx_1 终于可以成功对这个 id=10002 的记录加上了本地锁，同时拿到了本地锁和全局锁的 gtrx_1 就可以成功回滚了。整个过程，全局锁始终在 gtrx_1 手中，并不会发生脏写的问题。整个过程的流程图如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6881720430107527&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyibqdgKCPTq1sc53mfx7KezWibu2qs6CUtNVBia1qmWUVia69ld7HORWKfaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1116&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）读隔离（若有全局事务在改/写/删记录，另一个全局事务对同一记录的读取要被隔离起来，即读写互斥）：在数据库本地事务的隔离级别为读已提交、可重复读、串行化时（读未提交不起什么隔离作用，一般不使用），Seata AT 全局事务模型产生的隔离级别是读未提交，也就是说一个全局事务会看到另一个全局事务未全局提交的数据，产生脏读，从前文的第一阶段和第二阶段的流程图中也可以看出这一点。这在最终一致性的分布式事务模型中是可以接受的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要求 AT 模型一定要实现读已提交的事务隔离级别，可以利用 Seata 的 SelectForUpdateExecutor 执行器对 SELECT FOR UPDATE 语句进行代理。SELECT FOR UPDATE 语句在执行时会申请全局锁，如果全局锁已经被其他全局事务占有，则回滚 SELECT FOR UPDATE 语句的执行，释放本地锁，并且重试 SELECT FOR UPDATE 语句。在这个过程中，查询请求会被阻塞，直到拿到全局锁（也就是要读取的记录被其他全局事务提交），读到已被全局事务提交的数据才返回。这个过程如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5726141078838174&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyibjnx4IM9rsZERUlOMGP7jH1D1XlvqomjzSWjsAW6icukDEaOFSPN2g3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1205&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyib9iajtpdPVV9yJJ5cziawYohhNde1nJWE5rhicGvoVJYibEN6gBERvfY1pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 结束语&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;XA 协议是 X/Open 提出的分布式事务处理标准。文中提到的 2PC、3PC、TCC、本地事务表、Seata in AT mode，无论哪一种，本质都是事务协调者协调各个事务参与者的本地事务的进度，使使所有本地事务共同提交或回滚，最终达成一种全局的 ACID 特性。在协调的过程中，协调者需要收集各个本地事务的当前状态，并根据这些状态发出下一阶段的操作指令。这个思想就是 XA 协议的要义，我们可以说这些事务模型遵守或大致遵守了 XA 协议。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于消息中间件的最终一致性事务方案是互联网公司在高并发场景中探索出的一种创新型应用模式，利用 MQ 实现微服务之间的异步调用、解耦合和流量削峰，保证分布式数据记录的最终一致性。它显然不遵守 XA 协议。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于某项技术，可能存在业界标准或协议，但实践者针对具体应用场景的需求或者出于简便的考虑，给出与标准不完全相符的实现，甚至完全不相符的实现，这在工程领域是一种常见的现象。TCC 方案如此、基于消息中间件的最终一致性事务方案如此、Seata in AT mode 模式也如此。而新的标准往往就在这些创新中产生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9833333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyibzUMA505xjOaVyzBicRdPMjnO4L7yvpB7FsVTrF0ofKtwWMibhGPfWCicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你难道真的没有发现 2.6 节（基于消息中间件的最终一致性事务方案）给出的正确方案中存在的业务漏洞吗？请各位重新看下这张图，仔细品一品两个微服务的调用方向，把你的想法留在评论区吧 :-)&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3600953895071542&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/OyweysCSeLUicibBibJhpkgl32RrSLP1kyib3tVMuahWyAA1Z7s7SfMY81OwoPiavicH2SX8OJfb6J5wCSrEyTbeh6dQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1258&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后欢迎大家加我好友，拉你进技术交流群，群里有很多 BAT 的大咖，可以提问，互相交流，内推等，进群一起抱团取暖&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;jpeg&quot; data-w=&quot;231&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/OyweysCSeLUw3oEcJTUMphCBvlHmY65E5yTCPEQwy3OJtficSkmhhJmQd44k5Ze08DicI1mBhd38V1xk1DpLDLEA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>182248dbec16d336002e5936f5064c52</guid>
<title>博客十年</title>
<link>https://toutiao.io/k/nxy0gra</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-content&quot;&gt;
      &lt;p&gt;是的，我的个人博客今天迎来了第 10 个年头。今天碎碎念一篇这 10 年对我有很深影响的人和事情，以及感想。&lt;/p&gt;
&lt;h3 id=&quot;感谢带我入行的悦秋&quot;&gt;感谢带我入行的悦秋&lt;/h3&gt;
&lt;p&gt;我一开始是以网络工程师的身份进入职场的，清晰记得当时面试时运维经理悦秋问我的那些运维问题一个都回答不出来，印象最深的一个问题是「了解 CentOS 么？」只用过 RHEL 的我一脸懵逼。我想能通过面试是因为我非计算机专业的背景却独身一人来北京闯的那种拼劲和对知识的渴求吧。&lt;/p&gt;
&lt;p&gt;记得有一天和悦秋闲聊，悦秋给我展示了他的技术博客，拥有一个自己的博客在当时对我来说既神秘又向往，我就缠着悦秋教我怎么搞。从买域名、租主机到部署博客程序、配置 DNS，现在看来这些都太简单不过了，可是对于当时的我来说学到了很多知识。&lt;/p&gt;
&lt;h3 id=&quot;第一篇博客&quot;&gt;第一篇博客&lt;/h3&gt;
&lt;p&gt;无论是开发者还是运维，想必在职业生涯中都犯过错误。相信很多人都怕在试用期犯错，而我犯了个当时惊出我们组所有人一身冷汗的事故。&lt;/p&gt;
&lt;p&gt;我们接手了前面运维的工作，悦秋给我安排了一个修改全部服务器日常用户账号密码的任务。我忘了当时怎么操作了，密码改错了，所有人都登不上这个账号且没人知道 root 密码，当时只有我有一个终端还没有退出登录，但是已经不能 sudo 了。&lt;/p&gt;
&lt;p&gt;讲一点背景，当时运维是做日常维护，除此之外开发部门也有上线权限，当我发现密码出现问题赶紧和悦秋汇报，悦秋很镇定，在确定确实找不回来了后和我说 CentOS5 有一个通过 Gcc++ 漏洞普通用户获得 root 权限的问题我们还没有打补丁，让我网上找方法试试拿到 root 权限改密码。有大神指点，我很快 Google 到方法，试了下确实可以，就这样有惊无险在没人知道的情况下把密码改回来了。^_^&lt;/p&gt;
&lt;p&gt;现在说起来很轻松，但是当时对我可以说是差点被开除，现在想想很后怕：如果此时恰好出现个严重 BUG 需要上线...&lt;/p&gt;
&lt;p&gt;在悦秋的鼓励下，写了第一篇博客 &lt;a href=&quot;https://old.dongwm.com/old/archives/linux-gcc%E6%BC%8F%E6%B4%9E%EF%BC%9A%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E8%8E%B7%E5%BE%97root%E6%9D%83%E9%99%90/&quot;&gt;《Linux Gcc++ 漏洞：普通用户获得 root 权限》&lt;/a&gt; (这篇文章由于年久失修代码段格式已经混乱了)。它的发表时间是 2010 年 11 月 1 日，我说的博客十年就是按这个日期开始算的。&lt;/p&gt;
&lt;p&gt;从那个时刻开始，我把个人博客定位在一个存放笔记的地方，把工作和个人学习过程中一些觉得重要的、有价值的内容记录下来，方便日后能随时翻到，当时并没想着惠及他人或者出名之类的。&lt;/p&gt;
&lt;h3 id=&quot;追忆&quot;&gt;追忆&lt;/h3&gt;
&lt;p&gt;翻了翻过去写的内容，一转眼已经 328 篇，可以感受到文笔从稚嫩到成熟再到有自己的理解和风格。我的学习经历比较曲折：做过运维，学过 Ruby、Perl、Go 等语言以及前端的各种知识，刚开始工作走了很多弯路，无基础，无人指导，像没头苍蝇那样乱学一通。虽然人生的每一段经历都是有意义的，但现在回头想想，实在是浪费了太多不必要的时间，直到这几年才渐渐的才摸索出属于自己的方向。&lt;/p&gt;
&lt;p&gt;现在入行的朋友们已经非常幸福了，网络上资源非常多，大多数遇到的问题也能很容易地从网上找到答案或者思路，但不可否认的是，资源太分散，而且绝大多数文章都是浅尝辄止，千篇一律，想找到一些出众的、优秀的、比较原理性的文章真的没那么容易。&lt;/p&gt;
&lt;p&gt;虽然不同的文章会对应各个阶段的读者，对不同的人也有不同的帮助。但是我一直在试着写一些系列的、完整的、稍有深入的内容，并且未来也会这样。&lt;/p&gt;
&lt;p&gt;能有自己的理解和风格，需要付出很多的精力和时间，现在想想还能记起很多美好的事情。例如在早期学习 Linux 命令时我把所有系统里面存在的命令全部找出来，挨个查它是做什么的，都可以加什么参数实现什么作用。另外也会从同事那里了解一些有意思的玩法，我那会经常 attach 到同事的 tmux 会话里看他们怎么操作，‘偷师’成绩斐然。学习 Python 时也是这么个习惯，挨个查 Python 标准库是做什么的怎么用，这个很有价值，对于我 Python 的快速提高极其有帮助。我写的关于 Puppet、Nagios、Icinga、Gentoo、AWK/Sed、Celery、IPython、Python 并发编程、Asyncio 等等内容收到了很多网友从各种途径的反馈，这对我是很大的鼓励，能帮到别人非常有成就感，也非常开心。&lt;/p&gt;
&lt;h3 id=&quot;那些记忆深刻的博客和ID&quot;&gt;那些记忆深刻的博客和 ID&lt;/h3&gt;
&lt;p&gt;我赶上了最好的时代，也错过了最好的时代。怀念那个博客盛行的时代有太多闪亮的 ID 了。如果你在华蟒邮件组 (CPyUG) 里，你能见到非常多知名的 ID，在 14 年之前讨论很热烈，之后渐渐的消沉直到陷入长期的静默。而我有幸在豆瓣里也经历了这样的过程：我入职时洪教授和清风老师还在，翻代码版本库可以 blame 到各个大神的 ID，但是每个人都选择在正确、合适的时间离开了。豆瓣的那些开发者 ID 我就不提了，就写几个在互联网上印象最深的独立博客和 ID 吧。&lt;/p&gt;
&lt;h4 id=&quot;simple-is-better.com&quot;&gt;simple-is-better.com&lt;/h4&gt;
&lt;p&gt;这个网站到现在也不知道主人是谁，很神秘。我开始学习 Python 就关注了它，从里面看过有很多有价值的文章，后来还很忐忑的把自己的博客链接加在了它的「酷站导航」列表中。这个网站现在已经不可以访问，就像是突然消失，甚至像是从来没有出现过。&lt;/p&gt;
&lt;h4 id=&quot;laoqiu&quot;&gt;laoqiu&lt;/h4&gt;
&lt;p&gt;我刚开始学习 Python 时就看过他的技术博客。那个时候用 Flask 框架自己搞个博客是个很酷的事情 ，在之后我学习 Tornado 时还看到他基于 &lt;a href=&quot;https://github.com/laoqiu/pypress&quot;&gt;pypress&lt;/a&gt; 搞了一个 Tornado 版本的博客，一直走在我前面。这个人很神秘 ，等我能用 Python 写 Web 时他的博客已经不能访问，我之后一直关注他，但是他好像已经不在这一行了 。&lt;/p&gt;
&lt;h4 id=&quot;gashero&quot;&gt;gashero&lt;/h4&gt;
&lt;p&gt;这个 ID 想必大家很熟，不过大家可能只知道他是知乎大 V 刘老师，不知道他在 Python 领域里面做过什么，有兴趣的可以看看他的 &lt;a href=&quot;http://gashero.net/resume.html&quot;&gt;简历&lt;/a&gt; ，我一开始了解和学习 Twisted、SQLAlchemy 都是看他写的系列文章，真大佬。&lt;/p&gt;
&lt;h4 id=&quot;lepture&quot;&gt;lepture&lt;/h4&gt;
&lt;p&gt;很有名的 ID 了，如果你做过 Python Web 开发应该听过他的名字。他写了很多 Flask 插件 ，我的博客程序也用到了他写的 mistune 和 github-cards。不过遗憾的是他已经退出 Python 社区开发很久了，可以说他写 Flask 时我还不会，他不写很久以后我才开始做 Web 开发。&lt;/p&gt;
&lt;h3 id=&quot;博客程序历史&quot;&gt;博客程序历史&lt;/h3&gt;
&lt;p&gt;一开始用的是 Wordpress 和吴钊 (mg12) 的 iNove 主题，这个双栏主题当时很有名，曾经长期位于 WP 官方主题目录榜首。&lt;/p&gt;
&lt;p&gt;但是作为了 Python 开发者用一个 PHP 写的博客总觉得不好，后来紧跟潮流改用了 Jekyll：写 Markdown 语法的文章，它会自动帮你生成静态网站页面文件。使用 Jekyll 的时间比较短，而且比较早已经不记得用了什么主题了。不过当时没有一个好的 Wordpress 转 Markdown 文件的工具，所以我的早期文章转化后的格式是有问题的，上面提的类似第一篇文章的代码段格式问题就是这么来的。&lt;/p&gt;
&lt;p&gt;Jekyll 是 Ruby 写的，虽然我当时会一点 Ruby，但是上手不易且容易出现问题，很快就换成了基于它的 Octopress (现在我的 &lt;a href=&quot;https://old.dongwm.com/&quot;&gt;老博客&lt;/a&gt; 还是可以访问的)，这个时期我正好也在学前端知识，所以定制了一些内容包括用了一个自己写的豆瓣收藏秀的插件，可以说倒腾自己的博客是我实践我的前端知识的第一站。&lt;/p&gt;
&lt;p&gt;这里解释下，一直没选择 Python 世界里面的静态网站生成器 (例如 Pelican) 主要是没有满意的主题。而我一直也有个遗憾，就是没有用我 Web 开发的知识写个博客产品。&lt;/p&gt;
&lt;p&gt;说到这里偏个题，我以前面试别人或者看别人个人技术博客时，如果我发现对方用的博客应用是自己写的加分，用 Python 写的超加分，用静态网站生成器不减分，用 PHP 或者其他语言编写的应用时会减分：这是一种「&lt;strong&gt;技术信仰&lt;/strong&gt;」。终于借着机会在 19 年中用上了我自己写的博客应用 &lt;a href=&quot;https://github.com/dongweiming/lyanna&quot;&gt;Lyanna&lt;/a&gt; ，嗯，效果就是你现在访问的这样，觉得总算对得起自己的工作内容了，省的被嘲讽一个 Python Web 开发用着 Ruby 写的静态网站生成器 (其实并没人这么说过)。&lt;/p&gt;
&lt;h3 id=&quot;为什么写博客的越来越少？&quot;&gt;为什么写博客的越来越少？&lt;/h3&gt;
&lt;p&gt;和我同时代写技术博客的，现在几乎都已经停更了，即便现在还在更新的我也是很久一篇，而且渐渐的不怎么写技术性内容了。原来在我订阅列表里的绝大部分觉得写的很好、内容很有价值的国内外技术博客都停更甚至不再可以访问，其实挺可惜的。&lt;/p&gt;
&lt;p&gt;那么为什么大家不再写或者不愿意写了？&lt;/p&gt;
&lt;h4 id=&quot;有更重要的事情&quot;&gt;有更重要的事情&lt;/h4&gt;
&lt;p&gt;我认识的大部分博主都是在职场早期博客写的很勤快，一方面是求知欲相对更强，一方面一个有价值的技术博客是一份很好的简历，对于找工作确实能起到一些作用。不过随着技术的提升，大家有了非常多的方向：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt; 进入管理岗。我想大部分能写好技术博客的同学一开始也没想着去做管理，但是老人走了，能力又突出就顺理成章升职啦。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt; 肩负更重更高的职责。在工作中已经证明了自己的实力，甚至在业界也被认可了，写不写博客已经不重要。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt; 转行 / 创业。已经不碰代码了。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt; 带娃。很多我认识的博主都已经有了自己的家庭，有了孩子。我反正是非常羡慕公司的单身同事的，结婚后要花很多时间精力维护各种关系，而且带娃写作业比写博客可累多了，现在我已经很少能专心花个半天或者更长时间去专研点什么，更多的是碎片时间，也许正专心的思考什么时候就会被各种事情打断。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们每个人都要上班，这是一种习惯，但没人热爱上班。写博客这件事其实写着写着熟悉了就无趣了，很少有人热爱分享和写作。博客可以不写，但是班能不上嘛？写博客在后来的日子里会慢慢变得更力不从心，把有限的精力用来做更有价值的事情是成年人应该的选择。初入职场工资低娱乐少，写写博客充实也会很开心，但是慢慢地随着工资和见识增涨，会发现快乐的事情其实还有很多...O (∩_∩) O 再花那么多时间和精力写博客就没意思了。&lt;/p&gt;
&lt;h4 id=&quot;没有能力持续产出&quot;&gt;没有能力持续产出&lt;/h4&gt;
&lt;p&gt;职场一开始有非常多技术和非技术的技能要学习和理解，但是融入之后自己不求上进的话很容易温水煮青蛙。其实我们每个人只是公司产品线上的一颗螺丝钉罢了，在业务里我们并没有那么重要，对很多人来说只是负责其中一小部分，这部分可能你是专家，但是其他的部分基本上都只能算熟悉，写不了什么高质量文章：这也是很多人不写书或者写不了书的原因。就拿我说，知乎上我可能花半个小时就能写一篇上百赞的回答，但是写技术文章，别说日更，我都不敢说持续的每周能写 1-2 篇。&lt;/p&gt;
&lt;p&gt;哎，越学习越觉得懂得太少，知识深度和广度有限。&lt;/p&gt;
&lt;h4 id=&quot;收不到正反馈&quot;&gt;收不到正反馈&lt;/h4&gt;
&lt;blockquote&gt;&lt;p&gt; 写作和健身很像 ，是一个长期的、过程中效果不明显的工程。在这个碎片化的时代，踏实的好好写作很难收到正反馈 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在有非常多的渠道的方式分享你的知识和经验，甚至还能从其中获得实际的收益。写技术博客是其中最孤独、最不容易获得反馈的方式。其他的如微信公众号、知乎专栏和 Github 等等，无论那种都比自建博客开发和资源成本低，现在大部分人都喜欢快餐式的获得知识收获关注，不愿意从折腾中获得乐趣，看后就走，就好像点个赞、加个收藏就已经学会了。我能理解一个新人花了很长时间写完一篇自我感觉不错的文章充满期待的发出去，结果只有个位数的阅读量，无人点赞无人评论，这样很容易放弃掉。&lt;/p&gt;
&lt;p&gt;真正的技术人大部分不愿意「营销」自己，我这里说的营销不是贬义，是指写完文章主动推广给别人知道你写了它，要不然如果不是通过一些特殊的关键词搜索基本它就会被现在每日大量的信息垃圾淹没了。&lt;/p&gt;
&lt;p&gt;另外一个点是转载 / 搬运成风。原创的高质量文章永远是很稀缺的，搜索引擎先搜到的可能是那些专门搬运和转载的人的内容：因为他们总是在刷爆款文垃圾文，访问量高，权重很高。&lt;/p&gt;
&lt;p&gt;大家都没时间或者说不愿意静下心来学习和总结。各种碎片时间都用在了微信、知乎、短视频 (如抖音等) 这些平台了。所以越来越多的人丧失了独立思考的能力，很少有人静下心来写点有思考有深度的东西，也很少有人愿意静下心来读一些这样的文字。过去有独立的博客很自豪，通过网络可以找到同样喜欢某种技术或者某个东西的朋友，我们会交流观点分享经验，即便从未线下见过，也是心照不宣，这激励了我持续学习和思考。我能从脑海和 Google Reader 里面能找到一大堆有价值的博客甚至具体的文章，当年那些知名 Python 博客我能如数家珍，能快速的想到某个博主曾经写过某篇 (些) 文章介绍某个知识点或者解决某个问题的方案以及思路。而现在好的独立博客已经凤毛麟角，Python 领域我已经很长时间没有看到新鲜的内容和博主了；知乎直接沦陷成小白和割韭菜党；微信公众号头部大 V 们都是纯自媒体自己 Python 写的一坨屎，还日常贩卖焦虑，标题党，有一堆小白捧臭脚，真的看得我很尴尬，唉。&lt;/p&gt;
&lt;h3 id=&quot;后记&quot;&gt;后记&lt;/h3&gt;
&lt;blockquote&gt;&lt;p&gt; 我还是从前那个少年，没有一丝丝改变，时间只不过是考验，种在心中信念丝毫未减 - 《少年》歌词 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;十年很长，十年很短。写博客并不难，难的是坚持。我可能是一个愿意分享的人一直坚持到现在，但当我不再热血不再年轻的时候，我发现自己的精力并不是我想的那般充沛，生活并不是我想的那么美好，太多的事情要做，所以未来更新博客不会再如从前，但是如果我那天停更了，我会写最后一篇告诉大家不必再等。&lt;/p&gt;
&lt;p&gt;最后再次欢迎各位光临我的博客，更希望我的文章能对各位有所帮助。&lt;/p&gt;

    &lt;/div&gt;

  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>760abac844d1ba78b385dfca2d50b53e</guid>
<title>想自学 Maven？推荐 Maven 极简高速入门及常规使用</title>
<link>https://toutiao.io/k/7q3wfwb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.22260869565217392&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gDHRjEowjKQMYibiaKeHYSvicqcPfHnAwYpnTo6pOJiaGjibkf6kJ31Hll3h46EANcStccScvMOaMmp6mh4VY3CmdRw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;575&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;公众号[JavaQ]原创，专注分享Java基础原理分析、实战技术、微服务架构、分布式系统构建，诚邀点赞关注！&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;前言&lt;/h3&gt;&lt;p&gt;笔者的工作经历中使用过Ant、Maven和Gradle，如果让笔者选择，笔者会首选Gradle。那为什么还要写Maven这篇内容呢？时下大部分公司都还在使用Maven，并且很多开源项目也在使用Maven，Maven有一些功能特性还是很不错的，很值得做总结记录。&lt;/p&gt;&lt;h3&gt;Maven是什么&lt;/h3&gt;&lt;p&gt;Maven是Apache旗下的一个纯Java开发的开源项目，是一个用于构建和管理任何基于Java的项目的工具。&lt;/p&gt;&lt;h3&gt;为什么要使用Maven&lt;/h3&gt;&lt;p&gt;使用Maven轻松实现项目jar包依赖管理、子模块管理、构建jar/war包、管理jar/war包、执行单元/集成测试、执行代码分析/代码质量检查等等，开箱即用让开发者无需花更多的时间。&lt;/p&gt;&lt;h3&gt;Maven安装&lt;/h3&gt;&lt;p&gt;安装Maven之前，需要确保安装了JDK，Maven3.3+版本需要安装JDK 1.7或更高版本。Apache Maven 3.6.3是当前推荐安装的最新版本，推荐使用国内镜像地址下载(https://mirrors.tuna.tsinghua.edu.cn/apache/)。&lt;/p&gt;&lt;h4&gt;Windows系统安装及设置&lt;/h4&gt;&lt;p&gt;下载地址：https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.3/binaries/&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3094274146905726&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKQMYibiaKeHYSvicqcPfHnAwYp0icpTKxuFxPsKJ2hJRQHDPOCT2bL240lXsb91zIjKpfs5LazBUOKuicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1729&quot;/&gt;&lt;/p&gt;&lt;p&gt;windows操作系统下载apache-maven-3.6.3-bin.zip，解压压缩包到硬盘的某个路径，例如：D：\Maven\apache-maven-3.6.3，右键&quot;计算机&quot;(或我的电脑)，选择&quot;属性&quot;，点击&quot;高级系统设置&quot;，点击&quot;环境变量&quot;，新建系统变量 MAVEN_HOME，变量值为D：\Maven\apache-maven-3.6.3，编辑系统变量Path，在变量值得末尾加上;%MAVEN_HOME%\bin，保存如上修改退出。&lt;/p&gt;&lt;p&gt;打开命令行窗口(快捷键win+r，输入cmd回车)，输入mvn –v回车，如果正常输出Maven版本号则安装及配置完成，否则安装上述步骤检查。&lt;/p&gt;&lt;h4&gt;Linux系统安装及设置&lt;/h4&gt;&lt;p&gt;Linux系统下载apache-maven-3.6.3-bin.tar.gz，通过如下命令行操作下载及解压，例如解压到/usr/local/路径：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;wget https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;tar -xvf apache-maven-3.6.3-bin.tar.gz&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sudo mv -f apache-maven-3.6.3/usr/local/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;使用如下命令行操作打开/etc/profile：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sudo vim /etc/profile&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;在文件末尾添加如下配置：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;export MAVEN_HOME=/usr/local/apache-maven-3.6.3&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;export PATH=${PATH}:${MAVEN_HOME}/bin&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;退出编辑并保存，运行如下命令使配置的环境变量生效：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;source /etc/profile&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;在命令行窗口输入mvn –v命令检查安装及设置是否完成，如果正常输出Maven版本号则安装及配置完成，否则安装上述步骤检查。&lt;/p&gt;&lt;h4&gt;Mac系统安装及设置&lt;/h4&gt;&lt;p&gt;Mac系统下载apache-maven-3.6.3-bin.tar.gz，通过如下命令行操作下载及解压，例如解压到/usr/local/路径：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;curl -O https://mirrors.tuna.tsinghua.edu.cn/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;tar -xvf apache-maven-3.6.3-bin.tar.gz&lt;/span&gt;&lt;/code&gt;&lt;code/&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sudo mv -f apache-maven-3.6.3/usr/local/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;使用如下命令行操作打开/etc/profile：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sudo vim /etc/profile&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;在文件末尾添加如下配置：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;export MAVEN_HOME=/usr/local/apache-maven-3.6.3&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;export PATH=${PATH}:${MAVEN_HOME}/bin&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;退出编辑并保存，运行如下命令使配置的环境变量生效：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;source /etc/profile&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;在命令行窗口输入mvn –v命令检查安装及设置是否完成，如果正常输出Maven版本号则安装及配置完成，否则安装上述步骤检查。&lt;/p&gt;&lt;h3&gt;如何使用Maven&lt;/h3&gt;&lt;p&gt;Maven是一个庞大的项目，有很全面的管理功能，本篇内容只记录开发者日常使用频率比较高的部分功能。&lt;/p&gt;&lt;h3&gt;设置Maven仓库&lt;/h3&gt;&lt;p&gt;Maven仓库就是一个位置，用于存储项目中的依赖，这个依赖可以是jar、war、zip、pom等。&lt;/p&gt;&lt;p&gt;Maven仓库有三种类型：本地仓库、中央仓库和远程仓库。当执行Maven构建命令查找项目依赖时，首先从本地仓库搜索，如果本地仓库找不到，再从中央仓库搜索，如果中央仓库也找不到，又配置过远程仓库，那么再从远程仓库搜索。&lt;/p&gt;&lt;p&gt;本地仓库是计算机本机硬盘上的某个路径，这个路径在安装Maven后不会马上创建，它在第一次运行Maven命令的时候才被创建。默认情况下，本地仓库被创建后，这个路径是用户目录下.m2/repository/，例如Windows系统是C:\Users\admin.m2\repository，Linux系统是/home/admin/.m2/repository/，Mac系统是/Users/wxq/.m2/repository/。如果要修改本地仓库的位置，更改Maven解压后目录下conf中的settings.xml文件，找到localRepository标签，将其值设置为想要的本地路径，例如：&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!-- localRepository&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;|The path to the local repository maven will use to store artifacts.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;|&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;|Default: ${user.home}/.m2/repository&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;localRepository&amp;gt;D:/LocalRepository&amp;lt;/localRepository&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/settings&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;中央仓库是由Maven社区提供的仓库，其中包含了绝大多数流行的开源Java依赖。这个仓库不需要配置，只要有网络就可以直接使用。如果你想确认一下某依赖在中央仓库中是否真的存在，可以在http://search.maven.org/#browse搜索。使用中央仓库下载依赖可能会很慢，所以需要配置一个国内的镜像地址来代替原中央仓库的默认地址，推荐使用阿里云的镜像地址。打开Maven解压后目录下conf中的settings.xml文件，在mirrors标签中添加如下镜像配置即可。&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;mirror&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;　　 &amp;lt;id&amp;gt;alimaven&amp;lt;/id&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;　　 &amp;lt;name&amp;gt;aliyun maven&amp;lt;/name&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;　　 &amp;lt;url&amp;gt;http://maven.aliyun.com/nexus/content/groups/public/&amp;lt;/url&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;　　 &amp;lt;mirrorOf&amp;gt;central&amp;lt;/mirrorOf&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/mirror&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;远程仓库是开发人员自己定制的仓库，用于存放不想被公开的私有依赖，例如用于存放管理个人/公司开发的公共jar。远程仓库可以在pom.xml中配置，这里不详细描述步骤了。&lt;/p&gt;&lt;h3&gt;认识pom.xml&lt;/h3&gt;&lt;p&gt;pom.xml是Maven的基本工作单元，包含了项目的基本信息，声明了项目依赖、项目如何构建等等。使用Maven时，Maven会自动在当前目录中查找pom.xml，读取pom.xml，获取所需的配置信息，然后执行目标任务。pom.xml一般放置在项目源码的根目录下。&lt;/p&gt;&lt;p&gt;每个pom.xml都有一个父pom.xml，父pom.xml中包含了一些可以被继承的默认设置，例如当查找依赖时，如果本地仓库中没有，默认会从中央仓库中查找依赖，但是这个中央仓库默认是不需要配置的，是因为在父pom.xml中配置了中央仓库的地址http://repo1.maven.org/maven2。&lt;/p&gt;&lt;p&gt;pom.xml文件元素有很多，这里只介绍常用的部分标签元素。&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--继承的父项目信息，默认可以不配置，如果有可以配置--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--父项目的pom.xml中定义的元素值被本项目继承下来，也就是说如果本项目pom.xml中某元素没定义，那么默认会自动使用父项目定义的值--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;parent&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--指定父项目的全球唯一标识--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;groupId&amp;gt;com.alibaba.nacos&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--指定父项目的构件标识--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;artifactId&amp;gt;nacos-all&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--指定父项目的版本号--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;version&amp;gt;1.2.1&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--指定父项目pom.xml文件的相对路径。默认值是../pom.xml--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;relativePath&amp;gt;../pom.xml&amp;lt;/relativePath&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/parent&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--指定模型版本号，指定当前pom.xml应遵循哪一个POM模型版本，当前版本4.0.0--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--定义本项目的全球唯一标识--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;groupId&amp;gt;com.wind.cloud&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--定义本项目的构建标识，它和groupId一起唯一标识一个构件--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;artifactId&amp;gt;demo&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--指定本项目的构建版本号--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--目标构建类型，如jar、war、pom等，默认是jar--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--定义key-value形式的属性，这些属性可以在全局使用--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;properties&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;maven.compiler.source&amp;gt;1.8&amp;lt;/maven.compiler.source&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;maven.compiler.target&amp;gt;1.8&amp;lt;/maven.compiler.target&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;alibaba-nacos-config-version&amp;gt;2.2.1.RELEASE&amp;lt;/alibaba-nacos-config-version&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/properties&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--项目需要的依赖列表--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--依赖的具体信息--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--依赖的全球唯一标识--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--依赖的构建标识--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-nacos-config&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--依赖的版本号--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;version&amp;gt;${alibaba-nacos-config-version}&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--指定依赖在什么时候被使用，默认是compile，即编译--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--如果值为test，则用于test任务时使用--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--当有传递依赖时，从依赖列表中排除某些不需要的依赖--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;exclusions&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--排除依赖的信息--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;exclusion&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--排除依赖的构建标识--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;artifactId&amp;gt;org.slf4j&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--排除依赖的全球唯一标识--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;groupId&amp;gt;slf4j-api&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/exclusion&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/exclusions&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--项目构建管理，默认会使用父pom.xml中的配置，没有特殊需求可以不配置--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;build&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--使用的插件列表 --&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--Maven社区提供了很多不同功能的插件可以使用，这里不一一介绍了，有需要的在Maven官网查看(https://maven.apache.org/)--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;plugins&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--plugin元素描述插件所需要的信息--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;plugin&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--插件的artifactId--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;artifactId&amp;gt;maven-compiler-plugin&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--插件的版本--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;version&amp;gt;3.5.1&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--插件工作时需要的参数配置--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;configuration&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;source&amp;gt;${maven.compiler.source}&amp;lt;/source&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;target&amp;gt;${maven.compiler.target}&amp;lt;/target&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;compilerVersion&amp;gt;${maven.compiler.source}&amp;lt;/compilerVersion&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;showDeprecation&amp;gt;true&amp;lt;/showDeprecation&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;showWarnings&amp;gt;true&amp;lt;/showWarnings&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/configuration&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/plugin&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/plugins&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/build&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/project&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;依赖管理&lt;/h3&gt;&lt;p&gt;在pom.xml文件的dependencies标签中通过添加dependency元素添加项目依赖。实际的开发中，通常将项目的公共依赖定义到父项目的pom.xml中，或者定义到公共项目的pom.xml中。&lt;/p&gt;&lt;p&gt;Maven中的项目依赖是可传递的，例如项目A依赖jar包B，项目C依赖项目A构建后的jar包，那么项目C间接依赖jar包B。&lt;/p&gt;&lt;p&gt;有时，这种依赖传递会导致依赖的版本冲突，可以通过配置exclusions排除某些不需要的依赖，当然也可以通过optional标记某传递依赖是可选的。&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--项目需要的依赖列表--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;dependencies&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--依赖的具体信息--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--依赖的全球唯一标识--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;groupId&amp;gt;com.alibaba.cloud&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--依赖的构建标识--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;artifactId&amp;gt;spring-cloud-starter-alibaba-nacos-config&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--依赖的版本号--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;version&amp;gt;${alibaba-nacos-config-version}&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--指定依赖在什么时候被使用，默认是compile，即编译--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--如果值为test，则用于test任务时使用--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--当有传递依赖时，从依赖列表中排除某些不需要的依赖--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;exclusions&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--排除依赖的信息--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;exclusion&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--排除依赖的构建标识--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;artifactId&amp;gt;org.slf4j&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--排除依赖的全球唯一标识--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;groupId&amp;gt;slf4j-api&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/exclusion&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/exclusions&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--依赖的全球唯一标识--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;groupId&amp;gt;com.alibaba&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--依赖的构建标识--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;artifactId&amp;gt;dubbo&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--依赖的版本号--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;version&amp;gt;2.6.8&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--指定依赖在什么时候被使用，默认是compile，即编译--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--如果值为test，则用于test任务时使用--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;scope&amp;gt;compile&amp;lt;/scope&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;!--当有传递依赖时，指定依赖是可选的--&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/dependencies&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;Maven构建生命周期&lt;/h3&gt;&lt;p&gt;Maven构建生命周期（lifecycle）由各个阶段组成，每个阶段由Maven的插件plugin来执行完成。一般情况下，一个项目的Maven构建生命周期由以下几个阶段的序列组成。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.7937219730941705&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKQMYibiaKeHYSvicqcPfHnAwYpNNHwDKHC7TMBKmAibgdq1sPDbIEKVemfSIMrX4vF1Niaq0E9hXAtXJLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;446&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6161616161616161&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKQMYibiaKeHYSvicqcPfHnAwYpyEYlmQiboJF5GHic1PFvP28gfCfBpQagWkaravM2TrWB8oewCZyY8mpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;990&quot;/&gt;&lt;/p&gt;&lt;h3&gt;Maven构建命令&lt;/h3&gt;&lt;p&gt;在pom.xml文件所在的路径使用mvn命令，Maven会自动查找pom.xml，加载解析并执行文件中的构建任务。&lt;/p&gt;&lt;p&gt;一般常用的构建命令有mvn clean package、mvn clean install和mvn clean deploy。&lt;/p&gt;&lt;p&gt;mvn clean package：依次执行移除所有上一次构建生成的文件、代码编译、单元测试、打包。&lt;/p&gt;&lt;p&gt;mvn clean install：依次执行移除所有上一次构建生成的文件、代码编译、单元测试、打包、将打好的包安装到本地仓库。&lt;/p&gt;&lt;p&gt;mvn clean deploy：依次执行移除所有上一次构建生成的文件、代码编译、单元测试、打包、将打好的包安装到本地仓库、将打好的包发布到远程仓库。&lt;/p&gt;&lt;h3&gt;IntelliJ IDEA中使用Maven&lt;/h3&gt;&lt;p&gt;最新版本的IntelliJ IDEA会自带Maven插件，但还是建议通过配置更改成本机安装的Maven，这样方便更改Maven相关配置。&lt;/p&gt;&lt;p&gt;新建Maven项目或打开已有的Maven项目后，IDEA会自动识别项目中的pom.xml，在IDEA右侧的窗口中会展示pom.xml中使用到的插件和构建声明周期，例如下图所示。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8385772913816689&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKQMYibiaKeHYSvicqcPfHnAwYp00Jq0zibD83wxnoaviaDwsIaoyjua58T3IrG1RG9DkHuHeaiaqSsIas0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1462&quot;/&gt;&lt;/p&gt;&lt;p&gt;双击Lifecycle中的某阶段，会自动执行相应的构建任务。当然，也可以通过IDEA中的Terminal直接执行mvn命令。&lt;/p&gt;&lt;h3&gt;Eclipse中使用Maven&lt;/h3&gt;&lt;p&gt;最新版本的Eclipse会自带Maven插件，但还是建议通过配置更改成本机安装的Maven，这样方便更改Maven相关配置。&lt;/p&gt;&lt;p&gt;新建Maven项目或打开已有的Maven项目后，Eclipse会自动识别项目中的pom.xml。项目代码在Eclipse中打开后，右键选中项目，然后选择Run As，会列出可执行的Maven构建任务。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;往期推荐&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484878&amp;amp;idx=1&amp;amp;sn=daee4e4702b0d3a44daf8599501d72e8&amp;amp;chksm=e9bf5750dec8de4656a9aaf85ada2ca8042921c8e52b57c494cc9af52e615e19fb101a485103&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Java开发人员必知的常用类库，这些你都知道吗？&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484871&amp;amp;idx=1&amp;amp;sn=74ede98f0281459c8ded84bd5178caa0&amp;amp;chksm=e9bf5759dec8de4fa24d29ada560d50e73dd35264a02fdd85aab44c4a931af8f1f6e47d1b683&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;聊一聊Redis官方置顶推荐的Java客户端Redisson&lt;/a&gt;&lt;strong&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484871&amp;amp;idx=1&amp;amp;sn=74ede98f0281459c8ded84bd5178caa0&amp;amp;chksm=e9bf5759dec8de4fa24d29ada560d50e73dd35264a02fdd85aab44c4a931af8f1f6e47d1b683&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;/&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484828&amp;amp;idx=1&amp;amp;sn=bbdfbbed2c5e97dd58386df08fc011db&amp;amp;chksm=e9bf5702dec8de14016f5468ee387d8b326cdec0eca0013e8b5b95d945897f64a6cb817793d3&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;我画了25张图展示线程池工作原理和实现原理，原创干货，建议先收藏再阅读&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484763&amp;amp;idx=1&amp;amp;sn=a67f151b04967d149c2b60ed648e5dbf&amp;amp;chksm=e9bf57c5dec8ded33ccfc6cd269c4736eec528b8e6ab4cc6c2beb11deb744e7f78d7b61ec72b&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Spring框架你敢写精通，面试官就敢问@Autowired注解的实现原理&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484742&amp;amp;idx=1&amp;amp;sn=54e9e3e9de14d3681a8d426d90f5d687&amp;amp;chksm=e9bf57d8dec8decec68531bd74f92a6dba3fb4e74564c27fa9933ece75290d27ffa317a4a8ae&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;面试被问为什么使用Spring Boot？答案好像没那么简单&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484730&amp;amp;idx=1&amp;amp;sn=dd043e8eb2fbf4ca7df266aabed45443&amp;amp;chksm=e9bf57a4dec8deb2e7162250c559dd4d2189681f6e08b37da371d04867698a26b9be062fc24b&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Spring声明式事务处理的实现原理，来自面试官的穷追拷问&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484712&amp;amp;idx=1&amp;amp;sn=982a0801e878700b42b48f7fae3e5f30&amp;amp;chksm=e9bf57b6dec8dea04544c551c8206897f66efb81f49532b65df4ff878ad284c261b48ad9e3dd&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;没使用加号拼接字符串，面试官竟然问我为什么&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484707&amp;amp;idx=1&amp;amp;sn=3eea7537f43fcf0cd646d9bc64fd657f&amp;amp;chksm=e9bf57bddec8deab4ffea25c68197d82c1b46ba58ad0963c9fc0ee6d79f9c47c29660875187f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;面试官一步一步的套路你，为什么SimpleDateFormat不是线程安全的&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484701&amp;amp;idx=1&amp;amp;sn=67ba3d2cedbd7a475371acfc474210e1&amp;amp;chksm=e9bf5783dec8de95e76115bc1fbd14401f8b41030d7aa5ebd42894eba56f138fd03f153718a4&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;都说ThreadLocal被面试官问烂了，可为什么面试官还是喜欢继续问&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI0NjUxNTY5Nw==&amp;amp;mid=2247484696&amp;amp;idx=1&amp;amp;sn=54c8b5ad9373d88564032c8bc4bc0926&amp;amp;chksm=e9bf5786dec8de90506632f193789cc088165985e35320a5e2a64f6a1230f5d74c9118a811af&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Java注解是如何玩转的，面试官和我聊了半个小时&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;学之多，而后知之少&lt;/strong&gt;&lt;span&gt;！以上是本次分享的内容，朋友们点【在看】是我持续更新的最大动力，我们下期见！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKSxTAD3licFmGltOsliao1ZVHCicnRtbiarMjXCkm2y0FjRlsJ596O4ibOAoOib1XWGhXlYX8x0wYXIPfxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5555555555555556&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>