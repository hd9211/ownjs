<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b93b512443ed8f91b10007c6fa41f47e</guid>
<title>秋天的第一份 IT 技术周刊 | 码农周刊第 320 期</title>
<link>https://toutiao.io/k/9ew44gv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;秋天的第一份 IT 技术周刊 | 码农周刊第 320 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第320期（2020-09-29）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3200&quot; target=&quot;_blank&quot;&gt;秋天的第一份 IT 技术周刊，请查收！&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3200&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_320.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=320&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;思考和实践&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;由 JavaScript 之父 Brendan Eich 与 ES6 规范首席作者 Allen Wirfs-Brock 联合编写，详细记载和解读了自 1995 年语言诞生到 2015 年 ES6 规范制定为止，共计 20 年的 JavaScript 语言演化经历。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;支持 mp4, flv, m3u8 及 rtmp 协议的直播，支持移动端，PC 端。&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;利器&lt;/p&gt;
        
        &lt;p&gt;实打实的干货&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;容易踩的坑&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;细致分析&lt;/p&gt;
        
        &lt;p&gt;方案和思路&lt;/p&gt;
        
        &lt;p&gt;一些实践和工具&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;报告详情&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;深入探讨&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;java相关技术分享&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 444692 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 444414 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 435415 即可&lt;/p&gt;
        
        &lt;p&gt;不定期更新一些机器学习算法，方便大家浏览，然后一起学习，一起进步&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 104739 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 99181 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;本书深入地讲解了 Go 语言常见特性的内部机制和实现方式，大部分内容源自对 Go 语言源码的分析，并从中提炼出实现原理。欢迎到&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;兑换阅读。&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;值得推荐&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;无代码开发平台&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3be627fb58945f3f4e5b2dc36291db87</guid>
<title>缓存击穿导致 golang 组件死锁的问题分享</title>
<link>https://toutiao.io/k/f2baq90</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;  &lt;span mpa-is-content=&quot;t&quot;&gt;大纲&lt;/span&gt;  &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;思路排查&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Dump 堆栈很重要&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;关键思路&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;终于找到你&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;思路整理&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;发现蛛丝马迹&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;完整的推理流程&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;思考总结&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分享一个线上遇到的死锁问题，什么， golang 也会有死锁？&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;  &lt;span mpa-is-content=&quot;t&quot;&gt;思路排查&lt;/span&gt;  &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;Dump 堆栈很重要&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;线上某个环境发现 S3 上传请求卡住，请求不返回，卡了30分钟，长时间没有发现有效日志。一般来讲，死锁问题还是好排查的，因为现场一般都在。类似于 c 程序，遇到死锁问题都会用 pstack 看一把。golang 死锁排查思路也类似（golang 不适合使用 pstack，因为 golang 调度的是协程，pstack 只能看到线程栈），我们其实是需要知道 S3 程序里 goroutine 的栈状态。golang 遇到这个问题我们有两个办法：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;方法一：条件允许的话，gcore 出一个堆栈，这个是最有效的方法，因为是把整个 golang 程序的内存镜像 dump 出来，然后用 dlv 分析；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;方法二：如果你提前开启 net/pprof 库的引用，开启了 debug 接口，那么就可以调用 curl 接口，通过 http 接口获取进程的状态信息；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;需要注意到，golang 程序和 c 程序还是有点区别，goroutine 非常多，成百上千个 goroutine 是常态，甚至上万个也不稀奇。所以我们一般无法在终端上直接看完所有的栈，一般都是把所有的 goroutine 栈 dump 到文件，然用 vi 打开慢慢分析。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;调试这个 core 文件，意图从堆栈里找到些东西，由于堆栈太多了，所以就使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;gorouties -t -u&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  这个命令，并且把输出 dump 到文件；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;curl xxx/debug/pprof/goroutine&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;关键思路&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;成千上万个 goroutine ，直接显示到终端是不合适的，我们 dump 到文件 test.txt，然后分析 test.txt 这个文件。&lt;strong&gt;去查找发现了一些可疑堆栈，那么什么是可疑堆栈？重点关注加锁等待的堆栈，关键字是 &lt;/strong&gt;&lt;strong&gt;&lt;code&gt;runtime_notifyListWait&lt;/code&gt; 、&lt;code&gt;semaphore&lt;/code&gt; 、&lt;code&gt;sync.(*Cond).Wait&lt;/code&gt; 、&lt;code&gt;Acquire&lt;/code&gt;  这些阻塞场景才会用到的，如果业务堆栈上出现这个加锁调用，就非常可疑。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;划重点&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;留意阻塞关键字 &lt;/span&gt;&lt;code&gt;&lt;span&gt;runtime_notifyListWait&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 、&lt;/span&gt;&lt;code&gt;&lt;span&gt;semaphore&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 、&lt;/span&gt;&lt;code&gt;&lt;span&gt;sync.(*Cond).Wait&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 、&lt;/span&gt;&lt;code&gt;&lt;span&gt;Acquire&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;业务堆栈（非 runtime 的一些内部堆栈）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2344944774851317&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChPvYG5CqzKLibTDPC61D7Z7mRMAJiaxsZkialT2VhJyvKeuQSyz8QCxC9jt9Lrw4Zc5L7ibFYXJXklr0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1177&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;统计分析发现，有 11 个这个堆栈都在这同一个地方，都是在等同一把锁 &lt;/span&gt;&lt;code&gt;&lt;span&gt;blockingKeyCountLimit.lock&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，所以基本确认了阻塞的位置，就是这个地方阻塞到了所有的请求，但是这把锁我们使用 defer 释放的，使用姿势如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;lock.Acquire(key)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;defer&lt;/span&gt; lock.Release(key)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;blockingKeyCountLimit 是我们封装针对 key 操作流控的组件。举个例子，如果 limit == 1，key为 &quot;test&quot; 在 g1 上 Acquire 成功，g2 acquire(&quot;test&quot;) 就会等待，这个可以算是我们优化的一个逻辑。如果 limit == 2，那么就允许两个人加锁到，后面的人都等待。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从代码来看，函数退出一定会释放的，但是偏偏现在锁就卡在这个地方，所以就非常奇怪。我们先找哪个 goroutine 占着这把锁不释放，看看能不能搞清楚怎样导致这里抢不到锁的原因。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过审查业务代码分析，发现可能的源头函数（这个函数是向后端请求的函数）：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sh&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;api.(*Client).getBytesNolc&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;确认是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;getBytesNolc&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  这个函数执行的操作，那么大概率就是卡在这个地方了。用这个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;getBytesNolc&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 字符串搜索堆栈，找下是哪个堆栈 ？搜索到这个堆栈 &lt;/span&gt;&lt;code&gt;&lt;span&gt;goroutine 19458&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.28203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChPvYG5CqzKLibTDPC61D7Z7mGuDUCia2SWjhfXJznNKLy4oAx3txjUhibUyjOiczU8fVMHbDsa9TRvamA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大概率就是第 1 个堆栈了，也就是其他的 11 个 goroutine 都在等这 &lt;/span&gt;&lt;code&gt;&lt;span&gt;goroutine 19458&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  来放锁，仔细看这个堆栈。那么为啥这个堆栈不放锁呢？这里有个细节要注意下，这里是卡到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;gihub.com/golang/groupcache/singleflight/singleflight.go:48&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 这一行：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5752508361204013&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChPvYG5CqzKLibTDPC61D7Z7mLtg6p9VePicLmbNNbjgJTKHibQkAvweT9afp9DcWUkWfxcBJX4ntK4Xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;897&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;终于找到你&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这是一个开源库，singleflight 实现了缓存防击穿的功能。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;简单减少下 singleflight 的功能，这是一个非常有效的工具。在缓存大量失效的场景，如果针对同一个 key ，其实只需要有一个人穿透到后端请求数据，其他人等待他完成，然后取缓存结果即可。这个就是 singleflight 实现的功能。具体实现就是：来了请求之后，把 key 插入到 map 里，后面的请求如果发现同名 key 在 map 里面，那么就等待它完成就好；&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;截屏显示卡到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;c.wg.Wait()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  这一行，那么说明 map 里面肯定有已经存在的 key，说明 &lt;/span&gt;&lt;code&gt;&lt;span&gt;goroutine 19458&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  不是第一个人？但是外面还有一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;blockingKeyCountLimit&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的互斥呢，按道理其他的人也进不来（因为 limit == 1），这里这么讲来肯定要是源头才对？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;思路整理&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;伪代码显示如下&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;xxx&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    limitLocker.Acquire( key )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;defer&lt;/span&gt; limitLocker.Release( key )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    getBytesNolc( key , ...)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;getBytesNolc&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ret, err = x.Group.Do(id, &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    })&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;图示显示当前的现状&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.65234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VICDXkv9ChPvYG5CqzKLibTDPC61D7Z7mQrribV3oQPtonTYjfpIcIJSLwrMgEIf1SWMcZgviaFAh4TsiaU7Te8AQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;&lt;span/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现状小结：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;大量的协程都在等 &lt;/span&gt;&lt;code&gt;&lt;span&gt;blockingKeyCountLimit&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 这把锁释放；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;协程 &lt;/span&gt;&lt;code&gt;&lt;span&gt;goroutine 19458&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 持有 &lt;/span&gt;&lt;code&gt;&lt;span&gt;blockingKeyCountLimit&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 这把锁；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;协程 &lt;/span&gt;&lt;code&gt;&lt;span&gt;goroutine 19458&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  却在等一个相同 key 名字的任务的完成（ singleflight 一个防击穿的库，同一时间相同 key 只允许放到一个后端去执行），却永远没等到，协程因此呈现死锁；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当前的疑问就是第一个 key 的任务为啥永远完不成，堆栈也找不到了，去哪里了？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;发现蛛丝马迹&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们再仔细审一下 singleflight 的代码：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(g *Group)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Do&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(key &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;, fn &lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;()&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;) &lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}, error)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    g.mu.Lock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; g.m == &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        g.m = &lt;span class=&quot;code-snippet__built_in&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;]*call)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; c, ok := g.m[key]; ok {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        g.mu.Unlock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        c.wg.Wait()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; c.val, c.err&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    c := &lt;span class=&quot;code-snippet__built_in&quot;&gt;new&lt;/span&gt;(call)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    c.wg.Add(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    g.m[key] = c&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    g.mu.Unlock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    c.val, c.err = fn()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    c.wg.Done()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    g.mu.Lock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;delete&lt;/span&gt;(g.m, key)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    g.mu.Unlock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; c.val, c.err&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;发现有个线索，我们的 S3 服务程序一个 http 请求对应一个协程处理，为了提高服务端进程的可用性，在框架里会捕捉 panic，这样确保单个协程处理不会影响到其他的请求。基于这个前提，我们假设：如果 &lt;/span&gt;&lt;code&gt;&lt;span&gt;fn()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 执行异常，panic 掉了，那么就不会走 &lt;/span&gt;&lt;code&gt;&lt;span&gt;delete(g.m, key)&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的代码，那么 key 就永远都残留在 map 里面，而进程却又还活着。恍然大悟。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2/&gt;&lt;p mpa-is-content=&quot;t&quot;&gt;完整的推理流程&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一个协程 g1 来了，加了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;blockingKeyCountLimit&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  锁，然后准备穿透到后端，调用函数 &lt;/span&gt;&lt;code&gt;&lt;span&gt;getBytesNolc&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  获取数据，并走进了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;singlelight&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ，添加了一个 key：x， 准备干活；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;干活发生了一些不可预期的异常（后面发现是配置的异常），nil 指针引用之类的， panic 堆栈了，panic 导致后面 delete key 操作没有执行；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;虽然 g1 现在 panic 了，但是由于在函数 func xxx 里面 &lt;/span&gt;&lt;code&gt;&lt;span&gt;blockingKeyCountLimit&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 是 defer 执行的，所以这把锁还是，但是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;singlelight&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的 key 还存在，于是残留在 map 里面；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;但是由于我们服务程序为了高可用是 recover 了 panic 的，单个请求的失败不会导致整个进程挂掉，所以进程还是好好的；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;goroutine 19458&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  协程来了，&lt;/span&gt;&lt;code&gt;&lt;span&gt;blockingKeyCountLimit&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  加锁，然后走到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;singlelight&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  的时候，发现有 key: x 了，于是就等待；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;并且等待的是一个永远得不到的锁，因为 g1 早就没了；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;后续的 11 个 协程来了，于是被 &lt;/span&gt;&lt;code&gt;&lt;span&gt;blockingKeyCountLimit&lt;/span&gt;&lt;/code&gt;&lt;span&gt;  阻塞住，并且永远不能释放；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实锤：后续基于这个猜想，再去搜索一遍日志，发现确实是有一条 panic 相关的日志。这个时间点后面的请求全部被卡住。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;  &lt;span mpa-is-content=&quot;t&quot;&gt;思考总结&lt;/span&gt;  &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一般来讲 c 语言写程序容易出现死锁问题，因为各种异常逻辑可能会导致忘记放锁，从而导致抢一个永远都不可能得到的锁。&lt;strong&gt;golang 为了解决这个问题，一般是用 defer 机制来实现&lt;/strong&gt;，使用姿势如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    mtx.Lock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;defer&lt;/span&gt; mtx.Unlock()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;golang 的 defer 机制是一个经过经验沉淀下来的有效功能。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;我们必须要合理使用。defer 实现原理是和所在函数绑定，保证函数 return 的时候一定能调用到（ panic 退出也能），所以 golang 加锁放锁的有效实践是写在相邻的两行。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实思考下，&lt;strong&gt;singleflight 作为一个通用开源库，其实可以把 delete map key 放到 defer 里，这样就能保证 map 里面的 key 一定是可以被清理的&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;还有一点，&lt;strong&gt;其实 golang 是不提倡异常-捕捉这样的方式编程&lt;/strong&gt;，panic 一般不让随便用，如果真是严重的问题，挂掉就挂掉，这个估计还好一些。当然这是要看场景的，还是有一些特殊场景的，毕竟 golang 都已经提供了 panic-recover 这样的一个手段，就说明还是有需求。这个就跟 unsafe 库一样，你只有明确知道自己的行为影响，才去使用这个工具，否则别用。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;精彩推荐&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;amp;mid=2247484698&amp;amp;idx=1&amp;amp;sn=22c169cb21335cdf783ba257da31aec8&amp;amp;chksm=eb310495dc468d83a3791ddca2ae98112af324e4d4f3a29d39f083ff784216b530b780638c40&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Docker 镜像分析利器 dive&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;amp;mid=2247484598&amp;amp;idx=1&amp;amp;sn=ea91646ad078518e9ffbc39994abe424&amp;amp;chksm=eb310539dc468c2f81bc79f2ff55e3e8e314506137746ed6bb785420d9ee49f1a289a67897d6&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Go语言 | 基于channel实现的并发安全的字节池&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;amp;mid=2247484563&amp;amp;idx=1&amp;amp;sn=eb82f5596c2938fd9e94b030e3a9e436&amp;amp;chksm=eb31051cdc468c0a88ed0066eef48d77fe40b89b94651a29ae2071af02e261f0bb1d0f4bfc8d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Go语言 | 从并发模式看channel使用技巧&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;amp;mid=2247483773&amp;amp;idx=1&amp;amp;sn=e893cfca13b7edc0b1eeda0e343a82b5&amp;amp;chksm=eb3100f2dc4689e4dea21d7e3143acc52f775e2603efe2eb2f45371d6104242c4912b24dcbe0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《Go语言实战》笔记(十六) | Go并发示例-Pool&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;amp;mid=2247483771&amp;amp;idx=1&amp;amp;sn=52d0d44ecad893f0c3d7f59b15d62a62&amp;amp;chksm=eb3100f4dc4689e2681300b0830977193f3a35ca20e6c9ab758085c7e7679e764a367f3b2c22&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《Go语言实战》笔记(十五) | Go并发示例-Runner&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3MjU4Njk3Ng==&amp;amp;mid=2247483767&amp;amp;idx=1&amp;amp;sn=abb360ced1c969aed2aaa7fcc31ce275&amp;amp;chksm=eb3100f8dc4689eeccb7cf9b3cd2274be938fc3f65a40c9b445eb51e646a8da553f8cee2b371&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《Go语言实战》笔记(十三) | Go 并发资源竞争&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3649122807017544&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yGKTjJdYkkvuj8z0lDLzibibzK119ljw0Aq61ZDMUp0U6LG9Fhqo9c3rlrGUDGqfosib1ptkqYBDV4uYlOUEktQAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1710&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>db296051e3d4bd75fb9ce3089fce4847</guid>
<title>[译] 使用 Paging 3 实现分页加载</title>
<link>https://toutiao.io/k/xbgx43m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;&lt;i&gt;作者 / Florina Muntenescu&lt;/i&gt;&lt;/p&gt;&lt;p&gt;Paging 库可以帮助您优雅地渐进加载大型数据集合，同时也可以减少网络的使用和系统资源的消耗。基于您的反馈我们得知，Paging 2.0 API 还不能满足开发者们的需求——开发者们希望以更简便的方式处理错误；以更灵活的方式实现列表数据的转换操作，例如 map 和 filter；以及支持分割符、页眉和页脚。基于以上反馈，我们推出了 Paging 3.0。这是一个完全使用 Kotlin 协程重写的库 (依然支持 Java 用户)，它将为您提供您所要求的功能。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Paging 3 亮点&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Paging 3 的 API 对分页加载时可能需要实现的常见功能提供了支持:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;跟踪获取前一页或后一页所需要的参数；&lt;/li&gt;&lt;li&gt;当用户滚动到现有数据的末尾时，自动请求正确的下一页；&lt;/li&gt;&lt;li&gt;确保不会同时触发多个请求；&lt;/li&gt;&lt;li&gt;跟踪加载状态，并支持您在 RecyclerView 的列表项或者界面中的其他地方展示它。为失败的加载提供简便的重试功能；&lt;/li&gt;&lt;li&gt;无论您是否使用 Flow、LiveData、RxJava Flowable 或 Observable，都可以对需要展示的列表使用 map 或 filter 这类常见的操作；&lt;/li&gt;&lt;li&gt;提供实现列表分隔符的简便方法；&lt;/li&gt;&lt;li&gt;简化了数据缓存，确保不会让您在每次配置更改时都执行数据转换。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们还让 Paging 3 的一些组件向后兼容 Paging 2.0。因此，如果您已经在应用中使用了 Paging，则可以逐步 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/topic/libraries/architecture/paging/v3-migration&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;迁移至 Paging 3&lt;/a&gt;&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;在您的应用中使用 Paging 3&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;假设我们正在实现一个展示所有狗狗的应用。狗狗的数据从 GoodDoggos API 获得，该 API 支持基于索引的分页。让我们研究下需要实现的 Paging 组件，以及如何将 Paging 集成到现有的应用架构。接下来的例子将使用 Kotlin 及其协程功能编写，如果您需要使用 LiveData/RxJava 实现的 Java 编程语言示例，请参阅 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/topic/libraries/architecture/paging/v3-overview&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Android 开发者文档 | Paging 3 库概述&lt;/a&gt;&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;下图为您应用的各个层级中推荐直接接入 Paging 的 Android 应用架构:&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-9bd724bce134d49281f92753e59f0804_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1600&quot; data-rawheight=&quot;445&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-9bd724bce134d49281f92753e59f0804_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1600&quot; data-rawheight=&quot;445&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-9bd724bce134d49281f92753e59f0804_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-9bd724bce134d49281f92753e59f0804_b.jpg&quot;/&gt;&lt;figcaption&gt;Paging 组件及其在应用架构的集成&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;&lt;b&gt;定义数据源&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;数据源的定义取决于您从哪里加载数据。您仅需实现 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/paging/PagingSource&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PagingSource&lt;/a&gt;&lt;/b&gt; 或者 PagingSource 与 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/paging/RemoteMediator&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;RemoteMediator&lt;/a&gt;&lt;/b&gt; 的组合:&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如果您从 &lt;b&gt;单个源&lt;/b&gt; 加载数据，例如网络、本地数据、文件等，实现 PagingSource 即可，如果您使用了 &lt;b&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/111267510&quot; class=&quot;internal&quot;&gt;Room&lt;/a&gt;&lt;/b&gt;，从 2.3.0-alpha 开始，它将默认为您实现 Paging Source，请参见:&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/training/data-storage/room/accessing-data%23paging-integration&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt; Android 开发文档｜使用 Room DAO 访问数据&lt;/a&gt;&lt;/b&gt;；&lt;/li&gt;&lt;li&gt;如果您从一个 &lt;b&gt;多层级数据源&lt;/b&gt; 加载数据，就像带有本地数据库缓存的网络数据源那样。那么您需要实现 RemoteMediator 来合并两个数据源到一个本地数据库缓存的 PagingSource 中。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;PagingSource&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/paging/PagingSource&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PagingSource&lt;/a&gt;&lt;/b&gt; 可以定义一个分页数据的数据源，以及从该数据源获取数据的方式。PagingSource 应当为资源库层的一部分。您可以实现 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/paging/PagingSource%23load&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;load()&lt;/a&gt;&lt;/b&gt; 函数来从数据源获取分页数据，并返回加载好的数据和加载前后页的参数信息。load() 是一个挂起函数，您可以在这里调用其他的 &lt;b&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/145001592&quot; class=&quot;internal&quot;&gt;挂起函数&lt;/a&gt;&lt;/b&gt;，例如网络请求:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;class DoggosRemotePagingSource(
    val backend: GoodDoggosService
) : PagingSource&amp;lt;Int, Dog&amp;gt;() {
  override suspend fun load(
    params: LoadParams&amp;lt;Int&amp;gt;
  ): LoadResult&amp;lt;Int, Dog&amp;gt; {
    try {
      // 未定义时加载第 1 页
      val nextPageNumber = params.key ?: 1
      val response = backend.getDoggos(nextPageNumber)
      return LoadResult.Page(
        data = response.doggos,
        prevKey = null, // 仅向后翻页
        nextKey = response.nextPageNumber + 1
      )
    } catch (e: Exception) {
        // 在此块中处理错误
        return LoadResult.Error(exception)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;PagingData 与 Pager&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;分页数据的容器被称为 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/paging/PagingData&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PagingData&lt;/a&gt;&lt;/b&gt;，每次刷新数据时，都会创建一个 PagingData 的实例。如果要创建 PagingData 数据流，您需要创建一个 Pager 实例，并提供一个 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/paging/PagingConfig&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PagingConfig&lt;/a&gt;&lt;/b&gt; 配置对象和一个可以告诉 Pager 如何获取您实现的 PagerSource 的实例的函数，以供 Pager 使用。&lt;/p&gt;&lt;p&gt;您要在 ViewModel 中构造 Pager 对象并向 UI 暴露一个 Flow。Flow 有一个方便的 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/paging/package-summary%23cachedin&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;cachedIn()&lt;/a&gt;&lt;/b&gt; 方法，该方法使得数据流可以被共享，也让您可以在 CoroutineScope 中缓存 Flow 的内容。这样一来，如果您在数据流中实现了任何转换操作，当 Activity 被重建并使得您从 flow 中获取数据时，不会再次触发这些操作。由于我们希望数据在配置产生变化后仍然存在，缓存应当尽可能靠近 UI 层，但又不能在 UI 层中，那么最好的位置便是在 &lt;b&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/143346337&quot; class=&quot;internal&quot;&gt;ViewModel&lt;/a&gt;&lt;/b&gt; 中，并使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/lifecycle/package-summary%23viewmodelscope&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;viewModelScope&lt;/a&gt;&lt;/b&gt;:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;val doggosPagingFlow = Pager(PagingConfig(pageSize = 10)) {
  DogRemotePagingSource(goodDoggosService)
}.flow.cachedIn(viewModelScope)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;PagingDataAdapter&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;为了将 RecyclerView 与 PagingData 联系起来，您需要实现一个 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/paging/PagingDataAdapter&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PagingDataAdapter&lt;/a&gt;&lt;/b&gt;:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;class DogAdapter(diffCallback: DiffUtil.ItemCallback&amp;lt;Dog&amp;gt;) :
  PagingDataAdapter&amp;lt;Dog, DogViewHolder&amp;gt;(diffCallback) {
  override fun onCreateViewHolder(
    parent: ViewGroup,
    viewType: Int
  ): DogViewHolder {
    return DogViewHolder(parent)
  }

  override fun onBindViewHolder(holder: DogViewHolder, position: Int) {
    val item = getItem(position)
    if(item == null) {
      holder.bindPlaceholder()
    } else {
      holder.bind(item)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来，在您的 &lt;code&gt;Activity/Fragment&lt;/code&gt; 中，您需要收集 &lt;code&gt;Flow&amp;lt;PagingData&amp;gt;&lt;/code&gt; 并将其提交给 &lt;code&gt;PagingDataAdapter&lt;/code&gt;。下面是一个在 &lt;code&gt;Activity&lt;/code&gt; 的 &lt;code&gt;onCreate()&lt;/code&gt; 函数中实现该操作的示例:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;val viewModel by viewModels&amp;lt;DoggosViewModel&amp;gt;()

val pagingAdapter = DogAdapter(DogComparator)
val recyclerView = findViewById&amp;lt;RecyclerView&amp;gt;(R.id.recycler_view)
recyclerView.adapter = pagingAdapter

lifecycleScope.launch {
  viewModel.doggosPagingFlow.collectLatest { pagingData -&amp;gt;
    pagingAdapter.submitData(pagingData)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;&lt;b&gt;分页数据转换&lt;/b&gt;&lt;/h3&gt;&lt;figure data-size=&quot;small&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-94292e2cec2fc62945baabca0f8019e6_b.jpg&quot; data-size=&quot;small&quot; data-rawwidth=&quot;668&quot; data-rawheight=&quot;1314&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-94292e2cec2fc62945baabca0f8019e6_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;668&quot; data-rawheight=&quot;1314&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-94292e2cec2fc62945baabca0f8019e6_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-94292e2cec2fc62945baabca0f8019e6_b.jpg&quot;/&gt;&lt;figcaption&gt;展示一个过滤后的列表&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;转换 PagingData 流与您在其他数据流中所做的同类操作相似。举例来说，如果我们只想要展示 Flow&amp;lt;PagingData&amp;gt; 中那些调皮的狗狗，我们可能需要映射 Flow 对象并过滤 PagingData:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;doggosPagingFlow.map { pagingData -&amp;gt;
        pagingData.filter { dog -&amp;gt; dog.isPlayful }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;figure data-size=&quot;small&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ee9eac1129aed9f3955ddae7004ce397_b.jpg&quot; data-size=&quot;small&quot; data-rawwidth=&quot;668&quot; data-rawheight=&quot;1318&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-ee9eac1129aed9f3955ddae7004ce397_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;668&quot; data-rawheight=&quot;1318&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-ee9eac1129aed9f3955ddae7004ce397_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-ee9eac1129aed9f3955ddae7004ce397_b.jpg&quot;/&gt;&lt;figcaption&gt;有分隔符的列表&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;向列表中添加 &lt;b&gt;分隔符&lt;/b&gt; 同样是分页数据转换，这里我们通过转换 PagingData 向列表中插入分隔对象。举例来说，我们可以为狗狗的名字插入字母分隔符。当使用分隔符时，您需要自己实现 UI 模型类以支持新的分隔项。当您修改 PagingData 并插入分隔符时，您会用到 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/paging/PagingData%23insertseparators&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;insertSeparators&lt;/a&gt;&lt;/b&gt; 转换:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;pager.flow.map { pagingData: PagingData&amp;lt;Dog&amp;gt; -&amp;gt;
  pagingData.map { doggo -&amp;gt;
    // 将数据流中的项目转换为 UiModel.DogModel。
    UiModel.DogModel(doggo)
  }
  .insertSeparators&amp;lt;UiModel.DogModel, UiModel&amp;gt; { before: Dog, after: Dog -&amp;gt;
      return if(after == null) {
       // 我们到了列表的末尾
          null
      } else if (before == null || before.breed != after.breed) {
          // 上下品种不同，显示分隔符
          UiModel.SeparatorItem(after.breed)
      } else {
          // 无分隔符
          null
      }
    }
  }
}.cachedIn(viewModelScope)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;就像前面一样，我们会在数据到达 UI 层之前使用 cachedIn，这样便可以缓存所有已经加载的数据以及数据转换的结果。当配置发生改变时，这些缓存就会被复用。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;使用 RemoteMediator 进行高级分页操作&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;当您从一个 &lt;b&gt;多层级数据源&lt;/b&gt; 加载数据时，应当实现一个 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/paging/RemoteMediator&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;RemoteMediator&lt;/a&gt;&lt;/b&gt;。举例来说，在此类的实现中，您应当从网络请求数据并存入数据库。每当数据库中没有数据可以被展示时，就会触发 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/paging/RemoteMediator%23load&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;load()&lt;/a&gt;&lt;/b&gt; 方法。基于 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/paging/PagingState&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;PagingState&lt;/a&gt;&lt;/b&gt; 和 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/reference/kotlin/androidx/paging/LoadType&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;LoadType&lt;/a&gt;&lt;/b&gt;，我们可以构造下一页的数据请求。&lt;/p&gt;&lt;p&gt;由于 Paging 库并不知道您的 API 是怎样的，所以定义如何构造和获取前一页和下一页的远程数据的工作便需要由您自己来完成。举例来说，您可以将您从网络接收到的每个项目与远程关键字关联起来并存入数据库。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;override suspend fun load(loadType: LoadType, state: PagingState&amp;lt;Int, Dog&amp;gt;): MediatorResult {

   val page = ...  // 基于 loadType 和 state 进行计算

   try {
       val doggos = backend.getDoggos(page)
       doggosDatabase.doggosDao().insertAll(doggos)

       val endOfPaginationReached = emails.isEmpty()
       return MediatorResult.Success(endOfPaginationReached = endOfPaginationReached)
   } catch (exception: Exception) {
       return MediatorResult.Error(exception)
   } 
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果您从网络请求数据并存入数据库，那么数据库才是屏幕上所展示数据的真正数据源——这意味着 UI 会展示从数据库获取的数据，所以您需要为您的数据库实现 PagingSource。如果您正在使用 Room，那么您只需要向您的 DAO 添加一个返回 PagingSource 的查询:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;@Query(&quot;SELECT * FROM doggos&quot;)
fun getDoggos(): PagingSource&amp;lt;Int, Dog&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这种情况下 Pager 的实现略有不同，您还需要传入 RemoteMediator 实例:&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;val pagingSourceFactory = { database.doggosDao().getDoggos() }

return Pager(
     config = PagingConfig(pageSize = NETWORK_PAGE_SIZE),
     remoteMediator = DoggosRemoteMediator(service, database),
     pagingSourceFactory = pagingSourceFactory
).flow
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;您可以参阅文档了解 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/topic/libraries/architecture/paging/v3-network-db&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;使用 RemoteMediator&lt;/a&gt;&lt;/b&gt; 的详细信息。如果您需要 RemoteMediator 在应用中的完整实现，可以参阅 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//codelabs.developers.google.com/codelabs/android-paging/%2314&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Paging codelab&lt;/a&gt;&lt;/b&gt; 和 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/googlecodelabs/android-paging/blob/step13-19_network_and_database/app/src/main/java/com/example/android/codelabs/paging/data/GithubRemoteMediator.kt&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Paging 相关代码&lt;/a&gt;&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;我们将 Paging 3 设计为一个帮您涵盖简单和复杂情形下的分页加载的库。它可以让您更方便地使用大规模数据集合，无论数据来自网络、数据库、内存缓存还是上述几种情况的组合。Paging 库基于 &lt;b&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/140314207&quot; class=&quot;internal&quot;&gt;协程和 Flow&lt;/a&gt;&lt;/b&gt; 实现，使得它可以很简单地调用挂起函数并且处理数据流。&lt;/p&gt;&lt;p&gt;Paging 3 仍然处于 alpha 版本，我们需要您帮助我们进一步优化！请参阅以下资源开始使用 Paging:&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0153a26151e991a68e1eacb277ed22bf</guid>
<title>如何从 0 到 1 搭建用户标签体系</title>
<link>https://toutiao.io/k/78gg94x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;|0x00 前言&lt;/span&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;用户标签，其实发展到现在已经不是新鲜概念了。&lt;/p&gt;&lt;p&gt;各大公司在推进精细化的过程中，无论是技术方还是业务方，都已经从过去粗放的“流量运营”思维，转变为如今人人都在谈论的“用户运营”思维。这时，用户不再是一个个整齐划一的流量，而是有血有肉的个体。&lt;/p&gt;&lt;p&gt;但受限了于客观条件，我们无法一一去接触我们用户，了解他们的习惯喜欢，只能从他们产生的行为和数据，去抽象、总结出特征规律，这就引入了“用户标签”这个概念。当用户被打上的标签越来越丰富、越来越精准，也就越贴合人本身，勾勒出一个个立体的形象了。&lt;/p&gt;&lt;p&gt;鉴于市面上已有许多理论知识，丰富的实战分享，我也就不班门弄斧了。本文只讲讲那些在执行中，新手容易遇到的踩坑点，帮助大家排雷。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;|0x01 切勿“大而全”标签&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;刚接到这个项目时，我已开始抑制不住内心的激动了。从毕业开始做用户研究，脑中已经构建起了一个框架，希望通过这次从0到1的机会，将美好蓝图实施落地。于是我洋洋洒洒写下一个功能强大的脑图，头脑风暴出用户的所有特性，目标是构建一套成熟的标签体系和画像后台。&lt;/p&gt;&lt;p&gt;这样的结局自然是当头棒喝，第一次需求评审就遇到了很大阻力，现在想来，有两个问题是需要提前想透彻的：①虽说标签需要做得精细，但始终是有主次的，当前为什么会用到标签，具体用来做什么？②在需求调研阶段，什么样的调研是意义的？你会发现有许多做得不错的第三方平台，标签体系非常成熟全面，但像第三方平台这样的to B公司，为了适用于所有的公司业务，所以尽善尽美。而以我们当前的业务量来说，是否需要做到如此全面？以当前的资源来说，是否有能力进行开发和维护？&lt;/p&gt;&lt;p&gt;实际上，我们现阶段是从0到1，要想一步到位是不现实的，应该按照业务需求进行取舍。所以，真正有效的方法不是穷举法，而是由业务场景进行倒推：我们发现，当前标签首先会运用在消息推送上，其中很重要的一个场景是，圈选预流失用户，通过app push、短信等方式进行召回。&lt;/p&gt;&lt;p&gt;目的与场景明确了，接下来就是流失标签的定义了。作为PM，我立马与运营进行了沟通，了解一线业务人员对于流失的理解。这时，很容易又踩到了第二个坑：询问技巧。&lt;/p&gt;&lt;p&gt;错误方式：我：咱们现在要对用户打标签用于召回了，你觉得“流失1天以上”和“流失30天以上”，哪个更合适？运营：我觉得都是需要的，不同的流失程度我都会关心。我：好吧.....那针对活跃标签，你觉得“最近7天登录”“最近14天登录”“最近30天登录”，哪个最合适？运营：那肯定都要啊，这都是我们平时会关注的指标。emmmm天数能不能不要固定？我们能自定义是最好的。&lt;/p&gt;&lt;p&gt;与业务方沟通会发现，在对方对标签不甚熟悉的情况下，会误将标签与业务指标相混淆，从而显得“贪心”起来——什么标签都想要。这时，你需要转换一种提问方式，得到最有价值的答案&lt;/p&gt;&lt;p&gt;正确方式：我：咱们现在要对用户打标签用于召回了，平时你想对哪些用户进行召回呀？运营：我想想.....我平时看数据，大多用户会在前期流失，3日留存率就只有xx啦！是我的话，我会在3日这个节点去召回。我：soga，那我们可以提供“流失3天”这个标签，方便你进行召回操作。精简标签之后，留下最重要、最迫切的一些标签，作为第一期的实现内容。之后你会发现，一些基础标签，已经能满足百分之六七十的需求啦，这样既不会造成开发资源的浪费，也避免业务人员在使用时，面对着海量标签犹豫不决。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;|0x02 用户标签的分类&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;如果看过很多文章会发现，大家对于标签有非常多的不同描述，也少有文章有去认真讲解这个认知前提。这也导致初期容易对标签的理解产生混淆，因为从不同的维度去认识，标签有着不同的分类。&lt;/p&gt;&lt;p&gt;经过一些整合后，我认为大致可以从五个角度去理解标签：&lt;/p&gt;&lt;p&gt;1、从更新频率来分：静态标签、动态标签 例如“性别”这个标签，一般来说是不会随着时间变动的，所以它属于静态标签；而“最近一次访问时间”会随着每次用户登录而更新，也就是动态标签。&lt;/p&gt;&lt;p&gt;2、从主题上分：属性标签、行为标签等 随着业务的进行，标签往往会越来越多，而“主题”帮助我们从业务角度对标签进行归类，方便后续有秩序地补充新的标签。例如我可以分为“属性标签”和“行为标签”，将“性别”“年龄”这样描述用户的自然属性的标签归于“属性标签”，而将“近30日下单次数”这样的涉及到用户下单行为的标签归属到“行为标签”。主题的划分并没有规定，不同的公司可以根据自己的业务需求进行归类整合，避免标签体系杂乱。&lt;/p&gt;&lt;p&gt;3、从层级上分：一级标签、二级标签等 同样，层级也是为了业务理解更加有序才产生的，例如上述的“近30日下单次数”可以作为“二级标签”，归属于“近30日行为”这个一级标签，那么下次添加“近30日登陆次数”这个标签时，就可以同样归于“近30日行为”这个一级标签之下。当然，如果业务逻辑复杂，可能还会有三级标签。&lt;/p&gt;&lt;p&gt;4、从开发方式分：统计类标签、规则类标签、算法类标签（又称：事实标签、模型标签、预测标签） 这一种分类方式是从技术开发角度产生的。“统计类标签”（有些又称为“事实标签”）是从底层数据表中取出原始数据，进行简单的加减乘除运算得到的标签，例如“最近一次登录距今天数”这个标签，就是将用户的最后一次登录时间与今天做减法，得到距今天数，它反映基本事实。而“规则类标签”（有些又称“模型标签”）则是进行了业务定义后的标签，例如“流失用户”这个标签，基于我们的业务认知，将“最近一次登录距今天数”大于30天的用户定义为流失用户，不同公司会有自己的定义方式，例如“抖音”这样高频的社交产品，他的流失的定义一定会严格于“携程”这样低频的出行产品。“算法类标签”（又称“预测标签”）顾名思义，就是需要利用算法才能得到的标签了，例如电商产品常通过用户的下单行为，去猜测用户的性别。通常算法类标签涉及复杂的逻辑与权重，开发难度大，在所有标签中占比不高。&lt;/p&gt;&lt;p&gt;5、从生成规则分：单一标签、复合标签 一般来说，上述的统计类标签可以说是单一标签，而规则类和算法类标签就是需要多个单一标签组合而成的复合标签。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.9517544&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jWg3EibnYW98aFiaUUhWznOkrlss6JfCtUs4gtEuncWa1rjibAj9EodxvDnXcTboAfEp9fxsOSe6cS0NOhFpAzg7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;684&quot;/&gt;&lt;/p&gt;&lt;p&gt;搞清楚标签的分类之后，大家在搭建过程中对齐口径，再去制定相应的标签值就容易推进了。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;|0xFF 用户标签与画像的关系&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;起初在开始做标签的时候，我一度混淆标签与画像的概念。平时，我们常把两个词捆绑在一起说，但是标签=画像吗？我们先来看看百度百科的解释。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.2635585&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jWg3EibnYW98aFiaUUhWznOkrlss6JfCtUWCZMGun9MuobHfj01ugYsOuSXMMzO6PRicDsq6Es9aWg4pV9kZrkvvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1051&quot;/&gt;&lt;/p&gt;&lt;p&gt;度娘的解释是，画像需要“利用标签将用户形象具体化”，意味着，画像需要建立在标签的基础之上，存在依赖关系，但又不尽相同。&lt;/p&gt;&lt;p&gt;标签是对于用户，更偏底层的一种描述，当我们给用户打标签时，此用户的数据表中填充了“26岁”“女性”“北京”“白领”等标签值。对个体用户而言，我们一般不将其标签描述为画像，而叫做“典型用户”，用于直观阐述我们的目标群体是谁，或者用于客服回访时，快速了解用户的相关信息。&lt;/p&gt;&lt;p&gt;而我们常说的用户画像系统，一般针对的是一个群体。当每个个人都被打上标签之后，通过统计的方式将一个群体的特征进行汇总，才是我们想要得到的画像——当前我们的活跃用户主要来自哪些渠道？主要位于哪个年龄层？从而反向推导出哪些是最适合我们产品的用户，调整广告投放策略。&lt;/p&gt;&lt;p&gt;如果说标签是底层数据的标识，那么画像可以说是一个应用场景，同样，标签还有另一个重要的应用场景——分群。上述例子中，当我们要进行一次app push时，业务人员需要利用标签，选择精准的目标用户进行推送，从而达到最高的ROI。例如电商常见的，针对“偏好短裙”和“偏好美妆”的女性用户，编辑不同的文案和折扣信息，吸引点击转化。&lt;/p&gt;&lt;p&gt;综上所述，标签与画像有一定的联系，但又不完全一致，切勿混为一谈。标签的使用场景，还需要我们在深入业务的同时，不断去挖掘，让其价值最大化，才是我们所说的真正的“精细化运营”。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9a51b23943f1541b26afe2af4ec916f2</guid>
<title>快速搭建 HTTP 静态服务的 10 种方法</title>
<link>https://toutiao.io/k/re4fx9c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;pos-relative js-post-content&quot;&gt;
                
                &lt;p&gt;作为程序员，需要经常起一个&lt;strong&gt;静态服务器&lt;/strong&gt;（http static server，在命令执行的所在路径启动一个 http 服务器，即可通过浏览器访问该路径下的所有文件），来完成一些任务，如局域网内传文件，或者测试网页等；本文主旨即分享，如何快速搭建 HTTP 静态服务的 10 种方法，对于非程序员人也可以使用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/content/images/2020/09/http-static-server.jpg&quot; alt=&quot;快速搭建 HTTP 静态服务的 10 种方法&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;python&quot;&gt;Python&lt;/h2&gt;
&lt;h3 id=&quot;python2x&quot;&gt;基于 Python 2.x&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;python -m SimpleHTTPServer 8000
# Serving HTTP on 0.0.0.0 port 8000 ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;python3x&quot;&gt;基于 Python 3.x&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;python -m http.server 8000
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;livereload&quot;&gt;基于 Livereload 库&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;pip install livereload
#serves current dir with port 35729 which livereload extensions use
livereload
# 指定端口和路径      
livereload ~/testing -p 8000
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;nodejs&quot;&gt;Node.js&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# 安装依赖
npm i arya-jarvis -g

# 默认 8080 端口，如被占用，自增长
arya server
# 👏 Or Use Alias
arya s
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者直接使用 npx 来完成✅：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# 安装 + 使用
npx arya-jarvis server
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;httpserver&quot;&gt;基于 http-server&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# 安装依赖
npm install -g http-server
http-server -p 8000

# 或者基于 npx 
npx http-server
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# 安装依赖
npm install -g anywhere

anywhere
# 自定义端口
anywhere -p 8000

# 或者基于 npx 
npx anywhere -p 8000
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;nodestatic&quot;&gt;基于 node-static&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;# 安装依赖
npm install -g node-static 
static -p 8000

# 或者基于 npx 
npx node-static -p 8000
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;go&quot;&gt;Go&lt;/h2&gt;
&lt;h3 id=&quot;spark&quot;&gt;基于 spark&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;go get github.com/rif/spark
spark -port 8000 .
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;php&quot;&gt;PHP&lt;/h2&gt;
&lt;h3 id=&quot;php54&quot;&gt;基于 PHP (&amp;gt;= 5.4)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;php -S 127.0.0.1:8000
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;ruby&quot;&gt;Ruby&lt;/h2&gt;
&lt;h3 id=&quot;ruby192&quot;&gt;基于 Ruby 1.9.2+&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ruby -run -ehttpd . -p8000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果您使用 Mac 或 Linux 操作系统，可以在 &lt;code&gt;.zshrc&lt;/code&gt; 配置中添加如下这句，即可在终端，使用 &lt;code&gt;server&lt;/code&gt; 命令开启静态服务（当然，您将方式替换成如上提到的方法也可以）：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;alias server=&quot;ruby -run -ehttpd . -p 8080&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;serve&quot;&gt;基于 serve 库&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# 安装工具库
gem install serve
serve
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;golang&quot;&gt;Golang&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# 安装工具库
go get github.com/vwochnik/gost
gost
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;curl&quot;&gt;基于 curl&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;curl lama.sh | sh
&lt;/code&gt;&lt;/pre&gt;

              &lt;/div&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>