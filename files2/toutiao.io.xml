<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e45044fef6a469d6c7e0bf1d2f1c7677</guid>
<title>应用程序怎样划分模块？</title>
<link>https://toutiao.io/k/vbj8o6g</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;在做一个新项目，架构和功能很简单。大家讨论的时候对应用程序的模块划分都有自己的一些看法。需要的下面两个模块大家没有分歧，分别是core模块和web1模块、web2模块，因为最后对外会提供两个独立的web应用。这两个应用针对不同的业务，实现也稍有不同。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个架构整体是一个模板模式的，有通用的实现，还有一些接口需要web1和web2各自实现，还会涉及一个工具类。主要的分歧有：&lt;/p&gt;&lt;p&gt;1&amp;gt;工具类要不要提取一个专门的commons模块&lt;/p&gt;&lt;p&gt;2&amp;gt;流程模板放在core里没有异议，那针对需要各自实现的接口要不要单独提取一个模块。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;大家都表示最后怎么划分都支持，不会强烈坚持自己的观点，因为实际上对后续开发维护的影响不是很大。我决定用周末的时候把这个问题想明白，因为划分问题除了实用角度，更多是一个专业性的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我之前写过一篇文章&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484076&amp;amp;idx=1&amp;amp;sn=0c2b291a31ed53e9c8af06d131aabdd4&amp;amp;chksm=fafde802cd8a6114430a5c1eb8609481059341089ba2c4113012764578152570b6149780e3d5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《你们项目的核心战略是什么》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《&lt;span&gt;你们项目的核心战略是什么&lt;/span&gt;&lt;span&gt;》&lt;/span&gt;&lt;/a&gt;里有提到模块划分：按照之前项目标配是划分了commons模块的，但是在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485258&amp;amp;idx=1&amp;amp;sn=52a6a62d85e2e1caafcf0a1de46a4860&amp;amp;chksm=fafdede4cd8a64f21effe09d23efe7adc8d226eb021801a4dcb8f2fb02e2065577eb87bc1474&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《关于Java两点需要更新的知识》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《关于Java两点需要更新的知识》&lt;/a&gt;里我也提到，知识是要常常反思并进行更新的。没有调研，不要盖棺定论。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;思路是采用登高类比法进行业界调研得出结论登高类比法是先检索最为相似的场景以得出结论。如果检索结果不够时再扩大范围直到足以得出结论。比如设计一个IP分配方法，检索时先检索IP分配，在网上比较权威的大概只有DHCP动态主机配置了。但是我们需要的不是动态，可以退而检索资源分配。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;工具类要不要提取一个专门的commons模块&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;自己不知道怎么做好的时候，就看好的是怎么做的。首先调研了一下spring。极简标配：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;${spring.boot.version}&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;${spring.boot.version}&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;项目引入了上面两个maven坐标，看对应的spring包都引入了什么：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5110410094637224&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicaj3NoVtl5MyZZIr39JD2AbU2NHxA0MlrYYibSUTAkQDMB8RSax32jueMEMic4QfWEg7mCVHFR5LJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;634&quot;/&gt;&lt;/p&gt;&lt;p&gt;这里包含了spring-core和spring-web，spring并没有spring-commons模块，大家常用的都是&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486291&amp;amp;idx=1&amp;amp;sn=c6a52233e35571c6531bbef005139981&amp;amp;chksm=fafde1fdcd8a68ebf2e6c1f3edc53cff7c8a622dd8520d2e98cf9b99976e29096a3bd9d79604&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;apache-commons或者hutool&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;apache-commons或者hutool&lt;/a&gt;这种专业的工具包。那针对业务上通过的工具像spring这种大拿级别都是怎么来处理的呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;来看spring-core的目录结构&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5591397849462365&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicaj3NoVtl5MyZZIr39JD2Aw4TZT1oMkwBJ2fkz9YsLJsIaVNY5kPWPbY1ibwLgbV8ZjoFyNicKToXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;558&quot;/&gt;&lt;/p&gt;&lt;p&gt;工具在util下面。这里注意是util而不是utils单数。这个地方命名风格部分有规约：&lt;/p&gt;&lt;h1&gt;阿里巴巴Java开发手册&lt;/h1&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用 单数形式，但是类名如果有复数含义，类名可以使用复数形式。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;正例:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;应用工具类包名为&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;com&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.alibaba&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.open&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.util&lt;/span&gt;、类名为&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;MessageUtils&lt;/span&gt;(此规则参考 &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;spring&lt;/span&gt; 的框架结构)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;【强制】杜绝完全不规范的缩写，避免望文不知义。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;反例:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;AbstractClass&lt;/span&gt;“缩写”命名成 &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;AbsClass&lt;/span&gt;;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;condition&lt;/span&gt;“缩写”命名成 &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;condi&lt;/span&gt;，此类随 意缩写严重降低了代码的可阅读性。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;各自实现的接口要不要单独提取一个模块&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;模板架构我想了一下，比较合适的参考是mybatis-plus。这是一个mybatis的增强工具。使用这个工具，每个Mapper都需要继承BaseMapper。它的位置是：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.180385288966725&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicaj3NoVtl5MyZZIr39JD2Af6u2ePIuZa3rvChJXlozYicMCfYHe1vB2MhFfnL6DnefRzs5AQ0tzsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;571&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其实我还调研了其他一些框架，结论就是放到core模块下。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;自己不知道怎么做好的时候，就看好的是怎么做的。&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3566fc67ce36ff85f265a74e1602b067</guid>
<title>浪漫的turtle，送给程序员自己的圣诞树！</title>
<link>https://toutiao.io/k/r0vz8gy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;前几天一直在整 Pyqt5 相关的知识，在 Python UI 的世界里 Pyqt5 只是其中的一种用来做应用程序比较 nice。要在一个画布上面呈现我们需要的东西还是得依赖 turtle 比较靠谱，什么组件就做什么事、没有谁比谁厉害，只是在合适的地方用合适的组件来做需求。turtle 库主要就是通过画笔的形式来在画布上画出自己想要的东西，最后参考了 CSDN 对其函数进行了重写、封装，大家可以发挥想象做出更好的，程序猿嘛当然要活到老、学到老！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考来源：CSDN 博客&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA3ODk1Mzg0Mg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/wzyc1ToJM6hibKwqc6pgs9eu9tgh5AeibzhIhhMcAiaKaoczZdvmic9lLBP6oAyjibayia3ctN1WXEFyVia1OXoD9y3ibQ/0?wx_fmt=png&quot; data-nickname=&quot;Python 集中营&quot; data-alias=&quot;lwsbc1024&quot; data-signature=&quot;编程技巧、实战总结，在 Python 的路上越走越宽，+关注自动领取Python 学习视频资料！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;公众号内回复&quot;圣诞树&quot;，获取完整源代码。&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;89056&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section/&gt;&lt;/section&gt;&lt;section data-width=&quot;100%&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;（视频建议使用WIFI网络收看）&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;引入相关的第三方 python 库，其中主要用了 random 随机数库及 turtle 画布组件库。&lt;/span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; random &lt;span&gt;as&lt;/span&gt; rdm &lt;span&gt;# 内置随机数生成库&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; turtle &lt;span&gt;as&lt;/span&gt; tle  &lt;span&gt;# 执行画布画图库&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;初始化 turtle 画布的相关参数，并在初始化的过程中调用相关引用函数。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        self.tle = tle  &lt;span&gt;# 初始化 turtle 对象&lt;/span&gt;&lt;br/&gt;        self.tle.speed(&lt;span&gt;&#x27;fastest&#x27;&lt;/span&gt;)  &lt;span&gt;# 定义全局画笔速度：快速&lt;/span&gt;&lt;br/&gt;        self.tle.screensize(bg=&lt;span&gt;&#x27;black&#x27;&lt;/span&gt;)  &lt;span&gt;# 定义全局背景黑色&lt;/span&gt;&lt;br/&gt;        self.base_num = &lt;span&gt;100.0&lt;/span&gt;  &lt;span&gt;# 定义画笔移动基数为 100.0&lt;/span&gt;&lt;br/&gt;        self.tle.pensize(&lt;span&gt;3&lt;/span&gt;)  &lt;span&gt;# 定义画笔宽度&lt;/span&gt;&lt;br/&gt;        self.tle.setup(&lt;span&gt;1000&lt;/span&gt;, &lt;span&gt;750&lt;/span&gt;)  &lt;span&gt;# 定义画布大小&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# self.tle.tracer(False)  # 是否直接显示结果，取消画笔画画过程&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        self.draw_star()  &lt;span&gt;# 调用画五角星&lt;/span&gt;&lt;br/&gt;        self.draw_tree()  &lt;span&gt;# 调用画树&lt;/span&gt;&lt;br/&gt;        self.draw_bottom()  &lt;span&gt;# 调用画底部彩灯&lt;/span&gt;&lt;br/&gt;        self.draw_word()  &lt;span&gt;# 调用画文字&lt;/span&gt;&lt;br/&gt;        self.draw_snow()  &lt;span&gt;# 调用画雪&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        self.finshed()  &lt;span&gt;# 调用完成&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;画出一个五角星作为圣诞树的树顶部分。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;draw_star&lt;/span&gt;&lt;span&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&#x27;&#x27;&#x27;&lt;br/&gt;        画五角星函数&lt;br/&gt;        :return:&lt;br/&gt;        &#x27;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;        self.tle.left(&lt;span&gt;90&lt;/span&gt;)  &lt;span&gt;# 画笔逆时针旋转90度&lt;/span&gt;&lt;br/&gt;        self.tle.forward(&lt;span&gt;3&lt;/span&gt; * self.base_num)  &lt;span&gt;# 画笔向前画一条3 * self.base_num的直线&lt;/span&gt;&lt;br/&gt;        self.tle.color(&lt;span&gt;&#x27;yellow&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;yellow&#x27;&lt;/span&gt;)  &lt;span&gt;# 定义画笔颜色为黄色、填充颜色为黄色&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        self.tle.begin_fill()  &lt;span&gt;# 开始填充&lt;/span&gt;&lt;br/&gt;        self.tle.left(&lt;span&gt;126&lt;/span&gt;)  &lt;span&gt;# 画笔逆时针旋转126度&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;5&lt;/span&gt;):  &lt;span&gt;# 循环5次&lt;/span&gt;&lt;br/&gt;            self.tle.forward(self.base_num / &lt;span&gt;5&lt;/span&gt;)  &lt;span&gt;# 画笔向前画一条self.base_num / 5的直线&lt;/span&gt;&lt;br/&gt;            self.tle.right(&lt;span&gt;144&lt;/span&gt;)  &lt;span&gt;# 画笔顺时针旋转144度&lt;/span&gt;&lt;br/&gt;            self.tle.forward(self.base_num / &lt;span&gt;5&lt;/span&gt;)  &lt;span&gt;# 画笔向前画一条self.base_num / 5的直线&lt;/span&gt;&lt;br/&gt;            self.tle.left(&lt;span&gt;72&lt;/span&gt;)  &lt;span&gt;# 画笔逆时针旋转72度&lt;/span&gt;&lt;br/&gt;        self.tle.end_fill()  &lt;span&gt;# 结束填充&lt;/span&gt;&lt;br/&gt;        self.tle.right(&lt;span&gt;126&lt;/span&gt;)  &lt;span&gt;# 画笔顺时针旋转126度&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1640009164827&quot; data-category_id_list=&quot;1|11|16|17|22|24|26|27|28|29|3|31|32|35|36|37|39|41|42|43|45|46|47|48|49|5|50|51|52|53|54|55|6|7|8&quot; data-id=&quot;1640009164827&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;接下来画圣诞树的树干部分。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;draw_tree&lt;/span&gt;&lt;span&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&#x27;&#x27;&#x27;&lt;br/&gt;        画树函数&lt;br/&gt;        :return:&lt;br/&gt;        &#x27;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;        self.tle.color(&lt;span&gt;&#x27;dark green&#x27;&lt;/span&gt;)  &lt;span&gt;# 设置树的画笔颜色为深绿色&lt;/span&gt;&lt;br/&gt;        self.tle.backward(self.base_num * &lt;span&gt;4.8&lt;/span&gt;)  &lt;span&gt;# 向后画一条 self.base_num * 4.8的直线&lt;/span&gt;&lt;br/&gt;        self.tree_iterator(&lt;span&gt;15&lt;/span&gt;, self.base_num)  &lt;span&gt;# 调用树枝遍历函数&lt;/span&gt;&lt;br/&gt;        self.tle.backward(self.base_num / &lt;span&gt;2&lt;/span&gt;)  &lt;span&gt;# 向后画一条 self.base_num / 2的直线&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;tree_iterator&lt;/span&gt;&lt;span&gt;(self, d, s)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&#x27;&#x27;&#x27;&lt;br/&gt;        树枝的递归函数&lt;br/&gt;        :param d:&lt;br/&gt;        :param s:&lt;br/&gt;        :return:&lt;br/&gt;        &#x27;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; d &amp;lt;= &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;        self.tle.forward(s)  &lt;span&gt;# 向前画一条长度s的直线&lt;/span&gt;&lt;br/&gt;        self.tree_iterator(d - &lt;span&gt;1&lt;/span&gt;, s * &lt;span&gt;0.8&lt;/span&gt;)  &lt;span&gt;# 递归&lt;/span&gt;&lt;br/&gt;        self.tle.right(&lt;span&gt;120&lt;/span&gt;)  &lt;span&gt;# 顺时针旋转120度&lt;/span&gt;&lt;br/&gt;        self.tree_iterator(d - &lt;span&gt;3&lt;/span&gt;, s * &lt;span&gt;0.5&lt;/span&gt;)  &lt;span&gt;# 递归&lt;/span&gt;&lt;br/&gt;        self.draw_lantern()  &lt;span&gt;# 调用树枝彩灯函数&lt;/span&gt;&lt;br/&gt;        self.tle.right(&lt;span&gt;120&lt;/span&gt;)  &lt;span&gt;# 顺时针旋转120度&lt;/span&gt;&lt;br/&gt;        self.tree_iterator(d - &lt;span&gt;3&lt;/span&gt;, s * &lt;span&gt;0.5&lt;/span&gt;)  &lt;span&gt;# 递归&lt;/span&gt;&lt;br/&gt;        self.tle.right(&lt;span&gt;120&lt;/span&gt;)  &lt;span&gt;# 顺时针旋转120度&lt;/span&gt;&lt;br/&gt;        self.tle.backward(s)  &lt;span&gt;# 向后画一条长度s的直线&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后，为了让圣诞树更好看可以在树枝的部分加上彩灯。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;draw_lantern&lt;/span&gt;&lt;span&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&#x27;&#x27;&#x27;&lt;br/&gt;        画彩灯函数，随机在树枝上添加彩灯&lt;br/&gt;        :return:&lt;br/&gt;        &#x27;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; rdm.randint(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;50&lt;/span&gt;) == &lt;span&gt;10&lt;/span&gt;:&lt;br/&gt;            self.tle.color(&lt;span&gt;&#x27;tomato&#x27;&lt;/span&gt;)&lt;br/&gt;            self.tle.circle(&lt;span&gt;6&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;elif&lt;/span&gt; rdm.randint(&lt;span&gt;10&lt;/span&gt;, &lt;span&gt;50&lt;/span&gt;) == &lt;span&gt;50&lt;/span&gt;:&lt;br/&gt;            self.tle.color(&lt;span&gt;&#x27;yellow&#x27;&lt;/span&gt;)&lt;br/&gt;            self.tle.circle(&lt;span&gt;3&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;            self.tle.color(&lt;span&gt;&#x27;dark green&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在圣诞树的底部加上彩灯。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;draw_bottom&lt;/span&gt;&lt;span&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&#x27;&#x27;&#x27;&lt;br/&gt;        画底部彩灯函数&lt;br/&gt;        :return:&lt;br/&gt;        &#x27;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;200&lt;/span&gt;): &lt;span&gt;# 循环画200个底部彩灯&lt;/span&gt;&lt;br/&gt;            a = &lt;span&gt;200&lt;/span&gt; - &lt;span&gt;400&lt;/span&gt; * rdm.random()&lt;br/&gt;            b = &lt;span&gt;10&lt;/span&gt; - &lt;span&gt;20&lt;/span&gt; * rdm.random()&lt;br/&gt;            self.tle.pu()&lt;br/&gt;            self.tle.forward(b)&lt;br/&gt;            self.tle.left(&lt;span&gt;90&lt;/span&gt;)&lt;br/&gt;            self.tle.forward(a)&lt;br/&gt;            self.tle.pd()&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; rdm.randint(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;                self.tle.color(&lt;span&gt;&#x27;tomato&#x27;&lt;/span&gt;)&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;                self.tle.color(&lt;span&gt;&#x27;wheat&#x27;&lt;/span&gt;)&lt;br/&gt;            self.tle.circle(&lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;            self.tle.up()&lt;br/&gt;            self.tle.backward(a)&lt;br/&gt;            self.tle.right(&lt;span&gt;90&lt;/span&gt;)&lt;br/&gt;            self.tle.backward(b)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1640009182023&quot; data-category_id_list=&quot;1|11|16|17|22|24|26|27|28|29|3|31|32|35|36|37|39|41|42|43|45|46|47|48|49|5|50|51|52|53|54|55|6|7|8&quot; data-id=&quot;1640009182023&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在圣诞树的周围画上雪花。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;draw_snow&lt;/span&gt;&lt;span&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&#x27;&#x27;&#x27;&lt;br/&gt;        画雪函数&lt;br/&gt;        :return:&lt;br/&gt;        &#x27;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;        self.tle.ht()  &lt;span&gt;# 开启隐藏画笔模式&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;200&lt;/span&gt;):&lt;br/&gt;            self.tle.color(&lt;span&gt;&quot;white&quot;&lt;/span&gt;)  &lt;span&gt;# 设置画笔颜色为白色&lt;/span&gt;&lt;br/&gt;            self.tle.pu()  &lt;span&gt;# 抬起画笔&lt;/span&gt;&lt;br/&gt;            x_range = [&lt;span&gt;-350&lt;/span&gt;, &lt;span&gt;350&lt;/span&gt;]  &lt;span&gt;# 设置X轴范围&lt;/span&gt;&lt;br/&gt;            y_range = [&lt;span&gt;-100&lt;/span&gt;, &lt;span&gt;350&lt;/span&gt;]  &lt;span&gt;# 设置Y轴坐标&lt;/span&gt;&lt;br/&gt;            self.tle.setx(rdm.randint(x_range[&lt;span&gt;0&lt;/span&gt;], x_range[&lt;span&gt;1&lt;/span&gt;]))  &lt;span&gt;# 随机设置X轴坐标&lt;/span&gt;&lt;br/&gt;            self.tle.sety(rdm.randint(y_range[&lt;span&gt;0&lt;/span&gt;], y_range[&lt;span&gt;1&lt;/span&gt;]))  &lt;span&gt;# 随机设置Y轴坐标&lt;/span&gt;&lt;br/&gt;            self.tle.pd()  &lt;span&gt;# 落下画笔&lt;/span&gt;&lt;br/&gt;            leaies = &lt;span&gt;6&lt;/span&gt;  &lt;span&gt;# 设置雪花6片叶子&lt;/span&gt;&lt;br/&gt;            leaies_size = rdm.randint(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;)  &lt;span&gt;# 随机生成叶子大小&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; n &lt;span&gt;in&lt;/span&gt; range(leaies):&lt;br/&gt;                self.tle.forward(int(leaies_size))  &lt;span&gt;# 向前画一条长度leaies_size的直线&lt;/span&gt;&lt;br/&gt;                self.tle.backward(int(leaies_size))  &lt;span&gt;# 向后画一条长度leaies_size的直线&lt;/span&gt;&lt;br/&gt;                self.tle.right(int(&lt;span&gt;360&lt;/span&gt; / leaies))  &lt;span&gt;# 顺时针旋转60度&lt;/span&gt;&lt;br/&gt;            self.tle.backward(b)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在 cavans 画布上面写入祝福的文字。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;draw_word&lt;/span&gt;&lt;span&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&#x27;&#x27;&#x27;&lt;br/&gt;        在画布上面写入文字&lt;br/&gt;        :return:&lt;br/&gt;        &#x27;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;        self.tle.color(&lt;span&gt;&quot;dark red&quot;&lt;/span&gt;, &lt;span&gt;&quot;red&quot;&lt;/span&gt;)&lt;br/&gt;        self.tle.write(&lt;span&gt;&quot;Merry Christmas&quot;&lt;/span&gt;, align=&lt;span&gt;&quot;center&quot;&lt;/span&gt;, font=(&lt;span&gt;&quot;Comic Sans MS&quot;&lt;/span&gt;, &lt;span&gt;40&lt;/span&gt;, &lt;span&gt;&quot;bold&quot;&lt;/span&gt;))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;调用完成函数，即在画完的时候让其窗口不会消失。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;finshed&lt;/span&gt;&lt;span&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&#x27;&#x27;&#x27;&lt;br/&gt;        完成函数&lt;br/&gt;        :return:&lt;br/&gt;        &#x27;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;        self.tle.done()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;105183&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;NO.&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;1&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;往期回顾&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section hm_fix=&quot;304:396&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3ODk1Mzg0Mg==&amp;amp;mid=2649851345&amp;amp;idx=1&amp;amp;sn=ae7afdb182903c35c1243377f35605f6&amp;amp;chksm=87bfc9ccb0c840da86dcaa083c048bb9bf00846852f318bfda75b564e615c11a960b391d93a7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;PyQt5 GUI：百度图片下载器（文末附源码）&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;PyQt5 GUI：百度图片下载器（文末附源码）&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3ODk1Mzg0Mg==&amp;amp;mid=2649851332&amp;amp;idx=1&amp;amp;sn=8e02c66a72e780a50c92df5b7d5a6ab5&amp;amp;chksm=87bfc9d9b0c840cf954b53b1e3b40787a4a7b57238d8f19c01d351681f6769effc2cac28fdcd&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;python3中的zip()、zip(*)、list()之间的灵活转换！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;python3中的zip()、zip(*)、list()之间的灵活转换！&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3ODk1Mzg0Mg==&amp;amp;mid=2649851319&amp;amp;idx=1&amp;amp;sn=cb3ea245083dd2449cfdfea3969efc5b&amp;amp;chksm=87bfc9aab0c840bcb06017d8d430158799f723839c9f3c2d0a0f059d7749f8b4506630b3e9bd&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;python print() 函数的格式化字符串输出&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;python print() 函数的格式化字符串输出&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3ODk1Mzg0Mg==&amp;amp;mid=2649851309&amp;amp;idx=1&amp;amp;sn=8f93b7607f8d7093ab73da1ee8a021b7&amp;amp;chksm=87bfc9b0b0c840a6ba1da93d95626a3557abe63fe89d5b6fbfe21a8f883376f6a4bb67033394&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;PyQt5 GUI &amp;amp;&amp;amp; Requests Api 做一个天气查询系统（文末领取完整代码）！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;PyQt5 GUI &amp;amp;&amp;amp; Requests Api 做一个天气查询系统（文末领取完整代码）！&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3ODk1Mzg0Mg==&amp;amp;mid=2649851295&amp;amp;idx=1&amp;amp;sn=12ab2e9c3835e77ab47e585f0bf70640&amp;amp;chksm=87bfc982b0c84094194a0bd6ec79d2e4bfc5d0a26b0505632d92983722d501b6e36d523cbf94&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;一款优美的windows cmd命令行工具cmder&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;一款优美的windows cmd命令行工具cmder&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3ODk1Mzg0Mg==&amp;amp;mid=2649851275&amp;amp;idx=1&amp;amp;sn=abcf81fd330fb2bab479d5ed146f269e&amp;amp;chksm=87bfc996b0c8408056aa55a10a2fee0047ef88e71896cd41d41f1544658a749d8499030ec209&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;如何进行excel数据分析之后的可视化数据写入保存！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;如何进行excel数据分析之后的可视化数据写入保存！&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3ODk1Mzg0Mg==&amp;amp;mid=2649851259&amp;amp;idx=1&amp;amp;sn=2ca16dec7da14c050936d97a062d74bb&amp;amp;chksm=87bfc966b0c8407092dd5248e7dd7840aa31da18fee64dfe2489d4ea98616a5def5587af555c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;excel数据处理二：快速完成openpyxl数据的新增、修改！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;excel数据处理二：快速完成openpyxl数据的新增、修改！&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3ODk1Mzg0Mg==&amp;amp;mid=2649851246&amp;amp;idx=1&amp;amp;sn=de5c90cd6282a0019bb01aa7e3e4388c&amp;amp;chksm=87bfc973b0c840659c4426d3d8e1b1e28417c511d12b6debe7bb1b76e6009e785af2511ab352&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;excel数据处理一：巧妙使用openpyxl提取、筛选数据&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;excel数据处理一：巧妙使用openpyxl提取、筛选数据&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3ODk1Mzg0Mg==&amp;amp;mid=2649851232&amp;amp;idx=1&amp;amp;sn=1e921807ed6e5caf8e14bbf70656c2cf&amp;amp;chksm=87bfc97db0c8406b2847dfcd8d53bb21b42f023464a6717ca33f15c9638712285aa79e9d909a&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;比Selenium更方便的自动化测试工具Helium！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;比Selenium更方便的自动化测试工具Helium！&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3ODk1Mzg0Mg==&amp;amp;mid=2649851219&amp;amp;idx=1&amp;amp;sn=783db931523695b9df50459b72c104b0&amp;amp;chksm=87bfc94eb0c840582665128508f3e6aeb67a3d2dbc3980abb6547a3ada6ebc7e46cd9d425e5d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Python数据可视化：可视化数据分析插件D-Tale&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Python数据可视化：可视化数据分析插件D-Tale&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;100380&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;377:386&quot;&gt;我知道你&lt;span data-brushtype=&quot;text&quot;&gt;在看&lt;/span&gt;哦&lt;/section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.3&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/wzyc1ToJM6iaPU1ibFQzCBBYvlIAoygmPCRHTDyKOq5hZOQdLQhpH9nE5sCjy49ORlv69wop8Xu8PnSjmYTCD7OQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;558&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4c1c0129b48c019a54de4a16bb5e243b</guid>
<title>Python之禅：编写优雅Python代码的16个原则</title>
<link>https://toutiao.io/k/ae52kmj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;blockquote&gt;&lt;blockquote&gt;&lt;section&gt;微信搜索&lt;code&gt;逆锋起笔&lt;/code&gt;关注后回复&lt;code&gt;编程pdf&lt;/code&gt;&lt;br/&gt;领取编程大佬们所推荐的 23 种编程资料！&lt;/section&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;作者&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;刘宇宙&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;，《&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;进阶编程：编写更高效 优雅的&lt;/span&gt;&lt;span&gt;Python&lt;/span&gt;&lt;span&gt;代码》一书作者。&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;900&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9fRTdvQaGDJVC7bbe3ztL0CUv6u1vic82aiaRibXiciajV23I5SAay1pSDIL9QsJE5XOeWSiaUeTODW9iaNxF1lwc5LZg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;假如你刚参与了一个算法项目，当你第一次打开这个项目时，发现里面已经有上万行与算法相关的代码，仔细查看过后，发现如下一些让你抓狂的问题：&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1&lt;span&gt;、代码写的非常冗余，维护已经变得越来越困难。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2&lt;span&gt;、几乎没有任何注释。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3&lt;span&gt;、非常错乱的代码风格，让你有一种感觉打开了一个杂乱的网站的&lt;/span&gt;html&lt;span&gt;页面。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4&lt;span&gt;、存在那么几个函数，单个函数的源码超过&lt;/span&gt;500&lt;span&gt;行。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;5&lt;span&gt;、每一次需求的变更，都意味着一次痛苦的代码编写。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;这是&lt;/span&gt;&lt;/span&gt;&lt;span&gt;笔者&lt;/span&gt;&lt;span&gt;&lt;span&gt;以前参与一个算法项目时遇到的问题。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;在参与这个项目时，大家都在很努力的使项目往期望的方向走，但随着开发进度的往前推进，项目的复杂性正在不断加大，大家都在尽可能使用自己了解的最好的技术将系统打造的更为强壮，但系统但复杂性一点也没有降低。在需求但不断变化中，代码的冗余也越来越明显。程序中到处充斥着废弃的代码，但谁也不敢轻易去删除，谁也不清楚自己的一个不经意操作，是否会导致整个程序的奔溃。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;对于代码的开发，里面包含了很多细枝末节的东西，特别对于需要高度配合的项目（如算法人员和工程人员之间），细节的处理是否妥当，将很大程度影响项目是否可以成功交付，跨行之间的配合与细节的处理是大部分开发者所欠缺的，这类人才也是市场上急需的。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;python&lt;span&gt;的设计宗旨是简单、优雅、明确。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;但很多开发人员通过自己的努力将其做成了复杂、丑陋、晦涩。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;结合&lt;/span&gt;Python&lt;span&gt;之禅与自己的开发经验，给出如下一些观点与建议，希望可以为你带来一些帮助：&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;0&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;1&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot; hm_fix=&quot;274:397&quot;&gt;优美胜于丑陋&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;代码除了完成指定功能，同时也是给人看的。优美的代码和优美的风景一样，都能让人感到赏心悦目，优美的代码是一种艺术，相对于丑陋的代码，大家都会倾向于查阅优美的代码。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;在工作过程中，尽可能往编写优美代码的方向走。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;0&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;2&quot;&gt;2&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot; hm_fix=&quot;214:390&quot;&gt;&lt;p&gt;明了胜于晦涩&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;在代码编写中使用明了的词语来命名方法名、函数名或变量名是非常好的习惯。命名很好的代码，可以省略很多代码注释的工作，优秀的代码会说话。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;编写优秀的代码，代码本身就是注释。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;最好的代码是不需要注释就可以让大部分人都可以看懂，这需要编写者有很强的编码功底和语言抽象功能，很多时候并不要求所有开发这都有这种能力，但也需要在少量的代码注释情形下可以让代码阅读者可以快速看明白你写的代码。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;如果可能，尽量减少晦涩代码的出现，大部分情形下，晦涩代码的出现都是因为开发者对需求了解不清楚或没有用更简单的方式思考，对于代码的负责人，若看到出现类似代码，应当小心谨慎，需要了解对应的需求是否确实会如代码那么晦涩，还是开发人员想复杂了。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;0&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;3&quot;&gt;3&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;简单胜于复杂&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;把简单的事情做复杂并不难，但要把复杂的变得简单，那需要付出巨大的艰辛。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;在工程应用中，把简单的需求做得复杂的案例数不胜数；而能通过抽丝剥茧的方式把复杂应用场景拆分的很简单的案例少之又少，当今市场极为缺乏有这种能力的人才。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;复杂的来源也是有很多当时以为简单的事情堆积而成的，在多种简单的组合过程中，继续保持整体的简单，是一件值得思考的事情，这要求在对整体了解的情况下对各个细节的把控，编程本来就是一门对细节要求极高的技术，当对细节的掌控了然于胸时，编写出简单的代码就水到渠成了。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;0&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;4&quot;&gt;4&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;复杂胜于凌乱&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;我们排斥复杂，但有时复杂难以避免。可以复杂，但不要凌乱。有迹可循的复杂代码还是具有可读性的，至少可以从代码层面找到处理逻辑。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;当代码以凌乱的方式出现时，那是会让人非常崩溃的。犹如你与人交谈时，若与你谈话的人一直东一句，西一句，让你根本不清楚对方在讲什么，估计你与对方聊上几分钟就不想聊了，并期望不想再遇到类似的聊天对象。编程也一样，对于那些凌乱的代码，大家都是避之不恐。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;0&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;5&quot;&gt;5&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot; hm_fix=&quot;289:397&quot;&gt;扁平胜于嵌套&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;在编写代码时，每增加一个嵌套，则意味着代码的复杂度增加了一些，代码的执行效率对应的下降了一些。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;当出现三层以上的嵌套时，那说明代码编写思路出现了偏差，对于这种代码，应该会非常浪费系统的资源，甚至全部耗尽。实际应用中应当避免，并寻求其它更简单的实现方式。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;能用扁平的方式实现时，就不要使用嵌套实现。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section hm_fix=&quot;273:370&quot;&gt;&lt;section&gt;&lt;section&gt;0&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;6&quot;&gt;6&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;间隔胜于紧凑&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;若是面向计算机编程，代码间隔紧凑与否是没有任何关系的。但若需要不断被开发人员查看，适当的间隔那就非常有必要了，组织良好的代码不仅仅是逻辑清晰，在代码结构上也是非常有讲究的，很多时候都会遵循&lt;/span&gt;PEP8&lt;span&gt;的规范，那样写出来的代码是让人赏心悦目的。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;另一方面，这也能帮助你编写出更加高效的代码，因为通过合理的控制代码结构，当程序发生问题时，组织良好的代码结构可以帮助你更快的找到问题。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;0&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;7&quot;&gt;7&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt; 可读性很重要&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;很多时候，我们编写的代码除了让计算机执行指定的程序，另一个很重要的点就是给其他人查看。而代码的可读性决定了会有多少人愿意读你的代码。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;现在很流行的一个词叫开源代码，对于开源代码，可读性在很大程度上决定了有多人愿意参与到这个开源中。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;而对于项目应用中，编写一份可读性非常高的代码是非常必要的，尽管很多时候是以功能优先。提高代码的可读性，不仅仅是一个自我的修炼过程，对于团队、甚至公司，都可以更好的减少开发、维护和学习成本的。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;0&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;8&quot;&gt;8&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot; hm_fix=&quot;336:401&quot;&gt; 特例不足以特殊到违背这些原则&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;在代码编写过程中，不可避免会需要对某些特例提供支持，甚至有时为了可以支持特例，需要违背一些已有的好的原则。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;当有需要类似的操作时，需要做更为全局的平衡，这个特例是否必须，是否有其它可处理方式，怎么最小化特例给其它原则带来的破坏。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;0&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;9&quot;&gt;9&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot; hm_fix=&quot;379:397&quot;&gt;实用性胜过纯粹&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;编写代码的首要原则是可用，在可用的基础上才有可能执行其它如性能优化、效率提升等操作。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;实用性与纯粹性不同，纯粹性更多体现在实验或验证性操作上，很少参与到真实环境中的应用，而我们需要的是可以在真实环境中可用的代码。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;0&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;10&quot;&gt;10&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot; hm_fix=&quot;338:400&quot;&gt; 永远不要默默地忽视错误&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;当程序出现错误时，那已经在提示我们程序中的某处代码并没有如我们想象的那么完美，它编写有&lt;/span&gt;Bug&lt;span&gt;或是有隐藏&lt;/span&gt;Bug&lt;span&gt;，需要我们进行正确的处理，若置之不理，很有可能埋下一颗定时炸弹，在某一刻让你的程序直接崩溃，这种的代价往往都会不小。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;在实际的应用中，即时是很小的问题，也不要选择忽视，建立起必要的异常管理，而不要等到问题发生时才进行亡羊补牢的操作，殊不知可能会为时已晚。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;0&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;11&quot;&gt;11&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot; hm_fix=&quot;348:397&quot;&gt;面对模棱两可，拒绝猜测&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;计算机的世界是&lt;/span&gt;0&lt;span&gt;或&lt;/span&gt;1&lt;span&gt;的世界，是即是，非即非，没有不确定性的存在，也没有任何的猜测。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;对于编写的任何代码，都应该是清晰的，没有歧义的，若出现有歧义或不清晰的情形，那表明开发者对需要通过代码实现的问题理解不到位，或是有猜测的成分，这种都是需要杜绝的。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;0&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;12&quot;&gt;12&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot; hm_fix=&quot;339:394&quot;&gt; 解决问题最直接的方法应该有一种，最好只有一种&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;在编程的世界里，任何问题的解决办法都有多种，但更多的时候我们需要的是最直接的方法，并最好只有一种最直接的方法。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;如对编程语言的选择，对于科学计算和人工智能相关的事情，最直接的选择就是使用&lt;/span&gt;Python&lt;span&gt;，这个对于目前来说是最直接的唯一选择。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;0&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;13&quot;&gt;13&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;做也许好过不做，但不想就做，还不如不做&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;对于编程的过程，是一种知行合一的过程，光靠执行很多时候并不能得到期望的结果，还需要伴随思考的过程。越是大的项目，前期思考的时间占比就越多。在动手之前先做一些计划，对全盘先有一个大致了解，把可能遇到的问题，会存在的瓶颈，会占用时间比较多的步骤，需要协助的资源等先做一个前期的规划，会非常有利于后期的执行的。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;若期望一开始就撸起袖子直接干，那不是一个很建议的方法，除非你对需要做的事情已经非常熟悉，否则还是有必要认认真真想一想需要做什么。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;0&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;14&quot;&gt;14&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot; hm_fix=&quot;317:401&quot;&gt;&lt;p&gt;如果方案难以描述明白，那么一定是个糟糕的方案&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;对于编程来说，编写的应该是一个确定的事情，并且已经有可以描述明白的方案。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;对于不清晰的方案，编程上更不可能清晰。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;一个糟糕的方案只会诞生一个糟糕的项目，项目里面则包含各种晦涩的代码。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;0&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;15&quot;&gt;15&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot; hm_fix=&quot;348:393&quot;&gt;如果实现容易描述，那可能是个好方案&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;    &lt;span&gt;若一个实现可以通过类似伪代码的方式描述出来，这基本上是一个可行的方案，若可以通过伪代码容易的描述，那很有可能是个好方案，真实的应用上还有很多其它的外界因素，只有结合那些因素，才能完全的确定这是否是一个好的方案。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;0&lt;span data-original-title=&quot;&quot; title=&quot;&quot; data-num=&quot;16&quot;&gt;16&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot; hm_fix=&quot;341:398&quot;&gt;命名空间是一种绝妙的理念，多加利用&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;在编码的过程中，命名的冲突是一个非常需要小心的问题，这种问题一般不容易发现，出现问题时的查找并不容易，所以需要充分借助命名空间的理念，尽量避免如命名冲突的问题。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;通过命名空间控制变量的作用域，可以起到很好的变量的相互隔离的效果。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;结语：&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;编码是一件快乐的事情，特别当看到一些貌似不太可行的事情，通过编程的方式变为可行时，会感到一种发自内心深处的快乐。并且当一群人通过群策之力，完成一件艰巨的任务时，创造出一些&lt;/span&gt;amazing&lt;span&gt;的事情时，那是一种不可言喻的喜悦。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;而编写出如艺术般的代码需要付出很多，也需要经过时间的锤炼，但当它出现在大家眼前时，是需要一种心境的追求才可以企及，任何人都可以往这个方向追求，它没有任何标准，没有任何约束，有的只是你的不断创造，在计算机编程这块沃土上，还有一个超大的空间等待更多的人去开拓。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;新版&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;Python&lt;/span&gt;蟒蛇书重磅上市！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;助你&lt;/span&gt;&lt;span&gt;&lt;span&gt;系统掌握编写高效、优雅的&lt;/span&gt;Python&lt;span&gt;代码的方法&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;快速成长为一位高水平的&lt;/span&gt;Python&lt;span&gt;开发工程师&lt;/span&gt;&lt;/span&gt;&lt;span&gt;！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;限时&lt;span&gt;5&lt;/span&gt;折！单本包邮！&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;mpcps frameborder=&quot;0&quot; class=&quot;js_editor_cps&quot; data-datakey=&quot;1620787341085_0.7547334306610964&quot; data-uid=&quot;1620787341083&quot; data-type=&quot;1&quot; data-product=&quot;&quot; data-templateid=&quot;list&quot; data-pid=&quot;29233732&quot; data-categoryid=&quot;3&quot; data-appuin=&quot;3084391334&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;4.5720053835800805&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9fRTdvQaGDJVC7bbe3ztL0CUv6u1vic82vX5GcoanQPiapYLUTiabib1XcdcbSIniam6hd2A1HtYHQJW9bFrDZBgAgg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;福利&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;mpcps frameborder=&quot;0&quot; class=&quot;js_editor_cps&quot; data-datakey=&quot;1622014279280_0.7949213474253927&quot; data-uid=&quot;1622014279278&quot; data-type=&quot;1&quot; data-product=&quot;&quot; data-templateid=&quot;list&quot; data-pid=&quot;29233732&quot; data-categoryid=&quot;3&quot; data-appuin=&quot;3084391334&quot;/&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;mpcps frameborder=&quot;0&quot; class=&quot;js_editor_cps&quot; data-datakey=&quot;1622014279281_0.0842431751578605&quot; data-uid=&quot;1622014279279&quot; data-type=&quot;1&quot; data-product=&quot;&quot; data-templateid=&quot;list&quot; data-pid=&quot;13214688&quot; data-categoryid=&quot;3&quot; data-appuin=&quot;3208869061&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;感谢&lt;/span&gt;&lt;span&gt;机械工业出版社&lt;/span&gt;&lt;span&gt;赞助 2 本书给咱读者尝鲜，参与方式如下：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;给本文点&lt;/span&gt;&lt;span&gt;赞&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;在看&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;进入公众号回复&lt;/span&gt;&lt;span&gt;python之禅&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;等待开奖、取快递&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hs540iaTKoaI5P7ZgLtkuNMH9GnaB54RS0YndFmcgiaarptQVz5nssk6V0TLRibhskuP8LBvj69yBiaQqxBfk9lQbQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;长按 2秒 识别&lt;/p&gt;&lt;p&gt;&lt;span&gt;进入公众号回复&lt;/span&gt;&lt;span&gt;&lt;span&gt;python之禅&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d441d866ee5da7c0006e42c89660b07d</guid>
<title>看他就够了！一文带你全方面了解Apache Pulsar 延迟消息投递</title>
<link>https://toutiao.io/k/r2eynj9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                                    


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;56&quot; data-ratio=&quot;0.062037037037037036&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHVRXdlib6uFSXAGtIhnmSJfKSOibv1ESCPAOm4aydD55u05rIdZSnH1w5p6PCO6Gpz3icLzkjCWtJztw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1503268&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/dPkfGGYFSHXN9zzNy9ic0vpfTWhT860qOicRD03OMyWoTG5UJXz3B1NYVpdiaW0CmvEIuVMlMZCKuMJuEBkGZDxsw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;306&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;导语&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;Apache Pulsar 是一个多租户、高性能的服务间消息传输解决方案，支持多租户、低延时、读写分离、跨地域复制、快速扩容、灵活容错等特性。腾讯数据平台部 MQ 团队对 Pulsar 做了深入调研以及大量的性能和稳定性方面优化，目前已经在腾讯云消息队列 TDMQ 落地上线。本文主要介绍Pulsar延迟消息投递的实现，希望与大家一同交流。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7172996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXN9zzNy9ic0vpfTWhT860qOib757icGsNf1ibDZZPVPG1xJia1ibJvyOlE8JKqibFsrDmxyr78zZuvk0KfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;237&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;一、什么是延迟消息投递&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;延迟消息投递在MQ应用场景中十分普遍，它是指消息在发送到 MQ 服务端后并不会立马投递，而是根据消息中的属性延迟固定时间后才投递给消费者，一般分为定时消息和延迟消息两种：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前在业界，腾讯云的 CMQ 和阿里云的 RocketMQ 也都支持延迟消息投递：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;开源的 NSQ、RabbitMQ、ActiveMQ 和 Pulsar 也都内置了延迟消息的处理能力。虽然每个 MQ 项目的使用和实现方式不同，但核心实现思路都一样：&lt;strong&gt;Producer 将一个延迟消息发送到某个 Topic 中，Broker 将延迟消息放到临时存储进行暂存，延迟跟踪服务（Delayed Tracker Service）会检查消息是否到期，将到期的消息进行投递&lt;/strong&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.32634338138925295&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96XRBWQxSb1tueicMQbe2OibNqjdSXpokGvN1kZY6CMpOibZdreTXFKKt1UbfRPEOxbvib95er1osibIcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;763&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7172996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXN9zzNy9ic0vpfTWhT860qOib757icGsNf1ibDZZPVPG1xJia1ibJvyOlE8JKqibFsrDmxyr78zZuvk0KfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;237&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;二、延迟消息投递的使用场景&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;延迟消息投递是要暂缓对当前消息的处理，在未来的某个时间点再触发投递，实际的应用场景非常多，比如异常检测重试、订单超时取消、预约提醒等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TDMQ 最近就有个使用 Pulsar 延迟消息的 Case：业务要对两套系统的日志消息进行关联，其中一套系统由于查询 Hbase 可能会超时或失败，需要将失败的关联任务在集群空闲的时候再次调度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7172996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXN9zzNy9ic0vpfTWhT860qOib757icGsNf1ibDZZPVPG1xJia1ibJvyOlE8JKqibFsrDmxyr78zZuvk0KfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;237&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;三、如何使用Pulsar延迟消息投递&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Pulsar 最早是在 2.4.0 引入了延迟消息投递的特性，在 Pulsar 中使用延迟消息，可以精确指定延迟投递的时间，有 deliverAfter 和 deliverAt 两种方式。其中 deliverAt 可以指定具体的时间戳；deliverAfter 可以指定在当前多长时间后执行。两种方式的本质是一样的，Client 会计算出时间戳送到 Broker。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. deliverAfter发送&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;producer.newMessage()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        .deliverAfter(long time, TimeUnit unit)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        .send();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. deliverAt发送&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;producer.newMessage()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        .deliverAt(long timestamp)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        .send();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 Pulsar 中，可以支持跨度很大的延时消息，比方说一个月、半年；同时在一个 Topic 里，既支持延时消息，也支持非延时消息。下图展示了 Pulsar 中延迟消息的具体过程：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.257201646090535&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96XRBWQxSb1tueicMQbe2OibNzTfUYUwHQxXfNF6Bbc6Ba5xR7piarfoMzB7hyv04Ext9iaYrtGichuPGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;486&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;producer 发送的 m1/m3/m4/m5 有不同的延迟时间，m2 是不需要延迟投递的正常消息，consumer 消费时会根据不同的延迟时间进行 ack。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7172996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXN9zzNy9ic0vpfTWhT860qOib757icGsNf1ibDZZPVPG1xJia1ibJvyOlE8JKqibFsrDmxyr78zZuvk0KfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;237&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;四、Pulsar延迟消息投递实现原理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上面的使用方式可以看出，Pulsar 支持的是秒级精度的延迟消息投递，不同于开源 RocketMQ 支持固定时间 level 的延迟。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;316&quot; data-ratio=&quot;0.6751152073732719&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe96XRBWQxSb1tueicMQbe2OibNsQYWDz5uN9licZFoJRiaibPiaQhheCohBkckXcGsjA12iclqXzILibL7gqTw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;868&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Pulsar 实现延迟消息投递的方式比较简单，所有延迟投递的消息会被 Delayed Message Tracker 记录对应的 index。index 是由 timestamp | LedgerID | EntryID 三部分组成，其中 LedgerID | EntryID 用于定位该消息，timestamp 除了记录需要投递的时间，还用于 delayed index 优先级队列排序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Delayed Message Tracker 在堆外内存维护着一个 delayed index 优先级队列，根据延迟时间进行堆排序，延迟时间最短的会放在头上，时间越长越靠后。consumer 在消费时，会先去 Delayed Message Tracker 检查，是否有到期需要投递的消息，如果有到期的消息，则从 Tracker 中拿出对应的 index，找到对应的消息进行消费；如果没有到期的消息，则直接消费正常的消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果集群出现 Broker 宕机或者 topic 的 ownership 转移，Pulsar 会重建 delayed index 队列，来保证延迟投递的消息能够正常工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7172996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXN9zzNy9ic0vpfTWhT860qOib757icGsNf1ibDZZPVPG1xJia1ibJvyOlE8JKqibFsrDmxyr78zZuvk0KfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;237&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;五、Pulsar延迟消息投递面临的挑战&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从 Pulsar 的延迟消息投递实现原理可以看出，该方法简单高效，对 Pulsar 内核侵入性较小，可以支持到任意时间的延迟消息。但同时发现，Pulsar 的实现方案无法支持大规模使用延迟消息，主要有以下两个原因：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. delayed index队列受到内存限制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一条延迟消息的 delayed index 由三个 long 组成，对于小规模的延迟消息来说，内存开销并不大。但由于 index 队列是 subscription 级别，对于 topic 的同一个 partition 来说，有多少个 subscription 就需要维护多少个 index 队列；同时，由于延迟消息越多、延迟的时间越长，index 队列内存占用也会更多。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. delayed index队列重建时间开销&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面有提到，如果集群出现 Broker 宕机或者 topic 的 ownership 转移，Pulsar 会重建 delayed index 队列。对于跨度时间长的大规模延迟消息，重建时间可能会到小时级别。为了减小 delayed index 队列重建时间，虽然可以给 topic 分更多的 partition 提高重建的并发度，但没有彻底解决重建时间开销问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7172996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXN9zzNy9ic0vpfTWhT860qOib757icGsNf1ibDZZPVPG1xJia1ibJvyOlE8JKqibFsrDmxyr78zZuvk0KfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;237&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;六、Pulsar延迟消息投递未来工作&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Pulsar 目前的延迟消息投递方案简单高效，但处理大规模延迟消息时仍然存在风险。关于延迟消息投递，社区和数据平台部 MQ 团队下一步将聚焦在支持大规模延迟消息。目前讨论的方案是在 delayed index 队列加入时间分区，Broker 只加载当前较近的时间片 delayed index 到内存，其余时间片分区持久化磁盘，示例图如下图所示：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;339&quot; data-ratio=&quot;0.5945823927765237&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96XRBWQxSb1tueicMQbe2OibN6CdY9LjXB0fdUYpRrFU34iaYkoosSXmgJojQJsMytmP5Z5iahpJKxDww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2215&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图中，我们按 5 分钟的间隔对 delayed index 队列进行分区，m5 和 m1 放在了 time partition 1，由于延迟时间最近，放在了内存；m4 和 m3 在 time partition 2，延迟时间比较靠后，index 存储在了磁盘。该方案不仅可以减少 delayed index 队列重建时间开销，还可以降低对内存的依赖。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7172996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXN9zzNy9ic0vpfTWhT860qOib757icGsNf1ibDZZPVPG1xJia1ibJvyOlE8JKqibFsrDmxyr78zZuvk0KfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;237&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;结语&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文为大家介绍了延迟消息投递的相关概念和使用场景，并详细拓展了 Apache &lt;span&gt;Pulsar&lt;/span&gt; 的实现原理。&lt;span&gt;Pulsar 目前方案简单高效&lt;/span&gt;，&lt;span&gt;支持秒级精度的延迟消息投递&lt;/span&gt;，但在处理&lt;span&gt;大规模延迟消息时还有一些局限。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前腾讯云消息队列 TDMQ 上已上线了对 Pulsar 延迟消息投递的支持，Pulsar 社&lt;span&gt;区和数据平台部 MQ 团队下一步也将聚焦在支持大规模延迟消息&lt;/span&gt;上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;往期&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;推荐&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMTQ2NTA1Mg==&amp;amp;mid=2247487622&amp;amp;idx=1&amp;amp;sn=b94a383b06a6032a7ff893036a790b46&amp;amp;chksm=9b41e8b5ac3661a39cea9b2db1dd780787f6ed240b94a4cb52f841bd4c7d600795d0b23206f3&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《【精彩分享】腾讯云微服务平台的标准输出与落地实践》&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMTQ2NTA1Mg==&amp;amp;mid=2247487529&amp;amp;idx=1&amp;amp;sn=0442c7064633f05a0e4473adc12db530&amp;amp;chksm=9b41e81aac36610c7e040f88dcf37975498a6565e132c34211d51567ae5b74d6b3957b5cf4e0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《构建基于Service Mesh 的云原生微服务框架》&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMTQ2NTA1Mg==&amp;amp;mid=2247487524&amp;amp;idx=1&amp;amp;sn=4c205521bf49f517ef9230f1df377ed2&amp;amp;chksm=9b41e817ac366101a31740321c3921a6ac29c95bb8d77fb64dbb6a473433471ec027d75e8cfe&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《腾讯云中间件产品月报（2021年第1期）| 文末好礼送不停》&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;开奖&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;啦&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;恭喜以下小伙伴在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMTQ2NTA1Mg==&amp;amp;mid=2247487524&amp;amp;idx=1&amp;amp;sn=4c205521bf49f517ef9230f1df377ed2&amp;amp;chksm=9b41e817ac366101a31740321c3921a6ac29c95bb8d77fb64dbb6a473433471ec027d75e8cfe&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《腾讯云中间件产品月报（2021年第1期）| 文末好礼送不停》&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;活动中获赞 TOP 5 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;记得私聊小Q妹获得对应礼品噢&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;670&quot; data-backw=&quot;578&quot; data-ratio=&quot;1.1592592592592592&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dPkfGGYFSHXN9zzNy9ic0vpfTWhT860qOBrCVL3N3CELkEXCdHUicHxVGe7PRJjlVZV3vkS8J6NS67X6pswPUYbA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7083333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHWia32kFmaefMpOkDjzygcaXnDibFevLNTVkKPtYwvCQr4SQa6Ta1d2xYdwsiaOjdeeGRRtpBEVkFUicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;扫描下方二维码关注本公众号，&lt;/p&gt;&lt;p&gt;了解更多微服务、消息队列的相关信息！&lt;/p&gt;&lt;p&gt;解锁超多鹅厂周边！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;334&quot; data-ratio=&quot;0.5560488346281909&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXWa3qntCtcsFhOnLP26ERNdoiaX1SVaa3fWKpxLFQmBgwc9UOz5hoRzPicnvW7Fjyh3TianDRVbbic5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;901&quot;/&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;87578&quot;&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot; class=&quot;__bg_gif&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yqVAqoZvDibHW4ynpBjRrolMxOZtKTiaYgT0HG1BkTeIUjfS0zrwEYVMy6Fj54m58z6pH9yWNOnFkbflRtKVicx0w/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;戳原文，了解更多消息队列TDMQ的信息&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;87578&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94252&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.0740740740740742&quot; data-type=&quot;png&quot; data-w=&quot;81&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7QRTvkK2qC5ricrpxA0Tln6U4mt6c9God8owkFMgicqnvogW8znAX84Syp3PSlsnkPKnE2n4ZyZs8E73qZj6XgyA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;点亮&lt;span&gt;在看&lt;/span&gt;，你最好看&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5da2c69bfbd8faadc9d9ffb2719828f7</guid>
<title>超详细的秒杀架构设计，了解一下</title>
<link>https://toutiao.io/k/u3jnt92</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;58&quot; data-source-title=&quot;&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;作者：Yrion&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;链接：https://www.cnblogs.com/wyq178/p/11261711.html&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;秒杀系统相信很多人见过，比如京东或者淘宝的秒杀，小米手机的秒杀，那么秒杀系统的后台是如何实现的呢？我们如何设计一个秒杀系统呢？对于秒杀系统应该考虑哪些问题？如何设计出健壮的秒杀系统？本文我们就来探讨一下这个问题。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;秒杀应该考虑哪些问题&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;超卖问题&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;分析秒杀的业务场景,最重要的有一点就是超卖问题，假如备货只有100个，但是最终超卖了200，一般来讲秒杀系统的价格都比较低，如果超卖将严重影响公司的财产利益，因此首当其冲的就是解决商品的超卖问题。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;高并发&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;秒杀具有时间短、并发量大的特点，秒杀持续时间只有几分钟，而一般公司都为了制造轰动效应，会以极低的价格来吸引用户，因此参与抢购的用户会非常的多。短时间内会有大量请求涌进来，后端如何防止并发过高造成缓存击穿或者失效，击垮数据库都是需要考虑的问题。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;接口防刷&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;现在的秒杀大多都会出来针对秒杀对应的软件，这类软件会模拟不断向后台服务器发起请求，一秒几百次都是很常见的，如何防止这类软件的重复无效请求，防止不断发起的请求也是需要我们针对性考虑的。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;秒杀 URL&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;对于普通用户来讲，看到的只是一个比较简单的秒杀页面，在未达到规定时间，秒杀按钮是灰色的，一旦到达规定时间，灰色按钮变成可点击状态。这部分是针对小白用户的，如果是稍微有点电脑功底的用户，会通过F12看浏览器的network看到秒杀的url，通过特定软件去请求也可以实现秒杀。或者提前知道秒杀url的人，一请求就直接实现秒杀了。这个问题我们需要考虑解决。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;数据库设计&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;秒杀有把我们服务器击垮的风险，如果让它与我们的其他业务使用在同一个数据库中，耦合在一起，就很有可能牵连和影响其他的业务。如何防止这类问题发生，就算秒杀发生了宕机、服务器卡死问题，也应该让他尽量不影响线上正常进行的业务。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;大量请求问题&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;按照「高并发」的考虑，就算使用缓存还是不足以应对短时间的高并发的流量的冲击。如何承载这样巨大的访问量，同时提供稳定低时延的服务保证，是需要面对的一大挑战。我们来算一笔账，假如使用的是 Redis 缓存，单台 Redis 服务器可承受的 QPS 大概是 4W 左右，如果一个秒杀吸引的用户量足够多的话，单 QPS 可能达到几十万，单体 Redis 还是不足以支撑如此巨大的请求量。缓存会被击穿，直接渗透到 DB，从而击垮MySQL，后台会将会大量报错。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;秒杀系统的设计和技术方案&lt;/span&gt;&lt;/h3&gt;&lt;h4&gt;&lt;span&gt;秒杀系统数据库设计&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;针对「数据库设计」提出的秒杀数据库的问题，因此应该单独设计一个秒杀数据库，防止因为秒杀活动的高并发访问拖垮整个网站。这里只需要两张表，一张是秒杀订单表，一张是秒杀货品表。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08425925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNkaW9aL3SsTh9530XOB1jNKrzI28bBkaBoDEmibv3eTf0p4Ef7rlnzXuDDr0AVicCNoJ1iagASbXvXdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;其实应该还有几张表，商品表：可以关联goods_id查到具体的商品信息，商品图像、名称、平时价格、秒杀价格等，还有用户表：根据用户user_id可以查询到用户昵称、用户手机号，收货地址等其他额外信息，这个具体就不给出实例了。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;秒杀 URL 的设计&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;为了避免有程序访问经验的人通过下单页面url直接访问后台接口来秒杀货品，我们需要将秒杀的 URL 实现动态化，即使是开发整个系统的人都无法在秒杀开始前知道秒杀的URL 。具体的做法就是通过 md5 加密一串随机字符作为秒杀的 URL，然后前端访问后台获取具体的 URL，后台校验通过之后才可以继续秒杀。&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;秒杀页面静态化&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;将商品的描述、参数、成交记录、图像、评价等全部写入到一个静态页面，用户请求不需要通过访问后端服务器，不需要经过数据库，直接在前台客户端生成，这样可以最大可能的减少服务器的压力。具体的方法可以使用freemarker模板技术，建立网页模板，填充数据，然后渲染网页。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;单体 Redis 升级为集群 Redis&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;秒杀是一个读多写少的场景，使用 Redis 做缓存再合适不过。不过考虑到缓存击穿问题，我们应该构建 Redis 集群，采用哨兵模式，可以提升Redis的性能和可用性。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;使用 Nginx&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;Nginx 是一个高性能 Web 服务器，它的并发能力可以达到几万，而 Tomcat 只有几百。通过 Nginx 映射客户端请求，再分发到后台 Tomcat 服务器集群中可以大大提升并发能力。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;精简 SQL&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;典型的一个场景是在进行扣减库存的时候，传统的做法是先查询库存，再去update。这样的话需要两个SQL，而实际上一个SQL我们就可以完成的。可以用这样的做法：update miaosha_goods set stock =stock-1 where goos_id ={#goods_id} and version = #{version} and sock&amp;gt;0;这样的话，就可以保证库存不会超卖并且一次更新库存，还有注意一点这里使用了版本号的乐观锁，相比较悲观锁，它的性能较好。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;Redis 预减库存&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;很多请求进来，都需要后台查询库存,这是一个频繁读的场景。可以使用Redis来预减库存，在秒杀开始前可以在 Redis 设值，比如 redis.set(goodsId,100)，这里预放的库存为100可以设值为常量，每次下单成功之后，Integer stock = (Integer)redis.get(goosId); 然后判断 sock 的值，如果小于常量值就减去1；不过注意当取消的时候，需要增加库存，增加库存的时候也得注意不能大于之间设定的总库存数（查询库存和扣减库存需要原子操作，此时可以借助 lua 脚本）下次下单再获取库存的时候，直接从Redis里面查就可以了。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;接口限流&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;秒杀最终的本质是数据库的更新，但是有很多大量无效的请求，我们最终要做的就是如何把这些无效的请求过滤掉，防止渗透到数据库。限流的话，需要入手的方面很多：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;前端限流&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先第一步就是通过前端限流，用户在秒杀按钮点击以后发起请求，那么在接下来的5秒是无法点击（通过设置按钮为disable）。这一小举措开发起来成本很小，但是很有效。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;同一个用户xx秒内重复请求直接拒绝&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;具体多少秒需要根据实际业务和秒杀的人数而定，一般限定为10秒。具体的做法就是通过Redis的键过期策略，首先对每个请求都从 String value = redis.get(userId)；如果获取到这个 value 为空或者为 null，表示它是有效的请求，然后放行这个请求。如果不为空表示它是重复性请求，直接丢掉这个请求。如果有效，采用redis.setexpire(userId,value,10).value 可以是任意值，一般放业务属性比较好，这个是设置以 userId 为 key，10秒的过期时间（10秒后，key对应的值自动为null）。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;令牌桶算法限流&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;接口限流的策略有很多，我们这里采用令牌桶算法。令牌桶算法的基本思路是每个请求尝试获取一个令牌，后端只处理持有令牌的请求，生产令牌的速度和效率我们都可以自己限定，Guava 提供了 RateLimter 的 API 供我们使用。以下做一个简单的例子，注意需要引入Guava：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class TestRateLimiter {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public static void main(String[] args) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        //1秒产生1个令牌&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        final RateLimiter rateLimiter = RateLimiter.create(1);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        for (int i = 0; i &amp;lt; 10; i++) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            //该方法会阻塞线程，直到令牌桶中能取到令牌为止才继续向下执行。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            double waitTime= rateLimiter.acquire();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            System.out.println(&quot;任务执行&quot; + i + &quot;等待时间&quot; + waitTime);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.out.println(&quot;执行结束&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;上面代码的思路就是通过RateLimiter来限定我们的令牌桶每秒产生1个令牌（生产的效率比较低），循环10次去执行任务。acquire会阻塞当前线程直到获取到令牌，也就是如果任务没有获取到令牌，会一直等待。那么请求就会卡在我们限定的时间内才可以继续往下走，这个方法返回的是线程具体等待的时间。执行如下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34843205574912894&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNkaW9aL3SsTh9530XOB1jNKmz0JWzLD0FLVUSQ8xSQqUiaWhHEgHKrIDdPhib2dlxvcQrL82FdvChfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;574&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;可以看到任务执行的过程中，第1个是无需等待的，因为已经在开始的第1秒生产出了令牌。接下来的任务请求就必须等到令牌桶产生了令牌才可以继续往下执行。如果没有获取到就会阻塞（有一个停顿的过程）。不过这个方式不太好，因为用户如果在客户端请求，如果较多的话，直接后台在生产token就会卡顿（用户体验较差），它是不会抛弃任务的，我们需要一个更优秀的策略：如果超过某个时间没有获取到，直接拒绝该任务。接下来再来个案例：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class TestRateLimiter2 {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public static void main(String[] args) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        final RateLimiter rateLimiter = RateLimiter.create(1);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        for (int i = 0; i &amp;lt; 10; i++) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            long timeOut = (long) 0.5;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            boolean isValid = rateLimiter.tryAcquire(timeOut, TimeUnit.SECONDS);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            System.out.println(&quot;任务&quot; + i + &quot;执行是否有效:&quot; + isValid);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            if (!isValid) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                continue;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            System.out.println(&quot;任务&quot; + i + &quot;在执行&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        System.out.println(&quot;结束&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;其中用到了tryAcquire方法，这个方法的主要作用是设定一个超时的时间，如果在指定的时间内预估（注意是预估并不会真实的等待），如果能拿到令牌就返回true，如果拿不到就返回false。然后我们让无效的直接跳过，这里设定每秒生产1个令牌，让每个任务尝试在0.5秒获取令牌，如果获取不到，就直接跳过这个任务（放在秒杀环境里就是直接抛弃这个请求）。程序实际运行如下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3380503144654088&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNkaW9aL3SsTh9530XOB1jNKboyJ92uia3phR1CWtmaWwicvDGXmvuchh6WlIRUx6ffRiaNfo34t0Bz7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;636&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;只有第1个获取到了令牌，顺利执行了，下面的基本都直接抛弃了，因为0.5秒内，令牌桶（1秒1个）来不及生产就肯定获取不到返回false了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个限流策略的效率有多高呢？假如我们的并发请求是400万瞬间的请求，将令牌产生的效率设为每秒20个，每次尝试获取令牌的时间是0.05秒，那么最终测试下来的结果是，每次只会放行4个左右的请求，大量的请求会被拒绝，这就是令牌桶算法的优秀之处。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;异步下单&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;为了提升下单的效率，并且防止下单服务的失败。需要将下单这一操作进行异步处理。最常采用的办法是使用队列，队列最显著的三个优点：异步、削峰、解耦。这里可以采用 RabbitMQ，在后台经过了限流、库存校验之后，流入到这一步骤的就是有效请求。然后发送到队列里，队列接受消息，异步下单。下完单，入库没有问题可以用短信通知用户秒杀成功。假如失败的话，可以采用补偿机制，重试。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;服务降级&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;假如在秒杀过程中出现了某个服务器宕机，或者服务不可用，应该做好后备工作。之前的博客里有介绍通过Hystrix进行服务熔断和降级，可以开发一个备用服务，假如服务器真的宕机了，直接给用户一个友好的提示返回，而不是直接卡死，服务器错误等生硬的反馈。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;秒杀流程图：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4666666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/A1HKVXsfHNkaW9aL3SsTh9530XOB1jNKLJ6LrOVNYvUOu0Ssd2g4MWFnLlEDVaicGFrIpYD8HDiaKQ3zJYIkSrRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;这就是我设计出来的秒杀流程图，当然不同的秒杀体量针对的技术选型都不一样，这个流程可以支撑起几十万的流量，如果是成千万破亿那就得重新设计了。比如数据库的分库分表、队列改成用Kafka、Redis增加集群数量等手段。通过本次设计主要是要表明的是我们如何应对高并发的处理，并开始尝试解决它，在工作中多思考、多动手能提升我们的能力水平，加油！如果本篇博客有任何错误，请麻烦指出来，不胜感激。&lt;/span&gt;&lt;/section&gt;&lt;figure&gt;&lt;span&gt;--- EOF ---&lt;/span&gt;&lt;br/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;推荐↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI4MDEwNzAzNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/zYdZKiaLibic67sHnnpIbiaUZ4RWpClUiavPRn5ib37s9hNEnQE4dUca89nsFQV5kzibFwzAgBlcWmHXY53a8ouOEdnKQ/0?wx_fmt=png&quot; data-nickname=&quot;Linux学习&quot; data-alias=&quot;LoveLinux1024&quot; data-signature=&quot;专注分享Linux/Unix相关内容，包括Linux命令、Linux内核、Linux系统开发、Linux运维、网络编程、开发工具等Linux相关知识和技术&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>