<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>59c01526d57395228d80f47c441110a6</guid>
<title>为什么放弃 Kafka，选择 Pulsar?</title>
<link>https://toutiao.io/k/wxrneux</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Spring Boot 作为主流微服务框架，拥有成熟的社区生态。市场应用广泛，为了方便大家，整理了一个基于spring boot的常用中间件快速集成入门系列手册，涉及RPC、缓存、消息队列、分库分表、注册中心、分布式配置等常用开源组件，大概有几十篇文章，陆续会开放出来，感兴趣同学请提前关注&amp;amp;收藏&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Pulsar 介绍&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 是 Yahoo 在 2013 年创建的，2016年贡献给了 Apache 基金会，目前已经是 Apache 的顶级项目。Yahoo、Verizon、Twitter 等很多公司都在使用 Pulsar 来处理海量消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 声称比 Kafka 更快、运行成本更低、解决了很多 Kafka 的痛点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 非常灵活，可以像&lt;code&gt;Kafka&lt;/code&gt; 一样作为分布式日志系统，也可以作为类似&lt;code&gt;RabbitMQ&lt;/code&gt; 这类简单的消息系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 有多种订阅类型、传递保障、保存策略。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;特性&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同的团队可以使用同一个集群，互相隔离。支持隔离、认证授权、配额。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 使用特定的数据层来存储 topic 数据，使用了 Apache BookKeeper 作为数据账本。Broker 与存储分离。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用分隔机制可以解决集群的扩展、再平衡、维护等问题。也提升了可用性，不会丢失数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为使用了多层架构，对于 topic 数量没有限制，topic 与存储是分离的，也可以创建非持久化的 topic。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 中存储是很昂贵的，所以很少存储冷数据。Pulsar 使用了多层存储，可以自动把旧数据移动到专门的存储设备，例如 Amazon S3，但是对于客户端来讲是透明的，还可以正常使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar Function 是一种部署简单，轻量级计算、对开发人员友好的 API，无需像 Kafka 那样运行自己的流处理引擎。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内置了代理、多租户安全机制、可插入的身份验证等功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;partition 被分为了小块儿，所以再平衡时非常快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如 Kafka、RabbitMQ 等系统都可以轻松集成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如 Go、Java、Scala、Node、Python 等等&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么选择 Pulsar&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前业界使用比较多的是 Kafka，主要场景是大数据日志处理，较少用于金融场景。RocketMQ 对 Topic 运营不太友好，特别是不支持按 Topic 删除失效消息，以及不具备宕机 Failover 能力。选 Pulsar 是因为其原生的高一致性，基于 BookKeeper 提供高可用存储服务，采用了存储和服务分离架构方便扩容，同时还支持多种消费模式和多域部署模式。Kafka、RocketMQ 和 Pulsar 的对比如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7586705202312138&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3Ohm6WHibeXLb8xCP32L8huVaUIW7nm3GfctVQTmqQrKEEKOp1PxibWnCDgbzAhleXsmaY4F807U3iaMJveRPSdqw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;692&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;Show me the code&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;外部依赖：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 pom.xml 中添加 Pulsar 依赖：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;org.apache.pulsar&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;pulsar-client&amp;lt;/artifactId&amp;gt;&lt;br/&gt;    &amp;lt;version&amp;gt;2.4.0&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;配置文件：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在配置文件 &lt;code&gt;application.yaml&lt;/code&gt;中配置 Pulsar 的相关参数，具体内容如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;pulsar:&lt;br/&gt;  service:&lt;br/&gt;    url: pulsar://127.0.0.1:6650&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Producer 发送消息：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产端提供了一个restful接口，模拟发送一条创建新用户消息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Long id = Long.valueOf(new Random().nextInt(1000));&lt;br/&gt;User user = User.builder().id(id).userName(&lt;span&gt;&quot;TomGE&quot;&lt;/span&gt;).age(29).address(&lt;span&gt;&quot;上海&quot;&lt;/span&gt;).build();&lt;br/&gt;userPulsarMsgProducer.send(user);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内部通过 &lt;code&gt;@PostConstruct&lt;/code&gt; 在应用启动时，初始化&lt;code&gt;org.apache.pulsar.client.api.Producer&lt;/code&gt;实例，并交由spring 容器统一管理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public void send(T msg) {&lt;br/&gt;    String msgBody = JSON.toJSONString(msg);&lt;br/&gt;    try {&lt;br/&gt;        MessageId messageId = producer.send(msgBody.getBytes(StandardCharsets.UTF_8));&lt;br/&gt;        log.info(&lt;span&gt;&quot;pulsar msg send success, topic:{}, messageId:{}, msg:{}&quot;&lt;/span&gt;, getTopic(), messageId, msgBody);&lt;br/&gt;    } catch (Throwable e) {&lt;br/&gt;        log.error(&lt;span&gt;&quot;pulsar msg send failed, topic:{}, msg:{}&quot;&lt;/span&gt;, getTopic(), msgBody);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Producer 发送延迟消息：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;适用于一些有&lt;code&gt;延迟处理&lt;/code&gt;要求的业务场景，比如电商交易的&lt;code&gt;自动确认收货&lt;/code&gt;，在卖家发出货品后，有15天的观察期，这期间如果买家没有发起逆向流程/申请退款，将会由系统自动触发&lt;code&gt;超时确认收货&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同业务场景，设定不同的延迟时间值，可以让消费端在延迟指定时间后才能拉取到消息并进行消费。借助于该框架特性，有效节省开发成本和难度。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;producer.newMessage().deliverAfter(delay, unit)&lt;br/&gt;        .value(msgBody.getBytes(StandardCharsets.UTF_8))&lt;br/&gt;        .send();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Consumer 消费消息：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;系统启动时，自动创建consumer消费实例，并埋入&lt;code&gt;org.apache.pulsar.client.api.MessageListener&lt;/code&gt;接口实现，用于具体的消息消费处理逻辑。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@PostConstruct&lt;br/&gt;void init() throws PulsarClientException {&lt;br/&gt;    consumer = client.createConsumer(getTopic(), getSubscriptionName(), new DefaultJsonMsgListener());&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt; class DefaultJsonMsgListener implements MessageListener&amp;lt;byte[]&amp;gt; {&lt;br/&gt;&lt;br/&gt;        @Override&lt;br/&gt;        public void received(Consumer&amp;lt;byte[]&amp;gt; consumer, Message&amp;lt;byte[]&amp;gt; message) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (null != message &amp;amp;&amp;amp; null != message.getData() &amp;amp;&amp;amp; message.getData().length != 0) {&lt;br/&gt;                String msgBody = new String(message.getValue(), StandardCharsets.UTF_8);&lt;br/&gt;&lt;br/&gt;                log.warn(&lt;span&gt;&quot;topic:{} receive message:{}&quot;&lt;/span&gt;, getTopic(), msgBody);&lt;br/&gt;                try {&lt;br/&gt;                    T msg = JSON.parseObject(msgBody, clazzT);&lt;br/&gt;                    handleMsg(msg);&lt;br/&gt;                } catch (Exception e) {&lt;br/&gt;                    log.error(&lt;span&gt;&quot;handle msg failed, topic:{}, message:{}&quot;&lt;/span&gt;, getTopic(), msgBody, e);&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            try {&lt;br/&gt;                // 提交消费位移&lt;br/&gt;                consumer.acknowledge(message);&lt;br/&gt;            } catch (PulsarClientException e) {&lt;br/&gt;                log.error(&lt;span&gt;&quot;topic:{} ack failed&quot;&lt;/span&gt;, getTopic(), e);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;/code&gt;&lt;/pre&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2&gt;&lt;span&gt;演示代码地址&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;https://github.com/aalansehaiyang/spring-boot-bulking  &lt;br/&gt;&lt;br/&gt;模块：spring-boot-bulking-pulsar&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9f3cf9678bb7065369cffe0483b71728</guid>
<title>协程切换会引起什么问题</title>
<link>https://toutiao.io/k/xkhaihd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section class=&quot;post&quot;&gt;
&lt;p&gt;在微信的业务中协程被大规模应用，在使用的过程中遇到了一些和业务场景相关的问题。本文自下而上从 CPU 中断到 Linux 内核态、再到用户态进程、最后到协程，由这种视角去分析协程切换时引起问题的原因，希望可以更好地理解协程。&lt;/p&gt;

&lt;p&gt;计算机里有两类大的资源：CPU 资源和 IO 资源。计算型的任务主要消耗 CPU 资源，比如对字符串进行 base64 编码，我之前遇到 3W/min 的线上接口加了 base64 编码把 CPU 跑满；输入输出类的系统调用主要消耗 IO 资源，部分 IO 和硬件中断相关。CPU 芯片引脚上接入了很多控制芯片，比如中断控制器芯片 8259A。当键盘打字，中断芯片触发 CPU 上的硬件中断，CPU 被调度来处理键盘输入。&lt;/p&gt;

&lt;p&gt;计算机上有这么多的任务需要消耗 CPU 和 IO 资源，操作系统怎么去优化资源利用呢？&lt;/p&gt;

&lt;p&gt;对于计算密集型任务，可以用多进程/线程将任务分发到不同的 CPU 核上并行处理来提高效率；对于 IO 密集型任务，操作系统已经有中断回调机制，对于正在到来的 IO 事件进行处理。&lt;/p&gt;

&lt;hr/&gt;

&lt;h2 id=&quot;中断机制&quot;&gt;中断机制&lt;/h2&gt;

&lt;p&gt;外围硬件设备连接到中断控制器芯片上，产生的电信号经过中断控制器芯片编码后写到 CPU 的控制寄存器中。那 CPU 怎么知道寄存器发生了改变？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当执行了一条指令后，cs 和 eip 这对寄存器包含了下一条将要执行的指令的逻辑地址。在处理那条指令之前，控制单元会检查在运行前一条指令时是否已经发生了一个中断或异常，如果发生了一个中断或异常，那么控制单元执行下列操作 ——「深入理解 linux 内核」&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;也就是 CPU 在每个指令周期都会去查看中断寄存器，这是硬件级别的轮询。用这种轮询来实现了中断控制，这种中断回调存在于内核态。&lt;/p&gt;

&lt;hr/&gt;

&lt;h2 id=&quot;操作系统之上再造系统&quot;&gt;操作系统之上再造系统&lt;/h2&gt;

&lt;p&gt;业务的进程中，既需要使用 CPU，又需要使用大量 IO。怎么去优化这种场景？&lt;/p&gt;

&lt;p&gt;在进程中再开线程？在线程中出现 IO 调用时（主要讨论同步 IO，Linux 中还没有完善的异步 IO），让线程睡眠，让其他的线程去处理任务。假设现在 8 核 CPU 上有 4 个进程，每个进程开 10 个线程，理论上也只能同步并行跑 8 个线程，其他线程都是假性的并行运行。如果这时出现大量的阻塞 IO 调用，所有的线程都会进入睡眠，等待同步 IO 的数据返回；如果是非阻塞 IO 调用（O_NONBLOCK），使用 poll/epoll 来轮询事件到来，虽然不会进入睡眠，但线程不断从内核态到用户态的上下文切换效率较低。&lt;/p&gt;

&lt;p&gt;有什么办法可以让用户态的进程/线程中拥有一种异步回调的能力，在发生 IO 调用时切换到其他进程/线程，又能保证不睡眠进入内核态。在 IO 事件到来时，再切换回这个进程/线程，整个过程都是在用户态完成。这相当于在操作系统上重新造了一个操作系统来进行进程/线程调度，梦境之上再造梦境。&lt;/p&gt;

&lt;hr/&gt;

&lt;h2 id=&quot;协程是什么&quot;&gt;协程是什么&lt;/h2&gt;

&lt;p&gt;想象一个人进入到进程中，现在有两个子函数：一个函数负责倒开水，一个函数负责晾衣服。当人看到开水烧开了，调用函数去倒开水；当看到衣服洗好了，调用函数晾衣服。这个人就是程序员本人，他来负责子程序的调度。子程序就是协程，这个人就是程序员本人，可以看作是人肉协程调度器。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Huangtuzhi/ucoroutine/blob/master/ucoroutine.cpp&quot;&gt;ucoroutine&lt;/a&gt; 是一个协程调度的示例，使用 Linux getcontext、makecontext、swapcontext 函数簇来实现协程切换。&lt;/p&gt;

&lt;p&gt;那么人肉调度器可以由什么来自动化替代呢？这个调度器需要实现这些功能&lt;/p&gt;



&lt;p&gt;比如对于网络应用场景，hook 掉 socket 簇 read、write、connect、send、recv 函数，让这些函数调用时发生用户态协程切换，同时记录下相应的上下文信息&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;加入异步回调机制，在 IO 事件到来时回调到事件对应的处理协程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个东西是不是可以用 epoll 实现？在 IO 调用时把事件注入到 epoll 事件池，同时发生协程切换，等 IO 事件到来时由主协程用 epoll 去回调切换到对应的协程。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;void ucoroutine_body(schedule_t *ps)
{
int id = ps-&amp;gt;running_coroutine;

if (id != -1) {
ucoroutine_t *t = &amp;amp;(ps-&amp;gt;coroutines[id]);
t-&amp;gt;func(t-&amp;gt;arg);
// 模拟函数阻塞，进行调度。在这里将事件注入到了 epoll 中即可
puts(&quot;before yield&quot;);
ucoroutine_yield(*ps);
puts(&quot;after yield&quot;);
t-&amp;gt;state = IDLE;
ps-&amp;gt;running_coroutine = -1;
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就实现了用户态的操作系统。&lt;/p&gt;

&lt;p&gt;常见的协程库实现有三种方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用 glibc 的 ucontext 库&lt;/li&gt;
  &lt;li&gt;使用汇编代码切换上下文，微信 libco 使用这种方式&lt;/li&gt;
  &lt;li&gt;利用 C 语言的 setjmp 和 longjmp&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些方式的原理都是通过保存和恢复寄存器的状态，来进行各协程上下文的保存和切换。&lt;/p&gt;

&lt;hr/&gt;

&lt;h2 id=&quot;切换引起的问题&quot;&gt;切换引起的问题&lt;/h2&gt;

&lt;p&gt;在使用 libco 时，已 hook 掉所有的 socket read/write/send/recv 系统调用，在发生这些系统调用时，libco 会切换协程，将当前的上下文保存，切换到其他协程使用 CPU。所以在业务代码中发起 RPC 调用会触发协程切换，这种切换会引起一些问题。&lt;/p&gt;

&lt;h4 id=&quot;问题-1幻读&quot;&gt;问题 1：”幻读“&lt;/h4&gt;

&lt;p&gt;最近在进行一个项目的改造，有这样一段代码&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;m_config = config; // 进程变量
m_config-&amp;gt;cmdid() = 100; // 这个值根据请求不同会变化

id_a = m_config-&amp;gt;cmdid()
CallRPC()
id_b = m_config-&amp;gt;cmdid()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个代码段有多个协程共用，最后发现 id_a != id_b，出现了”幻读“问题。&lt;/p&gt;

&lt;p&gt;这是因为 CallRPC 时会发生协程切换，等再次切换回来，cmdid 已经被其他协程修改了。&lt;/p&gt;

&lt;p&gt;使用协程原则：全局变量和静态变量为所有协程共享，不要使用全局变量，静态变量。&lt;/p&gt;

&lt;h4 id=&quot;问题-2死锁&quot;&gt;问题 2：死锁&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NoticeConfig::NoticeConfig()
{
CallRPC();
}

NoticeConfig* NoticeConfig::GetDefault()
{
static NoticeConfig conf; // 卡在这里
return &amp;amp;conf;
}

func()
{
auto conf = NoticeConfig::GetDefault();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;协程 A 中 func 调用 GetDefault 获取单例，GetDefault 中初始化 conf 时，构造函数调用了 RPC 发生了协程切换，CPU 让给协程 B。而对于 static 变量，gcc 在构造时会加锁，所以 A 获得了这把锁。当协程 B 调用 func 时，conf 还没初始化完成，会尝试再次加锁。所以其他协程都会卡死在这里。&lt;/p&gt;

&lt;p&gt;这种场景出现需要满足两个条件&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;构造函数中加了 RPC 操作&lt;/li&gt;
  &lt;li&gt;用 static 来实现单例&lt;/li&gt;
&lt;/ul&gt;

&lt;hr/&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;从上面的分析可以知道协程的使用场景&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;频繁发生 RPC 调用，可以最大程度使用协程的能力。相比线程节省系统资源&lt;/li&gt;
  &lt;li&gt;非计算密集型任务，CPU 计算不复杂。CPU 计算会占用大量时间，会让协程占用 CPU 时间过长，影响其他协程正常运行。同理 sleep 也不能使用，会让进程睡眠而无法进行切换，使用 poll(NULL, 0, sec) 代替。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外操作系统中存在这三种层次的回调&lt;/p&gt;

&lt;p&gt;1、硬件设备往内核态的回调通过硬件中断实现&lt;/p&gt;

&lt;p&gt;2、内核态往用户态的回调通过睡眠队列唤醒 + 进程切换实现&lt;/p&gt;

&lt;p&gt;3、用户态中进程/线程往协程的回调通过协程调度器（epoll）实现&lt;/p&gt;

&lt;hr/&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Tencent/libco&quot;&gt;微信 libco&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/80206565&quot;&gt;一次系统调用开销到底有多大？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://sites.google.com/site/polarisnotme/linux/gcc&quot;&gt;GCC 优化编译指南&lt;/a&gt;&lt;/p&gt;

                          
&lt;/section&gt;



&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4103c399710dbdade8475a2b5cb3e864</guid>
<title>架构模式之分层架构总结</title>
<link>https://toutiao.io/k/fwtxydd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个问题，我们要把它搞清楚。需要深入的思考，从演进出发，从核心出发，探索它的本质。这样才能在工作中举一反三。探索本质的思想，对于架构者来说尤其重要。本文想探讨架构模式之分层设计的本质和核心。以便于更好的将正确的方式应用到项目中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;为什么分层&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;三层架构，多层架构我们听到的很多，那有没有考虑过为什么需要分层呢？不分不是更简单更方便吗，何必大费周折搞出一个分层架构？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;举一个例子，如果我们开一个饭店，一个人把采购，炒菜，上菜全部做了，一个月也有不错的收入。只是会比较忙，很辛苦。因为自己的能力毕竟有限，有时候也会把事情搞错，再比如哪天生病了，生意就没法做了。当人多了的时候就忙不过来了，大批的顾客就会跑到别人的饭店。这时候，我们就会考虑雇人，人多了就会考虑分工的问题，有的负责采购，有的负责炒菜，有的负责上菜，这样实际分层就产生了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分层本质是解耦和分类，解决职责不清的耦合问题，解决职责过大不利于发展的问题，在分层的基础上为团队分工和协作提供了依据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分层的好处&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;隔离业务复杂度和技术复杂度，可独立变化发展&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;职责清晰，减少耦合，提高复用性，可维护性，扩展性（部分）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;3、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;有利于团队分工协作&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分层的不足&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;代码理解的复杂度高了&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;性能低了，原本一次完成的事情，需要调多层实现&lt;/span&gt;&lt;/p&gt;&lt;p&gt;3、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;管理成本高了，需要考虑每层的边界，代码结构和团队情况&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;如何分层&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;         &lt;span&gt;分层设计也是一种抽象的思想，每层代表一个关注点，多层之间的协作实现了整个调用链路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;1、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;基于职责（关注点）不同进行分层&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;基于变化的程度进行分层&lt;/span&gt;&lt;/p&gt;&lt;p&gt;3、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;同一抽象层次的组件放在同一层&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分层中的设计思想&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果用一句话描述的话，个人理解的就是高内聚，松耦合。展开讲的话有以下几点&lt;/span&gt;&lt;/p&gt;&lt;p&gt;1、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;单一职责原则，分离关注点，每个层的职责是单一的，只做一类事情；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;开闭原则：隔离变化，对扩展开放，对修改关闭；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;3、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;依赖倒置原则：基于接口（抽象）编程，层与层之间的调用都应该依赖抽象而不是具体。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分层的方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;         &lt;span&gt;一般讲的都是逻辑分层，实际也存在物理层面进行分层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;物理分层（&lt;/span&gt;Tier&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要从物理元素切入，个人理解从物理层面有两类，一类从部署的角度考虑，一类从项目结构角度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从部署角度考虑，典型的&lt;/span&gt;J2EE N Tire&lt;span&gt;架构，如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4935064935064935&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UHKG18j8iasYnpqicm3vOlKZoFDg2DAFLCEGFAicp5KR5MN1aW4KibL6taEZiaz7mn5QAfSoMAia2ibd4R3eVmolecWXw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;770&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大型分布式系统的分层（简化版），如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9141630901287554&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UHKG18j8iasYnpqicm3vOlKZoFDg2DAFLCnFzxy5SbEFPxPGPp6ficoLF2njWBSmibeNU7nAib4MLDxAA3NuSAiaPKRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;466&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从项目结构考虑（很少有人这么讲）&lt;/span&gt;1&lt;span&gt;、项目的分包结构；&lt;/span&gt;2&lt;span&gt;、&lt;/span&gt;maven&lt;span&gt;中的父子项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;逻辑分层（&lt;/span&gt;Layer&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;         &lt;span&gt;大家常见的分层方式，典型的有三层，四层，七层，如下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.3875968992248062&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UHKG18j8iasYnpqicm3vOlKZoFDg2DAFLCVWtdL880OPRMgYMdqnolpvTiaOUib6E4IXuUd3b08uskX3s7hqxibicpKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;516&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中三层和四层从结构上看相差不大，主要是在三层数据访问层的基础上，扩展了如服务，设备等的调用。但是从架构层面，已经有比较大的改进。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;一个架构设计到这个程度就可以了吗？远远不够，下一步需要对分层架构进行细化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分层详解&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在做设计的时候，需要将每一个组件，每一个角色落地，让各个参与者都能清楚，明白。以四层架构为例，详细介绍每层的关注点和设计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;1、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;明确各层的关注点和职责。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9356223175965666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UHKG18j8iasYnpqicm3vOlKZoFDg2DAFLCl04zZsIayiaG7dbn85JS5v29SHlZOkBknWicQp9oGyLr5ymqTsf9gCpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;466&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）&lt;/span&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;表现层&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注点：&lt;/span&gt;&lt;span&gt;用户交互和页面渲染&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;职责：&lt;/span&gt;&lt;span&gt;接收用户输入，调用业务逻辑层，接收业务逻辑返回实现页面渲染。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）&lt;/span&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;业务逻辑层&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注点：领域模型和&lt;/span&gt;&lt;span&gt;业务逻辑&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;职责：&lt;/span&gt;&lt;span&gt;系统的核心部分，实现业务逻辑和业务规则，实现事务控制，调用资源访问层；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）&lt;/span&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;资源整合层：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注点：&lt;/span&gt;&lt;span&gt;各类资源的调用和隔离&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;职责：&lt;/span&gt;&lt;span&gt;整合数据访问（读写），整合外部接口，整合设备交互。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;明确各层的设计（代码级）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;671&quot; data-ratio=&quot;1.159744408945687&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UHKG18j8iasYnpqicm3vOlKZoFDg2DAFLCaqDGia7IGGEaV3Q3XWdws8uEN18lmom1EwJEhcW8iciaLFPplWDb7UnIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;626&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    上图已经把代码层面的组件画出来了，按照这个方案就可以进行开发了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;（1）&lt;/span&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;VO&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;BO&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Entity&lt;/span&gt;&lt;span&gt;可以使用同一套实体类也可以分开，比较推荐的做法是&lt;/span&gt;&lt;span&gt;VO&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;BO&lt;/span&gt;&lt;span&gt;使用一套，&lt;/span&gt;&lt;span&gt;Entity&lt;/span&gt;&lt;span&gt;使用一套。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;（2）&lt;span&gt;      &lt;/span&gt;&lt;span&gt;业务逻辑层：抽象了&lt;/span&gt;Logic&lt;span&gt;接口，用于定义每个服务方法的步骤，该部分会有一些通用的&lt;/span&gt;Logic&lt;span&gt;用于多个服务方法复用。&lt;/span&gt;Service&lt;span&gt;会调用具体的&lt;/span&gt;Logic&lt;span&gt;实现逻辑逻辑，达到了最大程度的解耦和复用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;业务逻辑层：对于&lt;/span&gt;&lt;span&gt;Logic&lt;/span&gt;&lt;span&gt;内复用的，可以下沉到&lt;/span&gt;&lt;span&gt;Manager&lt;/span&gt;&lt;span&gt;中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;（4）&lt;/span&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;业务逻辑层：还可以在&lt;/span&gt;&lt;span&gt;Servide&lt;/span&gt;&lt;span&gt;的基础上封装一层&lt;/span&gt;&lt;span&gt;Façade&lt;/span&gt;&lt;span&gt;，用于聚合多个&lt;/span&gt;&lt;span&gt;Servie&lt;/span&gt;&lt;span&gt;方法的调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（5）资源整合层：包含传统的数据库访问层结构和，调用接口的实现。调用接口使用代理模式实现，隔离了外部差异。复杂的话，可以考虑使用策略+适配器的方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;3、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;层之间的调用关系&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    标准的调用是严格按照上次调用下层的顺序，实际也可以跨层调用（根据团队规范，约定好）。&lt;/span&gt;&lt;span&gt;但是，应避免循环调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.1612903225806452&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UHKG18j8iasYnpqicm3vOlKZoFDg2DAFLCoAPc3IzRNlejb0ibIrwoZkhVU0QyzfI7AvMicZhWAczKFNhWktSnDAcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;341&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;物理分层与逻辑分层的关系&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;        &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.773371104815864&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UHKG18j8iasYnpqicm3vOlKZoFDg2DAFLCoViawUz3q20A4wriafspocRib6pV0X7C5kZTYb50q90rdUql1a6ibkjkCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;706&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;逻辑架构会以不同的方式，表现到物理架构中。拿分层来讲，常见的方式有全部逻辑分层一起部署，逻辑分层部分分开部署和逻辑分层完全分开部署。分开部署后会涉及到&lt;/span&gt;RPC&lt;span&gt;调用和服务高可用等问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;文章总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;         分层架构是项目中用到的最多的架构模式之一，核心思想是归类和解耦，实现有多种方式，不应局限于三层，四层，也可能是两层，五层，六层，具体以实际的项目为准。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;          本文希望由浅入深的介绍分层相关的知识，使大家不仅知道分层，还知道为什么分，怎么分。从概念到落地是架构师必须跨过的一道坎。通过了这个坎就可以将架构知识灵活的运用到项目中，实现能力的升华，成为真正的架构师。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;           实际每一层还会有一些变化，不同的设计模式和架构模式实现的分层和代码的组织方式也是不同的，没有完全一样的架构，合适的就是最好的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dbf33734ebfd118f37f9fae450ccab39</guid>
<title>JavaScript 垃圾回收策略</title>
<link>https://toutiao.io/k/i8pbfyr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;blockquote&gt;&lt;p&gt;前段时间，面了不少公司，不少面试官都会问到JavaScript垃圾回收。说实话，平时还真的了解不多，最近正在看“JavaScript高级程序设计”，从头把基础再巩固下。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;JavaScript 是使用垃圾回收的语言，通过自动内存管理实现内存分配和闲置资源回收。基本思路很简单：&lt;span&gt;垃圾收集器会按照固定的时间间隔或代码执行中预定的收集时间，周期性地执行操作--找出不再继续使用的变量，然后释放其占用的内存&lt;/span&gt;。如何找出不再继续使用的变量，浏览器发展怎么多年，出现了几种不同的实现方案，标记清理和引用计数。今天简单说说 JavaScript 最常用的垃圾回收策略 -【标记清理】。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;标记清理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;标记清理（mark-and-sweep）。当变量进入上下文，比如在函数内部声明一个变量时，&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; a = 1&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以手动释放：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; a = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 释放&lt;/span&gt;&lt;br/&gt;a = &lt;span&gt;null&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，关键是策略。垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还有种不太常用的垃圾回收策略-引用计数（reference counting）。引用计数的含义是跟踪记录每个值被引用的次数。由于不太常用，我们这里就不多介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面的内容，基本可以在“JavaScript高级程序设计”找到，感兴趣的可以读一读这本书，收获还是蛮大的，之后有时间，我会把书中的知识点整理，总结在公众号中，现在已经整理了一部分，后期会不定时更新。&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;我坚信，赞赏是不耍流氓的鼓励!&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>80d8079ac25a5ee5ae9b2b5ae36c6217</guid>
<title>厉害了，A4 纸上竟然能清晰看动漫</title>
<link>https://toutiao.io/k/izj0r49</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tools=&quot;新媒体管家&quot; data-label=&quot;powered by xmt.cn&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;随意抖动，弯曲纸张竟然毫不影响在纸上看动画？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YicUhk5aAGtDjtMH6xKpoxrYW9DJiaqicwFatpbJnkxib93hBicSKNfEa6beYIuuAL3bf6QPrviaYTtaf36oXN89DOQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是什么黑科技啊，原来是AI合成的图像。制作这图像的人正是来自：港中文-商汤联合实验室、浙江大学、英伟达的研究人员。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;研究人员用AI将图片视频投影到实时弯曲的纸面上，还更改了图片的视角、光照条件，最后呈现出大家所看到的电影。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ts4QibG8CPibajLM99hfbJNCgUKGn8m6seBqhMjz1HxSl2A6wuzKjBJYO1BCHicyjRkkYMmsOayVNZC7sCsH5r3hA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;778&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;肯定有很多小伙伴跟小编一样好奇，AI可以在纸上放电影到底是如何实现的呢？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;简单来讲，通过预测光流来替换视频中的图片，就能在纸上放电影。就拿大家熟悉的《星空》图片为列，为大家展示这过程：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一步，将星空打印在A4纸上，然后录制视频。不同角度、光照、抖动情况下捕捉纸张，并从中提取帧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/YicUhk5aAGtDjtMH6xKpoxrYW9DJiaqicwFicoDwleibObG9stWIwmotwEDps0ibE0M2mBsMID1uyoibHsRIe6me0j5eA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;830&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;第二步，用LIFE单独预测《星空》在视频画面中的流动，然后将其替换成其它的图片or视频。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在做的过程中，研究人员提出的弱监督框架该框架只需要将整个图像的相机姿势变换作为弱监督。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用这一框架来训练神经网络，图像对之间的不变光流通过运动结构（Structure-from-MotionSfM）技术，视角变化大、光照变化大的图像对之间的相机姿势。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YicUhk5aAGtDjtMH6xKpoxrYW9DJiaqicwFLlfZV2umlfL8pHVsjdK1ylzt4tWEjZKpwQLtSSEnfWJHvavz3gHFAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1318&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上就是通过LIFE合成的视频就是呈现我们最终的效果啦。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这实验中也会出现小小的问题，比如匹配指定的图像中会出现数据的差错，如以下画面所显示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/YicUhk5aAGtDjtMH6xKpoxrYW9DJiaqicwFIFUSzjEgXbxCiaJasjiak5mM0ias5g0KqZ0JzW26KVIo1OU0yZGyBuc0A/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;830&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然研究人员也在发布的论文中，解释道：&lt;strong&gt;在跨图像特征匹配过程中，本地图像内容不可避免地存在歧义 并且容易出错这阻碍了下游任务。建议用LIFE预测的流来指导特征匹配。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;这通过利用图像对中的大量上下文信息来解决歧义匹配，在具有挑战性的场景中LIFE大大优于以前的流程学习框架，&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;始终如一地改善了功能匹配并使下游任务受益。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.35602094240837695&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ts4QibG8CPibZLickDan8BnlJRCcCNbJfrjQLmL8R06sTXDWBBngsRtziaicvwTzqQz4NQ8eLXSCzmrMRGV3pBKg7Dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;764&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前来看这只是短暂小问题，后续会不断优化解决的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了图像投射是否稳定性问题，像素问题也是非常重要，研究人员用LIFE来指导特征匹配、利用图像对中丰富的上下文信息来解决模糊匹配的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img data-backh=&quot;333&quot; data-backw=&quot;500&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Ts4QibG8CPibajLM99hfbJNCgUKGn8m6seHYE5sV8DJD4of0W5o0Cn8UianC654iaoaZjcyU0GsEkV88xkjQtpcoHA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后看一下效果：在观看的时候实验人员随意的抖动纸张，纸张上呈现画面其实影响不是很大。如果将A4纸固定住，播放效果跟正常屏幕其次差不多的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/YicUhk5aAGtDjtMH6xKpoxrYW9DJiaqicwFSEd1qow8NWs4mRNfl6BfFrhpWr07ge0BVb0P8z9sDBnt02icje7EynA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;818&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于此项目有什么想法大家可以快快评论，有什么新鲜有趣的技术事件也可以评论告诉小编。小编会逐一筛选帮大家好好整理哦！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;论文链接：&lt;br/&gt;https://arxiv.org/abs/2104.03097&lt;br/&gt;参考链接：&lt;br/&gt;https://drinkingcoder.github.io/publication/life/&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>