<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f6d27ba30bcda8b1e153a73d8a06b07f</guid>
<title>几乎刷完了力扣所有的堆题，我发现了这些东西（第二弹）</title>
<link>https://toutiao.io/k/x15jtei</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一点题外话&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上次在我的公众号给大家做了一个小调查《投出你想要的题解编程语言吧~》。以下是调查的结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6674057649667405&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeP2mlIMBU8B7TXA1vuwEnWQvlGicRY3vKfHDvHEEhMicibdgz9ow4KXdBia4LvnQX51Nx6t1ia7UlTWoQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;902&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;投票结果&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而关于其他，则大多数是 Go 语言。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5094816687737042&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeP2mlIMBU8B7TXA1vuwEnWRKK20Z9BHXMfTWUkzJjLvhS7aB7ibyR4NGFoe31WHMTtW3Hnic28DQFg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1582&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;投其他的人都写了什么？&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 Java 和 Python 所占比例已经超过了 60%，这次我尝试一下 Java 和 Python 双语言来写，感谢 @CaptainZ 提供的 Java 代码。同时为了&lt;strong&gt;「不让文章又臭又长，我将 Java 本文所有代码（Java 和 Python）都放到了力扣加加官网上」&lt;/strong&gt;，网站地址：https://leetcode-solution.cn/solution-code&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;如果不科学上网的话，可能打开会很慢。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;正文&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6601466992665037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeP2mlIMBU8B7TXA1vuwEnWSBwHVQdB4CJdwVVDYvFbzt97V4dohleC76AqUXKGEt64FQlRSzKic4Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1636&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是 lucifer。今天给大家带来的是《堆》专题。先上下本文的提纲，这个是我用 mindmap 画的一个脑图，之后我会继续完善，将其他专题逐步完善起来。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;大家也可以使用 vscode blink-mind 打开源文件查看，里面有一些笔记可以点开查看。源文件可以去我的公众号《力扣加加》回复脑图获取，以后脑图也会持续更新更多内容。vscode 插件地址：https://marketplace.visualstudio.com/items?itemName=awehook.vscode-blink-mind&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本系列包含以下专题：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本次是下篇，没有看过上篇的同学强烈建议先阅读上篇&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI4MzUxNjI3OA==&amp;amp;mid=2247486985&amp;amp;idx=1&amp;amp;sn=4c0275e5ef02e0b9b8e4e99ba57b58dc&amp;amp;chksm=eb88c210dcff4b062cf5d72d86733e7b0ec087adbc714e112db083c683161320e3dcbf1d87f7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;几乎刷完了力扣所有的堆题，我发现了这些东西。。。(第一弹)&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;几乎刷完了力扣所有的堆题，我发现了这些东西。。。(第一弹)&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是第二部分，后面的内容更加干货，分别是&lt;strong&gt;「三个技巧」&lt;/strong&gt;和&lt;strong&gt;「四大应用」&lt;/strong&gt;。这两个主题是专门教你怎么解题的。掌握了它，力扣中的大多数堆的题目都不在话下（当然我指的仅仅是题目中涉及到堆的部分）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;警告：本章的题目基本都是力扣 hard 难度，这是因为堆的题目很多标记难度都不小，关于这点在前面也介绍过了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一点说明&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上主菜之前，先给大家来个开胃菜。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里给大家介绍两个概念，分别是&lt;strong&gt;「元组」&lt;/strong&gt;和&lt;strong&gt;「模拟大顶堆」&lt;/strong&gt; 。之所以进行这些说明就是防止大家后面看不懂。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;元组&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用堆不仅仅可以存储单一值，比如 [1,2,3,4] 的 1，2，3，4 分别都是单一值。除了单一值，也可以存储复合值，比如对象或者元组等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们介绍一种存储元组的方式，这个技巧会在后面被广泛使用，请务必掌握。比如 [(1,2,3), (4,5,6), (2,1,3),(4,2,8)]。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;h = [(&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;), (&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;), (&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;),(&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;)]&lt;br/&gt;heapq.heappify(h) &lt;span&gt;# 堆化（小顶堆）&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;heapq.heappop() &lt;span&gt;# 弹出 (1,2,3)&lt;/span&gt;&lt;br/&gt;heapq.heappop() &lt;span&gt;# 弹出 (2,1,3)&lt;/span&gt;&lt;br/&gt;heapq.heappop() &lt;span&gt;# 弹出 (4,2,8)&lt;/span&gt;&lt;br/&gt;heapq.heappop() &lt;span&gt;# 弹出 (4,5,6)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用图来表示堆结构就是下面这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0807799442896935&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeP2mlIMBU8B7TXA1vuwEnWUJaUnbCTJiblEjmh0gVVpesnuhaKWooXErqk0TqokI5hD14RiabTk5cg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;718&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;使用元组的小顶堆&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单解释一下上面代码的执行结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用元组的方式，默认将元组第一个值当做键来比较。如果第一个相同，继续比较第二个。比如上面的 (4,5,6) 和 (4,2,8)，由于第一个值相同，因此继续比较后一个，又由于 5 比 2 大，因此 (4,2,8)先出堆。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用这个技巧有两个作用：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;携带一些额外的信息。比如我想求二维矩阵中第 k 小数，当然是以值作为键。但是处理过程又需要用到其行和列信息，那么使用元组就很合适，比如 (val, row, col)这样的形式。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;想根据两个键进行排序，一个主键一个副键。这里面又有两种典型的用法，&lt;/p&gt;&lt;p&gt;2.1 一种是两个都是同样的顺序，比如都是顺序或者都是逆序。&lt;/p&gt;&lt;p&gt;2.2 另一种是两个不同顺序排序，即一个是逆序一个是顺序。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于篇幅原因，具体就不再这里展开了，大家在平时做题过程中留意可以一下，有机会我会单独开一篇文章讲解。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;如果你所使用的编程语言没有堆或者堆的实现不支持元组，那么也可以通过简单的改造使其支持，主要就是自定义比较逻辑即可。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;模拟大顶堆&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 Python 没有大顶堆。因此我这里使用了小顶堆进行模拟实现。即将原有的数全部取相反数，比如原数字是 5，就将 -5 入堆。经过这样的处理，小顶堆就可以当成大顶堆用了。不过需要注意的是，当你 pop 出来的时候， &lt;strong&gt;「记得也要取反，将其还原回来」&lt;/strong&gt;哦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;h = []&lt;br/&gt;A = [&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; a &lt;span&gt;in&lt;/span&gt; A:&lt;br/&gt;    heapq.heappush(h, -a)&lt;br/&gt;&lt;span&gt;-1&lt;/span&gt; * heapq.heappop(h) &lt;span&gt;# 5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-1&lt;/span&gt; * heapq.heappop(h) &lt;span&gt;# 4&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-1&lt;/span&gt; * heapq.heappop(h) &lt;span&gt;# 3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-1&lt;/span&gt; * heapq.heappop(h) &lt;span&gt;# 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;-1&lt;/span&gt; * heapq.heappop(h) &lt;span&gt;# 1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用图来表示就是下面这样：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1246537396121883&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeP2mlIMBU8B7TXA1vuwEnWmw8N6czGbByqnmwGrFqxuYHuuoONPTvVtNWLB2wiaeicVOPPuq3kx95A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;722&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;小顶堆模拟大顶堆&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;铺垫就到这里，接下来进入正题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三个技巧&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;技巧一 - 固定堆&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个技巧指的是固定堆的大小 k 不变，代码上可通过&lt;strong&gt;「每 pop 出去一个就 push 进来一个」&lt;/strong&gt;来实现。而由于初始堆可能是 0，我们刚开始需要一个一个 push 进堆以达到堆的大小为 k，因此严格来说应该是&lt;strong&gt;「维持堆的大小不大于 k」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;固定堆一个典型的应用就是求第 k 小的数。其实求第 k 小的数最简单的思路是建立小顶堆，将所有的数&lt;strong&gt;「先全部入堆，然后逐个出堆，一共出堆 k 次」&lt;/strong&gt;。最后一次出堆的就是第 k 小的数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而，我们也可不先全部入堆，而是建立&lt;strong&gt;「大顶堆」&lt;/strong&gt;（注意不是上面的小顶堆），并维持堆的大小为 k 个。如果新的数入堆之后堆的大小大于 k，则需要将堆顶的数和新的数进行比较，&lt;strong&gt;「并将较大的移除」&lt;/strong&gt;。这样可以保证&lt;strong&gt;「堆中的数是全体数字中最小的 k 个」&lt;/strong&gt;，而这最小的 k 个中最大的（即堆顶）不就是第 k 小的么？这也就是选择建立大顶堆，而不是小顶堆的原因。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.84375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeP2mlIMBU8B7TXA1vuwEnWBhZhtYFj50g9nU2k5997glFuGFcrZUtjHsibs6vX89bO13YC5d3jkew/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;固定大顶堆求第 5 小的数&lt;/figcaption&gt;&lt;/figure&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单一句话总结就是&lt;strong&gt;「固定一个大小为 k 的大顶堆可以快速求第 k 小的数，反之固定一个大小为 k 的小顶堆可以快速求第 k 大的数」&lt;/strong&gt;。比如力扣 2020-02-24 的周赛第三题 &lt;code&gt;找出第 K 大的异或坐标值&lt;/code&gt; 就可以用固定小顶堆技巧来实现（这道题让你求第 k 大的数所以用固定小顶堆）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么说可能你的感受并不强烈，接下来我给大家举两个例子来帮助大家加深印象。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;295. 数据流的中位数&lt;/span&gt;&lt;span/&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;题目描述&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。&lt;br/&gt;&lt;br/&gt;例如，&lt;br/&gt;&lt;br/&gt;[2,3,4]  的中位数是 3&lt;br/&gt;&lt;br/&gt;[2,3] 的中位数是 (2 + 3) / 2 = 2.5&lt;br/&gt;&lt;br/&gt;设计一个支持以下两种操作的数据结构：&lt;br/&gt;&lt;br/&gt;void addNum(int num) - 从数据流中添加一个整数到数据结构中。&lt;br/&gt;double findMedian() - 返回目前所有元素的中位数。&lt;br/&gt;示例：&lt;br/&gt;&lt;br/&gt;addNum(1)&lt;br/&gt;addNum(2)&lt;br/&gt;findMedian() -&amp;gt; 1.5&lt;br/&gt;addNum(3)&lt;br/&gt;findMedian() -&amp;gt; 2&lt;br/&gt;进阶:&lt;br/&gt;&lt;br/&gt;如果数据流中所有整数都在 0 到 100 范围内，你将如何优化你的算法？&lt;br/&gt;如果数据流中 99% 的整数都在 0 到 100 范围内，你将如何优化你的算法？&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;思路&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题实际上可看出是求第 k 小的数的特例了。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果列表长度是奇数，那么 k 就是 (n + 1) / 2，中位数就是第 k 个数，。比如 n 是 5， k 就是 (5 + 1)/ 2 = 3。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果列表长度是偶数，那么 k 就是 (n + 1) / 2 和 (n + 1) / 2 + 1，中位数则是这两个数的平均值。比如 n 是 6， k 就是 (6 + 1)/ 2 = 3 和 (6 + 1) / 2 + 1 = 4。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此我们的可以维护两个固定堆，固定堆的大小为 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;(n + 1) \div 2&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 -750 4822.9 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mo&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(389, 0)&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1211.2, 0)&quot;&gt;&lt;path data-c=&quot;2B&quot; d=&quot;M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(2211.4, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2711.4, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(3322.7, 0)&quot;&gt;&lt;path data-c=&quot;F7&quot; d=&quot;M318 466Q318 500 339 518T386 537Q418 537 438 517T458 466Q458 438 440 417T388 396Q355 396 337 417T318 466ZM56 237T56 250T70 270H706Q721 262 721 250T706 230H70Q56 237 56 250ZM318 34Q318 68 339 86T386 105Q418 105 438 85T458 34Q458 6 440 -15T388 -36Q355 -36 337 -15T318 34Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(4322.9, 0)&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt; 和 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;n - (n + 1)\div2&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 -750 6645.3 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(822.2, 0)&quot;&gt;&lt;path data-c=&quot;2212&quot; d=&quot;M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1822.4, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2211.4, 0)&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(3033.7, 0)&quot;&gt;&lt;path data-c=&quot;2B&quot; d=&quot;M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(4033.9, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(4533.9, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(5145.1, 0)&quot;&gt;&lt;path data-c=&quot;F7&quot; d=&quot;M318 466Q318 500 339 518T386 537Q418 537 438 517T458 466Q458 438 440 417T388 396Q355 396 337 417T318 466ZM56 237T56 250T70 270H706Q721 262 721 250T706 230H70Q56 237 56 250ZM318 34Q318 68 339 86T386 105Q418 105 438 85T458 34Q458 6 440 -15T388 -36Q355 -36 337 -15T318 34Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(6145.3, 0)&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;，也就是两个堆的大小&lt;strong&gt;「最多」&lt;/strong&gt;相差 1，更具体的就是 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot; 0 &amp;lt;= (n + 1) \div 2 - (n - (n + 1) \div 2) &amp;lt;= 1&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 -750 18691.8 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mn&quot;&gt;&lt;path data-c=&quot;30&quot; d=&quot;M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(777.8, 0)&quot;&gt;&lt;path data-c=&quot;3C&quot; d=&quot;M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z&quot;/&gt;&lt;path data-c=&quot;3D&quot; d=&quot;M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z&quot; transform=&quot;translate(778, 0)&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2611.6, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3000.6, 0)&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(3822.8, 0)&quot;&gt;&lt;path data-c=&quot;2B&quot; d=&quot;M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(4823, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(5323, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(5934.2, 0)&quot;&gt;&lt;path data-c=&quot;F7&quot; d=&quot;M318 466Q318 500 339 518T386 537Q418 537 438 517T458 466Q458 438 440 417T388 396Q355 396 337 417T318 466ZM56 237T56 250T70 270H706Q721 262 721 250T706 230H70Q56 237 56 250ZM318 34Q318 68 339 86T386 105Q418 105 438 85T458 34Q458 6 440 -15T388 -36Q355 -36 337 -15T318 34Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(6934.4, 0)&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(7656.7, 0)&quot;&gt;&lt;path data-c=&quot;2212&quot; d=&quot;M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(8656.9, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(9045.9, 0)&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(9868.1, 0)&quot;&gt;&lt;path data-c=&quot;2212&quot; d=&quot;M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(10868.3, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(11257.3, 0)&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(12079.6, 0)&quot;&gt;&lt;path data-c=&quot;2B&quot; d=&quot;M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(13079.8, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(13579.8, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(14191, 0)&quot;&gt;&lt;path data-c=&quot;F7&quot; d=&quot;M318 466Q318 500 339 518T386 537Q418 537 438 517T458 466Q458 438 440 417T388 396Q355 396 337 417T318 466ZM56 237T56 250T70 270H706Q721 262 721 250T706 230H70Q56 237 56 250ZM318 34Q318 68 339 86T386 105Q418 105 438 85T458 34Q458 6 440 -15T388 -36Q355 -36 337 -15T318 34Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(15191.2, 0)&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(15691.2, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(16358, 0)&quot;&gt;&lt;path data-c=&quot;3C&quot; d=&quot;M694 -11T694 -19T688 -33T678 -40Q671 -40 524 29T234 166L90 235Q83 240 83 250Q83 261 91 266Q664 540 678 540Q681 540 687 534T694 519T687 505Q686 504 417 376L151 250L417 124Q686 -4 687 -5Q694 -11 694 -19Z&quot;/&gt;&lt;path data-c=&quot;3D&quot; d=&quot;M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z&quot; transform=&quot;translate(778, 0)&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(18191.8, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于上面提到的知识，我们可以：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;建立一个大顶堆，并存放最小的 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;(n + 1) \div 2&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 -750 4822.9 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mo&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(389, 0)&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1211.2, 0)&quot;&gt;&lt;path data-c=&quot;2B&quot; d=&quot;M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(2211.4, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2711.4, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(3322.7, 0)&quot;&gt;&lt;path data-c=&quot;F7&quot; d=&quot;M318 466Q318 500 339 518T386 537Q418 537 438 517T458 466Q458 438 440 417T388 396Q355 396 337 417T318 466ZM56 237T56 250T70 270H706Q721 262 721 250T706 230H70Q56 237 56 250ZM318 34Q318 68 339 86T386 105Q418 105 438 85T458 34Q458 6 440 -15T388 -36Q355 -36 337 -15T318 34Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(4322.9, 0)&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt; 个数，这样堆顶的数就是第 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;(n + 1) \div 2&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 -750 4822.9 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mo&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(389, 0)&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1211.2, 0)&quot;&gt;&lt;path data-c=&quot;2B&quot; d=&quot;M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(2211.4, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2711.4, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(3322.7, 0)&quot;&gt;&lt;path data-c=&quot;F7&quot; d=&quot;M318 466Q318 500 339 518T386 537Q418 537 438 517T458 466Q458 438 440 417T388 396Q355 396 337 417T318 466ZM56 237T56 250T70 270H706Q721 262 721 250T706 230H70Q56 237 56 250ZM318 34Q318 68 339 86T386 105Q418 105 438 85T458 34Q458 6 440 -15T388 -36Q355 -36 337 -15T318 34Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(4322.9, 0)&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt; 小的数，也就是奇数情况的中位数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;建立一个小顶堆，并存放最大的 n - &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;(n + 1) \div 2&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 -750 4822.9 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mo&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(389, 0)&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1211.2, 0)&quot;&gt;&lt;path data-c=&quot;2B&quot; d=&quot;M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(2211.4, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2711.4, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(3322.7, 0)&quot;&gt;&lt;path data-c=&quot;F7&quot; d=&quot;M318 466Q318 500 339 518T386 537Q418 537 438 517T458 466Q458 438 440 417T388 396Q355 396 337 417T318 466ZM56 237T56 250T70 270H706Q721 262 721 250T706 230H70Q56 237 56 250ZM318 34Q318 68 339 86T386 105Q418 105 438 85T458 34Q458 6 440 -15T388 -36Q355 -36 337 -15T318 34Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(4322.9, 0)&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt; 个数，这样堆顶的数就是第 n - &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;(n + 1) \div 2&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 -750 4822.9 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mo&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(389, 0)&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1211.2, 0)&quot;&gt;&lt;path data-c=&quot;2B&quot; d=&quot;M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(2211.4, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2711.4, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(3322.7, 0)&quot;&gt;&lt;path data-c=&quot;F7&quot; d=&quot;M318 466Q318 500 339 518T386 537Q418 537 438 517T458 466Q458 438 440 417T388 396Q355 396 337 417T318 466ZM56 237T56 250T70 270H706Q721 262 721 250T706 230H70Q56 237 56 250ZM318 34Q318 68 339 86T386 105Q418 105 438 85T458 34Q458 6 440 -15T388 -36Q355 -36 337 -15T318 34Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(4322.9, 0)&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt; 大的数，结合上面的大顶堆，可求出偶数情况的中位数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了这样一个知识，剩下的只是如何维护两个堆的大小了。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果大顶堆的个数比小顶堆少，那么就将小顶堆中最小的转移到大顶堆。而由于小顶堆维护的是最大的 k 个数，大顶堆维护的是最小的 k 个数，因此小顶堆堆顶一定大于等于大顶堆堆顶，并且这两个堆顶是&lt;strong&gt;「此时」&lt;/strong&gt;的中位数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果大顶堆的个数比小顶堆的个数多 2，那么就将大顶堆中最大的转移到小顶堆，理由同上。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此，可能你已经明白了为什么分别建立两个堆，并且需要一个大顶堆一个小顶堆。这其中的原因正如上面所描述的那样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;固定堆的应用常见还不止于此，我们继续看一道题。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MedianFinder&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        self.min_heap = []&lt;br/&gt;        self.max_heap = []&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;addNum&lt;/span&gt;&lt;span&gt;(self, num: int)&lt;/span&gt; -&amp;gt; &lt;span&gt;None&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; self.max_heap &lt;span&gt;or&lt;/span&gt; num &amp;lt; -self.max_heap[&lt;span&gt;0&lt;/span&gt;]:&lt;br/&gt;            heapq.heappush(self.max_heap, -num)&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;            heapq.heappush(self.min_heap, num)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; len(self.max_heap) &amp;gt; len(self.min_heap) + &lt;span&gt;1&lt;/span&gt;:&lt;br/&gt;            heappush(self.min_heap, -heappop(self.max_heap))&lt;br/&gt;        &lt;span&gt;elif&lt;/span&gt; len(self.min_heap) &amp;gt; len(self.max_heap):&lt;br/&gt;            heappush(self.max_heap, -heappop(self.min_heap))&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;findMedian&lt;/span&gt;&lt;span&gt;(self)&lt;/span&gt; -&amp;gt; float:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; len(self.min_heap) == len(self.max_heap): &lt;span&gt;return&lt;/span&gt; (self.min_heap[&lt;span&gt;0&lt;/span&gt;] - self.max_heap[&lt;span&gt;0&lt;/span&gt;]) / &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; -self.max_heap[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(代码 1.3.1)&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;857. 雇佣 K 名工人的最低成本&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;题目描述&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;有 N 名工人。 第 i 名工人的工作质量为 quality[i] ，其最低期望工资为 wage[i] 。&lt;br/&gt;&lt;br/&gt;现在我们想雇佣 K 名工人组成一个工资组。在雇佣 一组 K 名工人时，我们必须按照下述规则向他们支付工资：&lt;br/&gt;&lt;br/&gt;对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。&lt;br/&gt;工资组中的每名工人至少应当得到他们的最低期望工资。&lt;br/&gt;返回组成一个满足上述条件的工资组至少需要多少钱。&lt;br/&gt;&lt;br/&gt; &lt;br/&gt;&lt;br/&gt;示例 1：&lt;br/&gt;&lt;br/&gt;输入：quality = [10,20,5], wage = [70,50,30], K = 2&lt;br/&gt;输出：105.00000&lt;br/&gt;解释： 我们向 0 号工人支付 70，向 2 号工人支付 35。&lt;br/&gt;示例 2：&lt;br/&gt;&lt;br/&gt;输入：quality = [3,1,10,10,1], wage = [4,8,2,2,7], K = 3&lt;br/&gt;输出：30.66667&lt;br/&gt;解释： 我们向 0 号工人支付 4，向 2 号和 3 号分别支付 13.33333。&lt;br/&gt; &lt;br/&gt;&lt;br/&gt;提示：&lt;br/&gt;&lt;br/&gt;1 &amp;lt;= K &amp;lt;= N &amp;lt;= 10000，其中 N = quality.length = wage.length&lt;br/&gt;1 &amp;lt;= quality[i] &amp;lt;= 10000&lt;br/&gt;1 &amp;lt;= wage[i] &amp;lt;= 10000&lt;br/&gt;与正确答案误差在 10^-5 之内的答案将被视为正确的。&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;思路&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;题目要求我们选择 k 个人，按其工作质量与同组其他工人的工作质量的比例来支付工资，并且工资组中的每名工人至少应当得到他们的最低期望工资。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换句话说，同一组的 k 个人他们的工作质量和工资比是一个固定值才能使支付的工资最少。请先理解这句话，后面的内容都是基于这个前提产生的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们不妨定一个指标&lt;strong&gt;「工作效率」&lt;/strong&gt;，其值等于 q / w。前面说了这 k 个人的 q / w 是相同的才能保证工资最少，并且这个 q / w 一定是这 k 个人最低的（短板），否则一定会有人得不到最低期望工资。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是我们可以写出下面的代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;mincostToHireWorkers&lt;/span&gt;&lt;span&gt;(self, quality: List[int], wage: List[int], K: int)&lt;/span&gt; -&amp;gt; float:&lt;/span&gt;&lt;br/&gt;        eff = [(q / w, q, w) &lt;span&gt;for&lt;/span&gt; a, b &lt;span&gt;in&lt;/span&gt; zip(quality, wage)]&lt;br/&gt;        eff.sort(key=&lt;span&gt;lambda&lt;/span&gt; a: -a[&lt;span&gt;0&lt;/span&gt;])&lt;br/&gt;        ans = float(&lt;span&gt;&#x27;inf&#x27;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(K&lt;span&gt;-1&lt;/span&gt;, len(eff)):&lt;br/&gt;            h = []&lt;br/&gt;            k = K - &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;            rate, _, total = eff[i]&lt;br/&gt;            &lt;span&gt;# 找出工作效率比它高的 k 个人，这 k 个人的工资尽可能低。&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;# 由于已经工作效率倒序排了，因此前面的都是比它高的，然后使用堆就可得到 k 个工资最低的。&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(i):&lt;br/&gt;                heapq.heappush(h, eff[j][&lt;span&gt;1&lt;/span&gt;] / rate)&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; k &amp;gt; &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;                total += heapq.heappop(h)&lt;br/&gt;                k -= &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;            ans = min(ans, total)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ans&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(代码 1.3.2)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种做法每次都 push 很多数，并 pop k 次，并没有很好地利用堆的&lt;strong&gt;「动态」&lt;/strong&gt;特性，而只利用了其&lt;strong&gt;「求极值」&lt;/strong&gt;的特性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个更好的做法是使用&lt;strong&gt;「固定堆技巧」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题可以换个角度思考。其实这道题不就是让我们选 k 个人，工作效率比取他们中最低的，并按照这个最低的工作效率计算总工资，找出最低的总工资么？因此这道题可以固定一个大小为 k 的大顶堆，通过一定操作保证堆顶的就是第 k 小的（操作和前面的题类似）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且前面的解法中堆使用了三元组 (q / w, q, w)，实际上这也没有必要。因为已知其中两个，可推导出另外一个，因此存储两个就行了，而又由于我们需要&lt;strong&gt;「根据工作效率比做堆的键」&lt;/strong&gt;，因此任意选一个 q 或者 w 即可，这里我选择了 q，即存 (q/2, q) 二元组。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体来说就是：以 rate 为最低工作效率比的 k 个人的总工资 = &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;\displaystyle \sum_{n=1}^{k}{q}_{n}/rate&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 -1740.7 4837.9 2986.6&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mstyle&quot;&gt;&lt;g data-mml-node=&quot;munderover&quot;&gt;&lt;g data-mml-node=&quot;mo&quot;&gt;&lt;path data-c=&quot;2211&quot; d=&quot;M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(58, -1087.9) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(600, 0)&quot;&gt;&lt;path data-c=&quot;3D&quot; d=&quot;M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(1378, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(537.8, 1150) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;6B&quot; d=&quot;M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;msub&quot; transform=&quot;translate(1610.7, 0)&quot;&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;71&quot; d=&quot;M33 157Q33 258 109 349T280 441Q340 441 372 389Q373 390 377 395T388 406T404 418Q438 442 450 442Q454 442 457 439T460 434Q460 425 391 149Q320 -135 320 -139Q320 -147 365 -148H390Q396 -156 396 -157T393 -175Q389 -188 383 -194H370Q339 -192 262 -192Q234 -192 211 -192T174 -192T157 -193Q143 -193 143 -185Q143 -182 145 -170Q149 -154 152 -151T172 -148Q220 -148 230 -141Q238 -136 258 -53T279 32Q279 33 272 29Q224 -10 172 -10Q117 -10 75 30T33 157ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; transform=&quot;translate(446, -229.4) scale(0.707)&quot; data-mjx-texclass=&quot;ORD&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;TeXAtom&quot; data-mjx-texclass=&quot;ORD&quot; transform=&quot;translate(2530.9, 0)&quot;&gt;&lt;g data-mml-node=&quot;mo&quot;&gt;&lt;path data-c=&quot;2F&quot; d=&quot;M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3030.9, 0)&quot;&gt;&lt;path data-c=&quot;72&quot; d=&quot;M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(3481.9, 0)&quot;&gt;&lt;path data-c=&quot;61&quot; d=&quot;M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(4010.9, 0)&quot;&gt;&lt;path data-c=&quot;74&quot; d=&quot;M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(4371.9, 0)&quot;&gt;&lt;path data-c=&quot;65&quot; d=&quot;M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;，这里的 rate 就是当前的 q / w，同时也是 k 个人的 q / w 的最小值。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;mincostToHireWorkers&lt;/span&gt;&lt;span&gt;(self, quality: List[int], wage: List[int], K: int)&lt;/span&gt; -&amp;gt; float:&lt;/span&gt;&lt;br/&gt;        effs = [(q / w, q) &lt;span&gt;for&lt;/span&gt; q, w &lt;span&gt;in&lt;/span&gt; zip(quality, wage)]&lt;br/&gt;        effs.sort(key=&lt;span&gt;lambda&lt;/span&gt; a: -a[&lt;span&gt;0&lt;/span&gt;])&lt;br/&gt;        ans = float(&lt;span&gt;&#x27;inf&#x27;&lt;/span&gt;)&lt;br/&gt;        h = []&lt;br/&gt;        total = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; rate, q &lt;span&gt;in&lt;/span&gt; effs:&lt;br/&gt;            heapq.heappush(h, -q)&lt;br/&gt;            total += q&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; len(h) &amp;gt; K:&lt;br/&gt;                total += heapq.heappop(h)&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; len(h) == K:&lt;br/&gt;                ans = min(ans, total / rate)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ans&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(代码 1.3.3)&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;技巧二 - 多路归并&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个技巧其实在前面讲&lt;strong&gt;「超级丑数」&lt;/strong&gt;的时候已经提到了，只是没有给这种类型的题目一个&lt;strong&gt;「名字」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这个技巧，叫做多指针优化可能会更合适，只不过这个名字实在太过朴素且容易和双指针什么的混淆，因此我给 ta 起了个别致的名字 - &lt;strong&gt;「多路归并」&lt;/strong&gt;。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;多路体现在：有多条候选路线。代码上，我们可使用多指针来表示。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;归并体现在：结果可能是多个候选路线中最长的或者最短，也可能是第 k 个 等。因此我们需要对多条路线的结果进行比较，并根据题目描述舍弃或者选取某一个或多个路线。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样描述比较抽象，接下来通过几个例子来加深一下大家的理解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我给大家精心准备了&lt;strong&gt;「四道难度为 hard」&lt;/strong&gt; 的题目。掌握了这个套路就可以去快乐地 AC 这四道题啦。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;1439. 有序矩阵中的第 k 个最小数组和&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;题目描述&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;给你一个 m * n 的矩阵 mat，以及一个整数 k ，矩阵中的每一行都以非递减的顺序排列。&lt;br/&gt;&lt;br/&gt;你可以从每一行中选出 1 个元素形成一个数组。返回所有可能数组中的第 k 个 最小 数组和。&lt;br/&gt;&lt;br/&gt; &lt;br/&gt;&lt;br/&gt;示例 1：&lt;br/&gt;&lt;br/&gt;输入：mat = [[1,3,11],[2,4,6]], k = 5&lt;br/&gt;输出：7&lt;br/&gt;解释：从每一行中选出一个元素，前 k 个和最小的数组分别是：&lt;br/&gt;[1,2], [1,4], [3,2], [3,4], [1,6]。其中第 5 个的和是 7 。&lt;br/&gt;示例 2：&lt;br/&gt;&lt;br/&gt;输入：mat = [[1,3,11],[2,4,6]], k = 9&lt;br/&gt;输出：17&lt;br/&gt;示例 3：&lt;br/&gt;&lt;br/&gt;输入：mat = [[1,10,10],[1,4,5],[2,3,6]], k = 7&lt;br/&gt;输出：9&lt;br/&gt;解释：从每一行中选出一个元素，前 k 个和最小的数组分别是：&lt;br/&gt;[1,1,2], [1,1,3], [1,4,2], [1,4,3], [1,1,6], [1,5,2], [1,5,3]。其中第 7 个的和是 9 。&lt;br/&gt;示例 4：&lt;br/&gt;&lt;br/&gt;输入：mat = [[1,1,10],[2,2,9]], k = 7&lt;br/&gt;输出：12&lt;br/&gt; &lt;br/&gt;&lt;br/&gt;提示：&lt;br/&gt;&lt;br/&gt;m == mat.length&lt;br/&gt;n == mat.length[i]&lt;br/&gt;1 &amp;lt;= m, n &amp;lt;= 40&lt;br/&gt;1 &amp;lt;= k &amp;lt;= min(200, n ^ m)&lt;br/&gt;1 &amp;lt;= mat[i][j] &amp;lt;= 5000&lt;br/&gt;mat[i] 是一个非递减数组&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;思路&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这道题就是给你 m 个长度均相同的一维数组，让我们从这 m 个数组中分别选出一个数，即一共选取 m 个数，求这 m 个数的和是&lt;strong&gt;「所有选取可能性」&lt;/strong&gt;中和第 k 小的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4909090909090909&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeP2mlIMBU8B7TXA1vuwEnWZ3KFW1LMUDHM8afHKY8HaE81QjnRQWRcqrRGqmrrlyYUyt0QkVTniaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2200&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个朴素的想法是使用多指针来解。对于这道题来说就是使用 m 个指针，分别指向 m 个一维数组，指针的位置表示当前选取的是该一维数组中第几个。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以题目中的 &lt;code&gt;mat = [[1,3,11],[2,4,6]], k = 5&lt;/code&gt; 为例。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;先初始化两个指针 p1,p2，分别指向两个一维数组的开头，代码表示就是全部初始化为 0。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;此时两个指针指向的数字和为 1 + 2 = 3，这就是第 1 小的和。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;接下来，我们移动其中一个指针。此时我们可以移动 p1，也可以移动 p2。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;那么第 2 小的一定是移动 p1 和 移动 p2 这两种情况的较小值。而这里移动 p1 和 p2 实际上都会得到 5，也就是说第 2 和第 3 小的和都是 5。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里已经分叉了，出现了两种情况(注意看粗体的位置，粗体表示的是指针的位置)：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;[1,&lt;strong&gt;「3」&lt;/strong&gt;,11],[&lt;strong&gt;「2」&lt;/strong&gt;,4,6] 和为 5&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;[&lt;strong&gt;「1」&lt;/strong&gt;,3,11],[2,&lt;strong&gt;「4」&lt;/strong&gt;,6] 和为 5&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，这两种情况应该&lt;strong&gt;「齐头并进，共同进行下去」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于情况 1 来说，接下来移动又有两种情况。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;[1,3,&lt;strong&gt;「11」&lt;/strong&gt;],[&lt;strong&gt;「2」&lt;/strong&gt;,4,6] 和为 13&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;[1,&lt;strong&gt;「3」&lt;/strong&gt;,11],[2,&lt;strong&gt;「4」&lt;/strong&gt;,6] 和为 7&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于情况 2 来说，接下来移动也有两种情况。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;[1,&lt;strong&gt;「3」&lt;/strong&gt;,11],[2,&lt;strong&gt;「4」&lt;/strong&gt;,6] 和为 7&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;[&lt;strong&gt;「1」&lt;/strong&gt;,3,11],[2,4,&lt;strong&gt;「6」&lt;/strong&gt;] 和为 7&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过比较这四种情况，得出结论：第 4，5，6 小的数都是 7。但第 7 小的数并不一定是 13。原因和上面类似，可能第 7 小的就隐藏在前面的 7 分裂之后的新情况中，实际上确实如此。因此我们需要继续执行上述逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进一步，我们可以将上面的思路拓展到一般情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面提到了题目需要求的其实是第 k 小的和，而最小的我们是容易知道的，即所有的一维数组首项和。我们又发现，根据最小的，我们可以推导出第 2 小，推导的方式就是移动其中一个指针，这就一共分裂出了 n 种情况了，其中 n 为一维数组长度，第 2 小的就在这分裂中的 n 种情况中，而筛选的方式是这 n 种情况和&lt;strong&gt;「最小」&lt;/strong&gt;的，后面的情况也是类似。不难看出每次分裂之后极值也发生了变化，因此这是一个明显的求动态求极值的信号，使用堆是一个不错的选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那代码该如何书写呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面说了，我们先要初始化 m 个指针，并赋值为 0。对应伪代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 初始化堆&lt;/span&gt;&lt;br/&gt;h = []&lt;br/&gt;&lt;span&gt;# sum(vec[0] for vec in mat) 是 m 个一维数组的首项和&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# [0] * m 就是初始化了一个长度为 m 且全部填充为 0 的数组。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 我们将上面的两个信息组装成元祖 cur 方便使用&lt;/span&gt;&lt;br/&gt;cur = (sum(vec[&lt;span&gt;0&lt;/span&gt;] &lt;span&gt;for&lt;/span&gt; vec &lt;span&gt;in&lt;/span&gt; mat), [&lt;span&gt;0&lt;/span&gt;] * m)&lt;br/&gt;&lt;span&gt;# 将其入堆&lt;/span&gt;&lt;br/&gt;heapq.heappush(h, cur)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们每次都移动一个指针，从而形成分叉出一条新的分支。每次从堆中弹出一个最小的，弹出 k 次就是第 k 小的了。伪代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; to K:&lt;br/&gt;    &lt;span&gt;# acc 当前的和， pointers 是指针情况。&lt;/span&gt;&lt;br/&gt;    acc, pointers = heapq.heappop(h)&lt;br/&gt;    &lt;span&gt;# 每次都粗暴地移动指针数组中的一个指针。每移动一个指针就分叉一次， 一共可能移动的情况是 n，其中 n 为一维数组的长度。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i, pointer &lt;span&gt;in&lt;/span&gt; enumerate(pointers):&lt;br/&gt;        &lt;span&gt;# 如果 pointer == len(mat[0]) - 1 说明到头了，不能移动了&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; pointer != len(mat[&lt;span&gt;0&lt;/span&gt;]) - &lt;span&gt;1&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;# 下面两句话的含义是修改 pointers[i] 的指针 为 pointers[i] + 1&lt;/span&gt;&lt;br/&gt;            new_pointers = pointers.copy()&lt;br/&gt;            new_pointers[i] += &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;# 将更新后的 acc 和指针数组重新入堆&lt;/span&gt;&lt;br/&gt;            heapq.heappush(h, (acc + mat[i][pointer + &lt;span&gt;1&lt;/span&gt;] - mat[i][pointer], new_pointers))&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是&lt;strong&gt;「多路归并」&lt;/strong&gt;问题的核心代码，请务必记住。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;代码看起来很多，其实去掉注释一共才七行而已。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的伪代码有一个问题。比如有两个一维数组，指针都初始化为 0。第一次移动第一个一维数组的指针，第二次移动第二个数组的指针，此时指针数组为 [1, 1]，即全部指针均指向下标为 1 的元素。而如果第一次移动第二个一维数组的指针，第二次移动第一个数组的指针，此时指针数组仍然为 [1, 1]。这实际上是一种情况，如果不加控制会被计算两次导致出错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个可能的解决方案是使用 hashset 记录所有的指针情况，这样就避免了同样的指针被计算多次的问题。为了做到这一点，我们需要对指针数组的使用做一些微调，即使用元组代替数组。原因在于数组是无法直接哈希化的。具体内容请参考代码区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「多路归并」&lt;/strong&gt;的题目，思路和代码都比较类似。为了后面的题目能够更高地理解，请务必搞定这道题，后面我们将不会这么详细地进行分析。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;kthSmallest&lt;/span&gt;&lt;span&gt;(self, mat, k: int)&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;br/&gt;        h = []&lt;br/&gt;        cur = (sum(vec[&lt;span&gt;0&lt;/span&gt;] &lt;span&gt;for&lt;/span&gt; vec &lt;span&gt;in&lt;/span&gt; mat), tuple([&lt;span&gt;0&lt;/span&gt;] * len(mat)))&lt;br/&gt;        heapq.heappush(h, cur)&lt;br/&gt;        seen = set(cur)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt; range(k):&lt;br/&gt;            acc, pointers = heapq.heappop(h)&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; i, pointer &lt;span&gt;in&lt;/span&gt; enumerate(pointers):&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; pointer != len(mat[&lt;span&gt;0&lt;/span&gt;]) - &lt;span&gt;1&lt;/span&gt;:&lt;br/&gt;                    t = list(pointers)&lt;br/&gt;                    t[i] = pointer + &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;                    tt = tuple(t)&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; tt &lt;span&gt;not&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; seen:&lt;br/&gt;                        seen.add(tt)&lt;br/&gt;                        heapq.heappush(h, (acc + mat[i][pointer + &lt;span&gt;1&lt;/span&gt;] - mat[i][pointer], tt))&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; acc&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(代码 1.3.4)&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;719. 找出第 k 小的距离对&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;题目描述&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;给定一个整数数组，返回所有数对之间的第 k 个最小距离。一对 (A, B) 的距离被定义为 A 和 B 之间的绝对差值。&lt;br/&gt;&lt;br/&gt;示例 1:&lt;br/&gt;&lt;br/&gt;输入：&lt;br/&gt;nums = [1,3,1]&lt;br/&gt;k = 1&lt;br/&gt;输出：0&lt;br/&gt;解释：&lt;br/&gt;所有数对如下：&lt;br/&gt;(1,3) -&amp;gt; 2&lt;br/&gt;(1,1) -&amp;gt; 0&lt;br/&gt;(3,1) -&amp;gt; 2&lt;br/&gt;因此第 1 个最小距离的数对是 (1,1)，它们之间的距离为 0。&lt;br/&gt;提示:&lt;br/&gt;&lt;br/&gt;2 &amp;lt;= len(nums) &amp;lt;= 10000.&lt;br/&gt;0 &amp;lt;= nums[i] &amp;lt; 1000000.&lt;br/&gt;1 &amp;lt;= k &amp;lt;= len(nums) * (len(nums) - 1) / 2.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;思路&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不难看出所有的数对可能共 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;C_n^2&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 -833.9 1222.6 1088.7&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;msubsup&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;43&quot; d=&quot;M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(819, 363) scale(0.707)&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(715, -247) scale(0.707)&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt; 个，也就是 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;n\times(n-1)\div2&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 -750 6645.3 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(822.2, 0)&quot;&gt;&lt;path data-c=&quot;D7&quot; d=&quot;M630 29Q630 9 609 9Q604 9 587 25T493 118L389 222L284 117Q178 13 175 11Q171 9 168 9Q160 9 154 15T147 29Q147 36 161 51T255 146L359 250L255 354Q174 435 161 449T147 471Q147 480 153 485T168 490Q173 490 175 489Q178 487 284 383L389 278L493 382Q570 459 587 475T609 491Q630 491 630 471Q630 464 620 453T522 355L418 250L522 145Q606 61 618 48T630 29Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(1822.4, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(2211.4, 0)&quot;&gt;&lt;path data-c=&quot;6E&quot; d=&quot;M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(3033.7, 0)&quot;&gt;&lt;path data-c=&quot;2212&quot; d=&quot;M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(4033.9, 0)&quot;&gt;&lt;path data-c=&quot;31&quot; d=&quot;M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(4533.9, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(5145.1, 0)&quot;&gt;&lt;path data-c=&quot;F7&quot; d=&quot;M318 466Q318 500 339 518T386 537Q418 537 438 517T458 466Q458 438 440 417T388 396Q355 396 337 417T318 466ZM56 237T56 250T70 270H706Q721 262 721 250T706 230H70Q56 237 56 250ZM318 34Q318 68 339 86T386 105Q418 105 438 85T458 34Q458 6 440 -15T388 -36Q355 -36 337 -15T318 34Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(6145.3, 0)&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此我们可以使用两次循环找出所有的数对，并升序排序，之后取第 k 个。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上，我们可使用固定堆技巧，维护一个大小为 k 的大顶堆，这样堆顶的元素就是第 k 小的，这在前面的固定堆中已经讲过，不再赘述。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;smallestDistancePair&lt;/span&gt;&lt;span&gt;(self, nums: List[int], k: int)&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;br/&gt;        h = []&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(len(nums)):&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt; range(i + &lt;span&gt;1&lt;/span&gt;, len(nums)):&lt;br/&gt;                a, b = nums[i], nums[j]&lt;br/&gt;                &lt;span&gt;# 维持堆大小不超过 k&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; len(h) == k &lt;span&gt;and&lt;/span&gt; -abs(a - b) &amp;gt; h[&lt;span&gt;0&lt;/span&gt;]:&lt;br/&gt;                    heapq.heappop(h)&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; len(h) &amp;lt; k:&lt;br/&gt;                    heapq.heappush(h, -abs(a - b))&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; -h[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(代码 1.3.5)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过这种优化意义不大，因为算法的瓶颈在于 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;N^2&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 -833.9 1358.6 833.9&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;msup&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(955, 363) scale(0.707)&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt; 部分的枚举，我们应当设法优化这一点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们将数对进行排序，那么最小的数对距离一定在 nums[i] - nums[i - 1] 中，其中 i 为从 1 到 n 的整数，究竟是哪个取决于谁更小。接下来就可以使用上面多路归并的思路来解决了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 nums[i] - nums[i - 1] 的差是最小的，那么第 2 小的一定是剩下的 n - 1 种情况和 nums[i] - nums[i - 1] 分裂的新情况。关于如何分裂，和上面类似，我们只需要移动其中 i 的指针为 i + 1 即可。这里的指针数组长度固定为 2，而不是上面题目中的 m。这里我将两个指针分别命名为 fr 和 to，分别代表 from 和 to。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;&lt;span&gt;(object)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;smallestDistancePair&lt;/span&gt;&lt;span&gt;(self, nums, k)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        nums.sort()&lt;br/&gt;        &lt;span&gt;# n 种候选答案&lt;/span&gt;&lt;br/&gt;        h = [(nums[i+&lt;span&gt;1&lt;/span&gt;] - nums[i], i, i+&lt;span&gt;1&lt;/span&gt;) &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(len(nums) - &lt;span&gt;1&lt;/span&gt;)]&lt;br/&gt;        heapq.heapify(h)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt; range(k):&lt;br/&gt;            diff, fr, to = heapq.heappop(h)&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; to + &lt;span&gt;1&lt;/span&gt; &amp;lt; len(nums):&lt;br/&gt;                heapq.heappush((nums[to + &lt;span&gt;1&lt;/span&gt;] - nums[fr], fr, to + &lt;span&gt;1&lt;/span&gt;))&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; diff&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(代码 1.3.6)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于时间复杂度和 k 有关，而 k 最多可能达到 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;N^2&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 -833.9 1358.6 833.9&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;msup&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mn&quot; transform=&quot;translate(955, 363) scale(0.707)&quot;&gt;&lt;path data-c=&quot;32&quot; d=&quot;M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt; 的量级，因此此方法实际上也会超时。&lt;strong&gt;「不过这证明了这种思路的正确性，如果题目稍加改变说不定就能用上」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题可通过二分法来解决，由于和堆主题有偏差，因此这里简单讲一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;求第 k 小的数比较容易想到的就是堆和二分法。二分的原因在于求第 k 小，本质就是求不大于其本身的有 k - 1 个的那个数。而这个问题很多时候满足单调性，因此就可使用二分来解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以这道题来说，最大的数对差就是数组的最大值 - 最小值，不妨记为 max_diff。我们可以这样发问：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数对差小于 max_diff 的有几个？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数对差小于 max_diff - 1 的有几个？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数对差小于 max_diff - 2 的有几个？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数对差小于 max_diff - 3 的有几个？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数对差小于 max_diff - 4 的有几个？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;。。。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而我们知道，发问的答案也是不严格递减的，因此使用二分就应该被想到。我们不断发问直到问到&lt;strong&gt;「小于 x 的有 k - 1 个」&lt;/strong&gt;即可。然而这样的发问也有问题。原因有两个：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;小于 x 的有 k - 1 个的数可能不止一个&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们无法确定小于 x 的有 k - 1 个的数一定存在。比如数对差分别为 [1,1,1,1,2]，让你求第 3 大的，那么小于 x 有两个的数根本就不存在。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的思路可调整为求&lt;strong&gt;「小于等于 x」&lt;/strong&gt; 有 k 个的，接下来我们使用二分法的最左模板即可解决。关于最左模板可参考我的二分查找专题&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;smallestDistancePair&lt;/span&gt;&lt;span&gt;(self, A: List[int], K: int)&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;br/&gt;        A.sort()&lt;br/&gt;        l, r = &lt;span&gt;0&lt;/span&gt;, A[&lt;span&gt;-1&lt;/span&gt;] - A[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;count_ngt&lt;/span&gt;&lt;span&gt;(mid)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;            slow = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;            ans = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; fast &lt;span&gt;in&lt;/span&gt; range(len(A)):&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; A[fast] - A[slow] &amp;gt; mid:&lt;br/&gt;                    slow += &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;                ans += fast - slow&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; ans&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; l &amp;lt;= r:&lt;br/&gt;            mid = (l + r) // &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; count_ngt(mid) &amp;gt;= K:&lt;br/&gt;                r = mid - &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;                l = mid + &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; l&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(代码 1.3.7)&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;632. 最小区间&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;题目描述&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;你有 k 个 非递减排列 的整数列表。找到一个 最小 区间，使得 k 个列表中的每个列表至少有一个数包含在其中。&lt;br/&gt;&lt;br/&gt;我们定义如果 b&lt;span&gt;-a&lt;/span&gt; &amp;lt; d-c 或者在 b&lt;span&gt;-a&lt;/span&gt; == d-c 时 a &amp;lt; c，则区间 [a,b] 比 [c,d] 小。&lt;br/&gt;&lt;br/&gt; &lt;br/&gt;&lt;br/&gt;示例 1：&lt;br/&gt;&lt;br/&gt;输入：nums = [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]&lt;br/&gt;输出：[20,24]&lt;br/&gt;解释：&lt;br/&gt;列表 1：[4, 10, 15, 24, 26]，24 在区间 [20,24] 中。&lt;br/&gt;列表 2：[0, 9, 12, 20]，20 在区间 [20,24] 中。&lt;br/&gt;列表 3：[5, 18, 22, 30]，22 在区间 [20,24] 中。&lt;br/&gt;示例 2：&lt;br/&gt;&lt;br/&gt;输入：nums = [[1,2,3],[1,2,3],[1,2,3]]&lt;br/&gt;输出：[1,1]&lt;br/&gt;示例 3：&lt;br/&gt;&lt;br/&gt;输入：nums = [[10,10],[11,11]]&lt;br/&gt;输出：[10,11]&lt;br/&gt;示例 4：&lt;br/&gt;&lt;br/&gt;输入：nums = [[10],[11]]&lt;br/&gt;输出：[10,11]&lt;br/&gt;示例 5：&lt;br/&gt;&lt;br/&gt;输入：nums = [[1],[2],[3],[4],[5],[6],[7]]&lt;br/&gt;输出：[1,7]&lt;br/&gt; &lt;br/&gt;&lt;br/&gt;提示：&lt;br/&gt;&lt;br/&gt;nums.length == k&lt;br/&gt;1 &amp;lt;= k &amp;lt;= 3500&lt;br/&gt;1 &amp;lt;= nums[i].length &amp;lt;= 50&lt;br/&gt;-105 &amp;lt;= nums[i][j] &amp;lt;= 105&lt;br/&gt;nums[i] 按非递减顺序排列&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;思路&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题本质上就是&lt;strong&gt;「在 m 个一维数组中各取出一个数字，重新组成新的数组 A，使得新的数组 A 中最大值和最小值的差值（diff）最小」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题和上面的题目有点类似，又略有不同。这道题是一个矩阵，上面一道题是一维数组。不过我们可以将二维矩阵看出一维数组，这样我们就可以沿用上面的思路了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的思路 diff 最小的一定产生于排序之后相邻的元素之间。而这道题我们无法直接对二维数组进行排序，而且即使进行排序，也不好确定排序的原则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们其实可以继续使用前面两道题的思路。具体来说就是使用&lt;strong&gt;「小顶堆获取堆中最小值」&lt;/strong&gt;，进而通过&lt;strong&gt;「一个变量记录堆中的最大值」&lt;/strong&gt;，这样就知道了 diff，每次更新指针都会产生一个新的 diff，不断重复这个过程并维护全局最小 diff 即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种算法的成立的前提是 k 个列表都是升序排列的，这里需要数组升序原理和上面题目是一样的，有序之后就可以对每个列表维护一个指针，进而使用上面的思路解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以题目中的 nums = [[1,2,3],[1,2,3],[1,2,3]] 为例：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先选取所有行的最小值，也就是 [1,1,1]，这时的 diff 为 0，全局最大值为 1，最小值也为 1。接下来，继续寻找备胎，看有没有更好的备胎供我们选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来的备胎可能产生于情况 1：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;[&lt;strong&gt;「1」&lt;/strong&gt;,2,3]&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;[&lt;strong&gt;「1」&lt;/strong&gt;,2,3]&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;[1,&lt;strong&gt;「2」&lt;/strong&gt;,3] 移动了这行的指针，将其从原来的 0 移动一个单位到达 1。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者情况 2：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;[&lt;strong&gt;「1」&lt;/strong&gt;,2,3]&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;[1,&lt;strong&gt;「2」&lt;/strong&gt;,3]移动了这行的指针，将其从原来的 0 移动一个单位到达 1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;[&lt;strong&gt;「1」&lt;/strong&gt;,2,3]&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这几种情况又继续分裂更多的情况，这个就和上面的题目一样了，不再赘述。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;smallestRange&lt;/span&gt;&lt;span&gt;(self, martrix: List[List[int]])&lt;/span&gt; -&amp;gt; List[int]:&lt;/span&gt;&lt;br/&gt;        l, r = &lt;span&gt;-10&lt;/span&gt;**&lt;span&gt;9&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;**&lt;span&gt;9&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 将每一行最小的都放到堆中，同时记录其所在的行号和列号，一共 n 个齐头并进&lt;/span&gt;&lt;br/&gt;        h = [(row[&lt;span&gt;0&lt;/span&gt;], i, &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;for&lt;/span&gt; i, row &lt;span&gt;in&lt;/span&gt; enumerate(martrix)]&lt;br/&gt;        heapq.heapify(h)&lt;br/&gt;        &lt;span&gt;# 维护最大值&lt;/span&gt;&lt;br/&gt;        max_v = max(row[&lt;span&gt;0&lt;/span&gt;] &lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; martrix)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;:&lt;br/&gt;            min_v, row, col = heapq.heappop(h)&lt;br/&gt;            &lt;span&gt;# max_v - min_v 是当前的最大最小差值， r - l 为全局的最大最小差值。因为如果当前的更小，我们就更新全局结果&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; max_v - min_v &amp;lt; r - l:&lt;br/&gt;                l, r = min_v, max_v&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; col == len(martrix[row]) - &lt;span&gt;1&lt;/span&gt;: &lt;span&gt;return&lt;/span&gt; [l, r]&lt;br/&gt;            &lt;span&gt;# 更新指针，继续往后移动一位&lt;/span&gt;&lt;br/&gt;            heapq.heappush(h, (martrix[row][col + &lt;span&gt;1&lt;/span&gt;], row, col + &lt;span&gt;1&lt;/span&gt;))&lt;br/&gt;            max_v = max(max_v, martrix[row][col + &lt;span&gt;1&lt;/span&gt;])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(代码 1.3.8)&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;1675. 数组的最小偏移量&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;题目描述&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;给你一个由 n 个正整数组成的数组 nums 。&lt;br/&gt;&lt;br/&gt;你可以对数组的任意元素执行任意次数的两类操作：&lt;br/&gt;&lt;br/&gt;如果元素是 偶数 ，除以 2&lt;br/&gt;例如，如果数组是 [1,2,3,4] ，那么你可以对最后一个元素执行此操作，使其变成 [1,2,3,2]&lt;br/&gt;如果元素是 奇数 ，乘上 2&lt;br/&gt;例如，如果数组是 [1,2,3,4] ，那么你可以对第一个元素执行此操作，使其变成 [2,2,3,4]&lt;br/&gt;数组的 偏移量 是数组中任意两个元素之间的 最大差值 。&lt;br/&gt;&lt;br/&gt;返回数组在执行某些操作之后可以拥有的 最小偏移量 。&lt;br/&gt;&lt;br/&gt;示例 1：&lt;br/&gt;&lt;br/&gt;输入：nums = [1,2,3,4]&lt;br/&gt;输出：1&lt;br/&gt;解释：你可以将数组转换为 [1,2,3,2]，然后转换成 [2,2,3,2]，偏移量是 3 - 2 = 1&lt;br/&gt;示例 2：&lt;br/&gt;&lt;br/&gt;输入：nums = [4,1,5,20,3]&lt;br/&gt;输出：3&lt;br/&gt;解释：两次操作后，你可以将数组转换为 [4,2,5,5,3]，偏移量是 5 - 2 = 3&lt;br/&gt;示例 3：&lt;br/&gt;&lt;br/&gt;输入：nums = [2,10,8]&lt;br/&gt;输出：3&lt;br/&gt;&lt;br/&gt;提示：&lt;br/&gt;&lt;br/&gt;n == nums.length&lt;br/&gt;2 &amp;lt;= n &amp;lt;= 105&lt;br/&gt;1 &amp;lt;= nums[i] &amp;lt;= 109&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;思路&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;题目说可对数组中每一项都执行任意次操作，但其实操作是有限的。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;我们只能对奇数进行一次 2 倍操作，因为 2 倍之后其就变成了偶数了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们可以对偶数进行若干次除 2 操作，直到等于一个奇数，不难看出这也是一个有限次的操作。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以题目中的 [1,2,3,4] 来说。我们可以：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将 1 变成 2（也可以不变）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 2 变成 1（也可以不变）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 3 变成 6（也可以不变）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将 4 变成 2 或 1（也可以不变）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用图来表示就是下面这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.7644444444444445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeP2mlIMBU8B7TXA1vuwEnWvS02yWZkg6JLZInh977s46bpfjz0JqW9EnTokrrIOpVZMrqIIQxRYQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;一维数组转二维数组&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这不就相当于: 从 [[1,2], [1,2], [3,6], [1,2,4]] 这样的一个二维数组中的每一行分别选取一个数，并使得其差最小么？这难道不是和上面的题目一模一样么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我直接将上面的题目解法封装成了一个 api 调用了，具体看代码。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;smallestRange&lt;/span&gt;&lt;span&gt;(self, martrix: List[List[int]])&lt;/span&gt; -&amp;gt; List[int]:&lt;/span&gt;&lt;br/&gt;        l, r = &lt;span&gt;-10&lt;/span&gt;**&lt;span&gt;9&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;**&lt;span&gt;9&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 将每一行最小的都放到堆中，同时记录其所在的行号和列号，一共 n 个齐头并进&lt;/span&gt;&lt;br/&gt;        h = [(row[&lt;span&gt;0&lt;/span&gt;], i, &lt;span&gt;0&lt;/span&gt;) &lt;span&gt;for&lt;/span&gt; i, row &lt;span&gt;in&lt;/span&gt; enumerate(martrix)]&lt;br/&gt;        heapq.heapify(h)&lt;br/&gt;        &lt;span&gt;# 维护最大值&lt;/span&gt;&lt;br/&gt;        max_v = max(row[&lt;span&gt;0&lt;/span&gt;] &lt;span&gt;for&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; martrix)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; &lt;span&gt;True&lt;/span&gt;:&lt;br/&gt;            min_v, row, col = heapq.heappop(h)&lt;br/&gt;            &lt;span&gt;# max_v - min_v 是当前的最大最小差值， r - l 为全局的最大最小差值。因为如果当前的更小，我们就更新全局结果&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; max_v - min_v &amp;lt; r - l:&lt;br/&gt;                l, r = min_v, max_v&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; col == len(martrix[row]) - &lt;span&gt;1&lt;/span&gt;: &lt;span&gt;return&lt;/span&gt; [l, r]&lt;br/&gt;            &lt;span&gt;# 更新指针，继续往后移动一位&lt;/span&gt;&lt;br/&gt;            heapq.heappush(h, (martrix[row][col + &lt;span&gt;1&lt;/span&gt;], row, col + &lt;span&gt;1&lt;/span&gt;))&lt;br/&gt;            max_v = max(max_v, martrix[row][col + &lt;span&gt;1&lt;/span&gt;])&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;minimumDeviation&lt;/span&gt;&lt;span&gt;(self, nums: List[int])&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;br/&gt;        matrix = [[] &lt;span&gt;for&lt;/span&gt; _ &lt;span&gt;in&lt;/span&gt; range(len(nums))]&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; i, num &lt;span&gt;in&lt;/span&gt; enumerate(nums):&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; num &amp;amp; &lt;span&gt;1&lt;/span&gt; == &lt;span&gt;1&lt;/span&gt;:&lt;br/&gt;                matrix[i] += [num, num * &lt;span&gt;2&lt;/span&gt;]&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;                temp = []&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; num &lt;span&gt;and&lt;/span&gt; num &amp;amp; &lt;span&gt;1&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;                    temp += [num]&lt;br/&gt;                    num //= &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;                temp += [num]&lt;br/&gt;                matrix[i] += temp[::&lt;span&gt;-1&lt;/span&gt;]&lt;br/&gt;        a, b = self.smallestRange(matrix)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; b - a&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(代码 1.3.9)&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;技巧三 - 事后小诸葛&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7938517179023508&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeP2mlIMBU8B7TXA1vuwEnW3uRYowgGEr2ckLrKAQTGuhJXc2n0IFCgejmcN8Q7Pyib7F9z8jhaLoQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;553&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个技巧指的是：当从左到右遍历的时候，我们是不知道右边是什么的，需要等到你到了右边之后才知道。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想知道右边是什么，一种简单的方式是遍历两次，第一次遍历将数据记录下来，当第二次遍历的时候，用上次遍历记录的数据。这是我们使用最多的方式。不过有时候，我们也可以在遍历到指定元素后，往前回溯，这样就可以边遍历边存储，使用一次遍历即可。具体来说就是将从左到右的数据全部收集起来，等到需要用的时候，从里面挑一个用。如果我们都要取最大值或者最小值且极值会发生变动， 就可&lt;strong&gt;「使用堆加速」&lt;/strong&gt;。直观上就是使用了时光机回到之前，达到了事后诸葛亮的目的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样说&lt;strong&gt;「你肯定不明白啥意思」&lt;/strong&gt;。没关系，我们通过几个例子来讲一下。当你看完这些例子之后，再回头看这句话。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;871. 最低加油次数&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;题目描述&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;汽车从起点出发驶向目的地，该目的地位于出发位置东面 target 英里处。&lt;br/&gt;&lt;br/&gt;沿途有加油站，每个 station[i] 代表一个加油站，它位于出发位置东面 station[i][0] 英里处，并且有 station[i][1] 升汽油。&lt;br/&gt;&lt;br/&gt;假设汽车油箱的容量是无限的，其中最初有 startFuel 升燃料。它每行驶 1 英里就会用掉 1 升汽油。&lt;br/&gt;&lt;br/&gt;当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。&lt;br/&gt;&lt;br/&gt;为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 -1 。&lt;br/&gt;&lt;br/&gt;注意：如果汽车到达加油站时剩余燃料为 0，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 0，仍然认为它已经到达目的地。&lt;br/&gt;&lt;br/&gt; &lt;br/&gt;&lt;br/&gt;示例 1：&lt;br/&gt;&lt;br/&gt;输入：target = 1, startFuel = 1, stations = []&lt;br/&gt;输出：0&lt;br/&gt;解释：我们可以在不加油的情况下到达目的地。&lt;br/&gt;示例 2：&lt;br/&gt;&lt;br/&gt;输入：target = 100, startFuel = 1, stations = [[10,100]]&lt;br/&gt;输出：-1&lt;br/&gt;解释：我们无法抵达目的地，甚至无法到达第一个加油站。&lt;br/&gt;示例 3：&lt;br/&gt;&lt;br/&gt;输入：target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]&lt;br/&gt;输出：2&lt;br/&gt;解释：&lt;br/&gt;我们出发时有 10 升燃料。&lt;br/&gt;我们开车来到距起点 10 英里处的加油站，消耗 10 升燃料。将汽油从 0 升加到 60 升。&lt;br/&gt;然后，我们从 10 英里处的加油站开到 60 英里处的加油站（消耗 50 升燃料），&lt;br/&gt;并将汽油从 10 升加到 50 升。然后我们开车抵达目的地。&lt;br/&gt;我们沿途在1两个加油站停靠，所以返回 2 。&lt;br/&gt; &lt;br/&gt;&lt;br/&gt;提示：&lt;br/&gt;&lt;br/&gt;1 &amp;lt;= target, startFuel, stations[i][1] &amp;lt;= 10^9&lt;br/&gt;0 &amp;lt;= stations.length &amp;lt;= 500&lt;br/&gt;0 &amp;lt; stations[0][0] &amp;lt; stations[1][0] &amp;lt; ... &amp;lt; stations[stations.length-1][0] &amp;lt; target&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;思路&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了能够获得&lt;strong&gt;「最低加油次数」&lt;/strong&gt;，我们肯定希望能不加油就不加油。那什么时候必须加油呢？答案应该是&lt;strong&gt;「如果你不加油，就无法到达下一个目的地的时候」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;伪代码描述就是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cur = startFuel &lt;span&gt;# 刚开始有 startFuel 升汽油&lt;/span&gt;&lt;br/&gt;last = &lt;span&gt;0&lt;/span&gt; &lt;span&gt;# 上一次的位置&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i, fuel &lt;span&gt;in&lt;/span&gt; stations:&lt;br/&gt;    cur -= i - last &lt;span&gt;# 走过两个 staton 的耗油为两个 station 的距离，也就是 i - last&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; cur &amp;lt; &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;# 我们必须在前面就加油，否则到不了这里&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 但是在前面的哪个 station 加油呢？&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 直觉告诉我们应该贪心地选择可以加汽油最多的站 i，如果加上 i 的汽油还是 cur &amp;lt; 0，继续加次大的站 j，直到没有更多汽油可加或者 cur &amp;gt; 0&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面说了要选择可以加汽油最多的站 i，如果加了油还不行，继续选择第二多的站。这种动态求极值的场景非常适合使用 heap。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体来说就是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;每经过一个站，就将其油量加到堆。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;尽可能往前开，油只要不小于 0 就继续开。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果油量小于 0 ，就从堆中取最大的加到油箱中去，如果油量还是小于 0 继续重复取堆中的最大油量。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果加完油之后油量大于 0 ，继续开，重复上面的步骤。否则返回 -1，表示无法到达目的地。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那这个算法是如何体现&lt;strong&gt;「事后小诸葛」&lt;/strong&gt;的呢？你可以把自己代入到题目中进行模拟。把自己想象成正在开车，你的目标就是题目中的要求：&lt;strong&gt;「最少加油次数」&lt;/strong&gt;。当你开到一个站的时候，你是不知道你的油量够不够支撑到下个站的，并且就算撑不到下个站，其实也许在上个站加油会更好。所以&lt;strong&gt;「现实中」&lt;/strong&gt;你无论如何都&lt;strong&gt;「无法知道在当前站，我是应该加油还是不加油的」&lt;/strong&gt;，因为信息太少了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8544303797468354&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeP2mlIMBU8B7TXA1vuwEnWQIz7lP55CiamKmCE1OW5Ta3gNV97Q7LEuEs2buJ1ibZiayX365tkvCWgg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;316&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那我会怎么做呢？如果是我在开车的话，我只能每次都加油，这样都无法到达目的地，那肯定就无法到达目的地了。但如果这样可以到达目的地，我就可以说&lt;strong&gt;「如果我们在那个站加油，这个站选择不加就可以最少加油次数到达目的地了」&lt;/strong&gt;。你怎么不早说呢？这不就是事后诸葛亮么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个事后诸葛亮体现在&lt;strong&gt;「我们是等到没油了才去想应该在之前的某个站加油」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这个事后诸葛亮本质上解决的是，基于当前信息无法获取最优解，我们必须掌握全部信息之后回溯。以这道题来说，我们可以先遍历一边 station，然后将每个 station 的油量记录到一个数组中，每次我们“预见“到无法到达下个站的时候，就从这个数组中取最大的。。。。基于此，我们可以考虑使用堆优化取极值的过程，而不是使用数组的方式。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;minRefuelStops&lt;/span&gt;&lt;span&gt;(self, target: int, startFuel: int, stations: List[List[int]])&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;br/&gt;        stations += [(target, &lt;span&gt;0&lt;/span&gt;)]&lt;br/&gt;        cur = startFuel&lt;br/&gt;        ans = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        h = []&lt;br/&gt;        last = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; i, fuel &lt;span&gt;in&lt;/span&gt; stations:&lt;br/&gt;            cur -= i - last&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; cur &amp;lt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; h:&lt;br/&gt;                cur -= heapq.heappop(h)&lt;br/&gt;                ans += &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; cur &amp;lt; &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;&lt;br/&gt;            heappush(h, -fuel)&lt;br/&gt;&lt;br/&gt;            last = i&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ans&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(代码 1.3.10)&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;1488. 避免洪水泛滥&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;题目描述&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;你的国家有无数个湖泊，所有湖泊一开始都是空的。当第 n 个湖泊下雨的时候，如果第 n 个湖泊是空的，那么它就会装满水，否则这个湖泊会发生洪水。你的目标是避免任意一个湖泊发生洪水。&lt;br/&gt;&lt;br/&gt;给你一个整数数组 rains ，其中：&lt;br/&gt;&lt;br/&gt;rains[i] &amp;gt; 0 表示第 i 天时，第 rains[i] 个湖泊会下雨。&lt;br/&gt;rains[i] == 0 表示第 i 天没有湖泊会下雨，你可以选择 一个 湖泊并 抽干 这个湖泊的水。&lt;br/&gt;请返回一个数组 ans ，满足：&lt;br/&gt;&lt;br/&gt;ans.length == rains.length&lt;br/&gt;如果 rains[i] &amp;gt; 0 ，那么ans[i] == -1 。&lt;br/&gt;如果 rains[i] == 0 ，ans[i] 是你第 i 天选择抽干的湖泊。&lt;br/&gt;如果有多种可行解，请返回它们中的 任意一个 。如果没办法阻止洪水，请返回一个 空的数组 。&lt;br/&gt;&lt;br/&gt;请注意，如果你选择抽干一个装满水的湖泊，它会变成一个空的湖泊。但如果你选择抽干一个空的湖泊，那么将无事发生（详情请看示例 4）。&lt;br/&gt;&lt;br/&gt; &lt;br/&gt;&lt;br/&gt;示例 1：&lt;br/&gt;&lt;br/&gt;输入：rains = [1,2,3,4]&lt;br/&gt;输出：[-1,-1,-1,-1]&lt;br/&gt;解释：第一天后，装满水的湖泊包括 [1]&lt;br/&gt;第二天后，装满水的湖泊包括 [1,2]&lt;br/&gt;第三天后，装满水的湖泊包括 [1,2,3]&lt;br/&gt;第四天后，装满水的湖泊包括 [1,2,3,4]&lt;br/&gt;没有哪一天你可以抽干任何湖泊的水，也没有湖泊会发生洪水。&lt;br/&gt;示例 2：&lt;br/&gt;&lt;br/&gt;输入：rains = [1,2,0,0,2,1]&lt;br/&gt;输出：[-1,-1,2,1,-1,-1]&lt;br/&gt;解释：第一天后，装满水的湖泊包括 [1]&lt;br/&gt;第二天后，装满水的湖泊包括 [1,2]&lt;br/&gt;第三天后，我们抽干湖泊 2 。所以剩下装满水的湖泊包括 [1]&lt;br/&gt;第四天后，我们抽干湖泊 1 。所以暂时没有装满水的湖泊了。&lt;br/&gt;第五天后，装满水的湖泊包括 [2]。&lt;br/&gt;第六天后，装满水的湖泊包括 [1,2]。&lt;br/&gt;可以看出，这个方案下不会有洪水发生。同时， [-1,-1,1,2,-1,-1] 也是另一个可行的没有洪水的方案。&lt;br/&gt;示例 3：&lt;br/&gt;&lt;br/&gt;输入：rains = [1,2,0,1,2]&lt;br/&gt;输出：[]&lt;br/&gt;解释：第二天后，装满水的湖泊包括 [1,2]。我们可以在第三天抽干一个湖泊的水。&lt;br/&gt;但第三天后，湖泊 1 和 2 都会再次下雨，所以不管我们第三天抽干哪个湖泊的水，另一个湖泊都会发生洪水。&lt;br/&gt;示例 4：&lt;br/&gt;&lt;br/&gt;输入：rains = [69,0,0,0,69]&lt;br/&gt;输出：[-1,69,1,1,-1]&lt;br/&gt;解释：任何形如 [-1,69,x,y,-1], [-1,x,69,y,-1] 或者 [-1,x,y,69,-1] 都是可行的解，其中 1 &amp;lt;= x,y &amp;lt;= 10^9&lt;br/&gt;示例 5：&lt;br/&gt;&lt;br/&gt;输入：rains = [10,20,20]&lt;br/&gt;输出：[]&lt;br/&gt;解释：由于湖泊 20 会连续下 2 天的雨，所以没有没有办法阻止洪水。&lt;br/&gt; &lt;br/&gt;&lt;br/&gt;提示：&lt;br/&gt;&lt;br/&gt;1 &amp;lt;= rains.length &amp;lt;= 10^5&lt;br/&gt;0 &amp;lt;= rains[i] &amp;lt;= 10^9&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;思路&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果上面的题用&lt;strong&gt;「事后诸葛亮」&lt;/strong&gt;描述比较牵强的话，那后面这两个题可以说很适合了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;题目说明了我们可以在不下雨的时候抽干一个湖泊，如果有多个下满雨的湖泊，我们该抽干哪个湖呢？显然应该是抽干最近即将被洪水淹没的湖。但是现实中无论如何我们都不可能知道未来哪天哪个湖泊会下雨的，即使有天气预报也不行，因此它也不 100% 可靠。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是代码可以啊。我们可以先遍历一遍 rain 数组就知道第几天哪个湖泊下雨了。有了这个信息，我们就可以事后诸葛亮了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“今天天气很好，我开了天眼，明天湖泊 2 会被洪水淹没，我们今天就先抽干它，否则就洪水泛滥了。”。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6458072590738423&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeP2mlIMBU8B7TXA1vuwEnWfbZxAIXMvCsVsEWricVR5tQbszZJ8OLN19gWP2RZlqSwwLPRcbqyctw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;799&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和上面的题目一样，我们也可以不先遍历 rain 数组，再模拟每天的变化，而是直接模拟，即使当前是晴天我们也不抽干任何湖泊。接着在模拟的过程&lt;strong&gt;「记录晴天的情况」&lt;/strong&gt;，等到洪水发生的时候，我们再考虑前面&lt;strong&gt;「哪一个晴天」&lt;/strong&gt;应该抽干哪个湖泊。因此这个事后诸葛亮体现在&lt;strong&gt;「我们是等到洪水泛滥了才去想应该在之前的某天采取什么手段」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;算法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;遍历 rain， 模拟每天的变化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 rain 当前是 0 表示当前是晴天，我们不抽干任何湖泊。但是我们将当前天记录到 sunny 数组。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 rain 大于 0，说明有一个湖泊下雨了，我们去看下下雨的这个湖泊是否发生了洪水泛滥。其实就是看下下雨前是否已经有水了。这提示我们用一个数据结构 lakes 记录每个湖泊的情况，我们可以用 0 表示没有水，1 表示有水。这样当湖泊 i 下雨的时候且 lakes[i] = 1 就会发生洪水泛滥。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果当前湖泊发生了洪水泛滥，那么就去 sunny 数组找一个晴天去抽干它，这样它就不会洪水泛滥，接下来只需要保持 lakes[i] = 1 即可。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题没有使用到堆，我是故意的。之所以这么做，是让大家明白&lt;strong&gt;「事后诸葛亮」&lt;/strong&gt;这个技巧并不是堆特有的，实际上这就是一种普通的算法思想，就好像从后往前遍历一样。只不过，很多时候，我们&lt;strong&gt;「事后诸葛亮」&lt;/strong&gt;的场景，需要动态取最大最小值， 这个时候就应该考虑使用堆了，这其实又回到文章开头的&lt;strong&gt;「一个中心」&lt;/strong&gt;了，所以大家一定要灵活使用这些技巧，不可生搬硬套。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下一道题是一个不折不扣的&lt;strong&gt;「事后诸葛亮」&lt;/strong&gt; + &lt;strong&gt;「堆优化」&lt;/strong&gt;的题目。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;avoidFlood&lt;/span&gt;&lt;span&gt;(self, rains: List[int])&lt;/span&gt; -&amp;gt; List[int]:&lt;/span&gt;&lt;br/&gt;        ans = [&lt;span&gt;1&lt;/span&gt;] * len(rains)&lt;br/&gt;        lakes = collections.defaultdict(int)&lt;br/&gt;        sunny = []&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; i, rain &lt;span&gt;in&lt;/span&gt; enumerate(rains):&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; rain &amp;gt; &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;                ans[i] = &lt;span&gt;-1&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; lakes[rain - &lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;1&lt;/span&gt;:&lt;br/&gt;                    &lt;span&gt;if&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; == len(sunny):&lt;br/&gt;                        &lt;span&gt;return&lt;/span&gt; []&lt;br/&gt;                    ans[sunny.pop()] = rain&lt;br/&gt;                lakes[rain - &lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;                sunny.append(i)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ans&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(代码 1.3.11)&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;1642. 可以到达的最远建筑&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;题目描述&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;给你一个整数数组 heights ，表示建筑物的高度。另有一些砖块 bricks 和梯子 ladders 。&lt;br/&gt;&lt;br/&gt;你从建筑物 0 开始旅程，不断向后面的建筑物移动，期间可能会用到砖块或梯子。&lt;br/&gt;&lt;br/&gt;当从建筑物 i 移动到建筑物 i+1（下标 从 0 开始 ）时：&lt;br/&gt;&lt;br/&gt;如果当前建筑物的高度 大于或等于 下一建筑物的高度，则不需要梯子或砖块&lt;br/&gt;如果当前建筑的高度 小于 下一个建筑的高度，您可以使用 一架梯子 或 (h[i+1] - h[i]) 个砖块&lt;br/&gt;如果以最佳方式使用给定的梯子和砖块，返回你可以到达的最远建筑物的下标（下标 从 0 开始 ）。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.998220640569395&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/liaT5dytkaTeP2mlIMBU8B7TXA1vuwEnW27rj3ibMmUpf8kSDNO4VWVjjolEep4lpEKX9V2rD4ykSxZg8kdHHqtA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;562&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;示例 1：&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;输入：heights = [4,2,7,6,9,14,12], bricks = 5, ladders = 1&lt;br/&gt;输出：4&lt;br/&gt;解释：从建筑物 0 出发，你可以按此方案完成旅程：&lt;br/&gt;- 不使用砖块或梯子到达建筑物 1 ，因为 4 &amp;gt;= 2&lt;br/&gt;- 使用 5 个砖块到达建筑物 2 。你必须使用砖块或梯子，因为 2 &amp;lt; 7&lt;br/&gt;- 不使用砖块或梯子到达建筑物 3 ，因为 7 &amp;gt;= 6&lt;br/&gt;- 使用唯一的梯子到达建筑物 4 。你必须使用砖块或梯子，因为 6 &amp;lt; 9&lt;br/&gt;无法越过建筑物 4 ，因为没有更多砖块或梯子。&lt;br/&gt;示例 2：&lt;br/&gt;&lt;br/&gt;输入：heights = [4,12,2,7,3,18,20,3,19], bricks = 10, ladders = 2&lt;br/&gt;输出：7&lt;br/&gt;示例 3：&lt;br/&gt;&lt;br/&gt;输入：heights = [14,3,19,3], bricks = 17, ladders = 0&lt;br/&gt;输出：3&lt;br/&gt; &lt;br/&gt;&lt;br/&gt;提示：&lt;br/&gt;&lt;br/&gt;1 &amp;lt;= heights.length &amp;lt;= 105&lt;br/&gt;1 &amp;lt;= heights[i] &amp;lt;= 106&lt;br/&gt;0 &amp;lt;= bricks &amp;lt;= 109&lt;br/&gt;0 &amp;lt;= ladders &amp;lt;= heights.length&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;思路&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以将梯子看出是无限的砖块，只不过只能使用一次，我们当然希望能将好梯用在刀刃上。和上面一样，如果是现实生活，我们是无法知道啥时候用梯子好，啥时候用砖头好的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没关系，我们继续使用事后诸葛亮法，一次遍历就可完成。和前面的思路类似，那就是我无脑用梯子，等梯子不够用了，我们就要开始事后诸葛亮了，&lt;strong&gt;「要是前面用砖头就好了」&lt;/strong&gt;。那什么时候用砖头就好了呢？很明显就是当初用梯子的时候高度差，比现在的高度差小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直白点就是当初我用梯子爬了个 5 米的墙，现在这里有个十米的墙，我没梯子了，只能用 10 个砖头了。要是之前用 5 个砖头，现在不就可以用一个梯子，从而省下 5 个砖头了吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这提示我们将用前面用梯子跨越的建筑物高度差存起来，等到后面梯子用完了，我们将前面被用的梯子“兑换”成砖头继续用。以上面的例子来说，我们就可以先兑换 10 个砖头，然后将 5 个砖头用掉，也就是相当于增加了 5 个砖头。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果前面多次使用了梯子，我们优先“兑换”哪次呢？显然是优先兑换&lt;strong&gt;「高度差」&lt;/strong&gt;大的，这样兑换的砖头才最多。这提示每次都从之前存储的高度差中选最大的，并在“兑换”之后将其移除。这种&lt;strong&gt;「动态求极值」&lt;/strong&gt;的场景用什么数据结构合适？当然是堆啦。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;代码&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;furthestBuilding&lt;/span&gt;&lt;span&gt;(self, heights: List[int], bricks: int, ladders: int)&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;br/&gt;        h = []&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(&lt;span&gt;1&lt;/span&gt;, len(heights)):&lt;br/&gt;            diff = heights[i] - heights[i - &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; diff &amp;lt;= &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;                &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; bricks &amp;lt; diff &lt;span&gt;and&lt;/span&gt; ladders &amp;gt; &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;                ladders -= &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; h &lt;span&gt;and&lt;/span&gt; -h[&lt;span&gt;0&lt;/span&gt;] &amp;gt; diff:&lt;br/&gt;                    bricks -= heapq.heappop(h)&lt;br/&gt;                &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;                    &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;            bricks -= diff&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; bricks &amp;lt; &lt;span&gt;0&lt;/span&gt;:&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; i - &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;            heapq.heappush(h, -diff)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; len(heights) - &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(代码 1.3.12)&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四大应用&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来是本文的最后一个部分《四大应用》，目的是通过这几个例子来帮助大家巩固前面的知识。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;1. topK&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;求解 topK 是堆的一个很重要的功能。这个其实已经在前面的&lt;strong&gt;「固定堆」&lt;/strong&gt;部分给大家介绍过了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里直接引用前面的话：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“其实求第 k 小的数最简单的思路是建立小顶堆，将所有的数先全部入堆，然后逐个出堆，一共出堆 k 次。最后一次出堆的就是第 k 小的数。然而，我们也可不先全部入堆，而是建立大顶堆（注意不是上面的小顶堆），并维持堆的大小为 k 个。如果新的数入堆之后堆的大小大于 k，则需要将堆顶的数和新的数进行比较，并将较大的移除。这样可以保证堆中的数是全体数字中最小的 k 个，而这最小的 k 个中最大的（即堆顶）不就是第 k 小的么？这也就是选择建立大顶堆，而不是小顶堆的原因。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实除了第 k 小的数，我们也可以将中间的数全部收集起来，这就可以求出最小的 &lt;strong&gt;「k 个数」&lt;/strong&gt;。和上面第 k 小的数唯一不同的点在于需要收集 popp 出来的所有的数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，有时候权重并不是原本数组值本身的大小，也可以是距离，出现频率等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相关题目：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;面试题 17.14. 最小 K 个数&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;347. 前 K 个高频元素&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;973. 最接近原点的 K 个点&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;力扣中有关第 k 的题目很多都是堆。除了堆之外，第 k 的题目其实还会有一些&lt;strong&gt;「找规律」&lt;/strong&gt;的题目，对于这种题目则可以通过&lt;strong&gt;「分治+递归」&lt;/strong&gt;的方式来解决，具体就不再这里展开了，感兴趣的可以和我留言讨论。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;2. 带权最短距离&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于这点，其实我在前面部分也提到过了，只不过当时只是一带而过。原话是“不过 BFS 真的就没人用优先队列实现么？当然不是！比如带权图的最短路径问题，如果用队列做 BFS 那就需要优先队列才可以，因为路径之间是有&lt;strong&gt;「权重的差异」&lt;/strong&gt;的，这不就是优先队列的设计初衷么。&lt;strong&gt;「使用优先队列的 BFS 实现典型的就是 dijkstra 算法」&lt;/strong&gt;。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DIJKSTRA 算法主要解决的是图中任意两点的最短距离。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;算法的基本思想是贪心，每次都遍历所有邻居，并从中找到距离最小的，本质上是一种广度优先遍历。这里我们借助堆这种数据结构，使得可以在 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;logN&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 -694 2148 899&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;6C&quot; d=&quot;M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(298, 0)&quot;&gt;&lt;path data-c=&quot;6F&quot; d=&quot;M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(783, 0)&quot;&gt;&lt;path data-c=&quot;67&quot; d=&quot;M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1260, 0)&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt; 的时间内找到 cost 最小的点，其中 N 为 堆的大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码模板：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;dijkstra&lt;/span&gt;&lt;span&gt;(graph, start, end)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# 堆里的数据都是 (cost, i) 的二元祖，其含义是“从 start 走到 i 的距离是 cost”。&lt;/span&gt;&lt;br/&gt;    heap = [(&lt;span&gt;0&lt;/span&gt;, start)]&lt;br/&gt;    visited = set()&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; heap:&lt;br/&gt;        (cost, u) = heapq.heappop(heap)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; u &lt;span&gt;in&lt;/span&gt; visited:&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;        visited.add(u)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; u == end:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; cost&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; v, c &lt;span&gt;in&lt;/span&gt; graph[u]:&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; v &lt;span&gt;in&lt;/span&gt; visited:&lt;br/&gt;                &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;            next = cost + c&lt;br/&gt;            heapq.heappush(heap, (next, v))&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(代码 1.4.1)&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;可以看出代码模板和 BFS 基本是类似的。如果你自己将堆的 key 设定为 steps 也可模拟实现 BFS，这个在前面已经讲过了，这里不再赘述。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如一个图是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;E -- 1 --&amp;gt; B -- 1 --&amp;gt; C -- 1 --&amp;gt; D -- 1 --&amp;gt; F&lt;br/&gt; \                                         /\&lt;br/&gt;  \                                        ||&lt;br/&gt;    -------- 2 ---------&amp;gt; G ------- 1 ------&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用邻接矩阵来构造：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;G = {&lt;br/&gt;    &lt;span&gt;&quot;B&quot;&lt;/span&gt;: [[&lt;span&gt;&quot;C&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;]],&lt;br/&gt;    &lt;span&gt;&quot;C&quot;&lt;/span&gt;: [[&lt;span&gt;&quot;D&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;]],&lt;br/&gt;    &lt;span&gt;&quot;D&quot;&lt;/span&gt;: [[&lt;span&gt;&quot;F&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;]],&lt;br/&gt;    &lt;span&gt;&quot;E&quot;&lt;/span&gt;: [[&lt;span&gt;&quot;B&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;], [&lt;span&gt;&quot;G&quot;&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;]],&lt;br/&gt;    &lt;span&gt;&quot;F&quot;&lt;/span&gt;: [],&lt;br/&gt;    &lt;span&gt;&quot;G&quot;&lt;/span&gt;: [[&lt;span&gt;&quot;F&quot;&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;]],&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;shortDistance = dijkstra(G, &lt;span&gt;&quot;E&quot;&lt;/span&gt;, &lt;span&gt;&quot;C&quot;&lt;/span&gt;)&lt;br/&gt;print(shortDistance)  &lt;span&gt;# E -- 3 --&amp;gt; F -- 3 --&amp;gt; C == 6&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;会了这个算法模板， 你就可以去 AC &lt;span&gt;743. 网络延迟时间&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt; 了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;dijkstra&lt;/span&gt;&lt;span&gt;(self, graph, start, end)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        heap = [(&lt;span&gt;0&lt;/span&gt;, start)]&lt;br/&gt;        visited = set()&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; heap:&lt;br/&gt;            (cost, u) = heapq.heappop(heap)&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; u &lt;span&gt;in&lt;/span&gt; visited:&lt;br/&gt;                &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;            visited.add(u)&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; u == end:&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; cost&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; v, c &lt;span&gt;in&lt;/span&gt; graph[u]:&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; v &lt;span&gt;in&lt;/span&gt; visited:&lt;br/&gt;                    &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;                next = cost + c&lt;br/&gt;                heapq.heappush(heap, (next, v))&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;networkDelayTime&lt;/span&gt;&lt;span&gt;(self, times: List[List[int]], N: int, K: int)&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;br/&gt;        graph = collections.defaultdict(list)&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; fr, to, w &lt;span&gt;in&lt;/span&gt; times:&lt;br/&gt;            graph[fr - &lt;span&gt;1&lt;/span&gt;].append((to - &lt;span&gt;1&lt;/span&gt;, w))&lt;br/&gt;        ans = &lt;span&gt;-1&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; to &lt;span&gt;in&lt;/span&gt; range(N):&lt;br/&gt;            &lt;span&gt;# 调用封装好的 dijkstra 方法&lt;/span&gt;&lt;br/&gt;            dist = self.dijkstra(graph, K - &lt;span&gt;1&lt;/span&gt;, to)&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; dist == &lt;span&gt;-1&lt;/span&gt;: &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;&lt;br/&gt;            ans = max(ans, dist)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ans&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(代码 1.4.2)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你学会了么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的算法并不是最优解，我只是为了体现&lt;strong&gt;「将 dijkstra 封装为 api 调用」&lt;/strong&gt; 的思想。一个更好的做法是一次遍历记录所有的距离信息，而不是每次都重复计算。时间复杂度会大大降低。这在计算一个点到图中所有点的距离时有很大的意义。为了实现这个目的，我们的算法会有什么样的调整？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;提示：你可以使用一个 dist 哈希表记录开始点到每个点的最短距离来完成。想出来的话，可以用力扣 882 题去验证一下哦~&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实只需要做一个小的调整就可以了，由于调整很小，直接看代码会比较好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;dijkstra&lt;/span&gt;&lt;span&gt;(self, graph, start, end)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        heap = [(&lt;span&gt;0&lt;/span&gt;, start)]  &lt;span&gt;# cost from start node,end node&lt;/span&gt;&lt;br/&gt;        dist = {}&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; heap:&lt;br/&gt;            (cost, u) = heapq.heappop(heap)&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; u &lt;span&gt;in&lt;/span&gt; dist:&lt;br/&gt;                &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;            dist[u] = cost&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; v, c &lt;span&gt;in&lt;/span&gt; graph[u]:&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; v &lt;span&gt;in&lt;/span&gt; dist:&lt;br/&gt;                    &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;                next = cost + c&lt;br/&gt;                heapq.heappush(heap, (next, v))&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; dist&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;networkDelayTime&lt;/span&gt;&lt;span&gt;(self, times: List[List[int]], N: int, K: int)&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;br/&gt;        graph = collections.defaultdict(list)&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; fr, to, w &lt;span&gt;in&lt;/span&gt; times:&lt;br/&gt;            graph[fr - &lt;span&gt;1&lt;/span&gt;].append((to - &lt;span&gt;1&lt;/span&gt;, w))&lt;br/&gt;        ans = &lt;span&gt;-1&lt;/span&gt;&lt;br/&gt;        dist = self.dijkstra(graph, K - &lt;span&gt;1&lt;/span&gt;, to)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; len(dist) != N &lt;span&gt;else&lt;/span&gt; max(dist.values())&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(代码 1.4.3)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出我们只是将 visitd 替换成了 dist，其他不变。另外 dist 其实只是带了 key 的 visited，它这里也起到了 visitd 的作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你需要计算一个节点到其他所有节点的最短路径，可以使用一个 dist （一个 hashmap）来记录出发点到所有点的最短路径信息，而不是使用 visited （一个 hashset）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类似的题目也不少， 我再举一个给大家 &lt;span&gt;787. K 站中转内最便宜的航班&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;。题目描述：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;有 n 个城市通过 m 个航班连接。每个航班都从城市 u 开始，以价格 w 抵达 v。&lt;br/&gt;&lt;br/&gt;现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到从 src 到 dst 最多经过 k 站中转的最便宜的价格。 如果没有这样的路线，则输出 -1。&lt;br/&gt;&lt;br/&gt; &lt;br/&gt;&lt;br/&gt;示例 1：&lt;br/&gt;&lt;br/&gt;输入:&lt;br/&gt;n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]&lt;br/&gt;src = 0, dst = 2, k = 1&lt;br/&gt;输出: 200&lt;br/&gt;解释:&lt;br/&gt;城市航班图如下&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7317073170731707&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeP2mlIMBU8B7TXA1vuwEnW3kZ8kIjAkNphZqVu9SHmJajAiaQw1uUJPqzbCm8H7IYiaGRqPZj2uJag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;492&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;br/&gt;从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。&lt;br/&gt;示例 2：&lt;br/&gt;&lt;br/&gt;输入:&lt;br/&gt;n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]&lt;br/&gt;src = 0, dst = 2, k = 0&lt;br/&gt;输出: 500&lt;br/&gt;解释:&lt;br/&gt;城市航班图如下&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7317073170731707&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/liaT5dytkaTeP2mlIMBU8B7TXA1vuwEnW3kZ8kIjAkNphZqVu9SHmJajAiaQw1uUJPqzbCm8H7IYiaGRqPZj2uJag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;492&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。&lt;br/&gt; &lt;br/&gt;&lt;br/&gt;提示：&lt;br/&gt;&lt;br/&gt;n 范围是 [1, 100]，城市标签从 0 到 n - 1&lt;br/&gt;航班数量范围是 [0, n * (n - 1) / 2]&lt;br/&gt;每个航班的格式 (src, dst, price)&lt;br/&gt;每个航班的价格范围是 [1, 10000]&lt;br/&gt;k 范围是 [0, n - 1]&lt;br/&gt;航班没有重复，且不存在自环&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题和上面的没有本质不同， 我仍然将其封装成 API 来使用，具体看代码就行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道题唯一特别的点在于如果中转次数大于 k，也认为无法到达。这个其实很容易，我们只需要在堆中用元组来&lt;strong&gt;「多携带一个 steps」&lt;/strong&gt;即可，这个 steps 就是 不带权 BFS 中的距离。如果 pop 出来 steps 大于 K，则认为非法，我们跳过继续处理即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Solution&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# 改造一下，增加参数 K，堆多携带一个 steps 即可&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;dijkstra&lt;/span&gt;&lt;span&gt;(self, graph, start, end, K)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        heap = [(&lt;span&gt;0&lt;/span&gt;, start, &lt;span&gt;0&lt;/span&gt;)]&lt;br/&gt;        visited = set()&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; heap:&lt;br/&gt;            (cost, u, steps) = heapq.heappop(heap)&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; u &lt;span&gt;in&lt;/span&gt; visited:&lt;br/&gt;                &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;            visited.add((u, steps))&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; steps &amp;gt; K: &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; u == end:&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; cost&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; v, c &lt;span&gt;in&lt;/span&gt; graph[u]:&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (v, steps) &lt;span&gt;in&lt;/span&gt; visited:&lt;br/&gt;                    &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;                next = cost + c&lt;br/&gt;                heapq.heappush(heap, (next, v, steps + &lt;span&gt;1&lt;/span&gt;))&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;-1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;findCheapestPrice&lt;/span&gt;&lt;span&gt;(self, n: int, flights: List[List[int]], src: int, dst: int, K: int)&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;&lt;br/&gt;        graph = collections.defaultdict(list)&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; fr, to, price &lt;span&gt;in&lt;/span&gt; flights:&lt;br/&gt;            graph[fr].append((to, price))&lt;br/&gt;         &lt;span&gt;# 调用封装好的 dijkstra 方法&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; self.dijkstra(graph, src, dst, K + &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;(代码 1.4.4)&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;3. 因子分解&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和上面两个应用一下，这个我在前面 《313. 超级丑数》部分也提到了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回顾一下丑数的定义：&lt;strong&gt;「丑数就是质因数只包含 2, 3, 5 的正整数。」&lt;/strong&gt; 因此丑数本质就是一个数经过&lt;strong&gt;「因子分解」&lt;/strong&gt;之后只剩下 2，3，5 的整数，而不携带别的因子了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于丑数的题目有很多，大多数也可以从堆的角度考虑来解。只不过有时候因子个数有限，不使用堆也容易解决。比如：&lt;span&gt;264. 丑数 II&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt; 就可以使用三个指针来记录即可，这个技巧在前面也讲过了，不再赘述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一些题目并不是丑数，但是却明确提到了类似&lt;strong&gt;「因子」&lt;/strong&gt;的信息，并让你求第 k 大的 xx，这个时候优先考虑使用堆来解决。如果题目中夹杂一些其他信息，比如&lt;strong&gt;「有序」&lt;/strong&gt;，则也可考虑二分法。具体使用哪种方法，要具体问题具体分析，不过在此之前大家要对这两种方法都足够熟悉才行。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;4. 堆排序&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面的三种应用或多或少在前面都提到过。而&lt;strong&gt;「堆排序」&lt;/strong&gt;却未曾在前面提到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接考察堆排序的题目几乎没有。但是面试却有可能会考察，另外学习堆排序对你理解分治等重要算法思维都有重要意义。个人感觉，堆排序，构造二叉树，构造线段树等算法都有很大的相似性，掌握一种，其他都可以触类旁通。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上，经过前面的堆的学习，我们可以封装一个堆排序，方法非常简单。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我放一个使用堆的 api 实现堆排序的简单的示例代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;h = [&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;]&lt;br/&gt;heapq.heapify(h)&lt;br/&gt;ans = []&lt;br/&gt;&lt;br/&gt;&lt;span&gt;while&lt;/span&gt; h:&lt;br/&gt;    ans.append(heapq.heappop(h))&lt;br/&gt;print(ans) &lt;span&gt;# 2,5,7,9&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;明白了示例， 那封装成&lt;strong&gt;「通用堆排序」&lt;/strong&gt;就不难了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;heap_sort&lt;/span&gt;&lt;span&gt;(h)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    heapq.heapify(h)&lt;br/&gt;    ans = []&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; h:&lt;br/&gt;        ans.append(heapq.heappop(h))&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; ans&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法足够简单，如果你明白了前面堆的原理，让你手撸一个堆排序也不难。可是这种方法有个弊端，它不是&lt;strong&gt;「原位算法」&lt;/strong&gt;，也就是说你必须使用额外的空间承接结果，空间复杂度为 &lt;span&gt;&lt;span role=&quot;presentation&quot; data-formula=&quot;O(N)&quot; data-formula-type=&quot;inline-equation&quot;&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 -750 2429 1000&quot; aria-hidden=&quot;true&quot;&gt;&lt;g stroke=&quot;currentColor&quot; fill=&quot;currentColor&quot; stroke-width=&quot;0&quot; transform=&quot;matrix(1 0 0 -1 0 0)&quot;&gt;&lt;g data-mml-node=&quot;math&quot;&gt;&lt;g data-mml-node=&quot;mi&quot;&gt;&lt;path data-c=&quot;4F&quot; d=&quot;M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(763, 0)&quot;&gt;&lt;path data-c=&quot;28&quot; d=&quot;M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mi&quot; transform=&quot;translate(1152, 0)&quot;&gt;&lt;path data-c=&quot;4E&quot; d=&quot;M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z&quot;/&gt;&lt;/g&gt;&lt;g data-mml-node=&quot;mo&quot; transform=&quot;translate(2040, 0)&quot;&gt;&lt;path data-c=&quot;29&quot; d=&quot;M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z&quot;/&gt;&lt;/g&gt;&lt;/g&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/span&gt;&lt;/span&gt;。但是其实调用完堆排序的方法后，原有的数组内存可以被释放了，因此理论上来说空间也没浪费，只不过我们计算空间复杂度的时候取的是使用内存最多的时刻，因此使用原地算法毫无疑问更优秀。如果你实在觉得不爽这个实现，也可以采用原地的修改的方式。这倒也不难，只不过稍微改造一下前面的堆的实现即可，由于篇幅的限制，这里不多讲了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆和队列有千丝万缕的联系。很多题目我都是先思考使用堆来完成。然后发现每次入堆都是 + 1，而不会跳着更新，比如下一个是 + 2，+3 等等，因此使用队列来完成性能更好。比如 649. Dota2 参议院 和 1654. 到家的最少跳跃次数 等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆的中心就一个，那就是&lt;strong&gt;「动态求极值」&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而求极值无非就是最大值或者最小值，这不难看出。如果求最大值，我们可以使用大顶堆，如果求最小值，可以用最小堆。而实际上，如果没有动态两个字，很多情况下没有必要使用堆。比如可以直接一次遍历找出最大的即可。而动态这个点不容易看出来，这正是题目的难点。这需要你先对问题进行分析， 分析出这道题&lt;strong&gt;「其实就是动态求极值」&lt;/strong&gt;，那么使用堆来优化就应该被想到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆的实现有很多。比如基于链表的跳表，基于数组的二叉堆和基于红黑树的实现等。这里我们介绍了&lt;strong&gt;「两种主要实现」&lt;/strong&gt; 并详细地讲述了二叉堆的实现，不仅是其实现简单，而且其在很多情况下表现都不错，推荐大家重点掌握二叉堆实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于二叉堆的实现，&lt;strong&gt;「核心点就一点」&lt;/strong&gt;，那就是始终维护堆的性质不变，具体是什么性质呢？那就是 &lt;strong&gt;「父节点的权值不大于儿子的权值（小顶堆）」&lt;/strong&gt;。为了达到这个目的，我们需要在入堆和出堆的时候，使用上浮和下沉操作，并恰当地完成元素交换。具体来说就是上浮过程和比它大的父节点进行交换，下沉过程和两个子节点中较小的进行交换，当然前提是它有子节点且子节点比它小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于堆化我们并没有做详细分析。不过如果你理解了本文的入堆操作，这其实很容易。因此堆化本身就是一个不断入堆的过程，只不过&lt;strong&gt;「将时间上的离散的操作变成了一次性操作」&lt;/strong&gt;而已。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外我给大家介绍了三个堆的做题技巧，分别是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;固定堆，不仅可以解决第 k 问题，还可有效利用已经计算的结果，避免重复计算。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多路归并，本质就是一个暴力解法，和暴力递归没有本质区别。如果你将其转化为递归，也是一种不能记忆化的递归。因此更像是&lt;strong&gt;「回溯算法」&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事后小诸葛。有些信息，我们在当前没有办法获取，就可用一种数据结构存起来，方便之后”东窗事发“的时候查。这种数据解决可以是很多，常见的有哈希表和堆。你也可以将这个技巧看成是&lt;strong&gt;「事后后悔&lt;strong&gt;」&lt;/strong&gt;&lt;/strong&gt;，有的人比较能接受这种叫法，不过不管叫法如何，指的都是这个含义。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后给大家介绍了四种应用，这四种应用除了堆排序，其他在前面或多或少都讲过，它们分别是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这四种应用实际上还是围绕了堆的一个中心&lt;strong&gt;「动态取极值」&lt;/strong&gt;，这四种应用只不过是灵活使用了这个特点罢了。因此大家在做题的时候只要死记&lt;strong&gt;「动态求极值」&lt;/strong&gt;即可。如果你能够分析出这道题和动态取极值有关，那么请务必考虑堆。接下来我们就要在脑子中过一下复杂度，对照一下题目数据范围就大概可以估算出是否可行啦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家对此有何看法，欢迎给我留言，我有时间都会一一查看回答。更多算法套路可以访问我的 LeetCode 题解仓库：https://github.com/azl397985856/leetcode 。目前已经 39K star 啦。大家也可以关注我的公众号《力扣加加》带你啃下算法这块硬骨头。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Reference&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;面试题 17.14. 最小K个数: &lt;em&gt;https://leetcode-cn.com/problems/smallest-k-lcci/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;347. 前 K 个高频元素: &lt;em&gt;https://leetcode-cn.com/problems/top-k-frequent-elements/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;973. 最接近原点的 K 个点: &lt;em&gt;https://leetcode-cn.com/problems/k-closest-points-to-origin/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;743. 网络延迟时间: &lt;em&gt;https://leetcode-cn.com/problems/network-delay-time/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;787. K 站中转内最便宜的航班: &lt;em&gt;https://leetcode-cn.com/problems/cheapest-flights-within-k-stops/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;264. 丑数 II: &lt;em&gt;https://leetcode-cn.com/problems/ugly-number-ii/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9d913da5ae22d0eaace608c6c7365da7</guid>
<title>基于开源技术打造 DevSecOps 工具链</title>
<link>https://toutiao.io/k/8dcb5n8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;

                

                
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3db710f82d6fe14afec2d8e6a50a4e09</guid>
<title>分布式延时任务调度系统设计与 Golang 实现</title>
<link>https://toutiao.io/k/y4y7pl1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;延时应用场景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;之前的文章分享了分布式任务调度系统负载均衡方案：&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIyMzMxNjYwNw==&amp;amp;mid=2247483723&amp;amp;idx=1&amp;amp;sn=a6c368be2b011de86b352f6239624ba5&amp;amp;chksm=e8215e5bdf56d74d2ed946e367ff9e4cbe4eb8f9c76b09d24b9383fd5c4b2c304ce8f5c6b9e4&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;分布式任务调度系统分发及负载均衡实现方案&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个完整的任务调度系统，对&lt;/span&gt;&lt;span&gt;延时&lt;/span&gt;&lt;span&gt;任务的支持必不可少。延时任务、延迟消息、延迟队列基本语境和实现类似，那么它有哪些适用场景呢？最常见的如：用户下单xx分钟内未付款订单自动取消，释放库存；订单发货后xx天自动确认收货；订单结束后xx天自动评价；用户注册后1min内触发xx动作等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;延时解决方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;延时作为常见的需求自然有众多解决方案，数据库轮询是最容易想到的一个方案，时间轮，小顶堆，有序链表，延时队列以及各类开源项目也是琳琅满目。了解每种解决方案的原理以及优缺点，可以帮助在生产中做好技术选型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.数据库轮询&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;最简单且容易想到的方案是后台启动&lt;/span&gt;&lt;span&gt;定时脚本&lt;/span&gt;&lt;span&gt;，定时轮询扫描数据库获取满足条件数据并处理，&lt;span&gt;这种方案实现简单有效&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;时间处理精度问题，linux系统crontab最小是&lt;/span&gt;&lt;span&gt;1分钟&lt;/span&gt;&lt;span&gt;&lt;span&gt;，如果需要更细时间粒度可以通过脚本&lt;span&gt;for{}&lt;/span&gt;无限循环轮询数据库，总执行时间为50秒，每次轮询后sleep10秒&lt;/span&gt;，类似操作可达成更小时间粒度。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;此方案项目初级比较有效，但也有较多&lt;/span&gt;&lt;span&gt;弊端：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.延迟消息队列&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;2.1RabbitMQ队列&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;RabbitMQ本身不支持延时消息，但可通过&lt;span&gt;死信队列及死信路由&lt;/span&gt;设置间接达成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3699248120300752&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd9ME5K3gLNtkBic5SNnExgqjHaMxGia8KFUvFZJD6ib2djduN7mORw3BClZZYuOEDyhutIdZtjBmRwvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;665&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TTL(Time to live)分消息TTL和队列TTL，控制消息超时时间，消息在队列中生存时间一旦超过TTL设置时间即成为dead letter（死信），然后通过Dead letter exchange死信路由交换机来重新路由消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.22477064220183487&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd8xnrzVoibMJU5ANalBUqBzu41bicRgSG5u57W01RFEmD8Tdh4toLmKQN29bELq0s5tCIwK7lsRW6MA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;872&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;方案分析&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;利用成熟RabbitMQ消息组件，稳定、易扩展、支持分布式，消息支持持久化可靠性好。但消息的延时时间需要保持一致，死信队列还是先进先出，如果先进的队列由于未到执行时间会阻塞所有后入消息，因此一种延时时间需要建一套路由。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除死信队列方案外还有一些RabbitMQ的插件可以实现延时，具体可下载插件：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;rabbitmq_delayed_message_exchange&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;2.2 RocketMQ&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;RocketMQ是支持延时消息的，且足够高效可靠，但&lt;span&gt;延迟消息的时间不是任意时间，而是仅支持18个固定的时间段&lt;/span&gt;，这里不再赘述。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.时间轮算法&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;时间轮算法是实现延时最常用的算法，这里重点介绍它的实现方案。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.1实现原理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;可以想象一个时钟的表盘，有一个指针绕着转动，每走一个格子称为一个&lt;/span&gt;&lt;span&gt;刻度&lt;/span&gt;&lt;span&gt;（时间间隔interval），表盘每个格子上挂载待执行&lt;/span&gt;&lt;span&gt;任务列表&lt;/span&gt;&lt;span&gt;（任务桶buckets），指针转动一圈&lt;/span&gt;&lt;/span&gt;&lt;span&gt;总&lt;/span&gt;&lt;span&gt;&lt;span&gt;长度&lt;/span&gt;&lt;span&gt;（bucketSize），这些元素构成一个时间轮。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.699873896595208&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd8xnrzVoibMJU5ANalBUqBzu5HGWvjCDFC2sfBjLCz6KzsW02z2iblWUKUokM5X07l1cU2y9H5fMYicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;793&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果刻度是1s，总长度是60s，那么转一圈就是1分钟，可以实现1分钟内的延时。要实现更长时间跨度，可将总长度设置更大，但这会造成占用内存过大，更多空转浪费资源。有两种优化方案，使用&lt;/span&gt;&lt;span&gt;多层时间轮&lt;/span&gt;&lt;span&gt;或&lt;span&gt;多级时间轮&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.43773119605425403&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd8xnrzVoibMJU5ANalBUqBzuxoKBTn8kzyPnTIpl4eCicKH7SVicjFkcoVWCZPlErOBXp8CyV7kqvMDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;811&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.2具体代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;定义时间轮结构如下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type TimeWheel &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ticker       *time.Ticker      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    interval     time.Duration     &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    buckets      []*list.List      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    bucketSize   &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;               &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    currentPos   &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;               &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;callbackFunc &lt;span class=&quot;code-snippet__title&quot;&gt;func&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}&lt;/span&gt;) &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    stopChannel  chan &lt;span class=&quot;code-snippet__keyword&quot;&gt;bool&lt;/span&gt;         &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;定时器触发使用&lt;/span&gt;&lt;span&gt;time.Ticker&lt;/span&gt;&lt;span&gt;，它是Go自身实现的内置定时器，基于&lt;/span&gt;&lt;span&gt;最小堆&lt;/span&gt;&lt;span&gt;结构实现。&lt;/span&gt;&lt;span&gt;Buckets存放任务列表，&lt;/span&gt;&lt;span&gt;使用双向链表&lt;/span&gt;&lt;span&gt;container/list&lt;/span&gt;&lt;span&gt;结构，注意它非线程安全。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;新建一个时间轮实例：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;New&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(interval time.Duration, bucketSize &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;, callbackFunc &lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{})&lt;/span&gt;) &lt;span class=&quot;code-snippet__params&quot;&gt;(*TimeWheel, e&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;rror)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; interval &amp;lt;= &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; || bucketSize &amp;lt;= &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; || callbackFunc == &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;, errors.New(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;create timewheel instance fail&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    tw := &amp;amp;TimeWheel{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        interval:     interval,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        buckets:      &lt;span class=&quot;code-snippet__built_in&quot;&gt;make&lt;/span&gt;([]*list.List, bucketSize),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        bucketSize:   bucketSize,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        currentPos:   &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        callbackFunc: callbackFunc,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        stopChannel:  &lt;span class=&quot;code-snippet__built_in&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;chan&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;bool&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; bucketSize; i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        tw.buckets[i] = list.New()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; tw, &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;定义任务Task结构体，并添加任务。为了构造多层时间轮，给任务添加circle代表该任务在第几圈。pos代表任务在当前表盘上的位置。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; Task &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Id     &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Data   &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Delay  time.Duration &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Circle &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;           &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(tw *TimeWheel)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;AddTask&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(task *Task)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    delaySeconds := &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;(task.Delay.Seconds())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    intervalSeconds := &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;(tw.interval.Seconds())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    circle := &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;(delaySeconds / intervalSeconds / tw.bucketSize)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    pos := &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;(tw.currentPos+delaySeconds/intervalSeconds) % tw.bucketSize&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    task.Circle = circle&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    tw.buckets[pos].PushBack(task)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;启动时间轮，每经过一刻度（这个刻度可以是1s、5s任意），做一次检查，如果当前格里有任务则取出执行，碰到多圈任务将circle-1。当指针走到末尾代表走完一圈，会重置再从头执行。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(tw *TimeWheel)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Start&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    tw.ticker = time.NewTicker(tw.interval)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; &amp;lt;-tw.ticker.C: &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                log.Println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;1 tick&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                tw.tickHandler()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; &amp;lt;-tw.stopChannel: &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                tw.ticker.Stop() &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(tw *TimeWheel)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;tickHandler&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    bucket := tw.buckets[tw.currentPos]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; e := bucket.Front(); e != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        task := e.Value.(*Task) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; task.Circle &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            task.Circle--&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            e = e.Next()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; tw.callbackFunc(task.Data)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        next := e.Next()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        bucket.Remove(e)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        e = next&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; tw.currentPos == tw.bucketSize&lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        log.Println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;new circle&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        tw.currentPos = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        tw.currentPos++&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;测试时间轮一圈10s，间隔刻度1s，添加延时12s的延时任务，第13s后执行任务。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;TestTimeWheel&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    tw, err := New(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;*time.Second, &lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(data &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        log.Println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;do task&quot;&lt;/span&gt;, data)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    })  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        t.Error(err)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    log.Println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;start timewheel...&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    tw.Start()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    task := Task{Id: &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, Data: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;test1&quot;&lt;/span&gt;, Delay: &lt;span class=&quot;code-snippet__number&quot;&gt;12&lt;/span&gt; * time.Second}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    tw.AddTask(&amp;amp;task)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    time.Sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;20&lt;/span&gt; * time.Second)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;执行效果：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8327272727272728&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd9ME5K3gLNtkBic5SNnExgqjmtWzWjXFOu6H2VubmoOL8GTzndjicz6FfggPG07grB9RMEDuCmI5iaLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;3.3 更多细节考虑&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;3.3.1 长时间跨度的解决方案&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;由于时间跨度越大轮子越大，会占用更多内存，所以可以考虑采用&lt;/span&gt;&lt;span&gt;磁盘文件+内存时间轮&lt;/span&gt;&lt;span&gt;相结合的方案。内存时间轮只加载1小时的任务，磁盘文件可以时间命名（2020101721代表2020年10月17日21:00-21:59:59所有延时任务），每小时一个文件，一天24个，一般情况不会保存太多文件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.3.2 内存时间轮的高可用性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为采用内存时间轮，如果程序崩溃会导致数据丢失。将时间轮持久化保存成文件存储，到达时间后预加载到内存，程序崩溃、重启后也可以重新加载，文件保存可保障数据不会丢失，当然也可保存在redis或其他持久化存储中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除内存时间轮外也可以直接使用&lt;/span&gt;&lt;span&gt;redis的list结构&lt;/span&gt;&lt;span&gt;替代container/list，&lt;/span&gt;&lt;span&gt;redis的string&lt;/span&gt;&lt;span&gt;结构保存时间轮当前指针。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;考虑恢复时间轮后需要确认哪些未执行，那么可以在执行的时候记录&lt;/span&gt;&lt;span&gt;成功执行日志&lt;/span&gt;&lt;span&gt;或&lt;/span&gt;&lt;span&gt;记录执行位置偏移&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;考虑是否执行成功，按at least once语义可以再发送/执行一次，需要下游保障幂等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;3.3.3 任务执行方式&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;call&lt;/span&gt;&lt;span&gt;back如果仅是发送消息等毫秒级完成还可以，如果是&lt;/span&gt;&lt;span&gt;执行http/rpc调用且较慢将会拖垮整&lt;/span&gt;&lt;span&gt;个延时任务系统，所以不要在callback做重任务，可以将到达延时的任务统一放到待发送MQ中，异步执行。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;3.3.4 分布式集群任务分发&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;单个时间轮处理任务能力有限，任务量大可以对任务数据分片处理，开启&lt;/span&gt;&lt;span&gt;多个时间轮并行处理&lt;/span&gt;&lt;span&gt;。在任务添加时，根据Id取模或hash分片，保存在不同的时间轮文件中。&lt;span&gt;如&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;2020101721_0&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;2020101721_1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;2020101721_2&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;2020101721_9&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;每小时再分10个任务片，分别由10个时间轮加载。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;3.4 方案分析&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;时间轮方案执行效率高，时间精度高，但内存时间轮重启或宕机后需要考虑持久化和消费标记，集群扩展实现也较复杂。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;4.排序链表算法&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;要使用排序链表数据结构，最先想到的就是redis的sorted set结构，这里以redis有序集合为基础来实现延时。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;4.1 实现原理&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;redis有序集合zset结构是一个有序链表，可以通过&lt;/span&gt;&lt;span&gt;zadd&lt;/span&gt;&lt;span&gt;向链表添加元素，并将其&lt;/span&gt;&lt;span&gt;score&lt;/span&gt;&lt;span&gt;设置为延时任务执行的时间戳，值设为任务id。然后通过&lt;/span&gt;&lt;span&gt;zrange&lt;/span&gt;&lt;span&gt;获取链表第一个元素（&lt;span&gt;默&lt;/span&gt;&lt;span&gt;认是score最小元素&lt;/span&gt;），通过判断score和当前时间大小，决定是否到达执行时间。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.2 具体代码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;按时间轮设计思想定义一个带定时器的结构体：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; BucketTicker &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Ticker       *time.Ticker&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Interval     time.Duration&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Name         &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    CallbackFunc &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;bool&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;//&lt;span class=&quot;code-snippet__title&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ticker&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__title&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;New&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(interval time.Duration, bucketName &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;, callbackFunc &lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;bool&lt;/span&gt;) &lt;span class=&quot;code-snippet__params&quot;&gt;(*Buck&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;etTicker, error)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; interval &amp;lt;= &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; || callbackFunc == &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;, errors.New(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;create bucket ticker instance fail&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    bucket := &amp;amp;BucketTicker{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Interval:     interval,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Name:         bucketName,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        CallbackFunc: callbackFunc,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; bucket, &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;定义任务及添加方法，将任务的执行时间（当前时间+延时时间）和任务唯一Id存到zset结构中，将任务主体序列化存到kv结构（string）中。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type Task &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Id        &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Data      &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Delay     time.Duration &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Timestamp &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func (bucket *BucketTicker) AddTask(task *Task) error {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    timestamp := time.Now().Add(task.Delay).Unix()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    err := redisclient.ZAdd(bucket.Name, &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;(timestamp), task.Id)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != nil {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; err&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    data, err := json.Marshal(task)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != nil {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; err&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    err = redisclient.Set(task.Id, &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;(data))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != nil {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; err&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; nil&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;启动定时器，每隔一个刻度，检查是否有满足执行时间的任务。间隔时间越长，可以减少与redis查询频率，但&lt;/span&gt;&lt;span&gt;延时任务处理精度&lt;/span&gt;&lt;span&gt;会降低。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(bucket *BucketTicker)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Start&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    timer := time.NewTicker(bucket.Interval) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;select&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; t := &amp;lt;-timer.C:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                log.Println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;1 tick&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                bucket.tickHandler(t, bucket.Name)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(bucket *BucketTicker)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;tickHandler&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(currentTime time.Time, bucketName &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        task, err := getTask(bucketName)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            log.Println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;error happen!&quot;&lt;/span&gt;, err)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; task == &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; task.Timestamp &amp;gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;(currentTime.Unix()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        taskDetail, err := getTaskDetail(task.Id)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            log.Println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;error happen!&quot;&lt;/span&gt;, err)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; ok := bucket.CallbackFunc(taskDetail.Data); ok {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            err = removeTask(bucketName, task.Id)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            log.Println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;error happen!&quot;&lt;/span&gt;, errors.New(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;callback error&quot;&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;continue&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;getTask()，getTaskDetail()和removeTask()分别执行Redis操作。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;getTask&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(bucketName &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(*Task, error)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    value, err := redisclient.ZRangeFirst(bucketName) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;, err&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; value == &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    timestamp := &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;(value[&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;].(&lt;span class=&quot;code-snippet__keyword&quot;&gt;float64&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    taskId := value[&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;].(&lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    task := Task{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Id:        taskId,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Timestamp: timestamp,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &amp;amp;task, &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;getTaskDetail&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(taskId &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(*Task, error)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    v, err := redisclient.Get(taskId)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;, err&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; v == &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    task := Task{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    err = json.Unmarshal([]&lt;span class=&quot;code-snippet__keyword&quot;&gt;byte&lt;/span&gt;(v), &amp;amp;task)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;, err&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &amp;amp;task, &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;removeTask&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(bucketName &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;, taskId &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    err := redisclient.ZRem(bucketName, taskId)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; err&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    err = redisclient.Del(taskId)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; err&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;编写测试用例测试，添加2个延时任务分别是延时5秒和延时8秒。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;TestRedisDelay&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    delay, err := New(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;*time.Second, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;test&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(data &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        log.Println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;do task &quot;&lt;/span&gt;, data)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    })  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; err != &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        t.Error(err)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    log.Println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;start ticker...&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    delay.Start()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    task1 := Task{Id: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;1&quot;&lt;/span&gt;, Data: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;task1&quot;&lt;/span&gt;, Delay: &lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt; * time.Second}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    task2 := Task{Id: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;2&quot;&lt;/span&gt;, Data: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;task2&quot;&lt;/span&gt;, Delay: &lt;span class=&quot;code-snippet__number&quot;&gt;8&lt;/span&gt; * time.Second}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    delay.AddTask(&amp;amp;task1)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    delay.AddTask(&amp;amp;task2)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    time.Sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt; * time.Second)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;执行效果如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.46598202824133506&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd9ME5K3gLNtkBic5SNnExgqjib5cu9HSKdAowYO53icuzDrQicWkSKwF3DrRlJrABCFfRoicrMYv7icF9ZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;779&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.3 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;分布式集群任务分片&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;当有更多延时任务时，考虑存储多个bucket，每个bucket有自己的定时器，执行自己的任务列表。当有任务添加时，轮询加入不同&lt;span&gt;bucket中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.4 方案分析&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;由于依赖比较成熟的组件redis，高可用程序挂掉重启后仍可继续处理，集群分片拓展也容易。但由于每次都取出数据比对score，会有频繁Redis IO操作，造成较大的资源浪费。&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;5.总结&lt;/strong&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;延时方案方案除上述几种外还有最小堆的形式，文中提到的Go内置定时器即采用四叉堆结构，其实现原理与排序链表大同小异。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;选择何种方案根据&lt;/span&gt;&lt;span&gt;业务场景和业务规模&lt;/span&gt;&lt;span&gt;而定。数据库轮询方案简单实用，在业务初期非常合适。延时队列方案实现简单，可以结合队列一起使用。当这些都不能满足业务时，再考虑自建延时系统，可以采用时间轮方案或有序链表方案。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;文章相关代码请关注公众号 “&lt;strong&gt;&lt;span&gt;技术岁月&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;”&lt;/span&gt;，发送关键字“&lt;/span&gt;&lt;span&gt;&lt;strong&gt;延时任务&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;”获取。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd8xnrzVoibMJU5ANalBUqBzuW7mZnCWFhYC94LpYATpCpIU9nDJiaDvqcf3PzctAFK61PgxWic8S5Axg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;258&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>90b66caa7e664c0e88cd385b92cce18e</guid>
<title>RESTful API 如何进行版本控制</title>
<link>https://toutiao.io/k/na04wzq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文将帮助您理解为什么需要版本控制，以及如何对REST API进行版本控制。我们将讨论4种版本控制的方法，并比较不同的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;您将学到&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为什么我们需要对RESTful API 进行版本控制?&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可用的版本控制有哪些?&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如何实现基于 Restful 的版本控制?&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么我们需要对RESTful API进行版本化&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最好的版本控制方法是不进行版本控制。只要不需要版本控制，就不要版本控制。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;构建向后兼容的服务，以便尽可能避免版本控制！&lt;/strong&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而，在许多情况下我们都需要进行版本控制，然我们看看下面具体的例子：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最初，你有个这个版本的Student服务，返回数据如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;Bob Charlie&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来，您希望将学生的名字拆分，因此创建了这个版本的服务。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;name&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;firstName&quot;&lt;/span&gt;: &lt;span&gt;&quot;Bob&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;lastName&quot;&lt;/span&gt;: &lt;span&gt;&quot;Charlie&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;您可以从同一个服务支持这两个请求，但是随着每个版本的需求多样化，它会变得越来越复杂。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这种情况下，版本控制就成必不可少，强制性的了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来让我们创建一个简单的SpringBoot的maven项目，并理解对 RESTful 服务进行版本控制的4种不同方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.projectlombok&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;lombok&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-test&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;test&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;几个用于实现版本控制的Bean&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个版本的 Bean&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@AllArgsConstructor&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;StudentV1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个版本的 Bean&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;StudentV2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Name name;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;StudentV2使用的Name实体&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Data&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@AllArgsConstructor&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Name&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String firstName;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String lastName;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Restful 版本控制的方法&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们希望创建两个版本的服务，一个返回 StudentV1，另一个返回 StudentV2。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们来看看创建相同服务版本的4种不同方法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;通过 URI 进行版本控制&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;StudentUriController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;v1/student&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; StudentV1 &lt;span&gt;studentV1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; StudentV1(&lt;span&gt;&quot;javadaily&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;v2/student&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; StudentV2 &lt;span&gt;studentV2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; StudentV2(&lt;span&gt;new&lt;/span&gt; Name(&lt;span&gt;&quot;javadaily&quot;&lt;/span&gt;, &lt;span&gt;&quot;JAVA日知录&quot;&lt;/span&gt;));&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求：&lt;code&gt;http://localhost:8080/v1/student&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;响应：{&quot;name&quot;:&quot;javadaily&quot;}&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求：&lt;code&gt;http://localhost:8080/v2/student&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;响应：{&quot;name&quot;:{&quot;firstName&quot;:&quot;javadaily&quot;,&quot;lastName&quot;:&quot;JAVA日知录&quot;}}&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;通过请求参数进行版本控制&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;版本控制的第二种方法是使用请求参数来区分版本。请求示例如下所示：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;http://localhost:8080/student/param?version=1&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;http://localhost:8080/student/param?version=2&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现方式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;StudentParmController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(value=&lt;span&gt;&quot;/student/param&quot;&lt;/span&gt;,params = &lt;span&gt;&quot;version=1&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; StudentV1 &lt;span&gt;studentV1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; StudentV1(&lt;span&gt;&quot;javadaily&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(value=&lt;span&gt;&quot;/student/param&quot;&lt;/span&gt;,params = &lt;span&gt;&quot;version=2&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; StudentV2 &lt;span&gt;studentV2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; StudentV2(&lt;span&gt;new&lt;/span&gt; Name(&lt;span&gt;&quot;javadaily&quot;&lt;/span&gt;, &lt;span&gt;&quot;JAVA日知录&quot;&lt;/span&gt;));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求：&lt;code&gt;http://localhost:8080/student/param?version=1&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;响应：{&quot;name&quot;:&quot;javadaily&quot;}&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求：&lt;code&gt;http://localhost:8080/student/param?version=2&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;响应：{&quot;name&quot;:{&quot;firstName&quot;:&quot;javadaily&quot;,&quot;lastName&quot;:&quot;JAVA日知录&quot;}}&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;通过自定义Header进行版本控制&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;版本控制的第三种方法是使用请求头来区分版本，请求示例如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;http://localhost:8080/student/header&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;headers=[X-API-VERSION=1]&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;http://localhost:8080/student/header&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;headers=[X-API-VERSION=2]&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现方式如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;StudentHeaderController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(value=&lt;span&gt;&quot;/student/header&quot;&lt;/span&gt;,headers = &lt;span&gt;&quot;X-API-VERSION=1&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; StudentV1 &lt;span&gt;studentV1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; StudentV1(&lt;span&gt;&quot;javadaily&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(value=&lt;span&gt;&quot;/student/header&quot;&lt;/span&gt;,headers = &lt;span&gt;&quot;X-API-VERSION=2&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; StudentV2 &lt;span&gt;studentV2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; StudentV2(&lt;span&gt;new&lt;/span&gt; Name(&lt;span&gt;&quot;javadaily&quot;&lt;/span&gt;, &lt;span&gt;&quot;JAVA日知录&quot;&lt;/span&gt;));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图展示了我们如何使用Postman执行带有请求头的Get请求方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求：&lt;code&gt;http://localhost:8080/student/header&lt;/code&gt; &lt;br/&gt;header：&lt;code&gt;X-API-VERSION = 1&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3175&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4gVoZknxZPgmicd52cXAPibYmJ6xb6vtfic4xsib5jAIrIRFXg1gdDeO3lb6gSVzlNMA5P8sLFeWkYcWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求：&lt;code&gt;http://localhost:8080/student/header&lt;/code&gt; &lt;br/&gt;header：&lt;code&gt;X-API-VERSION = 2&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.36625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4gVoZknxZPgmicd52cXAPibYmibia98c2GctEYFFHcqNaE0TGEucC6UBfxgNrDNXJee6e7a2xUtEvHhRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;通过媒体类型进行版本控制&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后一种版本控制方法是在请求中使用Accept Header，请求示例如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;http://localhost:8080/student/produce&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;headers=[Accept=application/api-v1+json]&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;http://localhost:8080/student/produce&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;headers=[Accept=application/api-v2+json]&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现方式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;StudentProduceController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(value=&lt;span&gt;&quot;/student/produce&quot;&lt;/span&gt;,produces = &lt;span&gt;&quot;application/api-v1+json&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; StudentV1 &lt;span&gt;studentV1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; StudentV1(&lt;span&gt;&quot;javadaily&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(value=&lt;span&gt;&quot;/student/produce&quot;&lt;/span&gt;,produces = &lt;span&gt;&quot;application/api-v2+json&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; StudentV2 &lt;span&gt;studentV2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; StudentV2(&lt;span&gt;new&lt;/span&gt; Name(&lt;span&gt;&quot;javadaily&quot;&lt;/span&gt;, &lt;span&gt;&quot;JAVA日知录&quot;&lt;/span&gt;));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图展示了我们如何使用Postman执行带有请求Accept的Get方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求：&lt;code&gt;http://localhost:8080/student/produce&lt;/code&gt; &lt;br/&gt;header：&lt;code&gt;Accept = application/api-v1+json&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.335&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4gVoZknxZPgmicd52cXAPibYmlUAajcibLuHfmUQ63kXmfrntKMuEpGwBf3mk2VwNdoLa69orL8Oxe5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求：&lt;code&gt;http://localhost:8080/student/produce&lt;/code&gt; &lt;br/&gt;header：&lt;code&gt;Accept = application/api-v2+json&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.355&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4gVoZknxZPgmicd52cXAPibYmHrdX0bFIOhwiaKWLqAIBkrlsjsR9JNwMeoNxtlia6T0yO8eMBJsGib1mw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;影响版本选择的因素&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下因素影响版本控制的选择&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;URI 污染 - URL版本和请求参数版本控制会污染URI空间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;滥用请求头 - Accept 请求头并不是为版本控制而设计的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缓存 - 如果你使用基于头的版本控制，我们不能仅仅基于URL缓存，你需要考虑特定的请求头。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;是否能在浏览器直接执行 ? - 如果您有非技术消费者，那么基于URL的版本将更容易使用，因为它们可以直接在浏览器上执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;API文档 - 如何让文档生成理解两个不同的url是同一服务的版本？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;事实上，并没有完美的版本控制解决方案，你需要根据项目实际情况进行选择。&lt;/strong&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面列表展示了主要API提供商使用的不同版本控制方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;媒体类型的版本控制&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;自定义Header&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;URI路径&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;请求参数控制&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>518c6cc888bd3ab05bbaae9ad28bf73d</guid>
<title>智能标签体系之业务应用场景</title>
<link>https://toutiao.io/k/q6fpqvz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1&gt;&lt;span&gt;一、评估标签质量&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、业务背景&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;基于标签对业务进行精准分析，从而影响运营思路和产品迭代的节奏，进而带来非常高的商业价值，但是这里需要对标签的质量进行评估，假设标签的覆盖场景非常低，而且准确度低，同样也会反向影响业务。&lt;/p&gt;&lt;p&gt;通过在标签的使用过程分析和评估，不断优化标签的质量，形成完整的管理周期，这样才能发挥更高的业务价值。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、覆盖维度&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;单一场景下标签能产生的价值并不高，这也是很多产品在初期不会过度考虑数据分析的一大原因，能获取到有标签含义的数据不足以产生较高的价值。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.46757679180887374&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBiaLL6sFribZDjRkTjdxwll5WxU45ibK6V4HBkzdMKBRfgCo7xI5s9sqOd3A5SXia4MIewFE5GiaP0WQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1172&quot;/&gt;&lt;/p&gt;&lt;p&gt;通常当用户有一定规模之后，业务的主流程搭建完毕，产品自身也基本完成，这时候就会开始考虑数据的标签化分析，在标签初始化完成后，会有小规模的业务场景验证，通常通过一些运营操作完成，验证标签效果之后就会全面开放到业务中。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3、准确度&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;标签的准确度是在整合周期中最关键的，在给对象打上标签后，需要准确获取对象的各项数据，提供基准的分析。&lt;/p&gt;&lt;p&gt;例如：描述24-30岁白领消费能力，在实际业务中发现28-30岁的白领消费能力并不符合预期描述，那就需要对该标签做垂直细化，分为[24-27]和[28-30]两个阶段，如果范围内还是存在较大差异，则还是需要不断优化。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3098827470686767&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBiaLL6sFribZDjRkTjdxwll5ibcr7U2VRNF9ict8PA5yMWjiaP2tbv4ibKS05OkDXW2yVvmjXoibl4nnT8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1194&quot;/&gt;&lt;/p&gt;&lt;p&gt;如何把控准确度，可以是基于指标阈值，或者特定业务场景下的人工分析和手动管理，从而判断标签是否准确或者获得标签优化的依据。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、标签基础应用&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、贴标签&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;给一个用户贴标签的过程是非常复杂的，这里通常需要依赖现有成熟的标签体系。&lt;/p&gt;&lt;p&gt;例如新注册的用户或者长期不活跃的用户，如何获取精准的分析，从而为运营提供激活用户的策略：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.275&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBiaLL6sFribZDjRkTjdxwll50B0OGXfGoNOiaB5hj12FFH9ic7MbavofNnfaOlAiay7SdxKywHASiaQdibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;这里相似的用户可能从多个角度分析，例如性别.年龄.区域.或者参考少数的行为数据。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、标签查询&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;基于对标签的选择，和标签值选取，生成数据查询的条件，圈取数据包，这是最常使用的手段。&lt;/p&gt;&lt;p&gt;例如很多的数据分析，筛选等，或者将一些图片视频文件等，通过一些精准的标签设定，从而达到被快速查询定位的效果。&lt;/p&gt;&lt;p&gt;在很多媒体类平台上，发布内容都需要自己设定描述标签或者自动内容做分析，生成相关标签，都是很常规的应用场景。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3、API调用&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;把标签条件组装成API参数，通过接口调用的方式，快速获取该标签条件下的数据包，从而响应业务场景的需求。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、标签营销应用&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;1、种子数据&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;基于小批量的种子数据，获取该数据的公共特征，进而基于这些特征选取更大的数据包，有点抛一块砖砌一面墙的味道，该行为也称相似数据包挖掘。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2995169082125604&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBiaLL6sFribZDjRkTjdxwll55uziccFWzsULOLdDdRfiaqVRUtQzoGpUQfCw1EczqhkkicDqx03WzicVng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1242&quot;/&gt;&lt;/p&gt;&lt;p&gt;这是数据营销的案例中最基础的思路，先小范围测试用户的营销效果好，如果效果良好，则根据分析这批小用户特点，提取描述标签，然后获取具有相同标签的用户进行营销，如果这批种子用户效果不好，则快速停下转换思路。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、数据包运算&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;基于多个数据包，进行运算，比如两个数据包并集，交集，补集，差集等系列运算。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.27813504823151125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBiaLL6sFribZDjRkTjdxwll5CctyiccbCvCNYXZTlBUpz1joqkAhZV7NFicChJuHKDoFd50YBVKTm7Rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1244&quot;/&gt;&lt;/p&gt;&lt;p&gt;这样可以得到数据包的差距，分析组合标签或者差异标签之间的影响，可以给营销带来精确的参考。数据能产生多大的价值，取决于如何去管理和运营这些数据，不管从什么思路去分析，思考的角度和整体意识要把握住。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、源代码地址&lt;/span&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;GitHub·地址&lt;br/&gt;https:&lt;span&gt;//github.com/cicadasmile&lt;/span&gt;&lt;br/&gt;GitEE·地址&lt;br/&gt;https:&lt;span&gt;//gitee.com/cicadasmile&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3783359497645212&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvCjMheLZtcM2iaVMBOpIUKR4CDRCG9FLT5K6NmGXvG7exrW0TSuDjnTKJQ5PDq8j8Y7PHDd17Z3gicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>