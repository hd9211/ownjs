<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>19586f11ffd15d2738877513e94971fb</guid>
<title>一个技术团队leader的搭建私有知识库避坑经验分享</title>
<link>https://toutiao.io/k/o3dptn4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;container app-preview post-body&quot;&gt;
  &lt;div class=&quot;preview&quot;&gt;&lt;p&gt;作为一名技术团队的管理者，团队整体规模达到80人，对团队人才培养与团队搭建有些所思所得，现在分享下。
1、需求的产生
开始带团队的时候，对​​知识库​​完全没有概念，公司内也没有什么分享整理的系统的解决方法，大多数都是些成word或者excel，甚至文本文档，然后在svn上的某一个文件夹一丢，就算是知识库了。但是两年过后，就发现这种杂乱无序的知识库分享方式，有很多缺点，比如快速查找、文档有错的时候不能同步更新等等。 。
基于我遇到的情况，公司内部要搭建统一管理的知识库，知识库要能够实实在在的帮助到团队的每一个需要帮助的人，而不仅仅是一个形式，马马虎虎应付了事的知识库资料是没有意义。
然后，整理了我的想法思路需求：
• 内容划分：将知识或者信息分类，形成文档集或者知识库。从知识信息的用途来分为：公司制度管理类、通用技术类、市场知识类、产品规范与案例类、入职培训类等；&lt;/p&gt;

&lt;p&gt;• 信息安全：对于公司内部信息，特别是技术、市场相关的信息，有非常机密敏感的内容，一定不能是SaaS，要支持本地化部署；一定要有权限化管理，有效的信息分级控制；&lt;/p&gt;

&lt;p&gt;• 内容形式：B/S模式，支持富文本、支持演示文稿、支持脑图、支持画图等；&lt;/p&gt;

&lt;p&gt;• 快速检索：要支持内容级的检索，不能只是搜索题目，一定要能支持内容搜索；&lt;/p&gt;

&lt;p&gt;• 形成交流：对内容可以评价与评论，这样更加容易形成团队内部交流，最好是类似于论坛的形式，相关的人都可以发表相关的意见和建议；&lt;/p&gt;

&lt;p&gt;• 易于分享：能对分享的范围进行控制，可以对分享的时间有效性、支持密码、内部账号等；&lt;/p&gt;

&lt;p&gt;• 简易操作：交付一定要简单，最好支持便捷的用户认证等；&lt;/p&gt;

&lt;p&gt;• 成本控制：因为公司人数逐步在增加，最好是成本越低越好，不能有人数与功能的限制；&lt;/p&gt;

&lt;p&gt;• 易于扩展：最好是完全开源，容易扩展，因为我们内部有个需求，是日常项目执行的过程中，能把日常项目中的某些文档形成知识积累（产品经理的​​需求分析​​，prd等），那么要在知识库上可以提供便捷的二开；&lt;/p&gt;

&lt;p&gt;2、技术选型
其实从交付上最理想的是语雀和Thoughts（teambition的内容管理），虽然也有腾讯文档与石墨文档等，其实从需求层面都可以使用，但是更多的侧重于个人使用，但是这些都是SaaS的，​​私有化​​部署贵的吓人。
然后找了支持本地化部署的MRdoc，但是这个版本是python的，我们的技术团队都是java，技术栈不对。然后也看了开源wiki，根据项目组的实际情况，修改代码，实现自己想要的效果。推荐使用dokuwiki，简洁、可自行性极高、支持权限、版本持续更新重。最大的的缺点是，编辑文档的操作性比较不友好。
最后我们选型的是 “​​无忧·企业文档​​”，对我们企业需求相当匹配。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/attachment/089f787eb4c540d19191a0423c476710/w600&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;

&lt;p&gt;git开源地址：gitee.com/software-minister/jvs-knowledge-lib/tree/master&lt;/p&gt;

&lt;p&gt;PC端演示环境：
无忧·企业文档-微信扫码直接登录  knowledge.bctools.cn/#/index&lt;/p&gt;

&lt;p&gt;从开始看文档到部署完成，花了半天时间，文档支持还是比较充足。
部分图片：&lt;img src=&quot;https://img.toutiao.io/attachment/119710fff0124df1b445b8120029ce17/w600&quot; alt=&quot;file&quot;/&gt;&lt;img src=&quot;https://img.toutiao.io/attachment/ff7ab8847a8e4c5d89750f037e506cf1/w600&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、最后总结
• 团队一旦达到一定规模，内部信息流动的有效性降低，特别是在技能的传递与知识的沉淀上存在明显的问题。一定要有配套的机制进行技术内容的沉淀与知识的传递。&lt;/p&gt;

&lt;p&gt;• 一定要有所分工与负责人，内容的整理一定是要有经验，对公司的背景特点有非常深刻认识的。公司制度由人事管理、​​通用技术​​有技术部技术专家管理、市场知识类有市场总监负责、产品需求类由产品总监负责等。&lt;/p&gt;

&lt;p&gt;• 知识库的建立到一定程度之后，写的分享就会实实在在的帮助到新人或者其他成员，逐渐的，团队也就能感受到知识库的作用，但是这个过程比较漫长。个人认为分享知识，要调动所有人的积极性是不可能的事情，唯有负责人+强制+鼓励并行，才能真正的建立起知识库。&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>083260150feefd9e01dfc9ef29fe082a</guid>
<title>网络字节序列-大端序和小端序</title>
<link>https://toutiao.io/k/ohy7j47</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;引子&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485988&amp;amp;idx=1&amp;amp;sn=efad5a030bc0a933ac5af2ee09f3c6c4&amp;amp;chksm=fafde08acd8a699c198d0d65c413273f05f2796cfd873160c2ba81ed3f33aebfaccb62234cb7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《一个http请求进来都经过了什么(2021版)》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《一个http请求进来都经过了什么(2021版)》&lt;/a&gt;到&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486103&amp;amp;idx=1&amp;amp;sn=943c5b7f3558df78164321806f273c8f&amp;amp;chksm=fafde039cd8a692f86f0ac97b0e1e05ece075de3e4f33e6a5ec90b269c51aed1963ff3107e0e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《懂得三境界-使用dubbo时请求超过问题》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《懂得三境界-使用dubbo时请求超过问题》&lt;/a&gt;，再到&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486166&amp;amp;idx=1&amp;amp;sn=08a24c175c02a4b146dc52088d410599&amp;amp;chksm=fafde078cd8a696e616aebcb72aeef444e1e0008bf950a368933195f13c0a268face0d3ee371&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《接下来一段时间会对大家进行网络通信的魔鬼训练-理解socket》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《接下来一段时间会对大家进行网络通信的魔鬼训练-理解socket》&lt;/a&gt;和&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486186&amp;amp;idx=1&amp;amp;sn=f21e17b21beb4c99cef0e076071ac859&amp;amp;chksm=fafde044cd8a69526aa3ec9edbe71ea5aa41de2ef236494201dc2f20701ed8abc6be1a72344f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《深入理解MQ生产端的底层通信过程-理解channel》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《&lt;span&gt;深入理解MQ生产端的底层通信过程-理解channel&lt;/span&gt;&lt;span&gt;》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;，我的思路是一篇篇的深入网络通信底层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;到了通信底层，必须要了解的一个知识是网络字节序列。这个东东，99%以上的开发中都用不到。but:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先这个问题比较好理解；第二，要手动处理二进制流的话就不得不考虑，否则可能测试的时候完全没有发现问题，到线上出现诡异事件；第三，这个知识如此之重要，我记得大学的时候课本上也讲过。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;字节序列的历史&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;字节序列分成大端序（big endian或称大尾序）和小端序（little endian或称小尾序）。那为什么大小尾序会称为大小端序呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;术语“little endian(小端)”和“big endian(大端)”出自Swift的《格列佛游记》（Gulliver&#x27;s Trabels）一书，其中交战的两个派别无法就应该从哪一端（小端还是大端）打开一个半熟的鸡蛋达成一致。就像鸡蛋的问题一样，选择何种字节顺序没有技术上的理由。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;“小”国和“大”国，这两大强国在过去三年一直在苦战。战争开始是由于：我们大家都认为，吃鸡蛋前，原始的方法是打破鸡蛋较大的一端，可是“小”国的祖父小时候吃鸡蛋，一次按古法打鸡蛋是碰巧将一个手指弄破了，因此他的父亲，当时的皇帝，就下了一道敕令，命令全体臣民吃鸡蛋时打破鸡蛋较小的一端，违令者重罚。老百姓们对这项命令极为反感。历史告诉我们，由此曾发生过六次叛乱，其中一个皇帝送了命，另一个丢了王位。这些叛乱大多都是由“大”国的人们煽动起来的。因为叛乱平息后，流亡的人总是逃到“大”国去寻救避难，“大”国的人口就增加了。据估计，先后几次有11000人情愿受死也不肯去打破鸡蛋较小的一端。关于这一争端，曾出版过几百本大部著作，不过大端派的书一直是受禁的，法律也规定该派的任何人不得做官。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Swift是在讽刺英国和法国之间的持续的冲突。Danny Cohen，一位网络协议的早期开创者，第一次使用这两个术语来指代字节顺序，后来这个术语被广泛接纳了。因为产生两种序列的标准和Swift讲的故事如出一辙：几十年前，两强互相看不惯，摩托罗拉(Motorala)使用大端序，英特尔(Intel)使用小端序。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;大端序和小&lt;strong&gt;&lt;span&gt;端&lt;/span&gt;&lt;/strong&gt;序的理解&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;数值例如0x2266使用两个字节储存：高位字节是0x22，低位字节是0x66。&lt;/p&gt;&lt;blockquote/&gt;&lt;p&gt;0x1234567大端字节序和小端字节序的写法如下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;200&quot; data-backw=&quot;400&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibpMFn6yJ42PkM6FDR6NNvsNKyHic0WYn72S9OeWvJMgrIgPvGKscDLf9tgN5lIttJt35Gp1CdsliaA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p&gt;打个比方：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.568&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlibpMFn6yJ42PkM6FDR6NNvspUShpCYV4Tp2Kmgpic2OuibiaJBicB3FicnIrZ1Wno4Z8WJeT9qwGGbkE6Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;&lt;p&gt;计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。但是，人类还是习惯读写大端字节序。所以，除了计算机的内部处理，其他的场合几乎都是大端字节序，比如网络传输和文件储存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;结论：网络字节序列传输采用大端序。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;标准不同引发的问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2016年我做了一款用于处理图片位置被旋转的方法和工具，并成功申请了专利。起因是这样的：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;做过一个项目，有天运营打电话过来说：“有个用户上传了头像到咱们应用上，结果头像是倒置的。”我去后台一看果然是和练倒立一样倒置着脑袋。我们自己测试的时候，从来没有发生这种问题。但是用户所有的声音都是有道理的。当时我们动员了公司所有人用我们的应用看看有没有类似的情况。终于在一个三星的手机上重现了这个问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;原来照片属性中是存储了旋转信息的，我们之所以看到照片显示的位置都很正确，其实是iphone系统，还有大部分的安卓系统发现图片被旋转了之后都有将图片旋转回来的处理。但是在部分android系统中，却没有做这种处理。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.32470334412081986&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibpMFn6yJ42PkM6FDR6NNvsT358Kk1c1sfxibFKicYLN1PTKBibmLqld7Gn8LAGerse0xY1ga9AzU1KQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;927&quot;/&gt;&lt;/p&gt;&lt;p&gt;上面两张图片，每张图片被旋转了旋转了8个角度。这里面只有它们的EXIF信息里的orientation值不同。EXIF信息是数码相机的拍摄信息，在压缩文件的格式中只有JPEG格式的储存了这种信息。它可以有1-8的8个值。分别对应于旋转0度，水平翻转，旋转180度，垂直翻转，顺时针90度—+水平翻转，顺时针90度，顺时针90度+垂直翻转，逆时针90度。这时就会发生这种情况。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;经过调查发现目前并没有现成的java类库来做这件事情，基本都是从系统层面就解决了这个问题。确实有图片处理的类库，可是添加一个大jar包进来就只为获取图片的旋转信息，jar包可有将近一个MB呢。所以咱们尽量还是自己写工具类来解决问题吧。因为这种解决这种问题不涉及其他的处理，这时只用这样一个针对特定问题的工具类增加了代码的可读性，减少了服务器负担。&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;实现原理简单可以理解为：存储图片的旋转信息都是放在EXIF信息里。所以只要找到EXIF信息，根据EXIF信息里的旋转方向将图片旋转回来即可。当然实际上各种考虑要复杂的多。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;后记&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;还记得&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485790&amp;amp;idx=1&amp;amp;sn=28d1275aec18350f7627e81bbdab4dfc&amp;amp;chksm=fafde3f0cd8a6ae60b893b6998175db1c20e96328a5721a1b00a2d7b231d141ba7e85f02c6f0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《面试中一个暴露能力等级的问题》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《面试中一个暴露能力等级的问题》&lt;/a&gt;那篇文章吗？相信只要在工作中遇到问题仔细思考，不放过，一定能说出让面试官眼前一亮的故事。&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6d39e299e619d6434e0f636dcf6bbbcf</guid>
<title>干货 | 分布式数据库TiDB在携程的实践</title>
<link>https://toutiao.io/k/67t945m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single js_wx_tap_highlight wx_tap_card&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left&quot; aria-describedby=&quot;js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MjM5MDI3MjA5MQ==&amp;amp;action=getalbum&amp;amp;album_id=2170120724240302083#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;2170120724240302083&quot; data-tag_source=&quot;3&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#数据库&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;1个&lt;span class=&quot;weui-hidden_abs&quot;&gt;内容&lt;/span&gt;&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span title=&quot;&quot; opera-tn-ra-cell=&quot;_$.pages:0.layers:0.comps:0.title1&quot;&gt;&lt;p&gt;&lt;strong&gt;作者简介&lt;/strong&gt;&lt;/p&gt;&lt;/span&gt; &lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;Army，携程数据库专家，主要负责分布式数据库运维及研究。&lt;/p&gt;&lt;p&gt;Keira，资深数据库工程师，主要负责MySQL和TiDB运维。&lt;/p&gt;&lt;p&gt;Rongjun，携程大数据架构开发，专注离线和实时大数据产品和技术。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程自2014年左右开始全面使用MySQL数据库，随着业务增长、数据量激增，单机实例逐渐出现瓶颈，如单表行数过大导致历史数据查询耗时升高，单库容量过大导致磁盘空间不足等。为应对这些问题，我们采取了诸多措施如分库分表的水平拆分、一主多从读写分离、硬件SSD升级、增加前端Redis缓存等，但同时也使得整个业务层架构更加复杂，且无法做到透明的弹性，因此开始将目光转移到分布式数据库以解决这些痛点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;近年来受到Spanner&amp;amp;F1的启发，基于CAP理论和Paxos、Raft协议作为工程实现的分布式数据库得到了蓬勃发展，从硅谷的CockroachDB到国产的TiDB都在社区产生了很强的影响力。携程也对这些产品从社区活跃度、用户规模、易用性等多个方面做了调研，最终选择了国产的TiDB。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TiDB是一个开源的NewSQL数据库，支持混合事务和分析处理（HTAP）工作负载，兼容大部分MySQL语法，并且提供水平可扩展性、强一致性和高可用性。主要由PingCAP公司开发和支持，并在Apache 2.0下授权。2018年11月我们开始TiDB的POC以及与携程现有运维平台的整合，2019年1月第一个线上应用正式接入，最初的目标只是保证数据库的可用性以及可以存储足够多的关系型数据。随着TiDB快速迭代，越来越多的功能进入社区，如HATP特性，让我们不局限于最初的目标，开始了新的探索。本文将介绍TiDB在携程业务场景中的运维实践，希望对读者有所帮助和参考。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、架构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程内部历时1年，代号为“流浪地球”的机房级故障演练，验证了IDC级别故障容灾能力。我们将TiDB的三个副本分布在三个数据中心，保证在单中心故障时不影响对外服务，同时数据一致性也不受影响，并在tidb-server层实现了自动探活以及自动故障切换，让RPO等于0，RTO小于30S。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们先来了解一下TiDB的整体架构（如图1-1），再结合携程的场景来部署。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5244479495268138&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlVOWWWXtR6ckO6HmJBBpeTPlCmSrVx9L6icZxZsz2SsS5ujT9MXDqvvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1-1 TiDB的整体架构图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从TiDB的架构图我们可以看到，得益于组件 PD 和 TiKV 都通过 Raft 实现了数据的容灾，原生就提供了多IDC的部署能力，和 Google Spanner 采用原子钟方案不同的是，TiDB 采用了 PD 进行单点全局统一授时的 Timestamp方案。TiDB 中的每个事务都需要向 PD leader 获取 TSO，当 TiDB 与 PD leader 不在同一个数据中心时，它上面运行的事务也会因此受网络延迟影响。目前携程的跨 IDC 延迟在 0.5-2ms之间 ，属于可接受的延迟范围。配置三数据中心时，需要对相应的TiKV和PD的label配置规则，这样PD在调度re&lt;/span&gt;&lt;span&gt;gion副本时会根据标签属性在每一个机房都拥有一份全量数据。具体的一个配置示例，如图1-2：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.32636469221835074&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlnicXUdMNyYRCvnRBtibsOdLrj0fcAicjCcudyzFLJ3HUcUKFCSwiadssuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;861&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1-2 TiDB在携程的部署架构和配置&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种部署架构的优点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;所有数据的副本分布在三个数据中心，具备IDC级别的高可用和容灾能力&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;任何一个数据中心失效后，不会产生任何数据丢失 (RPO = 0)&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;任何一个数据中心失效后，其他两个数据中心会自动发起 leader election，并在合理长的时间内（通常情况 20s 以内）自动恢复服务&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、应用场景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TiDB目前已经应用到携程的多个业务场景，包括风控、社区、营销、搜索、酒店等。这里选取两个比较典型的使用案例——国际业务CDP平台和酒店结算业务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.1 国际业务CDP平台&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为Trip数据来源比较广泛，既有自身数据也有外部数据；数据形式也非常多样化，既有结构化数据，也有半结构化和非结构化数据；数据加工形式既有离线数据处理，也有在线数据处理，因此国际业务构建了CDP平台以解决加工这些数据，形成业务系统、运营、市场需要并且可以理解的数据和标签，具体可以阅读往期文章：《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDI3MjA5MQ==&amp;amp;mid=2697271936&amp;amp;idx=2&amp;amp;sn=72d5a081eb34f37a3bd3bdc9e1758b88&amp;amp;chksm=8376e5b4b4016ca2a37435cc855ac9a119a1546821aff30ecef51631c0d14ee31e5ee6695e39&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;携程国际业务动态实时标签处理平台实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;携程国际业务动态实时标签处理平台实践&lt;/a&gt;》。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Ti&lt;/span&gt;&lt;span&gt;DB在其中主要承担存储业务持久化的标签以及内部SOA调用的查询服务。查询分为UID等维度的基础信息查询、订单订阅基础信息查询的OLTP，以及EDM\Marketing等人群的OLAP查询。整个CDP平台的架构如图2-1：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.47012302284710017&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlQknvoGVddYSFXx1kxiaWEPornWQNjegMaX0P3yl3AAEc8AsicLWuiapEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1138&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2-1 CDP平台架构图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体的数据处理，历史全量数据通过数据批处理引擎（如Spark）转换完成以后批量写入到数据持久化存储引擎（TiDB），增量数据业务应用以消息的形式发送到Kafka或者QMQ消息队列，通过实时DAG处理完后持久化到存储引擎（TiDB）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;持久标签访问的主要场景有两个，一种是跟现有CRM系统对接，在线根据业务的特征圈选符合条件的业务数据，这种场景的查询条件不固定，返回结果集因筛选条件而定，对于数据存储引擎的数据计算和处理能力要求比较高，即我们在数据处理领域经常提到的OLAP的场景。&lt;/span&gt;&lt;span&gt;另一种场景是线上业务根据前端传入的业务标签相关的唯一标识来查询是否满足特定业务要求，或者返回指定特征值，满足业务处理的需要，需要毫秒级响应，对应的是OLTP场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于标签的多样性，有查询记录的字段多达60个，查询条件是60个字段的随机组合，无法通过传统数据库层的Index来提高查询效率，经典的方案是OLTP和OLAP分离，但数据会存储多份，多数据源的数据一致性是一个很大的挑战。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于这种场景，我们开启了TiDB的TiFlash，TiFlash 是 TiDB HTAP 形态的关键组件，它是 TiKV 的列存扩展，在提供了良好的隔离性的同时，也兼顾了强一致性。列存副本通过 Raft Learner 协议异步复制，但是在读取的时候通过 Raft 校对索引配合 MVCC 的方式获得 Snapshot Isolation 的一致性隔离级别。&lt;span&gt;TiFlash&lt;/span&gt; MPP模式如图2-2。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.51875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlSAMeqJap3J7C4icicsj0qZ0bWHgNeKYxeqM6E1w4NTZBKnBKrmv2icCQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2-2 TiDB MPP模式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种架构很好地解决了 HTAP 场景的隔离性以及列存同步的问题，开启之后几个典型查询性能提升：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;TiFlash MPP提升，20s -&amp;gt; 1s&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;Set @@session.tidb_allow_mpp=1;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;Set @@session.tidb_enforce_mpp=0;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.12812248186946013&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlaicH70pms48eA0u6kAl6avI4Bqzyq7O25jOElCp7StJ2nTUn665XUAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1241&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;TiFlash 列裁剪，16.9s -&amp;gt; 2.8s&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;Set @@session.tidb_allow_mpp=1;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;Set @@session.tidb_enforce_mpp=0;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;Set session tidb_isolation_read_engines =’tidb,tiFlash’;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.07661290322580645&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlCM8th2Kwk5ehiblHuqrvVpNG3SfNc4HM2WLwflm8icMecLVVCA51JSHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.2 酒店结算业务&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;携程酒店结算业务全库6T，单服务器存储6T全量数据有很大挑战。常规的方法是用分库分表的方式来减少实例数据量及压力，但分库分表的维度很难确定，无论从酒店维度还是供应商维度都无法避免跨片的查询，给程序的开发带来了很大的困难，并且大部分查询都是聚合运算，因此我们尝试迁移到TiDB。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前最大的表存储了28亿条数据，读写已完全切换到TiDB。具体所使用的部署模式和上节提到的国际业务CDP平台类似，同样是开启了TiDB的TiFlash来加速查询的性能，具体的性能如图2-3：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5172995780590718&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlVQiawmS0L6MbvEGbLjbTVuL7hbsEibzzqMgnbBSqTUSrOcIhdhF9ugdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1185&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2-3 酒店结算性能监控&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、一些问题的实践&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.1 参数不合理导致的性能问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分布式数据库有别于传统单机，通常MySQL遇到性能问题时可以快速定位是由于网络抖动、SQL缺失索引还是请求次数激增等原因导致的，但分布式的&lt;span&gt;Ti&lt;/span&gt;&lt;span&gt;DB&lt;/span&gt;&lt;/span&gt;&lt;span&gt;组件众多，各个组件之间的网络通信、某个组件资源不足、SQL复杂等都可能是导致出现性能问题的原因。目前官方提供了问题导图，方便根据不同的场景尽快定位原因。这里给出一个具体的案例，总结了一个典型问题的排查思路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;国际业务集群使用官方默认配置的集群上线测试时，发现写入耗时高达秒级，且耗时波动较大。来自应用端的监控（纵坐标单位为毫秒）,如图3-1：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7613636363636364&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlSibFtzZUTujYhHM0LjJAuWwpQ3Rnb74hBuS6NA4fKSJRmSd2EtdtaWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;528&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3-1 IBA写入响应监控&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据Pingcap的导图发现scheduler command duration的时间约等于事务的prewrite时间（纵坐标单位为秒），可以看出scheduler-worker不足。如图3-2：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.40339425587467365&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlrTV5ahKCibPuUicKpC8HGWXZ4HSEKC6VZc5D1MmxrdSvibr4xGdZsJBFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;766&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3-2 scheduler command duration的时间&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以我们做了如下的调整：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;调整完成后来自应用端的监控（纵坐标单位为毫秒），如图3-3，红色箭头处是参数调整的时间点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4430379746835443&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlxhVWz64nt2icsCnOMmuibWnmVUPuT56XFTqKdOacxtZqkQqqTojgnEIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;711&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3-3 IBA写入响应监控&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;默认配置并非最佳配置，需要根据服务器硬件、使用场景不断调试并最终固化为每个集群甚至所有集群的最佳实践配置；根据PingCAP提供的问题导图，逐步定位具体哪个组件哪个方面存在瓶颈，我们同时也在进一步开发一键定位工具，能更快速的定位性能瓶颈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.2 分布式带来的自增列问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;含自增列的表，在自增列不强制赋值的情况下，insert语句报主键冲突：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;报错SQL：INSERT INTO `xxx_table ` (`id, `name`, `tag`, `comment`, `creator`) VALUES (?, ?, ?, ?, ?)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;报错内容：com.mysql.jdbc.exceptions.jdbc4.MySQLIntegrity&lt;/span&gt;&lt;span&gt;Constraint&lt;/span&gt;&lt;span&gt;ViolationException: Duplicate entry 175190 for key &#x27;PRIMARY&#x27;.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在PingCAP官方文档上，有以下介绍：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TiDB 中，自增列只保证自增且唯一，并不保证连续分配。TiDB 目前采用批量分配 ID 的方式，所以如果在多台 TiDB 上同时插入数据，分配的自增 ID 会不连续。TiDB 实现自增 ID 的原理是每个 tidb-server 实例缓存一段 ID 值用于分配（目前会缓存 30000 个 ID），用完这段值再去取下一段。假设集群中有两个 tidb-server 实例 A 和 B（A 缓存 [1,30000] 的自增 ID，B 缓存 [30001,60000] 的自增 ID），依次执行如下操作：客户端向 B 插入一条将 id 设置为 1 的语句 insert into t values (1, 1)，并执行成功。客户端向 A 发送 Insert 语句 insert into t (c) (1)，这条语句中没有指定 id 的值，所以会由 A 分配，当前 A 缓存了 [1, 30000] 这段 ID，所以会分配 1 为自增 ID 的值，并把本地计数器加 1。而此时数据库中已经存在 id 为 1 的数据，最终返回 Duplicated Error 错误。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过这段介绍，我们了解到造成自增主键冲突，是因为存在自增主键显式插入导致。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;结论：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;分布式数据库对于表自增列是预分配的，自增主键显式插入会导致tidb-server上的计数器混乱，引起数据写入报错。在开发规范中，我们明确要求TiDB不允许自增主键显式插入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.3 修改字段是否为空导致默认值异常&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下的表，我们字段从int升级到bigint&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CREATE TABLE `test` (`id` int);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;alter table `test` add `col1` int(11) null default &#x27;0&#x27;;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;alter table `test` add `col2` int(11) null default &#x27;0&#x27;;   &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;alter table `test` change `col1` `col1` bigint(20) null default &#x27;0&#x27;;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;alter table `test` change `col2` `col2` bigint(20) null default &#x27;0&#x27;;  &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们发现默认值0不合适，因此，执行下面的语句，把默认值调整为null&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;alter table `test` change `col1` `col1` bigint(20) null ;   &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;alter table `test` change `col2` `col2` bigint(20) null&#x27;;   &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此时，我们插入一条数据：insert into test(id) values(1);&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;神奇的发现，col1和col2的值依旧是0. 这和我们的预期不符。经过一系列重现测试，以及社区论坛的查找，我们发现这个问题是一个已知问题。&lt;a target=&quot;_blank&quot; href=&quot;https://github.com/pingcap/tidb/pull/20491&quot; textvalue=&quot;https://github.com/pingcap/tidb/pull/20491&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;https://github.com/pingcap/tidb/pull/20491&lt;/a&gt;. 该Bug在TiDB 4.0.9及以后版本已修复。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;结论：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;成熟的社区论坛是TiDB日常运维和快速排障的利器，借助社区论坛上各种技术探索和交流分享，可以汲取优质内容，收获前沿知识，快速定位和解决问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;四、监控与告警&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于分布式数据库运维，监控和告警是非常核心的一环，冒烟现象或者不规范现象，需要及时发现，及时解决，避免问题恶化。监控准确、告警及时可以帮助运维人员准确定位问题，快速解决故障。TiDB 使用开源时序数据库 Prometheus 作为监控和性能指标信息存储方案，使用 Grafana 作为可视化组件进行展示，我们在此基础上进一步做了整合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.1 TiDB监控大盘&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TiDB原生提供prometheus+Grafana的性能大盘，数据非常丰富，但数据分散在单独的集群，无法提供全局视角，我们通过prometheus源生remote write到9201端口，自研了一个adaptor监听9201端口，转发性能数据到携程统一监控平台，搭建了我们自己的监控大盘。如图4-1：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.45&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlYNjibrJTuNyUbfuMBXqn3O27sghq24cIBWCMfd530hBT8gD1lSUU0xQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4-1 整合后的TiDB监控大盘 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.2 三副本监控&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TiDB使用三个以上的副本，通过raft协议来保证数据的一致性。当出现多数副本丢失或者宕机时，这部分数据处于不可用状态，是否存在副本缺失或者副本状态异常是需要特别注意的。因此我们会针对副本的数目及状态进行巡检，确保不会出现长时间内副本不足的情况，一旦发现有副本丢失，可以增加副本的调度线程，务必及时解决副本缺失问题。Region Peer的监控如图4-2：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4709090909090909&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdl5AMVht994duxmH66vOKjq80s4nltUJgRej56DwmA93Mx1zAl9n1jbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;550&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4-2 三副本监控&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.3 磁盘容量监控&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TiDB存储数据量庞大，需要特别关注机器磁盘剩余可使用空间的情况，以免写满磁盘造成不必要的故障。对于磁盘的监控，我们的阈值是物理磁盘的80%，一旦磁盘使用容量超过阈值，我们需要安排加机器扩容。对比相同情况下MySQL复杂的拆分方法，TiDB的处理方法更简单高效。磁盘的监控告警如图4-3：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5444444444444444&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1fxxpGjtl7qM7bDvYqFvqdlem5Ao42rbS1CZickcCZfCXIjxY0zLYFT0giaYRpHzh9PWJD3FJDPzFTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;360&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4-3 TiDB磁盘监控&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.4 配置标准化检查&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TiDB集群的配置文件参数、系统参数众多，不同实例的配置项各不相同，且经常会对集群扩容缩容，因此我们要求变更前后集群的配置必须严格按照标准配置进行调整。只要做到配置标准，很大程度上就会保证集群标准化运行。配置标准化的监控告警如图4-4：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.16752312435765673&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kEeDgfCVf1crw9HkpWicbLUPHibZpLqibqCp7RzaX0XDWjzobFyVIpibVolrHR04ZpJNI8EjFr3EPw55WI8z3m6QZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;973&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4-4 配置标准化的监控告警&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;4.5 性能告警&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有时候会存在突发的流量上升，或者瞬间的性能尖峰的情况，这时候就需要关注性能告警。METRICS_SCHEMA 是基于 Prometheus 中 TiDB 监控指标的一组视图，有了基础的性能数据，我们只需要根据性能阈值，及时告警，及时分析处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;五、周边工具&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了监控与告警，我们也开发了一系列周边工具，对于TiDB的运维，带来了更大的便利。这些周边工具主要包括：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.1 和现有的数据周边工具打通&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现有的数据周边工具主要包括：数据库的发布（DDL），数据在线查询，数据在线修改，以及和现有的大数据流程打通等，这些支持MySQL的工具也一样可以支持TiDB，为MySQL迁移TiDB打解决了后顾之忧，让之前使用MySQL的开发测试人员可以方便流畅地切换到TiDB。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.2 TiDB部署工具&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TiDB集群实例角色较多，集群部署有别于传统单机，需要单独开发一套部署工具，包括集群上线流程、集群下线流程、扩容缩容实例、集群版本升级等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.3 TiDB闪回工具&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有时候会遇到开发测试人员误操作数据的情况，可以使用数据闪回工具进行回退，我们借助TiDB binlog开发了闪回工具，对binlog的内容做反转，生成数据恢复SQL，供 TiDB数据恢复使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;六、未来规划&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.1 故障的一键分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分布式数据库与单机不同， TiDB组件比较多，可供调整的参数有数百个，各个组件之间的网络通信、某个组件资源不足、SQL复杂等都可能导致出现性能问题，后续计划将TiDB诊断做成自动化和智能化，目前已经通过改造TiDB server源码，完成了TiDB的全链路SQL收集和分析，这将作为未来故障一键分析的基础。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.2 基于HDD硬盘测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TiDB 所有的优化都是基于SSD来做的，高性能意味着高成本。我们还是会面临数据量比较大，但写入和查询都比较少，响应要求不高的场景。我们目前已经完成基于HDD硬盘的测试，选择的机器配置为12块10T HDD硬盘，单机部署12个TiKV实例，这种架构已经在小范围应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.3 同城双中心自适应同步方案DR Auto-Sync&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DR Auto-Sync 正处在高速迭代的周期中，后续版本将会有一系列高可用和容灾能力的加强。从 5.3.0 开始将支持双中心对等部署，藉此获得快速恢复多副本的能力，我们也在保持关注中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;【推荐阅读】&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kEeDgfCVf1crw9HkpWicbLUPHibZpLqibqCNpp1MADT0D3Tic6Aaw2wmqnpOhvqedVNzZbkqicLxbb6h9O8p1uNKI6Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; “携程技术”公众号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;  分享，交流，成长&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bdc555394158f6d5c74e5e8e01bd45a2</guid>
<title>如何用Python爬取网易云音乐歌单</title>
<link>https://toutiao.io/k/3xwcyvs</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;pre data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;点击⬆️方“&lt;/span&gt;&lt;span&gt;逆锋起笔&lt;/span&gt;&lt;span&gt;”，&lt;/span&gt;&lt;span&gt;公众号回复 &lt;/span&gt;&lt;span&gt;编程资源&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;领取大佬们推荐的学习资料&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;作者：我不是秃头哆唻咪 （侵删）&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;https://blog.csdn.net/weixin_44864260/article/details/113428996&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;此货很干,跟上脚步!!!&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;Cookie&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;cookie是什么东西?&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;小饼干?能吃吗?&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;简单来说就是你第一次用账号密码访问服务器&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;服务器在你本机硬盘上设置一个身份识别的会员卡(cookie)&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下次再去访问的时候只要亮一下你的卡片(cookie)&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;服务器就会知道是你来了,因为你的账号密码等信息已经刻在了会员卡上&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;需求分析&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;爬虫要访问一些私人的数据就需要用cookie进行伪装&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;想要得到cookie就得先登录,爬虫可以通过表单请求将账号密码提交上去&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是在火狐的F12截取到的数据就是,&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;网易云音乐先将你的账号密码给编了码,再发post请求&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以我们在准备表单数据的时候就已经被卡住了&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这时候我们就可以使用自动化测试Selenium帮助我们去登录&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;登录好之后就获取cookie给爬虫使用&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;OK,废话也废话完了,直接开整吧!!&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先跟我创建一个爬虫项目和爬虫&lt;br/&gt;在cmd创建&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5244897959183673&quot; data-type=&quot;png&quot; data-w=&quot;980&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoXsib8iaWvdDA8GuFFicqPibSPmu7ickftcibgBmGJmesR4xeXdSgLPoMKC5kMUCy61wkteEmiat98tqTFw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;用Pycharm打开这个项目&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先修改配置文件setting.py&lt;br/&gt;1.关闭机器人协议&lt;br/&gt;2.取消禁用cookie的功能&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.0174520069808028&quot; data-type=&quot;png&quot; data-w=&quot;573&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoXsib8iaWvdDA8GuFFicqPibSPhX9rKwj6H6yOpfBDXSngAa5VrmYmGDub70ZXhrk8IRC8ooY9R7tMyQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;现在就回到爬虫文件wyySpider.py准备前期的工作&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;修改start_urls里的网址&lt;/strong&gt;和&lt;strong&gt;准备一个请求头&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;首先用火狐浏览器打开网易云音乐,登录后进入到个人主页&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.1129032258064515&quot; data-type=&quot;png&quot; data-w=&quot;372&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoXsib8iaWvdDA8GuFFicqPibSPrsKc6Mo5Kylq0oI28yovtlPlRYUb54WNGo87llS16Nk8vFrlXrLcyg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.8128031037827352&quot; data-type=&quot;png&quot; data-w=&quot;1031&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoXsib8iaWvdDA8GuFFicqPibSPJL8gyhEabOuqvLzeMG355Wl7vRibSVKFr5bCfTYwhiah4jpgBupL1EDg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4991852254209669&quot; data-type=&quot;png&quot; data-w=&quot;1841&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoXsib8iaWvdDA8GuFFicqPibSPxyL0SzxibNP4VScLscSXK4MbSrQj2AAFYz5hqPCH5iaHiaCC2MibycXwJg/640?wx_fmt=png&quot;/&gt;&lt;img data-ratio=&quot;0.28702851885924563&quot; data-type=&quot;png&quot; data-w=&quot;1087&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoXsib8iaWvdDA8GuFFicqPibSPbFicoyMTXxUL7sDkmg5qr6C0pZWbjuyG8LKTibxAzPH2klv08KWMW0sg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在爬虫代码那里准备一下,修改一下start_urls&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;import&lt;/span&gt; scrapy&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt; webdriver&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.common.action_chains &lt;span&gt;import&lt;/span&gt; ActionChains&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; time&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WyyspiderSpider&lt;/span&gt;&lt;span&gt;(scrapy.Spider)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    name = &lt;span&gt;&#x27;wyySpider&#x27;&lt;/span&gt;&lt;br/&gt;    allowed_domains = [&lt;span&gt;&#x27;163.com&#x27;&lt;/span&gt;]&lt;br/&gt;    start_urls = [&lt;span&gt;&#x27;https://music.163.com/playlist?id=19xxxxx7&#x27;&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;先实现一下&lt;strong&gt;自动登录功能获取cookie&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先导一下自动化测试的包(Selenium)&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;没有这个包的话去控制台:pip --default-timeout=100 install selenium -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt; webdriver&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.common.action_chains &lt;span&gt;import&lt;/span&gt; ActionChains&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; time&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;导完包还要一个谷歌的驱动程序,先看一下自己的谷歌版本&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4195612431444241&quot; data-type=&quot;png&quot; data-w=&quot;1094&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoXsib8iaWvdDA8GuFFicqPibSPsNJBndJsib8iccT3fXMIGbxbA5ANKmzj92mUEHyibHsdn2dib4BXU0VfGA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;到这网站下载相同版本的驱动程序:&lt;/span&gt;&lt;span&gt;https://sites.google.com/a/chromium.org/chromedriver/home&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果版本跟我的一样可以去网盘下载:&lt;br/&gt;链接: https://pan.baidu.com/s/1M-gME2R8EEhEoFlPaDhbmA 提取码: 7iai&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;解压后记住这个驱动的位置,在爬虫文件写一个获取cookie的函数（微信搜索readdot，关注后回复 编程资源，领取各种经典学习资料）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;以下代码的坐标不一定适合各位的电脑,不过给你们安利个物理外挂(电脑微信截图Alt+A)&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;        &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;getCookie&lt;/span&gt;&lt;span&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 获取谷歌的驱动,参数为刚刚驱动程序的位置&lt;/span&gt;&lt;br/&gt;        driver = webdriver.Chrome(&lt;span&gt;&quot;C:/Users/Administrator/AppData/Local/Programs/Python38/Lib/site-packages/selenium/webdriver/chrome/chromedriver.exe&quot;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;# -----------------selenium自动登录-----------------------&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 打开谷歌然后访问指定的网站&lt;/span&gt;&lt;br/&gt;        driver.get(&lt;span&gt;&quot;https://music.163.com/&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 最大化,睡眠是怕网速慢没加载出来&lt;/span&gt;&lt;br/&gt;        driver.maximize_window()&lt;br/&gt;        time.sleep(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 鼠标从(0,0)向x(1435px),y(35px)移动,用左键点击一下&lt;/span&gt;&lt;br/&gt;        ActionChains(driver).move_by_offset(&lt;span&gt;1435&lt;/span&gt;, &lt;span&gt;35&lt;/span&gt;).click().perform()&lt;br/&gt;        time.sleep(&lt;span&gt;0.3&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 点击其他方式&lt;/span&gt;&lt;br/&gt;        ActionChains(driver).move_by_offset(&lt;span&gt;-480&lt;/span&gt;, &lt;span&gt;575&lt;/span&gt;).click().perform()&lt;br/&gt;        time.sleep(&lt;span&gt;0.3&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 同意条款&lt;/span&gt;&lt;br/&gt;        ActionChains(driver).move_by_offset(&lt;span&gt;-218&lt;/span&gt;, &lt;span&gt;-10&lt;/span&gt;).click().perform()&lt;br/&gt;        time.sleep(&lt;span&gt;0.3&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 手机登录&lt;/span&gt;&lt;br/&gt;        ActionChains(driver).move_by_offset(&lt;span&gt;107&lt;/span&gt;, &lt;span&gt;-100&lt;/span&gt;).click().perform()&lt;br/&gt;        time.sleep(&lt;span&gt;0.3&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 输入账号密码&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 通过css选择器获取id为&quot;p&quot;的标签,然后send_keys就是模拟输入一些信息&lt;/span&gt;&lt;br/&gt;        driver.find_element_by_css_selector(&lt;span&gt;&quot;#p&quot;&lt;/span&gt;).send_keys(&lt;span&gt;&quot;账号&quot;&lt;/span&gt;)&lt;br/&gt;        driver.find_element_by_css_selector(&lt;span&gt;&quot;#pw&quot;&lt;/span&gt;).send_keys(&lt;span&gt;&quot;密码&quot;&lt;/span&gt;)&lt;br/&gt;        time.sleep(&lt;span&gt;0.3&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 点击登录&lt;/span&gt;&lt;br/&gt;        ActionChains(driver).move_by_offset(&lt;span&gt;110&lt;/span&gt;, &lt;span&gt;15&lt;/span&gt;).click().perform()&lt;br/&gt;        time.sleep(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 找到头像悬浮&lt;/span&gt;&lt;br/&gt;        img = driver.find_element_by_css_selector(&lt;span&gt;&quot;div.head:nth-child(1) &amp;gt; img:nth-child(1)&quot;&lt;/span&gt;)&lt;br/&gt;        ActionChains(driver).move_to_element(img).perform()&lt;br/&gt;        time.sleep(&lt;span&gt;0.5&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;# 点击我的主页&lt;/span&gt;&lt;br/&gt;        ActionChains(driver).move_by_offset(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;40&lt;/span&gt;).click().perform()&lt;br/&gt;        time.sleep(&lt;span&gt;0.5&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;# 点击喜欢的音乐&lt;/span&gt;&lt;br/&gt;        ActionChains(driver).move_by_offset(&lt;span&gt;-870&lt;/span&gt;, &lt;span&gt;830&lt;/span&gt;).click().perform()&lt;br/&gt;        time.sleep(&lt;span&gt;0.3&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# -----------------selenium自动登录-----------------------&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;登录完毕后就可以获取cookie,但看一下下面的cookie&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;[{&lt;span&gt;&#x27;domain&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;music.163.com&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;expiry&#x27;&lt;/span&gt;: &lt;span&gt;2147483647&lt;/span&gt;, &lt;span&gt;&#x27;httpOnly&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;WM_TID&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;path&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;secure&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;value&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;UnQj6SSNqN9BEVdubmNcEjpl%2B9DA&#x27;&lt;/span&gt;}, {&lt;span&gt;&#x27;domain&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;music.163.com&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;expiry&#x27;&lt;/span&gt;: &lt;span&gt;2147483647&lt;/span&gt;, &lt;span&gt;&#x27;httpOnly&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;WM_NIKE&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;path&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;secure&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;value&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;9ca17ae2e6ffcda170e2e6ee87f4508ef58483ea4a97968ea7c54e879a8eaaf445aebc83b6e933f3f1c0b4c82af0fea7c3b92af697b7a6dc7b82afc09ad98ca695bc5082ecbcb1e772b7889b3d1c15bf28da0bbfb5b95aa8795f073adbc9c98ed79a28d8aa7f450f1ae9dd9b77a85edbf9ac625f1ef84d8f970b4e7bfd8cd21b48e8c8ec17df3e7a898f74488ef9bb5c837e2a3&#x27;&lt;/span&gt;}, {&lt;span&gt;&#x27;domain&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;.music.163.com&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;httpOnly&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;WNMCID&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;path&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;sameSite&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;Strict&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;secure&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;value&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;fdygqk.1611989994304.01.0&#x27;&lt;/span&gt;}, {&lt;span&gt;&#x27;domain&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;.music.163.com&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;httpOnly&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;WEVNSM&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;path&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;sameSite&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;Strict&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;secure&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;value&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;1.0.0&#x27;&lt;/span&gt;}, {&lt;span&gt;&#x27;domain&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;music.163.com&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;expiry&#x27;&lt;/span&gt;: &lt;span&gt;2147483647&lt;/span&gt;, &lt;span&gt;&#x27;httpOnly&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;WM_NI&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;path&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;secure&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;value&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;6IyEYqBqpyZMITjt9DB4tPdzuXUFC%2BNyOiu3S04CTC5Nsv2Q4gkMM0BQ2SPZxQWvItmyodTwnsbSFFqD3rS84rG3qyG%2F31L7zdp9q7N%2BpRDmBw19hwtHD1UTE%3D&#x27;&lt;/span&gt;}, {&lt;span&gt;&#x27;domain&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;.music.163.com&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;expiry&#x27;&lt;/span&gt;: &lt;span&gt;1927349994&lt;/span&gt;, &lt;span&gt;&#x27;httpOnly&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;NMTID&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;path&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;secure&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;value&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;00O-pWx8ZDJJQfiFkHzsgin07nYSmUAAAF3UhdN2w&#x27;&lt;/span&gt;}, {&lt;span&gt;&#x27;domain&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;.163.com&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;expiry&#x27;&lt;/span&gt;: &lt;span&gt;4765589994&lt;/span&gt;, &lt;span&gt;&#x27;httpOnly&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;_ntes_nuid&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;path&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;secure&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;value&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;738fc9cd89d6d8799fa76b3348d25d7d&#x27;&lt;/span&gt;}, {&lt;span&gt;&#x27;domain&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;.163.com&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;expiry&#x27;&lt;/span&gt;: &lt;span&gt;4765589994&lt;/span&gt;, &lt;span&gt;&#x27;httpOnly&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;_ntes_nnid&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;path&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;secure&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;value&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;738fc9cd89d6d8799fa76b3348d25d7d,1611989994150&#x27;&lt;/span&gt;}, {&lt;span&gt;&#x27;domain&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;.music.163.com&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;expiry&#x27;&lt;/span&gt;: &lt;span&gt;1769671794&lt;/span&gt;, &lt;span&gt;&#x27;httpOnly&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;_iuqxldmzr_&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;path&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;secure&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;value&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;32&#x27;&lt;/span&gt;}, {&lt;span&gt;&#x27;domain&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;.music.163.com&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;expiry&#x27;&lt;/span&gt;: &lt;span&gt;1769671794&lt;/span&gt;, &lt;span&gt;&#x27;httpOnly&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;JSESSIONID-WYYY&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;path&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;/&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;secure&#x27;&lt;/span&gt;: &lt;span&gt;False&lt;/span&gt;, &lt;span&gt;&#x27;value&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;OoCMxNwGV%5CfZD2OSzAXovf4ASVZsJ8UQ4sgg7JfH075cKTD%2FW3sMzZj%2BpayS1EnNVXzRm%2F2GxfzIoNv3FTjYxKeNFZWqf6UeiMSc1%2BG98kgsEM94juuE%5Cs18k2%2BPNPAp3hU0G%5CFDUtjkimCR5pgOIOI%3A1611991794102&#x27;&lt;/span&gt;}]&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;是列表加字典的结构,而Scrapy的cookie是字符串类型的,所以我们要做一个转型&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;# 将driver获取的字典类型的cookie提取name和value封装成字符串&lt;/span&gt;&lt;br/&gt;        temp = []&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; driver.get_cookies():&lt;br/&gt;            temp.append(i[&lt;span&gt;&#x27;name&#x27;&lt;/span&gt;] + &lt;span&gt;&quot;=&quot;&lt;/span&gt; + i[&lt;span&gt;&#x27;value&#x27;&lt;/span&gt;])&lt;br/&gt;        &lt;span&gt;# 返回字符串cookie&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&#x27;;&#x27;&lt;/span&gt;.join(temp)&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;所以这个函数基本就写完了,自动登录后获取cookie是不是很爽!!!&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在重写一下def start_requests(self),这个函数是在请求发起前执行的&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;在这个函数把请求头给塞进去,因为setting那边没有定义&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;start_requests&lt;/span&gt;&lt;span&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 定义请求头的时候调用一下getCookie获取一下cookie&lt;/span&gt;&lt;br/&gt;        headers = {&lt;br/&gt;            &lt;span&gt;&#x27;Cookie&#x27;&lt;/span&gt;: self.getCookie(),&lt;br/&gt;            &lt;span&gt;&#x27;User-Agent&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36&#x27;&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;# 注意url是个列表这里拿下标[0],然后把headers请求头塞进去,交给parse函数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;yield&lt;/span&gt; scrapy.Request(url=self.start_urls[&lt;span&gt;0&lt;/span&gt;], headers=headers, callback=self.parse)&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;请求前一切准备好之后,在解析函数(parse)进行保存一下数据,记得导re包&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;parse&lt;/span&gt;&lt;span&gt;(self, response)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 匹配歌曲名的正则表达式&lt;/span&gt;&lt;br/&gt;        patt = re.compile(&lt;span&gt;r&#x27;&amp;lt;a href=&quot;/song.id=.*?&quot;&amp;gt;([^&amp;lt;|{]*?)&amp;lt;/a&amp;gt;&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 找到所有歌曲名&lt;/span&gt;&lt;br/&gt;        listdata = re.findall(patt, response.text)&lt;br/&gt;        &lt;br/&gt;        &lt;span&gt;# 把数据写进txt文件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;with&lt;/span&gt; open(file=&lt;span&gt;&quot;../response.txt&quot;&lt;/span&gt;, mode=&lt;span&gt;&quot;w+&quot;&lt;/span&gt;, encoding=&lt;span&gt;&quot;utf-8&quot;&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; file:&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; listdata:&lt;br/&gt;                file.write(item+&lt;span&gt;&quot;\n&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;一句启动爬虫的命令,眨眨眼的时间 ~&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;数据就进去了哦!原来我的喜爱歌单只有不到500~&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.026098901098901&quot; data-type=&quot;png&quot; data-w=&quot;728&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PvP6qjUpvIoXsib8iaWvdDA8GuFFicqPibSPXibZJJlnu4bHSWTQG1ZBOKQjIJmPuNzbAlu5WzX0rfn0iaZy0dh00VQg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;下面就是爬虫源代码&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;import&lt;/span&gt; scrapy&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; selenium &lt;span&gt;import&lt;/span&gt; webdriver&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; selenium.webdriver.common.action_chains &lt;span&gt;import&lt;/span&gt; ActionChains&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; time&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; re&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WyyspiderSpider&lt;/span&gt;&lt;span&gt;(scrapy.Spider)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    name = &lt;span&gt;&#x27;wyySpider&#x27;&lt;/span&gt;&lt;br/&gt;    allowed_domains = [&lt;span&gt;&#x27;163.com&#x27;&lt;/span&gt;]&lt;br/&gt;    start_urls = [&lt;span&gt;&#x27;https://music.163.com/playlist?id=19xxxxx7&#x27;&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;getCookie&lt;/span&gt;&lt;span&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 获取谷歌的驱动,参数为刚刚驱动程序的位置&lt;/span&gt;&lt;br/&gt;        driver = webdriver.Chrome(&lt;span&gt;&quot;C:/Users/Administrator/AppData/Local/Programs/Python38/Lib/site-packages/selenium/webdriver/chrome/chromedriver.exe&quot;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;# -----------------selenium自动登录-----------------------&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 打开谷歌然后访问指定的网站&lt;/span&gt;&lt;br/&gt;        driver.get(&lt;span&gt;&quot;https://music.163.com/&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 最大化,睡眠是怕网速慢没加载出来&lt;/span&gt;&lt;br/&gt;        driver.maximize_window()&lt;br/&gt;        time.sleep(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;# 以下坐标以自己的电脑为准&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 鼠标从(0,0)向x(1435px),y(35px)移动,用左键点击一下&lt;/span&gt;&lt;br/&gt;        ActionChains(driver).move_by_offset(&lt;span&gt;1435&lt;/span&gt;, &lt;span&gt;35&lt;/span&gt;).click().perform()&lt;br/&gt;        time.sleep(&lt;span&gt;0.3&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 点击其他方式&lt;/span&gt;&lt;br/&gt;        ActionChains(driver).move_by_offset(&lt;span&gt;-480&lt;/span&gt;, &lt;span&gt;575&lt;/span&gt;).click().perform()&lt;br/&gt;        time.sleep(&lt;span&gt;0.3&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 同意条款&lt;/span&gt;&lt;br/&gt;        ActionChains(driver).move_by_offset(&lt;span&gt;-218&lt;/span&gt;, &lt;span&gt;-10&lt;/span&gt;).click().perform()&lt;br/&gt;        time.sleep(&lt;span&gt;0.3&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 手机登录&lt;/span&gt;&lt;br/&gt;        ActionChains(driver).move_by_offset(&lt;span&gt;107&lt;/span&gt;, &lt;span&gt;-100&lt;/span&gt;).click().perform()&lt;br/&gt;        time.sleep(&lt;span&gt;0.3&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 输入账号密码&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 通过css选择器获取id为&quot;p&quot;的标签,然后send_keys就是模拟输入一些信息&lt;/span&gt;&lt;br/&gt;        driver.find_element_by_css_selector(&lt;span&gt;&quot;#p&quot;&lt;/span&gt;).send_keys(&lt;span&gt;&quot;账号&quot;&lt;/span&gt;)&lt;br/&gt;        driver.find_element_by_css_selector(&lt;span&gt;&quot;#pw&quot;&lt;/span&gt;).send_keys(&lt;span&gt;&quot;密码&quot;&lt;/span&gt;)&lt;br/&gt;        time.sleep(&lt;span&gt;0.3&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 点击登录&lt;/span&gt;&lt;br/&gt;        ActionChains(driver).move_by_offset(&lt;span&gt;110&lt;/span&gt;, &lt;span&gt;15&lt;/span&gt;).click().perform()&lt;br/&gt;        time.sleep(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 找到头像悬浮&lt;/span&gt;&lt;br/&gt;        img = driver.find_element_by_css_selector(&lt;span&gt;&quot;div.head:nth-child(1) &amp;gt; img:nth-child(1)&quot;&lt;/span&gt;)&lt;br/&gt;        ActionChains(driver).move_to_element(img).perform()&lt;br/&gt;        time.sleep(&lt;span&gt;0.5&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;# 点击我的主页&lt;/span&gt;&lt;br/&gt;        ActionChains(driver).move_by_offset(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;40&lt;/span&gt;).click().perform()&lt;br/&gt;        time.sleep(&lt;span&gt;0.5&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;# # 点击喜欢的音乐&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# ActionChains(driver).move_by_offset(-870, 830).click().perform()&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# time.sleep(0.3)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# -----------------selenium自动登录-----------------------&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 将driver获取的字典类型的cookie提取name和value封装成字符串&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 临时存放每个拼接好的key=value字符串&lt;/span&gt;&lt;br/&gt;        temp = []&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 遍历driver给的cookies字典&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; driver.get_cookies():&lt;br/&gt;            temp.append(i[&lt;span&gt;&#x27;name&#x27;&lt;/span&gt;] + &lt;span&gt;&quot;=&quot;&lt;/span&gt; + i[&lt;span&gt;&#x27;value&#x27;&lt;/span&gt;])&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 返回字符串cookie&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&#x27;;&#x27;&lt;/span&gt;.join(temp)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;start_requests&lt;/span&gt;&lt;span&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 定义请求头的时候调用一下getCookie获取一下cookie&lt;/span&gt;&lt;br/&gt;        headers = {&lt;br/&gt;            &lt;span&gt;&#x27;Cookie&#x27;&lt;/span&gt;: self.getCookie(),&lt;br/&gt;            &lt;span&gt;&#x27;User-Agent&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.104 Safari/537.36&#x27;&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;# 注意url是个列表这里拿下标[0],然后把headers请求头塞进去,交给parse函数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;yield&lt;/span&gt; scrapy.Request(url=self.start_urls[&lt;span&gt;0&lt;/span&gt;], headers=headers, callback=self.parse)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;parse&lt;/span&gt;&lt;span&gt;(self, response)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 匹配歌曲名的正则表达式&lt;/span&gt;&lt;br/&gt;        patt = re.compile(&lt;span&gt;r&#x27;&amp;lt;a href=&quot;/song.id=.*?&quot;&amp;gt;([^&amp;lt;|{]*?)&amp;lt;/a&amp;gt;&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 找到所有歌曲名&lt;/span&gt;&lt;br/&gt;        listdata = re.findall(patt, response.text)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 把数据写进txt文件&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;with&lt;/span&gt; open(file=&lt;span&gt;&quot;response.txt&quot;&lt;/span&gt;, mode=&lt;span&gt;&quot;w+&quot;&lt;/span&gt;, encoding=&lt;span&gt;&quot;utf-8&quot;&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt; file:&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; listdata:&lt;br/&gt;                file.write(item+&lt;span&gt;&quot;\n&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247492605&amp;amp;idx=1&amp;amp;sn=d4a9e41c255057e2a2e64a813f5c1ef2&amp;amp;chksm=fa3f02a6cd488bb03b519f3a16430c0ccf3725d875ba3b01225b898911882d3d5caf57119fa4&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;假如程序员进军 UI 界？&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247492582&amp;amp;idx=1&amp;amp;sn=7994d770fcca4e47e379db37c4c13054&amp;amp;chksm=fa3f02bdcd488bab5acddee3cb1c35e1e7e597bd65fa3c3508ce8045c6fb13615b8ffe2ec34b&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;2021 年软件开发趋势大预测！&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247492576&amp;amp;idx=1&amp;amp;sn=e481178446fb6b3ee0eec9d7b400277b&amp;amp;chksm=fa3f02bbcd488badceacdd16cb64c930d39f2fcf603004a0379cfacdf1098bb38e5f37b2f85a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;谷歌发布新编程语言，居然专治这个？&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247492456&amp;amp;idx=1&amp;amp;sn=03b089ffe7a7986cdc6ea50bfffb11ed&amp;amp;chksm=fa3f0233cd488b250a43e7a574d1e88a0bc89fb5e3bd912c043b07ce0cd388d4bc189390df21&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;重磅：微信内置输入法来了！&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMzM2ODUwMA==&amp;amp;mid=2247492542&amp;amp;idx=1&amp;amp;sn=49b99b871ac5386db6b526408e92a54e&amp;amp;chksm=fa3f02e5cd488bf3211f2e0048d517cc9a104970787a2269a1d9c57b58186b533ae5c1cfea28&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;这个程序员火了，竟是因为给老板修了一 次U盘...&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.3619246861924685&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hs540iaTKoaILnb3kuPFMrsGenkU5D5P7HJTPPCzZ02JAG1SwoNypeEXhc9CmUJBNAPl1RsRGxTRtKg0wRBtWwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;956&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;添加微信codingSmart领取&lt;/span&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hs540iaTKoaJzr8mCunJ8fiaLHTVy5ic53H2dSVXKlA7iaibMyl7qJNTePsPptc1CdmciaD2PmhG5J98xjRicQ3Ob0diaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span data-darkmode-bgcolor-15865441435016=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15865441435016=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15865441435016=&quot;rgb(255, 21, 21)&quot; data-darkmode-original-color-15865441435016=&quot;rgb(255, 0, 0)&quot; data-style=&quot;max-width: 100%; color: rgb(255, 0, 0); font-family: Optima-Regular, PingFangTC-light; font-weight: 700; letter-spacing: 0.544px; widows: 1; word-spacing: 2px; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__37&quot; data-darkmode-bgcolor-15866879525102=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15866879525102=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15866879525102=&quot;rgb(255, 21, 21)&quot; data-darkmode-original-color-15866879525102=&quot;rgb(255, 0, 0)&quot; data-darkmode-bgcolor-158705654000210=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-158705654000210=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-158705654000210=&quot;rgb(255, 21, 21)&quot; data-darkmode-original-color-158705654000210=&quot;rgb(255, 0, 0)&quot; data-darkmode-bgcolor-15870565400370=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15870565400370=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15870565400370=&quot;rgb(255, 21, 21)&quot; data-darkmode-original-color-15870565400370=&quot;rgb(255, 0, 0)&quot;&gt;支持下 &lt;/span&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;1.764&quot; data-type=&quot;gif&quot; data-w=&quot;250&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/ibsfLhQMgy09JhlUaCQZm4kXHBSlPxPOOpOcfiaNmJRjoem28z1x3CbXNG2eQNK8Tic1Yyf1WqKZ3VibvSicNtwcguQ/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b0d31773bb4bd8122dc9dd6df9b77d37</guid>
<title>基于 Python 探针完成调用库的数据提取</title>
<link>https://toutiao.io/k/3wr0tqo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;前记&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近在完善公司的监控系统, 发现在项目运行时经常会出现一些运行时的问题， 这些问题往往不是一个子服务引发的问题， 而可能是某个环节出现了问题， 这时候就需要引入APM系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在收集APM数据时发现在&lt;code&gt;Python&lt;/code&gt;生态中针对web框架都有完善的APM中间件用于接口统计与监控, 但是第三方调用库相关的APM实现都比较少(几乎没有)， 同时这些库大多数也都没提供一些钩子实现。这就需要自己去封装一些库， 为这些库实现一套调用过程的数据提供逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文是以&lt;code&gt;Python&lt;/code&gt;的&lt;code&gt;aiomysql&lt;/code&gt;库为例，阐述如何基于&lt;code&gt;Python&lt;/code&gt;的探针完成调用库的调用过程统计与监控的封装。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注: 监控的形式的agent有很多种，如&lt;code&gt;Prometheus&lt;/code&gt;，&lt;code&gt;Zabbix&lt;/code&gt;, &lt;code&gt;Graphite&lt;/code&gt;和&lt;code&gt;Opentracing&lt;/code&gt;他们的数据源有很大的不同，但是他们都是基于元数据封装成自己的源数据，然后发送到对应的服务，所以本文只介绍如何提取元数据，剩下的如何发送需要自己按照特定的监控系统去实现。注：这里以aiomysql库来做示例，提取数据的方法应该用统一的dbapi2， 本文只阐述如何简单的实现。&lt;/p&gt;&lt;/blockquote&gt;&lt;section&gt;原文地址：&lt;span&gt;https://so1n.me/2020/11/18/%E5%9F%BA%E4%BA%8EPython%E6%8E%A2%E9%92%88%E5%AE%8C%E6%88%90%E8%B0%83%E7%94%A8%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8F%90%E5%8F%96&lt;/span&gt;&lt;/section&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;1.简单粗暴的方法--对mysql库进行封装&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要统计一个执行过程， 就需要知道这个执行过程的开始位置和结束位置， 所以最简单粗暴的方法就是基于要调用的方法进行封装，在框架调用&lt;code&gt;MySQL&lt;/code&gt;库和&lt;code&gt;MySQL&lt;/code&gt;库中间实现一个中间层, 在中间层完成耗时统计,如:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# 伪代码&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;my_execute&lt;/span&gt;&lt;span&gt;(conn, sql, param)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;# 针对MySql库的统计封装组件&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;with&lt;/span&gt; MyTracer(conn, sql, param):&lt;br/&gt;        &lt;span&gt;# 以下为正常使用MySql库的代码&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;with&lt;/span&gt; conn.cursor &lt;span&gt;as&lt;/span&gt; cursor:&lt;br/&gt;            cursor.execute(sql, param)&lt;br/&gt;            ...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看样子实现起来非常不错, 而且更改非常方便, 但由于是在最顶层的API上进行修改, 其实是非常不灵活的, 同时在&lt;code&gt;cursor.execute&lt;/code&gt;里会进行一些预操作, 如把sql和param进行拼接, 调用&lt;code&gt;nextset&lt;/code&gt;清除当前游标的数据等等。我们最后拿到的数据如时间耗时也是不准确的, 同时也没办法得到一些详细的元数据， 如错误码等等.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要拿到最直接有用的数据，就只能去改源代码, 然后再调用源代码了, 但是如果每个库都需要改源代码才能统计, 那也太麻烦了, 好在&lt;code&gt;Python&lt;/code&gt;也提供了一些类似探针的接口, 可以通过探针把库的源码进行替换完成我们的代码.&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;2.Python的探针&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;Python&lt;/code&gt;中可以通过&lt;code&gt;sys.meta_path&lt;/code&gt;来实现&lt;code&gt;import hook&lt;/code&gt;的功能, 当执行 import 相关操作时, 会根据&lt;code&gt;sys.meta_path&lt;/code&gt;定义的对象对import相关库进行更改.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sys.meta_path&lt;/code&gt;中的对象需要实现一个&lt;code&gt;find_module&lt;/code&gt;方法， 这个&lt;code&gt;find_module&lt;/code&gt;方法返回&lt;code&gt;None&lt;/code&gt;或一个实现了&lt;code&gt;load_module&lt;/code&gt;方法的对象, 我们可以通过这个对象, 针对一些库在import时, 把相关的方法进行替换, 简单用法如下,通过hook&lt;code&gt;time.sleep&lt;/code&gt;让他在sleep的时候能打印消耗的时间.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;github源码存储：&lt;span&gt;https://github.com/so1n/example/blob/master/example_python/example_python/python_hook/hook_demo&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; importlib&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; sys&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; functools &lt;span&gt;import&lt;/span&gt; wraps&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;func_wrapper&lt;/span&gt;&lt;span&gt;(func)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;&quot;&quot;这里通过一个装饰器来达到狸猫换太子和获取数据的效果&quot;&quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    @wraps(func)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;wrapper&lt;/span&gt;&lt;span&gt;(*args, **kwargs)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 记录开始时间&lt;/span&gt;&lt;br/&gt;        start = time.time()&lt;br/&gt;        result = func(*args, **kwargs)&lt;br/&gt;        &lt;span&gt;# 统计消耗时间&lt;/span&gt;&lt;br/&gt;        end = time.time()&lt;br/&gt;        print(&lt;span&gt;f&quot;speed time:&lt;span&gt;{end - start}&lt;/span&gt;&quot;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; wrapper&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MetaPathFinder&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;find_module&lt;/span&gt;&lt;span&gt;(self, fullname, path=None)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 执行时可以看出来在import哪些模块&lt;/span&gt;&lt;br/&gt;        print(&lt;span&gt;f&#x27;find module:&lt;span&gt;{path}&lt;/span&gt;:&lt;span&gt;{fullname}&lt;/span&gt;&#x27;&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; MetaPathLoader()&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MetaPathLoader&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;load_module&lt;/span&gt;&lt;span&gt;(self, fullname)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# import的模块都会存放在sys.modules里面， 通过判断可以减少重复import&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; fullname &lt;span&gt;in&lt;/span&gt; sys.modules:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; sys.modules[fullname]&lt;br/&gt;        &lt;span&gt;# 防止递归调用&lt;/span&gt;&lt;br/&gt;        finder = sys.meta_path.pop(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;# 导入 module&lt;/span&gt;&lt;br/&gt;        module = importlib.import_module(fullname)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; fullname == &lt;span&gt;&#x27;time&#x27;&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;# 替换函数&lt;/span&gt;&lt;br/&gt;            module.sleep = func_wrapper(module.sleep)&lt;br/&gt;        sys.meta_path.insert(&lt;span&gt;0&lt;/span&gt;, finder)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; module&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;sys.meta_path.insert(&lt;span&gt;0&lt;/span&gt;, MetaPathFinder())&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;&#x27;__main__&#x27;&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;import&lt;/span&gt; time&lt;br/&gt;    time.sleep(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 输出示例:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# find module:datetime&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# find module:time&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# load module:time&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# find module:math&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# find module:_datetime&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# speed time:1.00073385238647468&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;3.制作探针模块&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解完了主要流程后， 可以开始制作自己的探针模块了, 由于示例只涉及到aiomysql模块, 那么在&lt;code&gt;MetaPathFinder.find_module&lt;/code&gt;中需要只对aiomysql模块进行处理, 其他的先忽略. 然后我们需要确定我们要把aiomysql的哪个功能给替换, 从业务上来说, 一般情况下我们只要&lt;code&gt;cursor.execute&lt;/code&gt;, &lt;code&gt;cursor.fetchone&lt;/code&gt;, &lt;code&gt;cursor.fetchall&lt;/code&gt;, &lt;code&gt;cursor.executemany&lt;/code&gt;这几个主要的操作,所以需要深入cursor的源码：&lt;span&gt;https://github.com/aio-libs/aiomysql/blob/master/aiomysql/cursors.py&lt;/span&gt;, 看看如何去更改代码, 后者重载哪个函数.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先&lt;code&gt;cursor.execute&lt;/code&gt;的源码(&lt;code&gt;cursor.executemanay&lt;/code&gt;也类似), 发现会先调用&lt;code&gt;self.nextset&lt;/code&gt;的方法, 把上个请求的数据先拿完, 再合并sql语句, 最后通过&lt;code&gt;self._query&lt;/code&gt;进行查询:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;execute&lt;/span&gt;&lt;span&gt;(self, query, args=None)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;&quot;&quot;Executes the given operation&lt;br/&gt;    Executes the given operation substituting any markers with&lt;br/&gt;    the given parameters.&lt;br/&gt;    For example, getting all rows where id is 5:&lt;br/&gt;        cursor.execute(&quot;SELECT * FROM t1 WHERE id = %s&quot;, (5,))&lt;br/&gt;    :param query: ``str`` sql statement&lt;br/&gt;    :param args: ``tuple`` or ``list`` of arguments for sql query&lt;br/&gt;    :returns: ``int``, number of rows that has been produced of affected&lt;br/&gt;    &quot;&quot;&quot;&lt;/span&gt;&lt;br/&gt;    conn = self._get_db()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;await&lt;/span&gt; self.nextset()):&lt;br/&gt;        &lt;span&gt;pass&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; args &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;:&lt;br/&gt;        query = query % self._escape_args(args, conn)&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;await&lt;/span&gt; self._query(query)&lt;br/&gt;    self._executed = query&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; self._echo:&lt;br/&gt;        logger.info(query)&lt;br/&gt;        logger.info(&lt;span&gt;&quot;%r&quot;&lt;/span&gt;, args)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; self._rowcount&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再看&lt;code&gt;cursor.fetchone&lt;/code&gt;的源码(&lt;code&gt;cursor.fetchall&lt;/code&gt;也类似), 发现其实是从缓存中获取数据, 这些数据在执行&lt;code&gt;cursor.execute&lt;/code&gt;中就已经获取了:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;fetchone&lt;/span&gt;&lt;span&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;&quot;&quot;Fetch the next row &quot;&quot;&quot;&lt;/span&gt;&lt;br/&gt;    self._check_executed()&lt;br/&gt;    fut = self._loop.create_future()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; self._rows &lt;span&gt;is&lt;/span&gt; &lt;span&gt;None&lt;/span&gt; &lt;span&gt;or&lt;/span&gt; self._rownumber &amp;gt;= len(self._rows):&lt;br/&gt;        fut.set_result(&lt;span&gt;None&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; fut&lt;br/&gt;    result = self._rows[self._rownumber]&lt;br/&gt;    self._rownumber += &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    fut = self._loop.create_future()&lt;br/&gt;    fut.set_result(result)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; fut&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综合上面的分析, 我们只要对核心的方法&lt;code&gt;self._query&lt;/code&gt;进行重载即可拿到我们要的数据, 从源码中我们可以知道, 我们能获取到传入&lt;code&gt;self._query&lt;/code&gt;的&lt;code&gt;self&lt;/code&gt;和&lt;code&gt;sql&lt;/code&gt;参数, 根据&lt;code&gt;self&lt;/code&gt;又能获取到查询的结果, 同时我们通过装饰器能获取到运行的时间, 要的数据基本都到齐了, 按照思路修改后的代码如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; importlib&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; time&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; sys&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; functools &lt;span&gt;import&lt;/span&gt; wraps&lt;br/&gt;&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; typing &lt;span&gt;import&lt;/span&gt; cast, Any, Callable, Optional, Tuple, TYPE_CHECKING&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; types &lt;span&gt;import&lt;/span&gt; ModuleType&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; TYPE_CHECKING:&lt;br/&gt;    &lt;span&gt;import&lt;/span&gt; aiomysql&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;func_wrapper&lt;/span&gt;&lt;span&gt;(func: Callable)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    @wraps(func)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;wrapper&lt;/span&gt;&lt;span&gt;(*args, **kwargs)&lt;/span&gt; -&amp;gt; Any:&lt;/span&gt;&lt;br/&gt;        start: float = time.time()&lt;br/&gt;        func_result: Any = &lt;span&gt;await&lt;/span&gt; func(*args, **kwargs)&lt;br/&gt;        end: float = time.time()&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;# 根据_query可以知道, 第一格参数是self, 第二个参数是sql&lt;/span&gt;&lt;br/&gt;        self: aiomysql.Cursor = args[&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt;        sql: str = args[&lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;        &lt;span&gt;# 通过self,我们可以拿到其他的数据&lt;/span&gt;&lt;br/&gt;        db: str = self._connection.db&lt;br/&gt;        user: str = self._connection.user&lt;br/&gt;        host: str = self._connection.host&lt;br/&gt;        port: str = self._connection.port&lt;br/&gt;        execute_result: Tuple[Tuple] = self._rows&lt;br/&gt;        &lt;span&gt;# 可以根据自己定义的agent把数据发送到指定的平台, 然后我们就可以在平台上看到对应的数据或进行监控了, &lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# 这里只是打印一部分数据出来&lt;/span&gt;&lt;br/&gt;        print({&lt;br/&gt;            &lt;span&gt;&quot;sql&quot;&lt;/span&gt;: sql,&lt;br/&gt;            &lt;span&gt;&quot;db&quot;&lt;/span&gt;: db,&lt;br/&gt;            &lt;span&gt;&quot;user&quot;&lt;/span&gt;: user,&lt;br/&gt;            &lt;span&gt;&quot;host&quot;&lt;/span&gt;: host,&lt;br/&gt;            &lt;span&gt;&quot;port&quot;&lt;/span&gt;: port,&lt;br/&gt;            &lt;span&gt;&quot;result&quot;&lt;/span&gt;: execute_result,&lt;br/&gt;            &lt;span&gt;&quot;speed time&quot;&lt;/span&gt;: end - start&lt;br/&gt;        })&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; func_result&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; cast(Callable, wrapper)&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MetaPathFinder&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;    @staticmethod&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;find_module&lt;/span&gt;&lt;span&gt;(fullname: str, path: Optional[str] = None)&lt;/span&gt; -&amp;gt; Optional[&quot;MetaPathLoader&quot;]:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; fullname == &lt;span&gt;&#x27;aiomysql&#x27;&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;# 只有aiomysql才进行hook&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; MetaPathLoader()&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;None&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MetaPathLoader&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;    @staticmethod&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;load_module&lt;/span&gt;&lt;span&gt;(fullname: str)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; fullname &lt;span&gt;in&lt;/span&gt; sys.modules:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; sys.modules[fullname]&lt;br/&gt;        &lt;span&gt;# 防止递归调用&lt;/span&gt;&lt;br/&gt;        finder: &lt;span&gt;&quot;MetaPathFinder&quot;&lt;/span&gt; = sys.meta_path.pop(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;# 导入 module&lt;/span&gt;&lt;br/&gt;        module: ModuleType = importlib.import_module(fullname)&lt;br/&gt;        &lt;span&gt;# 针对_query进行hook&lt;/span&gt;&lt;br/&gt;        module.Cursor._query = func_wrapper(module.Cursor._query)&lt;br/&gt;        sys.meta_path.insert(&lt;span&gt;0&lt;/span&gt;, finder)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; module&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;test_mysql&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; -&amp;gt; &lt;span&gt;None&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;import&lt;/span&gt; aiomysql&lt;br/&gt;    pool: aiomysql.Pool = &lt;span&gt;await&lt;/span&gt; aiomysql.create_pool(&lt;br/&gt;        host=&lt;span&gt;&#x27;127.0.0.1&#x27;&lt;/span&gt;, port=&lt;span&gt;3306&lt;/span&gt;, user=&lt;span&gt;&#x27;root&#x27;&lt;/span&gt;, password=&lt;span&gt;&#x27;123123&#x27;&lt;/span&gt;, db=&lt;span&gt;&#x27;mysql&#x27;&lt;/span&gt;&lt;br/&gt;    )&lt;br/&gt;    &lt;span&gt;async&lt;/span&gt; &lt;span&gt;with&lt;/span&gt; pool.acquire() &lt;span&gt;as&lt;/span&gt; conn:&lt;br/&gt;        &lt;span&gt;async&lt;/span&gt; &lt;span&gt;with&lt;/span&gt; conn.cursor() &lt;span&gt;as&lt;/span&gt; cur:&lt;br/&gt;            &lt;span&gt;await&lt;/span&gt; cur.execute(&lt;span&gt;&quot;SELECT 42;&quot;&lt;/span&gt;)&lt;br/&gt;            (r,) = &lt;span&gt;await&lt;/span&gt; cur.fetchone()&lt;br/&gt;            &lt;span&gt;assert&lt;/span&gt; r == &lt;span&gt;42&lt;/span&gt;&lt;br/&gt;    pool.close()&lt;br/&gt;    &lt;span&gt;await&lt;/span&gt; pool.wait_closed()&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;&#x27;__main__&#x27;&lt;/span&gt;:&lt;br/&gt;    sys.meta_path.insert(&lt;span&gt;0&lt;/span&gt;, MetaPathFinder())&lt;br/&gt;    &lt;span&gt;import&lt;/span&gt; asyncio&lt;br/&gt;&lt;br/&gt;    asyncio.run(test_mysql())&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 输出示例:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 可以看出sql语句与我们输入的一样, db, user, host, port等参数也是, 还能知道执行的结果和运行时间&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# {&#x27;sql&#x27;: &#x27;SELECT 42;&#x27;, &#x27;db&#x27;: &#x27;mysql&#x27;, &#x27;user&#x27;: &#x27;root&#x27;, &#x27;host&#x27;: &#x27;127.0.0.1&#x27;, &#x27;port&#x27;: 3306, &#x27;result&#x27;: ((42,),), &#x27;speed time&#x27;: 0.00045609474182128906}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子看来很不错, 但是需要在调用的入口处显式调用该逻辑, 通常一个项目可能有几个入口, 每个入口都显示调用该逻辑会非常麻烦， 而且必须先调用我们的hook逻辑后才能import， 这样就得订好引入规范， 不然就可能出现部分地方hook不成功, 如果能把引入hook这个逻辑安排在解析器启动后马上执行， 就可以完美地解决这个问题了. &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查阅了一翻资料后发现,&lt;code&gt;python&lt;/code&gt;解释器初始化的时候会自动&lt;code&gt;import PYTHONPATH&lt;/code&gt;下存在的&lt;code&gt;sitecustomize&lt;/code&gt;和&lt;code&gt;usercustomize&lt;/code&gt;模块, 我们只要创建该模块, 并在模块里面写入我们的 替换函数即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体结构如下，也可以参考github存储：https://github.com/so1n/example/blob/master/example_python/example_python/python_hook/hook_by_sys/&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;.&lt;br/&gt;├── __init__.py&lt;br/&gt;├── hook_aiomysql.py&lt;br/&gt;├── sitecustomize.py&lt;br/&gt;└── test_auto_hook.py&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;hook_aiomysql.py&lt;/code&gt;是我们制作探针的代码为例子， 而&lt;code&gt;sitecustomize.py&lt;/code&gt;存放的代码如下, 非常简单， 就是引入我们的探针代码, 并插入到&lt;code&gt;sys.meta_path&lt;/code&gt;：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; sys&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; hook_aiomysql &lt;span&gt;import&lt;/span&gt; MetaPathFinder&lt;br/&gt;&lt;br/&gt;sys.meta_path.insert(&lt;span&gt;0&lt;/span&gt;, MetaPathFinder())&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;test_auto_hook.py&lt;/code&gt;则是测试代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; asyncio&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; hook_aiomysql &lt;span&gt;import&lt;/span&gt; test_mysql&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;asyncio.run(test_mysql())&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来只要设置&lt;code&gt;PYTHONPATH&lt;/code&gt;并运行我们的代码即可（如果是项目的话一般交由superisor启动，则可以在配置文件中设置好&lt;code&gt;PYTHONPATH&lt;/code&gt;）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;(.venv) ➜  python_hook git:(master) ✗ &lt;span&gt;export&lt;/span&gt; PYTHONPATH=.      &lt;br/&gt;(.venv) ➜  python_hook git:(master) ✗ python test_auto_hook.py &lt;br/&gt;{&lt;span&gt;&#x27;sql&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;SELECT 42;&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;db&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;mysql&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;user&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;root&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;host&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;127.0.0.1&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;port&#x27;&lt;/span&gt;: 3306, &lt;span&gt;&#x27;result&#x27;&lt;/span&gt;: ((42,),), &lt;span&gt;&#x27;speed time&#x27;&lt;/span&gt;: 0.000213623046875}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;4.直接替换方法&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到上面的方法很好的运行了， 而且可以很方便的嵌入到我们的项目中， 但是依赖与&lt;code&gt;sitecustomize.py&lt;/code&gt;文件很难让他抽离成一个第三方的库， 如果要抽离成第三方的库就得考虑看看有没有其他的方法。在上面介绍&lt;code&gt;MetaPathLoader&lt;/code&gt;时说到了&lt;code&gt;sys.module&lt;/code&gt;, 在里面通过&lt;code&gt;sys.modules&lt;/code&gt;来减少重复引入：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MetaPathLoader&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;load_module&lt;/span&gt;&lt;span&gt;(self, fullname)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;# import的模块都会存放在sys.modules里面， 通过判断可以减少重复import&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; fullname &lt;span&gt;in&lt;/span&gt; sys.modules:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; sys.modules[fullname]&lt;br/&gt;        &lt;span&gt;# 防止递归调用&lt;/span&gt;&lt;br/&gt;        finder = sys.meta_path.pop(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;        &lt;span&gt;# 导入 module&lt;/span&gt;&lt;br/&gt;        module = importlib.import_module(fullname)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; fullname == &lt;span&gt;&#x27;time&#x27;&lt;/span&gt;:&lt;br/&gt;            &lt;span&gt;# 替换函数&lt;/span&gt;&lt;br/&gt;            module.sleep = func_wrapper(module.sleep)&lt;br/&gt;        sys.meta_path.insert(&lt;span&gt;0&lt;/span&gt;, finder)&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; module&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个减少重复引入的原理是， 每次引入一个模块后， 他就会存放在sys.modules， 如果是重复引入， 就会直接刷新成最新引入的模块。上面之所以会考虑到减少重复import是因为我们不会在程序运行时升级第三方库的依赖。利用到我们可以不考虑重复引入同名不同实现的模块， 以及sys.modules会缓存引入模块的特点， 我们可以把上面的逻辑简化成&lt;code&gt;引入模块-&amp;gt;替换当前模块方法为我们修改的hook方法&lt;/code&gt;。第一次接触这个方法是从opentracing-python-instrumentation：https://github.com/uber-common/opentracing-python-instrumentation学的， 不过他夹带着其他的封装， 所以我这里进行了简化处理 github代码仓：https://github.com/so1n/example/tree/master/example_python/example_python/python_hook/hook_by_global：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; time&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; functools &lt;span&gt;import&lt;/span&gt; wraps&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; typing &lt;span&gt;import&lt;/span&gt; Any, Callable, Tuple, cast&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; aiomysql&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;func_wrapper&lt;/span&gt;&lt;span&gt;(func: Callable)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;&quot;&quot;和上面一样的封装函数, 这里简单略过&quot;&quot;&quot;&lt;/span&gt;&lt;br/&gt;    &lt;br/&gt;&lt;span&gt;# 判断是否hook过&lt;/span&gt;&lt;br/&gt;_IS_HOOK: bool = &lt;span&gt;False&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 存放原来的_query&lt;/span&gt;&lt;br/&gt;_query: Callable = aiomysql.Cursor._query&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# hook函数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;install_hook&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; -&amp;gt; &lt;span&gt;None&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    _IS_HOOK = &lt;span&gt;False&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; _IS_HOOK:&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;    aiomysql.Cursor._query = func_wrapper(aiomysql.Cursor._query)&lt;br/&gt;    _IS_HOOK = &lt;span&gt;True&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 还原到原来的函数方法&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;reset_hook&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; -&amp;gt; &lt;span&gt;None&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    aiomysql.Cursor._query = _query&lt;br/&gt;    _IS_HOOK = &lt;span&gt;False&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码简单明了，接下来跑一跑刚才的测试：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; asyncio&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; aiomysql&lt;br/&gt;&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; demo &lt;span&gt;import&lt;/span&gt; install_hook, reset_hook&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;test_mysql&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; -&amp;gt; &lt;span&gt;None&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    pool: aiomysql.Pool = &lt;span&gt;await&lt;/span&gt; aiomysql.create_pool(&lt;br/&gt;        host=&lt;span&gt;&#x27;127.0.0.1&#x27;&lt;/span&gt;, port=&lt;span&gt;3306&lt;/span&gt;, user=&lt;span&gt;&#x27;root&#x27;&lt;/span&gt;, password=&lt;span&gt;&#x27;&#x27;&lt;/span&gt;, db=&lt;span&gt;&#x27;mysql&#x27;&lt;/span&gt;&lt;br/&gt;    )&lt;br/&gt;    &lt;span&gt;async&lt;/span&gt; &lt;span&gt;with&lt;/span&gt; pool.acquire() &lt;span&gt;as&lt;/span&gt; conn:&lt;br/&gt;        &lt;span&gt;async&lt;/span&gt; &lt;span&gt;with&lt;/span&gt; conn.cursor() &lt;span&gt;as&lt;/span&gt; cur:&lt;br/&gt;            &lt;span&gt;await&lt;/span&gt; cur.execute(&lt;span&gt;&quot;SELECT 42;&quot;&lt;/span&gt;)&lt;br/&gt;            (r,) = &lt;span&gt;await&lt;/span&gt; cur.fetchone()&lt;br/&gt;            &lt;span&gt;assert&lt;/span&gt; r == &lt;span&gt;42&lt;/span&gt;&lt;br/&gt;    pool.close()&lt;br/&gt;    &lt;span&gt;await&lt;/span&gt; pool.wait_closed()&lt;br/&gt;&lt;br/&gt;print(&lt;span&gt;&quot;install hook&quot;&lt;/span&gt;)&lt;br/&gt;install_hook()&lt;br/&gt;asyncio.run(test_mysql())&lt;br/&gt;print(&lt;span&gt;&quot;reset hook&quot;&lt;/span&gt;)&lt;br/&gt;reset_hook()&lt;br/&gt;asyncio.run(test_mysql())&lt;br/&gt;print(&lt;span&gt;&quot;end&quot;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过测试输出可以发现我们的逻辑的正确的, install hook后能出现我们提取的元信息， 而reset后则不会打印原信息&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;install hook&lt;br/&gt;{&lt;span&gt;&#x27;sql&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;SELECT 42;&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;db&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;mysql&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;user&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;root&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;host&#x27;&lt;/span&gt;: &lt;span&gt;&#x27;127.0.0.1&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;port&#x27;&lt;/span&gt;: 3306, &lt;span&gt;&#x27;result&#x27;&lt;/span&gt;: ((42,),), &lt;span&gt;&#x27;speed time&#x27;&lt;/span&gt;: 0.000347137451171875}&lt;br/&gt;reset hook&lt;br/&gt;end&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;5.总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;得益于Python动态语言的特性， 我们可以很容易的为第三方库实现钩子方法，上面说的两种方法中， 第二种方法非常简单， 但在自己项目中最好还是采用第一种方法， 因为&lt;code&gt;Python&lt;/code&gt;是通过一行一行代码进行扫描执行的， 第二种方法只能放在入口代码中， 并且要在被hook的对象实例化之前执行， 不然就会实现hook失败的现象, 而第一种方法除了麻烦外， 基本上能躲避所有坑。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>