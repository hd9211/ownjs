<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1d4d4b44df832196f22d59defa74c8f3</guid>
<title>求抱抱，小王被这 10 道 Java 面试题虐哭了</title>
<link>https://toutiao.io/k/jnjaul9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一天，小王告诉我，他去一家公司面试 Java 岗，结果被面试官虐哭了。整整 10 道 Java 面试题，小王一道也没答正确。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他沮丧地给我说，“哥，说点我的情况，你愿意听吗？我和一个女孩相处，女孩大我两岁，我非科班。本来打算国庆换一家薪水高点的，好确认关系。我经验不多，技术一般般，之前在一家外包公司，有一个甲方内推，我就鲁莽地把外包的工作辞了，结果没想到面试被虐了，我担心女朋友会不会因为我没有工作和我分手。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;听他这么一说，确实挺虐心的。后来我就安慰他，要他端正心态，先把这些面试题整明白，然后继续找工作，不要想太多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;借这个机会，我就把小王遇到的这 10 道面试题分享出来，希望能对其他小伙伴一些帮助。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第一题，下面这串代码打印的结果是什么&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(Math.min(Double.MIN_VALUE, &lt;span&gt;0.0&lt;/span&gt;d));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他觉得 Double.MIN_VALUE 和 Integer.MIN_VALUE 一样，是个负数，应该小于 0.0d。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但事实上，Double. MIN_VALUE 和 Double. MAX_VALUE 一样，都是正数，Double. MIN_VALUE 的值是 &lt;code&gt;2^(-1074)&lt;/code&gt;，直接打印 Double. MIN_VALUE 的话，输出结果为 &lt;code&gt;4.9E-324&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此这道题的正确答案是输出 &lt;code&gt;0.0&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第二题，在 try 块或者 catch 语句中执行 return 语句或者 &lt;code&gt;System.exit()&lt;/code&gt; 会发生什么，finally 语句还会执行吗？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为在他的刻板印象中，finally 语句是无论如何都会执行的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但事实上，在 try 块或者 catch 语句中执行 return 语句时，finally 语句会执行；在 try 块或者 catch 语句中执行 &lt;code&gt;System.exit()&lt;/code&gt; 时，finally 语句不会执行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        returnTryExec();&lt;br/&gt;        returnCatchExec();&lt;br/&gt;        exitTryExec();&lt;br/&gt;        exitCatchExec();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;returnTryExec&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;finally returnTryExec&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;returnCatchExec&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; { } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;finally returnCatchExec&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;exitTryExec&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            System.exit(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;finally exitTryExec&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;exitCatchExec&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; { } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            System.exit(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            System.out.println(&lt;span&gt;&quot;finally exitCatchExec&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序执行结果如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;finally returnTryExec&lt;br/&gt;finally returnCatchExec&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第三题，私有方法或者静态方法能被重写（override）吗？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他不确定私有方法或者静态方法与重写之间的关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重写的两个方法名相同，方法参数的个数也相同；不过一个方法在父类中，另外一个在子类中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LaoWang&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;老王写了一本《基督山伯爵》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;XiaoWang&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;LaoWang&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;小王写了一本《茶花女》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;OverridingTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        LaoWang wang = &lt;span&gt;new&lt;/span&gt; XiaoWang();&lt;br/&gt;        wang.write();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;父类 LaoWang 有一个 &lt;code&gt;write()&lt;/code&gt; 方法（无参），方法体是写一本《基督山伯爵》；子类 XiaoWang 重写了父类的 &lt;code&gt;write()&lt;/code&gt; 方法（无参），但方法体是写一本《茶花女》。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 main 方法中，我们声明了一个类型为 LaoWang 的变量 wang。在编译期间，编译器会检查 LaoWang 类是否包含了 &lt;code&gt;write()&lt;/code&gt; 方法，发现 LaoWang 类有，于是编译通过。在运行期间，new 了一个 XiaoWang 对象，并将其赋值给 wang，此时 Java 虚拟机知道 wang 引用的是 XiaoWang 对象，所以调用的是子类 XiaoWang 中的 &lt;code&gt;write()&lt;/code&gt; 方法而不是父类 LaoWang  中的 &lt;code&gt;write()&lt;/code&gt; 方法，因此输出结果为“小王写了一本《茶花女》”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而私有方法对子类是不可见的，它仅在当前声明的类中可见，private 关键字满足了封装的最高级别要求。另外，Java 中的私有方法是通过编译期的静态绑定的方式绑定的，不依赖于特定引用变量所持有的对象类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法重写适用于动态绑定，因此私有方法无法被重写。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LaoWang&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;LaoWang&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        write();&lt;br/&gt;        read();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;老王写了一本《基督山伯爵》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;老王在读《哈姆雷特》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;XiaoWang&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;LaoWang&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;小王写了一本《茶花女》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;小王在读《威尼斯商人》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PrivateOrrideTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        LaoWang wang = &lt;span&gt;new&lt;/span&gt; XiaoWang();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序输出结果如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;小王写了一本《茶花女》&lt;br/&gt;老王在读《哈姆雷特》&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在父类的构造方法中，分别调用了 &lt;code&gt;write()&lt;/code&gt; 和 &lt;code&gt;read()&lt;/code&gt; 方法，&lt;code&gt;write()&lt;/code&gt;方法是 public 的，可以被重写，因此执行了子类的 &lt;code&gt;write()&lt;/code&gt; 方法，&lt;code&gt;read()&lt;/code&gt; 方法是私有的，无法被重写，因此执行的仍然是父类的 &lt;code&gt;read()&lt;/code&gt; 方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和私有方法类似，静态方法在编译期也是通过静态绑定的方式绑定的，不依赖于特定引用变量所持有的对象类型。方法重写适用于动态绑定，因此静态方法无法被重写。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;StaticOrrideTest&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Laozi zi = &lt;span&gt;new&lt;/span&gt; Xiaozi();&lt;br/&gt;        zi.write();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Laozi&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;老子写了一本《基督山伯爵》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Xiaozi&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Laozi&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;小子写了一本《茶花女》&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序输出结果如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;老子写了一本《基督山伯爵》&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引用变量 zi 的类型为 Laozi，所以 &lt;code&gt;zi.write()&lt;/code&gt; 执行的是父类中的 &lt;code&gt;write()&lt;/code&gt; 方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;静态方法也叫类方法，直接通过类名就可以调用，通过对象调用的时候，IDE 会发出警告。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.21129032258064517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHplr7ZibLgLzL5cP90VDbAx0vjaQrDk8rK6mIlHibUKfIo2ahrauLT88w9ncxN74MfVEq6QWYmOdLyQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第四题，&lt;code&gt;1.0/0.0&lt;/code&gt; 得到的结果是什么？会抛出异常吗，还是会出现编译错误？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他没有深入研究过 double 类型和 int 类型的除法运算。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数字在 Java 中可以分为两种，一种是整形，一种是浮点型。不太清楚的小伙伴先去研究一下&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIxNzQwNjM3NA==&amp;amp;mid=2247489521&amp;amp;idx=2&amp;amp;sn=869f20ba8b26b523b5b0d7d10f3ef87a&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;数据类型&lt;/a&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当浮点数除以 0 的时候，结果为 Infinity 或者 NaN。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;System.out.println(1.0 / 0.0); // Infinity&lt;br/&gt;System.out.println(0.0 / 0.0); // NaN&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Infinity 的中文意思是无穷大，NaN 的中文意思是这不是一个数字（Not a Number）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当整数除以 0 的时候（&lt;code&gt;10 / 0&lt;/code&gt;），会抛出异常：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Exception &lt;span&gt;in&lt;/span&gt; thread &lt;span&gt;&quot;main&quot;&lt;/span&gt; java.lang.ArithmeticException: / by zero&lt;br/&gt; at com.itwanger.eleven.ArithmeticOperator.main(ArithmeticOperator.java:32)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常，我们在进行整数的除法运算时，需要先判断除数是否为 0，以免程序抛出异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第五题，Java 支持多重继承吗？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他知道，通过接口可以达到多重继承的目的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来定义两个接口，Fly 会飞，Run 会跑。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public interface Fly {&lt;br/&gt;    void fly();&lt;br/&gt;}&lt;br/&gt;public interface Run {&lt;br/&gt;    void run();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后让一个类同时实现这两个接口。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Pig&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Fly&lt;/span&gt;,&lt;span&gt;Run&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;fly&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;会飞的猪&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;会跑的猪&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但说到多重继承，讨论的关键字是 extends，而非 implements。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 只支持单一继承，是因为涉及到菱形问题。如果有两个类共同继承一个有特定方法的父类，那么该方法可能会被两个子类重写。然后，如果你决定同时继承这两个子类，那么在你调用该重写方法时，编译器不能识别你要调用哪个子类的方法。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7518939393939394&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHplr7ZibLgLzL5cP90VDbAx0vpLyyBPgeyaDBb4ic38y0Nt62WnH5lCqgojdcbfyUlg2wgToialPRnCibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1056&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类 C 同时继承了类 A 和类 B，类 C 的对象在调用类 A 和类 B 中重写的方法时，就不知道该调用类 A 的方法，还是类 B 的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第六题，当在 HashMap 中放入一个已经存在的 key 时，会发生什么？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他没有深入研究过 HashMap 的工作原理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Hash，一般译作“散列”，也有直接音译为“哈希”的，这玩意什么意思呢？就是把任意长度的数据通过一种算法映射到固定长度的域上（散列值）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再直观一点，就是对一串数据 wang 进行杂糅，输出另外一段固定长度的数据 er——作为数据 wang 的特征。我们通常用一串指纹来映射某一个人，别小瞧手指头那么大点的指纹，在你所处的范围内很难找出第二个和你相同的（人的散列算法也好厉害，有没有）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于任意两个不同的数据块，其散列值相同的可能性极小，也就是说，对于一个给定的数据块，找到和它散列值相同的数据块极为困难。再者，对于一个数据块，哪怕只改动它的一个比特位，其散列值的改动也会非常的大——这正是 Hash 存在的价值！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家应该知道，HashMap 的底层数据结构是一个数组，通过 &lt;code&gt;hash()&lt;/code&gt; 方法来确定下标。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;hash&lt;/span&gt;&lt;span&gt;(Object key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; h;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;) ? &lt;span&gt;0&lt;/span&gt; : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; &lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们放入一个键值对的时候，会先调用 &lt;code&gt;hash()&lt;/code&gt; 方法对 key 进行哈希算法，如果 key 是相同的，那么哈希后的结果也是相同的，意味着数组中的下标是相同的，新放入的值就会覆盖原来的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第七题，下面这段代码将会打印出什么？&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Test&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;char&lt;/span&gt;[] chars = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;char&lt;/span&gt;[]{&lt;span&gt;&#x27;\u0097&#x27;&lt;/span&gt;};&lt;br/&gt;        String str = &lt;span&gt;new&lt;/span&gt; String(chars);&lt;br/&gt;        &lt;span&gt;byte&lt;/span&gt;[] bytes = str.getBytes();&lt;br/&gt;        System.out.println(Arrays.toString(bytes));&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他没有深入研究过字符编码方面的一些知识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这段程序中，我们通过一个字符数组创建了一个字符串对象，然后调用 String 类的 &lt;code&gt;getByte()&lt;/code&gt; 方法得到字节数组并将其打印到控制台。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这道面试题考察的核心并不是最终的打印结果（结果是不确定的），而是字符编码。通常情况下，我们在调用 &lt;code&gt;getBytes()&lt;/code&gt; 方法时，要指定编码，比如说 &lt;code&gt;str.getBytes(StandardCharsets.UTF_8)&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们没有指定编码的时候，JDK 会调用平台默认的字符编码，而不同的操作系统，编码不尽相同的，bytes 的结果也就会不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当使用 UTF_8 时，结果为 &lt;code&gt;-62, -105&lt;/code&gt;，当使用 GB2312 时，结果为 &lt;code&gt;63&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第八题，当方法在父类中抛出 &lt;code&gt;NullPointerException&lt;/code&gt; 时，是否可以使用抛出 &lt;code&gt;RuntimeException&lt;/code&gt; 的方法来重写它？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他被重写（overriding）和重载（overloading）的概念搞混了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法重写和方法重载时，方法名可以完全相同，但根本的不同在于方法重写时发生在运行时，方法重载时发生在编译时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，方法重写和方法重载时的规则也不尽相同。在 Java 中，不能重写 private、static 和 final 方法，但可以重载它们。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来重点看一下方法重写时的规则：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）方法签名必须相同，包括返回类型、参数的数量、参数的类型和参数的顺序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）重写后的方法不能抛出比父类中更高级别的异常。举例来说，如果父类中的方法抛出的是 IOException，那么子类中重写的方法不能抛出 Exception，可以是 IOException 的子类或者不抛出任何异常。这条规则只适用于可检查的异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可检查（checked）异常必须在源代码中显式地进行捕获处理，不检查（unchecked）异常就是所谓的运行时异常，比如说 NullPointerException、ArrayIndexOutOfBoundsException 之类的，不会在编译器强制要求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3）重写后的方法访问权限不能比父类中的方法低，比如说父类中的方法是 public，重写后的方法就不能是 protected。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ExceptionDemo&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Super s = &lt;span&gt;new&lt;/span&gt; Child();&lt;br/&gt;        s.write();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Super&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; NullPointerException &lt;/span&gt;{ }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Child&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Super&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; RuntimeException &lt;/span&gt;{ }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RuntimeException 和 NullPointerException 属于不检查异常，所以本题的答案是可以的。如果是可检查异常的话，IDE 就会发出警告。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2725806451612903&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHplr7ZibLgLzL5cP90VDbAx0vqiaNGoCuwE2WOibPSf0f5aicWWzt3tgIFGWcRnEticCSPlGCEZlB9Vr9QQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第九题，下面这段代码使用了 &lt;code&gt;compareTo()&lt;/code&gt; 方法，有问题吗？&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Employee&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Comparable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;compareTo&lt;/span&gt;&lt;span&gt;(Object o)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Employee emp = (Employee) o;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.id - emp.id;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他想当然地认为 id 的都是正整数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们需要按照一定的规则进行排序的时候，通常要实现 Comparable 接口，并实现 compareTo 方法，规则如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）如果当前对象小于另外一个对象，则 compareTo 方法必须返回负数；如果当前对象大于另外一个对象，则必须返回正数；如果两个对象相等，则返回零。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）通常来说，compareTo 方法必须和 equals 方法一致，如果两个对象通过 equals 方法判断的结果为 true，那么 compareTo 必须返回零。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，JDK 中有一个反例，就是 BigDecimal。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BigDecimal bd1 = &lt;span&gt;new&lt;/span&gt; BigDecimal(&lt;span&gt;&quot;2.0&quot;&lt;/span&gt;);&lt;br/&gt;BigDecimal bd2 = &lt;span&gt;new&lt;/span&gt; BigDecimal(&lt;span&gt;&quot;2.00&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;System.out.println(&lt;span&gt;&quot;equals: &quot;&lt;/span&gt; + bd1.equals(bd2));&lt;br/&gt;System.out.println(&lt;span&gt;&quot;compareTo: &quot;&lt;/span&gt; + bd1.compareTo(bd2));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出结果如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;equals: &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;compareTo: 0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是因为 JDK 认为 2.0 和 2.00 的精度不一样，所以不能 equals，但值确实是相等的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3）不能使用减法来比较整数值，因为减法的结果可能溢出。应该使用 &lt;code&gt;Integer.compareTo()&lt;/code&gt; 来进行比较。如果你想通过减法操作来提高性能，必须得确保两个操作数是正整数，或者确保两者相差的值小于 Integer.MAX_VALUE。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CompareDemo&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;Employee&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;        list.add(&lt;span&gt;new&lt;/span&gt; Employee(&lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;        list.add(&lt;span&gt;new&lt;/span&gt; Employee(Integer.MIN_VALUE));&lt;br/&gt;        list.add(&lt;span&gt;new&lt;/span&gt; Employee(Integer.MAX_VALUE));&lt;br/&gt;        Collections.sort(list);&lt;br/&gt;        System.out.println(list);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Employee&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Comparable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Employee&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; id)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.id = id;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;compareTo&lt;/span&gt;&lt;span&gt;(Object o)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Employee emp = (Employee) o;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.id - emp.id;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Employee{&quot;&lt;/span&gt; +&lt;br/&gt;                &lt;span&gt;&quot;id=&quot;&lt;/span&gt; + id +&lt;br/&gt;                &lt;span&gt;&#x27;}&#x27;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序的输出结果如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[Employee{id=1}, Employee{id=2147483647}, Employee{id=-2147483648}]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;排序就乱了。因为 &lt;code&gt;Integer.MIN_VALUE - 1&lt;/code&gt; 变成了正数 &lt;code&gt;2147483647&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第十题，StringBuffer 和 StringBuilder 之间有什么区别？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小王之所以没答对这道题，是因为他觉得这道题太简单了，结果说反了，大意了啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;StringBuilder 是 JDK 1.5 之后引入的，它和 StringBuffer 最大的区别就在于它的一系列方法都是非同步的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5018867924528302&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHplr7ZibLgLzL5cP90VDbAx0vZ4VQSwpWC08xoJfx4ibOH2Ap3e7Fbgicu7DtxX7jGWY2Aq7yGASwUBrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1060&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，以上就是小王这次面试遇到的 10 道虐心的面试题，本来最后一道是送分题，结果大意说反了，让小王更加懊恼。年后是跳槽的高峰期，有打算的小伙伴要提前准备了，希望大家都能够顺利面上心仪的岗位。&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b551ea860d67c5d1b98d7c1f4db03af9</guid>
<title>[译] Android Studio 和 Gradle 插件使用全新版本编号</title>
<link>https://toutiao.io/k/84ipocl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;&lt;i&gt;作者 / Jamal Eason, Product Manager&lt;/i&gt;&lt;/p&gt;&lt;figure data-size=&quot;small&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-70165c6a8b7338448184d56f51413e0a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;1251&quot; data-rawheight=&quot;1405&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-70165c6a8b7338448184d56f51413e0a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;small&quot; data-rawwidth=&quot;1251&quot; data-rawheight=&quot;1405&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-70165c6a8b7338448184d56f51413e0a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-70165c6a8b7338448184d56f51413e0a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;第一版 Android Studio Arctic Fox (2020.3.1) 以及 Android Gradle 插件 (AGP) 的 7.0.0-alpha01 版双双在 Canary 通道已正式发布。在此版本中，我们调整了 Android Studio 和 Gradle 插件的版本编号方案。此项变更将 Gradle 插件从 Android Studio 的版本编号方案中剥离，并使 Android Studio 的每个版本对应于哪个年份和 IntelliJ 版本变得更加清晰。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Android Studio 的新版本编号方案&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;从 Arctic Fox (2020.3.1) 开始，Android Studio 的版本号系统将以年份为基础，从而更加符合 IntelliJ IDEA 的版本模式——Android Studio 正是基于这个 IDE 构建的。新的版本编号方案会引入几项重要属性: 年份、所基于的 IntelliJ 版本以及功能和补丁程序级别。这种命名模式的变更使您能够快速确定您在 Android Studio 中使用的 IntelliJ 平台版本。此外，每个主要版本都将具有标准代号，从 Arctic Fox 开始，之后会按字母顺序依次命名，以帮助用户轻松辨别新老版本。&lt;/p&gt;&lt;p&gt;我们建议您使用最新版本的 Android Studio，以体验最新功能和质量改进。为便于更新，我们对版本进行了更改，将 Android Studio 与 Android Gradle 插件版本进行了明确的分离。需要记住的一个重要细节是，更新 IDE 时，构建系统执行编译和打包应用的方式不受影响。相反，应用构建流程变更和 APK/Bundle 则会受到您的项目 AGP 版本影响。因此，即使在开发周期的后期，您也可以安全地更新 Android Studio 版本，因为您的项目 AGP 版本与 Android Studio 版本可以采用不同的节奏进行更新。最后，在新的版本系统中，只要您的 AGP 版本保持在稳定版，您或您的团队就可以在应用项目中更加方便地 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/studio/preview/install-preview&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;同时运行&lt;/a&gt;&lt;/b&gt; 稳定版和预览版 Android Studio。&lt;/p&gt;&lt;p&gt;如果沿用以前的编号系统，则此版本将为 Android Studio 4.3。现在，新版编号系统将其命名为 Android Studio Arctic Fox (2020.3.1) Canary 1，或简称为 Arctic Fox。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-385532c1b6d358d5eacc571e8a36a038_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1400&quot; data-rawheight=&quot;184&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-385532c1b6d358d5eacc571e8a36a038_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1400&quot; data-rawheight=&quot;184&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-385532c1b6d358d5eacc571e8a36a038_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-385532c1b6d358d5eacc571e8a36a038_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;未来，Android Studio 版本号方案将采用以下模式:&lt;/p&gt;&lt;p&gt;&lt;b&gt;&amp;lt;IntelliJ 版本年份&amp;gt;.&amp;lt;IntelliJ 主版本&amp;gt;.&amp;lt;Studio 主版本&amp;gt;&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;前两组数字代表特定 Android Studio 版本所基于的 IntelIiJ 平台版本 (早期 Canary 版本依然可能是早期版本)。对于已发布的新版本，这两组数字为 2020.3；&lt;/li&gt;&lt;li&gt;第三组数字代表 Studio 主版本，从 1 开始，每个主版本递增 1；&lt;/li&gt;&lt;li&gt;为便于引用每个版本，我们还为主版本提供了一个代号，根据动物名称从 A 到 Z 递增。新发布的初始版名为 Arctic Fox。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;Android Gradle 插件的新版本编号方案&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在 AGP 7.0.0 中，我们采用了 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//semver.org/&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;语义化版本&lt;/a&gt;&lt;/b&gt; 的原则，并与 AGP 所需的 Gradle 版本保持一致。Android Studio 和 Android Gradle 插件之间的兼容性不会更改。您可以使用更新版本的 Android Studio 打开使用稳定版 AGP 的项目。&lt;/p&gt;&lt;p&gt;我们近期发表的 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//android-developers.googleblog.com/2020/12/announcing-android-gradle-plugin.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;另一篇博文&lt;/a&gt;&lt;/b&gt; 详细介绍了 AGP 版本编号原则以及 AGP 7.0 这一全新主版本中的最新变化。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;Android Studio Arctic Fox 中的最新变化&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;我们尚处于 Arctic Fox 功能开发的初期阶段，但是我们已经在这个 IDE 中投入了大量的时间实施改进，包括代码编辑器、应用检查工具、布局编辑器到嵌入式模拟器等众多方面，共计 200 多处质量改进和错误修复。请参阅 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/studio/releases&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;版本说明&lt;/a&gt;&lt;/b&gt; 了解错误修复的详细信息。&lt;/p&gt;&lt;p&gt;对于那些尝试使用 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/jetpack/compose&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Jetpack Compose&lt;/a&gt;&lt;/b&gt; 的用户，我们提供了大量更新内容，例如将 @Preview Composable 部署到设备/模拟器:&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-df1dd456172c200580892f9b0c81dcc5_b.gif&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1600&quot; data-rawheight=&quot;1054&quot; data-thumbnail=&quot;https://pic2.zhimg.com/v2-df1dd456172c200580892f9b0c81dcc5_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-df1dd456172c200580892f9b0c81dcc5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1600&quot; data-rawheight=&quot;1054&quot; data-thumbnail=&quot;https://pic2.zhimg.com/v2-df1dd456172c200580892f9b0c81dcc5_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-df1dd456172c200580892f9b0c81dcc5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-df1dd456172c200580892f9b0c81dcc5_b.gif&quot;/&gt;&lt;figcaption&gt;△ 部署 Preview Composable&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;另外，请尝试使用 Arctic Fox 中新的布局验证工具 (Layout Validation Tool)，查看您的布局在各种屏幕尺寸、字体大小和 Android 色彩校正/色盲模式下的响应效果。您可以在使用布局编辑器时通过 &lt;b&gt;Layout Validation&lt;/b&gt; 工具窗口体验这个功能。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-eaf5a6894cd4ab8d867f1cd3d5aa9159_b.gif&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1600&quot; data-rawheight=&quot;1010&quot; data-thumbnail=&quot;https://pic2.zhimg.com/v2-eaf5a6894cd4ab8d867f1cd3d5aa9159_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-eaf5a6894cd4ab8d867f1cd3d5aa9159_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1600&quot; data-rawheight=&quot;1010&quot; data-thumbnail=&quot;https://pic2.zhimg.com/v2-eaf5a6894cd4ab8d867f1cd3d5aa9159_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-eaf5a6894cd4ab8d867f1cd3d5aa9159_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-eaf5a6894cd4ab8d867f1cd3d5aa9159_b.gif&quot;/&gt;&lt;figcaption&gt;△ Layout Validation&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;最后，对于在 MacOS (即将支持其他平台) 下运行最新版 Android Platform 工具以及使用 Android 11 设备的用户，您可以前往 &lt;b&gt;Run&lt;/b&gt; (运行) 按钮的设备选择对话框 → &lt;b&gt;Pair Devices Using Wi-Fi&lt;/b&gt; 来尝试 IDE 中集成的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/studio/command-line/adb%23wireless-adb-android-11&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;ADB 无线调试功能&lt;/a&gt;。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-def5bc131ee83d9a9743eebc4bcbd643_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;808&quot; data-rawheight=&quot;420&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-def5bc131ee83d9a9743eebc4bcbd643_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;808&quot; data-rawheight=&quot;420&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-def5bc131ee83d9a9743eebc4bcbd643_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-def5bc131ee83d9a9743eebc4bcbd643_b.jpg&quot;/&gt;&lt;figcaption&gt;△ 通过菜单使用 ADB 无线调试功能&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f26746e91678a359cb2b4096a0a20d5d_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;473&quot; data-rawheight=&quot;512&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-f26746e91678a359cb2b4096a0a20d5d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;473&quot; data-rawheight=&quot;512&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-f26746e91678a359cb2b4096a0a20d5d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-f26746e91678a359cb2b4096a0a20d5d_b.jpg&quot;/&gt;&lt;figcaption&gt;△ ADB 无线调试设置窗口&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;未来计划&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;如果您想详细了解关于此版本 Android Studio 和 Android Gradle 插件的其他变更，请务必查看 &lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.android.google.cn/studio/releases&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;版本说明&lt;/a&gt;&lt;/b&gt;。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>32cc808c036d69a7dcd1940bfadeabac</guid>
<title>记一起由 Clang 编译器优化触发的 Crash</title>
<link>https://toutiao.io/k/2as0flo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section class=&quot;blog-content&quot;&gt;&lt;h1&gt;记一起由 Clang 编译器优化触发的 Crash&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/troubleshooting-crash-clang-compiler-optimization.png&quot; alt=&quot;troubleshooting-crash-clang-compiler-optimization&quot;/&gt;&lt;/p&gt;&lt;p&gt;如果有人告诉你，下面的 C++ 函数会导致程序 crash，你会想到哪些原因呢？&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;std&lt;span&gt;::&lt;/span&gt;string b2s(&lt;span&gt;bool&lt;/span&gt; b) {
    &lt;span&gt;return&lt;/span&gt; b &lt;span&gt;?&lt;/span&gt; &lt;span&gt;&quot;true&quot;&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;false&quot;&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果再多给一些描述，比如：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Crash 以一定的概率复现&lt;/li&gt;&lt;li&gt;Crash 原因是段错误（SIGSEGV）&lt;/li&gt;&lt;li&gt;现场的 Backtrace 经常是不完整甚至完全丢失的。&lt;/li&gt;&lt;li&gt;只有优化级别在 -O2 以上才会（更容易）复现&lt;/li&gt;&lt;li&gt;仅在 Clang 下复现，GCC 复现不了&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;好了，一些老鸟可能已经有线索了，下面给出一个最小化的复现程序和步骤：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span&gt;// file crash.cpp
&lt;/span&gt;&lt;span/&gt;&lt;span&gt;#include&lt;/span&gt; &lt;span&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span&gt;#include&lt;/span&gt; &lt;span&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span&gt;
&lt;/span&gt;&lt;span/&gt;
std&lt;span&gt;::&lt;/span&gt;string __attribute__((noinline)) b2s(&lt;span&gt;bool&lt;/span&gt; b) {
    &lt;span&gt;return&lt;/span&gt; b &lt;span&gt;?&lt;/span&gt; &lt;span&gt;&quot;true&quot;&lt;/span&gt; &lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;false&quot;&lt;/span&gt;;
}

&lt;span&gt;union&lt;/span&gt; {
    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; c;
    &lt;span&gt;bool&lt;/span&gt; b;
} &lt;span&gt;volatile&lt;/span&gt; u;

&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;() {
    u.c &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0x80&lt;/span&gt;;
    std&lt;span&gt;::&lt;/span&gt;cout &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; b2s(u.b) &lt;span&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span&gt;::&lt;/span&gt;endl;
    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;pre&gt;&lt;code&gt;$ clang++ -O2 crash.cpp
$ ./a.out
truefalse,d$x4DdzRx

Segmentation fault (core dumped)

$ gdb ./a.out core.3699
Core was generated by `./a.out&#x27;.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x0000012cfffff0d4 in ?? ()
(gdb) bt
#0  0x0000012cfffff0d4 in ?? ()
#1  0x00000064fffff0f4 in ?? ()
#2  0x00000078fffff124 in ?? ()
#3  0x000000b4fffff1e4 in ?? ()
#4  0x000000fcfffff234 in ?? ()
#5  0x00000144fffff2f4 in ?? ()
#6  0x0000018cfffff364 in ?? ()
#7  0x0000000000000014 in ?? ()
#8  0x0110780100527a01 in ?? ()
#9  0x0000019008070c1b in ?? ()
#10 0x0000001c00000010 in ?? ()
#11 0x0000002ffffff088 in ?? ()
#12 0xe2ab001010074400 in ?? ()
#13 0x0000000000000000 in ?? ()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;因为 backtrace 信息不完整，说明程序并不是在第一时间 crash 的。面对这种情况，为了快速找出第一现场，我们可以试试 AddressSanitizer（ASan）：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ clang++ -g -O2 -fno-omit-frame-pointer -fsanitize=address crash.cpp
$ ./a.out
=================================================================
==3699==ERROR: AddressSanitizer: global-buffer-overflow on address 0x000000552805 at pc 0x0000004ff83a bp 0x7ffd7610d240 sp 0x7ffd7610c9f0
READ of size 133 at 0x000000552805 thread T0
    #0 0x4ff839 in __asan_memcpy (a.out+0x4ff839)
    #1 0x5390a7 in b2s[abi:cxx11](bool) crash.cpp:6
    #2 0x5391be in main crash.cpp:16:18
    #3 0x7faed604df42 in __libc_start_main (/usr/lib64/libc.so.6+0x23f42)
    #4 0x41c43d in _start (a.out+0x41c43d)

0x000000552805 is located 59 bytes to the left of global variable &#x27;&amp;lt;string literal&amp;gt;&#x27; defined in &#x27;crash.cpp:6:25&#x27; (0x552840) of size 6
  &#x27;&amp;lt;string literal&amp;gt;&#x27; is ascii string &#x27;false&#x27;
0x000000552805 is located 0 bytes to the right of global variable &#x27;&amp;lt;string literal&amp;gt;&#x27; defined in &#x27;crash.cpp:6:16&#x27; (0x552800) of size 5
  &#x27;&amp;lt;string literal&amp;gt;&#x27; is ascii string &#x27;true&#x27;
SUMMARY: AddressSanitizer: global-buffer-overflow (/home/dutor.hou/Wdir/nebula-graph/build/bug/a.out+0x4ff839) in __asan_memcpy
Shadow bytes around the buggy address:
…
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从 ASan 给出的信息，我们可以定位到是函数 &lt;code&gt;b2s(bool)&lt;/code&gt; 在读取字符串常量 &lt;code&gt;&quot;true&quot;&lt;/code&gt; 的时候，发生了“全局缓冲区溢出”。好了，我们再次以上帝视角审视一下问题函数和复现程序，“似乎”可以得出结论：因为 &lt;code&gt;b2s&lt;/code&gt; 的布尔类型参数 &lt;code&gt;b&lt;/code&gt; 没有初始化，所以 &lt;code&gt;b&lt;/code&gt; 中存储的是一个 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 之外的值[1]。那么问题来了，为什么 &lt;code&gt;b&lt;/code&gt; 的这种取值会导致“缓冲区溢出”呢？感兴趣的可以将 &lt;code&gt;b&lt;/code&gt; 的类型由 &lt;code&gt;bool&lt;/code&gt; 改成 &lt;code&gt;char&lt;/code&gt; 或者 &lt;code&gt;int&lt;/code&gt;，问题就可以得到修复。&lt;/p&gt;&lt;p&gt;想要解答这个问题，我们不得不看下 clang++ 为 &lt;code&gt;b2s&lt;/code&gt; 生成了怎样的指令（之前我们提到 GCC 下没有出现 crash，所以问题可能和代码生成有关）。在此之前，我们应该了解：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;样例程序中，&lt;code&gt;b2s&lt;/code&gt; 的返回值是一个临时的 &lt;code&gt;std::string&lt;/code&gt; 对象，是保存在栈上的&lt;/li&gt;&lt;li&gt;C++ 11 之后，GCC 的 &lt;code&gt;std::string&lt;/code&gt; 默认实现使用了 SBO（Small Buffer Optimization），其定义大致为 &lt;code&gt;std::string{ char *ptr; size_t size; union{ char buf[16]; size_t capacity}; }&lt;/code&gt;。对于长度小于 &lt;code&gt;16&lt;/code&gt; 的字符串，不需要额外申请内存。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;OK，那我们现在来看一下 &lt;code&gt;b2s&lt;/code&gt; 的反汇编并给出关键注解：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;(gdb) disas b2s
Dump of assembler code for function b2s[abi:cxx11](bool):
   0x00401200 &amp;lt;+0&amp;gt;:     push   %r14
   0x00401202 &amp;lt;+2&amp;gt;:     push   %rbx
   0x00401203 &amp;lt;+3&amp;gt;:     push   %rax
   0x00401204 &amp;lt;+4&amp;gt;:     mov    %rdi,%r14         # 将返回值(string)的起始地址保存到 r14
   0x00401207 &amp;lt;+7&amp;gt;:     mov    $0x402010,%ecx    # 将 &quot;true&quot; 的起始地址保存至 ecx
   0x0040120c &amp;lt;+12&amp;gt;:    mov    $0x402015,%eax    # 将 &quot;false&quot; 的起始地址保存至 eax
   0x00401211 &amp;lt;+17&amp;gt;:    test   %esi,%esi         # “测试” 参数 b 是否非零
   0x00401213 &amp;lt;+19&amp;gt;:    cmovne %rcx,%rax         # 如果 b 非零，则将 &quot;true&quot; 地址保存至 rax
   0x00401217 &amp;lt;+23&amp;gt;:    lea    0x10(%rdi),%rdi   # 将 string 中的 buf 起始地址保存至 rdi
                                                 # （同时也是后面 memcpy 的第一个参数）
   0x0040121b &amp;lt;+27&amp;gt;:    mov    %rdi,(%r14)       # 将 rdi 保存至 string 的 ptr 字段，即 SBO
   0x0040121e &amp;lt;+30&amp;gt;:    mov    %esi,%ebx         # 将 b 的值保存至 ebx
   0x00401220 &amp;lt;+32&amp;gt;:    xor    $0x5,%rbx         # 将 0x5 异或到 rbx（也即 ebx）
                                                 # 注意，如果 rbx 非 0 即 1，那么 rbx 保存的就是 4 或 5，
                                                 # 即 &quot;true&quot; 或 &quot;false&quot; 的长度 
   0x00401224 &amp;lt;+36&amp;gt;:    mov    %rax,%rsi         # 将字符串起始地址保存至 rsi，即 memcpy 的第二个参数
   0x00401227 &amp;lt;+39&amp;gt;:    mov    %rbx,%rdx         # 将字符串的长度保存至 rdx，即 memcpy 的第三个参数
   0x0040122a &amp;lt;+42&amp;gt;:    callq  &amp;lt;memcpy@plt&amp;gt;      # 调用 memcpy
   0x0040122f &amp;lt;+47&amp;gt;:    mov    %rbx,0x8(%r14)    # 将字符串长度保存到 string::size
   0x00401233 &amp;lt;+51&amp;gt;:    movb   $0x0,0x10(%r14,%rbx,1)  # 将 string 以 &#x27;\0&#x27; 结尾
   0x00401239 &amp;lt;+57&amp;gt;:    mov    %r14,%rax         # 将 string 地址保存至 rax，即返回值
   0x0040123c &amp;lt;+60&amp;gt;:    add    $0x8,%rsp
   0x00401240 &amp;lt;+64&amp;gt;:    pop    %rbx
   0x00401241 &amp;lt;+65&amp;gt;:    pop    %r14
   0x00401243 &amp;lt;+67&amp;gt;:    retq
End of assembler dump.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;到这里，问题就无比清晰了：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;clang++ 假设了 &lt;code&gt;bool&lt;/code&gt; 类型的值非 &lt;code&gt;0&lt;/code&gt; 即 &lt;code&gt;1&lt;/code&gt;&lt;/li&gt;&lt;li&gt;在编译期，&lt;code&gt;”true”&lt;/code&gt; 和 &lt;code&gt;”false”&lt;/code&gt; 长度已知&lt;/li&gt;&lt;li&gt;使用异或指令（ &lt;code&gt;0x5 ^ false == 5&lt;/code&gt;, &lt;code&gt;0x5 ^ true == 4&lt;/code&gt;）计算要拷贝的字符串的长度&lt;/li&gt;&lt;li&gt;当 &lt;code&gt;bool&lt;/code&gt; 类型不符合假设时，长度计算错误&lt;/li&gt;&lt;li&gt;因为 &lt;code&gt;memcpy&lt;/code&gt; 目标地址在栈上（仅对本例而言），因此栈上的缓冲区也可能溢出，从而导致程序跑飞，backtrace 缺失。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;注：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;C++ 标准要求 &lt;code&gt;bool&lt;/code&gt; 类型至少_能够_表示两个状态： &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt; ，但并没有规定 &lt;code&gt;sizeof(bool)&lt;/code&gt; 的大小。但在几乎所有的编译器实现上， &lt;code&gt;bool&lt;/code&gt; 都占用一个寻址单位，即字节。因此，从存储角度，取值范围为 &lt;code&gt;0x00-0xFF&lt;/code&gt;，即 &lt;code&gt;256&lt;/code&gt; 个状态。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;喜欢这篇文章？来来来，给我们的 &lt;a href=&quot;https://github.com/vesoft-inc/nebula&quot;&gt;GitHub&lt;/a&gt; 点个 star 表鼓励啦~~ 🙇‍♂️🙇‍♀️ [手动跪谢]&lt;/p&gt;&lt;p&gt;交流图数据库技术？交个朋友，Nebula Graph 官方小助手微信：&lt;a href=&quot;https://www-cdn.nebula-graph.com.cn/nebula-blog/nbot.png&quot;&gt;NebulaGraphbot&lt;/a&gt; 拉你进交流群~~&lt;/p&gt;&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;&lt;blockquote class=&quot;star-ads&quot;&gt;&lt;span&gt;你喜欢这篇文章吗? 喜欢的话，给我们点个&lt;/span&gt;
&lt;span&gt;star 吧:&lt;/span&gt;
&lt;a href=&quot;https://github.com/vesoft-inc/nebula&quot;&gt;https://github.com/vesoft-inc/nebula&lt;/a&gt;&lt;/blockquote&gt;&lt;p id=&quot;discourse-comments&quot;/&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0e0dd808728704db999b3a64292ec014</guid>
<title>好的重构方法才能摆脱 “屎山”</title>
<link>https://toutiao.io/k/rr23n1t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;strong&gt;&lt;span&gt;这里是Z哥的个人公众号&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;每周五11：45 按时送达&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;当然了，也会时不时加个餐～&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;我的第「171」篇原创敬上&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;大家好，我是Z哥。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最近在整理一些项目，所以相关的文章写的多了些。之前的相关文章有《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NzEwMDc4OQ==&amp;amp;mid=2247485351&amp;amp;idx=1&amp;amp;sn=63580ffa1d350032afab8aae7544adb8&amp;amp;chksm=fca313bdcbd49aab984df27355ef518c0ab6100bc96580a26fa1969042ad71093b6ba4282062&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;聊聊单元测试&lt;/a&gt;》，感兴趣的话可以点击文末链接去阅读。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这次整理项目的时候，做了比较多的codereview和重构。好久没做这么高强度了重构了，所以对重构这件事有了新的思考和理解。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;突然发现叫我们程序员“码农”还挺形象的，因为写代码和种田很像，想有个好收成，就要好好管理代码，让它们井井有条。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;吴军老师在《文明之光》里讲到一个「垄耕种植法」，它由中国人发明，后发扬到全球，影响了全世界的粮食生产。据说欧洲人民以前是把种子随意地撒在地里，任其自由生长，结果收成很低，如果种下20斤，大概只能收获60斤左右粮食。而中国早在先秦时期亩产最少都在240斤以上，最新的数据是今年11月初袁隆平的杂交水稻，早晚稻加起来达到3000斤，这都得益于「垄耕种植法」。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，当你看到那些被随意“播种”的糟糕代码，是改，还是不改？改吧，花时间；不改吧，就像上面的欧洲人民。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其实很多人对「重构」的理解还有些误区。「重构」仅仅是所谓的优化代码吗？并不是。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Martin Fowler大神在他的《重构》一书中对「重构」的定义就非常准确。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;95&quot; data-source-title=&quot;《重构》Martin Fowler&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;blockquote_info js_blockquote_source&quot; data-json=&quot;%7B%22type%22%3A%22out%22%2C%22source%22%3A%22url%22%2C%22digest%22%3A%22%22%2C%22digestLen%22%3A95%2C%22text%22%3A%22%E9%87%8D%E6%9E%84%EF%BC%88%E5%90%8D%E8%AF%8D%EF%BC%89%EF%BC%9A%E5%AF%B9%E8%BD%AF%E4%BB%B6%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%80%E7%A7%8D%E8%B0%83%E6%95%B4%EF%BC%8C%E7%9B%AE%E7%9A%84%E6%98%AF%E5%9C%A8%E4%B8%8D%E6%94%B9%E5%8F%98%E8%BD%AF%E4%BB%B6%E5%8F%AF%E8%A7%82%E5%AF%9F%E8%A1%8C%E4%B8%BA%E7%9A%84%E5%89%8D%E6%8F%90%E4%B8%8B%EF%BC%8C%E6%8F%90%E9%AB%98%E5%85%B6%E5%8F%AF%E7%90%86%E8%A7%A3%E6%80%A7%EF%BC%8C%E9%99%8D%E4%BD%8E%E5%85%B6%E4%BF%AE%E6%94%B9%E6%88%90%E6%9C%AC%E3%80%82%C2%A0%E9%87%8D%E6%9E%84%EF%BC%88%E5%8A%A8%E8%AF%8D%EF%BC%89%EF%BC%9A%E4%BD%BF%E7%94%A8%E4%B8%80%E7%B3%BB%E5%88%97%E9%87%8D%E6%9E%84%E6%89%8B%E6%B3%95%EF%BC%8C%E5%9C%A8%E4%B8%8D%E6%94%B9%E5%8F%98%E8%BD%AF%E4%BB%B6%E5%8F%AF%E8%A7%82%E5%AF%9F%E8%A1%8C%E4%B8%BA%E7%9A%84%E5%89%8D%E6%8F%90%E4%B8%8B%EF%BC%8C%E8%B0%83%E6%95%B4%E5%85%B6%E7%BB%93%E6%9E%84%E3%80%82%22%2C%22article%22%3A%7B%7D%2C%22hasReportOverSize%22%3Afalse%2C%22editorReportData%22%3A%5B%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2276%22%2C%22len%22%3A1%7D%5D%2C%22from%22%3A%22%E3%80%8A%E9%87%8D%E6%9E%84%E3%80%8BMartin%20Fowler%22%7D&quot;&gt;&lt;span class=&quot;blockquote_other&quot;&gt;《重构》Martin Fowler&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，重构不仅仅是修改代码，是对软件结构的调整，修改代码只是其中的一个手段而已。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么具体应该怎么做呢？在这之前，需要考虑清楚以下几个问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;/01  什么时候重构？/&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;很多理想主义者认为的理想情况自然是随时发现坏代码就重构。但是这里存在两个问题：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以我们需要几个更加客观的外部标准，Z哥建议你可以从以下三个方面来观察，如果发现了类似的现象，说明它在给你发出需要重构的信号。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/02  怎么重构？/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了保证重构的质量，在你重构的过程中，一定要关注以下4个关键点：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可以回想一下，你之前做过的重构是否都符合了以上的这些要求？反正Z哥最近做的重构是不符合的，所以感觉很累很痛苦～&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具体的重构工作其实说起来很简单，因为一段代码无非就是「输入参数」、「输出参数」、「方法体」3个东西，重构也自然以这几个地方展开。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/01  输入参数/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于输入参数的重构，主要关注在参数的个数上。那些优秀的开源项目里，你几乎看不到参数很多的方法。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因为过多的参数个数，不但不容易理解，而且你在写调用这个方法的代码的时候也会很头疼，时不时要数一下这是第几个参数，对应的参数说明是什么。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有一些工具推荐的默认参数最大长度是7个（如SonarQube）。如果你没有更好的定义和理解，那么不妨以“7”这个标准来执行。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/02  输出参数/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;输出参数只有一个，能够出乱子的空间也很小，所以一般来说不需要怎么优化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;唯一值得提醒的两点是：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;参数类型尽量用强类型。弱类型的返回值虽然让你的Function向后兼容性很好，但是也带来了很多无法在编译期间被发现的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不返回不需要的参数。添加更多参数在最初肯定是为了“跑在业务前面”，但这份好心往往最终带来的是更多“意料之外的耦合”，导致后续的重构成本大增。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/03  方法体/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于方法体的重构是花费时间最多的地方，具体的方式方法也很多。但是我建议你一定要坚持一个核心要点，我将它称为「NRD重构法」，这3个字母分别表示：New、Replace、Delete。也就是说，做重构的时候不要直接在原来的方法体里改，重新建一个新的方法，然后等单测跑通之后再替换掉老方法，最后再把老方法删除。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;只要做到这点，要满足前面提到的4个关键点，就没那么困难了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具体的重构内容自然是以减少复杂度为核心思路去做。衡量代码复杂度有一个概念叫「圈复杂度」（也叫「循环复杂度」），在1976年由Thomas J. McCabe, Sr. 提出。现在有不少工具有统计这个指标。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;复杂度大说明程序代码可能质量低且难于测试和维护，根据经验，程序的可能错误和高的圈复杂度有着很大关系。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;复杂度大的代码往往伴随着大量的if/switch/for/foreach/try...catch/while等等。每一次试用都会让「圈复杂度」+1，并且其中的条件判断越多，增加的越快。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，常见的重构方式大多以降低代码的圈复杂度为主。比如，&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;还有很多小众的重构技巧这里就不赘述了，真是觉得大家都应该读一读《重构》这本书。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;多说一句，不提倡刻意降低代码行数的方法，因为你的复杂度不下降，减少代码行数只是“掩耳盗铃”而已。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外，重构有一个最佳伴侣，就是单元测试。你想象一个画面，当你重构之前通过率100%的单元测试在重构完成后跑一遍，发现了10%的失败。此时你的心情肯定是“真香，否则一堆bug等着我修”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不过，如果你的代码「圈复杂度」越高，单元测试写起来越费劲。如何写好单元测试可以看我之前写的文章《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NzEwMDc4OQ==&amp;amp;mid=2247485351&amp;amp;idx=1&amp;amp;sn=63580ffa1d350032afab8aae7544adb8&amp;amp;chksm=fca313bdcbd49aab984df27355ef518c0ab6100bc96580a26fa1969042ad71093b6ba4282062&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;聊聊单元测试&lt;/a&gt;》。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后，怎么判断重构的效果好不好呢？自然是工作效率是否提高了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;增加一个功能或者接口的时间是不是缩短了？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;测试那边回归测试的平均时间是不是缩短了？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;……&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;好了，就这么多。如果你还是觉得无从下手，不妨试试《重构》作者推荐的一种做法:&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;随机挑选一个目标，比如，“去掉一堆不必要的子类”。然后朝着目标前进，没把握就停下来。当你无法证明自己所做的修改能够保证原有程序的逻辑和语义时，立马停下来思考：当前做的重构是改善了？还是毫无成果需要撤销？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后再次强力推荐《重构》这本书，里面有很多非常具体的代码重构方法，值得每一位程序员入手一本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;mpcps frameborder=&quot;0&quot; class=&quot;js_editor_cps&quot; data-datakey=&quot;1604914048250_0.953375247605875&quot; data-uid=&quot;1604914048249&quot; data-type=&quot;1&quot; data-product=&quot;&quot; data-templateid=&quot;list&quot; data-pid=&quot;12584498&quot; data-categoryid=&quot;3&quot; data-appuin=&quot;3208869061&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;好了，总结一下。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这篇呢，Z哥和你分享了我对代码重构这件事的看法。要想提高你代码的“产出”，那么就得好好重视重构这件事。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在重构代码的「输入参数」、「输出参数」、「方法体」的时候需要持续保持以下4个关键点：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这才能使得你的重构工作平稳的进行，而不会是一场赌博。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;并且，重构方法体的时候要以降低「圈复杂度」为目的，而不是代码行数。如果条件允许，尽量多写一些单元测试来保障重构的稳定性。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;希望对你有所启发。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;重构可以使软件更容易地被修改和被理解，这个意义甚至大于所谓的“优化和改进”。Kent Beck大神曾也经说过：首先让代码架构易于改变，然后再进行简单的改进。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你想摆脱代码越改越痛苦的困境，那么赶紧行动起来吧。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原创不易，如果你觉得这篇文章还不错，就「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」或者「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;分享&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」一下吧。鼓励我的创作 ：）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.4428822495606327&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/oB5bd6W6hI1Xrkr3iaFRP5fErfmjHqlBw160icnia8yicWBlicnPEfqGE80alzGl9FLj6FxyuibIuliceoH9zicibj95loQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1138&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你有关于软件架构、分布式系统、产品、运营的困惑&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以试试点击「&lt;strong&gt;阅读原文&lt;/strong&gt;」&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fb1bea933d337473ad3af416de6a2cee</guid>
<title>云游戏在革谁的命？</title>
<link>https://toutiao.io/k/160lo6y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.628125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHgfBRWw69LibJob3BMOPo2gfqJHVH4LzohaX3rr6l6zxpMMMq9ouzPaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;我上大学时的第一台电脑是微星的一款游戏本，当时买它的原因很简单，性能足够强大，无论是编程等日常任务还是游戏它都可以胜任。现在回想起来，依稀记得它炫酷的灯光、强悍的性能以及用它驰骋虚拟世界的快感。后来年纪渐长，打游戏的热情逐渐减少，虽然那台电脑仍在家中，但已经落后的性能让我鲜有机会“宠幸”它。再后来，读研之后换了 Mac 后更是没怎么碰过游戏了。&lt;/p&gt;&lt;p&gt;大家都说正经人谁用 Mac 打游戏，一开始我也是这么认为的，毕竟买来就是用来写代码的，可是最近发现的一个有趣玩意让我对这个问题有了新的想法，那就是——云游戏。&lt;/p&gt;&lt;h2&gt;云计算？云？&lt;/h2&gt;&lt;p&gt;以下内容摘自百度百科&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;云游戏是以&lt;strong&gt;云计算&lt;/strong&gt;为基础的游戏方式，在云游戏的运行模式下，所有游戏都在&lt;strong&gt;服务器端&lt;/strong&gt;运行，并将渲染完毕后的游戏画面&lt;strong&gt;压缩&lt;/strong&gt;后通过网络传送给用户。在客户端，用户的游戏设备&lt;strong&gt;不需要&lt;/strong&gt;任何高端处理器和显卡，只需要基本的&lt;strong&gt;视频解压能力&lt;/strong&gt;就可以了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我将上述内容中一些比较重要的点做了标注，百科在对于云游戏的描述时，第一句就直接阐明了云游戏的基础是云计算，那么「云计算」以及「云」指的是什么？&lt;/p&gt;&lt;p&gt;云计算（cloud computing），是一种基于互联网的计算方式，通过这种方式，&lt;strong&gt;共享的&lt;/strong&gt;软硬件资源和信息可以按需提供给计算机和其他设备。提供资源的网络被称为“云”。&lt;/p&gt;&lt;p&gt;看完上面一句话有些小伙伴还会不太清楚，我们先来回顾下之前的知识。我在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2ODAyNTgyMQ==&amp;amp;mid=2247484553&amp;amp;idx=1&amp;amp;sn=132a24db34dc55a11be68cbb738a5631&amp;amp;scene=21#wechat_redirect&quot; title=&quot;《互联网是如何工作的》&quot; data-linktype=&quot;2&quot;&gt;《互联网是如何工作的》&lt;/a&gt;这一篇文章中提到：一台又一台的服务器通过“网线”连接在了一起，形成了类似下面这样的结构 👇&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;161&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.5113941018766756&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHQLthVgvia7dUianrTqqI0uQl6qxdtPibM7TKP189Qc2bExjoCxiakWFkNA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1492&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;众多服务器组成的这种结构被称为“互联网”，而其中每台服务器都被称作“节点”。&lt;/p&gt;&lt;p&gt;事实上这些节点都和你的本机无关但又和你的本机有关。&lt;/p&gt;&lt;p&gt;为什么这么说呢？&lt;/p&gt;&lt;p&gt;无关的原因是，这些节点所包含的计算能力（CPU、GPU）和存储文件都不是你的。有关的原因是，你可以通过某些方式运用这些能力和文件。&lt;/p&gt;&lt;p&gt;而上述所说的一个个节点便是云计算的核心，即「云」。&lt;/p&gt;&lt;p&gt;大量的水滴漂浮在空中，聚合成云。和我们所说的云很相似，只是这里的云是由&lt;strong&gt;大量的数据存储、计算资源和应用程序组成&lt;/strong&gt;，这便是云计算服务。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;210&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHSp9rauZrMSxicuDCuVNSic16w3TRRL7wc9oUc6xSONYQlibPhU7IQF5iaQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1620&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;「云」其实是一个抽象的概念，并不像服务器有一个具体的实物可以展示，我们可以把「云」理解为一个&lt;strong&gt;资源共享池&lt;/strong&gt;。举个例子就是，我有很多东西，家里放不下了，放到一个特定的地方存着，随时提取。大家都可以访问的就是「公有云」，只有特定的人可以访问的就是「私有云」。&lt;/p&gt;&lt;p&gt;这个“东西”一般是指&lt;strong&gt;数据、软件、服务&lt;/strong&gt;等，而“特定的地方”就是云。所以对于云计算我们也可以简单的理解为：将本地需要进行的计算任务迁移到云端进行。&lt;/p&gt;&lt;p&gt;如今云计算及其产物已经深入我们的生活，我们熟悉的百度网盘、iCloud 还有最近的阿里网盘就是「云存储」，以及本文要介绍的主角「云游戏」也是云计算的产物。&lt;/p&gt;&lt;h2&gt;云游戏&lt;/h2&gt;&lt;h3&gt;云游戏的原理&lt;/h3&gt;&lt;p&gt;在现在这个游戏变得越来越流行的时代，人们却仍然被低配设备所限制，比如我，虽然不差 298 买赛博朋克的钱，却苦于手头没有一台合适的机器用于玩耍。以往玩游戏我需要配一台游戏主机或者高性能游戏本，少说也要五六千，因为游戏对于计算机性能的要求是非常高的，这些都必须依赖玩家自己的电脑。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;167&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.531496062992126&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHz1nREHHT8oufyOhGx6uYWHJbKEKSonyQGKQicbo4iaIvIq0r1ltHZ7cg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2032&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;但是在云游戏模型中，所有的游戏逻辑和渲染都在&lt;strong&gt;服务器端&lt;/strong&gt;运行，然后再从服务器把压缩的画面传给用户，这样玩家就不需要一台高性能的计算机了，对于设备的要求便也就是&lt;strong&gt;基本的视频渲染能力&lt;/strong&gt;和&lt;strong&gt;可靠稳定的网络环境&lt;/strong&gt;了。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;123&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.39105504587155965&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpH70wfGgT8DalLuugwaclC5UJib7iacUzF7cWYRWOOpe6icFcCc3QNt2apA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1744&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;云游戏摆脱了对硬件的依赖。对服务器来说，仅仅需要提高服务器性能而不需要研发新主机；对用户来说，可以得到更高的画质而不用购买高性能的计算机。也就是说，用户可以花一小笔钱租一个更好的计算机来玩各种游戏，就像用机顶盒看电视一样，这意味着玩家可以在计算机硬件，特别是 GPU 上省下一大笔钱。&lt;/p&gt;&lt;h3&gt;云游戏需要什么？&lt;/h3&gt;&lt;h3&gt;低延时&lt;/h3&gt;&lt;p&gt;在解释云游戏的原理时，我们提到了云游戏的游戏逻辑和渲染都是在服务器端进行，然后将画面传送给用户，所以说一台可以高速上网的设备极其重要。如果网速不够快，不够稳定就无法及时接收到高质量的画面。&lt;/p&gt;&lt;p&gt;说到这我们需要介绍一下网络延时，所谓网络延时指一个数据包从用户的计算机发送到网站服务器，然后再立即从网站服务器返回用户计算机的来回时间。通俗的讲，就是数据从电脑这边传到那边往返所用的时间。&lt;/p&gt;&lt;p&gt;以我们现在还在普遍使用的 4G 网络而言，它的延时基本在 30ms ～ 70ms 波动，部分信号不好的地方延时还会更大。这还只是数据传输时的网络延时，如果算上画面编解码的时间，延时达到 100ms 是很容易的事情。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1.0033444816053512&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHyfFnEl5tdhYI1bGkiaXh2nv1rXJdzvuFd5UGZuKKxbsGAuYtvnZctWg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;299&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们知道视频的原理就是每秒播放多张静态画面，画面越多，对于人的观感来说就是视频越流畅。这是因为对于人眼来说，我们的视觉神经是有一个反应速度的，并且对于不同频率的光有不同的暂留时间。其时值约是 1/16 秒，也就是 62.5ms。也就是说，如果网络传输所消耗的延时大于 62.5ms，我们就会觉得画面很不流畅（62.5 是一个理论值，实际情况下这个数值会小于 62.5ms，对延时的要求更苛刻）。&lt;/p&gt;&lt;h3&gt;高带宽&lt;/h3&gt;&lt;p&gt;现在我们来做一个简单的数学题。&lt;/p&gt;&lt;p&gt;刚才我们说到视频的原理是每秒播放多张静态图像。我们知道图像都是由一个个像素点构成的，对于一张非黑即白的二值图像，不压缩的情况下一个像素只需要 1 个 bit。如果是 256 种状态的灰度图像，不压缩的情况下一个像素需要 8bit（1 字节，256 种状态）。如果用 256 种状态标识屏幕上某种颜色的灰度，而屏幕采用三基色红绿蓝（RGB），不压缩的情况下一个像素需要占用 24bit（3 字节），这个就是常说的 24 位真彩色。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.83984375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHo6zCIEFFdHRic1zntGibWtvamoaT01oac4Srl6g0JUTiah5L2OKjBwJlA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;那么对于一张 1920×1080 的图像，在不压缩的情况下，所需要的大小为 1920×1080×24 = 49766400bit，约等于 48Mb（注意这里是小写的 b，表示位），那么假设对于一个 1080P 30FPS 的视频，每秒就会播放 30 张 1920×1080 的图像，所以在不压缩的情况下如果为了传输这么多画面，网络的带宽必须要达到 48×30=1440Mb/s，当然在视频传输的过程中，肯定会有压缩的过程，假设可以压缩 50%的数据，那网络的带宽也需要 720Mb/s，看到这你想一下，你家的网络带宽又有多少呢？&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;这里之所以用 Mb 作为单位是因为方便大家和自己家的宽带进行比较，因为通常我们所说的百兆带宽指的是 100Mb 而不是 100MB。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;如何实现低延时+高带宽&lt;/h3&gt;&lt;p&gt;从开源节流的角度去考虑问题，如果网络传输的速度有上限，那么想要在单位时间内传输更多的视频数据，最好的方式便是对视频进行编解码。&lt;/p&gt;&lt;h3&gt;视频编解码&lt;/h3&gt;&lt;p&gt;编码这一概念在通信与信息处理领域中广泛使用，其基本原理是将信息按照一定规则使用某种形式的码流表示与传输。常用的需要编码的信息主要有：文字、语音、视频和控制信息等。&lt;/p&gt;&lt;p&gt;刚才说了动态图像的像素形式表示数据量极为巨大，存储空间和传输带宽完全无法满足保存和传输的需求。所以要对视频进行编码，其最主要的目的就是为了对视频数据进行压缩。&lt;/p&gt;&lt;p&gt;而视频信息之所以存在大量可以被压缩的空间，是因为其中本身就存在大量的数据冗余。&lt;/p&gt;&lt;p&gt;举个简单的例子，下面这两张图片是一段视频的其中两个画面（寒食君友情出镜）&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;176&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.5582761998041136&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHbdFxG6jUuWfqGuW2rCicqI6pGZEGYfeicOrDAAwfrRxAaDHO9zxMWj5Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1021&quot; title=&quot;null&quot;/&gt;从这两张图片可以看出，其实变化的部分就是人物的动作，而不变的是后面的背景，所以后面的这块背景像素在对于视频来说就是一段冗余数据，可以被压缩。同样的，人物的脸部虽然有动作变化，但是人物的脸并没有变化，寒食君还是寒食君，因此不变的地方同样是冗余数据。&lt;/p&gt;&lt;p&gt;视频中的冗余数据的主要类型有：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;时间冗余：视频相邻的两帧之间内容相似，存在运动关系&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;空间冗余：视频的某一帧内部的相邻像素存在相似性&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;编码冗余：视频中不同数据出现的概率不同&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;视觉冗余：观众的视觉系统对视频中不同的部分敏感度不同&lt;/span&gt;&lt;/p&gt;&lt;p&gt;针对这些不同类型的冗余信息，在各种视频编码的标准算法中都有不同的技术专门应对，以通过不同的角度提高压缩的比率。这里我们简单说一下目前较为流行的两种编码 &lt;strong&gt;H.264 与 H.265&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;217&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.6902173913043478&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpH8aJVqgsNvUMkgVKB7unlu0QiaEI2Mppukg0fMQCvJo5DEyo5UeRGoEA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;736&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;这两个是 ITU-T VCEG 制定的视频编码标准。H.265 标准围绕着现有的视频编码标准 H.264，保留原来的某些技术，同时对一些相关的技术加以改进。新技术使用先进的技术用以改善码流、编码质量、延时和算法复杂度之间的关系，达到最优化设置。&lt;/p&gt;&lt;p&gt;具体的编码算法太过复杂，这里就不再多说，我们只要知道 H264 由于算法优化，可以低于 1Mbps 的速度实现标清数字图像传送；H265 则可以实现利用 1~2Mbps 的传输速度传送 720P（分辨率 1280*720）普通高清音视频传送。H.265 旨在在有限带宽下传输更高质量的网络视频，仅需 H.264 的一半带宽即可播放相同质量的视频。&lt;/p&gt;&lt;p&gt;经过测试，在相同的图像质量下，相比于 H.264，通过 H.265 编码的视频大小将减少大约 39-44%。在码率减少 51-74%的情况下，H.265 编码视频的质量还能与 H.264 编码视频近似甚至更好。&lt;/p&gt;&lt;h3&gt;5G 和 Wi-Fi6&lt;/h3&gt;&lt;p&gt;&lt;img data-backh=&quot;173&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.547699214365881&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHXfxdXfeReh9S3ricZRFmQHFM6UErVjKdtRSQLeoI5LXC7owibwpWjwrA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1782&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;有了视频解码可以在单位时间内传输更多的数据后，剩下要做的便是提高传输速率。这便引出了今年非常火的两个名词——5G 和 Wi-Fi6。&lt;/p&gt;&lt;p&gt;就目前公开的数据来看，5G 协议中的峰值速度已经达到 20Gbit/s，Wi-Fi 6 最高也可以达到 9.6Gbit/s，这也就意味着在网络传输中可以携带的数据包更大。而且由于技术的提升，这两者在网络延时上也做了非常多的优化，在同等条件下 5G 的延迟低于 1 毫秒，相较于 4G 的 30-70 毫秒可谓是质的飞升。而 WI-FI6 的网络延时虽然不及 5G 这么优秀，但也从 Wi-Fi5 的平均 30ms 降低至 20ms。&lt;/p&gt;&lt;h3&gt;小结&lt;/h3&gt;&lt;p&gt;云游戏的概念其实早在 2013 年就已提出，但一直不温不火，目前来看，得益于越来越先进的压缩算法和低延时高带宽的网络环境，云游戏真的有可能异军突起，那么目前已有的云游戏做到什么样了呢？恰好笔者最近收到消息，腾讯的 START 云游戏平台已经公测，接下来谈谈我的云游戏初体验。&lt;/p&gt;&lt;h2&gt;我的云游戏初体验&lt;/h2&gt;&lt;p&gt;我的第一次云游戏初体验是在腾讯的 START 平台上进行的，点击官网https://start.qq.com即可看到如下的页面。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;155&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.4913557779799818&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHxjUQHMhIAtVEotSw2kRCdxu3MXPs46oFe8s2giaFCiaW5XOtCuPUg5Gw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2198&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;如果不是因为他的域名里有 qq.com，这简洁的页面真的让我怀疑这是腾讯做的吗？而且这句「从此 Mac 也有庞大的游戏库」这句话真的让我很难不怀疑腾讯会那么好心提供那么多游戏吗？&lt;/p&gt;&lt;p&gt;抱着怀疑的态度我下载安装了这款云游戏平台，Mac 安装软件的方法一如既往的简单，下载完后直接将 app 文件拖入 Application 文件夹中即可。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;191&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.6060606060606061&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHiazltm77RZUR3ceHibj8ZMpRDvvX7pnaKIxHx2yRzXpSZ4MnGg5dQoPg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1320&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;打开之后我们可以看到腾讯提供的一些游戏，种类虽然不是很多，但是对于不能玩游戏的 Mac 来说已经很不错了。&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;207&quot; data-backw=&quot;315&quot; data-ratio=&quot;0.6564356435643565&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHKDvhlUYKyzvIvkibUmql9Q50KDpnMYNiccibLg7JTgNWFbpEfI8iagMe0Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1010&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;我试玩了一下很久没玩的 QQ 飞车，体验一番后，我只能说：NB！！&lt;/p&gt;&lt;p&gt;我录了一段小视频，大家可以播放看一下（玩的比较菜，不要嫌弃）&lt;/p&gt;&lt;p/&gt;&lt;p&gt;之后我又玩了几把堡垒之夜和穿越火线，目前来看：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;腾讯 START 的整个流程已基本完备，使用门槛很低，下载一个客户端即可体验云游戏。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;虽然游戏种类不是很多，但有总比没有好&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;赛车类键盘操作游戏体验很好，能还原 PC 体验的 90%以上。画面流畅，帧率稳定，分辨率高。(网速要求并不是很苛刻，只要连接了 5G Wi-Fi 即可)&lt;/span&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;目前来看 START 是免费的，不知道公开运行时候是不是会收费。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;总的来说，这次的体验真的让我惊到了，因为按照之前的计算，现在的 5G Wi-Fi 的速率和延时其实是不足以带动云游戏，但体验下来，效果真的非常棒，我的 Macbook pro 终于也可以愉快的打游戏了，手里有 Mac 的小伙伴也可以下载体验下。&lt;/p&gt;&lt;h2&gt;浅谈云游戏&lt;/h2&gt;&lt;h3&gt;云游戏的影响&lt;/h3&gt;&lt;p&gt;对于玩家来说，云游戏并不需要高性能的显卡，连使用 MacBook Air 的小伙伴也可以畅玩，扩充了游戏品类，减少了高昂的硬件开支。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHNaNsLOXYNj99DnUDBcwadyFxf6cybP9A52icpG253keQb31fRHAxeuA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;而且由于游戏都在云端，可以有效的杜绝外挂（你总不能把外挂装到厂商的服务器里吧），同样的也可以防止盗版游戏的盛行（虽然并不知道这是好事还是坏事）。&lt;/p&gt;&lt;p&gt;同样的，对于游戏开发者来说，云游戏的出现可以是他们在开发游戏时可以减少对老设备、低性能设备的适配，提升了游戏呈现质量的同时降低了开发成本，提高了游戏开发的效率。&lt;/p&gt;&lt;h3&gt;云游戏会取代 PC 吗？&lt;/h3&gt;&lt;p&gt;说了那么多，一旦一项新技术兴起，就会面临一个老生常谈的问题：云游戏的出现会取代传统的游戏主机吗？肯定的说，不会。&lt;/p&gt;&lt;p&gt;就算未来网速再快、延时再低，也不可能达到 0 延迟。没办法，这是物理法则。当你在玩电竞游戏的时候，你需要的一定是几毫秒的延时而不是几百毫秒。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6416666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpHV1wr7a5HXpYtUaNibZY7xHeZh0plLiccOrCia2pzQbzbv0zR59Vwf0Fag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;但同样的，云游戏给游戏玩家提供了新的选择，对于一些非重度游戏玩家，玩一些对延时要求不高的游戏来说，云游戏确实是一个新的选择。&lt;/p&gt;&lt;p&gt;所以，回到一开始的问题，云游戏在革谁的命？是英伟达、AMD 这样的显卡厂商吗？还是 Steam、Uplay 这样的游戏平台？我看都不是，它革的是「游戏本」、是「盗版游戏」的命。&lt;/p&gt;&lt;h2&gt;最后&lt;/h2&gt;&lt;p&gt;以上就是本篇文章的全部内容了，如果你觉得还不错的，欢迎点赞支持一波，你们的支持是我更新的最大动力！&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1skeHK2Gybxwic7wyTnC2AklsA8OVQMpH47ZQb0Qia7ibfUdueIsZVJMzPW9DXBor2xORyYzlpF6GtIRTkibRTUEQQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>