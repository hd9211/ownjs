<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>259ad0b59bc92cc81e7b2680e89d8433</guid>
<title>【大内存服务GC实践】- 一文看懂G1GC垃圾回收器</title>
<link>https://toutiao.io/k/fio8ane</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7837837837837838&quot; data-type=&quot;png&quot; data-w=&quot;74&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/siayVELeBkzWBXV8e57JJ4OyQuuMXTfadZCia0bN2sFBfdbTRlFx0S97kyKKjic5v6eaZ8cY4WQt0UEu4dkyowHYg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7837837837837838&quot; data-type=&quot;png&quot; data-w=&quot;74&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rl6daM2XiabyLSr7nSTyAzcoZqPAsfe5tOOrXX0aciaVAfibHeQk5NOfQTdESRsezCwstPF02LeE4RHaH6NBEB9Rw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;背景介绍&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;笔者在这个系列的第一篇文章&lt;/span&gt;&lt;span&gt;《一文看懂&quot;ParNew+CMS&quot;垃圾回收器》&lt;/span&gt;&lt;span&gt;中详细介绍了&quot;ParNew+CMS&quot;垃圾回收器的工作原理。文章最后笔者提到CMS垃圾回收器有两个比较显著的问题，一个是长时间运行无法避免Full GC，一个是Remark阶段STW时间较长。正是因为这两个问题的存在，CMS垃圾回收器在JDK9被标记弃用，慢慢开始退出历史舞台。有走的，就有来的，JVM重新设计了另一款垃圾回收器G1，有效地解决了CMS垃圾回收器遇到的上述两大问题。那么，这篇文章我们就详细探讨一下G1垃圾回收器是如何解决上述两大问题的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;和上篇文章介绍&quot;ParNew+CMS&quot;垃圾回收器一样，笔者会从G1垃圾回收器最基础的数据结构和算法出发，深入分析它的工作原理，对其中的一些关键机制进行剖析。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7837837837837838&quot; data-type=&quot;png&quot; data-w=&quot;74&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/siayVELeBkzWBXV8e57JJ4OyQuuMXTfadZCia0bN2sFBfdbTRlFx0S97kyKKjic5v6eaZ8cY4WQt0UEu4dkyowHYg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7837837837837838&quot; data-type=&quot;png&quot; data-w=&quot;74&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rl6daM2XiabyLSr7nSTyAzcoZqPAsfe5tOOrXX0aciaVAfibHeQk5NOfQTdESRsezCwstPF02LeE4RHaH6NBEB9Rw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;G1核心数据结构&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;1. Region&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;为什么CMS垃圾回收器长时间运行无法避免FGC？本质是因为CMS垃圾回收器中老年代采用标记清理算法，这种算法会产生较多内存碎片，当内存碎片很碎无法给对象分配出连续空间的时候，JVM就会触发FGC整理老年代。那有些同学就会问为什么不在每次老年代GC的时候执行整理操作呢？这主要是因为老年代如果很大的话，整理一次STW的时间会不可控。那怎么破这个局呢？JVM设计者提出了一个思路：&lt;/span&gt;&lt;span&gt;老年代不是很大吗，那就将老年代划分成很多小的格子，在此基础上GC算法基本不变，还是先标记，不过在标记完成后，按照优先级选择部分格子使用复制算法进行整理，这样每次整理的内存空间是可控的，STW的时间就相对可控，而且因为使用复制算法就不再会出现内存碎片。对，这就是G1垃圾回收器的核心设计思想。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;G1 是一个分代回收器，它依然保留了&quot;ParNew+CMS&quot;垃圾回收器中新生代和老年代的分代逻辑。但与&quot;ParNew+CMS&quot;回收器不同的是，它引入了一个新的数据结构 - Region，也就是上文中笔者提到的小格子。G1垃圾回收器会把整个堆划分成一个个大小相等的Region，每个Region的大小可以通过参数设置，通常大小在1~32M之间，默认大小取决于总堆的大小。下图是G1回收器堆划分的示意图：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.584&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dTQ3R5geQ2wmia7RLzhgB8BbmVmV6Zqd7V31D1DuulGjuLKpGb8ibWBNa606rM79FO963TatEyNUSzRkea0wxibRw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上图中整个堆区会被划分为新生代以及老年代，其中新生代又分为Eden区和Survivor区，这和&quot;ParNew+CMS&quot;回收器是相同的。不同的主要有两点：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;（1）G1回收器不要求新生代或者老年代的Region连续分布，换言之，这些Region可以随意分布在整个堆区，它和新生代或者老年代的隶属关系属于逻辑隶属。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;（2）如果一个对象大小超过Region大小的一半，就会被视为巨型对象（Humongous Object），巨型对象会被分配到Humongous Region。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. RememberedSet（RSet）和Card Table&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;《一文看懂&quot;ParNew+CMS&quot;垃圾回收器》&lt;/span&gt;&lt;span&gt;文章在介绍对象标记的时候重点说明了一个对象跨代引用的问题。比如YGC阶段标记新生代对象的时候，不仅需要扫描GC Roots标记其直接引用的新生代对象，还需要扫描所有老年代对象，查看其是否引用了新生代对象，如果引用了的话，对应新生代对象也是需要标记的，否则就会发生漏标。然而实际实现中，扫描整个老年代对象的代价相当大。文章中我们介绍了可以通过Card Table这种数据结构大幅降低扫描老年代对象查找跨代引用的代价，简单来说，就是通过写屏障技术在老年代对象引用新生代对象的时候将Card Table对应Card设置成&quot;脏卡&quot;，这样的话，查找跨代引用，只需要扫描Card Table脏卡对应的老年代区域，而不需要扫描整个老年代，大大降低了扫描代价。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;根据上文介绍，G1也是一个分代回收器，也需要处理跨代引用扫描代价大的问题。为了解决这个问题，G1引用了另一种新的数据结构 - Remembered Set，简称RSet。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;2.1 RSet是什么样的数据结构呢？&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;在G1实现中，每个Region会被划分成很多512Byte大小的小块，这样一个32M的Region就会被划分为65536个小块。与之大小对应的会有一个长度为65536的Card Table数组，数组的每个元素只有1Byte，对应Region的每个小块。Card Table数组这个结构和CMS垃圾回收器中Card Table是相同的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;除了Card Table数组之外，每个Region还会有一个RSet数据结构，RSet主要用来记录哪个Region的哪个Card上的对象引用了本Region中的对象。实际实现中，RSet默认是一个HashMap，Map的key是引用Region，value是一个List，List中存储引用Region中的引用Card列表。Region、Card Table以及RSet的示意图如下所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.38671875&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dTQ3R5geQ2wmia7RLzhgB8BbmVmV6Zqd7WoADaHdp3CtC46djM3gPUd7VCFPyvOLr7Gb5SY8ZyvBnzCjJQ5iblkg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上图中，RegionA和RegionB中分别有对象引用RegionC中的对象，在RegionC对应的RSet就会记录这样的引用关系。该RSet中有两个KV对，第一个KV对的key是RegionA，value是一个列表，列表中有两个元素3和65534，分别代表RegionA中引用对象在对应Card Table中的下标。第二个KV对的key是RegionB，value中列表只有一个元素1565，代表RegionB中引用对象在对应Card Table中的下标。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;介绍到这里，大家应该对RSet的结构有了初步的了解。与CMS回收器中Card Table相比，Card Table中的脏卡代表&quot;我引用了别的对象&quot;，属于一种points-out结构。而RSet记录的是哪些其他Region引用了本Region中的对象，属于points-into结构。两者是有本质区别的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;按照上述介绍，如果一个Region是热点Region，表示这个Region中的对象被大量其他Region中的对象所引用，那么RSet占用的内存空间开销就会越大。但我们要清楚一点，RSet内存开销不是为业务服务的，实际上不应该占用太多。因此为了控制RSet占用内存空间的大小，RSet会根据引用Region个数的多少，设置3种不同的实现方式（上文中介绍的是其中一种），分别称为：&lt;/span&gt;&lt;/section&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;sparse per-region-table (PRT)，从字面意思来看表示这个RSet是一个稀疏的集合。具体实现使用HashMap方式记录引用关系，其中Map的key是引用Region，value是一个List，List中存储引用Region中的引用Card列表。上文有过介绍。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;fine-grained PRT，还是使用HashMap方式记录引用关系，其中Map的key是引用Region，但value不再是List，而是一个bitmap，bit位为1表示对应Card是引用Card，否则不是引用Card。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;coarse-grained bitmap，从字面意思可以看出来这就是一个bitmap，不过bitmap中每个bit位引用粒度不再是Card，而是Region。如果bit位值为1，表示这个Region是引用Region，即这个Region中有对象引用了该Region中的对象。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;很显然，上述3种实现方式中，spase PRT和fine-grained PRT都是精确到Card，而coarse-grained bitmap是精确到Region。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;2.2 G1是如何管理RSet的？&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;G1会创建一个用于管理RSet的线程池，这些线程称为Refine线程。G1中RSet的更新不是同步完成的，G1会把所有引用关系都先放入一个队列中，称为Dirty Card Queue（DCQ），然后使用Refine线程来消费这个队列完成引用关系的记录并更新RSet。如果Refine线程忙不过来，GC线程以及应用线程也可能会协助更新RSet。&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7837837837837838&quot; data-type=&quot;png&quot; data-w=&quot;74&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/siayVELeBkzWBXV8e57JJ4OyQuuMXTfadZCia0bN2sFBfdbTRlFx0S97kyKKjic5v6eaZ8cY4WQt0UEu4dkyowHYg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7837837837837838&quot; data-type=&quot;png&quot; data-w=&quot;74&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rl6daM2XiabyLSr7nSTyAzcoZqPAsfe5tOOrXX0aciaVAfibHeQk5NOfQTdESRsezCwstPF02LeE4RHaH6NBEB9Rw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;strong&gt;G1核心工作流程&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在介绍G1垃圾回收器工作流程之前，先简单回顾一下&quot;ParNew+CMS&quot;回收器的工作流程，具体流程不再赘述，参考下图：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.41875&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dTQ3R5geQ2wmia7RLzhgB8BbmVmV6Zqd7MYFIIJtOVn7IRj1HmSiaMibOZ9fuWriaibAhEm4Yj7ZbeJWHlax21f2kdg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;G1回收器核心工作流程与&quot;ParNew+CMS&quot;回收器基本相同，参考上图看下图：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.421875&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dTQ3R5geQ2wmia7RLzhgB8BbmVmV6Zqd75561RchITIS4syKIa5581cbu89icPvIsp9ben0IdhnhOELs2vwd47uw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对比&quot;ParNew+CMS&quot;回收器工作流程，G1中同样会比较频繁地进行新生代YGC，同样也有老年代并发标记周期。不同的是，G1在并发标记之后并没有直接清理全部垃圾对象，而是新增了一个混合收集周期，这个周期包含多次Mixed GC，每次Mixed GC只会回收部分Region，直至未处理Region集合占比低于特定阈值。之所以将这个周期称为&quot;Mixed Collection Cycle&quot;，是因为每次Mixed GC都会同时回收新生代和老生代中的Region。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上图中，IHOP(InitiatingHeapOccupancyPercent) Trigger代表&quot;并发标记周期&quot;触发的阈值。一旦当前JVM已使用内存/总堆内存超过这个阈值，就会触发并发标记。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;虽然G1回收器的工作流程和&quot;ParNew+CMS&quot;回收器差的不是很多，但是每个核心步骤的具体实现却有很大的不同。接下来分别来看G1中的YGC、Concurrent Marking Cycle以及Mixed GC的一些核心实现细节。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;1. Young GC核心流程&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;和&quot;ParNew+CMS&quot;一样，一旦Eden区满了之后，就会触发YGC。YGC只负载回收堆中新生代的所有Region，不回收老年代的Region。基本流程可以表示为如下几步：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;（1）将eden区和survivor区所有Region添加到CSet中准备回收。注：CSet是一个存放待回收Region的数据结构。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;（2）标记阶段&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从GC Roots开始标记直接引用的新生代对象。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;基于RSet标记跨代引用的新生代对象。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;（3）复制阶段：将标记活跃的对象复制到其他Region中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了更加清楚的明白上述步骤，下图是一次真实的YGC日志片段，可以对照着上述流程来看。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.51953125&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dTQ3R5geQ2wmia7RLzhgB8BbmVmV6Zqd7t4y7ib4pvXw1uQI5JJ4PCA19RmXEibjoKyibFuo7BKQUefxOqxaIR9ib5Q/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;G1在日志的细节上比&quot;ParNew+CMS&quot;要详细很多，如果研究G1的话，日志是一个非常不错的研究入口。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;2. Concurrent Marking Cycle核心流程&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;根据上文介绍，一旦&quot;JVM已使用内存/总内存&quot;的比例超过设定阈值IHOP（InitiatingHeapOccupancyPercent）后，G1会执行一次Concurrent Marking Cycle，并在之后进行多轮Mixed GC。和CMS回收器基本一样，G1中一轮并发标记周期包含初始标记、并发标记、重新标记，再加上一个cleanup阶，这样就可以完成整堆所有Region的对象标记。下面是一段G1回收器中并发标记周期的完整日志：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8796875&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dTQ3R5geQ2wmia7RLzhgB8BbmVmV6Zqd7daMdUdiaZ3WK1jgfL9kGjlcyHQXC68ZT13sia5p6Gia4GkynfJPLG7kgw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;初始标记（Initial Marking）：初始化标记是伴随一次普通的YGC发生的，从GC Root开始标记直接可达的对象。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;并发标记( Concurrent Marking)：这个阶段标记线程和应用线程并发工作，遍历整堆所有可达对象并标记。这个阶段需要特别关注并发标记可能产生的&quot;漏标&quot;问题，G1使用Snapshot AT Begining（简称SATB）算法避免漏标问题发生，这和CMS完全不同。3.4小节深入介绍。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul start=&quot;1&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;重新标记( Remark) ：标记那些在并发标记阶段发生变化的对象,将被回收。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;清理( Cleanup )：释放没有存活对象的Region。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;3. Mixed GC核心流程&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;一轮并发标记之后紧接着是混合回收周期，包括多次Mixed GC，每次Mixed GC只回收部分Region。这里有三个问题：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;（1）为什么这些Region需要分为多次回收？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;主要原因是所有Region一起回收的话有可能会导致暂停时间比较长，尤其在内存较大的情况下。为了每次回收的暂停时间可控，就将一次大回收分成很多次小回收。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;（2）每次回收Region集合的选择原则是什么？&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在执行混合回收之前，G1会将所有Region按照每个Region中垃圾对象占比进行一次排序，垃圾对象占比越高，排名越靠前。排好序之后，每次Mixed GC按顺序选择部分Region进行回收，选择多少Region取决于这些Region的回收预估暂停时间不超过设置的最大暂停时间。这个回收算法称为Garbage First，也就是G1的意思。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;（3）每次Mixed GC的过程是怎么样的？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具体的回收过程和上文中介绍的Young GC没有太大区别，可以参考上文介绍。&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;4. 并发标记阶段对象&quot;漏标&quot;问题解法 - SATB算法&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;在介绍SATB算法之前，先简单介绍一下并发标记过程中可能出现的对象&quot;漏标&quot;问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h5&gt;&lt;strong&gt;&lt;span&gt;4.1 对象漏标简介&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h5&gt;&lt;section&gt;&lt;span&gt;什么是对象漏标？就是本应该被标记为活跃的对象因为某些原因最终没有被标记，被垃圾回收器认为是垃圾对象而回收掉，最终导致应用错误，很显然这种情况是不允许发生的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;并发标记阶段什么场景下会发生对象漏标？应用线程和标记线程并发执行，在下面两种场景下会出现漏标：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1. 应用线程在并发标记过程中新生成的活跃对象因为某些原因没有被标记线程标记。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. 应用线程在并发标记过程中变更引用关系的时候在特定场景下会出现漏标，具体场景涉及标记算法&quot;三色标记法&quot;，详细可以阅读文章《【大内存服务GC实践】- 一文看懂”ParNew+CMS”垃圾回收器》。这里只简单进行描述：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6053882725832013&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1262&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dTQ3R5geQ2wmia7RLzhgB8BbmVmV6Zqd71JwLKervUHfePuicJlY7Rfu4ntXWJu2uhgl0owoFGUUBT3PNVC0uy8w/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如上图所示，老年代中有三个对象A、B和C，在标记之前的引用关系是A引用B，B引用C。先分别介绍一下他们的标记情况：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对象A已经被标记为黑色，表示为A为活跃对象且所有它引用的对象也完成标记。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对象B被标记为灰色，表示B对象是活跃对象，但是它关联的对象还没有被完全标记完。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对象C是白色，表示还没有被标记。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在这种背景下，应用线程此时发生了一次引用关系变更，B引用C的关系被删除了且同时A引用了C，即如下所示代码：&lt;/span&gt;&lt;/section&gt;&lt;pre data-wrap=&quot;true&quot;&gt;&lt;section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;objB.fieldC = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;objA.filedC = C;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;此时，标记线程就不再会标记对象C，因为对象A已经是黑色，表示所有它引用的对象都已经完成标记。然而实际上活跃的对象C就会被漏标最终被回收掉。&lt;/span&gt;&lt;/section&gt;&lt;h5&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5&gt;&lt;strong&gt;&lt;span&gt;4.2 SATB算法思想简介&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h5&gt;&lt;section&gt;&lt;span&gt;对象漏标介绍之后简单介绍一下SATB算法的基本思想，可以概括为如下三句话：&lt;/span&gt;&lt;/section&gt;&lt;ol start=&quot;1&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;并发标记之前先给Region内存打个快照，标记线程基于这个快照独立进行标记。应用线程不会直接修改这个快照中的对象，也就是说应用线程不会干扰标记线程的工作。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;应用线程新分配的对象都认为是活跃对象，实际在下一个并发标记周期进行标记。上文说过漏标发生的第一种场景是&quot;应用线程在并发标记过程中新生成的活跃对象因为某些原因没有被标记线程标记&quot;，那如果能够将标记阶段新分配的对象全都集合到一起，这些对象全部都标记为活跃对象（实际肯定会有部分垃圾对象，将垃圾对象标记为活跃对象不影响程序正确性）就可以解决这个问题。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;并发标记过程中已存在对象的引用关系变更在Remark阶段单独进行处理。上文介绍了漏标发生的第二种场景，为了解决这个场景引入的漏标问题，可以将引用关系变更分解为旧的引用关系先删除，新的引用关系生成两个步骤，只要破坏任何一个步骤就可以防止漏标发生。因此有两种针对性解法：&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在并发标记阶段如果有新引用关系生成，就记录下来，Remark阶段进行重标记，这个破坏了步骤二，即黑色对象重新引用了白色对象，就记录下来重新扫描黑色对象，将其引用的所有对象都标记成存活对象。这个就是CMS垃圾回收器使用的增量更新算法。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在并发标记阶段如果有引用关系被删除，就记录下来，Remark阶段对这些引用关系被删除的重标记，这个破坏了步骤一，即灰色对象断开了白色对象引用的时候，记录下来，后面重新把这个白色对象标记成存活对象。这个就是G1垃圾回收器使用的算法。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;简单来说，SATB明确将并发标记这一个大工程分成了三个字模块，分别是对快照进行并发标记、对并发标记过程中新分配的对象全部标记为活跃、对并发标记过程中引用关系变更的对象单独进行处理。&lt;/span&gt;&lt;/section&gt;&lt;h5&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5&gt;&lt;strong&gt;&lt;span&gt;4.3 SATB算法实现&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h5&gt;&lt;section&gt;&lt;span&gt;了解了SATB算法的核心思想之后，再来看看这个算法是如何实现的。G1回收器将堆内存分成一个一个Region，在Region中分配对象时，对象都是连续分配的。这里介绍两个指针：Bottom指针和Top指针，其中Bottom指针指向Region的初始位置，Top指针指向下一个对象分配的内存位置，如果有新的对象分配，就将Top指针向前移动。如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.615686274509804&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;510&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dTQ3R5geQ2wmia7RLzhgB8BbmVmV6Zqd7SbgkJvPgvuqVQyNv3dFfCgZkjIAy9Y4HRnOegV5vp8V5yzYdNicGhGA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;G1使用的SATB算法是基于内存快照的，那SATB算法具体怎么实现基于内存快照的标记呢？现在假设在标记之前Region如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.23556231003039513&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;658&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dTQ3R5geQ2wmia7RLzhgB8BbmVmV6Zqd78ib0N8xZBsywicVb5picxHRZJQb87ZWRyWFu4VyWBNGXDGtrv4kf3xaqQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;这个时候要进行一轮完整的并发标记周期，按照上面的说法是要先给这个Region打个快照，这个快照实际上就是[Bottom, Top)现在这块内存区域。但是在并发标记周期内，因为有引用线程在分配对象，所以Top指针肯定会往前移动，所以为了将标记开始前Top这个位置记录下来，需要定义另一个指针TAMS（全称Top-At-Mart-Start）指向标记前Top这个位置，从Top-At-Mark-Start这个字面含义就可以理解是标记开始时Top指针所在位置，这样快照所代表的内存区域就是[Bottom, TAMS)这块，并发标记过程中标记线程就基于这块内存对象进行标记，后面Top指针就可以随意往前移动了。所以按照正常的逻辑应该是这样：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5485362095531587&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;649&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dTQ3R5geQ2wmia7RLzhgB8BbmVmV6Zqd7mT6oJdwTZ1twOnOoicnseW6TlazrI0ymPLuxvx9AgsrJrpf5ibvia3qiag/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;上图中Initial Marking刚开始的时候，Top指针和TAMS指针指向同一个内存位置，[Bottom, TAMS）这块内存区域有一个对应的bitmap，bitmap中每一位代表对应内存区域对象是否存活。经过并发标记之后，Remark开始的时候，Top指针因为应用线程有分配对象所以会向前移动，并发标记线程独立标记[Bottom, TAMS)这块内存区域对应的对象，标记后的结果使用bitmap表示（其中黑色方块表示对应对象被标记为活跃对象）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在并发标记过程中新生成的对象都分配在[TAMS, Top) 这块内存区域，G1算法会将这部分新生成的对象都认为是存活对象，这轮标记不处理这部分新生成对象，留到下一轮标记处理。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在继续来看SATB算法如何处理并发标记过程中引用关系变更问题。在并发标记阶段，引用变更发生后通过写屏障会将这些变更记录并保存在一个队列里（&lt;/span&gt;&lt;code&gt;&lt;span&gt;satb_mark_queue&lt;/span&gt;&lt;/code&gt;&lt;span&gt;），在remark阶段会扫描这个队列，通过这种方式，旧的引用所指向的对象就会被标记上，其子孙也会被递归标记上，这样就不会漏标记任何对象，snapshot的完整性也就得到了保证。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;实际上介绍到这里基本上已经将SATB算法实现介绍的比较清楚了。下图是完整的两轮并发标记示意图（摘自网上）：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.6863636363636363&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;440&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dTQ3R5geQ2wmia7RLzhgB8BbmVmV6Zqd7hZZ5upIGVeyYMnuwfFxiaqp9W9icHWGG5thFIj4jSAaFaHEnPL99QeBg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;h5&gt;&lt;br/&gt;&lt;/h5&gt;&lt;h5&gt;&lt;strong&gt;&lt;span&gt;4.4 SATB算法 vs Incremental Update算法&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/h5&gt;&lt;section&gt;&lt;span&gt;G1的SATB算法在Remark阶段不需要暂停遍历整堆对象，所以避免了这个阶段可能的长耗时。但是CMS垃圾回收器中增量更新算法因为无法知道哪些对象是并发标记阶段新增的，所以在Remark阶段需要重新扫描GC Roots标记整堆对象，这就可能带来不可控的长耗时暂停。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7837837837837838&quot; data-type=&quot;png&quot; data-w=&quot;74&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/siayVELeBkzWBXV8e57JJ4OyQuuMXTfadZCia0bN2sFBfdbTRlFx0S97kyKKjic5v6eaZ8cY4WQt0UEu4dkyowHYg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7837837837837838&quot; data-type=&quot;png&quot; data-w=&quot;74&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rl6daM2XiabyLSr7nSTyAzcoZqPAsfe5tOOrXX0aciaVAfibHeQk5NOfQTdESRsezCwstPF02LeE4RHaH6NBEB9Rw/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;全文总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;至此，笔者基本将G1GC的核心内容介绍完了。可以看到，G1相比CMS在很多地方都做了非常大的改动，整体思路还是比较清晰的。但是在具体实践中，因为G1的这种复杂性，导致想要用好G1，需要开发同学对其中各个参数的含义比较了解，并且要有一定的调优经验。尤其在一些大内存场景下，一旦参数调不好，很可能GC效果会非常差。因为笔者目前接触到的大数据系统都是大内存场景，所以在这些场景下用好G1，实际上还是需要不断地测试和调优。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ac564c005bceb65428ebde9b1c6e7e56</guid>
<title>纳瓦尔宝典：财富和幸福指南.pdf</title>
<link>https://toutiao.io/k/br1y473</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ff197705a203b7f27c53aa11e8448ab3</guid>
<title>Http缓存有什么最佳实践么？</title>
<link>https://toutiao.io/k/7qn4gpb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是 &lt;code&gt;ConardLi&lt;/code&gt;，我又来给大家解读浏览器策略了，这次是缓存相关的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置缓存大家可能大家都是从性能角度去考虑的，但是如果你不注意或者稍微设置不当，缓存也可能对我们的网站的安全性和用户隐私造成负面影响。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;开门见山&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老规矩，先把推荐的配置说出来，后面再啰嗦：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为了防止中介缓存，建议设置：&lt;code&gt;Cache-Control: private&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;建议设置适当的二级缓存 key：如果我们请求的响应是跟请求的 &lt;code&gt;Cookie&lt;/code&gt; 相关的，建议设置：&lt;code&gt;Vary: Cookie&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么为啥推荐这两个配置呢？如果不配置会对我们的网站带来什么风险呢？且听我下面的讲解。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;回顾 HTTP 缓存&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提到缓存，大家可能很快就会想到两种缓存方式，以及对应的几个请求头，我们来快速回顾一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常情况下，我们的浏览器客户端会像服务器发起请求，然后服务器会将数据响应返回给客户端。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35242839352428396&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQYYeTBiaTIV45f1RZqEDT1iakP3DS0ibWqw7k2Hp2kR7azbWPceWUwW3oicQN3gIeTEJkFVdjGV90GTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1606&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是一台服务器可能要对成千上万台客户端的请求进行响应，其中也有非常多是重复的请求，这会对服务器造成非常大的压力。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.361890694239291&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQYYeTBiaTIV45f1RZqEDT1iamJ5gQe5N6wRQWVMs9Gxcy8E6P8HXRHqY9zzZicl1PFOia3hOV0CLe9ibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1354&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以一般我们都会在客户端和服务器间进行一些缓存，对于一些重复的请求数据，如果之前的响应已经被存储到缓存数据库中，满足一定条件的话就会直接去缓存中取，不会到达服务器。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34140969162995594&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQYYeTBiaTIV45f1RZqEDT1ia6BiaFeghnKEcgyauhgdqR898NP2icB3yMJwicbIgibdSZCyH4M2uqLCuaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1816&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，HTTP 缓存一般又分为两种，强缓存和协商缓存：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;强缓存&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;强缓存，在缓存数据未失效的情况下，客户端可以直接使用缓存数据，不用和数据库进行交互。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，判断请求是否失效主要靠两个 HTTP Header：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Expires&lt;/code&gt;：数据的缓存到期时间，下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Cache-Control&lt;/code&gt;：可以指定一个 &lt;code&gt;max-age&lt;/code&gt; 字段，表示缓存的内容将在一定时间后失效。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;协商缓存&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;协商缓存，顾名思义需要和服务器进行一次协商。浏览器第一次请求时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回 304 状态码，通知客户端比较成功，可以使用缓存数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;判断请求主要靠下面两组 HTTP Header：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Last-Modified&lt;/code&gt;：一个 &lt;code&gt;Response Header&lt;/code&gt;，服务器在响应请求时，告诉浏览器资源的最后修改时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;if-Modified-Since&lt;/code&gt;：一个 &lt;code&gt;Request Header&lt;/code&gt;，再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务器会通过收到的 &lt;code&gt;If-Modified-Since&lt;/code&gt; 和资源的最后修改时间进行比对，判断是否使用缓存。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Etag&lt;/code&gt;：一个 &lt;code&gt;Response Header&lt;/code&gt;，服务器返回的资源的唯一标示&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;If-None-Match&lt;/code&gt;：一个 &lt;code&gt;Request Header&lt;/code&gt;，再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务器会通过收到的 &lt;code&gt;If-None-Match&lt;/code&gt; 和资源的唯一标识进行对比，判断是否使用缓存。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;关于缓存的常见误区&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面提到的知识估计就是平时大家最常背到的，不过大家有没有认真想过一个问题？我们取到的缓存数据，一定缓存在浏览器里面吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上是不然的：资源的缓存通常是有多级的，一些缓存专门用于单个用户，一些缓存专用于多个用户。有些是由服务器控制的，有些是由用户控制的，有些则由中介层控制。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6525198938992043&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQYYeTBiaTIV45f1RZqEDT1iaLhpyDhzc5Q30MQGFFw9oVAWWjFibKuvdIic5R1Iib2ia1gwTTwcticJfMUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2262&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;浏览器缓存：一般并专用于单个用户，在浏览器客户端中实现。它们通过避免多次获取相同的响应来提高性能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;本地代理：可能是用户自己安装的，也可能是由某个中介层管理的：比如公司的网络层或者网络提供商。本地代理通常会为多个用户缓存单个响应，这就构成了一种“公共”缓存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;源服务器缓存/CDN。由服务器控制，源服务器缓存的目标是通过为多个用户缓存相同的响应来减少源服务器的负载。CDN 的目标是相似的，但它分布在全球各个地区，然后通过分配给最近的一组用户来达到减少延迟的目的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，我们也经常会使用本地配置的代理，这些代理能够通过配置信任证书来缓存 &lt;code&gt;HTTPS&lt;/code&gt; 资源。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Spectre 漏洞&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么缓存怎么会对我们网站的安全性和用户隐私造成威胁呢？我们来看一个非常有名的漏洞：&lt;code&gt;Spectre&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQYYeTBiaTIV45f1RZqEDT1ia1uwibW7rsBGtFVKF3ibL0hOKkiaLyGQicrIZF9ibPM3VR1icfJnEicXC0xSDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;攻击者可以利用 &lt;code&gt;Spectre 漏洞&lt;/code&gt; 来读取操作系统进程的内存，这意味着可以访问到未经过授权的跨域数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;特别是在使用一些需要和计算机硬件进行交互的 API 时：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;SharedArrayBuffer (required for WebAssembly Threads)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;performance.measureMemory()&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;JS Self-Profiling API&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为此，浏览器一度禁用了 &lt;code&gt;SharedArrayBuffer&lt;/code&gt; 等高风险的 API。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个漏洞其实在我之前的多个文章中都有提到过，其实浏览器出过的很多安全策略都和它有关：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多小伙伴对它具体的攻击原理感兴趣，通过几个 &lt;code&gt;JavaScript API&lt;/code&gt; 怎么做到越权访问数据的？这个下次我会专门出个文章来讲一下。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;缓存是怎么影响 Spectre 的？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么 &lt;code&gt;Spectre&lt;/code&gt; 和缓存有啥关系呢？我们可以简单的这样理解下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们正常打开一个收到跨域限制的页面，肯定是获取不到数据的。但是如果我们的 &lt;code&gt;Cache-Control&lt;/code&gt; 设置为了 &lt;code&gt;Public&lt;/code&gt;，这份数据可能会被缓存到一个 &lt;code&gt;Public Cache&lt;/code&gt; 上（比如我们本地代理的 &lt;code&gt;Cache&lt;/code&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然我们是没有权限访问这个数据的，但是数据却被存到缓存数据库里了。一旦数据已经被存下来了，攻击者就可以利用 &lt;code&gt;Spectre&lt;/code&gt; 漏洞获取到这些缓存数据了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么为啥利用 &lt;code&gt;Spectre&lt;/code&gt; 可以越权访问到这些缓存数据呢？我们来举个简单的小例子：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，我们有个网站的登录密码是 &lt;code&gt;conardli&lt;/code&gt;，一个攻击者想要爆破我们的密码，假设我们的密码一定由小写字母组成，那攻击者也至少需要 26 的 8 次方次来猜出我们的密码。这是一个非常大的数字，几乎不可能爆破成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设，我们的密码存在了一块攻击者无权限访问到的内存里，然后攻击者自己又单独使用一块内存存储了所有的26个英文字母，并把这段内存设置为不可缓存。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44754653130287647&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQYYeTBiaTIV45f1RZqEDT1ia9Tmu8HBC4sAQcRC7kl0ice3TN7bcey0tbjptXCeaNQOiaRnVyRrdLWng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2364&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这个时候，攻击者越界访问了我们密码的存储区域，访问到了 c 这个字母，但是由于权限问题，他肯定是访问不到的，会被计算机拒绝。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4204368174726989&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQYYeTBiaTIV45f1RZqEDT1iaThMM7ObCSu5ibJeOmKwtjD9icmGSgd7oM0aV8l6Aib5bjlYV5jNfla0hA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2564&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是虽然访问不到，c 这个字母会被缓存起来。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5821347464042392&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQYYeTBiaTIV45f1RZqEDT1iavTeBvHspSG6D85MUHf7qBO2OnjRvrBC0BVBLzgPZNabXzyiayib9IWibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2642&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，攻击者再回去遍历他那 26 个字母的内存，会发现，c 的访问速度变快了 ...&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4981549815498155&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQYYeTBiaTIV45f1RZqEDT1iaBrkiaBymE13LrWpJc9RPdVZKD9WYeaNpqvSKuv2LLnEpYzIPmRtpXBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2710&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，你的密码第一个数字是 c ...&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里就简单讲一下，下篇文章我会专门来讲一下 &lt;code&gt;Spectre&lt;/code&gt; 漏洞，还是非常巧妙的 ... 感兴趣的小伙伴可以再留言区告诉我。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;网站的建议配置&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为上面的问题，我们建议对所有比较重要的网站数据做下面的两个配置：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;禁用 Public Cache&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置 &lt;code&gt;Cache-Control: private&lt;/code&gt;，这可以禁用掉所有 &lt;code&gt;Public Cache&lt;/code&gt;（比如代理），这就减少了攻击者跨界访问到公共内存的可能性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里注意，&lt;code&gt;private&lt;/code&gt; 这个值并不是一个独立的值，比如他是可以和 max-age 进行共存的，性能和 public 差不了多少，我们打开 Google 的网站来看一下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3247663551401869&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdQYYeTBiaTIV45f1RZqEDT1iac3npOhHUVmCquGUZ5KxLRibzwLicfwosa3nhyiaEDlWicCN5LBUbOASzQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;856&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;设置适当的二级缓存 key&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认情况下，我们浏览器的缓存使用 URL 和 请求方法来做缓存 key 的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这意味着，如果一个网站需要登录，不同用户的请求由于它们的请求URL和方法相同，数据会被缓存到一块内存里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这显然是有点问题，我们可以通过设置 &lt;code&gt;Vary: Cookie&lt;/code&gt; 来避免这个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当用户身份信息发生变化的时候，缓存的内存也会发生变化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，如果你的资源是一个大家都可以访问的公共 CDN 资源，那你的缓存当然是随便设置了，如果你的资源数据是比较敏感的，建议走上面这两个设置。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;https://web.dev/http-cache-security/&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://zhuanlan.zhihu.com/p/32784852&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Vary&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家有在业务里设置过缓存吗？都是怎么设置的呢？有考虑过这个问题吗？欢迎在留言区告诉我。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;296&quot; data-ratio=&quot;0.5299270072992701&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/5Q3ZxrD2qNAwfITg4YV29uSdjzeu5TianfNF4GxRloxGjYnDmsXeLeaiaxc3JplwWTTlaDU8tr50srgXqHe3Gr4Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;685&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong/&gt;&lt;strong&gt;&lt;span&gt;彦祖，&lt;/span&gt;&lt;span&gt;点个&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;「在看」&lt;/strong&gt;&lt;span&gt;吧&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d43db2e6cd1e6100bb745a1ee0a27711</guid>
<title>谷歌工程实践 | 学习笔记</title>
<link>https://toutiao.io/k/qvka8z3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;span&gt;你好，我是太白。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近公司同事作了个Code Review的分享，于是乎我系统学习了下《谷歌工程实践》，里面主要讲的是Code Review。写下本文作为笔记。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;如果觉得文章对你有帮助，记得点赞+关注+转发。目前本公号没有评论功能，有问题请联系我。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;点击下方👇🏻 关注本公众号&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg5OTcwNDc5Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/y18hkib7c4x9eqg3nPicpPPwX5QicW5GH0GDjvnLvCTOBOBqXvBDElILDVzRne2QibNY0DIV2Sg0FweAFze3K0aBog/0?wx_fmt=png&quot; data-nickname=&quot;太白技术&quot; data-alias=&quot;taibai_tech&quot; data-signature=&quot;关键词：Go语言、微服务、架构、开源项目。欢迎关注。&quot; data-from=&quot;1&quot;/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;前言&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;术语&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;代码审查者指南&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Code Review 标准&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Code Review 要点&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;查看CL的步骤&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Code Review 速度&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如何撰写 Code Review 评论&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;处理 Code Review 中的拖延&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;代码开发者指南&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;总结&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《谷歌工程实践》是 Google 团队长期以来的内部项目最佳实践。其目的是帮助开发者更好地进行代码审查工作，通过 Code Review 来提升并优化当前项目的代码质量，便于开发人员维护和维护旧项目。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管你是代码开发者还是代码的审查者都值得读一读。&lt;span&gt;本文主要是基于&lt;/span&gt;&lt;span&gt;《谷歌工程实践》&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;span&gt;，摘取了关键部分，并做了笔记和扩展。&lt;/span&gt;&lt;span&gt;建议看下英文原版&lt;/span&gt;&lt;span&gt;《Google Engineering Practices Documentation
》&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;术语&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;CL（&lt;span&gt;Change List&lt;/span&gt;）&lt;/section&gt;&lt;section&gt;表示变更列表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LGTM（&lt;span&gt;Looks Good to &lt;/span&gt;&lt;span&gt;Me&lt;/span&gt;）&lt;/section&gt;&lt;section&gt;我觉得不错。表示认可这次PR，同意merge合并代码到远程仓库。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;扩展&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;MR（&lt;span&gt;Merge Request&lt;/span&gt;）&lt;/section&gt;&lt;section&gt;合并请求，GitLab中术语。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PR（Pull Request）&lt;/section&gt;&lt;section&gt;合并请求，GitHub中术语。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CR（Code Review）&lt;/section&gt;&lt;section&gt;代码审查。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ACK（Acknowledgement）&lt;/section&gt;&lt;section&gt;我确认了或者我接受了,我承认了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;WIP（Work in progress）&lt;/section&gt;&lt;section&gt;do not merge yet.   开发中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ASAP（As Soon As Possible）&lt;/section&gt;&lt;section&gt;尽快。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TL;DR（Too Long; Didn’t Read）&lt;/section&gt;&lt;section&gt;「太长懒得看」README 文档常见。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;PTAL（Please take a look ）&lt;/section&gt;&lt;section&gt;帮我看下，一般都是请别人 review 自己的 PR。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CC（Carbon copy ）&lt;/section&gt;&lt;section&gt;一般代表抄送别人的意思。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RFC（Request for comments）&lt;/section&gt;&lt;section&gt;我觉得这个想法很好, 我们来一起讨论下。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;NACK/NAK（Negative acknowledgement）&lt;/section&gt;&lt;section&gt;不同意。i.e. disagree with change and/or concept。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RFC（Request For Comments）&lt;/section&gt;&lt;section&gt;请求进行讨论 i.e. I think this is a good idea, lets discuss。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AFAIK/AFAICT（&lt;span&gt;As Far As I Know / Can Tell &lt;/span&gt;）&lt;/section&gt;&lt;section&gt;据我所知；就我所知。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;TBR（&lt;span&gt;To Be Reviewed&lt;/span&gt;）&lt;/section&gt;&lt;section&gt;提示维护者进行 review。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩展参考&lt;span&gt;Git 团队协作常用术语&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;、&lt;span&gt;LGTM : code review 行话&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代码审查者指南&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Code Review 标准&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有 Code Review 指南中的高级原则：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;一般来说，审核人员应该倾向于批准CL，只要CL确实可以提高系统的整体代码健康状态，即使CL并不完美。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Code Review 要点&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;设计：主要是看CL整体设计是否合理，比如代码的分层是否合理等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;功能：主要看是否符合开发者的意图，并考虑到一些边缘情况，如并发问题等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;复杂度：阅读代码的人无法快速理解。还要注意过度工程（over-engineering）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;测试：确保 CL 中的测试正确，合理且有用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;命名：一个好名字应该足够长，可以完全传达项目的内容或作用，但又不会太长，以至于难以阅读。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;注释：是否所有注释都是必要的？通常，注释解释为什么某些代码存在时很有用，且不应该用来解释某些代码正在做什么。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;风格：参考&lt;span&gt;《Google Style Guides》&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt; ，里面包含Google的多种语言的风格指南。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;文档：如果 CL 变更了，请检查相关文档是否有更新。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每一行：查看分配给您审查的每行代码。如果不了解某些部分的审查，请确保 CL 上有一个合格的审查人，特别是对于安全性、并发性、可访问性、国际化等复杂问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;上下文：通常，代码审查工具只会显示变更的部分的周围的几行。有时您必须查看整个文件以确保变更确实有意义。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;好的事情：&lt;/span&gt;&lt;span&gt;比起告诉他们做错了什么，有时更有价值的是告诉开发人员他们做&lt;/span&gt;&lt;span&gt;对了什么。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;查看CL的步骤&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第一步：全面了解变更。&lt;span/&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第二步：检查 CL 的主要部分。&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通常，包含大量的逻辑变更的文件就是 CL 的主要部分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 CL 太大而无法确定哪些部分是主要部分，请向开发人员询问您应该首先查看的内容或者要求他们将 CL 拆分为多个 CL。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果在该部分发现存在一些主要的设计问题时，即使没有时间立即查看 CL 的其余部分，也应立即留下评论告知此问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第三步：以适当的顺序查看CL的其余部分。&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通常在查看主要文件之后，最简单的方法是按照代码审查工具向您提供的顺序浏览每个文件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有时在阅读主代码之前先阅读测试也很有帮助，因为这样您就可以了解该变更应当做些什么。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Code Review 速度&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么尽快进行 Code Review？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不然就会发生：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;整个团队的速度降低了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开发者开始抗议代码审查流程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;代码健康状况可能会受到影响。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Code Review 应该有多快？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您没有处于重点任务的中，那么您应该在收到代码审查后尽快开始。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;速度 vs. 中断&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果您正处于重点任务中，例如编写代码，请不要打断自己进行代码审查。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在回复审查请求之前，请等待工作中断点。可能是当你的当前编码任务完成，午餐后，从会议返回等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;快速响应&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;快速的个人响应比整个过程快速发生更为重要。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;带评论的LGTM&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了加快代码审查，在某些情况下，即使他们也在 CL 上留下未解决的评论，审查者也应该给予 LGTM/Approva。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;大型CL&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有人向您发送了代码审查太大，您不确定何时有时间查看，那么您应该要求开发者将 CL 拆分为几个较小的 CL 而不是一次审查的一个巨大的 CL。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;代码审查随时间推移而改进&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要为了提高想象中的代码审查速度，而在代码审查标准或质量方面妥协，实际上这样做对于长期来说不会有任何帮助。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;紧急情况&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CL必须非常快速地通过整个审查流程，并且质量准则将放宽。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;紧急 CL 是这样的小更新：允许主要发布继续而不是回滚，修复显著影响用户生产的错误，处理紧迫的法律问题，关闭主要安全漏洞等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何撰写 Code Review 评论&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;保持友善。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;解释你的推理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在给出明确的指示与只指出问题并让开发人员自己决定间做好平衡。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;鼓励开发人员简化代码或添加代码注释，而不仅仅是向你解释复杂性。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;礼貌&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般而言，对于那些正在被您审查代码的人，除了保持有礼貌且尊重以外，重要的是还要确保您（的评论）是非常清楚且有帮助的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;糟糕的示例&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;为什么这里你使用了线程，显然并发并没有带来什么好处？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;好的示例&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;这里的并发模型增加了系统的复杂性，但没有任何实际的性能优势，因为没有性能优势，最好是将这些代码作为单线程处理而不是使用多线程。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解释为什么&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于上面的“好”示例，您会注意到的一件事是，它可以帮助开发人员理解您发表评论的原因。并不总是需要您在审查评论中包含此信息，但有时候提供更多解释，对于表明您的意图，您在遵循的最佳实践，或为您建议如何提高代码健康状况是十分恰当的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;给予指导&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，修复 CL 是开发人员的责任，而不是审查者。您无需为开发人员详细设计解决方案或编写代码。但这并不意味着审查者应该没有帮助。一般来说，您应该在指出问题和提供直接指导之间取得适当的平衡。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;接受解释&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您要求开发人员解释一段您不理解的代码，那通常会导致他们更清楚地重写代码。偶尔，在代码中添加注释也是一种恰当的响应，只要它不仅仅是解释过于复杂的代码。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;处理 Code Review 中的拖延&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时开发人员会拖延（Pushback）代码审查。他们要么不同意您的建议，要么抱怨您太严格。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;谁是对的？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当开发人员不同意您的建议时，请先花点时间考虑一下是否正确。通常，他们比你更接近代码，所以他们可能真的对它的某些方面有更好的洞察力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时需要几轮解释一个建议才能才能让对方真正理解你的用意。只要确保始终保持礼貌，让开发人员知道你有听到他们在说什么，只是你不同意该论点而已。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;沮丧的开发者&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;审查者有时认为，如果审查者人坚持改进，开发人员会感到不安。有时候开发人员会感到很沮丧，但这样的感觉通常只会持续很短的时间，后来他们会非常感谢您在提高代码质量方面给他们的帮助。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下，如果您在评论中表现得很有礼貌，开发人员实际上根本不会感到沮丧，这些担忧都仅存在于审核者心中而已。开发者感到沮丧通常更多地与评论的写作方式有关，而不是审查者对代码质量的坚持。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;稍后清理&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经验表明，在开发人员编写原始 CL 后，经过越长的时间这种清理发生的可能性就越小。实际上，通常除非开发人员在当前 CL 之后立即进行清理，否则它就永远不会发生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，在代码进入代码库并“完成”之前，通常最好坚持让开发人员现在清理他们的 CL。让人们“稍后清理东西”是代码库质量退化的常见原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 CL 引入了新的复杂性，除非是紧急情况，否则必须在提交之前将其清除。如果 CL 暴露了相关的问题并且现在无法解决，那么开发人员应该将 bug 记录下来并分配给自己，避免后续被遗忘。又或者他们可以选择在程序中留下 TODO 的注释并连结到刚记录下的 bug。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;关于严格性的抱怨&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您以前有相当宽松的代码审查，并转而进行严格的审查，一些开发人员会抱怨得非常大声。通常提高代码审查的速度会让这些抱怨逐渐消失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时，这些投诉可能需要数月才会消失，但最终开发人员往往会看到严格的代码审查的价值，因为他们会看到代码审查帮助生成的优秀代码。而且一旦发生某些事情时，最响亮的抗议者甚至可能会成为你最坚定的支持者，因为他们会看到审核变严格后所带来的价值。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解决冲突&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果上述所有操作仍无法解决您与开发人员之间的冲突，请参阅 “Code Review 标准”以获取有助于解决冲突的指导和原则。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代码开发者指南&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;写好 CL 描述&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CL 描述是进行了哪些更改以及为何更改的公开记录。CL 将作为版本控制系统中的永久记录，可能会在长时期内被除审查者之外的数百人阅读。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;首行&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;正在做什么的简短摘要。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;完整的句子，使用祈使句。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;后面跟一个空行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Body 是信息丰富的&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其余描述应该是提供信息的。可能包括对正在解决的问题的简要描述，以及为什么这是最好的方法。如果方法有任何缺点，应该提到它们。如果相关，请包括背景信息，例如错误编号，基准测试结果以及设计文档的链接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使是小型 CL 也需要注意细节。在 CL 描述中提供上下文以供参照。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;糟糕的 CL 描述&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“Fix bug ”是一个不充分的 CL 描述。什么 bug？你做了什么修复？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他类似的不良描述包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;“Fix build.”&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“Add patch.”&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“Moving code from A to B.”&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“Phase 1.”&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“Add convenience functions.”&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;“kill weird URLs.”&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中一些是真正的 CL 描述。他们的作者可能认为自己提供了有用的信息，却没有达到 CL 描述的目的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;好的 CL 描述&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下是一些很好的描述示例。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;功能变化例子：&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;rpc：删除 RPC 服务器消息空闲列表的大小限制。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;像 FizzBuzz 这样的服务器有非常大的消息，并且可以从重用中受益。使 freelist 更大，并添加一个 goroutine，随着时间的推移缓慢释放 freelist 条目，以便空闲服务器最终释放所有 freelist 条目。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前几个词描述了 CL 的实际作用。描述的其余部分讨论了正在解决的问题，为什么这是一个好的解决方案，以及有关具体实现的更多信息。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;重构例子：&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;使用 TimeKeeper 构造一个 Task 以使用其 TimeStr 和 Now 方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;给Task添加一个Now方法，这样borglet()的getter方法就可以被移除了（它只被OOMCandidate用来调用borglet的Now方法）。这替换了 Borglet 上委托给 TimeKeeper 的方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;允许 Tasks 提供 Now 是消除对 Borglet 依赖的一步。最终，依赖于从 Task 获取 Now 的协作者应
该改为直接使用 TimeKeeper，但这是对小步骤重构的一种适应。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;继续重构 Borglet Hierarchy 的长期目标。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一行描述了 CL 的作用以及与过去相比的变化。描述的其余部分讨论了具体的实现、CL 的上下文、解决方案并不理想以及可能的未来方向。它还解释了为什么要进行这种更改。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;需要一些上下文的小型 CL例子：&lt;span/&gt;&lt;/h5&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;为 status.py 创建一个 Python3 构建规则。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这允许已经在 Python3 中使用它的消费者依赖于原始状态构建规则旁边的规则，而不是他们自己树中的某个位置。它鼓励新消费者尽可能使用 Python3，而不是 Python2，并显着简化当前正在开发的一些自动构建文件重构工具。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一句话描述了实际正在做的事情。描述的其余部分解释了为什么要进行更改，并为审阅者提供了很多背景信息。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小型 CL&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么提交小型 CL?&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小且简单的 CL 是指：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;审查更快&lt;/strong&gt;。审查者更容易抽多次五分钟时间来审查小型 CL，而不是留出 30 分钟来审查一个大型 CL。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;审查得更彻底&lt;/strong&gt;。如果是大的变更，审查者和提交者往往会因为大量细节的讨论翻来覆去而感到沮丧——有时甚至到了重要点被遗漏或丢失的程度。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;不太可能引入错误&lt;/strong&gt;。由于您进行的变更较少，您和您的审查者可以更轻松有效地推断 CL 的影响，并查看是否已引入错误。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;如果被拒绝，减少浪费的工作&lt;/strong&gt;。如果您写了一个巨大的 CL，您的评论者说整个 CL 的方向都错误了，你就浪费了很多精力和时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;更容易合并&lt;/strong&gt;。处理大型 CL 需要很长时间，在合并时会出现很多冲突，并且必须经常合并。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;更容易设计好&lt;/strong&gt;。打磨一个小变更的设计和代码健康状况比完善一个大变更的所有细节要容易得多。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;减少对审查的阻碍&lt;/strong&gt;。发送整体变更的自包含部分可让您在等待当前 CL 审核时继续编码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;更简单的回滚&lt;/strong&gt;。大型 CL 更有可能触及在初始 CL 提交和回滚 CL 之间更新的文件，从而使回滚变得复杂（中间的 CL 也可能需要回滚）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是小型 CL？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，CL 的正确大小是自包含的变更。这意味着：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;CL 进行了一项最小的变更，只解决了一件事。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;审查者需要了解的关于 CL 的所有内容（除了未来的开发）都在 CL 的描述、现有的代码库或已经审查过的 CL 中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对其用户和开发者来说，在签入 CL 后系统能继续良好的工作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CL 不会过小以致于其含义难以理解。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于多大算“太大”没有严格的规则。对于 CL 来说，100 行通常是合理的大小，1000 行通常太大，但这取决于您的审查者的判断。变更中包含的文件数也会影响其“大小”。一个文件中的 200 行变更可能没问题，但是分布在 50 个文件中通常会太大。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么时候大 CL 是可以的？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在某些情况下，大变更也是可以接受的：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;您通常可以将整个文件的删除视为一行变更，因为审核人员不需要很长时间审核。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有时一个大的 CL 是由您完全信任的自动重构工具生成的，而审查者的工作只是检查并确定想要这样的变更。但这些 CL 可以更大，尽管上面的一些警告（例如合并和测试）仍然适用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;分离出重构&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常最好在功能变更或错误修复的单独 CL 中进行重构。例如，移动和重命名类应该与修复该类中的错误的 CL 不同。审查者更容易理解每个 CL 在单独时引入的更改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，修复本地变量名称等小清理可以包含在功能变更或错误修复 CL 中。如果重构大到包含在您当前的 CL 中，会使审查更加困难的话，需要开发者和审查者一起判断是否将其拆开。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;将相关的测试代码保存在同一个 CL 中&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;避免将测试代码拆分为单独的 CL。验证代码修改的测试应该进入相同的 CL，即使它增加了代码行数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，独立的测试修改可以首先进入单独的 CL，类似于重构指南。包括：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用新测试验证预先存在的已提交代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重构测试代码（例如引入辅助函数）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引入更大的测试框架代码（例如集成测试）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;不要破坏构建&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您有几个相互依赖的 CL，您需要找到一种方法来确保在每次提交 CL 后整个系统能够继续运作。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;如果不能让它足够小&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时你会遇到看起来您的 CL 必须如此庞大，但这通常很少是正确的。习惯于编写小型 CL 的提交者几乎总能找到将功能分解为一系列小变更的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在编写大型 CL 之前，请考虑在重构 CL 之前是否可以为更清晰的实现铺平道路。与你的同伴聊聊，看看是否有人想过如何在小型 CL 中实现这些功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果以上的努力都失败了（这应该是非常罕见的），那么请在事先征得审查者的同意后提交大型 CL，以便他们收到有关即将发生的事情的警告。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何处理审查者的评论&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当您发送 CL 进行审查时，您的审查者可能会对您的 CL 发表一些评论。以下是处理审查者评论的一些有用信息。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;不是针对您&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;审查的目标是保持代码库和产品的质量。当审查者对您的代码提出批评时，请将其视为在帮助您、代码库，而不是对您或您的能力的个人攻击。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;永远不要愤怒地回应代码审查评论。这严重违反了专业礼仪且将永远存在于代码审查工具中。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;修复代码&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果审查者说他们不了解您的代码中的某些内容，那么您的第一反应应该是澄清代码本身。如果无法澄清代码，请添加代码注释，以解释代码存在的原因。只有在想增加的注释看起来毫无意义时，您才能在代码审查工具中进行回复与解释。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果审查者不理解您的某些代码，那么代码的未来读者可能也不会理解。在代码审查工具中回复对未来的代码读者没有帮助，但澄清代码或添加代码注释确可以实实在在得帮助他们。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;自我反思&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编写 CL 可能需要做很多工作。在终于发送一个 CL 用于审查后，我们通常会感到满足的，认为它已经完成，并且非常确定不需要进一步的工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这通常是令人满意的。因此，当审查者回复对可以改进的事情的评论时，很容易本能地认为评论是错误的，审查者正在不必要地阻止您，或者他们应该让您提交 CL。但是，无论您目前多么确定，请花一点时间退一步，考虑审查者是否提供有助于对代码库和公司有价值的反馈。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解决冲突&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决冲突的第一步应该是尝试与审查者达成共识。如果您无法达成共识，请参阅“代码审查标准”，该标准提供了在这种情况下遵循的原则。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代码审查者视角&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;以制定审核标准为前提，尽可能快速、及时的反馈代码开发者的合并请求。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对于评论要保持友善、提供引导，以最终代码质量、公司价值为导向。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;做好沟通，有疑问及时沟通、接受解释。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;代码开发者视角&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;写好CL的描述。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;提供小的CL、相关测试代码不分离、重构代码分离、不破坏构建。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;以代码质量、公司价值为结果导向，及时修复、做好沟通。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;《谷歌工程实践》: &lt;em&gt;https://jimmysong.io/eng-practices/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;《Google Engineering Practices Documentation
》: &lt;em&gt;https://github.com/google/eng-practices&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;Git 团队协作常用术语: &lt;em&gt;https://blog.csdn.net/qq_15988951/article/details/108331701&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;LGTM : code review 行话: &lt;em&gt;&quot;https://blog.csdn.net/weixin_41287260/article/details/108676433&quot;&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;《Google Style Guides》: &lt;em&gt;https://google.github.io/styleguide/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>492648e91b5b0f73105be2abc7dbcc42</guid>
<title>2022 年升职加薪就靠它了！抓紧时间！</title>
<link>https://toutiao.io/k/i6bb1wf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;码农周刊是什么？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;span&gt;码农周刊VIP会员&lt;/span&gt;」服务。&lt;br/&gt;&lt;strong&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;如何加入「码农周刊VIP会员」？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;391&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;425&quot; data-ratio=&quot;1.3478260869565217&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ6elqZKJKdKVMrGKUKjLwPpIFaDmrXyf1iaRtelGc6Fm6W4vp1uEAbb7Nz7QuBzxXNW96CiauDAL3Aw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;心动不如心动，赶快订阅吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>