<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>11ad6585985f065e64a61f4466164e40</guid>
<title>首个确保缓存与数据库一致性的方案</title>
<link>https://toutiao.io/k/imjqbp3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;h2 tabindex=&quot;-1&quot;&gt;概述&lt;/h2&gt;&lt;p&gt;大量的实际的项目中，都会引入 Redis 缓存来缓解数据库的查询压力，此时由于一个数据在 Redis 和数据库两处进行了存储，就会有数据一致性的问题。目前业界尚未见到成熟的能够确保最终一致性的方案，特别是当如下场景发生时，会直接导致缓存数据与数据库数据不一致。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7247579529737206&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_svg/VNDQtnw16icLecJiaHcUyhQMmfTjtEA2RTUnhHD4uV0F3rd64YmWyhKB09sl2FdPHyUibdMpSV5xkXf60s4vcticDDKniaHqCc284/640?wx_fmt=svg&quot; data-type=&quot;svg&quot; data-w=&quot;723&quot;/&gt;&lt;/p&gt;&lt;p&gt;在上述场景下，缓冲中的数据最终版本为v1，而数据库的最终版本为v2，可能给应用带来较大问题。&lt;/p&gt;&lt;p&gt;dtm-labs 致力于解决数据一致性问题，在分析了行业的现有做法后，提出了新解决方案dtm + rockscache，彻底解决了上述问题。另外作为一个成熟方案，该方案还可以防缓存穿透，防缓存击穿，防缓存雪崩，同时也可应用于要求数据强一致的场景。&lt;/p&gt;&lt;p&gt;关于管理缓存的现有方案，本文不再赘述，不太了解的同学可以参考下面这两篇文章&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;乱序产生的不一致&lt;/h2&gt;&lt;p&gt;在上述这个时序图中，由于服务1发生了进程暂停（例如由于GC导致），因此当它往缓存当中写入v1时，覆盖了缓存中的v2，导致了最终的不一致（DB中为v2，缓存中为v1）。&lt;/p&gt;&lt;p&gt;对于上述这类问题应当如何解决？目前现存的方案，全都没有彻底解决该问题，一般都是通过设定稍短的过期时间兜底。我们实现的缓存延迟删除方案，能够彻底解决这个问题，确保缓存与数据库之间的数据保持一致。解决原理如下：&lt;/p&gt;&lt;p&gt;缓存中的数据是一个hash，里面有以下几个字段：&lt;/p&gt;&lt;p&gt;查询缓存时：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;如果数据为空，且被锁定，则睡眠1s后，重新查询&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果数据为空，且未被锁定，同步执行&quot;取数据&quot;，返回结果&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果数据不为空，那么立即返回结果，并异步执行&quot;取数据&quot;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;其中&quot;取数据&quot;的操作定义为：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;判断是否需要更新缓存，下面两个条件满足其一，则需要更新缓存&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;如果需要更新，则锁定缓存，查询DB，校验锁持有者无变化，写入缓存，解锁缓存&lt;/p&gt;&lt;/li&gt;&lt;p&gt;当DB数据更新时，通过dtm确保数据更新成功时，将缓存延迟删除（将在后面一节展开详细讲解）&lt;/p&gt;&lt;p&gt;在上述的策略下：假如最后写入数据库的版本为Vi，最后写入到缓存的版本为V，写入V的uuid为uuidv，那么一定存在以下事件序列：&lt;/p&gt;&lt;p&gt;数据库写入Vi -&amp;gt; 缓存数据被标记为删除 -&amp;gt; 某个查询锁定数据并写入uuidv -&amp;gt; 查询数据库结果V -&amp;gt; 缓存中的锁定者为uuidv，写入结果V&lt;/p&gt;&lt;p&gt;在这个序列中，V的读取发生在写入Vi之后，所以V等于Vi，保证了缓存的数据的最终一致性。&lt;/p&gt;&lt;p&gt;dtm-labs/rockscache已经实现了上述方法，能够确保缓存数据的最终一致性。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;Fetch&lt;/code&gt;函数实现了前面的查询缓存&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;DelayDelete&lt;/code&gt;函数实现了延迟删除逻辑&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;感兴趣的同学，可以参考dtm-cases/cache，里面有详细的例子&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;DB与缓存操作的原子性&lt;/h2&gt;&lt;p&gt;对于缓存的管理，一般业界会采用写完数据库后，删除/更新缓存数据的策略。由于保存到缓存和保存到数据库两个操作之间不是原子的，一定会有时间差，因此这两个数据之间会有一个不一致的时间窗口，通常这个窗口不大，影响较小。但是两个中间可能发生宕机，也可能发生各种网络错误，因此就有可能发生完成了其中一个，但是未完成另一个，导致数据会出现长时间不一致。&lt;/p&gt;&lt;p&gt;举一个场景来说明上述不一致的情况，数据用户将数据 A 修改为 B ，应用修改完数据库之后，再去删除/更新缓存，如果未发生异常，那么数据库和缓存的数据是一致的，没有问题。但是分布式系统中，可能会发生进程crash、宕机等事件，因此如果更新完数据库，尚未删除/更新缓存时，出现进程crash，那么数据库和缓存的数据就可能出现长时间的不一致。&lt;/p&gt;&lt;p&gt;面对这里的长时间不一致的情况，想要彻底解决，并不是一件容易的事，我们下面分各种应用情况来介绍解决方案。&lt;/p&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;方案一：较短的缓存时间&lt;/h4&gt;&lt;p&gt;这个方案，是最简单的方案，适合并发量不大应用。如果应用的并发不高，那么整个缓存系统，只需要设置了一个较短的缓存时间，例如一分钟。这种情况下数据库需要承担的负载是：大约每一分钟，需要将访问到的缓存数据全部生成一遍，在并发量不大的情况下，这种策略是可行的。&lt;/p&gt;&lt;p&gt;上述这种策略非常简单，易于理解和实现，缓存系统提供的语义是，大多数情况下，缓存和数据库之间不一致的时间窗口是很短的，在较低概率发生进程crash的情况下，不一致的时间窗口会达到一分钟。&lt;/p&gt;&lt;p&gt;应用在上述约束下，需要将一致性要求不高的数据读取，从缓存读取；而将一致性要求较高的读，不走缓存，直接从数据库查询。&lt;/p&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;方案二：消息队列保证一致&lt;/h4&gt;&lt;p&gt;假如应用的并发量很高，缓存过期时间需要比一分钟更长，而且应用中的大量请求不能够容忍较长时间的不一致，那么这个时候，可以通过使用消息队列的方式，来更新缓存。具体的做法是：&lt;/p&gt;&lt;p&gt;这种做法可以保证数据库更新之后，缓存一定会被更新。但这种这种架构方案很重，这几个部分开发维护成本都不低：消息队列的维护；高效轮询任务的开发与维护。&lt;/p&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;方案三：订阅 binlog&lt;/h4&gt;&lt;p&gt;这个方案适用场景与方案二非常类似，原理又与数据库的主从同步类似，数据库的主从同步是通过订阅binlog，将主库的更新应用到从库上，而这个方案则是通过订阅binlog，将数据库的更新应用到缓存上。具体做法是：&lt;/p&gt;&lt;p&gt;这种方案也可以保证数据库更新之后，缓存一定会被更新，但是这种架构方案跟前面的消息队列方案一样，也非常重。一方面 canal 的学习维护成本不低，另一方面，开发者可能只需要少量数据更新缓存，通过订阅所有的 binlog 来做这个事情，浪费了很多资源。&lt;/p&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;方案四：dtm 二阶段消息方案&lt;/h4&gt;&lt;p&gt;dtm 里的二阶段消息模式，非常适合这里的修改数据库之后更新/删除缓存，主要代码如下：&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20534458509142053&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9m9OfQX94VstsDlZWn1DicInYoJUPQe5tXCbBk3NHJaZDVfiatcHOJZMQPDlkcU4y3byGmP3z8Uk9eGxThodsvLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1422&quot;/&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;这段代码，DoAndSubmitDB会进行本地数据库操作，进行数据库的数据修改，修改完成后，会提交一个二阶段消息事务，消息事务将会异步调用 UpdateRedis。假如本地事务执行之后，就立刻发生了进程 crash 事件，那么 dtm 会进行回查调用 QueryPrepared ，保证本地事务提交成功的情况下，UpdateRedis 会被最少成功执行一次。&lt;/p&gt;&lt;p&gt;回查的逻辑非常简单，只需要copy类似下面这样的代码即可：&lt;code&gt;&lt;br/&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.10909090909090909&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9m9OfQX94VstsDlZWn1DicInYoJUPQe5tMiawYOaDlQpCM03XQRekicRL3Xds9hMSYuolZqA9wVPm2aSaib6uCKoIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1430&quot;/&gt;&lt;/p&gt;&lt;p&gt;这种方案的优点：&lt;/p&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;从库延时&lt;/h4&gt;&lt;p&gt;上述的方案中，假定缓存删除后，服务进行数据查询，总是能够查到最新的数据。但是实际的生产环境中，可能会出现主从分离的架构，而主从延时并不是一个可控的变量，那么这时候又要怎么处理？&lt;/p&gt;&lt;p&gt;处理方案两种：一是区分最终一致性很高和不高的缓存数据，查询数据时，将要求很高的数据必须从主库读取，而把要求不高的数据从从库读取。对于使用了rockscache的应用来说，高并发的请求都会在Redis这一层被拦截，对于一个数据，最多只会有一个请求到达数据库，因此数据库的负载已大幅降低，采用主库读取是一个实际可行的方案。&lt;/p&gt;&lt;p&gt;另一种方案是，主从分离需要采用不分叉的单链架构，那么链条末尾的从库必定是延迟最长的从库，此时采用监听binlog的方案，需要监听链条做末端的从库binlog，当收到数据变更通知时，按照上述方案将缓存标记为延迟删除。&lt;/p&gt;&lt;p&gt;这两个方案各有优缺点，业务可以根据自己的特点采用。&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;防缓存击穿&lt;/h2&gt;&lt;p&gt;rockscache还可以防缓存击穿。当数据变更时，业界现有做法既可以选择更新缓存，也可以选择删除缓存，各有优劣。而延迟删除综合了两种方法的优势，并克服了两种方法的劣势：&lt;/p&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;更新缓存&lt;/h4&gt;&lt;p&gt;采取更新缓存策略，那么会为所有的DB数据更新生成缓存，不区分冷热数据，那么会存在以下问题：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;内存上，即使一个数据没有被读取，也会保存在缓存里，浪费了宝贵的内存资源；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在计算上，即使一个数据没有被读取，也可能因为多次更新，被多次计算，浪费了宝贵的计算资源。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;上述的乱序不一致发生的概率会较高，当两个临近的更新中出现延迟，就可能触发。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;删除缓存&lt;/h4&gt;&lt;p&gt;因为前面的更新缓存做法问题较多，因此大多数的实践采用的是删除缓存策略，查询时再按需生成缓存。这种做法解决了更新缓存中的问题，但是又带来新问题：&lt;/p&gt;&lt;p&gt;为了防止缓存击穿，通用的做法是使用分布式 Redis 锁保证只有一个请求到数据库，等缓存生成之后，其他请求进行共享。这种方案能够适合很多的场景，但有些场景却不适合。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;例如有一个重要的热点数据，计算代价比较高，需要3s才能够获得结果，那么上述方案在删除一个这种热点数据之后，就会在这个时刻，有大量请求3s才返回结果，一方面可能造成大量请求超时，另一方面3s没有释放链接，会导致并发连接数量突然升高，可能造成系统不稳定。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;另外使用 Redis 锁时，未获得锁的这部分用户，通常会定时轮询，而这个睡眠时间不好设定。如果设定比较大的睡眠时间1s，那么对于10ms就计算出结果的缓存数据，返回太慢了；如果设定的睡眠时间太短，那么很消耗 CPU 和 Redis 性能&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;延迟删除法的应对策略&lt;/h4&gt;&lt;p&gt;前面介绍的dtm-labs/rockscache实现的延时删除法也属于删除法，但它彻底解决了删除缓存中的击穿问题，以及击穿带来的附带问题。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;缓存击穿问题：延迟删除法中，如果缓存中的数据不存在，那么会锁定缓存中的这条数据，因此避免了多个请求打到后端数据库。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;上述大量请求3s才返回数据，以及定时轮询的问题，在延时删除中也不存在，因为热点数据被延时删除时，旧版本的数据还在缓存中，会被立即返回，无需等待。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们来看看不同的数据访问频率下，延迟删除法的表现如何：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;热点数据，每秒1K qps，计算缓存时间5ms，此时延迟删除法，大约5~8ms左右的时间里，会返回过期数据，而先更新DB，再更新缓存，因为更新缓存需要时间，也会有大约0~3ms返回过期数据，因此两者差别不大。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;热点数据，每秒1K qps，计算缓存时间3s，此时延迟删除法，大约3s的时间里，会返回过期数据。对比于等待3s后再返回数据，那么返回旧数据，通常是更好的行为。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;普通数据，每秒50 qps，计算缓存时间1s，此时延迟删除法的行为分析，类似2，没有问题。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;低频数据，5秒访问一次，计算缓存时间3s，此时延迟删除法的行为与删除缓存策略基本一样，没有问题&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;冷数据，10分钟访问一次，此时延迟删除法，与删除缓存策略基本一样，只是数据比删除缓存的方式多保存10s，占用空间不大，没有问题&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;有一种极端情况是，那就是原先缓存中没有数据，突然大量请求到来，这种场景对，更新缓存法删除缓存法，延迟删除法，都是不友好的。这种的场景是开发人员需要避免的，需要通过预热来解决，而不应当直接扔给缓存系统。当然，由于延迟删除法已经把打到数据库的请求量降到最低，因此表现也不弱于任何其他方案。&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;防缓存穿透与缓存雪崩&lt;/h2&gt;&lt;p&gt;dtm-labs/rockscache还实现了防缓存穿透与缓存雪崩。&lt;/p&gt;&lt;p&gt;缓存穿透是指，缓存和数据库都没有的数据，被大量请求。由于数据不存在，缓存就也不会存在该数据，所有的请求都会直接穿透到数据库。rockscache中可以设定&lt;code&gt;EmptyExipire&lt;/code&gt;设定对空结果的缓存时间，如果设定为0，那么不缓存空数据，关闭防缓存穿透&lt;/p&gt;&lt;p&gt;缓存雪崩是指缓存中有大量的数据，在同一个时间点，或者较短的时间段内，全部过期了，这个时候请求过来，缓存没有数据，都会请求数据库，则数据库的压力就会突增，扛不住就会宕机。rockscache可以设定&lt;code&gt;RandomExpireAdjustment&lt;/code&gt;，对过期时间加上随机值，避免同时过期。&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;应用能否做到强一致？&lt;/h2&gt;&lt;p&gt;上面已经介绍了缓存一致性的各种场景，以及相关的解决方案，那么是否可以保证使用缓存的同时，还提供强一致的数据读写呢？强一致的读写需求比前面的最终一致的需求场景少，但是在金融领域，也是有不少场景的。&lt;/p&gt;&lt;p&gt;当我们在这里讨论强一致时，我们需要先把一致性的含义做一下明确。&lt;/p&gt;&lt;p&gt;开发者最直观的强一致性很可能理解为，数据库和缓存保持完全一致，写数据的过程中以及写完之后，无论从数据库直接读，或者从缓存直接读，都能够获得最新写入的结果。对于这种两个独立系统之间的“强一致性”，可以非常明确的说，理论上是不可能的，因为更新数据库和更新缓存在不同的机器上，无法做到同时更新，无论如何都会有时间间隔，在这个时间间隔里，一定是不一致的。&lt;/p&gt;&lt;p&gt;但是应用层的强一致性，则是可以做到的。可以简单考虑我们熟悉的场景：CPU的缓存作为内存的缓存，内存作为磁盘的缓存，这些都是缓存的场景，从来没有发生过一致性问题。为什么？其实很简单，要求所有的数据使用方，只能够从缓存读取数据，而不能同时从缓存和底层存储同时读取数据。&lt;/p&gt;&lt;p&gt;对于DB和Redis，如果所有的数据读取，只能够由缓存提供，就可以很容易的做到强一致，不会出现不一致的情况。下面我们来根据DB和Redis的特点，来分析其中的设计：&lt;/p&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;先更新缓存还是DB&lt;/h4&gt;&lt;p&gt;类比CPU缓存与内存，内存缓存与磁盘，这两个系统都是先修改缓存，再修改底层存储，那么到了现在的DB缓存场景是否也先修改缓存再修改DB？&lt;/p&gt;&lt;p&gt;在绝大多数的应用场景下，开发者会认为Redis作为缓存，当Redis出现故障时，那么应用需要支持降级处理，依旧能够访问数据库，提供一定的服务能力。考虑这种场景，一旦出现降级，先写缓存再写DB方案就有问题，一方面会丢失数据，另一方面会发生先读取到缓存中的新版本v2，再读取到旧版本v1。因此在Redis作为缓存的场景下，绝大部分系统会采取先写入DB，再写入缓存的这种设计&lt;/p&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;写入DB成功缓存失败情况&lt;/h4&gt;&lt;p&gt;假如因为进程crash，导致写入DB成功，但是标记延迟删除第一次失败怎么办？虽然间隔几秒之后，会重试成功，但这几秒钟的时间里，用户去读取缓存，依旧还是旧版本的数据。例如用户发起了一笔充值，资金已经进入到DB，只是更新缓存失败，导致从缓存看到的余额还是旧值。这种情况的处理很简单，用户充值时，写入DB成功时，应用不要给用户返回成功，而是等缓存更新也成功了，再给用户返回成功；用户查询充值交易时，要查询DB和缓存是否都成功了（可以查询二阶段消息全局事务是否已成功），只有两者都成功了，才返回成功。&lt;/p&gt;&lt;p&gt;在上述的处理策略下，当用户发起充值后，在缓存更新完成之前，用户看到的是，这笔交易还在处理中，结果未知，此时是符合强一致要求的；当用户看到交易已经处理成功，也就是缓存已更新成功，那么所有从缓存中拿到的数据都是更新后的数据，那么也符合强一致的要求。&lt;/p&gt;&lt;p&gt;dtm-labs/rockscache也实现了强一致的读取需求。当打开&lt;code&gt;StrongConsistency&lt;/code&gt;选项，那么rockscache里&lt;code&gt;Fetch&lt;/code&gt;函数就提供了强一致的缓存读取。其原理与延迟删除差别不大，仅做了很小的改变，就是不再返回旧版本的数据，而是同步等待“取数据”的最新结果&lt;/p&gt;&lt;p&gt;当然这个改变会带来性能上的下降，对比与最终一致的数据读取，强一致的读取一方面要等待当前“取数据”的最新结果，增加了返回延迟，另一方面要等待其他进程的结果，会产生sleep等待，耗费资源。&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;缓存降级升级中的强一致&lt;/h2&gt;&lt;p&gt;上述的强一致方案中，说明了其强一致的前提是：“所有的数据读取，只能够由缓存”。不过如果Redis如果发生故障，需要进行降级，那么降级的过程可能很短只有几秒，但是这个几秒内如果不能接受不可访问，还严苛的要求提供访问的话，就会出现读取缓存和读取DB混用情况，就不满足这个前提。不过因为Redis故障的频率不高，要求强一致性的应用通常配备专有Redis，因此遇见故障降级的概率很低，很多应用不会在这个地方提出苛刻的要求。&lt;/p&gt;&lt;p&gt;不过dtm-labs作为数据一致性领域的领导者，也深入研究了这个问题，并给出这种苛刻条件下的解决方案。&lt;/p&gt;&lt;h4 tabindex=&quot;-1&quot;&gt;升降级的过程&lt;/h4&gt;&lt;p&gt;现在我们来考虑应用在Redis缓存出现问题的升降级处理。一般情况下这个升降级的开关在配置中心，当修改配置后，各个应用进程会陆续收到降级配置变更通知，然后在行为上降级。在降级的过程中，会出现缓存与DB混合访问的情况，这时我们上面的方案就有可能出现不一致。那么如何处理才能够保证在这种混合访问的情况下，依旧能够让应用获取到强一致的结果呢？&lt;/p&gt;&lt;p&gt;混合访问的过程中，我们可以采取下面这个策略，来保证DB和缓存混合访问时的数据一致性。&lt;/p&gt;&lt;p&gt;这个策略跟前面不考虑降级场景的强一致方案，差别不大，读数据部分完全不变，需要变的是更新数据。rockscache假定更新DB是一个业务上可能失败的操作，于是采用一个SAGA事务来保证原子操作，详情参见例子dtm-cases/cache&lt;/p&gt;&lt;p&gt;升降级的开启关闭有顺序要求，不能够同时开启缓存读和写，而是需要在开启缓存读的时候，所有的写操作都已经确保会更新缓存。&lt;/p&gt;&lt;p&gt;降级的详细过程如下：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;最初状态：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;读降级：&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;读：关闭缓存读。混合读 =&amp;gt; 全部DB读&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;写：DB+缓存&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;写降级：&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;读：全部DB读；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;写：关闭缓存写。DB+缓存 =&amp;gt; 只写DB&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;升级的过程与此相反，如下：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;最初状态：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;写升级：&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;读：全部读DB&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;写：打开写缓存。只写DB =&amp;gt; 写DB+缓存&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;读升级：&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;读：部分读缓存。全部读DB =&amp;gt; 混合读&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;写：写DB+缓存&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;dtm-labs/rockscache已实现了上述强一致的缓存管理方法。&lt;/p&gt;&lt;p&gt;感兴趣的同学，可以参考dtm-cases/cache，里面有详尽的例子&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;小结&lt;/h2&gt;&lt;p&gt;这篇文章很长，许多的分析比较晦涩，最后将Redis缓存的使用方式做个总结：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;最简单的方式为：较短的缓存时间，允许少量数据库修改，未同步删除缓存&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;保证最终一致，并且可防缓存击穿的方式为：二阶段消息+延迟删除(rockscache)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;强一致：二阶段消息+强一致(rockscache)&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;一致性要求最严苛的方式为：二阶段消息+强一致(rockscache)+升降级兼容&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;对于后两种方式，我们都推荐使用dtm-labs/rockscache来作为您的缓存方案&lt;/p&gt;&lt;h2&gt;联系我们&lt;/h2&gt;&lt;p&gt;欢迎访问我们的项目，并star支持我们：&lt;/p&gt;&lt;p&gt;https://github.com/dtm-labs/dtm&lt;/p&gt;&lt;p&gt;https://github.com/dtm-labs/rockscache&lt;/p&gt;&lt;p&gt;关注【分布式事务】公众号，获得更多分布式事务相关知识&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIwNzQ2NzMyNg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/9m9OfQX94Vv04GUcaMFCzcfHeGnTECibTEibP26ByiaHcdD7qYLNFAyQcDvbVBerQs55hXppwia3XpPjIYF3MKGzVQ/0?wx_fmt=png&quot; data-nickname=&quot;分布式事务&quot; data-alias=&quot;wangxiyan0901&quot; data-signature=&quot;介绍分布式事务相关理论与实践知识。 开源项目dtm-labs/dtm的相关信息发布。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7bedebd8d9217f9aaf7b170ebd05c3c7</guid>
<title>你见过哪些目瞪口呆的 Java 代码技巧？</title>
<link>https://toutiao.io/k/avsba7r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;来源：blog.csdn.net/zl1zl2zl3/article/details/85196627&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;技术点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开发工具&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Bean&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Bean 的验证&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;拥抱 lombok&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;重构&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设计模式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;技能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;总结&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;技术点&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文不是一个吹嘘的文章，不会讲很多高深的架构，相反，会讲解很多基础的问题和写法问题，如果读者自认为基础问题和写法问题都是不是问题，那请忽略这篇文章，节省出时间去做一些有意义的事情。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;开发工具&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道有多少”老”程序员还在使用 Eclipse，这些程序员们要不就是因循守旧，要不就是根本就不知道其他好的开发工具的存在，Eclipse 吃内存卡顿的现象以及各种偶然莫名异常的出现，都告知我们是时候寻找新的开发工具了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;更换 IDE&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根本就不想多解释要换什么样的 IDE，如果你想成为一个优秀的 Java 程序员，请更换 IntelliJ IDEA。使用 IDEA 的好处，请搜索谷歌。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;别告诉我快捷键不好用&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更换 IDE 不在我本文的重点内容中，所以不想用太多的篇幅去写为什么更换IDE。在这里，我只能告诉你，更换 IDE 只为了更好、更快的写好 Java 代码。原因略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;别告诉我快捷键不好用，请尝试新事物。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Bean&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;bean 使我们使用最多的模型之一，我将以大篇幅去讲解 bean，希望读者好好体会。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;domain 包名&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据很多 Java 程序员的”经验”来看，一个数据库表则对应着一个 domain 对象，所以很多程序员在写代码时，包名则使用：com.xxx.domain ，这样写好像已经成为了行业的一种约束，数据库映射对象就应该是 domain。但是你错了，domain 是一个领域对象，往往我们再做传统 Java 软件 Web 开发中，这些 domain 都是贫血模型，是没有行为的，或是没有足够的领域模型的行为的，所以，以这个理论来讲，这些 domain 都应该是一个普通的 entity 对象，并非领域对象，所以请把包名改为:com.xxx.entity。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你还不理解我说的话，请看一下 Vaughn Vernon 出的一本叫做《IMPLEMENTING DOMAIN-DRIVEN DESIGN》(实现领域驱动设计)这本书，书中讲解了贫血模型与领域模型的区别，相信你会受益匪浅。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;DTO&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据传输我们应该使用 DTO 对象作为传输对象，这是我们所约定的，因为很长时间我一直都在做移动端 API 设计的工作，有很多人告诉我，他们认为只有给手机端传输数据的时候(input or output)，这些对象成为 DTO 对象。请注意！这种理解是错误的，只要是用于网络传输的对象，我们都认为他们可以当做是 DTO 对象，比如电商平台中，用户进行下单，下单后的数据，订单会发到 OMS 或者 ERP 系统，这些对接的返回值以及入参也叫 DTO 对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们约定某对象如果是 DTO 对象，就将名称改为 XXDTO，比如订单下发OMS：OMSOrderInputDTO。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;DTO 转化&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如我们所知，DTO 为系统与外界交互的模型对象，那么肯定会有一个步骤是将 DTO 对象转化为 BO 对象或者是普通的 entity 对象，让 service 层去处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;场景&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如添加会员操作，由于用于演示，我只考虑用户的一些简单数据，当后台管理员点击添加用户时，只需要传过来用户的姓名和年龄就可以了，后端接受到数据后，将添加创建时间和更新时间和默认密码三个字段，然后保存数据库。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@RequestMapping(&lt;span&gt;&quot;/v1/api/user&quot;&lt;/span&gt;)&lt;br/&gt;@RestController&lt;br/&gt;public class UserApi {&lt;br/&gt;&lt;br/&gt;    @Autowired&lt;br/&gt;    private UserService userService;&lt;br/&gt;&lt;br/&gt;    @PostMapping&lt;br/&gt;    public User addUser(UserInputDTO userInputDTO){&lt;br/&gt;        User user = new User();&lt;br/&gt;        user.setUsername(userInputDTO.getUsername());&lt;br/&gt;        user.setAge(userInputDTO.getAge());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; userService.addUser(user);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们只关注一下上述代码中的转化代码，其他内容请忽略：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;User user = new User();&lt;br/&gt;user.setUsername(userInputDTO.getUsername());&lt;br/&gt;user.setAge(userInputDTO.getAge());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;请使用工具&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上边的代码，从逻辑上讲，是没有问题的，只是这种写法让我很厌烦，例子中只有两个字段，如果有 20 个字段，我们要如何做呢？一个一个进行 set 数据吗？当然，如果你这么做了，肯定不会有什么问题，但是，这肯定不是一个最优的做法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网上有很多工具，支持浅拷贝或深拷贝的 Utils。举个例子，我们可以使用 org.springframework.beans.BeanUtils#copyProperties 对代码进行重构和优化：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@PostMapping&lt;br/&gt;public User addUser(UserInputDTO userInputDTO){&lt;br/&gt;    User user = new User();&lt;br/&gt;    BeanUtils.copyProperties(userInputDTO,user);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; userService.addUser(user);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BeanUtils.copyProperties 是一个浅拷贝方法，复制属性时，我们只需要把 DTO 对象和要转化的对象两个的属性值设置为一样的名称，并且保证一样的类型就可以了。如果你在做 DTO 转化的时候一直使用 set 进行属性赋值，那么请尝试这种方式简化代码，让代码更加清晰!&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;转化的语义&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上边的转化过程，读者看后肯定觉得优雅很多，但是我们再写 Java 代码时，更多的需要考虑语义的操作，再看上边的代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;User user = new User();&lt;br/&gt;BeanUtils.copyProperties(userInputDTO,user);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然这段代码很好的简化和优化了代码，但是他的语义是有问题的，我们需要提现一个转化过程才好，所以代码改成如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@PostMapping&lt;br/&gt; public User addUser(UserInputDTO userInputDTO){&lt;br/&gt;         User user = convertFor(userInputDTO);&lt;br/&gt;&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; userService.addUser(user);&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; private User convertFor(UserInputDTO userInputDTO){&lt;br/&gt;&lt;br/&gt;         User user = new User();&lt;br/&gt;         BeanUtils.copyProperties(userInputDTO,user);&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; user;&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个更好的语义写法，虽然他麻烦了些，但是可读性大大增加了，在写代码时，我们应该尽量把语义层次差不多的放到一个方法中，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;User user = convertFor(userInputDTO);&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; userService.addUser(user);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两段代码都没有暴露实现，都是在讲如何在同一个方法中，做一组相同层次的语义操作，而不是暴露具体的实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上所述，是一种重构方式，读者可以参考 Martin Fowler 的《Refactoring Imporving the Design of Existing Code》(重构 改善既有代码的设计) 这本书中的 Extract Method 重构方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;抽象接口定义&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当实际工作中，完成了几个 API 的 DTO 转化时，我们会发现，这样的操作有很多很多，那么应该定义好一个接口，让所有这样的操作都有规则的进行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果接口被定义以后，那么 convertFor 这个方法的语义将产生变化，它将是一个实现类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一下抽象后的接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public interface DTOConvert&amp;lt;S,T&amp;gt; {&lt;br/&gt;    T convert(S s);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然这个接口很简单，但是这里告诉我们一个事情，要去使用泛型，如果你是一个优秀的 Java 程序员，请为你想做的抽象接口，做好泛型吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看接口实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class UserInputDTOConvert implements DTOConvert {&lt;br/&gt;@Override&lt;br/&gt;public User convert(UserInputDTO userInputDTO) {&lt;br/&gt;User user = new User();&lt;br/&gt;BeanUtils.copyProperties(userInputDTO,user);&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; user;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们这样重构后，我们发现现在的代码是如此的简洁，并且那么的规范：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@RequestMapping(&lt;span&gt;&quot;/v1/api/user&quot;&lt;/span&gt;)&lt;br/&gt;@RestController&lt;br/&gt;public class UserApi {&lt;br/&gt;&lt;br/&gt;    @Autowired&lt;br/&gt;    private UserService userService;&lt;br/&gt;&lt;br/&gt;    @PostMapping&lt;br/&gt;    public User addUser(UserInputDTO userInputDTO){&lt;br/&gt;        User user = new UserInputDTOConvert().convert(userInputDTO);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; userService.addUser(user);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;review code&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你是一个优秀的 Java 程序员，我相信你应该和我一样，已经数次重复 review 过自己的代码很多次了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再看这个保存用户的例子，你将发现，API 中返回值是有些问题的，问题就在于不应该直接返回 User 实体，因为如果这样的话，就暴露了太多实体相关的信息，这样的返回值是不安全的，所以我们更应该返回一个 DTO 对象，我们可称它为 UserOutputDTO：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@PostMapping&lt;br/&gt;public UserOutputDTO addUser(UserInputDTO userInputDTO){&lt;br/&gt;        User user = new UserInputDTOConvert().convert(userInputDTO);&lt;br/&gt;        User saveUserResult = userService.addUser(user);&lt;br/&gt;        UserOutputDTO result = new UserOutDTOConvert().convertToUser(saveUserResult);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样你的 API 才更健全。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不知道在看完这段代码之后，读者有是否发现还有其他问题的存在，作为一个优秀的 Java 程序员，请看一下这段我们刚刚抽象完的代码:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;User user = new UserInputDTOConvert().convert(userInputDTO);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你会发现，new 这样一个 DTO 转化对象是没有必要的，而且每一个转化对象都是由在遇到 DTO 转化的时候才会出现，那我们应该考虑一下，是否可以将这个类和 DTO 进行聚合呢，看一下我的聚合结果:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class UserInputDTO {&lt;br/&gt;private String username;&lt;br/&gt;private int age;&lt;br/&gt;&lt;br/&gt;    public String &lt;span&gt;&lt;span&gt;getUsername&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; username;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public void setUsername(String username) {&lt;br/&gt;        this.username = username;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public int &lt;span&gt;&lt;span&gt;getAge&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; age;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public void setAge(int age) {&lt;br/&gt;        this.age = age;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    public User &lt;span&gt;&lt;span&gt;convertToUser&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;        UserInputDTOConvert userInputDTOConvert = new UserInputDTOConvert();&lt;br/&gt;        User convert = userInputDTOConvert.convert(this);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; convert;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    private static class UserInputDTOConvert implements DTOConvert&amp;lt;UserInputDTO,User&amp;gt; {&lt;br/&gt;        @Override&lt;br/&gt;        public User convert(UserInputDTO userInputDTO) {&lt;br/&gt;            User user = new User();&lt;br/&gt;            BeanUtils.copyProperties(userInputDTO,user);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; user;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后 API 中的转化则由：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;User user = new UserInputDTOConvert().convert(userInputDTO);&lt;br/&gt;User saveUserResult = userService.addUser(user);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;变成了：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;User user = userInputDTO.convertToUser();&lt;br/&gt;User saveUserResult = userService.addUser(user);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再 DTO 对象中添加了转化的行为，我相信这样的操作可以让代码的可读性变得更强，并且是符合语义的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;再查工具类&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来看 DTO 内部转化的代码，它实现了我们自己定义的 DTOConvert 接口，但是这样真的就没有问题，不需要再思考了吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我觉得并不是，对于 Convert 这种转化语义来讲，很多工具类中都有这样的定义，这中 Convert 并不是业务级别上的接口定义，它只是用于普通 bean 之间转化属性值的普通意义上的接口定义，所以我们应该更多的去读其他含有 Convert 转化语义的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我仔细阅读了一下 GUAVA 的源码，发现了 com.google.common.base.Convert 这样的定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public abstract class Converter&amp;lt;A, B&amp;gt; implements Function&amp;lt;A, B&amp;gt; {&lt;br/&gt;    protected abstract B doForward(A a);&lt;br/&gt;    protected abstract A doBackward(B b);&lt;br/&gt;    //其他略&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从源码可以了解到，GUAVA 中的 Convert 可以完成正向转化和逆向转化，继续修改我们 DTO 中转化的这段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;private static class UserInputDTOConvert implements DTOConvert&amp;lt;UserInputDTO,User&amp;gt; {&lt;br/&gt;        @Override&lt;br/&gt;        public User convert(UserInputDTO userInputDTO) {&lt;br/&gt;                User user = new User();&lt;br/&gt;                BeanUtils.copyProperties(userInputDTO,user);&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; user;&lt;br/&gt;        }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改后：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;private static class UserInputDTOConvert extends Converter&amp;lt;UserInputDTO, User&amp;gt; {&lt;br/&gt;         @Override&lt;br/&gt;         protected User doForward(UserInputDTO userInputDTO) {&lt;br/&gt;                 User user = new User();&lt;br/&gt;                 BeanUtils.copyProperties(userInputDTO,user);&lt;br/&gt;                 &lt;span&gt;return&lt;/span&gt; user;&lt;br/&gt;         }&lt;br/&gt;&lt;br/&gt;         @Override&lt;br/&gt;         protected UserInputDTO doBackward(User user) {&lt;br/&gt;                 UserInputDTO userInputDTO = new UserInputDTO();&lt;br/&gt;                 BeanUtils.copyProperties(user,userInputDTO);&lt;br/&gt;                 &lt;span&gt;return&lt;/span&gt; userInputDTO;&lt;br/&gt;         }&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看了这部分代码以后，你可能会问，那逆向转化会有什么用呢？其实我们有很多小的业务需求中，入参和出参是一样的，那么我们变可以轻松的进行转化，我将上边所提到的 UserInputDTO 和 UserOutputDTO 都转成 UserDTO 展示给大家。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DTO：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class UserDTO {&lt;br/&gt;    private String username;&lt;br/&gt;    private int age;&lt;br/&gt;&lt;br/&gt;    public String &lt;span&gt;&lt;span&gt;getUsername&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; username;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public void setUsername(String username) {&lt;br/&gt;            this.username = username;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public int &lt;span&gt;&lt;span&gt;getAge&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; age;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public void setAge(int age) {&lt;br/&gt;            this.age = age;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    public User &lt;span&gt;&lt;span&gt;convertToUser&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;            UserDTOConvert userDTOConvert = new UserDTOConvert();&lt;br/&gt;            User convert = userDTOConvert.convert(this);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; convert;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public UserDTO convertFor(User user){&lt;br/&gt;            UserDTOConvert userDTOConvert = new UserDTOConvert();&lt;br/&gt;            UserDTO convert = userDTOConvert.reverse().convert(user);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; convert;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    private static class UserDTOConvert extends Converter&amp;lt;UserDTO, User&amp;gt; {&lt;br/&gt;            @Override&lt;br/&gt;            protected User doForward(UserDTO userDTO) {&lt;br/&gt;                    User user = new User();&lt;br/&gt;                    BeanUtils.copyProperties(userDTO,user);&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; user;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            @Override&lt;br/&gt;            protected UserDTO doBackward(User user) {&lt;br/&gt;                    UserDTO userDTO = new UserDTO();&lt;br/&gt;                    BeanUtils.copyProperties(user,userDTO);&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; userDTO;&lt;br/&gt;            }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;API：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@PostMapping&lt;br/&gt; public UserDTO addUser(UserDTO userDTO){&lt;br/&gt;         User user =  userDTO.convertToUser();&lt;br/&gt;         User saveResultUser = userService.addUser(user);&lt;br/&gt;         UserDTO result = userDTO.convertFor(saveResultUser);&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，上述只是表明了转化方向的正向或逆向，很多业务需求的出参和入参的 DTO 对象是不同的，那么你需要更明显的告诉程序：逆向是无法调用的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;private static class UserDTOConvert extends Converter&amp;lt;UserDTO, User&amp;gt; {&lt;br/&gt;         @Override&lt;br/&gt;         protected User doForward(UserDTO userDTO) {&lt;br/&gt;                 User user = new User();&lt;br/&gt;                 BeanUtils.copyProperties(userDTO,user);&lt;br/&gt;                 &lt;span&gt;return&lt;/span&gt; user;&lt;br/&gt;         }&lt;br/&gt;&lt;br/&gt;         @Override&lt;br/&gt;         protected UserDTO doBackward(User user) {&lt;br/&gt;                 throw new AssertionError(&lt;span&gt;&quot;不支持逆向转化方法!&quot;&lt;/span&gt;);&lt;br/&gt;         }&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一下 doBackward 方法，直接抛出了一个断言异常，而不是业务异常，这段代码告诉代码的调用者，这个方法不是准你调用的，如果你调用，我就”断言”你调用错误了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于异常处理的更详细介绍，可以参考我之前的文章：如何优雅的设计 Java 异常（http://lrwinx.github.io/2016/04/28/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%AE%BE%E8%AE%A1java%E5%BC%82%E5%B8%B8/） ，应该可以帮你更好的理解异常。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Bean 的验证&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你认为我上边写的那个添加用户 API 写的已经非常完美了，那只能说明你还不是一个优秀的程序员。我们应该保证任何数据的入参到方法体内都是合法的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么要验证&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多人会告诉我，如果这些 API 是提供给前端进行调用的，前端都会进行验证啊，你为什还要验证？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实答案是这样的，我从不相信任何调用我 API 或者方法的人，比如前端验证失败了，或者某些人通过一些特殊的渠道(比如 Charles 进行抓包)，直接将数据传入到我的 API，那我仍然进行正常的业务逻辑处理，那么就有可能产生脏数据！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“对于脏数据的产生一定是致命”，这句话希望大家牢记在心，再小的脏数据也有可能让你找几个通宵！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;jsr 303验证&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;hibernate 提供的 jsr 303 实现，我觉得目前仍然是很优秀的，具体如何使用，我不想讲，因为谷歌上你可以搜索出很多答案!&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再以上班的 API 实例进行说明，我们现在对 DTO 数据进行检查：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class UserDTO {&lt;br/&gt;    @NotNull&lt;br/&gt;    private String username;&lt;br/&gt;    @NotNull&lt;br/&gt;    private int age;&lt;br/&gt;        //其他代码略&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;API 验证：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@PostMapping&lt;br/&gt;    public UserDTO addUser(@Valid UserDTO userDTO){&lt;br/&gt;            User user =  userDTO.convertToUser();&lt;br/&gt;            User saveResultUser = userService.addUser(user);&lt;br/&gt;            UserDTO result = userDTO.convertFor(saveResultUser);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要将验证结果传给前端，这种异常应该转化为一个 api 异常(带有错误码的异常)。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@PostMapping&lt;br/&gt;public UserDTO addUser(@Valid UserDTO userDTO, BindingResult bindingResult){&lt;br/&gt;     checkDTOParams(bindingResult);&lt;br/&gt;&lt;br/&gt;     User user =  userDTO.convertToUser();&lt;br/&gt;     User saveResultUser = userService.addUser(user);&lt;br/&gt;     UserDTO result = userDTO.convertFor(saveResultUser);&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;br/&gt;private void checkDTOParams(BindingResult bindingResult){&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt;(bindingResult.hasErrors()){&lt;br/&gt;             //throw new 带验证码的验证错误异常&lt;br/&gt;     }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BindingResult 是 Spring MVC 验证 DTO 后的一个结果集，可以参考spring 官方文档（http://spring.io/）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;检查参数后，可以抛出一个“带验证码的验证错误异常”，具体异常设计可以参考如何优雅的设计 Java 异常（http://lrwinx.github.io/2016/04/28/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E8%AE%BE%E8%AE%A1java%E5%BC%82%E5%B8%B8/）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;拥抱 lombok&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上边的 DTO 代码，已经让我看的很累了，我相信读者也是一样，看到那么多的 Getter 和 Setter 方法，太烦躁了，那时候有什么方法可以简化这些呢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请拥抱 lombok,它会帮助我们解决一些让我们很烦躁的问题&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;去掉 Setter 和 Getter&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这个标题，我不太想说，因为网上太多，但是因为很多人告诉我，他们根本就不知道 lombok 的存在，所以为了让读者更好的学习，我愿意写这样一个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Setter&lt;br/&gt;@Getter&lt;br/&gt;public class UserDTO {&lt;br/&gt;    @NotNull&lt;br/&gt;    private String username;&lt;br/&gt;    @NotNull&lt;br/&gt;    private int age;&lt;br/&gt;&lt;br/&gt;    public User &lt;span&gt;&lt;span&gt;convertToUser&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;        UserDTOConvert userDTOConvert = new UserDTOConvert();&lt;br/&gt;        User convert = userDTOConvert.convert(this);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; convert;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public UserDTO convertFor(User user){&lt;br/&gt;        UserDTOConvert userDTOConvert = new UserDTOConvert();&lt;br/&gt;        UserDTO convert = userDTOConvert.reverse().convert(user);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; convert;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    private static class UserDTOConvert extends Converter&amp;lt;UserDTO, User&amp;gt; {&lt;br/&gt;        @Override&lt;br/&gt;        protected User doForward(UserDTO userDTO) {&lt;br/&gt;            User user = new User();&lt;br/&gt;            BeanUtils.copyProperties(userDTO,user);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; user;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        @Override&lt;br/&gt;        protected UserDTO doBackward(User user) {&lt;br/&gt;            throw new AssertionError(&lt;span&gt;&quot;不支持逆向转化方法!&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到了吧，烦人的 Getter 和 Setter 方法已经去掉了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是上边的例子根本不足以体现 lombok 的强大。我希望写一些网上很难查到，或者很少人进行说明的 lombok 的使用以及在使用时程序语义上的说明。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如:@Data,@AllArgsConstructor,@NoArgsConstructor..这些我就不进行一一说明了，请大家自行查询资料。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;bean 中的链式风格&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么是链式风格？我来举个例子，看下面这个 Student 的 bean：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class Student {&lt;br/&gt;    private String name;&lt;br/&gt;    private int age;&lt;br/&gt;&lt;br/&gt;    public String &lt;span&gt;&lt;span&gt;getName&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; name;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public Student setName(String name) {&lt;br/&gt;        this.name = name;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; this;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public int &lt;span&gt;&lt;span&gt;getAge&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; age;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public Student setAge(int age) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; this;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仔细看一下 set 方法，这样的设置便是 chain 的 style，调用的时候，可以这样使用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Student student = new Student()&lt;br/&gt;        .setAge(24)&lt;br/&gt;        .setName(&lt;span&gt;&quot;zs&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信合理使用这样的链式代码，会更多的程序带来很好的可读性，那看一下如果使用 lombok 进行改善呢，请使用 @Accessors(chain = true)，看如下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Accessors(chain = &lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;@Setter&lt;br/&gt;@Getter&lt;br/&gt;public class Student {&lt;br/&gt;    private String name;&lt;br/&gt;    private int age;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就完成了一个对于 bean 来讲很友好的链式操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;静态构造方法&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;静态构造方法的语义和简化程度真的高于直接去 new 一个对象。比如 new 一个 List 对象，过去的使用是这样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;String&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一下 guava 中的创建方式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;String&amp;gt; list = Lists.newArrayList();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lists 命名是一种约定(俗话说：约定优于配置)，它是指 Lists 是 List 这个类的一个工具类，那么使用 List 的工具类去产生 List，这样的语义是不是要比直接 new 一个子类来的更直接一些呢，答案是肯定的，再比如如果有一个工具类叫做 Maps，那你是否想到了创建 Map 的方法呢：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;HashMap&amp;lt;String, String&amp;gt; objectObjectHashMap = Maps.newHashMap();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，如果你理解了我说的语义，那么，你已经向成为 Java 程序员更近了一步了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再回过头来看刚刚的 Student，很多时候，我们去写 Student 这个 bean 的时候，他会有一些必输字段，比如 Student 中的 name 字段，一般处理的方式是将 name 字段包装成一个构造方法，只有传入 name 这样的构造方法，才能创建一个 Student 对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接上上边的静态构造方法和必传参数的构造方法，使用 lombok 将更改成如下写法（@RequiredArgsConstructor 和 @NonNull）:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Accessors(chain = &lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;@Setter&lt;br/&gt;@Getter&lt;br/&gt;@RequiredArgsConstructor(staticName = &lt;span&gt;&quot;ofName&quot;&lt;/span&gt;)&lt;br/&gt;public class Student {&lt;br/&gt;    @NonNull private String name;&lt;br/&gt;    private int age;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Student student = Student.ofName(&lt;span&gt;&quot;zs&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样构建出的 bean 语义是否要比直接 new 一个含参的构造方法(包含  name 的构造方法)要好很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，看过很多源码以后，我想相信将静态构造方法 ofName 换成 of 会先的更加简洁：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Accessors(chain = &lt;span&gt;true&lt;/span&gt;)&lt;br/&gt;@Setter&lt;br/&gt;@Getter&lt;br/&gt;@RequiredArgsConstructor(staticName = &lt;span&gt;&quot;of&quot;&lt;/span&gt;)&lt;br/&gt;public class Student {&lt;br/&gt;        @NonNull private String name;&lt;br/&gt;        private int age;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Student student = Student.of(&lt;span&gt;&quot;zs&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然他仍然是支持链式调用的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Student student = Student.of(&lt;span&gt;&quot;zs&quot;&lt;/span&gt;).setAge(24);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样来写代码，真的很简洁，并且可读性很强。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;使用 builder&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Builder 模式我不想再多解释了，读者可以看一下《Head First》(设计模式) 的建造者模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天其实要说的是一种变种的 builder 模式，那就是构建 bean 的 builder 模式，其实主要的思想是带着大家一起看一下 lombok 给我们带来了什么。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看一下 Student 这个类的原始 builder 状态:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class Student {&lt;br/&gt;    private String name;&lt;br/&gt;    private int age;&lt;br/&gt;&lt;br/&gt;    public String &lt;span&gt;&lt;span&gt;getName&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; name;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public void setName(String name) {&lt;br/&gt;            this.name = name;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public int &lt;span&gt;&lt;span&gt;getAge&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; age;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public void setAge(int age) {&lt;br/&gt;            this.age = age;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public static Builder &lt;span&gt;&lt;span&gt;builder&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; new Builder();&lt;br/&gt;    }&lt;br/&gt;    public static class Builder{&lt;br/&gt;            private String name;&lt;br/&gt;            private int age;&lt;br/&gt;            public Builder name(String name){&lt;br/&gt;                    this.name = name;&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; this;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            public Builder age(int age){&lt;br/&gt;                    this.age = age;&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; this;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            public Student &lt;span&gt;&lt;span&gt;build&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;                    Student student = new Student();&lt;br/&gt;                    student.setAge(age);&lt;br/&gt;                    student.setName(name);&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt; student;&lt;br/&gt;            }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用方式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Student student = Student.builder().name(&lt;span&gt;&quot;zs&quot;&lt;/span&gt;).age(24).build();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的 builder 代码，让我是在恶心难受，于是我打算用 lombok 重构这段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@Builder&lt;br/&gt;public class Student {&lt;br/&gt;    private String name;&lt;br/&gt;    private int age;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用方式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Student student = Student.builder().name(&lt;span&gt;&quot;zs&quot;&lt;/span&gt;).age(24).build();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代理模式&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如我们所知的，在程序中调用 rest 接口是一个常见的行为动作，如果你和我一样使用过 spring 的 RestTemplate，我相信你会我和一样，对他抛出的非 http 状态码异常深恶痛绝。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们考虑将 RestTemplate 最为底层包装器进行包装器模式的设计：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public abstract class FilterRestTemplate implements RestOperations {&lt;br/&gt;        protected volatile RestTemplate restTemplate;&lt;br/&gt;&lt;br/&gt;        protected FilterRestTemplate(RestTemplate restTemplate){&lt;br/&gt;                this.restTemplate = restTemplate;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        //实现RestOperations所有的接口&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后再由扩展类对 FilterRestTemplate 进行包装扩展：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public class ExtractRestTemplate extends FilterRestTemplate {&lt;br/&gt;    private RestTemplate restTemplate;&lt;br/&gt;    public ExtractRestTemplate(RestTemplate restTemplate) {&lt;br/&gt;            super(restTemplate);&lt;br/&gt;            this.restTemplate = restTemplate;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public &amp;lt;T&amp;gt; RestResponseDTO&amp;lt;T&amp;gt; postForEntityWithNoException(String url, Object request, Class&amp;lt;T&amp;gt; responseType, Object... uriVariables)&lt;br/&gt;                    throws RestClientException {&lt;br/&gt;            RestResponseDTO&amp;lt;T&amp;gt; restResponseDTO = new RestResponseDTO&amp;lt;T&amp;gt;();&lt;br/&gt;            ResponseEntity&amp;lt;T&amp;gt; tResponseEntity;&lt;br/&gt;            try {&lt;br/&gt;                    tResponseEntity = restTemplate.postForEntity(url, request, responseType, uriVariables);&lt;br/&gt;                    restResponseDTO.setData(tResponseEntity.getBody());&lt;br/&gt;                    restResponseDTO.setMessage(tResponseEntity.getStatusCode().name());&lt;br/&gt;                    restResponseDTO.setStatusCode(tResponseEntity.getStatusCodeValue());&lt;br/&gt;            }catch (Exception e){&lt;br/&gt;                    restResponseDTO.setStatusCode(RestResponseDTO.UNKNOWN_ERROR);&lt;br/&gt;                    restResponseDTO.setMessage(e.getMessage());&lt;br/&gt;                    restResponseDTO.setData(null);&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; restResponseDTO;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;包装器 ExtractRestTemplate 很完美的更改了异常抛出的行为，让程序更具有容错性。在这里我们不考虑 ExtractRestTemplate 完成的功能，让我们把焦点放在 FilterRestTemplate 上，“实现 RestOperations 所有的接口”,这个操作绝对不是一时半会可以写完的，当时在重构之前我几乎写了半个小时,如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public abstract class FilterRestTemplate implements RestOperations {&lt;br/&gt;&lt;br/&gt;    protected volatile RestTemplate restTemplate;&lt;br/&gt;&lt;br/&gt;    protected FilterRestTemplate(RestTemplate restTemplate) {&lt;br/&gt;            this.restTemplate = restTemplate;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    public &amp;lt;T&amp;gt; T getForObject(String url, Class&amp;lt;T&amp;gt; responseType, Object... uriVariables) throws RestClientException {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; restTemplate.getForObject(url,responseType,uriVariables);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    public &amp;lt;T&amp;gt; T getForObject(String url, Class&amp;lt;T&amp;gt; responseType, Map&amp;lt;String, ?&amp;gt; uriVariables) throws RestClientException {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; restTemplate.getForObject(url,responseType,uriVariables);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    public &amp;lt;T&amp;gt; T getForObject(URI url, Class&amp;lt;T&amp;gt; responseType) throws RestClientException {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; restTemplate.getForObject(url,responseType);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    @Override&lt;br/&gt;    public &amp;lt;T&amp;gt; ResponseEntity&amp;lt;T&amp;gt; getForEntity(String url, Class&amp;lt;T&amp;gt; responseType, Object... uriVariables) throws RestClientException {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; restTemplate.getForEntity(url,responseType,uriVariables);&lt;br/&gt;    }&lt;br/&gt;    //其他实现代码略。。。&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我相信你看了以上代码，你会和我一样觉得恶心反胃，后来我用 lombok 提供的代理注解优化了我的代码(@Delegate)：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@AllArgsConstructor&lt;br/&gt;public abstract class FilterRestTemplate implements RestOperations {&lt;br/&gt;    @Delegate&lt;br/&gt;    protected volatile RestTemplate restTemplate;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这几行代码完全替代上述那些冗长的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是不是很简洁，做一个拥抱 lombok 的程序员吧。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;重构&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;需求案例&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;项目需求&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目开发阶段，有一个关于下单发货的需求：如果今天下午 3 点前进行下单，那么发货时间是明天，如果今天下午 3 点后进行下单，那么发货时间是后天，如果被确定的时间是周日，那么在此时间上再加 1 天为发货时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;思考与重构&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我相信这个需求看似很简单，无论怎么写都可以完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多人可能看到这个需求，就动手开始写 Calendar 或 Date 进行计算，从而完成需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而我给的建议是，仔细考虑如何写代码，然后再去写，不是说所有的时间操作都用 Calendar 或 Date 去解决，一定要看场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于时间的计算我们要考虑 joda-time 这种类似的成熟时间计算框架来写代码，它会让代码更加简洁和易读。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请读者先考虑这个需求如何用 Java 代码完成，或先写一个你觉得完成这个代码的思路，再来看我下边的代码，这样，你的收获会更多一些：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;final DateTime DISTRIBUTION_TIME_SPLIT_TIME = new DateTime().withTime(15,0,0,0);&lt;br/&gt;private Date calculateDistributionTimeByOrderCreateTime(Date orderCreateTime){&lt;br/&gt;    DateTime orderCreateDateTime = new DateTime(orderCreateTime);&lt;br/&gt;    Date tomorrow = orderCreateDateTime.plusDays(1).toDate();&lt;br/&gt;    Date theDayAfterTomorrow = orderCreateDateTime.plusDays(2).toDate();&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; orderCreateDateTime.isAfter(DISTRIBUTION_TIME_SPLIT_TIME) ? wrapDistributionTime(theDayAfterTomorrow) : wrapDistributionTime(tomorrow);&lt;br/&gt;}&lt;br/&gt;private Date wrapDistributionTime(Date distributionTime){&lt;br/&gt;    DateTime currentDistributionDateTime = new DateTime(distributionTime);&lt;br/&gt;    DateTime plusOneDay = currentDistributionDateTime.plusDays(1);&lt;br/&gt;    boolean isSunday = (DateTimeConstants.SUNDAY == currentDistributionDateTime.getDayOfWeek());&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; isSunday ? plusOneDay.toDate() : currentDistributionDateTime.toDate() ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读这段代码的时候，你会发现，我将判断和有可能出现的不同结果都当做一个变量，最终做一个三目运算符的方式进行返回，这样的优雅和可读性显而易见，当然这样的代码不是一蹴而就的，我优化了 3 遍产生的以上代码。读者可根据自己的代码和我写的代码进行对比。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;提高方法&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你做了 3 年+的程序员，我相信像如上这样的需求，你很轻松就能完成，但是如果你想做一个会写 Java 的程序员，就好好的思考和重构代码吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写代码就如同写字一样，同样的字，大家都会写，但是写出来是否好看就不一定了。如果想把程序写好，就要不断的思考和重构，敢于尝试，敢于创新，不要因循守旧，一定要做一个优秀的 Java 程序员。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提高代码水平最好的方法就是有条理的重构！(注意：是有条理的重构)&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;设计模式&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计模式就是工具，而不是提现你是否是高水平程序员的一个指标。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我经常会看到某一个程序员兴奋的大喊，哪个程序哪个点我用到了设计模式，写的多么多么优秀，多么多么好。我仔细去翻阅的时候，却发现有很多是过度设计的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;业务驱动技术 or 技术驱动业务&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务驱动技术 or 技术驱动业务 ？其实这是一个一直在争论的话题，但是很多人不这么认为，我觉得就是大家不愿意承认罢了。我来和大家大概分析一下作为一个 Java 程序员，我们应该如何判断自己所处于的位置.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;业务驱动技术：&lt;/strong&gt; 如果你所在的项目是一个收益很小或者甚至没有收益的项目，请不要搞其他创新的东西，不要驱动业务要如何如何做，而是要熟知业务现在的痛点是什么？如何才能帮助业务盈利或者让项目更好，更顺利的进行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;技术驱动业务：&lt;/strong&gt; 如果你所在的项目是一个很牛的项目，比如淘宝这类的项目，我可以在满足业务需求的情况下，和业务沟通，使用什么样的技术能更好的帮助业务创造收益，比如说下单的时候要进队列，可能几分钟之后订单状态才能处理完成，但是会让用户有更流畅的体验，赚取更多的访问流量，那么我相信业务愿意被技术驱动，会同意订单的延迟问题，这样便是技术驱动业务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我相信大部分人还都处于业务驱动技术的方向吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以你既然不能驱动业务，那就请拥抱业务变化吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码设计&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一直在做 Java 后端的项目，经常会有一些变动，我相信大家也都遇到过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如当我们写一段代码的时候，我们考虑将需求映射成代码的状态模式，突然有一天，状态模式里边又添加了很多行为变化的东西，这时候你就挠头了，你硬生生的将状态模式中添加过多行为和变化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;慢慢的你会发现这些状态模式，其实更像是一簇算法，应该使用策略模式，这时你应该已经晕头转向了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说了这么多，我的意思是，只要你觉得合理，就请将状态模式改为策略模式吧，所有的模式并不是凭空想象出来的，都是基于重构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 编程中没有银弹，请拥抱业务变化，一直思考重构，你就有一个更好的代码设计!&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;你真的优秀吗？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;真不好意思，我取了一个这么无聊的标题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;国外流行一种编程方式，叫做结对编程，我相信国内很多公司都没有这么做，我就不在讲述结对编程带来的好处了，其实就是一边 code review，一边互相提高的一个过程。既然做不到这个，那如何让自己活在自己的世界中不断提高呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“平时开发的时候，做出的代码总认为是正确的，而且写法是完美的。”，我相信这是大部分人的心声，还回到刚刚的问题，如何在自己的世界中不断提高呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案就是:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;多看成熟框架的源码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;多回头看自己的代码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;勤于重构&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你真的优秀吗？如果你每周都完成了学习源码，回头看自己代码，然后勤于重构，我认为你就真的很优秀了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使也许你只是刚刚入门，但是一直坚持，你就是一个真的会写java代码的程序员了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;技能&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;UML&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不想多讨论 UML 相关的知识，但是我觉得你如果真的会写 Java，请先学会表达自己，UML 就是你说话的语言，做一名优秀的 Java 程序员，请至少学会这两种 UML 图：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;类图&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;时序图&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;clean code&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我认为保持代码的简洁和可读性是代码的最基本保证，如果有一天为了程序的效率而降低了这两点，我认为是可以谅解的，除此之外，没有任何理由可以让你任意挥霍你的代码。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;读者可以看一下 Robert C. Martin 出版的《Clean Code》（代码整洁之道） 这本书&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可以参考美团文章聊聊 clean code（http://tech.meituan.com/clean-code.html）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;也可以看一下阿里的 Java 编码规范（https://yq.aliyun.com/articles/69327?spm=5176.100239.topwz.1.om5dRN）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论如何，请保持你的代码的整洁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Linux 基础命令&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这点其实和会写 Java 没有关系，但是 Linux 很多时候确实承载运行 Java 的容器，请学好 Linux 的基础命令。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;参考鸟哥的《Linux私房菜》&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 是一个大体系，今天讨论并未涉及框架和架构相关知识，只是讨论如何写好代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文从写 Java 程序的小方面一直写到大方面，来阐述了如何才能写好 Java 程序，并告诉读者们如何才能提高自身的编码水平。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我希望看到这篇文章的各位都能做一个优秀的 Java 程序员。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5d4ea1c8442a2603b530df86f3cac807</guid>
<title>解决微服务架构下流量有损问题的实践和探索</title>
<link>https://toutiao.io/k/f8xxqp3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;阿里开发者&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;ali_tech&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;阿里巴巴官方技术号，关于阿里的技术创新均呈现于此。&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d9ec25e525d0b6a46e4c4507eab70359</guid>
<title>eBPF编程指北</title>
<link>https://toutiao.io/k/fn0j0ty</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt;1&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;开发环境&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这里以 Ubuntu 20.04 为例构建 eBPF 开发环境：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ uname -a&lt;br/&gt;Linux VM-1-3-ubuntu 5.4.0-42-generic &lt;span&gt;#46-Ubuntu SMP Fri Jul 10 00:24:02 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux&lt;/span&gt;&lt;br/&gt;$ sudo apt install build-essential git make libelf-dev clang llvm strace tar bpfcc-tools linux-headers-$(uname -r) gcc-multilib  flex  bison libssl-dev -y&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;主流的发行版在对 LLVM 打包的时候就默认启用了 BPF 后端，因此，在大部分发行版上安 装 clang 和 llvm 就可以将 C 代码编译为 BPF 对象文件了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;典型的工作流是：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;用 C 编写 BPF 程序&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;用 LLVM 将 C 程序编译成对象文件（ELF）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;用户空间 BPF ELF 加载器（例如 iproute2）解析对象文件&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;加载器通过 bpf() 系统调用将解析后的对象文件注入内核&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;内核验证 BPF 指令，然后对其执行即时编译（JIT），返回程序的一个新文件描述符&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;利用文件描述符 attach 到内核子系统（例如网络子系统）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;某些子系统还支持将 BPF 程序 offload 到硬件（例如网卡）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;查看 LLVM 支持的 BPF target：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ llc --version&lt;br/&gt;LLVM (http://llvm.org/):&lt;br/&gt;  LLVM version 10.0.0&lt;br/&gt;&lt;br/&gt;  Optimized build.&lt;br/&gt;  Default target: x86_64-pc-linux-gnu&lt;br/&gt;  Host CPU: skylake&lt;br/&gt;&lt;br/&gt;  Registered Targets:&lt;br/&gt;    &lt;span&gt;# ...&lt;/span&gt;&lt;br/&gt;    bpf        - BPF (host endian)&lt;br/&gt;    bpfeb      - BPF (big endian)&lt;br/&gt;    bpfel      - BPF (little endian)&lt;br/&gt;    &lt;span&gt;# ...&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;默认情况下，bpf target 使用编译时所在的 CPU 的大小端格式，即，如果 CPU 是小端，BPF 程序就会用小端表示；如果 CPU 是大端，BPF 程序就是大端。这也和 BPF 的运行时行为相匹配，这样的行为比较通用，而且大小端格式一致&lt;/span&gt;&lt;span&gt;可以避免一些因为格式导致的架构劣势&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF 程序可以在大端节点上编译，在小端节点上运行，或者相反，因此对于交叉编译， 引入了两个新目标 bpfeb 和 bpfel。注意前端也需要以相应的大小端方式运行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在不存在大小端混用的场景下，建议使用 bpf target。例如，在 x86_64 平台上（小端 ），指定 bpf 和 bpfel 会产生相同的结果，因此触发编译的脚本不需要感知到大小端 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;下面是一个最小的完整 XDP 程序，实现丢弃包的功能（xdp-example.c）：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;#include &amp;lt;linux/bpf.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef __section&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define __section(NAME)                  \&lt;/span&gt;&lt;br/&gt;   __attribute__((section(NAME), used))&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;__section(&lt;span&gt;&quot;prog&quot;&lt;/span&gt;)&lt;br/&gt;int xdp_drop(struct xdp_md *ctx)&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; XDP_DROP;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;char __license[] __section(&lt;span&gt;&quot;license&quot;&lt;/span&gt;) = &lt;span&gt;&quot;GPL&quot;&lt;/span&gt;;&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;用下面的命令编译并加载到内核：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ clang -O2 -Wall -target bpf -c xdp-example.c -o xdp-example.o&lt;br/&gt;$ ip link &lt;span&gt;set&lt;/span&gt; dev em1 xdp obj xdp-example.o&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;—&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;编程限制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;用 C 语言编写 BPF 程序不同于用 C 语言做应用开发，有一些陷阱需要注意。本节列出了 二者的一些不同之处。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;所有函数都需要内联（inlined）、没有函数调用（对于老版本 LLVM）或共享库调用&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF 不支持共享库（Shared libraries）。但是，可以将常规的库代码（library code）放到头文件中，然后在主程序中 include 这些头文件，例如 Cilium 就大量使用了这种方式 （可以查看 bpf/lib/ 文件夹）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;另外，也可以 include 其他的一些头文件，例如内核或其他库中的头文件，复用其中的静态内联函数（static inline functions）或宏/定义（ macros / definitions）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;内核 4.16+ 和 LLVM 6.0+ 之后已经支持 BPF-to-BPF 函数调用。对于任意给定的程序片段 ，在此之前的版本只能将全部代码编译和内联成一个扁平的 BPF 指令序列（a flat sequence of BPF instructions）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在这种情况下，最佳实践就是为每个库函数都使用一个 像 __inline 一样的注解（annotation ），下面的例子中会看到。推荐使用 always_inline，因为编译器可能会对只注解为 inline 的长函数仍然做 uninline 操 作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;如果是后者，LLVM 会在 ELF 文件中生成一个重定位项（relocation entry），BPF ELF 加载器（例如 iproute2）无法解析这个重定位项，因此会产生一条错误，因为对加载器 来说只有 BPF maps 是合法的、能够处理的重定位项。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;#include &amp;lt;linux/bpf.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef __section&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define __section(NAME)                  \&lt;/span&gt;&lt;br/&gt;   __attribute__((section(NAME), used))&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef __inline&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define __inline                         \&lt;/span&gt;&lt;br/&gt;   inline __attribute__((always_inline))&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;static __inline int foo(void)&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; XDP_DROP;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;__section(&lt;span&gt;&quot;prog&quot;&lt;/span&gt;)&lt;br/&gt;int xdp_drop(struct xdp_md *ctx)&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; foo();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;char __license[] __section(&lt;span&gt;&quot;license&quot;&lt;/span&gt;) = &lt;span&gt;&quot;GPL&quot;&lt;/span&gt;;&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;多个程序可以放在同一 C 文件中的不同 section&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF C 程序大量使用 section annotations。一个 C 文件典型情况下会分为 3 个或更 多个 section。BPF ELF 加载器利用这些名字来提取和准备相关的信息，以通过 bpf() 系统调用加载程序和 maps。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;例如，查找创建 map 所需的元数据和 BPF 程序的 license 信息 时，iproute2 会分别使用 maps 和 license 作为默认的 section 名字。注意在程序创建时 license section 也会加载到内核，如果程序使用的是兼容 GPL 的协议，这些信息就可以启用那些 GPL-only 的辅助函数，例如 bpf_ktime_get_ns() 和 bpf_probe_read() 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;其余的 section 名字都是和特定的 BPF 程序代码相关的，例如，下面经过修改之后的代码包含两个程序 section：&lt;/span&gt;&lt;span&gt;ingress&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt; 和 &lt;/span&gt;&lt;span&gt;egress&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;。这个非常简单的示例展示了不同 section （这里是 ingress 和 egress）之间可以共享 BPF map 和常规的静态内联辅助函数（例如 account_data()）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;示例程序：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这里将原来的 xdp-example.c 修改为 tc-example.c，然后用 tc 命令加载，attach 到 一个 netdevice 的 ingress 或 egress hook。该程序对传输的字节进行计数，存储在一 个名为 acc_map 的 BPF map 中，这个 map 有两个槽（slot），分别用于 ingress hook 和 egress hook 的流量统计。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;#include &amp;lt;linux/bpf.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;linux/pkt_cls.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;stdint.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#include &amp;lt;iproute2/bpf_elf.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef __section&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define __section(NAME)                  \&lt;/span&gt;&lt;br/&gt;   __attribute__((section(NAME), used))&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef __inline&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define __inline                         \&lt;/span&gt;&lt;br/&gt;   inline __attribute__((always_inline))&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef lock_xadd&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define lock_xadd(ptr, val)              \&lt;/span&gt;&lt;br/&gt;   ((void)__sync_fetch_and_add(ptr, val))&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef BPF_FUNC&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define BPF_FUNC(NAME, ...)              \&lt;/span&gt;&lt;br/&gt;   (*NAME)(__VA_ARGS__) = (void *)BPF_FUNC_&lt;span&gt;##NAME&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;static void *BPF_FUNC(map_lookup_elem, void *map, const void *key);&lt;br/&gt;&lt;br/&gt;struct bpf_elf_map acc_map __section(&lt;span&gt;&quot;maps&quot;&lt;/span&gt;) = {&lt;br/&gt;    .&lt;span&gt;type&lt;/span&gt;           = BPF_MAP_TYPE_ARRAY,&lt;br/&gt;    .size_key       = sizeof(uint32_t),&lt;br/&gt;    .size_value     = sizeof(uint32_t),&lt;br/&gt;    .pinning        = PIN_GLOBAL_NS,&lt;br/&gt;    .max_elem       = 2,&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;static __inline int account_data(struct __sk_buff *skb, uint32_t dir)&lt;br/&gt;{&lt;br/&gt;    uint32_t *bytes;&lt;br/&gt;&lt;br/&gt;    bytes = map_lookup_elem(&amp;amp;acc_map, &amp;amp;dir);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (bytes)&lt;br/&gt;            lock_xadd(bytes, skb-&amp;gt;len);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; TC_ACT_OK;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;__section(&lt;span&gt;&quot;ingress&quot;&lt;/span&gt;)&lt;br/&gt;int tc_ingress(struct __sk_buff *skb)&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; account_data(skb, 0);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;__section(&lt;span&gt;&quot;egress&quot;&lt;/span&gt;)&lt;br/&gt;int tc_egress(struct __sk_buff *skb)&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; account_data(skb, 1);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;char __license[] __section(&lt;span&gt;&quot;license&quot;&lt;/span&gt;) = &lt;span&gt;&quot;GPL&quot;&lt;/span&gt;;&lt;/section&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;其他程序说明：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这个例子还展示了其他一些很有用的东西，在开发过程中要注意。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，include 了内核头文件、标准 C 头文件和一个特定的 iproute2 头文件 iproute2/bpf_elf.h&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;，后者定义了struct bpf_elf_map。iproute2 有一个通用的 BPF ELF 加载器，因此 struct bpf_elf_map的定义对于 XDP 和 tc 类型的程序是完全一样的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次，程序中每条 struct bpf_elf_map 记录（entry）定义一个 map&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;，这个记录包含了生成一 个（ingress 和 egress 程序需要用到的）map 所需的全部信息（例如 key/value 大 小）。这个结构体的定义必须放在 maps section，这样加载器才能找到它。可以用这个 结构体声明很多名字不同的变量，但这些声明前面必须加上 __section(&quot;maps&quot;) 注解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;结构体 struct bpf_elf_map 是特定于 iproute2 的。不同的 BPF ELF 加载器有不同的格式，例如，内核源码树中的 libbpf（主要是 perf 在用）就有一个不同的规范 （结构体定义）。iproute2 保证 struct bpf_elf_map 的后向兼容性。Cilium 采用的 是 iproute2 模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;另外，这个例子还展示了 BPF 辅助函数是如何映射到 C 代码以及如何被使用的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这里首先定义了一个宏 BPF_FUNC，接受一个函数名 NAME 以及其他的任意参数。然后用这个宏声明了一 个 NAME 为 map_lookup_elem 的函数，经过宏展开后会变成 BPF_FUNC_map_lookup_elem 枚举值，后者以辅助函数的形式定义在 uapi/linux/bpf.h。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;当随后这个程序被加载到内核时，校验器会检查传入的参数是否是期望的类型，如果是，就将辅助函数调用重新指向（re-points）某个真正的函数调用。另外，map_lookup_elem() 还展示了 map 是如何传递给 BPF 辅助函数的。这里，maps section 中的 &amp;amp;acc_map 作为第一个参数传递给 map_lookup_elem()。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;由于程序中定义的数组 map （array map）是全局的，因此&lt;/span&gt;&lt;span&gt;计数时需要使用原子操作&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;，这里 是使用了 lock_xadd()。LLVM 将 __sync_fetch_and_add() 作为一个内置函数映射到 BPF 原子加指令，即 BPF_STX | BPF_XADD | BPF_W（for word sizes）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;另外，struct bpf_elf_map 中的 .pinning 字段初始化为 PIN_GLOBAL_NS，这意味 着 tc 会将这个 map 作为一个节点（node）钉（pin）到 BPF 伪文件系统。默认情况下， 这个变量 acc_map 将被钉到 /sys/fs/bpf/tc/globals/acc_map。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;如果指定的是 PIN_GLOBAL_NS，那 map 会被放到 /sys/fs/bpf/tc/globals/。globals 是一个跨对象文件的全局命名空间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;如果指定的是 PIN_OBJECT_NS，tc 将会为对象文件创建一个它的本地目录（local to the object file）。例如，只要指定了 PIN_OBJECT_NS，不同的 C 文件都可以像上 面一样定义各自的 acc_map。在这种情况下，这个 map 会在不同 BPF 程序之间共享。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;PIN_NONE 表示 map 不会作为节点（node）钉（pin）到 BPF 文件系统，因此当 tc 退 出时这个 map 就无法从用户空间访问了。同时，这还意味着&lt;/span&gt;&lt;span&gt;独立的 tc 命令会创建出独 立的 map 实例&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;，因此后执行的 tc 命令无法用这个 map 名字找到之前被钉住的 map。在路径 /sys/fs/bpf/tc/globals/acc_map 中，map 名是 acc_map。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;因此，在加载 ingress 程序时，&lt;/span&gt;&lt;span&gt;tc 会先查找这个 map 在 BPF 文件系统中是否存在，不存在就创建一个&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;。创建成功后，map 会被钉（pin）到 BPF 文件系统，因此当 egress 程 序通过 tc 加载之后，它就会发现这个 map 存在了，接下来会复用这个 map 而不是再创建 一个新的。在 map 存在的情况下，加载器还会确保 map 的属性（properties）是匹配的， 例如 key/value 大小等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;就像 tc 可以从同一 map 获取数据一样，第三方应用也可以用 bpf 系统调用中的 BPF_OBJ_GET 命令创建一个指向某个 map 实例的新文件描述符，然后用这个描述 符来查看/更新/删除 map 中的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;通过 clang 编译和 iproute2 加载：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ clang -O2 -Wall -target bpf -c tc-example.c -o tc-example.o&lt;br/&gt;&lt;br/&gt;$ tc qdisc add dev em1 clsact&lt;br/&gt;$ tc filter add dev em1 ingress bpf da obj tc-example.o sec ingress&lt;br/&gt;$ tc filter add dev em1 egress bpf da obj tc-example.o sec egress&lt;br/&gt;&lt;br/&gt;$ tc filter show dev em1 ingress&lt;br/&gt;filter protocol all pref 49152 bpf&lt;br/&gt;filter protocol all pref 49152 bpf handle 0x1 tc-example.o:[ingress] direct-action id 1 tag c5f7825e5dac396f&lt;br/&gt;&lt;br/&gt;$ tc filter show dev em1 egress&lt;br/&gt;filter protocol all pref 49152 bpf&lt;br/&gt;filter protocol all pref 49152 bpf handle 0x1 tc-example.o:[egress] direct-action id 2 tag b2fd5adc0f262714&lt;br/&gt;&lt;br/&gt;$ mount | grep bpf&lt;br/&gt;sysfs on /sys/fs/bpf &lt;span&gt;type&lt;/span&gt; sysfs (rw,nosuid,nodev,noexec,relatime,seclabel)&lt;br/&gt;bpf on /sys/fs/bpf &lt;span&gt;type&lt;/span&gt; bpf (rw,relatime,mode=0700)&lt;br/&gt;&lt;br/&gt;$ tree /sys/fs/bpf/&lt;br/&gt;/sys/fs/bpf/&lt;br/&gt;+-- ip -&amp;gt; /sys/fs/bpf/tc/&lt;br/&gt;+-- tc&lt;br/&gt;|   +-- globals&lt;br/&gt;|       +-- acc_map&lt;br/&gt;+-- xdp -&amp;gt; /sys/fs/bpf/tc/&lt;br/&gt;&lt;br/&gt;4 directories, 1 file&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;以上步骤指向完成后，当包经过 em 设备时，BPF map 中的计数器就会递增。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;不允许全局变量&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;出于第 1 条中提到的原因（只支持 BPF maps 重定位，译者注），BPF 不能使用全局变量 ，而常规 C 程序中是可以的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;但是，我们有间接的方式实现全局变量的效果：BPF 程序可以使用一个 BPF_MAP_TYPE_PERCPU_ARRAY 类型的、只有一个槽（slot）的、可以存放任意类型数据（ arbitrary value size）的 BPF map。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这可以实现全局变量的效果原因是，&lt;/span&gt;&lt;span&gt;BPF 程序在执行期间不会被内核抢占&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;，因此可以用单个 map entry 作为一个 scratch buffer 使用，存储临时数据，例如扩展 BPF 栈的限制（512 字节）。这种方式在尾调用中也是可 以工作的，因为尾调用执行期间也不会被抢占。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;另外，如果要在不同次 BPF 程序执行之间保持状态，使用常规的 BPF map 就可以了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;不支持常量字符串或数组（const strings or arrays）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF C 程序中不允许定义 const 字符串或其他数组，原因和第 1 点及第 3 点一样，即 ，ELF 文件中生成的 重定位项（relocation entries）会被加载器拒绝，因为不符合加载器的 ABI（加载器也无法修复这些重定位项，因为这需要对已经编译好的 BPF 序列进行大范围的重写）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;将来 LLVM 可能会检测这种情况，提前将错误抛给用户。现在可以用下面的辅助函数来作为短期解决方式（work around）：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;static void BPF_FUNC(trace_printk, const char *fmt, int fmt_size, ...);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef printk&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define printk(fmt, ...)                                      \&lt;/span&gt;&lt;br/&gt;    ({                                                         \&lt;br/&gt;        char ____fmt[] = fmt;                                  \&lt;br/&gt;        trace_printk(____fmt, sizeof(____fmt), &lt;span&gt;##__VA_ARGS__); \&lt;/span&gt;&lt;br/&gt;    })&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;有了上面的定义，程序就可以自然地使用这个宏，例如 printk(&quot;skb len:%u\n&quot;, skb-&amp;gt;len);。 输出会写到 trace pipe，用 tc exec bpf dbg 命令可以获取这些打印的消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;不过，使用 trace_printk() 辅助函数也有一些不足，&lt;/span&gt;&lt;span&gt;因此不建议在生产环境使用&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;。每次调用这个辅助函数时，常量字符串（例如 &quot;skb len:%u\n&quot;）都需要加载到 BPF 栈，但这个辅助函数最多只能接受 5 个参数，因此使用这个函数输出信息时只能传递三个参数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;因此，虽然这个辅助函数对快速调试很有用，但（对于网络程序）还是推荐使用 skb_event_output() 或 xdp_event_output() 辅助函数。这两个函数接受从 BPF 程序传递自定义的结构体类型参数，然后将参数以及可选的包数据（packet sample）放到 perf event ring buffer。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;例如，Cilium monitor 利用这些辅助函数实现了一个调试框架，以及在发现违反网络策略时发出通知等功能。这些函数通过一个无锁的、内存映射的、 per-CPU 的 perf ring buffer 传递数据，因此要远快于 trace_printk()。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;使用 LLVM 内置的函数做内存操作&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;因为 BPF 程序除了调用 BPF 辅助函数之外无法执行任何函数调用，因此常规的库代码必须 实现为内联函数。另外，LLVM 也提供了一些可以用于特定大小（这里是 n）的内置函数 ，这些函数永远都会被内联：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;section&gt;&lt;span&gt;#ifndef memset&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define memset(dest, chr, n)   __builtin_memset((dest), (chr), (n))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef memcpy&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define memcpy(dest, src, n)   __builtin_memcpy((dest), (src), (n))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef memmove&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define memmove(dest, src, n)  __builtin_memmove((dest), (src), (n))&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;/section&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;LLVM 后端中的某个问题会导致内置的 memcmp() 有某些边界场景下无法内联，因此在这个问题解决之前不推荐使用这个函数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;（目前还）不支持循环&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;内核中的 BPF 校验器除了对其他的控制流进行图验证（graph validation）之外，还会对所有程序路径执行深度优先搜索（depth first search），确保其中&lt;/span&gt;&lt;span&gt;不存在循环&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;。这样做的目的是确保程序永远会结束。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;但可以使用 #pragma unroll 指令实现常量的、不超过一定上限的循环。下面是一个例子：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;#pragma unroll&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; IPV6_MAX_HEADERS; i++) {&lt;br/&gt;        switch (nh) {&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; NEXTHDR_NONE:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; DROP_INVALID_EXTHDR;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; NEXTHDR_FRAGMENT:&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; DROP_FRAG_NOSUPPORT;&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; NEXTHDR_HOP:&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; NEXTHDR_ROUTING:&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; NEXTHDR_AUTH:&lt;br/&gt;        &lt;span&gt;case&lt;/span&gt; NEXTHDR_DEST:&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (skb_load_bytes(skb, l3_off + len, &amp;amp;opthdr, sizeof(opthdr)) &amp;lt; 0)&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; DROP_INVALID;&lt;br/&gt;&lt;br/&gt;            nh = opthdr.nexthdr;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (nh == NEXTHDR_AUTH)&lt;br/&gt;                len += ipv6_authlen(&amp;amp;opthdr);&lt;br/&gt;            &lt;span&gt;else&lt;/span&gt;&lt;br/&gt;                len += ipv6_optlen(&amp;amp;opthdr);&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        default:&lt;br/&gt;            *nexthdr = nh;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; len;&lt;br/&gt;        }&lt;br/&gt;    }&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;另外一种实现循环的方式是：用一个 BPF_MAP_TYPE_PERCPU_ARRAY map 作为本地 scratch space（存储空间），然后用尾调用的方式调用函数自身。虽然这种方式更加动态，但目前最大只支持 32 层嵌套调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;将来 BPF 可能会提供一些更加原生、但有一定限制的循环。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;尾调用的用途&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;尾调用能够从一个程序调到另一个程序，提供了在运行时（runtime）原子地改变程序行为的灵活性。为了选择要跳转到哪个程序，尾调用使用了程序数组 map（ BPF_MAP_TYPE_PROG_ARRAY），将 map 及其索引（index）传递给将要跳转到的程序。跳转动作一旦完成，就没有办法返回到原来的程序；但如果给定的 map 索引中没有程序（无法跳转），执行会继续在原来的程序中执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;例如，可以用尾调用实现解析器的不同阶段，可以在运行时（runtime）更新这些阶段的新解析特性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;尾调用的另一个用处是事件通知，例如，Cilium 可以在运行时（runtime）开启或关闭丢弃包的通知（packet drop notifications），其中对 skb_event_output() 的调用就是发 生在被尾调用的程序中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;因此，在常规情况下，&lt;/span&gt;&lt;span&gt;执行的永远是从上到下的路径&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;（ fall-through path），当某个程序被加入到相关的 map 索引之后，程序就会解析元数据， 触发向用户空间守护进程（user space daemon）发送事件通知。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;程序数组 map 非常灵活， map 中每个索引对应的程序可以实现各自的动作（actions）。例如，attach 到 tc 或 XDP 的 root 程序执行初始的、跳转到程序数组 map 中索引为 0 的程序，然后执行流量抽样（traffic sampling），然后跳转到索引为 1 的程序，在那个程序中应用防火墙策略，然后就可以决定是丢地包还是将其送到索引为 2 的程序中继续处理，在后者中，可能可能会被 mangle 然后再次通过某个接口发送出去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在程序数据 map 之中是可以随意跳转的。当达到尾调用的最大调用深度时，内核最终会执行 fall-through path。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;一个使用尾调用的最小程序示例：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;[...]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef __stringify&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define __stringify(X)   #X&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef __section&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define __section(NAME)                  \&lt;/span&gt;&lt;br/&gt;   __attribute__((section(NAME), used))&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef __section_tail&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define __section_tail(ID, KEY)          \&lt;/span&gt;&lt;br/&gt;   __section(__stringify(ID) &lt;span&gt;&quot;/&quot;&lt;/span&gt; __stringify(KEY))&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef BPF_FUNC&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define BPF_FUNC(NAME, ...)              \&lt;/span&gt;&lt;br/&gt;   (*NAME)(__VA_ARGS__) = (void *)BPF_FUNC_&lt;span&gt;##NAME&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#define BPF_JMP_MAP_ID   1&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;static void BPF_FUNC(tail_call, struct __sk_buff *skb, void *map,&lt;br/&gt;                     uint32_t index);&lt;br/&gt;&lt;br/&gt;struct bpf_elf_map jmp_map __section(&lt;span&gt;&quot;maps&quot;&lt;/span&gt;) = {&lt;br/&gt;    .&lt;span&gt;type&lt;/span&gt;           = BPF_MAP_TYPE_PROG_ARRAY,&lt;br/&gt;    .id             = BPF_JMP_MAP_ID,&lt;br/&gt;    .size_key       = sizeof(uint32_t),&lt;br/&gt;    .size_value     = sizeof(uint32_t),&lt;br/&gt;    .pinning        = PIN_GLOBAL_NS,&lt;br/&gt;    .max_elem       = 1,&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;__section_tail(JMP_MAP_ID, 0)&lt;br/&gt;int looper(struct __sk_buff *skb)&lt;br/&gt;{&lt;br/&gt;    printk(&lt;span&gt;&quot;skb cb: %u\n&quot;&lt;/span&gt;, skb-&amp;gt;cb[0]++);&lt;br/&gt;    tail_call(skb, &amp;amp;jmp_map, 0);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; TC_ACT_OK;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;__section(&lt;span&gt;&quot;prog&quot;&lt;/span&gt;)&lt;br/&gt;int entry(struct __sk_buff *skb)&lt;br/&gt;{&lt;br/&gt;    skb-&amp;gt;cb[0] = 0;&lt;br/&gt;    tail_call(skb, &amp;amp;jmp_map, 0);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; TC_ACT_OK;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;char __license[] __section(&lt;span&gt;&quot;license&quot;&lt;/span&gt;) = &lt;span&gt;&quot;GPL&quot;&lt;/span&gt;;&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;加载这个示例程序时，tc 会创建其中的程序数组（jmp_map 变量），并将其钉（pin）到 BPF 文件系统中全局命名空间下名为的 jump_map 位置。而且，iproute2 中的 BPF ELF 加载器也会识别出标记为 __section_tail() 的 section。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;jmp_map 的 id 字段会 跟__section_tail() 中的 id 字段（这里初始化为常量 JMP_MAP_ID）做匹配，因此程 序能加载到用户指定的索引（位置），在上面的例子中这个索引是 0。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;然后，所有的尾调用 section 将会被 iproute2 加载器处理，关联到 map 中。这个机制并不是 tc 特有的， iproute2 支持的其他 BPF 程序类型（例如 XDP、lwt）也适用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;生成的 elf 包含 section headers，描述 map id 和 map 内的条目：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ llvm-objdump -S --no-show-raw-insn prog_array.o | less&lt;br/&gt;prog_array.o:   file format ELF64-BPF&lt;br/&gt;&lt;br/&gt;Disassembly of section 1/0:&lt;br/&gt;looper:&lt;br/&gt;       0:       r6 = r1&lt;br/&gt;       1:       r2 = *(u32 *)(r6 + 48)&lt;br/&gt;       2:       r1 = r2&lt;br/&gt;       3:       r1 += 1&lt;br/&gt;       4:       *(u32 *)(r6 + 48) = r1&lt;br/&gt;       5:       r1 = 0 ll&lt;br/&gt;       7:       call -1&lt;br/&gt;       8:       r1 = r6&lt;br/&gt;       9:       r2 = 0 ll&lt;br/&gt;      11:       r3 = 0&lt;br/&gt;      12:       call 12&lt;br/&gt;      13:       r0 = 0&lt;br/&gt;      14:       &lt;span&gt;exit&lt;/span&gt;&lt;br/&gt;Disassembly of section prog:&lt;br/&gt;entry:&lt;br/&gt;       0:       r2 = 0&lt;br/&gt;       1:       *(u32 *)(r1 + 48) = r2&lt;br/&gt;       2:       r2 = 0 ll&lt;br/&gt;       4:       r3 = 0&lt;br/&gt;       5:       call 12&lt;br/&gt;       6:       r0 = 0&lt;br/&gt;       7:       exi&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在这个例子中，section 1/0 表示 looper() 函数位于 map 1 中，在 map 1 内的 位置是 0。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;被钉住（pinned）map 可以被用户空间应用（例如 Cilium daemon）读取，也可以被 tc 本 身读取，因为 tc 可能会用新的程序替换原来的程序，此时可能需要读取 map 内容。更新是原子的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;tc 执行尾调用 map 更新（tail call map updates）的例子：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ tc &lt;span&gt;exec&lt;/span&gt; bpf graft m:globals/jmp_map key 0 obj new.o sec foo&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;如果 iproute2 需要更新被钉住（pinned）的程序数组，可以使用 graft 命令。上面的 例子中指向的是 globals/jmp_map，那 tc 将会用一个新程序更新位于 index/key 为 0 的 map， 这个新程序位于对象文件 new.o 中的 foo section。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF 最大栈空间 512 字节&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF 程序的最大栈空间是 512 字节，在使用 C 语言实现 BPF 程序时需要考虑到这一点。但正如在第 3 点中提到的，可以通过一个只有一条记录（single entry）的 BPF_MAP_TYPE_PERCPU_ARRAY map 来绕过这限制，增大 scratch buffer 空间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;尝试使用 BPF 内联汇编&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;LLVM 6.0 以后支持 BPF 内联汇编，在某些场景下可能会用到。下面这个玩具示例程序（ 没有实际意义）展示了一个 64 位原子加操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;由于文档不足，要获取更多信息和例子，目前可能只能参考 LLVM 源码中的 lib/Target/BPF/BPFInstrInfo.td 以及 test/CodeGen/BPF/。测试代码：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;#include &amp;lt;linux/bpf.h&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#ifndef __section&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# define __section(NAME)                  \&lt;/span&gt;&lt;br/&gt;   __attribute__((section(NAME), used))&lt;br/&gt;&lt;span&gt;#endif&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;__section(&lt;span&gt;&quot;prog&quot;&lt;/span&gt;)&lt;br/&gt;int xdp_test(struct xdp_md *ctx)&lt;br/&gt;{&lt;br/&gt;    __u64 a = 2, b = 3, *c = &amp;amp;a;&lt;br/&gt;    /* just a toy xadd example to show the syntax */&lt;br/&gt;    asm volatile(&lt;span&gt;&quot;lock *(u64 *)(%0+0) += %1&quot;&lt;/span&gt; : &lt;span&gt;&quot;=r&quot;&lt;/span&gt;(c) : &lt;span&gt;&quot;r&quot;&lt;/span&gt;(b), &lt;span&gt;&quot;0&quot;&lt;/span&gt;(c));&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; a;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;char __license[] __section(&lt;span&gt;&quot;license&quot;&lt;/span&gt;) = &lt;span&gt;&quot;GPL&quot;&lt;/span&gt;;&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;上面的程序会被编译成下面的 BPF 指令序列：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;Verifier analysis:&lt;br/&gt;&lt;br/&gt;0: (b7) r1 = 2&lt;br/&gt;1: (7b) *(u64 *)(r10 -8) = r1&lt;br/&gt;2: (b7) r1 = 3&lt;br/&gt;3: (bf) r2 = r10&lt;br/&gt;4: (07) r2 += -8&lt;br/&gt;5: (db) lock *(u64 *)(r2 +0) += r1&lt;br/&gt;6: (79) r0 = *(u64 *)(r10 -8)&lt;br/&gt;7: (95) &lt;span&gt;exit&lt;/span&gt;&lt;br/&gt;processed 8 insns (&lt;span&gt;limit&lt;/span&gt; 131072), stack depth 8&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;用 #pragma pack 禁止结构体填充（struct padding）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;现代编译器默认会对数据结构进行内存对齐（align），以实现更加高效的访问。结构体成员会被对齐到数倍于其自身大小的内存位置，不足的部分会进行填充（padding），因此结构体最终的大小可能会比预想中大。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;struct called_info {&lt;br/&gt;    u64 start;  // 8-byte&lt;br/&gt;    u64 end;    // 8-byte&lt;br/&gt;    u32 sector; // 4-byte&lt;br/&gt;}; // size of 20-byte ?&lt;br/&gt;&lt;br/&gt;&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;size of %d-byte\n&quot;&lt;/span&gt;, sizeof(struct called_info)); // size of 24-byte&lt;br/&gt;&lt;br/&gt;// Actual compiled composition of struct called_info&lt;br/&gt;// 0x0(0)                   0x8(8)&lt;br/&gt;//  ↓________________________↓&lt;br/&gt;//  |        start (8)       |&lt;br/&gt;//  |________________________|&lt;br/&gt;//  |         end  (8)       |&lt;br/&gt;//  |________________________|&lt;br/&gt;//  |  sector(4) |  PADDING  | &amp;lt;= address aligned to 8&lt;br/&gt;//  |____________|___________|     with 4-byte PADDING.&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;内核中的 BPF 校验器会检查栈边界（stack boundary），BPF 程序不会访问栈边界外的空间，或者是未初始化的栈空间。如果将结构体中填充出来的内存区域作为一个 map 值进行 访问，那调用 bpf_prog_load() 时就会报 invalid indirect read from stack 错误。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;示例代码：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;struct called_info {&lt;br/&gt;    u64 start;&lt;br/&gt;    u64 end;&lt;br/&gt;    u32 sector;&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;struct bpf_map_def SEC(&lt;span&gt;&quot;maps&quot;&lt;/span&gt;) called_info_map = {&lt;br/&gt;    .&lt;span&gt;type&lt;/span&gt; = BPF_MAP_TYPE_HASH,&lt;br/&gt;    .key_size = sizeof(long),&lt;br/&gt;    .value_size = sizeof(struct called_info),&lt;br/&gt;    .max_entries = 4096,&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;SEC(&lt;span&gt;&quot;kprobe/submit_bio&quot;&lt;/span&gt;)&lt;br/&gt;int submit_bio_entry(struct pt_regs *ctx)&lt;br/&gt;{&lt;br/&gt;    char fmt[] = &lt;span&gt;&quot;submit_bio(bio=0x%lx) called: %llu\n&quot;&lt;/span&gt;;&lt;br/&gt;    u64 start_time = bpf_ktime_get_ns();&lt;br/&gt;    long bio_ptr = PT_REGS_PARM1(ctx);&lt;br/&gt;    struct called_info called_info = {&lt;br/&gt;            .start = start_time,&lt;br/&gt;            .end = 0,&lt;br/&gt;            .bi_sector = 0&lt;br/&gt;    };&lt;br/&gt;&lt;br/&gt;    bpf_map_update_elem(&amp;amp;called_info_map, &amp;amp;bio_ptr, &amp;amp;called_info, BPF_ANY);&lt;br/&gt;    bpf_trace_printk(fmt, sizeof(fmt), bio_ptr, start_time);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; 0;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// On bpf_load_program&lt;br/&gt;bpf_load_program() err=13&lt;br/&gt;0: (bf) r6 = r1&lt;br/&gt;...&lt;br/&gt;19: (b7) r1 = 0&lt;br/&gt;20: (7b) *(u64 *)(r10 -72) = r1&lt;br/&gt;21: (7b) *(u64 *)(r10 -80) = r7&lt;br/&gt;22: (63) *(u32 *)(r10 -64) = r1&lt;br/&gt;...&lt;br/&gt;30: (85) call bpf_map_update_elem&lt;span&gt;#2&lt;/span&gt;&lt;br/&gt;invalid indirect &lt;span&gt;read&lt;/span&gt; from stack off -80+20 size 24&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在 bpf_prog_load() 中会调用 BPF 校验器的 bpf_check() 函数，后者会调用 check_func_arg() -&amp;gt; check_stack_boundary() 来检查栈边界。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;从上面的错误可以看出 ，struct called_info 被编译成 24 字节，错误信息提示从 +20 位置读取数据是“非法的间接读取”（invalid indirect read）。从我们更前面给出的内存布局图中可以看到， 地址 0x14(20) 是填充（PADDING）开始的地方。这里再次画出内存布局图以方便对比：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;// Actual compiled composition of struct called_info&lt;br/&gt;// 0x10(16)    0x14(20)    0x18(24)&lt;br/&gt;//  ↓____________↓___________↓&lt;br/&gt;//  |  sector(4) |  PADDING  | &amp;lt;= address aligned to 8&lt;br/&gt;//  |____________|___________|     with 4-byte PADDING.&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;check_stack_boundary() 会遍历每一个从开始指针出发的 access_size (24) 字节，确保它们位于栈边界内部，并且栈内的所有元素都初始化了。因此填充的部分是不允许使用的，所以报了 “invalid indirect read from stack” 错误。要避免这种错误，需要将结构体中的填充去掉。这是通过 #pragma pack(n) 原语实现的：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;#pragma pack(4)&lt;/span&gt;&lt;br/&gt;struct called_info {&lt;br/&gt;    u64 start;  // 8-byte&lt;br/&gt;    u64 end;    // 8-byte&lt;br/&gt;    u32 sector; // 4-byte&lt;br/&gt;}; // size of 20-byte ?&lt;br/&gt;&lt;br/&gt;&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;size of %d-byte\n&quot;&lt;/span&gt;, sizeof(struct called_info)); // size of 20-byte&lt;br/&gt;&lt;br/&gt;// Actual compiled composition of packed struct called_info&lt;br/&gt;// 0x0(0)                   0x8(8)&lt;br/&gt;//  ↓________________________↓&lt;br/&gt;//  |        start (8)       |&lt;br/&gt;//  |________________________|&lt;br/&gt;//  |         end  (8)       |&lt;br/&gt;//  |________________________|&lt;br/&gt;//  |  sector(4) |             &amp;lt;= address aligned to 4&lt;br/&gt;//  |____________|                 with no PADDING.&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在 struct called_info 前面加上 #pragma pack(4) 之后，编译器会以 4 字节为单位进行对齐。上面的图可以看到，这个结构体现在已经变成 20 字节大小，没有填充了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;但是，&lt;/span&gt;&lt;span&gt;去掉填充也是有弊端的&lt;/span&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;。例如，编译器产生的代码没有原来优化的好。去掉填充之后 ，处理器访问结构体时触发的是非对齐访问（unaligned access），可能会导致性能下降。并且，某些架构上的校验器可能会直接拒绝非对齐访问。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;不过，我们也有一种方式可以避免产生自动填充：手动填充。我们简单地在结构体中加入一 个 u32 pad 成员来显式填充，这样既避免了自动填充的问题，又解决了非对齐访问的问题。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;struct called_info {&lt;br/&gt;    u64 start;  // 8-byte&lt;br/&gt;    u64 end;    // 8-byte&lt;br/&gt;    u32 sector; // 4-byte&lt;br/&gt;    u32 pad;    // 4-byte&lt;br/&gt;}; // size of 24-byte ?&lt;br/&gt;&lt;br/&gt;&lt;span&gt;printf&lt;/span&gt;(&lt;span&gt;&quot;size of %d-byte\n&quot;&lt;/span&gt;, sizeof(struct called_info)); // size of 24-byte&lt;br/&gt;&lt;br/&gt;// Actual compiled composition of struct called_info with explicit padding&lt;br/&gt;// 0x0(0)                   0x8(8)&lt;br/&gt;//  ↓________________________↓&lt;br/&gt;//  |        start (8)       |&lt;br/&gt;//  |________________________|&lt;br/&gt;//  |         end  (8)       |&lt;br/&gt;//  |________________________|&lt;br/&gt;//  |  sector(4) |  pad (4)  | &amp;lt;= address aligned to 8&lt;br/&gt;//  |____________|___________|     with explicit PADDING.&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;通过未验证的引用（invalidated references）访问包数据&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;某些网络相关的 BPF 辅助函数，例如 bpf_skb_store_bytes，可能会修改包的大小。校验器无法跟踪这类改动，因此它会将所有之前对包数据的引用都视为过期的（未验证的） 。因此，为避免程序被校验器拒绝，在访问数据之外需要先更新相应的引用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;来看下面的例子：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;struct iphdr *ip4 = (struct iphdr *) skb-&amp;gt;data + ETH_HLEN;&lt;br/&gt;&lt;br/&gt;skb_store_bytes(skb, l3_off + offsetof(struct iphdr, saddr), &amp;amp;new_saddr, 4, 0);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (ip4-&amp;gt;protocol == IPPROTO_TCP) {&lt;br/&gt;    // &lt;span&gt;do&lt;/span&gt; something&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;校验器会拒绝这段代码，因为它认为在 skb_store_bytes 执行之后，引用 ip4-&amp;gt;protocol 是未验证的（invalidated）：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;R1=pkt_end(id=0,off=0,imm=0) R2=pkt(id=0,off=34,r=34,imm=0) R3=inv0&lt;br/&gt;R6=ctx(id=0,off=0,imm=0) R7=inv(id=0,umax_value=4294967295,var_off=(0x0; 0xffffffff))&lt;br/&gt;R8=inv4294967162 R9=pkt(id=0,off=0,r=34,imm=0) R10=fp0,call_-1&lt;br/&gt;...&lt;br/&gt;18: (85) call bpf_skb_store_bytes&lt;span&gt;#9&lt;/span&gt;&lt;br/&gt;19: (7b) *(u64 *)(r10 -56) = r7&lt;br/&gt;R0=inv(id=0) R6=ctx(id=0,off=0,imm=0) R7=inv(id=0,umax_value=2,var_off=(0x0; 0x3))&lt;br/&gt;R8=inv4294967162 R9=inv(id=0) R10=fp0,call_-1 fp-48=mmmm???? fp-56=mmmmmmmm&lt;br/&gt;21: (61) r1 = *(u32 *)(r9 +23)&lt;br/&gt;R9 invalid mem access &lt;span&gt;&#x27;inv&#x27;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;要解决这个问题，必须更新（重新计算） ip4 的地址：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;struct iphdr *ip4 = (struct iphdr *) skb-&amp;gt;data + ETH_HLEN;&lt;br/&gt;&lt;br/&gt;skb_store_bytes(skb, l3_off + offsetof(struct iphdr, saddr), &amp;amp;new_saddr, 4, 0);&lt;br/&gt;&lt;br/&gt;ip4 = (struct iphdr *) skb-&amp;gt;data + ETH_HLEN;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (ip4-&amp;gt;protocol == IPPROTO_TCP) {&lt;br/&gt;    // &lt;span&gt;do&lt;/span&gt; something&lt;br/&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;—&lt;/em&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt; &lt;/strong&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;em&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-none-contnet=&quot;t&quot;&gt;3&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;span&gt; &lt;span&gt;&lt;em mpa-none-contnet=&quot;t&quot;&gt;—&lt;/em&gt;&lt;/span&gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;开发工具链&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;libbpf&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;bpftool&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;bpftool &lt;/span&gt;&lt;span&gt;是查看和调试 BPF 程序的主要工具。它随内核一起开发，在内核中的路径是 tools/bpf/bpftool/。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这个工具可以完成：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;dump 当前已经加载到系统中的所有 BPF 程序和 map&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;列出和指定程序相关的所有 BPF map&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;dump 整个 map 中的 key/value 对&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;查看、更新、删除特定 key&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;查看给定 key 的相邻 key（neighbor key）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;要执行这些操作可以指定 BPF 程序、map ID，或者指定 BPF 文件系统中程序或 map 的位 置。另外，这个工具还提供了将 map 或程序钉（pin）到 BPF 文件系统的功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;查看系统当前已经加载的 BPF 程序：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool prog&lt;br/&gt;398: sched_cls  tag 56207908be8ad877&lt;br/&gt;   loaded_at Apr 09/16:24  uid 0&lt;br/&gt;   xlated 8800B  jited 6184B  memlock 12288B  map_ids 18,5,17,14&lt;br/&gt;399: sched_cls  tag abc95fb4835a6ec9&lt;br/&gt;   loaded_at Apr 09/16:24  uid 0&lt;br/&gt;   xlated 344B  jited 223B  memlock 4096B  map_ids 18&lt;br/&gt;400: sched_cls  tag afd2e542b30ff3ec&lt;br/&gt;   loaded_at Apr 09/16:24  uid 0&lt;br/&gt;   xlated 1720B  jited 1001B  memlock 4096B  map_ids 17&lt;br/&gt;401: sched_cls  tag 2dbbd74ee5d51cc8&lt;br/&gt;   loaded_at Apr 09/16:24  uid 0&lt;br/&gt;   xlated 3728B  jited 2099B  memlock 4096B  map_ids 17&lt;br/&gt;[...]&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;类似地，查看所有的 active maps：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool map&lt;br/&gt;5: &lt;span&gt;hash&lt;/span&gt;  flags 0x0&lt;br/&gt;    key 20B  value 112B  max_entries 65535  memlock 13111296B&lt;br/&gt;6: &lt;span&gt;hash&lt;/span&gt;  flags 0x0&lt;br/&gt;    key 20B  value 20B  max_entries 65536  memlock 7344128B&lt;br/&gt;7: &lt;span&gt;hash&lt;/span&gt;  flags 0x0&lt;br/&gt;    key 10B  value 16B  max_entries 8192  memlock 790528B&lt;br/&gt;8: &lt;span&gt;hash&lt;/span&gt;  flags 0x0&lt;br/&gt;    key 22B  value 28B  max_entries 8192  memlock 987136B&lt;br/&gt;9: &lt;span&gt;hash&lt;/span&gt;  flags 0x0&lt;br/&gt;    key 20B  value 8B  max_entries 512000  memlock 49352704B&lt;br/&gt;[...]&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;bpftool 的每个命令都提供了以 json 格式打印的功能，在命令末尾指定 --json 就行了。另外，--pretty 会使得打印更加美观，看起来更清楚。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool prog --json --pretty&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;要 dump 特定 BPF 程序的 post-verifier BPF 指令镜像（instruction image），可以先 从查看一个具体程序开始，例如，查看 attach 到 tc ingress hook 上的程序：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ tc filter show dev cilium_host egress&lt;br/&gt;filter protocol all pref 1 bpf chain 0&lt;br/&gt;filter protocol all pref 1 bpf chain 0 handle 0x1 bpf_host.o:[from-netdev] \&lt;br/&gt;                    direct-action not_in_hw id 406 tag e0362f5bd9163a0a jited&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这个程序是从对象文件 bpf_host.o 加载来的，程序位于对象文件的 from-netdev section，程序 ID 为 406。基于以上信息 bpftool 可以提供一些关于这个程序的上层元数据：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool prog show id 406&lt;br/&gt;406: sched_cls  tag e0362f5bd9163a0a&lt;br/&gt;     loaded_at Apr 09/16:24  uid 0&lt;br/&gt;     xlated 11144B  jited 7721B  memlock 12288B  map_ids 18,20,8,5,6,14&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;从上面的输出可以看到：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;程序 ID 为 406，类型是 sched_cls（BPF_PROG_TYPE_SCHED_CLS），有一个 tag 为 e0362f5bd9163a0a（指令序列的 SHA sum）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这个程序被 root uid 0 在 Apr 09/16:24 加载&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF 指令序列有 11,144 bytes 长，JIT 之后的镜像有 7,721 bytes&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;程序自身（不包括 maps）占用了 12,288 bytes，这部分空间使用的是 uid 0 用户 的配额&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF 程序使用了 ID 为 18、20 8 5 6 和 14 的 BPF map。可以用这些 ID 进一步 dump map 自身或相关信息&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;另外，bpftool 可以 dump 出运行中程序的 BPF 指令：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool prog dump xlated id 406&lt;br/&gt; 0: (b7) r7 = 0&lt;br/&gt; 1: (63) *(u32 *)(r1 +60) = r7&lt;br/&gt; 2: (63) *(u32 *)(r1 +56) = r7&lt;br/&gt; 3: (63) *(u32 *)(r1 +52) = r7&lt;br/&gt;[...]&lt;br/&gt;47: (bf) r4 = r10&lt;br/&gt;48: (07) r4 += -40&lt;br/&gt;49: (79) r6 = *(u64 *)(r10 -104)&lt;br/&gt;50: (bf) r1 = r6&lt;br/&gt;51: (18) r2 = map[id:18]                    &amp;lt;-- BPF map id 18&lt;br/&gt;53: (b7) r5 = 32&lt;br/&gt;54: (85) call bpf_skb_event_output&lt;span&gt;#5656112  &amp;lt;-- BPF helper call&lt;/span&gt;&lt;br/&gt;55: (69) r1 = *(u16 *)(r6 +192)&lt;br/&gt;[...]&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;如上面的输出所示，bpftool 将指令流中的 BPF map ID、BPF 辅助函数或其他 BPF 程序都 做了关联。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;和内核的 BPF 校验器一样，bpftool dump 指令流时复用了同一个使输出更美观的打印程序 （pretty-printer）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;由于程序被 JIT，因此真正执行的是生成的 JIT 镜像（从上面 xlated 中的指令生成的 ），这些指令也可以通过 bpftool 查看：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool prog dump jited id 406&lt;br/&gt; 0:        push   %rbp&lt;br/&gt; 1:        mov    %rsp,%rbp&lt;br/&gt; 4:        sub    &lt;span&gt;$0x228&lt;/span&gt;,%rsp&lt;br/&gt; b:        sub    &lt;span&gt;$0x28&lt;/span&gt;,%rbp&lt;br/&gt; f:        mov    %rbx,0x0(%rbp)&lt;br/&gt;13:        mov    %r13,0x8(%rbp)&lt;br/&gt;17:        mov    %r14,0x10(%rbp)&lt;br/&gt;1b:        mov    %r15,0x18(%rbp)&lt;br/&gt;1f:        xor    %eax,%eax&lt;br/&gt;21:        mov    %rax,0x20(%rbp)&lt;br/&gt;25:        mov    0x80(%rdi),%r9d&lt;br/&gt;[...]&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;另外，还可以指定在输出中将反汇编之后的指令关联到 opcodes，这个功能主要对 BPF JIT 开发者比较有用：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool prog dump jited id 406 opcodes&lt;br/&gt; 0:        push   %rbp&lt;br/&gt;           55&lt;br/&gt; 1:        mov    %rsp,%rbp&lt;br/&gt;           48 89 e5&lt;br/&gt; 4:        sub    &lt;span&gt;$0x228&lt;/span&gt;,%rsp&lt;br/&gt;           48 81 ec 28 02 00 00&lt;br/&gt; b:        sub    &lt;span&gt;$0x28&lt;/span&gt;,%rbp&lt;br/&gt;           48 83 ed 28&lt;br/&gt; f:        mov    %rbx,0x0(%rbp)&lt;br/&gt;           48 89 5d 00&lt;br/&gt;13:        mov    %r13,0x8(%rbp)&lt;br/&gt;           4c 89 6d 08&lt;br/&gt;17:        mov    %r14,0x10(%rbp)&lt;br/&gt;           4c 89 75 10&lt;br/&gt;1b:        mov    %r15,0x18(%rbp)&lt;br/&gt;           4c 89 7d 18&lt;br/&gt;[...]&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;同样，也可以将常规的 BPF 指令关联到 opcodes，有时在内核中进行调试时会比较有用：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool prog dump xlated id 406 opcodes&lt;br/&gt; 0: (b7) r7 = 0&lt;br/&gt;    b7 07 00 00 00 00 00 00&lt;br/&gt; 1: (63) *(u32 *)(r1 +60) = r7&lt;br/&gt;    63 71 3c 00 00 00 00 00&lt;br/&gt; 2: (63) *(u32 *)(r1 +56) = r7&lt;br/&gt;    63 71 38 00 00 00 00 00&lt;br/&gt; 3: (63) *(u32 *)(r1 +52) = r7&lt;br/&gt;    63 71 34 00 00 00 00 00&lt;br/&gt; 4: (63) *(u32 *)(r1 +48) = r7&lt;br/&gt;    63 71 30 00 00 00 00 00&lt;br/&gt; 5: (63) *(u32 *)(r1 +64) = r7&lt;br/&gt;    63 71 40 00 00 00 00 00&lt;br/&gt; [...]&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;此外，还可以用 graphviz 以可视化的方式展示程序的基本组成部分。bpftool 提供了一 个 visual dump 模式，这种模式下输出的不是 BPF xlated 指令文本，而是一张点图（ dot graph），后者可以转换成 png 格式的图片：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool prog dump xlated id 406 visual &amp;amp;&amp;gt; output.dot&lt;br/&gt;&lt;br/&gt;$ dot -Tpng output.dot -o output.png&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;也可以用 dotty 打开生成的点图文件：dotty output.dot，bpf_host.o 程序的效果如 下图所示（一部分）：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.9019607843137254&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vHicVZXtcAzDp8dEicxVWG7Zzv3hKlzKexIOoPKHSuYm1CYVOR5Tt3nJ3Ge4c4FcQTJ0zSQzWQPyzp9rEVRsGbGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;408&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;注意，xlated 中 dump 出来的指令是经过校验器之后（post-verifier）的 BPF 指令镜 像，即和 BPF 解释器中执行的版本是一样的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在内核中，校验器会对 BPF 加载器提供的原始指令执行各种重新（rewrite）。一个例子就 是对辅助函数进行内联化（inlining）以提高运行时性能，下面是对一个哈希表查找的优化：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool prog dump xlated id 3&lt;br/&gt; 0: (b7) r1 = 2&lt;br/&gt; 1: (63) *(u32 *)(r10 -4) = r1&lt;br/&gt; 2: (bf) r2 = r10&lt;br/&gt; 3: (07) r2 += -4&lt;br/&gt; 4: (18) r1 = map[id:2]                      &amp;lt;-- BPF map id 2&lt;br/&gt; 6: (85) call __htab_map_lookup_elem&lt;span&gt;#77408   &amp;lt;-+ BPF helper inlined rewrite&lt;/span&gt;&lt;br/&gt; 7: (15) &lt;span&gt;if&lt;/span&gt; r0 == 0x0 goto pc+2                |&lt;br/&gt; 8: (07) r0 += 56                              |&lt;br/&gt; 9: (79) r0 = *(u64 *)(r0 +0)                &amp;lt;-+&lt;br/&gt;10: (15) &lt;span&gt;if&lt;/span&gt; r0 == 0x0 goto pc+24&lt;br/&gt;11: (bf) r2 = r10&lt;br/&gt;12: (07) r2 += -4&lt;br/&gt;[...]&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;bpftool 通过 kallsyms 来对辅助函数或 BPF-to-BPF 调用进行关联。因此，确保 JIT 之 后的 BPF 程序暴露到了 kallsyms（bpf_jit_kallsyms），并且 kallsyms 地址是明确的 （否则调用显示的就是 call bpf_unspec#0）：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ &lt;span&gt;echo&lt;/span&gt; 0 &amp;gt; /proc/sys/kernel/kptr_restrict&lt;br/&gt;$ &lt;span&gt;echo&lt;/span&gt; 1 &amp;gt; /proc/sys/net/core/bpf_jit_kallsyms&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF-to-BPF 调用在解释器和 JIT 镜像中也做了关联。对于后者，子程序的 tag 会显示为 调用目标（call target）。在两种情况下，pc+2 都是调用目标的程序计数器偏置（ pc-relative offset），表示就是子程序的地址。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool prog dump xlated id 1&lt;br/&gt;0: (85) call pc+2&lt;span&gt;#__bpf_prog_run_args32&lt;/span&gt;&lt;br/&gt;1: (b7) r0 = 1&lt;br/&gt;2: (95) &lt;span&gt;exit&lt;/span&gt;&lt;br/&gt;3: (b7) r0 = 2&lt;br/&gt;4: (95) &lt;span&gt;exit&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;对应的 JIT 版本：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool prog dump xlated id 1&lt;br/&gt;0: (85) call pc+2&lt;span&gt;#bpf_prog_3b185187f1855c4c_F&lt;/span&gt;&lt;br/&gt;1: (b7) r0 = 1&lt;br/&gt;2: (95) &lt;span&gt;exit&lt;/span&gt;&lt;br/&gt;3: (b7) r0 = 2&lt;br/&gt;4: (95) &lt;span&gt;exit&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在尾调用中，内核会将它们映射为同一个指令，但 bpftool 还是会将它们作为辅助函数进 行关联，以方便调试：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool prog dump xlated id 2&lt;br/&gt;[...]&lt;br/&gt;10: (b7) r2 = 8&lt;br/&gt;11: (85) call bpf_trace_printk&lt;span&gt;#-41312&lt;/span&gt;&lt;br/&gt;12: (bf) r1 = r6&lt;br/&gt;13: (18) r2 = map[id:1]&lt;br/&gt;15: (b7) r3 = 0&lt;br/&gt;16: (85) call bpf_tail_call&lt;span&gt;#12&lt;/span&gt;&lt;br/&gt;17: (b7) r1 = 42&lt;br/&gt;18: (6b) *(u16 *)(r6 +46) = r1&lt;br/&gt;19: (b7) r0 = 0&lt;br/&gt;20: (95) &lt;span&gt;exit&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;$ bpftool map show id 1&lt;br/&gt;1: prog_array  flags 0x0&lt;br/&gt;      key 4B  value 4B  max_entries 1  memlock 4096B&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;map dump 子命令可以 dump 整个 map，它会遍历所有的 map 元素，输出 key/value。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;如果 map 中没有可用的 BTF 数据，那 key/value 会以十六进制格式输出：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ bpftool map dump id 5&lt;br/&gt;key:&lt;br/&gt;f0 0d 00 00 00 00 00 00  0a 66 00 00 00 00 8a d6&lt;br/&gt;02 00 00 00&lt;br/&gt;value:&lt;br/&gt;00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00&lt;br/&gt;00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00&lt;br/&gt;00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00&lt;br/&gt;00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00&lt;br/&gt;00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00&lt;br/&gt;00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00&lt;br/&gt;00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00&lt;br/&gt;key:&lt;br/&gt;0a 66 1c ee 00 00 00 00  00 00 00 00 00 00 00 00&lt;br/&gt;01 00 00 00&lt;br/&gt;value:&lt;br/&gt;00 00 00 00 00 00 00 00  01 00 00 00 00 00 00 00&lt;br/&gt;00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00&lt;br/&gt;[...]&lt;br/&gt;Found 6 elements&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;如果有 BTF 数据，map 就有了关于 key/value 结构体的调试信息。例如，BTF 信息加上 BPF map 以及 iproute2 中的 BPF_ANNOTATE_KV_PAIR() 会产生下面的输出（内核 selftests 中的 test_xdp_noinline.o）：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ cat tools/testing/selftests/bpf/test_xdp_noinline.c&lt;br/&gt;  []&lt;br/&gt;   struct ctl_value {&lt;br/&gt;         union {&lt;br/&gt;                 __u64 value;&lt;br/&gt;                 __u32 ifindex;&lt;br/&gt;                 __u8 mac[6];&lt;br/&gt;         };&lt;br/&gt;   };&lt;br/&gt;&lt;br/&gt;   struct bpf_map_def __attribute__ ((section(&lt;span&gt;&quot;maps&quot;&lt;/span&gt;), used)) ctl_array = {&lt;br/&gt;          .&lt;span&gt;type&lt;/span&gt;  = BPF_MAP_TYPE_ARRAY,&lt;br/&gt;          .key_size = sizeof(__u32),&lt;br/&gt;          .value_size = sizeof(struct ctl_value),&lt;br/&gt;          .max_entries = 16,&lt;br/&gt;          .map_flags = 0,&lt;br/&gt;   };&lt;br/&gt;   BPF_ANNOTATE_KV_PAIR(ctl_array, __u32, struct ctl_value);&lt;br/&gt;&lt;br/&gt;   []&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF_ANNOTATE_KV_PAIR() 宏强制每个 map-specific ELF section 包含一个空的 key/value，这样 iproute2 BPF 加载器可以将 BTF 数据关联到这个 section，因此在加载 map 时可用从 BTF 中选择响应的类型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;使用 LLVM 编译，并使用 pahole 基于调试信息产生 BTF：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ clang [...] -O2 -target bpf -g -emit-llvm -c test_xdp_noinline.c -o - |&lt;br/&gt;  llc -march=bpf -mcpu=probe -mattr=dwarfris -filetype=obj -o test_xdp_noinline.o&lt;br/&gt;&lt;br/&gt;$ pahole -J test_xdp_noinline.o&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;加载到内核，然后使用 bpftool dump 这个 map：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ ip -force link &lt;span&gt;set&lt;/span&gt; dev lo xdp obj test_xdp_noinline.o sec xdp-test&lt;br/&gt;$ ip a&lt;br/&gt;1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 xdpgeneric/id:227 qdisc noqueue state UNKNOWN group default qlen 1000&lt;br/&gt;    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00&lt;br/&gt;    inet 127.0.0.1/8 scope host lo&lt;br/&gt;       valid_lft forever preferred_lft forever&lt;br/&gt;    inet6 ::1/128 scope host&lt;br/&gt;       valid_lft forever preferred_lft forever&lt;br/&gt;[...]&lt;br/&gt;&lt;br/&gt;$ bpftool prog show id 227&lt;br/&gt;227: xdp  tag a85e060c275c5616  gpl&lt;br/&gt;    loaded_at 2018-07-17T14:41:29+0000  uid 0&lt;br/&gt;    xlated 8152B  not jited  memlock 12288B  map_ids 381,385,386,382,384,383&lt;br/&gt;&lt;br/&gt;$ bpftool map dump id 386&lt;br/&gt; [{&lt;br/&gt;      &lt;span&gt;&quot;key&quot;&lt;/span&gt;: 0,&lt;br/&gt;      &lt;span&gt;&quot;value&quot;&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;&quot;&quot;&lt;/span&gt;: {&lt;br/&gt;              &lt;span&gt;&quot;value&quot;&lt;/span&gt;: 0,&lt;br/&gt;              &lt;span&gt;&quot;ifindex&quot;&lt;/span&gt;: 0,&lt;br/&gt;              &lt;span&gt;&quot;mac&quot;&lt;/span&gt;: []&lt;br/&gt;          }&lt;br/&gt;      }&lt;br/&gt;  },{&lt;br/&gt;      &lt;span&gt;&quot;key&quot;&lt;/span&gt;: 1,&lt;br/&gt;      &lt;span&gt;&quot;value&quot;&lt;/span&gt;: {&lt;br/&gt;          &lt;span&gt;&quot;&quot;&lt;/span&gt;: {&lt;br/&gt;              &lt;span&gt;&quot;value&quot;&lt;/span&gt;: 0,&lt;br/&gt;              &lt;span&gt;&quot;ifindex&quot;&lt;/span&gt;: 0,&lt;br/&gt;              &lt;span&gt;&quot;mac&quot;&lt;/span&gt;: []&lt;br/&gt;          }&lt;br/&gt;      }&lt;br/&gt;  },{&lt;br/&gt;[...]&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;针对 map 的某个 key，也可用通过 bpftool 查看、更新、删除和获取下一个 key（’get next key’）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF sysctls&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Linux 内核提供了一些 BPF 相关的 sysctl 配置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;/proc/sys/net/core/bpf_jit_enable：启用或禁用 BPF JIT 编译器。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| Value | Description                                                       |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| 0     | Disable the JIT and use only interpreter (kernel&lt;span&gt;&#x27;s default value) |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| 1     | Enable the JIT compiler                                           |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| 2     | Enable the JIT and emit debugging traces to the kernel log        |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;后面会介绍到，当 JIT 编译设置为调试模式（option 2）时，bpf_jit_disasm 工 具能够处理调试跟踪信息（debugging traces）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;/proc/sys/net/core/bpf_jit_harden：启用会禁用 BPF JIT 加固。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;注意，启用加固会降低性能，但能够降低 JIT spraying（喷射）攻击，因为它会禁止 （blind）BPF 程序使用立即值（immediate values）。对于通过解释器处理的程序， 禁用（blind）立即值是没有必要的（也是没有去做的）。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| Value | Description                                                       |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| 0     | Disable JIT hardening (kernel&lt;span&gt;&#x27;s default value)                    |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| 1     | Enable JIT hardening for unprivileged users only                  |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| 2     | Enable JIT hardening for all users                                |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;/proc/sys/net/core/bpf_jit_kallsyms：是否允许 JIT 后的程序作为内核符号暴露到 /proc/kallsyms。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;启用后，这些符号可以被 perf 这样的工具识别，使内核在做 stack unwinding 时 能感知到这些地址，例如，在 dump stack trace 的时候，符合名中会包含 BPF 程序 tag（bpf_prog_&amp;lt;tag&amp;gt;）。如果启用了 bpf_jit_harden，这个特性就会自动被禁用。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| Value | Description                                                       |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| 0     | Disable JIT kallsyms &lt;span&gt;export&lt;/span&gt; (kernel&lt;span&gt;&#x27;s default value)              |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| 1     | Enable JIT kallsyms export for privileged users only              |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;/proc/sys/kernel/unprivileged_bpf_disabled：是否允许非特权用户使用 bpf(2) 系统调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;内核默认允许非特权用户使用 bpf(2) 系统调用，但一旦将这个开关关闭，必须重启 内核才能再次将其打开。因此这是一个一次性开关（one-time switch），一旦关闭， 不管是应用还是管理员都无法再次修改。这个开关不影响 cBPF 程序（例如 seccomp） 或 传统的没有使用 bpf(2) 系统调用的 socket 过滤器 加载程序到内核。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| Value | Description                                                       |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| 0     | Unprivileged use of bpf syscall enabled (kernel&lt;span&gt;&#x27;s default value)  |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;br/&gt;| 1     | Unprivileged use of bpf syscall disabled                          |&lt;br/&gt;+-------+-------------------------------------------------------------------+&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;内核测试&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Linux 内核自带了一个 selftest 套件，在内核源码树中的路径是 tools/testing/selftests/bpf/。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ &lt;span&gt;cd&lt;/span&gt; tools/testing/selftests/bpf/&lt;br/&gt;$ make&lt;br/&gt;$ make run_tests&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;测试用例包括：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF 校验器、程序 tags、BPF map 接口和 map 类型的很多测试用例&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;用于 LLVM 后端的运行时测试，用 C 代码实现&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;用于解释器和 JIT 的测试，运行在内核，用 eBPF 和 cBPF 汇编实现&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;JIT Debugging&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;对于执行审计或编写扩展的 JIT 开发人员，每次编译运行都可以通过以下方式将生成的 JIT 镜像输出到内核日志中：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ &lt;span&gt;echo&lt;/span&gt; 2 &amp;gt; /proc/sys/net/core/bpf_jit_enable&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;每当加载新的 BPF 程序时，JIT 编译器都会转储输出，然后可以使用 dmesg 检查，例如：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;[ 3389.935842] flen=6 proglen=70 pass=3 image=ffffffffa0069c8f from=tcpdump pid=20583&lt;br/&gt;[ 3389.935847] JIT code: 00000000: 55 48 89 e5 48 83 ec 60 48 89 5d f8 44 8b 4f 68&lt;br/&gt;[ 3389.935849] JIT code: 00000010: 44 2b 4f 6c 4c 8b 87 d8 00 00 00 be 0c 00 00 00&lt;br/&gt;[ 3389.935850] JIT code: 00000020: e8 1d 94 ff e0 3d 00 08 00 00 75 16 be 17 00 00&lt;br/&gt;[ 3389.935851] JIT code: 00000030: 00 e8 28 94 ff e0 83 f8 01 75 07 b8 ff ff 00 00&lt;br/&gt;[ 3389.935852] JIT code: 00000040: eb 02 31 c0 c9 c3&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;flen 是 BPF 程序的长度（这里是 6 个 BPF 指令），proglen 告诉 JIT 为操作码图像生成的字节数（这里是 70 字节大小）。pass 意味着图像是在 3 次编译器 pass 中生成的，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;例如，x86_64 可以有各种优化 pass 以在可能的情况下进一步减小图像大小。image 包含生成的 JIT 镜像的地址，from 和 pid 分别是用户空间应用程序名称和 PID，它们触发了编译过程。eBPF 和 cBPF JIT 的转储输出格式相同。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;在 tools/bpf/ 下的内核树中，有一个名为 bpf_jit_disasm 的工具。它读出最新的转储并打印反汇编以供进一步检查：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ ./bpf_jit_disasm&lt;br/&gt;70 bytes emitted from JIT compiler (pass:3, flen:6)&lt;br/&gt;ffffffffa0069c8f + &amp;lt;x&amp;gt;:&lt;br/&gt;   0:       push   %rbp&lt;br/&gt;   1:       mov    %rsp,%rbp&lt;br/&gt;   4:       sub    &lt;span&gt;$0x60&lt;/span&gt;,%rsp&lt;br/&gt;   8:       mov    %rbx,-0x8(%rbp)&lt;br/&gt;   c:       mov    0x68(%rdi),%r9d&lt;br/&gt;  10:       sub    0x6c(%rdi),%r9d&lt;br/&gt;  14:       mov    0xd8(%rdi),%r8&lt;br/&gt;  1b:       mov    &lt;span&gt;$0xc&lt;/span&gt;,%esi&lt;br/&gt;  20:       callq  0xffffffffe0ff9442&lt;br/&gt;  25:       cmp    &lt;span&gt;$0x800&lt;/span&gt;,%eax&lt;br/&gt;  2a:       jne    0x0000000000000042&lt;br/&gt;  2c:       mov    &lt;span&gt;$0x17&lt;/span&gt;,%esi&lt;br/&gt;  31:       callq  0xffffffffe0ff945e&lt;br/&gt;  36:       cmp    &lt;span&gt;$0x1&lt;/span&gt;,%eax&lt;br/&gt;  39:       jne    0x0000000000000042&lt;br/&gt;  3b:       mov    &lt;span&gt;$0xffff&lt;/span&gt;,%eax&lt;br/&gt;  40:       jmp    0x0000000000000044&lt;br/&gt;  42:       xor    %eax,%eax&lt;br/&gt;  44:       leaveq&lt;br/&gt;  45:       retq&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;或者，该工具还可以将相关操作码与反汇编一起转储。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ ./bpf_jit_disasm -o&lt;br/&gt;70 bytes emitted from JIT compiler (pass:3, flen:6)&lt;br/&gt;ffffffffa0069c8f + &amp;lt;x&amp;gt;:&lt;br/&gt;   0:       push   %rbp&lt;br/&gt;    55&lt;br/&gt;   1:       mov    %rsp,%rbp&lt;br/&gt;    48 89 e5&lt;br/&gt;   4:       sub    &lt;span&gt;$0x60&lt;/span&gt;,%rsp&lt;br/&gt;    48 83 ec 60&lt;br/&gt;   8:       mov    %rbx,-0x8(%rbp)&lt;br/&gt;    48 89 5d f8&lt;br/&gt;   c:       mov    0x68(%rdi),%r9d&lt;br/&gt;    44 8b 4f 68&lt;br/&gt;  10:       sub    0x6c(%rdi),%r9d&lt;br/&gt;    44 2b 4f 6c&lt;br/&gt;  14:       mov    0xd8(%rdi),%r8&lt;br/&gt;    4c 8b 87 d8 00 00 00&lt;br/&gt;  1b:       mov    &lt;span&gt;$0xc&lt;/span&gt;,%esi&lt;br/&gt;    be 0c 00 00 00&lt;br/&gt;  20:       callq  0xffffffffe0ff9442&lt;br/&gt;    e8 1d 94 ff e0&lt;br/&gt;  25:       cmp    &lt;span&gt;$0x800&lt;/span&gt;,%eax&lt;br/&gt;    3d 00 08 00 00&lt;br/&gt;  2a:       jne    0x0000000000000042&lt;br/&gt;    75 16&lt;br/&gt;  2c:       mov    &lt;span&gt;$0x17&lt;/span&gt;,%esi&lt;br/&gt;    be 17 00 00 00&lt;br/&gt;  31:       callq  0xffffffffe0ff945e&lt;br/&gt;    e8 28 94 ff e0&lt;br/&gt;  36:       cmp    &lt;span&gt;$0x1&lt;/span&gt;,%eax&lt;br/&gt;    83 f8 01&lt;br/&gt;  39:       jne    0x0000000000000042&lt;br/&gt;    75 07&lt;br/&gt;  3b:       mov    &lt;span&gt;$0xffff&lt;/span&gt;,%eax&lt;br/&gt;    b8 ff ff 00 00&lt;br/&gt;  40:       jmp    0x0000000000000044&lt;br/&gt;    eb 02&lt;br/&gt;  42:       xor    %eax,%eax&lt;br/&gt;    31 c0&lt;br/&gt;  44:       leaveq&lt;br/&gt;    c9&lt;br/&gt;  45:       retq&lt;br/&gt;    c3&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;最近，bpftool 采用了相同的功能，即根据系统中已加载的给定 BPF 程序 ID 转储 BPF JIT 镜像。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;对于 JITed BPF 程序的性能分析，perf 可以照常使用。作为先决条件，需要通过 kallsyms 基础设施导出 JIT 程序。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ &lt;span&gt;echo&lt;/span&gt; 1 &amp;gt; /proc/sys/net/core/bpf_jit_enable&lt;br/&gt;$ &lt;span&gt;echo&lt;/span&gt; 1 &amp;gt; /proc/sys/net/core/bpf_jit_kallsyms&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;启用或禁用 bpf_jit_kallsyms 不需要重新加载相关的 BPF 程序。接下来，提供了一个小型工作流示例来分析 BPF 程序。一个精心制作的 tc BPF 程序用于演示目的，其中 perf 在 bpf_clone_redirect() 帮助程序中记录了失败的分配。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;由于使用直接写入，bpf_try_make_head_writable() 失败，然后会再次释放克隆的 skb 并返回错误消息。因此 perf 记录了所有 kfree_skb 事件。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ tc qdisc add dev em1 clsact&lt;br/&gt;$ tc filter add dev em1 ingress bpf da obj prog.o sec main&lt;br/&gt;$ tc filter show dev em1 ingress&lt;br/&gt;filter protocol all pref 49152 bpf&lt;br/&gt;filter protocol all pref 49152 bpf handle 0x1 prog.o:[main] direct-action id 1 tag 8227addf251b7543&lt;br/&gt;&lt;br/&gt;$ cat /proc/kallsyms&lt;br/&gt;[...]&lt;br/&gt;ffffffffc00349e0 t fjes_hw_init_command_registers    [fjes]&lt;br/&gt;ffffffffc003e2e0 d __tracepoint_fjes_hw_stop_debug_err    [fjes]&lt;br/&gt;ffffffffc0036190 t fjes_hw_epbuf_tx_pkt_send    [fjes]&lt;br/&gt;ffffffffc004b000 t bpf_prog_8227addf251b7543&lt;br/&gt;&lt;br/&gt;$ perf record -a -g -e skb:kfree_skb sleep 60&lt;br/&gt;$ perf script --kallsyms=/proc/kallsyms&lt;br/&gt;[...]&lt;br/&gt;ksoftirqd/0     6 [000]  1004.578402:    skb:kfree_skb: skbaddr=0xffff9d4161f20a00 protocol=2048 location=0xffffffffc004b52c&lt;br/&gt;   7fffb8745961 bpf_clone_redirect (/lib/modules/4.10.0+/build/vmlinux)&lt;br/&gt;   7fffc004e52c bpf_prog_8227addf251b7543 (/lib/modules/4.10.0+/build/vmlinux)&lt;br/&gt;   7fffc05b6283 cls_bpf_classify (/lib/modules/4.10.0+/build/vmlinux)&lt;br/&gt;   7fffb875957a tc_classify (/lib/modules/4.10.0+/build/vmlinux)&lt;br/&gt;   7fffb8729840 __netif_receive_skb_core (/lib/modules/4.10.0+/build/vmlinux)&lt;br/&gt;   7fffb8729e38 __netif_receive_skb (/lib/modules/4.10.0+/build/vmlinux)&lt;br/&gt;   7fffb872ae05 process_backlog (/lib/modules/4.10.0+/build/vmlinux)&lt;br/&gt;   7fffb872a43e net_rx_action (/lib/modules/4.10.0+/build/vmlinux)&lt;br/&gt;   7fffb886176c __do_softirq (/lib/modules/4.10.0+/build/vmlinux)&lt;br/&gt;   7fffb80ac5b9 run_ksoftirqd (/lib/modules/4.10.0+/build/vmlinux)&lt;br/&gt;   7fffb80ca7fa smpboot_thread_fn (/lib/modules/4.10.0+/build/vmlinux)&lt;br/&gt;   7fffb80c6831 kthread (/lib/modules/4.10.0+/build/vmlinux)&lt;br/&gt;   7fffb885e09c ret_from_fork (/lib/modules/4.10.0+/build/vmlinux)&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;perf 记录的堆栈跟踪将显示 bpf_prog_8227addf251b7543() 符号作为调用跟踪的一部分，这意味着带有标签 8227addf251b7543 的 BPF 程序与 kfree_skb 事件相关，并且该程序在入口挂钩上附加到 netdevice em1 为 由 tc 显示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;内省&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Linux 内核围绕 BPF 和 XDP 提供了多种 tracepoints，这些 tracepoints 可以用于进一 步查看系统内部行为，例如，跟踪用户空间程序和 bpf 系统调用的交互。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF 相关的 tracepoints：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ perf list | grep bpf:&lt;br/&gt;bpf:bpf_map_create                                 [Tracepoint event]&lt;br/&gt;bpf:bpf_map_delete_elem                            [Tracepoint event]&lt;br/&gt;bpf:bpf_map_lookup_elem                            [Tracepoint event]&lt;br/&gt;bpf:bpf_map_next_key                               [Tracepoint event]&lt;br/&gt;bpf:bpf_map_update_elem                            [Tracepoint event]&lt;br/&gt;bpf:bpf_obj_get_map                                [Tracepoint event]&lt;br/&gt;bpf:bpf_obj_get_prog                               [Tracepoint event]&lt;br/&gt;bpf:bpf_obj_pin_map                                [Tracepoint event]&lt;br/&gt;bpf:bpf_obj_pin_prog                               [Tracepoint event]&lt;br/&gt;bpf:bpf_prog_get_type                              [Tracepoint event]&lt;br/&gt;bpf:bpf_prog_load                                  [Tracepoint event]&lt;br/&gt;bpf:bpf_prog_put_rcu                               [Tracepoint event]&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;使用 perf 跟踪 BPF 系统调用（这里用 sleep 只是展示用法，实际场景中应该 执行 tc 等命令）：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ perf record -a -e bpf:* sleep 10&lt;br/&gt;$ perf script&lt;br/&gt;sock_example  6197 [005]   283.980322: bpf:bpf_map_create: map &lt;span&gt;type&lt;/span&gt;=ARRAY ufd=4 key=4 val=8 max=256 flags=0&lt;br/&gt;sock_example  6197 [005]   283.980721: bpf:bpf_prog_load: prog=a5ea8fa30ea6849c &lt;span&gt;type&lt;/span&gt;=SOCKET_FILTER ufd=5&lt;br/&gt;sock_example  6197 [005]   283.988423: bpf:bpf_prog_get_type: prog=a5ea8fa30ea6849c &lt;span&gt;type&lt;/span&gt;=SOCKET_FILTER&lt;br/&gt;sock_example  6197 [005]   283.988443: bpf:bpf_map_lookup_elem: map &lt;span&gt;type&lt;/span&gt;=ARRAY ufd=4 key=[06 00 00 00] val=[00 00 00 00 00 00 00 00]&lt;br/&gt;[...]&lt;br/&gt;sock_example  6197 [005]   288.990868: bpf:bpf_map_lookup_elem: map &lt;span&gt;type&lt;/span&gt;=ARRAY ufd=4 key=[01 00 00 00] val=[14 00 00 00 00 00 00 00]&lt;br/&gt;     swapper     0 [005]   289.338243: bpf:bpf_prog_put_rcu: prog=a5ea8fa30ea6849c &lt;span&gt;type&lt;/span&gt;=SOCKET_FILTER&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;对于 BPF 程序，以上命令会打印出每个程序的 tag。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;对于调试，XDP 还有一个 xdp:xdp_exception tracepoint，在抛异常的时候触发：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;$ perf list | grep xdp:&lt;br/&gt;xdp:xdp_exception                                  [Tracepoint event]&lt;/p&gt;&lt;/pre&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;异常在下面情况下会触发：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF 程序返回一个非法/未知的 XDP action code&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF 程序返回 XDP_ABORTED，这表示非优雅的退出（non-graceful exit）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;BPF 程序返回 XDP_TX，但发送时发生错误，例如，由于端口没有启用、发送缓冲区已 满、分配内存失败等等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;这两类 tracepoint 也都可以通过 attach BPF 程序，用这个 BPF 程序本身来收集进一步 信息，将结果放到一个 BPF map 或以事件的方式发送到用户空间收集器，例如利用 bpf_perf_event_output() 辅助函数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;其他&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;和 perf 类似，BPF 程序和 map 占用的内存是算在 RLIMIT_MEMLOCK 中的。可以用 ulimit -l 查看当前锁定到内存中的页面大小。setrlimit() 系统调用的 man page 提 供了进一步的细节。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;默认的限制通常导致无法加载复杂的程序或很大的 BPF map，此时 BPF 系统调用会返回 EPERM 错误码。这种情况就需要将限制调大，或者用 ulimit -l unlimited 来临时解 决。RLIMIT_MEMLOCK 主要是针对非特权用户施加限制。根据实际场景不同，为特权 用户设置一个较高的阈值通常是可以接受的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;END&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;想要了解更多相关的内容，欢迎扫描下方👇 关注 公众号，回复关键词 [实战群]  ,就有机会进群和我们进行交流~&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5763688760806917&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbDrrBk1KBPqY1QNI320ZK2IIycDa77FcDQAeAFJRVb240xr8biceh23auy7ZpPibEYXPNOnmfsEewkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;694&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;分享、在看与点赞，至少我要拥有一个叭~&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-ratio=&quot;0.2106667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/vbERicIdYZbB79dKphkWU3rVKFiaZGWHEic0qXJ8QAeF6XRTLwTCEgUxxiamV13wPv9kMtaqrOtsrVibdHzvYiaxCwgA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;750&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.696&quot; data-type=&quot;gif&quot; data-w=&quot;500&quot; class=&quot;__bg_gif&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/vbERicIdYZbB79dKphkWU3rVKFiaZGWHEicOoCY9eHaUhZY0vkZibusOg9ibjGibicfyjHiaWfkN9QOiclK2DnfLh4KYTLA/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>10f6242a0e67c699e3ea03fad0d3fd50</guid>
<title>程序设计的2个技巧</title>
<link>https://toutiao.io/k/iwooo69</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;善用本地缓存&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;7年前见过一个别人做的项目：因为公司的视频和专辑这些媒体资讯信息属于基础数据，非常重要。有个基础服务专门将这些基础数据提供给全公司使用。这些数据都是从后台信息中录入的，全量数据数据库中有存储，并全量存到了集中式缓存中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;全量数据大概不到500M。但是存在一些大专辑，就是说有的数据一条就占几M。所以在查询时，特别是请求多的时候遇到很多超时现象。毕竟像redis等集中式缓存都不建议缓存大数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是我们这个服务特别重要，请求量大，SLA要求高，得缓存啊。这时我建议直接使用本地缓存。很多人在设计的时候有个误区：有了集中式缓存再用本地缓存好像不够高级。最高级的用法是采用合适的技术。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;咱们以终为始的来考虑问题：集中式缓存的好处是数据一致性高，一旦数据更新了。从哪台应用服务器取的数据都是一样的。但是咱们目前的情况是数据是后台录入的，本身就有人工时间误差。所以定时1分钟、2分钟从数据库刷新一次检查数据有没有变化也是可以的。每个服务有一定时间差也是可以容忍的。所以集中式缓存的必要性并不高。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有人说本地内存很珍贵呀。咱们来算一算哈。一般这种核心的系统，随着请求量的增加，IO会增加、CPU会增加，基本与请求量成线性关系。当然每个请求都要占用一定内存，拿Java语言来说。主要是年轻代的占用。像这种大数据一直在内存中的就直接进入老年代了，当然也可以直接使用堆外内存。因为JVM等存储各个内存区大小固定，请求增多会导致年轻代的young gc频率升高，其实对老年代影响并不明显。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其实可以验证一下，请求量升高时，内存的使用量变化很少。所以内存影响是可以计算的。比如咱们4C8G的虚机，内存多使用500M，只要JVM参数设置合理，对一般程序来说都是可以接受的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用这种方案，避免了集中式缓存大value引起的各种超时等问题，很多请求下反而更优。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;不兼容版本设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;当开发了一个接口2.0，产品设计人员的设计与原来1.0完全不兼容。1.0已经有用户在使用了。怎么办呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当遇到一个问题，不知道怎么做更合适的时候首先要做业界调研。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;微信开放平台的做法：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2843560933448574&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8vHMYx0goeNdBCnJ2ljcXuz3vOy3iaHj4FwnjFvBStY8TOez8DBF8kjrgCz0CkKvO4JXYAqmI5oQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1157&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在url中标明版本号，按照版本号进行路由。不同版本对应不同的实现，并且将不同版本的请求不同点都体现在文档中。接入方就不会质疑版本不兼容问题了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;编程一生&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;因为公众号平台更改了推送规则，如果不想错过内容，记得读完点一下“在看”，加个“星标”，这样每次新文章推送才会第一时间出现在你的订阅列表里。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;想知道自己错过了哪些更新，可参考我不定期更新的《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247487380&amp;amp;idx=2&amp;amp;sn=4e71d679e2c22f9c5af4ea3abc667b76&amp;amp;chksm=fafde53acd8a6c2c9d2fb5eb83de5e5a2e3f244a57fa275394d9d61a0cdfa154290fe7a21fe8&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;系列文章分类汇总&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;em&gt;&lt;strong&gt;系列文章分类汇总&lt;/strong&gt;&lt;/em&gt;&lt;/a&gt;》。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>