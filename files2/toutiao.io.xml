<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1e22e4414b07b7f0d29b33c0799106a1</guid>
<title>2022 年别再焦虑啦！加入我们！</title>
<link>https://toutiao.io/k/obimloc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fea7cbe7ca02e56ce79a9facef087f50</guid>
<title>百度和米哈游的Golang面试经验分享</title>
<link>https://toutiao.io/k/q0sox0k</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;最近面了两家公司的&lt;code&gt;go&lt;/code&gt;技术岗位，一家百度，一家米哈游，面试的情况也不太乐观，现在分享一下面试中问的问题吧。&lt;/p&gt;&lt;p&gt;两家都是采用线上面试的，当时没有录音，&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yAABniahAY8ZrO9jY7dRJ1zDsVdPMObBWYFItXnsBiavdibkQKJVkXvTBwsGtHlS1BUNU2xia3y3lnlXPNrRD4ZLgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;现在全靠自己的回忆来复盘一下了。&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;百度一面&lt;/h2&gt;&lt;p&gt;百度的面试步骤分为计算机基础、&lt;code&gt;go&lt;/code&gt;相关、&lt;code&gt;mysql&lt;/code&gt;相关、&lt;code&gt;redis&lt;/code&gt;相关、&lt;code&gt;linux&lt;/code&gt;相关问题。还有一些发散性的问题。&lt;/p&gt;&lt;h3&gt;&lt;span/&gt;基础相关&lt;/h3&gt;&lt;p&gt;这一块的话，我回答的是稀碎，算法和数据结构我一个都没答上来，后面两个因为之前面试问到过，所以查过一些，回答的还算可以。&lt;/p&gt;&lt;h3&gt;&lt;span/&gt;go相关&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;GC&lt;/code&gt;，（面&lt;code&gt;GO&lt;/code&gt;必问题），&lt;code&gt;GC&lt;/code&gt;中&lt;code&gt;stw&lt;/code&gt;时机，各个阶段是如何解决的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;gpm&lt;/code&gt;，（面&lt;code&gt;GO&lt;/code&gt;必问题），这个必须要完全理解，抢占式调度是如何抢占的，怎么调度&lt;code&gt;goroutine&lt;/code&gt;的，&lt;code&gt;M&lt;/code&gt;和&lt;code&gt;P&lt;/code&gt;的数量问题。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如何优雅的实现一个&lt;code&gt;goroutine&lt;/code&gt;池（这个回答的稀碎）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;谈谈内存逃逸&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;内存管理（这个也回答的稀碎）&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;span/&gt;mysql相关&lt;/h3&gt;&lt;h3&gt;&lt;span/&gt;redis&lt;/h3&gt;&lt;h3&gt;&lt;span/&gt;linux&lt;/h3&gt;&lt;h3&gt;&lt;span/&gt;总结&lt;/h3&gt;&lt;p&gt;我面试结束后，一般都会问面试官，根据这次面试，针对我的技术上面，有什么好的建议或者意见，这位面试官给我的回答是：计算机基础比较薄弱，但是业务能力很强。这也是我目前的现状，哈哈，所以最近一直在看哈工大老师的计算机理论和操作系统。希望能勤能补拙吧。&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;米哈游一面&lt;/h2&gt;&lt;p&gt;米哈游面试总体分为四个部分，&lt;code&gt;go&lt;/code&gt;相关，&lt;code&gt;mysql&lt;/code&gt;相关，&lt;code&gt;redis&lt;/code&gt;相关，&lt;code&gt;linux&lt;/code&gt;相关。&lt;/p&gt;&lt;h3&gt;&lt;span/&gt;go相关&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;...&lt;/span&gt;&lt;br/&gt;m &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;make&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;map&lt;/span&gt;&lt;span&gt;[&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i&lt;span&gt;&amp;lt;=&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i&lt;span&gt;++&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    m&lt;span&gt;[&lt;/span&gt;i&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; i&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; k&lt;span&gt;,&lt;/span&gt; v &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;m&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;go&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        fmt&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;k -&amp;gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; k&lt;span&gt;,&lt;/span&gt; &lt;span&gt;&quot;v -&amp;gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; v&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;问会出现什么状况，为什么，怎么解决。就是不要闭包直接使用外部变量，通过传参就能解决了。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;内存泄露，什么情况下内存会泄露。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;channel的底层实现原理，（其实就是问buf是环形链表的数据结构）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;defer，这个一定要认真回答，defer在什么时机会修改返回值。多个defer的顺序。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;make和new的区别&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;channel关闭了接着send数据会发生什么，关闭一个已经关闭的channel会发生什么。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;map是线程安全的吗，map的扩容规则。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数组和切片的区别。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;GC&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;GPM模型&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;进程、线程、协程区别。（这个很重要）&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;还有其他的我忘记了。&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yAABniahAY8ZrO9jY7dRJ1zDsVdPMObBWYFItXnsBiavdibkQKJVkXvTBwsGtHlS1BUNU2xia3y3lnlXPNrRD4ZLgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span/&gt;redis&lt;/h3&gt;&lt;p&gt;差不多就是百度那样。&lt;/p&gt;&lt;h3&gt;&lt;span/&gt;mysql&lt;/h3&gt;&lt;p&gt;也差不多和百度那样。&lt;/p&gt;&lt;h3&gt;&lt;span/&gt;linux&lt;/h3&gt;&lt;p&gt;大差不差，就问了一个怎么根据进程名查该进程的id.&lt;/p&gt;&lt;h3&gt;&lt;span/&gt;总结&lt;/h3&gt;&lt;p&gt;根据面试反馈来看，米哈游给出的是go基础较差，但是业务能力较强。可能这就是之前干外包的特点吧。&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yAABniahAY8ZrO9jY7dRJ1zDsVdPMObBWYFItXnsBiavdibkQKJVkXvTBwsGtHlS1BUNU2xia3y3lnlXPNrRD4ZLgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span/&gt;米哈游的二面&lt;/h3&gt;&lt;p&gt;米哈游二面主要问的是业务方面和算法方面的问题，主要有三部分。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;微服务相关，包括微服务的注册与发现，微服务的监控，微服务的限流相关等等，还有微服务怎么守护进程，我回答的是supervisor，也不知道对不对。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;具体业务的实现，兑换码的实现，如何批量生成几十万或者上百万的兑换码，（这个我回答的是用雪花算法实现），高并发下，一个兑换码如何保证只能被一个人兑换一次，以及一个兑换码如何可以被多个人兑换的实现。（这道题前前后后回答了有半个小时吧，因为之前做过相关的业务，所以心里有点底）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;三个算法问题。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;写一个方法，解决：输入4个数字，通过加减乘除，输出一个期望值。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;广度优先算法：怎么输出各层的值。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;台阶问题，假如对于上台阶，可以一次上一阶，也可以一次上两阶，写一个方法，实现输入台阶数，输出可以有多少种上法。&lt;/p&gt;&lt;p&gt;&lt;span&gt;文章原作者：ezreal_rao&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA3MTUwNDU1NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/yAABniahAY8ZKcmczZwW2lOD3icB2iaicXKS3v7smeF8uwHtMI8YicppR3JyJQXl2L7HPnABTcgiaQcialTE11OlTpHnw/0?wx_fmt=png&quot; data-nickname=&quot;Go编程&quot; data-alias=&quot;&quot; data-signature=&quot;Golang语言编程，针对学习教程&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>75be9dcd4d89b88e9a118174d44ff0bc</guid>
<title>作为前端，工作中处理过什么复杂的需求？</title>
<link>https://toutiao.io/k/de9u8lc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其次，&lt;strong&gt;前端自己要保持柔性&lt;/strong&gt;，除了核心CGI外，其他接口无论是超时还是返错，都不要影响页面核心功能的正常运行，这&lt;strong&gt;对前端的代码提出了很高的要求&lt;/strong&gt;，所幸平时团队CR习惯养成良好，对接口的异常处理也做的比较完善，只是模拟接口测试验证花费了一些时间。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;97333&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;2. 再说需求&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;你以为上面就是全部了？Too Naive！上面的几点只是挤出时间去做一些调整，&lt;strong&gt;重头戏还在于极度紧张的业务需求。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;腾讯课堂之前的toB部分针对的是开课机构、个人老师，现在是学校教务、学校老师、学校领导、教育局领导，老板们直接&lt;strong&gt;重点关注&lt;/strong&gt;，可想而知产品的压力有多大。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们在&lt;strong&gt;两天内就推出了腾讯课堂极速版&lt;/strong&gt;（https://ke.qq.com/s），支持老师10s开课，随时随地开课，目前已经迭代到了第4版。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;众所周知，对于一个系统而言，&lt;strong&gt;由简入繁易，由繁入简难&lt;/strong&gt;。腾讯课堂有着一套复杂的B侧管理体系，极速版要将这一切推翻，让老师极速开课，学生极速上课，这是多么困难的一件事情。课堂在这么短时间内拿下极速版的版本发布，体现了极强的开发战斗力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d2f12c3438225194cc134cf401b174c2</guid>
<title>对流处理的误解</title>
<link>https://toutiao.io/k/gp9phek</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.428125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6Lros5vgmrlcorGHoxEVAFRnseiaOx0ueUqyb8VrbVlmQuibJP6xcCUl1oib6Nnic2xIBhtslVy4SCMkjmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI0OTYwNTQ4Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/nKovjAe6LrpVR0GEQn2UGOvBUCta35aF6ibVFvTR0fFPE83DrdKGl8v2sCTVbYNJPnun6Yftg1OAlMJ94kxzgyg/0?wx_fmt=png&quot; data-nickname=&quot;大数据生态&quot; data-alias=&quot;big_data_ecosphere&quot; data-signature=&quot;火爆数年的大数据圈，让很多人还没弄懂大数据是什么，就已然身处其中。该订阅号对大数据行业中的各个领域进行梳理，有助于业内人士了解大数据生态圈。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;我们花了很多时间来思考流处理。更酷的是：我们也花了很多时间帮助其他人思考流处理以及如何使用流应用解决他们的数据问题。这个过程的第一步是纠正对现代流处理的误解（作为一个快速变化的领域，这里有很多误见值得我们思考）。在这篇文章中，我们选择了其中的 6 个进行讲解，由于 Apache Flink 是我们最熟悉的开源流处理框架，所以我们会基于 Flink 来讲解这些例子。&lt;/p&gt;&lt;h3&gt;1. 误解1：如果不使用批处理就不能使用的流（Lambda架构）&lt;/h3&gt;&lt;p&gt;Lambda 架构 在 Apache Storm 和其它流处理项目的早期阶段是一个很有用并且出名的设计模式。这个架构包含了一个快速流层和一个批处理层。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.45725490196078433&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6Lros5vgmrlcorGHoxEVAFRnsKOpAtqGU5rT6Q4BDiccP25fpBF6E2YfomLqdw5CX8oSib7awMfJaVoYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1275&quot;/&gt;&lt;/p&gt;&lt;p&gt;之所以使用两层的原因是 Lambda 架构里的流处理只能计算出近似结果（例如，如果发生故障，结果是不可信的），而且只能处理相对少量的事件。虽然这些问题只存在于 Apache Storm 的早期版本中，与现今开源流处理不相关。现今的很多开源流处理框架都具有容错能力，即使出现故障也能产出准确的结果，而且具有高吞吐的计算能力。所以没有必要为了得到’快’而’准确’的结果维护多层架构。现今的流处理器（例如，Flink）可以满足你这两方面的需求。好在人们不再更多地讨论 Lambda 架构，这表明流处理正在走向成熟。&lt;/p&gt;&lt;h3&gt;2. 误解2：延迟和吞吐量：只能选择一个&lt;/h3&gt;&lt;p&gt;早期的开源流处理框架要么是高吞吐，要么是低延迟，因此开源流处理框架不是’海量数据、快速’场景的选择。但是 Flink（可能还有其他流流处理器）同时提供了高吞吐量和低延迟。这里有一个基准测试结果的示例。&lt;/p&gt;&lt;p&gt;让我们从一个基本的角度来研究这一点，特别是从硬件层。让我们考虑一个存在网络瓶颈的流处理 Pipeline（至少我们看到的许多使用 Flink 的 Pipeline 存在这种情况）。在硬件层面，不需要存在这样的权衡。网络容量才是影响最大吞吐量和可达到的最低延迟的主要因素。&lt;/p&gt;&lt;p&gt;一个设计良好的软件系统应可以达到网络上限而不会引入瓶颈问题。虽然 Flink 的性能还是有优化的空间，使其更接近硬件所能达到的水平。但在这一点上，Flink 已经证明可以在 10 节点的集群上每秒处理 1000 万个事件，如果扩展到 1000 个节点，可以同时实现几十毫秒的延迟。根据我们的经验，这种性能水平对于大多数实际部署来说绰绰有余。&lt;/p&gt;&lt;h3&gt;误解3：微批处理意味着更好的吞吐量&lt;/h3&gt;&lt;p&gt;我们可以从另一个角度来讨论性能，不过先让我们来澄清两个容易混淆的概念：&lt;/p&gt;&lt;p&gt;常见的误解是使用微批处理的数据处理框架会比每次处理一个事件的流处理框架有更高的吞吐量，因为微批处理在网络上传输的效率更高。该误解忽略了一个事实，流处理框架不会依赖任何处理和编程模型层面的批处理，但会在物理层面进行缓冲。Flink 确实也会对数据进行缓冲，这也就意味着 Flink 会通过网络一次发送一组处理过的记录，而不是一次只发送一条记录。从性能方面说，不对数据进行缓冲是不可取的，因为通过网络逐个发送记录不会带来任何性能上的好处。所以我们承认，在物理层面根本不存在一次发送一条记录的事情。但缓冲仅用作性能优化。因此，缓冲：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;对用户是不可见的&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不应该对系统造成任何影响&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不应该强加人为的限制&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不应该限制系统功能&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;所以对 Flink 的用户来说，他们可以按照单独处理每个记录的方式开发程序，但 Flink 使用缓冲来实现其底层性能优化。事实上，微批处理会以调度任务的形式引入相当大的开销，而如果这样做是为了降低延迟，那么这种开销只会只增不减！流处理器知道该如何利用缓冲的优势而不会带来任务调度方面的开销。&lt;/p&gt;&lt;h3&gt;4. 误解4：Exactly-Once？完全不可能&lt;/h3&gt;&lt;p&gt;这个误解包含了如下几个方面的内容：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;在现实中 Exactly-once 语义是不可能的&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Exactly-once 语义不可能是端到端的&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Exactly-once 语义从来都不是现实世界的需求&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Exactly-once 语义是以牺牲性能为代价的&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;之前 Exactly-Once 仅指 Exactly-Once Delivery，而现在这个词被随意用在流处理里，使得这两个词比以前更容易混淆，也失去了它原本的意义。不过，相关概念仍然很重要，因此我们不会完全跳过它。为了尽可能准确，我们将 Exactly-Once 拆分为状态的 Exactly-Once 和传递的 Exactly-Once。&lt;/p&gt;&lt;p&gt;由于之前人们对这两个词的错误使用导致了这两个不同概念的混淆。例如，Apache Storm 使用 At-Least-Once 来描述传递(Storm 不支持状态)，而 Apache Samza 使用 At-Least-Once 来描述应用状态。&lt;/p&gt;&lt;p&gt;状态 Exactly-once 意味着发生故障后，应用程序状态就像没有发生故障一样。例如，我们在维护一个计数器应用程序，在发生故障后，既不会多计数也不能少计数。在这种情况下使用 Exactly-Once 这个词是因为应用程序状态中每条消息都只处理了一次。传递 Exactly-once 意味着发生故障后，接收方（应用程序之外的某个系统）接收到处理后的事件就好像没有发生故障一样。&lt;/p&gt;&lt;p&gt;虽然流处理框架不可能在每个场景中保证传递的 Exactly-once，但可以做到状态的 Exactly-once。Flink 可以做到状态的 Exactly-once，并不会对性能造成显著影响。与 Flink 的 Checkpoint 配合，还能实现 Sink 上的传递 Exactly-once 语义保证。Flink Checkpoint 是应用程序状态的周期性、异步和一致的快照。这就是 Flink 在发生故障时仍然能保证状态 Exactly-once 的原因：Flink 会定时记录（快照）输入流的读取位置和每个算子的相关状态。如果发生故障，Flink 就会回滚到之前的状态，并重新开始计算。&lt;/p&gt;&lt;p&gt;因此，即使重放记录，结果状态中记录也好像只处理了一次。那么端到端的 Exactly-once 处理呢？可以通过让 Checkpoint 兼具事务协调机制来实现，换句话说，就是让 Source 和 Sink 算子参与到 Checkpoint 里来。在框架内部，结果是 Exactly-once 的，从端到端来看，也是 Exactly-once 的，或者说接近一次性。例如，在使用 Kafka 作为 Source，滚动文件(HDFS)作为 Sink 时，从 Kafka 到 HDFS 可以实现端到端的 Exactly-once 处理。类似地，Kafka 作为 Source，Cassandra 作为 Sink 时，如果对 Cassandra 做幂等更新时，那么就可以实现端到端的 Exactly-once 处理。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.26824034334763946&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6Lros5vgmrlcorGHoxEVAFRnsvjsLTgQhQAHHdW4Psjm4WhVUKZjQzqo1SlepicBFj6Vibg8XjHVNaoVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;932&quot;/&gt;&lt;/p&gt;&lt;h3&gt;5. 误解5：流处理只能被应用在’实时’场景里&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;这个误解包括如下几个方面的内容：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;我没有低延迟的应用，所以我不需要流处理器&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;流处理只跟那些持久化之前的过渡数据有关系&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;我们需要批处理器来完成笨重的离线计算&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;现在是时候思考一下数据集类型与执行模型类型之间的关系了。有两种数据集&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;无限：连续产生的数据，没有终点&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;有限：有限且完整的数据&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;事实上，许多现实世界的数据集是无限数据集。无论数据存储在 HDFS 上的文件或者目录中，还是存储在 Apache Kafka 等基于日志的系统中，都是如此。有如下示例：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;用户与移动设备或网站的交互&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;物理传感器提供的测量数据&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;金融市场数据&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;机器日志数据&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;实际上，在现实世界中很难找到一个有限数据集，不过一个公司的大楼位置信息倒是有限的（不过它也会随着公司业务的增长而变化）。其次，有两种处理模型：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;流处理：只要有数据生成就会一直处理&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;批处理：在有限的时间内运行完处理，并释放资源&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;让我们再深入一点，有两种无限数据集：连续流(有连续到达数据的流)和间歇流(周期性到达数据的流)。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.46025641025641023&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6Lros5vgmrlcorGHoxEVAFRnsLv0yianicvaAPNFTJXWxzeW4wnohiaBlNSVXW5kATUKzhPBgkNfs7qgCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;780&quot;/&gt;&lt;/p&gt;&lt;p&gt;使用任意一种模型来处理任意一种数据集都是完全可能的，尽管不一定是最优的做法。例如，批处理模型一直被应用在无限数据集上，特别是间歇性的无限数据集。现实情况是，大多数批处理任务是通过调度来执行的，每次只处理无限数据集的一小部分。这意味着流的无限特性会给某些人带来麻烦。&lt;/p&gt;&lt;p&gt;批处理给人的印象是无状态的，因为输出只取决于输入。现实情况是，批处理作业会在内部保留状态（比如 Reducer 经常会保留状态），但这些状态只局限在一个批次内，无法跨多个批次处理关联事件。一旦用户尝试实现事件时间窗口这样简单的东西时，’状态限制在一个批次内’就很重要了，这是处理无限数据集常用的方法。处理无限数据集的批处理器不可避免地遇到迟到事件(因为上游的延迟)，批次内的数据有可能因此变得不完整。需要注意的是，这里我们假设是基于事件时间生成窗口，因为事件时间是现实当中最为准确的模型。在执行批处理的时候，即使是简单的固定窗口(比如翻转或滑动窗口)在遇到迟到数据时也会出现问题，当使用会话窗口时更难以处理。如果完成一个计算所需要的数据不在一个批次里，那么在使用批次处理无限数据集时，就很难得到正确的结果。最起码，需要额外的开销来处理迟到的数据，还要维护批次之间的状态(要等到所有数据达到后才开始处理，或者重新处理批次)。Flink 内置了处理迟到数据的机制，在现实世界中处理无限数据时，迟到数据一种很正常的现象，因此，精心设计的流处理器将提供简单的工具来处理迟到数据。&lt;/p&gt;&lt;h3&gt;6. 误解6：不管怎么样，流太复杂了&lt;/h3&gt;&lt;p&gt;我们到了最后阶段，在这个阶段你会想’这听起来很棒，但我仍然不会使用流处理，因为……’：&lt;/p&gt;&lt;p&gt;我们永远不会仅仅因为我们认为流处理很酷就怂恿你使用流处理。相反，我们认为使用流处理的决定最终应该取决于你的数据的性质和代码的性质。在做决定之前问问自己：’我现在使用什么类型的数据集？’&lt;/p&gt;&lt;p&gt;然后再问另一个问题：”什么变更最频繁？”&lt;/p&gt;&lt;p&gt;如果你的数据比代码变更更频繁，例如，在经常变化的数据集上执行一个相对固定的查询操作，我们认为你有流的问题。所以，在认定流是一个”复杂”的东西之前，你可能在不知不觉中已经解决过流方面的问题！你可能使用过基于小时的批次任务调度（在这种情况下，由于批次的时间问题和之前提过的状态问题，你得到的结果可能是不准确的，你可能都没意识到这点）。&lt;/p&gt;&lt;p&gt;Flink 社区长期以来一直致力于提供更高级别的 API，以抽象出更多复杂的时间和状态。例如，在 Flink 中处理事件时间就像定义一个时间窗口和一个提取时间戳和 Watermark 的函数一样简单（每个流只需执行一次）。处理状态就像在 Java 程序中定义变量并将它们注册到 Flink 一样简单。Flink 的 StreamSQL 等努力可以让你在永无止境的流上运行 SQL 查询。&lt;/p&gt;&lt;p&gt;完成思考练习：如果你的代码比数据变更更频繁怎么办？在这种情况下，我们认为你遇到了探索性问题。使用笔记本或其他类似的迭代工具可能非常适合解决探索问题。但是，一旦你的代码稳定下来，你就会遇到流处理问题。我们建议你从一开始就开始思考流处理的长期解决方案。&lt;/p&gt;&lt;h3&gt;7. 流处理的未来&lt;/h3&gt;&lt;p&gt;随着流处理的日渐成熟，这些误解在日常讨论中也变得越来越少，我们发现流正朝着除分析应用之外的领域发展。正如我们所讨论的那样，真实世界正连续不断地生成数据。传统上，这种连续的数据流必须中断处理，数据要么集中收集在一个地方，要么分批次切割，以便应用程序与之交互。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI0OTYwNTQ4Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/nKovjAe6LrpVR0GEQn2UGOvBUCta35aF6ibVFvTR0fFPE83DrdKGl8v2sCTVbYNJPnun6Yftg1OAlMJ94kxzgyg/0?wx_fmt=png&quot; data-nickname=&quot;大数据生态&quot; data-alias=&quot;big_data_ecosphere&quot; data-signature=&quot;火爆数年的大数据圈，让很多人还没弄懂大数据是什么，就已然身处其中。该订阅号对大数据行业中的各个领域进行梳理，有助于业内人士了解大数据生态圈。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;原文:Stream Processing Myths Debunked&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a823ff4af56698e5d35c98c85f94feb9</guid>
<title>sqlite3.36版本 btree实现（零）- 起步及概述</title>
<link>https://toutiao.io/k/mbbbpdu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;strong&gt;&lt;span&gt;引言&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;理解算法的原理，以及能写出生产级别的实现，中间隔了很大的距离。本文是讲解sqlite btree实现系列文章的第零篇，讲解我探索“生产级 btree 实现”的过程，以及 sqlite btree 架构的简介。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;起步&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在去年（2020 年）大体把 btree 以及 b+tree 算法流程研究了之后，我写了两篇博客：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（鉴于 b+tree 只是 btree 的一个特例，下面描述将仅使用“btree”，不再严格区分两者。）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是，这两篇文章仅仅只是让我懂得了最基本的原理。懂得原理，只是能做出 toy 级别的实现，拿 btree 类的存储引擎来说，要做到生产级产品，至少还有以下几个问题我当时不知道怎么做的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如何处理不同大小的数据的存储？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;删除一个数据之后，如何复用其留下的空间？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;错误、崩溃恢复怎么做？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;跟磁盘文件是如何交互的？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;页面缓存模块如何实现？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;等等等等，还有太多我还没有弄清楚的实现细节。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（我甚至还在微博上发问，得到了两个质量很高的回答，见本文最后的彩蛋部分[3]。）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对 LSM 类存储引擎有了解的人都知道，Leveldb 这个项目在 LSM 领域属于入门级别的生产级实现，即这个领域最精简、但是又能放心在某些要求不高的场景下用于生产的项目。在这之后，我一直在找那种 btree 领域的“leveldb”，很遗憾一直都没有找到，我分别看了目前 WiredTiger、innodb、sqlite 的对应实现，都太复杂了，看不下去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;直到有一天，无意间发现了这个项目：madushadhanushka/simple-sqlite: Code reading for sqlite backend[4]，看介绍，作者把 sqlite2.5 里 b-tree 相关的部分代码抽取出来了，我编译运行了一下用例都能正常跑，代码量不过几千行，我只花了几天就看完了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然按照 Release History Of SQLite[5] 上的记载，sqlite 2.5 版本是 2002 年的版本了，但是这个版本还是某种程度回答了我在上面的疑问。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;趁热打铁，我又找来更新一些的 sqlite 3.6.10 代码继续看这部分的实现，这次花了更多的时间才看完，但是又增强了我的信心。由于这个版本的 sqlite，还未实现 btree 的 wal，还只是用了 journal 文件来做崩溃恢复（无论 wal 还是 journal，都会在后面文章展开详细讨论），所以在有足够的信心之后，我接下来又继续看当时（2021.10 月份）最新的 sqlite 3.36 版本的实现，这部分的实现对比 3.6.10 来说，在 btree 部分最大的变化就是多了 wal 的实现，在已经清楚 3.6.10 的前提下，再增加了解这部分的实现，也并不是什么难事了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上，简单描述了我探索一个生产级 btree 实现的初过程，btree 类存储引擎的实现博大精深，更复杂者还有很多（WiredTiger、innodb、tokudb...），但是无疑从低版本 sqlite 开始的探索流程，终于让我打开了走上这条路的一扇大门。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本系列文章就 sqlite 3.36 版本的 btree 实现展开描述，希望对那些和我一样对“生产级 btree 类存储引擎实现”有好奇心的人有一点帮助。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，如果你还是觉得吃力，可以先从 madushadhanushka/simple-sqlite: Code reading for sqlite backend[6] 这里看起。这里并不建议对 btree 原理没有了解的人直接上手 sqlite 的实现，如果需要了解原理请参考相关文章或者我上面给出的我写的两篇博客。这系列文章中，将不再对 btree 原理做过多描述，将假设读者已经了解这部分内容。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;sqlite 的 btree 架构概述&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面简单描述一下 sqlite 的 btree 架构，从高往低大体分为以下几个部分：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5462962962962963&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vxCq1iahXotjwWgu8BUWrxMb6sFo6DxmHoXTky9vg8Pb4rCAumYnQVXOW2t6w4HAj53pWawpvp1XDnNKyvt194w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;btree 架构&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;这三部分架构，由下往上依次是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;系统级 API 的实现：因为 sqlite 是一个可以在多个平台编译运行的数据库，所以系统级 API 这一层，需要解决平台相关的文件 IO、锁等问题。这部分实现，将不在这系列文章中介绍，因为并不属于数据库实现时的核心问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;页面管理模块：btree 存储引擎，其操作文件的最基本单位就是页面。页面管理模块解决以下的问题：对上层的 btree 模块，暴露针对页面读、写的接口，内部会缓存页面的内容，何时将修改的页面（所谓脏页面，dirty page）落盘到磁盘，是否需要 sync 修改，崩溃或者重启时的数据恢复，这些都不需要上层的 btree 模块关心。为了达到这些效果，内部还有几个子模块：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;页面缓存模块：用于缓存页面的内存有限，何时淘汰缓存中的页面、何时将缓存中的脏页面落盘，等等都由这个模块负责。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;页面备份：从上面的描述可以看到，因为页面的修改并不一定马上落盘，而是可能只是修改了缓存中的页面，这样在系统发生崩溃的时候，需要做恢复操作，一些没有完成的事务需要回滚，等等。这部分页面管理模块由两种不同的实现：&lt;/span&gt;&lt;span&gt;journal 文件：这是早期，但是效率并不高的实现；WAL 文件：这是从 3.7 之后引入的更高效的方式。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;事务：事务处理也放在了页面管理中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;btree：基于页面管理模块之上，实现了可以存储可变数据的 btree 模块。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以这样来简单区别理解“页面管理”模块和 btree 模块的功能：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上面的分析可以看出来，“页面管理模块”无疑是这里最大最复杂的部分，Andy Pavlo 在 CMU 15445 课程中提到过：任何用 mmap 来做页面管理的做法都是很糟糕的做法（如 boltdb、LMDB 等）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/vxCq1iahXotjwWgu8BUWrxMb6sFo6DxmHPH4pqXkOCSoVVo6RFaG0ajwfbX4kgcyIRv3aP6dDCtiaf5YZd71C9rw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;span&gt;mmap&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这系列的文章，也将按照这个顺序，从下往上逐层分析 sqlite 的 3.36 版本的 btree 实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;彩蛋&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2021 年 9 月 5 日，我在微博上就处理崩溃恢复的实现，提了一个问题（见：那些很成熟的存储引擎... - @玩家老 C 的微博 - 微博[7]）：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那些很成熟的存储引擎，都是怎么处理崩溃恢复问题的呢，比如写数据落盘到一半，进程崩了，该如何恢复呢？求资料和指点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;得到了两个很不错的指点回复：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;ba0tiao 的回复&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;做 InnoDB 这块挺久了, 我试试说说 InnoDB 是怎么做的吧..&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实你这里应该细分成两个问题&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.16kb 的 page 写入的原子性该如何保证2.Btree 结构的完整性如何保证, 也就是你说的修改了 n 个页面以后如果修改了父子, 兄弟关系以后, 如果解决中间的 crash 的问题&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;问题 1 是通过 double write buffer 来解决的, 因为 InnoDB 的 page 大小是 16kb, 很多文件系统只能保证 4kb 大小写入的原子性, 因此需要写入前先将 page 的内容写入到 double write buffer 来保证, 如果写入失败也不会将原有 page 的内容覆盖.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;问题 2 是通过 redo log + mtr(mini transaction) 进行保证.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;InnoDB 里面的 redo log 是由 mtr 组成, mtr 是修改 btree 的最小单位. 每次写入 redo log 的时候必须是一个完整的 mtr 的内容, 具体实现方式是 mtr 会有 MULTI_REC_END 标记, 在 crash recovery 的时候, 如果读取到 mtr 的内容没有 MULTI_REC_END 标记, 那么则会认为这个 mtr 不完整, 就会把这段 mtr 抛弃.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么是不是一次 insert 操作产生的 redo log 都包含在一个 mtr 里面呢?&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不是的.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们知道在 btree 里面对 page 的修改都需要对 page 加锁, 从 fsp 模块分配一个 new page 也需要对 root page 进行加锁等等. 所以 InnoDB 的 mtr 里面自然就包含对锁的操作, 因此要修改某一个 page 的时候, mtr begin 的时候会对该 page 加锁, 然后写入修改的内容, 然后 mtr commit 的时候, 对于修改的 page 的锁就可以释放了.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果整个 insert 的过程都放在一个 mtr 里面做, 那也是可以的, 也就是对于所有 page 的 latch 都是一开始持有, 最后的时候在释放, 就算后续这个 page 已经不再修改了, 也依然要一直持有. 很容易理解这样并发自然就降低下来的, 因此在 InnoDB 设计里面, mtr 的粒度是尽可能小的. 修改完 page 就应该尽快的 commit, 然后将 page lock 释放. 但是又需要保证每一次的 mtr 操作前和操作后 btree 的完整性.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;体现具体的例子就是, InnoDB 里面对于一个简单的 insert 操作, 其实是有非常多个 mtr 组成, 尽可能减少持有锁的时间.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是在做 btree 分裂操作的时候, 分配新的 page, 将之前 page 一半的数据迁移到 new page 是在一个 mtr 里面完成, 但是后续具体的 insert 操作是在另外一个 mtr 里面完成的. 那么如果在做分裂操作过程中 crash, 那么这个分裂操作是不会完成的, 如果在分裂操作完成以后, insert 之前 crash, 那么 btree 是已经分裂过的, 只是数据没有插入了.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然这里会有你说的更复杂的设计的父节点 and 父节点的父节点的分裂, 那么自然持有锁的时间就更长了, 但是在我们在这里是做的一些优化.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还有一些比如 InnoDB redo log 是&quot;physical to a page, logical within a page&quot; 就是解决我们上面说的如果分裂操作成功了, 但是这个事务要回滚, 这个时候该如何处理等等..&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体的内容其实这些文章里面都有：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.C. Mohan, Don Handerle. ARIES: A Transaction Recovery Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.C. Mohan, Frank Levine. ARIES/lM: An Efficient and High Concurrency index Management Method Using Write-Ahead Logging.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.Goetz Graefe. A Survey of B-Tree Logging and Recovery Techniques.4.Goetz Graefe. A Survey of B-Tree Locking Techniques.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对了 Goetz Graefe 号称 Btree 守护神&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（见：&lt;/span&gt;&lt;span&gt;做 InnoDB 这块... - @ba0tiao 的微博 - 微博[8]）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2&gt;&lt;span&gt;BohuTANG 的回复&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以深入一点：如果每次写的 log 都在，怎么做到基于这些 log 做回放的问题？其实就是 redo-log +checkpoint+ LSM 的机制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;redo 解决数据不丢，checkpoint 解决 recovery 的时候扫描的 redo 尽量少，LSM 解决每次写入后新的 page 不会覆盖老的数据，这类实现是比较简单可行，也是目前的主流做法&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;（见：&lt;/span&gt;&lt;span&gt;可以深入一点：&lt;/span&gt;&lt;span&gt;如果每... - @BohuTANG 的微博 - 微博[11]）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以及：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前大部分理论都参考于这篇 ARIES: A Transaction Recovery Method Supporting Fine-Granularity Locking and Partial Rollbacks Using Write-Ahead Logging – Mohan et al. 1992&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（见：目前大部分理论都参考... - @BohuTANG 的微博 - 微博[12]）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;center&gt;&lt;p&gt;&lt;/p&gt;&lt;/center&gt;&lt;h4&gt;&lt;strong&gt;&lt;span&gt;引用链接&lt;/span&gt;&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[1] B树、B+树索引算法原理（上） - codedump的网络日志: https://www.codedump.info/post/20200609-btree-1/&lt;br/&gt;[2] B树、B+树索引算法原理（下） - codedump的网络日志: https://www.codedump.info/post/20200615-btree-2/&lt;br/&gt;[3] 彩蛋部分: https://www.codedump.info/post/20211217-sqlite-btree-0/#%E5%BD%A9%E8%9B%8B&lt;br/&gt;[4] madushadhanushka/simple-sqlite: Code reading for sqlite backend: https://github.com/madushadhanushka/simple-sqlite&lt;br/&gt;[5] Release History Of SQLite: https://www.sqlite.org/changes.html&lt;br/&gt;[6] madushadhanushka/simple-sqlite: Code reading for sqlite backend: https://github.com/madushadhanushka/simple-sqlite&lt;br/&gt;[7] 那些很成熟的存储引擎... - @玩家老C的微博 - 微博: https://weibo.com/1642628345/KwKqNgScT&lt;br/&gt;[8] 做InnoDB 这块... - @ba0tiao的微博 - 微博: https://weibo.com/1832563813/KwRpIxunM&lt;br/&gt;[9] baotiao: http://baotiao.github.io/&lt;br/&gt;[10] MySQL内核揭秘 - 知乎: https://www.zhihu.com/column/360infra&lt;br/&gt;[11] 可以深入一点：如果每... - @BohuTANG的微博 - 微博: https://weibo.com/1691468715/KwT2GdDfu&lt;br/&gt;[12] 目前大部分理论都参考... - @BohuTANG的微博 - 微博: https://weibo.com/1691468715/Kx3yAhFKj&lt;br/&gt;[13] datafuselabs/databend: https://github.com/datafuselabs/databend&lt;br/&gt;[14] [ 虎哥的博客 ]: https://bohutang.me/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651485910&amp;amp;idx=2&amp;amp;sn=553e1a3c2c862ba938a6a81760d88a1e&amp;amp;chksm=bd251aa98a5293bf27b77898215710bf1e06576dc7f6625f5703f71d87e8c8c990a1a6f4f541&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;为什么 MySQL 使用 B+ 树&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;为什么 MySQL 使用 B+ 树&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651486796&amp;amp;idx=2&amp;amp;sn=42b0309f043e04c33acd72b2f3b66862&amp;amp;chksm=bd2516338a529f25df936f790a748f0886d890bd412ce8d60be7db5557c8e0420c87861417df&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;拜托，别再问我什么是 B+ 树了&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;拜托，别再问我什么是 B+ 树了&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651503922&amp;amp;idx=2&amp;amp;sn=abb8da9ee2c524c72259bc0743bce7d4&amp;amp;chksm=bd25d14d8a52585b012867371463fe6813bad93e3c625bdcd7d37494845716016a1a3ede10dc&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;这篇 MySQL 索引和 B+Tree 讲的太通俗易懂！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;这篇 MySQL 索引和 B+Tree 讲的太通俗易懂！&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点赞和在看就是最大的支持❤️&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>