<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>dd725b1b0ae3074638a3bbb369005e7a</guid>
<title>撸猫必备三件套，立即下单现价仅需8.9元！</title>
<link>https://toutiao.io/k/14kxbpf</link>
<content:encoded>&lt;div&gt;&lt;body id=&quot;readabilityBody&quot;&gt;


&lt;/body&gt;
&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7741dff969960664aecfa95530f9c2fb</guid>
<title>[推荐] 非常哇塞的 ES读场景、写场景 性能优化指南！你值得拥有！</title>
<link>https://toutiao.io/k/5pjb28q</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;174&quot; data-backw=&quot;365&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4767123287671233&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/cvQbJDZsKLp6wejHtKTRbqqQyt0wMk9K1wNtuwRqQTJAPOJ1KiaqSeSRbIJRTicVicKpDKRndBodY2DBNN20tvWwA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;365&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原创：小姐姐味道（微信公众号ID：xjjdog），欢迎分享，转载请保留出处。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ES作为NoSQL数据库里非常重要的一员，使用越来越广泛。虽然它因为索引延迟的原因，数据在时效性上有一些缺陷，但其大容量、分布式的优秀设计，使得它在时效性要求并不是特别高的类实时搜索领域，能够大展身手。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据使用场景和用途，ES可以分为写入和读取两种典型的应用方式。比如ELKB，我们就需要额外关注它的&lt;code&gt;写优化&lt;/code&gt;；再比如从MySQL中同步数据到ES的宽表，我们就需要额外关注它的&lt;code&gt;读优化&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;废话不多说，我们直接show一下优化方法。如果你对ES的一些概念还不是很清楚，建议收藏本文慢慢看。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.写入优化&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日志属于写多读少的业务场景，对写入速度要求很高。拿我们其中一个集群来说，单集群日志量达到百TB，每秒钟日志写入量达到10W条。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据写入，主要有三个动作：flush、refresh和merge。通过调整它们的行为，即可在性能和数据可靠性之间进行权衡。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 translog异步化&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，ES需要写一份translog，它类似于MySQL中的redolog，为的是避免在断电的时候数据丢失。ES默认每次请求都进行一次flush，但对于日志来说，这没有必要，可以将这个过程改为异步的，刷盘间隔为60秒。参数如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;curl-H&lt;span&gt;&quot;Content-Type: application/json&quot;&lt;/span&gt;-XPUT&lt;span&gt;&#x27;http://localhost:9200/_all/_settings?preserve_existing=true&#x27;&lt;/span&gt;-d&lt;span&gt;&#x27;{&lt;br/&gt;  &quot;index.translog.durability&quot; : &quot;async&quot;,&lt;br/&gt;  &quot;index.translog.flush_threshold_size&quot; : &quot;512mb&quot;,&lt;br/&gt;  &quot;index.translog.sync_interval&quot; : &quot;60s&quot;&lt;br/&gt;}&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这可以说是最重要的一步优化了，对性能的影响最大，但在极端情况下会有丢失部分数据的可能。对于日志系统来说，是可以忍受的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 增加refresh间隔&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了写translog，ES还会将数据写入到一个缓冲区中。但是注意了！此时，缓冲区的内容是无法被搜索到的，它还需要写入到segment里面才可以，也就是刷新到lucence索引里面。这就是refresh动作，默认1秒。也就是你写入的数据，大概率1秒之后才会被搜索到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是为什么ES不是实时搜索系统的原因，它从数据写入到数据读出，一般是有一个合并过程的，有一定的时间差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过index.refresh_interval可以修改这个刷新间隔。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于日志系统来说，当然要把它调大一点啦。xjjdog这里调整到了120s，减少了这些落到segment的频率，I/O的压力自然会小，写入速度自然会快。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;curl-H&lt;span&gt;&quot;Content-Type: application/json&quot;&lt;/span&gt;-XPUT&lt;span&gt;&#x27;http://localhost:9200/_all/_settings?preserve_existing=true&#x27;&lt;/span&gt;-d&lt;span&gt;&#x27;{&lt;br/&gt;  &quot;index.refresh_interval&quot; : &quot;120s&quot;&lt;br/&gt;}&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3 merge&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;merge其实是lucene的机制，它主要是合并小的segment块，生成更大的segment，来提高检索的速度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因就是refresh过程会生成一大堆小segment文件，数据删除也会产生空间碎片。所以merge，通俗来讲就像是碎片整理进程。像postgresql等，也有vaccum进程在干同样的事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显而易见，这种整理操作，既浪费I/O，又浪费CPU。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的系统merge非常频繁，那么调整merge的块大小和频率，是一个比较好的方法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.读取优化&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 指定路由&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你向ES里写数据，那么它会为你设置一个离散的隐藏ID，落到哪个分片，是不一定的。如果你根据一个查询条件查询数据，你设置了6个shards的话，它要查询6次才行。如果能够在路由的时候就知道数据在哪个分片上，查询速度自然会上升，这就要求我们在构造数据的时候，人工指定路由规则。它的实际运行规则如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;shard = &lt;span&gt;hash&lt;/span&gt;(routing) % number_of_primary_shards&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，一个查询会变成这样。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;GET my-index-000001/_search&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;query&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;terms&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;_routing&quot;&lt;/span&gt;: [ &lt;span&gt;&quot;user1&quot;&lt;/span&gt; ] &lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，如果你的查询维度较多，又对数据的查询速度有非常高的有求，根据routing存放多份数据是一个比较好的选择。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 rollover冷热分离&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;rollover根据索引大小，文档数或使用期限自动过渡到新索引。当rollover触发后，将创建新索引，写别名将更新为指向新索引，所有后续更新都将写入新索引，比如&lt;code&gt;indexname-000001.&lt;/code&gt;这种模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从rollover这个名字可以看出来，它和Java的log日志有一定的相似之处，比如Log4j的RollingFileAppender。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当索引变的非常大，通常是几十GB，那它的查询效率将变的非常的低，索引重建的成本也较大。实际上，很多索引的数据在时间维度上有较为明显的规律，一些冷数据将很少被用到。这个时候，建立滚动索引将是一个比较好的办法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;滚动索引一般可以与索引模板结合使用，实现按一定条件自动创建索引，ES的官方文档有具体的_rollover建立方法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 使用BoolQuery替代TermQuery&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Bool查询现在包括四种子句，must、filter、should和must_not。Bool查询是true、false对比，而TermQuery是精确的字符串比对，所以如果需求相似，BoolQuery自然会快于TermQuery。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 将大查询拆成分段查询&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些业务的查询比较复杂，我们不得不拼接一张非常大的宽表放在ES中，这有两个比较明显的问题。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;宽表的数据往往需要从其他数据源中回查拼接而成，数据更新时对源库或者ES本身都有较大的压力&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务的查询JSON需要书写的非常复杂，查询效率未知，一次查询锁定的内存过高，无法进行深入优化&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，宽表不论在RDBMS中还是ES中，都会与复杂的查询语句有关，其锁定时间都较长，业务也不够灵活。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应对这种场景的策略，通常将复杂的数据查询，转移到业务代码的拼接上来。比如，将一段非常冗长的单条查询，拆分成循环遍历的100条小查询。所有的数据库都对较小的查询请求有较好的响应，其整体性能整体上将优于复杂的单条查询。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这对我们的ES索引建模能力和编码能力提出了挑战。毕竟，在ES层面，互不相关的几个索引，将作为整体为其他服务提供所谓的数据中台接口。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5 增加第一次索引的速度&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多业务的索引数据往往来自于MySQL等传统数据库，第一次索引往往是全量索引，后面才是增量索引。必要的时候，也会进行索引的重建，大量的数据灌入造成了ES的索引速度建立缓慢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了缓解这种情况，建议在创建索引的时候，把副本数量设置成1，即没有从副本。等所有数据索引完毕，再将副本数量增加到正常水平。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，数据能够快速索引，副本会在后台慢慢复制。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.通用优化&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，我们还可以针对ES做一些通用的优化。比如，使用监控接口或者trace工具，发现线程池有明显的瓶颈，则需要调整线程池的大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的优化项如下。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 线程池优化&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新版本对线程池的配置进行了优化，不需要配置复杂的search、bulk、index线程池。有需要配置下面几个就行了：thread_pool.get.size, thread_pool.write.size, thread_pool.listener.size, thread_pool.analyze.size。具体可观测_cat/thread_pool接口暴露的数据进行调整。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 物理冷热分离&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的rollover接口，我们可以实现索引滚动。但是如何将冷数据存放在比较慢但是便宜的节点上？如何将某些索引移动过去？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ES支持给节点打标签，具体方式是在elasticsearch.yml文件中增加一些属性。比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//热节点&lt;/span&gt;&lt;br/&gt;node.attr.temperature: hot &lt;br/&gt;&lt;span&gt;//冷节点&lt;/span&gt;&lt;br/&gt;node.attr.temperature: cold &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;节点有了冷热属性后，接下来就是指定数据的冷热属性，来设置和调整数据分布。ES提供了index shard filtering功能来实现索引的迁移。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，可以对索引也设置冷热属性。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;PUT hot_data_index/_settings&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;&quot;index.routing.allocation.require.temperature&quot;&lt;/span&gt;: &lt;span&gt;&quot;hot&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些索引将自动转移到冷设备上。我们可以写一些定时任务，通过_cat接口的数据，自动的完成这个转移过程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 多磁盘分散I/O&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，可以通过配置多块磁盘的方式，来分散I/O的压力，但容易会造成数据热点集中在单块磁盘上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ES支持在一台机器上配置多块磁盘，所以在存储规模上有更大的伸缩性。在配置文件中，配置path.data属性，即可挂载多块磁盘。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;path.data : /data1, /data2, /data3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得注意的是，如果你是在扩容，那么就需要配合reroute接口进行索引的重新分配。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 减少单条记录的大小&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lucene的索引建立过程，非常耗费CPU，可以减少倒排索引的数量来减少CPU的损耗。第一个优化就是减少字段的数量；第二个优化就是减少索引字段的数量。具体的操作，是将不需要搜索的字段，index属性设置为not_analyzed或者no。至于_source和_all，在实际调试中效果不大，不再赘述。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;End&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ES的使用越来越广泛，从ELKB到APM，从NoSQL到搜索引擎，ES在企业中的地位也越来越重要。本文通过分析ES写入和读取场景的优化，力求从原理到实践层面，助你为ES加速。希望你在使用ES时能够更加得心应手。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常，一个ES集群对配置的要求是较高的，尤其是APM等场景，甚至会占到PaaS平台的1/3资源甚至更多。ES提供了较多的配置选项，我们可以根据应用场景，调整ES的表现，使其更好的为我们服务。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;作者简介：&lt;strong&gt;小姐姐味道&lt;/strong&gt;  (xjjdog)，一个不允许程序员走弯路的公众号。聚焦基础架构和Linux。十年架构，日百亿流量，与你探讨高并发世界，给你不一样的味道。我的个人微信xjjdog0，欢迎添加好友，进一步交流。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3a676082c2425e9d5ae55a5f471e09b6</guid>
<title>[推荐] 缓存一致性最佳实践</title>
<link>https://toutiao.io/k/ymscqc1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4382826&quot; data-w=&quot;559&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbbFu7n3GktsBgczeVd0RHngWc5I6Wvf01FzUtDwQibTQEpYeZSM64W8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;背景 &lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;概述&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;最近团队里我们在密集的讨论Redis缓存一致性相关的问题，电商核心的域如商品、营销、库存、订单等实际上在缓存的选择上各有特色，那么在这些差异的业务背后，我们有没有一些最佳实践可供参考呢？&lt;/p&gt;&lt;p&gt;本文尝试着来讨论这个问题，并给出一些建议。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在讨论之前，有两个重点我们需要达成一致：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分布式场景下无法做到强一致&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不同于CPU硬件缓存体系采用的MESI协议以及硬件的强时钟控制，分布式场景下我们无法做到缓存与底层数据库的强一致，即把缓存和数据库的数据变更做成一个原子操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;硬件工程师设计了内存屏障（Memory Barrier）的概念，提供给软件开发者不同的一致性选项在性能与一致性上进行权衡。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;就算是达到最终一致性也很难&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;分布式场景下，要做到最终一致性，就要求缓存中存储的是最新版本的数据（或者缓存为空），而且是在数据库更新后很迅速的就要达到这个一致性的状态，要做到是极其困难的。&lt;/p&gt;&lt;p&gt;我们会面临硬件、软件、通信等等组件非常多的异常情况。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5409836&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbvSxeCUz3xV2YIUErVqjzgbHHKuhWXsU0JyWT3jfkpKJPI1Z14xiatxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;976&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;CPU的缓存结构&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;缓存的一致性问题&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;一般化来说，我们面临的是这样的一个问题，如下图所示，数据库的数据会有5次更新，产生6个版本，V1~V6，图中每个方框的长度代表这个版本持续的时间。&lt;/p&gt;&lt;p&gt;我们期望，在数据库中的数据变化后，缓存层需要尽快的感知到并作出反应，如下图所示，缓存层方框中的间隔代表这个时间段缓存数据不存在，V2、V3以及V5版本在缓存中不存在并不会破坏我们的最终一致性要求，只要数据库的最终版本和缓存的最终版本是相同的就可以了。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2796296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbpcFMVGBvhuLoH4m6rYIj8yhttcP7lbiaonk7s2MgEjNyQmj9zOCXE1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;缓存是如何写入的&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;缓存写入的代码通常情况下都是和缓存使用的代码放在一起的，包含4个步骤，如下图所示：W1读取缓存，W2判断缓存是否存在，W3组装缓存数据（这通常需要向数据库进行查询），W4写入缓存。&lt;/p&gt;&lt;p&gt;每一个步骤间可能会停顿多久是没有办法控制的，尤其是W3、W4之间的停顿最为要命，它很可能让我们将旧版本的数据写入到缓存中。&lt;/p&gt;&lt;p&gt;&lt;br/&gt;我们可能会想，W4步的写入，带上W2的假设，即使用WriteIfNotExists语义，会不会有所改善？&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3916667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTb20FjhyT48qhUfho2h4bwblJcIsFVibcSh0dgWLCqB0hicJ8EDgk8VUyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;考虑如下的情形，假设有3个缓存写入的并发执行，由于短时间数据库大量的更新，它们分别组装的是V1、V2、V3版本的数据。&lt;/p&gt;&lt;p&gt;使用WriteIfNotExists语义，其中必然有2个执行会失败，哪一个会成功根本无法保证。&lt;/p&gt;&lt;p&gt;我们无法简单的做决策，需要再次将缓存读取出来，然后判断是否我们即将写入的一样，如果一样那就很简单；如果不一样的话，我们有两种选择：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;将缓存删除，让后续别的请求来处理写入。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用缓存提供的原子操作，仅在我们的数据是较新版本时写入。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.27833&quot; data-w=&quot;1006&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbxFk3v9PuJ3VBXYmdBKGOcvrMXAyRjrqiaXlId1X7Q849lA9Gbon5dpg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;如何感知数据库的变化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;数据库的数据发生变化后，我们如何感知到并进行有效的缓存管理呢？&lt;/p&gt;&lt;p&gt;通常情况下有如下的3种做法：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用代码执行流&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;通常我们会在数据库操作完成后，执行一些缓存操作的代码。&lt;/p&gt;&lt;p&gt;这种方式最大的问题是可靠性不高，应用重启、机器意外当机等情况都会导致后续的代码无法执行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用事务消息&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;作为使用代码执行流的改进，在数据库操作完成后发出事务消息，然后在消息的消费逻辑里执行缓存的管理操作。&lt;/p&gt;&lt;p&gt;可靠性的问题就解决了，只是业务侧要为此增加事务消息的逻辑，以及运行成本。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;使用数据变更日志&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;数据库产品通常都支持在数据变更后产生变更日志，比如MySQL的binlog。&lt;/p&gt;&lt;p&gt;可以让中间件团队写一款产品，在接收到变更后执行缓存的管理操作，比如阿里的精卫。&lt;/p&gt;&lt;p&gt;可靠性有保证，同时还可以进行某个时间段变更日志的回放，功能就比较强大了。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;最佳实践一：数据库变更后失效缓存&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这是最常用和简单的方式，应该被作为首选的方案，整体的执行逻辑如下图所示：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5731481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTbuFnDYpEbhQKFJQVPGlOAZaJibTSPEQ0ag8mIn1J78yhhBfdYOlLhBibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;W4步使用最基本的put语义，这里的假设是写入较晚的请求往往也是携带的最新的数据，这在大多的情形下都是成立的。&lt;/p&gt;&lt;p&gt;D1步使用监听DB binlog的方式来删除缓存，即前述使用数据变更日志中介绍的方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;这个方案的缺点是&lt;/strong&gt;：在数据库数据存在高并发更新且缓存读取流量较大的情况下，会有小概率存在缓存中存储的是旧版本数据的情况。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通常的解法有四种：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;限制缓存有效时间&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;设定缓存的过期时间，比如15分钟。即表示我们最多接受缓存在15分钟的时间范围内是旧的。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;小概率缓存重加载&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;根据流量比设定一定比例的缓存重加载，以保证大流量情况下的缓存数据的一致性。&lt;/p&gt;&lt;p&gt;比如1%的比例，这同时还可以帮助数据库得到充分的预热。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;结合业务特点&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;根据业务的特点做一些设计，比如：&lt;/p&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;针对营销的场景&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;在商品详情页/确认订单页的优惠计算时使用缓存，而在下单时不使用缓存。&lt;/p&gt;&lt;p&gt;这可以让极端情况发生时，不产生过大的业务损失。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;针对库存的场景&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;读取到旧版本的数据只是会在商品已售罄的情况下让多余的流量进入到下单而已，下单时的库存扣减是操作数据库的，所以不会有业务上的损失。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;两次删除&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;D1步删除缓存的操作执行两次，且中间有一定的间隔，比如30秒。&lt;/p&gt;&lt;p&gt;这两次动作的触发都是由“缓存管理组件”发起的，所以可以由它支持。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;最佳实践二：带版本写入&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;针对象商品信息缓存这种更新频率低、数据一致性要求较高且缓存读取流量很高的场景，通常会采用带版本更新的方式，整体的执行逻辑如下图如示：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6055556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74ACnsfKcnFDT8Uf8XcCHKTblN4aNHDMTub6GiboN4tIj5MlIj1sSpEiamGf0A9Pu2VBmPRF9fjxcayA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;和“数据库变更后失效缓存”方案最大的差异在W4步和D1步，需要缓存层提供带版本写入的API，即仅当写入数据版本较新时可以写入成功，否则写入失败。&lt;/p&gt;&lt;p&gt;这同时也要求我们在数据库增加数据版本的信息。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个方案的最终一致性效果比较好，仅在极端情况下（新版本写入后数据丢失了，后续旧版本的写入就会成功）存在缓存中存储的是旧版本数据的可能。&lt;/p&gt;&lt;p&gt;在D1步使用写入而不是使用删除可以极大程度的避免这个极端情况的出现，同时由于该方案适用于缓存读取流量很高的场景，还可以避免缓存被删除后W3步短时间大量请求穿透到DB。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;总结与展望&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;对于缓存与数据库分离的场景，在结合了业界多家公司的实践经验以及ROI权衡之后，前述的两个最佳实践是被应用的最为广泛的，尤其是最佳实践一，应该作为我们日常应用的首选。&lt;/p&gt;&lt;p&gt;同时，为了最大限度的避免每个最佳实践背后可能发生的不一致性问题，我们还需要切合业务的特点，在关键的场景上做一些保障一致性的设计（比如前述的营销在下单时使用数据库读而不是缓存读），这也显得尤为重要（毕竟如“背景”中所述，并不存在完美的技术方案）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;除了缓存与数据库分离的方案，还有两个业界已经应用的方案也值得我们借鉴：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;阿里XKV&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;简单来讲就是在数据库上部署一个Memcache的Server，它直接绕过数据库层直接访问存储引擎层（如：InnoDB），同时使用KV client来进行数据的访问。&lt;/p&gt;&lt;p&gt;它的特点是数据实际上与数据库是强一致的，性能可以比使用SQL访问数据库提升5～10倍。&lt;/p&gt;&lt;p&gt;缺点也很明显，只能通过主键或者唯一键来访问数据（这只是相对SQL来说的，大多数缓存本来也就是KV访问协议）。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;腾讯DCache&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;不用自行维护缓存与数据库两套存储，给开发人员统一的一套数据视图，由DCache在缓存更新后自行持久化数据。&lt;/p&gt;&lt;p&gt;缺点是支持的数据结构有限（ key-value，k-k-row，list，set，zset ），未来也很难支持形如数据库表一样复杂的数据结构。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.004&quot; data-w=&quot;1000&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/n4p7ssmqwmGHOiaBs4TLdiacnZ6Ub3E6Oqia4cJNlwjuvAI6fuDuXvUGb9FX2wTNgvRtdpqlSf4V780atTia0eorag/640?wx_fmt=gif&quot; data-type=&quot;gif&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;*文/苏木&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkxNTE3ODU0NA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/AAQtmjCc74Diclic7XyegA4UmC0SqoT4jDEpdzibjkibmAvz8svbJwfsufiaBqOWx9sskIrickxzGfCwkjuMBiaNLDxNA/0?wx_fmt=png&quot; data-nickname=&quot;得物技术&quot; data-signature=&quot;技术知识分享交流平台，与你一同走向技术的云端。&quot;/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dfe5304959ee4108032de2d773ec31a1</guid>
<title>[推荐] 聊聊spring事务失效的12种场景，太坑了</title>
<link>https://toutiao.io/k/uf6yk96</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong data-darkmode-bgcolor-16346154121535=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16346154121535=&quot;#fff|rgb(255, 255, 255)|rgb(255, 255, 255)&quot; data-darkmode-color-16346154121535=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16346154121535=&quot;#fff|rgb(62, 62, 62)|rgb(0, 0, 0)&quot; data-style=&quot;outline: 0px; letter-spacing: 0.544px; text-align: left; white-space: normal; color: rgb(0, 0, 0); font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &amp;quot;PingFang SC&amp;quot;, Cambria, Cochin, Georgia, Times, &amp;quot;Times New Roman&amp;quot;, serif; font-size: 16px; background-color: rgb(255, 255, 255);&quot; class=&quot;js_darkmode__2&quot;&gt;点击关注公众号，Java干货&lt;/strong&gt;&lt;span data-darkmode-bgcolor-16346154121535=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16346154121535=&quot;#fff|rgb(255, 255, 255)|rgb(255, 255, 255)&quot; data-darkmode-color-16346154121535=&quot;rgb(255, 76, 65)&quot; data-darkmode-original-color-16346154121535=&quot;#fff|rgb(62, 62, 62)|rgb(255, 76, 65)&quot; data-style=&quot;outline: 0px; letter-spacing: 0.544px; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &amp;quot;PingFang SC&amp;quot;, Cambria, Cochin, Georgia, Times, &amp;quot;Times New Roman&amp;quot;, serif; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(255, 76, 65);&quot; class=&quot;js_darkmode__3&quot;&gt;&lt;strong data-darkmode-bgcolor-16346154121535=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16346154121535=&quot;#fff|rgb(255, 255, 255)|rgb(255, 255, 255)&quot; data-darkmode-color-16346154121535=&quot;rgb(255, 76, 65)&quot; data-darkmode-original-color-16346154121535=&quot;#fff|rgb(62, 62, 62)|rgb(255, 76, 65)&quot;&gt;及时送达👇&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4MDUyMDQyNQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/knmrNHnmCLEX3M6DvCn5gKuBOaMMVu9lUJAvwH2k66nV9VgGG0cyczd1ryib06P1z5pF72Le3HUr5loicnQx36lg/0?wx_fmt=png&quot; data-nickname=&quot;小哈学Java&quot; data-alias=&quot;xiaoha_java&quot; data-signature=&quot;专注于Java领域干货分享，不限于BAT面试, 算法，数据库，Spring Boot, 微服务,高并发, JVM, Docker容器，ELK相关知识，期待与您一同进步。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5645161290322581&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/knmrNHnmCLHoM2ib2hgLaZr0ruTQZDRYZlAFxVibcicZ18G3Llxx1ibOBNRVRWeex0qMOndOBUfLgh1K72Nm1G31zg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;496&quot;/&gt;&lt;span data-darkmode-bgcolor-16346154121535=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16346154121535=&quot;#fff|rgb(255, 255, 255)|rgb(255, 255, 255)&quot; data-darkmode-color-16346154121535=&quot;rgb(255, 76, 65)&quot; data-darkmode-original-color-16346154121535=&quot;#fff|rgb(62, 62, 62)|rgb(255, 76, 65)&quot; data-style=&quot;outline: 0px; letter-spacing: 0.544px; text-align: left; font-family: Optima-Regular, Optima, PingFangSC-light, PingFangTC-light, &amp;quot;PingFang SC&amp;quot;, Cambria, Cochin, Georgia, Times, &amp;quot;Times New Roman&amp;quot;, serif; font-size: 16px; background-color: rgb(255, 255, 255); color: rgb(255, 76, 65);&quot; class=&quot;js_darkmode__3&quot;&gt;&lt;strong data-darkmode-bgcolor-16346154121535=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16346154121535=&quot;#fff|rgb(255, 255, 255)|rgb(255, 255, 255)&quot; data-darkmode-color-16346154121535=&quot;rgb(255, 76, 65)&quot; data-darkmode-original-color-16346154121535=&quot;#fff|rgb(62, 62, 62)|rgb(255, 76, 65)&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于从事java开发工作的同学来说，spring的事务肯定再熟悉不过了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在某些业务场景下，如果一个请求中，需要同时&lt;span&gt;写入&lt;/span&gt;多张表的数据。为了保证操作的原子性（要么同时成功，要么同时失败），避免数据不一致的情况，我们一般都会用到spring事务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;确实，spring事务用起来贼爽，就用一个简单的注解：&lt;code&gt;@Transactional&lt;/code&gt;，就能轻松搞定事务。我猜大部分小伙伴也是这样用的，而且一直用一直爽。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果你使用不当，它也会坑你于无形。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们就一起聊聊，事务失效的一些场景，说不定你已经中招了。不信，让我们一起看看。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9913419913419913&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDFI5ibhP1TXOMnqQtJhfb3XCnTbgmpiab2LDA8VVCmg2jMUoeJd70gAJsj7vL2IB0icYxsbsvnKIu9LQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1386&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一 事务不生效&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.访问权限问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，java的访问权限主要有四种：private、default、protected、public，它们的权限从左到右，依次变大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果我们在开发过程中，把有某些事务方法，定义了错误的访问权限，就会导致事务功能出问题，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;         saveData(userModel);&lt;br/&gt;         updateData(userModel);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到add方法的访问权限被定义成了&lt;code&gt;private&lt;/code&gt;，这样会导致事务失效，spring要求被代理方法必须是&lt;code&gt;public&lt;/code&gt;的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说白了，在&lt;code&gt;AbstractFallbackTransactionAttributeSource&lt;/code&gt;类的&lt;code&gt;computeTransactionAttribute&lt;/code&gt;方法中有个判断，如果目标方法不是public，则&lt;code&gt;TransactionAttribute&lt;/code&gt;返回null，即不支持事务。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; TransactionAttribute &lt;span&gt;computeTransactionAttribute&lt;/span&gt;&lt;span&gt;(Method method, @Nullable Class&amp;lt;?&amp;gt; targetClass)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// Don&#x27;t allow no-public methods as required.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (allowPublicMethodsOnly() &amp;amp;&amp;amp; !Modifier.isPublic(method.getModifiers())) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// The method may be on an interface, but we need attributes from the target class.&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// If the target class is null, the method will be unchanged.&lt;/span&gt;&lt;br/&gt;    Method specificMethod = AopUtils.getMostSpecificMethod(method, targetClass);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// First try is the method in the target class.&lt;/span&gt;&lt;br/&gt;    TransactionAttribute txAttr = findTransactionAttribute(specificMethod);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (txAttr != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; txAttr;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// Second try is the transaction attribute on the target class.&lt;/span&gt;&lt;br/&gt;    txAttr = findTransactionAttribute(specificMethod.getDeclaringClass());&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (txAttr != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; ClassUtils.isUserLevelMethod(method)) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; txAttr;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (specificMethod != method) {&lt;br/&gt;      &lt;span&gt;// Fallback is to look at the original method.&lt;/span&gt;&lt;br/&gt;      txAttr = findTransactionAttribute(method);&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (txAttr != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; txAttr;&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;// Last fallback is the class of the original method.&lt;/span&gt;&lt;br/&gt;      txAttr = findTransactionAttribute(method.getDeclaringClass());&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (txAttr != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; ClassUtils.isUserLevelMethod(method)) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; txAttr;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，如果我们自定义的事务方法（即目标方法），它的访问权限不是&lt;code&gt;public&lt;/code&gt;，而是private、default或protected的话，spring则不会提供事务功能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2. 方法用final修饰&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，某个方法不想被子类重新，这时可以将该方法定义成final的。普通方法这样定义是没问题的，但如果将事务方法定义成final，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        saveData(userModel);&lt;br/&gt;        updateData(userModel);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到add方法被定义成了&lt;code&gt;final&lt;/code&gt;的，这样会导致事务失效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你看过spring事务的源码，可能会知道spring事务底层使用了aop，也就是通过jdk动态代理或者cglib，帮我们生成了代理类，在代理类中实现的事务功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果某个方法用final修饰了，那么在它的代理类中，就无法重写该方法，而添加事务功能。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：如果某个方法是static的，同样无法通过动态代理，变成事务方法。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.方法内部调用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候我们需要在某个Service类的某个方法中，调用另外一个事务方法，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br/&gt;&lt;br/&gt;  &lt;span/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        userMapper.insertUser(userModel);&lt;br/&gt;        updateStatus(userModel);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;updateStatus&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        doSameThing();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到在事务方法add中，直接调用事务方法updateStatus。从前面介绍的内容可以知道，updateStatus方法拥有事务的能力是因为spring aop生成代理了对象，但是这种方法直接调用了this对象的方法，所以updateStatus方法不会生成事务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此可见，在同一个类中的方法直接内部调用，会导致事务失效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了，如果有些场景，确实想在同一个类的某个方法中，调用它自己的另外一个方法，该怎么办呢？&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 新加一个Service方法&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个方法非常简单，只需要新加一个Service方法，把@Transactional注解加到新Service方法上，把需要事务执行的代码移到新方法中。具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Servcie&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ServiceA&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;   prvate ServiceB serviceB;&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;save&lt;/span&gt;&lt;span&gt;(User user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;         queryData1();&lt;br/&gt;         queryData2();&lt;br/&gt;         serviceB.doSave(user);&lt;br/&gt;   }&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;@Servcie&lt;/span&gt;&lt;br/&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ServiceB&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;(rollbackFor=Exception&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSave&lt;/span&gt;(&lt;span&gt;User&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;       addData1();&lt;br/&gt;       updateData2();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 在该Service类中注入自己&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不想再新加一个Service类，在该Service类中注入自己也是一种选择。具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Servcie&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ServiceA&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;   prvate ServiceA serviceA;&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;save&lt;/span&gt;&lt;span&gt;(User user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;         queryData1();&lt;br/&gt;         queryData2();&lt;br/&gt;         serviceA.doSave(user);&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;@Transactional&lt;/span&gt;(rollbackFor=Exception&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSave&lt;/span&gt;(&lt;span&gt;User&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;       addData1();&lt;br/&gt;       updateData2();&lt;br/&gt;    }&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能有些人可能会有这样的疑问：这种做法会不会出现循环依赖问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：不会。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实spring ioc内部的三级缓存保证了它，不会出现循环依赖问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 通过AopContent类&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在该Service类中使用AopContext.currentProxy()获取代理对象&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的方法2确实可以解决问题，但是代码看起来并不直观，还可以通过在该Service类中使用AOPProxy获取代理对象，实现相同的功能。具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Servcie&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ServiceA&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;save&lt;/span&gt;&lt;span&gt;(User user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;         queryData1();&lt;br/&gt;         queryData2();&lt;br/&gt;         ((ServiceA)AopContext.currentProxy()).doSave(user);&lt;br/&gt;   }&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;@Transactional&lt;/span&gt;(rollbackFor=Exception&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSave&lt;/span&gt;(&lt;span&gt;User&lt;/span&gt; &lt;span&gt;user&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;       addData1();&lt;br/&gt;       updateData2();&lt;br/&gt;    }&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.未被spring管理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们平时开发过程中，有个细节很容易被忽略。即使用spring事务的前提是：对象要被spring管理，需要创建bean实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下，我们通过@Controller、@Service、@Component、@Repository等注解，可以自动实现bean实例化和依赖注入的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有一天，你匆匆忙忙的开发了一个Service类，但忘了加@Service注解，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;         saveData(userModel);&lt;br/&gt;         updateData(userModel);&lt;br/&gt;    }    &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的例子，我们可以看到UserService类没有加&lt;code&gt;@Service&lt;/code&gt;注解，那么该类不会交给spring管理，所以它的add方法也不会生成事务。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.多线程调用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际项目开发中，多线程的使用场景还是挺多的。如果spring事务用在多线程场景中，会有问题吗？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RoleService roleService;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        userMapper.insertUser(userModel);&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(() -&amp;gt; {&lt;br/&gt;            roleService.doOtherThing();&lt;br/&gt;        }).start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RoleService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doOtherThing&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;保存role表数据&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的例子中，我们可以看到事务方法add中，调用了事务方法doOtherThing，但是事务方法doOtherThing是在另外一个线程中调用的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样会导致两个方法不在同一个线程中，获取到的数据库连接不一样，从而是两个不同的事务。如果想doOtherThing方法中抛了异常，add方法也回滚是不可能的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果看过spring事务源码的朋友，可能会知道spring的事务是通过数据库连接来实现的。当前线程中保存了一个map，key是数据源，value是数据库连接。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ThreadLocal&amp;lt;Map&amp;lt;Object, Object&amp;gt;&amp;gt; resources =&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;new&lt;/span&gt; NamedThreadLocal&amp;lt;&amp;gt;(&lt;span&gt;&quot;Transactional resources&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们说的同一个事务，其实是指同一个数据库连接，只有拥有同一个数据库连接才能同时提交和回滚。如果在不同的线程，拿到的数据库连接肯定是不一样的，所以是不同的事务。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;6.表不支持事务&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;周所周知，在mysql5之前，默认的数据库引擎是&lt;code&gt;myisam&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的好处就不用多说了：索引文件和数据文件是分开存储的，对于查多写少的单表操作，性能比innodb更好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些老项目中，可能还在用它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在创建表的时候，只需要把&lt;code&gt;ENGINE&lt;/code&gt;参数设置成&lt;code&gt;MyISAM&lt;/code&gt;即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CREATE TABLE `category` (&lt;br/&gt;  `id` bigint NOT NULL AUTO_INCREMENT,&lt;br/&gt;  `one_category` varchar(&lt;span&gt;20&lt;/span&gt;) COLLATE utf8mb4_bin DEFAULT NULL,&lt;br/&gt;  `two_category` varchar(&lt;span&gt;20&lt;/span&gt;) COLLATE utf8mb4_bin DEFAULT NULL,&lt;br/&gt;  `three_category` varchar(&lt;span&gt;20&lt;/span&gt;) COLLATE utf8mb4_bin DEFAULT NULL,&lt;br/&gt;  `four_category` varchar(&lt;span&gt;20&lt;/span&gt;) COLLATE utf8mb4_bin DEFAULT NULL,&lt;br/&gt;  &lt;span&gt;PRIMARY &lt;span&gt;KEY&lt;/span&gt; &lt;span&gt;(`id`)&lt;/span&gt;&lt;br/&gt;) ENGINE&lt;/span&gt;=MyISAM AUTO_INCREMENT=&lt;span&gt;4&lt;/span&gt; DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;myisam好用，但有个很致命的问题是：&lt;code&gt;不支持事务&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果只是单表操作还好，不会出现太大的问题。但如果需要跨多张表操作，由于其不支持事务，数据极有可能会出现不完整的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，myisam还不支持行锁和外键。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在实际业务场景中，myisam使用的并不多。在mysql5以后，myisam已经逐渐退出了历史的舞台，取而代之的是innodb。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;有时候我们在开发的过程中，发现某张表的事务一直都没有生效，那不一定是spring事务的锅，最好确认一下你使用的那张表，是否支持事务。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7.未开启事务&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，事务没有生效的根本原因是没有开启事务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你看到这句话可能会觉得好笑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开启事务不是一个项目中，最最最基本的功能吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么还会没有开启事务？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，如果项目已经搭建好了，事务功能肯定是有的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果你是在搭建项目demo的时候，只有一张表，而这张表的事务没有生效。那么会是什么原因造成的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然原因有很多，但没有开启事务，这个原因极其容易被忽略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你使用的是springboot项目，那么你很幸运。因为springboot通过&lt;code&gt;DataSourceTransactionManagerAutoConfiguration&lt;/code&gt;类，已经默默的帮你开启了事务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你所要做的事情很简单，只需要配置&lt;code&gt;spring.datasource&lt;/code&gt;相关参数即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果你使用的还是传统的spring项目，则需要在applicationContext.xml文件中，手动配置事务相关参数。如果忘了配置，事务肯定是不会生效的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体配置如下信息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;   &lt;br/&gt;&amp;lt;!-- 配置事务管理器 --&amp;gt; &lt;br/&gt;&amp;lt;bean &lt;span&gt;&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;=&lt;span&gt;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&lt;/span&gt; id=&lt;span&gt;&quot;transactionManager&quot;&lt;/span&gt;&amp;gt; &lt;br/&gt;    &amp;lt;property name=&lt;span&gt;&quot;dataSource&quot;&lt;/span&gt; ref=&lt;span&gt;&quot;dataSource&quot;&lt;/span&gt;&amp;gt;&amp;lt;/property&amp;gt; &lt;br/&gt;&amp;lt;/bean&amp;gt; &lt;br/&gt;&amp;lt;tx:advice id=&lt;span&gt;&quot;advice&quot;&lt;/span&gt; transaction-manager=&lt;span&gt;&quot;transactionManager&quot;&lt;/span&gt;&amp;gt; &lt;br/&gt;    &amp;lt;tx:attributes&amp;gt; &lt;br/&gt;        &amp;lt;tx:method name=&lt;span&gt;&quot;*&quot;&lt;/span&gt; propagation=&lt;span&gt;&quot;REQUIRED&quot;&lt;/span&gt;/&amp;gt;&lt;br/&gt;    &amp;lt;/tx:attributes&amp;gt; &lt;br/&gt;&amp;lt;/tx:advice&amp;gt; &lt;br/&gt;&amp;lt;!-- 用切点把事务切进去 --&amp;gt; &lt;br/&gt;&amp;lt;aop:config&amp;gt; &lt;br/&gt;    &amp;lt;aop:pointcut expression=&lt;span&gt;&quot;execution(* com.susan.*.*(..))&quot;&lt;/span&gt; id=&lt;span&gt;&quot;pointcut&quot;&lt;/span&gt;/&amp;gt; &lt;br/&gt;    &amp;lt;aop:advisor advice-ref=&lt;span&gt;&quot;advice&quot;&lt;/span&gt; pointcut-ref=&lt;span&gt;&quot;pointcut&quot;&lt;/span&gt;/&amp;gt; &lt;br/&gt;&amp;lt;/aop:config&amp;gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默默的说一句，如果在pointcut标签中的切入点匹配规则，配错了的话，有些类的事务也不会生效。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二 事务不回滚&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.错误的传播特性&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，我们在使用&lt;code&gt;@Transactional&lt;/code&gt;注解时，是可以指定&lt;code&gt;propagation&lt;/code&gt;参数的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该参数的作用是指定事务的传播特性，spring目前支持7种传播特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;REQUIRED&lt;/code&gt; 如果当前上下文中存在事务，那么加入该事务，如果不存在事务，创建一个事务，这是默认的传播属性值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;SUPPORTS&lt;/code&gt; 如果当前上下文存在事务，则支持事务加入事务，如果不存在事务，则使用非事务的方式执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;MANDATORY&lt;/code&gt; 如果当前上下文中存在事务，否则抛出异常。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;REQUIRES_NEW&lt;/code&gt; 每次都会新建一个事务，并且同时将上下文中的事务挂起，执行当前新建事务完成以后，上下文事务恢复再执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;NOT_SUPPORTED&lt;/code&gt; 如果当前上下文中存在事务，则挂起当前事务，然后新的方法在没有事务的环境中执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;NEVER&lt;/code&gt; 如果当前上下文中存在事务，则抛出异常，否则在无事务环境上执行代码。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;NESTED&lt;/code&gt; 如果当前上下文中存在事务，则嵌套事务执行，如果不存在事务，则新建事务。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们在手动设置propagation参数的时候，把传播特性设置错了，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;(propagation = Propagation.NEVER)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        saveData(userModel);&lt;br/&gt;        updateData(userModel);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看到add方法的事务传播特性定义成了Propagation.NEVER，这种类型的传播特性不支持事务，如果有事务则会抛异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前只有这三种传播特性才会创建新事务：REQUIRED，REQUIRES_NEW，NESTED。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.自己吞了异常&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务不会回滚，最常见的问题是：开发者在代码中手动try...catch了异常。比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            saveData(userModel);&lt;br/&gt;            updateData(userModel);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            log.error(e.getMessage(), e);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况下spring事务当然不会回滚，因为开发者自己捕获了异常，又没有手动抛出，换句话说就是把异常吞掉了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想要spring事务能够正常回滚，必须抛出它能够处理的异常。如果没有抛异常，则spring认为程序是正常的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.手动抛了别的异常&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使开发者没有手动捕获异常，但如果抛的异常不正确，spring事务也不会回滚。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;             saveData(userModel);&lt;br/&gt;             updateData(userModel);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            log.error(e.getMessage(), e);&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception(e);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的这种情况，开发人员自己捕获了异常，又手动抛出了异常：Exception，事务同样不会回滚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为spring事务，默认情况下只会回滚&lt;code&gt;RuntimeException&lt;/code&gt;（运行时异常）和&lt;code&gt;Error&lt;/code&gt;（错误），对于普通的Exception（非运行时异常），它不会回滚。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.自定义了回滚异常&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用@Transactional注解声明事务时，有时我们想自定义回滚的异常，spring也是支持的。可以通过设置&lt;code&gt;rollbackFor&lt;/code&gt;参数，来完成这个功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果这个参数的值设置错了，就会引出一些莫名其妙的问题，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;(rollbackFor = BusinessException&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;UserModel&lt;/span&gt; &lt;span&gt;userModel&lt;/span&gt;) &lt;span&gt;throws&lt;/span&gt; &lt;span&gt;Exception&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;       saveData(userModel);&lt;br/&gt;       updateData(userModel);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在执行上面这段代码，保存和更新数据时，程序报错了，抛了SqlException、DuplicateKeyException等异常。而BusinessException是我们自定义的异常，报错的异常不属于BusinessException，所以事务也不会回滚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使rollbackFor有默认值，但阿里巴巴开发者规范中，还是要求开发者重新指定该参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是为什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为如果使用默认值，一旦程序抛出了Exception，事务不会回滚，这会出现很大的bug。所以，建议一般情况下，将该参数设置成：Exception或Throwable。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.嵌套事务回滚多了&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RoleService roleService;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        userMapper.insertUser(userModel);&lt;br/&gt;        roleService.doOtherThing();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RoleService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;(propagation = Propagation.NESTED)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doOtherThing&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;保存role表数据&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况使用了嵌套的内部事务，原本是希望调用roleService.doOtherThing方法时，如果出现了异常，只回滚doOtherThing方法里的内容，不回滚 userMapper.insertUser里的内容，即回滚保存点。。但事实是，insertUser也回滚了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;why?&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为doOtherThing方法出现了异常，没有手动捕获，会继续往上抛，到外层add方法的代理方法中捕获了异常。所以，这种情况是直接回滚了整个事务，不只回滚单个保存点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么样才能只回滚保存点呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; UserMapper userMapper;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RoleService roleService;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        userMapper.insertUser(userModel);&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            roleService.doOtherThing();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            log.error(e.getMessage(), e);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以将内部嵌套事务放在try/catch中，并且不继续往上抛异常。这样就能保证，如果内部嵌套事务中出现异常，只回滚内部事务，而不影响外部事务。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三 其他&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1 大事务问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在使用spring事务时，有个让人非常头疼的问题，就是大事务问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下，我们会在方法上&lt;code&gt;@Transactional&lt;/code&gt;注解，填加事务功能，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;UserService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RoleService roleService;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;       query1();&lt;br/&gt;       query2();&lt;br/&gt;       query3();&lt;br/&gt;       roleService.save(userModel);&lt;br/&gt;       update(userModel);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RoleService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RoleService roleService;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;@Transactional&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;save&lt;/span&gt;&lt;span&gt;(UserModel userModel)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;       query4();&lt;br/&gt;       query5();&lt;br/&gt;       query6();&lt;br/&gt;       saveData(userModel);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但&lt;code&gt;@Transactional&lt;/code&gt;注解，如果被加到方法上，有个缺点就是整个方法都包含在事务当中了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的这个例子中，在UserService类中，其实只有这两行才需要事务：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;roleService.save(userModel);&lt;br/&gt;update(userModel);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在RoleService类中，只有这一行需要事务：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;saveData(userModel);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在的这种写法，会导致所有的query方法也被包含在同一个事务当中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果query方法非常多，调用层级很深，而且有部分查询方法比较耗时的话，会造成整个事务非常耗时，而从造成大事务问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2759259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDEBCPPbyDJ73OtgGneSbqS4EPv3uEv9HEcX4hevWFJGDG8gPspHNL0abAiaEvxZoGZbBIkTbBQGfHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;2.编程式事务&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面聊的这些内容都是基于&lt;code&gt;@Transactional&lt;/code&gt;注解的，主要说的是它的事务问题，我们把这种事务叫做：&lt;code&gt;声明式事务&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，spring还提供了另外一种创建事务的方式，即通过手动编写代码实现的事务，&lt;span&gt;我们把这种事务叫做&lt;/span&gt;：&lt;code&gt;编程式事务&lt;/code&gt;。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;   &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;private&lt;/span&gt; TransactionTemplate transactionTemplate;&lt;br/&gt;   &lt;br/&gt;   ...&lt;br/&gt;   &lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;save&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; User user)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;         queryData1();&lt;br/&gt;         queryData2();&lt;br/&gt;         transactionTemplate.execute((status) =&amp;gt; {&lt;br/&gt;            addData1();&lt;br/&gt;            updateData2();&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;         })&lt;br/&gt;   }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在spring中为了支持编程式事务，专门提供了一个类：TransactionTemplate，在它的execute方法中，就实现了事务的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相较于&lt;code&gt;@Transactional&lt;/code&gt;注解声明式事务，我更建议大家使用，基于&lt;code&gt;TransactionTemplate&lt;/code&gt;的编程式事务。主要原因如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;避免由于spring aop问题，导致事务失效的问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;能够更小粒度的控制事务的范围，更直观。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;建议在项目中少使用@Transactional注解开启事务。但并不是说一定不能用它，如果项目中有些业务逻辑比较简单，而且不经常变动，使用@Transactional注解开启事务开启事务也无妨，因为它更简单，开发效率更高，但是千万要小心事务失效的问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1c012d41cbbfad492738e4d915df738e</guid>
<title>[推荐] 画架构图的神器</title>
<link>https://toutiao.io/k/4773s9p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;fieldset&gt;&lt;section data-brushtype=&quot;text&quot;&gt;架构师（JiaGouX）&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;我们都是架构师！&lt;br/&gt;架构未来，你来不来？&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/fieldset&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwNjQwNzU2NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/sXiaukvjR0RCNb3RYsCgx02T4J55ia2SnemY7uJHsDChxq6jAibbATlIKDgzLxz0zekXWjblzCDcL86AjbMNp02Tg/0?wx_fmt=png&quot; data-nickname=&quot;架构师&quot; data-alias=&quot;JiaGouX&quot; data-signature=&quot;架构师云集，三高（高可用、高性能、高稳定）架构、大数据、机器学习、Java架构、系统架构、大规模分布式架构、人工智能等的架构讨论交流，以及结合互联网技术的架构调整，大规模架构实战分享。欢迎有想法、乐于分享的架构师交流学习。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看过我以往文章的小伙伴可能会发现，我的大部分文章都有很多配图。我的文章风格是图文相结合，更便于大家理解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近有很多小伙伴发私信问我：文章中的图是用什么工具画的。他们觉得我画的图风格挺小清新的，能够让人眼前一亮。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先上几张图让大家看看效果：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7021996615905245&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEcQeQVeSPhd00alFgESSqkDNsO0rWriam0JoiccWGEP4ewJdibk25nZZiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1182&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.513677811550152&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBESNLJibcUXjyxw8wBM9S04knvpJRWzxGQzQcYATR48MicUtbTHKkGax4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1316&quot;/&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4361525704809287&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBExhcMHxwz8Qq45Q2sJeBBTxLtWGRaaFHkRbHLicrPn8ZVKnObEiaKMxkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1206&quot;/&gt;说实话，问我的人太多了，我真的没法一个个回复。同时问我的人多，也恰恰说明了这个工具的优秀。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天特地写一篇介绍画图工具的文章，给有需要的朋友一个参考。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 用什么画的图？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于画流程图的工具，之前大家用得比较多的可能是：&lt;code&gt;visio&lt;/code&gt;和&lt;code&gt;process on&lt;/code&gt;了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;visio&lt;/code&gt;是微软的一款画图软件，需要在电脑上安装，正版软件是付费的，但网上也可以搜到很多破解版。它是我用过的最早的画流程图工具了，后面使用mac电脑办公之后，就没有用过它了，之前觉得它跨电脑办公有点不方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;process on&lt;/code&gt;是一款免费在线画图工具，功能非常强大。除了常规的各种流程图之外，对于思维导图支持也非常友好。但有个缺点是只能免费保存最近9张图，想保留更多的图，需要付费升级。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面的两款画图工具，说到底还是收费的，对于喜欢白嫖的我们来说，有点无法接受。那么，有没有一款免费、在线、功能强大的画流程图的工具呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：有，可以使用：&lt;code&gt;diagrams&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，我文章中的图都是用&lt;code&gt;diagrams&lt;/code&gt;画出来的，也可以叫它：&lt;code&gt;draw.io&lt;/code&gt;，它已经成为了我画图首选工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这款画图工具的官网地址是：https://app.diagrams.net/，它的前身是：https://draw.io/。这两个url都能访问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时它也提供了离线版的画图软件，大家可以自己下载diagrams的安装软件，不过有个坏处是它是收费的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我用的最多的还是在线版的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 如何进入画图界面？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面已经知道，我的文章都是用&lt;code&gt;diagrams&lt;/code&gt;画流程图的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如何进入diagrams的画图界面呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在浏览器上输入diagrams的官网地址，我平时喜欢输入：&lt;code&gt;https://draw.io/&lt;/code&gt;，因为它比较好记。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次访问的时候有点慢，因为它要初始化一些东西。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2803819444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEkicr9pN4EjtlBrLhFveOKiawBA7NZN0to7h7d08apyjvJz7CuwSLibLCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2304&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，会弹出一个窗口，让我们选择画的图，需要保存到哪里。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48214285714285715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEz6LoWib1bdic6VXFiaXYyP0lJtZY9hwU0959MFVMRyOCp22aZLCFFSzzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2464&quot;/&gt;它主要支持四种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;OneDrive：即云&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Device：即设备&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Github&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Gitlab&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我目前为了图方便，用的最多的是&lt;code&gt;Device&lt;/code&gt;，它可以把画的图保存到本地电脑，也可以从本地电脑导入已有的图。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实如果可以的话，把图保存到&lt;code&gt;Github&lt;/code&gt;，也是个不错的选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，会弹出一个窗口，让你选择是Create New Diagram（创建新流程图），还是选择Open Existing Diagram（打开已有的流程图）。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7270471464019851&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBESZhribz7pkaq82baW6iaYnb27QE16vR5CLLHvJqultLNhC70zGDxN31w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;806&quot;/&gt;我们第一次进来，当然是选择创建新流程图了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，进入了画流程图的主界面：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5746388443017657&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBE6yxHRaA0VhHxKurYQ3t7Y1d6oATeaD2ibibZgL1lxxqt6a9swiaQnNMlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2492&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3 画图界面的组成部分&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;diagrams的工作界面主要是由以下几个部分组成：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5211155378486055&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEdYwF3yvNND7Qxkm97LZ2W079xic5VzuVU73ozAZQia8T4rA4SicDyyM6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2510&quot;/&gt;此外，在这里顺便说一句，如果你想修改流程图名称的话，可以双击左上角的：&lt;code&gt;Untitled Diagram.drawio&lt;/code&gt;这几个字，会弹出如下窗口：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38235294117647056&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEaSJ3tFGJ0OpyJYCibudZL736yskF1rl2ezw3eNcuicWrFUngdnxZwqiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;816&quot;/&gt;在这个窗口中可以修改流程图的名称和文件类型，默认是&lt;code&gt;.drawio&lt;/code&gt;格式的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面用一张图总结一下，diagrams的工作界面主要组成部分：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7270788912579957&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEUZzzvjNiaicf6LFmHibuZTb2Iouia8dGLwbrSZXJGuuQtQq3ORFxADcKzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;938&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.1 菜单栏&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.11148648648648649&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEMiaKwpoRmxicKG3H09elk4dxGqAmOghCQOG3r3DHArJbrQ6tTrqBLC5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;592&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;File&lt;/code&gt;菜单：包含了一系列的文件操作，包括：新建、打开文件、打开最近的文件、保存文件、另存为文件、分享文件、重命名、拷贝文件、导入、导出、打印、关闭等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Edit&lt;/code&gt;菜单：包含了一系列工作区的操作，包括：回退、撤回、剪切、复制、粘贴、删除、查找、替换、编辑、编辑属性、选择、全选等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;View&lt;/code&gt;菜单：包含了一系列的视图操作，包括：恢复默认布局、大纲视图、图层、标签、网格、滚动条、全屏等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Arrange&lt;/code&gt;菜单：包含了一系列图形排列操作，包含：在前面、在后面、插入图形、对齐等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Extras&lt;/code&gt;菜单：包含了一系列额外的操作，包含：主题、展开、收缩、插件、编辑画图区、配置等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Help&lt;/code&gt;菜单：主要包含一系列全局的操作，包含：搜索、快捷键、关于等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.2 工具栏&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.02857142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBE7528BHib30X3v53TI2IZL7fhPETiabuP803sm5WnFgXDxE5EVxCkVMibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2450&quot;/&gt;工具栏中包含了一些常用的功能，比如：图片尺寸、放大、缩小、退回、撤销、删除、在前、在后、背景色、字体颜色、连接、阴影、添加表格、添加图形、全屏、展开、收缩等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些功能真的太实用了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.3 左边图形区&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个区域可以选择我们画图时，需要的图形，默认有这7类图形。&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;1066&quot; data-backw=&quot;426&quot; data-ratio=&quot;2.5023474178403755&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEhpZOib4Nmfj6kgDMcFo3jNfy2nPsYfWSeIicP9PODU2K6RkRNCI7GqPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;426&quot;/&gt;如果不满足要求，可以点击 More Shapes 按钮，选择更多类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.739568345323741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEhNNAoyh3nTtsThQde1HLlXw7ozIibVzSnr6socA0cGDt2wwlGBouY1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1390&quot;/&gt;上图中我另外加了&lt;code&gt;IOS&lt;/code&gt;类的图形。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我个人喜欢使用&lt;code&gt;General&lt;/code&gt;类的图形：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.7208121827411167&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBE0Wm1lb7mrxKaQhAicFu7tav8qmywMovZ8sphbWn6yVbibhSzEvNlmyJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;394&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;里面常用的图形都有，画一般的流程图是够用的。当然你也可以根据个人喜欢，选择更多的类型画图。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.4 画图区&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6675257731958762&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEmnCP8AoM9dnhbKI8oNrB8BKPnUZic1EoADIFt4OW0wokNgveAZVbzng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1552&quot;/&gt;画图区是最重要的地方了，你的流程图是在这片区域完成的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以在左边的图形区选择好图形之后，用鼠标拖到画图区。也可以直接在画图区复制已有的图形。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还可以加网格：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5284653465346535&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBE63d8GR4EVibKM6yvoMSeibVm4EwIbaEOJpKjELjjMbU4I2so8KL2GrHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1616&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;右键空白的地方，会出现一些操作选项：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9698492462311558&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBE4AXjicv7EWaicbJSBwn4XU0Np31XJ5TKVmfoXoGpNrRNMrgKoG2ibia12Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;796&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;右键某个具体图形，会出现一些图形相关的选项：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2914691943127963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBETmAzsHLaXdcIcQUU97GHAyVUfMp6o6EnpSAPrAXqibOa3VFxqD5ibbEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;844&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.5 右边样式区&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.9958333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEMGxGicRBdDxKxThGMVOXcbDJtqlvxP8OELrz9CgvB0oXGpcrFzMfKnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;480&quot;/&gt;右边样式区可以说是diagrams的灵魂。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选择的图形，在画图区默认是这样的：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4981949458483754&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEoE4aibg7hv82N12zGycZQcgIiaAZm9y8mMFwgiapFzcpMBPQIl5sk7LQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;一眼看过去，显得非常单调。但如果在右边样式区，我加了一些样式之后，图形马上变得不一样了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5981554677206851&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEukaBHqX4lRUIpQOdh51vV2fX0PRedu66fVb1icrKPPCHzicEJWL4Curw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1518&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于文本样式也有挺多功能可以设置的：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5431606905710491&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEPxjjibSXOgF7zGlLBmLXh5UAg5svf7lfz3LNqnal3ZLwwYHNUxHfw8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1506&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.6 底部&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.05672823218997362&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEseqOogg5tHGPRrD16A2NrRWUhro0jcO1gSqL5icvqDHwLicDHIoicqfsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1516&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;底部主要展示的是每页的名称。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击左侧三个点：&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;422&quot; data-backw=&quot;438&quot; data-ratio=&quot;0.9634703196347032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEJF9XiaACQqqWGYkR6FEP8Xib4kBCdDLYXlD7FiaQH0LSJyTDic6xa9SNjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;438&quot;/&gt;可以切换、插入、删除和重命名页面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;点击右侧的加号：&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.09336099585062241&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBEDDRebca26ZSVDGIjWiaErmofVNMPWPliacrjKxVpJFQHvKzSjxFYsprg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;964&quot;/&gt;&lt;span&gt;可以立刻新增页面。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们每次画图需要在某个页面上操作。&lt;/span&gt;&lt;span&gt;但如果你需要画的图很多，可以使用页进行归类，方面今后维护。&lt;/span&gt;&lt;span&gt;不太建议，一页上画的图太多，不然画图时会非常卡。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要介绍了diagrams画图工具，它是一款免费的在线画图工具，也叫做draw.io。它的功能非常强大，包括：菜单栏、工具栏、左边图形区、画图区、右边样式区、底部等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时还介绍了如何进入画图区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然本文只是抛砖引玉，给大家介绍了diagrams的一小部分功能。它的强大之处，需要大家自己多动手摸索。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面用一张图给大家展示一下，我是如何使用diagrams画图的：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47346938775510206&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5jd2iaESCiah43qP7BwTyRHBETZ3yDdsUI1XpZEHlPX7IHhHaGg3iaCzcBvTHRNdIvmEEqy6U65FQmVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2450&quot;/&gt;好了，今天的内容先分享到这里，我们下期再见。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果大家觉得这个工具不错，或者看了我的分享有些收获的话，请帮我点个在看。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如喜欢本文，请点击右上角，把文章分享到朋友圈&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如有想了解学习的技术点，请留言给若飞安排分享&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;·END·&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;相关阅读：&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools-id=&quot;23409&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;作者：苏三呀    &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来源：苏三说技术&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;版权申明：&lt;/span&gt;&lt;span&gt;内容来源网络，版权归原创者所有。&lt;/span&gt;&lt;span&gt;除非无法确认，我们都会标明作者及出处，如有侵权烦请告知，我们会立即删除并表示歉意。&lt;/span&gt;&lt;span&gt;谢谢!&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;article ng-controller=&quot;EntryCtrl&quot; ui-lightbox=&quot;&quot;&gt;&lt;section ng-bind-html=&quot;postContentTrustedHtml&quot;&gt;&lt;section data-id=&quot;702&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;架构师&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;我们都是架构师！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img border=&quot;0&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/sXiaukvjR0RB58TtkIHwhn4lpsqLnZgian9d5tr1BibP7XpibGTFFib1nq9YuYq209XZUEfCOqMzepDOBbN9KD9wMSg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot; data-width=&quot;200px&quot; height=&quot;&quot; opacity=&quot;&quot; title=&quot;&quot; vspace=&quot;0&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;关注&lt;/strong&gt;架构师(JiaGouX)，添加“星标”&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;获取每天技术干货，一起成为牛逼架构师&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;技术群请&lt;/strong&gt;&lt;strong&gt;加若飞：&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;1321113940 &lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;进架构师群&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;投稿、合作、版权等邮箱：&lt;strong&gt;&lt;span&gt;admin@137x.com&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/article&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>