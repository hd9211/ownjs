<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>27a9b15aa01c6e1468b446ec04554e4e</guid>
<title>[推荐] 谈谈 Git 存储原理及相关实现</title>
<link>https://toutiao.io/k/mzszqf0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;post-intro&quot;&gt;摘要：Git 是目前最流行的版本控制系统，从本地开发到生产部署，我们每天都在使用 Git 进行我们的版本控制，除了日常使用的命令之外，如果想要对 Git 有更深一步的了解，那么研究下 Git 的底层存储原理将会对理解 Git 及其使用非常有帮助，就算你不是一个 Git 开发者，也推荐你了解下 Git 的底层原理，你会对 Git 的强大有一个全新的认识，并且将会在日常的 Git 使用过程中更加得心应手。&lt;/p&gt;&lt;div class=&quot;markdown-body&quot;&gt;&lt;p&gt;&lt;img src=&quot;https://zoker.io/uploads/images/2021/0221/232751_a88e9997.png&quot; alt=&quot;输入图片说明&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;这篇文章面向的读者主要是对 Git 有一定的了解的群体，并不会介绍具体 Git 的作用及其使用，也不会介绍与其它版本控制系统如 Subversion 之间的差异，主要是介绍下 Git 的本质以及他的存储实现的相关原理，旨在帮助 Git 使用者更加清晰的了解在使用 Git 进行版本控制的时候其内部实现。&lt;/p&gt;&amp;#13;
&lt;h2 id=&quot;git-本质是什么&quot;&gt;Git 本质是什么&lt;/h2&gt;&amp;#13;
&lt;p&gt;Git 本质上是一个内容寻址的 Key-Value 数据库，我们可以向 Git 仓库内插入任意类型的内容，Git 会返回给我们一个唯一的键值，可以通过这个键取出当时我们插入的值，我们可以通过底层命令&lt;code&gt;git hash-object&lt;/code&gt;命令来尝试：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ &lt;span class=&quot;hljs-keyword&quot;&gt;cat&lt;/span&gt; testfile&amp;#13;
Hello Git&amp;#13;
➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ git hash-object testfile -&lt;span class=&quot;hljs-keyword&quot;&gt;w&lt;/span&gt;&amp;#13;
&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;f4d96d5b00d98959ea9960f069585ce42b1349a&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到我们目录下有一个名为&lt;code&gt;testfile&lt;/code&gt;的文件，内容是&lt;code&gt;Hello Git!&lt;/code&gt; 我们使用&lt;code&gt;git hash-object&lt;/code&gt;命令将这个文件的内容写入到 Git 仓库，&lt;code&gt;-w&lt;/code&gt; 选项告诉 Git 把这个内容写到 Git 的&lt;code&gt;.git/objects&lt;/code&gt;对象数据库目录，并且 Git 返回了一个 SHA 值，这个 SHA 值就是后续我们要取出这个文件的键值：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ git &lt;span class=&quot;hljs-keyword&quot;&gt;cat&lt;/span&gt;-&lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt; -&lt;span class=&quot;hljs-keyword&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;f4d96d5b00d98959ea9960f069585ce42b1349a&amp;#13;
Hello Git&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们使用了&lt;code&gt;git cat-file&lt;/code&gt;命令取回刚刚存入到 Git 仓库的内容，虽然不像&lt;code&gt;Redis&lt;/code&gt;的命令&lt;code&gt;get&lt;/code&gt; &lt;code&gt;set&lt;/code&gt; 那么直观，但是它确实是一个 KV 数据库，不是吗？&lt;/p&gt;&amp;#13;
&lt;p&gt;我们刚刚尝试插入的这种数据是基础的&lt;code&gt;blob&lt;/code&gt;类型的对象，Git 还有其它如 &lt;code&gt;tree&lt;/code&gt;、&lt;code&gt;commit&lt;/code&gt;等对象类型，这些不同的对象类型之间有特定的关联关系，它们将不同的对象有逻辑的关联起来，才能够帮我们进行不同版本的控制和检出。稍后会展开讲解这几种不同的对象类型，我们先来了解下 Git 的目录结构，看看在 Git 中数据是如何存放的。&lt;/p&gt;&amp;#13;
&lt;h2 id=&quot;git-目录结构&quot;&gt;Git 目录结构&lt;/h2&gt;&amp;#13;
&lt;p&gt;通过上一节的介绍，我们知道了 Git 本质就是一个 KV 数据库，而且还提到了内容都是写到 &lt;code&gt;.git/objects&lt;/code&gt;对象目录，那么这个目录放在哪里？Git 又是如何存储这些数据的呢？本节我们重点介绍一下 Git 的存储目录结构，了解下 Git 是如何存放不同类型的数据的。&lt;/p&gt;&amp;#13;
&lt;blockquote&gt;&amp;#13;
&lt;p&gt;更详细的介绍参见：&lt;a href=&quot;https://github.com/git/git/blob/master/Documentation/gitrepository-layout.txt&quot;&gt;https://github.com/git/git/blob/master/Documentation/gitrepository-layout.txt&lt;/a&gt;&lt;/p&gt;&amp;#13;
&lt;/blockquote&gt;&amp;#13;
&lt;p&gt;通过 &lt;code&gt;git init&lt;/code&gt; 我们可以在当前目录初始化一个空的 Git 仓库，Git 会自动生成 &lt;code&gt;.git&lt;/code&gt; 目录，这个 &lt;code&gt;.git&lt;/code&gt; 目录就是后续所有的 Git 元数据的存储中心，我们来看一下它的目录结构：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker git init&amp;#13;
Initialized empty Git repository &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; /Users/zoker/tmp/Zoker/.git/&amp;#13;
➜  Zoker git:(master) ✗ tree &lt;span class=&quot;hljs-class&quot;&gt;.git&lt;/span&gt;&amp;#13;
&lt;span class=&quot;hljs-class&quot;&gt;.git&lt;/span&gt;&amp;#13;
├── HEAD              &lt;span class=&quot;hljs-comment&quot;&gt;// 是一个符号引用，指明当前工作目录的版本引用信息，我们平时执行 checkout 命令时就会改变 HEAD 的内容&lt;/span&gt;&amp;#13;
├── config             &lt;span class=&quot;hljs-comment&quot;&gt;// 配置当前存储库的一些信息，如：Proxy、用户信息、引用等，此处的配置项相对于全局配置权重更高&lt;/span&gt;&amp;#13;
├── description      &lt;span class=&quot;hljs-comment&quot;&gt;// 仓库描述信息&lt;/span&gt;&amp;#13;
├── hooks             &lt;span class=&quot;hljs-comment&quot;&gt;// 钩子目录，执行 Git 相关命令后的回调脚本，默认会有一些模板&lt;/span&gt;&amp;#13;
│   ├── update&lt;span class=&quot;hljs-class&quot;&gt;.sample&lt;/span&gt;&amp;#13;
│   ├── pre-receive&lt;span class=&quot;hljs-class&quot;&gt;.sample&lt;/span&gt;&amp;#13;
│   └── ...&amp;#13;
├── info                &lt;span class=&quot;hljs-comment&quot;&gt;// 存储一些额外的仓库信息如 refs、exclude、attributes 等&lt;/span&gt;&amp;#13;
│   └── exclude&amp;#13;
├── objects           &lt;span class=&quot;hljs-comment&quot;&gt;// 元数据存储中心&lt;/span&gt;&amp;#13;
│   ├── info&amp;#13;
│   └── pack&amp;#13;
└── refs               &lt;span class=&quot;hljs-comment&quot;&gt;// 存放引用信息，也就是分支、标签&lt;/span&gt;&amp;#13;
    ├── heads&amp;#13;
    └── tags&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;默认初始化生成的 Git 仓库就只有这些文件，除此之外还存在一些其它类型的文件和目录如&lt;code&gt;packed-refs&lt;/code&gt; &lt;code&gt;modules&lt;/code&gt; &lt;code&gt;logs&lt;/code&gt;等，这些文件都有特定的用途，都是在特定的操作或者配置后才会出现，这里我们只关注核心存储的实现，这些额外文件或目录的作用及使用场景再可自行翻阅文档，这里仅介绍核心的一些文件。&lt;/p&gt;&amp;#13;
&lt;h3 id=&quot;hooks-目录&quot;&gt;hooks 目录&lt;/h3&gt;&amp;#13;
&lt;p&gt;hooks 目录主要存储的是 Git 钩子，Git 钩子可以在很多事件发生后或者发生前触发，能够提供给我们非常灵活的使用方式，默认情况下全部都是带&lt;code&gt;.sample&lt;/code&gt;后缀的，需要移除这个后缀并赋予可执行权限方可生效，下面列举下常用的一些钩子及其常见的用途：&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;客户端钩子&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;ul&gt;&amp;#13;
&lt;li&gt;pre-commit：提交前触发，比如检查提交信息是否规范，测试是否运行完毕，代码格式是否符合要求&lt;/li&gt;&amp;#13;
&lt;li&gt;post-commit：相反，这个是整个提交完成后触发，可以用来发通知&lt;/li&gt;&amp;#13;
&lt;/ul&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;服务端钩子&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;ul&gt;&amp;#13;
&lt;li&gt;pre-receive：服务端接收推送请求首先被调用的脚本，可以检测这些被推送的引用是否符合要求&lt;/li&gt;&amp;#13;
&lt;li&gt;update：与 pre-receive 相似，但是 pre-receive 只会运行一次，而 update 将会为每一个推送的分支分别运行一次&lt;/li&gt;&amp;#13;
&lt;li&gt;post-receive：整个推送过程完成后触发，可以用来发送通知、触发构建系统等&lt;/li&gt;&amp;#13;
&lt;/ul&gt;&amp;#13;
&lt;h3 id=&quot;objects-目录&quot;&gt;objects 目录&lt;/h3&gt;&amp;#13;
&lt;p&gt;如上一节我们提到的，Git 将所有接收到的内容生成对象文件存储在这个目录下，我们通过&lt;code&gt;git hash-object&lt;/code&gt;生成了一个对象并写入了 Git 仓库，这个对象的键值是&lt;code&gt;9f4d96d5b00d98959ea9960f069585ce42b1349a&lt;/code&gt;，这个时候我们来查看下 &lt;code&gt;objects&lt;/code&gt; 目录的结构：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker git:(master) ✗ git hash-object testfile -w&amp;#13;
&lt;span class=&quot;hljs-number&quot;&gt;9f&lt;/span&gt;4d96d5b00d98959ea9960f069585ce42b1349a&amp;#13;
➜  Zoker git:(master) ✗ tree .git/objects&amp;#13;
.git/objects&amp;#13;
├── &lt;span class=&quot;hljs-number&quot;&gt;9f&lt;/span&gt;&amp;#13;
│   └── &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;d96d5b00d98959ea9960f069585ce42b1349a&amp;#13;
├── info&amp;#13;
└── pack&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到&lt;code&gt;objects&lt;/code&gt;目录已经有了新的内容，多了一个&lt;code&gt;9f&lt;/code&gt;的文件夹以及其中的文件，这个文件就是插入到 Git 仓库的内容的对象文件，Git 取其键值的前两个字母作为文件夹，将后面的字母作为对象文件的文件名进行存储，这里（也就是&lt;code&gt;objects/[0-9a-f][0-9a-f]&lt;/code&gt;）所存储的对象我们一般称为&lt;code&gt;loose objects&lt;/code&gt;或者&lt;code&gt;unpacked objects&lt;/code&gt;，也就是松散对象。&lt;/p&gt;&amp;#13;
&lt;p&gt;除了对象的存储文件夹，细心的同学应该已经注意到了&lt;code&gt;objects/pack&lt;/code&gt;文件夹的存在，这里对应的是打包后的文件，为了节省空间和提升效率，当存储库中有过多的松散对象文件或者手动执行&lt;code&gt;git gc&lt;/code&gt;命令时，亦或是推送拉取的传输过程中，Git 都会将这些松散的对象文件打包成&lt;code&gt;pack&lt;/code&gt;文件来提升效率，这里存放的就是这些打包后的文件:&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  objects git:(master) git gc&amp;#13;
&lt;span class=&quot;hljs-keyword&quot;&gt;...&lt;/span&gt;&amp;#13;
Compressing objects: &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;% (&lt;span class=&quot;hljs-number&quot;&gt;75&lt;/span&gt;/&lt;span class=&quot;hljs-number&quot;&gt;75&lt;/span&gt;), done.&amp;#13;
&lt;span class=&quot;hljs-keyword&quot;&gt;...&lt;/span&gt;&amp;#13;
➜  objects git:(master) tree&amp;#13;
.&amp;#13;
├─ pack&amp;#13;
    ├── pack-fe24a22b0313342a6732cff4759bedb25c2ea55d.idx&amp;#13;
    └── pack-fe24a22b0313342a6732cff4759bedb25c2ea55d.pack&amp;#13;
└── &lt;span class=&quot;hljs-keyword&quot;&gt;...&lt;/span&gt;&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到&lt;code&gt;objects&lt;/code&gt;目录已经没有了松散对象，取而代之的是&lt;code&gt;pack&lt;/code&gt;目录的两个文件，一个是打包后的文件，另一个是对这个打包的内容进行索引的&lt;code&gt;idx&lt;/code&gt;文件，方便查询某个对象是否在这个对应的&lt;code&gt;pack&lt;/code&gt;包内。&lt;/p&gt;&amp;#13;
&lt;p&gt;需要注意的是，如果在刚刚我们手动创建的一个&lt;code&gt;blob&lt;/code&gt;对象的仓库进行 GC，将不会产生任何效果，因为这个时候整个 Git 仓库并没有任何一个引用指向这个对象，我们说这个对象是游离的，下面我们来介绍下存储引用的目录。&lt;/p&gt;&amp;#13;
&lt;h3 id=&quot;refs-目录&quot;&gt;refs 目录&lt;/h3&gt;&amp;#13;
&lt;p&gt;refs 目录存储我们的引用（references），引用可以看做是对一个版本号的别名，它存储的实际就是某一个 Commit 的 SHA 值，上面我们用来测试的仓库并没有任何一个提交，所以只有一个空的目录结构&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;└── refs&amp;#13;
    ├── heads&amp;#13;
    └── &lt;span class=&quot;hljs-keyword&quot;&gt;tags&lt;/span&gt;&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们随便找一个包含提交的仓库查看他的默认分支&lt;code&gt;master&lt;/code&gt;&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  .git &lt;span class=&quot;hljs-string&quot;&gt;git:&lt;/span&gt;(master) cat refs&lt;span class=&quot;hljs-regexp&quot;&gt;/heads/&lt;/span&gt;master&amp;#13;
&lt;span class=&quot;hljs-number&quot;&gt;87e917616712189&lt;/span&gt;ecac8c4890fe7d2dc2d554ac6&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到这个&lt;code&gt;master&lt;/code&gt;的引用只是存储了一个 Commit 的 SHA 值，好处当然就是我们不需要记着那长长的一串 SHA 值，我们只需要用&lt;code&gt;master&lt;/code&gt;这个别名就可以获取到这个版本。同样的 tags 目录下存储的就是我们的标签，与分支不同的是，标签的所记录的引用值一般是不会变化的，而分支可以我们的版本变化而变化。除此之外，还可能会看到&lt;code&gt;refs/remotes&lt;/code&gt; &lt;code&gt;refs/fetch&lt;/code&gt; 等目录，这些里面存储的是特定命名空间的引用。&lt;/p&gt;&amp;#13;
&lt;p&gt;还有一种情况，就是上面我们讲到的 GC 机制，如果一个仓库执行了 GC，那么不仅&lt;code&gt;objects&lt;/code&gt;目录下的松散对象会被打包，&lt;code&gt;refs&lt;/code&gt;下面的引用同样也会被打包，只不过它存放在裸仓库的根目录下&lt;code&gt;.git/packed-refs&lt;/code&gt;&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  .git&lt;span class=&quot;hljs-function&quot;&gt; git:(&lt;/span&gt;master&lt;span class=&quot;hljs-function&quot;&gt;)&lt;/span&gt; cat&lt;span class=&quot;hljs-instruction&quot;&gt; packed-refs&amp;#13;
&lt;/span&gt;&lt;span class=&quot;hljs-comment&quot;&gt;# pack-refs with: peeled fully-peeled sorted&lt;/span&gt;&amp;#13;
87e917616712189ecac8c4890fe7d2dc2d554ac6 refs/heads/master&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当我们需要访问分支&lt;code&gt;master&lt;/code&gt;的时候，Git 会首先去&lt;code&gt;refs/heads&lt;/code&gt;里面进行查找，如果找不到就会前往&lt;code&gt;.git/packed-refs&lt;/code&gt;进行查找，将所有的引用打包到一个文件无疑提升了不少效率。需要注意的是，如果我们在这个时候往&lt;code&gt;master&lt;/code&gt;分支上更新了一些提交，这个时候 Git 并不会直接修改 &lt;code&gt;.git/packed-refs&lt;/code&gt;文件，它会直接在&lt;code&gt;refs/heads/&lt;/code&gt;下重新创建一个&lt;code&gt;master&lt;/code&gt;引用，包含最新的提交的 SHA 值，根据刚刚我们介绍的 Git 的机制，Git 会首先在&lt;code&gt;refs/heads/&lt;/code&gt;查找，找不到才会去&lt;code&gt;.git/packed-refs&lt;/code&gt;查找。&lt;/p&gt;&amp;#13;
&lt;p&gt;那么引用里面存储的 Commit 的 这串 SHA 值到底是指向什么内容呢，我们可以使用之前查看&lt;code&gt;blob&lt;/code&gt;对象内容的&lt;code&gt;cat-file&lt;/code&gt;命令进行查看：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  .git git:(master) git cat-&lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt; -p &lt;span class=&quot;hljs-number&quot;&gt;87e917616712189&lt;/span&gt;ecac8c4890fe7d2dc2d554ac6&amp;#13;
tree aab1a9217aa6896ef46d3e1a90bc64e8178e1662 &lt;span class=&quot;hljs-comment&quot;&gt;// 指向的tree对象&lt;/span&gt;&amp;#13;
&lt;span class=&quot;hljs-keyword&quot;&gt;parent&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;d000309cb780fa27898b4d103afcfa95a8c04db &lt;span class=&quot;hljs-comment&quot;&gt;// 父提交&lt;/span&gt;&amp;#13;
author Zoker &amp;lt;kaixuanguiqu&lt;span class=&quot;hljs-variable&quot;&gt;@gmail&lt;/span&gt;.com&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1607958804&lt;/span&gt; +&lt;span class=&quot;hljs-number&quot;&gt;0800&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;// 作者信息&lt;/span&gt;&amp;#13;
committer Zoker &amp;lt;kaixuanguiqu&lt;span class=&quot;hljs-variable&quot;&gt;@gmail&lt;/span&gt;.com&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1607958804&lt;/span&gt; +&lt;span class=&quot;hljs-number&quot;&gt;0800&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;// 提交者信息&lt;/span&gt;&amp;#13;
&amp;#13;
test ssh &lt;span class=&quot;hljs-comment&quot;&gt;// 提交信息&lt;/span&gt;&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;它是一个&lt;code&gt;commit&lt;/code&gt;类型的对象，主要的属性是它指向的&lt;code&gt;tree&lt;/code&gt;对象，它的父提交（如果它是第一个提交，那么这里是0000000...），以及作者和提交信息。&lt;/p&gt;&amp;#13;
&lt;p&gt;那么&lt;code&gt;commit&lt;/code&gt;对象是什么？它所指向的&lt;code&gt;tree&lt;/code&gt;对象又是什么？与之前我们手工创建的&lt;code&gt;blob&lt;/code&gt;对象有什么差别？接下来我们来谈谈 Git 存储对象。&lt;/p&gt;&amp;#13;
&lt;h2 id=&quot;git-存储对象&quot;&gt;Git 存储对象&lt;/h2&gt;&amp;#13;
&lt;p&gt;在 Git 的世界里，一共有四种类型的存储对象： 文件（blob）、树（tree）、提交（commit）、标签（tag），这里我们主要探讨头三种类型，因为这三种是最基础的 Git 元数据，而标签对象只是一个包含了额外属性信息的 Tag 而已，也就是附注标签（annotated tag），这里不再过多的介绍。&lt;/p&gt;&amp;#13;
&lt;blockquote&gt;&amp;#13;
&lt;p&gt;轻量标签（lightweight）与附注标签（annotated）介绍：&lt;a href=&quot;https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE&quot;&gt;https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE&lt;/a&gt;&lt;/p&gt;&amp;#13;
&lt;/blockquote&gt;&amp;#13;
&lt;h3 id=&quot;blob-对象&quot;&gt;Blob 对象&lt;/h3&gt;&amp;#13;
&lt;p&gt;在介绍 Git 本质的时候，为了演示 Git 是一个基于内容寻址的 KV 数据库，我们向 Git 仓库插入了一个文件的内容：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ &lt;span class=&quot;hljs-keyword&quot;&gt;cat&lt;/span&gt; testfile&amp;#13;
Hello Git&amp;#13;
➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ git hash-object testfile -&lt;span class=&quot;hljs-keyword&quot;&gt;w&lt;/span&gt;&amp;#13;
&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;f4d96d5b00d98959ea9960f069585ce42b1349a&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个 Key 为&lt;code&gt;9f4d96d5b00d98959ea9960f069585ce42b1349a&lt;/code&gt;的 Git 对象实际上就是一个 Blob 对象，他存储了这个&lt;code&gt;testfile&lt;/code&gt;文件的值，我们可以使用&lt;code&gt;cat-file&lt;/code&gt;命令来进行查看：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ git &lt;span class=&quot;hljs-keyword&quot;&gt;cat&lt;/span&gt;-&lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt; -&lt;span class=&quot;hljs-keyword&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;f4d96d5b00d98959ea9960f069585ce42b1349a&amp;#13;
Hello Git&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;每一次我们修改文件，Git 都会完整的保存一份这个文件的快照而非记录差异，所以如果我们修改了&lt;code&gt;testfile&lt;/code&gt;文件的内容再次存入到 Git 仓库中的时候，Git 会基于当前最新的内容来生成它的 Key，需要注意的是当内容不变的时候，它的 Key 值是固定的，毕竟我们前面也说了，Git 是一个基于内容寻址的 KV 数据库。&lt;/p&gt;&amp;#13;
&lt;p&gt;另外，这里的 Blob 对象存储的是文本内容，它还可以是二进制内容，但是这里并不建议使用 Git 管理二进制文件的版本。我们 Gitee 平台在日常运营过程中遇到最多的问题就是用户仓库过大，这种情况一般都是用户提交了大的二进制文件导致的，因为每次文件的变更记录的是快照，所以这个二进制文件如果变更频繁，它占用的空间是倍增的。而且对于文本内容的 Blob，Git 在 GC 的过程中会只保存两次提交之间的文件差异，是可以达到节省空间的效果的，但是对于二进制内容的 Blob 是无法像文本内容的 Blob 那样处理的，所以尽量不要把频繁变动的二进制内容存储到 Git 仓库，可以使用 LFS 的方式进行存储。如果已经存在了大量的二进制文件，可以使用&lt;code&gt;filter-branch&lt;/code&gt;进行瘦身，新加入的同事在首次 Clone 仓库的时候肯定会感激你的。&lt;/p&gt;&amp;#13;
&lt;blockquote&gt;&amp;#13;
&lt;p&gt;LFS 的使用：&lt;a href=&quot;https://gitee.com/help/articles/4235&quot;&gt;https://gitee.com/help/articles/4235&lt;/a&gt;&amp;#13;
大仓库的瘦身：&lt;a href=&quot;https://gitee.com/help/articles/4232&quot;&gt;https://gitee.com/help/articles/4232&lt;/a&gt;&amp;#13;
filter-branch：&lt;a href=&quot;https://github.com/git/git/blob/master/Documentation/git-filter-branch.txt&quot;&gt;https://github.com/git/git/blob/master/Documentation/git-filter-branch.txt&lt;/a&gt;&lt;/p&gt;&amp;#13;
&lt;/blockquote&gt;&amp;#13;
&lt;p&gt;到了这里是不是觉得哪里不对劲？没错，这个 Blob 对象只存储了这个文件的内容，却没有记录文件名，那我们该怎么知道这个内容是属于哪个文件的啊？答案是 Git 的另外一个重要的对象：Tree 对象。&lt;/p&gt;&amp;#13;
&lt;h3 id=&quot;tree-对象&quot;&gt;Tree 对象&lt;/h3&gt;&amp;#13;
&lt;p&gt;在 Git 中，Tree 对象主要的作用是将多个 Blob 或者 子 Tree 对象组织到一起，所有的内容都是通过 Tree 和 Blob 类型的对象进行存储的。一个 Tree 对象包含了一个或者多个 Tree Entry（树对象记录），每个树对象记录都包含了一个指向 Blob 或者子 Tree SHA 值的指针，还有它们对应的文件名等信息，其实就可以理解为索引文件系统中的&lt;code&gt;inode&lt;/code&gt;和&lt;code&gt;block&lt;/code&gt;的关系，图示一个 Tree 对象的话，如下图：&amp;#13;
&lt;img src=&quot;https://zoker.io/uploads/images/2021/0221/232855_c0f2e4e8.png&quot; alt=&quot;输入图片说明&quot; title=&quot;在这里输入图片标题&quot;/&gt;&amp;#13;
这个 Tree 对象对应的目录结构就是下面这样的：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;.&amp;#13;
├── LICENSE&amp;#13;
├── readme&lt;span class=&quot;hljs-class&quot;&gt;.md&lt;/span&gt;&amp;#13;
└── src&amp;#13;
    ├── libssl&lt;span class=&quot;hljs-class&quot;&gt;.so&lt;/span&gt;&amp;#13;
    └── logo.png&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过这种方式，我们可以像组织 Linux 下目录的方式一样来结构化的存储我们仓库的内容，把 Tree 看作目录结构，把 Blob 看作具体的文件内容。&lt;/p&gt;&amp;#13;
&lt;p&gt;那么该如何创建一个 Tree 对象呢？在 Git 中是根据暂存区的状态来创建对应的 Tree 对象的，这里的暂存区其实就是我们日常在使用 Git 的过程中所理解的暂存区（Staged），一般我们使用&lt;code&gt;git add&lt;/code&gt;命令将某些文件添加到暂存区待提交。在没有任何提交的空仓库里，这个暂存区的状态就是你通过&lt;code&gt;git add&lt;/code&gt;所添加的那些文件，如：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker git:(master) ✗ git status&amp;#13;
&lt;span class=&quot;hljs-keyword&quot;&gt;On&lt;/span&gt; branch master&amp;#13;
&amp;#13;
No commits yet&amp;#13;
&amp;#13;
Changes &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; be committed:&amp;#13;
  (&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;git rm --cached &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; unstage)&amp;#13;
    &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt;:   LICENSE&amp;#13;
    &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt;:   readme.md&amp;#13;
&amp;#13;
Untracked files:&amp;#13;
  (&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;git add &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; include &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; what will be committed)&amp;#13;
    src/&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这里当前的暂存区状态就是在根目录有两个文件，暂存区的状态是保存在&lt;code&gt;.git/index&lt;/code&gt;文件的，我们使用&lt;code&gt;file&lt;/code&gt;命令来看看它是什么：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker git:(master) ✗ &lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt; .git/&lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt;&amp;#13;
.git/&lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt;: Git &lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt;, version &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; entries&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以发现在&lt;code&gt;index&lt;/code&gt;文件中有两个&lt;code&gt;entry&lt;/code&gt;，也就是根目录的两个文件&lt;code&gt;LICENSE&lt;/code&gt;和&lt;code&gt;readme.md&lt;/code&gt;。对于已经有提交的仓库，如果暂存区没有任何内容，那么这个&lt;code&gt;index&lt;/code&gt;表示的就是当前版本的目录树状态，如果修改或者增删了文件，并且加入了暂存区，那么&lt;code&gt;index&lt;/code&gt;就会发生改变，将相关文件的指针指向该文件新的 Blob 对象的 SHA 值。&lt;/p&gt;&amp;#13;
&lt;p&gt;所以如果想要创建一个 Tree 对象，我们需要往暂存区放点东西，除了使用&lt;code&gt;git add&lt;/code&gt;，我们还可以使用底层命令&lt;code&gt;update-index&lt;/code&gt;来创建一个暂存区。接下来我们根据上面已经创建好的&lt;code&gt;testfile&lt;/code&gt;文件来创建一个树对象，首先就是将文件&lt;code&gt;testfile&lt;/code&gt;加入到暂存区：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker git:(master) ✗ git &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;update&lt;/span&gt;-&lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;--add testfile // 与 git add testfile 一样&lt;/span&gt;&amp;#13;
➜  Zoker git:(&lt;span class=&quot;hljs-keyword&quot;&gt;master&lt;/span&gt;) ✗ git &lt;span class=&quot;hljs-keyword&quot;&gt;status&lt;/span&gt;&amp;#13;
&lt;span class=&quot;hljs-keyword&quot;&gt;On&lt;/span&gt; branch &lt;span class=&quot;hljs-keyword&quot;&gt;master&lt;/span&gt;&amp;#13;
&amp;#13;
&lt;span class=&quot;hljs-keyword&quot;&gt;No&lt;/span&gt; commits yet&amp;#13;
&amp;#13;
Changes &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; be committed:&amp;#13;
  (&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;git rm --cached &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; unstage)&amp;#13;
    new file:   testfile&lt;/span&gt;&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个过程 Git 主要是先把&lt;code&gt;testfile&lt;/code&gt;的内容以 Blob 的形式插入到 Git 仓库，然后将返回的这个 Blob 的 SHA 值记录到&lt;code&gt;index&lt;/code&gt;中，告诉暂存区目前这个文件的内容是哪个。&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ tree .git/objects&amp;#13;
.git/objects&amp;#13;
├── &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;f&lt;/span&gt;&amp;#13;
│   └── &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;d96d5b00d98959ea9960f069585ce42b1349a&amp;#13;
├── info&amp;#13;
└── pack&amp;#13;
&amp;#13;
&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; directories, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt;&amp;#13;
➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ git &lt;span class=&quot;hljs-keyword&quot;&gt;cat&lt;/span&gt;-&lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt; -&lt;span class=&quot;hljs-keyword&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;f4d96d5b00d98959ea9960f069585ce42b1349a&amp;#13;
Hello Git&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Git 在执行&lt;code&gt;update-index&lt;/code&gt;命令的时候，把指定文件的内容存储为 Blob 对象，并且记录在&lt;code&gt;index&lt;/code&gt;文件状态内。由于在之前我们已经通过&lt;code&gt;git hash-object&lt;/code&gt;命令将这个文件的内容插入过了，并且我们可以发现因为内容不变，所以生成的这个 Blob 对象的 SHA 值也是一致的，如果像我们这样已经做过插入的动作，下面的命令是等效的：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;git &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;update&lt;/span&gt;-&lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;--add --cacheinfo 9f4d96d5b00d98959ea9960f069585ce42b1349a testfile&lt;/span&gt;&lt;/span&gt;&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个命令其实就是把之前已经生成的 Blob 对象放到暂存区，并且指定它的文件名字是&lt;code&gt;testfile&lt;/code&gt;。由于我们的暂存区已经有一个文件&lt;code&gt;testfile&lt;/code&gt;，所以我接下来我们可以使用&lt;code&gt;git write-tree&lt;/code&gt;命令来基于当前暂存区的状态来创建一个 Tree 对象了：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ git &lt;span class=&quot;hljs-keyword&quot;&gt;write&lt;/span&gt;-tree&amp;#13;
aa406ee8804971cf8edfd8c89ff431b0462e250c&amp;#13;
➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ tree .git/objects&amp;#13;
.git/objects&amp;#13;
├── &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;f&lt;/span&gt;&amp;#13;
│   └── &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;d96d5b00d98959ea9960f069585ce42b1349a&amp;#13;
├── aa&amp;#13;
│   └── &lt;span class=&quot;hljs-number&quot;&gt;406&lt;/span&gt;ee8804971cf8edfd8c89ff431b0462e250c&amp;#13;
├── info&amp;#13;
└── pack&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行完命令后，Git 会基于当前暂存区的状态生成一个 SHA 值为&lt;code&gt;aa406ee8804971cf8edfd8c89ff431b0462e250c&lt;/code&gt;的 Tree 对象，并把这个 Tree 对象像 Blob 对象一样存储在&lt;code&gt;.git/objects&lt;/code&gt;目录下。&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ git &lt;span class=&quot;hljs-keyword&quot;&gt;cat&lt;/span&gt;-&lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt; -&lt;span class=&quot;hljs-keyword&quot;&gt;p&lt;/span&gt; aa406ee8804971cf8edfd8c89ff431b0462e250c&amp;#13;
&lt;span class=&quot;hljs-number&quot;&gt;100644&lt;/span&gt; blob &lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;f4d96d5b00d98959ea9960f069585ce42b1349a    testfile&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用&lt;code&gt;cat-file&lt;/code&gt;命令查看这个 Tree 对象，可以看到这个对象下只有一个文件，名为&lt;code&gt;testfile&lt;/code&gt;&amp;#13;
&lt;img src=&quot;https://zoker.io/uploads/images/2021/0221/232928_772a3f62.png&quot; alt=&quot;输入图片说明&quot; title=&quot;在这里输入图片标题&quot;/&gt;&amp;#13;
我们继续创建第二个 Tree 对象，我们需要第二个 Tree 对象下有修改后的&lt;code&gt;testfile&lt;/code&gt;文件，有新增的 &lt;code&gt;testfile2&lt;/code&gt;文件，并且需要把第一个 Tree 对象作为 第二个 Tree 对象的&lt;code&gt;duplicate&lt;/code&gt;目录。首先我们先把修改后的&lt;code&gt;testfile&lt;/code&gt;和新增的&lt;code&gt;testfile2&lt;/code&gt;文件加入到暂存区：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker git:(master) ✗ git &lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;update&lt;/span&gt;-&lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt; testfile&amp;#13;
➜  Zoker git:(&lt;span class=&quot;hljs-keyword&quot;&gt;master&lt;/span&gt;) ✗ git &lt;span class=&quot;hljs-keyword&quot;&gt;update&lt;/span&gt;-&lt;span class=&quot;hljs-keyword&quot;&gt;index&lt;/span&gt; &lt;span class=&quot;hljs-comment&quot;&gt;--add testfile2&lt;/span&gt;&amp;#13;
➜  Zoker git:(&lt;span class=&quot;hljs-keyword&quot;&gt;master&lt;/span&gt;) ✗ git &lt;span class=&quot;hljs-keyword&quot;&gt;status&lt;/span&gt;&amp;#13;
&lt;span class=&quot;hljs-keyword&quot;&gt;On&lt;/span&gt; branch &lt;span class=&quot;hljs-keyword&quot;&gt;master&lt;/span&gt;&amp;#13;
&amp;#13;
&lt;span class=&quot;hljs-keyword&quot;&gt;No&lt;/span&gt; commits yet&amp;#13;
&amp;#13;
Changes &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; be committed:&amp;#13;
  (&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;git rm --cached &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; unstage)&amp;#13;
    new file:   testfile&amp;#13;
    new file:   testfile2&lt;/span&gt;&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;紧接着我们需要把第一个 Tree 对象挂到&lt;code&gt;duplicate&lt;/code&gt;目录下，我们可以使用&lt;code&gt;read-tree&lt;/code&gt;命令来实现：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker git:(master) ✗ git read-tree &lt;span class=&quot;hljs-comment&quot;&gt;--prefix=duplicate aa406ee8804971cf8edfd8c89ff431b0462e250c &lt;/span&gt;&amp;#13;
➜  Zoker git:(master) ✗ git status&amp;#13;
&lt;span class=&quot;hljs-keyword&quot;&gt;On&lt;/span&gt; branch master&amp;#13;
&amp;#13;
No commits yet&amp;#13;
&amp;#13;
Changes &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; be committed:&amp;#13;
  (&lt;span class=&quot;hljs-keyword&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;git rm --cached &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; unstage)&amp;#13;
    &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt;:   duplicate/testfile&amp;#13;
    &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt;:   testfile&amp;#13;
    &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt;:   testfile2&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后我们执行&lt;code&gt;write-tree&lt;/code&gt;并通过&lt;code&gt;cat-file&lt;/code&gt;查看第二个 Tree 对象：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ git &lt;span class=&quot;hljs-keyword&quot;&gt;write&lt;/span&gt;-tree&amp;#13;
&lt;span class=&quot;hljs-number&quot;&gt;64&lt;/span&gt;d62cef754e6cc995ed8d34f0d0e233e1dfd5d1&amp;#13;
➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ git &lt;span class=&quot;hljs-keyword&quot;&gt;cat&lt;/span&gt;-&lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt; -&lt;span class=&quot;hljs-keyword&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;64&lt;/span&gt;d62cef754e6cc995ed8d34f0d0e233e1dfd5d1&amp;#13;
&lt;span class=&quot;hljs-number&quot;&gt;040000&lt;/span&gt; tree aa406ee8804971cf8edfd8c89ff431b0462e250c    duplicate&amp;#13;
&lt;span class=&quot;hljs-number&quot;&gt;100644&lt;/span&gt; blob &lt;span class=&quot;hljs-number&quot;&gt;106287&lt;/span&gt;c47fd25ad9a0874670a0d5c6eacf1bfe4e    testfile&amp;#13;
&lt;span class=&quot;hljs-number&quot;&gt;100644&lt;/span&gt; blob &lt;span class=&quot;hljs-number&quot;&gt;098&lt;/span&gt;ffe6f84559f4899edf119c25d276dc70607cf    testfile2&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;成功完成了，我们不仅修改了&lt;code&gt;testfile&lt;/code&gt;的文件内容，还新增了一个&lt;code&gt;testfile2&lt;/code&gt;文件，并且还把第一个 Tree 对象当作第二个 Tree 对象的&lt;code&gt;duplicate&lt;/code&gt;目录了，这个时候 Tree 对象看起来应该是这样的：&amp;#13;
&lt;img src=&quot;https://zoker.io/uploads/images/2021/0221/232948_54b120f4.png&quot; alt=&quot;输入图片说明&quot; title=&quot;在这里输入图片标题&quot;/&gt;&amp;#13;
至此，我们知道了如何手动创建一个 Tree 对象，但是后面如果我需要这两个不同的 Tree 的快照该怎么办？总不能都记住这三个 Tree 对象的 SHA 值吧？没错，记起来费老大劲了，关键是还不知道是谁在什么时间为了什么而创建的这个快照，而 Commit 对象（提交对象）就能够帮我们解决这个问题。&lt;/p&gt;&amp;#13;
&lt;h3 id=&quot;commit-对象&quot;&gt;Commit 对象&lt;/h3&gt;&amp;#13;
&lt;p&gt;Commit 对象主要是为了记录快照的一些附加信息，并且维护快照之间的线性关系。我们可以通过&lt;code&gt;git commit-tree&lt;/code&gt;命令来创建一个提交，这个命令看字面意思就知道，它是用来将 Tree 对象提交为一个 Commit 对象的命令：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker git:(master) ✗ git commit-tree -h&amp;#13;
usage: git commit-tree [(-p &amp;lt;parent&amp;gt;)&lt;span class=&quot;hljs-keyword&quot;&gt;...&lt;/span&gt;] [-S[&amp;lt;keyid&amp;gt;]] [(-m &amp;lt;message&amp;gt;)&lt;span class=&quot;hljs-keyword&quot;&gt;...&lt;/span&gt;] [(-&lt;span class=&quot;hljs-literal&quot;&gt;F&lt;/span&gt; &amp;lt;file&amp;gt;)&lt;span class=&quot;hljs-keyword&quot;&gt;...&lt;/span&gt;] &amp;lt;tree&amp;gt;&amp;#13;
&amp;#13;
    -p &amp;lt;parent&amp;gt;           id of a parent commit object&amp;#13;
    -m &amp;lt;message&amp;gt;          commit message&amp;#13;
    -&lt;span class=&quot;hljs-literal&quot;&gt;F&lt;/span&gt; &amp;lt;file&amp;gt;             read commit log message from file&amp;#13;
    -S, --gpg-sign[=&amp;lt;key-id&amp;gt;]&amp;#13;
                          GPG sign commit&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;关键的两个参数是&lt;code&gt;-p&lt;/code&gt;和&lt;code&gt;-m&lt;/code&gt;，&lt;code&gt;-p&lt;/code&gt;是指定这个提交的父提交，如果是初始的第一个提交，那这里可以忽略；&lt;code&gt;-m&lt;/code&gt;则是指定本次提交的信息，主要是用来描述提交的原因。我们来把第一个 Tree 对象作为我们的初始提交：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker git:&lt;span class=&quot;hljs-comment&quot;&gt;(master)&lt;/span&gt; ✗ git commit-tree -m &lt;span class=&quot;hljs-string&quot;&gt;&quot;init commit&quot;&lt;/span&gt; aa&lt;span class=&quot;hljs-number&quot;&gt;406&lt;/span&gt;ee&lt;span class=&quot;hljs-number&quot;&gt;8804971&lt;/span&gt;cf&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;edfd&lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt;c&lt;span class=&quot;hljs-number&quot;&gt;89&lt;/span&gt;ff&lt;span class=&quot;hljs-number&quot;&gt;431&lt;/span&gt;b&lt;span class=&quot;hljs-number&quot;&gt;0462&lt;/span&gt;e&lt;span class=&quot;hljs-number&quot;&gt;250&lt;/span&gt;c&amp;#13;
&lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;ae&lt;span class=&quot;hljs-number&quot;&gt;181&lt;/span&gt;bd&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;c&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;e&lt;span class=&quot;hljs-number&quot;&gt;703&lt;/span&gt;df&lt;span class=&quot;hljs-number&quot;&gt;7851&lt;/span&gt;c&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;f&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;ea&lt;span class=&quot;hljs-number&quot;&gt;01&lt;/span&gt;d&lt;span class=&quot;hljs-number&quot;&gt;9&lt;/span&gt;e&lt;span class=&quot;hljs-number&quot;&gt;33&lt;/span&gt;a&lt;span class=&quot;hljs-number&quot;&gt;675&lt;/span&gt;b&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用&lt;code&gt;cat-file&lt;/code&gt;来查看这个提交：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;tree&lt;/span&gt; aa406ee8804971cf8edfd8c89ff431b0462e250c&amp;#13;
author Zoker &amp;lt;kaixuanguiqu&lt;span class=&quot;hljs-variable&quot;&gt;@gmail&lt;/span&gt;.com&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1613225370&lt;/span&gt; +&lt;span class=&quot;hljs-number&quot;&gt;0800&lt;/span&gt;&amp;#13;
committer Zoker &amp;lt;kaixuanguiqu&lt;span class=&quot;hljs-variable&quot;&gt;@gmail&lt;/span&gt;.com&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1613225370&lt;/span&gt; +&lt;span class=&quot;hljs-number&quot;&gt;0800&lt;/span&gt;&amp;#13;
&amp;#13;
init commit&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Commit 所存储的内容是一个 Tree 对象，并且记录了提交者、提交时间以及提交信息。我们基于这个 Commit 将第二个 Tree 对象作为引用：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ git commit-tree -&lt;span class=&quot;hljs-keyword&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;ae181bd -&lt;span class=&quot;hljs-keyword&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;add dir&quot;&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;64&lt;/span&gt;d62cef754e6cc995ed8d34f0d0e233e1dfd5d1&amp;#13;
de96a74725dd72c10693c4896cb74e8967859e58&amp;#13;
➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ git &lt;span class=&quot;hljs-keyword&quot;&gt;cat&lt;/span&gt;-&lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt; -&lt;span class=&quot;hljs-keyword&quot;&gt;p&lt;/span&gt; de96a74725dd72c10693c4896cb74e8967859e58&amp;#13;
tree &lt;span class=&quot;hljs-number&quot;&gt;64&lt;/span&gt;d62cef754e6cc995ed8d34f0d0e233e1dfd5d1&amp;#13;
parent &lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;ae181bd6c3e703df7851c0f7ea01d9e33a675b&amp;#13;
author Zoker &amp;lt;kaixuanguiqu@gmail.&lt;span class=&quot;hljs-keyword&quot;&gt;com&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1613225850&lt;/span&gt; +&lt;span class=&quot;hljs-number&quot;&gt;0800&lt;/span&gt;&amp;#13;
committer Zoker &amp;lt;kaixuanguiqu@gmail.&lt;span class=&quot;hljs-keyword&quot;&gt;com&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1613225850&lt;/span&gt; +&lt;span class=&quot;hljs-number&quot;&gt;0800&lt;/span&gt;&amp;#13;
&amp;#13;
&lt;span class=&quot;hljs-built_in&quot;&gt;add&lt;/span&gt; dir&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以使用&lt;code&gt;git log&lt;/code&gt;来查看这两个提交，这里添加&lt;code&gt;--stat&lt;/code&gt;参数查看文件变更记录：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-operator&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;commit&lt;/span&gt; de96a74725dd72c10693c4896cb74e8967859e58&amp;#13;
Author: Zoker &amp;lt;kaixuanguiqu@gmail.com&amp;gt;&amp;#13;
&lt;span class=&quot;hljs-built_in&quot;&gt;Date&lt;/span&gt;:   Sun Feb &lt;span class=&quot;hljs-number&quot;&gt;13&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2021&lt;/span&gt; +&lt;span class=&quot;hljs-number&quot;&gt;0800&lt;/span&gt;&amp;#13;
&amp;#13;
    &lt;span class=&quot;hljs-keyword&quot;&gt;add&lt;/span&gt; dir&amp;#13;
&amp;#13;
 duplicate/testfile | &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; +&amp;#13;
 testfile           | &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; +-&amp;#13;
 testfile2          | &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; +&amp;#13;
 &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; files &lt;span class=&quot;hljs-keyword&quot;&gt;changed&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; insertions(+), &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; deletion(-)&amp;#13;
&amp;#13;
&lt;span class=&quot;hljs-keyword&quot;&gt;commit&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;17&lt;/span&gt;ae181bd6c3e703df7851c0f7ea01d9e33a675b&amp;#13;
Author: Zoker &amp;lt;kaixuanguiqu@gmail.com&amp;gt;&amp;#13;
&lt;span class=&quot;hljs-built_in&quot;&gt;Date&lt;/span&gt;:   Sun Feb &lt;span class=&quot;hljs-number&quot;&gt;13&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;22&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;09&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;30&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;2021&lt;/span&gt; +&lt;span class=&quot;hljs-number&quot;&gt;0800&lt;/span&gt;&amp;#13;
&amp;#13;
    init &lt;span class=&quot;hljs-keyword&quot;&gt;commit&lt;/span&gt;&amp;#13;
&amp;#13;
 testfile | &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; +&amp;#13;
 &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; file &lt;span class=&quot;hljs-keyword&quot;&gt;changed&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; insertion(+)&lt;/span&gt;&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个时候整个对象的结构如下图：&amp;#13;
&lt;img src=&quot;https://zoker.io/uploads/images/2021/0221/233021_a6ed134f.png&quot; alt=&quot;输入图片说明&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&amp;#13;
&lt;h3 id=&quot;练习：使用底层命令创建一个提交&quot;&gt;练习：使用底层命令创建一个提交&lt;/h3&gt;&amp;#13;
&lt;p&gt;仅使用我们上面提到的&lt;code&gt;hash-object&lt;/code&gt; &lt;code&gt;write-tree&lt;/code&gt; &lt;code&gt;read-tree&lt;/code&gt; &lt;code&gt;commit-tree&lt;/code&gt;等底层命令来创建一个提交，思考哪些过程是与&lt;code&gt;git add&lt;/code&gt; &lt;code&gt;git commit&lt;/code&gt;等价的。&lt;/p&gt;&amp;#13;
&lt;h3 id=&quot;对象存储方式&quot;&gt;对象存储方式&lt;/h3&gt;&amp;#13;
&lt;p&gt;我们通过前面的介绍，知道了 Git 是将数据以不同的对象类型归纳，并且根据内容计算出一个 SHA 值用来作为寻址，那么到底是如何计算的呢？以 Blob 对象为例，Git 主要是做了如下几步：&lt;/p&gt;&amp;#13;
&lt;ol&gt;&amp;#13;
&lt;li&gt;识别对象的类型，构造头部信息，以&lt;code&gt;类型+内容字节数+空字节&lt;/code&gt;作为头部信息如&lt;code&gt;blob 151\u0000&lt;/code&gt;&lt;/li&gt;&amp;#13;
&lt;li&gt;将头部信息与内容拼接，并且计算 SHA-1 校验和&lt;/li&gt;&amp;#13;
&lt;li&gt;通过 zlib 压缩内容&lt;/li&gt;&amp;#13;
&lt;li&gt;通过 SHA 值将其内容放到对应的&lt;code&gt;objects&lt;/code&gt;目录&lt;/li&gt;&amp;#13;
&lt;/ol&gt;&amp;#13;
&lt;p&gt;整个过程就做了这些事情，Tree 对象和 Commit 对象也差不多，只是头部类型有所差异而已，这里不再赘述，《Pro Git 2》在 Git 内部原理章节中有介绍如何使用 Ruby 来实现同等的逻辑，感兴趣的可以自行翻阅。&lt;/p&gt;&amp;#13;
&lt;blockquote&gt;&amp;#13;
&lt;p&gt;Git-内部原理：&lt;a href=&quot;https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1&quot;&gt;https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1&lt;/a&gt;&lt;/p&gt;&amp;#13;
&lt;/blockquote&gt;&amp;#13;
&lt;h2 id=&quot;git-引用&quot;&gt;Git 引用&lt;/h2&gt;&amp;#13;
&lt;p&gt;我们在上面通过&lt;code&gt;git log --stat 17ae181b&lt;/code&gt;能够查看第一个版本的相关信息，并且可以通过这串 SHA 值拿到这个快照的内容，但是还是挺麻烦的，因为我们要记住一串毫无意义的字符串，这个时候 Git 的引用就派上用场了，在 Git 目录结构章节我们已经介绍了&lt;code&gt;refs&lt;/code&gt;目录，我们知道在引用中存储的就是 Commit 对象的键值，也就是这个对象的 SHA 值，既然如此，我们就给我们当前的版本起一个有意义的名字，一般我们会拿&lt;code&gt;master&lt;/code&gt;作为默认分支引用：&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ &lt;span class=&quot;hljs-keyword&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;17ae181bd6c3e703df7851c0f7ea01d9e33a675b&quot;&lt;/span&gt; &amp;gt;&amp;gt; .git/refs/heads/master&amp;#13;
➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ tree .git/refs&amp;#13;
.git/refs&amp;#13;
├── heads&amp;#13;
│   └── master&amp;#13;
└── &lt;span class=&quot;hljs-keyword&quot;&gt;tags&lt;/span&gt;&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个时候，&lt;code&gt;master&lt;/code&gt;里面存储了我们的第一个 Commit 的 SHA 值，我们可以使用&lt;code&gt;master&lt;/code&gt;来代替&lt;code&gt;17ae181b&lt;/code&gt;这串毫无意义的字符串了&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  Zoker gi&lt;span class=&quot;hljs-variable&quot;&gt;t:&lt;/span&gt;(master) ✗ git &lt;span class=&quot;hljs-keyword&quot;&gt;cat&lt;/span&gt;-&lt;span class=&quot;hljs-keyword&quot;&gt;file&lt;/span&gt; -&lt;span class=&quot;hljs-keyword&quot;&gt;p&lt;/span&gt; master&amp;#13;
tree aa406ee8804971cf8edfd8c89ff431b0462e250c&amp;#13;
author Zoker &amp;lt;kaixuanguiqu@gmail.&lt;span class=&quot;hljs-keyword&quot;&gt;com&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1613916447&lt;/span&gt; +&lt;span class=&quot;hljs-number&quot;&gt;0800&lt;/span&gt;&amp;#13;
committer Zoker &amp;lt;kaixuanguiqu@gmail.&lt;span class=&quot;hljs-keyword&quot;&gt;com&lt;/span&gt;&amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;1613916447&lt;/span&gt; +&lt;span class=&quot;hljs-number&quot;&gt;0800&lt;/span&gt;&amp;#13;
&amp;#13;
init commit&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是，这个并不是我们最新的版本，我们最新的版本是第二个提交&lt;code&gt;de96a74725dd72c10693c4896cb74e8967859e58&lt;/code&gt;，同样的，我们可以把&lt;code&gt;refs/heads/master&lt;/code&gt;的内容更改为这个提交的 SHA 值，但是这里我们使用一个底层命令来完成&lt;/p&gt;&amp;#13;
&lt;pre&gt;&lt;code class=&quot;hljs&quot;&gt;➜  &lt;span class=&quot;hljs-type&quot;&gt;Zoker&lt;/span&gt; git:(master) ✗ git update-&lt;span class=&quot;hljs-keyword&quot;&gt;ref&lt;/span&gt; refs/heads/master de96a74725dd72c10693c4896cb74e8967859e58&amp;#13;
➜  &lt;span class=&quot;hljs-type&quot;&gt;Zoker&lt;/span&gt; git:(master) ✗ cat .git/refs/heads/master&amp;#13;
de96a74725dd72c10693c4896cb74e8967859e58&amp;#13;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个时候，分支&lt;code&gt;master&lt;/code&gt;就指向了我们最新的版本&amp;#13;
&lt;img src=&quot;https://zoker.io/uploads/images/2021/0221/233032_874f10d4.png&quot; alt=&quot;输入图片说明&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&amp;#13;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;&amp;#13;
&lt;p&gt;以上主要讨论了 Git 基础的存储原理以及一些实现，还有一些如 Pack 的打包、传输协商机制以及存储格式等，限于篇幅并没有说到，后面根据一些场景再另行讨论。&lt;/p&gt;&amp;#13;
&lt;blockquote&gt;&amp;#13;
&lt;p&gt;永远不要停下提升的脚步，想想还贷的压力、小孩的压力、渐渐老去的父母的压力，你是想要那种滥竽充数的心惊胆战，还是要怀才不遇的怆然涕下？&lt;/p&gt;&amp;#13;
&lt;/blockquote&gt;&amp;#13;
&lt;p&gt;&lt;img src=&quot;https://zoker.io/uploads/images/2021/0125/003521_d71b3ff1.png&quot; alt=&quot;输入图片说明&quot; title=&quot;在这里输入图片标题&quot;/&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;转载请保留出处：微信公众号「Zoker 随笔」（zokersay）&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9a908d85c771cf68a7c5f0e7df02613f</guid>
<title>[推荐] 8 张图带你了解大型应用架构演进历程</title>
<link>https://toutiao.io/k/xuv7rlf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;几乎所有的大型应用都是从一个小应用开始的，好的互联网产品是慢慢运营出来的，不是一开始就开发好的，所以本篇我们来聊聊应用架构的演进历程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何打造一个高可用，高性能，易扩展的应用？首先我们了解一下大型应用的特点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;高可用：系统需要不间断的提供服务，不能出现单点故障&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高并发：在大流量的冲击下，系统依然稳定提供服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;大数据：应用每天都会产生大量的数据，需要存储和管理好这些数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最简单的架构&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚开始应用没有太多访问量，所以只需要一台服务器，这时候的架构如下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.49375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zGicf6vk3kaemSzAD7bHhK4yQnhRK7RWJs1RJBAsCylY5WYZqKUibUtt1IHr52b7QqeQ7gEsJxiaJSKTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;最简单的架构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用程序、文件、数据库往往都部署在一台服务器上。应用程序可以采用Java开发，部署在Tomcat服务器上，数据库可以使用开源的MySQL&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;应用与数据服务分隔&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着应用的业务越来越复杂，应用访问量越来越大，导致性能越来越差，存储空间严重不足，这时候我们考虑把服务增加到三台（能通过加机器解决的问题都不是问题）；分离出应用服务器、数据库服务器、文件服务器。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;应用服务器需要处理大量的访问，所以需要性能更好的CPU&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据库服务器需要存储大量的数据以及快速的检索，所以需磁盘的检索速度较快以及存储空间大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;文件服务器需要存储上传的文件，需要更大的磁盘；现在通常情况下会选择第三方的存储服务&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.465&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zGicf6vk3kaemSzAD7bHhK4yQjQYNRwSLTtGmJU0mqtSiciae0QrC31XdGAtIyNtXeKDq78A5ibKGej99w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;应用与数据访问服务分隔&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据每个服务器对应的场景，配置服务器后应用的性能能够大大提高，更好的支持业务的发展。但是随之业务的发展，访问量的增大，这种架构又将再次面临挑战，应用服务器处理能力下降，存储空间不足&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;应用服务器集群&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发，大流量的情况下，一台服务器是肯定处理不过来的，这个时候增加服务器，部署集群提供服务，来分担每台服务器的压力。部署集群的另一个好处是可伸缩性，比如当遇到了双11大流量的场景下，可以增加服务器分摊流量，等双11过后，减少服务器节约成本。架构如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.42125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zGicf6vk3kaemSzAD7bHhK4yQWicNMqzicoMC1HHaxaz8hU18d75CRCibvX9V1pg3f7UuuicNywX80licbpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;应用服务器集群&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果应用服务器是Tomcat，那么可以部署一个Tomcat的集群，外部在部署一个负载均衡器，可以采用随机、轮询或者一致性哈希算法达将用户的请求分发到不同应用服务集群；通常选择的免费的负载均衡是nginx。在这种架构下，应用服务器的负载将不会是整个应用的瓶颈点；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然应用程序的处理速度在这种架构下提升了许多，但是又会暴露一个问题，数据库的压力大大增大，导致访问响应延迟，影响整个应用的性能。这种架构还有个问题，通常应用是有状态的，需要记录用户的登录信息，如果每次用户的请求都是随机路由到后端的应用服务器，那么用户的会话将会丢失；解决这个问题两个方案：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;采用一致性hash把用户的请求路由到同一个Tomcat，如果有一台服务器跪了，那么这台服务器上面的用户信息将会丢失&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Tomcat集群之间通过配置session复制，达到共享，此方案效率较低&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两个方案都不是很好，那么还有其他的方案吗？请继续往下看&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;缓存&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据二八原则，80%的的业务都是集中访问20%的数据，这20%的数据通常称为热点数据，但是这20%的数据占用的内存也不会小，如果每个应用服务器都存放一份，有些浪费存储空间，所以这时候需要考虑加入分布式缓存服务器（常用的是Redis）；当引入了分布式缓存服务器，再来看上面那个方案的问题，就可以解决了，把用户的会话存放到缓存服务器，不仅可以防止用户数据丢失，效率也不低；架构图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.52&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zGicf6vk3kaemSzAD7bHhK4yQPwuUagZ0h3Jz3w7lDgwV8YtoACOZsr2wbTIR9K6x7cHXaib05yNN4nA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;缓存&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于分布式缓存服务器毕竟存放在远程，需要经过网络，所以取数据还是要花一点时间；本地缓存访问速度更快，但是内存空间有限，并且还会出现和应用程序争抢资源；所以这种架构搭配了分布式缓存和本地缓存，本地缓存存放少量常用热点数据，当本地缓存中没有命中时在去集中式缓存取&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在引进缓存之后，数据库的访问压力可以的一定的缓解&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据库读写分离&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然在加入了缓存之后，部分数据可以直接走缓存，不需要访问数据库，但是任然会有一些请求，会访问数据库，比如：缓存失效，缓存未命中；当流量大的时候，数据库的访问量也不小。这时候我们需要考虑搭建数据库集群，读写分离&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zGicf6vk3kaemSzAD7bHhK4yQruU99JpAljqiaYjHbZ9KmcCQX4PFdicBuFiaNV6FW9D6ptiaXZBnoEhHXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;数据库读写分离&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当应用服务器有写操作时，访问主库，当应用程序有读操作时，访问从库；大多数的应用都是读的操作远远大于写的操作，所以可以配置数据库一主多从来分担数据库的压力；为了让应用程序对应主库和从库无感知，通常需要引入一些读写分离的框架做一个统一的数据访问模块。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种架构通常需要警惕的一个问题是主从延迟，当在高并发的场景下，主库刚写成功，数据库还未成功同步完从库，这时候另一个请求进入读取数据发现不存在；解放方案是在应用程序中高并发的场景下设置强制走主库查询&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;兄弟们，请不要白嫖哦，文章看一半，请先点个赞&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;反向代理和CDN&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如随着业务的不断扩大，全国各地都会使用到我们的应用，由于各地区的网络情况不同，所以有的人请求响应速度快，有的人请求响应速度慢，这会严重的影响到用户的体验。为了提高响应速度需要引入反向代理和CDN；CDN和反向代理都是采用的缓存，目的：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;架构图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.50125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zGicf6vk3kaemSzAD7bHhK4yQ9r7nTCb9u4zPRzhvmxmDqBx82gUT6NzlAJuqvfZWTRXTgFicV2GOibiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;反向代理和CDN&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CDN: 部署在网络提供商的机房，当用户来访问的时候，从距离用户最近的服务器返回数据，尽快呈现给用户；通常情况下在CDN中缓存的是静态资源（html,js,css），达到动静分离；但是有时候遇到了某些数据访问量特别大的时候，后端会生成静态资源放入到CDN，比如：商城的首页，每个用户进入都需要访问的页面，如果每次请求都进入到后端，那么服务器的压力肯定不小，这种情况下会把首页生成静态的文件缓存到cdn和反向代理服务器&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反向代理：部署在应用的中心机房，通常也是缓存的静态资源，当用户通过CDN未请求到需要的数据时，先进入反向代理服务器，如果有缓存用户访问的数据，那么直接返回给用户；这里也有特殊情况，对于有些场景下的热点数据，在这里根据用户的请求去分布式缓存服务器中获取，能拿到就直接返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种架构已经把缓存做到了4级&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一级：CDN 缓存静态资源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二级：反向代理缓存静态资源以及部分热点数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三级：应用服务器的本地缓存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第四级：分布式缓存服务器&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下经过了这4级缓存，能够进入到数据库的请求也不多了，很好的释放了数据库的压力&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;搜索引擎和NoSQL&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着业务的不断扩大，对于数据的存储和查询的需求也越来越复杂，通常情况我们需要引入非关系型数据库，比如搜索引擎和NoSQL数据库&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.60375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zGicf6vk3kaemSzAD7bHhK4yQ6Wcj8ynjq3PjCVPKib7Q7YanbrbdsicibgYIViaKB2tz0xDGI9lf8fFrUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;搜索引擎和NoSQL&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候我们的查询场景很复杂，需要查询很多数据表，经过一系列的计算才能完成，这时候可以考虑通过数据同步工具（比如canal）拉去数据到大数据平台，使用批处理框架离线计算，把输出的结果存放到搜索引擎或者NoSQL数据库中，应用程序直接查询计算的结果返回给用户。也有可能我们需要汇总多个表的数据做一张宽表，方便应用程序查询&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于引入的数据存储方式增多，为了减轻应用程序的管理多个数据源的麻烦，需要封装统一数据访问模块，如果使用的时Java，可以考虑spring-data&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;业务纵向拆分&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;互联网公司通常的宗旨是小步迭代试错快跑，当业务发展到足够大，对于单体应用想要达到这个宗旨是有难度的，随着业务的发展，应用程序越来越大，研发、维护、发布的成本也越来越大，这时候就需要考虑根据业务把单体应用拆分为多个服务，服务之间可以通过RPC远程调用和消息队列来一起完成用户的请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于业务的拆分，通常情况下也会相应的对数据库进行拆分，达到一个服务对应一个数据库的理想状态&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6025&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zGicf6vk3kaemSzAD7bHhK4yQ9uwLFeiafJtWW25fVEcQlibwTYtqGO7IiaQNNNjXZh9PHgInmg234BQbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;业务纵向拆分&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入MQ的好处：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;提高系统的可用性：当消费服务器发送故障时，消息还在消息队列中，数据不会丢失&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加快请求的响应：当用户请求到达服务器后，把请求中可以异步处理的数据放入到MQ，让系统逐一消费，不需要用户等待，加快了响应速度&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;削峰填谷：当大量请求都同时进入到系统之后，会全部放入到消息队列，系统逐一消费，不会对系统造成很大的冲击&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一个情况未谈及到，就是数据库的水平拆分，这也是数据库拆分的最后手段，只有当单表数据特别大，不能满足业务的需要才使用。使用最多的还是进行数据库的业务纵向拆分，把数据库中不同业务的数据放到不同的物理服务器上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用当前到底选择什么架构，一定要根据实际业务的需求进行灵活的选择，驱动技术架构发展的主要动力还是在于业务的发展，不要为了技术而技术。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;写在最后&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先感谢大家可以耐心地读到这里。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当然，文中或许会存在或多或少的不足、错误之处，有建议或者意见也非常欢迎大家在评论交流。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后，&lt;strong&gt;「白嫖不好，创作不易」&lt;/strong&gt;，希望朋友们可以&lt;strong&gt;「点赞」&lt;/strong&gt;，因为这些就是我分享的全部动力来源🙏&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bcef6c56513b00078523040ec46a5cdf</guid>
<title>[推荐] 面试被吊打：Redis 原理</title>
<link>https://toutiao.io/k/pmxukkm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;小张兴冲冲去面试，结果被面试官吊打！&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官，你好。我是来参加面试的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你好，小张。我看了你的简历，熟练掌握Redis，那么我就随便问你几个Redis相关的问题吧。首先我的问题是，&lt;strong&gt;Redis是单线程还是多线程呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis不同版本之间采用的线程模型是不一样的，在Redis4.0版本之前使用的是单线程模型，在4.0版本之后增加了多线程的支持。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在4.0之前虽然我们说Redis是单线程，也只是说它的网络I/O线程以及Set 和 Get操作是由一个线程完成的。但是Redis的持久化、集群同步还是使用其他线程来完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4.0之后添加了多线程的支持，主要是体现在大数据的异步删除功能上，例如 &lt;code&gt;unlink key&lt;/code&gt;、&lt;code&gt;flushdb async&lt;/code&gt;、&lt;code&gt;flushall async&lt;/code&gt; 等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回答的很好，&lt;strong&gt;那为什么Redis在4.0之前会选择使用单线程？而且使用单线程还那么快？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选择单线程个人觉得主要是使用简单，不存在锁竞争，可以在无锁的情况下完成所有操作，不存在死锁和线程切换带来的性能和时间上的开销，但同时单线程也不能完全发挥出多核CPU的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于为什么单线程那么快我觉得主要有以下几个原因：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Redis 的大部分操作都在内存中完成，内存中的执行效率本身就很快，并且采用了高效的数据结构，比如哈希表和跳表。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用单线程避免了多线程的竞争，省去了多线程切换带来的时间和性能开销，并且不会出现死锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;采用 I/O 多路复用机制处理大量客户端的Socket请求，因为这是基于非阻塞的 I/O 模型，这就让Redis可以高效地进行网络通信，I/O的读写流程也不再阻塞。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不错，&lt;strong&gt;那Redis是如何实现数据不丢失的呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis数据是存储在内存中的，为了保证Redis数据不丢失，那就要把数据从内存存储到磁盘上，以便在服务器重启后还能够从磁盘中恢复原有数据，这就是Redis的数据持久化。Redis数据持久化有三种方式。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;AOF 日志（Append Only File，文件追加方式）：记录所有的操作命令，并以文本的形式追加到文件中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RDB 快照（Redis DataBase）：将某一个时刻的内存数据，以二进制的方式写入磁盘。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;混合持久化方式：Redis 4.0 新增了混合持久化的方式，集成了 RDB 和 AOF 的优点。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那你分别说说 &lt;strong&gt;AOF和 RDB的实现原理吧。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AOF采用的是写后日志的方式，Redis先执行命令把数据写入内存，然后再记录日志到文件中。AOF日志记录的是操作命令，不是实际的数据，如果采用AOF方法做故障恢复时需要将全量日志都执行一遍。&lt;img data-ratio=&quot;0.4425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jO7IqBicQ3GSO5A7UCoVnPDUErCW7ZkcymMUSm9zD8Vzm6cWypLcibJGyYWmZJQacUEGFRgJWOnF7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RDB采用的是内存快照的方式，它记录的是某一时刻的数据，而不是操作，所以采用RDB方法做故障恢复时只需要直接把RDB文件读入内存即可，实现快速恢复。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你刚提到了AOF采用的是 “写后日志” 的方式，我们平时用的MySQL则采用的是 “写前日志”，那 &lt;strong&gt;Redis为什么要先执行命令，再把数据写入日志呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：额头开始冒汗，问的是些啥问题呀。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;额，这个主要是由于Redis在写入日志之前，不对命令进行语法检查，所以只记录执行成功的命令，避免出现记录错误命令的情况，而且在命令执行后再写日志不会阻塞当前的写操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那 &lt;strong&gt;后写日志又有什么风险呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我... 这个我不会。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好吧，后写日志主要有两个风险可能会发生：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;数据可能会丢失：如果 Redis 刚执行完命令，此时发生故障宕机，会导致这条命令存在丢失的风险。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可能阻塞其他操作：AOF 日志其实也是在主线程中执行，所以当 Redis 把日志文件写入磁盘的时候，还是会阻塞后续的操作无法执行。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我还有个问题是 &lt;strong&gt;RDB做快照时会阻塞线程吗？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 提供了两个命令来生成 RDB 快照文件，分别是 &lt;code&gt;save&lt;/code&gt; 和 &lt;code&gt;bgsave&lt;/code&gt;。&lt;code&gt;save&lt;/code&gt; 命令在主线程中执行，会导致阻塞。而 &lt;code&gt;bgsave&lt;/code&gt; 命令则会创建一个子进程，用于写入 RDB 文件的操作，避免了对主线程的阻塞，这也是 Redis RDB 的默认配置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;RDB 做快照的时候数据能修改吗？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;save是同步的会阻塞客户端命令，bgsave的时候是可以修改的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那Redis是怎么解决在bgsave做快照的时候允许数据修改呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：（你咋还问。。。我™不会啊！）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;额，这个我不太清楚...&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8897849462365591&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jO7IqBicQ3GSO5A7UCoVnPDRmmiaUsIMpo0WmPuIHLmia60lZ6IG2R2BmyT9HRFJoP3pY9BaiappqecQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;372&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里主要是利用 &lt;code&gt;bgsave&lt;/code&gt;的子线程实现的，具体操作如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果主线程执行读操作，则主线程和 &lt;code&gt;bgsave&lt;/code&gt; 子进程互相不影响；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果主线程执行写操作，则被修改的数据会复制一份副本，然后 &lt;code&gt;bgsave&lt;/code&gt;子进程会把该副本数据写入 RDB 文件，在这个过程中，主线程仍然可以直接修改原来的数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.38875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jO7IqBicQ3GSO5A7UCoVnPD77lQMwvWt1J3AVR80gGQ8y6QEhXa0icp4gzy4pMn9f8xsmyMXEpmicAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;要注意，Redis 对 RDB 的执行频率非常重要，因为这会影响快照数据的完整性以及 Redis 的稳定性，所以在 Redis 4.0 后，&lt;strong&gt;增加了 AOF 和 RDB 混合的数据持久化机制：&lt;/strong&gt; 把数据以 RDB 的方式写入文件，再将后续的操作命令以 AOF 的格式存入文件，既保证了 Redis 重启速度，又降低数据丢失风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;学到了学到了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那你再跟我说说Redis如何实现高可用吧？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis实现高可用主要有三种方式：主从复制、哨兵模式，以及 Redis 集群。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;主从复制&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将从前的一台 Redis 服务器，同步数据到多台从 Redis 服务器上，即一主多从的模式，这个跟MySQL主从复制的原理一样。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5723684210526315&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jO7IqBicQ3GSO5A7UCoVnPDImufrmEtAUtj0eeEC8mNIibMS4obtqEhXtBcc0de8E6stySr3UwwzPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;608&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;br/&gt;哨兵模式&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 Redis 主从服务的时候，会有一个问题，就是当 Redis 的主从服务器出现故障宕机时，需要手动进行恢复，为了解决这个问题，Redis 增加了哨兵模式（因为哨兵模式做到了可以监控主从服务器，并且提供自动容灾恢复的功能）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.84125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jO7IqBicQ3GSO5A7UCoVnPDFwbYPmzRhSlwEhtYXu1sDml50K179hnWiaYEadFTnqBNUwv7sqXjjfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;br/&gt;Redis Cluster（集群）&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis Cluster 是一种分布式去中心化的运行模式，是在 Redis 3.0 版本中推出的 Redis 集群方案，它将数据分布在不同的服务器上，以此来降低系统对单主节点的依赖，从而提高 Redis 服务的读写性能。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.325&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jO7IqBicQ3GSO5A7UCoVnPDMRaD2kNBqnyoqS9icUQCXNHkFgGqhkvSahoTeTG3Uv0ibibn12ice0ibwfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用哨兵模式在数据上有副本数据做保证，在可用性上又有哨兵监控，一旦master宕机会选举salve节点为master节点，这种已经满足了我们的生产环境需要，&lt;strong&gt;那为什么还需要使用集群模式呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;额，哨兵模式归根节点还是主从模式，在主从模式下我们可以通过增加slave节点来扩展读并发能力，但是没办法扩展写能力和存储能力，存储能力只能是master节点能够承载的上限。所以为了扩展写能力和存储能力，我们就需要引入集群模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;集群中那么多Master节点，redis cluster在存储的时候如何确定选择哪个节点呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这应该是使用了某种hash算法，但是我不太清楚。。。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6432291666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4jO7IqBicQ3GSO5A7UCoVnPDzlCRiaaCqGsVlhcAKbkQE7m5iajwZjf3dI3yOTeKn93g1VwwoYBOqPGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;384&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那好，今天的面试就到这里吧，你先回去等我们的面试通知。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小张：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好的，谢谢面试官，你能告诉我redis cluster怎么实现节点选择的吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;面试官：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis Cluster采用的是&lt;strong&gt;类一致性哈希算法实现节点选择的&lt;/strong&gt;，至于什么是一致性哈希算法你自己回去看看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis Cluster将自己分成了16384个&lt;strong&gt;Slot&lt;/strong&gt;（槽位），哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中，具体执行过程分为两大步。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;根据键值对的 key，按照 CRC16 算法计算一个 16 bit 的值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再用 16bit 值对 16384 取模，得到 &lt;code&gt;0~16383&lt;/code&gt; 范围内的模数，每个模数代表一个相应编号的哈希槽。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个Redis节点负责处理一部分槽位，假如你有三个master节点 ABC，每个节点负责的槽位如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;节点&lt;/th&gt;&lt;th&gt;处理槽位&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;A&lt;/td&gt;&lt;td&gt;0-5000&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;B&lt;/td&gt;&lt;td&gt;5001 - 10000&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;C&lt;/td&gt;&lt;td&gt;10001 - 16383&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就实现了cluster节点的选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，各位看官朋友们，Redis原理的这些面试点你们记住了吗？希望你们的面试不会被这个问题难倒哟~&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8f464e7790c69c48a2d489e52a9472ca</guid>
<title>[推荐] 下一代微服务 Service Mesh 原理及实践</title>
<link>https://toutiao.io/k/hxrinvv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;微服务架构痛点&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;业务关注服务之间通信&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;会导致业务迭代速度变慢&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;微服务架构1.0&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.643&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmiajLDjc9MPXicibQiaAOrKpKhktXkwo2z5AvyvtbGM2G3zPx7EM1rAZHIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;网关层1个、业务逻辑层多个、数据访问层多个、DB/Cache多个，注册中心、配置中心&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;微服务2.0架构-服务网格&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3867735470941884&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm04yhHth8b2E02ib2USEvHaksgazdibxTMQGWicTTrqD0cJOpTt1nDl4JA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1996&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基础设施升级困难&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;影响基础设施团队的交付能力和交付速度&lt;br/&gt;因为应用程序通过jar包方式引入通信组件&lt;br/&gt;通信组件升级需要应用程序配合jar包版本升级&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.35850956696878145&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmuVcXnTB12CTiaZVfCDZD4XLTEMxuT7JD9dsQsD6yJdN6kH40neXsRpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1986&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;多编程语言之间&#x27;通信&#x27;问题&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;业务每种语言一套基础设施 成本大&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5065065065065065&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm0nkAfvnwft5wCfvspwQt3ia7UKuvn1duiatSHBlazZEfeb7yV48BwNjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1998&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;微服务架构演进&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6202404809619239&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm82tn8Emsn1QQJ8Gd8oVkUOgNrjGbk5Qo8eibwrgticTdSEsUjF7XP53A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1996&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务网格定义&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1494949494949495&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmdp8dbUuibwWlMgXtcKZMYHfjoGxouD6aP5llbqrpE6d5Ph50Vo4MOrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1980&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务网格架构&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3587939698492462&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm7ldtRY15MtRTHt4CFvCK0B7hlXA1NwmU6rsPIDRLmw4y7AxXl6av9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1990&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;带来的问题-链路会变长&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;性能里面的RT 平均响应延迟会变高&lt;br/&gt;但本机之间即应用程序放到本机的sidecar损耗不会超过1毫秒&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;开源框架&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;最早版本linkerd&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5393145161290323&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmhqnkic7NVOkx4vic78f0T6Bb5sQCA0OdszPgw7ohciaEuHbPrjke1Q6bg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1984&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;应用程序和sidecar之间通讯用tcp或http1.1以上都可以；两者需要保持长连接&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;istio&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5272177419354839&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmV5BVAcx02mtLnoX8k72PeIgfZ2fy57ybnMcrh18FCtchUETXwkNPqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1984&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;控制中心&lt;br/&gt;1、控制proxy之间通讯&lt;br/&gt;2、负载均衡&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;数据收集服务：&lt;br/&gt;&lt;br/&gt;proxy之间通讯完之后 要上报一些mertics信息 （耗时、请求次数）&lt;br/&gt;全部同步上报&lt;br/&gt;集中式 不靠谱&lt;br/&gt;它的性能影响proxy本身的性能&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;做鉴权安全相关的&lt;br/&gt;proxy之间权限鉴权比如TLS、SSL&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;sofa mesh&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;蚂蚁金服开源&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;架构&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5371485943775101&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmjb27vgyKDnVKosFmXPicLTPtNPaV3PeVibd8PCFnj6VRrdQOlTQhib0uw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1992&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、将istio中的proxy重写&lt;br/&gt;isotio proxy是用c++写的&lt;br/&gt;sofa用go重写&lt;br/&gt;2、istio数据收集节点是集中式的 sofa是分布式的即每个proxy中都有一个mixer&lt;br/&gt;3、目前还没有公司大规模在用 社区不活跃 建议使用istio&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;新浪weibo mesh&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5542046605876393&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm2AcJ10hv8sSMFHW5pnNv802fibw4icNZfxAkIlpdK3h0lh5IxypAqxGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1974&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务网格做什么&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5557809330628803&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmfqEgE9Iyuic9SDnQGfJF5lU2C32bibIZTfuB65QWzXxFAicbSdPL9xbmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1972&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;如何选型&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0440456769983686&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmoCLMeFcSWr3p7LHdyDm1sZbb56h6HF5y3u4oLH6RZeIrfVwCLWbmGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1226&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、业务升级代价太高 要让业务的升级成本降低到0 要兼容所有rpc用法 所以自研&lt;br/&gt;2、期望的是业务方只需要将rpc jar包换成这个rpc mesh jar包就行了&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;自研思路&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6939655172413793&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmbQfriaJyu4Rc3C2ibSQicXoEww4Ple3YtpZ12M5c4MIQtQDc3akNFH2mA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1856&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、要兼容传统(物理机、虚拟机)和云&lt;br/&gt;2、控制中心包括服务管理平台和数据收集中心&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;架构设计&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.624750499001996&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm6YibfraG2mpo9wpNsAs4fQVaxH903whNVe2ssxQUYIAbkiaamplfmqBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2004&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、数据收集中心：&lt;br/&gt;a、Metric:收集耗时、响应情况&lt;br/&gt;b、Trace:分布式请求跟踪系统APM&lt;br/&gt;c、Alarm：报警功能&lt;br/&gt;2、Protocol&lt;br/&gt;a、RPC:兼容老的RPC协议&lt;br/&gt;b、mesh包括通讯协议(http1.1和2.0)和数据协议(protobuff)&lt;br/&gt;&lt;br/&gt;（注：http1.0不支持 因为是短连接;http1.1和http2.0支持keep alive长连接;tpc是长连接;连接还在 server短可以直接推送消息给client）&lt;br/&gt;&lt;br/&gt;2、sidecar之间的健康检查没有通过注册中心而是本身&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总体流程&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5563380281690141&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmrSJdXxcYt152vciaR2Ob4vQiagxHDFXu7AK2qTtD6qbiadr6oXczw4Y3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1988&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;用户发起一个熔断服务B的指令&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6687179487179488&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm2TJRQWtdicfY7JJaRtb3QRUad370WicLSQK8RDpLUWLb53ialyPKNqRQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1950&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、服务管理平台、控制中心、数据收集中心都是现成的服务（之前文章介绍过）那么自研Service Mesh只需要实现proxy就可以了&lt;br/&gt;2、之前Service和Proxy是一个进程&lt;br/&gt;现在需要修改成2个独立的进程即可&lt;br/&gt;3、将二者放到同一个pod中&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;如果sidecar挂了对整体是否有影响?&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;没有影响。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4915514592933948&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmha1K9PrBecoN7mhbfYdUAa1bledkmlrEMYdwwf9lWovsiaYndOL5I9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1302&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sidecar挂掉 pod如何处理？&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;如果sidecar挂掉了 就会被监控到 直接把当前pod杀死就行了 k8s会自动重启一个pod&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;2个应用程序放在同一个物理机上架构怎样？&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5741758241758241&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmVVtyS2E1ZDIlJRdTiceHsjug11thSR3uOZQtjtbuzwg9uPqM5wn3ldw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;728&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;漂移&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、日志漂移&lt;br/&gt;&lt;br/&gt;服务器1上有服务1生成日志1&lt;br/&gt;如果服务器1上面的服务1挂了&lt;br/&gt;在服务器2上启动服务2生成日志2 &lt;br/&gt;如果日志1和日志2有强依赖关系 &lt;br/&gt;那么必须得在服务器1上启动服务1继续在日志1的基础上生成日志&lt;br/&gt;&lt;br/&gt;2、重试漂移&lt;br/&gt;pod如果挂了 再次重启 那么ip就会改变&lt;br/&gt;重试漂移到云上任何节点都没有关系&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;完整流程图&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;这个完整的流程图涵盖了&lt;br/&gt;DNS、CDN、Nginx、FastDFS（或Ceph）、&lt;br/&gt;LVS、ServiceMash、数据收集中心、&lt;br/&gt;注册中心、控制中心、网关、业务逻辑层、&lt;br/&gt;数据访问层、存储层等数据交互过程&lt;br/&gt;&lt;br/&gt;价值不菲 想要的话 &lt;br/&gt;可以添加我微信15900411193&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;调用链路&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3782696177062374&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmgLOSWZMwhkiaN5VeySCQn6QUbjIibuHr4MOWQGibSzNlhfuqibGBpyUHCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1988&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、做协议解析的目的是兼容老的协议&lt;br/&gt;客户端发出请求后 在客户端service和服务方service要做协议解析&lt;br/&gt;如果都是mesh协议 是不需要协议解析的、协议封装也不需要&lt;br/&gt;2、客户端一定要做序列化、反序列化 这和通讯没啥关系 就是一个数据包&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;调用方时序图&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.1094017094017095&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmo2ZqydDFr5mLALib7TFtOxoFyrW4put3x8MzSwP5TpsW6bgLplp3umw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1170&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务方时序图&lt;br/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.4110671936758894&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmA6dmticzO1uAO4jXEy5NC7T1wPfmuNmr99yWrOibPd2ic5iaXDKwB1E8xQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1012&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;缓存管理 多个Map:&lt;br/&gt;服务方提供哪些函数调用 通过扫描jar包 反射机制 获取服务提供的类名和方法名&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;协议设计&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;数据协议&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、Protocol Buffer&lt;br/&gt;2、分割符、版本号、Mesh消息构成&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.19497487437185929&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmk1YhLJzQ3xd5E9GbDmX1anKKgIqD6tuiaNG4EQIV52TrWIHF4yXApEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1990&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、一次传输协议中有版本号 &lt;br/&gt;比如 版本号1表示rpc协议 &lt;br/&gt;版本号2表示mesh协议&lt;br/&gt;通过版本号可以区分兼容老协议还是新协议&lt;br/&gt;2、多个数据包之间通过头和尾分割符分开&lt;br/&gt;3、分割符占5个字节&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Mesh通讯协议&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、TCP长连接&lt;br/&gt;2、Http1.1或2.0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;混合云部署&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、调用方&lt;br/&gt;a、SideCar+Service(Mesh)&lt;br/&gt;b、Service(RPC)&lt;br/&gt;2、服务方&lt;br/&gt;a、SideCar+Service(Mesh)&lt;br/&gt;b、Service(RPC)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;访问流程&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3229689067201605&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm20ht2oGM3KHs0CDYics7JXYjRJrPIEYplfbpOYS7zhQ9tgAIXzD1kFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1994&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、在服务启动的时候 mesh服务或普通的RPC服务都会去注册中心注册 此时就知道了该节点的服务类型&lt;br/&gt;2、调用方下拉服务信息 也就知道了提供方服务类型 然后选择不同的协议去调用&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小细节&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、熔断放在mesh里面做 不需要业务方参与&lt;br/&gt;2、下游重试次数是一样的 是服务粒度 非接口粒度&lt;br/&gt;3、proxy(mesh)之间做健康检测 是分布式的 一旦发现自己的上游或下游出现了问题 就更新本地的路由表&lt;br/&gt;4、负载均衡算法:Random、RR、Hash(主要用一致性&lt;span&gt;hash&lt;/span&gt;来做)&lt;br/&gt;（RR：(循环负载)&lt;br/&gt;第一次请求路由到第一个节点，&lt;br/&gt;第二次请求路由到第二个节点，&lt;br/&gt;第三次请求路由到第三个节点，&lt;br/&gt;第四次请求路由到第一个节点&lt;br/&gt;....）&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;架构未来&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;2平台1中心1趋势&lt;br/&gt;&lt;br/&gt;service mesh平台与业务解耦&lt;br/&gt;容器云弹性平台&lt;br/&gt;服务治理平台(控制中心、注册中心、数据收集中心)&lt;br/&gt;人工智能(AI)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务管理平台的调用关系-数据收集存储方法&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务方-调用方角度&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4020100502512563&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmnp3gibme5rHX7cQxzrJojyic7S72CvWH0Vr24WpDC8RGicKCuQYm2ogaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1990&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;服务方:1分钟500万条记录&lt;br/&gt;调用方:50万&lt;br/&gt;共550万&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;存储方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;方案1&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5426278836509528&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm0a7lakm422lTyImtA59Vo4GP3nsFjib63vAQQq6uuheS5AhqicIbW6rQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1994&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;方案二&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;重复数据提取出来作为元数据&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.46598984771573604&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm1ficWMZOiaX1GReepHV0qKPibWuE9zpYfhicnJ1a3EhXurnibZ7iaG6jRwWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1970&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;方案三&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;实际调用流量仅为方案1的1/10&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.295959595959596&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmMekAzNGwEOiarZTiakpzeibcXlV36Cen0DhAcna6ictLUKddPVBeE4iaVfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1980&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;、&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c7848135d6361ed5f737b8f82b2fc593</guid>
<title>[推荐] [译] 新老手必备的 34 种 JavaScript 简写优化技术</title>
<link>https://toutiao.io/k/jdslwhk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原文：https://javascript.plainenglish.io/34-javascript-optimization-techniques-to-know-in-2021-d561afdf73c3&lt;br/&gt;作者：Atit&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发者的生活总是在学习新的东西，跟上变化不应该比现在更难，我的动机是介绍所有JavaScript的最佳实践，比如简写功能，作为一个前端开发者，我们必须知道，让我们的生活在2021年变得更轻松。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可能做了很长时间的JavaScript开发，但有时你可能没有更新最新的特性，这些特性可以解决你的问题，而不需要做或编写一些额外的代码。这些技术可以帮助您编写干净和优化的JavaScript代码。此外，这些主题可以帮助你为2021年的JavaScript面试做准备。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.如果有多个条件&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以在数组中存储多个值，并且可以使用数组 &lt;code&gt;include&lt;/code&gt; 方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (x === &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt; || x === &lt;span&gt;&#x27;def&#x27;&lt;/span&gt; || x === &lt;span&gt;&#x27;ghi&#x27;&lt;/span&gt; || x ===&lt;span&gt;&#x27;jkl&#x27;&lt;/span&gt;) {&lt;br/&gt;  &lt;span&gt;//logic&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; ([&lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;def&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;ghi&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;jkl&#x27;&lt;/span&gt;].includes(x)) {&lt;br/&gt;  &lt;span&gt;//logic&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.如果为真…否则简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这对于我们有 &lt;code&gt;if-else&lt;/code&gt; 条件，里面不包含更大的逻辑时，是一个较大的捷径。我们可以简单的使用三元运算符来实现这个简写。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test: boolean;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (x &amp;gt; &lt;span&gt;100&lt;/span&gt;) {&lt;br/&gt;  test = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  test = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test = (x &amp;gt; &lt;span&gt;10&lt;/span&gt;) ? &lt;span&gt;true&lt;/span&gt; : &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//or we can use directly&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test = x &amp;gt; &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(test);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们有嵌套条件时，我们可以采用这种方式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; x = &lt;span&gt;300&lt;/span&gt;,&lt;br/&gt;test2 = (x &amp;gt; &lt;span&gt;100&lt;/span&gt;) ? &lt;span&gt;&#x27;greater 100&#x27;&lt;/span&gt; : (x &amp;lt; &lt;span&gt;50&lt;/span&gt;) ? &lt;span&gt;&#x27;less 50&#x27;&lt;/span&gt; : &lt;span&gt;&#x27;between 50 and 100&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(test2); &lt;span&gt;// &quot;greater than 100&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.声明变量&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们要声明两个具有共同值或共同类型的变量时，可以使用此简写形式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test1;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test2 = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test1, test2 = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.Null, Undefined，空检查&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们创建新的变量时，有时我们想检查我们引用的变量的值是否为空或undefined。JavaScript确实有一个非常好的简写工具来实现这些功能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (test1 !== &lt;span&gt;null&lt;/span&gt; || test1 !== &lt;span&gt;undefined&lt;/span&gt; || test1 !== &lt;span&gt;&#x27;&#x27;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; test2 = test1;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test2 = test1 || &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.null值检查和分配默认值&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; test1 = &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;    test2 = test1 || &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;null check&quot;&lt;/span&gt;, test2); &lt;span&gt;// output will be &quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.undefined值检查和分配默认值&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; test1 = &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;    test2 = test1 || &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;undefined check&quot;&lt;/span&gt;, test2); &lt;span&gt;// output will be &quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常值检查&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; test1 = &lt;span&gt;&#x27;test&#x27;&lt;/span&gt;,&lt;br/&gt;    test2 = test1 || &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(test2); &lt;span&gt;// output: &#x27;test&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.将值分配给多个变量&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们处理多个变量并希望将不同的值分配给不同的变量时，此简写技术非常有用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test1, test2, test3;&lt;br/&gt;test1 = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;test2 = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;test3 = &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; [test1, test2, test3] = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.赋值运算符简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在编程中处理很多算术运算符，这是将运算符分配给JavaScript变量的有用技术之一。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;test1 = test1 + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;test2 = test2 - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;test3 = test3 * &lt;span&gt;20&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;test1++;&lt;br/&gt;test2--;&lt;br/&gt;test3 *= &lt;span&gt;20&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.如果存在简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是我们大家都在使用的常用简写之一，但仍然值得一提。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (test1 === &lt;span&gt;true&lt;/span&gt;) or &lt;span&gt;if&lt;/span&gt; (test1 !== &lt;span&gt;&quot;&quot;&lt;/span&gt;) or &lt;span&gt;if&lt;/span&gt; (test1 !== &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand //it will check empty string,null and undefined too&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (test1)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：如果test1有任何值，它将在if循环后进入逻辑，该运算符主要用于 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 的检查。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.多个条件的AND（&amp;amp;&amp;amp;）运算符&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果仅在变量为 &lt;code&gt;true&lt;/code&gt; 的情况下才调用函数，则可以使用 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 运算符。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (test1) {&lt;br/&gt; callMethod(); &lt;br/&gt;} &lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;test1 &amp;amp;&amp;amp; callMethod();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11.foreach循环简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是迭代的常用简写技术之一。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; testData.length; i++)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; testData) or  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i &lt;span&gt;of&lt;/span&gt; testData)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个变量的数组&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;testData&lt;/span&gt;(&lt;span&gt;element, index, array&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;test[&#x27;&lt;/span&gt; + index + &lt;span&gt;&#x27;] = &#x27;&lt;/span&gt; + element);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;[&lt;span&gt;11&lt;/span&gt;, &lt;span&gt;24&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;].forEach(testData);&lt;br/&gt;&lt;span&gt;// logs: test[0] = 11, test[1] = 24, test[2] = 32&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12.return中比较&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也可以在return语句中使用比较。它将避免我们的5行代码，并将它们减少到1行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;checkReturn&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!(test === &lt;span&gt;undefined&lt;/span&gt;)) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; test;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; callMe(&lt;span&gt;&#x27;test&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; data = checkReturn();&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(data); &lt;span&gt;//output test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;callMe&lt;/span&gt;(&lt;span&gt;val&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(val);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;checkReturn&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; test || callMe(&lt;span&gt;&#x27;test&#x27;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13.箭头函数&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;a, b&lt;/span&gt;) &lt;/span&gt;{ &lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; a + b; &lt;br/&gt;} &lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; add = &lt;span&gt;(&lt;span&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; a + b;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多示例。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;callMe&lt;/span&gt;(&lt;span&gt;name&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;Hello&#x27;&lt;/span&gt;, name);&lt;br/&gt;}&lt;br/&gt;callMe = &lt;span&gt;&lt;span&gt;name&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;Hello&#x27;&lt;/span&gt;, name);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;14.短函数调用&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用三元运算符来实现这些功能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;test1&#x27;&lt;/span&gt;);&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;test2&#x27;&lt;/span&gt;);&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; test3 = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (test3 == &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;  test1();&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  test2();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;(test3 === &lt;span&gt;1&lt;/span&gt;? test1:test2)();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;15. Switch简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以将条件保存在键值对象中，并可以根据条件使用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;switch&lt;/span&gt; (data) {&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;:&lt;br/&gt;    test1();&lt;br/&gt;  &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;:&lt;br/&gt;    test2();&lt;br/&gt;  &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;:&lt;br/&gt;    test();&lt;br/&gt;  &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// And so on...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; data = {&lt;br/&gt;  &lt;span&gt;1&lt;/span&gt;: test1,&lt;br/&gt;  &lt;span&gt;2&lt;/span&gt;: test2,&lt;br/&gt;  &lt;span&gt;3&lt;/span&gt;: test&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;data[something] &amp;amp;&amp;amp; data[something]();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;16.隐式返回简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用箭头函数，我们可以直接返回值，而不必编写return语句。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;calculate&lt;/span&gt;(&lt;span&gt;diameter&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Math&lt;/span&gt;.PI * diameter&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;calculate = &lt;span&gt;&lt;span&gt;diameter&lt;/span&gt; =&amp;gt;&lt;/span&gt; (&lt;br/&gt;  &lt;span&gt;Math&lt;/span&gt;.PI * diameter;&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;17.小数基数指数&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10000&lt;/span&gt;; i++) { ... }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1e4&lt;/span&gt;; i++) {&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;18.默认参数值&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;test1, test2&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (test1 === &lt;span&gt;undefined&lt;/span&gt;)&lt;br/&gt;    test1 = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (test2 === &lt;span&gt;undefined&lt;/span&gt;)&lt;br/&gt;    test2 = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; test1 + test2;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;add = &lt;span&gt;(&lt;span&gt;test1 = &lt;span&gt;1&lt;/span&gt;, test2 = &lt;span&gt;2&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; (test1 + test2);&lt;br/&gt;add() &lt;span&gt;//output: 3&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;19.扩展运算符简写&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// joining arrays using concat&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; data = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test = [&lt;span&gt;4&lt;/span&gt; ,&lt;span&gt;5&lt;/span&gt; , &lt;span&gt;6&lt;/span&gt;].concat(data);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// joining arrays&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; data = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test = [&lt;span&gt;4&lt;/span&gt; ,&lt;span&gt;5&lt;/span&gt; , &lt;span&gt;6&lt;/span&gt;, ...data];&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(test); &lt;span&gt;// [ 4, 5, 6, 1, 2, 3]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于克隆，我们也可以使用扩展运算符。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// cloning arrays&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test1 = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test2 = test1.slice()&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// cloning arrays&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test1 = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test2 = [...test1];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;20.模板文字&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您厌倦了在单个字符串中使用 &lt;code&gt;+&lt;/code&gt; 来连接多个变量，那么这种简写可以消除您的头痛。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; welcome = &lt;span&gt;&#x27;Hi &#x27;&lt;/span&gt; + test1 + &lt;span&gt;&#x27; &#x27;&lt;/span&gt; + test2 + &lt;span&gt;&#x27;.&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; welcome = &lt;span&gt;`Hi &lt;span&gt;${test1}&lt;/span&gt; &lt;span&gt;${test2}&lt;/span&gt;`&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;21.多行字符串简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们在代码中处理多行字符串时，可以使用以下功能：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; data = &lt;span&gt;&#x27;abc abc abc abc abc abc\n\t&#x27;&lt;/span&gt;&lt;br/&gt;    + &lt;span&gt;&#x27;test test,test test test test\n\t&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; data = &lt;span&gt;`abc abc abc abc abc abc&lt;br/&gt;         test test,test test test test`&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;22.对象属性分配&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; test1 = &lt;span&gt;&#x27;a&#x27;&lt;/span&gt;; &lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test2 = &lt;span&gt;&#x27;b&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; obj = {&lt;span&gt;test1&lt;/span&gt;: test1, &lt;span&gt;test2&lt;/span&gt;: test2}; &lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; obj = {test1, test2};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;23.将字符串转换成数字&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test1 = &lt;span&gt;parseInt&lt;/span&gt;(&lt;span&gt;&#x27;123&#x27;&lt;/span&gt;); &lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test2 = &lt;span&gt;parseFloat&lt;/span&gt;(&lt;span&gt;&#x27;12.3&#x27;&lt;/span&gt;); &lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test1 = +&lt;span&gt;&#x27;123&#x27;&lt;/span&gt;; &lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test2 = +&lt;span&gt;&#x27;12.3&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;24.用解构简写&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test1 = &lt;span&gt;this&lt;/span&gt;.data.test1;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test2 = &lt;span&gt;this&lt;/span&gt;.data.test2;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test2 = &lt;span&gt;this&lt;/span&gt;.data.test3;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; { test1, test2, test3 } = &lt;span&gt;this&lt;/span&gt;.data;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;25.用Array.find简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们确实有一个对象数组并且我们想要根据对象属性查找特定对象时，find方法确实很有用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; data = [&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;test1&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;test2&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;cde&#x27;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;test1&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;fgh&#x27;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;]&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;findtest1&lt;/span&gt;(&lt;span&gt;name&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; data.length; ++i) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (data[i].type === &lt;span&gt;&#x27;test1&#x27;&lt;/span&gt; &amp;amp;&amp;amp; data[i].name === name) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; data[i];&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand&lt;/span&gt;&lt;br/&gt;filteredData = data.find(&lt;span&gt;&lt;span&gt;data&lt;/span&gt; =&amp;gt;&lt;/span&gt; data.type === &lt;span&gt;&#x27;test1&#x27;&lt;/span&gt; &amp;amp;&amp;amp; data.name === &lt;span&gt;&#x27;fgh&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(filteredData); &lt;span&gt;// { type: &#x27;test1&#x27;, name: &#x27;fgh&#x27; }&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;26.查找条件简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们有代码来检查类型，根据类型需要调用不同的方法，我们可以选择使用多个else ifs或者switch，但是如果我们有比这更好的简写方法呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (type === &lt;span&gt;&#x27;test1&#x27;&lt;/span&gt;) {&lt;br/&gt;  test1();&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (type === &lt;span&gt;&#x27;test2&#x27;&lt;/span&gt;) {&lt;br/&gt;  test2();&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (type === &lt;span&gt;&#x27;test3&#x27;&lt;/span&gt;) {&lt;br/&gt;  test3();&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (type === &lt;span&gt;&#x27;test4&#x27;&lt;/span&gt;) {&lt;br/&gt;  test4();&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;&#x27;Invalid value &#x27;&lt;/span&gt; + type);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; types = {&lt;br/&gt;  &lt;span&gt;test1&lt;/span&gt;: test1,&lt;br/&gt;  &lt;span&gt;test2&lt;/span&gt;: test2,&lt;br/&gt;  &lt;span&gt;test3&lt;/span&gt;: test3,&lt;br/&gt;  &lt;span&gt;test4&lt;/span&gt;: test4&lt;br/&gt;};&lt;br/&gt; &lt;br/&gt;&lt;span&gt;var&lt;/span&gt; func = types[type];&lt;br/&gt;(!func) &amp;amp;&amp;amp; &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;&#x27;Invalid value &#x27;&lt;/span&gt; + type); func();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;27.按位索引简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们遍历数组以查找特定值时，我们确实使用 &lt;code&gt;indexOf()&lt;/code&gt; 方法，如果找到更好的方法该怎么办？让我们看看这个例子。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(arr.indexOf(item) &amp;gt; &lt;span&gt;-1&lt;/span&gt;) { &lt;span&gt;// item found &lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(arr.indexOf(item) === &lt;span&gt;-1&lt;/span&gt;) { &lt;span&gt;// item not found&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(~arr.indexOf(item)) { &lt;span&gt;// item found&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(!~arr.indexOf(item)) { &lt;span&gt;// item not found&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按位（&lt;code&gt;〜&lt;/code&gt;）运算符将返回除-1以外的任何值的真实值。否定它就像做 &lt;code&gt;~~&lt;/code&gt; 一样简单。另外，我们也可以使用 &lt;code&gt;include()&lt;/code&gt; 函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (arr.includes(item)) { &lt;br/&gt;&lt;span&gt;// true if the item found&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;28.Object.entries()&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此函数有助于将对象转换为对象数组。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; data = { &lt;span&gt;test1&lt;/span&gt;: &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;, &lt;span&gt;test2&lt;/span&gt;: &lt;span&gt;&#x27;cde&#x27;&lt;/span&gt;, &lt;span&gt;test3&lt;/span&gt;: &lt;span&gt;&#x27;efg&#x27;&lt;/span&gt; };&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; arr = &lt;span&gt;Object&lt;/span&gt;.entries(data);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(arr);&lt;br/&gt;&lt;span&gt;/** Output:&lt;br/&gt;[ [ &#x27;test1&#x27;, &#x27;abc&#x27; ],&lt;br/&gt;  [ &#x27;test2&#x27;, &#x27;cde&#x27; ],&lt;br/&gt;  [ &#x27;test3&#x27;, &#x27;efg&#x27; ]&lt;br/&gt;]&lt;br/&gt;**/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;29.Object.values()&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是ES8中引入的一项新功能，该功能执行与 &lt;code&gt;Object.entries()&lt;/code&gt; 类似的功能，但没有关键部分：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; data = { &lt;span&gt;test1&lt;/span&gt;: &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;, &lt;span&gt;test2&lt;/span&gt;: &lt;span&gt;&#x27;cde&#x27;&lt;/span&gt; };&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; arr = &lt;span&gt;Object&lt;/span&gt;.values(data);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(arr);&lt;br/&gt;&lt;span&gt;/** Output:&lt;br/&gt;[ &#x27;abc&#x27;, &#x27;cde&#x27;]&lt;br/&gt;**/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;30.双按位简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双重NOT按位运算符方法仅适用于32位整数）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Math&lt;/span&gt;.floor(&lt;span&gt;1.9&lt;/span&gt;) === &lt;span&gt;1&lt;/span&gt; &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;~~&lt;span&gt;1.9&lt;/span&gt; === &lt;span&gt;1&lt;/span&gt; &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;31.重复一个字符串多次&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要一次又一次地重复相同的字符，我们可以使用for循环并将它们添加到同一循环中，但是如果我们有一个简写方法呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;; &lt;br/&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;5&lt;/span&gt;; i ++) { &lt;br/&gt;  test += &lt;span&gt;&#x27;test &#x27;&lt;/span&gt;; &lt;br/&gt;} &lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(str); &lt;span&gt;// test test test test test &lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&#x27;test &#x27;&lt;/span&gt;.repeat(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;32.在数组中查找最大值和最小值&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; arr = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]; &lt;br/&gt;&lt;span&gt;Math&lt;/span&gt;.max(…arr); &lt;span&gt;// 3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Math&lt;/span&gt;.min(…arr); &lt;span&gt;// 1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;33.从字符串中获取字符&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; str = &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;str.charAt(&lt;span&gt;2&lt;/span&gt;); &lt;span&gt;// c&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;Note: If we know the index &lt;span&gt;of&lt;/span&gt; the array then we can directly use index insted &lt;span&gt;of&lt;/span&gt; character.If we are not sure about index it can &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;undefined&lt;/span&gt;&lt;br/&gt;str[&lt;span&gt;2&lt;/span&gt;]; &lt;span&gt;// c&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;34.数学指数幂函数的简写&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Math&lt;/span&gt;.pow(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;); &lt;span&gt;// 8&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;**&lt;span&gt;3&lt;/span&gt; &lt;span&gt;// 8&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>