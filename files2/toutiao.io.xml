<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>7d4cf3d5e6704ed4b5ea38bb0cb7b15a</guid>
<title>聊聊接口性能优化的 11 个小技巧</title>
<link>https://toutiao.io/k/4i9d6w2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;接口性能优化&lt;/strong&gt;对于从事后端开发的同学来说，肯定再熟悉不过了，因为它是一个跟开发语言无关的公共问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该问题说简单也简单，说复杂也复杂。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，只需加个索引就能解决问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，需要做代码重构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，需要增加缓存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，需要引入一些中间件，比如mq。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，需要需要分库分表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，需要拆分服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;等等。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;导致接口性能问题的原因千奇百怪，不同的项目不同的接口，原因可能也不一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我总结了一些行之有效的，优化接口性能的办法，给有需要的朋友一个参考。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.索引&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口性能优化大家第一个想到的可能是：&lt;code&gt;优化索引&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，优化索引的成本是最小的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你通过查看线上日志或者监控报告，查到某个接口用到的某条sql语句耗时比较长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时你可能会有下面这些疑问：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;该sql语句加索引了没？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加的索引生效了没？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mysql选错索引了没？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.1 没加索引&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sql语句中&lt;code&gt;where&lt;/code&gt;条件的关键字段，或者&lt;code&gt;order by&lt;/code&gt;后面的排序字段，忘了加索引，这个问题在项目中很常见。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目刚开始的时候，由于表中的数据量小，加不加索引sql查询性能差别不大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来，随着业务的发展，表中数据量越来越多，就不得不加索引了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;show index from `order`;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;能单独查看某张表的索引情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以通过命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;show create table `order`;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看整张表的建表语句，里面同样会显示索引情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过&lt;code&gt;ALTER TABLE&lt;/code&gt;命令可以添加索引：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ALTER TABLE `order` &lt;span&gt;ADD INDEX &lt;span&gt;idx_name&lt;/span&gt; &lt;span&gt;(name)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也可以通过&lt;code&gt;CREATE INDEX&lt;/code&gt;命令添加索引：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CREATE INDEX idx_name ON `order` (name);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过这里有一个需要注意的地方是：想通过命令修改索引，是不行的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前在mysql中如果想要修改索引，只能先删除索引，再重新添加新的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;删除索引可以用&lt;code&gt;DROP INDEX&lt;/code&gt;命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ALTER TABLE `order` DROP INDEX idx_name;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用&lt;code&gt;DROP INDEX&lt;/code&gt;命令也行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;DROP INDEX idx_name ON `order`;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.2 索引没生效&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的命令我们已经能够确认索引是有的，但它生效了没？此时你内心或许会冒出这样一个疑问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何查看索引有没有生效呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：可以使用&lt;code&gt;explain&lt;/code&gt;命令，查看mysql的执行计划，它会显示索引的使用情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;explain select * from `order` where code=&lt;span&gt;&#x27;002&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果：&lt;img data-ratio=&quot;0.07168894289185905&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibJZVicC7nz5hq0iaKg80FgbtoMf7wY5zmvJK1wqcJMIIbPicTcqgpoRuVwkOYVc0Y6gqA4rncT3uQPfXDQib9bNTgw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1646&quot;/&gt;通过这几列可以判断索引使用情况，执行计划包含列的含义如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1130434782608696&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibJZVicC7nz5hq0iaKg80FgbtoMf7wY5zmvTjic6byYl1N77LPVqmLoTHBZhj3Wp7RW3xpJZHWso7O69Gn6dEpcHTg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;920&quot;/&gt;如果你想进一步了解explain的详细用法，可以看看我的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247490262&amp;amp;idx=1&amp;amp;sn=a67f610afa984ecca130a54a3be453ab&amp;amp;chksm=c0ebc23ef79c4b2869dea998e413c5cbea6aeeea01ee74efc7c1a5fc228baa7beca215adf3ea&amp;amp;token=751314179&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;explain | 索引优化的这把绝世好剑，你真的会用吗？&lt;/a&gt;》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说实话，sql语句没有走索引，排除没有建索引之外，最大的可能性是索引失效了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面说说索引失效的常见原因：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7130281690140845&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibJZVicC7nz5hq0iaKg80FgbtoMf7wY5zmvjI2KJ1iaGZotNaDcrVic7hY6ce0Te0phoOicsB6vQibvXdY7FtcN0lXhag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1136&quot;/&gt;如果不是上面的这些原因，则需要再进一步排查一下其他原因。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.3 选错索引&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，你有没有遇到过这样一种情况：明明是同一条sql，只有入参不同而已。有的时候走的索引a，有的时候却走的索引b？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，有时候mysql会选错索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;必要时可以使用&lt;code&gt;force index&lt;/code&gt;来强制查询sql走某个索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于为什么mysql会选错索引，后面有专门的文章介绍的，这里先留点悬念。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. sql优化&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果优化了索引之后，也没啥效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来试着优化一下sql语句，因为它的改造成本相对于java代码来说也要小得多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面给大家列举了sql优化的15个小技巧：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4396782841823057&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibJZVicC7nz5hq0iaKg80FgbtoMf7wY5zmvPa8OXNqDDPJUqFEaRicwy9DN3Z6JiambArtqtX4fnQpgfvxgIxcYQSSg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;746&quot;/&gt;由于这些技巧在我之前的文章中已经详细介绍过了，在这里我就不深入了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更详细的内容，可以看我的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247490473&amp;amp;idx=1&amp;amp;sn=ba07d64aa8c89054bd263efd660d3a3f&amp;amp;chksm=c0ebc341f79c4a579a6f41465df0459a696ab8ef0499a5f6fd76269af1064fde0286afdb027d&amp;amp;token=2041133408&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;聊聊sql优化的15个小技巧&lt;/a&gt;》，相信看完你会有很多收获。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 远程调用&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，我们需要在某个接口中，调用其他服务的接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如有这样的业务场景：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在用户信息查询接口中需要返回：用户名称、性别、等级、头像、积分、成长值等信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而用户名称、性别、等级、头像在用户服务中，积分在积分服务中，成长值在成长值服务中。为了汇总这些数据统一返回，需要另外提供一个对外接口服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是，用户信息查询接口需要调用用户查询接口、积分查询接口 和 成长值查询接口，然后汇总数据统一返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用过程如下图所示：&lt;img data-ratio=&quot;2.184049079754601&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5hq0iaKg80FgbtoMf7wY5zmvNqrtTugs0tLoibbGIgU0CEUI1mRC8v7caqGNrdKRRiaO69tQ13jTjvOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;326&quot;/&gt;调用远程接口总耗时 530ms = 200ms + 150ms + 180ms&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然这种串行调用远程接口性能是非常不好的，调用远程接口总的耗时为所有的远程接口耗时之和。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么如何优化远程接口性能呢？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.1 并行调用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面说到，既然串行调用多个远程接口性能很差，为什么不改成并行呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5012285012285013&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5hq0iaKg80FgbtoMf7wY5zmvUC155A7eBbGB76ho3DX2KE2vptrOxuOXfibsibcwL9zJac4CI9w8YS5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;814&quot;/&gt;调用远程接口总耗时 200ms = 200ms（即耗时最长的那次远程接口调用）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java8之前可以通过实现&lt;code&gt;Callable&lt;/code&gt;接口，获取线程返回结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;java8以后通过&lt;code&gt;CompleteFuture&lt;/code&gt;类实现该功能。我们这里以CompleteFuture为例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; UserInfo &lt;span&gt;getUserInfo&lt;/span&gt;&lt;span&gt;(Long id)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException, ExecutionException &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; UserInfo userInfo = &lt;span&gt;new&lt;/span&gt; UserInfo();&lt;br/&gt;    CompletableFuture userFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        getRemoteUserAndFill(id, userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;&lt;br/&gt;    CompletableFuture bonusFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        getRemoteBonusAndFill(id, userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;&lt;br/&gt;    CompletableFuture growthFuture = CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        getRemoteGrowthAndFill(id, userInfo);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;    CompletableFuture.allOf(userFuture, bonusFuture, growthFuture).join();&lt;br/&gt;&lt;br/&gt;    userFuture.get();&lt;br/&gt;    bonusFuture.get();&lt;br/&gt;    growthFuture.get();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; userInfo;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;温馨提醒一下，这两种方式别忘了使用线程池。示例中我用到了executor，表示自定义的线程池，为了防止高并发场景下，出现线程过多的问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.2 数据异构&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面说到的用户信息查询接口需要调用用户查询接口、积分查询接口 和 成长值查询接口，然后汇总数据统一返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，我们能不能把数据冗余一下，把用户信息、积分和成长值的数据统一存储到一个地方，比如：redis，存的数据结构就是用户信息查询接口所需要的内容。然后通过用户id，直接从redis中查询数据出来，不就OK了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在高并发的场景下，为了提升接口性能，远程接口调用大概率会被去掉，而改成保存冗余数据的数据异构方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5hq0iaKg80FgbtoMf7wY5zmv0ezkxYJrZsexYiciaxOH0lCRdMTIsG6OyWKjgCwPr16GA2YibQqNmQS1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;780&quot;/&gt;但需要注意的是，如果使用了数据异构方案，就可能会出现数据一致性问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户信息、积分和成长值有更新的话，大部分情况下，会先更新到数据库，然后同步到redis。但这种跨库的操作，可能会导致两边数据不一致的情况产生。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 重复调用&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;重复调用&lt;/code&gt;在我们的日常工作代码中可以说随处可见，但如果没有控制好，会非常影响接口的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不信，我们一起看看。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.1 循环查数据库&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们需要从指定的用户集合中，查询出有哪些是在数据库中已经存在的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现代码可以这样写：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;User&amp;gt; &lt;span&gt;queryUser&lt;/span&gt;&lt;span&gt;(List&amp;lt;User&amp;gt; searchList)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (CollectionUtils.isEmpty(searchList)) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Collections.emptyList();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    List&amp;lt;User&amp;gt; result = Lists.newArrayList();&lt;br/&gt;    searchList.forEach(user -&amp;gt; result.add(userMapper.getUserById(user.getId())));&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里如果有50个用户，则需要循环50次，去查询数据库。我们都知道，每查询一次数据库，就是一次远程调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果查询50次数据库，就有50次远程调用，这是非常耗时的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，我们如何优化呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;User&amp;gt; &lt;span&gt;queryUser&lt;/span&gt;&lt;span&gt;(List&amp;lt;User&amp;gt; searchList)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (CollectionUtils.isEmpty(searchList)) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Collections.emptyList();&lt;br/&gt;    }&lt;br/&gt;    List&amp;lt;Long&amp;gt; ids = searchList.stream().map(User::getId).collect(Collectors.toList());&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; userMapper.getUserByIds(ids);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提供一个根据用户id集合批量查询用户的接口，只远程调用一次，就能查询出所有的数据。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里有个需要注意的地方是：id集合的大小要做限制，最好一次不要请求太多的数据。要根据实际情况而定，建议控制每次请求的记录条数在500以内。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.2 死循环&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些小伙伴看到这个标题，可能会感到有点意外，死循环也算？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码中不是应该避免死循环吗？为啥还是会产生死循环？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候死循环是我们自己写的，例如下面这段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(condition) {&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;do samething&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里使用了while(true)的循环调用，这种写法在&lt;code&gt;CAS自旋锁&lt;/code&gt;中使用比较多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当满足condition等于true的时候，则自动退出该循环。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果condition条件非常复杂，一旦出现判断不正确，或者少写了一些逻辑判断，就可能在某些场景下出现死循环的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出现死循环，大概率是开发人员人为的bug导致的，不过这种情况很容易被测出来。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;还有一种隐藏的比较深的死循环，是由于代码写的不太严谨导致的。如果用正常数据，可能测不出问题，但一旦出现异常数据，就会立即出现死循环。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;4.3 无限递归&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想要打印某个分类的所有父分类，可以用类似这样的递归方法实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;printCategory&lt;/span&gt;&lt;span&gt;(Category category)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(category == &lt;span&gt;null&lt;/span&gt; &lt;br/&gt;      || category.getParentId() == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;  } &lt;br/&gt;  System.out.println(&lt;span&gt;&quot;父分类名称：&quot;&lt;/span&gt;+ category.getName());&lt;br/&gt;  Category parent = categoryMapper.getCategoryById(category.getParentId());&lt;br/&gt;  printCategory(parent);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常情况下，这段代码是没有问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果某次有人误操作，把某个分类的parentId指向了它自己，这样就会出现无限递归的情况。导致接口一直不能返回数据，最终会发生堆栈溢出。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;建议写递归方法时，设定一个递归的深度，比如：分类最大等级有4级，则深度可以设置为4。然后在递归方法中做判断，如果深度大于4时，则自动返回，这样就能避免无限循环的情况。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 异步处理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们接口性能优化，需要重新梳理一下业务逻辑，看看是否有设计上不太合理的地方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如有个用户请求接口中，需要做业务操作，发站内通知，和记录操作日志。为了实现起来比较方便，通常我们会将这些逻辑放在接口中同步执行，势必会对接口性能造成一定的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接口内部流程图如下：&lt;img data-ratio=&quot;2.1298701298701297&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5hq0iaKg80FgbtoMf7wY5zmvH95SZ8wbDpYibyk0ic5fwxEAIXum7tVW3dTv8TzqysJ5dCtmDcVYBkkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;308&quot;/&gt;这个接口表面上看起来没有问题，但如果你仔细梳理一下业务逻辑，会发现只有业务操作才是&lt;code&gt;核心逻辑&lt;/code&gt;，其他的功能都是&lt;code&gt;非核心逻辑&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在这里有个原则就是：核心逻辑可以同步执行，同步写库。非核心逻辑，可以异步执行，异步写库。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这个例子中，发站内通知和用户操作日志功能，对实时性要求不高，即使晚点写库，用户无非是晚点收到站内通知，或者运营晚点看到用户操作日志，对业务影响不大，所以完全可以异步处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常异步主要有两种：&lt;code&gt;多线程&lt;/code&gt; 和 &lt;code&gt;mq&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.1 线程池&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;线程池&lt;/code&gt;改造之后，接口逻辑如下：&lt;img data-ratio=&quot;0.6271929824561403&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5hq0iaKg80FgbtoMf7wY5zmvGeCa4OT7u2MBBfLD20m224k9T2OGuRXOxvwnaTzicqgvLetFyCzkCtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;912&quot;/&gt;发站内通知和用户操作日志功能，被提交到了两个单独的线程池中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样接口中重点关注的是业务操作，把其他的逻辑交给线程异步执行，这样改造之后，让接口性能瞬间提升了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但使用线程池有个小问题就是：如果服务器重启了，或者是需要被执行的功能出现异常了，无法重试，会丢数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这个问题该怎么办呢？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;5.2 mq&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用&lt;code&gt;mq&lt;/code&gt;改造之后，接口逻辑如下：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5747126436781609&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5hq0iaKg80FgbtoMf7wY5zmvQJiaJkosJoofluGNxU0OgVcV1qKUvIExt1ZUezFWegnlK1QjkwvqE2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1218&quot;/&gt;对于发站内通知和用户操作日志功能，在接口中并没真正实现，它只发送了mq消息到mq服务器。然后由mq消费者消费消息时，才真正的执行这两个功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样改造之后，接口性能同样提升了，因为发送mq消息速度是很快的，我们只需关注业务操作的代码即可。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 避免大事务&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多小伙伴在使用spring框架开发项目时，为了方便，喜欢使用&lt;code&gt;@Transactional&lt;/code&gt;注解提供事务功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，使用@Transactional注解这种声明式事务的方式提供事务功能，确实能少写很多代码，提升开发效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但也容易造成大事务，引发其他的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面用一张图看看大事务引发的问题。&lt;img data-ratio=&quot;0.2759259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5hq0iaKg80FgbtoMf7wY5zmvQ3FrvLJETJGpgeUfCjqWXymLqtl89avXvfc3QjRxJQupxLQd2n5Mqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;从图中能够看出，大事务问题可能会造成接口超时，对接口的性能有直接的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们该如何优化大事务呢？&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;少用@Transactional注解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将查询(select)方法放到事务外&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务中避免远程调用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事务中避免一次性处理太多数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有些功能可以非事务执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有些功能可以异步处理&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于大事务问题我的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247490259&amp;amp;idx=1&amp;amp;sn=1dd11c5f49103ca303a61fc82ce406e0&amp;amp;chksm=c0ebc23bf79c4b2db58b28ef752560bd91a1932ceb6713c9b19b821db0f29e1c58275d334076&amp;amp;token=2041133408&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;让人头痛的大事务问题到底要如何解决？&lt;/a&gt;》，它里面做了非常详细的介绍，如果大家感兴趣可以看看。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. 锁粒度&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在某些业务场景中，为了防止多个线程并发修改某个共享数据，造成数据异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决并发场景下，多个线程同时修改数据，造成数据不一致的情况。通常情况下，我们会：&lt;code&gt;加锁&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果锁加得不好，导致锁的粒度太粗，也会非常影响接口性能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7.1 synchronized&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java中提供了&lt;code&gt;synchronized&lt;/code&gt;关键字给我们的代码加锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常有两种写法：&lt;code&gt;在方法上加锁&lt;/code&gt; 和 &lt;code&gt;在代码块上加锁&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看看如何在方法上加锁：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;doSave&lt;/span&gt;&lt;span&gt;(String fileUrl)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    mkdir();&lt;br/&gt;    uploadFile(fileUrl);&lt;br/&gt;    sendMessage(fileUrl);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里加锁的目的是为了防止并发的情况下，创建了相同的目录，第二次会创建失败，影响业务功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这种直接在方法上加锁，锁的粒度有点粗。因为doSave方法中的上传文件和发消息方法，是不需要加锁的。只有创建目录方法，才需要加锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道文件上传操作是非常耗时的，如果将整个方法加锁，那么需要等到整个方法执行完之后才能释放锁。显然，这会导致该方法的性能很差，变得得不偿失。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，我们可以改成在代码块上加锁了，具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSave&lt;/span&gt;&lt;span&gt;(String path,String fileUrl)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt;(!exists(path)) {&lt;br/&gt;          mkdir(path);&lt;br/&gt;       }&lt;br/&gt;    }&lt;br/&gt;    uploadFile(fileUrl);&lt;br/&gt;    sendMessage(fileUrl);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样改造之后，锁的粒度一下子变小了，只有并发创建目录功能才加了锁。而创建目录是一个非常快的操作，即使加锁对接口的性能影响也不大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最重要的是，其他的上传文件和发送消息功能，任然可以并发执行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，这种做在单机版的服务中，是没有问题的。但现在部署的生产环境，为了保证服务的稳定性，一般情况下，同一个服务会被部署在多个节点中。如果哪天挂了一个节点，其他的节点服务任然可用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多节点部署避免了因为某个节点挂了，导致服务不可用的情况。同时也能分摊整个系统的流量，避免系统压力过大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时它也带来了新的问题：synchronized只能保证一个节点加锁是有效的，但如果有多个节点如何加锁呢?&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：这就需要使用：&lt;code&gt;分布式锁&lt;/code&gt;了。目前主流的分布式锁包括：redis分布式锁、zookeeper分布式锁 和 数据库分布式锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于zookeeper分布式锁的性能不太好，真实业务场景用的不多，这里先不讲。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面聊一下redis分布式锁。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7.2 redis分布式锁&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式系统中，由于redis分布式锁相对于更简单和高效，成为了分布式锁的首先，被我们用到了很多实际业务场景当中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用redis分布式锁的伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSave&lt;/span&gt;&lt;span&gt;(String path,String fileUrl)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    String result = jedis.set(lockKey, requestId, &lt;span&gt;&quot;NX&quot;&lt;/span&gt;, &lt;span&gt;&quot;PX&quot;&lt;/span&gt;, expireTime);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;OK&quot;&lt;/span&gt;.equals(result)) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt;(!exists(path)) {&lt;br/&gt;         mkdir(path);&lt;br/&gt;         uploadFile(fileUrl);&lt;br/&gt;         sendMessage(fileUrl);&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;  } &lt;span&gt;finally&lt;/span&gt;{&lt;br/&gt;      unlock(lockKey,requestId);&lt;br/&gt;  }  &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;跟之前使用&lt;code&gt;synchronized&lt;/code&gt;关键字加锁时一样，这里锁的范围也太大了，换句话说就是锁的粒度太粗，这样会导致整个方法的执行效率很低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实只有创建目录的时候，才需要加分布式锁，其余代码根本不用加锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是，我们需要优化一下代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSave&lt;/span&gt;&lt;span&gt;(String path,String fileUrl)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;.tryLock()) {&lt;br/&gt;      mkdir(path);&lt;br/&gt;   }&lt;br/&gt;   uploadFile(fileUrl);&lt;br/&gt;   sendMessage(fileUrl);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;tryLock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    String result = jedis.set(lockKey, requestId, &lt;span&gt;&quot;NX&quot;&lt;/span&gt;, &lt;span&gt;&quot;PX&quot;&lt;/span&gt;, expireTime);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;OK&quot;&lt;/span&gt;.equals(result)) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;  } &lt;span&gt;finally&lt;/span&gt;{&lt;br/&gt;      unlock(lockKey,requestId);&lt;br/&gt;  }  &lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面代码将加锁的范围缩小了，只有创建目录时才加了锁。这样看似简单的优化之后，接口性能能提升很多。说不定，会有意外的惊喜喔。哈哈哈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;redis分布式锁虽说好用，但它在使用时，有很多注意的细节，隐藏了很多坑，如果稍不注意很容易踩中。详细内容可以看看我的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247490430&amp;amp;idx=1&amp;amp;sn=a1f42f9a981a8f161941a6472f317b10&amp;amp;chksm=c0ebc396f79c4a801a330917ca700e7d7a6af3a3c2c5a4e11a05770da925de8aa9ed3c277737&amp;amp;token=2041133408&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;聊聊redis分布式锁的8大坑&lt;/a&gt;》&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;7.3 数据库分布式锁&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mysql数据库中主要有三种锁：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;表锁：加锁快，不会出现死锁。但锁定粒度大，发生锁冲突的概率最高，并发度最低。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;行锁：加锁慢，会出现死锁。但锁定粒度最小，发生锁冲突的概率最低，并发度也最高。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;间隙锁：开销和加锁时间界于表锁和行锁之间。它会出现死锁，锁定粒度界于表锁和行锁之间，并发度一般。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并发度越高，意味着接口性能越好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以数据库锁的优化方向是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优先使用&lt;code&gt;行锁&lt;/code&gt;，其次使用&lt;code&gt;间隙锁&lt;/code&gt;，再其次使用&lt;code&gt;表锁&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;赶紧看看，你用对了没？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.分页处理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候我会调用某个接口批量查询数据，比如：通过用户id批量查询出用户信息，然后给这些用户送积分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果你一次性查询的用户数量太多了，比如一次查询2000个用户的数据。参数中传入了2000个用户的id，远程调用接口，会发现该用户查询接口经常超时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;User&amp;gt; users = remoteCallUser(ids);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，调用接口从数据库获取数据，是需要经过网络传输的。如果数据量太大，无论是获取数据的速度，还是网络传输受限于带宽，都会导致耗时时间比较长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，这种情况要如何优化呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：&lt;code&gt;分页处理&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将一次获取所有的数据的请求，改成分多次获取，每次只获取一部分用户的数据，最后进行合并和汇总。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，处理这个问题，要分为两种场景：&lt;code&gt;同步调用&lt;/code&gt; 和 &lt;code&gt;异步调用&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;8.1 同步调用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在&lt;code&gt;job&lt;/code&gt;中需要获取2000个用户的信息，它要求只要能正确获取到数据就好，对获取数据的总耗时要求不太高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但对每一次远程接口调用的耗时有要求，不能大于500ms，不然会有邮件预警。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，我们可以同步分页调用批量查询用户信息接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体示例代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;List&amp;lt;Long&amp;gt;&amp;gt; allIds = Lists.partition(ids,&lt;span&gt;200&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt;(List&amp;lt;Long&amp;gt; batchIds:allIds) {&lt;br/&gt;   List&amp;lt;User&amp;gt; users = remoteCallUser(batchIds);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码中我用的&lt;code&gt;google&lt;/code&gt;的&lt;code&gt;guava&lt;/code&gt;工具中的&lt;code&gt;Lists.partition&lt;/code&gt;方法，用它来做分页简直太好用了，不然要巴拉巴拉写一大堆分页的代码。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;8.2 异步调用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是在&lt;code&gt;某个接口&lt;/code&gt;中需要获取2000个用户的信息，它考虑的就需要更多一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了需要考虑远程调用接口的耗时之外，还需要考虑该接口本身的总耗时，也不能超时500ms。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候用上面的同步分页请求远程接口，肯定是行不通的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，只能使用&lt;code&gt;异步调用&lt;/code&gt;了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;List&amp;lt;Long&amp;gt;&amp;gt; allIds = Lists.partition(ids,&lt;span&gt;200&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;final&lt;/span&gt; List&amp;lt;User&amp;gt; result = Lists.newArrayList();&lt;br/&gt;allIds.stream().forEach((batchIds) -&amp;gt; {&lt;br/&gt;   CompletableFuture.supplyAsync(() -&amp;gt; {&lt;br/&gt;        result.addAll(remoteCallUser(batchIds));&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;    }, executor);&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用CompletableFuture类，多个线程异步调用远程接口，最后汇总结果统一返回。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.加缓存&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决接口性能问题，&lt;code&gt;加缓存&lt;/code&gt;是一个非常高效的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但不能为了缓存而缓存，还是要看具体的业务场景。毕竟加了缓存，会导致接口的复杂度增加，它会带来数据不一致问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在有些并发量比较低的场景中，比如用户下单，可以不用加缓存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有些场景，比如在商城首页显示商品分类的地方，假设这里的分类是调用接口获取到的数据，但页面暂时没有做静态化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果查询分类树的接口没有使用缓存，而直接从数据库查询数据，性能会非常差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么如何使用缓存呢？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;9.1 redis缓存&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下，我们使用最多的缓存可能是：&lt;code&gt;redis&lt;/code&gt;和&lt;code&gt;memcached&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但对于java应用来说，绝大多数都是使用的redis，所以接下来我们以redis为例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于在关系型数据库，比如：mysql中，菜单是有上下级关系的。某个四级分类是某个三级分类的子分类，这个三级分类，又是某个二级分类的子分类，而这个二级分类，又是某个一级分类的子分类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种存储结构决定了，想一次性查出这个分类树，并非是一件非常容易的事情。这就需要使用程序递归查询了，如果分类多的话，这个递归是比较耗时的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，如果每次都直接从数据库中查询分类树的数据，是一个非常耗时的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时我们可以使用缓存，大部分情况，接口都直接从缓存中获取数据。操作redis可以使用成熟的框架，比如：jedis和redisson等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用jedis伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String json = jedis.get(key);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(StringUtils.isNotEmpty(json)) {&lt;br/&gt;   CategoryTree categoryTree = JsonUtil.toObject(json);&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; categoryTree;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; queryCategoryTreeFromDb();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先从redis中根据某个key查询是否有菜单数据，如果有则转换成对象，直接返回。如果redis中没有查到菜单数据，则再从数据库中查询菜单数据，有则返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，我们还需要有个job每隔一段时间，从数据库中查询菜单数据，更新到redis当中，这样以后每次都能直接从redis中获取菜单的数据，而无需访问数据库了。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7819548872180451&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5hq0iaKg80FgbtoMf7wY5zmvb6m2T6ibqH0kOITLsSE7VBicLP6nIvClJwnIvTFiaACl5Q7s9QbkTCf8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1064&quot;/&gt;这样改造之后，能快速的提升性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这样做性能提升不是最佳的，还有其他的方案，我们一起看看下面的内容。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;9.2 二级缓存&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的方案是基于redis缓存的，虽说redis访问速度很快。但毕竟是一个远程调用，而且菜单树的数据很多，在网络传输的过程中，是有些耗时的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有没有办法，不经过请求远程，就能直接获取到数据呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：使用&lt;code&gt;二级缓存&lt;/code&gt;，即基于内存的缓存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了自己手写的内存缓存之后，目前使用比较多的内存缓存框架有：guava、Ehcache、caffine等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在这里以&lt;code&gt;caffeine&lt;/code&gt;为例，它是spring官方推荐的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步，引入caffeine的相关jar包&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;spring-boot-starter-cache&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;com.github.ben-manes.caffeine&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;caffeine&amp;lt;/artifactId&amp;gt;&lt;br/&gt;    &amp;lt;version&amp;gt;&lt;span&gt;2.6&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步，配置CacheManager，开启EnableCaching&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@EnableCaching&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CacheConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; CacheManager &lt;span&gt;cacheManager&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        CaffeineCacheManager cacheManager = &lt;span&gt;new&lt;/span&gt; CaffeineCacheManager();&lt;br/&gt;        &lt;span&gt;//Caffeine配置&lt;/span&gt;&lt;br/&gt;        Caffeine&amp;lt;Object, Object&amp;gt; caffeine = Caffeine.newBuilder()&lt;br/&gt;                &lt;span&gt;//最后一次写入后经过固定时间过期&lt;/span&gt;&lt;br/&gt;                .expireAfterWrite(&lt;span&gt;10&lt;/span&gt;, TimeUnit.SECONDS)&lt;br/&gt;                &lt;span&gt;//缓存的最大条数&lt;/span&gt;&lt;br/&gt;                .maximumSize(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;        cacheManager.setCaffeine(caffeine);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; cacheManager;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三步，使用Cacheable注解获取数据&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CategoryService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;   &lt;br/&gt;   &lt;span&gt;@Cacheable&lt;/span&gt;(value = &lt;span&gt;&quot;category&quot;&lt;/span&gt;, key = &lt;span&gt;&quot;#categoryKey&quot;&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; CategoryModel &lt;span&gt;getCategory&lt;/span&gt;&lt;span&gt;(String categoryKey)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;      String json = jedis.get(categoryKey);&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt;(StringUtils.isNotEmpty(json)) {&lt;br/&gt;         CategoryTree categoryTree = JsonUtil.toObject(json);&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; categoryTree;&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; queryCategoryTreeFromDb();&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用categoryService.getCategory()方法时，先从caffine缓存中获取数据，如果能够获取到数据，则直接返回该数据，不进入方法体。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不能获取到数据，则再从redis中查一次数据。如果查询到了，则返回数据，并且放入caffine中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果还是没有查到数据，则直接从数据库中获取到数据，然后放到caffine缓存中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体流程图如下：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.653566229985444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5hq0iaKg80FgbtoMf7wY5zmvBRreB8lwkw5bicBwoFrnQC3pOXmEzyAUSgEpQOBicpoNHBEYMldu2AIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1374&quot;/&gt;该方案的性能更好，但有个缺点就是，如果数据更新了，不能及时刷新缓存。此外，如果有多台服务器节点，可能存在各个节点上数据不一样的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此可见，二级缓存给我们带来性能提升的同时，也带来了数据不一致的问题。使用二级缓存一定要结合实际的业务场景，并非所有的业务场景都适用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但上面我列举的分类场景，是适合使用二级缓存的。因为它属于用户不敏感数据，即使出现了稍微有点数据不一致也没有关系，用户有可能都没有察觉出来。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10. 分库分表&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，接口性能受限的不是别的，而是数据库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当系统发展到一定的阶段，用户并发量大，会有大量的数据库请求，需要占用大量的数据库连接，同时会带来磁盘IO的性能瓶颈问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，随着用户数量越来越多，产生的数据也越来越多，一张表有可能存不下。由于数据量太大，sql语句查询数据时，即使走了索引也会非常耗时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：需要做&lt;code&gt;分库分表&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8426103646833013&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibJZVicC7nz5hq0iaKg80FgbtoMf7wY5zmvuiabrBQQ72tdwNFzaBSpWm4EjQ5RWOLZafCpKvibFiceuPk2CXibNXoQpw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1042&quot;/&gt;图中将用户库拆分成了三个库，每个库都包含了四张用户表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有用户请求过来的时候，先根据用户id路由到其中一个用户库，然后再定位到某张表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;路由的算法挺多的：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;根据id取模&lt;/code&gt;，比如：id=7，有4张表，则7%4=3，模为3，路由到用户表3。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;给id指定一个区间范围&lt;/code&gt;，比如：id的值是0-10万，则数据存在用户表0，id的值是10-20万，则数据存在用户表1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;一致性hash算法&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分库分表主要有两个方向：&lt;code&gt;垂直&lt;/code&gt;和&lt;code&gt;水平&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说实话垂直方向（即业务方向）更简单。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在水平方向（即数据方向）上，分库和分表的作用，其实是有区别的，不能混为一谈。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;分库&lt;/code&gt;：是为了解决数据库连接资源不足问题，和磁盘IO的性能瓶颈问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;分表&lt;/code&gt;：是为了解决单表数据量太大，sql语句查询数据时，即使走了索引也非常耗时问题。此外还可以解决消耗cpu资源问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;分库分表&lt;/code&gt;：可以解决 数据库连接资源不足、磁盘IO的性能瓶颈、检索数据耗时 和 消耗cpu资源等问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在有些业务场景中，用户并发量很大，但是需要保存的数据量很少，这时可以只分库，不分表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在有些业务场景中，用户并发量不大，但是需要保存的数量很多，这时可以只分表，不分库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在有些业务场景中，用户并发量大，并且需要保存的数量也很多时，可以分库分表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于分库分表更详细的内容，可以看看我另一篇文章，里面讲的更深入《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247490459&amp;amp;idx=1&amp;amp;sn=1e4296228c00aa4203aab481575ac916&amp;amp;chksm=c0ebc373f79c4a658de7ce7f0d8cf30b1f45adb346c2386321779e7cf85a757a12337d3ae233&amp;amp;token=2041133408&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;阿里二面：为什么分库分表？&lt;/a&gt;》&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11. 辅助功能&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优化接口性能问题，除了上面提到的这些常用方法之外，还需要配合使用一些辅助功能，因为它们真的可以帮我们提升查找问题的效率。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;11.1 开启慢查询日志&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常情况下，为了定位sql的性能瓶颈，我们需要开启mysql的慢查询日志。把超过指定时间的sql语句，单独记录下来，方面以后分析和定位问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开启慢查询日志需要重点关注三个参数：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;slow_query_log&lt;/code&gt; 慢查询开关&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;slow_query_log_file&lt;/code&gt; 慢查询日志存放的路径&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;long_query_time&lt;/code&gt; 超过多少秒才会记录日志&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过mysql的&lt;code&gt;set&lt;/code&gt;命令可以设置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;set&lt;/span&gt; &lt;span&gt;global&lt;/span&gt; slow_query_log=&lt;span&gt;&#x27;ON&#x27;&lt;/span&gt;; &lt;br/&gt;&lt;span&gt;set&lt;/span&gt; &lt;span&gt;global&lt;/span&gt; slow_query_log_file=&lt;span&gt;&#x27;/usr/local/mysql/data/slow.log&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;set&lt;/span&gt; &lt;span&gt;global&lt;/span&gt; long_query_time=&lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置完之后，如果某条sql的执行时间超过了2秒，会被自动记录到slow.log文件中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然也可以直接修改配置文件&lt;code&gt;my.cnf&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[mysqld]&lt;br/&gt;slow_query_log = ON&lt;br/&gt;slow_query_log_file = /usr/local/mysql/data/slow.log&lt;br/&gt;long_query_time = &lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这种方式需要重启mysql服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多公司每天早上都会发一封慢查询日志的邮件，开发人员根据这些信息优化sql。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;11.2 加监控&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了出现sql问题时，能够让我们及时发现，我们需要对系统做&lt;code&gt;监控&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前业界使用比较多的开源监控系统是：&lt;code&gt;Prometheus&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它提供了 &lt;code&gt;监控&lt;/code&gt; 和 &lt;code&gt;预警&lt;/code&gt; 的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;架构图如下：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6002960769800149&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5hq0iaKg80FgbtoMf7wY5zmveKgibicKeEd0zE2pSVGDVtLqyjb4qLhFq6WEibiaeb4eqSkQpzBt0M7NTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1351&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以用它监控如下信息：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;接口响应时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;调用第三方服务耗时&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;慢查询sql耗时&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;cpu使用情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内存使用情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;磁盘使用情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据库使用情况&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;等等。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的界面大概长这样子：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5218508997429306&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5hq0iaKg80FgbtoMf7wY5zmv5ggL9a2ibibxk37Cwa9nUkjzgBWGsLwrXAOnicGicnOSpAN2bMBWs0eicMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;778&quot;/&gt;可以看到mysql当前qps，活跃线程数，连接数，缓存池的大小等信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果发现数据量连接池占用太多，对接口的性能肯定会有影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时可能是代码中开启了连接忘了关，或者并发量太大了导致的，需要做进一步排查和系统优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;截图中只是它一小部分功能，如果你想了解更多功能，可以访问Prometheus的官网：https://prometheus.io/&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;11.3 链路跟踪&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候某个接口涉及的逻辑很多，比如：查数据库、查redis、远程调用接口，发mq消息，执行业务代码等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该接口一次请求的链路很长，如果逐一排查，需要花费大量的时间，这时候，我们已经没法用传统的办法定位问题了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有没有办法解决这问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用分布式链路跟踪系统：&lt;code&gt;skywalking&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;架构图如下：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5hq0iaKg80FgbtoMf7wY5zmvb7yX6Aql7Zwzym9AQMvr9qx8DaElAK7G7z9tLVW53C0n2xq72CQxdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot;/&gt;通过skywalking定位性能问题：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4390787518573551&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5hq0iaKg80FgbtoMf7wY5zmv5dGuiccQBUC6nvQs0c5MXpCELfqEQIiaX5lD37ZGUhw0GALQzLbmvvBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1346&quot;/&gt;在skywalking中可以通过&lt;code&gt;traceId&lt;/code&gt;（全局唯一的id），串联一个接口请求的完整链路。可以看到整个接口的耗时，调用的远程服务的耗时，访问数据库或者redis的耗时等等，功能非常强大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前没有这个功能的时候，为了定位线上接口性能问题，我们还需要在代码中加日志，手动打印出链路中各个环节的耗时情况，然后再逐一排查。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你用过skywalking排查接口性能问题，不自觉的会爱上它的。如果你想了解更多功能，可以访问skywalking的官网：https://skywalking.apache.org/&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a00c002043dd060a0abcc630e23eefbc</guid>
<title>2021 年最佳开源软件榜单｜InfoWorld</title>
<link>https://toutiao.io/k/swk6nu6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;公众号关注 “GitHubDaily”&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;设为 “&lt;/span&gt;&lt;span&gt;星标&lt;/span&gt;&lt;span&gt;”，每天带你逛 GitHub！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5586919104991395&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28hE3B6lk6RsU4AB7MicaKzBBF3D00fl6XugUa850hyWtEfPMBYaXU9teAnScurbhB4Qz8RYJ9ricbxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2905&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;来自OSC社区&lt;/span&gt;&lt;/section&gt;&lt;p cid=&quot;n2&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;大家好，我是小 G。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n3&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;作为一家信息技术媒体公司，InfoWorld 成立于 1978 年，目前隶属于 IDG。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n4&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;每年。InfoWorld 都会根据软件对开源界的贡献，以及在业界的影响力评选出当年的 “最佳开源软件” (BOSSIE)，该奖项评选已经延续了十多年。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n5&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;本次获奖的 29 个开源项目包括：软件开发、开发、云原生计算、机器学习等类型，下面我们一起来看看，有没有熟悉的面孔！&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n6&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;1、Svelte 和 SvelteKit&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n7&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcL7Evia8qqK8QRjuC1JSsofFCtSG2Nb3HxqJK9Y5sDv1VQScibDckS2lmA/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcL7Evia8qqK8QRjuC1JSsofFCtSG2Nb3HxqJK9Y5sDv1VQScibDckS2lmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n8&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在众多创新的、开源的、前端的 JavaScript 框架中，Svelte 及其全栈对应的 SvelteKit 可能是最有野心和远见的。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n9&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Svelte 一开始就通过采用编译时策略来颠覆现状，并以出色的性能、持续的发展和卓越的开发者体验向前迈进。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n10&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;SvelteKit 现已进入公测阶段，它延续了 Svelte 的传统，通过采用最新的工具，并将部署到无服务器环境作为一项内置功能来实现飞跃。&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n11&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n12&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/sveltejs/svelte&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n13&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2、Minikube&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n14&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLrIvl9n4cibknXZ1NqSIqDv1AIZHfkQic6TrPFXN7ibmH6cjqwweKMouog/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLrIvl9n4cibknXZ1NqSIqDv1AIZHfkQic6TrPFXN7ibmH6cjqwweKMouog/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.6666666666666666&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n15&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Minikube 是一个易于在本地运行 Kubernetes 的工具，可在你的笔记本电脑上的虚拟机内轻松创建单机版 Kubernetes 集群。便于尝试 Kubernetes 或使用 Kubernetes 日常开发。&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n16&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n17&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/kubernetes/minikube&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n18&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;3、Pixie&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n19&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLjwRTOsxL7riau9eWj1aWRia2icTT8DlJG2ueAzWRiae5BcwWgiam3duh1Tg/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLjwRTOsxL7riau9eWj1aWRia2icTT8DlJG2ueAzWRiae5BcwWgiam3duh1Tg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n20&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Pixie 是 Kubernetes 应用的可观察性工具，它可以查看集群的高级状态，如服务地图、集群资源和应用流量；还可以深入到更详细的视图，如 pod 状态、火焰图和单个 full-body 应用请求。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n21&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Pixie 使用 eBPF 自动收集遥测数据，它在集群本地收集、存储和查询所有的遥测数据，使用不到 5% 的集群 CPU。Pixie 的用例包括集群内的网络监控、基础设施健康、服务性能和数据库查询剖析。&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n22&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n23&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/pixie-io/pixie&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n24&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;4、FastAPI&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n25&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLNybFeKB5yJdurDia8ibRa0iczpicOaS9B0uiaqaxiaAmtkeErmH0O4aw4iblg/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLNybFeKB5yJdurDia8ibRa0iczpicOaS9B0uiaqaxiaAmtkeErmH0O4aw4iblg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n26&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;FastAPI 是一个高性能 Web 框架，用于构建 API。主要特性：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n27&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n29&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;快速：非常高的性能，与 NodeJS 和 Go 相当&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n31&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;快速编码：将功能开发速度提高约 200％ 至 300％&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n33&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;更少的错误：减少约 40％ 的人为错误&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n35&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;直观：强大的编辑器支持，自动补全无处不在，调试时间更少&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n37&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;简易：旨在易于使用和学习，减少阅读文档的时间。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n39&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;简短：减少代码重复。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n41&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;稳健：获取可用于生产环境的代码，具有自动交互式文档&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n43&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;基于标准：基于并完全兼容 API 的开放标准 OpenAPI 和 JSON Schema&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote cid=&quot;n44&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n45&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/tiangolo/fastapi&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n46&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;5、Crystal  &lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n47&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLLSxiaibmTfkSRctOvib8wVskzUZ4rjgRIftnXuyDCj1gweRPgppIORnEQ/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLLSxiaibmTfkSRctOvib8wVskzUZ4rjgRIftnXuyDCj1gweRPgppIORnEQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.6666666666666666&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n48&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;作为一个提供具有 C 语言的速度和 Ruby 语言的表现力的编程语言的项目，Crystal 已经开发了好几年了。随着今年年初 Crystal 1.0 的发布，该语言现在已经足够稳定到可以用于一般工作负载。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n49&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Crystal 使用静态类型和 LLVM 编译器来实现高速度，并避免在运行时出现空引用等常见问题。Crystal 可以与现有的 C 代码接口，以进一步提高速度和便利性，它还可以使用编译时宏来扩展基础语言的语法。&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n50&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n51&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/crystal-lang/crystal&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n52&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;6、Windows Terminal&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n53&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLqY0RFhptUeDYa5G6n7CblNXwPTz5M3OCKKleq9PM5tWsIlE4kOHiaow/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLqY0RFhptUeDYa5G6n7CblNXwPTz5M3OCKKleq9PM5tWsIlE4kOHiaow/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.6666666666666666&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n54&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Windows Terminal 是一个全新的、流行的、功能强大的命令行终端工具。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n55&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;包含很多来社区呼声很高的特性，例如：多 Tab 支持、富文本、多语言支持、可配置、主题和样式，支持 emoji 和基于 GPU 运算的文本渲染等等。同时该终端依然符合我们的目标和要求，以确保它保持快速、高效，并且不会消耗大量内存和电源。&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n56&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n57&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/Microsoft/Terminal&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n58&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;7、OBS Studio&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n59&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLKec5oVQ0RhZeMzZCoT8iasR1IWtN7mPqm1HS7icfbv8eXYTpzuZBPb9w/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLKec5oVQ0RhZeMzZCoT8iasR1IWtN7mPqm1HS7icfbv8eXYTpzuZBPb9w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.6666666666666666&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n60&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;OBS Studio 是一款用于实时流媒体和屏幕录制的软件，为高效捕获，合成，编码，记录和流传输视频内容而设计，支持所有流媒体平台。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n61&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n63&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;高性能实时视频 / 音频捕获和混合。创建由多种来源组成的场景，包括窗口捕获、图像、文本、浏览器窗口、网络摄像头、捕获卡等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n65&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;设置无限数量的场景，用户可以通过自定义过渡无缝切换。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n67&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;带有每个源滤波器的直观音频混合器，例如噪声门，噪声抑制和增益。全面控制 VST 插件支持。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n69&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;强大且易于使用的配置选项。添加新源，复制现有源，并轻松调整其属性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n71&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;精简的设置面板使用户可以访问各种配置选项，以调整广播或录制的各个方面。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n73&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;模块化的 “Dock” UI 允许用户完全根据需要重新排列布局。用户甚至可以将每个单独的 Dock 弹出到自己的窗口中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote cid=&quot;n74&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n75&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/obsproject/obs-studio&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n76&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;8、Shotcut&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n77&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLgRrj3nUYq0zV26WgL2JbgfWyPYn8PCuiaptlaEOzH84X3CyoPKL0KnQ/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLgRrj3nUYq0zV26WgL2JbgfWyPYn8PCuiaptlaEOzH84X3CyoPKL0KnQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n78&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Shotcut 是一款跨平台的视频编辑工具，允许人们在应用效果和分层的同时，对音频和视频轨道进行所有的标准修正。Shotcut 有一个非常活跃的社区，并提供大量的操作视频和指导，以帮助新手和高级摄像师。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n79&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;它可以在 Mac、Linux、BSD 和 Windows 上运行 -- 尽管是跨平台的，但与同类工具相比，它的界面很敏捷，使用起来也相对简单。&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n80&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n81&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/mltframework/shotcut&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n82&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;9、Weave GitOps Core&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n83&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLhzwPQc7YI6icGcdrqDsCuRzyyQRpWLAUYcI19AQf6mln8FTvexsJDAQ/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLhzwPQc7YI6icGcdrqDsCuRzyyQRpWLAUYcI19AQf6mln8FTvexsJDAQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.6666666666666666&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n84&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Weave GitOps 支持有效的 GitOps 工作流，以将应用程序持续交付到 Kubernetes 集群中。它基于领先的 GitOps 引擎 CNCF Flux。&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n85&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n86&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/weaveworks/weave-gitops&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n87&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;10、Apache Solr&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n88&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLpYNuLTJkq0RECBlIe9sjw0HI1Qiatfe2aNdHicUJiclsaPEEjbnABbTiag/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLpYNuLTJkq0RECBlIe9sjw0HI1Qiatfe2aNdHicUJiclsaPEEjbnABbTiag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.6666666666666666&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n89&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Apache Solr  是基于 Lucene 的全文搜索服务器，也是最流行的企业级搜索引擎。Apache Lucene 是你所使用的大部分软件的搜索功能背后的基础搜索技术 -- 包括其他搜索引擎，如 Elasticsearch。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n90&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;与 Elasticsearch 不同的是，Solr 放弃了它的开源许可，不过它仍然是免费的。Solr 是可集群的、可在云端部署的，并且强大到足以建立云端级的搜索服务。它甚至包括 LTR 算法，以帮助自动调整和加权结果。&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n91&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n92&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/apache/solr&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n93&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;11、MLflow&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n94&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLR4JsUQKdNGjYeek9AdnrrRb8eGQ0sFpiaibTnbud5QWxUMSCUk127ylg/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLR4JsUQKdNGjYeek9AdnrrRb8eGQ0sFpiaibTnbud5QWxUMSCUk127ylg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.6666666666666666&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n95&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;MLflow 由 Databricks 创建，并由 Linux 基金会托管，是一个 MLOps 平台，可以让人跟踪、管理和维护各种机器学习模型、实验及其部署。它为你提供了记录和查询实验（代码、数据、配置、结果）的工具，将数据科学代码打包成项目，并将这些项目链入工作流程。&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n96&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n97&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/mlflow/mlflow&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n98&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;12、Orange&lt;/span&gt;&lt;/h3&gt;&lt;h1 cid=&quot;n99&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://tva1.sinaimg.cn/large/008i3skNgy1gwhn4i90jij30u00k0ad3.jpg&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uDRkMWLia28ia5sp4KbsyPiclLnzIraX9C938wR7nwAeJzcIHe3rljOPXeTkUMfKAGnF26wfnYME90LGaHbV2IJtQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p cid=&quot;n100&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Orange 旨在使将数据挖掘 &quot;富有成效且有趣&quot;。Orange 允许用户创建一个数据分析工作流程，执行各种机器学习和分析功能以及可视化。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n101&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;与 R Studio 和 Jupyter 等程序化或文本工具相比，Orange 是非常直观的。你可以将小部件拖到画布上以加载文件，用模型分析数据并将结果可视化。&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n102&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n103&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/biolab/orange3&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n104&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;13、Flutter&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n105&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLWFL3HRDpfzovDzBpfLMIFLKibtTX379JUUKrMiaMOK0bwzQn2Jrlw9Kg/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLWFL3HRDpfzovDzBpfLMIFLKibtTX379JUUKrMiaMOK0bwzQn2Jrlw9Kg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.6666666666666666&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n106&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Flutter 由 Google 的工程师团队打造，用于创建高性能、跨平台的移动应用。Flutter 针对当下以及未来的移动设备进行优化，专注于 Android and iOS 低延迟的输入和高帧率。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n107&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;它可以给开发者提供简单、高效的方式来构建和部署跨平台、高性能移动应用；给用户提供漂亮、快速、jitter-free 的 app 体验。&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n108&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n109&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/flutter&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n110&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;14、Apache Superset&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n111&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLcoUqyPfatQHyqAZc44UoeNSWB4iaZBmpF28FSTSicfEBAmDLvhDqXT2w/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLcoUqyPfatQHyqAZc44UoeNSWB4iaZBmpF28FSTSicfEBAmDLvhDqXT2w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.6666666666666666&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n112&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Apache Superset 是 Airbnb （知名在线房屋短租公司）开源的数据探查与可视化平台（曾用名 Panoramix、Caravel ），该工具在可视化、易用性和交互性上非常有特色，用户可以轻松对数据进行可视化分析。Apache Superset 也是一款企业级商业智能 Web 应用程序。&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n113&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n114&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/apache/superset&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n115&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;15、Presto&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n116&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLd9Twp9x6lib0fbwOdpZyksolibmjiaQ5gRqc1DpC3lWzJ4uMh4CAFXYHQ/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLd9Twp9x6lib0fbwOdpZyksolibmjiaQ5gRqc1DpC3lWzJ4uMh4CAFXYHQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.6666666666666666&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n117&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Presto 是一个开源的分布式 SQL 引擎，用于在线分析处理，在集群中运行。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n118&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Presto 可以查询各种各样的数据源，从文件到数据库，并将结果返回到许多商业智能和分析环境。更重要的是，Presto 允许查询数据所在的地方，包括 Hive、Cassandra、关系型数据库和专有数据存储。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n119&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;一个 Presto 查询可以结合多个来源的数据。Facebook 使用 Presto 对几个内部数据存储进行互动查询，包括他们的 300PB 数据仓库。&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n120&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n121&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/prestodb/presto&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n122&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;16、Apache Arrow&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n123&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLPhZZdZm0bWky9cNKDZoBO8J15RsIyKKic4vK2ktPkmd3R5OicibNyuAWA/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLPhZZdZm0bWky9cNKDZoBO8J15RsIyKKic4vK2ktPkmd3R5OicibNyuAWA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n124&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Apache Arrow 为平面和分层数据定义了一种独立于语言的柱状内存格式，为现代 CPU 和 GPU 上的高效分析操作而组织。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n125&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Arrow 内存格式还支持零拷贝读取，以便在没有序列化开销的情况下进行闪电式的数据访问。Arrow 库可用于 C、C++、C#、Go、Java、JavaScript、Julia、MATLAB、Python、R、Ruby 和 Rust。&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n126&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n127&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/apache/arrow&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n128&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;17、InterpretML&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n129&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLNeAxjDEc29kuH6mDLKP6r1fupv0d2r96NL1ecfgkbMB54J4fjHY4sw/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLNeAxjDEc29kuH6mDLKP6r1fupv0d2r96NL1ecfgkbMB54J4fjHY4sw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.6666666666666666&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n130&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;InterpretML 是一个开源的 Explainable AI（XAI）包，其中包含了几个最先进的机器学习可解释性技术。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n131&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;InterpretML 让你训练可解释的 glassbox 模型并解释黑盒系统。InterpretML 可帮助你了解模型的全局行为，或了解个别预测背后的原因。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n132&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;在它的许多功能中，InterpretML 有一个来自 Microsoft Research 的 &quot;glass box&quot; 模型，称为 Explainable Boosting Machine，它支持用黑盒模型的近似值进行 post-hoc 解释的 Lime。&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n133&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n134&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/interpretml/interpret&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n135&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;18、Lime&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n136&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLNP8zQhL2NHGSgBxGfPDGpYiaBKHYG44qdHOqaw0iaYMTIfLWuQY0KqIg/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLNP8zQhL2NHGSgBxGfPDGpYiaBKHYG44qdHOqaw0iaYMTIfLWuQY0KqIg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n137&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Lime（local interpretable model-agnostic explanations 的简称）是一种 post-hoc 技术，通过扰动输入的特征并检查预测结果来解释任何机器学习分类器的预测。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n138&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Lime 能够解释任何具有两个或更多类的黑盒分类器，其同时适用于文本和图像领域。Lime 也被包含在 InterpretML 中。&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n139&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n140&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/marcotcr/lime&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n141&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;19、Dask&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n142&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLhw4E1ia4ZjAXpRobLU4kh0s3RPEre4dD4OQn9HPZy666LhT5nxWIfkQ/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLhw4E1ia4ZjAXpRobLU4kh0s3RPEre4dD4OQn9HPZy666LhT5nxWIfkQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n143&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Dask 是一个用于并行计算的开源库，可以将 Python 包扩展到多台机器上。Dask 可以将数据和计算分布在多个 GPU 上，无论是在同一个系统中还是在一个多节点集群中。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n144&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Dask 与 Rapids cuDF、XGBoost 和 Rapids cuML 集成，用于 GPU 加速的数据分析和机器学习。它还与 NumPy、Pandas 和 Scikit-learn 集成，以并行化其工作流程&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n145&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n146&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/dask/dask&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n147&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;20、BlazingSQL&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n148&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcL66HUVAiarl5UejFGLDuibPEibSITlKaXDAxoMy4jykFChLfw5ODHUYwJQ/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcL66HUVAiarl5UejFGLDuibPEibSITlKaXDAxoMy4jykFChLfw5ODHUYwJQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n149&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;BlazingSQL 是一个基于 RAPIDS 生态系统构建的 GPU 加速 SQL 引擎。RAPIDS 基于 Apache Arrow 柱状内存格式，cuDF 是一个 GPU DataFrame 库，用于加载、连接、聚合、过滤和操作数据。它是 cuDF 的 SQL 接口，具有支持大规模数据科学工作流和企业数据集的各种功能。&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n150&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n151&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/BlazingDB/blazingsql&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n152&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;21、Rapids&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n153&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLFLoVUKXeD5ZicxCvqickMgmn4bIAnd3LuHQwTXyrZIEBhdJcGfB5ULvA/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLFLoVUKXeD5ZicxCvqickMgmn4bIAnd3LuHQwTXyrZIEBhdJcGfB5ULvA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n154&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Nvidia 的 Rapids 开源软件库和 API 套件让你有能力完全在 GPU 上执行端到端的数据科学和分析管道。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n155&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Rapids 使用 Nvidia CUDA 基元进行底层计算优化，并通过用户友好的 Python 接口暴露了 GPU 的并行性和高带宽内存速度。Rapids 依赖于 Apache Arrow 柱状内存格式，包括 cuDF，一个类似 Pandas 的 DataFrame 库；cuML，一个机器学习库集合，提供 Scikit-learn 中大多数算法的 GPU 版本；以及 cuGraph，一个类似 NetworkX 的加速图分析库&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n156&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n157&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/rapidsai/cudf&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n158&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;22、PostHog&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n159&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLpuPwY9Oy0norPaeEjibUMonPfVOzOibnhO2KreSPISScXuzpFEFV2NPQ/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLpuPwY9Oy0norPaeEjibUMonPfVOzOibnhO2KreSPISScXuzpFEFV2NPQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.6666666666666666&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n160&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;PostHog 是一个为开发人员构建的开源产品分析平台。自动收集你网站或应用程序上的每个事件，无需向第三方发送数据。它在用户级别提供基于事件的分析，捕获你产品的使用数据以查看哪些用户在你的应用程序中执行了哪些操作。它会自动捕获点击次数和综合浏览量，以分析你的用户在做什么，而无需手动推送事件。&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n161&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n162&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/PostHog/posthog&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n163&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;23、LakeFS&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n164&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLUx5eiauxJm6Sx7Gho1yfHdDUVQiaSsuaLZ6vrzkx9ZQZLWrMfwHthZeQ/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLUx5eiauxJm6Sx7Gho1yfHdDUVQiaSsuaLZ6vrzkx9ZQZLWrMfwHthZeQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n165&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;LakeFS 提供了一种 &quot;以管理代码的方式管理你的数据湖&quot; 的方法，为对象存储增加了一层类似于 Git 的版本控制。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n166&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;这种对 Git 语义的应用让用户可以创建自己的隔离的、零拷贝的数据分支，在上面工作、实验和建模分析，而没有破坏共享对象的风险。LakeFS 为你的数据带来了有用的 commit notes、元数据字段和 rollback 选项，同时也带来了维护数据完整性和质量的验证 hooks-- 在一个未提交的分支被意外地合并回生产中之前，运行格式和模式检查。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n167&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;通过 LakeFS，管理和保护代码库的熟悉技术可以扩展到现代数据库，如 Amazon S3 和 Azure Blob 存储。&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n168&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n169&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/treeverse/lakeFS&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n170&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;24、Meltano&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n171&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcL6vbUKO1VMU0vqgmMfmlRcAl77icUt056onzzq35A2T6NvibZhCdNicBaA/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcL6vbUKO1VMU0vqgmMfmlRcAl77icUt056onzzq35A2T6NvibZhCdNicBaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-ratio=&quot;0.6666666666666666&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n172&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Meltano 是今年从 GitLab 中分离出来的，一个免费的开源 DataOps 替代传统 ELT（提取、加载、转换）的工具链。Meltano 的数据仓库框架使得为你的项目建模、提取和转换数据变得容易，并通过内置的分析工具和简化报告的仪表盘来补充集成和转换管道。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n173&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Meltano 提供了一个可靠的提取器和加载器库，以及对 Singer 标准的 data extracting taps 和 data loading targets 的支持，Meltano 已经是一个数据编排的动力源。&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n174&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;25、Trino&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n175&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLguDibC2yK55mB2qFoYD5TJuoqmyDeTqTJiaktEQ8hKqsojJc5jN0mibxw/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLguDibC2yK55mB2qFoYD5TJuoqmyDeTqTJiaktEQ8hKqsojJc5jN0mibxw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n176&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Trino（原名 PrestoSQL）是一个分布式 SQL 分析引擎，能够对大型分布式数据源运行极快的查询。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n177&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Trino 允许你同时对数据湖、关系型存储或多个不同来源执行查询，而不需要复制或移动数据进行处理。而且 Trino 与你的数据科学家可能使用的任何商业智能和分析工具配合得很好，无论是交互式的还是临时性的，最大限度地减少了学习曲线。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n178&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;随着数据工程师努力支持越来越多的数据源的复杂分析，Trino 提供了一种优化查询执行和加速不同来源的结果的方法。&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n179&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n180&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/trinodb/trino&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n181&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;26、StreamNative&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n182&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLZqWUst5ovw5cwSGE7u5biazrgP3awzXEOswwB5Ofd4TR1vvyzPzAsnQ/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLZqWUst5ovw5cwSGE7u5biazrgP3awzXEOswwB5Ofd4TR1vvyzPzAsnQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n183&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;StreamNative 是一个高度可扩展的消息和事件流平台，大大简化了实时报告和分析工具以及企业应用流的数据管道铺设。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n184&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;StreamNative 将 Apache Pulsar 强大的分布式流处理架构与 Kubernetes 和混合云支持等企业额外功能、大型数据连接器库、简易认证和授权以及用于健康和性能监控的专用工具相结合，既简化了基于 Pulsar 的实时应用程序的开发，又简化了大规模消息传递背板的部署和管理。&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n185&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n186&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/streamnative&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n187&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;27、Hugging Face&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n188&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLJJt2d5JkAskzgIaXfnoq6XRiaS04PicDnVuAoOK5ndsW3CuRxkn83ZYQ/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLJJt2d5JkAskzgIaXfnoq6XRiaS04PicDnVuAoOK5ndsW3CuRxkn83ZYQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n189&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;Hugging Face 提供了最重要的开源深度学习资源库，它本身并不是一个深度学习框架。Hugging Face 的目标是扩展到文本之外，支持图像、音频、视频、物体检测等。Infoworld 指出，深度学习从业者应在未来几年内密切关注这个 repo。&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n190&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n191&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/huggingface/transformers&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n192&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;28、EleutherAI&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n193&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLddLicFgMAwVTsIlDdcFtECAcOIgr6pEWbqAlX9ApcbfpicG8VPFYtsxw/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dkwuWwLoRK8TTBZGSDibI4rHU2pJTFibcLddLicFgMAwVTsIlDdcFtECAcOIgr6pEWbqAlX9ApcbfpicG8VPFYtsxw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n194&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;EleutherAI 是一个由机器学习研究人员组成的分布式小组，旨在将 GPT-3 带给所有人。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n195&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;2021 年伊始，EleutherAI 发布了 The Pile，是一个 825 GB 的用于训练的多样化文本数据集；并在 6 月公布了 GPT-J，一个 60 亿参数的模型，大致相当于 OpenAI 的 GPT-3 的 Curie variant。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n196&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;随着 GPT-NeoX 的出现，EleutherAI 计划将参数一直提高到 1750 亿，以与目前最广泛的 GPT-3 模型竞争。&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n197&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n198&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/EleutherAI/gpt-neo&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 cid=&quot;n199&quot; mdtype=&quot;heading&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;29、Colab notebooks for generative art&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n200&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNO6gF8EcqFHTlkwg8FOsoJicj6K2p5bqJSdDc5FoNMdqN3RUARFXP7p11AhOKn2UCOZiaT60hozH8sA/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNO6gF8EcqFHTlkwg8FOsoJicj6K2p5bqJSdDc5FoNMdqN3RUARFXP7p11AhOKn2UCOZiaT60hozH8sA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n201&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;首先是 OpenAI 的 CLIP（对比语言 - 图像预训练）模型，一个用于生成文本和图像矢量嵌入的多模态模型。虽然 CLIP 是完全开源的，但 OpenAI 的生成性神经网络 DALL-E 却不是。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n202&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;为了填补这一空白，Ryan Murdoch 和 Katherine Crowson 开发了 Colab notebooks， CLIP 与其他开源模型（如 BigGAN 和 VQGAN）结合起来，制作 prompt-based 生成性艺术作品。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n203&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;这些 notebooks 基于 MIT 许可，于过去几十年间在互联网上进行了广泛传播，被重新混合、改变、翻译，并被用来生成了惊人的艺术作品。&lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n204&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n205&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;地址：&lt;/span&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;&gt;https://github.com/openai/CLIP&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;section&gt;&lt;span md-inline=&quot;url&quot; spellcheck=&quot;false&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span md-inline=&quot;plain&quot;&gt;如果你今年有看过一些比较酷炫或实用的开源项目，也欢迎在评论区分享。&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAxOTcxNTIwNQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uDRkMWLia28ia8xsyOClt8NDDCTAZNaDsEic4EEpUG1FPduFr5TUMK1GbDiaFX0qNCJiaS2XPfHzWlFicK95v1a9ic7Vg/0?wx_fmt=png&quot; data-nickname=&quot;GitHubDaily&quot; data-alias=&quot;GitHubDaily&quot; data-signature=&quot;专注于分享 GitHub 上知名的 Python、Java、Web、AI、数据分析等多个领域的优质学习资源、开源项目及开发者工具，为 GitHub 开发者提供优质编程资讯。&quot; data-from=&quot;0&quot;/&gt;&lt;br/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e1d05cc394f16e2b4f70ebde60fe01fc</guid>
<title>Linux I/O 那些事儿</title>
<link>https://toutiao.io/k/49kzv9u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;br/&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;介绍 Linux IO 的一些基本原理。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：arraywang，腾讯 CSIG&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先看一张图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1132075471698113&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasBUBtUJPKhBmt78ulibI4ibAApnLdRSGTTTNZia7dFaImicicQQmNpz334zyLSwZiaVBCqlcQxWjMCEWpw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;530&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这张图大体上描述了 Linux 系统上，应用程序对磁盘上的文件进行读写时，从上到下经历了哪些事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章就以这张图为基础，介绍 Linux 在 I/O 上做了哪些事情。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;文件系统&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是文件系统&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文件系统，本身是对存储设备上的文件，进行组织管理的机制。组织方式不同，就会形成不同的文件系统。比如常见的 Ext4、XFS、ZFS 以及网络文件系统 NFS 等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是不同类型的文件系统标准和接口可能各有差异，我们在做应用开发的时候却很少关心系统调用以下的具体实现，大部分时候都是直接系统调用 &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt; 来实现应用程序的功能，不会再去关注我们具体用了什么文件系统（UFS、XFS、Ext4、ZFS），磁盘是什么接口（IDE、SCSI，SAS，SATA 等），磁盘是什么存储介质（HDD、SSD）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用开发者之所以这么爽，各种复杂细节都不用管直接调接口，是因为内核为我们做了大量的有技术含量的脏活累活。开始的那张图看到 Linux 在各种不同的文件系统之上，虚拟了一个 VFS，目的就是统一各种不同文件系统的标准和接口，让开发者可以使用相同的系统调用来使用不同的文件系统。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;文件系统如何工作（VFS）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Linux 系统下的文件&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Linux 中一切皆文件。不仅普通的文件和目录，就连块设备、套接字、管道等，也都要通过统一的文件系统来管理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;用 ls -l 命令看最前面的字符可以看到这个文件是什么类型&lt;br/&gt;&lt;br/&gt;brw-r--r-- 1 root    root    1, 2 4月  25 11:03 bnod // 块设备文件&lt;br/&gt;crw-r--r-- 1 root    root    1, 2 4月  25 11:04 cnod // 符号设备文件&lt;br/&gt;drwxr-xr-x 2 wrn3552 wrn3552    6 4月  25 11:01 dir // 目录&lt;br/&gt;-rw-r--r-- 1 wrn3552 wrn3552    0 4月  25 11:01 file // 普通文件&lt;br/&gt;prw-r--r-- 1 root    root       0 4月  25 11:04 pipeline // 有名管道&lt;br/&gt;srwxr-xr-x 1 root    root       0 4月  25 11:06 socket.sock // socket文件&lt;br/&gt;lrwxrwxrwx 1 root    root       4 4月  25 11:04 softlink -&amp;gt; file // 软连接&lt;br/&gt;-rw-r--r-- 2 wrn3552 wrn3552 0 4月  25 11:07 hardlink // 硬链接（本质也是普通文件）&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 文件系统设计了两个数据结构来管理这些不同种类的文件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;inode(index node)：索引节点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;dentry(directory entry)：目录项&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;inode 和 dentry&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;inode&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;inode 是用来记录文件的 metadata，所谓 metadata 在 Wikipedia 上的描述是 data of data，其实指的就是文件的各种属性，比如 inode 编号、文件大小、访问权限、修改日期、数据的位置等。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;wrn3552@novadev:~/playground$ &lt;span&gt;stat&lt;/span&gt; file&lt;br/&gt;  文件：file&lt;br/&gt;  大小：0               块：0          IO 块：4096   普通空文件&lt;br/&gt;设备：fe21h/65057d      Inode：32828       硬链接：2&lt;br/&gt;权限：(0644/-rw-r--r--)  Uid：( 3041/ wrn3552)   Gid：( 3041/ wrn3552)&lt;br/&gt;最近访问：2021-04-25 11:07:59.603745534 +0800&lt;br/&gt;最近更改：2021-04-25 11:07:59.603745534 +0800&lt;br/&gt;最近改动：2021-04-25 11:08:04.739848692 +0800&lt;br/&gt;创建时间：-&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;inode 和文件一一对应，它跟文件内容一样，都会被持久化存储到磁盘中。所以，inode 同样占用磁盘空间，只不过相对于文件来说它大小固定且大小不算大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;dentry&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;dentry 用来记录文件的名字、inode 指针以及与其他 dentry 的关联关系。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;wrn3552@novadev:~/playground$ tree&lt;br/&gt;.&lt;br/&gt;├── dir&lt;br/&gt;│   └── file_in_dir&lt;br/&gt;├── file&lt;br/&gt;└── hardlink&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;文件的名字：像 dir、file、hardlink、file_in_dir 这些名字是记录在 dentry 里的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;inode 指针：就是指向这个文件的 inode&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;与其他 dentry 的关联关系：其实就是每个文件的层级关系，哪个文件在哪个文件下面，构成了文件系统的目录结构&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同于 inode，dentry 是由内核维护的一个内存数据结构，所以通常也被叫做 dentry cache。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;文件是如何存储在磁盘上的&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6064593301435407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasBUBtUJPKhBmt78ulibI4ibAprg9QrOHEnkevaApNxOia4ibGSMymaWJWd5uAWKwib1fRrLaeMxwN2aCg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;836&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有张图解释了文件是如何存储在磁盘上的，首先，磁盘再进行文件系统格式化的时候，会分出来 3 个区：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Superblock&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;inode blocks&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;data blocks&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（其实还有 boot block，可能会包含一些 bootstrap 代码，在机器启动的时候被读到，这里忽略）其中 inode blocks 放的都是每个文件的 inode，data blocks 里放的是每个文件的内容数据。这里关注一下 superblock，它包含了整个文件系统的 metadata，具体有：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;inode/data block 总量、使用量、剩余量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;文件系统的格式，属主等等各种属性&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;superblock 对于文件系统来说非常重要，如果 superblock 损坏了，文件系统就挂载不了了，相应的文件也没办法读写。既然 superblock 这么重要，那肯定不能只有一份，坏了就没了，它在系统中是有很多副本的，在 superblock 损坏的时候，可以使用 &lt;code&gt;fsck&lt;/code&gt;（File System Check and repair）来恢复。回到上面的那张图，可以很清晰地看到文件的各种属性和文件的数据是如何存储在磁盘上的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;dentry 里包含了文件的名字、目录结构、inode 指针&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;inode 指针指向文件特定的 inode（存在 inode blocks 里）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个 inode 又指向 data blocks 里具体的 logical block，这里的 logical block 存的就是文件具体的数据&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里解释一下什么是 logical block：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对于不同存储介质的磁盘，都有最小的读写单元&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;/sys/block/sda/queue/physical_block_size&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;HDD 叫做 sector（扇区），SSD 叫做 page（页面）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于 hdd 来说，每个 sector 大小 512Bytes&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于 SSD 来说每个 page 大小不等（和 cell 类型有关），经典的大小是 4KB&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;但是 Linux 觉得按照存储介质的最小读写单元来进行读写可能会有效率问题，所以支持在文件系统格式化的时候指定 block size 的大小，一般是把几个 physical_block 拼起来就成了一个 logical block&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;/sys/block/sda/queue/logical_block_size&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol start=&quot;6&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;理论上应该是 logical_block_size &amp;gt;= physical_block_size，但是有时候我们会看到 physical_block_size = 4K，logical_block_size = 512B 情况，其实这是因为磁盘上做了一层 512B 的仿真（emulation）（详情可参考 &lt;a href=&quot;https://g.126.fm/038DZzG&quot; data-linktype=&quot;2&quot;&gt;512e 和 4Kn&lt;/a&gt;）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ZFS&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里简单介绍一个广泛应用的文件系统 ZFS，一些数据库应用也会用到 ZFS，先看一张 zfs 的层级结构图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7511415525114156&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasBUBtUJPKhBmt78ulibI4ibA49VfmrB42xw9jria1oiaSYdz5UZCeTWmXmNQicSINzQribcghibEfiaFBBcw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;438&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一张从底向上的图：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将若干物理设备 disk 组成一个虚拟设备 vdev（同时，disk 也是一种 vdev）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;再将若干个虚拟设备 vdev 加到一个 zpool 里&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 zpool 的基础上创建 zfs 并挂载（zvol 可以先不看，我们没有用到）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ZFS 的一些操作&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;创建 zpool&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;root@:~ &lt;span&gt;# zpool create tank raidz /dev/ada1 /dev/ada2 /dev/ada3 raidz /dev/ada4 /dev/ada5 /dev/ada6&lt;/span&gt;&lt;br/&gt;root@:~ &lt;span&gt;# zpool list tank&lt;/span&gt;&lt;br/&gt;NAME    SIZE  ALLOC   FREE  CKPOINT  EXPANDSZ   FRAG    CAP  DEDUP  HEALTH  ALTROOT&lt;br/&gt;tank     11G   824K  11.0G        -         -     0%     0%  1.00x  ONLINE  -&lt;br/&gt;root@:~ &lt;span&gt;# zpool status tank&lt;/span&gt;&lt;br/&gt;  pool: tank&lt;br/&gt; state: ONLINE&lt;br/&gt;  scan: none requested&lt;br/&gt;config:&lt;br/&gt;&lt;br/&gt;        NAME        STATE     READ WRITE CKSUM&lt;br/&gt;        tank        ONLINE       0     0     0&lt;br/&gt;          raidz1-0  ONLINE       0     0     0&lt;br/&gt;            ada1    ONLINE       0     0     0&lt;br/&gt;            ada2    ONLINE       0     0     0&lt;br/&gt;            ada3    ONLINE       0     0     0&lt;br/&gt;          raidz1-1  ONLINE       0     0     0&lt;br/&gt;            ada4    ONLINE       0     0     0&lt;br/&gt;            ada5    ONLINE       0     0     0&lt;br/&gt;            ada6    ONLINE       0     0     0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;创建了一个名为 tank 的 zpool&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这里的 raidz 同 RAID5&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了 raidz 还支持其他方案：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44963144963144963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasBUBtUJPKhBmt78ulibI4ibA1zHFcVv5icHagxIZ76vSyejhWwEPXyNic7qeaNZ7tLeDXMKkGIs6gIMg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1628&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;创建 zfs&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;root@:~ &lt;span&gt;# zfs create -o mountpoint=/mnt/srev tank/srev&lt;/span&gt;&lt;br/&gt;root@:~ &lt;span&gt;# df -h tank/srev&lt;/span&gt;&lt;br/&gt;Filesystem    Size    Used   Avail Capacity  Mounted on&lt;br/&gt;tank/srev     7.1G    117K    7.1G     0%    /mnt/srev&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;创建了一个 zfs，挂载到了 /mnt/srev&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这里没有指定 zfs 的 quota，创建的 zfs 大小即 zpool 大小&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;对 zfs 设置 quota&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;root@:~ &lt;span&gt;# zfs set quota=1G tank/srev&lt;/span&gt;&lt;br/&gt;root@:~ &lt;span&gt;# df -h tank/srev&lt;/span&gt;&lt;br/&gt;Filesystem    Size    Used   Avail Capacity  Mounted on&lt;br/&gt;tank/srev     1.0G    118K    1.0G     0%    /mnt/srev&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ZFS 特性&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Pool 存储&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的层级图和操作步骤可以看到 zfs 是基于 zpool 创建的，zpool 可以动态扩容意味着存储空间也可以动态扩容，而且可以创建多个文件系统，文件系统共享完整的 zpool 空间无需预分配。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;事务文件系统&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;zfs 的写操作是事务的，意味着要么就没写，要么就写成功了，不会像其他文件系统那样，应用打开了文件，写入还没保存的时候断电，导致文件为空。zfs 保证写操作事务采用的是 copy on write 的方式：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.521630615640599&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasBUBtUJPKhBmt78ulibI4ibAdJTPgz7JwEFJFWpq7s8VDEwAuqG1rNFdMmnt47afwT0MVl4lGiaiapNA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1202&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当 block B 有修改变成 B1 的时候，普通的文件系统会直接在 block B 原地进行修改变成 B1&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;zfs 则会再另一个地方写 B1，然后再在后面安全的时候对原来的 B 进行回收&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这样结果就不会出现 B 被打开而写失败的情况，大不了就是 B1 没写成功&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个特性让 zfs 在断电后不需要执行 fsck 来检查磁盘中是否存在写操作失败需要恢复的情况，大大提升了应用的可用性。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ARC 缓存&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZFS 中的 ARC(Adjustable Replacement Cache) 读缓存淘汰算法，是基于 IBM 的 ARP(Adaptive Replacement Cache) 演化而来。在一些文件系统中实现的标准 LRU 算法其实是有缺陷的：比如复制大文件之类的线性大量 I/O 操作，导致缓存失效率猛增（大量文件只读一次，放到内存不会被再读，坐等淘汰）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，缓存可以根据时间来进行优化（LRU，最近最多使用），也可以根据频率进行优化（LFU，最近最常使用），这两种方法各有优劣，但是没办法适应所有场景。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ARC 的设计就是尝试在 LRU 和 LFU 之间找到一个平衡，根据当前的 I/O workload 来调整用 LRU 多一点还是 LFU 多一点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ARC 定义了 4 个链表：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LRU list：最近最多使用的页面，存具体数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LFU list：最近最常使用的页面，存具体数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Ghost list for LRU：最近从 LRU 表淘汰下来的页面信息，不存具体数据，只存页面信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Ghost list for LFU：最近从 LFU 表淘汰下来的页面信息，不存具体数据，只存页面信息&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ARC 工作流程大致如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;LRU list 和 LFU list 填充和淘汰过程和标准算法一样&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当一个页面从 LRU list 淘汰下来时，这个页面的信息会放到 LRU ghost 表中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果这个页面一直没被再次引用到，那么这个页面的信息最终也会在 LRU ghost 表中被淘汰掉&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果这个页面在 LRU ghost 表中未被淘汰的时候，被再一次访问了，这时候会引起一次幽灵（phantom）命中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;phantom 命中的时候，事实上还是要把数据从磁盘第一次放缓存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;但是这时候系统知道刚刚被 LRU 表淘汰的页面又被访问到了，说明 LRU list 太小了，这时它会把 LRU list 长度加一，LFU 长度减一&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于 LFU 的过程也与上述过程类似&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ZFS 参考资料&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于 ZFS 详细介绍可以参考：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;磁盘类型&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;磁盘根据不同的分类方式，有各种不一样的类型。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;磁盘的存储介质&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据磁盘的存储介质可以分两类（大家都很熟悉）：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;磁盘的接口&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据磁盘接口分类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;IDE (Integrated Drive Electronics)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SCSI (Small Computer System Interface)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SAS (Serial Attached SCSI)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;SATA (Serial ATA)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;...&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同的接口，往往分配不同的设备名称。比如， IDE 设备会分配一个 hd 前缀的设备名，SCSI 和 SATA 设备会分配一个 sd 前缀的设备名。如果是多块同类型的磁盘，就会按照 a、b、c 等的字母顺序来编号。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Linux 对磁盘的管理&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实在 Linux 中，磁盘实际上是作为一个块设备来管理的，也就是以块为单位读写数据，并且支持随机读写。每个块设备都会被赋予两个设备号，分别是主、次设备号。主设备号用在驱动程序中，用来区分设备类型；而次设备号则是用来给多个同类设备编号。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;g18-&lt;span&gt;&quot;299&quot;&lt;/span&gt; on ~&lt;span&gt;# ls -l /dev/sda*&lt;/span&gt;&lt;br/&gt;brw-rw---- 1 root disk 8,  0 Apr 25 15:53 /dev/sda&lt;br/&gt;brw-rw---- 1 root disk 8,  1 Apr 25 15:53 /dev/sda1&lt;br/&gt;brw-rw---- 1 root disk 8, 10 Apr 25 15:53 /dev/sda10&lt;br/&gt;brw-rw---- 1 root disk 8,  2 Apr 25 15:53 /dev/sda2&lt;br/&gt;brw-rw---- 1 root disk 8,  5 Apr 25 15:53 /dev/sda5&lt;br/&gt;brw-rw---- 1 root disk 8,  6 Apr 25 15:53 /dev/sda6&lt;br/&gt;brw-rw---- 1 root disk 8,  7 Apr 25 15:53 /dev/sda7&lt;br/&gt;brw-rw---- 1 root disk 8,  8 Apr 25 15:53 /dev/sda8&lt;br/&gt;brw-rw---- 1 root disk 8,  9 Apr 25 15:53 /dev/sda9&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这些 sda 磁盘主设备号都是 8，表示它是一个 sd 类型的块设备&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;次设备号 0-10 表示这些不同 sd 块设备的编号&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Generic Block Layer&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.823728813559322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasBUBtUJPKhBmt78ulibI4ibAXEprQaog5BaZ3SEM46uFc6xNC9SeJ2zkAc9YRWQJq5ICWibejUzibmnA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;590&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和 VFS 类似，为了对上层屏蔽不同块设备的差异，内核在文件系统和块设备之前抽象了一个 Generic Block Layer（通用块层），有时候一些人也会把下面的 I/O 调度层并到通用块层里表述。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两层主要做两件事：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;跟 VFS 的功能类似。向上，为文件系统和应用程序，提供访问块设备的标准接口；向下，把各种异构的磁盘设备抽象为统一的块设备，并提供统一框架来管理这些设备的驱动程序&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对 I/O 请求进行调度，通过重新排序、合并等方式，提高磁盘读写效率&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图是一个完整的 I/O 栈全景图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4166666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasBUBtUJPKhBmt78ulibI4ibAJ0yg821WSfwUdib6icUwxaicic7hFtHEZx1USpKmrWRW92BGua9LKAM7MA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到中间的 Block Layer 其实就是 Generic Block Layer，在图中可以看到 Block Layer 的 I/O 调度分为两类，分别表示单队列和多队列的调度：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;I/O 调度&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老版本的内核里只支持单队列的 I/O scheduler，在 3.16 版本的内核开始支持多队列 blkmq，这里介绍几种经典的 I/O 调度策略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单队列 I/O scheduler：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;NOOP：事实上是个 FIFO 的队列，只做基本的请求合并&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;CFQ：Completely Fair Queueing，完全公平调度器，给每个进程维护一个 I/O 调度队列，按照时间片来均匀分布每个进程 I/O 请求，&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;DeadLine：为读和写请求创建不同的 I/O 队列，确保达到 deadline 的请求被优先处理&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多队列 blkmq：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;bfq：Budget Fair Queueing，也是公平调度器，不过不是按时间片来分配，而是按请求的扇区数量（带宽）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;kyber：维护两个队列（同步/读、异步/写），同时严格限制发到这两个队列的请求数以保证相应时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mq-deadline：多队列版本的 deadline&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;性能指标&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说 I/O 性能指标有这几个：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用率：ioutil，指的是磁盘处理 I/O 的时间百分比，ioutil 只看有没有 I/O 请求，不看 I/O 请求的大小。ioutil 越高表示一直都有 I/O 请求，不代表磁盘无法响应新的 I/O 请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;IOPS：每秒的 I/O 请求数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;吞吐量/带宽：每秒的 I/O 请求大小，通常是 MB/s 或者 GB/s 为单位&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;响应时间：I/O 请求发出到收到响应的时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;饱和度：指的是磁盘处理 I/O 的繁忙程度。这个指标比较玄学，没有直接的数据可以表示，一般是根据平均队列请求长度或者响应时间跟基准测试的结果进行对比来估算&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（在做基准测试时，还会分顺序/随机、读/写进行排列组合分别去测 IOPS 和带宽）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的指标除了饱和度外，其他都可以在监控系统中看到。Linux 也提供了一些命令来输出不同维度的 I/O 状态：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;iostat -d -x&lt;/code&gt;：看各个设备的 I/O 状态，数据来源 &lt;code&gt;/proc/diskstats&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;pidstat -d&lt;/code&gt;：看近处的 I/O&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;iotop&lt;/code&gt;：类似 top，按 I/O 大小对进程排序&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a7ba7ba2865ceba4bda74e32632d1008</guid>
<title>Go Ballast 让内存控制更加丝滑</title>
<link>https://toutiao.io/k/knmkin5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于 Go GC 优化的手段你知道的有哪些？比较常见的是通过调整 GC 的步调，以调整 GC 的触发频率。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;设置 GOGC&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置 debug.SetGCPercent()&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两种方式的原理和效果都是一样的，GOGC 默认值是 100，也就是下次 GC 触发的 heap 的大小是这次 GC 之后的 heap 的一倍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道 GO 的 GC 是标记-清除方式，当 GC 会触发时全量遍历变量进行标记，当标记结束后执行清除，把标记为白色的对象执行垃圾回收。值得注意的是，这里的&lt;strong&gt;回收&lt;/strong&gt;仅仅是标记内存可以返回给操作系统，并不是立即回收，这就是你看到 Go 应用 RSS 一直居高不下的原因。在整个垃圾回收过程中会暂停整个 Go 程序（STW），Go 垃圾回收的耗时还是主要取决于&lt;strong&gt;标记&lt;/strong&gt;花费的时间的长短，清除过程是非常快的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;设置 GOGC 的弊端&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. GOGC 设置比率的方式不精确&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置 GOGC 基本上我们比较常用的 Go GC 调优的方式，大部分情况下其实我们并不需要调整 GOGC 就可以，一方面是不涉及内存密集型的程序本身对内存敏感程度太低，另外就是 GOGC 这种设置比率的方式不精确，我们很难精确的控制我们想要的触发的垃圾回收的阈值。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. GOGC 设置过小&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GOGC 设置的非常小，会频繁触发 GC 导致太多无效的 CPU 浪费，反应到程序的表现就会特别明显。举个例子，对于 API 接口来说，导致的结果的就是接口周期性的耗时变化。这个时候你抓取 CPU profile 来看，大部分的耗时都集中在 GC 的相关处理上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.27665544332211&quot; data-type=&quot;png&quot; data-w=&quot;1782&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/picLDrXZzloaZr8XHeo1X6MXSTVXXdb4UzM2HwHVia4hfeklSCK14Z8Np05IzYHx3pCkR67xl7uI9kFibw63RiaibTw/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图，这是一次 prometheus 的查询操作，我们看到大部分的 CPU 都消耗在 GC 的操作上。这也是生产环境遇到的，由于 GOGC 设置的过小，导致过多的消耗都耗费在 GC 上。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 对某些程序本身占用内存就低，容易触发 GC&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对 API 接口耗时比较敏感的业务，如果  GOGC 置默认值的时候，也可能也会遇到接口的周期性的耗时波动。这是为什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为这种接口本身占用内存比较低，每次 GC 之后本身占的内存比较低，如果按照上次 GC 后的 heap 的一倍的 GC 步调来设置 GOGC 的话，这个阈值其实是很容易就能够触发，于是就很容出现接口因为 GC 的触发导致额外的消耗。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. GOGC 设置很大，有的时候又容易触发 OOM&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那如何调整呢？是不是把 GOGC 设置的越大越好呢？这样确实能够降低 GC 的触发频率，但是这个值需要设置特别大才有效果。这样带来的问题，GOGC 设置的过大，如果这些接口突然接受到一大波流量，由于长时间无法触发 GC 可能导致 OOM。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此，GOGC 对于某些场景并不是很友好，那有没有能够精确控制内存，让其在 10G 的倍数时准确控制 GC 呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;GO 内存 ballast&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就需要 Go ballast 出场了。什么是 Go ballast，其实很简单就是初始化一个生命周期贯穿整个 Go 应用生命周期的超大 slice。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  ballast := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;) &lt;span&gt;// 10G &lt;/span&gt;&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;// do something&lt;/span&gt;&lt;br/&gt;  &lt;br/&gt;  runtime.KeepAlive(ballast)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码就初始化了一个 ballast，利用 runtime.KeepAlive 来保证 ballast 不会被 GC 给回收掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用这个特性，就能保证 GC 在 10G 的一倍时才能被触发，这样就能够比较精准控制 GO GC 的触发时机。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这里你可能有一个疑问，这里初始化一个 10G 的数组，不就占用了 10 G 的物理内存呢？&lt;/strong&gt; 答案其实是不会的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;&quot;runtime&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;math&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    ballast := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;    &amp;lt;-time.After(time.Duration(math.MaxInt64))&lt;br/&gt;    runtime.KeepAlive(ballast)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ ps -eo pmem,comm,pid,maj_flt,min_flt,rss,vsz --sort -rss | numfmt --header --to=iec --field 5 | numfmt --header --from-unit=1024 --to=iec --field 6 | column -t | egrep &lt;span&gt;&quot;[t]est|[P]I&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;%MEM  COMMAND   PID    MAJFL      MINFL  RSS    VSZ&lt;br/&gt;0.1   &lt;span&gt;test&lt;/span&gt;      12859  0          1.6K   344M   11530184&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个结果是在 CentOS Linux release 7.9 验证的，我们看到占用的 RSS 真实的物理内存只有 344M，但是 VSZ 虚拟内存确实有 10G 的占用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;延伸一点，当怀疑我们的接口的耗时是由于 GC 的频繁触发引起的，我们需要怎么确定呢？首先你会想到周期性的抓取 pprof 的来分析，这种方案其实也可以，但是太麻烦了。其实可以根据 GC 的触发时间绘制这个曲线图，GC 的触发时间可以利用 runtime.Memstats 的 LastGC 来获取。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;生产环境验证&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;绿线 调整前 GOGC = 30&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;黄线 调整后 GOGC 默认值，ballast = 50G&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2676348547717842&quot; data-type=&quot;png&quot; data-w=&quot;964&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/picLDrXZzloaZr8XHeo1X6MXSTVXXdb4UAickq8nJNLrPluYibCjx5CuEuZZj46ZIkeegGecBNlcjFkPqXBPiapKuA/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34178610804851156&quot; data-type=&quot;png&quot; data-w=&quot;907&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/picLDrXZzloaZr8XHeo1X6MXSTVXXdb4Uwic2ibJic19Jlib7Pcq2vhib5UrKibxibzYjT6lkic41F4hBlt3k3IXa1ic0r3w/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这张图相同的流量压力下，ballast 的表现明显偏好&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36951754385964913&quot; data-type=&quot;png&quot; data-w=&quot;912&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/picLDrXZzloaZr8XHeo1X6MXSTVXXdb4Uf3MwfQYNR81OoZrvQKuP327RaKndlrwrxUTCekibuUJyMra7apicvlMw/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;结论&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇文章只是简单的阐述了 Go ballast 的使用，Go ballast 是官方比较认可的方案，具体可以参见 &lt;span&gt;issue 23044&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;。很多开源程序，如 &lt;span&gt;tidb&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;，&lt;span&gt;cortex&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt; 都实现了 go ballast，如果你的程序饱受 GOGC 的问题影响或者周期性的耗时不稳定，不妨尝试下 go ballast。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然强烈推荐你看下&lt;span&gt;twitch.tv 这篇文章&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;，相信让你会对 GOGC 以及 ballast 的运用理解的更加透彻。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;写文章不易请大家帮忙点击 在看，点赞，分享。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.30918595967139656&quot; data-type=&quot;png&quot; data-w=&quot;2678&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/picLDrXZzloaZr8XHeo1X6MXSTVXXdb4UCZW0h1BOpKsg5hPv01DWsH7icmzZNZvFzBJ3EgAcrGXwI2gU4Zk5e8A/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;issue 23044: &lt;em&gt;https://github.com/golang/go/issues/23044&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;tidb: &lt;em&gt;https://github.com/pingcap/tidb/pull/29121/files&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;cortex: &lt;em&gt;https://github.com/cortexproject/cortex/blob/master/cmd/cortex/main.go#L148&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;twitch.tv 这篇文章: &lt;em&gt;https://blog.twitch.tv/en/2019/04/10/go-memory-ballast-how-i-learnt-to-stop-worrying-and-love-the-heap/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fed439f366242cfa454b750de2444054</guid>
<title>JuiceFS 在大搜车数据平台的实践</title>
<link>https://toutiao.io/k/29tbwsr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post_content markdown&quot;&gt;&lt;p&gt;&lt;strong&gt;JuiceFS&lt;/strong&gt; 是云原生共享文件，完全兼容 HDFS 与 POSIX API，适用于大数据平台、容器平台，支持数据共享、数据分析、机器学习训练等场景。&lt;/p&gt;&lt;p&gt;本文是 JuiceFS 在大搜车数据平台的实践分享，作者张健，南昌大学毕业，目前任职于杭州大搜车软件技术有限公司数据专家，负责大数据架构设计及维护。&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;大搜车已经搭建起比较完整的汽车产业互联网协同生态。在这一生态中，不仅涵盖了大搜车已经数字化的全国 90% 中大型二手车商、9000+ 家 4S 店和 70000+ 家新车二网，还包括大搜车旗下车易拍、车行168、运车管家、布雷克索等具备较强产业链服务能力的公司， 与大搜车在新零售解决方案上达成深度战略合作的长城汽车、长安汽车、英菲尼迪等主机厂商，以及与中石油昆仑好客等产业链上下游的合作伙伴。基于这样的生态布局，大搜车数字化了汽车流通链条上的每个环节，进而为整个行业赋能。&lt;/p&gt;&lt;p&gt;说到大数据，对于每个公司都不陌生。存储组件 HDFS，计算资源管理 YARN，离线计算 Hive、Spark、Spark SQL，列存储数据库 HBase，实时计算Spark Streaming、Flink等。这些组件在集群稳定情况下维护还算比较轻松，但是在公司快速发展过程中，集群容量的高速增长是不可避免的，作为大数据的设计者不得不从集群的成本和效益上思考两者的权衡。&lt;/p&gt;&lt;h1 id=&quot;大数据集群现状&quot;&gt;大数据集群现状&lt;/h1&gt;&lt;p&gt;大搜车目前大数据集群分为离线计算集群和实时计算集群，离线计算基于 Hive 和 Spark，实时计算基于 Flink，这两类集群分别基于 HDP 和 CDH 两套管理方式。早期离线计算选用了 HDP，实时计算后来选用 CDH 的初衷是多集群管理比较方便。由于离线计算引擎两者是有区别的，迁移会有兼容性问题，两套集群一直并存，集群间资源完全隔离。&lt;/p&gt;&lt;h2 id=&quot;集群维护痛点&quot;&gt;集群维护痛点&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;数据量持续增长，成本一定的情况下做集群扩容耗时耗力&lt;/p&gt;&lt;p&gt;从 18 年初到 19 年 6 月份，离线集群从最初的数十个节点持续增长到上百个节点，数据量也从数十 TiB 增长了 10 多倍，并且保持每天数 TiB 的速度增加。在节省开支的情况下，每月做一次集群扩容，形成了与数据增长速度赛跑的情况。每月固定工作差不多变成了接受磁盘告警狂炸、扩容、均衡数据、再均衡数据的情况。遇到一些极端情况，比如阿里云在某个可用区没有数据类型设备资源而要新在另一个可用区创建，还会涉及到数据网段变更，就更复杂了。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;存储所需资源跟计算资源不同步&lt;/p&gt;&lt;p&gt;在对离线集群数据做分析过程中发现，热点数据仅占大约 20%。在集群不断扩容的情况下，计算资源会有较大冗余，产生了不必要的成本，另外每次均衡会占用节点网络带宽，影响任务读写数据的速度。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;跨集群数据同步&lt;/p&gt;&lt;p&gt;为了减少了实时任务和离线任务的相互影响，方便资源控制和云资源选型价值最大化，实时计算和离线计算集群在物理上做了资源隔离，难点也随之出现，实时和离线集群的数据无法实时同步，造成一些需求无法实现。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;NameNode内存持续增长，重启时间过久&lt;/p&gt;&lt;p&gt;在文件存储中，文件数量过多导致 NameNode 管理内存持续增加，重启一次时间过长，势必影响数据同步；并且在数仓层面不严加控制数据生命周期，资源占用也会越来越大，在对集群中整个资源做分析时也会受到影响。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 id=&quot;选择-juicefs&quot;&gt;选择 JuiceFS&lt;/h1&gt;&lt;p&gt;针对以上这些问题，选取一款产品做底层存储势在必行。存储选择上作为大数据的基石，需要遵从如下特点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;兼容Hadoop框架协议&lt;/li&gt;&lt;li&gt;多版本集群兼容&lt;/li&gt;&lt;li&gt;高吞吐、低延时&lt;/li&gt;&lt;li&gt;支持深度压缩减少资源使用&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;在一开始，我们尝试使用阿里云的 OSS 作为冷备存储。在测试过程中，由于没有元信息管理，在数据维护上很受限制。后来接触到了 JuiceFS 这款产品，在选择上很是满足上述要求。对此我们做了一些性能测试（均基于实际场景提取业务逻辑）。&lt;/p&gt;&lt;h2 id=&quot;实际场景性能测试&quot;&gt;实际场景性能测试&lt;/h2&gt;&lt;p&gt;以下测试均选取实际业务数据，数据大小是 where 查询条件不同选取的，仅做两个文件系统性能对比：&lt;/p&gt;&lt;p&gt;综上，JuiceFS 在查询、插入数据时多数耗时比较稳定且整体比HDFS耗时要少，在 SELECT 数据情况，多数性能相差不多极个别情况要优于 HDFS，单行做排序操作性能差不多。&lt;/p&gt;&lt;h2 id=&quot;成本控制&quot;&gt;成本控制&lt;/h2&gt;&lt;p&gt;我们对比了采用 JuiceFS 和 HDFS 两种方案的费用（HDFS 集群保证存储冗余 20%）。在同等数据量（JuiceFS 会再次做深度压缩，压缩比大约为 3:1）和对等计算资源的情况下采用 JuiceFS 每月会比使用云主机部署 HDFS 节省至少 18%。&lt;/p&gt;&lt;p&gt;综合看 JuiceFS 的性能和成本都非常满足公司对成本和产品性能的要求。&lt;/p&gt;&lt;h1 id=&quot;未来展望&quot;&gt;未来展望&lt;/h1&gt;&lt;h2 id=&quot;存储计算分离&quot;&gt;存储计算分离&lt;/h2&gt;&lt;p&gt;大数据集群引入 JuiceFS，存储和计算实际上已经分离。大数据集群灵活弹性扩展计算资源已经成为可能，在凌晨业务低谷期可以将业务机器的计算资源调度给大数据集群。&lt;/p&gt;&lt;p&gt;以下是目前整个大数据集群架构：&lt;/p&gt;&lt;p&gt;后续可以结合计算存储分离和动态伸缩设计为如下目标架构：&lt;/p&gt;&lt;p&gt;与 Kubernetes 做结合，按需申请资源，节省成本和减少维护成本。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>