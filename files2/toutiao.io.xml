<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>31d9ce0967a693e0c18a8acd042d1040</guid>
<title>MongoDB全方位知识图谱！</title>
<link>https://toutiao.io/k/efxw4nr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe977Xa5zfy5iaV3agpS11Cqm4psjPOibic6BZSicnBFh6uWzCFp3uqN5R114Fq85DmuCzdL3eESlQ37bFA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;导语 | &lt;/span&gt;&lt;span/&gt;&lt;span&gt;MongoDB是一个强大的分布式存储引擎，天然支持高可用、分布式和灵活设计。MongoDB的一个很重要的设计理念是：服务端只关注底层核心能力的输出，至于怎么用，就尽可能的将工作交个客户端去决策。这也就是MongoDB灵活性的保证，但是灵活性带来的代价就是使用成本的提升。与MySql相比，想要用好MongoDB，减少在项目中出问题，用户需要掌握的东西更多。本文致力于全方位的介绍MongoDB的理论和应用知识，目标是让大家可以通过阅读这篇文章之后能够掌握MongoDB的常用知识，具备在实际项目中高效应用MongoDB的能力。本文既有MongoDB基础知识也有相对深入的进阶知识，同时适用于对MonogDB感兴趣的初学者或者希望对MongoDB有更深入了解的业务开发者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;一、前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以下是笔者在学习和使用MongoDB过程中总结的MongoDB知识图谱。本文将按照一下图谱中依次介绍MongoDB的一些核心内容。由于能力和篇幅有限，本文并不会对图谱中全部内容都做深入分析，后续将会针对特定条目做专门的分析。同时，如果图谱和内容中有错误或疏漏的地方，也请大家随意指正，笔者这边会积极修正和完善。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文按照图谱从以下&lt;/span&gt;&lt;span&gt;3个方面&lt;/span&gt;&lt;span&gt;来介绍MongoDB相关知识：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;902&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.56328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96wFFuYibavG2DePVqax9J0BykcIEibibPgUxCogPVp4TzCCeiatVTMfLT4GASuJ1susdEgP3UuIXgWvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;二、基础知识&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB是基于文档的NoSql存储引擎。MongoDB的数据库管理由数据库、Collection（集合，类似MySql的表）、Document（文档，类似MySQL的行）组成，每个Document都是一个类JSON结构BSON结构数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB的核心特性是：No Schema、高可用、分布式（可平行扩展），另外MongoDB自带数据压缩功能，使得同样的数据存储所需的资源更少。本节将会依次介绍这些特性的基本知识，以及MongoDB是如何实现这些能力的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（一）No Schema&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB是文档型数据库，其文档组织结构是BSON(Binary Serialized Document Format) 是类JSON的二进制存储格式，数据组织和访问方式完全和JSON一样。支持动态的添加字段、支持内嵌对象和数组对象，同时它也对JSON做了一些扩充，如支持Date和BinData数据类型。正是BSON这种字段灵活管理能力赋予了Mongo的No Schema或者Schema Free的特性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;No Schema特性带来的好处包括：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MongoDB在提供No Schema特性基础上，提供了部分可选的Schema特性：Validation。其主要功能有包括：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面的字段包含内嵌文档的，也就是说，你可以指定Document内任意一层JSON文件的字段属性。validator的值有两种，一种是简单的JSON Object，另一种是通过关键字$jsonSchema指定。以下是简单示例，想了解更多请参考官方文档：&lt;/span&gt;&lt;span&gt;MongoDB JSON Schema详解&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（https://www.docs4dev.com/docs/zh/mongodb/v3.6/reference/reference-operator-query-jsonSchema.html）&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;方式一：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.createCollection&lt;/span&gt;(&quot;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;saky_test_validation&lt;/span&gt;&quot;,{&lt;span class=&quot;code-snippet__attribute&quot;&gt;validator&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    $and:[&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      {name:{$type: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;string&quot;&lt;/span&gt;}},&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      {&lt;span class=&quot;code-snippet__attribute&quot;&gt;status&lt;/span&gt;:{$in:[&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;INIT&quot;&lt;/span&gt;,&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;DEL&quot;&lt;/span&gt;]}}]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方式二：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;db&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.createCollection&lt;/span&gt;(&quot;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;saky_test_validation&lt;/span&gt;&quot;, {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__attribute&quot;&gt;validator&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      $jsonSchema: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         bsonType: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;object&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         required: [ &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;name&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;status&quot;&lt;/span&gt;, ],&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         properties: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            name: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               bsonType: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;string&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               description: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;must be a string and is required&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;status&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               &lt;span class=&quot;code-snippet__attribute&quot;&gt;enum&lt;/span&gt;: [ &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;INIT&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;DEL&quot;&lt;/span&gt;], &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               description: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;can only be one of the enum values and is required&quot;&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} }})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;（二）MongoDB的高可用&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;高可用是MongoDB最核心的功能之一，相信很多同学也是因为这一特性才想深入了解它的。那么本节就来说下MongoDB通过哪些方式来实现它的高可用，然后给予这些特性我们可以实现什么程度的高可用。&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相信一旦提到高可用，浮现在大家脑海里会有如下几个问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，带着这些问题，我们继续看下去，看完大家应该会对这些问题有所了解了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MongoDB高可用的基础是复制集群，复制集群本质来说就是一份数据存多份，保证一台机器挂掉了数据不会丢失。一个副本集至少有3个节点组成：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上面的节点类型可以看出，一个三节点的复制集群可能是PSS或者PSA结构。PSA结构优点是节约成本，但是缺点是Primary挂掉之后，一些依赖 majority（多数）特性的写功能出问题，因此一般不建议使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;复制集群确保数据一致性的核心设计是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上面4点我们可以得出 MongoDB 高可用的如下结论：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上一小节发现，MongoDB的高可用机制在不同的场景表现是不一样的。实际上，MongoDB提供了一整套的机制让用户根据自己业务场景选择不同的策略。这里要说的就是MongoDB的读写策略，根据用户选取不同的读写策略，你会得到不同程度的数据可靠性和一致性保障。这些对业务开放者非常重要，因为你只有彻底掌握了这些知识，才能根据自己的业务场景选取合适的策略，同时兼顾读写性能和可靠性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Write Concern——写策略    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;控制服务端一次写操作在什么情况下才返回客户端成功，由两个参数控制：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Read Preference——读策略    &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;控制客户端从什么节点读取数据，默认为primary，具体参数及含义：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;更多信息可参考&lt;/span&gt;&lt;span&gt;MongoDB 官方文档&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（https://www.mongodb.com/docs/v4.0/reference/read-preference/index.html?_ga=2.71414227.1531435120.1648536327-1778944104.1630835426）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Read Concern Level——读级别&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一个非常有意思的参数，也是最不容易理解的异常参数。它主要控制的是读到的数据是不是最新的、是不是持久的，最新的和持久的是一对矛盾，最新的数据可能会被回滚，持久的数据可能不是最新的，这需要业务根据自己场景的容忍度做决策，前提是你的先知道有哪些，他们代表什么意义：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了便于理解local和majority，这里引用一下MongoDB官网上的一张 WriteConcern=majority时写操作的过程图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3787465940054496&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96wFFuYibavG2DePVqax9J0BprBVMoOib34nWvgic5naLlOyqDo9jJibxNtLjLtPcXPcibd7VZ2xZx1aHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;734&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过这张图可以看出，不同节点在不同阶段看待同一条数据满足的level是不同的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.19814814814814816&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96wFFuYibavG2DePVqax9J0B4ibQVXhibAzXz1dEuvEpLN0gKASvLWFPtpibjM1Xg7FCicic1icpmeWWLe9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（三）MongoDB的可扩展性——分片集群&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;水平扩展是MongoDB的另一个核心特性，它是MongoDB支持海量数据存储的基础。&lt;/span&gt;&lt;span&gt;MongoDB天然的分布式特性使得它几乎可无限的横向扩展，你再也不用为MySQL分库分表的各种繁琐问题操碎心了。&lt;/span&gt;&lt;span&gt;当然，我们这里不讨论MongoDB和其它存储引擎的对比，这个以后专门写下，这里只关注分片集群相关信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB的分片集群由如下三个部分组成：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7103109656301145&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQX5F50QpF1w2LVmagceTUfkKuic5P4NnwRcics1OzNyxYehZSO4KR0VPSw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1222&quot;/&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Config：配置，本质上是一个MongoDB的副本集，负责存储集群的各种元数据和配置，如分片地址、chunks等。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Mongos：路由服务，不存具体数据，从Config获取集群配置讲请求转发到特定的分片，并且整合分片结果返回给客户端。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Mongod：一般将具体的单个分片叫mongod，实质上每个分片都是一个单独的复制集群，具备负责集群的高可用特性。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其实分片集群的架构看起来和很多支持海量存储的设计很像，本质上都是将存储分片，然后在前面挂一个proxy做请求路由。但是，MongoDB的分片集群有个非常重要的特性是其它数据库没有的，这个特性就是数据均衡。数据分片一个绕不开的话题就是数据分布不均匀导致不同分片负载差异巨大，不能最大化利用集群资源。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB的数据均衡的实现方式是：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;分片集群上数据管理单元叫chunk，一个chunk默认64M，可选范围1～ 1024M。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;集群有多少个chunk，每个chunk的范围，每个chunk是存在哪个分片上的，这些数据都是存储在Config的。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;chunk会在其内部包含的数据超过阈值时分裂成两个。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;MongoDB在运行时会自定检测不同分片上的chunk数，当发现最多和最少的差异超过阈值就会启动chunk迁移，使得每个分片上的chunk数差不多。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;chunk 迁移过程叫rebalance，会比较耗资源，因此一般要把它的执行时间设置到业务低峰期。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关于chunk更加深入的知识会在后面进阶知识里面讲解，这里就不展开了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB支持&lt;/span&gt;&lt;span&gt;两种分片算法&lt;/span&gt;&lt;span&gt;来满足不同的查询需求：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;区间分片：可以按shardkey做区间查询的分片算法，直接按照shardkey的值来分片。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;hash分片：用的最多的分片算法，按shardkey的hash值来分片。hash分片可以看作一种特殊的区间分片。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;区间分片示例：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3585434173669468&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQXl1h4S3NoqkMr7JFSv0qQsj53QLg0W3Dx668ia0A9NVRT9za2awZrkgA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1428&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;hash分片示例：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36623748211731044&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQXaQ3Dsia4Ye0ib2lr5exJs4HibKUup0Py1aJDeZBDkSibqLG2yibPwT1rcbw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1398&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从上面两张图可以看出：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;分片的本质是将shardkey按一定的函数变换f(x)之后的空间划分为一个个连续的段，每一段就是一个chunk。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;区间分片f(x)=x；hash分片f(x)=hash(x)。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;每个chunk在空间中起始值是存在Config里面的。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当请求到Mongos的时候，根据shardkey的值算出f(x)的具体值为 f(shardkey)，找到包含该值的chunk，然后就能定位到数据的实际位置了。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（四）数据压缩&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB的另外一个比较重要的特性是数据压缩，MongoDB会自动把客户数据压缩之后再落盘，这样就可以节省存储空间。MongoDB的数据压缩算法有多种：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;前缀压缩：索引用的压缩算法，简单理解就是丢掉重复的前缀。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;zstd：MongoDB 4.2之后新增的压缩算法，拥有更好的压缩率。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在推荐的MongoDB版本是4.0，在这个版本下推荐使用snappy算法，虽然zlib有更高的压缩比，但是读写会有一定的性能波动，不适合核心业务，但是比较适合流水、日志等场景。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;三、应用接入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在掌握第一部分的基础上，基本上对MongoDB有一个比较直观的认识了，知道它是什么，有什么优势，适合什么场景。在此基础上，我们基本上已经可以判定MongoDB是否适合自己的业务了。如果适合，那么接下来就需要考虑怎么将其应用到业务中。在此之前，我们还得先对MongoDB的性能有个大致的了解，这样才能根据业务情况选取合适的配置。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（一）基本性能测试&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在使用MongoDB之前，需要对其功能和性能有一定的了解，才能判定是否符合自己的业务场景，以及需要注意些什么才能更好的使用。笔者这边对其做了一些测试，本测试是基于自己业务的一些数据特性，而且这边使用的是分片集群。因此有些测试项不同数据会有差异，如压缩比、读写性能具体值等。但是也有一些是共性的结论，如写性能随数据量递减并最终区域平稳。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对比了同样数据在Mongo和MySQL下压缩比对比，可以看出snapy算法大概是MySQL的3倍，zlib大概是6倍。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3092053501180173&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQX29yn4xQIkFNicibInJibz7PIlFua3Oa4QbxKzTJejia7DZBf2Z5sgyr7Cw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1271&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分片集群写性能在测试之后得到如下结论，这里分片是4核8G的配置：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当数据量小时是存内存读写，写性能很好，之后随着数量增加急剧下降，并最终趋于平稳，在3000QPS。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;分片集群批量写和逐条写性能无差异，而如果是复制集群批量写性能是逐条写性能的数倍。这点有点违背常识，具体原因这边还未找到。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6899696048632219&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQXskvOMYIy5Md7vddB8fyMPMGzS6nahJeYWHHwEkjw63nR57ZgZ4vfDQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;658&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分片集群的读分为三年种情况：按shardkey查询、按索引查询、其他查询。下面这些测试数据都是在单分片2亿以上的数据，这个时候cache已经不能完全换成业务数据了，如果数据量很小，数据全在cache这个性能应该会很好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Mongos有点特殊情况要注意的，就是客户端请求会到哪个Mongos是通过客户端ip的hash值决定的，因此同一个客户端所有请求一定会到同一个 Mongos，如果客户端过少的时候还会出现Mongos负载不均问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（二）分片选择&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在了解了MongoDB的基本性能数据之后，就可以根据自己的业务需求选取合适的配置了。如果是分片集群，其中最重要的就是分片选取，包括：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关于前面两点，其实在知道各种性能参数之后就很简单了，前人已经总结出了相关的公式，我这里就简单把图再贴一下。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36523652365236525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQXCf5f0nLhYQRdV90EPDn5uTWubSWbMMyNv5PewBxrfX9rAk58v2xTdQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1818&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（三）spring-data-mongo&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MonogDB官方提供了各种语言的Client，这些Client是对mongo原始命令的封装。笔者这边是使用的java，因此并未直接使用MongoDB官方的客户端，而是经过二次封装之后的spring-data-mongo。好处是可以不用他关心底层的设计如连接管理、POJO转换等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;spring-data-mongo的使用方式非常简单。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第一步：引入jar包&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-data-mongodb&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第二步：ymal配置&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;spring&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;data&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;mongodb&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;host&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;{{.MONGO_HOST}}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;port&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;{{.MONGO_PORT}}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;database&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;{{.MONGO_DB}}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;username&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;{{.MONGO_USER}}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;password&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;{{.MONGO_PASS}}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里有个两个要注意：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;权限，MongoDB的权限是到数据级别的，所有配置的username必须有 database那个库的权限，要不然会连不上。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;这种方式配置没有指定读写concern，如果需要在连接上指定的话，需要用 uri的方式来配置，两种配置方式是不兼容的，或者自己初始化 MongoTemplate。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关于配置，跟多的可以在IDEA里面搜索MongoAutoConfiguration查看源码，具体就是这个类：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;org.springframework.boot.autoconfigure.mongo.MongoProperties&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关于自己初始化MongoTemplate的方式是：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Configuration&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MyMongoConfig&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Primary&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Bean&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; MongoTemplate &lt;span class=&quot;code-snippet__title&quot;&gt;mongoTemplate&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(MongoDbFactory mongoDbFactory,  MongoConverter mongoConverter)&lt;/span&gt;&lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        MongoTemplate mongoTemplate = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; MongoTemplate(mongoDbFactory,mongoConverter);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mongoTemplate.setWriteConcern(WriteConcern.MAJORITY);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; mongoTemplate;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第三步：使用MongoTemplate&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在完成上面这些之后，就可以在代码里面注入MongoTemplate，然后使用各种增删改查接口了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB Client的批量操作有两种方式：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;bulkOps的方式会比另外一种方式在性能上低一些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这两种方式到引擎层面具体执行时都是一条条语句单独执行，它们有一个很重要的参数：ordered，这个参数的作用是控制批量操作在引擎内最终执行时是并行的还是穿行的。其默认值是true。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;显然，false模式下插入耗时会低一些，但是MongoTemplate的insertAll 函数是在内部写死的true。因此，如果想用false模式，需要自己继承MongoTemplate然后重写里面的insertDocumentList方法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MyMongoTemplate&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;MongoTemplate&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;protected&lt;/span&gt; List&amp;lt;Object&amp;gt; &lt;span class=&quot;code-snippet__title&quot;&gt;insertDocumentList&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(String collectionName, List&amp;lt;Document&amp;gt; documents)&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                .........&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                InsertManyOptions options = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; InsertManyOptions();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                options = options.ordered(&lt;span class=&quot;code-snippet__keyword&quot;&gt;false&lt;/span&gt;);  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;long&lt;/span&gt; begin = System.currentTimeMillis();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (writeConcernToUse == &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    collection.insertMany(documents, options); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                } &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              collection.withWriteConcern(writeConcernToUse).insertMany(documents,options);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; MappedDocument.toIds(documents);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为MongoDB真的将太多自主性交给的客户端来决策，因此如果对其了解不够，真的会很容易踩坑。这里例举一些常见的坑，避免大家遇到。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;预分片&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个问题的常见表现就是：为啥我的数据分布很随机了，但是分片集群的MongoDB插入性能还是这么低？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先我们说下预分片是什么，预分片就是提前把shard key的空间划分成若干段，然后把这些段对应的chunk创建出来。那么，这个和插入性能的关系是什么呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们回顾下前面说到的chunk知识，其中有两点需要注意：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当chunk内的数据超过阈值就会将chunk拆分成两个。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当各个分片上chunk数差异过大时就会启动rebalance，迁移chunk。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么，很明显，问题就是出在这了，chunk分裂和chunk迁移都是比较耗资源的，必然就会影响插入性能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此，如果提前将个分片上的chunk创建好，就能避免频繁的分裂和迁移chunk，进而提升插入性能。预分片的设置方式为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; sh.shardCollection(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;saky_db.saky_table&quot;&lt;/span&gt;, {&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;_id&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;hashed&quot;&lt;/span&gt;}, &lt;span class=&quot;code-snippet__literal&quot;&gt;false&lt;/span&gt;,{&lt;span class=&quot;code-snippet__attr&quot;&gt;numInitialChunks&lt;/span&gt;:&lt;span class=&quot;code-snippet__number&quot;&gt;8192&lt;/span&gt;*分片数})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;numInitialChunks的最大值为8192*分片数&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;内存排序&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个是一个不容易被注意到的问题，但是使用MongoDB时一定要注意的就是避免任何查询的内存操作，因为用MongoDB的很多场景都是海量数据，这个情况下任何内存操作的成本都可能是非常高昂甚至会搞垮数据库的，当然MongoDB为了避免内存操作搞垮它，是有个阈值，如果需要内存处理的数据超过阈值它就不会处理并报错。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;继续说内存排序问题，它的本质是索引问题。MongoDB的索引都是有序的，正序或者逆序。如果我们有一个Collection里面记录了学生信息，包括年龄和性别两个字段。然后我们创建了这样一个复合索引：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;span class=&quot;code-snippet__attr&quot;&gt;gender&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;code-snippet__attr&quot;&gt;age&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;} &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当这个时候，如果你排序顺序是下面这样的话，就会导致内存排序，如果数据两小到没事，如果非常大的话就会影响性能。避免内存排序就是要查询的排序方式要和索引的相同。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;span class=&quot;code-snippet__attr&quot;&gt;gender&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;code-snippet__attr&quot;&gt;age&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;-1&lt;/span&gt;} &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;链式复制&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;链式复制是指副本集的各个副本在复制数据时，并不是都是从Primary节点拉oplog，而是各个节点排成一条链，依次复制过去。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;优点&lt;/span&gt;&lt;span&gt;：避免大量Secondary从Primary拉oplog，影响Primary的性能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缺点&lt;/span&gt;&lt;span&gt;：如果WriteConcern=majority，那么链式复制会导致写操作耗时更长。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此，是否开启链式复制就是一个成本与性能的平衡，默认是开启链式复制的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;链式复制关闭时，节点数据复制对Primary节点性能影响程度目前没有专业测试过，因此不能评判到底开启还是关闭好，这边数据库同学从他们的经验来建议是关闭，因此我这边是关闭的，如果有用到MongoDB的可以考虑关掉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;四、进阶知识&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来终于到了最重要的部分了，这部分将讲解一些MongoDB的一些高级功能和底层设计。虽然不了解这些也能使用，但是如果想用好MongoDB，这部分知识是必须掌握的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（一）存储引擎Wired Tiger&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;说到MongoDB最重要的知识，其存储引擎Wired Tiger肯定是要第一个说的。因为MongoDB的所有功能都是依赖底层存储引擎实现的，掌握了存储引擎的核心知识，有利于我们理解MongoDB的各种功能。存储引擎的核心工作是管理数据如何在磁盘和内存上读写，从MongoDB 3.2开始支持多种存储引擎：Wired Tiger，MMAPv1和In-Memory，其中默认为Wired Tiger。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;B+Tree&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;存储引擎最核心的功能就是完成数据在客户端-内存-磁盘之间的交互。客户端是不可控的，因此如何设计一个高效的数据结构和算法，实现数据快速在内存和磁盘间交互就是存储引擎需要考虑的核心问题。目前大多少流行的存储引擎都是基于B/B+Tree和LSM(Log Structured Merge) Tree来实现，至于他们的优势和劣势，以及各种适用的场景，暂时超出了笔者的能力，后面到是有兴趣去研究一下。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Oracle、SQL Server、DB2、MySQL (InnoDB) 这些传统的关系数据库依赖的底层存储引擎是基于B+ Tree开发的；而像Cassandra、Elasticsearch (Lucene)、Google Bigtable、Apache HBase、LevelDB和RocksDB这些当前比较流行的NoSQL数据库存储引擎是基于LSM开发的。MongoDB虽然是NoSQL的，但是其存储引擎Wired Tiger 却是用的B+Tree，因此有种说法是MongoDB是最接近SQL的NoSQL存储引擎。好了，我们这里知道Wired Tiger的存储结构是B+Tree就行了，至于什么是B+Tree，它有些啥优势网都有很多文章，这里就不在赘述了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Page&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Wired Tiger在内存和磁盘上的数据结构都B+Tree，B+的特点是中间节点只有索引，数据都是存在叶节点。Wired Tiger管理数据结构的基本单元Page。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6114494518879415&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQXT6nd8UyrNhbNwxZShPzZFWx93xqX2gTya2Vcoz5b8ZiaIgJDx8nRObw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1642&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上图是Page在内存中的数据结构，是一个典型的B+ Tree，Page上有3个重要的list WT_ROW、WT_UPDATE、WT_INSERT。这个Page的组织结构和Page的3个list对后面理解cache、checkpoint等操作很重要：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;叶节点Page的WT_ROW：是从磁盘加载进来的数据数组。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;叶节点Page的WT_UPDATE：是记录数据加载之后到下个checkpoint之间被修改的数据。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;叶节点Page的WT_INSERT：是记录数据加载之后到下个checkpoint之间新增的数据。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;上面说了Page的基本结构，接下来再看下Page的生命周期和状态扭转，这个生命周期和Wired Tiger的缓存息息相关。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8660785886126704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQXFOgfA0jUcsXj03xwlZSX6MHwMaEJOkGM9Uic8S85UgCkUSib4RIqsicow/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1247&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Page在磁盘和内存中的整个生命周期状态机如上图：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;READING：Page正在被从磁盘加载到内存中。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;LOCKED：内存淘汰过程（evict）正在锁住Page。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;LOOKASIDE：在执行reconcile的时候，如果page正在被其他线程读取被修改的部分，这个时候会把数据存储在lookasidetable里面。当页面再次被读时可以通过lookasidetable重构出内存Page。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;LIMBO：&lt;/span&gt;&lt;span&gt;在执行完reconcile之后，Page会被&lt;/span&gt;&lt;span&gt;刷到磁盘。&lt;/span&gt;&lt;span&gt;这个时候如果page有lookasidetable数据，并且还没合并过来之前就又被加载到内存了，就会是这个状态，需要先从lookasidetable重构内存Page才能正常访问。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其中两个比较重要的过程是reconcile和evict。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其中reconcile发生在checkpoint的时候，将内存中Page的修改转换成磁盘需要的B+ Tree结构。前面说了Page的WT_UPDATE和WT_UPDATE列表存储了数据被加载到内存之后的修改，类似一个内存级的oplog，而数据在磁盘中时显然不可能是这样的结构。因此reconcile会新建一个Page来将修改了的数据做整合，然后原Page就会被discarded，新page会被刷新到磁盘，同时加入LRU队列。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;evict是内存不够用了或者脏数据过多的时候触发的，根据LRU规则淘汰内存 Page到磁盘。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB不是内存数据库，但是为了提供高效的读写操作存储引擎会最大化的利用内存缓存。MongoDB的读写性能都会随着数据量增加到了某个点出现近乎断崖式跌落最终趋于稳定。这其中的根本原因就是内存是否能cover住全部的数据，数据量小的时候是纯内存读写，性能肯定非常好，当数据量过大时就会触发内存和磁盘间数据的来回交换，导致性能降低。所以，如果在使用MongoDB时，如果发现自己某些操作明显高于常规，那么很大可能是它触发了磁盘操作。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来说下MongoDB的存储引擎Wired Tiger是怎样利用内存cache的。首先，Wired Tiger会将整个内存划分为3块：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;存储引擎内部cache：缓存前面提到的内存数据，默认大小Max((RAM-1G)/2,256M )，服务器16G的话，就是(16-1)/2=7.5G。这个内存配置一定要注意，因为Wired Tiger如果内存不够可能会导致数据库宕掉的。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;文件系统cache：这个实际上不是存储引擎管理，是利用的操作系统的文件系统缓存，目的是减少内存和磁盘交互。剩下的内存都会用来做这个。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;内存分配大小一般是不建议改的，除非你确实想把自己全部数据放到内存，并且主够的引擎知识。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;引擎cache和文件系统cache在数据结构上是不一样的，文件系统cache是直接加载的内存文件，是经过压缩的数据，可以占用更少的内存空间，相对的就是数据不能直接用，需要解压；而引擎中的数据就是前面提到的B+ Tree，是解压后的，可以直接使用的数据，占有的内存会大一些。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Evict&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;就算内存再大它与磁盘间的差距也是数据量级的差异，随着数据增长也会出现内存不够用的时候。因此内存管理一个很重要的操作就是内存淘汰evict。内存淘汰时机由eviction_target（内存使用量）和eviction_dirty_target（内存脏数据量）来控制，而内存淘汰默认是有后台的evict线程控制的。但是如果超过一定阈值就会把用户线程也用来淘汰，会严重影响性能，应该避免这种情况。用户线程参与evict的原因，一般是大量的写入导致磁盘IO抗不住了，需要控制写入或者更换磁盘。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34324659231722426&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQXLWybBbjzspykrbsCNWbxP5Zh3ibx5mRreuOYG93AkgHdiaYqr41j2mJA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1614&quot;/&gt;&lt;/figure&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前面说过，MongoDB的读写都是操作的内存，因此必须要有一定的机制将内存数据持久化到磁盘，这个功能就是Wired Tiger的checkpoint来实现的。checkpoint实现将内存中修改的数据持久化到磁盘，保证系统在因意外重启之后能快速恢复数据。checkpoint本身数据也是会在每次checkpoint执行时落盘持久化的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7451923076923077&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvavNnSoX9tkcNKAh4MBmVzDD62B6SH8ghUJOv53sg3mLItiawVx0GmzwXdOMRmPK9UkX13eAt72icW3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;832&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个checkpoint 就是一个内存B+ Tree，其结构就是前面提到的Page组成的树，它有几个重要的字段：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35030728709394204&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQXtlsEF5THgD8EGW2xhtM7DyQOvIttja7gUxibO2G9XhehcmdUa6Z6KdQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2278&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;checkpoint的大致流程入上图所述：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在系统启动或者集合文件打开时，从磁盘加载最新的checkpoint。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;根据checkpoint的file size truncate文件。因为只有checkpoint确认的数据才是真正持久化的数据，它后面的数据可能是最新checkpoint之后到宕机之间的数据，不能直接用，需要通过Journal日志来回放。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;根据checkpoint构建内存的B+Tree。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据库run起来之后，各种修改操作都是操作checkpoint的B+Tree，并且会checkpoint会有专门的list来记录这些修改和新增的page。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在60s一次的checkpoint执行时，会创建新的checkpoint，并且将旧的 checkpoint数据合并过来。然后执行reconcile将修改的数据刷新到磁盘，并删除旧的checkpoint。这时候会清空allocated，discarded里面的 page，并且将空闲的page加到available里面。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（二）Chunk&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Chunk为啥要单独出来说一下呢，因为它是MongoDB分片集群的一个核心概念，是使用和理解分片集群读写实现的最基础的概念。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，说下chunk是什么，chunk本质上就是由一组Document组成的逻辑数据单元。它是分片集群用来管理数据存储和路由的基本单元。具体来说就是，分片集群不会记录每条数据在哪个分片上，这不现实，它只会记录哪一批（一个chunk）数据存储在哪个分片上，以及这个chunk包含哪些范围的数据。而数据与chunk之间的关联是有数据的shard key的分片算法f(x)的值是否在chunk的起始范围来确定的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前面说过，分片集群的chunk信息是存在Config里面的，而Config本质上是一个复制集群。如果你创建一个分片集群，那么你默认会得到两个库，admin和config，其中config库对应的就是分片集群架构里面的Config。其中的包含一个Collection chunks里面记录的就是分片集群的全部chunk信息，具体结构如下图：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3814026792750197&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQXNC3ok0HhLEN2m8Wt25vgZVI0Vgkk5hW4V3rODWSFPGb9Xwjwq2BLnw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1269&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;chunk的几个关键属性：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;ns：命名空间，就是DB.COLLECTION的结构。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;min：chunk包含数据的shard key的f(x)最小值。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;max：chunk包含数据的shard key的f(x)最大值。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;chunk是分片集群管理数据的基本单元，本身有一个大小，那么随着chunk内的数据不断新增，最终大小会超过限制，这个时候就需要把chunk拆分成2个，这个就chunk的分裂。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;chunk的大小不能太大也不能太小。太大了会导致迁移成本高，太小了有会触发频繁分裂。因此它需要一个合理的范围，默认大小是64M，可配置的取值范围是1M～1024M。这个大小一般来说是不用专门配置的，但是也有特例：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;导致chunk分裂有两个条件，达到任何一个都会触发&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB一个区别于其他分布式数据库的特性就是自动数据均衡。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;chunk分裂是MongoDB保证数据均衡的基础&lt;/span&gt;&lt;span&gt;：数据的不断增加，chunk不断分裂，如果数据不均匀就会导致不同分片上的chunk数目出现差异，这就解决了分片集群的数据不均匀问题发现。然后就可以通过将chunk从数据多的分片迁移到数据少的分片来实现数据均衡，这个过程就是rebalance。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如下图所示，随着数据插入，导致chunk分裂，让AB两个分片有3个 chunk，C分片只有一个，这个时候就会把B分配的迁移一个到C分分片实现集群数据均衡。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.34075104311543813&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQXRBLwurwoRnFrOjSlKEn84xicUh2yTH0YqlJNXZ3EzCric8SNhicypfzVA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1438&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;执行rebalance是有几个前置条件的：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;数据库和集合开启了rebalance开关，默认是开启的。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当前时间在设置的rebalance时间窗，默认没有配置，就是只要检测到了就会执行rebalance。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;集群中分片chunk数最大和最小之差超过阈值，这个阈值和chunk总数有关，具体如下：&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.572347266881029&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQXJsqLGTEEkL43YibIvKSg2wk2t2IGaMlRZVv1aQWdgDIheRllErIlg3Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;622&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;rebalance为了尽快完成数据迁移，其设计是尽最大努力迁移，因此是非常消耗系统资源的，在系统配置不高的时候会影响系统正常业务。因此，为了减少其影响需要：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;预分片：减少大量数据插入时频繁的分裂和迁移chunk。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;对于可能会影响业务的大规模数据迁移，如扩容分片，可以采取手段迁移的方式来控制迁移速度。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（三）一致性/高可用&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;分布式系统必须要面对的一个问题就是数据的一致性和高可用，针对这个问题有一个非常著名的理论就是CAP理论。CAP理论的核心结论是：一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。关于CAP理论在网上有非常多的论述，这里也不赘述。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;CAP理论提出了分布式系统必须面临的问题，但是我们也不可能因为这个问题就不用分布式系统。因此，BASE（Basically Available基本可用、Soft state软状态、Eventually consistent最终一致性）理论被提出来了。BASE理论是在一致性和可用性上的平衡，现在大部分分布式系统都是基于 BASE理论设计的，当然MongoDB也是遵循此理论的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB为了保证可用性和分区容错性，采用的是副本集的方式，这种模式就必须要解决的一个问题就是怎样快速在系统启动和Primary发生异常时选取一个合适的主节点。这里潜在着多个问题：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;哪些Secondary节点有资格参加Primary选举？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;发现Primary异常之后用什么样的算法选出新的Primary节点？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Raft协议&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB的选举算法是基于Raft协议的改进，Raft协议将分布式集群里面的节点有&lt;/span&gt;&lt;span&gt;3种状态&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;leader：就是Primary节点，负责整个集群的写操作。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;candidate：候选者，在Primary节点挂掉之后，参与竞选的节点。只有选举期间才会存在，是个临时状态。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;flower：就是Secondary节点，被动的从Primary节点拉取更新数据。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;节点的状态变化是：正常情况下只有一个leader和多个flower，当leader挂掉了，那么flower里面就会有部分节点成为candidate参与竞选。当某个candidate竞选成功之后就成为新的leader，而其他candidate回到flower状态。具体状态机如下：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5559055118110237&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvat2ibj5sjlnKxe8f1zVhzsQXtbpHL8dbtnrx5tBU8uw5DuJLtNPEpFoXxro2x4SibVDNpNTg4NVddeg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1270&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Raft协议中有两个核心RPC协议分别应用在选举阶段和正常阶段：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;请求投票：选举阶段，candidate向其他节点发起请求，请求对方给自己投票。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;追加条目：正常阶段，leader节点向flower节点发起请求，告诉对方有数据更新，同时作为心跳机制来向所有flower宣示自己的地位。如果flower在一定时间内没有收到该请求就会启动新一轮的选举投票。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;投票规则&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Raft协议规定了在选举阶段的投票规则：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;一个节点，在一个选举周期（Term）内只能给一个candidate节点投赞成票，且先到先得。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;只有在candidate节点的oplog领先或和自己相同时才投赞成票。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;选举过程&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一轮完整的选举过程包含如下内容：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;某个/多个flower节点超时未收到leader的心跳，将自己改变成candidate 状态，增加选举周期（Term），然后先给自己投一票，并向其他节点发起投票请求。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;等待其它节点的投票返回，在此期间如果收到其它candidate发来的请求，根据投票规则给其它节点投票。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果某个candidate在收到过半的赞成票之后，就把自己转换成leader状态，并向其它节点发送心跳宣誓即位。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果节点在没有收到过半赞成票之前，收到了来自leader的心跳，就将自己退回到flower状态。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;只要本轮有选出leader就完成了选举，否则超时启动新一轮选举。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;catchup（追赶）&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以上就是目前掌握的MongoDB的选举机制，其中有个问题暂时还未得到解答，就是最后一个，怎样确保选出的Primary是最合适的那一个。因为，从前面的协议来看，存在一个逻辑bug：&lt;/span&gt;&lt;span&gt;由于flower转换成candidate是随机并行的，再加上先到先得的投票机制会导致选出一个次优的节点成为Primary&lt;/span&gt;&lt;span&gt;。但是这一点应该是笔者自己掌握知识不够，应该是有相关机制保证的，怀疑是通过节点优先级实现的。这点也和相关同学确认过，因此这里暂定此问题不存在，等深入学习这里的细节之后补充其设计和实现。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;针对Raft协议的这个问题，下来查询了一些资料，结论是：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Raft协议确实不保证选举出来的Primary节点是最优的。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;MongoDB通过在选举成功，到新Primary即位之前，新增了一个 catchup（追赶）操作来解决。即在节点获取投票胜利之后，会先检查其它节点是否有比自己更新的oplog，如果没有就直接即位，如果有就先把数据同步过来再即位。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB的主从同步机制是确保数据一致性和可靠性的重要机制。其同步的基础是oplog，类似MySQL的binlog，但是也有一些差异，oplog虽然叫log但并不是一个文件，而是一个集合（Collection）。同时由于 oplog 的并行写入，存在尾部乱序和空洞现象，具体来说就是oplog里面的数据顺序可能是和实际数据顺序不一致，并且存在时间的不连续问题。为了解决这个问题，MongoDB采用的是混合逻辑时钟（HLC）来解决的，HLC不止解决乱序和空洞问题，同时也是用来解决分布式系统上事务一致性的方案。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主从同步的本质实际上就是，Primary节点接收客户端请求，将更新操作写到oplog，然后Secondary从同步源拉取oplog并本地回放，实现数据的同步。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同步源选取&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同步源是指节点拉取oplog的源节点，这个节点不一定是Primary，链式复制模式下就可能是任何节点。节点的同步源选取是一个非常复杂的过程，大致上来说是：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;节点维护整个集群的全部节点信息，并每2s发送一次心跳检测，存活的节点都是同步源备选节点。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;落后自己的节点不能做同步源：就是源节点最新的opTime不能小于自己最新的opTime。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;太超前的节点不能作为同步源：就是源节点最老的opTime不能大于自己最新的opTime，否则有oplog空洞。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在同步源选取时有些特殊情况：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果关闭链式复制，所有Secondary节点的同步源都是Primary节点。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;oplog拉取和回放&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;整个拉取和回放的逻辑非常复杂，这里根据自己的理解简化说明，如果想了解更多知识可以参考&lt;/span&gt;&lt;span&gt;《MongoDB复制技术内幕》&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;节点有一个专门拉取oplog的线程，通过Exhausted cursor从同步源拉取 oplog。拉取下来之后，并不会执行回放执行，而是会将其丢到一个本地的阻塞队列中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然后有多个具体的执行线程，从阻塞队列中取出oplog并执行。在取出过程中，同一个Collection的oplog一定会被同一个线程取出执行，线程会尽可能的合并连续的插入命令。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;整个回放的执行过程，大致为先加锁，然后写本店oplog，然后将oplog刷盘（WAL机制），最后更新自己的最新opTime。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（四）索引&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;索引对任何数据库而言都是非常重要的一个功能。数据库支持的索引类型，决定的数据库的查询方式和应用场景。而正确的使用索引能够让我们最大化的利用数据库性能，同时避免不合理的操作导致的数据库问题，最常见的问题就是CPU或内存耗尽。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB的索引和MySql的索引有点不一样，它的索引在创建时必须指定顺序（1：升序，-1：降序），同时所有的集合都有一个默认索引 _id，这是一个唯一索引，类似MySql的主键。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;MongoDB支持的索引类型有：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;单字段索引：建立在单个字段上的索引，索引创建的排序顺序无所谓，MongoDB可以头/尾开始遍历。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;多key索引：我们知道MongoDB的一个字段可能是数组，在对这种字段创建索引时，就是多key索引。MongoDB会为数组的每个值创建索引。就是说你可以按照数组里面的值做条件来查询，这个时候依然会走索引。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Hash索引：按数据的哈希值索引，用在hash分片集群上。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;地理位置索引：基于经纬度的索引，适合2D和3D的位置查询。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;文本索引：MongoDB虽然支持全文索引，但是性能低下，暂时不建议使用。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h5&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;索引功能强大，但是也有很多限制，使用索引时一定要注意一些问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;复合索引&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;复合索引有几个问题需要注意：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;避免内存排序：复合索引除第一个字段之外，其他字段的查询排序方式，必须和索引排序方式一致，否则会导致内存排序。如前面的索引，可以支持 {userid:-1,score:-1}的查询，同时也能支持{userid:1,score:1}的查询，只是后一种需要内存排序score字段。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;索引交集：索引交集时查询优化器的优化方案，很少用到，尽量不要依赖这个功能。索引交集本质上就有创建两个独立的单字段索引，在查询保护两个字段时，优化器自动做索引交集。如{user:1}+{score:-1}两个索引的交集可以支持前面的{userid:1,score:1}的查询&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;后台创建索引&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在对一个已经拥有较大数据集的Collection创建索引时，建议通过创建命令参数指定后台创建，不会阻塞命令和意外中断。但是，在后台创建多个索引时，不能命令执行完就接着下一个。因为是后台创建，命令行虽然推出了，但是索引还没创建完。这个时候如果同事输入多个创建索引命令，会因为大量的写操作和数据复制导致系统cpu耗尽。这个时候需要观察系统监控，确定第一个索引创建完了再执行下一个。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;explain是MongoDB的查询计划工具，和MySql的explain功能相同，都是用来分析一条语句的索引使用情况、影响行数、执行时间等。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;explain有三种参数分别对应结果输出的三部分数据：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;queryPlanner：MongoDB运行查询优化器对当前的查询进行评估并选择一个最佳的查询计划。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;exectionStats：mongoDB运行查询优化器对当前的查询进行评估并选择一个最佳的查询计划进行执行。在执行完毕后返回这个最佳执行计划执行完成时的相关统计信息。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;allPlansExecution：即按照最佳的执行计划执行以及列出统计信息，如果有多个查询计划，还会列出这些非最佳执行计划部分的统计信息。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;explain是一个非常有用的工具，建议在一个数据量较大的数据库上开发新功能时，一定要用explain分析一下自己的语句是否合理、索引是否合理，避免在项目上线之后出现问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt; 作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe96wFFuYibavG2DePVqax9J0BmzP4xvWAROiawpjb0Cr7JVzic9qm47nZgyIicJRe0VWJiafPL4xxgDv0CQ/0?wx_fmt=jpeg&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;134.09523809523807&quot; data-cropy2=&quot;1414.095238095238&quot; data-fileid=&quot;100043716&quot; data-ratio=&quot;1.000925925925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe96wFFuYibavG2DePVqax9J0BlFpfajib50UP3traPRdf7kJgQoNgf7sfZWpRgwZnIhTY8kPPeeredJA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;sakychen&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;&lt;span&gt;腾讯应用开发工程师&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;腾讯应用开发工程师，毕业于电子科技大学，目前主要从事腾讯优码的码平台设计和开发工作。喜欢研究新技术，擅长快速梳理和总结复杂事物的逻辑脉络，并乐于和同事分享总结和经验。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;37b42a3b6ddcc414e6e32be4a161956e&quot;&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt; 推荐阅读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247538447&amp;amp;idx=1&amp;amp;sn=3d6ff1dae8f2ed056e9012fb7e860ddc&amp;amp;chksm=eaa84d5fdddfc4495e89716470071c0ff65507a638fe409347c93aef6bd99f2934172200c89e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;解锁tRPC高性能密码：网络方案简介！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;解锁tRPC高性能密码：网络方案简介！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247538296&amp;amp;idx=1&amp;amp;sn=97eacded099b48cc2f117a590c939a57&amp;amp;chksm=eaa84c28dddfc53e644d86a54577a3bdbda3b0eadfe14a202a9d24604c2782b5b9b61b2c8941&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;异步编程指北！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;异步编程指北！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247538229&amp;amp;idx=1&amp;amp;sn=2d7dcbb1b79fc2a53ffb20dbc0741cef&amp;amp;chksm=eaa84c65dddfc573bed4f9558174eb14dc8a8d917594a9a111f39a48563206a19a7d96bc3ed1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;图文结合！Redis延迟队列golang高效实践&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;图文结合！Redis延迟队列golang高效实践&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI2NDU4OTExOQ==&amp;amp;mid=2247537945&amp;amp;idx=1&amp;amp;sn=d51d07540f96441cd96ee708480c4646&amp;amp;chksm=eaa84f49dddfc65f817c15fe9885414cb6b305dd71dbe0f939a7d46134aee03201fa406b64c7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;开箱即用！深入浅出Prometheus监控神器&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;开箱即用！深入浅出Prometheus监控神器&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI2NDU4OTExOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96FK2eEg86vUicOR3n6kAHk1PHvTb8VBicYk0RmNQYsQyibgg8iaZqT0bCEU9VKo3Z3iceoQfgycyMpKWQ/0?wx_fmt=png&quot; data-nickname=&quot;云加社区&quot; data-alias=&quot;QcloudCommunity&quot; data-signature=&quot;腾讯云官方社区公众号，汇聚技术开发者群体，分享技术干货，打造技术影响力交流社区。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.59375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/VY8SELNGe977Xa5zfy5iaV3agpS11Cqm4xV7ckfbmtFLyUjFID2k7yO4q8hvB4OqYoNkARZ2xuvzKvMtnmVN2BQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>da4e46faa80112f52f437e7c44d744b9</guid>
<title>吐血推荐17个提升开发效率的“轮子”</title>
<link>https://toutiao.io/k/10u7n9b</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;chksm=fa496f8ecd3ee698f4954c00efb80fe955ec9198fff3ef4011e331aa37f55a6a17bc8c0335a8&amp;amp;scene=21&amp;amp;token=899450012&amp;amp;lang=zh_CN#wechat_redirect&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibJZVicC7nz5gEUIHd7HFBm8mgd6RiavSHC3iaDgONobX3XIWtLZw2jHzLoqHBz9HpWiacGZMYqjKU41o1trASibVM6A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;800&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/section&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java的庞大体系中，其实有很多不错的小工具，也就是我们平常说的：&lt;code&gt;轮子&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在我们的日常工作当中，能够将这些轮子用户，再配合一下idea的快捷键，可以极大得提升我们的开发效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我决定把一些压箱底的小工具，分享给大家，希望对你有所帮助。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文会分享17个我们日常工作中一定会用得到的小工具。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;基于 Spring Boot + MyBatis Plus + Vue &amp;amp; Element 实现的后台管理系统 + 用户小程序，支持 RBAC 动态权限、多租户、数据权限、工作流、三方登录、支付、短信、商城等功能。&lt;/p&gt;&lt;p&gt;项目地址：https://github.com/YunaiV/ruoyi-vue-pro&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先出场的是&lt;code&gt;java.util&lt;/code&gt;包下的&lt;code&gt;Collections&lt;/code&gt;类，该类主要用于操作集合或者返回集合，我个人非常喜欢用它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在工作中经常有对集合排序的需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看看使用&lt;code&gt;Collections&lt;/code&gt;工具是如何实现升序和降序的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;  list.add(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;  list.add(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;  list.add(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;  Collections.sort(list);&lt;span&gt;//升序&lt;/span&gt;&lt;br/&gt;  System.out.println(list);&lt;br/&gt;  Collections.reverse(list);&lt;span&gt;//降序&lt;/span&gt;&lt;br/&gt;  System.out.println(list);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候需要找出集合中的&lt;code&gt;最大值&lt;/code&gt;或者&lt;code&gt;最小值&lt;/code&gt;，这时可以使用Collections的&lt;code&gt;max&lt;/code&gt;和&lt;code&gt;min&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;list.add(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;list.add(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;list.add(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;Integer max = Collections.max(list);&lt;span&gt;//获取最大值&lt;/span&gt;&lt;br/&gt;Integer min = Collections.min(list);&lt;span&gt;//获取最小值&lt;/span&gt;&lt;br/&gt;System.out.println(max);&lt;br/&gt;System.out.println(min);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道，java中的很多集合，比如：ArrayList、LinkedList、HashMap、HashSet等，都是线程不安全的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;换句话说，这些集合在多线程的环境中，添加数据会出现异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时，可以用Collections的&lt;code&gt;synchronizedxxx&lt;/code&gt;方法，将这些线程不安全的集合，直接转换成线程安全集合。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;  list.add(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;  list.add(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;  list.add(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  List&amp;lt;Integer&amp;gt; integers = Collections.synchronizedList(list);&lt;span&gt;//将ArrayList转换成线程安全集合&lt;/span&gt;&lt;br/&gt;  System.out.println(integers);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的底层会创建&lt;code&gt;SynchronizedRandomAccessList&lt;/code&gt;或者&lt;code&gt;SynchronizedList&lt;/code&gt;类，这两个类的很多方法都会用&lt;code&gt;synchronized&lt;/code&gt;加锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时，我们在判空之后，需要返回空集合，就可以使用&lt;code&gt;emptyList&lt;/code&gt;方法，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; List&amp;lt;Integer&amp;gt; &lt;span&gt;fun&lt;/span&gt;&lt;span&gt;(List&amp;lt;Integer&amp;gt; list)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (list == &lt;span&gt;null&lt;/span&gt; || list.size() == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Collections.emptyList();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//业务处理&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; list;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;binarySearch&lt;/code&gt;方法提供了一个非常好用的&lt;code&gt;二分查找&lt;/code&gt;功能，只用传入指定集合和需要找到的key即可。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;list.add(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;list.add(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;list.add(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; i = Collections.binarySearch(list, &lt;span&gt;3&lt;/span&gt;);&lt;span&gt;//二分查找&lt;/span&gt;&lt;br/&gt;System.out.println(i );&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了防止后续的程序把某个集合的结果修改了，有时候我们需要把某个集合定义成不可修改的，使用Collections的&lt;code&gt;unmodifiablexxx&lt;/code&gt;方法就能轻松实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;list.add(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;list.add(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;list.add(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;List&amp;lt;Integer&amp;gt; integers = Collections.unmodifiableList(list);&lt;br/&gt;integers.add(&lt;span&gt;4&lt;/span&gt;);&lt;br/&gt;System.out.println(integers);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Exception in thread &lt;span&gt;&quot;main&quot;&lt;/span&gt; java.lang.UnsupportedOperationException&lt;br/&gt; at java.util.Collections$UnmodifiableCollection.add(Collections.java:&lt;span&gt;1055&lt;/span&gt;)&lt;br/&gt; at com.sue.jump.service.test1.UtilTest.main(UtilTest.java:&lt;span&gt;19&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然Collections工具类中还有很多常用的方法，在这里就不一一介绍了，需要你自己去探索。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7UhX8BflOYas3SicLTLLxxGI9gRNEhmtG6LWX7N3xA5iaicqIDJC3q9jP8wQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9537037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7UhEZoGXa23Xw1JibibNO6ibLI2vBlxv3SxNEHDibFdTUmib2mgshUjFBjg1vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;基于微服务的思想，构建在 B2C 电商场景下的项目实战。核心技术栈，是 Spring Boot + Dubbo 。未来，会重构成 Spring Cloud Alibaba 。&lt;/p&gt;&lt;p&gt;项目地址：https://github.com/YunaiV/onemall&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对集合操作，除了前面说的&lt;code&gt;Collections&lt;/code&gt;工具类之后，&lt;code&gt;CollectionUtils&lt;/code&gt;工具类也非常常用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前比较主流的是&lt;code&gt;spring&lt;/code&gt;的&lt;code&gt;org.springframework.util&lt;/code&gt;包下的CollectionUtils工具类。&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.674074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7UhJvoort7hZkFwfREJMFq6YeHYly4brlia3zsANmBZMOKvA6ep98GILNQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和&lt;code&gt;apache&lt;/code&gt;的&lt;code&gt;org.apache.commons.collections&lt;/code&gt;包下的CollectionUtils工具类。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.025&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7UhkhTKCXIEcqzSGAU6EtiaQfyw7xWibc2VSIoPL7huiaK9VOCgGeOGbr8JA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7Uhn5zDWiaEWtfcWKgMn47uOMicL4Z4tibG7PgH5PspZqGgW5h8qA0htt0lQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;我个人更推荐使用apache的包下的CollectionUtils工具类，因为它的工具更多更全面。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个简单的例子，&lt;code&gt;spring&lt;/code&gt;的CollectionUtils工具类没有判断集合不为空的方法。而&lt;code&gt;apache&lt;/code&gt;的CollectionUtils工具类却有。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们以&lt;code&gt;apache&lt;/code&gt;的CollectionUtils工具类为例，介绍一下常用方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过CollectionUtils工具类的&lt;code&gt;isEmpty&lt;/code&gt;方法可以轻松判断集合是否为空，&lt;code&gt;isNotEmpty&lt;/code&gt;方法判断集合不为空。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;list.add(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;list.add(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;list.add(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (CollectionUtils.isEmpty(list)) {&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;集合为空&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (CollectionUtils.isNotEmpty(list)) {&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;集合不为空&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候我们需要对已有的两个集合进行操作，比如取交集或者并集等。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;list.add(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;list.add(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;list.add(&lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;List&amp;lt;Integer&amp;gt; list2 = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;list2.add(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;list2.add(&lt;span&gt;4&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//获取并集&lt;/span&gt;&lt;br/&gt;Collection&amp;lt;Integer&amp;gt; unionList = CollectionUtils.union(list, list2);&lt;br/&gt;System.out.println(unionList);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//获取交集&lt;/span&gt;&lt;br/&gt;Collection&amp;lt;Integer&amp;gt; intersectionList = CollectionUtils.intersection(list, list2);&lt;br/&gt;System.out.println(intersectionList);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//获取交集的补集&lt;/span&gt;&lt;br/&gt;Collection&amp;lt;Integer&amp;gt; disjunctionList = CollectionUtils.disjunction(list, list2);&lt;br/&gt;System.out.println(disjunctionList);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//获取差集&lt;/span&gt;&lt;br/&gt;Collection&amp;lt;Integer&amp;gt; subtractList = CollectionUtils.subtract(list, list2);&lt;br/&gt;System.out.println(subtractList);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;2&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;]&lt;br/&gt;[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说句实话，对两个集合的操作，在实际工作中用得挺多的，特别是很多批量的场景中。以前我们需要写一堆代码，但没想到有现成的轮子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你引入&lt;code&gt;com.google.guava&lt;/code&gt;的pom文件，会获得很多好用的小工具。这里推荐一款&lt;code&gt;com.google.common.collect&lt;/code&gt;包下的集合工具：&lt;code&gt;Lists&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它是在太好用了，让我爱不释手。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们想创建一个空集合。这时可以用Lists的&lt;code&gt;newArrayList&lt;/code&gt;方法，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = Lists.newArrayList();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们想给一个集合中初始化一些元素。这时可以用Lists的newArrayList方法，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = Lists.newArrayList(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想将两个集合做&lt;code&gt;笛卡尔积&lt;/code&gt;，Lists的&lt;code&gt;cartesianProduct&lt;/code&gt;方法可以帮你实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list1 = Lists.newArrayList(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;List&amp;lt;Integer&amp;gt; list2 = Lists.newArrayList(&lt;span&gt;4&lt;/span&gt;,&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; productList = Lists.cartesianProduct(list1,list2);&lt;br/&gt;System.out.println(productList);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;], [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;], [&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;], [&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;], [&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;], [&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想将一个&lt;code&gt;大集合&lt;/code&gt;分成若干个&lt;code&gt;小集合&lt;/code&gt;，可以使用Lists的&lt;code&gt;partition&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = Lists.newArrayList(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; partitionList = Lists.partition(list, &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;System.out.println(partitionList);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[[&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;], [&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;], [&lt;span&gt;5&lt;/span&gt;]]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子中，list有5条数据，我将list集合按大小为2，分成了3页，即变成3个小集合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是我最喜欢的方法之一，经常在项目中使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如有个需求：现在有5000个id，需要调用批量用户查询接口，查出用户数据。但如果你直接查5000个用户，单次接口响应时间可能会非常慢。如果改成分页处理，每次只查500个用户，异步调用10次接口，就不会有单次接口响应慢的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们想把某个集合转换成另外一个接口，可以使用Lists的&lt;code&gt;transform&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;String&amp;gt; list = Lists.newArrayList(&lt;span&gt;&quot;a&quot;&lt;/span&gt;,&lt;span&gt;&quot;b&quot;&lt;/span&gt;,&lt;span&gt;&quot;c&quot;&lt;/span&gt;);&lt;br/&gt;List&amp;lt;String&amp;gt; transformList = Lists.transform(list, x -&amp;gt; x.toUpperCase());&lt;br/&gt;System.out.println(transformList);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将小写字母转换成了大写字母。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lists的有颠倒顺序的方法&lt;code&gt;reverse&lt;/code&gt;。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Integer&amp;gt; list = Lists.newArrayList(&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;List&amp;lt;Integer&amp;gt; reverseList = Lists.reverse(list);&lt;br/&gt;System.out.println(reverseList);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;[&lt;span&gt;2&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;list的原始顺序是312，使用&lt;code&gt;reverse&lt;/code&gt;方法颠倒顺序之后，变成了213。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lists还有其他的好用的工具，我在这里只是抛砖引玉，有兴趣的朋友，可以仔细研究一下。&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7861111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7UhlSZTfIOibDn3ZqZlxbtwGtUkIYcUtYIZ3R6S05et6jI0icjjHwqzHxLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;jdk7&lt;/code&gt;之后，提供了&lt;code&gt;Objects&lt;/code&gt;工具类，我们可以通过它操作对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java中万事万物皆对象，对象的判空可以说无处不在。Objects的&lt;code&gt;isNull&lt;/code&gt;方法判断对象是否为空，而&lt;code&gt;nonNull&lt;/code&gt;方法判断对象是否不为空。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Integer integer = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (Objects.isNull(integer)) {&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;对象为空&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (Objects.nonNull(integer)) {&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;对象不为空&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们想在对象为空时，抛出空指针异常，可以使用Objects的&lt;code&gt;requireNonNull&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Integer integer1 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;128&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;Objects.requireNonNull(integer1);&lt;br/&gt;Objects.requireNonNull(integer1, &lt;span&gt;&quot;参数不能为空&quot;&lt;/span&gt;);&lt;br/&gt;Objects.requireNonNull(integer1, () -&amp;gt; &lt;span&gt;&quot;参数不能为空&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们经常需要判断两个对象是否相等，Objects给我们提供了&lt;code&gt;equals&lt;/code&gt;方法，能非常方便的实现：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Integer integer1 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;Integer integer2 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;System.out.println(Objects.equals(integer1, integer2));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但使用这个方法有坑，比如例子改成：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Integer integer1 = &lt;span&gt;new&lt;/span&gt; Integer(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;Long integer2 = &lt;span&gt;new&lt;/span&gt; Long(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;System.out.println(Objects.equals(integer1, integer2));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体原因不细说了，有兴趣的小伙们可以看看我的另一篇文章《Objects.equals有坑》，里面有非常详细的讲解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想获取某个对象的hashCode，可以使用Objects的&lt;code&gt;hashCode&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String str = &lt;span&gt;new&lt;/span&gt; String(&lt;span&gt;&quot;abc&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(Objects.hashCode(str));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;96354&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Objects的内容先介绍到这里，有兴趣的小伙们，可以看看下面更多的方法：&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.662004662004662&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7Uhlt1anvibHLapehvbqN7QTgLf4SRaj59QN0qEU2zpW3LM6tj4RkibsTaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;858&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在java中布尔值，随处可见。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你使用了布尔的包装类：&lt;code&gt;Boolean&lt;/code&gt;，总感觉有点麻烦，因为它有三种值：&lt;code&gt;null&lt;/code&gt;、&lt;code&gt;true&lt;/code&gt;、&lt;code&gt;false&lt;/code&gt;。我们在处理Boolean对象时，需要经常判空。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;头疼！！！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果使用&lt;code&gt;BooleanUtils&lt;/code&gt;类处理布尔值，心情一下子就愉悦起来了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想判断某个参数的值是true或false，可以直接使用&lt;code&gt;isTrue&lt;/code&gt;或&lt;code&gt;isFalse&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Boolean aBoolean = &lt;span&gt;new&lt;/span&gt; Boolean(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;System.out.println(BooleanUtils.isTrue(aBoolean));&lt;br/&gt;System.out.println(BooleanUtils.isFalse(aBoolean));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，需要判断某个参数不为true，即是null或者false。或者判断不为false，即是null或者true。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用&lt;code&gt;isNotTrue&lt;/code&gt;或&lt;code&gt;isNotFalse&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Boolean aBoolean = &lt;span&gt;new&lt;/span&gt; Boolean(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;Boolean aBoolean1 = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;System.out.println(BooleanUtils.isNotTrue(aBoolean));&lt;br/&gt;System.out.println(BooleanUtils.isNotTrue(aBoolean1));&lt;br/&gt;System.out.println(BooleanUtils.isNotFalse(aBoolean));&lt;br/&gt;System.out.println(BooleanUtils.isNotFalse(aBoolean1));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想将true转换成数字1，false转换成数字0，可以使用&lt;code&gt;toInteger&lt;/code&gt;方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Boolean aBoolean = &lt;span&gt;new&lt;/span&gt; Boolean(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;Boolean aBoolean1 = &lt;span&gt;new&lt;/span&gt; Boolean(&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;System.out.println(BooleanUtils.toInteger(aBoolean));&lt;br/&gt;System.out.println(BooleanUtils.toInteger(aBoolean1));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们有时候需要将包装类&lt;code&gt;Boolean&lt;/code&gt;对象，转换成原始的&lt;code&gt;boolean&lt;/code&gt;对象，可以使用&lt;code&gt;toBoolean&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Boolean aBoolean = &lt;span&gt;new&lt;/span&gt; Boolean(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;Boolean aBoolean1 = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;System.out.println(BooleanUtils.toBoolean(aBoolean));&lt;br/&gt;System.out.println(BooleanUtils.toBoolean(aBoolean1));&lt;br/&gt;System.out.println(BooleanUtils.toBooleanDefaultIfNull(aBoolean1, &lt;span&gt;false&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们无需额外的判空了，而且还可以设置Boolean对象为空时返回的默认值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BooleanUtils类的方法还有很多，有兴趣的小伙伴可以看看下面的内容：&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.124074074074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7Uh2MZD07FW7NXXcUy0icracXNDicYLQE5M4myUdgnWpWbqLFcYWnPRKfRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;字符串&lt;/code&gt;（String）在我们的日常工作中，用得非常非常非常多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们的代码中经常需要对字符串判空，截取字符串、转换大小写、分隔字符串、比较字符串、去掉多余空格、拼接字符串、使用正则表达式等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果只用String类提供的那些方法，我们需要手写大量的额外代码，不然容易出现各种异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在有个好消息是：&lt;code&gt;org.apache.commons.lang3&lt;/code&gt;包下的&lt;code&gt;StringUtils&lt;/code&gt;工具类，给我们提供了非常丰富的选择。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实空字符串，不只是null一种，还有&quot;&quot;，&quot; &quot;，&quot;null&quot;等等，多种情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;StringUtils给我们提供了多个判空的静态方法，例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; String str1 = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;String str2 = &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;String str3 = &lt;span&gt;&quot; &quot;&lt;/span&gt;;&lt;br/&gt;String str4 = &lt;span&gt;&quot;abc&quot;&lt;/span&gt;;&lt;br/&gt;System.out.println(StringUtils.isEmpty(str1));&lt;br/&gt;System.out.println(StringUtils.isEmpty(str2));&lt;br/&gt;System.out.println(StringUtils.isEmpty(str3));&lt;br/&gt;System.out.println(StringUtils.isEmpty(str4));&lt;br/&gt;System.out.println(&lt;span&gt;&quot;=====&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(StringUtils.isNotEmpty(str1));&lt;br/&gt;System.out.println(StringUtils.isNotEmpty(str2));&lt;br/&gt;System.out.println(StringUtils.isNotEmpty(str3));&lt;br/&gt;System.out.println(StringUtils.isNotEmpty(str4));&lt;br/&gt;System.out.println(&lt;span&gt;&quot;=====&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(StringUtils.isBlank(str1));&lt;br/&gt;System.out.println(StringUtils.isBlank(str2));&lt;br/&gt;System.out.println(StringUtils.isBlank(str3));&lt;br/&gt;System.out.println(StringUtils.isBlank(str4));&lt;br/&gt;System.out.println(&lt;span&gt;&quot;=====&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(StringUtils.isNotBlank(str1));&lt;br/&gt;System.out.println(StringUtils.isNotBlank(str2));&lt;br/&gt;System.out.println(StringUtils.isNotBlank(str3));&lt;br/&gt;System.out.println(StringUtils.isNotBlank(str4));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;=====&lt;br/&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;=====&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;=====&lt;br/&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例中的：&lt;code&gt;isEmpty&lt;/code&gt;、&lt;code&gt;isNotEmpty&lt;/code&gt;、&lt;code&gt;isBlank&lt;/code&gt;和&lt;code&gt;isNotBlank&lt;/code&gt;，这4个判空方法你们可以根据实际情况使用。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;优先推荐使用&lt;code&gt;isBlank&lt;/code&gt;和&lt;code&gt;isNotBlank&lt;/code&gt;方法，因为它会把&lt;code&gt;&quot; &quot;&lt;/code&gt;也考虑进去。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分隔字符串是常见需求，如果直接使用String类的split方法，就可能会出现空指针异常。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String str1 = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;System.out.println(StringUtils.split(str1,&lt;span&gt;&quot;,&quot;&lt;/span&gt;));&lt;br/&gt;System.out.println(str1.split(&lt;span&gt;&quot;,&quot;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;null&lt;/span&gt;&lt;br/&gt;Exception in thread &lt;span&gt;&quot;main&quot;&lt;/span&gt; java.lang.NullPointerException&lt;br/&gt; at com.sue.jump.service.test1.UtilTest.main(UtilTest.java:&lt;span&gt;21&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用StringUtils的split方法会返回null，而使用String的split方法会报指针异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给定一个字符串，判断它是否为纯数字，可以使用&lt;code&gt;isNumeric&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String str1 = &lt;span&gt;&quot;123&quot;&lt;/span&gt;;&lt;br/&gt;String str2 = &lt;span&gt;&quot;123q&quot;&lt;/span&gt;;&lt;br/&gt;String str3 = &lt;span&gt;&quot;0.33&quot;&lt;/span&gt;;&lt;br/&gt;System.out.println(StringUtils.isNumeric(str1));&lt;br/&gt;System.out.println(StringUtils.isNumeric(str2));&lt;br/&gt;System.out.println(StringUtils.isNumeric(str3));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们需要将某个集合的内容，拼接成一个字符串，然后输出，这时可以使用&lt;code&gt;join&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;String&amp;gt; list = Lists.newArrayList(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;c&quot;&lt;/span&gt;);&lt;br/&gt;List&amp;lt;Integer&amp;gt; list2 = Lists.newArrayList(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;System.out.println(StringUtils.join(list, &lt;span&gt;&quot;,&quot;&lt;/span&gt;));&lt;br/&gt;System.out.println(StringUtils.join(list2, &lt;span&gt;&quot; &quot;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;a,b,c&lt;br/&gt;&lt;span&gt;1&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然还有很多实用的方法，我在这里就不一一介绍了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9046296296296297&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7UhlvMeG2HrX8aImcgnc0d207UpHbDEHg5tVouHiaqAYGILl2UIfWxPticA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9953703703703703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7UhthmcPYsBNKDqLx5joUwlSE3tkwe3LYHSNcIMiaupuiamsQ2pibzXyzrXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，我们需要在代码中做判断：如果不满足条件，则抛异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有没有统一的封装呢?&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实&lt;code&gt;spring&lt;/code&gt;给我们提供了&lt;code&gt;Assert&lt;/code&gt;类，它表示&lt;code&gt;断言&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;断言&lt;code&gt;参数&lt;/code&gt;是否空，如果不满足条件，则直接抛异常。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String str = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;Assert.isNull(str, &lt;span&gt;&quot;str必须为空&quot;&lt;/span&gt;);&lt;br/&gt;Assert.isNull(str, () -&amp;gt; &lt;span&gt;&quot;str必须为空&quot;&lt;/span&gt;);&lt;br/&gt;Assert.notNull(str, &lt;span&gt;&quot;str不能为空&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不满足条件就会抛出&lt;code&gt;IllegalArgumentException&lt;/code&gt;异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;断言&lt;code&gt;集合&lt;/code&gt;是否空，如果不满足条件，则直接抛异常。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;String&amp;gt; list = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;Map&amp;lt;String, String&amp;gt; map = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;Assert.notEmpty(list, &lt;span&gt;&quot;list不能为空&quot;&lt;/span&gt;);&lt;br/&gt;Assert.notEmpty(list, () -&amp;gt; &lt;span&gt;&quot;list不能为空&quot;&lt;/span&gt;);&lt;br/&gt;Assert.notEmpty(map, &lt;span&gt;&quot;map不能为空&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不满足条件就会抛出&lt;code&gt;IllegalArgumentException&lt;/code&gt;异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;断言是否满足某个&lt;code&gt;条件&lt;/code&gt;，如果不满足条件，则直接抛异常。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;String&amp;gt; list = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;Assert.isTrue(CollectionUtils.isNotEmpty(list), &lt;span&gt;&quot;list不能为空&quot;&lt;/span&gt;);&lt;br/&gt;Assert.isTrue(CollectionUtils.isNotEmpty(list), () -&amp;gt; &lt;span&gt;&quot;list不能为空&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然Assert类还有一些其他的功能，这里就不多介绍了。&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2472222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7Uh7OKzquJaWkfLd8Ih6ibUNPStj7vQCWVicBEOXNQGuIhJbNYkgSNZwmtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;IO&lt;/code&gt;流在我们日常工作中也用得比较多，尽管java已经给我们提供了丰富的API。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但我们不得不每次读取文件，或者写入文件之后，写一些重复的的代码。手动在&lt;code&gt;finally&lt;/code&gt;代码块中关闭流，不然可能会造成&lt;code&gt;内存溢出&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有个好消息是：如果你使用&lt;code&gt;org.apache.commons.io&lt;/code&gt;包下的&lt;code&gt;IOUtils&lt;/code&gt;类，会节省大量的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想将某个txt文件中的数据，读取到字符串当中，可以使用IOUtils类的&lt;code&gt;toString&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String str = IOUtils.toString(&lt;span&gt;new&lt;/span&gt; FileInputStream(&lt;span&gt;&quot;/temp/a.txt&quot;&lt;/span&gt;), StandardCharsets.UTF_8);&lt;br/&gt;System.out.println(str);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想将某个字符串的内容，写入到指定文件当中，可以使用IOUtils类的&lt;code&gt;write&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String str = &lt;span&gt;&quot;abcde&quot;&lt;/span&gt;;&lt;br/&gt;IOUtils.write(str, &lt;span&gt;new&lt;/span&gt; FileOutputStream(&lt;span&gt;&quot;/temp/b.tx&quot;&lt;/span&gt;), StandardCharsets.UTF_8);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想将某个文件中的所有内容，都拷贝到另一个文件当中，可以使用IOUtils类的&lt;code&gt;copy&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;IOUtils.copy(&lt;span&gt;new&lt;/span&gt; FileInputStream(&lt;span&gt;&quot;/temp/a.txt&quot;&lt;/span&gt;), &lt;span&gt;new&lt;/span&gt; FileOutputStream(&lt;span&gt;&quot;/temp/b.txt&quot;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想将某个文件中的内容，读取字节数组中，可以使用IOUtils类的&lt;code&gt;toByteArray&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;byte&lt;/span&gt;[] bytes = IOUtils.toByteArray(&lt;span&gt;new&lt;/span&gt; FileInputStream(&lt;span&gt;&quot;/temp/a.txt&quot;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IOUtils类非常实用，感兴趣的小伙们，可以看看下面内容。&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1564814814814814&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7Uh6HLLwUBK302H4peAUR5BWpicqf2xReNPOKtzvCRRfkNdHEORYC9ePWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;MDC&lt;/code&gt;是&lt;code&gt;org.slf4j&lt;/code&gt;包下的一个类，它的全称是Mapped Diagnostic Context，我们可以认为它是一个线程安全的存放诊断日志的容器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MDC的底层是用了&lt;code&gt;ThreadLocal&lt;/code&gt;来保存数据的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以用它传递参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如现在有这样一种场景：我们使用&lt;code&gt;RestTemplate&lt;/code&gt;调用远程接口时，有时需要在&lt;code&gt;header&lt;/code&gt;中传递信息，比如：traceId，source等，便于在查询日志时能够串联一次完整的请求链路，快速定位问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种业务场景就能通过&lt;code&gt;ClientHttpRequestInterceptor&lt;/code&gt;接口实现，具体做法如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步，定义一个LogFilter拦截所有接口请求，在MDC中设置traceId：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LogFilter&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Filter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;(FilterConfig filterConfig)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ServletException &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doFilter&lt;/span&gt;&lt;span&gt;(ServletRequest request, ServletResponse response, FilterChain chain)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException, ServletException &lt;/span&gt;{&lt;br/&gt;        MdcUtil.add(UUID.randomUUID().toString());&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;记录请求日志&quot;&lt;/span&gt;);&lt;br/&gt;        chain.doFilter(request, response);&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;记录响应日志&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;destroy&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步，实现&lt;code&gt;ClientHttpRequestInterceptor&lt;/code&gt;接口，MDC中获取当前请求的traceId，然后设置到header中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RestTemplateInterceptor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ClientHttpRequestInterceptor&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ClientHttpResponse &lt;span&gt;intercept&lt;/span&gt;&lt;span&gt;(HttpRequest request, &lt;span&gt;byte&lt;/span&gt;[] body, ClientHttpRequestExecution execution)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        request.getHeaders().set(&lt;span&gt;&quot;traceId&quot;&lt;/span&gt;, MdcUtil.get());&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; execution.execute(request, body);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三步，定义配置类，配置上面定义的&lt;code&gt;RestTemplateInterceptor&lt;/code&gt;类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RestTemplateConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; RestTemplate &lt;span&gt;restTemplate&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        RestTemplate restTemplate = &lt;span&gt;new&lt;/span&gt; RestTemplate();&lt;br/&gt;        restTemplate.setInterceptors(Collections.singletonList(restTemplateInterceptor()));&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; restTemplate;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; RestTemplateInterceptor &lt;span&gt;restTemplateInterceptor&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RestTemplateInterceptor();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中MdcUtil其实是利用MDC工具在ThreadLocal中存储和获取traceId&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MdcUtil&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String TRACE_ID = &lt;span&gt;&quot;TRACE_ID&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String &lt;span&gt;get&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; MDC.get(TRACE_ID);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;&lt;span&gt;(String value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        MDC.put(TRACE_ID, value);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，这个例子中没有演示MdcUtil类的add方法具体调的地方，我们可以在filter中执行接口方法之前，生成traceId，调用MdcUtil类的add方法添加到MDC中，然后在同一个请求的其他地方就能通过MdcUtil类的get方法获取到该traceId。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;能使用MDC保存traceId等参数的根本原因是，用户请求到应用服务器，Tomcat会从线程池中分配一个线程去处理该请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么该请求的整个过程中，保存到MDC的ThreadLocal中的参数，也是该线程独享的，所以不会有线程安全问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring的&lt;code&gt;org.springframework.util&lt;/code&gt;包下的&lt;code&gt;ClassUtils&lt;/code&gt;类，它里面有很多让我们惊喜的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它里面包含了类和对象相关的很多非常实用的方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想获取某个对象的所有接口，可以使用ClassUtils的&lt;code&gt;getAllInterfaces&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Class&amp;lt;?&amp;gt;[] allInterfaces = ClassUtils.getAllInterfaces(&lt;span&gt;new&lt;/span&gt; User());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想获取某个类的包名，可以使用ClassUtils的&lt;code&gt;getPackageName&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String packageName = ClassUtils.getPackageName(User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;System.out.println(packageName);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想判断某个类是否内部类，可以使用ClassUtils的&lt;code&gt;isInnerClass&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;System.out.println(ClassUtils.isInnerClass(User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;))&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想判断对象是否代理对象，可以使用ClassUtils的&lt;code&gt;isCglibProxy&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;System.out.println(ClassUtils.isCglibProxy(&lt;span&gt;new&lt;/span&gt; User()));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ClassUtils还有很多有用的方法，等待着你去发掘。感兴趣的朋友，可以看看下面内容：&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1703703703703703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7UhTRglsYWZUMgjjMz4ibx9gP2ian6NXcTWRoVolQxchSy2PibQv7e47rI4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;spring给我们提供了一个&lt;code&gt;JavaBean&lt;/code&gt;的工具类，它在&lt;code&gt;org.springframework.beans&lt;/code&gt;包下面，它的名字叫做：&lt;code&gt;BeanUtils&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们一起看看这个工具可以带给我们哪些惊喜。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;曾几何时，你有没有这样的需求：把某个对象中的所有属性，都拷贝到另外一个对象中。这时就能使用BeanUtils的&lt;code&gt;copyProperties&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;User user1 = &lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;user1.setId(&lt;span&gt;1L&lt;/span&gt;);&lt;br/&gt;user1.setName(&lt;span&gt;&quot;苏三说技术&quot;&lt;/span&gt;);&lt;br/&gt;user1.setAddress(&lt;span&gt;&quot;成都&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;User user2 = &lt;span&gt;new&lt;/span&gt; User();&lt;br/&gt;BeanUtils.copyProperties(user1, user2);&lt;br/&gt;System.out.println(user2);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想通过反射实例化一个类的对象，可以使用BeanUtils的&lt;code&gt;instantiateClass&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;User user = BeanUtils.instantiateClass(User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;System.out.println(user);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想获取某个类的指定方法，可以使用BeanUtils的&lt;code&gt;findDeclaredMethod&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Method declaredMethod = BeanUtils.findDeclaredMethod(User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &quot;&lt;span&gt;getId&lt;/span&gt;&quot;)&lt;/span&gt;;&lt;br/&gt;System.out.println(declaredMethod.getName());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想获取某个方法的参数，可以使用BeanUtils的&lt;code&gt;findPropertyForMethod&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Method declaredMethod = BeanUtils.findDeclaredMethod(User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &quot;&lt;span&gt;getId&lt;/span&gt;&quot;)&lt;/span&gt;;&lt;br/&gt;PropertyDescriptor propertyForMethod = BeanUtils.findPropertyForMethod(declaredMethod);&lt;br/&gt;System.out.println(propertyForMethod.getName());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你对BeanUtils比较感兴趣，可以看看下面内容：&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7Uh9yaXjxBwHETxoS3Bhkak1fV1Ngoa8b2yANQtbgCwMBiaYXu11FbMtKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们需要在项目中使用&lt;code&gt;反射&lt;/code&gt;功能，如果使用最原始的方法来开发，代码量会非常多，而且很麻烦，它需要处理一大堆异常以及访问权限等问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好消息是spring给我们提供了一个&lt;code&gt;ReflectionUtils&lt;/code&gt;工具，它在&lt;code&gt;org.springframework.util&lt;/code&gt;包下面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想获取某个类的某个方法，可以使用ReflectionUtils类的&lt;code&gt;findMethod&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Method method = ReflectionUtils.findMethod(User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &quot;&lt;span&gt;getId&lt;/span&gt;&quot;)&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想获取某个类的某个字段，可以使用ReflectionUtils类的&lt;code&gt;findField&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Field field = ReflectionUtils.findField(User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &quot;&lt;span&gt;id&lt;/span&gt;&quot;)&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想通过反射调用某个方法，传递参数，可以使用ReflectionUtils类的&lt;code&gt;invokeMethod&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; ReflectionUtils.invokeMethod(method, springContextsUtil.getBean(beanName), param);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想判断某个字段是否常量，可以使用ReflectionUtils类的&lt;code&gt;isPublicStaticFinal&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Field field = ReflectionUtils.findField(User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &quot;&lt;span&gt;id&lt;/span&gt;&quot;)&lt;/span&gt;;&lt;br/&gt;System.out.println(ReflectionUtils.isPublicStaticFinal(field));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想判断某个方法是否equals方法，可以使用ReflectionUtils类的&lt;code&gt;isEqualsMethod&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Method method = ReflectionUtils.findMethod(User&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &quot;&lt;span&gt;getId&lt;/span&gt;&quot;)&lt;/span&gt;;&lt;br/&gt;System.out.println(ReflectionUtils.isEqualsMethod(method));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这个类还有不少有趣的方法，感兴趣的朋友，可以看看下面内容：&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0666666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7Uh10pfOquMyQP1hFAdje31XPnbDq1jib5IlKRZKxa6ia8n9jEHatCnIkAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，为了安全考虑，需要将参数只用&lt;code&gt;base64&lt;/code&gt;编码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时就能直接使用&lt;code&gt;org.springframework.util&lt;/code&gt;包下的&lt;code&gt;Base64Utils&lt;/code&gt;工具类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它里面包含：&lt;code&gt;encode&lt;/code&gt;和&lt;code&gt;decode&lt;/code&gt;方法，用于对数据进行加密和解密。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String str = &lt;span&gt;&quot;abc&quot;&lt;/span&gt;;&lt;br/&gt;String encode = &lt;span&gt;new&lt;/span&gt; String(Base64Utils.encode(str.getBytes()));&lt;br/&gt;System.out.println(&lt;span&gt;&quot;加密后：&quot;&lt;/span&gt; + encode);&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    String decode = &lt;span&gt;new&lt;/span&gt; String(Base64Utils.decode(encode.getBytes()), &lt;span&gt;&quot;utf8&quot;&lt;/span&gt;);&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;解密后：&quot;&lt;/span&gt; + decode);&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (UnsupportedEncodingException e) {&lt;br/&gt;    e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;加密后：YWJj&lt;br/&gt;解密后：abc&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在做字符转换的时候，经常需要指定字符编码，比如：UTF-8、ISO-8859-1等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时就可以直接使用&lt;code&gt;java.nio.charset&lt;/code&gt;包下的&lt;code&gt;StandardCharsets&lt;/code&gt;类中静态变量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String str = &lt;span&gt;&quot;abc&quot;&lt;/span&gt;;&lt;br/&gt;String encode = &lt;span&gt;new&lt;/span&gt; String(Base64Utils.encode(str.getBytes()));&lt;br/&gt;System.out.println(&lt;span&gt;&quot;加密后：&quot;&lt;/span&gt; + encode);&lt;br/&gt;String decode = &lt;span&gt;new&lt;/span&gt; String(Base64Utils.decode(encode.getBytes())&lt;br/&gt;, StandardCharsets.UTF_8);&lt;br/&gt;System.out.println(&lt;span&gt;&quot;解密后：&quot;&lt;/span&gt; + decode);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们需要对数据进行加密处理，比如：md5或sha256。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用apache的&lt;code&gt;org.apache.commons.codec.digest&lt;/code&gt;包下的&lt;code&gt;DigestUtils&lt;/code&gt;类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想对数据进行md5加密，可以使用DigestUtils的&lt;code&gt;md5Hex&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String md5Hex = DigestUtils.md5Hex(&lt;span&gt;&quot;苏三说技术&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(md5Hex);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想对数据进行sha256加密，可以使用DigestUtils的&lt;code&gt;sha256Hex&lt;/code&gt;方法。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String md5Hex = DigestUtils.sha256Hex(&lt;span&gt;&quot;苏三说技术&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(md5Hex);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这个工具还有很多其他的加密方法：&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.643020594965675&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7Uh0COn42SKmKwZyzRzR2s9TCuUpjVtoIJWpWFsrMBw3pS2TcUrkmOYVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;874&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，我们需要把数据进行&lt;code&gt;序列化&lt;/code&gt;和&lt;code&gt;反序列化&lt;/code&gt;处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传统的做法是某个类实现&lt;code&gt;Serializable&lt;/code&gt;接口，然后重新它的&lt;code&gt;writeObject&lt;/code&gt;和&lt;code&gt;readObject&lt;/code&gt;方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果使用&lt;code&gt;org.springframework.util&lt;/code&gt;包下的&lt;code&gt;SerializationUtils&lt;/code&gt;工具类，能更轻松实现序列化和反序列化功能。例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Map&amp;lt;String, String&amp;gt; map = Maps.newHashMap();&lt;br/&gt;map.put(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;1&quot;&lt;/span&gt;);&lt;br/&gt;map.put(&lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;2&quot;&lt;/span&gt;);&lt;br/&gt;map.put(&lt;span&gt;&quot;c&quot;&lt;/span&gt;, &lt;span&gt;&quot;3&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;byte&lt;/span&gt;[] serialize = SerializationUtils.serialize(map);&lt;br/&gt;Object deserialize = SerializationUtils.deserialize(serialize);&lt;br/&gt;System.out.println(deserialize);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，我们会在代码中定义http的返回码，比如：接口正常返回200，异常返回500，接口找不到返回404，接口不可用返回502等。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SUCCESS_CODE = &lt;span&gt;200&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; ERROR_CODE = &lt;span&gt;500&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; NOT_FOUND_CODE = &lt;span&gt;404&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实&lt;code&gt;org.springframework.http&lt;/code&gt;包下的HttpStatus枚举，或者&lt;code&gt;org.apache.http&lt;/code&gt;包下的&lt;code&gt;HttpStatus&lt;/code&gt;接口，已经把常用的http返回码给我们定义好了，直接拿来用就可以了，真的不用再重复定义了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMTA2NTU2Ng==&amp;amp;mid=2247487551&amp;amp;idx=1&amp;amp;sn=18f64ba49f3f0f9d8be9d1fdef8857d9&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.4363207547169812&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JdLkEI9sZffaLPQVm6QomiaO7zCCyT7Uhnr3IxBZGY6uFB1zPlcf2xawdhPRNPwLcepicVvQ53yHu5CsQDO4YaxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;848&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，今天的内容分享到这里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作当中还有很多好用的小工具，欢迎在下方留言。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8d6bf3702a3e89c102f930416e314536</guid>
<title>去哪儿网基于 DDD 思想的技术架构战略调整</title>
<link>https://toutiao.io/k/sxd2kss</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section&gt;
作者 | 郑吉敏&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;本文最初发表于 Qunar 技术沙龙公众号，经授权由 InfoQ 架构头条发布。&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;
&lt;span&gt;1&lt;/span&gt; 案例简述&lt;/section&gt;&lt;p&gt;2020 年疫情对旅游行业影响特别大，公司层面做了组织架构调整，酒店业务侧发生了巨大的变化，新的业务团队在推进一些实际需求时遇到了新的产研效率问题，主要体现在产品每次要和多个技术团队合作、整体技术架构与业务出现脱节。&lt;/p&gt;&lt;p&gt;结合之前 DDD 落地的成功经验，酒店技术侧于 2021 年中旬主动发起了一次基于 DDD 思想的技术架构战略调整，涉及组织架构调整、系统架构调整等，并制定了一些核心技术方案的标准，本次重点介绍这次战略调整的确认及落地过程。最后基于这次战略调整，看康威定律及 DDD 思想发挥的作用。&lt;/p&gt;&lt;section&gt;
&lt;span&gt;2&lt;/span&gt; 案例背景及问题分析&lt;/section&gt;&lt;section&gt;&lt;span/&gt;
背景&lt;/section&gt;&lt;p&gt;2020 年初，全球爆发了新冠疫情，对旅游行业影响比较大。2020 年 5 月份公司层面做了比较大的调整，首先成立了机票目的地事业群，机票和酒店作为两个公司最大的事业部从独立运营合并成到一个事业群，其次统一了服务、用户体验等团队，统一对事业群负责，同时制定了机酒交叉（可以简单理解为用户购买完机票后能购买酒店）的战略目标。&lt;/p&gt;&lt;p&gt;面对这些组织架构、业务架构调整，系统架构又该如何演进来支撑这些变化呢？带着这个思考，我们来看实际遇到的一些问题。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
问题及表现&lt;/section&gt;&lt;section&gt;&lt;span/&gt;
产品吐槽&lt;/section&gt;&lt;section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;几乎每个需求要和多个技术团队沟通，合作麻烦&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;很多需求的技术方案，经常需要升级才能达成共识&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;
引申问题&lt;/section&gt;&lt;section/&gt;&lt;section&gt;&lt;span/&gt;
问题分析一&lt;/section&gt;&lt;p&gt;先来看一下主流程核心的交互：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7733333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7kGvjj03nCWLpR1lSibwukJClpQxqoBYpkVZRia8yLnmNsfIPUBgGQlrRmeaqNhtkBpvia6hYLOYHpLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1050&quot;/&gt;&lt;/p&gt;&lt;p&gt;（注：图中 List 代表列表页、Detail 代表详情页、Booking 代表预订页，Order 代表订单页）&lt;/p&gt;&lt;p&gt;通过上图的交互流程，我们可以总结出以下几个问题：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;所有核心流程都涉及的团队是报价团队，报价团队是后端团队，比较底层&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户端跨页面交互统一需要在底层的报价团队完成&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;底层修改，会带动整个链路跟着修改（典型的比如：基础数据新增字段）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;报价团队的定位是基于用户计算酒店房型、价格及实际的优惠细节，基础数据及相关逻辑并不想感知&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span/&gt;
问题分析二&lt;/section&gt;&lt;p&gt;继续看一下主流程核心团队及核心设计：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6166982922201139&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7kGvjj03nCWLpR1lSibwukJCdGFEtctThkap21SnXuHEg4eGQoVs9TfV5jPu7NJ2ypiaQMfQaDPssJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1054&quot;/&gt;&lt;/p&gt;&lt;p&gt;通过上图，我们可以总结出以下几点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;很多团队在自己的领域层上面都有应用层&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;这些应用层，导致有些事情上下游团队都可以做&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;很多事情，谁都能做的时候，就可能出现谁都不想做&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;“万金油”式架构，适合业务上升期，不适合稳定期&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;
&lt;span&gt;3&lt;/span&gt; 案例分析与规划&lt;/section&gt;&lt;section&gt;&lt;span/&gt;
基于 Explicit Architecture（清晰架构）分析&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5663551401869159&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7kGvjj03nCWLpR1lSibwukJCUEu75Yu8OPz9jP6GBxuajU6KyPY7BqXMApPxnoGl8lPK86nFs7PIWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1070&quot;/&gt;&lt;/p&gt;&lt;p&gt;上图来自国外顶级架构师 herberto graca 的博客（https://herbertograca.com/），融合了  DDD、洋葱架构、整洁架构、CQRS 的”清晰架构“，这个架构有很多优势，比如：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;从外向内，越向内越偏核心原则，核心原则相对稳定。核心原则就是常规的领域层，提供核心能力&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;外层基于核心原则适配不同的业务场景，组装内层的能力。这里的外层就是常规的接口层到应用层，主要使用主动适配器模式，重点关注 BFF 及对内层能力的聚合&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;内层不依赖外层，不受业务变化而变化，关注能力的扩展，完成核心策略实现&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;边界明显，尤其是领域层与应用层之间&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;CQRS 机制，耦合度低，通过外层组装内层能力动态适配业务变化，扩展性高&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;...&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
技术架构构想&lt;/section&gt;&lt;p&gt;结合清晰架构的特点来思考技术架构整体的调整策略&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7348837209302326&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7kGvjj03nCWLpR1lSibwukJCuibmsASzLh3SpPVjYtXJh3AjyLKXuHcrPqZLib4Xa6dCLK8mqHzaTR2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;860&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
技术架构调整规划&lt;/section&gt;&lt;p&gt;围绕上面的构想，整体架构图期望如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7kGvjj03nCWLpR1lSibwukJCW7B9ZhicgODqfHLJ0jSeEcbmPQBVMCDLbEeowBl6Eh2pbkqnkPzI0Cg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;966&quot;/&gt;&lt;/p&gt;&lt;p&gt;通过上面这个图可以明确几个关键点：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;明确战略调整核心&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;明确和之前的区别&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;负责核心领域的团队聚焦可复用的能力，专注核心策略、玩法的改进&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;负责应用层的团队聚焦业务识别与扩展，专注业务模型设计和组装下游能力&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;业务收敛到一个团队，这个团队了解下游可提供的能力，能从全局看业务整体开展情况&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span/&gt;
优势劣势分析&lt;/section&gt;&lt;p&gt;围绕着上面的调整，分析一下优劣和劣势&lt;/p&gt;&lt;p&gt;&lt;strong&gt;优势（偏向中台方向）&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;这两点，在实际中都验证了确实可以起到产研提效作用。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;劣势及可能带来的问题&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;
&lt;span&gt;4&lt;/span&gt; 案例落地过程&lt;/section&gt;&lt;section&gt;&lt;span/&gt;
系统架构调整&lt;/section&gt;&lt;p&gt;这里主要完成的是，将做“应用层”的应用及逻辑上交给大前台团队，先保证各自团队负责该负责的事情，让负责核心领域的团队实际主要负责领域的事情，其他交给大前台&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
组织架构调整&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;组织架构按需调整：比如多个网关合并成大前台，同时借助一些需求完成一些人员交叉&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;核心人员归属团队规划：这里主要是 review 一遍核心成员，看看适合领域团队还是大前台，必要时进行相关调整&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;HC 调整，招聘计划跟进：本次会按需为大前台团队增加 hc，同时加紧招聘节奏保证人员尽早就位，这样也可以避免个别成员不稳定对整体的影响程度&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;成立业务架构组：监督及保证架构调整，同时避免之后的腐化&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span/&gt;
技术方案标准制定&lt;/section&gt;&lt;section&gt;&lt;span/&gt;
数据回传标准化&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9175531914893617&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7kGvjj03nCWLpR1lSibwukJCOmJr7rJ1Aq8x7UhjMhc8icGbnS74qJs9ibpulStibY5w6qJ6YXOksLia4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;752&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9151193633952255&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7kGvjj03nCWLpR1lSibwukJCIArjANPZvTsWMPHxcicgfaIibceR2eaiad7lturVV4vZibENTNoXy4LR0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;754&quot;/&gt;&lt;/p&gt;&lt;p&gt;根据 SPU、SKU 数据回传标准进行链路治理：对比之前的链路，核心要对基础数据要一次完整的改造。我们首先对基础数据基于 DDD 思想做了一次领域划分，然后基于领域提供相关的对外 API 服务，然后直接对接大前台。大前台在拿走报价团队的应用层应用（内部应用名字叫 mprice），先将原服务合并到已有的应用层应用中，然后对接基础数据服务 API，从之前链路的 7 个应用直接降为 4 个应用，再加上一些串行操作并行化，不但链路缩短了，同时主流程响应时间降低了 25%，效果特别好。&lt;/p&gt;&lt;section&gt;&lt;span/&gt;
请求处理标准化&lt;/section&gt;&lt;p&gt;&lt;strong&gt;方案制定&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4306569343065693&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7kGvjj03nCWLpR1lSibwukJCFuuSk0XhBReoRYZ8cke1Iz2tiap5ZDcD4VLmEDoR9Kh4k2ialS5lcovw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;822&quot;/&gt;&lt;/p&gt;&lt;p&gt;上图是我们主流程计算用户支付价的几个核心过程。重点解释一下【商促】：基于用户画像打包，满足特定要求（比如特定的用户身份）的营销活动，拿到更低的底价，获得更高的利润。&lt;/p&gt;&lt;p&gt;接下来看一个实际问题：要过节了，业务侧希望放开某些商促限制，给所有用户使用，技术方案该如何设计？我们先来给出常规的两种技术方案：&lt;/p&gt;&lt;p&gt;常规的方案都有明显的问题，那么根本问题出在哪里呢？其实是标准做法里缺少对【场景】的应对！&lt;/p&gt;&lt;p&gt;我们结合下图聊一下业务场景中的身份和场景。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42685185185185187&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7kGvjj03nCWLpR1lSibwukJC4ylUuLYUbOT0TVlwd7yApw9QLkKeN3ficfm2xyC9eOwGic8UTqgM4qGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;内部做了多次讨论后，最终给出结论：&lt;/p&gt;&lt;p&gt;举几个例子，比如酒店新客、机酒用户都是定义为在一段时间内有过某些指定消费行为（买过酒店、买过机票等）的用户，通过 userid 可以直接得到明确的结果，这个属于身份；而异地面纱就属于场景，原因是对于明确 userid，假设常住地为北京，这个用户本次要去北京以外的地方，这样才能匹配上“异地”。这里要注意身份特征有限个数的限制，比如门店新客，对于一个用户而言，他是否是某个门店的新客正常也是明确的，但是我们有将近百万在线的门店，这时就不适合作为身份使用了，因为我们在使用 userid 去查询他的身份时，每个门店都列出来的代价太大，这种更适合拿着 userid + 门店去查询。&lt;/p&gt;&lt;p&gt;在我们的业务场景里，常规都是基于正常定义的身份进行标准计算，如果不能使用身份来匹配，就需要使用场景来解决。&lt;/p&gt;&lt;p&gt;基于对【身份】和【场景】的理解，针对前面的问题，我们给出更合理的方案：&lt;strong&gt;报价提供“强制使用指定商促能力”前台识别场景，组装使用新能力。&lt;/strong&gt;这样报价依旧关心能力的提升，前台依旧负责的是业务的适配及组装能力，核心是针对身份和场景的标准使用。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4444444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7kGvjj03nCWLpR1lSibwukJCqyKtqAyr7GLM8zC6l0a30rFSpKcb7yIx5oPphKbIib8ia9TH3LXhibnxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;补充说明一下，按照这样架构调整及技术方案执行后，从整体来看整个架构：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;领域层能实际暴露出能力，应用层最终暴露出去功能&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;由于应用层可以按照需要组装能力，因此可以表现出很强的扩展性；对于领域层而言，专注能力的复用，因此更具稳定性&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;应用层组装领域层能力，靠的是标准的身份和场景。要么基于标准身份使用常规能力，要么基于场景强制使用特殊能力&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;功能是解决实际场景诉求的，变化快，因此需要提供很多接口去完成一些定制功能；能力是需要尽可能忽略场景的，这样才可能做到最大程度复用。要解决两者的冲突，就需要合理的使用身份和场景。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;参数透传&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;日常开发我们经常会遇到这种情况，需要借助很多应用透传一个参数，给特别上游的应用使用，这种参数对链路上参与透传的团队和应用来说，没有任何业务逻辑处理，徒增开发工时，扰乱定义的 API。为了解决这个问题，公司内部业务研发和基础研发共同讨论确认开发一个新的通用组件：QShareData。各个应用可以基于请求把一些数据写入 QShareData 组件，对应的数据 id 跟随 trace 一起传递，链路上其他应用可以按需通过数据 id 获取其他应用写入组件的数据，减少一些无意义的透传。当然，这里面涉及一些权限、性能及合理使用等问题，需要结合实际做些要求和限制。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3616600790513834&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7kGvjj03nCWLpR1lSibwukJCn8AxwnkYuWYhBq6SkLOdpib95W6LPVy52foicjOBIDtwa3r6vibibWeQBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1012&quot;/&gt;&lt;/p&gt;&lt;section&gt;
&lt;span&gt;5&lt;/span&gt; 案例总结&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8616187989556136&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YE1dmj1Pw7kGvjj03nCWLpR1lSibwukJCL1HDljhJopAbhojofN9HEts9mqGx4ST4fqh3XJvAqB313drNu514TA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;766&quot;/&gt;&lt;/p&gt;&lt;p&gt;首先，我们来回顾一下著名的&lt;strong&gt;康威定律&lt;/strong&gt;：设计系统的组织，其产生的设计等同于组织之内、 组织之间的沟通结构。康威定律成立说明组织架构与系统之间必须匹配，但未强调合理。&lt;/p&gt;&lt;p&gt;接下来，我们再看一下 &lt;strong&gt;DDD 中的康威定律，&lt;/strong&gt;它的核心是系统架构驱动组织架构。DDD 基于业务领域，回归业务，与业务匹配，更容易做到合理。&lt;/p&gt;&lt;p&gt;相信有些人会问：团队如何划分才能与业务匹配？本质是让 DDD 的制约因素成为 DDD 要改变的目标，这里总结两点：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;作者简介：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;郑吉敏&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2019年8月入职去哪儿网，机票目的地事业群技术总监、技术委员会委员、业务架构 SIG 负责人，负责酒店报价中心团队、业务架构组。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2020 年金项奖评选中主导的“对内 DDD 对外 API 驱动的酒店报价业务重塑”项目获得了 CEO 特别奖。2021 年获得技术品牌最佳贡献奖，曾在 QCon、Top100、CSDI、SACC、MPD 等大会做过技术分享。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关联阅读：&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;amp;mid=2651110356&amp;amp;idx=2&amp;amp;sn=f7595273abb1c4a98fa6f91713773abc&amp;amp;chksm=bdb943878aceca91ab1905f51d0a7e5dadc50c40a5fd7325f9d3b5b8af996c14f153f6bafaf6&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;坚定推动 DDD 一年后，去哪儿网如今怎么样了&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;坚定推动 DDD 一年后，去哪儿网如今怎么样了&lt;/span&gt;&lt;/a&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;span/&gt;
今日文章推荐&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&amp;amp;mid=2247523955&amp;amp;idx=1&amp;amp;sn=b5acbcf077f134a19a24d684c986d747&amp;amp;chksm=e8d461b1dfa3e8a710ad1abfbd9025fd2bc513e91b6188045adf24a1cb107b32a51e9dc7657b&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;无限生长，我们都将奔赴未来 | InfoQ中国成立15周年&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;无限生长，我们都将奔赴未来 | InfoQ中国成立15周年&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNjUxMzk2NQ==&amp;amp;mid=2247523838&amp;amp;idx=1&amp;amp;sn=12a5a93c5e7b5e8b7024b0e1f16272ed&amp;amp;chksm=e8d4623cdfa3eb2a2a84813c85d95a71c63cae9b3ef53e81f114d69fa1880805bb80f608457c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;为什么你需要关注软件架构？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;为什么你需要关注软件架构？&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt; 活动推荐&lt;/section&gt;&lt;section&gt;&lt;p&gt;今年 7 月，ArchSummit 全球架构师峰会将落地深圳。目前已经邀请到了顺丰集团 CTO 耿艳坤、美的集团 IoT 副总裁兼 CTO 向江旭、度小满金融数据智能部总经理 / 技术委员会执行主席杨青、Shopee 技术委员会主席叶绍志博士等多位专家来大会现场分享，更多大咖正在陆续邀请中...&lt;/p&gt;&lt;p&gt;ArchSummit 深圳站的主题是数字化转型下的架构升级，根据这一主题，以及广东地区金融业、制造业发达的特色，我们设置了金融领域数字化转型、数字化转型时代的数据治理、AICon 全球人工智能与机器学习大会、 可观测性技术落地探索、单云架构到多云架构转型、 IoT 系统架构设计、微服务架构落地实践、云原生前沿技术应用、架构师能力模型、出海业务架构、开源和自研选型思考、架构稳定性保障等专题，点击阅读原文了解详情。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;现在购票即可享受 9 折特惠，单人立减 880 元，购票请扫码或联系：1851454922&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FE4VibF0SjfOpzgIGIgOmrscThZCCVwLUrEn1TEAR9y9SIyXTkXImGGrOm2mWEf3FYKo7DHfMts5HU5oyXNBSsg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0c6d670bc764f479c2d8152b4b19980c</guid>
<title>从C++转向Rust：两大主题值得关注！</title>
<link>https://toutiao.io/k/9au1pw0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;导语 |&lt;/span&gt;&lt;span&gt; 今天为大家带来的是从C++转向Rust主题的内容。在日常的开发过程中，&lt;/span&gt;&lt;span&gt;长期使用C++，在使用Rust的过程中可能会碰到一些问题。&lt;/span&gt;&lt;span&gt;本&lt;/span&gt;&lt;span&gt;文是From C++ To Rust的第二篇，在这一篇里，主要介绍错误处理和生命周期两个主题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此前，我介绍了其中思维方式的转变（mind shift）：&lt;em&gt;《&lt;/em&gt;&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwOTIyNzM5OA==&amp;amp;mid=2247485153&amp;amp;idx=1&amp;amp;sn=2228bba09bb7349e1c60a154eba9b42a&amp;amp;chksm=c13ca208f64b2b1e93750e4d0e7ac1ce002374f38a14e654c199afd2cb9b2099ca42df03bf64&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;详细解答！从C++转向Rust需要注意哪些问‍题？&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;em&gt;&lt;span&gt;&lt;strong&gt;详细解答！从C++转向Rust需要注意哪些问题？&lt;/strong&gt;&lt;/span&gt;&lt;/em&gt;&lt;/a&gt;&lt;em&gt;》&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;一、错误处理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-lines=&quot;2&quot; data-sign=&quot;358448472a1a6511797477f36822ec29&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-lines=&quot;2&quot; data-sign=&quot;80f96e80733bc716c57df25dd86dd80b&quot;&gt;&lt;span&gt;&lt;strong&gt;（一）C++&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;24dd56c70981396d645c3436f830faa0&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;24dd56c70981396d645c3436f830faa0&quot;&gt;&lt;span&gt;任何生产级别的软件开发中，错误处理都需要被妥善考虑。C++通常会有两种错误处理的风格：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;d9dde144488519befd4d8d4a19c4cd5e&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;d9dde144488519befd4d8d4a19c4cd5e&quot;&gt;&lt;span&gt;这两种方案各有优劣，这里简单地说明一下。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;1d203f4ae8fe13cbabcc9db7c4d8c576&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;1d203f4ae8fe13cbabcc9db7c4d8c576&quot;&gt;&lt;span&gt;返回值风格的优点是清晰，错误发生的位置和处理方法都写得很直白；缺点即是拖沓，错误代码与业务代码交错在一起，使得主要逻辑不突出。同时占用了返回值位置，影响逻辑的表达。另外，没有强制错误检查，可能会遗漏错误检查而导致代码缺陷。如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__type&quot;&gt;OK&lt;/span&gt; != foo()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__type&quot;&gt;SomeThing&lt;/span&gt; thing;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;code-snippet__type&quot;&gt;OK&lt;/span&gt; != getSomeThing(&amp;amp;thing)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;thing.&lt;span class=&quot;code-snippet__keyword&quot;&gt;init&lt;/span&gt;(); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;thing.action(); &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;异常&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;恰恰相反，错误有独立的处理流，通常不与业务逻辑相交，使得业务逻辑看起 来很清晰；但是由于异常的隐性，使得任何位置都可能抛出异常，函数的退出点也变得隐晦，带来&lt;/span&gt;&lt;span&gt;&lt;strong&gt;异常安全&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;问题，增加了代码编写的心智负担。如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;auto&lt;/span&gt; thing = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Thing();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  bar(); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;delete&lt;/span&gt; thing;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;29fb51fc58c5fcd47e03ddc934edcf49&quot;&gt;&lt;span&gt;如果上面代码中的bar抛出异常，程序的执行流程将从bar函数跳出进入&lt;/span&gt;&lt;span&gt;&lt;strong&gt;异常处理流程&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;因此后面delete语句不能得到执行，导致thing泄漏。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;d20050cd9d9345c471427fbc3ccaecb2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;d20050cd9d9345c471427fbc3ccaecb2&quot;&gt;&lt;span&gt;解决此问题的方法是使用&lt;/span&gt;&lt;span&gt;&lt;strong&gt;智能指针&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，它们使用了&lt;/span&gt;&lt;span&gt;RAII&lt;/span&gt;&lt;span&gt;机制确保了函数在各种情况下均能妥善地释放动态分配的对象。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;d20050cd9d9345c471427fbc3ccaecb2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;d20050cd9d9345c471427fbc3ccaecb2&quot;&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;2&quot; data-sign=&quot;fd5e1488565cdc6b09be2c441b2425b0&quot;&gt;&lt;span&gt;&lt;strong&gt;（二）Rust&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;a4864838c0249d0625e722f93f5718cf&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;a4864838c0249d0625e722f93f5718cf&quot;&gt;&lt;span&gt;Rust没有提供异常机制，与使用Option来解决可选的情况类似，它使用了Result来提供此功能。Result的定义如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pub &lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;Result&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__title&quot;&gt;T&lt;/span&gt;, &lt;span class=&quot;code-snippet__title&quot;&gt;E&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__type&quot;&gt;Ok&lt;/span&gt;(&lt;span class=&quot;code-snippet__type&quot;&gt;T&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__type&quot;&gt;Err&lt;/span&gt;(&lt;span class=&quot;code-snippet__type&quot;&gt;E&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到，Result的定义几乎与Option一样。只是在异常的情况返回时多带一个错误类型。举一个具体的例子：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;#[derive(Debug)]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pub &lt;span class=&quot;code-snippet__keyword&quot;&gt;enum&lt;/span&gt; MyError {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  IoError(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Inexist(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pub &lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; Result&amp;lt;T&amp;gt; = std::result::Result&amp;lt;T, MyError&amp;gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pub fn fetch_id() -&amp;gt; Result&amp;lt;u64&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Ok(&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fn main() -&amp;gt; Result&amp;lt;()&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;let&lt;/span&gt; id = fetch_id()?;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  println!(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;{:?}&quot;&lt;/span&gt;, id);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Ok(())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面let id=fetch_id()?；一句，使用了?操作符，实际相当于执行如下语句：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;objectivec&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;let &lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt; = match fetch_id() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Ok(&lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt;) =&amp;gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Err(err) =&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; Err(err);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;fdeecd10005ae1b63349cf9c24567913&quot;&gt;&lt;span&gt;相当于，如果被调函数(fetch_id)正常返回则unwrap其值；反之，则将被调函数的错误向上返回。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;47eb7a4477033a484e47d15f50a4a9b7&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;47eb7a4477033a484e47d15f50a4a9b7&quot;&gt;&lt;span&gt;相对于C/C++，Rust在此处，实际上在尝试做到某种&lt;/span&gt;&lt;span&gt;&lt;strong&gt;平衡&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-lines=&quot;2&quot; data-sign=&quot;29fdb99d9742c7c5cb32463370f8a32e&quot;&gt;&lt;br/&gt;&lt;/h4&gt;&lt;h4 data-lines=&quot;2&quot; data-sign=&quot;29fdb99d9742c7c5cb32463370f8a32e&quot;&gt;&lt;span&gt;在Rust中，错误被划成了两类：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;可恢复的(recoverable)&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; 和&lt;/span&gt;&lt;span&gt;&lt;strong&gt;不可恢复的(unrecoverable)&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。所谓&lt;/span&gt;&lt;span&gt;&lt;strong&gt;可恢复&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;通常指的是可以上报给用户，修复之后，然后&lt;/span&gt;&lt;span&gt;&lt;strong&gt;重试&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;一下的错误，比如：文件未找到，配置错误等。而&lt;/span&gt;&lt;span&gt;&lt;strong&gt;不可恢复&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;一般是由于代码Bug导致的，程序已经&lt;/span&gt;&lt;span&gt;进入&lt;/span&gt;&lt;span&gt;未定义状态&lt;/span&gt;&lt;span&gt;，继续执行可能产生&lt;/span&gt;&lt;span&gt;&lt;strong&gt;未定义行为&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，比如：数组越界访问。&lt;/span&gt;&lt;/h4&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;ee342fe01b6bb093f92f9c270581d848&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;ee342fe01b6bb093f92f9c270581d848&quot;&gt;&lt;span&gt;对于可恢复的错误，使用Result&amp;lt;T，E&amp;gt;返回错误，交由调用方决定该如何处理。而对于不可恢复的错误，使用panic!宏直接中止程序的执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 data-lines=&quot;1&quot; data-sign=&quot;f639433af39e14c8027825c33ed2e041&quot;&gt;&lt;span&gt;&lt;strong&gt;（三）Rust错误处理惯例&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;05b251f8b060e6e9b48a7384cbf23f3f&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;05b251f8b060e6e9b48a7384cbf23f3f&quot;&gt;&lt;span&gt;如之前所说，Rust的错误处理是&lt;/span&gt;&lt;span&gt;&lt;strong&gt;强类型&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的。因此，不能像C++的异常一样，错误可以穿透多层调用栈；相反，错误必须被逐层处理、翻译，不能一抛到底。这个工作其实是较为繁琐的。举个例子：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;#[derive(Debug)]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pub &lt;span class=&quot;code-snippet__keyword&quot;&gt;enum&lt;/span&gt; MyError {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  IoError(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Inexist(&lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pub &lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; Result&amp;lt;T&amp;gt; = std::result::Result&amp;lt;T, MyError&amp;gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pub fn fetch_id() -&amp;gt; Result&amp;lt;u64&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;let&lt;/span&gt; content = std::fs::read_to_string(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/tmp/tmp_id&quot;&lt;/span&gt;)?;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;let&lt;/span&gt; id = content.parse::&amp;lt;u64&amp;gt;()?;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Ok(id)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这段代码不能编译通过，因为std::fs::read_to_string和String::parse的 返回值虽然都叫Result，但却不是相同的类型(因为E被定义为库局部的错误了)。因此，这里都不能直接使用?操作符。而是需要进行错误类型的翻译，转成我们自己定义的MyError：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pub fn fetch_id() -&amp;gt; Result&amp;lt;u64&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  let content = match std::fs::read_to_string(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/tmp/tmp_id&quot;&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Ok(content) =&amp;gt; content,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Err(_) =&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; Err(MyError::IoError(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;read /tmp/tmp_id failed.&quot;&lt;/span&gt;.to_owned()));&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  };&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  let id = content&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    .parse::&amp;lt;u64&amp;gt;()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    .map_err(|_| MyError::ParseError(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;parse error.&quot;&lt;/span&gt;.to_owned()))?;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Ok(id)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;9&quot; data-type=&quot;p&quot; data-sign=&quot;58ca48a1cc9f35ddca0464eff0131f2a&quot;&gt;&lt;span&gt;显然，写法1过入繁冗，实在称不上优雅。而写法2直接使用标准库函数&lt;/span&gt;&lt;span&gt;map_err&lt;/span&gt;&lt;span&gt;来完成错误类型的映射，会干净很多。但是如果映射的代码比较复杂，或者同样的处理会多次重复，就会希望将错误映射集的代码中起来。因此，社区中也提供了库来简化这部分处理，如：&lt;/span&gt;&lt;span&gt;thiserror，&lt;/span&gt;&lt;span&gt;anyhow&lt;/span&gt;&lt;span&gt;。这两个库分别对应了&lt;/span&gt;&lt;span&gt;&lt;strong&gt;库级别&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;与&lt;/span&gt;&lt;span&gt;&lt;strong&gt;应用级别&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的错误处理。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;5&quot; data-type=&quot;p&quot; data-sign=&quot;6ddfb956ccfb2e5ec68149b48ac49e2d&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;5&quot; data-type=&quot;p&quot; data-sign=&quot;6ddfb956ccfb2e5ec68149b48ac49e2d&quot;&gt;&lt;span&gt;所谓&lt;/span&gt;&lt;span&gt;&lt;strong&gt;库级别&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;指的是编写为可被其它库或者应用复用的代码。因此，并不清楚错误最终会被如何处理，所以最终会在库级别统一Error的类型，并最终将底层转译到该错误类型。如上例中的MyError。上例在使用thiserror改写之后：&lt;/span&gt;&lt;/p&gt;&lt;pre/&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;#[derive(thiserror::&lt;span class=&quot;code-snippet__built_in&quot;&gt;Error&lt;/span&gt;, Debug)]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pub &lt;span class=&quot;code-snippet__keyword&quot;&gt;enum&lt;/span&gt; MyError {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  #[error(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;io error.&quot;&lt;/span&gt;)]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  IoError(#[&lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt;] std::io::&lt;span class=&quot;code-snippet__built_in&quot;&gt;Error&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  #[error(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;parse error.&quot;&lt;/span&gt;)]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  ParseError(#[&lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt;] std::num::ParseIntError),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pub &lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; Result&amp;lt;T&amp;gt; = std::result::Result&amp;lt;T, MyError&amp;gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pub fn fetch_id() -&amp;gt; Result&amp;lt;u64&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;let&lt;/span&gt; content = std::fs::read_to_string(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/tmp/tmp_id&quot;&lt;/span&gt;)?;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;let&lt;/span&gt; id = content.parse::&amp;lt;u64&amp;gt;()?;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Ok(id)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;f206a5a149add4ff0f58c48c4d44b928&quot;&gt;&lt;span&gt;可以看使用thiserror后，代码清爽了很多。thiserror会为MyError自动实现底层Error的From trait。所以在fetch_id中就可以直接用?操作符将底层 Error映射到MyError。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;508030a94830ba6681504523ae14c1ab&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;508030a94830ba6681504523ae14c1ab&quot;&gt;&lt;span&gt;而&lt;/span&gt;&lt;span&gt;&lt;strong&gt;应用级别&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的Error不需要进一步上传给调用者，只需要有一个Result类型 可以集中处理所有的底层Error即可。因此，此时不需要自定义MyError， 使用anyhow改写之后如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;objectivec&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;use anyhow::{Context, Result};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;pub fn fetch_id() -&amp;gt; Result&amp;lt;u64&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  let content = std::fs::read_to_string(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/tmp/tmp_id&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    .context(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;open /tmp/tmp_id failed.&quot;&lt;/span&gt;)?;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  let &lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt; = content.parse::&amp;lt;u64&amp;gt;().context(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;parse error.&quot;&lt;/span&gt;)?;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Ok(&lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fn main() -&amp;gt; Result&amp;lt;()&amp;gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  let &lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt; = fetch_id()?;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  println!(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;{:?}&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__keyword&quot;&gt;id&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  Ok(())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;75483c8fcac5f58e888fae0e01ba8cb9&quot;&gt;&lt;span&gt;anyhow为泛型(generic)的Result&amp;lt;T，E&amp;gt;实现了Context trait。而Context提供了context函数，将原来的Result&amp;lt;T，E&amp;gt;转成了Result&amp;lt;T，anyhow::Error&amp;gt;，最终在应用级别将错误类型统一到anyhow::Error上。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;7742a0d6adeafddc673d7ddcebcd3034&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;7742a0d6adeafddc673d7ddcebcd3034&quot;&gt;&lt;span&gt;限于篇幅，这里不再对这两个库做更深入说明，更细致的说明可以参考以下详细文档： &lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;7742a0d6adeafddc673d7ddcebcd3034&quot;&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;7742a0d6adeafddc673d7ddcebcd3034&quot;&gt;&lt;span&gt;Rust:Structuring and handling errors in 2020&lt;/span&gt;&lt;span&gt;（https://nick.groenen.me/posts/rust-error-handling/）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;7742a0d6adeafddc673d7ddcebcd3034&quot;&gt;&lt;span/&gt;&lt;span&gt;thiserror&lt;/span&gt;&lt;span&gt;（https://docs.rs/thiserror）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;7742a0d6adeafddc673d7ddcebcd3034&quot;&gt;&lt;span&gt;anyhow&lt;/span&gt;&lt;span&gt;（https://docs.rs/anyhow）&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;7742a0d6adeafddc673d7ddcebcd3034&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;00bce93b09d7fbdb3602f93412a3ab22&quot;&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;二、生命周期&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;6&quot; data-type=&quot;p&quot; data-sign=&quot;fb0e459130b8c2eb992ce945597972d5&quot;&gt;&lt;span&gt;终于到这个主题了！显然&lt;/span&gt;&lt;span&gt;&lt;strong&gt;生命周期&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是Rust最独特的特性，没有之一。虽然在各种语言都会定义对象的生命周期，但将其在语言中静态表达出来的只有Rust。因此，虽然早有接触，但是在Rust碰到还是会觉得陌生，甚至晦涩。在这里笔者尝试记录下自己学习这个概念的关键点，想到什么说什么，不会是一个系统的教程，只是记录C++的熟悉者容易忽略的一些点。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;6&quot; data-type=&quot;p&quot; data-sign=&quot;fb0e459130b8c2eb992ce945597972d5&quot;&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;2&quot; data-sign=&quot;fb71140f4256bdaff48d3f818a82d417&quot;&gt;&lt;span&gt;&lt;strong&gt;（一）谈谈生命周期&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;8&quot; data-type=&quot;p&quot; data-sign=&quot;213001252f1ceeb6ce634540b5dabbed&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;8&quot; data-type=&quot;p&quot; data-sign=&quot;213001252f1ceeb6ce634540b5dabbed&quot;&gt;&lt;span&gt;简单地说，生命周期就是一个对象的存续时间。对于支持引用的语言来说， 引用目标在&lt;/span&gt;&lt;span&gt;&lt;strong&gt;使用时必须存在&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是程序正确运行的基础；同时因为计算机内&lt;/span&gt;&lt;span&gt;&lt;strong&gt;有限的资源&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，所以在对象使用完毕后，必须尽早释放。生命周期可以&lt;/span&gt;&lt;span&gt;&lt;strong&gt;手动管理&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，但是因为程序的复杂性，&lt;/span&gt;&lt;span&gt;手动管理&lt;/span&gt;&lt;span&gt;是一件成本很高并且易错的工作。所以也就诞生了各种&lt;/span&gt;&lt;span&gt;&lt;strong&gt;自动管理&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;生命周期的算法，当前典型的算法有两类，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;引用计数(RC)&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;&lt;strong&gt;垃圾收集(GC)&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;5&quot; data-type=&quot;p&quot; data-sign=&quot;e96c7eea12d213a2294650a1e6ebb4d7&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;5&quot; data-type=&quot;p&quot; data-sign=&quot;e96c7eea12d213a2294650a1e6ebb4d7&quot;&gt;&lt;span&gt;而Rust实际是探索了第三种自动管理的方案：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;编译期的静态检查-BorrowChecker&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，它通过分析变量的定义域(Scope)与移动(Move)规则，来保证通过引用使用目标对象的安全性。(注：在NLL BorrowChecker引入后，定义域不再是严格的代码块)。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;d8364673a2d74c6b97f59f105c7289f6&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;d8364673a2d74c6b97f59f105c7289f6&quot;&gt;&lt;span&gt;初次接触Rust，最奇怪的就是生命周期的记法了：&#x27;a。很陌生，很费解。为什么需要它？解决什么问题？说一下我的理解：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;2&quot; data-sign=&quot;b336b9bd7b5676ee31197c146f2aa8dd&quot;&gt;&lt;span&gt;&lt;strong&gt;（二）生命周期省略-Lifetime Elision&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;3d86604d76ea36dbd1ef05679a03c8bf&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;3d86604d76ea36dbd1ef05679a03c8bf&quot;&gt;&lt;span&gt;Rust为了代码的清爽，允许开发在很多情况下都可以不使用生命周期标记。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;3d86604d76ea36dbd1ef05679a03c8bf&quot;&gt;&lt;br/&gt;&lt;span&gt;这使得生命周期标记的出现场景比较微妙，比如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fn &lt;span class=&quot;code-snippet__built_in&quot;&gt;print&lt;/span&gt;(s: &amp;amp;str);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际上应该理解为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fn &lt;span class=&quot;code-snippet__built_in&quot;&gt;print&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;a&amp;gt;(s: &amp;amp;&#x27;&lt;/span&gt;a str);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;b51789564435277cf992798177e918d9&quot;&gt;&lt;span&gt;该函数接受一个字符串的引用，显然，这个引用目标的生命周期一定可以覆盖 print的执行期，print并不需要对引用的生命周期做更特别的静态检查。因此，Rust允许省略这个生命周期标记。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;04f279b7401ce01858d1dd993e4ce591&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;04f279b7401ce01858d1dd993e4ce591&quot;&gt;&lt;span&gt;具体的省略规则可以参考文档：&lt;/span&gt;&lt;span&gt;Lifetime Elision&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;04f279b7401ce01858d1dd993e4ce591&quot;&gt;&lt;span&gt;（https://doc.rust-lang.org/nomicon/lifetime-elision.html）&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;04f279b7401ce01858d1dd993e4ce591&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;04f279b7401ce01858d1dd993e4ce591&quot;&gt;&lt;span&gt;说一下我的理解：&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;8ccf430c71083f099b325b2eb8c57036&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;8ccf430c71083f099b325b2eb8c57036&quot;&gt;&lt;span&gt;首先定义了&lt;/span&gt;&lt;span&gt;&lt;strong&gt;输入引用&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;&lt;strong&gt;输出引用&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，文档中为了严谨，描述得比较长。简单地说，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;除了函数返回的引用外，其它都是输入引用&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。然后依据以下规则省略引用：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;919390e79dc1a872b3697dd033273a36&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;919390e79dc1a872b3697dd033273a36&quot;&gt;&lt;span&gt;虽然Rust允许开发省略标注，但是需要注意的是：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;Rust根据上面规则自动恢复的标注，有可能并不是你想要表达的目的&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。如文档中的例子：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fn &lt;span class=&quot;code-snippet__keyword&quot;&gt;substr&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;s&lt;/span&gt;: &amp;amp;str, &lt;span class=&quot;code-snippet__keyword&quot;&gt;until&lt;/span&gt;: usize) -&amp;gt; &amp;amp;str;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;应用规则2，取消省略之后：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;perl&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fn &lt;span class=&quot;code-snippet__keyword&quot;&gt;substr&lt;/span&gt;&amp;lt;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;a&amp;gt;(s: &amp;amp;&#x27;&lt;/span&gt;a str, &lt;span class=&quot;code-snippet__keyword&quot;&gt;until&lt;/span&gt;: usize) -&amp;gt; &amp;amp;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;a str;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在取子串的情形中，返回的子串生命周期与输入参数一致，因此，默认恢复的标注是合理的。但是如果是下面函数：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fn country_abbr(c: &amp;amp;str) -&amp;gt; &amp;amp;str {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  match c {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;China&quot;&lt;/span&gt; =&amp;gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;CN&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;America&quot;&lt;/span&gt; =&amp;gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;US&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    _ =&amp;gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;Unknown&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;应用规则2，取消省略后的签名是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;fn&lt;/span&gt; country_abbr&amp;lt;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;a&amp;gt;(c: &amp;amp;&#x27;&lt;/span&gt;a str) -&amp;gt; &amp;amp;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;a str;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以知道，返回的“CN”，“US”，“Unknown”的生命周期是&#x27;static，由于&#x27;static的长度比所有其它生命周期都长，因此，将其以&amp;amp;&#x27;a str的类型返回不会有编译错误。但是这个结果会缩小country_abbr的使用范围，这可能并不是我们想要的结果。如下代码会无法编译通过：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fn check_lifetime(abbr: &amp;amp;&#x27;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; str) {}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;check_lifetime(country_abbr(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;China&quot;&lt;/span&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，在了解了生命周期的省略规则后，country_abbr的签名应该写作：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;fn &lt;span class=&quot;code-snippet__title&quot;&gt;country_abbr&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;c: &amp;amp;str&lt;/span&gt;) -&amp;gt; &amp;amp;&#x27;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; str&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另一个需要注意的地方是：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;对于接受多个引用参数的函数，每个引用的生命周期都是独立的&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;fn &lt;span class=&quot;code-snippet__title&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;bar: &amp;amp;str, baz: &amp;amp;str&lt;/span&gt;)&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;应该应用规则1和规则2展开为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;fn&lt;/span&gt; foo&amp;lt;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;a, &#x27;&lt;/span&gt;b&amp;gt;(bar: &amp;amp;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;a str, baz: &amp;amp;&#x27;&lt;/span&gt;b str);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而不是:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;fn&lt;/span&gt; foo&amp;lt;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;a&amp;gt;(bar: &amp;amp;&#x27;&lt;/span&gt;a str, baz: &amp;amp;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;a str);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;d3b97c67ac81c5a3266718efad1dd5ba&quot;&gt;&lt;span&gt;因为后期实际上要求了两个参数的生命周期必须是&lt;/span&gt;&lt;span&gt;&lt;strong&gt;一样的&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;， 因此施加了比前者更强的约束。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;d3b97c67ac81c5a3266718efad1dd5ba&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;2&quot; data-sign=&quot;958346aa87f49c9e4534edbe20435780&quot;&gt;&lt;span&gt;&lt;strong&gt;（三）子类化(Subtyping)与变型(Variance)&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;5&quot; data-type=&quot;p&quot; data-sign=&quot;ae38a8f68a2782358c469be8e0b5a9c2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;5&quot; data-type=&quot;p&quot; data-sign=&quot;ae38a8f68a2782358c469be8e0b5a9c2&quot;&gt;&lt;span&gt;写下这个标题时，我心里也是没有什么底的：因为相对&lt;/span&gt;&lt;span&gt;来说这是一些抽象及陌生的概念，使用简单且易于理解的语言将其说明白，对我来说是也很大的挑战。下面的说明都是使用自己理解的语言来表达的，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;不追求特别严谨精确&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，但希望易于理解。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;5&quot; data-type=&quot;p&quot; data-sign=&quot;ae38a8f68a2782358c469be8e0b5a9c2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;7&quot; data-type=&quot;p&quot; data-sign=&quot;fa84302915309c70c46e8026ef1fdc42&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;7&quot; data-type=&quot;p&quot; data-sign=&quot;fa84302915309c70c46e8026ef1fdc42&quot;&gt;&lt;span&gt;为了加快思考，人脑会将一些常用的推导变成直觉，不自觉地忽略底层的逻辑细节，子类化(Subtyping)就是其中一个例子。因为在C++中，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;子类关系&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;通常在&lt;/span&gt;&lt;span&gt;&lt;strong&gt;继承关系&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;中体现，所以从C++转过来的话，很容易下意识地认为子类就是继承。而事实上，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;子类关系是比继承关系更一般的(generic)关系&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。或者换句话说，继承关系是子类关&lt;/span&gt;&lt;span&gt;系的一种实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;759855c21d3600f143481b37c53964ff&quot;&gt;&lt;span&gt;所以，在Rust中不能简单地将子类化理解为继承，需要重新整理一下。笔者从几个点来理解：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;b227ccd4249b80f603077310d9545984&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;b227ccd4249b80f603077310d9545984&quot;&gt;&lt;span&gt;说了这么多，终于可以回到生命周期主题了。笔者在学习生命周期的过程中， 碰到第一个&lt;/span&gt;&lt;span&gt;&lt;strong&gt;反直觉&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的结论是：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&#x27;static是&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;所有其它生命周期的子类&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，可以写作&#x27;static&amp;lt;: &#x27;a (&#x27;a是任意任命周期)。你看：明明&#x27;static是最长最大最多的生命周期，为什么是子类？是小的那端？理解起来很不自然。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;5705cbe2d65c20d610cf6c912e5eab8e&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;5705cbe2d65c20d610cf6c912e5eab8e&quot;&gt;&lt;span&gt;后来一句话解了我的疑惑：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;生命周期的长度体现的是内涵&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。这句话想想还有点哲学意味。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;6&quot; data-type=&quot;p&quot; data-sign=&quot;2060a76ec7990f01e2a71a7a5ab79e60&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;6&quot; data-type=&quot;p&quot; data-sign=&quot;2060a76ec7990f01e2a71a7a5ab79e60&quot;&gt;&lt;span&gt;因此，&amp;lt;: 描述的是&lt;/span&gt;&lt;span&gt;&lt;strong&gt;外延&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的大小，所以，任何大于&#x27;a的生命周期都是&#x27;a的实例，而&#x27;static的实例只有一个，就是&#x27;static本身。显然，&#x27;a的外延大于&#x27;static，所以&#x27;static是子类。从&lt;/span&gt;&lt;span&gt;&lt;strong&gt;有用性&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的角度理解，&#x27;static可以在任何需要生命周期的地方使用，是最有用的，所以根据前面说到的，子类比超类更有用，&#x27;static显然是子类。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;6&quot; data-type=&quot;p&quot; data-sign=&quot;2060a76ec7990f01e2a71a7a5ab79e60&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;7a9596006c7bc1e821ada9394895f6f2&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;7a9596006c7bc1e821ada9394895f6f2&quot;&gt;&lt;span&gt;在介绍变型之前，需要先引入另外一个概念&lt;/span&gt;&lt;span&gt;&lt;strong&gt;类型构造子&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;(Type Constructor)&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。首先这个概念要与C++中的&lt;/span&gt;&lt;span&gt;&lt;strong&gt;构造函数(Constructor)&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;区别开来：构造函数是用于创建类型的&lt;/span&gt;&lt;span&gt;&lt;strong&gt;新实例&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;；而类型构造子则是用于创建&lt;/span&gt;&lt;span&gt;&lt;strong&gt;新类型&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;2dc925e4621ff59150fd3be93b66ee0f&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;2dc925e4621ff59150fd3be93b66ee0f&quot;&gt;&lt;span&gt;在考虑&lt;/span&gt;&lt;span&gt;&lt;strong&gt;变型&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;时，主要是第二种情形，即&lt;/span&gt;&lt;span&gt;：泛型类型的实例化。&lt;/span&gt;&lt;span&gt;我们可以将&lt;/span&gt;&lt;span&gt;&lt;strong&gt;泛型类型&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;理解为&lt;/span&gt;&lt;span&gt;&lt;strong&gt;类型的函数&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，因为其接收类型参数，返回新的类型。这样，我们就可以引出&lt;/span&gt;&lt;span&gt;&lt;strong&gt;变型&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的三种情况了：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;ebeeeeeded1200e17a064e2c5f6f5db7&quot;&gt;&lt;span&gt;假设有类型构造子：F&amp;lt;T&amp;gt;, 并且有两个具体的类型：Super和Sub满足Sub&amp;lt;:Super，这两个具体类型通过F&amp;lt;T&amp;gt;可以分别构建新类型F&amp;lt;Sub&amp;gt;和F&amp;lt;Super&amp;gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;e32bc0c37fa50b90876af8295307f899&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;e32bc0c37fa50b90876af8295307f899&quot;&gt;&lt;span&gt;终于介绍完了两个抽象概念，可以回来谈Rust了。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;5ee387cd3d81667b841aac8d56fbbe71&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;5ee387cd3d81667b841aac8d56fbbe71&quot;&gt;&lt;span&gt;Rust当前&lt;/span&gt;&lt;span&gt;&lt;strong&gt;没有&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;定义类型间的子类关系。trait虽然可以继承，但并不是符合定义的子类关系（无法将&amp;amp;dyn Derive直接传给&amp;amp;dyn Base）。因此，在当前版本的Rust中，&lt;/span&gt;&lt;span&gt;子类关系只在生命周期中存在&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;64132b3fa2a845cf112624a19b8c58b5&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;64132b3fa2a845cf112624a19b8c58b5&quot;&gt;&lt;span&gt;在Rust的&lt;/span&gt;&lt;span&gt;文档&lt;/span&gt;&lt;span&gt;中，有一个表描述了各种类型的变型关系，这里针对不太容易理解的两种情况进一步说明：&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;64132b3fa2a845cf112624a19b8c58b5&quot;&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;h5 data-lines=&quot;2&quot; data-sign=&quot;5974c5ca0e23c0edebbaab2559c5c5d3&quot;&gt;&lt;span&gt;&lt;strong&gt;&amp;amp;&#x27;a mut T为什么对T是不变(invariant)?&lt;/strong&gt;&lt;/span&gt;&lt;/h5&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;fe9c0103ed47a6eb8b32d897b35dbaa6&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;fe9c0103ed47a6eb8b32d897b35dbaa6&quot;&gt;&lt;span&gt;根据《&lt;/span&gt;&lt;span&gt;锈灵书&lt;/span&gt;&lt;span&gt;》在介绍变型的相关章节中提供的例子：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;fn &lt;span class=&quot;code-snippet__title&quot;&gt;evil_feeder&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;pet: &amp;amp;mut Animal&lt;/span&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;let&lt;/span&gt; spike: Dog = ...;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    *pet = spike;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;fn &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;/&gt;)&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;let&lt;/span&gt; mut mr_snuggles: Cat = ...;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    evil_feeder(&amp;amp;mut mr_snuggles);  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    mr_snuggles.meow();             &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;83921f4b885b717a1e8415b08759328c&quot;&gt;&lt;span&gt;&amp;amp;mut T对T的不变性(invariant) 是为了阻止通过修改超类的引用&amp;amp;mut Animal将Dog的实例复制到Cat的内存上(*pet=spike)。但是这个例子还是有一些不清晰的地方：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如前面所述，类型间的子类关系在Rust并未定义，所以这里上面提到“Dog is a subtype of Animal”并不准确。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，由于trait object是一个动态尺寸类型(dynamic sized type)，所以必须Dog，Cat必须位于某种指针之后，因此，let spike: Dog=...不是合法的代码。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;033139160e7fcf5aee45022e07112065&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;033139160e7fcf5aee45022e07112065&quot;&gt;&lt;span&gt;从逻辑上说，拿到某个类的指针，并不能用子类(当然也不能用超类)实例去覆盖该类的实例，因此，&amp;amp;mut T应该是不变的(invariant)。笔者推测是否也是Rust为了保留以后类型子类化的能力。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;033139160e7fcf5aee45022e07112065&quot;&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;h5 data-lines=&quot;2&quot; data-sign=&quot;13371e3f3725b2e37d88d716fb285c3a&quot;&gt;&lt;span&gt;&lt;strong&gt;fn(T)-&amp;gt; ()为什么对T是逆变(contravariant)?&lt;/strong&gt;&lt;/span&gt;&lt;/h5&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-lines=&quot;6&quot; data-type=&quot;p&quot; data-sign=&quot;2f75d0c6806b0a05c0031eaa446ad670&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;6&quot; data-type=&quot;p&quot; data-sign=&quot;2f75d0c6806b0a05c0031eaa446ad670&quot;&gt;&lt;span&gt;这是文档中唯一的逆变的例子，所以多说明一下。fn(T) -&amp;gt; ()是函数类型，用该类型描述某个作用场景(即，参数位置)时，其实是回调的场景。因此，回调函数的参数类型T，实际是对调用方的要求。这个要求越少(即，更加泛化，约束少，更偏向超类)， 回调函数反而使用场景更大(即，更有用)。前面已经说到，更有用的是子类。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;cb6d72b636d41ccde113444a815cdd16&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;cb6d72b636d41ccde113444a815cdd16&quot;&gt;&lt;span&gt;举个例子：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;A&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__title&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;foo&lt;/span&gt;(&lt;span class=&quot;code-snippet__title&quot;&gt;cb&lt;/span&gt;: &lt;span class=&quot;code-snippet__title&quot;&gt;fn&lt;/span&gt;(&lt;span class=&quot;code-snippet__title&quot;&gt;a&lt;/span&gt;: &amp;amp;&lt;span class=&quot;code-snippet__title&quot;&gt;A&lt;/span&gt;)) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;let&lt;/span&gt; a = &lt;span class=&quot;code-snippet__type&quot;&gt;A&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  cb(&amp;amp;a);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fn cb0(_a: &amp;amp;&lt;span class=&quot;code-snippet__type&quot;&gt;A&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__built_in&quot;&gt;println&lt;/span&gt;!(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;cb0 called.&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fn cb1(_a: &amp;amp;&#x27;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__type&quot;&gt;A&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__built_in&quot;&gt;println&lt;/span&gt;!(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;cb1 called.&quot;&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;fn main() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  foo(cb1);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;95db838532e6fef320360e5dd013df8b&quot;&gt;&lt;span&gt;这里cb1的参数类型&amp;amp;&#x27;statc A是cb0的参数类型&amp;amp;&#x27;a A的子类，但是cb1却不能被foo接受。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;95db838532e6fef320360e5dd013df8b&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;95db838532e6fef320360e5dd013df8b&quot;&gt;&lt;/p&gt;&lt;h3 data-lines=&quot;2&quot; data-sign=&quot;ccefd91f69c2074ca1ad0b762f0c2194&quot;&gt;&lt;span&gt;&lt;strong&gt;（四）关于生命周期容易产生的误解&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;fb873642169d347af8a5f3adc79131da&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;fb873642169d347af8a5f3adc79131da&quot;&gt;&lt;span&gt;在Rust中，生命周期是全新的概念，因此也容易理解错误，对于常见的情形，&lt;/span&gt;&lt;span&gt;Common Rust Lifetime Misconceptions&lt;/span&gt;&lt;span&gt;一文介绍得非常清楚。&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;fb873642169d347af8a5f3adc79131da&quot;&gt;&lt;span&gt;文档：（&lt;/span&gt;&lt;span&gt;https://github.com/pretzelhammer/rust-blog/blob/master/posts&lt;/span&gt;&lt;span&gt;/common-rust-lifetime-misconceptions.md#3-a-t-and-t-a-are-the-same-thing&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;fb873642169d347af8a5f3adc79131da&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;fb873642169d347af8a5f3adc79131da&quot;&gt;&lt;span&gt;如果刚开始学习Rust特别需要注意：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;d3abea91348dfb9434b7a672df66d4a5&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;d3abea91348dfb9434b7a672df66d4a5&quot;&gt;&lt;span&gt;对于熟悉C++重载规则的开发来说，这两点是需要注意的。在Rust中，因为T包含&amp;amp;T，所以，不能同时为T，&amp;amp;T实现一个trait. 如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;Trait&lt;/span&gt; {}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;impl&amp;lt;T&amp;gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;Trait&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; T {}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;impl&amp;lt;T&amp;gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;Trait&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; &amp;amp;T {} &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&amp;amp;mut T和T也同理。因此，要为引用实现trait应该写作：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;php&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;trait&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;Trait&lt;/span&gt; {}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;impl&amp;lt;T&amp;gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;Trait&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; &amp;amp;T {} &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;impl&amp;lt;T&amp;gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;Trait&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; &amp;amp;mut T {} &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;ad00f11a7ffd607a7a224990ad517470&quot;&gt;&lt;span&gt;另外，即是要区分好，T: &#x27;static和&amp;amp;&#x27;static T，主要规则如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为T: &#x27;static包括&lt;/span&gt;&lt;span&gt;&lt;strong&gt;拥有所有权类型&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，所以T：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;a660cfd7cb7733baf35a9929e6889227&quot;&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;a660cfd7cb7733baf35a9929e6889227&quot;&gt;&lt;span&gt;更加一般地，T: &#x27;a和&amp;amp;&#x27;a T的规则如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;三、后记&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;9e53a5447c415a718c71708e5047232c&quot;&gt;&lt;span&gt;这两个主题比我想像花了更多的篇幅，所以这一篇先到这里吧。后面计划继续聊聊&lt;/span&gt;&lt;span&gt;&lt;strong&gt;可修改性Mutablility&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;&lt;strong&gt;异步Async&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt; 作者简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe96Vvfqbsjqsn4P1wIc5VzbicpHkI09FrZJ7RyPvNwHTpB3VrVPYj9R3O5cRmSGqEBt29qqB1xDKXXg/0?wx_fmt=jpeg&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;12.19047619047619&quot; data-cropy2=&quot;1316.5714285714284&quot; data-fileid=&quot;100044396&quot; data-ratio=&quot;1.0157407407407408&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe96Vvfqbsjqsn4P1wIc5VzbicdX3CvyHpjvMpiaY46coXiar12RG8xCuRyl7k6UvECGg2S8INHARTwWXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;孟杰&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;腾讯后台开发工程师&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;腾讯后台开发工程师，毕业于中南大学。目前负责腾讯安全流量分析平台的后台开发工作。开发经验丰富，对程序语言，类型系统，编译等方向很感兴趣。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;觉得不错，点个赞吧&lt;/p&gt;&lt;p&gt;扫码关注「&lt;span&gt;Rust编程指北&lt;/span&gt;」&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/kmhrPEkIgHUOxOIbBEsyACGOicYC9vRw0NtRrW7BsnWWmBjtwvOLEO75Yxib6ViagwACCA1z7p29eG6HCad48fXAA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6e71cdf89e0014441b998e1ebb87eaa2</guid>
<title>吴恩达：机器学习的六个核心算法</title>
<link>https://toutiao.io/k/7s61wih</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-darkmode-bgcolor-16521906578916=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521906578916=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521906578916=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521906578916=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin-right: 16px; margin-left: 16px; padding-right: 0em; padding-left: 0em; outline: 0px; max-width: 100%; color: rgb(34, 34, 34); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; white-space: normal; font-size: 16px; widows: 1; background-color: rgb(255, 255, 255); text-align: right; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__3&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span data-darkmode-bgcolor-16521906578916=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521906578916=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521906578916=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16521906578916=&quot;#fff|rgb(34, 34, 34)|rgb(136, 136, 136)&quot;&gt;本文转载自 | AI科技评论&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16521906578916=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521906578916=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521906578916=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521906578916=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin-right: 16px; margin-left: 16px; padding-right: 0em; padding-left: 0em; outline: 0px; max-width: 100%; color: rgb(34, 34, 34); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; white-space: normal; font-size: 16px; widows: 1; background-color: rgb(255, 255, 255); text-align: right; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__3&quot;&gt;&lt;span data-darkmode-bgcolor-16521906578916=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521906578916=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521906578916=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16521906578916=&quot;#fff|rgb(34, 34, 34)|rgb(136, 136, 136)&quot;&gt;编译 | 黄楠&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最近，吴恩达在其创办的人工智能周讯《The Batch》上更新了一篇博文，总结了机器学习领域多个基础算法的历史溯源。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;文章开头，吴恩达回忆他的研究历程中曾有一次抉择：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;多年前，在一次项目中，选择算法时，他不得不在神经网络与决策树学习算法之间做选择。考虑到计算预算，他最终选择了神经网络，在很长的一段时间内弃用增强决策树。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是一个错误的决定，「幸好我的团队很快修改了我的选择，项目才成功。」吴恩达谈道。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;他由此感叹，不断学习与更新基础知识是十分重要的。与其他技术领域一样，随着研究人员的增加、研究成果数量的增长，机器学习领域也在不断发展。但有些基础算法与核心思想的贡献是经得起时间考验的：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;算法：线性和逻辑回归、决策树等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;概念：正则化、优化损失函数、偏差/方差等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在吴恩达看来，这些算法与概念是许多机器学习模型的核心思想，包括房价预测器、文本-图像生成器（如DALL·E）等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在最新的这篇文章中，吴恩达与团队调研了六种基础算法的来源、用途、演变等，并提供了较为详细的讲解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这六种算法分别是：线性回归、逻辑回归、梯度下降、神经网络、决策树与k均值聚类算法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; data-style=&quot;outline: 0px; max-width: 100%; color: rgb(0,0,0); letter-spacing: 1.5px; line-height: 24px; word-break: break-all; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__5&quot;&gt;&lt;p data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;span data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; msthash=&quot;12992109&quot; msttexthash=&quot;4459&quot;&gt;1&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; data-style=&quot;margin: -4px 2px; outline: 0px; max-width: 100%; color: rgb(0,0,0); letter-spacing: 1.5px; line-height: 24px; word-break: break-all; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__6&quot;&gt;&lt;p data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;strong data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; msthash=&quot;14836042&quot; msttexthash=&quot;20191860&quot;&gt;『线性回归：直的&amp;amp;窄的』&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin: 3px auto 6px; outline: 0px; max-width: 100%; width: 50px; height: 0px; border-top: 1px solid rgb(0,0,0); visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__7&quot;&gt;&lt;br data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-filtered=&quot;filtered&quot;/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin: 3px auto 1px; outline: 0px; max-width: 100%; width: 100px; height: 0px; border-top: 1px solid rgb(0,0,0); visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__8&quot;&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;线性回归是机器学习中的一个关键的统计方法，但它并非不战而胜。它由两位杰出的数学家提出，但200 年过去了，这个问题仍未解决。长期存在的争议不仅证明了该算法具有出色的实用性，还证明了它的本质十分简单。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么线性回归到底是谁的算法呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1805 年，法国数学家 Adrien-Marie Legendre 发表了将一条线拟合到一组点的方法，同时试图预测彗星的位置（天体导航是当时全球商业中最有价值的科学方向，就像今天的人工智能一样）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;540&quot; data-ratio=&quot;1.424802110817942&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cNFA8C0uVPuNqicARDfV4XYLt8JhicVIsOfNNUvlUgcVm2RhF8icQmNNOb50QvES1uhJqdO9M3zTp703V1ia6hjRsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;379&quot; data-width=&quot;379&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图注：Adrien-Marie Legendre 的素描画像&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;四年后，24 岁的德国神童 Carl Friedrich Gauss （高斯）坚称他自 1795 年以来一直在使用它，但认为它太琐碎了，无法写。高斯的主张促使Legendre匿名发表了一份文章，称“一位非常著名的几何学家毫不犹豫地采用了这种方法。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;463&quot; data-ratio=&quot;1.2740740740740741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cNFA8C0uVPuNqicARDfV4XYLt8JhicVIsOJL0SJkvOC6EPy7ib63vO3OceJ9lfibpJW4ylRQOhjAvg9hOmhmlNvBQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-width=&quot;365&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图注：Carl Friedrich Gauss&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;斜率和偏差&lt;/strong&gt;：当结果与影响它的变量之间的关系遵循直线时，线性回归很有用。例如，汽车的油耗与其重量成线性关系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;普及的两个步骤&lt;/strong&gt;：该算法立即帮助航海者追踪星星，以及帮助后来的生物学家（尤其是查尔斯·达尔文的堂兄Francis Galton）识别植物和动物的可遗传特征。这两项深入发展释放了线性回归的广泛潜力。1922 年，英国统计学家 Ronald Fisher 和 Karl Pearson 展示了线性回归如何适应相关性和分布的一般统计框架，使其在所有科学中都有用。而且，近一个世纪后，计算机的出现提供了数据和处理能力，可以更大程度地利用它。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;应对歧义&lt;/strong&gt;：当然，数据永远不会被完美地衡量，有些变量比其他变量更重要。这些生活事实激发了更复杂的变体。例如，带有正则化的线性回归（也称为「岭回归」，ridge regression）鼓励线性回归模型不要过多地依赖于任何一个变量，或者更确切地说，均匀地依赖于最重要的变量。如果为了简单起见，另一种形式的正则化（L1 而不是 L2）会产生 lasso（压缩估计），鼓励尽可能多的系数为零。换句话说，它学会选择具有高预测能力的变量并忽略其余的。弹性网络结合了这两种类型的正则化。当数据稀疏或特征看起来相关时，它很有用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;在每个神经元中&lt;/strong&gt;：现在，简单的版本仍然非常有用。神经网络中最常见的神经元类型是线性回归模型，随后是非线性激活函数，使线性回归成为深度学习的基本组成部分。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; data-style=&quot;outline: 0px; max-width: 100%; color: rgb(0,0,0); letter-spacing: 1.5px; line-height: 24px; word-break: break-all; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__5&quot;&gt;&lt;p data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;span data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; msthash=&quot;12992109&quot; msttexthash=&quot;4459&quot;&gt;2&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; data-style=&quot;margin: -4px 2px; outline: 0px; max-width: 100%; color: rgb(0,0,0); letter-spacing: 1.5px; line-height: 24px; word-break: break-all; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__6&quot;&gt;&lt;p data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;strong data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; msthash=&quot;14836042&quot; msttexthash=&quot;20191860&quot;&gt;『逻辑回归：跟随曲线』&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin: 3px auto 6px; outline: 0px; max-width: 100%; width: 50px; height: 0px; border-top: 1px solid rgb(0,0,0); visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__7&quot;&gt;&lt;br data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-filtered=&quot;filtered&quot;/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin: 3px auto 1px; outline: 0px; max-width: 100%; width: 100px; height: 0px; border-top: 1px solid rgb(0,0,0); visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__8&quot;&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;曾经有一段时间，逻辑回归只用于对一件事进行分类：如果你喝了一瓶毒药，你可能会被贴上的标签是“活着”还是“死去”呢？时代变了，今天，不仅呼叫紧急服务为这个问题提供了更好的答案，而且逻辑回归也成为了深度学习的核心。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;毒物控制&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;逻辑函数可以追溯到 1830 年代，当时比利时统计学家 P.F. Verhulst 发明它来描述人口动态：随着时间的推移，指数增长的初始爆炸随着它消耗可用资源而趋于平缓，从而产生特征逻辑曲线。一个多世纪过去后，美国统计学家 E. B. Wilson 和他的学生 Jane Worcester 又设计了逻辑回归来计算给定有害物质有多少是致命的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;600&quot; data-ratio=&quot;1.5584415584415585&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cNFA8C0uVPuNqicARDfV4XYLt8JhicVIsOyicCWGnByS9WB95gsKYhdhuibzJHDC2Dlg1mtldlfCNcrE0wpey6l0DQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;385&quot; data-width=&quot;385&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图注：P.F. Verhulst&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;拟合函数&lt;/strong&gt;：逻辑回归将逻辑函数拟合到数据集，以便预测给定事件（例如，摄入士的宁）发生特定结果（例如，过早死亡）的概率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;更多结果&lt;/strong&gt;：Verhulst 的工作发现了二元结果的概率，忽略了进一步的可能性，例如中毒受害者可能会进入来世的哪一边。他的继任者扩展了算法：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;492&quot; data-ratio=&quot;1.2793136320305052&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cNFA8C0uVPuNqicARDfV4XYLt8JhicVIsO3e3qmxibgZibLlDAM6NUReeIvjn1o6REPmxUeoNoJtkagn14UeGq031w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2098&quot; data-width=&quot;386&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图注：David Cox&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;多功能曲线&lt;/strong&gt;：逻辑函数以相当准确的方式描述了广泛的现象，因此逻辑回归在许多情况下提供了有用的基线预测。在医学上，它可以估计死亡率和疾病风险。在政治学中，它预测选举的赢家和输家。在经济学中，它预测商业前景。更重要的是，它在各种各样的神经网络中驱动一部分神经元（其中非线性是 Sigmoid 函数）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; data-style=&quot;outline: 0px; max-width: 100%; color: rgb(0,0,0); letter-spacing: 1.5px; line-height: 24px; word-break: break-all; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__5&quot;&gt;&lt;p data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;span data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; msthash=&quot;12992109&quot; msttexthash=&quot;4459&quot;&gt;3&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; data-style=&quot;margin: -4px 2px; outline: 0px; max-width: 100%; color: rgb(0,0,0); letter-spacing: 1.5px; line-height: 24px; word-break: break-all; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__6&quot;&gt;&lt;p data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;strong data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; msthash=&quot;14836042&quot; msttexthash=&quot;20191860&quot;&gt;『梯度下降：一切都在下坡』&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin: 3px auto 6px; outline: 0px; max-width: 100%; width: 50px; height: 0px; border-top: 1px solid rgb(0,0,0); visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__7&quot;&gt;&lt;br data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-filtered=&quot;filtered&quot;/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin: 3px auto 1px; outline: 0px; max-width: 100%; width: 100px; height: 0px; border-top: 1px solid rgb(0,0,0); visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__8&quot;&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;想象一下黄昏后在山上徒步旅行，发现脚下什么都看不到。而且您的手机电池没电了，因此您无法使用 GPS 应用程序找到回家的路。您可能会通过梯度下降找到最快的路径。小心不要从悬崖上走。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;太阳和地毯：&lt;/strong&gt;梯度下降比通过陡峭的地形下降更有利。1847年，法国数学家Augustin-Louis Cauchy发明了近似恒星轨道的算法。60 年后，他的同胞 Jacques Hadamard 独立开发了它来描述薄而灵活的物体（如地毯）的变形，这可能会使膝盖向下徒步更容易。然而，在机器学习中，它最常见的用途是找到学习算法损失函数的最低点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-height=&quot;388&quot; data-ratio=&quot;1.3857142857142857&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cNFA8C0uVPuNqicARDfV4XYLt8JhicVIsOHZ3Vk98Rr6FfnhkrNLJYotia1JVdhM9l3X07V6zw7mEHC9tH3J5j7dw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;280&quot; data-width=&quot;280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图注：Augustin-Louis Cauchy&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;向下爬&lt;/strong&gt;：经过训练的神经网络提供了一个函数，该函数在给定输入的情况下计算所需的输出。训练网络的一种方法是通过迭代计算实际输出与期望输出之间的差异，然后更改网络的参数值以缩小差异，从而将输出中的损失或误差最小化。梯度下降缩小了差异，将计算损失的函数最小化。网络的参数值相当于地形上的一个位置，损失的是当前高度。随着你的下降，你可以提高网络计算接近所需输出的能力。可见性是有限的，因为在典型的监督学习情况下，该算法仅依赖于网络的参数值和损失函数的梯度或斜率——即你在山上的位置和你脚下的斜率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;卡在山谷里&lt;/strong&gt;：太糟糕了，你的手机没电了，因为算法可能没有把你推到凸山的底部。你可能会陷入由多个山谷（局部最小值）、山峰（局部最大值）、鞍点（鞍点）和高原组成的非凸面景观中。事实上，图像识别、文本生成和语音识别等任务都是非凸的，并且已经出现了梯度下降的许多变体来处理这种情况。例如，该算法可能具有帮助它放大小幅上涨和下跌的动量，从而使其更有可能到达底部。研究人员设计了如此多的变体，以至于看起来优化器的数量与局部最小值一样多。幸运的是，局部最小值和全局最小值往往大致相等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;最优优化器&lt;/strong&gt;：梯度下降是寻找任一函数的最小值的明确选择。在可以直接计算精确解的情况下——例如，具有大量变量的线性回归任务中——它可以逼近一个值，而且通常速度更快、成本更低。但它确实在复杂的非线性任务中发挥了作用。凭借梯度下降和冒险精神，你可能可以及时赶出山区吃晚饭。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; data-style=&quot;outline: 0px; max-width: 100%; color: rgb(0,0,0); letter-spacing: 1.5px; line-height: 24px; word-break: break-all; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__5&quot;&gt;&lt;p data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;span data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; msthash=&quot;12992109&quot; msttexthash=&quot;4459&quot;&gt;4&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; data-style=&quot;margin: -4px 2px; outline: 0px; max-width: 100%; color: rgb(0,0,0); letter-spacing: 1.5px; line-height: 24px; word-break: break-all; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__6&quot;&gt;&lt;p data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;strong data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; msthash=&quot;14836042&quot; msttexthash=&quot;20191860&quot;&gt;『神经网络：寻找函数』&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin: 3px auto 6px; outline: 0px; max-width: 100%; width: 50px; height: 0px; border-top: 1px solid rgb(0,0,0); visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__7&quot;&gt;&lt;br data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-filtered=&quot;filtered&quot;/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin: 3px auto 1px; outline: 0px; max-width: 100%; width: 100px; height: 0px; border-top: 1px solid rgb(0,0,0); visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__8&quot;&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;让我们先把这个问题弄清楚：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;大脑不是一个图形处理单元集&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;如果它是的话，那它运行的软件要比典型的人工神经网络复杂得多。而神经网络的灵感来自大脑的结构：一层层相互连接的神经元，每个神经元根据其相邻状态来计算自己的输出，由此产生的一连串活动形成了一个想法——或识别出一张猫的照片。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;从生物到人工&lt;/strong&gt;：大脑通过神经元之间相互作用来学习的想法可以追溯到 1873 年，但直到 1943 年，美国神经科学家 Warren McCulloch 和 Walter Pitts 才利用简单的数学规则建立了生物神经网络模型。1958 年，美国心理学家Frank Rosenblatt开发出感测器——这是一种在打卡机上实现的单层视觉网络，旨在为美国海军建立一个硬件版本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;307&quot; data-backw=&quot;546&quot; data-height=&quot;641&quot; data-ratio=&quot;0.5622807017543859&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cNFA8C0uVPuNqicARDfV4XYLt8JhicVIsOGjmG7tr2UoxFKCJicdKUF3BPWU4PTT1Xt12T4hcRXGmiaNVibBkiaxoCxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1140&quot; data-width=&quot;1140&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图注：Frank Rosenblatt&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;越大越好&lt;/strong&gt;：Rosenblatt 的发明只能识别单线分类。之后，乌克兰数学家 Alexey Ivakhnenko 和 Valentin Lapa 通过在任意层数中堆叠神经元网络，克服了这一限制。1985 年，独立工作的法国计算机科学家 Yann LeCun、David Parker 和美国心理学家 David Rumelhart 及其同事，描述了使用反向传播来有效训练此类网络。在新千年的第一个十年中，包括 Kumar Chellapilla、Dave Steinkraus 和 Rajat Raina（与吴恩达合作）在内的研究人员通过使用图形处理单元进一步推动了神经网络的发展，这使得越来越大的神经网络能从互联网生成的海量数据中得到学习。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;适合每项任务&lt;/strong&gt;：神经网络背后的原理很简单：对于任何任务，都有一个可执行它的函数。一个神经网络通过组合多个简单函数构成可训练函数，每个函数由单个神经元执行。一个神经元的功能由称为「权重」的可调参数决定。给定这些权重和输入示例及其所需输出的随机值，就可以反复更改权重，直到可训练的函数能完成手头的任务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;黑匣子&lt;/strong&gt;：虽然运气好的话，一个训练有素的网络可以完成它的任务，但最终你要阅读一个函数，往往会非常复杂——包含数千个变量和嵌套的激活函数——以至于解释网络是如何成功完成其任务也是非常困难的。此外， 一个训练有素的网络只和它所学的数据一样好。例如，如果数据集有偏差，那么网络的输出也会出现偏差。如果它只包含猫的高分辨率图片，那它对低分辨率图片的反应就不得而知了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个常识：在报道 Rosenblatt 于1958年发明的感测器时，《纽约时报》开辟了人工智能炒作的道路，报道中提到“美国海军期望拥有一台会走路、说话、看、写、自我复制和意识到自己存在的电子计算机雏形。” 虽然当时的感测器没有达到这个要求，但它产生了许多令人印象深刻的模型：用于图像的卷积神经网络；文本的循环神经网络；以及用于图像、文本、语音、视频、蛋白质结构等的transformers。它们已经做出了令人惊叹的事情，像下围棋时的表现超过了人类水平，在诊断X射线图像等实际任务中也接近人类水平。然而，它们在常识和逻辑推理方面的问题仍然较难应对。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; data-style=&quot;outline: 0px; max-width: 100%; color: rgb(0,0,0); letter-spacing: 1.5px; line-height: 24px; word-break: break-all; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__5&quot;&gt;&lt;p data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;5&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; data-style=&quot;margin: -4px 2px; outline: 0px; max-width: 100%; color: rgb(0,0,0); letter-spacing: 1.5px; line-height: 24px; word-break: break-all; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__6&quot;&gt;&lt;p data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;strong data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; msthash=&quot;14836042&quot; msttexthash=&quot;20191860&quot;&gt;『决策树：从根到叶』&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin: 3px auto 6px; outline: 0px; max-width: 100%; width: 50px; height: 0px; border-top: 1px solid rgb(0,0,0); visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__7&quot;&gt;&lt;br data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-filtered=&quot;filtered&quot;/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin: 3px auto 1px; outline: 0px; max-width: 100%; width: 100px; height: 0px; border-top: 1px solid rgb(0,0,0); visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__8&quot;&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;亚里士多德是一个什么样的「野兽」？这位哲学家的追随者、第三世纪期间生活在叙利亚的 Porphyry 想出了一个合乎逻辑的方法来回答这个问题。他将亚里士多德提出的“存在类别”从一般到具体组合起来，将亚里士多德依次归入到每个分类中：亚里士多德的存在是物质的而不是概念或精神；他的身体是有生命的而不是无生命的；他的思想是理性的而不是非理性的。因此，他的分类是人类。中世纪的逻辑教师将这个序列绘制为垂直流程图：一个早期的决策树。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;数字差异&lt;/strong&gt;：快进到 1963 年，密歇根大学社会学家John Sonquist和经济学家James Morgan在将调查的受访者分组时，首次在计算机中实行了决策树。随着自动训练算法软件的出现，这种工作变得很普遍，如今包括 scikit-learn 等在内的各种机器学习库也已经使用决策树。这套代码是由斯坦福大学和加州大学伯克利分校的四位统计学家花费了10 年时间开发的。到今天，从头开始编写决策树已经成为了《机器学习 101》中的一项家庭作业。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;空中的根&lt;/strong&gt;：决策树可以执行分类或回归。它向下生长，从根部到树冠，将一个决策层次结构的输入示例分类为两个（或更多）。想到德国医学家和人类学家Johann Blumenbach的课题：大约在 1776 年，他首先将猴子与猿（撇开人类除外）区分开来，在此之前，猴子和猿是被归为一类的。这种分类取决于各种标准，例如是否有尾巴、胸部狭窄或宽阔、是直立还是蹲伏、还有智力的高低。使用经训练的决策树来为这类动物贴上标签，逐一考虑每个标准，最终将这两组动物分开。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;进入前 10 名：鉴于 Blumenbach 的结论（后来被Charles Darwin推翻），即人类与猿的区别在于宽阔的骨盆、手和紧牙的牙齿，如果我们想扩展决策树以不仅分类猿和猴子，而是对人类进行分类，那会怎么样呢？澳大利亚计算机科学家 John Ross Quinlan 在 1986 年通过 ID3 实现了这一可能，它扩展了决策树，以支持非二元结果。2008 年， 在IEEE国际数据挖掘会议策划的数据挖掘十大算法名单中，一项命名为 C4.5 的扩展细化算法名列前茅。在一个创新猖獗的世界里，这就是持久力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;扒开树叶：决策树确实有一些缺点。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;它们很容易通过增加多级别层次来过度拟合数据，以至于叶节点只包括一个例子。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;更糟糕的是，它们很容易出现蝴蝶效应：更换一个例子，长出来的树就大不相同。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;走进森林：美国统计学家 Leo Breiman 和新西兰统计学家 Adele Cutler 将这一特征转化为优势，于 2001 年开发了随机森林（random forest）——这是一个决策树的集合，每个决策树会处理不同的、重叠的示例选择，并对最终结果进行投票。随机森林和它的表亲XGBoost不太容易过度拟合，这有助于使它们成为最受欢迎的机器学习算法之一。这就像让亚里士多德、Porphyry、Blumenbach、Darwin、 Jane Goodall、Dian Fossey和其他 1000 位动物学家一起在房间里，确保你的分类是最好的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; data-style=&quot;outline: 0px; max-width: 100%; color: rgb(0,0,0); letter-spacing: 1.5px; line-height: 24px; word-break: break-all; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__5&quot;&gt;&lt;p data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;span data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; msthash=&quot;12992109&quot; msttexthash=&quot;4459&quot;&gt;6&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot;&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; data-style=&quot;margin: -4px 2px; outline: 0px; max-width: 100%; color: rgb(0,0,0); letter-spacing: 1.5px; line-height: 24px; word-break: break-all; visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__6&quot;&gt;&lt;p data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;span data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot;&gt;&lt;strong data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(39, 84, 255)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)|rgb(0,0,0)&quot; msthash=&quot;14836042&quot; msttexthash=&quot;20191860&quot;&gt;『K均值聚类：群体思维』&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin: 3px auto 6px; outline: 0px; max-width: 100%; width: 50px; height: 0px; border-top: 1px solid rgb(0,0,0); visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__7&quot;&gt;&lt;br data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-filtered=&quot;filtered&quot;/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xmyeditor.com&quot; data-md5=&quot;207fd&quot; data-darkmode-bgcolor-16521905242426=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16521905242426=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16521905242426=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16521905242426=&quot;#fff|rgb(34, 34, 34)&quot; data-style=&quot;margin: 3px auto 1px; outline: 0px; max-width: 100%; width: 100px; height: 0px; border-top: 1px solid rgb(0,0,0); visibility: visible; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__8&quot;&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;如果你在聚会上与其他人站得很近，那么你们很可能有一些共同点。这就是使用 k 均值聚类将数据点分组的想法。无论是通过人类机构还是其他力量形成的群体，这个算法都会找到它们。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;从爆炸到拨号音&lt;/strong&gt;：美国物理学家 Stuart Lloyd 是贝尔实验室标志性创新工厂和发明原子弹的曼哈顿计划的校友，他于 1957 年首次提出 k-means 聚类，以在数字信号中分配信息，但直到 1982 年才发表这个工作：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;105&quot; data-backw=&quot;546&quot; data-height=&quot;388&quot; data-ratio=&quot;0.19188921859545005&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cNFA8C0uVPuNqicARDfV4XYLt8JhicVIsOpJuygA1lgnEzII4KgU8XhiasDWcKYJUDZiaUGNHg87RibIyeCW8JibgTDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2022&quot; data-width=&quot;2022&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;论文地址：https://cs.nyu.edu/~roweis/csc2515-2006/readings/lloyd57.pdf&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与此同时，美国统计学家 Edward Forgy 在 1965 年描述了一种类似的方法，导致了它的替代名称为「Lloyd-Forgy 算法」。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;寻找中心&lt;/strong&gt;：考虑将聚类分成志同道合的工作组。给定房间中参与者的位置和要形成的组数，k-means 聚类可以将参与者分成大小大致相等的组，每个组都聚集在一个中心点或质心周围。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;不同的距离&lt;/strong&gt;：当然，聚类对象之间的距离不需要很大。两个向量之间的任何度量都可以。例如，k-means 聚类可以根据他们的服装、职业或其他属性来划分他们，而不是根据物理距离对参加派对的人进行分组。在线商店使用它根据客户的喜好或行为来划分客户，天文学家也可以将相同类型的星星分在一组。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据点的力量&lt;/strong&gt;：这个想法产生了一些显着的变化：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;n 维狂欢&lt;/strong&gt;：尽管如此，原始形式的算法仍然广泛有用——特别是因为作为一种无监督算法，它不需要收集昂贵的标记数据。它的使用速度也越来越快。例如，包括 scikit-learn 在内的机器学习库受益于 2002 年添加的 kd-trees，这些 kd-trees 可以非常快速地划分高维数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原文链接：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://read.deeplearning.ai/the-batch/issue-146/&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jupejmznDCicCEDfm4Q5koCraSm45XoTnY8A5RQMIFlLNVKlC8bo97y7Pibp6VwDZmUGebhLN3akM0R19icNU6tCw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>