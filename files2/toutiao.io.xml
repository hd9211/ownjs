<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ad74e7676957b46695d55c75973fcfc1</guid>
<title>2021 年快结束了！抓紧啦！</title>
<link>https://toutiao.io/k/809c4m6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6e209f19dd533a04e188a9a902d0fdac</guid>
<title>我做系统架构的一些原则</title>
<link>https://toutiao.io/k/vlt0zc9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content&quot;&gt;
&lt;p&gt;&lt;img loading=&quot;lazy&quot; class=&quot;alignright size-full wp-image-21682&quot; src=&quot;https://coolshell.cn/wp-content/uploads/2021/12/bachelor-mechanical-eng-icon@72x.png&quot; alt=&quot;&quot; srcset=&quot;https://coolshell.cn/wp-content/uploads/2021/12/bachelor-mechanical-eng-icon@72x.png 250w, https://coolshell.cn/wp-content/uploads/2021/12/bachelor-mechanical-eng-icon@72x-150x150.png 150w&quot; sizes=&quot;(max-width: 250px) 100vw, 250px&quot;/&gt;工作 20 多年了，这 20 来年看到了很多公司系统架构，也看到了很多问题，在跟这些公司进行交流和讨论的时候，包括进行实施和方案比较的时候，都有很多各种方案的比较和妥协，因为相关的经历越来越多，所以，逐渐形成了自己的逻辑和方法论。今天，想写下这篇文章，把我的这些个人的经验和想法总结下来，希望能够让更多的人可以参考和借鉴，并能够做出更好的架构来。另外，我的这些思维方式和原则都针对于现有市面上众多不合理的架构和方案，所以，也算是一种“纠正”……（注意，这篇文章所说的这些架构上的原则，一般适用于相对比较复杂的业务，如果只是一些简单和访问量不大的应用，那么你可能会得出相反的结论）&lt;/p&gt;

&lt;h4&gt;&lt;span class=&quot;ez-toc-section&quot; id=&quot;%E5%8E%9F%E5%88%99%E4%B8%80%EF%BC%9A%E5%85%B3%E6%B3%A8%E4%BA%8E%E7%9C%9F%E6%AD%A3%E7%9A%84%E6%94%B6%E7%9B%8A%E8%80%8C%E4%B8%8D%E6%98%AF%E6%8A%80%E6%9C%AF%E6%9C%AC%E8%BA%AB&quot;/&gt;原则一：关注于真正的收益而不是技术本身&lt;span class=&quot;ez-toc-section-end&quot;/&gt;&lt;/h4&gt;
&lt;p&gt;对于软件架构来说，我觉得第一重要的是架构的收益，如果不说收益，只是为了技术而技术，而没有任何意义。对于技术收益来说，我觉得下面这几个收益是非常重要的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;是否可以降低技术门槛加快整个团队的开发流程&lt;/strong&gt;。能够加快整个团队的工程流程，快速发布，是软件工程一直在解决的问题，所以，系统架构需要能够进行并行开发，并行上线和并行运维，而不会让某个团队成为瓶颈点。（注：就算拖累团队的原因是组织构架，也不妨碍我们做出并行的系统架构设计）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;是否可以让整个系统可以运行的更稳定&lt;/strong&gt;。要让整个系统可以运行的更为的稳定，提升整个系统的 SLA，就需要对有计划和无计划的停机做相应的解决方案（参看《&lt;a title=&quot;关于高可用的系统&quot; href=&quot;https://coolshell.cn/articles/17459.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;关于高可用的架构&lt;/a&gt;》）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;是否可以通过简化和自动化降低成本&lt;/strong&gt;。最高优化的成本是人力成本，人的成本除了慢和贵，还有经常不断的 human error。如果不能降低人力成本，反而需要更多的人，那么这个架构设计一定是失败的。除此之外，是时间成本，资金成本。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果一个系统架构不能在上面三个事上起到作用，那就没有意义了。&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;more-21672&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span class=&quot;ez-toc-section&quot; id=&quot;%E5%8E%9F%E5%88%99%E4%BA%8C%EF%BC%9A%E4%BB%A5%E5%BA%94%E7%94%A8%E6%9C%8D%E5%8A%A1%E5%92%8C_API_%E4%B8%BA%E8%A7%86%E8%A7%92%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E4%BB%A5%E8%B5%84%E6%BA%90%E5%92%8C%E6%8A%80%E6%9C%AF%E4%B8%BA%E8%A7%86%E8%A7%92&quot;/&gt;原则二：以应用服务和 API 为视角，而不是以资源和技术为视角&lt;span class=&quot;ez-toc-section-end&quot;/&gt;&lt;/h4&gt;
&lt;p&gt;国内很多公司都会有很多分工，基本上都会分成运维和开发，运维又会分成基础运维和应用运维，开发则会分成基础核心开发和业务开发。不同的分工会导致完全不同的视角和出发点。比如，基础运维和开发的同学更多的只是关注资源的利用率和性能，而应用运维和业务开发则更多关注的是应用和服务上的东西。这两者本来相关无事，但是因为分布式架构的演进，导致有一些系统已经说不清楚是基础层的还是应用层的了，比如像服务治理上的东西，里面即有底层基础技术，也需要业务的同学来配合，包括 k8s 也样，里面即有底层的如网络这样的技术，也有需要业务配合的 readniess和 liveness 这样的健康检查，以及业务应用需要 configMap 等等 ……&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这些东西都让我感觉到所谓 DevOps，其实就是因为很多技术和组件已经分不清是 Dev 还是 Ops 的了，所以，需要合并 Dev和 Ops&lt;/strong&gt;。而且，整个组织和架构的优化，已经不能通过调优单一分工或是单一组件能够有很大提升的了。其需要有一种自顶向下的，整体规划，统一设计的方式，才能做到整体的提升（可以试想一下城市交通的优化，当城市规模到一定程度的时候，整体的性能你是无法通过优化几条路或是几条街区来完成的，你需要对整个城市做整体的功能体的规划才可能达到整体效率的提升）。而为了做到整体的提升，需要所有的人都要有一个统一的视角和目标，这几年来，我觉得这个目标就是——&lt;strong&gt;要站在服务和 对外API的视角来看问题，而不是技术和底层的角度。&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span class=&quot;ez-toc-section&quot; id=&quot;%E5%8E%9F%E5%88%99%E4%B8%89%EF%BC%9A%E9%80%89%E6%8B%A9%E6%9C%80%E4%B8%BB%E6%B5%81%E5%92%8C%E6%88%90%E7%86%9F%E7%9A%84%E6%8A%80%E6%9C%AF&quot;/&gt;原则三：选择最主流和成熟的技术&lt;span class=&quot;ez-toc-section-end&quot;/&gt;&lt;/h4&gt;
&lt;p&gt;技术选型是一件很重要的事，技术一旦选错，那会导致整个架构需要做调整，而对架构的调整重来都不是一件简单的事，我在过去几年内，当系统越来越复杂的时候，用户把他们的  PHP，Python, .NET，或 Node.js 的架构完全都迁移到 Java + Go 的架构上来的案例不断的发生。这个过程还是非常痛苦的，但是你没有办法，当你的系统越来越复杂，越来越大时，你就再也不能在一些玩具技术上玩了，你需要的更为工业化的技术。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;尽可能的使用更为成熟更为工业化的技术栈，而不是自己熟悉的技术栈&lt;/strong&gt;。所谓工业化的技术栈，你可以看看大多数公司使用的技术栈，比如：互联网，金融，电信……等等 ，大公司会有更多的技术投入，也需要更大规模的生产，所以，他们使用的技术通常来说都是比较工业化的。在技术选型上，千万不要被——“你看某个公司也在用这个技术”，或是一些在论坛上看到的一些程序员吐槽技术的观点（没有任何的数据，只有自己的喜好）来决定自己的技术，还是看看主流大多数公司实际在用的技术栈，会更靠谱一些。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;选择全球流行的技术，而不是中国流行的技术&lt;/strong&gt;。技术这个东西一定是一个全球化的东西，不是一个局域化的事。所以，一定要选国际化的会更好。另外，千万不要被某些公司的“特别案例”骗过去了，那怕这个案例很性感，关键还是要看解决问题的思路和采用的技术是否具有普世性。只有普世性的技术有更强的生命力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;尽可能的使用红利大的主流技术，而不要自己发明轮子，更不要魔改&lt;/strong&gt;。我见过好些个公司魔改开源软件，比如有个公司同魔改mesos，最后改着改着发现自己发明另一个 kubernetes。我还见过很多公司或技术团队喜欢自己发明自己的专用轮子，最后都会被主流开源软件所取代。完全没有必要。不重新发明轮子，不魔改，不是因为自己技术不能，而是因为，这个世界早已不是自己干所有事的年代了，这个时代是要想尽方法跟整个产业，整个技术社区融合和合作，这样才会有最大的收益。那些试图因为某个特例需要自成一套的玩法，短期没问题，但长期来说，我都不看好。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;绝大多数情况下，如无非常特殊要求，选 Java基本是不会错的&lt;/strong&gt;。一方面，这是因为 Java 的业务开发的生产力是非常好的，而且有 Spring 框架保障，代码很难写烂，另外，Java 的社区太成熟了，你需要的各种架构和技术都可以很容易获得，技术红利实在是太大。这种运行在JVM上的语言有太多太多的好处了。在 Java 的技术栈上，你的架构风险和架构的成本（无论是人力成本，时间成本和资金成本）从长期来说都是最优的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在我见过的公司中，好些公司的架构都被技术负责人个人的喜好、擅长和个人经验给绑架了，完全不是从一个客观的角度来进行技术选型。其实，从 0 到 1 的阶段，你用什么样的技术都行，如果你做一个简单的应用，没有事务处理没有复杂的交易流程，比如一些论坛、社交之类的应用，你用任何语言都行。但是如果有一天你的系统变复杂了，需要处理交易了，量也上来了，从 1 到 10，甚至从 10 到 100，你的开发团队也变大了，需要构建的系统越来越大，你可能会发现你只有一个选择，就是 Java。想想京东从.NET 到 Java，淘宝从 PHP 到 Java……&lt;/p&gt;
&lt;h4&gt;&lt;span class=&quot;ez-toc-section&quot; id=&quot;%E5%8E%9F%E5%88%99%E5%9B%9B%EF%BC%9A%E5%AE%8C%E5%A4%87%E6%80%A7%E4%BC%9A%E6%AF%94%E6%80%A7%E8%83%BD%E6%9B%B4%E9%87%8D%E8%A6%81&quot;/&gt;原则四：完备性会比性能更重要&lt;span class=&quot;ez-toc-section-end&quot;/&gt;&lt;/h4&gt;
&lt;p&gt;我发现好些公司的架构师做架构的时候，首要考虑的是架构的性能是否能够撑得住多大多大的流量，而不是考虑系统的完备性和扩展性。所以，我已经多次见过这样的案例了，一开始直接使用 MongoDB 这样的非关系型数据库，或是把数据直接放在 Redis 里，而直接放弃关系型数据库的数据完备性的模型，而在后来需要在数据上进行关系查询的时候，发现 NoSQL 的数据库在 Join 上都表现的太差，然后就开始各种飞线，为了不做 Join 就开始冗余数据，然而自己又维护不好冗余数据后带来的数据一致性的问题，导致数据上的各种错乱丢失。&lt;/p&gt;
&lt;p&gt;所以，我给如下的一些如下的架构原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用最科学严谨的技术模型为主，并以不严谨的模型作为补充&lt;/strong&gt;。对于上面那个案例来说，就是——永远使用完备支持 ACID 的关系型数据库，然后用 NoSQL 作补充，而不是完全放弃关系型数据库。这里的原则就是所谓的“先紧后松”，一开始紧了，你可以慢慢松，但是开始松了，以后你想紧再也紧不过来了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能上的东西，总是有很多解的&lt;/strong&gt;。我这么多年的经历告诉我，性能上的事，总是有解的，手段也是最多的，这个比起架构的完备性和扩展性来说真的不必太过担心。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了追求所谓的性能，把整个系统的完备性丢失掉，相当地得不偿失。&lt;/p&gt;
&lt;h4&gt;&lt;span class=&quot;ez-toc-section&quot; id=&quot;%E5%8E%9F%E5%88%99%E4%BA%94%EF%BC%9A%E5%88%B6%E5%AE%9A%E5%B9%B6%E9%81%B5%E5%BE%AA%E6%9C%8D%E4%BB%8E%E6%A0%87%E5%87%86%E3%80%81%E8%A7%84%E8%8C%83%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5&quot;/&gt;原则五：制定并遵循服从标准、规范和最佳实践&lt;span class=&quot;ez-toc-section-end&quot;/&gt;&lt;/h4&gt;
&lt;p&gt;这个原则是非常重要的，因为只有服从了标准，你的架构才能够有更好的扩展性。比如：我经常性的见到很多公司的系统既没有服从业界标准，也没有形成自己公司的标准，感觉就像一群乌合之众一样。最典型的例子就是 HTTP 调用的状态返回码。业内给你的标准是 200表示成功，3xx 跳转，4xx 表示调用端出错，5xx 表示服务端出错，我实在是不明白为什么无论成功和失败大家都喜欢返回 200，然后在 body 里指出是否error（前两年我在微信公众号里看到一个有一定名气的互联网老兵推荐使用无论正确还是出错都返回 200 的做法，我在后台再三确认后，我发现这样的架构师真是害人不浅）。这样做最大的问题是——监控系统将在一种低效的状态下工作。监控系统需要把所有的网络请求包打开后才知道是否是错误，而且完全不知道是调用端出错还是服务端出错，于是一些像重试或熔断这样的控制系统完全不知道怎么搞（如果是 4xx错，那么重试或熔断是没有意义的，只有 5xx 才有意义）。&lt;strong&gt;有时候，我会有种越活越退步的感觉，错误码设计这种最基本最基础的东西为什么会没有？并且一个公司会任由着大家乱来？这些基础技能怎么就这样丢掉了？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;还有，我还见过一些公司，他们整个组织没有一个统一的用户 ID 的设计，各个系统之间同步用户的数据是通过用户的身份证 ID，是的，就是现实世界的身份证 ID，包括在网关上设置的用户白名单居然也是用身份证 ID。我对这个公司的内的用户隐私管理有很大的担忧。一个企业，一个组织，如果没有标准和规范，也就会有抽象，这一定是要出各种乱子的。&lt;/p&gt;
&lt;p&gt;下面，我罗列一些你需要注意的标准和规范（包括但不限于）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;服务间调用的协议标准和规范&lt;/strong&gt;。这其中包括 Restful API路径, HTTP 方法、状态码、标准头、自定义头等，返回数据 JSon Scheme……等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一些命名的标准和规范&lt;/strong&gt;。这其中包括如：用户 ID，服务名、标签名、状态名、错误码、消息、数据库……等等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;日志和监控的规范&lt;/strong&gt;。这其中包括：日志格式，监控数据，采样要求，报警……等等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;配置上的规范&lt;/strong&gt;。这其中包括：操作系统配置、中间件配置，软件包……等等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中间件使用的规范&lt;/strong&gt;。数据库，缓存、消息队列……等等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;软件和开发库版本统一&lt;/strong&gt;。整个组织架构内，软件或开发库的版本最好每年都升一次级，然后在各团队内统一。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里重要说一下两个事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Restful API 的规范&lt;/strong&gt;。我觉得是非常重要的，这里给两个我觉得写得最好的参考：&lt;a href=&quot;https://github.com/paypal/api-standards/blob/master/api-style-guide.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Paypal&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/microsoft/api-guidelines&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Microsoft&lt;/a&gt; 。Restful API 有一个标准和规范最大的好处就是监视可以很容易地做各种统计分析，控制系统可以很容易的做流量编排和调度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;另一个是服务调用链追踪&lt;/strong&gt;。对于服务调用链追踪来说，基本上都是参考于 &lt;a href=&quot;https://research.google/pubs/pub36356/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google Dapper&lt;/a&gt; 这篇论文，目前有很多的实现，最严格的实现是 &lt;a href=&quot;https://zipkin.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Zipkin&lt;/a&gt;，这也是 Spring Cloud Sleuth 的底层实现。Zipkin 贴近 Google Dapper 论文的好处在于——无状态，快速地把 Span 发出来，不消耗服务应用侧的内存和 CPU。这意味着，监控系统宁可自己死了也不能干扰实际应用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;软件升级&lt;/strong&gt;。我发现很多公司包括 BAT，他们完全没有软件升级的活动，全靠开发人员自发。然而，这种成体系的活动，是永远不可能靠大众的自发形成的。一个公司至少一年要有一次软件版本升级的review，然后形成软件版本的统一和一致，这样会极太简化系统架构的复杂度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;span class=&quot;ez-toc-section&quot; id=&quot;%E5%8E%9F%E5%88%99%E5%85%AD%EF%BC%9A%E9%87%8D%E8%A7%86%E6%9E%B6%E6%9E%84%E6%89%A9%E5%B1%95%E6%80%A7%E5%92%8C%E5%8F%AF%E8%BF%90%E7%BB%B4%E6%80%A7&quot;/&gt;原则六：重视架构扩展性和可运维性&lt;span class=&quot;ez-toc-section-end&quot;/&gt;&lt;/h4&gt;
&lt;p&gt;在我见过很多架构里，技术人员只考虑当下，但从来不考虑系统的未来扩展性和可运维性。所谓的管生不管养。如果你生下来的孩子胳膊少腿，严重畸形，那么未来是很难玩的。因为架构不是和软件不是写好就完的，是需要不断修改不断维护的，80%的软件成本都是在维护上。所以，如何让你的架构有更好的扩展性，可以更容易地运维，这个是比较重要的。所谓的扩展性，意味着，我可以很容易地加更多的功能，或是加入更多的系统，而所谓可运维，就是说我可以对线上的系统做任意的变更。扩展性要求的是有标准规范且不耦合的业务架构，可运维性要求的则是可控的能力，也就是一组各式各样的控制系统。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;通过服务编排架构来降低服务间的耦合&lt;/strong&gt;。比如：通过一个业务流程的专用服务，或是像 Workflow，Event Driven Architecture ， Broker，Gateway，Service Discovery 等这类的的中间件来降低服务间的依赖关系。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;通过服务发现或服务网关来降低服务依赖所带来的运维复杂度&lt;/strong&gt;。服务发现可以很好的降低相关依赖服务的运维复杂度，让你可以很轻松的上线或下线服务，或是进行服务伸缩。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;一定要使用各种软件设计的原则&lt;/strong&gt;。比如：像SOLID这样的原则（参看《&lt;a title=&quot;一些软件设计的原则&quot; href=&quot;https://coolshell.cn/articles/4535.html&quot;&gt;一些软件设计的原则&lt;/a&gt;》），IoC/DIP，SOA 或 Spring Cloud 等 架构的最佳实践（参看《&lt;a title=&quot;SteveY对Amazon和Google平台的吐槽 - 67,710 人阅读&quot; href=&quot;https://coolshell.cn/articles/5701.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SteveY对Amazon和Google平台的吐槽&lt;/a&gt;》中的 Service Interface 的那几条军规），分布式系统架构的相关实践（参看：《&lt;a title=&quot;分布式系统的事务处理&quot; href=&quot;https://coolshell.cn/articles/10910.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;分布式系统的事务处理&lt;/a&gt;》，或微软件的 《&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/architecture/patterns/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Cloud Design Patterns&lt;/a&gt;》）……等等&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;span class=&quot;ez-toc-section&quot; id=&quot;%E5%8E%9F%E5%88%99%E4%B8%83%EF%BC%9A%E5%AF%B9%E6%8E%A7%E5%88%B6%E9%80%BB%E8%BE%91%E8%BF%9B%E8%A1%8C%E5%85%A8%E9%9D%A2%E6%94%B6%E5%8F%A3&quot;/&gt;原则七：对控制逻辑进行全面收口&lt;span class=&quot;ez-toc-section-end&quot;/&gt;&lt;/h4&gt;
&lt;p&gt;所有的程序都会有两种逻辑，一种是业务逻辑，一种是控制逻辑，业务逻辑就是完成业务的逻辑，控制逻辑是辅助，比如你用多线程，还是用分布式，是用数据库还是用文件，如何配置、部署，运维、监控，事务控制，服务发现，弹性伸缩，灰度发布，高并发，等等，等等 ……这些都是控制逻辑，跟业务逻辑没有一毛钱关系。控制逻辑的技术深度会通常会比业务逻辑要深一些，门槛也会要高一些，所以，最好要专业的程序员来负责控制逻辑的开发，统一规划统一管理，进行收口。这其中包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;流量收口&lt;/strong&gt;。包括南北向和东西向的流量的调度，主要通过流量网关，开发框架 SDK或 Service Mesh 这样的技术。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;服务治理收口&lt;/strong&gt;。包括：服务发现、健康检查，配置管理、事务、事件、重试、熔断、限流……主要通过开发框架 SDK – 如：Spring Cloud，或服务网格Service Mesh等技术。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;监控数据收口&lt;/strong&gt;。包括：日志、指标、调用链……主要通过一些标准主流的探针，再加上后台的数据清洗和数据存储来完成，最好是使用无侵入式的技术。监控的数据必须统一在一个地方进行关联，这样才会产生信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;资源调度有应用部署的收口&lt;/strong&gt;。包括：计算、网络和存储的收口，主要是通过容器化的方案，如k8s来完成。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中间件的收口&lt;/strong&gt;。包括：数据库，消息，缓存，服务发现，网关……等等。这类的收口方式一般要在企业内部统一建立一个共享的云化的中间件资源池。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对此，这里的原则是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;你要选择容易进行业务逻辑和控制逻辑分离的技术&lt;/strong&gt;。这里，Java 的 JVM+字节码注入+AOP 式的Spring 开发框架，会带给你太多的优势。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;你要选择可以享受“前人种树，后人乘凉”的有技术红利的技术&lt;/strong&gt;。如：有庞大社区而且相互兼容的技术，如：Java, Docker,  Ansible，HTTP，Telegraf/Collectd……&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中间件你要使用可以 支持HA集群和多租户的技术&lt;/strong&gt;。这里基本上所有的主流中间件都会支持 HA 集群方式的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;span class=&quot;ez-toc-section&quot; id=&quot;%E5%8E%9F%E5%88%99%E5%85%AB%EF%BC%9A%E4%B8%8D%E8%A6%81%E8%BF%81%E5%B0%B1%E8%80%81%E6%97%A7%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%8A%80%E6%9C%AF%E5%80%BA%E5%8A%A1&quot;/&gt;原则八：不要迁就老旧系统的技术债务&lt;span class=&quot;ez-toc-section-end&quot;/&gt;&lt;/h4&gt;
&lt;p&gt;我发现很多公司都很非常大的技术债务，这些债务具体表现如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用老旧的技术&lt;/strong&gt;。比如，使用HTTP1.0， Java 1.6，Websphere，ESB，基于 socket的通讯协议，过时的模型……等等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不合理的设计&lt;/strong&gt;。比如，在 gateway 中写大量的业务逻辑，单体架构，数据和业务逻辑深度耦合，错误的系统架构（把缓存当数据库，用消息队列同步数据）……等等&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;缺少配套设施&lt;/strong&gt;。比如，没有自动化测试，没有好的软件文档，没有质量好的代码，没有标准和规范……等等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来找我寻求技术帮助的人都有各种各样的问题。我都会对他们苦口婆心地说同样的一句话——“&lt;strong&gt;如果你是来找我 case-by-case 解决问题，我兴趣不大，因为，你们千万不要寄希望能够很简单的把一辆夏利车改成一辆法拉利跑车，或是把一栋地基没打好的歪楼搞正。以前欠下的技术债，都得要还，没打好的地基要重新打，没建配套设施都要建。这些基础设施如果不按照正确科学的方式建立的话，你是不可能有一个好的的系统，我也没办法帮你 case-by-case 的解决问题……&lt;/strong&gt;”，一开始，他们都会对我说，没问题，我们就是要还债，但是，最后发现要还的债真多，有点承受不了，就开始现原形了。&lt;/p&gt;
&lt;p&gt;他们开始为自己的“欠的技术债”找各种合理化的理由——给你解释各种各样的历史原因和不得以而为之的理由。谈着谈着，让我有一种感觉——他们希望得到一种什么都不改什么都不付出的方式就可以进步的心态，他们宁可让新的技术 low 下来迁就于这些技术债，把新的技术滥用地乱七八糟的。有一个公司，他们的系统架构和技术选型基本都搞错了，使用错误的模型构建系统，导致整个系统的性能非常之差，也才几千万条数据，但他们想的不是还债，不是把地基和配套设施建好，而且要把楼修的更高，上更多的系统——他们觉得现有的系统挺好，性能问题的原因是他们没一个大数据平台，所以要建大数据平台……&lt;/p&gt;
&lt;p&gt;我见过很多很多公司，包括大如 BAT 这样的公司，都会在原来的技术债上进行更多的建设，然后，技术债越来越大，利息越来越大，最终成为一个高利贷，再也还不了（我在《&lt;a href=&quot;https://coolshell.cn/articles/11656.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;开发团队的效率&lt;/a&gt;》一文中讲过一个 WatchDog 的架构模式，一个系统烂了，不是去改这个系统，而是在旁边建一个系统来看着它，我很难理解为什么会有这样的逻辑，也许是为了要解决更多的就业……）&lt;/p&gt;
&lt;p&gt;这里有几个原则和方法我是非常坚持的，分享给大家：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;与其花大力气迁就技术债务，不如直接还技术债。是所谓的长痛不如短痛。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;建设没有技术债的“新城区”，并通过“&lt;a href=&quot;https://docs.microsoft.com/en-us/azure/architecture/patterns/anti-corruption-layer&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;防腐层&lt;/a&gt; ”的架构模型，不要让技术债侵入“新城区”&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;&lt;span class=&quot;ez-toc-section&quot; id=&quot;%E5%8E%9F%E5%88%99%E4%B9%9D%EF%BC%9A%E4%B8%8D%E8%A6%81%E4%BE%9D%E8%B5%96%E8%87%AA%E5%B7%B1%E7%9A%84%E7%BB%8F%E9%AA%8C%EF%BC%8C%E8%A6%81%E4%BE%9D%E8%B5%96%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%92%8C%E5%AD%A6%E4%B9%A0&quot;/&gt;原则九：不要依赖自己的经验，要依赖于数据和学习&lt;span class=&quot;ez-toc-section-end&quot;/&gt;&lt;/h4&gt;
&lt;p&gt;有好些人来找我跟我说他们的技术问题，然后希望我能够给他们一个答案。我说，我需要了解一下你现有系统的情况，也就是需要先做个诊断，我只有得到这些数据后，我才可能明白真正的原因是什么 ，我才可能给你做出一个比较好的技术方案。我个人觉得这是一种对对方负责的方法，因为技术手段太多了，所有的技术手段都有适应的场景，并且有各种 trade-off，所以，只有调研完后才能做出决定。这跟医生看病是一样的，确诊病因不能靠经验，还是要靠诊断数据。在科学面前，所有的经验都是靠不住的……&lt;/p&gt;
&lt;p&gt;另外，如果有一天你在做技术决定的时候，开始凭自己以往的经验，那么你就已经不可能再成长了。人都是不可能通过不断重复过去而进步的，人的进步从来都是通过学习自己不知道的东西。所以，千万不要依赖于自己的经验做决定。做任何决定之前，最好花上一点时间，上网查一下相关的资料，技术博客，文章，论文等 ，同时，也看看各个公司，或是各个开源软件他们是怎么做的？然后，比较多种方案的 Pros/Cons，最终形成自己的决定，这样，才可能做出一个更好的决定。&lt;/p&gt;
&lt;h4&gt;&lt;span class=&quot;ez-toc-section&quot; id=&quot;%E5%8E%9F%E5%88%99%E5%8D%81%EF%BC%9A%E5%8D%83%E4%B8%87%E8%A6%81%E5%B0%8F%E5%BF%83_X_-_Y_%E9%97%AE%E9%A2%98%EF%BC%8C%E8%A6%81%E8%BF%BD%E9%97%AE%E5%8E%9F%E5%A7%8B%E9%9C%80%E6%B1%82&quot;/&gt;原则十：千万要小心 X – Y 问题，要追问原始需求&lt;span class=&quot;ez-toc-section-end&quot;/&gt;&lt;/h4&gt;
&lt;p&gt;对于 &lt;a title=&quot;X-Y Problem&quot; href=&quot;https://coolshell.cn/articles/10804.html&quot;&gt;X-Y 问题&lt;/a&gt;，也就是说，用户为了解决 X问题，他觉得用 Y 可以解，于是问我 Y 怎么搞，结果搞到最后，发现原来要解决的 X 问题，这个时候最好的解决方案不是 Y，而是 Z。 这种 X-Y 问题真是相当之多，见的太多太多了。所以，每次用户来找我的时候，我都要不断地追问什么是 X 问题。&lt;/p&gt;
&lt;p&gt;比如，好些用户都会来问我他们要一个大数据流式处理，结果追问具体要解决什么样的问题时，才发现他们的问题是因为服务中有大量的状态，需要把相同用户的数据请求放在同一个服务上处理，而且设计上导致一个慢函数拖慢整个应用服务。最终就是做一下性能调优就好了，根本没有必要上什么大数据的流式处理。&lt;/p&gt;
&lt;p&gt;我很喜欢追问为什么 ，这种追问，会让客户也跟着来一起重新思考。比如，有个客户来找我评估的一个技术架构的决定，从理论上来说，好像这个架构在用户的这个场景下非常不错。但是，这个场景和这个架构是我职业生涯从来没有见过的。于是，我开始追问这个为什么会是这么一个场景？当我追问的时候，我发现用户都感到这个场景的各种不合理。最后引起了大家非常深刻的研讨，最终用户把那个场景修正后，而架构就突然就变成了一个常见且成熟的的模型……&lt;/p&gt;
&lt;h4&gt;&lt;span class=&quot;ez-toc-section&quot; id=&quot;%E5%8E%9F%E5%88%99%E5%8D%81%E4%B8%80%EF%BC%9A%E6%BF%80%E8%BF%9B%E8%83%9C%E4%BA%8E%E4%BF%9D%E5%AE%88%EF%BC%8C%E5%88%9B%E6%96%B0%E4%B8%8E%E5%AE%9E%E7%94%A8%E5%B9%B6%E4%B8%8D%E5%86%B2%E7%AA%81&quot;/&gt;原则十一：激进胜于保守，创新与实用并不冲突&lt;span class=&quot;ez-toc-section-end&quot;/&gt;&lt;/h4&gt;
&lt;p&gt;我对技术的态度是比较激进的，但是，所谓的激进并不是瞎搞，也不是见新技术就上，而是积极拥抱会改变未来的新技术，如：Docker/Go，我就非常快地跟进，但是像区块链或是 Rust 这样的，我就不是很积极。因为，其并没有命中我认为的技术趋势的几个特征（参看《&lt;a title=&quot;Go语言、Docker 和新技术&quot; href=&quot;https://coolshell.cn/articles/18190.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Go,Docker 和新技术&lt;/a&gt; 》）。当然，我也不是不喜欢的就不学了，我对区块链和 Rust 我一样学习，我也知道这些技术的优势，但我不会大规模使用它们。另外，我也尊重保守的决定，这里面没有对和错。但是，我个人觉得对技术激进的态度比起保守来说有太多的好处了。一方面来说，对于用户来说，很大程度上来说，新技术通常都表面有很好的竞争力，而且我见太多这样成功的公司都在积极拥抱新的技术的，而保守的通常来说都越来越不好。&lt;/p&gt;
&lt;p&gt;有一些人会跟我说，我们是实用主义，我们不需要创新，能解决当下的问题就好，所以，我们不需要新技术，现有的技术用好就行了。这类的公司，他们的技术设计第一天就在负债，虽然可以解决当下问题，但是马上就会出现新的问题，然后他们会疲于解决各种问题。最后呢，最后还是会走到新的技术上。&lt;/p&gt;
&lt;p&gt;这里的逻辑很简单 —— &lt;strong&gt;进步永远来自于探索，探索是要付出代价的，但是收益更大&lt;/strong&gt;。对我而言，不敢冒险才是最大的冒险，不敢犯错才是最大的错误，害怕失去会让你失去的更多……&lt;/p&gt;
&lt;p&gt;（全文完）&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://coolshell.cn/wp-content/uploads/2020/03/coolshell.weixin.jpg&quot;/&gt; &lt;img loading=&quot;lazy&quot; src=&quot;https://coolshell.cn/wp-content/uploads/2020/03/coolshell.mini_.jpg&quot;/&gt; &lt;br/&gt;关注CoolShell微信公众账号和微信小程序&lt;/p&gt;



&lt;div id=&quot;post-ratings-21672-loading&quot; class=&quot;post-ratings-loading&quot;&gt;&lt;img src=&quot;https://coolshell.cn/wp-content/plugins/wp-postratings/images/loading.gif&quot; class=&quot;post-ratings-image&quot;/&gt;&lt;p&gt;Loading...&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e45044fef6a469d6c7e0bf1d2f1c7677</guid>
<title>应用程序怎样划分模块？</title>
<link>https://toutiao.io/k/vbj8o6g</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;在做一个新项目，架构和功能很简单。大家讨论的时候对应用程序的模块划分都有自己的一些看法。需要的下面两个模块大家没有分歧，分别是core模块和web1模块、web2模块，因为最后对外会提供两个独立的web应用。这两个应用针对不同的业务，实现也稍有不同。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个架构整体是一个模板模式的，有通用的实现，还有一些接口需要web1和web2各自实现，还会涉及一个工具类。主要的分歧有：&lt;/p&gt;&lt;p&gt;1&amp;gt;工具类要不要提取一个专门的commons模块&lt;/p&gt;&lt;p&gt;2&amp;gt;流程模板放在core里没有异议，那针对需要各自实现的接口要不要单独提取一个模块。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;大家都表示最后怎么划分都支持，不会强烈坚持自己的观点，因为实际上对后续开发维护的影响不是很大。我决定用周末的时候把这个问题想明白，因为划分问题除了实用角度，更多是一个专业性的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我之前写过一篇文章&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247484076&amp;amp;idx=1&amp;amp;sn=0c2b291a31ed53e9c8af06d131aabdd4&amp;amp;chksm=fafde802cd8a6114430a5c1eb8609481059341089ba2c4113012764578152570b6149780e3d5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《你们项目的核心战略是什么》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《&lt;span&gt;你们项目的核心战略是什么&lt;/span&gt;&lt;span&gt;》&lt;/span&gt;&lt;/a&gt;里有提到模块划分：按照之前项目标配是划分了commons模块的，但是在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485258&amp;amp;idx=1&amp;amp;sn=52a6a62d85e2e1caafcf0a1de46a4860&amp;amp;chksm=fafdede4cd8a64f21effe09d23efe7adc8d226eb021801a4dcb8f2fb02e2065577eb87bc1474&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《关于Java两点需要更新的知识》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《关于Java两点需要更新的知识》&lt;/a&gt;里我也提到，知识是要常常反思并进行更新的。没有调研，不要盖棺定论。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;思路是采用登高类比法进行业界调研得出结论登高类比法是先检索最为相似的场景以得出结论。如果检索结果不够时再扩大范围直到足以得出结论。比如设计一个IP分配方法，检索时先检索IP分配，在网上比较权威的大概只有DHCP动态主机配置了。但是我们需要的不是动态，可以退而检索资源分配。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;工具类要不要提取一个专门的commons模块&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;自己不知道怎么做好的时候，就看好的是怎么做的。首先调研了一下spring。极简标配：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;${spring.boot.version}&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;${spring.boot.version}&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;/&lt;span class=&quot;code-snippet__name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;项目引入了上面两个maven坐标，看对应的spring包都引入了什么：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5110410094637224&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicaj3NoVtl5MyZZIr39JD2AbU2NHxA0MlrYYibSUTAkQDMB8RSax32jueMEMic4QfWEg7mCVHFR5LJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;634&quot;/&gt;&lt;/p&gt;&lt;p&gt;这里包含了spring-core和spring-web，spring并没有spring-commons模块，大家常用的都是&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486291&amp;amp;idx=1&amp;amp;sn=c6a52233e35571c6531bbef005139981&amp;amp;chksm=fafde1fdcd8a68ebf2e6c1f3edc53cff7c8a622dd8520d2e98cf9b99976e29096a3bd9d79604&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;apache-commons或者hutool&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;apache-commons或者hutool&lt;/a&gt;这种专业的工具包。那针对业务上通过的工具像spring这种大拿级别都是怎么来处理的呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;来看spring-core的目录结构&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5591397849462365&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicaj3NoVtl5MyZZIr39JD2Aw4TZT1oMkwBJ2fkz9YsLJsIaVNY5kPWPbY1ibwLgbV8ZjoFyNicKToXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;558&quot;/&gt;&lt;/p&gt;&lt;p&gt;工具在util下面。这里注意是util而不是utils单数。这个地方命名风格部分有规约：&lt;/p&gt;&lt;h1&gt;阿里巴巴Java开发手册&lt;/h1&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用 单数形式，但是类名如果有复数含义，类名可以使用复数形式。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;正例:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;应用工具类包名为&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;com&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.alibaba&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.open&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.util&lt;/span&gt;、类名为&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;MessageUtils&lt;/span&gt;(此规则参考 &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;spring&lt;/span&gt; 的框架结构)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;【强制】杜绝完全不规范的缩写，避免望文不知义。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;反例:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;AbstractClass&lt;/span&gt;“缩写”命名成 &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;AbsClass&lt;/span&gt;;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;condition&lt;/span&gt;“缩写”命名成 &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;condi&lt;/span&gt;，此类随 意缩写严重降低了代码的可阅读性。&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;各自实现的接口要不要单独提取一个模块&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;模板架构我想了一下，比较合适的参考是mybatis-plus。这是一个mybatis的增强工具。使用这个工具，每个Mapper都需要继承BaseMapper。它的位置是：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.180385288966725&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicaj3NoVtl5MyZZIr39JD2Af6u2ePIuZa3rvChJXlozYicMCfYHe1vB2MhFfnL6DnefRzs5AQ0tzsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;571&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其实我还调研了其他一些框架，结论就是放到core模块下。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;自己不知道怎么做好的时候，就看好的是怎么做的。&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8a9b14e89ff5457ea9bf0dbf6266d587</guid>
<title>干货 | 中小型公司的Devops 落地建议</title>
<link>https://toutiao.io/k/lhil5c5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;       &lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;63&quot; data-backw=&quot;28&quot; data-ratio=&quot;2.246376811594203&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/y84wDDf8g0jIGp7P4ZpKTmyErTeGmgcAm3AjmnEhCqBUeSlER8WazBLTX4dtysqA842hzgciaJfGJBiaBHIyTnVw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;138&quot;/&gt;
        &lt;/span&gt;&lt;span&gt;引言&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;span&gt;一说起Devops ，人们就会想到jenkins，想到cicd，但是你要问谁家真的做到了Devops，可能真没有几家。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    接触过很多公司，不论是从面试还是做技术交流，你会发现，大家讲的devops理解的都不同，因为不同的业务场景，技术架构，开发习惯，造就了不同的理解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    市场上甚至很多人认为Devops 不就是运维开发吗，你从招聘信息上看列出的需求看他就是在招一个开发运维平台又懂运维的运维工程师，是不是有点绕，其实这就是大多数公司的需求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    百度一下Devops的含义 字面上的意思大多都很虚，有很多概念性的东西，说的很高大上，似乎与现实场景不搭边，再谈到落地的话更是人云亦云，理解都比较片面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    Devops 是一种理念一种文化，不是什么新的技术，而且随着技术的不断发展，devops也有着自己应有的使命。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    中小公司应该本着自己的需求，考虑自己的业务场景，要实现的目标来规划，如降本增效，而不是跟风造轮子，开发一堆运维平台，pass平台……可能换一个领导就换一个平台，到底解决了哪些痛点，提高了哪些效率，他们并不考虑，只是在不断的重构内卷。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    技术不论吹得多么美好，不能解决实际问题也没有价值。Devops 从诞生以来无非就是用来解决持续集成，持续交付，通过快速迭代开发来适应互联网产品变化的快速交付。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    说到Devops 不得不说敏捷，敏捷管理是实施Devops的关键，所以很多大公司在落地时会引入敏捷教练，先从开发那块改变，才能慢慢让团队都接受Devops文化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;    市面上开源的Devops 的工具非常多，怎么整合来适应你的环境和业务才是最重要的，&lt;/span&gt;&lt;span&gt;要建设Devops ，其实要明白一点就是你到底要实现什么功能和价值，想明白了再上，不然后续肯定会遇到各种各样的问题，如开发和运维的责任分工不清，互相扯皮，本应该是两个协作的团队，到头来研发推给运维，让运维自己去建，运维埋怨研发，说各种配置命名不清楚不规范，代码提交混乱，权限管理混乱，代码框架扫出一堆漏洞，导致很大的安全风险，再就是构建时间长，本该几分钟就交付的，居然编译构建了半个小时，代码上线后一直在不停的重启，cpu，内存打满等等。。。。诸如此类，下面就这些问题说说我的看法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;
        &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15384615384615385&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/y84wDDf8g0jIGp7P4ZpKTmyErTeGmgcAbzNfvVRI4X9hPn8LVsCE5aKBEZnuBsCDvJnysaPM8wiasy78JsQJ1iaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;494&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;  &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.246376811594203&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/y84wDDf8g0jIGp7P4ZpKTmyErTeGmgcAm3AjmnEhCqBUeSlER8WazBLTX4dtysqA842hzgciaJfGJBiaBHIyTnVw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;138&quot;/&gt;
        &lt;/span&gt;&lt;span&gt;关于内容&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;研发文化的规范&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;项目管理部分，如通过jira 等工具提高研发效率，控制过程质量QA,最终产出高效代码&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码分支规范，代码的生命周期管理，主干开发，还是什么，先把研发提交代码规范起来，然后是QA，有哪些分支，如开发分支，bugfix分支，特性开发的分支，生产分支等，如何提交，谁来&lt;span&gt;review&lt;/span&gt;，不同环境提交，合并分支的策略，质量如何控制，权限控制，安全是否提前介入&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;开发流程规范，如果编译错误是否能快速反馈给研发，整个闭环过程是否畅通，是否有监控加入，是否有完善的通知机制，与项目管理，质量管理相辅相成&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Pipeline 规范，考虑清楚整个持续集成的链路，都有哪些stage 阶段，哪些task&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Sql 版本变更规范，如何控制数据库更新版本，如何回滚&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;测试规范，引入哪些测试，自动化测试脚本，单元测试，集成测试，测试覆盖率&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;配置参数的规范化，如已拆成微服务，是否有统一的配置中心，按不同环境分开&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;命名规范，不论是代码仓库名，构建任务名，服务名，镜像名 tag等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;构建规范，不同的语言栈有不同的构建方式，也会有相应的构建工具，如私服，镜像仓库，代码仓库，提前建好，如何同步，提升效率&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;app 打包规范，基础镜像，安卓，苹果构建环境，如苹果需要mac 环境&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;交付物规范，如Java语言 ，war 包，jar包，zip 包等还是容器镜像image&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;部署环境规范，涉及哪些环境，测试，预发，生产，UAT 等，版本tag,是否有灰度环境，蓝绿环境等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;发布流程规范，由谁来操作生产，变更流程，审批流程，回退流程，故障突发预案等&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;运维侧的规范：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;环境，配置，备份迁移恢复，可观测监控告警，高可用，资源成本，资源限制，弹性扩缩容，负载均衡，域名映射，证书，网络环境等&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;研发和运维协作方面：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Devops 工具链涉及的task，pipline 怎么设计，如声明式还是脚本式，重复的代码是否可以拆成共享库，变量引入，打包编译的脚本等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;测试过程的引入，安全扫描的引入，通知机制的引入，监控的引入&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;代码打包编译，Dockerfile 的编写，基础镜像的引入，启动脚本，探活脚本&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;构建的基础环境，私服的建设(maven,npm，gradle等)，代码仓库，镜像仓库 habor，交付物仓库&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;环境的设计，部署环境的分类，如虚机，物理机，云ecs，k8s，docker等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;部署工具，如调用自动化部署工具(引入一套工具增加运维成本)ansible ，Terrtaform, &lt;/span&gt;&lt;span&gt;helm 包管理工具（控制版本与参数规范化)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;应用环境，测试环境，预发，UAT，生产等&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;测试环境，灰度，蓝绿，AB测试&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对外接口，负载均衡，应用网关，waf 等方式&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;网络模式，网络的流向，虚机到容器，容器到容器，外网访问等&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;
        &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1079429735234216&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/y84wDDf8g0jIGp7P4ZpKTmyErTeGmgcAKkwbswFnwvs4GIRcWaicru4eibgIr7EDnialsrBK74GUNdicrjlWBp9vJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;491&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;    说了这么多，真正落地的路漫漫修远兮，另外中小型公司可以快速搭建的Devops 体系可考虑的现成方案也很多，如果不怕费事，有人手，有运维，愿意折腾，可以&lt;/span&gt;&lt;span&gt;自己搭建Jenkins，gitlab等工具，当然维护成本也比较高，试错的概率也比较大。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;    如果怕费事，想快速上手，又不想招运维，可以直接买云厂商的服务，再者中小型公司基础环境上云的比较多，腾讯有codeding,阿里有云效，其实都差不多。&lt;/span&gt;&lt;span&gt;基本上都是在Jenkins 的基础上做了二次封装，加入了从代码管理生命周期的一整个链条，当然也有很多缺点，如定制性不够强，权限控制不能适应公司组织架构，优点呢上手比较快，一键发布，环境多样。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;    个人还是比较推崇gitops 的理念，Devops 如果不能做到快速交付，快速迭代，其实就失去了本质意义，&lt;/span&gt;&lt;span&gt;所以在推进公司的Devops 转型中，一定要想清楚目标，要达成什么目标，建设成什么样，有些公司为了控制权限，给领导有存在感，加入了各种各样复杂的审批流，不知道Devops 是为了提升效率还是降低效率，导致各种审批流程冗长复杂，失去了Devops 应有的意义。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;END&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d441d866ee5da7c0006e42c89660b07d</guid>
<title>看他就够了！一文带你全方面了解Apache Pulsar 延迟消息投递</title>
<link>https://toutiao.io/k/r2eynj9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                                    


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;56&quot; data-ratio=&quot;0.062037037037037036&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHVRXdlib6uFSXAGtIhnmSJfKSOibv1ESCPAOm4aydD55u05rIdZSnH1w5p6PCO6Gpz3icLzkjCWtJztw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1503268&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/dPkfGGYFSHXN9zzNy9ic0vpfTWhT860qOicRD03OMyWoTG5UJXz3B1NYVpdiaW0CmvEIuVMlMZCKuMJuEBkGZDxsw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;306&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;导语&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;Apache Pulsar 是一个多租户、高性能的服务间消息传输解决方案，支持多租户、低延时、读写分离、跨地域复制、快速扩容、灵活容错等特性。腾讯数据平台部 MQ 团队对 Pulsar 做了深入调研以及大量的性能和稳定性方面优化，目前已经在腾讯云消息队列 TDMQ 落地上线。本文主要介绍Pulsar延迟消息投递的实现，希望与大家一同交流。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7172996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXN9zzNy9ic0vpfTWhT860qOib757icGsNf1ibDZZPVPG1xJia1ibJvyOlE8JKqibFsrDmxyr78zZuvk0KfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;237&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;一、什么是延迟消息投递&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;延迟消息投递在MQ应用场景中十分普遍，它是指消息在发送到 MQ 服务端后并不会立马投递，而是根据消息中的属性延迟固定时间后才投递给消费者，一般分为定时消息和延迟消息两种：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前在业界，腾讯云的 CMQ 和阿里云的 RocketMQ 也都支持延迟消息投递：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;开源的 NSQ、RabbitMQ、ActiveMQ 和 Pulsar 也都内置了延迟消息的处理能力。虽然每个 MQ 项目的使用和实现方式不同，但核心实现思路都一样：&lt;strong&gt;Producer 将一个延迟消息发送到某个 Topic 中，Broker 将延迟消息放到临时存储进行暂存，延迟跟踪服务（Delayed Tracker Service）会检查消息是否到期，将到期的消息进行投递&lt;/strong&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.32634338138925295&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96XRBWQxSb1tueicMQbe2OibNqjdSXpokGvN1kZY6CMpOibZdreTXFKKt1UbfRPEOxbvib95er1osibIcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;763&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7172996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXN9zzNy9ic0vpfTWhT860qOib757icGsNf1ibDZZPVPG1xJia1ibJvyOlE8JKqibFsrDmxyr78zZuvk0KfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;237&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;二、延迟消息投递的使用场景&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;延迟消息投递是要暂缓对当前消息的处理，在未来的某个时间点再触发投递，实际的应用场景非常多，比如异常检测重试、订单超时取消、预约提醒等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;TDMQ 最近就有个使用 Pulsar 延迟消息的 Case：业务要对两套系统的日志消息进行关联，其中一套系统由于查询 Hbase 可能会超时或失败，需要将失败的关联任务在集群空闲的时候再次调度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7172996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXN9zzNy9ic0vpfTWhT860qOib757icGsNf1ibDZZPVPG1xJia1ibJvyOlE8JKqibFsrDmxyr78zZuvk0KfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;237&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;三、如何使用Pulsar延迟消息投递&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Pulsar 最早是在 2.4.0 引入了延迟消息投递的特性，在 Pulsar 中使用延迟消息，可以精确指定延迟投递的时间，有 deliverAfter 和 deliverAt 两种方式。其中 deliverAt 可以指定具体的时间戳；deliverAfter 可以指定在当前多长时间后执行。两种方式的本质是一样的，Client 会计算出时间戳送到 Broker。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. deliverAfter发送&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;producer.newMessage()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        .deliverAfter(long time, TimeUnit unit)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        .send();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. deliverAt发送&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;producer.newMessage()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        .deliverAt(long timestamp)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        .send();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 Pulsar 中，可以支持跨度很大的延时消息，比方说一个月、半年；同时在一个 Topic 里，既支持延时消息，也支持非延时消息。下图展示了 Pulsar 中延迟消息的具体过程：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.257201646090535&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96XRBWQxSb1tueicMQbe2OibNzTfUYUwHQxXfNF6Bbc6Ba5xR7piarfoMzB7hyv04Ext9iaYrtGichuPGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;486&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;producer 发送的 m1/m3/m4/m5 有不同的延迟时间，m2 是不需要延迟投递的正常消息，consumer 消费时会根据不同的延迟时间进行 ack。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7172996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXN9zzNy9ic0vpfTWhT860qOib757icGsNf1ibDZZPVPG1xJia1ibJvyOlE8JKqibFsrDmxyr78zZuvk0KfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;237&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;四、Pulsar延迟消息投递实现原理&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从上面的使用方式可以看出，Pulsar 支持的是秒级精度的延迟消息投递，不同于开源 RocketMQ 支持固定时间 level 的延迟。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;316&quot; data-ratio=&quot;0.6751152073732719&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe96XRBWQxSb1tueicMQbe2OibNsQYWDz5uN9licZFoJRiaibPiaQhheCohBkckXcGsjA12iclqXzILibL7gqTw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;868&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Pulsar 实现延迟消息投递的方式比较简单，所有延迟投递的消息会被 Delayed Message Tracker 记录对应的 index。index 是由 timestamp | LedgerID | EntryID 三部分组成，其中 LedgerID | EntryID 用于定位该消息，timestamp 除了记录需要投递的时间，还用于 delayed index 优先级队列排序。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Delayed Message Tracker 在堆外内存维护着一个 delayed index 优先级队列，根据延迟时间进行堆排序，延迟时间最短的会放在头上，时间越长越靠后。consumer 在消费时，会先去 Delayed Message Tracker 检查，是否有到期需要投递的消息，如果有到期的消息，则从 Tracker 中拿出对应的 index，找到对应的消息进行消费；如果没有到期的消息，则直接消费正常的消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果集群出现 Broker 宕机或者 topic 的 ownership 转移，Pulsar 会重建 delayed index 队列，来保证延迟投递的消息能够正常工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7172996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXN9zzNy9ic0vpfTWhT860qOib757icGsNf1ibDZZPVPG1xJia1ibJvyOlE8JKqibFsrDmxyr78zZuvk0KfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;237&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;五、Pulsar延迟消息投递面临的挑战&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从 Pulsar 的延迟消息投递实现原理可以看出，该方法简单高效，对 Pulsar 内核侵入性较小，可以支持到任意时间的延迟消息。但同时发现，Pulsar 的实现方案无法支持大规模使用延迟消息，主要有以下两个原因：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. delayed index队列受到内存限制&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一条延迟消息的 delayed index 由三个 long 组成，对于小规模的延迟消息来说，内存开销并不大。但由于 index 队列是 subscription 级别，对于 topic 的同一个 partition 来说，有多少个 subscription 就需要维护多少个 index 队列；同时，由于延迟消息越多、延迟的时间越长，index 队列内存占用也会更多。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2. delayed index队列重建时间开销&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面有提到，如果集群出现 Broker 宕机或者 topic 的 ownership 转移，Pulsar 会重建 delayed index 队列。对于跨度时间长的大规模延迟消息，重建时间可能会到小时级别。为了减小 delayed index 队列重建时间，虽然可以给 topic 分更多的 partition 提高重建的并发度，但没有彻底解决重建时间开销问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7172996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXN9zzNy9ic0vpfTWhT860qOib757icGsNf1ibDZZPVPG1xJia1ibJvyOlE8JKqibFsrDmxyr78zZuvk0KfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;237&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;六、Pulsar延迟消息投递未来工作&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Pulsar 目前的延迟消息投递方案简单高效，但处理大规模延迟消息时仍然存在风险。关于延迟消息投递，社区和数据平台部 MQ 团队下一步将聚焦在支持大规模延迟消息。目前讨论的方案是在 delayed index 队列加入时间分区，Broker 只加载当前较近的时间片 delayed index 到内存，其余时间片分区持久化磁盘，示例图如下图所示：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;339&quot; data-ratio=&quot;0.5945823927765237&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VY8SELNGe96XRBWQxSb1tueicMQbe2OibN6CdY9LjXB0fdUYpRrFU34iaYkoosSXmgJojQJsMytmP5Z5iahpJKxDww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2215&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图中，我们按 5 分钟的间隔对 delayed index 队列进行分区，m5 和 m1 放在了 time partition 1，由于延迟时间最近，放在了内存；m4 和 m3 在 time partition 2，延迟时间比较靠后，index 存储在了磁盘。该方案不仅可以减少 delayed index 队列重建时间开销，还可以降低对内存的依赖。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7172996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXN9zzNy9ic0vpfTWhT860qOib757icGsNf1ibDZZPVPG1xJia1ibJvyOlE8JKqibFsrDmxyr78zZuvk0KfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;237&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;结语&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文为大家介绍了延迟消息投递的相关概念和使用场景，并详细拓展了 Apache &lt;span&gt;Pulsar&lt;/span&gt; 的实现原理。&lt;span&gt;Pulsar 目前方案简单高效&lt;/span&gt;，&lt;span&gt;支持秒级精度的延迟消息投递&lt;/span&gt;，但在处理&lt;span&gt;大规模延迟消息时还有一些局限。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前腾讯云消息队列 TDMQ 上已上线了对 Pulsar 延迟消息投递的支持，Pulsar 社&lt;span&gt;区和数据平台部 MQ 团队下一步也将聚焦在支持大规模延迟消息&lt;/span&gt;上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;往期&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;推荐&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMTQ2NTA1Mg==&amp;amp;mid=2247487622&amp;amp;idx=1&amp;amp;sn=b94a383b06a6032a7ff893036a790b46&amp;amp;chksm=9b41e8b5ac3661a39cea9b2db1dd780787f6ed240b94a4cb52f841bd4c7d600795d0b23206f3&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《【精彩分享】腾讯云微服务平台的标准输出与落地实践》&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMTQ2NTA1Mg==&amp;amp;mid=2247487529&amp;amp;idx=1&amp;amp;sn=0442c7064633f05a0e4473adc12db530&amp;amp;chksm=9b41e81aac36610c7e040f88dcf37975498a6565e132c34211d51567ae5b74d6b3957b5cf4e0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《构建基于Service Mesh 的云原生微服务框架》&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMTQ2NTA1Mg==&amp;amp;mid=2247487524&amp;amp;idx=1&amp;amp;sn=4c205521bf49f517ef9230f1df377ed2&amp;amp;chksm=9b41e817ac366101a31740321c3921a6ac29c95bb8d77fb64dbb6a473433471ec027d75e8cfe&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《腾讯云中间件产品月报（2021年第1期）| 文末好礼送不停》&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;开奖&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;啦&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;恭喜以下小伙伴在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxMTQ2NTA1Mg==&amp;amp;mid=2247487524&amp;amp;idx=1&amp;amp;sn=4c205521bf49f517ef9230f1df377ed2&amp;amp;chksm=9b41e817ac366101a31740321c3921a6ac29c95bb8d77fb64dbb6a473433471ec027d75e8cfe&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《腾讯云中间件产品月报（2021年第1期）| 文末好礼送不停》&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;活动中获赞 TOP 5 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;记得私聊小Q妹获得对应礼品噢&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;670&quot; data-backw=&quot;578&quot; data-ratio=&quot;1.1592592592592592&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/dPkfGGYFSHXN9zzNy9ic0vpfTWhT860qOBrCVL3N3CELkEXCdHUicHxVGe7PRJjlVZV3vkS8J6NS67X6pswPUYbA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7083333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHWia32kFmaefMpOkDjzygcaXnDibFevLNTVkKPtYwvCQr4SQa6Ta1d2xYdwsiaOjdeeGRRtpBEVkFUicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;240&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;扫描下方二维码关注本公众号，&lt;/p&gt;&lt;p&gt;了解更多微服务、消息队列的相关信息！&lt;/p&gt;&lt;p&gt;解锁超多鹅厂周边！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;562&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;334&quot; data-ratio=&quot;0.5560488346281909&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dPkfGGYFSHXWa3qntCtcsFhOnLP26ERNdoiaX1SVaa3fWKpxLFQmBgwc9UOz5hoRzPicnvW7Fjyh3TianDRVbbic5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;901&quot;/&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;87578&quot;&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;&lt;section&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot; class=&quot;__bg_gif&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/yqVAqoZvDibHW4ynpBjRrolMxOZtKTiaYgT0HG1BkTeIUjfS0zrwEYVMy6Fj54m58z6pH9yWNOnFkbflRtKVicx0w/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;戳原文，了解更多消息队列TDMQ的信息&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;87578&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;94252&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.0740740740740742&quot; data-type=&quot;png&quot; data-w=&quot;81&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/7QRTvkK2qC5ricrpxA0Tln6U4mt6c9God8owkFMgicqnvogW8znAX84Syp3PSlsnkPKnE2n4ZyZs8E73qZj6XgyA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;点亮&lt;span&gt;在看&lt;/span&gt;，你最好看&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>