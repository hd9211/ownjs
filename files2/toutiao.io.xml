<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>2b02b270d56c3642774cbeb1bb2650bb</guid>
<title>教你从头写游戏服务器框架</title>
<link>https://toutiao.io/k/906zu1i</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;前言
大概已经有差不多一年没写技术文章了，原因是今年投入了一些具体游戏项目的开发。这些新的游戏项目，比较接近独立游戏的开发方式。我觉得公司的“祖传”服务器框架技术不太适合，所以从头写了一个游戏服务器端的框架，以便获得更好的开发效率和灵活性。现在项目将近上线，有时间就想总结一下，这样一个游戏服务器框架的设计和实现过程。
这个框架的基本运行环境是 Linux ，采用 C++ 编写。为了能在各种环境上运行和使用，所以采用了 gcc 4.8 这个“古老”的编译器，以 C99 规范开发。
需求
由于“越通用的代码，就是越没用的代码”，所以在设计之初，我就认为应该使用分层的模式来构建整个系统。按照游戏服务器的一般需求划分，最基本的可以分为两层：&lt;/p&gt;

&lt;p&gt;底层基础功能：包括通信、持久化等非常通用的部分，关注的是性能、易用性、扩展性等指标。
高层逻辑功能：包括具体的游戏逻辑，针对不同的游戏会有不同的设计。
&lt;img src=&quot;https://img.toutiao.io/attachment/48dde7a7278c47ac8d82c3ccec117c04/w600&quot; alt=&quot;file&quot;/&gt;
我希望能有一个基本完整的“底层基础功能”的框架，可以被复用于多个不同的游戏。由于目标是开发一个 适合独立游戏开发 的游戏服务器框架。所以最基本的需求分析为：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;功能性需求&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;并发：所有的服务器程序，都会碰到这个基本的问题：如何处理并发处理。一般来说，会有多线程、异步两种技术。多线程编程在编码上比较符合人类的思维习惯，但带来了“锁”这个问题。而异步非阻塞的模型，其程序执行的情况是比较简单的，而且也能比较充分的利用硬件性能，但是问题是很多代码需要以“回调”的形式编写，对于复杂的业务逻辑来说，显得非常繁琐，可读性非常差。虽然这两种方案各有利弊，也有人结合这两种技术希望能各取所长，但是我更倾向于基础是使用异步、单线程、非阻塞的调度方式，因为这个方案是最清晰简单的。为了解决“回调”的问题，我们可以在其上再添加其他的抽象层，比如协程或者添加线程池之类的技术予以改善。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通信：支持 请求响应 模式以及 通知模式的通信（广播视为一种多目标的通知）。游戏有很多登录、买卖、打开背包之类的功能，都是明确的有请求和响应的。而大量的联机游戏中，多个客户端的位置、HP等东西都需要经过网络同步，其实就是一种“主动通知”的通信方式。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;3.持久化：可以存取 对象 。游戏存档的格式非常复杂，但其索引的需求往往都是根据玩家 ID 来读写就可以。在很多游戏主机如PlayStation 上，以前的存档都是可以以类似“文件”的方式存放在记忆卡里的。所以游戏持久化最基本的需求，就是一个key-value存取模型。当然，游戏中还会有更复杂的持久化需求，比如排行榜、拍卖行等，这些需求应该额外对待，不适合包含在一个最基本的通用底层中。&lt;/p&gt;

&lt;p&gt;4.缓存：支持远程、分布式的对象缓存。游戏服务基本上都是“带状态”的服务，因为游戏要求响应延迟非常苛刻，基本上都需要利用服务器进程的内存来存放过程数据。但是游戏的数据，往往是变化越快的，价值越低，比如经验值、金币、HP，而等级、装备等变化比较慢的，价值则越高，这种特征，非常适合用一个缓存模型来处理。&lt;/p&gt;

&lt;p&gt;5.协程：可以用 C++来编写协程代码，避免大量回调函数分割代码。这个是对于异步代码非常有用的特性，能大大提高代码的可读性和开发效率。特别是把很多底层涉及IO的功能，都提供了协程化API，使用起来就会像同步的 API 一样轻松惬意。&lt;/p&gt;

&lt;p&gt;6.脚本：初步设想是支持可以用 Lua来编写业务逻辑。游戏需求变化是出了名快的，用脚本语言编写业务逻辑正好能提供这方面的支持。实际上脚本在游戏行业里的使用非常广泛。所以支持脚本，也是一个游戏服务器框架很重要的能力。&lt;/p&gt;

&lt;p&gt;7.其他功能：包括定时器、服务器端的对象管理等等。这些功能很常用，所以也需要包含在框架中，但已经有很多成熟方案，所以只要选取常见易懂的模型即可。比如对象管理，我会采用类似Unity 的组件模型来实现。
&lt;strong&gt;非功能性需求&lt;/strong&gt;
1.灵活性：支持可替换的通信协议；可替换的持久化设备（如数据库）；可替换的缓存设备（如 memcached/redis）；以静态库和头文件的方式发布，不对使用者代码做过多的要求。游戏的运营环境比较复杂，特别是在不同的项目之间，可能会使用不同的数据库、不同的通信协议。但是游戏本身业务逻辑很多都是基于对象模型去设计的，所以应该有一层能够基于“对象”来抽象所有这些底层功能的模型。这样才能让多个不同的游戏，都基于一套底层进行开发。&lt;/p&gt;

&lt;p&gt;2.部署便利性：支持灵活的配置文件、命令行参数、环境变量的引用；支持单独进程启动，而无须依赖数据库、消息队列中间件等设施。一般游戏都会有至少三套运行环境，包括一个开发环境、一个内测环境、一个外测或运营环境。一个游戏的版本更新，往往需要更新多个环境。所以如何能尽量简化部署就成为一个很重要的问题。我认为一个好的服务器端框架，应该能让这个服务器端程序，在无配置、无依赖的情况下独立启动，以符合在开发、测试、演示环境下快速部署。并且能很简单的通过配置文件、或者命令行参数的不同，在集群化下的外部测试或者运营环境下启动。&lt;/p&gt;

&lt;p&gt;3.性能：很多游戏服务器，都会使用异步非阻塞的方式来编程。因为异步非阻塞可以很好的提高服务器的吞吐量，而且可以很明确的控制多个用户任务并发下的代码执行顺序，从而避免多线程锁之类的复杂问题。所以这个框架我也希望是以异步非阻塞作为基本的并发模型。这样做还有另外一个好处，就是可以手工的控制具体的进程，充分利用多核 CPU 服务器的性能。当然异步代码可读性因为大量的回调函数，会变得很难阅读，幸好我们还可以用“协程”来改善这个问题。&lt;/p&gt;

&lt;p&gt;4.扩展性：支持服务器之间的通信，进程状态管理，类似 SOA 的集群管理。自动容灾和自动扩容，其实关键点是服务进程的状态同步和管理。我希望一个通用的底层，可以把所有的服务器间调用，都通过一个统一的集权管理模型管理起来，这样就可以不再每个项目去关心集群间通信、寻址等问题。
一旦需求明确下来，基本的层级结构也可以设计了：
&lt;img src=&quot;https://img.toutiao.io/attachment/ba2a2ab719754b02851b8581517d84a5/w600&quot; alt=&quot;file&quot;/&gt;
最后，整体的架构模块类似：
&lt;img src=&quot;https://img.toutiao.io/attachment/7238d9aa95704fb88fa8e3854e578463/w600&quot; alt=&quot;file&quot;/&gt;
&lt;strong&gt;通信模块&lt;/strong&gt;
对于通信模块来说，需要有灵活的可替换协议的能力，就必须按一定的层次进行进一步的划分。对于游戏来说，最底层的通信协议，一般会使用 TCP 和 UDP 这两种，在服务器之间，也会使用消息队列中间件一类通信软件。框架必须要有能同事支持这几通信协议的能力。故此设计了一个层次为: Transport&lt;/p&gt;

&lt;p&gt;在协议层面，最基本的需求有“分包”“分发”“对象序列化”等几种需求。如果要支持“请求-响应”模式，还需要在协议中带上“序列号”的数据，以便对应“请求”和“响应”。另外，游戏通常都是一种“会话”式的应用，也就是一系列的请求，会被视为一次“会话”，这就需要协众需要有类似 Session ID 这种数据。为了满足这些需求，设计一个层次为： Protocol&lt;/p&gt;

&lt;p&gt;拥有了以上两个层次，是可以完成最基本的协议层能力了。但是，我们往往希望业务数据的协议包，能自动化的成为编程中的 对象，所以在处理消息体这里，需要一个可选的额外层次，用来把字节数组，转换成对象。所以我设计了一个特别的处理器：ObjectProcessor ，去规范通信模块中对象序列化、反序列化的接口。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/attachment/87f2ecdd576140a09684d51c0e93979d/w600&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Transport&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;此层次是为了统一各种不同的底层传输协议而设置的，最基本应该支持 TCP 和 UDP 这两种协议。对于通信协议的抽象，其实在很多底层库也做的非常好了，比如 Linux 的 socket 库，其读写 API 甚至可以和文件的读写通用。C# 的 Socket 库在 TCP 和 UDP 之间，其 api 也几乎是完全一样的。但是由于作用游戏服务器，很多适合还会接入一些特别的“接入层”，比如一些代理服务器，或者一些消息中间件，这些 API 可是五花八门的。另外，在 html5 游戏（比如微信小游戏）和一些页游领域，还有用 HTTP 服务器作为游戏服务器的传统（如使用 WebSocket 协议），这样就需要一个完全不同的传输层了。
服务器传输层在异步模型下的基本使用序列，就是：&lt;/p&gt;

&lt;p&gt;1.在主循环中，不断尝试读取有什么数据可读
2.如果上一步返回有数据到达了，则读取数据
3.读取数据处理后，需要发送数据，则向网络写入数据&lt;/p&gt;

&lt;p&gt;根据上面三个特点，可以归纳出一个基本的接口：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Transport {
public:   
   /**
    * 初始化Transport对象，输入Config对象配置最大连接数等参数，可以是一个新建的Config对象。
    */   
   virtual int Init(Config* config) = 0;

   /**
    * 检查是否有数据可以读取，返回可读的事件数。后续代码应该根据此返回值循环调用Read()提取数据。
    * 参数fds用于返回出现事件的所有fd列表，len表示这个列表的最大长度。如果可用事件大于这个数字，并不影响后续可以Read()的次数。
    * fds的内容，如果出现负数，表示有一个新的终端等待接入。
    */
   virtual int Peek(int* fds, int len) = 0;

   /**
    * 读取网络管道中的数据。数据放在输出参数 peer 的缓冲区中。
    * @param peer 参数是产生事件的通信对端对象。
    * @return 返回值为可读数据的长度，如果是 0 表示没有数据可以读，返回 -1 表示连接需要被关闭。
    */
   virtual int Read( Peer* peer) = 0;

   /**
    * 写入数据，output_buf, buf_len为想要写入的数据缓冲区，output_peer为目标队端，
    * 返回值表示成功写入了的数据长度。-1表示写入出错。
    */
   virtual int Write(const char* output_buf, int buf_len, const Peer&amp;amp; output_peer) = 0;

   /**
    * 关闭一个对端的连接
    */
   virtual void ClosePeer(const Peer&amp;amp; peer) = 0;

   /**
    * 关闭Transport对象。
    */
   virtual void Close() = 0;

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的定义中，可以看到需要有一个 Peer 类型。这个类型是为了代表通信的客户端（对端）对象。在一般的 Linux 系统中，一般我们用 fd （File Description）来代表。但是因为在框架中，我们还需要为每个客户端建立接收数据的缓存区，以及记录通信地址等功能，所以在 fd 的基础上封装了一个这样的类型。这样也有利于把 UDP 通信以不同客户端的模型，进行封装。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;///@brief 此类型负责存放连接过来的客户端信息和数据缓冲区
class Peer {
public: 
    int buf_size_;      ///&amp;lt; 缓冲区长度
    char* const buffer_;///&amp;lt; 缓冲区起始地址
    int produced_pos_;  ///&amp;lt; 填入了数据的长度
    int consumed_pos_;  ///&amp;lt; 消耗了数据的长度

    int GetFd() const;
    void SetFd(int fd);    /// 获得本地地址
    const struct sockaddr_in&amp;amp; GetLocalAddr() const;
    void SetLocalAddr(const struct sockaddr_in&amp;amp; localAddr);    /// 获得远程地址

    const struct sockaddr_in&amp;amp; GetRemoteAddr() const;
    void SetRemoteAddr(const struct sockaddr_in&amp;amp; remoteAddr);

private:
    int fd_;                            ///&amp;lt; 收发数据用的fd
    struct sockaddr_in remote_addr_;    ///&amp;lt; 对端地址
    struct sockaddr_in local_addr_;     ///&amp;lt; 本端地址
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;游戏使用 UDP 协议的特点：一般来说 UDP 是无连接的，但是对于游戏来说，是肯定需要有明确的客户端的，所以就不能简单用一个 UDP socket 的fd 来代表客户端，这就造成了上层的代码无法简单在 UDP 和 TCP 之间保持一致。因此这里使用 Peer 这个抽象层，正好可以接近这个问题。这也可以用于那些使用某种消息队列中间件的情况，因为可能这些中间件，也是多路复用一个 fd 的，甚至可能就不是通过使用 fd 的 API 来开发的。&lt;/p&gt;

&lt;p&gt;对于上面的 Transport 定义，对于 TCP 的实现者来说，是非常容易能完成的。但是对于 UDP 的实现者来说，则需要考虑如何宠妃利用 Peer ，特别是 Peer.fd_ 这个数据。我在实现的时候，使用了一套虚拟的 fd 机制，通过一个客户端的 IPv4 地址到 int 的对应 Map ，来对上层提供区分客户端的功能。在 Linux 上，这些 IO 都可以使用 epoll 库来实现，在 Peek() 函数中读取 IO 事件，在 Read()/Write() 填上 socket 的调用就可以了。&lt;/p&gt;

&lt;p&gt;另外，为了实现服务器之间的通信，还需要设计和 Tansport 对应的一个类型：Connector 。这个抽象基类，用于以客户端模型对服务器发起请求。其设计和 Transport 大同小异。除了 Linux 环境下的 Connecotr ，我还实现了在 C# 下的代码，以便用 Unity 开发的客户端可以方便的使用。由于 .NET 本身就支持异步模型，所以其实现也不费太多功夫。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * @brief 客户端使用的连接器类，代表传输协议，如 TCP 或 UDP
 */
class Connector {

public:    virtual ~Connector() {}    

    /**
     * @brief 初始化建立连接等
     * @param config 需要的配置
     * @return 0 为成功
     */
    virtual int Init(Config* config) = 0;

    /**
     * @brief 关闭
     */
    virtual void Close() = 0;

    /**
     * @brief 读取是否有网络数据到来
     * 读取有无数据到来，返回值为可读事件的数量，通常为1
     * 如果为0表示没有数据可以读取。
     * 如果返回 -1 表示出现网络错误，需要关闭此连接。
     * 如果返回 -2 表示此连接成功连上对端。
     * @return 网络数据的情况
     */
    virtual int Peek() = 0;

    /**
     * @brief 读取网络数 
     * 读取连接里面的数据，返回读取到的字节数，如果返回0表示没有数据，
     * 如果buffer_length是0, 也会返回0，
     * @return 返回-1表示连接需要关闭（各种出错也返回0）
     */
    virtual int Read(char* ouput_buffer, int buffer_length) = 0;

    /**
     * @brief 把input_buffer里的数据写入网络连接，返回写入的字节数。
     * @return 如果返回-1表示写入出错，需要关闭此连接。
     */
   virtual int Write(const char* input_buffer, int buffer_length) = 0;

protected:
    Connector(){}
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Protocol&lt;/strong&gt;
对于通信“协议”来说，其实包含了许许多多的含义。在众多的需求中，我所定义的这个协议层，只希望完成四个最基本的能力：&lt;/p&gt;

&lt;p&gt;1.分包：从流式传输层切分出一个个单独的数据单元，或者把多个“碎片”数据拼合成一个完整的数据单元的能力。一般解决这个问题，需要在协议头部添加一个“长度”字段。&lt;/p&gt;

&lt;p&gt;2.请求响应对应：这对于异步非阻塞的通信模式下，是非常重要的功能。因为可能在一瞬间发出了很多个请求，而回应则会不分先后的到达。协议头部如果有一个不重复的“序列号”字段，就可以对应起哪个回应是属于哪个请求的。&lt;/p&gt;

&lt;p&gt;3.会话保持：由于游戏的底层网络，可能会使用 UDP 或者 HTTP 这种非长连接的传输方式，所以要在逻辑上保持一个会话，就不能单纯的依靠传输层。加上我们都希望程序有抗网络抖动、断线重连的能力，所以保持会话成为一个常见的需求。我参考在 Web 服务领域的会话功能，设计了一个 Session 功能，在协议中加上 Session ID 这样的数据，就能比较简单的保持会话。&lt;/p&gt;

&lt;p&gt;4.分发：游戏服务器必定会包含多个不同的业务逻辑，因此需要多种不同数据格式的协议包，为了把对应格式的数据转发。&lt;/p&gt;

&lt;p&gt;除了以上三个功能，实际上希望在协议层处理的能力，还有很多，最典型的就是对象序列化的功能，还有压缩、加密功能等等。我之所以没有把对象序列化的能力放在 Protocol 中，原因是对象序列化中的“对象”本身是一个业务逻辑关联性非常强的概念。在 C++ 中，并没有完整的“对象”模型，也缺乏原生的反射支持，所以无法很简单的把代码层次通过“对象”这个抽象概念划分开来。但是我也设计了一个 ObjectProcessor ，把对象序列化的支持，以更上层的形式结合到框架中。这个 Processor 是可以自定义对象序列化的方法，这样开发者就可以自己选择任何“编码、解码”的能力，而不需要依靠底层的支持。&lt;/p&gt;

&lt;p&gt;至于压缩和加密这一类功能，确实是可以放在 Protocol 层中实现，甚至可以作为一个抽象层次加入 Protocol ，可能只有一个 Protocol 层不足以支持这么丰富的功能，需要好像 Apache Mina 这样，设计一个“调用链”的模型。但是为了简单起见，我觉得在具体需要用到的地方，再额外添加 Protocol 的实现类就好，比如添加一个“带压缩功能的 TLV Protocol 类型”之类的。&lt;/p&gt;

&lt;p&gt;消息本身被抽象成一个叫 Message 的类型，它拥有“服务名字”“会话ID”两个消息头字段，用以完成“分发”和“会话保持”功能。而消息体则被放在一个字节数组中，并记录下字节数组的长度。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum MessageType {
    TypeError, ///&amp;lt; 错误的协议
    TypeRequest, ///&amp;lt; 请求类型，从客户端发往服务器
    TypeResponse, ///&amp;lt; 响应类型，服务器收到请求后返回
    TypeNotice  ///&amp;lt; 通知类型，服务器主动通知客户端
};

///@brief 通信消息体的基类
///基本上是一个 char[] 缓冲区
struct Message {
public:
    static int MAX_MAESSAGE_LENGTH;
    static int MAX_HEADER_LENGTH;

    MessageType type;  ///&amp;lt; 此消息体的类型(MessageType)信息

    virtual ~Message();    virtual Message&amp;amp; operator=(const Message&amp;amp; right);

    /**
     * @brief 把数据拷贝进此包体缓冲区
     */
    void SetData(const char* input_ptr, int input_length);

    ///@brief 获得数据指针
    inline char* GetData() const{
        return data_;
    }

     ///@brief 获得数据长度
    inline int GetDataLen() const{
        return data_len_;
    }

    char* GetHeader() const;
    int GetHeaderLen() const;

protected:
    Message();
    Message(const Message&amp;amp; message);

private:
    char* data_;                  // 包体内容缓冲区
    int data_len_;                // 包体长度

};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据之前设计的“请求响应”和“通知”两种通信模式，需要设计出三种消息类型继承于 Message，他们是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Request 请求包&lt;/li&gt;
&lt;li&gt;Response 响应包&lt;/li&gt;
&lt;li&gt;Notice 通知包&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Request 和 Response 两个类，都有记录序列号的 seq_id 字段，但 Notice 没有。Protocol 类就是负责把一段 buffer 字节数组，转换成 Message 的子类对象。所以需要针对三种 Message 的子类型都实现对应的 Encode() / Decode() 方法。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Protocol {

public:
    virtual ~Protocol() {
    }

    /**
     * @brief 把请求消息编码成二进制数据
     * 编码，把msg编码到buf里面，返回写入了多长的数据，如果超过了 len，则返回-1表示错误。
     * 如果返回 0 ，表示不需要编码，框架会直接从 msg 的缓冲区读取数据发送。
     * @param buf 目标数据缓冲区
     * @param offset 目标偏移量
     * @param len 目标数据长度
     * @param msg 输入消息对象
     * @return 编码完成所用的字节数，如果 &amp;lt; 0 表示出错
     */
    virtual int Encode(char* buf, int offset, int len, const Request&amp;amp; msg) = 0;

    /**
     * 编码，把msg编码到buf里面，返回写入了多长的数据，如果超过了 len，则返回-1表示错误。
     * 如果返回 0 ，表示不需要编码，框架会直接从 msg 的缓冲区读取数据发送。
     * @param buf 目标数据缓冲区
     * @param offset 目标偏移量
     * @param len 目标数据长度
     * @param msg 输入消息对象
     * @return 编码完成所用的字节数，如果 &amp;lt; 0 表示出错
     */
    virtual int Encode(char* buf, int offset, int len, const Response&amp;amp; msg) = 0;

    /**
     * 编码，把msg编码到buf里面，返回写入了多长的数据，如果超过了 len，则返回-1表示错误。
     * 如果返回 0 ，表示不需要编码，框架会直接从 msg 的缓冲区读取数据发送。
     * @param buf 目标数据缓冲区
     * @param offset 目标偏移量
     * @param len 目标数据长度
     * @param msg 输入消息对象
     * @return 编码完成所用的字节数，如果 &amp;lt; 0 表示出错
     */
    virtual int Encode(char* buf, int offset, int len, const Notice&amp;amp; msg) = 0;

    /**
     * 开始编码，会返回即将解码出来的消息类型，以便使用者构造合适的对象。
     * 实际操作是在进行“分包”操作。
     * @param buf 输入缓冲区
     * @param offset 输入偏移量
     * @param len 缓冲区长度
     * @param msg_type 输出参数，表示下一个消息的类型，只在返回值 &amp;gt; 0 的情况下有效，否则都是 TypeError
     * @return 如果返回0表示分包未完成，需要继续分包。如果返回-1表示协议包头解析出错。其他返回值表示这个消息包占用的长度。
     */
    virtual int DecodeBegin(const char* buf, int offset, int len,
                            MessageType* msg_type) = 0;

    /**
     * 解码，把之前DecodeBegin()的buf数据解码成具体消息对象。
     * @param request 输出参数，解码对象会写入此指针
     * @return 返回0表示成功，-1表示失败。
     */
    virtual int Decode(Request* request) = 0;

    /**
     * 解码，把之前DecodeBegin()的buf数据解码成具体消息对象。
     * @param request 输出参数，解码对象会写入此指针
     * @return 返回0表示成功，-1表示失败。
     */
    virtual int Decode(Response* response) = 0;

    /**
     * 解码，把之前DecodeBegin()的buf数据解码成具体消息对象。
     * @param request 输出参数，解码对象会写入此指针
     * @return 返回0表示成功，-1表示失败。
     */
    virtual int Decode(Notice* notice) = 0;protected:

    Protocol() {
    }

};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里有一点需要注意，由于 C++ 没有内存垃圾搜集和反射的能力，在解释数据的时候，并不能一步就把一个 char[] 转换成某个子类对象，而必须分成两步处理。&lt;/p&gt;

&lt;p&gt;1.先通过 DecodeBegin() 来返回，将要解码的数据是属于哪个子类型的。同时完成分包的工作，通过返回值来告知调用者，是否已经完整的收到一个包。&lt;/p&gt;

&lt;p&gt;2.调用对应类型为参数的 Decode() 来具体把数据写入对应的输出变量。&lt;/p&gt;

&lt;p&gt;对于 Protocol 的具体实现子类，我首先实现了一个 LineProtocol ，是一个非常不严谨的，基于文本ASCII编码的，用空格分隔字段，用回车分包的协议。用来测试这个框架是否可行。因为这样可以直接通过 telnet 工具，来测试协议的编解码。然后我按照 TLV （Type Length Value）的方法设计了一个二进制的协议。大概的定义如下：&lt;/p&gt;

&lt;p&gt;协议分包： [消息类型:int:2] [消息长度:int:4] [消息内容:bytes:消息长度]
消息类型取值:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0x00 Error&lt;/li&gt;
&lt;li&gt;0x01 Request&lt;/li&gt;
&lt;li&gt;0x02 Response&lt;/li&gt;
&lt;li&gt;0x03 Notice&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/attachment/5c18d457cfe4468ca0b9d5aebb6c2052/w600&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一个名为 TlvProtocol 的类型完成对这个协议的实现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Processor&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;处理器层是我设计用来对接具体业务逻辑的抽象层，它主要通过输入参数 Request 和 Peer 来获得客户端的输入数据，然后通过 Server 类的 Reply()/Inform() 来返回 Response 和 Notice 消息。实际上 Transport 和 Protocol 的子类们，都属于 net 模块，而各种 Processor 和 Server/Client 这些功能类型，属于另外一个 processor 模块。这样设计的原因，是希望所有 processor 模块的代码单向的依赖 net 模块的代码，但反过来不成立。&lt;/p&gt;

&lt;p&gt;Processor 基类非常简单，就是一个处理函数回调函数入口 Process()：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;///@brief 处理器基类，提供业务逻辑回调接口

class Processor {

public:
    Processor();
    virtual ~Processor();

    /**
     * 初始化一个处理器，参数server为业务逻辑提供了基本的能力接口。
     */
    virtual int Init(Server* server, Config* config = NULL);

    /**
     * 处理请求-响应类型包实现此方法，返回值是0表示成功，否则会被记录在错误日志中。
     * 参数peer表示发来请求的对端情况。其中 Server 对象的指针，可以用来调用 Reply(),
     * Inform() 等方法。如果是监听多个服务器，server 参数则会是不同的对象。
     */
    virtual int Process(const Request&amp;amp; request, const Peer&amp;amp; peer,
                        Server* server);

    /**
     * 关闭清理处理器所占用的资源
     */
    virtual int Close();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设计完 Transport/Protocol/Processor 三个通信处理层次后，就需要一个组合这三个层次的代码，那就是 Server 类。这个类在 Init() 的时候，需要上面三个类型的子类作为参数，以组合成不同功能的服务器，如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TlvProtocol tlv_protocol;   //  Type Length Value 格式分包协议，需要和客户端一致
TcpTransport tcp_transport; // 使用 TCP 的通信协议，默认监听 0.0.0.0:6666
EchoProcessor echo_processor;   // 业务逻辑处理器
Server server;  // DenOS 的网络服务器主对象
server.Init(&amp;amp;tcp_transport, &amp;amp;tlv_protocol, &amp;amp;echo_processor);    // 组装一个游戏服务器对象：TLV 编码、TCP 通信和回音服务
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Server 类型还需要一个 Update() 函数，让用户进程的“主循环”不停的调用，用来驱动整个程序的运行。这个 Update() 函数的内容非常明确：&lt;/p&gt;

&lt;p&gt;1.检查网络是否有数据需要处理（通过 Transport 对象）&lt;/p&gt;

&lt;p&gt;2.有数据的话就进行解码处理（通过 Protocol 对象）&lt;/p&gt;

&lt;p&gt;3.解码成功后进行业务逻辑的分发调用（通过 Processor 对象）&lt;/p&gt;

&lt;p&gt;另外，Server 还需要处理一些额外的功能，比如维护一个会话缓存池（Session），提供发送 Response 和 Notice 消息的接口。当这些工作都完成后，整套系统已经可以用来作为一个比较“通用”的网络消息服务器框架存在了。剩下的就是添加各种 Transport/Protocol/Processor 子类的工作。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Server {

public:
    Server();
    virtual ~Server();

    /**
     * 初始化服务器，需要选择组装你的通信协议链
     */
    int Init(Transport* transport, Protocol* protocol, Processor* processor, Config* config = NULL);

    /**
     * 阻塞方法，进入主循环。
     */
    void Start();

    /**
     * 需要循环调用驱动的方法。如果返回值是0表示空闲。其他返回值表示处理过的任务数。
     */
    virtual int Update();
    void ClosePeer(Peer* peer, bool is_clear = false); //关闭当个连接，is_clear 表示是否最终整体清理

    /**
     * 关闭服务器
     */
    void Close();

    /**
     * 对某个客户端发送通知消息，
     * 参数peer代表要通知的对端。
     */
    int Inform(const Notice&amp;amp; notice, const Peer&amp;amp; peer);

    /**
     * 对某个  Session ID 对应的客户端发送通知消息，返回 0 表示可以发送，其他值为发送失败。
     * 此接口能支持断线重连，只要客户端已经成功连接，并使用旧的 Session ID，同样有效。
     */
    int Inform(const Notice&amp;amp; notice, const std::string&amp;amp; session_id);

    /**
     * 对某个客户端发来的Request发回回应消息。
     * 参数response的成员seqid必须正确填写，才能正确回应。
     * 返回0成功，其它值（-1）表示失败。
     */
    int Reply(Response* response, const Peer&amp;amp; peer);

    /**
     * 对某个 Session ID 对应的客户端发送回应消息。
     * 参数 response 的 seqid 成员系统会自动填写会话中记录的数值。
     * 此接口能支持断线重连，只要客户端已经成功连接，并使用旧的 Session ID，同样有效。
     * 返回0成功，其它值（-1）表示失败。
     */
    int Reply(Response* response, const std::string&amp;amp; session_id);

    /**
     * 会话功能
     */
    Session* GetSession(const std::string&amp;amp; session_id = &quot;&quot;, bool use_this_id = false);
    Session* GetSessionByNumId(int session_id = 0);
    bool IsExist(const std::string&amp;amp; session_id);

};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有了 Server 类型，肯定也需要有 Client 类型。而 Client 类型的设计和 Server 类似，但就不是使用 Transport 接口作为传输层，而是 Connector 接口。不过 Protocol 的抽象层是完全重用的。Client 并不需要 Processor 这种形式的回调，而是直接传入接受数据消息就发起回调的接口对象 ClientCallback。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class ClientCallback {

public:

    ClientCallback() {
    }
    virtual ~ClientCallback() {
         // Do nothing
    }

    /**
     *  当连接建立成功时回调此方法。
     * @return 返回 -1 表示不接受这个连接，需要关闭掉此连接。
     */
    virtual int OnConnected() {
        return 0;
    }

    /**
     * 当网络连接被关闭的时候，调用此方法
     */
    virtual void OnDisconnected() {        // Do nothing
    }

    /**
     * 收到响应，或者请求超时，此方法会被调用。
     * @param response 从服务器发来的回应
     * @return 如果返回非0值，服务器会打印一行错误日志。
     */
    virtual int Callback(const Response&amp;amp; response) {
        return 0;
    }

    /**
     * 当请求发生错误，比如超时的时候，返回这个错误
     * @param err_code 错误码
     */
    virtual void OnError(int err_code){
        WARN_LOG(&quot;The request is timeout, err_code: %d&quot;, err_code);
    }

    /**
     * 收到通知消息时，此方法会被调用
     */
    virtual int Callback(const Notice&amp;amp; notice) {
        return 0;
    }

    /**
     * 返回此对象是否应该被删除。此方法会被在 Callback() 调用前调用。
     * @return 如果返回 true，则会调用 delete 此对象的指针。
     */
    virtual bool ShouldBeRemoved() {
        return false;
    }
};

class Client : public Updateable {

public:
    Client();    virtual ~Client();

     /**
     * 连接服务器
     * @param connector 传输协议，如 TCP， UDP ...
     * @param protocol 分包协议，如 TLV, Line, TDR ...
     * @param notice_callback 收到通知后触发的回调对象，如果传输协议有“连接概念”（如TCP/TCONND），建立、关闭连接时也会调用。
     * @param config 配置文件对象，将读取以下配置项目：MAX_TRANSACTIONS_OF_CLIENT 客户端最大并发连接数; BUFFER_LENGTH_OF_CLIENT客户端收包缓存；CLIENT_RESPONSE_TIMEOUT 客户端响应等待超时时间。
     * @return 返回 0 表示成功，其他表示失败
     */
    int Init(Connector* connector, Protocol* protocol,
             ClientCallback* notice_callback = NULL, Config* config = NULL);

    /**
     * callback 参数可以为 NULL，表示不需要回应，只是单纯的发包即可。
     */
    virtual int SendRequest(Request* request, ClientCallback* callback = NULL);

    /**
     * 返回值表示有多少数据需要处理，返回-1为出错，需要关闭连接。返回0表示没有数据需要处理。
     */
    virtual int Update();
    virtual void OnExit();
    void Close();
    Connector* connector() ;
    ClientCallback* notice_callback() ;
    Protocol* protocol() ;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;至此，客户端和服务器端基本设计完成，可以直接通过编写测试代码，来检查是否运行正常。
图片来源：&lt;a href=&quot;http://www.diuxie.com/&quot;&gt;http://www.diuxie.com/&lt;/a&gt; 游戏&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1af9d3903098e9ea4506bb8b1da8e0ac</guid>
<title>又谈 SQL-to-SQL 翻译器</title>
<link>https://toutiao.io/k/ugvpa8o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6169154228855721&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag9UPn0y9ibOHoubKnUZjZWng3Pz57OH6iavxb5NDMETkNVsG1l4Pc05jLiaWVjA3FZPtKs9ibfR0vp3Vg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;603&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;之前已经浅谈(&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3MDU3OTc1Nw==&amp;amp;mid=2247485169&amp;amp;idx=1&amp;amp;sn=291abcdc9ad90718d71c28d0653c92e3&amp;amp;chksm=eacfa7b3ddb82ea5968e7d6661075f63bd30d4c6ac262a49e314cde2eaeef0ce95ec86ac360c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;浅析构建SQL-to-SQL的翻译器&lt;/a&gt;)，再谈(&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI3MDU3OTc1Nw==&amp;amp;mid=2247485189&amp;amp;idx=1&amp;amp;sn=f82d3a2e98ef567c38b1b28c647000d3&amp;amp;chksm=eacfa647ddb82f51f54d8904531ba1f5c52b22e5445f87cf61ef31eb8c204aead7c486507f2a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;再谈SQL-to-SQL翻译器&lt;/a&gt;)过两次SQL-to-SQL了，这次就只能又谈了，希望这个系列，还能再谈下去，我想做个102年的公众号...&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这次从一张图说起，就是下面这幅图，当我画完他的时候，我就感觉无比的舒爽。让整个执行流程，可控，并且可扩展。还记得当初上学的时候，数学建模课上，老师为了“求证一张四条腿的椅子，四条腿处在一个平面上的概率”，写了满满四黑板板书，然后心满意足的，跟一脸蒙的我们说，“看，多美啊！”。我现在有点理解他当时的状态了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5140625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag9UPn0y9ibOHoubKnUZjZWngcJibx4IIv232L2iaJetI0Qibc4gK6HWmvCCwfchwwKX2aFbJGnSjZvgtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有眼尖的同学，可能已经发现了，没错，这里借鉴了Flink的流程设计。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4743150684931507&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/8uJ0ic6nAag9UPn0y9ibOHoubKnUZjZWngzca4O3d6fVW8Pkge5Dibib3iak9ttl25dfxGiaxtyia6HaXxrFhGWf6FZAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;584&quot;/&gt;&lt;/p&gt;&lt;p&gt;简单的说，输入-&amp;gt; 转换 -&amp;gt; 输出 经典的三段论式构造。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里我们把输入 SourceFunction  和 输出 SinkFunction 进行了抽象，但是并没有像Flink那样，输入输出集成相同的接口，可以自由转换，从需求上来看，是没有必要Sql -to- Sql -to- Sql 的必要的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在转换过程中，我们引用了DSL，来承接前面的SQL解析，以及后续的SQL生成，于是，自然的将转换分成了2段，即输入转换（SourceMapper） 和 输出转换（SinkMapper）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而定义转换与否，以及转换动如何完成，我们可以轻松的通过java自带的 Function 接口来实现。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一个输入是可以接对接N条输出的，输出的方向也完全由实现 SinkFunction 的对象来自实现。 &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果后续，把任务并行化，Pipline 对外提供高阶函数的话， 画美不看...&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;DEMO：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;    &lt;span&gt;public static void &lt;/span&gt;&lt;span&gt;main&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;&lt;span&gt;[] &lt;/span&gt;&lt;span&gt;args&lt;/span&gt;&lt;span&gt;) &lt;/span&gt;&lt;span&gt;throws &lt;/span&gt;&lt;span&gt;IOException &lt;/span&gt;&lt;span&gt;{&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;输入&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;FileSourceFunction &lt;/span&gt;&lt;span&gt;fileSourceFunction &lt;/span&gt;= &lt;span&gt;new &lt;/span&gt;&lt;span&gt;FileSourceFunction&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;fileSourceFunction&lt;/span&gt;.&lt;span&gt;init&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;new &lt;/span&gt;&lt;span&gt;File&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;fff.txt&quot;&lt;/span&gt;&lt;span&gt;))&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;输出&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;PrintlnSinkFunction&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;PrintStream&lt;/span&gt;&lt;span&gt;&amp;gt; &lt;/span&gt;&lt;span&gt;printSinkFunction &lt;/span&gt;= &lt;span&gt;new &lt;/span&gt;&lt;span&gt;PrintlnSinkFunction&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;ListSinkFunction &lt;/span&gt;&lt;span&gt;listSinkFunction &lt;/span&gt;= &lt;span&gt;new &lt;/span&gt;&lt;span&gt;ListSinkFunction&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;p&gt;&lt;span&gt;TransformPepline &lt;/span&gt;&lt;span&gt;tp &lt;/span&gt;= &lt;span&gt;new &lt;/span&gt;&lt;span&gt;TransformPepline&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;    //添加输入输出&lt;/p&gt;&lt;span&gt;tp&lt;/span&gt;.&lt;span&gt;addSource&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;fileSourceFunction&lt;/span&gt;&lt;span&gt;)&lt;br/&gt;&lt;/span&gt;&lt;span&gt;                &lt;/span&gt;.&lt;span&gt;addSink&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;printSinkFunction&lt;/span&gt;&lt;span&gt;)&lt;br/&gt;&lt;/span&gt;&lt;span&gt;                &lt;/span&gt;.&lt;span&gt;addSink&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;listSinkFunction&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;;&lt;br/&gt;    //定制转换动作&lt;br/&gt;        &lt;span&gt;tp&lt;/span&gt;.&lt;span&gt;addSourceMapFunction&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;new &lt;/span&gt;&lt;span&gt;Function&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;String&lt;/span&gt;, &lt;span&gt;String&lt;/span&gt;&lt;span&gt;&amp;gt;() {&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;SqlTransExecManager &lt;/span&gt;&lt;span&gt;sqlTransExecManager &lt;/span&gt;= &lt;span&gt;new &lt;/span&gt;&lt;span&gt;SqlTransExecManager&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;.&lt;span&gt;build&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;@Override&lt;br/&gt;&lt;/span&gt;&lt;span&gt;            &lt;/span&gt;&lt;span&gt;public &lt;/span&gt;&lt;span&gt;String &lt;/span&gt;&lt;span&gt;apply&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;String &lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;) {&lt;br/&gt;&lt;/span&gt;&lt;span&gt;                &lt;/span&gt;&lt;span&gt;return &lt;/span&gt;&lt;span&gt;sqlTransExecManager&lt;/span&gt;.&lt;span&gt;doParseAndTransform&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;s&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;.&lt;span&gt;getTargetSql&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;}&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        })&lt;/span&gt;;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        //&lt;/span&gt;&lt;span&gt;执行&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;tp&lt;/span&gt;.&lt;span&gt;execute&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;System&lt;/span&gt;.&lt;span&gt;out&lt;/span&gt;.&lt;span&gt;println&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;listSinkFunction&lt;/span&gt;.&lt;span&gt;getLists&lt;/span&gt;&lt;span&gt;())&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;}&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关注 【&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;麒思妙想&lt;/span&gt;&lt;span&gt;】解锁更多硬核。&lt;/span&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;历史文章导读&lt;/strong&gt;：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果文章对您有那么一点点帮助，我将倍感荣幸&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;欢迎  &lt;span&gt;&lt;strong&gt;关注、在看、点赞、转发 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8uJ0ic6nAag8EItgzqIEhe3GbK3ibibrSC3kGNLaCYoEXEEEV8vatdHqibkazrs7oLJERAG1cldW9pbVmcTKvXL3fA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>84d42f3ec82853c50befb5812e746c79</guid>
<title>5 分钟搞定 B 站答题成为正式会员，每天自动刷经验值升级账号</title>
<link>https://toutiao.io/k/kks2428</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;苏生不惑第&lt;code&gt;225&lt;/code&gt; 篇原创文章，将本公众号设为&lt;code&gt;星标&lt;/code&gt;，第一时间看最新文章。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章开始前说下之前文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MjM5ODIzNDExMg==&amp;amp;mid=2257486573&amp;amp;idx=1&amp;amp;sn=ed0bc701a50bb4d8c5578f3d629c6883&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;2021 微信运动一键刷步数，让你成功占领封面&lt;/a&gt; 有人问为什么修改后不生效，注意解压后有个txt文件不能删。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于b站之前已经写过很多文章了：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIyMjg2ODExMA==&amp;amp;mid=2247487672&amp;amp;idx=1&amp;amp;sn=669e6c9aa9f522cabb21a48d85308aab&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;b 站账号快速升级到 Lv6：每天自动签到，观看，分享，投币视频&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIyMjg2ODExMA==&amp;amp;mid=2247484497&amp;amp;idx=1&amp;amp;sn=00705110eeb2fe091682388c8f0e884a&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;bilibili(b站)升级到BV号了，还想用av号怎么办？&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIyMjg2ODExMA==&amp;amp;mid=2247484594&amp;amp;idx=1&amp;amp;sn=5d0401cb012f4bdd087d371d429f4ef8&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;如何更优雅地使用 bilibili(b站)&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIyMjg2ODExMA==&amp;amp;mid=2247484667&amp;amp;idx=1&amp;amp;sn=89dc7038ad8e1de921da3e79c50a6b2e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;想方便快捷的分享/收藏图片？试试免费好用的微博/b站图床&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIyMjg2ODExMA==&amp;amp;mid=2247484793&amp;amp;idx=1&amp;amp;sn=ebd068a51f43bf9b061dc5eb0451e568&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;如何找回bilibili(b站)收藏夹里失效的视频？&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIyMjg2ODExMA==&amp;amp;mid=2247485933&amp;amp;idx=1&amp;amp;sn=19544541242c66dc6e954a64bf2d9b8d&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;如何免登陆观看b站大会员番剧&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIyMjg2ODExMA==&amp;amp;mid=2247486222&amp;amp;idx=1&amp;amp;sn=caa568b4e4e1e82da6e8746890bc8313&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;借用 potplayer 播放器，在本地播放 b 站视频也能看弹幕了&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIyMjg2ODExMA==&amp;amp;mid=2247486774&amp;amp;idx=1&amp;amp;sn=65adc6b7bd37b7a267f73faffc386828&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;下载b站外挂字幕,用 potplayer 播放视频也能看字幕了&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIyMjg2ODExMA==&amp;amp;mid=2247489363&amp;amp;idx=1&amp;amp;sn=b7c0e62f9f94b3b154d974c778a59c0e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;建了个微信交流群，和我一起在 b 站学 Python&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIyMjg2ODExMA==&amp;amp;mid=2247489313&amp;amp;idx=1&amp;amp;sn=3dc1030a4622c6ca76131f4bb449c0ac&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;又一视频下载神器，一键下载b站收藏夹视频和up主所有视频&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIyMjg2ODExMA==&amp;amp;mid=2247489219&amp;amp;idx=1&amp;amp;sn=eb2d6d062d29e6c2e9495fa41ebb8584&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;过年无聊？来b站看豆瓣电影 Top 250&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIyMjg2ODExMA==&amp;amp;mid=2247488912&amp;amp;idx=1&amp;amp;sn=8948d25efd28f214c505d1336b4748a7&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;没有b站大会员怎么看番剧&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天来说说怎么快速成为b站正式会员，b站和其他网站不一样，注册后不能评论，需要通过答题考试（或者邀请码）转正为正式会员才行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我用了4年的号也没发邀请码的权限。&lt;img data-ratio=&quot;0.6548117154811716&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lHKDUzJfR75tzpHzs06Qgicbl23KEczQOdWTbeq4z90jBS0jyHibRM6j7mWzT3QMic7NdkKPbzpzb03A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;478&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答题的话100个题目还是有点难，即使搜索也得答好久，今天分享个脚本帮你5分钟搞定，这里我用了个新手机号来注册答题。&lt;img data-ratio=&quot;0.9826388888888888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lHKDUzJfR75tzpHzs06QgicbHLQep84SCBg6h4IPxjJZDw20ASvTJnqIKpl3fwsqiaQWNe96hXh55zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;576&quot;/&gt;注册后进入 https://www.bilibili.com/v/newbie/basic-1?score=0  开始答题，共100题，得分过60才能通过，下面来演示下脚本怎么自动答题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5948616600790514&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lHKDUzJfR75tzpHzs06QgicbjaA1DMvDhhQqT4rytOiavFLPXL3icBTagMRByjn1rWia5Pl7pHFRkUMiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1012&quot;/&gt;首先在公众号后台回复 &lt;code&gt;b站&lt;/code&gt; 获取脚本，其实就是一段JavaScript代码，打开控制台复制代码运行即可，可以看到控制台在自动答题。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5346774193548387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lHKDUzJfR75tzpHzs06QgicbOvVHicATD3RFpITBn4N3qPM0TD6VI36mPzhkrlJ1AU6r0ouNKJyev1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;到了第50题脚本会&lt;/span&gt;&lt;span&gt;停止，因&lt;/span&gt;&lt;span&gt;为要选择题目模块，这&lt;/span&gt;&lt;span&gt;个得手动操作下&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6695652173913044&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lHKDUzJfR75tzpHzs06QgicbepeHveeq7CgAicoXhSl0XMd9xXLQcTuciazvsXUbgAibylCvDHIGH5hIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1035&quot;/&gt;再次复制脚本运行，很快就到60分了（看GIF动图）。&lt;img data-ratio=&quot;0.516595744680851&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/sZeVtjGD4lHKDUzJfR75tzpHzs06QgicblxmtknvSIgY3MRG0VK5gZicicniaJVhrgIicSw0cMa3OSfiabN6EN7sYSsw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1175&quot;/&gt;答题通过，得分61，成为正式用户了。&lt;img data-ratio=&quot;0.562618595825427&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lHKDUzJfR75tzpHzs06QgicbicCaCNXmziaXabmX2O0ztB18yHKAtiblXLyMQkBQlRFTcr1IUS5FB0Ieg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1054&quot;/&gt;晋级成功。&lt;img data-ratio=&quot;0.9360119047619048&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lHKDUzJfR75tzpHzs06QgicboOrfHd8sRFGcWfQUzuR8xtkf5uqoqFtznCb6SHzw0B0vFsyaUNcLqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;672&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;转正后积分还很低，为了快速升级可以通过GitHub脚本自动刷经验，这个之前文章分享过了&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIyMjg2ODExMA==&amp;amp;mid=2247487672&amp;amp;idx=1&amp;amp;sn=669e6c9aa9f522cabb21a48d85308aab&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;b 站账号快速升级到 Lv6：每天自动签到，观看，分享，投币视频&lt;/a&gt;  ，不过现在脚本更新了，更方便操作了，首先打开控制台复制b站的cookie。&lt;img data-ratio=&quot;0.46593186372745493&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lHKDUzJfR75tzpHzs06QgicbiaicvbmOxiaDNQXlAqNpEibia80EaphjiciaHSR5DFdTNbZ26rEt3ZacUowyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;998&quot;/&gt;在GitHub fork这个项目 https://github.com/RayWangQvQ/BiliBiliTool ，在setting添加secrets ，就是刚才复制的cookie值。&lt;img data-ratio=&quot;0.6241413150147204&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lHKDUzJfR75tzpHzs06QgicbmWHzQRpunhIstA52WMOOJMhSxKnakGibnjicL67I1tPh9QVfiadMcwL6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1019&quot;/&gt;再开启GitHub action  。&lt;img data-ratio=&quot;0.42476851851851855&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lHKDUzJfR75tzpHzs06Qgicbmme5XMFdBh3sLBLib2CJ2fBKicFf0RYWHr5PmAJfjdm30hakiaya95HVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;864&quot;/&gt;运行测试下。&lt;img data-ratio=&quot;0.3524193548387097&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lHKDUzJfR75tzpHzs06Qgicbe5ZF8wKGV6UYrB2ibx5lnRL73desC4oCTrnLWne4tE93yPI7ybQxeTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试成功，可能时间有点长，耐心等待会。&lt;img data-ratio=&quot;1.2280701754385965&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lHKDUzJfR75tzpHzs06QgicbVMQ1SFJaZmsHL96TSLzPRqvNwgJ2T0s9P5KLMfZzyibUib2XEIQiaUxMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;684&quot;/&gt;之后会每天凌晨执行脚本帮你自动签到，观看，分享，投币视频，你也可以改下执行脚本时间 https://hub.fastgit.org/RayWangQvQ/BiliBiliTool.Docs/blob/main/questions.md ，在运行 bilibili-daily-task.yml 之后， Settings 下Environments 中会自动多出一个名为 Production 的环境，wait timer 填写分钟数。&lt;img data-ratio=&quot;0.574468085106383&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lHKDUzJfR75tzpHzs06Qgicb6gKU95zjRiaDSXHjUPYE9xBPxqjH2mSgJo6Y8XPufML3lXA7rqPEDyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;940&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后每天早上9点左右收到微信通知。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5018315018315018&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lHKDUzJfR75tzpHzs06QgicbD0kziaRo4mXxmRJWt9xTMF9kX1VPOkGl3wlqruDf3bVsEkDMgkcFhcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;819&quot;/&gt;每日奖励也都有了 https://account.bilibili.com/account/home&lt;img data-ratio=&quot;0.34880803011292344&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lHKDUzJfR75tzpHzs06Qgicb5MBuO9Blf8LL6BzpOIKicfXYCrHJ5NpyTPzfkvsNLTYiaPjNpia6q4ahA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;797&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果文章对你有帮助还请 &lt;code&gt;点赞/在看/分享&lt;/code&gt; 三连支持下， 感谢各位！&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;公众号苏生不惑&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.357258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sZeVtjGD4lHKDUzJfR75tzpHzs06QgicbPdQY70eOvUKNZ2pdnr4r0TJgP8ofRzX8TPZdnicibwZiaKwwzuuBPvnzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;扫描二维码关注或搜索微信susheng_buhuo&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;坚持原创不易，点在看支持一下&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5031da8869fc3e57b8d83e657aae72e7</guid>
<title>商业银行安全架构设计实践</title>
<link>https://toutiao.io/k/idcm9zk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tools=&quot;新媒体管家&quot; data-label=&quot;powered by xmt.cn&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;本公众号发布的文章均转载自互联网或经作者投稿授权的原创，文末已注明出处，其内容和图片版权归原网站或作者本人所有，并不代表安世加的观点，若有无意侵权或转载不当之处请联系我们处理，谢谢合作！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;欢迎各位添加微信号：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;asj-jacky&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;加入安世加 交流群 和大佬们一起交流安全技术&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一、重申以业务为中心的安全目标&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;安全架构设计人员首先要了解银行业务，尽管银行业务不断推陈出新，但基本的业务流程变化不大，比如我们从客户旅程的角度针对零售类业务总结了以下流程：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.06614785992217899&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JbibqQoyqGQIcWzZp9t2whxqUys2iaRVXz7d1SkC6HffMrQGbGx05smiciakuj79IlzCTIY5dtTicqKebwDSJkTBcCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;514&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;如上图所示，其中交易包括存款类、贷款类、汇款类和中间业务类等交易，可以说我们日常安全需求分析和设计申请多数来源于上述这些类型的业务需求。安全架构设计的目标并不是要求业务零风险上线，而是通过引入领先的安全技术能力和构建灵活的纵深防御体系，帮助业务在机会和风险中间取得平衡，最终赢得客户和市场。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;二、应用系统风险生命周期管理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;线上应用系统的安全事件除可能对银行自身及客户造成损失外，处理安全事件的过程同样费时费力，成本高昂。为了减少生产事件数量，我们自然很希望在系统上线前即保证其对风险免疫。应用系统的建设过程如同养娃，而系统上线则是将娃养大成人后推向社会，最终成为能够修身，齐家，治国，平天下的有用之人，当然这一切的前提是其能够屏蔽社会上的各类危害的不良影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.8680555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JbibqQoyqGQIcWzZp9t2whxqUys2iaRVXzY63OYMriavc5tkkicDMPzpSTpkWicK13UAbLbwgl37x8gHnJEkb5656XA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p&gt;图 1 风险生命周期管理&lt;/p&gt;&lt;p&gt;&lt;span&gt;三、安全架构设计的定义&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们的目标是保护业务安全，尽管安全架构设计在业界分享不是很多，为了使安全工作降本增效，我们需要摸索推进安全架构设计工作。&lt;/span&gt;&lt;span&gt;在谈安全架构设计的时候我们必须考虑到实战场景的威胁模型和安全属性（如机密性、完整性、可用性、隐私性、真实性等等）组成的安全模型（包括下文提到的5A模型），脱离威胁模型和安全模型空谈绝对安全几乎毫无意义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;四、安全架构设计的价值&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了上面提到的可以实现安全工作降本增效之外，安全架构设计还有以下2个好处：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. &lt;/span&gt;&lt;span&gt;识别体系化的结构缺陷：大多数安全问题是设计缺陷问题，通过安全架构模型全面识别这些体系化设计缺陷，比漏洞测试角度更具整体观，识别风险更为全面，提前减少风险敞口。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. &lt;/span&gt;&lt;span&gt;识别国内外合规要求：由于银行通常涉及跨国分行和海外业务，通过向监管机构和合作伙伴提供产品的风险管理活动的完整记录，帮助开发团队遵守国内或全球法律法规要求如《个人金融信息保护技术规范》、PCI DSS、GDPR等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;五、安全架构设计概述&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;安全架构设计主要从组织人员、管理流程、安全技术三个方面推进工作，组织人员方面需明确人员分工，持续提升人员能力；管控流程上实现安全管控流程左移，特别是安全需求分析和安全设计；安全技术上实现安全能力解耦，确保安全功能的独立性和可复用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、&lt;/span&gt;&lt;span&gt;组织人员&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在进行复杂的安全架构设计时并非一个团队就可以独立完成的，还需要数据安全、IT安全、风控合规、应用架构、网络、隐私保护、法务、运维等多个团队协作，各参与者最好提前建立对基础设施、架构设计规约、应用架构、安全分工的认知，清楚各应用的作用、适用场景、特点、接入办法。&lt;/span&gt;&lt;span&gt;对于实施安全架构设计的负责人有以下基本技术能力要求，其中第2条并不是安全人员的特长而是开发人员的特长，需要较长时间的工作积累：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;a. &lt;/span&gt;&lt;span&gt;熟悉常用的攻击方法、危害、规范要求、安全模型、安全技术、安全机制，加密算法；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;b. &lt;/span&gt;&lt;span&gt;熟悉业务、项目流程、内部技术服务、产品与产品之间、组件和组件之间的关系；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、管控流程&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于外部采购的系统，立项、POC阶段就开展安全需求分析和设计活动；对于自研类的系统，在系统建设初期，参照SDL流程，做好安全需求分析、安全设计、安全方案评审等安全活动，但因为面临工作多、难度大，人员少等问题、所以务必需要对需求分类分级。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;安全需求分析&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;传统的安全一般是分层的，物理安全、网络安全、系统安全、应用安全、数据安全和业务安全，然后再纵向切分，如软件开发安全生命周期、运维纵深防护体系。通常除了数据安全和业务安全需求对开发人员可见外，理论上这两层的安全需求应该是业务需求的一部分，而其他层次的安全需求的可见度并不高，需要进行安全需求分析。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;实施安全需求分析最常用的方法是威胁建模，在研发团队的安全活动中，对于一些拥有重要数据资产、安全事件影响大、攻击暴露面大的系统除了要进行常规的安全测试之外，更应该系统地按迭代版本或定期开展威胁建模活动，&lt;/span&gt;&lt;span&gt;保证这些系统的安全需求分析的覆盖率、及时率和有效率&lt;/span&gt;&lt;span&gt;。因为银行是强监管行业，我们需要定制化威胁建模。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. &lt;/span&gt;&lt;span&gt;识别干系方&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;银行是业务最容易数字化的行业，各种业务都需要信息系统的支持，随着银行应用架构成熟度的提高，通常一个业务需求会涉及到多个业务应用系统。我们应提前识别干系人，干系人包括业务需求人员、业务风控人员、主办系统开发人员、配合系统开发人员、系统对口业务人员等，对干系人的正确全面识别是后续工作顺利开展的前提条件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2. &lt;/span&gt;&lt;span&gt;需求分析&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需求分析这一步骤的输出就是绘制数据流图，数据流图这项技术本身存在的不足是：关注组件的交付是还是相对偏数据流动视角，例如钓鱼等风险不能充分揭示；不能完全表达出应用系统的全部交易，只能关注重点交易；数据流会额外显示出其他安全层引起的风险，并不仅仅是业务自身的应用安全。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对上面这些缺点，需求分析一般包括2个方面，一个是业务方面，一个是技术方面，业务方面首先梳理所有的交易清单并明确是否关键交易，因为不同交易的数据流可能是不一致的。技术方面我们需要梳理出关键链路上的所有节点应用，对每个节点应用进行安全多层分析，分析其层间依赖组件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;3. &lt;/span&gt;&lt;span&gt;合规研判&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;   银行是强监管行业，除了国家标准要求的安全规范外，还有金融行业的各类安全规范，监管规范通常会对银行的各类业务场景给出了明确指导意见，如《网上银行系统信息安全通用规范》对电子银行安全进行了明确，《商业银行应用程序接口安全管理规范》对开放银行等外联类业务安全提出了指导意见。通常银行会将这些规范解读后形成行内的安全规范，这样可以提高合规研判这一步骤的效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;4. &lt;/span&gt;&lt;span&gt;威胁分析&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前业内有STRIDE、Trike、OCTAVE等多种常见威胁分析方法论，有很多可以参考的资料，我们这里不做详细讨论，这里我想提醒大家的是威胁分析的第一步是确认该业务需求是否必需，如非必需建议不做，这样可最大程度降低攻击面。针对银行的常见业务，我们分别梳理了相关的威胁库、需求库、设计库和漏洞库。梳理的威胁风险列表示例如下：&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;业务流程&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;渠道&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;营销&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;开户&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;认证&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;鉴权&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;交易&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;权益&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;客服&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;数据分析&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;常见风险&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;PC、H5、APP、三方渠道、5G消息、公众号、小程序、自助机具&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;薅羊毛&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;冒名开户、交易步骤绕过&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;短信炸弹、人脸替换等、密码加密等。&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;功能越权&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据越权&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;冒名转账、冒名贷款、冒名合同&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;活动达标配置错误&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;视频客服&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;td&gt;&lt;p&gt;&lt;span&gt;个人信息泄露&lt;/span&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;基于数据流图的威胁建模对于业务开发人员来说的门槛还是比较高的，建议开发人员在安全需求分析和安全设计时跳过前面的威胁分析步骤，直接使用安全架构模型，毕竟开发人员更熟悉安全架构模型。安全模型的代表是5A安全模型：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;身份认证（Authentication）：用户主体是谁？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;授权（Authorization）：授予某些用户主体允许或拒绝访问客体的权限。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;访问控制（Access Control）：控制措施以及是否放行的执行者。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;可审计（Auditable）：形成可供追溯的操作日志。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;资产保护（Asset Protection）：资产的保密性、完整性、可用性保障。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们都知道无论哪层的架构都包括三要素：职责明确的模块或者组件、关联关系、约束和指导原则，5A安全模型就是对组件间的交互过程提供保护，当然这种保护是跨安全分层的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;95&quot; data-backw=&quot;415&quot; data-ratio=&quot;0.22875816993464052&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JbibqQoyqGQIcWzZp9t2whxqUys2iaRVXz0MmfdDw4W7hWHXHo4YS9YxQwHZfFFBhC8nx0Uds04AOXKPxBhSrZVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;612&quot;/&gt;&lt;/p&gt;&lt;p&gt;图 2 5A安全模型&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;5. &lt;/span&gt;&lt;span&gt;同类参考&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据保持同一交易在不同渠道的安全机制一致的原则，与现有同类业务场景的安全需求进行相比，保障安全需求的一致性，一方面确保现有的安全需求为我所用，避免遗漏安全需求，另一方面明确现有业务场景在安全需求方面的不足，为后续安全整改奠定基础。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了参考行内同类业务的安全需求之外，我们还可以了解同业机构中同类业务的安全控制机制有哪些，这些信息除了对安全需求分析提供参考之外，还可以帮忙我们与业务人员沟通该项业务需求的可行性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;6. &lt;/span&gt;&lt;span&gt;综合评估&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;安全需求文档的初稿普通要求较为严格，通过召集各干系方沟通，请大家对安全需求清单、安全需求分级结果进行讨论，讨论取舍哪些需求，最终确定安全需求文档终稿，如果各方实在无法达成一致，则申请专家联合评审。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2　 &lt;/span&gt;&lt;span&gt;安全设计&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;针对上述安全需求文档进行方案设计，复用安全设计库的中现有方案，重点关注该应用个性化的安全需求，主要步骤包括：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 回顾&lt;/span&gt;&lt;span&gt;安全设计原则：因为大家都很熟悉这里不做赘述。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2. &lt;/span&gt;&lt;span&gt;了解现有安全设计：包括主办应用、关联应用，如果我们对各应用的情况有所了解，则可以大大提高效率，通过与开发人员面对面访谈了解安全设计现状。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;3. &lt;/span&gt;&lt;span&gt;参考标准安全模型：安全架构设计的一个很重要的原则是标准化设计。认证相关的模型如OIDC、OAuth2、CAS、SAML和Kerberos等，访问控制相关的模型如ACL、RBAC、ABAC等、NIST和CIS发布容器安全指南、IC卡密钥设计、SpringSecurity、Shiro、RKL远程密钥加密、FIDO实现生物识别等。除了业界标准外，目前安全产品的实现机制也是重要参考之一。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;4. &lt;/span&gt;&lt;span&gt;串联安全组件：安全设计的最大价值体现在解决问题上，通常安全设计方案偏向理论说明，落地过程中存在开发人员理解差异等问题，我们日常工作中应该注意收集和规划公共安全组件，在方案中明确引用相关的安全组件，以开发人员熟悉的组件调用方式确保安全方案落地。对于无法使用安全组件满足的安全设计项，还需要与各关联方沟通安全功能的具体分工，以确保方案落地。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;5. &lt;/span&gt;&lt;span&gt;安全方案评审：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    除了客户和业务的显式安全需求外，安全机制通常对易用性、性能等特性产生负面影响，这些影响如果与业务开发团队无法达成一致的话，通常也需要通过专家评审确定最终的安全设计文档。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、安全技术&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;安全功能最理想的状态是与业务功能松耦合，具备相当的独立性，这就要求将安全功能从业务逻辑中剥离出来。安全设计方案的落地离不开安全组件，根据新思科技(Synopsys)发布的BSSIM软件构建成熟度模型要求，不应当让每个项目组自行实施全部的安全功能（例如，身份验证、角色管理、密钥管理、日志记录、密码、协议等等），而应当通过 SSG (软件安全小组)制定或由 SSG (软件安全小组)推动他人制定并发布可供工程技术团队使用的安全性功能来提供前瞻性的指导。这些公共的安全功能被称为安全组件，项目组可受益于SSG预先批准的实施内容，而SSG 则免于重复追踪那些常常处于安全功能之中的细微错误。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.34852801519468185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JbibqQoyqGQIcWzZp9t2whxqUys2iaRVXz2FQD7RBO8wT7oegElEV8fleoTwpWY5iaVIoSlNqianqDLbDY6C48YIhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1053&quot;/&gt;&lt;/p&gt;&lt;p&gt;图 3 使用安全组件前后对比&lt;/p&gt;&lt;p&gt;&lt;span&gt;安全组件的好处有以下几个：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1　 &lt;/span&gt;&lt;span&gt;帮助项目组聚焦业务功能开发，促进提升研发效率，突显安全技术价值。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2　 &lt;/span&gt;&lt;span&gt;协助我行快速满足落实和满足监管规范中的安全技术要求。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;3　 &lt;/span&gt;&lt;span&gt;协助行内安全规范落地，协助安全需求及安全方案落地。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;4　 &lt;/span&gt;&lt;span&gt;指导项目组快速修复常见漏洞问题，避免实现方式缺乏标准的问题，实现源头性整改。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们目前梳理的应用组件视图如下，分为SDK和系统，其中系统还可以根据封装粒度的大小分为原子系统和组合系统：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5273851590106007&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JbibqQoyqGQIcWzZp9t2whxqUys2iaRVXzrcvBX7KECEk7Qd7UxO5QET2pkMahibw8Ndd1S5Qgc9WEz2tbQzBRsKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1132&quot;/&gt;&lt;/p&gt;&lt;p&gt;图 4  公共安全组件统一视图&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;六、经验教训&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1　 &lt;/span&gt;&lt;span&gt;承认双方信息不对称&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果安全人员在与开发人员沟通的过程中不了解他们的基本业务，我们安全人员其实是很被动，沟通效率低，所以我们一方面需要了解基本业务知识，这样才能在业务人员沟通的过程中尽可能少的丢失信息，另一方面我们积极培训业务开发团队中对安全感兴趣的人员，帮助他们掌握安全知识，这样比较简单的安全需求可以由他们自行完成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2　 &lt;/span&gt;&lt;span&gt;正确理解安全左移&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作为软件开发中心的安全人员，虽然理论上我们只需关注应用安全，但在实际操作过程中，作为离应用系统开发人员最近的安全人员我们义不容辞的要承担起其他安全分层中安全左移的工作。如果开发人员在上线前才知道系统的管理端与交易端需要拆分部署，显然为时已晚了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;3　 &lt;/span&gt;&lt;span&gt;以需求为中心而不是以应用系统为中心&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;银行业务的复杂性决定了每个需求都不是由一个系统独立实现，而是一个系统工程，然而我们需求分析时很难组织所有关联系统在一起开会，大多数只能会主办系统的人员沟通业务需求和实现方案，所以往往会遇到对方对很多内容并不清楚的情况，这个时候我们就很难继续下去，只能把问题提出来请他们去搞清楚再评估。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;4　 &lt;/span&gt;&lt;span&gt;仅分析相对高阶的安全需求&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最开始践行安全需求的时候，我们总是想希望做得很全面，于是出具一个很冗长的安全需求，希望这个安全需求一直可以传递到安全测试阶段。这个方式理论上很好，但也丧失了重点，应该不同阶段解决解决不同的安全需求，基础的安全需求靠组件和自动化测试解决，我们应该重点关注这个业务场景中一些相对独特的或薄弱的安全需求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;5　 &lt;/span&gt;&lt;span&gt;与开发人员形成信任&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;开发人员日常开发过程中一定会遇到安全相关的问题，他愿意和你沟通且能帮助他们解决问题的话，双方之间就会逐渐形成信任，信任以后在日常的沟通中开发人员的安全意识就会提高，也就会在这个项目组成为安全的广播员，后续就可以不失时机的安排培训了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;6　 &lt;/span&gt;&lt;span&gt;为啥新增业务需求不能复用存量的安全设计方案。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;a. &lt;/span&gt;&lt;span&gt;随着监管制度法规的完善对业务的安全性提出更高的要求，如国密算法要求；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;b. &lt;/span&gt;&lt;span&gt;公司安全基础设施能力不断提升，为业务提供的公共安全能力不断增强，如之前由应用系统自行实现，目前由公共安全组件统一实现；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;7　 &lt;/span&gt;&lt;span&gt;安全架构设计业内经验分享少。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们采用的思路是眼前灭火与体系建设同时推进的思路开展安全架构设计工作，在灭火期我的主要目标是提高高风险系统的覆盖率和及时率，后续从组织人员、管控流程和安全技术等方面逐步完善体系。&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3fe94919e2e61405665b6e1719a7b790</guid>
<title>该如何理解 Java 中的 Class 类</title>
<link>https://toutiao.io/k/rjmq5lr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;java&lt;/code&gt;里面一切都是类和对象&lt;/p&gt;&lt;p&gt;当我们在程序中要表达&lt;code&gt;书&lt;/code&gt;这个实体时，往往会定义一个&lt;code&gt;Book&lt;/code&gt;类。例如&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Book&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String name;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; price;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String publish;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;reading...&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当我们在程序中要表达&lt;code&gt;车&lt;/code&gt;这个实体时，往往会定义一个&lt;code&gt;Car&lt;/code&gt;类。例如&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Car&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String brand;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; price;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;running...&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;总之不同的实体都会定义不同&lt;code&gt;类&lt;/code&gt;用来表示相关信息。&lt;/p&gt;&lt;p&gt;其实&lt;code&gt;JVM&lt;/code&gt;里面所有的&lt;code&gt;类&lt;/code&gt;本身也是一个实体。每个类都有类名，都有方法名，都有属性名。那么我们用什么来表示这些信息呢？答案就是&lt;code&gt;Class&lt;/code&gt;类。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;为什么需要&lt;code&gt;Class&lt;/code&gt;类。&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;如果想在运行时或者编译时拿到类或者对象的信息；那么必须借助&lt;code&gt;Class&lt;/code&gt;类。运行时获取类型信息可以让我们写出更灵活更强大的程序，比如实现&lt;code&gt;RMI&lt;/code&gt;，动态代理，反射等等。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;举个例子&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;Animal类&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Animal&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{System.out.println(&lt;span&gt;&quot;I&#x27;m &quot;&lt;/span&gt; + &lt;span&gt;this&lt;/span&gt;);}&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;BarkPet接口&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;BarkPet&lt;/span&gt; &lt;/span&gt;{    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;bark&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Dog类&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Dog&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Animal&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BarkPet&lt;/span&gt; &lt;/span&gt;{        &lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;bark&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{       &lt;br/&gt;        System.out.println(&lt;span&gt;&quot;wang wang ...&quot;&lt;/span&gt;); &lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Dog&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Cat类&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Cat&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Animal&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BarkPet&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;bark&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;miao miao ...&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Cat&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Fish类&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Fish&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Animal&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;toString&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Fish&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;AnimalDemo类&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AnimalDemo&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        List&amp;lt;Animal&amp;gt; animals = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Animal&amp;gt;();&lt;br/&gt;        animals.add(&lt;span&gt;new&lt;/span&gt; Dog());&lt;br/&gt;        animals.add(&lt;span&gt;new&lt;/span&gt; Cat());&lt;br/&gt;        animals.add(&lt;span&gt;new&lt;/span&gt; Fish());&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//如果我想找出，小猫和小狗怎么办？&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (Animal animal : animals){&lt;br/&gt;            &lt;span&gt;//??&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于&lt;code&gt;AnimalDemo&lt;/code&gt;类，我想在程序运行的过程中，找到&lt;code&gt;Dog&lt;/code&gt;和&lt;code&gt;Cat&lt;/code&gt;类型的对象，这就是所谓的运行时获取类型信息。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;Class基本介绍&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;每个类都有一个&lt;code&gt;Class&lt;/code&gt;对象。&lt;/p&gt;&lt;p&gt;当我们编写并且编译完成一个类之后，就会自动生成对应的&lt;code&gt;Class&lt;/code&gt;对象(和类同名的&lt;code&gt;.class&lt;/code&gt;文件)。当程序创建第一个对类的静态成员的的引用时，就会加载这个类。&lt;/p&gt;&lt;p&gt;这里有必要说一下类加载过程。&lt;/p&gt;&lt;p&gt;&lt;span&gt;类加载器首先检查这个类的&lt;code&gt;Class&lt;/code&gt;对象是否已经加载，如果尚&lt;/span&gt;未&lt;span&gt;加载，默认的类加载器就会根据类名查找 &lt;/span&gt;&lt;code&gt;.class&lt;/code&gt;&lt;span&gt;文件(也可以自定义类加载器，加载指定路径的&lt;/span&gt;&lt;code&gt;.class&lt;/code&gt;&lt;span&gt;文件，比如数据库，或者网络)。&lt;/span&gt;&lt;span&gt;加载完成后，&lt;/span&gt;&lt;code&gt;JVM&lt;/code&gt;&lt;span&gt;会对其进行验证，确保没有被损坏，且没有不良代码。&lt;/span&gt;&lt;span&gt;一旦某个类的&lt;/span&gt;&lt;code&gt;Class&lt;/code&gt;&lt;span&gt;对象被载入内存，它就可以被用来创建对象了。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;注意：&lt;code&gt;Java&lt;/code&gt;并不是在一开始的时候就把所有的类加载进内存，而是按需加载，也就是在第一次对类的静态成员引用的时候加载。构造器也是类的静态方法。&lt;/p&gt;&lt;/blockquote&gt;&lt;h4&gt;&lt;span&gt;如何使用Class对象&lt;/span&gt;&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Class c = Class.forName(&quot;com.example.demo.Dog&quot;)&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;类字面量 &lt;code&gt;Class c = Dog.class&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;两者区别：通过类字面量的方式创建对&lt;code&gt;Class&lt;/code&gt;对象的引用时，不会自动初始化该&lt;code&gt;Class&lt;/code&gt;对象。&lt;/p&gt;&lt;p&gt;要很好理解两者的区别，还需要了解一个类从加载到可用要经历哪些过程：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;加载，这是由类加载器执行的。该步骤负责查找字节码（通常在&lt;code&gt;classpath&lt;/code&gt;所指定的路径中查找，但并非必须），并从这些字节码中创建一个&lt;code&gt;Class&lt;/code&gt;对象。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;链接，在链接阶段将验证类中的字节码，为&lt;code&gt;static&lt;/code&gt;字段分配存储空间，并且如果需要的话，将解析这个类创建的对其它类的所有引用。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;初始化，如果该类具有超类，则先初始化超类，执行&lt;code&gt;static&lt;/code&gt;初始化器和&lt;code&gt;static&lt;/code&gt;初始化块。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;下面通过一段简单的demo代码来对&lt;code&gt;Class&lt;/code&gt;类的应用做一个简单的说明。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;//获取Class引用方式1&lt;/span&gt;&lt;br/&gt;            Class dog1 = Class.forName(&lt;span&gt;&quot;com.example.demo.Dog&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;//获取Class引用方式2&lt;/span&gt;&lt;br/&gt;            Dog dogObj = &lt;span&gt;new&lt;/span&gt; Dog();&lt;br/&gt;            Class dog2 = dogObj.getClass();&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;//获取Class引用方式3&lt;/span&gt;&lt;br/&gt;            Class dog3 = Dog&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;//name = com.example.demo.Dog&lt;/span&gt;&lt;br/&gt;            String name = dog1.getName();&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;//dogSuperClass = com.example.demo.Animal&lt;/span&gt;&lt;br/&gt;            Class dogSuperClass = dog1.getSuperclass();&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;// dogInterface[0] = interface com.example.demo.BarkPet&lt;/span&gt;&lt;br/&gt;            Class[] dogInterface = dog1.getInterfaces();&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;//dogAnnotations = null&lt;/span&gt;&lt;br/&gt;            Annotation[] dogAnnotations = dog1.getAnnotations();&lt;br/&gt;            &lt;br/&gt;            Field[] dogFields = dog1.getFields();&lt;br/&gt;            Constructor[] dogConstructors =  dog1.getConstructors();&lt;br/&gt;            Method[] methods = dog1.getMethods();&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (Method method : methods){&lt;br/&gt;                &lt;span&gt;//通过反射调用Dog的bark方法&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (method.getName() == &lt;span&gt;&quot;bark&quot;&lt;/span&gt;){&lt;br/&gt;                    method.invoke(dogObj);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (ClassNotFoundException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IllegalAccessException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InvocationTargetException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//如果我想找出，小猫和小狗怎么办？&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (Animal animal : animals) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (animal &lt;span&gt;instanceof&lt;/span&gt; Dog){&lt;br/&gt;                &lt;span&gt;//成功拿到Dog类型对象&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (Dog&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;.&lt;span&gt;isInstance&lt;/span&gt;(&lt;span&gt;animal&lt;/span&gt;))&lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;//成功拿到Dog类型对象&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;总之当你想在运行时获取类型信息，或者编译的过程中拿到类型信息，一定要想到&lt;code&gt;Class&lt;/code&gt;。&lt;code&gt;Class&lt;/code&gt;是用来表示所有类型信息的类。&lt;code&gt;Spring Framework&lt;/code&gt;里面很多重要功能都借助了该知识点的应用，比如&lt;code&gt;IOC&lt;/code&gt;，&lt;code&gt;AOP&lt;/code&gt;等等，想深入了解可以多参考&lt;code&gt;Spring&lt;/code&gt;的源码和相关文档。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247484022&amp;amp;idx=1&amp;amp;sn=d3176ea73e48360b64c3f50e8fd622bf&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;1. Java并发编程那些事儿(十)——最后的总结&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247484092&amp;amp;idx=1&amp;amp;sn=5618300d2182d57bc3af6751fdc21fd1&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;2. 不会使用虚拟机的程序员不是好程序员&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247483893&amp;amp;idx=1&amp;amp;sn=85f6a2063048cc244aedde3172444e32&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;3. Awk这件上古神兵你会用了吗&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzMzE4MDY0Nw==&amp;amp;mid=2247483852&amp;amp;idx=1&amp;amp;sn=6efb0db3d5dff639fae2aaec978c2160&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;4. 手把手教你搭建一套ELK日志搜索运维平台&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>