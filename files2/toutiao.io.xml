<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ae4ab3593caff2642ad63757ec5a9735</guid>
<title>Redis 很屌，不懂使用规范就糟蹋了</title>
<link>https://toutiao.io/k/lpnakbk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;这可能是最中肯的 Redis 使用规范了&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;码哥，昨天我被公司 Leader 批评了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我在单身红娘婚恋类型互联网公司工作，在双十一推出下单就送女朋友的活动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;谁曾想，凌晨 12 点之后，用户量暴增，出现了一个技术故障，用户无法下单，当时老大火冒三丈！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过查找发现 Redis 报 &lt;code&gt;Could not get a resource from the pool&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取不到连接资源，并且集群中的单台 Redis 连接量很高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是各种更改最大连接数、连接等待数，虽然报错信息频率有所缓解，但还是&lt;strong&gt;持续报错&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来经过线下测试，发现存放 Redis 中的&lt;strong&gt;字符数据很大，平均 1s 返回数据&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;码哥，可以分享下使用 Redis 的规范么？我想做一个唯快不破的真男人！&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 使用规范围绕如下几个纬度展开：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;键值对使用规范；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;命令使用规范；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据保存规范；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;运维规范。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;键值对使用规范&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有两点需要注意：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;好的 &lt;code&gt;key&lt;/code&gt; 命名，才能提供可读性强、可维护性高的 key，便于定位问题和寻找数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;value&lt;/code&gt;要避免出现 &lt;code&gt;bigkey&lt;/code&gt;、选择高效的序列化和压缩、使用对象共享池、选择高效恰当的数据类型（可参考《Redis 实战篇：巧用数据类型实现亿级数据统计》）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;key 命名规范&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;规范的 &lt;code&gt;key&lt;/code&gt;命名，在遇到问题的时候能够方便定位。Redis 属于 没有 &lt;code&gt;Scheme&lt;/code&gt;的 &lt;code&gt;NoSQL&lt;/code&gt;数据库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以要靠规范来建立其 &lt;code&gt;Scheme&lt;/code&gt; 语意，就好比根据不同的场景我们建立不同的数据库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;敲黑板&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把「业务模块名」作为前缀（好比数据库 &lt;code&gt;Scheme&lt;/code&gt;），通过「冒号」分隔，再加上「具体业务名」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样我们就可以通过 &lt;code&gt;key&lt;/code&gt; 前缀来区分不同的业务数据，清晰明了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结起来就是：「业务名:表名:id」&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们要统计公众号属于技术类型的博主「码哥字节」的粉丝数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;set&lt;/span&gt; 公众号:技术类:码哥字节 100000&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;码哥，key 太长的话有什么问题么？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;key 是字符串，底层的数据结构是 &lt;code&gt;SDS&lt;/code&gt;，SDS 结构中会包含字符串长度、分配空间大小等元数据信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;字符串长度增加，SDS 的元数据也会占用更多的内存空间。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以当字符串太长的时候，我们可以采用适当缩写的形式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;不要使用 bigkey&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;码哥，我就中招了，导致报错获取不到连接。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;因为 Redis 是单线程执行读写指令，如果出现&lt;code&gt;bigkey&lt;/code&gt; 的读写操作就会阻塞线程，降低 Redis 的处理效率。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;bigkey&lt;/code&gt;包含两种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;键值对的 &lt;code&gt;value&lt;/code&gt;很大，比如 &lt;code&gt;value&lt;/code&gt;保存了 &lt;code&gt;2MB&lt;/code&gt;的 &lt;code&gt;String&lt;/code&gt;数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;键值对的 &lt;code&gt;value&lt;/code&gt;是集合类型，元素很多，比如保存了 5 万个元素的 &lt;code&gt;List&lt;/code&gt; 集合。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然 Redis 官方说明了 &lt;code&gt;key&lt;/code&gt;和&lt;code&gt;string&lt;/code&gt;类型 &lt;code&gt;value&lt;/code&gt;限制均为&lt;code&gt;512MB&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;防止网卡流量、慢查询，&lt;code&gt;string&lt;/code&gt;类型控制在&lt;code&gt;10KB&lt;/code&gt;以内，&lt;code&gt;hash、list、set、zset&lt;/code&gt;元素个数不要超过 5000。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;码哥，如果业务数据就是这么大咋办？比如保存的是《金瓶梅》这个大作。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还可以通过 &lt;code&gt;gzip&lt;/code&gt; 数据压缩来减小数据大小:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 使用gzip压缩字符串&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String &lt;span&gt;compress&lt;/span&gt;&lt;span&gt;(String str)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (str == &lt;span&gt;null&lt;/span&gt; || str.length() == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; str;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; (ByteArrayOutputStream out = &lt;span&gt;new&lt;/span&gt; ByteArrayOutputStream();&lt;br/&gt;    GZIPOutputStream gzip = &lt;span&gt;new&lt;/span&gt; GZIPOutputStream(out)) {&lt;br/&gt;        gzip.write(str.getBytes());&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;        e.printStackTrace();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; sun.misc.BASE64Encoder().encode(out.toByteArray());&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;/**&lt;br/&gt; * 使用gzip解压缩&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String &lt;span&gt;uncompress&lt;/span&gt;&lt;span&gt;(String compressedStr)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (compressedStr == &lt;span&gt;null&lt;/span&gt; || compressedStr.length() == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; compressedStr;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;byte&lt;/span&gt;[] compressed = &lt;span&gt;new&lt;/span&gt; sun.misc.BASE64Decoder().decodeBuffer(compressedStr);;&lt;br/&gt;    String decompressed = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; (ByteArrayOutputStream out = &lt;span&gt;new&lt;/span&gt; ByteArrayOutputStream();&lt;br/&gt;    ByteArrayInputStream in = &lt;span&gt;new&lt;/span&gt; ByteArrayInputStream(compressed);&lt;br/&gt;    GZIPInputStream ginzip = &lt;span&gt;new&lt;/span&gt; GZIPInputStream(in);) {&lt;br/&gt;        &lt;span&gt;byte&lt;/span&gt;[] buffer = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;1024&lt;/span&gt;];&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; offset = -&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; ((offset = ginzip.read(buffer)) != -&lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;            out.write(buffer, &lt;span&gt;0&lt;/span&gt;, offset);&lt;br/&gt;        }&lt;br/&gt;        decompressed = out.toString();&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;        e.printStackTrace();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; decompressed;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;集合类型&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果集合类型的元素的确很多，我们可以将一个大集合拆分成多个小集合来保存。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用高效序列化和压缩方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了节省内存，我们可以使用高效的序列化方法和压缩方法去减少 &lt;code&gt;value&lt;/code&gt;的大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;protostuff&lt;/code&gt;和 &lt;code&gt;kryo&lt;/code&gt;这两种序列化方法，就要比 &lt;code&gt;Java&lt;/code&gt;内置的序列化方法效率更高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述的两种序列化方式虽然省内存，但是序列化后都是二进制数据，可读性太差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常我们会序列化成 &lt;code&gt;JSON&lt;/code&gt;或者 &lt;code&gt;XML&lt;/code&gt;，为了避免数据占用空间大，我们可以使用压缩工具（snappy、 gzip）将数据压缩再存到 Redis 中。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用整数对象共享池&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 内部维护了 0 到 9999 这 1 万个整数对象，并把这些整数作为一个共享池使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使大量键值对保存了 0 到 9999 范围内的整数，在 Redis 实例中，其实只保存了一份整数对象，可以节省内存空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，有两种情况是不生效的：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Redis 中设置了 &lt;code&gt;maxmemory&lt;/code&gt;，而且启用了 &lt;code&gt;LRU&lt;/code&gt;策略（&lt;code&gt;allkeys-lru 或 volatile-lru 策略&lt;/code&gt;），那么，整数对象共享池就无法使用了。&lt;/p&gt;&lt;blockquote&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;这是因为 LRU 需要统计每个键值对的使用时间，如果不同的键值对都复用一个整数对象就无法统计了。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果集合类型数据采用 ziplist 编码，而集合元素是整数，这个时候，也不能使用共享池。&lt;/p&gt;&lt;blockquote&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;因为 ziplist 使用了紧凑型内存结构，判断整数对象的共享情况效率低。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;命令使用规范&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有的命令的执行会造成很大的性能问题，我们需要格外注意。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;生产禁用的指令&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Redis 是单线程处理请求操作，如果我们执行一些涉及大量操作、耗时长的命令，就会严重阻塞主线程，导致其它请求无法得到正常处理。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;KEYS：该命令需要对 Redis 的全局哈希表进行全表扫描，严重阻塞 Redis 主线程；&lt;/p&gt;&lt;blockquote&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;应该使用 SCAN 来代替，分批返回符合条件的键值对，避免主线程阻塞。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;FLUSHALL：删除 Redis 实例上的所有数据，如果数据量很大，会严重阻塞 Redis 主线程；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;FLUSHDB，删除当前数据库中的数据，如果数据量很大，同样会阻塞 Redis 主线程。&lt;/p&gt;&lt;blockquote&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;加上 ASYNC 选项，让 FLUSHALL，FLUSHDB 异步执行。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也可以直接禁用，用&lt;code&gt;rename-command&lt;/code&gt;命令在配置文件中对这些命令进行重命名，让客户端无法使用这些命令。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;慎用 MONITOR 命令&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MONITOR 命令会把监控到的内容持续写入输出缓冲区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果线上命令的操作很多，输出缓冲区很快就会溢出了，这就会对 Redis 性能造成影响，甚至引起服务崩溃。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，除非十分需要监测某些命令的执行（例如，Redis 性能突然变慢，我们想查看下客户端执行了哪些命令）我们才使用。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;慎用全量操作命令&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如获取集合中的所有元素（HASH 类型的 hgetall、List 类型的 lrange、Set 类型的 smembers、zrange 等命令）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些操作会对整个底层数据结构进行全量扫描 ，导致阻塞 Redis 主线程。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;码哥，如果业务场景就是需要获取全量数据咋办？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有两个方式可以解决：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用 &lt;code&gt;SSCAN、HSCAN&lt;/code&gt;等命令分批返回集合数据；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;把大集合拆成小集合，比如按照时间、区域等划分。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据保存规范&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;冷热数据分离&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然 Redis 支持使用 RDB 快照和 AOF 日志持久化保存数据，但是，这两个机制都是用来提供数据可靠性保证的，并不是用来扩充数据容量的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要什么数据都存在 Redis，应该作为缓存保存&lt;strong&gt;热数据&lt;/strong&gt;，这样既可以充分利用 Redis 的高性能特性，还可以把宝贵的内存资源用在服务热数据上。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;业务数据隔离&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要将不相关的数据业务都放到一个 Redis 中。一方面避免业务相互影响，另一方面避免单实例膨胀，并能在故障时降低影响面，快速恢复。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;设置过期时间&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在数据保存时，我建议你根据业务使用数据的时长，设置数据的过期时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写入 Redis 的数据会一直占用内存，如果数据持续增多，就可能达到机器的内存上限，造成内存溢出，导致服务崩溃。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;控制单实例的内存容量&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建议设置在 2~6 GB 。这样一来，无论是 RDB 快照，还是主从集群进行数据同步，都能很快完成，不会阻塞正常请求的处理。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;防止缓存雪崩&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;避免集中过期 key 导致缓存雪崩。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;码哥，什么是缓存雪崩？&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当某一个时刻出现大规模的缓存失效的情况，那么就会导致大量的请求直接打在数据库上面，导致数据库压力巨大，如果在高并发的情况下，可能瞬间就会导致数据库宕机。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;运维规范&lt;/span&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用 Cluster 集群或者哨兵集群，做到高可用；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;实例设置最大连接数，防止过多客户端连接导致实例负载过高，影响性能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不开启 AOF 或开启 AOF 配置为每秒刷盘，避免磁盘 IO 拖慢 Redis 性能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置合理的 repl-backlog，降低主从全量同步的概率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设置合理的 slave client-output-buffer-limit，避免主从复制中断情况发生。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;根据实际场景设置合适的内存淘汰策略。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用连接池操作 Redis。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU0OTE4MzYzMw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/fEsWkVrSk55KKLFaGCDRURMvFtPXf9fZXJOHOFsA3Ye8Qbibf3qHLkBQNpdjicAVpPf2T03EcakjAFbwqicjXSibXA/0?wx_fmt=png&quot; data-nickname=&quot;架构师社区&quot; data-alias=&quot;devabc&quot; data-signature=&quot;架构师社区，专注分享架构师技术干货，架构师行业秘闻，汇集各类奇妙好玩的架构师话题和流行的架构师动向！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9263075a9f04b2b9566570f86898ac75</guid>
<title>带你十天轻松搞定 Go 微服务系列（一）</title>
<link>https://toutiao.io/k/cm7r81b</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文开始，我们会出一个系列文章跟大家详细展示一个 go-zero 微服务示例，整个系列分十篇文章，目录结构如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;环境搭建（本文）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务拆分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;产品服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;订单服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支付服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;RPC 服务 Auth 验证&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务监控&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;链路追踪&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分布式事务&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;期望通过本系列带你在本机利用 Docker 环境利用 go-zero 快速开发一个商城系统，让你快速上手微服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整示例代码：https://github.com/nivin-studio/go-zero-mall&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1 环境要求&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Golang&lt;/code&gt; 1.15+&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Etcd&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Redis&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Mysql&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Prometheus&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Grafana&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Jaeger&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;DTM&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2 &lt;code&gt;Docker&lt;/code&gt; 本地开发环境搭建&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了方便开发调试，我们使用 &lt;code&gt;Docker&lt;/code&gt; 构建本地开发环境。&lt;code&gt;Windows&lt;/code&gt; 和 &lt;code&gt;macOS&lt;/code&gt; 系统可下载 &lt;code&gt;Docker Desktop&lt;/code&gt; 安装使用，具体下载安装方法可自行搜索相关教程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们使用 &lt;code&gt;Docker Compose&lt;/code&gt; 来编排管理我们的容器，创建如下目录：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;gonivinck&lt;br/&gt;├── dtm                   &lt;span&gt;# DTM 分布式事务管理器&lt;/span&gt;&lt;br/&gt;│   ├── config.yml        &lt;span&gt;# DTM 配置文件&lt;/span&gt;&lt;br/&gt;│   └── Dockerfile&lt;br/&gt;├── etcd                  &lt;span&gt;# Etcd 服务注册发现&lt;/span&gt;&lt;br/&gt;│   └── Dockerfile&lt;br/&gt;├── golang                &lt;span&gt;# Golang 运行环境&lt;/span&gt;&lt;br/&gt;│   └── Dockerfile&lt;br/&gt;├── grafana               &lt;span&gt;# Grafana 可视化数据监控&lt;/span&gt;&lt;br/&gt;│   └── Dockerfile&lt;br/&gt;├── jaeger                &lt;span&gt;# Jaeger 链路追踪&lt;/span&gt;&lt;br/&gt;│   └── Dockerfile&lt;br/&gt;├── mysql                 &lt;span&gt;# Mysql 服务&lt;/span&gt;&lt;br/&gt;│   └── Dockerfile&lt;br/&gt;├── mysql-manage          &lt;span&gt;# Mysql 可视化管理&lt;/span&gt;&lt;br/&gt;│   └── Dockerfile&lt;br/&gt;├── prometheus            &lt;span&gt;# Prometheus 服务监控&lt;/span&gt;&lt;br/&gt;│   ├── Dockerfile&lt;br/&gt;│   └── prometheus.yml    &lt;span&gt;# Prometheus 配置文件&lt;/span&gt;&lt;br/&gt;├── redis                 &lt;span&gt;# Redis 服务&lt;/span&gt;&lt;br/&gt;│   └── Dockerfile&lt;br/&gt;├── redis-manage          &lt;span&gt;# Redis 可视化管理&lt;/span&gt;&lt;br/&gt;│   └── Dockerfile&lt;br/&gt;├── .env                  &lt;span&gt;# env 配置&lt;/span&gt;&lt;br/&gt;└── docker-compose.yml&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 编写 &lt;code&gt;Dockerfile&lt;/code&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;go-zero&lt;/code&gt; 的微服务中采用 &lt;code&gt;grpc&lt;/code&gt; 进行服务间的通信，而 &lt;code&gt;grpc&lt;/code&gt; 的编写就需要用到 &lt;code&gt;protoc&lt;/code&gt; 和翻译成 &lt;code&gt;go&lt;/code&gt; 语言 &lt;code&gt;rpc stub&lt;/code&gt; 代码的插件 &lt;code&gt;protoc-gen-go&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了提高开发效率，减少代码的出错率，缩短业务开发的工作量，&lt;code&gt;go-zero&lt;/code&gt; 还提供了 &lt;code&gt;goctl&lt;/code&gt; 代码生成工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，我们需要将 &lt;code&gt;protoc&lt;/code&gt;, &lt;code&gt;protoc-gen-go&lt;/code&gt;, &lt;code&gt;goctl&lt;/code&gt;, 给提前安装到 &lt;code&gt;golang&lt;/code&gt; 的容器中，以便后续使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 &lt;code&gt;golang&lt;/code&gt; 容器的 &lt;code&gt;Dockerfile&lt;/code&gt; 代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;FROM&lt;/span&gt; golang:&lt;span&gt;1.17&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;LABEL&lt;/span&gt;&lt;span&gt; maintainer=&lt;span&gt;&quot;Ving &amp;lt;ving@nivin.cn&amp;gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;ENV&lt;/span&gt; GOPROXY https://goproxy.cn,direct&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 安装必要的软件包和依赖包&lt;/span&gt;&lt;br/&gt;&lt;span&gt;USER&lt;/span&gt; root&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; sed -i &lt;span&gt;&#x27;s/deb.debian.org/mirrors.tuna.tsinghua.edu.cn/&#x27;&lt;/span&gt; /etc/apt/sources.list &amp;amp;&amp;amp; \&lt;br/&gt;    sed -i &lt;span&gt;&#x27;s/security.debian.org/mirrors.tuna.tsinghua.edu.cn/&#x27;&lt;/span&gt; /etc/apt/sources.list &amp;amp;&amp;amp; \&lt;br/&gt;    sed -i &lt;span&gt;&#x27;s/security-cdn.debian.org/mirrors.tuna.tsinghua.edu.cn/&#x27;&lt;/span&gt; /etc/apt/sources.list &amp;amp;&amp;amp; \&lt;br/&gt;    apt-get update &amp;amp;&amp;amp; \&lt;br/&gt;    apt-get upgrade -y &amp;amp;&amp;amp; \&lt;br/&gt;    apt-get install -y --no-install-recommends \&lt;br/&gt;    curl \&lt;br/&gt;    zip \&lt;br/&gt;    unzip \&lt;br/&gt;    git \&lt;br/&gt;    vim &lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 安装 goctl&lt;/span&gt;&lt;br/&gt;&lt;span&gt;USER&lt;/span&gt; root&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; GOPROXY=https://goproxy.cn/,direct go install github.com/tal-tech/go-zero/tools/goctl@cli&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 安装 protoc&lt;/span&gt;&lt;br/&gt;&lt;span&gt;USER&lt;/span&gt; root&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; curl -L -o /tmp/protoc.zip https://github.com/protocolbuffers/protobuf/releases/download/v3.19.1/protoc-3.19.1-linux-x86_64.zip &amp;amp;&amp;amp; \&lt;br/&gt;    unzip -d /tmp/protoc /tmp/protoc.zip &amp;amp;&amp;amp; \&lt;br/&gt;    mv /tmp/protoc/bin/protoc &lt;span&gt;$GOPATH&lt;/span&gt;/bin&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 安装 protoc-gen-go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;USER&lt;/span&gt; root&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; go get -u github.com/golang/protobuf/protoc-gen-go@v1.4.0&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# $GOPATH/bin添加到环境变量中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ENV&lt;/span&gt; PATH $GOPATH/bin:$PATH&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 清理垃圾&lt;/span&gt;&lt;br/&gt;&lt;span&gt;USER&lt;/span&gt; root&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt;&lt;span&gt; apt-get clean &amp;amp;&amp;amp; \&lt;br/&gt;    rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/* &amp;amp;&amp;amp; \&lt;br/&gt;    rm /var/&lt;span&gt;log&lt;/span&gt;/lastlog /var/&lt;span&gt;log&lt;/span&gt;/faillog&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 设置工作目录&lt;/span&gt;&lt;br/&gt;&lt;span&gt;WORKDIR&lt;/span&gt;&lt;span&gt; /usr/src/code&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;EXPOSE&lt;/span&gt; &lt;span&gt;8000&lt;/span&gt;&lt;br/&gt;&lt;span&gt;EXPOSE&lt;/span&gt; &lt;span&gt;8001&lt;/span&gt;&lt;br/&gt;&lt;span&gt;EXPOSE&lt;/span&gt; &lt;span&gt;8002&lt;/span&gt;&lt;br/&gt;&lt;span&gt;EXPOSE&lt;/span&gt; &lt;span&gt;8003&lt;/span&gt;&lt;br/&gt;&lt;span&gt;EXPOSE&lt;/span&gt; &lt;span&gt;9000&lt;/span&gt;&lt;br/&gt;&lt;span&gt;EXPOSE&lt;/span&gt; &lt;span&gt;9001&lt;/span&gt;&lt;br/&gt;&lt;span&gt;EXPOSE&lt;/span&gt; &lt;span&gt;9002&lt;/span&gt;&lt;br/&gt;&lt;span&gt;EXPOSE&lt;/span&gt; &lt;span&gt;9003&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他服务容器 &lt;code&gt;Dockerfile&lt;/code&gt; 无需特殊处理，只要基于现有的镜像即可。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;服务&lt;/th&gt;&lt;th&gt;基于的镜像&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;DTM&lt;/td&gt;&lt;td&gt;yedf/dtm&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Etcd&lt;/td&gt;&lt;td&gt;bitnami/etcd&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Mysql&lt;/td&gt;&lt;td&gt;mysql:5.7&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Redis&lt;/td&gt;&lt;td&gt;redis:5.0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Mysql Manage&lt;/td&gt;&lt;td&gt;phpmyadmin/phpmyadmin&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Redis Manage&lt;/td&gt;&lt;td&gt;erikdubbelboer/phpredisadmin&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Prometheus&lt;/td&gt;&lt;td&gt;bitnami/prometheus&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Grafana&lt;/td&gt;&lt;td&gt;grafana/grafana&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Jaeger&lt;/td&gt;&lt;td&gt;jaegertracing/all-in-one:1.28&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 编写 &lt;code&gt;.env&lt;/code&gt; 配置文件&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# 设置时区&lt;/span&gt;&lt;br/&gt;TZ=Asia/Shanghai&lt;br/&gt;&lt;span&gt;# 设置网络模式&lt;/span&gt;&lt;br/&gt;NETWORKS_DRIVER=bridge&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# PATHS ##########################################&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 宿主机上代码存放的目录路径&lt;/span&gt;&lt;br/&gt;CODE_PATH_HOST=./code&lt;br/&gt;&lt;span&gt;# 宿主机上Mysql Reids数据存放的目录路径&lt;/span&gt;&lt;br/&gt;DATA_PATH_HOST=./data&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# MYSQL ##########################################&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Mysql 服务映射宿主机端口号，可在宿主机127.0.0.1:3306访问&lt;/span&gt;&lt;br/&gt;MYSQL_PORT=3306&lt;br/&gt;MYSQL_USERNAME=admin&lt;br/&gt;MYSQL_PASSWORD=123456&lt;br/&gt;MYSQL_ROOT_PASSWORD=123456&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Mysql 可视化管理用户名称，同 MYSQL_USERNAME&lt;/span&gt;&lt;br/&gt;MYSQL_MANAGE_USERNAME=admin&lt;br/&gt;&lt;span&gt;# Mysql 可视化管理用户密码，同 MYSQL_PASSWORD&lt;/span&gt;&lt;br/&gt;MYSQL_MANAGE_PASSWORD=123456&lt;br/&gt;&lt;span&gt;# Mysql 可视化管理ROOT用户密码，同 MYSQL_ROOT_PASSWORD&lt;/span&gt;&lt;br/&gt;MYSQL_MANAGE_ROOT_PASSWORD=123456&lt;br/&gt;&lt;span&gt;# Mysql 服务地址&lt;/span&gt;&lt;br/&gt;MYSQL_MANAGE_CONNECT_HOST=mysql&lt;br/&gt;&lt;span&gt;# Mysql 服务端口号&lt;/span&gt;&lt;br/&gt;MYSQL_MANAGE_CONNECT_PORT=3306&lt;br/&gt;&lt;span&gt;# Mysql 可视化管理映射宿主机端口号，可在宿主机127.0.0.1:1000访问&lt;/span&gt;&lt;br/&gt;MYSQL_MANAGE_PORT=1000&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# REDIS ##########################################&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Redis 服务映射宿主机端口号，可在宿主机127.0.0.1:6379访问&lt;/span&gt;&lt;br/&gt;REDIS_PORT=6379&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# Redis 可视化管理用户名称&lt;/span&gt;&lt;br/&gt;REDIS_MANAGE_USERNAME=admin&lt;br/&gt;&lt;span&gt;# Redis 可视化管理用户密码&lt;/span&gt;&lt;br/&gt;REDIS_MANAGE_PASSWORD=123456&lt;br/&gt;&lt;span&gt;# Redis 服务地址&lt;/span&gt;&lt;br/&gt;REDIS_MANAGE_CONNECT_HOST=redis&lt;br/&gt;&lt;span&gt;# Redis 服务端口号&lt;/span&gt;&lt;br/&gt;REDIS_MANAGE_CONNECT_PORT=6379&lt;br/&gt;&lt;span&gt;# Redis 可视化管理映射宿主机端口号，可在宿主机127.0.0.1:2000访问&lt;/span&gt;&lt;br/&gt;REDIS_MANAGE_PORT=2000&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# ETCD ###########################################&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Etcd 服务映射宿主机端口号，可在宿主机127.0.0.1:2379访问&lt;/span&gt;&lt;br/&gt;ETCD_PORT=2379&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# PROMETHEUS #####################################&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Prometheus 服务映射宿主机端口号，可在宿主机127.0.0.1:3000访问&lt;/span&gt;&lt;br/&gt;PROMETHEUS_PORT=3000&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# GRAFANA ########################################&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Grafana 服务映射宿主机端口号，可在宿主机127.0.0.1:4000访问&lt;/span&gt;&lt;br/&gt;GRAFANA_PORT=4000&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# JAEGER #########################################&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Jaeger 服务映射宿主机端口号，可在宿主机127.0.0.1:5000访问&lt;/span&gt;&lt;br/&gt;JAEGER_PORT=5000&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# DTM #########################################&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# DTM HTTP 协议端口号&lt;/span&gt;&lt;br/&gt;DTM_HTTP_PORT=36789&lt;br/&gt;&lt;span&gt;# DTM gRPC 协议端口号&lt;/span&gt;&lt;br/&gt;DTM_GRPC_PORT=36790&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 编写 &lt;code&gt;docker-compose.yml&lt;/code&gt; 配置文件&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;version:&lt;/span&gt; &lt;span&gt;&#x27;3.5&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 网络配置&lt;/span&gt;&lt;br/&gt;&lt;span&gt;networks:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;backend:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;driver:&lt;/span&gt; &lt;span&gt;${NETWORKS_DRIVER}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 服务容器配置&lt;/span&gt;&lt;br/&gt;&lt;span&gt;services:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;golang:&lt;/span&gt;                                &lt;span&gt;# 自定义容器名称&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;build:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;context:&lt;/span&gt; &lt;span&gt;./golang&lt;/span&gt;                  &lt;span&gt;# 指定构建使用的 Dockerfile 文件&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;environment:&lt;/span&gt;                         &lt;span&gt;# 设置环境变量&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;TZ=${TZ}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;volumes:&lt;/span&gt;                             &lt;span&gt;# 设置挂载目录&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;${CODE_PATH_HOST}:/usr/src/code&lt;/span&gt;  &lt;span&gt;# 引用 .env 配置中 CODE_PATH_HOST 变量，将宿主机上代码存放的目录挂载到容器中 /usr/src/code 目录&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;ports:&lt;/span&gt;                               &lt;span&gt;# 设置端口映射&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;8000:8000&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;8001:8001&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;8002:8002&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;8003:8003&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;9000:9000&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;9001:9001&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;9002:9002&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;9003:9003&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;stdin_open:&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;                     &lt;span&gt;# 打开标准输入，可以接受外部输入&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;tty:&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;networks:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;backend&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;restart:&lt;/span&gt; &lt;span&gt;always&lt;/span&gt;                      &lt;span&gt;# 指定容器退出后的重启策略为始终重启&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;etcd:&lt;/span&gt;                                  &lt;span&gt;# 自定义容器名称&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;build:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;context:&lt;/span&gt; &lt;span&gt;./etcd&lt;/span&gt;                    &lt;span&gt;# 指定构建使用的 Dockerfile 文件&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;environment:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;TZ=${TZ}&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;ALLOW_NONE_AUTHENTICATION=yes&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;ports:&lt;/span&gt;                               &lt;span&gt;# 设置端口映射&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;${ETCD_PORT}:2379&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;networks:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;backend&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;restart:&lt;/span&gt; &lt;span&gt;always&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;mysql:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;build:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;context:&lt;/span&gt; &lt;span&gt;./mysql&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;environment:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;TZ=${TZ}&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;MYSQL_USER=${MYSQL_USERNAME}&lt;/span&gt;                  &lt;span&gt;# 设置 Mysql 用户名称&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;MYSQL_PASSWORD=${MYSQL_PASSWORD}&lt;/span&gt;              &lt;span&gt;# 设置 Mysql 用户密码&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;MYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}&lt;/span&gt;    &lt;span&gt;# 设置 Mysql root 用户密码&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;volumes:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;${DATA_PATH_HOST}/mysql:/var/lib/mysql&lt;/span&gt;        &lt;span&gt;# 引用 .env 配置中 DATA_PATH_HOST 变量，将宿主机上存放 Mysql 数据的目录挂载到容器中 /var/lib/mysql 目录&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;${MYSQL_PORT}:3306&quot;&lt;/span&gt;                          &lt;span&gt;# 设置容器3306端口映射指定宿主机端口&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;networks:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;backend&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;restart:&lt;/span&gt; &lt;span&gt;always&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;redis:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;build:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;context:&lt;/span&gt; &lt;span&gt;./redis&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;environment:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;TZ=${TZ}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;volumes:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;${DATA_PATH_HOST}/redis:/data&lt;/span&gt;                 &lt;span&gt;# 引用 .env 配置中 DATA_PATH_HOST 变量，将宿主机上存放 Redis 数据的目录挂载到容器中 /data 目录&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;${REDIS_PORT}:6379&quot;&lt;/span&gt;                          &lt;span&gt;# 设置容器6379端口映射指定宿主机端口&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;networks:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;backend&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;restart:&lt;/span&gt; &lt;span&gt;always&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;mysql-manage:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;build:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;context:&lt;/span&gt; &lt;span&gt;./mysql-manage&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;environment:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;TZ=${TZ}&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;PMA_ARBITRARY=1&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;MYSQL_USER=${MYSQL_MANAGE_USERNAME}&lt;/span&gt;               &lt;span&gt;# 设置连接的 Mysql 服务用户名称&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;MYSQL_PASSWORD=${MYSQL_MANAGE_PASSWORD}&lt;/span&gt;           &lt;span&gt;# 设置连接的 Mysql 服务用户密码&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;MYSQL_ROOT_PASSWORD=${MYSQL_MANAGE_ROOT_PASSWORD}&lt;/span&gt; &lt;span&gt;# 设置连接的 Mysql 服务 root 用户密码&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;PMA_HOST=${MYSQL_MANAGE_CONNECT_HOST}&lt;/span&gt;             &lt;span&gt;# 设置连接的 Mysql 服务 host，可以是 Mysql 服务容器的名称，也可以是 Mysql 服务容器的 ip 地址&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;PMA_PORT=${MYSQL_MANAGE_CONNECT_PORT}&lt;/span&gt;             &lt;span&gt;# 设置连接的 Mysql 服务端口号&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;${MYSQL_MANAGE_PORT}:80&quot;&lt;/span&gt;                         &lt;span&gt;# 设置容器80端口映射指定宿主机端口，用于宿主机访问可视化web&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;depends_on:&lt;/span&gt;                                           &lt;span&gt;# 依赖容器&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;mysql&lt;/span&gt;                                             &lt;span&gt;# 在 Mysql 服务容器启动后启动&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;networks:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;backend&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;restart:&lt;/span&gt; &lt;span&gt;always&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;redis-manage:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;build:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;context:&lt;/span&gt; &lt;span&gt;./redis-manage&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;environment:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;TZ=${TZ}&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;ADMIN_USER=${REDIS_MANAGE_USERNAME}&lt;/span&gt;           &lt;span&gt;# 设置 Redis 可视化管理的用户名称&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;ADMIN_PASS=${REDIS_MANAGE_PASSWORD}&lt;/span&gt;           &lt;span&gt;# 设置 Redis 可视化管理的用户密码&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;REDIS_1_HOST=${REDIS_MANAGE_CONNECT_HOST}&lt;/span&gt;     &lt;span&gt;# 设置连接的 Redis 服务 host，可以是 Redis 服务容器的名称，也可以是 Redis 服务容器的 ip 地址&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;REDIS_1_PORT=${REDIS_MANAGE_CONNECT_PORT}&lt;/span&gt;     &lt;span&gt;# 设置连接的 Redis 服务端口号&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;${REDIS_MANAGE_PORT}:80&quot;&lt;/span&gt;                     &lt;span&gt;# 设置容器80端口映射指定宿主机端口，用于宿主机访问可视化web&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;depends_on:&lt;/span&gt;                                       &lt;span&gt;# 依赖容器&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;redis&lt;/span&gt;                                         &lt;span&gt;# 在 Redis 服务容器启动后启动&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;networks:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;backend&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;restart:&lt;/span&gt; &lt;span&gt;always&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;prometheus:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;build:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;context:&lt;/span&gt; &lt;span&gt;./prometheus&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;environment:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;TZ=${TZ}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;volumes:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;./prometheus/prometheus.yml:/opt/bitnami/prometheus/conf/prometheus.yml&lt;/span&gt;  &lt;span&gt;# 将 prometheus 配置文件挂载到容器里&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;${PROMETHEUS_PORT}:9090&quot;&lt;/span&gt;                     &lt;span&gt;# 设置容器9090端口映射指定宿主机端口，用于宿主机访问可视化web&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;networks:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;backend&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;restart:&lt;/span&gt; &lt;span&gt;always&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;grafana:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;build:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;context:&lt;/span&gt; &lt;span&gt;./grafana&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;environment:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;TZ=${TZ}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;${GRAFANA_PORT}:3000&quot;&lt;/span&gt;                        &lt;span&gt;# 设置容器3000端口映射指定宿主机端口，用于宿主机访问可视化web&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;networks:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;backend&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;restart:&lt;/span&gt; &lt;span&gt;always&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;jaeger:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;build:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;context:&lt;/span&gt; &lt;span&gt;./jaeger&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;environment:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;TZ=${TZ}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;${JAEGER_PORT}:16686&quot;&lt;/span&gt;                        &lt;span&gt;# 设置容器16686端口映射指定宿主机端口，用于宿主机访问可视化web&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;networks:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;backend&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;restart:&lt;/span&gt; &lt;span&gt;always&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;dtm:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;build:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;context:&lt;/span&gt; &lt;span&gt;./dtm&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;environment:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;TZ=${TZ}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;entrypoint:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;/app/dtm/dtm&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;-c=/app/dtm/configs/config.yaml&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;volumes:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;./dtm/config.yml:/app/dtm/configs/config.yaml&lt;/span&gt; &lt;span&gt;# 将 dtm 配置文件挂载到容器里&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;ports:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;${DTM_HTTP_PORT}:36789&quot;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;&quot;${DTM_GRPC_PORT}:36790&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;networks:&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;-&lt;/span&gt; &lt;span&gt;backend&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;restart:&lt;/span&gt; &lt;span&gt;always&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 构建与运行&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用 &lt;code&gt;docker-compose&lt;/code&gt; 命令来构建和启动运行我们的服务容器，在根目录执行如下命令：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ docker-compose up -d&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;容器构建中&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32447552447552447&quot; data-type=&quot;png&quot; data-w=&quot;715&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UyIojWicPOg3Nk4vXsMRJn3yot36aUNnLjHfeKxQsxz53tb94pvNCWatG7Xy4v7j4vn13TciaZSiadBQ2dZGOUS8A/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在 &lt;code&gt;Windows&lt;/code&gt; 系统容器构建中出现如下图所示，请选择 &lt;code&gt;Share it&lt;/code&gt; 这将允许 &lt;code&gt;Windows&lt;/code&gt; 的文件目录挂载到容器目录中。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4930747922437673&quot; data-type=&quot;png&quot; data-w=&quot;361&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UyIojWicPOg3Nk4vXsMRJn3yot36aUNnLXWobzel8x3fwKpCfoUjibXR9IUBFE4z86VJaXgN1zVHOn8pNP9zJSfQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;容器已启动运行&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4930747922437673&quot; data-type=&quot;png&quot; data-w=&quot;361&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UyIojWicPOg3Nk4vXsMRJn3yot36aUNnLXWobzel8x3fwKpCfoUjibXR9IUBFE4z86VJaXgN1zVHOn8pNP9zJSfQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6754320060105184&quot; data-type=&quot;png&quot; data-w=&quot;1331&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UyIojWicPOg3Nk4vXsMRJn3yot36aUNnLsdpn8qgO7KicuxdYbogJRiaPOYxmVpiaicfWMsMdNm2PhmkSCPqFgibV2rA/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5 容器说明&lt;span/&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;容器名称&lt;/th&gt;&lt;th&gt;暴露端口&lt;/th&gt;&lt;th&gt;host地址&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;golang&lt;/td&gt;&lt;td&gt;8000:8000&lt;br/&gt;8001:8001&lt;br/&gt;8002:8002&lt;br/&gt;8003:8003&lt;br/&gt;9000:9000&lt;br/&gt;9001:9001&lt;br/&gt;9002:9002&lt;br/&gt;9003:9003&lt;/td&gt;&lt;td&gt;golang&lt;/td&gt;&lt;td&gt;在生产环境中微服务一般都是集群部署，可能一个微服务一台服务器，也可能一个微服务一个容器。为了方便开发调试，我们将在 &lt;code&gt;golang&lt;/code&gt; 容器中启动所有微服务，并为它们分配监听不同的端口号以示区分。&lt;br/&gt;80：开头的端口号我们将用于 &lt;code&gt;api&lt;/code&gt; 服务 &lt;br/&gt;90：开头的端口号我们将用于 &lt;code&gt;rpc&lt;/code&gt; 服务&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;dtm&lt;/td&gt;&lt;td&gt;36789:36789&lt;br/&gt;36790:36790&lt;/td&gt;&lt;td&gt;dtm&lt;/td&gt;&lt;td&gt;&lt;code&gt;dtm&lt;/code&gt; 的 &lt;code&gt;http&lt;/code&gt; 协议和 &lt;code&gt;grpc&lt;/code&gt; 协议服务端口号，供客户端交互使用。&lt;br/&gt;此项目中我们只在 &lt;code&gt;Docker&lt;/code&gt; 内部容器之间访问使用，所以也可以不暴露端口号给宿主机&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;etcd&lt;/td&gt;&lt;td&gt;2379:2379&lt;/td&gt;&lt;td&gt;etcd&lt;/td&gt;&lt;td&gt;&lt;code&gt;Etcd&lt;/code&gt; &lt;code&gt;http api&lt;/code&gt; 服务端口号，供客户端交互使用。&lt;br/&gt;此项目中我们只在 &lt;code&gt;Docker&lt;/code&gt; 内部容器之间访问使用，所以也可以不暴露端口号给宿主机&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mysql&lt;/td&gt;&lt;td&gt;3306:3306&lt;/td&gt;&lt;td&gt;mysql&lt;/td&gt;&lt;td&gt;&lt;code&gt;Mysql&lt;/code&gt; 服务默认端口号，宿主机可通过 &lt;code&gt;127.0.0.1:3306&lt;/code&gt; 进行数据库的连接&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;redis&lt;/td&gt;&lt;td&gt;6379:6379&lt;/td&gt;&lt;td&gt;redis&lt;/td&gt;&lt;td&gt;&lt;code&gt;Redis&lt;/code&gt; 服务默认端口号，宿主机可通过 &lt;code&gt;127.0.0.1:6379&lt;/code&gt; 进行数据库的连接&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mysql-manage&lt;/td&gt;&lt;td&gt;1000:80&lt;/td&gt;&lt;td&gt;mysql-manage&lt;/td&gt;&lt;td&gt;&lt;code&gt;phpMyAdmin&lt;/code&gt; &lt;code&gt;web&lt;/code&gt; 服务端口号，可以在宿主机 &lt;code&gt;127.0.0.1:1000&lt;/code&gt; 访问&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;redis-manage&lt;/td&gt;&lt;td&gt;2000:80&lt;/td&gt;&lt;td&gt;redis-manage&lt;/td&gt;&lt;td&gt;&lt;code&gt;phpRedisAdmin&lt;/code&gt; &lt;code&gt;web&lt;/code&gt; 服务端口号，可以在宿主机 &lt;code&gt;127.0.0.1:2000&lt;/code&gt; 访问&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;prometheus&lt;/td&gt;&lt;td&gt;3000:9090&lt;/td&gt;&lt;td&gt;prometheus&lt;/td&gt;&lt;td&gt;&lt;code&gt;Prometheus&lt;/code&gt; &lt;code&gt;web&lt;/code&gt; 服务端口号，可以在宿主机 &lt;code&gt;127.0.0.1:3000&lt;/code&gt; 访问&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;grafana&lt;/td&gt;&lt;td&gt;4000:3000&lt;/td&gt;&lt;td&gt;grafana&lt;/td&gt;&lt;td&gt;&lt;code&gt;Grafana&lt;/code&gt; &lt;code&gt;web&lt;/code&gt; 服务端口号，可以在宿主机 &lt;code&gt;127.0.0.1:4000&lt;/code&gt; 访问&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;jaeger&lt;/td&gt;&lt;td&gt;5000:16686&lt;/td&gt;&lt;td&gt;jaeger&lt;/td&gt;&lt;td&gt;&lt;code&gt;Jaeger&lt;/code&gt; &lt;code&gt;web&lt;/code&gt; 服务端口号，可以在宿主机 &lt;code&gt;127.0.0.1:5000&lt;/code&gt; 访问&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.6 访问验证&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Mysql&lt;/code&gt; 访问验证&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5590465872156013&quot; data-type=&quot;png&quot; data-w=&quot;1846&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UyIojWicPOg3Nk4vXsMRJn3yot36aUNnL4EfI2ATmI06Xb8uK8CgDk5PXbZ81iaPZgMBiaYWODqKc4wTWwsJoDdHA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Redis&lt;/code&gt; 访问验证&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5593495934959349&quot; data-type=&quot;png&quot; data-w=&quot;1845&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UyIojWicPOg3Nk4vXsMRJn3yot36aUNnLBMuY32v3RxKVBg8rby5RMQUPPfhXe9JsuwSCQlMj7yGU1JHAsIlS4w/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Prometheus&lt;/code&gt; 访问验证&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5579631635969664&quot; data-type=&quot;png&quot; data-w=&quot;1846&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UyIojWicPOg3Nk4vXsMRJn3yot36aUNnLTpxUddJhzrqsIMuD0jpic2r2w5tu3cY6Y0Y1A9Tpn5s6c2Wwaapy1uQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Grafana&lt;/code&gt; 访问验证&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5577862181226262&quot; data-type=&quot;png&quot; data-w=&quot;1843&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UyIojWicPOg3Nk4vXsMRJn3yot36aUNnLkE2wcZVEicHyKhBAFfIvl3pcRicZPnlIct7ozgqhTGNgGvZyoFhfHT4w/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;Jaeger&lt;/code&gt; 访问验证&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.559652928416486&quot; data-type=&quot;png&quot; data-w=&quot;1844&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UyIojWicPOg3Nk4vXsMRJn3yot36aUNnL7n5ramiar5PRbrO7YR8wL7olBBRHeEFy3jgQqialJibJEReUvboIaBcVg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;项目地址&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/zeromicro/go-zero&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欢迎使用 &lt;code&gt;go-zero&lt;/code&gt; 并 &lt;strong&gt;star&lt;/strong&gt; 支持我们！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;微信交流群&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关注『&lt;strong&gt;微服务实践&lt;/strong&gt;』公众号并点击 &lt;strong&gt;交流群&lt;/strong&gt; 获取社区群二维码。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f4017151d931c1f1b492ad3e1d06e4ca</guid>
<title>深入浅出Apache Pulsar（1）：Pulsar vs Kafka</title>
<link>https://toutiao.io/k/u78e5hn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;h1&gt;什么是Pulsar？&lt;/h1&gt;

&lt;p&gt;Apache Pulsar 是 Apache 软件基金会顶级项目，是下一代 云原生 分布式消息流平台，集消息、存储、轻量化函数式计算为一体，采用计算与存储分离架构设计，支持多租户、持久化存储、多机房跨区域数据复制，具有强一致性、高吞吐以及低延时的高可扩展流数据存储特性。&lt;/p&gt;

&lt;h1&gt;Pulsar 的关键特性&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;  Pulsar 的单个实例原生支持&lt;strong&gt;多个集群&lt;/strong&gt;，可跨机房在集群间无缝地完成消息复制。&lt;/li&gt;
&lt;li&gt;  极低的发布延迟和端到端延迟。&lt;/li&gt;
&lt;li&gt;  可无缝扩展到超过 一百万 个 topic。&lt;/li&gt;
&lt;li&gt;  简单的客户端 API，支持 Java、Go、Python 和 C++。&lt;/li&gt;
&lt;li&gt;  支持多种 topic 订阅模式(独占订阅、共享订阅、故障转移订阅)。&lt;/li&gt;
&lt;li&gt;  通过 Apache &lt;strong&gt;BookKeeper&lt;/strong&gt; 提供的持久化消息存储机制保证消息传递 。&lt;/li&gt;
&lt;li&gt;  由轻量级的 serverless 计算框架 &lt;strong&gt;Pulsar Functions&lt;/strong&gt; 实现流原生的数据处理。&lt;/li&gt;
&lt;li&gt;  基于 Pulsar Functions 的 serverless connector 框架 &lt;strong&gt;Pulsar IO&lt;/strong&gt; 使得数据更易移入、移出 Apache Pulsar。&lt;/li&gt;
&lt;li&gt;  &lt;strong&gt;分层式存储&lt;/strong&gt;可在数据陈旧时，将数据从热存储卸载到冷/长期存储(如S3、GCS)中。&lt;/li&gt;
&lt;/ul&gt;

&lt;h1&gt;Pulsar vs Kafka&lt;/h1&gt;

&lt;p&gt;下方链接为 Pulsar与 Kafka详细对比报告，可自行下载查看&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://streamnative.io/en/blog/tech/2020-07-08-pulsar-vs-kafka-part-1&quot;&gt;https://streamnative.io/en/blog/tech/2020-07-08-pulsar-vs-kafka-part-1&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://streamnative.io/zh/blog/tech/2020-07-22-pulsar-vs-kafka-part-2&quot;&gt;https://streamnative.io/zh/blog/tech/2020-07-22-pulsar-vs-kafka-part-2&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;基准测试(StreamNative)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;数据来源&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/UZJTOEpzX8foUJv9XMJxOw&quot;&gt;https://mp.weixin.qq.com/s/UZJTOEpzX8foUJv9XMJxOw&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://streamnative.io/en/blog/tech/2020-11-09-benchmark-pulsar-kafka-performance&quot;&gt;https://streamnative.io/en/blog/tech/2020-11-09-benchmark-pulsar-kafka-performance&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://streamnative.io/whitepaper/benchmark-pulsar-vs-kafka&quot;&gt;https://streamnative.io/whitepaper/benchmark-pulsar-vs-kafka&lt;/a&gt;&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-adb49ac78b99796fe56cb27fba53694588e.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在与 Kafka 的持久性保证相同的情况下， Pulsar 可达到 605 MB /s 的发布和端到端 吞吐量 (与 Kafka 相同)以及 3.5 GB/s 的 catch-up read 吞吐量(比 Kafka 高 3.5 倍)。Pulsar 的吞吐量不会因分区数量的增加和持久性级别的改变而受到影响，而 Kafka 的吞吐量会因分区数量或持久性级别的改变而受到严重影响。&lt;/p&gt;



&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-d51ba7af6d8755dd50176b9296be31ba6a5.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在不同的测试实例(包括不同订阅数量、不同主题数量和不同持久性保证)中，Pulsar 的延迟显著低于 Kafka。Pulsar P99 延迟在 5 到 15 毫秒之间。Kafka P99 延迟可能长达数秒，并且会因主题数量、订阅数量和不同持久性保证而受到巨大影响。&lt;/p&gt;



&lt;ol&gt;
&lt;li&gt; 多语言客户端(C/C++、Python、Java、Go ...)&lt;/li&gt;
&lt;li&gt; 管理工具(Pulsar Manager vs Kafka Manager)&lt;/li&gt;
&lt;li&gt; 内置流处理Built-In Stream Processing(Pulsar Function vs Kafka Streams)&lt;/li&gt;
&lt;li&gt; Rich Integrations (Pulsar Connectors)&lt;/li&gt;
&lt;li&gt; Exactly-Once Processing&lt;/li&gt;
&lt;li&gt; 日志压缩&lt;/li&gt;
&lt;li&gt; 多租户(Pulsar)&lt;/li&gt;
&lt;li&gt; 安全管理(Pulsar)&lt;/li&gt;
&lt;/ol&gt;

&lt;h1&gt;架构设计&lt;/h1&gt;

&lt;p&gt;Pulsar 采用存储和计算分离的软件架构。 &lt;strong&gt;在消息领域，Pulsar 是第一个将存储计算分离&lt;/strong&gt; &lt;strong&gt;云原生&lt;/strong&gt; &lt;strong&gt;架构落地的&lt;/strong&gt; &lt;strong&gt;开源&lt;/strong&gt; &lt;strong&gt;项目&lt;/strong&gt; 。由于在 Broker 层不存储任何数据，这种架构为用户带来了更高的可用性、更灵活的扩容和管理、避免数据的 reblance 和 catch-up。&lt;/p&gt;

&lt;p&gt;在 Apache Pulsar 的分层架构中，服务层 Broker 和存储层 BookKeeper 的每个节点都是对等的。Broker 仅仅负责消息的服务支持，不存储数据。这为服务层和存储层提供了瞬时的节点扩展和无缝的失效恢复。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-ec8cf35b00c9c73857eaacfc5c833999f6b.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;持久化存储(Persistent storage)&lt;/h2&gt;

&lt;p&gt;Pulsar 使用 BookKeeper 分布式日志存储数据库作为存储组件，在底层使用日志作为存储模型。&lt;/p&gt;

&lt;p&gt;Pulsar 将所有未确认消息(即未处理消息)存储在 BookKeeper 中的多个“bookie”服务器上。&lt;/p&gt;

&lt;p&gt;BookKeeper 通过 Quorum Vote 的方式来实现数据的一致性，跟 Master/Slave 模式不同，BookKeeper 中每个节点也是对等的，对一份数据会 并发 地同时写入指定数目的存储节点。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://yunzhihui.feishu.cn/space/api/box/stream/download/asynccode/?code=YjEzYzZjODQ3NDg1N2E1NGNkOWZhMTkwZjRlYzZlNzRfYnVDbmdOR3BTcWE2M1dYalBGM04zdzJzSUV4NVZpZGhfVG9rZW46Ym94Y241VTU1UlNGY0NJcFBMZTZFYUxTaTRNXzE2NDI0MDYwNTk6MTY0MjQwOTY1OV9WNA&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一个Topic实际上是一个ledgers流。Ledger本身就是一个日志。所以一系列的子日志(Ledgers)组成了一个父日志(Topic)。&lt;/p&gt;

&lt;p&gt;Ledgers追加到一个Topic，条目(消息或者一组消息)追加到Ledgers。Ledger一旦关闭是不可变的。Ledger作为最小的删除单元，也就是说我们不能删除单个条目而是去删除整个Ledger。&lt;/p&gt;

&lt;p&gt;Ledgers本身也被分解为多个Fragment。Fragment是BookKeeper集群中最小的分布单元。&lt;/p&gt;

&lt;p&gt;每个Ledger(由一个或多个Fragment组成)可以跨多个BookKeeper节点(Bookies)进行复制，以实现数据容灾和提升读取性能。每个Fragment都在一组不同的Bookies中复制(存在足够的Bookies)。&lt;/p&gt;

&lt;h3&gt;conf/bookkeeper.conf&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;#############################################################################&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;## Server parameters&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;#############################################################################&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;# Directories BookKeeper outputs its write ahead log.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;# Could define multi directories to store write head logs, separated by &#x27;,&#x27;.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;journalDirectories=/data/appData/pulsar/bookkeeper/journal&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;#############################################################################&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;## Ledger storage settings&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;#############################################################################&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;# Directory Bookkeeper outputs ledger snapshots&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;# could define multi directories to store snapshots, separated by &#x27;,&#x27;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ledgerDirectories=/data/appData/pulsar/bookkeeper/ledgers&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;conf/broker.conf&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;### --- Managed Ledger --- ###&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;# Number of bookies to use when creating a ledger&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;managedLedgerDefaultEnsembleSize=2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;# Number of copies to store for each message&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;managedLedgerDefaultWriteQuorum=2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;# Number of guaranteed copies (acks to wait before write is complete)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;managedLedgerDefaultAckQuorum=2&lt;/code&gt;&lt;/p&gt;

&lt;h2&gt;元数据存储(Metadata storage)&lt;/h2&gt;

&lt;p&gt;Pulsar 和BookKeeper都使用Apache Zookeeper 来存储元数据和监控节点健康状况。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$ $PULSAR_HOME/bin/pulsar zookeeper-shell&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;gt; ls /&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;[admin, bookies, counters, ledgers, loadbalance, managed-ledgers, namespace, pulsar, schemas, stream, zookeeper]&lt;/code&gt;&lt;/p&gt;

&lt;h1&gt;更多福利&lt;/h1&gt;

&lt;p&gt;云智慧已开源集轻量级、聚合型、智能运维为一体的综合运维管理平台OMP（Operation Management Platform） ，具备 纳管、部署、监控、巡检、自愈、备份、恢复 等功能，可为用户提供便捷的运维能力和业务管理，在提高运维人员等工作效率的同时，极大提升了业务的连续性和安全性。点击下方地址链接，欢迎大家给OMP点赞送star，了解更多相关内容～&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GitHub地址： &lt;a href=&quot;https://github.com/CloudWise-OpenSource/OMP&quot;&gt;https://github.com/CloudWise-OpenSource/OMP&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Gitee地址：&lt;a href=&quot;https://gitee.com/CloudWise/OMP&quot;&gt;https://gitee.com/CloudWise/OMP&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;微信扫描识别下方二维码，备注【OMP】加入AIOps社区运维管理平台OMP开发者交流群，与更多行业大佬一起交流学习～&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/up-7b55ba67396e9a80e05688bb8d2edb584f7.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h1&gt;系列阅读&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://toutiao.io/posts/vd8ag4a&quot;&gt;深入浅出Apache Pulsar（2）：Pulsar消息机制&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cf3ee18a473e69609437a481b58abadd</guid>
<title>代码质量第4层——健壮的代码</title>
<link>https://toutiao.io/k/rk56dfv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;58&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe977Xa5zfy5iaV3agpS11Cqm4psjPOibic6BZSicnBFh6uWzCFp3uqN5R114Fq85DmuCzdL3eESlQ37bFA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;导语 |&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;&lt;span&gt;腾讯云加社区精品内容栏目《云荐大咖》，特邀行业佼者，聚焦前沿技术的落地与理论实践，持续为您解读云时代热点技术，探秘行业发展新机。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.31875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/VY8SELNGe97RaasLzB8SmnamCoG99ssI0NHnW4S2uDd7zKPSPU3DHf1S8l9clOc9icg9J2nmuZIjDLwjjIpIYDw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1 name=&quot;%E5%85%AC%E5%8F%B8%E6%8F%90%E4%BE%9B%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E8%BD%AF%E7%A1%AC%E4%BB%B6%E6%9B%B4%E8%83%BD%E5%90%B8%E5%BC%95%E4%BA%BA%E6%89%8D%EF%BC%9F%E6%B2%A1%E9%92%B1%E7%9A%84%E5%B0%8F%E5%85%AC%E5%8F%B8%E5%A6%82%E4%BD%95%E6%89%93%E9%80%A0%E6%9E%81%E5%AE%A2%E6%B0%9B%E5%9B%B4%EF%BC%9F%E6%9C%AC%E6%96%87%E5%B0%86%E7%BB%99%E5%87%BA%E6%96%B9%E6%A1%88%E3%80%82&quot;&gt;&lt;span&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;健壮性(Robustness) 是指&lt;/span&gt;&lt;span&gt;&lt;strong&gt;程序在遇到规范以外的输入，错误和异常时，仍能正常运行&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。简单来说，健壮代码的适应性很强，不会因为一些异常，就导致程序崩溃。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不健壮的前端代码体现为：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;一、如何写出健壮的前端代码&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;%E5%A6%82%E4%BD%95%E5%86%99%E5%87%BA%E5%81%A5%E5%A3%AE%E7%9A%84%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;要写出健壮的前端代码，就要处理规范以外的输入，错误和异常。具体来说，有4点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面，我们具体来说。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 name=&quot;1.-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86&quot;&gt;&lt;span&gt;&lt;strong&gt;（一）异常处理&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不做异常做处理，轻则导致功能出错，重则导致页面白屏。异常处理，可以分为如下几种情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用try-catch捕获同步代码的运行时错误。如果是异步代码，需要转化成await的写法。如:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;try&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  doSth()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;await&lt;/span&gt; doSth2()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} &lt;span class=&quot;code-snippet__keyword&quot;&gt;catch&lt;/span&gt; (e) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;未被处理的JavaScript运行时错误（包括语法错误）发生时, window会触发error事件。这么处理:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;window&lt;/span&gt;.addEventListener(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;error&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__function&quot;&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当一项资源（如&amp;lt;img&amp;gt;或&amp;lt;script&amp;gt;）加载失败时，加载资源的元素会触发error事件。这么处理：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; img = &lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Image();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;img.addEventListener(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;error&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__function&quot;&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;img.src = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;xxx&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Promise被reject时，可以在then的第二个参数或catch中处理。如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;p&lt;/span&gt;()&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.then&lt;/span&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;onSuccess&lt;/span&gt;, &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;onReject&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;p&lt;/span&gt;()&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.catch&lt;/span&gt;(&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;onReject&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Promise reject没有被处理的话，window会触发unhandledrejection事件。可以统一来处理：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;window&lt;/span&gt;.addEventListener(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;unhandledrejection&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__function&quot;&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以在Axios接口返回的拦截器中，加入接口报错的通用处理。例如:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;axios.interceptors.response.use(&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;code-snippet__params&quot;&gt;response&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; response;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}, &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;err&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;(err.response) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;switch&lt;/span&gt; (err.response.status) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;400&lt;/span&gt;: err.message = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;请求错误(400)&#x27;&lt;/span&gt;; &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;500&lt;/span&gt;: err.message = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;服务器错误(500)&#x27;&lt;/span&gt;; &lt;span class=&quot;code-snippet__keyword&quot;&gt;break&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;Promise&lt;/span&gt;.reject(error);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;app.config.errorHandler = &lt;span class=&quot;code-snippet__function&quot;&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;err, vm, info&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;React的生命周期函数ComponentDidCatch可以捕获子组件的异常。因此，可以在根组件外包裹一个组件来处理错误。如:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__class&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ErrorBoundary&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;code-snippet__title&quot;&gt;Component&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  componentDidCatch(error, info) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;apache&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;&amp;lt;ErrorBoundary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__section&quot;&gt;&amp;lt;App /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;&amp;lt;/ErrorBoundary&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 name=&quot;2-%E8%BE%93%E5%85%A5%E6%A3%80%E6%9F%A5&quot;&gt;&lt;span&gt;&lt;strong&gt;（二）输入检查&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当输入不满足条件时，要尽早返回或主动报错。这里的输入包括：接口的返回结果，函数的参数，组件的属性等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接口的返回会出现和前端预期不一致的情况。原因可能是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，我们要对接口返回格式做检查。我们来看个例子:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cpp&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; res = await fetchList()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;list&lt;/span&gt; = res.&lt;span class=&quot;code-snippet__built_in&quot;&gt;map&lt;/span&gt;(...)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果接口返回的不是数组，程序就会报错。可以做类似这样的优化：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; res = &lt;span class=&quot;code-snippet__keyword&quot;&gt;await&lt;/span&gt; fetchList()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; list = &lt;span class=&quot;code-snippet__built_in&quot;&gt;Array&lt;/span&gt;.isArray(res) ? res.map(...) : []&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;JavaScript是弱类型语言，函数的参数可以传任意值或不传参。因此，不对函数参数检查，会出现一些和预期不一致的情况。比如，期望实现两数求和的功能：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;sum&lt;/span&gt; (&lt;span class=&quot;code-snippet__params&quot;&gt;a, b&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; a + b&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sum(&lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sum() &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sum(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;3&#x27;&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对函数参数做检查，可以这么优化：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;sum&lt;/span&gt; (&lt;span class=&quot;code-snippet__params&quot;&gt;a, b&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt;(&lt;span class=&quot;code-snippet__built_in&quot;&gt;isNaN&lt;/span&gt;(&lt;span class=&quot;code-snippet__built_in&quot;&gt;parseFloat&lt;/span&gt;(a)) || &lt;span class=&quot;code-snippet__built_in&quot;&gt;isNaN&lt;/span&gt;(&lt;span class=&quot;code-snippet__built_in&quot;&gt;parseFloat&lt;/span&gt;(b))) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;param error. param should be a num&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;parseFloat&lt;/span&gt;(a) + &lt;span class=&quot;code-snippet__built_in&quot;&gt;parseFloat&lt;/span&gt;(b)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐使用TypeScript。可以用它检查函数参数。上面的代码用TypeScript这么写：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;sum&lt;/span&gt; (&lt;span class=&quot;code-snippet__params&quot;&gt;a: &lt;span class=&quot;code-snippet__built_in&quot;&gt;number&lt;/span&gt; | &lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;, b: &lt;span class=&quot;code-snippet__built_in&quot;&gt;number&lt;/span&gt; | &lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;parseFloat&lt;/span&gt;(a &lt;span class=&quot;code-snippet__keyword&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;) + &lt;span class=&quot;code-snippet__built_in&quot;&gt;parseFloat&lt;/span&gt;(b &lt;span class=&quot;code-snippet__keyword&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对组件的属性检查和函数参数检查类似，就不做赘述了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 name=&quot;3-%E5%86%99%E6%B3%95%E4%BC%98%E5%8C%96&quot;&gt;&lt;span&gt;&lt;strong&gt;（三）写法优化&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多写法优化能提升代码健壮性。这里介绍2点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如：a.b.c改成a&amp;amp;&amp;amp;a.b&amp;amp;&amp;amp;a.b.c。如果用了TypeScript，可以这么写：a?.b?.c。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 name=&quot;4-%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E7%9A%84%E9%80%89%E6%8B%A9&quot;&gt;&lt;span&gt;&lt;strong&gt;（四）第三方库的选择&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用第三库，可以减少造轮子，从而提升开发效率。但如果第三方包不健壮，用到第三方包的功能也就不健壮了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;健壮的第三方库是成熟，稳定的。最好不要选择以下情况的第三方库：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;二、健壮性的测试方法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以用&lt;/span&gt;&lt;span&gt;&lt;strong&gt;猴子测试来测试代码的健壮性&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;注&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：猴子测试(Money Test)，也&lt;/span&gt;&lt;span&gt;称搞怪测试。&lt;/span&gt;&lt;span&gt;在软件测试中，测试者可以进行各种稀奇古怪的操作模式，用以测试软件的健壮性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里推荐一个适用于浏览器的猴子测试工具：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;gremlins.js&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。工具会对要测试的页面进行一通乱点。如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.9085631349782293&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/VY8SELNGe97RaasLzB8SmnamCoG99ssIBGic0EmdqicRgQV8I9VkW8qqFYMYFmVltfRtpKfsD5j6dZWPmJ4CibVwg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;689&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot; data-mpa-template=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot; powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot; mpa-is-content=&quot;t&quot;&gt;三、提升代码质量的下一步&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 name=&quot;%E6%8F%90%E5%8D%87%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%84%E4%B8%8B%E4%B8%80%E6%AD%A5&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;提升代码质量的下一步就是提升代码的可读性。我会在下一篇文章中介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwNzIyMTYzNA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/mEakJnD74m965xnGDuRc9yHa3d69a3nXZZO0qiaXjklno7xJqiaZ1tqotAEKOEBLNnbN3XB7zBpjNK5SzoqHyZibQ/0?wx_fmt=png&quot; data-nickname=&quot;前端GoGoGo&quot; data-alias=&quot;fegogogo&quot; data-signature=&quot;致力于提升前端收入。提供有深度的面试，晋级提升的前端内容。&quot; data-from=&quot;0&quot;/&gt;&lt;span/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3fbb6d11de8c4031ee549c0bf35c3cff</guid>
<title>2022过虎年新年春节大门立体对联大礼包，点击链接立即领取红包！</title>
<link>https://toutiao.io/k/mfp3pig</link>
<content:encoded>&lt;div&gt;&lt;body data-spm=&quot;10720394/n&quot; id=&quot;readabilityBody&quot;&gt;
    
    
    
    
    
    
      
      
    
    
    
    
    
  &lt;/body&gt;
&lt;/div&gt;</content:encoded>
</item>
</channel></rss>