<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>35541b01f9c5a8fbd1528fd77ca9e1ef</guid>
<title>分位数算法总结</title>
<link>https://toutiao.io/k/w39cw6o</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section class=&quot;article-entry&quot;&gt;
    &lt;h1&gt;背景&lt;/h1&gt;
&lt;p&gt;首先说下，分位数(quantile)的概念，也就是我们监控中常见的p99， 这里举一个例子&lt;/p&gt;
&lt;p&gt;排序为rank=⌊ϕN⌋的元素，其中N为序列中元素的个数。考虑以下例子数据：&lt;/p&gt;
&lt;p&gt;11 , 21 , 24 , 61 , 81 , 39 , 89 , 56 , 12 , 51&lt;/p&gt;
&lt;p&gt;查询ϕ−quantile分位点所在数据前，需要对无序数据进行排序：&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;input:  11   21   24   61   81   39   89   56   12   51&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;sort:   11   12   21   24   39   51   56   61   81   89&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;line&quot;&gt;rank:   1    2    3    4    5    6    7    8    9    10&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;排序后，我想查这批数据的中位数 也就是：0.5−quantile 对应 rank=5，值为39&lt;/p&gt;
&lt;p&gt;现时场景下，我们一般用这个来统计比如一段时间的调用延迟的p99，而上述操作无论在时间还是空间上成本比较高，实际场景中肯定不是这么实现的。&lt;/p&gt;
&lt;p&gt;后文将阐述近年来实际工业中使用的各种分位数算法.&lt;/p&gt;
&lt;h1&gt;随机算法&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cs.umd.edu/~samir/498/vitter.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;论文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;实现案例:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dropwizard/metrics/blob/release/4.1.x/metrics-core/src/main/java/com/codahale/metrics/UniformReservoir.java&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;dropwizard 的 metrics 库提供的随机算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原理解释:&lt;/p&gt;
&lt;p&gt;维护一个固定长度的sample buffer数组，写sample时，随机确定是否插入到当前sample buffer 数组。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/post_images/2020-08-03/dbd716f9faf745869bf7f73c4462fa1d.png&quot; alt=&quot;65d61ec2f71173d1b075f72d42019020.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当需要查询quantile时，则进行传统的排序，计算quantile&lt;/p&gt;
&lt;p&gt;时间复杂度&lt;/p&gt;

&lt;p&gt;空间占用&lt;/p&gt;
&lt;p&gt;固定大小，gc影响为0&lt;/p&gt;
&lt;p&gt;缺点： 数据失真严重&lt;/p&gt;
&lt;h1&gt;确定性算法&lt;/h1&gt;
&lt;h2&gt;静态分桶&lt;/h2&gt;
&lt;p&gt;实现案例&lt;br/&gt;
&lt;a href=&quot;https://github.com/HdrHistogram/HdrHistogram&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;HdrHistogram&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;思路还是分桶，只不过不是一个数字一个桶，而是一个区间一个桶。&lt;/p&gt;
&lt;p&gt;该区间的范围可以是线性增长，可指数增长。&lt;/p&gt;
&lt;p&gt;通过牺牲一小部分精度，从而达到减小空间占用，并且数据大致准确的结果。&lt;/p&gt;
&lt;p&gt;下图中，采样范围在 [1-15]的有991个，在 [16-31]的有2个...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/post_images/2020-08-03/3b302243655e4a328d77f73d1b7d7859.png&quot; alt=&quot;cf27e5d45bd6340104f0ce89eff93225.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;空间占用&lt;br/&gt;
根据采样点的范围以及精度分桶，大小固定。gc影响为0&lt;/p&gt;
&lt;p&gt;缺点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;统计范围有限，需要预先确定&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;q-digest&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://graphics.stanford.edu/courses/cs468-05-winter/Papers/Information_Aggregation/Suri_sensys04.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;论文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;代码实现:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/addthis/stream-lib/blob/master/src/main/java/com/clearspring/analytics/stream/quantile/QDigest.java&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;addthis stream-lib的Qdigest实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本质上还是静态分桶，只是用完全二叉树存储数据。&lt;/p&gt;
&lt;p&gt;他的使用场景为为大数据分块计算 histogram 后，可对多个histogram 快速归并&lt;/p&gt;
&lt;p&gt;数据格式如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/post_images/2020-08-03/b3e0edb8d5774c76ba5981225c7c987d.png&quot; alt=&quot;17222857e4caf351634916d183186cbd.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中，这颗树总共能统计 1-8，8个数字。其中，有4个3，6个4，2个5-6, 2个 7-8 , 1个 1-8&lt;/p&gt;
&lt;p&gt;它将数据压缩的的目标就是将 σ 个采样点 变成 k 组数据输出。下面是将简述压缩树的过程&lt;/p&gt;
&lt;p&gt;是否可以进行压缩，以2个约束条件作为宗旨&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;count(v) &amp;lt;= n/k&lt;/li&gt;
&lt;li&gt;count(v) + count(vp1) + count(vp2) &amp;gt; n/k&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;vp1 vp2 就是下图框起来的3个点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/post_images/2020-08-03/114a15a1ea6f4cf4a6b5c7a83b4709ed.png&quot; alt=&quot;69864a4f9f52a7ca4710315432f1937e.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如何计算Quantile?&lt;/p&gt;
&lt;p&gt;用图1做例子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/post_images/2020-08-03/557a0813e24f4add97e4617e2aba8549.png&quot; alt=&quot;567edd2d71a366b59d500890a827f073.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先，我们把树上每个节点根据其数进行bfs，并进行编号，并根据其编号的值的个数做成一个二维组 &lt;code&gt;（编号，count）&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可得到&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;{〈1,1〉,〈6,2〉,〈7,2〉,〈10,4〉,〈11,6〉}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;每个节点可表达的数据不同，比如 c可表达[5, 6], g 可表达[1,8]&lt;/p&gt;
&lt;p&gt;然后再根据每个二维组，可表达的最大范围进行正序排序&lt;/p&gt;
&lt;p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;{〈10,4〉 [3],〈11,6〉 [4],〈6,2〉 [5-6],〈7,2〉 [7-8], 〈1,1〉 [1-8]}&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;最后就是 count x 请求的分位数，确定index的套路。&lt;/p&gt;
&lt;p&gt;对于 p50 = 0.5*15 = 7.5&lt;/p&gt;
&lt;p&gt;4 + 6 &amp;gt; 7.5&lt;/p&gt;
&lt;p&gt;所以p50 是 &amp;lt;11.6&amp;gt; 也就是4&lt;/p&gt;
&lt;p&gt;时间复杂度&lt;/p&gt;

&lt;p&gt;优点：树的特点决定了，对相同规格的树，merge操作成本很低，适合大数据map reduce 场景下的多颗树的合并作业&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;需要预分桶&lt;/li&gt;
&lt;li&gt;空间占用较多&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;动态分桶&lt;/h2&gt;
&lt;h3&gt;GK 算法&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cis.upenn.edu/~sanjeev/papers/sigmod01_quantiles.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;论文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;思路，还是分桶，只不过这个桶的大小是变化的，论文的话是根据一个区间段来划分的，这里简化下，本质还是根据现存的相邻sample之间的距离确定下个sample是不是放在一个新的独立的桶，具体如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/post_images/2020-08-03/b1adf5e93ae6412099889b2b85ab4fad.png&quot; alt=&quot;228c5e892001b378e38922ae300ff07a.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不需要预设定统计范围&lt;/li&gt;
&lt;li&gt;根据sample的量的范围，大部分情况下较静态分桶节省空间&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;写成本比静态分桶高，比起静态分桶是一个确定的空间，他的空间会不定期扩大。&lt;/li&gt;
&lt;li&gt;精度不可控。
&lt;ol&gt;
&lt;li&gt;假设 sample数据很均匀的平铺在总的数据范围内，则会导致采样的节点数过多，甚至不如静态分桶。&lt;/li&gt;
&lt;li&gt;假设 部分节点的距离较大，则会导致精度降低。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;时间复杂度&lt;/p&gt;

&lt;p&gt;注： 实现时，需要维护一个buffer，当buffer满时需要做排序，所以写的成本按照最慢的来算，就是nlogn&lt;/p&gt;
&lt;p&gt;空间占用&lt;/p&gt;
&lt;p&gt;空间太可控，由于有merge成本，会有一定的gc成本&lt;/p&gt;
&lt;h3&gt;CKMS算法&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://dimacs.rutgers.edu/~graham/pubs/papers/bquant-icde.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;论文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GK算法的升级版本，&lt;a href=&quot;https://github.com/prometheus/client_java/blob/master/simpleclient/src/main/java/io/prometheus/client/CKMSQuantiles.java&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;prometheus 的summary&lt;/a&gt; 就用的该算法&lt;/p&gt;
&lt;p&gt;它引入了一个可配置的错误率的概念，从而解决了GK 精度不可控问题。&lt;/p&gt;
&lt;p&gt;GK 的桶的大小是根据 sample之间的距离delta 决定的，而 CKMS 在抉择是否开辟新桶，则是根据用户设置的&lt;strong&gt;错误率。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;delta = 错误率 x 总体sample个数，并以此决定分桶的大小。&lt;/p&gt;
&lt;p&gt;下图是一个数据合并的例子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/post_images/2020-08-03/33d036bdcfb44ed8a620fe2c742e09f1.png&quot; alt=&quot;667e99ae5f13a0a59fb967b13e30ae54.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见，当错误率为0.1时，当size &amp;gt; 10 时，会对range &amp;lt;=1 的进行合并&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不需要预设定统计范围&lt;/li&gt;
&lt;li&gt;根据sample的量的范围，大部分情况下较静态分桶节省空间&lt;/li&gt;
&lt;li&gt;空间上 完全靠用户参数 &lt;strong&gt;错误率&lt;/strong&gt; 决定，更可控。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;写成本比静态分桶高&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;时间复杂度&lt;/p&gt;

&lt;p&gt;注： 同上，需要维护一个buffer，写时，大部分情况下都是O(1), 触发merge 时由于需要做排序，所以O(nlogn)&lt;/p&gt;
&lt;p&gt;空间占用&lt;/p&gt;
&lt;p&gt;空间太可控，由于有merge，并且空间不可控，所以会有一定的gc成本&lt;/p&gt;
&lt;h2&gt;素描法 (sketch)&lt;/h2&gt;
&lt;h3&gt;t-digest&lt;/h3&gt;
&lt;p&gt;作者源码: &lt;a href=&quot;https://github.com/tdunning/t-digest&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/tdunning/t-digest&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;t-digest算法，比动态分桶算法更准，但是资源又可控&lt;/p&gt;
&lt;p&gt;作者对他的简介&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mapr.com/blog/some-important-streaming-algorithms-you-should-know-about/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://mapr.com/blog/some-important-streaming-algorithms-you-should-know-about/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/1902.04023&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;论文&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;简单描述:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;本质上，还是动态分桶，但有以下几个特点
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;桶的大小在一开始就固定，ckms 并不固定，这样实现可以直接用数组，这对gc友好&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;桶划分函数也更适合于计算分位数场景，众所周知我们更关心 p9999, p999 的精度，对p90, p50 的精度并不太在意。&lt;/p&gt;
&lt;p&gt;所以在划分桶的函数上对2边分桶分的更细，对中间划分的更粗&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/post_images/2020-08-03/ad09ec908a3347e9a6a687216beffaf9.png&quot; alt=&quot;51195aebc7022a4004a0e6931077b229.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;桶的大小随着采样个数的增加而增加。（不这样也就没法保证空间固定了）
桶大小 = f(n) x 当前采样个数&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;时间复杂度:&lt;/p&gt;

&lt;p&gt;注： 写时，大部分情况下都是O(1), 触发merge 时排序，导致 O(nlogn)&lt;/p&gt;
&lt;p&gt;空间复杂度:&lt;/p&gt;
&lt;p&gt;总空间占用较为固定，对gc影响较小。&lt;/p&gt;
&lt;h1&gt;压测&lt;/h1&gt;
&lt;p&gt;最终我们基于以下3种较为可靠的算法做压测，做一个横向比较。&lt;/p&gt;
&lt;p&gt;我们的场景，一般用于统计接口的 p99 的耗时。允许几十ms的误差。一般统计的范围为 &lt;code&gt;0 - 6000&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;由于 CKMS 和 t-digest 的实现并非线程安全，所以对其读写操作时都加了把锁。&lt;a href=&quot;http://gitlab.ximalaya.com/mainstay/quantile-benchmark/blob/master/src/main/java/com/cr/MyBenchmark.java&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;测试代码在此&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里直接给结果:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th/&gt;
&lt;th&gt;w (ops/ms)&lt;/th&gt;
&lt;th&gt;r (ops/ms)&lt;/th&gt;
&lt;th&gt;gc影响&lt;/th&gt;
&lt;th&gt;空间(byte)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ckms&lt;/td&gt;
&lt;td&gt;0.182&lt;/td&gt;
&lt;td&gt;3670790&lt;/td&gt;
&lt;td&gt;4次&lt;/td&gt;
&lt;td&gt;32440&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;hdrhistogram&lt;/td&gt;
&lt;td&gt;6.546&lt;/td&gt;
&lt;td&gt;43&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;3352&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;tdigest&lt;/td&gt;
&lt;td&gt;8.733&lt;/td&gt;
&lt;td&gt;177045&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;13600&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;从上述结果可见，tdigest 的读写性能相对来说是最好的，但是他的空间占用却很厉害。hdrhistogram 反倒是出乎意料的写性能比tdigest略逊一筹。&lt;/p&gt;
&lt;p&gt;仔细看源码会发现tdigest 为了减少gc影响，内部使用了多个固定长度的double数组来实现，&lt;/p&gt;
&lt;p&gt;也就是说，假如采样的范围足够大时，tdigest 才能凸显出优势，不然，内存占用有点多。&lt;/p&gt;
&lt;p&gt;所以，最终，在我们的场景下，还是选择 hdrhistogram&lt;/p&gt;
&lt;h1&gt;reference&lt;/h1&gt;
&lt;p&gt;qdigest&lt;br/&gt;
&lt;a href=&quot;http://www.mathcs.emory.edu/~cheung/Courses/584/Syllabus/08-Quantile/Greenwald2.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.mathcs.emory.edu/~cheung/Courses/584/Syllabus/08-Quantile/Greenwald2.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GK&lt;br/&gt;
&lt;a href=&quot;https://blog.csdn.net/matrix_zzl/article/details/78641264&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://blog.csdn.net/matrix_zzl/article/details/78641264&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;t-digest&lt;br/&gt;
&lt;a href=&quot;https://blog.bcmeng.com/post/tdigest.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://blog.bcmeng.com/post/tdigest.html&lt;/a&gt;&lt;/p&gt;

  &lt;/section&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bbc0e6f39437c3937e721bf0a579ab81</guid>
<title>2021 年仅剩 2 个月啦！抓紧啦！</title>
<link>https://toutiao.io/k/f430jea</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;34&quot; data-cropselx2=&quot;356&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;425&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNav8Byw4xNoV6O2YGutfKmQLKuMZEIhBJF6MrQvoShfIAT6u3dXs6VZRzwSa2eT9jcekfaYuaOD6Hhw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>635f128200e1568af149581e221a6050</guid>
<title>聊聊如何把第三方服务注册到我们项目的 Spring 容器中</title>
<link>https://toutiao.io/k/ukj399s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.7222222222222222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uibLVqKibib5HwPb7TECD2IBxMCvtugVNKbLQfN9MEStWUNAibkwzicbusViaNqatzUbeiaJNVgp02zMhjZw0rkh5bYCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;36&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;点击上方&lt;span data-mid=&quot;&quot;&gt;蓝字&lt;/span&gt;关注我们&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Bs1Gcd8nw37O52kr4rend4jkT77KC5d7FfQf0PBvneJEDRrCiaf2kXibhQSLCNjibpmS3zlOSZ0TQniaZwxDCzTGkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;28&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;1&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最近业务部门向我们反馈一个问题，我们部门原先提供的组件突然用不了了。后面排查是因为我们提供出去的组件类没有注入到spring 容器中，之前没问题是因为业务部门的根包名跟我们组件的根包名是一样，后续他们根包名换了，导致我们的组件类没法注入到spring中，当时的解决方案是形如下&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;@SpringBootApplication(scanBasePackages = {&lt;span&gt;&quot;业务根包&quot;&lt;/span&gt;,&lt;span&gt;&quot;组件根包&quot;&lt;/span&gt;})&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;就是在业务的启动类上加上扫描组件根包。&lt;/p&gt;&lt;p&gt;虽然这样的方式可以解决，但是事后复盘了一下，业务方是否需要了解组件根包？是否还有更优雅一点的方式？本文就来聊聊如何把第三方服务注册到我们项目的spring容器中&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;2&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;注入方式&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.8571428571428571&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HhnEClSmc37Bxb1zZj7tialnNnk1dnmft6ibz6n2lZaheQClZ7FHjs4RElm391lFKwznAZicyxB8VmZvSSEGHrXHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;28&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;1、注入的组件个数比较少&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.9523809523809523&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KLN26icsnib2XYJCRIIHRBibXLekicoWWj63pjFjuYHlBicDncmnjctDfZtAbAodw3tO4bOczk4fxTl7EO5Pq2IM2LA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;42&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.46808510638297873&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fw07L4QCL8zxn8yLTxgxtaKEBOmKyfeXzaxN31SQFNho0f9EIq2uoMDO2O2PzQEJB0sCg2O6oeeyT10sNPHgSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;188&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;&gt;01&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;自动装配机制 + @Bean的形式&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@EnableConfigurationProperties&lt;/span&gt;(XxlJobProperty.class)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;XxlJobAutoConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@ConditionalOnMissingBean&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; XxlJobSpringExecutor &lt;span&gt;xxlJobExecutor&lt;/span&gt;&lt;span&gt;(XxlJobProperty property)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        log.info(&lt;span&gt;&quot;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; xxl-job config init.&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        XxlJobSpringExecutor xxlJobSpringExecutor = &lt;span&gt;new&lt;/span&gt; XxlJobSpringExecutor();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        xxlJobSpringExecutor.setAdminAddresses(property.getAdminAddresses());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        xxlJobSpringExecutor.setAppname(property.getExecutorAppname());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        xxlJobSpringExecutor.setAddress(property.getExecutorAddress());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        xxlJobSpringExecutor.setIp(property.getExecutorIp());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        xxlJobSpringExecutor.setPort(property.getExecutorPort());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        xxlJobSpringExecutor.setAccessToken(property.getAccessToken());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        xxlJobSpringExecutor.setLogPath(property.getExecutorLogPath());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        xxlJobSpringExecutor.setLogRetentionDays(property.getExecutorLogRetentionDays());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; xxlJobSpringExecutor;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;在META-INF/spring.factories加入&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;org.springframework.boot.autoconfigure.EnableAutoConfiguration=\&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;com&lt;/span&gt;.github.lybgeek.autoconfiure.XxlJobAutoConfiguration&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;&gt;02&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;利用@Eanblexxx + @Import机制&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Target&lt;/span&gt;(ElementType.TYPE)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Documented&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Import&lt;/span&gt;(HelloSeviceImpl.class)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;public &lt;span&gt;@interface&lt;/span&gt; EnableHelloSvc{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;在业务项目启动加上@EnableHelloSvc&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;&gt;03&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;调用beanFactory.registerSingleton()&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Slf&lt;/span&gt;4j&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;HelloSvcBeanFactoryPostProcessor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BeanFactoryPostProcessor&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;postProcessBeanFactory&lt;/span&gt;&lt;span&gt;(ConfigurableListableBeanFactory beanFactory)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        String beanName = StringUtils.uncapitalize(HelloService.class.getSimpleName());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        log.info(&lt;span&gt;&quot;register bean : beanName:{}&quot;&lt;/span&gt;,beanName);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        beanFactory.registerSingleton(beanName,&lt;span&gt;new&lt;/span&gt; HelloServiceImpl());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.8571428571428571&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HhnEClSmc37Bxb1zZj7tialnNnk1dnmft6ibz6n2lZaheQClZ7FHjs4RElm391lFKwznAZicyxB8VmZvSSEGHrXHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;28&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;2、注入的组件个数比较多&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.9523809523809523&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KLN26icsnib2XYJCRIIHRBibXLekicoWWj63pjFjuYHlBicDncmnjctDfZtAbAodw3tO4bOczk4fxTl7EO5Pq2IM2LA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;42&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.46808510638297873&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fw07L4QCL8zxn8yLTxgxtaKEBOmKyfeXzaxN31SQFNho0f9EIq2uoMDO2O2PzQEJB0sCg2O6oeeyT10sNPHgSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;188&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;&gt;01&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;自动装配机制 + @ComponentScan&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@ComponentScan&lt;/span&gt;(basePackages = Constant.SVC_PACAKAEE)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;public class ThirdPartySvcAutoConfiguration {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在META-INF/spring.factories加入&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;org.springframework.boot.autoconfigure.EnableAutoConfiguration=\&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;com&lt;/span&gt;.github.lybgeek.autoconfiure.ThirdPartySvcAutoConfiguration&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;&gt;02&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;@Eanblexxx + @Import机制+ClassPathScanningCandidateComponentProvider&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ThirdPartySvcRegister&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;ImportBeanDefinitionRegistrar&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;registerBeanDefinitions&lt;/span&gt;&lt;span&gt;(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        ClassPathBeanDefinitionScanner classPathBeanDefinitionScanner = &lt;span&gt;new&lt;/span&gt; ClassPathBeanDefinitionScanner(registry);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        classPathBeanDefinitionScanner.scan(Constant.SVC_PACAKAEE);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Target&lt;/span&gt;(ElementType.TYPE)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Documented&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Import&lt;/span&gt;(ThirdPartySvcRegister.class)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;public &lt;span&gt;@interface&lt;/span&gt; EnableThirdPartySvc {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在业务项目启动加上@EnableThirdPartySvc&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;3&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果是业务开发人员直接使用&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;@SpringBootApplication(scanBasePackages = {&lt;span&gt;&quot;业务根包&quot;&lt;/span&gt;,&lt;span&gt;&quot;组件根包&quot;&lt;/span&gt;})&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;其实是没问题的，但是如果作为组件提供给其他业务部门使用，能让业务部门无感知，开箱即用会是比较优雅的方式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;4&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;demo链接&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.8055555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YLhbXM3YvH06VDe6ky7ae63IiczjCR6bQDKWN0l8F9BP5oDCNDOiboKPYtheciaq4UMyBM3eWG6Iv07IjZ7xGwUyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;72&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;https://github.com/lyb-geek/springboot-learning/tree/master/springboot-scan-thirdparty-service&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>26d2baa6b48469ce4bb2c196632d3c4b</guid>
<title>Go 泛型系列：再简化，省略接口</title>
<link>https://toutiao.io/k/1yva3zl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;article-entry&quot; itemprop=&quot;articleBody&quot;&gt;
      
      
      
      &lt;p&gt;这是Go泛型系列文章。&lt;/p&gt;
&lt;p&gt;其它Go泛型文章：&lt;/p&gt;

&lt;a id=&quot;more&quot;/&gt;
&lt;p&gt;如果你一直关注Go泛型的设计和实现，一定知道Go泛型代码实现是通过类型参数(type parameter)实现的，当运行泛型代码时，类型参数(type parameter)由类型参数（type argument）替代。(很遗憾parameter和argument都被翻译成了中文参数)&lt;/p&gt;
&lt;p&gt;类型参数(type parameter)也有类型，也就是描述这个参数类型行为的元数据，被成为约束(constraint)。最通用的约束就是内建的&lt;code&gt;any&lt;/code&gt;类型，它代表任意的类型：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;1&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;2&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;3&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;4&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;5&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; Print[T any](s []T) {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; _, v := &lt;span class=&quot;keyword&quot;&gt;range&lt;/span&gt; s {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;fmt.Println(v)&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在Go泛型设计中， 约束是通过接口类型来实现的(&lt;code&gt;interface&lt;/code&gt;)。因为接口类型和约束的功能黑类似，就是限定type argument必须实现type parameter的约束(方法集)。当然，为了实现泛型的功能，除了方法集之外，Go还对用来当做约束的接口做了扩展，定义了类型集(&lt;code&gt;type set&lt;/code&gt;)的概念,比如下面是约束代表一个type argument可以是int、int8、int16、int32或int64的类型，是并(&lt;code&gt;union&lt;/code&gt;)的关系，所以使用&lt;code&gt;|&lt;/code&gt;符号。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;1&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;2&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;3&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Signed &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;typename&quot;&gt;int&lt;/span&gt; | &lt;span class=&quot;typename&quot;&gt;int8&lt;/span&gt; | &lt;span class=&quot;typename&quot;&gt;int16&lt;/span&gt; | &lt;span class=&quot;typename&quot;&gt;int32&lt;/span&gt; | &lt;span class=&quot;typename&quot;&gt;int64&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;更进一步，Go还定义了&lt;code&gt;~&lt;/code&gt;的符号，代表只要底层类型都是某个特定类型就可以，所以上面的例子可以写的更通用一些:&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;1&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;2&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;3&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Signed &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;~&lt;span class=&quot;typename&quot;&gt;int&lt;/span&gt; | ~&lt;span class=&quot;typename&quot;&gt;int8&lt;/span&gt; | ~&lt;span class=&quot;typename&quot;&gt;int16&lt;/span&gt; | ~&lt;span class=&quot;typename&quot;&gt;int32&lt;/span&gt; | ~&lt;span class=&quot;typename&quot;&gt;int64&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这样&lt;code&gt;type MyInt int&lt;/code&gt;定义的&lt;code&gt;MyInt&lt;/code&gt;类型的实例也满足这个约束。&lt;/p&gt;
&lt;h2 id=&quot;constraints_包&quot;&gt;constraints 包&lt;/h2&gt;
&lt;p&gt;Go目前的实现新增加一个package,叫做&lt;code&gt;constraints&lt;/code&gt;,用来定义内建的约束,比如常见的:&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;1&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;2&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;3&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;4&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;5&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;6&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;7&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;8&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;9&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;10&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;11&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;12&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;13&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;14&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;15&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;16&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;17&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;18&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;19&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;20&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;21&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;22&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;23&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Signed &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;~&lt;span class=&quot;typename&quot;&gt;int&lt;/span&gt; | ~&lt;span class=&quot;typename&quot;&gt;int8&lt;/span&gt; | ~&lt;span class=&quot;typename&quot;&gt;int16&lt;/span&gt; | ~&lt;span class=&quot;typename&quot;&gt;int32&lt;/span&gt; | ~&lt;span class=&quot;typename&quot;&gt;int64&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Unsigned &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;~&lt;span class=&quot;typename&quot;&gt;uint&lt;/span&gt; | ~&lt;span class=&quot;typename&quot;&gt;uint8&lt;/span&gt; | ~&lt;span class=&quot;typename&quot;&gt;uint16&lt;/span&gt; | ~&lt;span class=&quot;typename&quot;&gt;uint32&lt;/span&gt; | ~&lt;span class=&quot;typename&quot;&gt;uint64&lt;/span&gt; | ~&lt;span class=&quot;typename&quot;&gt;uintptr&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Integer &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;Signed | Unsigned&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Float &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;~&lt;span class=&quot;typename&quot;&gt;float32&lt;/span&gt; | ~&lt;span class=&quot;typename&quot;&gt;float64&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Complex &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;~&lt;span class=&quot;typename&quot;&gt;complex64&lt;/span&gt; | ~&lt;span class=&quot;typename&quot;&gt;complex128&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Ordered &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;Integer | Float | ~&lt;span class=&quot;typename&quot;&gt;string&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;甚至 Russ Cox、Ian Lance Taylor他们 提议和讨论为 slice、map、chan增加必要的约束，因为它们太常用了，标准库中都可以用到。(&lt;a href=&quot;https://github.com/golang/go/discussions/47203&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;#47203&lt;/a&gt;、&lt;a href=&quot;https://github.com/golang/go/discussions/47319&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;#47319&lt;/a&gt;、&lt;a href=&quot;https://github.com/golang/go/discussions/47330&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;47330#&lt;/a&gt;)。&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;1&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;2&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;3&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;4&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;5&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;6&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;7&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;8&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;9&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;10&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;11&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Slice[Elem any] &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;~[]Elem&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Map[Key comparable, Val any] &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;~&lt;span class=&quot;keyword&quot;&gt;map&lt;/span&gt;[Key]Val&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;type&lt;/span&gt; Chan[Elem any] &lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;~&lt;span class=&quot;keyword&quot;&gt;chan&lt;/span&gt; Elem&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;blockquote&gt;
&lt;p&gt;Rob Pike 最近新提交了一个issue,建议在Go 1.18中不要对标准库增加泛型的支持&lt;a href=&quot;https://github.com/golang/go/issues/48918&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;#48918&lt;/a&gt;。离Go 1.18发布就四个月了，很多实现还在摸索之中，这是大师给出的一个很中肯的建议，建议相关的哭的改动先增加到扩展库中(&lt;code&gt;x/exp&lt;/code&gt;),成熟后再加到标准库中，得到了很多Gopher的赞同。这是另外一个话题了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;包&lt;code&gt;constraints&lt;/code&gt;定义常用的约束可以很好的帮助我们开发，但是你有没有感觉有点异常？&lt;/p&gt;
&lt;h2 id=&quot;省略接口&quot;&gt;省略接口&lt;/h2&gt;
&lt;p&gt;是的，依照Go泛型规范，我们必须定义一个约束，然后才能在泛型类型和泛型方法中使用，和其它语言的泛型定义相比，你有没有觉得这一点有脱裤子放屁多此一举的味道？&lt;/p&gt;
&lt;p&gt;你看上面的Slice、Map、Chan的定义，是不是很冗余？为什么我们不能直接在泛型类型和方法的定义中直接使用&lt;code&gt;~[]Elem&lt;/code&gt;、&lt;code&gt;~map[Key]Val&lt;/code&gt;、&lt;code&gt;~chan Elem&lt;/code&gt;呢？&lt;/p&gt;
&lt;p&gt;因此fzipp提议，对于一个非接口的类型，默认等价为一个约束&lt;a href=&quot;https://github.com/golang/go/issues/48424&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;#48424&lt;/a&gt;，下面的公式很好的描述了这个功能：&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;1&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;[T nonInterfaceType] ≡ [T &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt;&lt;/span&gt;{~nonInterfaceType}]&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;在泛型的定义中，非接口类型&lt;code&gt;nonInterfaceType&lt;/code&gt;等价于约束&lt;code&gt;interface{~nonInterfaceType}&lt;/code&gt;, 比如&lt;code&gt;~int&lt;/code&gt;等价于&lt;code&gt;interface{~int}&lt;/code&gt;。这样我们就可以省略&lt;code&gt;constraints&lt;/code&gt;包了。 这个提议北接收了，而且相关功能也加入到了go master分支中。&lt;/p&gt;
&lt;p&gt;mattn的Go泛型例子中，将一个整形数组转换成一个chan的&lt;a href=&quot;https://github.com/mattn/go-generics-example/blob/main/constraints-chan/main.go&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;例子&lt;/a&gt;(我稍微改动成更地道的Go的写法):&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;1&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;2&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;3&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;4&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;5&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;6&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;7&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;8&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;9&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;10&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;11&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;12&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;13&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;14&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;15&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;16&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;17&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;18&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;19&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;20&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;21&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;22&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;23&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;24&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;25&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;26&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;27&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;28&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;29&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; (&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;constraints&quot;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;context&quot;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;)&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; makeChan[T constraints.Chan[E], E any](ctx context.Context, arr []E) T {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;ch := &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;(T)&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt;() {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;close&lt;/span&gt;(ch)&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; _, v := &lt;span class=&quot;keyword&quot;&gt;range&lt;/span&gt; arr {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; ch &amp;lt;- v:&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}()&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ch&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; main() {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; v := &lt;span class=&quot;keyword&quot;&gt;range&lt;/span&gt; makeChan(context.Background(), []&lt;span class=&quot;typename&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;{1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt; 2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt; 3&lt;/span&gt;}) {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;fmt.Println(v)&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;这里使用的是&lt;code&gt;constraints.Chan[E]&lt;/code&gt;代表一个泛型的channel，现在可以用更简便的方法了:&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;1&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;2&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;3&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;4&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;5&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;6&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;7&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;8&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;9&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;10&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;11&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;12&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;13&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;14&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;15&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;16&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;17&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;18&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;19&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;20&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;21&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;package&lt;/span&gt; main&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; (&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;context&quot;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;)&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; makeChan[T &lt;span class=&quot;keyword&quot;&gt;chan&lt;/span&gt; E, E any](ctx context.Context, arr []E) T {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;ch := &lt;span class=&quot;built_in&quot;&gt;make&lt;/span&gt;(T)&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt;() {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;defer&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;close&lt;/span&gt;(ch)&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; _, v := &lt;span class=&quot;keyword&quot;&gt;range&lt;/span&gt; arr {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;select&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &amp;lt;-ctx.Done():&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; ch &amp;lt;- v:&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}()&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; ch&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;直接使用&lt;code&gt;chan E&lt;/code&gt;就可以了，方不方便？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;chan E&lt;/code&gt; 隐式地代表&lt;code&gt;interface {chan E}&lt;/code&gt;,使用起来更简捷，不需要额外的接口(约束)定义。&lt;/p&gt;
&lt;p&gt;虽然Go 1.18的临近，感觉Go泛型的开发工作越来越重，甚至有一些还不明确的地方，祝福一下吧，希望它顺顺利利的推出。&lt;/p&gt;

      
    &lt;/div&gt;
    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>09d8fd176f9b2814befc6389d7aa0f75</guid>
<title>揭秘 Golang 内存管理优化！三色标记法源码浅析</title>
<link>https://toutiao.io/k/663izdo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.212&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/E7QbOwiaziaTicnnEkDGarHVZp8HOhePeER3Pp90fQLp32vBibuHnu5Jiar8ic6dJUkLhkZ2JoaLCXup1rL89IQK4U2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1500&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;93770&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;导语&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;       &lt;/span&gt;&lt;/span&gt;&lt;span&gt;垃圾回收的第一步是什么呢？要找到垃圾，如果我们反其道而行之，找到所有的存活对象，是不是也等于找到了垃圾呢? 本文想要探讨的gcDrain函数就是使用三色标记法找到存活对象的一个重要函数，了解gcDrain函数就会对golang垃圾回收机制有更深的理解。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;一. &lt;/span&gt;&lt;span&gt;源自某次技术需求后的发现&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;对于想要了解&lt;/span&gt;&lt;code&gt;golang&lt;/code&gt;&lt;span&gt;垃圾回收来源于一次技术需求，某天，当我愉快的把代码灰度发布到正式环境后，出现了问题，123平台的火焰图有些异常。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;505&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8730822873082287&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/E7QbOwiaziaTib3AY0JOQRaxhicVXUOEjiaCRgdqiaksqyjib5RZI7fibOKfeC1d7aE9IrhTksUicdceLoicMk8AEZnibDsug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;717&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;图里&lt;/span&gt;&lt;code&gt;runtime.scanobject&lt;/code&gt;&lt;span&gt;这部分是大平顶，这说明&lt;/span&gt;&lt;code&gt;cpu&lt;/code&gt;&lt;span&gt;在这部分耗时是很久的，而&lt;/span&gt;&lt;code&gt;runtime.scanobject&lt;/code&gt;&lt;span&gt;是属于&lt;/span&gt;&lt;code&gt;runtime.gcDrain&lt;/code&gt;&lt;span&gt;这个函数的，最下方调用的函数是&lt;/span&gt;&lt;code&gt;runtime.gcBgMarkWorker&lt;/code&gt;&lt;span&gt;，这些函数看上去和垃圾回收是有关系的(garbage collection)，那么&lt;/span&gt;&lt;code&gt;golang&lt;/code&gt;&lt;span&gt;的垃圾回收是什么样的呢?&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;二. golang垃圾回收小史&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;&lt;code&gt;golang&lt;/code&gt;&lt;span&gt;版本发展的历史中，垃圾回收器机制的演进占据了重要的位置。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;385&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6656346749226006&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/E7QbOwiaziaT86Y9D2hV3EqIRTrDcvlOUknPtJNL6wmEtX0yb9BfeWZSUNy1Joo9ErE7NlfHyhpFXF2ZWj5T7r8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1292&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;code&gt;golang&lt;/code&gt;&lt;span&gt;在1.0版本引入了串行标记清扫，在进行标记和清扫工作时，所有的&lt;/span&gt;&lt;code&gt;goroutine&lt;/code&gt;&lt;span&gt;都会停下来(stop the word)等待这两个工作的结束。如果说我们的服务中要使用到大量的内存，&lt;/span&gt;&lt;code&gt;golang&lt;/code&gt;&lt;span&gt;程序会发生明显的卡顿现象，这对于后台服务来说是无法忍受的。到了1.3版本，将清扫的过程抽离了出来，和用户&lt;/span&gt;&lt;code&gt;goroutine&lt;/code&gt;&lt;span&gt;一起执行，提高了不少性能。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;216&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3742138364779874&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/E7QbOwiaziaT86Y9D2hV3EqIRTrDcvlOUkb38SmorDya2WMluRYqibciazJj3KjWRvR3hMRxahjHE0mVLv334pRq9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;636&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;在1.5版本中，&lt;/span&gt;&lt;code&gt;golang&lt;/code&gt;&lt;span&gt;的垃圾回收机制迎来了巨大的改变，在原先版本中标记存活对象的过程是完全占用一个&lt;/span&gt;&lt;code&gt;goroutine&lt;/code&gt;&lt;span&gt;的，而1.5版本中，标记过程和开启了写屏障的用户&lt;/span&gt;&lt;code&gt;goroutine&lt;/code&gt;&lt;span&gt;可以同时运行。实现了并行版本的三色标记清除垃圾收集器，极大的降低了&lt;/span&gt;&lt;code&gt;STW&lt;/code&gt;&lt;span&gt;的时间，&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;200&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.3458904109589041&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/E7QbOwiaziaT86Y9D2hV3EqIRTrDcvlOUkDOvjrdAY7f0y0uPqs2pQzGRpyn9sMuGV7A4Q00zbgS575gSLDibKzXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;584&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;1.8版本中，引入了混合写屏障，消除了对栈本身的重新扫描，又一次降低了&lt;/span&gt;&lt;code&gt;STW&lt;/code&gt;&lt;span&gt;的时间。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;187&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3232830820770519&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/E7QbOwiaziaT86Y9D2hV3EqIRTrDcvlOUkGtdxPvN55AatwnKXhUUUbk6ic0nq05rmgiaMxCALAgKglUNZ3nVssEdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;597&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;p data-lines=&quot;11&quot; data-type=&quot;p&quot; data-sign=&quot;89cc311b402d3aea5b40dae1ab111ac7&quot;&gt;1.13版本中，改进&lt;code&gt;Scavenger&lt;/code&gt;，这部分是垃圾回收器在回收完垃圾后将内存返回给操作系统的结构，老版本是另开一个&lt;code&gt;goroutine&lt;/code&gt;运行，在1.13版本也和其他用户&lt;code&gt;goroutine&lt;/code&gt;并发执行，进一步提高了垃圾回收器的效率。&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;19d326b3d47714e6f023c0c8f6b60005&quot;&gt;这里只是对于&lt;code&gt;golang&lt;/code&gt;垃圾回收历史中几个我觉得比较重要的改进做了说明，现在&lt;code&gt;golang&lt;/code&gt;的最新版本为1.17，如果对1.13版本之后的有关于&lt;code&gt;golang&lt;/code&gt;垃圾回收历史感兴趣的同学可以搜索&lt;code&gt;golang&lt;/code&gt;的官网查看相关的改动。&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;三. golang垃圾回收过程&lt;/span&gt;&lt;/h1&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;86f721a8f6ce7b9f21127136ac99a753&quot;&gt;&lt;span&gt;以1.13版本为例子，垃圾回收的过程以&lt;/span&gt;&lt;code&gt;&lt;span&gt;STW&lt;/span&gt;&lt;/code&gt;&lt;span&gt;作为界限可以分为5个阶段&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;center&quot;&gt;阶段&lt;/th&gt;&lt;th align=&quot;center&quot;&gt;说明&lt;/th&gt;&lt;th align=&quot;center&quot;&gt;赋值器状态&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;SweepTermination&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;清扫终止阶段，为下一个阶段的并发标记做准备工作，启动写屏障&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;STW&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;Mark&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;扫描标记阶段，与赋值器并发执行，写屏障开启&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;并发&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;MarkTermination&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;标记终止阶段，保证一个周期内标记任务完成，停止写屏障&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;STW&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;GCoff&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;内存清扫阶段，将需要回收的内存暂存，写屏障关闭&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;并发&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;GCoff&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;内存归还阶段，将内存依照策略归还给操作系统，写屏障关闭&lt;/td&gt;&lt;td align=&quot;center&quot;&gt;并发&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-lines=&quot;6&quot; data-type=&quot;p&quot; data-sign=&quot;b87c9a580581b8978b81778b547afd90&quot;&gt;&lt;span&gt;每个阶段的触发函数如下:&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;343&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5932203389830508&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/E7QbOwiaziaT86Y9D2hV3EqIRTrDcvlOUkQmuXMuQvX6CaibdetFXSGDuxJgI5svOgc7iaSk6icKQayKvzvRZZr0xaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;649&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;再看下我们最早提到的火焰图中有关于垃圾回收这一部分:&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;133&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.23057644110275688&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/E7QbOwiaziaT86Y9D2hV3EqIRTrDcvlOUkKiaQoXwFLfxI3Tn8XQSwjHicjLfmXzCeoIzMT21ziblSUclReFYicMp1HQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1197&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;可以看出我们性能较差的地方在&lt;/span&gt;&lt;code&gt;gcBgMarkWorker&lt;/code&gt;&lt;span&gt;这个函数中，说明我们在标记存活对象的过程中&lt;/span&gt;&lt;code&gt;cpu&lt;/code&gt;&lt;span&gt;耗费了大量的时间。其中&lt;/span&gt;&lt;code&gt;gcDrain&lt;/code&gt;&lt;span&gt;就是三色标记法在&lt;/span&gt;&lt;code&gt;golang&lt;/code&gt;&lt;span&gt;中的实现。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;span&gt;四. &lt;/span&gt;&lt;span&gt;三色标记法&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;三色标记法是&lt;/span&gt;&lt;code&gt;golang&lt;/code&gt;&lt;span&gt;在堆内存中寻找存活对象的抽象过程。&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;274&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.47309833024118736&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/E7QbOwiaziaT86Y9D2hV3EqIRTrDcvlOUk48cvcJd3PBl3iaZmLB47JvJ4MfQqNEHXVib9oQsz0FxG2mofx496qicNw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1078&quot;/&gt;&lt;span/&gt;&lt;/section&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;159f9a827a2f9c7b956b023c467408cd&quot;&gt;其中黑色对象标识该对象已经被标记过了，且黑色对象引用的对象也全部都被标记过了。灰色对象表示该对象已经被标记了但是该对象引用的对象没有被全部标记。白色对象就是没有被标记的对象，被认为是潜在的垃圾，在标记开始前，所有对象都是白色对象。&lt;/p&gt;&lt;p data-lines=&quot;4&quot; data-type=&quot;p&quot; data-sign=&quot;b1604d5f2af539ed26fb89673333b4c1&quot;&gt;在垃圾收集器开始工作时，从根对象开始进行遍历访问，有如下几个步骤:&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;233&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.40297450424929177&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/E7QbOwiaziaT86Y9D2hV3EqIRTrDcvlOUkJj5LhPWnec6FSkjDcpWV73uJbicJdG7Il3y50X0EqDu1MwfyhNkgU7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1412&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;通过这种方式，&lt;/span&gt;&lt;code&gt;golang&lt;/code&gt;&lt;span&gt;垃圾收集器就可以找到需要进行回收的垃圾，不过这是抽象层面的做法，具体的实现在之后的章节会有介绍。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;span&gt;五. &lt;/span&gt;&lt;span&gt;写屏障&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;在&lt;/span&gt;&lt;code&gt;golang&lt;/code&gt;&lt;span&gt;1.5之后，标记垃圾的协程和用户用户协程可以并发执行，这样就会出现问题，如果把垃圾标记为存活对象，虽然这对于垃圾收集器来讲是错误的但是它不影响程序的正确性，垃圾收集器只要在下一次垃圾收集的过程中将这个对象收集就好了，但是如果标记垃圾执行在前，将一个对象标记为垃圾，然而用户协程又引用了这个对象，这就会造成把存活对象当作垃圾的冤案。下面有一个例子可以说明这个问题&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;150&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.26002587322121606&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/E7QbOwiaziaT86Y9D2hV3EqIRTrDcvlOUk7y31BDSsxBhL9d3mw94fC7Twicicq441cT589xicVd97ZBpics3HZml9ug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;773&quot;/&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;初始状态：假设某个黑色对象 C 指向某个灰色对象 A ，而 A 指向白色对象 B；&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;C.ref3 = C.ref2.ref1：赋值器并发地将黑色对象 C 指向（ref3）了白色对象 B；&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;A.ref1 = nil：移除灰色对象 A 对白色对象 B 的引用（ref2）；&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;最终状态：在继续扫描的过程中，白色对象 B 永远不会被标记为黑色对象了（回收器不会重新扫描黑色对象），进而对象 B 被错误地回收&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;那么如何解决这种问题呢，&lt;/span&gt;&lt;code&gt;golang&lt;/code&gt;&lt;span&gt;1.5引入了写屏障机制来确保垃圾回收器的正确性。&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;181&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.31417979610750696&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/E7QbOwiaziaT86Y9D2hV3EqIRTrDcvlOUkOQzb74beZyGsNNI57pzT6qufKJRiaveXT9kX8YEFkJhrOtx31yXnW3g/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1079&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;●强三色不变式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注白色指针指向黑色对象的写入操作，不允许出现黑色指针指向白色，如果出现黑色对象指向白色对象，那就使用插入写屏障，具体的做法就是将黑色对象指向的白色对象涂灰或者将黑色对象涂灰。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;●弱三色&lt;/span&gt;&lt;span&gt;不变式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果有黑色对象指向白色对象时继续观察，如果还有灰色对象指向该白色对象，说明满足弱三色不变式，弱三色不变式提醒我们关注对那些白色对象路径的破坏行为。解决这个问题的方式是删除写屏障，可以把灰色对象指向的白色对象涂灰，这样黑色对象指向的就是灰色对象而不是之前的白色对象。&lt;br/&gt;使用写屏障之后，垃圾回收器的正确性就得到了保障。&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;&lt;span&gt;六. &lt;/span&gt;&lt;span&gt;gcDrain函数的实现&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;h2 data-lines=&quot;2&quot; data-sign=&quot;12b979d65acbd06b938985bd2160f390&quot;&gt;&lt;span&gt;6.1 gcDrain函数的触发阶段&lt;/span&gt;&lt;/h2&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;8d4a5460d643c325c66524cfed437306&quot;&gt;从之前的火焰图可以看出来，&lt;code&gt;gcDrain&lt;/code&gt;函数是火焰图中大平顶函数的调用的函数之一&lt;/p&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;3903bf93e456b71861662791219f098f&quot;&gt;该函数的触发位置如图所示，处在&lt;code&gt;STW&lt;/code&gt;之后的标记阶段&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;316&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5473537604456824&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/E7QbOwiaziaT86Y9D2hV3EqIRTrDcvlOUkDfNE9iaPibRFoX6hHGmR3rs6ekotjicQTTiaBSBkqg0olibZkHYiawx9Tleg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;718&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-lines=&quot;2&quot; data-sign=&quot;12b979d65acbd06b938985bd2160f390&quot;&gt;&lt;span&gt;6.2 gcDrain函数的参数&lt;/span&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;func &lt;span&gt;gcDrain&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;gcw &lt;span&gt;*&lt;/span&gt;gcWork&lt;span&gt;,&lt;/span&gt; flags gcDrainFlags&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;23c7574e36a9c0caa0aee2939b459dde&quot;&gt;&lt;code&gt;gcDrain&lt;/code&gt;函数的参数有两个，其中&lt;code&gt;gcw&lt;/code&gt;是该函数主要处理的结构，&lt;code&gt;gcDrainFlags&lt;/code&gt;和&lt;code&gt;golang&lt;/code&gt;的调度有很大关系&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; p &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;...&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 每个p上绑定一个gcWork&lt;/span&gt;&lt;br/&gt;    gcw gcWork&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; gcWork &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 本地工作缓存，wbuf1为主工作缓存，wbuf2为副工作缓存&lt;/span&gt;&lt;br/&gt;wbuf1&lt;span&gt;,&lt;/span&gt; wbuf2 &lt;span&gt;*&lt;/span&gt;workbuf&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 标记变黑的结点&lt;/span&gt;&lt;br/&gt;bytesMarked &lt;span&gt;uint64&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 每个p做了多少标记工作的记录，与调度有关&lt;/span&gt;&lt;br/&gt;scanWork &lt;span&gt;int64&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// gcWork的workbuff是否与全局workbuff进行过flash操作&lt;/span&gt;&lt;br/&gt;    flushedWork &lt;span&gt;bool&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;008e5f9a1460ff4b1d739b262de17add&quot;&gt;&lt;code&gt;p(process)&lt;/code&gt;是&lt;code&gt;golang&lt;/code&gt;定义的一个抽象的概念，它不是物理上的&lt;code&gt;CPU&lt;/code&gt;，当一个&lt;code&gt;P&lt;/code&gt;有任务，需要创建或者唤醒一个系统线程去处理它队列中的任务，&lt;code&gt;P&lt;/code&gt;决定同时执行的任务数量，我们平常会经常看到&lt;code&gt;GOMAXPROCS&lt;/code&gt;这个参数，&lt;code&gt;GOMAXPROCS&lt;/code&gt;就是限制系统线程执行用户层面的任务的数量，可以简单的理解为一个&lt;code&gt;p&lt;/code&gt;对应一个物理核心。每个&lt;code&gt;p&lt;/code&gt;上会绑定一个&lt;code&gt;gcWork&lt;/code&gt;，&lt;code&gt;gcWork&lt;/code&gt;中最重要的结构就是两个本地工作缓存&lt;code&gt;wbuf1&lt;/code&gt;和&lt;code&gt;wbuf2&lt;/code&gt;。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; workbuf &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;workbufhdr&lt;br/&gt;&lt;span&gt;// uintptr 是golang的内置类型，可以存储指针的整型，这种指针类型是可以做运算的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// obj 是一个指针数组，每个元素是一个可以进行计算的指针，该指针通过计算可以指向灰色对象&lt;/span&gt;&lt;br/&gt;obj &lt;span&gt;[&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;_WorkbufSize &lt;span&gt;-&lt;/span&gt; unsafe&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Sizeof&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;workbufhdr&lt;span&gt;{&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;/&lt;/span&gt; sys&lt;span&gt;.&lt;/span&gt;PtrSize&lt;span&gt;]&lt;/span&gt;&lt;span&gt;uintptr&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; workbufhdr &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 灰色对象&lt;/span&gt;&lt;br/&gt;node lfnode&lt;br/&gt;&lt;span&gt;// 工作缓存中灰色对象的个数&lt;/span&gt;&lt;br/&gt;nobj &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Lock-free stack node.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// lock-free机制的底层实现是CAS，目的是为了解决并发问题&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; lfnode &lt;span&gt;struct&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;next    &lt;span&gt;uint64&lt;/span&gt;&lt;br/&gt;pushcnt &lt;span&gt;uintptr&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;28dc9f29ba470a85e6608cdb3f76b804&quot;&gt;我们可以认为&lt;code&gt;wbuf1&lt;/code&gt;和&lt;code&gt;wbuf2&lt;/code&gt;中存储的是灰色对象，具体存储的地方就在&lt;code&gt;obj&lt;/code&gt;这个指针数组中，其中指针数组中灰色对象的个数为&lt;code&gt;nobj&lt;/code&gt;，灰色对象被定义为&lt;code&gt;lfnode&lt;/code&gt;，&lt;code&gt;lfnode&lt;/code&gt;的底层实现涉及到了&lt;code&gt;CAS(Compare And Swag)&lt;/code&gt;，这是为了解决并发问题。&lt;/p&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;a31f37d81d4f2c10460a3a226d808e2f&quot;&gt;&lt;code&gt;gcDrain&lt;/code&gt;函数主要就是在使用&lt;code&gt;wbuf1&lt;/code&gt;、&lt;code&gt;wbuf2&lt;/code&gt;以及全局&lt;code&gt;wbuf&lt;/code&gt;来实现三色标记法，而引入全局&lt;code&gt;wbuf&lt;/code&gt;的目的在于平衡每个&lt;code&gt;P&lt;/code&gt;的工作量，不至于旱的旱死，涝的涝死。&lt;/p&gt;&lt;h2 data-lines=&quot;2&quot; data-sign=&quot;12b979d65acbd06b938985bd2160f390&quot;&gt;&lt;span&gt;6.3 操作gcWork中灰色对象的函数&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;382&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6607329842931937&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/E7QbOwiaziaT86Y9D2hV3EqIRTrDcvlOUkGmiaxp3nHzFnxNYRKppSl2no9nOmD8jnp9REWibqBorYzENggicKfgORA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;955&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;针对&lt;/span&gt;&lt;code&gt;gcWork&lt;/code&gt;&lt;span&gt;的操作有六个，总结下来其实是四个，带有&lt;/span&gt;&lt;code&gt;Fast&lt;/code&gt;&lt;span&gt;后缀的方法是其主方法的简单实现形式，目的是减少使用主方法带来的代价。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;h2 data-lines=&quot;2&quot; data-sign=&quot;12b979d65acbd06b938985bd2160f390&quot;&gt;&lt;span&gt;6.3.1 put&lt;/span&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;w &lt;span&gt;*&lt;/span&gt;gcWork&lt;span&gt;)&lt;/span&gt; &lt;span&gt;put&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;obj &lt;span&gt;uintptr&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;flushed &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;wbuf &lt;span&gt;:=&lt;/span&gt; w&lt;span&gt;.&lt;/span&gt;wbuf1&lt;br/&gt;    &lt;span&gt;...&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 如果wbuf1没有创建&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; wbuf &lt;span&gt;==&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 初始化并给wbuf1一个空值&lt;/span&gt;&lt;br/&gt;w&lt;span&gt;.&lt;/span&gt;&lt;span&gt;init&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;wbuf &lt;span&gt;=&lt;/span&gt; w&lt;span&gt;.&lt;/span&gt;wbuf1&lt;br/&gt;  &lt;span&gt;// 如果wbuf1是满的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; wbuf&lt;span&gt;.&lt;/span&gt;nobj &lt;span&gt;==&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;wbuf&lt;span&gt;.&lt;/span&gt;obj&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// wbuf1和wbuf2进行交换&lt;/span&gt;&lt;br/&gt;w&lt;span&gt;.&lt;/span&gt;wbuf1&lt;span&gt;,&lt;/span&gt; w&lt;span&gt;.&lt;/span&gt;wbuf2 &lt;span&gt;=&lt;/span&gt; w&lt;span&gt;.&lt;/span&gt;wbuf2&lt;span&gt;,&lt;/span&gt; w&lt;span&gt;.&lt;/span&gt;wbuf1&lt;br/&gt;wbuf &lt;span&gt;=&lt;/span&gt; w&lt;span&gt;.&lt;/span&gt;wbuf1&lt;br/&gt;        &lt;span&gt;// 如果交换之后还是满的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; wbuf&lt;span&gt;.&lt;/span&gt;nobj &lt;span&gt;==&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;wbuf&lt;span&gt;.&lt;/span&gt;obj&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 就把wbuf1中的灰色对象放入全局工作缓存中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;putfull&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;wbuf&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 与全局工作缓存执行过交流后设置该标记位&lt;/span&gt;&lt;br/&gt;w&lt;span&gt;.&lt;/span&gt;flushedWork &lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// 将wbuf1的内容置为空&lt;/span&gt;&lt;br/&gt;wbuf &lt;span&gt;=&lt;/span&gt; &lt;span&gt;getempty&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;w&lt;span&gt;.&lt;/span&gt;wbuf1 &lt;span&gt;=&lt;/span&gt; wbuf&lt;br/&gt;flushed &lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 如果wbuf1不满，就直接操作wubf1&lt;/span&gt;&lt;br/&gt;wbuf&lt;span&gt;.&lt;/span&gt;obj&lt;span&gt;[&lt;/span&gt;wbuf&lt;span&gt;.&lt;/span&gt;nobj&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; obj&lt;br/&gt;wbuf&lt;span&gt;.&lt;/span&gt;nobj&lt;span&gt;++&lt;/span&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;413&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7154772937905468&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/E7QbOwiaziaT86Y9D2hV3EqIRTrDcvlOUkeugNn7ynyrZVn1DPbnJr39FySTfe4Um7jTRDmxJILt2zQPfYgV59vA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1079&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;&lt;span&gt;其中&lt;/span&gt;&lt;code&gt;put&lt;/code&gt;&lt;span&gt;操作就是将灰色对象放入&lt;/span&gt;&lt;code&gt;wbuf1&lt;/code&gt;&lt;span&gt;中，如果&lt;/span&gt;&lt;code&gt;wbuf1&lt;/code&gt;&lt;span&gt;满了就将&lt;/span&gt;&lt;code&gt;wbuf1&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code&gt;wbuf2&lt;/code&gt;&lt;span&gt;进行交换，如果交换之后依旧是满的，那么就将这部分灰色对象flush到全局工作缓存中，并将&lt;/span&gt;&lt;code&gt;flushedWork&lt;/code&gt;&lt;span&gt;标记为true，这意味着&lt;/span&gt;&lt;code&gt;gcWork&lt;/code&gt;&lt;span&gt;中的&lt;/span&gt;&lt;code&gt;wbuf&lt;/code&gt;&lt;span&gt;与全局&lt;/span&gt;&lt;code&gt;wbuf&lt;/code&gt;&lt;span&gt;有过数据交换。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;h2 data-lines=&quot;2&quot; data-sign=&quot;12b979d65acbd06b938985bd2160f390&quot;&gt;&lt;span&gt;6.3.2 &lt;/span&gt;&lt;span&gt;tryGet&lt;/span&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;w &lt;span&gt;*&lt;/span&gt;gcWork&lt;span&gt;)&lt;/span&gt; &lt;span&gt;tryGet&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;uintptr&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;wbuf &lt;span&gt;:=&lt;/span&gt; w&lt;span&gt;.&lt;/span&gt;wbuf1&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; wbuf &lt;span&gt;==&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;w&lt;span&gt;.&lt;/span&gt;&lt;span&gt;init&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;wbuf &lt;span&gt;=&lt;/span&gt; w&lt;span&gt;.&lt;/span&gt;wbuf1&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 当wbuf1缓冲区中没有灰色对象时&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; wbuf&lt;span&gt;.&lt;/span&gt;nobj &lt;span&gt;==&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// wubf1 与 wbuf2 进行对象互换&lt;/span&gt;&lt;br/&gt;w&lt;span&gt;.&lt;/span&gt;wbuf1&lt;span&gt;,&lt;/span&gt; w&lt;span&gt;.&lt;/span&gt;wbuf2 &lt;span&gt;=&lt;/span&gt; w&lt;span&gt;.&lt;/span&gt;wbuf2&lt;span&gt;,&lt;/span&gt; w&lt;span&gt;.&lt;/span&gt;wbuf1&lt;br/&gt;wbuf &lt;span&gt;=&lt;/span&gt; w&lt;span&gt;.&lt;/span&gt;wbuf1&lt;br/&gt;&lt;span&gt;// 如果交换完还为空，意味着本地的主从buffer均为空&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; wbuf&lt;span&gt;.&lt;/span&gt;nobj &lt;span&gt;==&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;owbuf &lt;span&gt;:=&lt;/span&gt; wbuf&lt;br/&gt;&lt;span&gt;// 需要从全局工作缓存中取&lt;/span&gt;&lt;br/&gt;wbuf &lt;span&gt;=&lt;/span&gt; &lt;span&gt;trygetfull&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 如果全局工作缓存中也没有灰色对象，就返回&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; wbuf &lt;span&gt;==&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;putempty&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;owbuf&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 将得到的灰色对象给wbuf1&lt;/span&gt;&lt;br/&gt;w&lt;span&gt;.&lt;/span&gt;wbuf1 &lt;span&gt;=&lt;/span&gt; wbuf&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;wbuf&lt;span&gt;.&lt;/span&gt;nobj&lt;span&gt;--&lt;/span&gt;&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; wbuf&lt;span&gt;.&lt;/span&gt;obj&lt;span&gt;[&lt;/span&gt;wbuf&lt;span&gt;.&lt;/span&gt;nobj&lt;span&gt;]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;413&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7154772937905468&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/E7QbOwiaziaT86Y9D2hV3EqIRTrDcvlOUkWS6xjn84ZRcxiasH7a7LFPoAsqibfWzO6kamFxy7kBjx7NPHmF0F53Ww/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1079&quot;/&gt;&lt;/p&gt;&lt;h2 data-lines=&quot;2&quot; data-sign=&quot;12b979d65acbd06b938985bd2160f390&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span&gt;首先判断&lt;/span&gt;&lt;code&gt;wbuf1&lt;/code&gt;&lt;span&gt;中是否有灰色对象，如果没有就将&lt;/span&gt;&lt;code&gt;wbuf1&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code&gt;wbuf2&lt;/code&gt;&lt;span&gt;进行交换，如果两个&lt;/span&gt;&lt;code&gt;wbuf&lt;/code&gt;&lt;span&gt;均为空，那么就需要请求全局工作缓存中的灰色对象了，与全局工作缓存的交互保证了每个&lt;/span&gt;&lt;code&gt;P&lt;/code&gt;&lt;span&gt;上绑定的&lt;/span&gt;&lt;code&gt;gcWork&lt;/code&gt;&lt;span&gt;不至于太忙也不至于太闲。&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-lines=&quot;2&quot; data-sign=&quot;12b979d65acbd06b938985bd2160f390&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-lines=&quot;2&quot; data-sign=&quot;12b979d65acbd06b938985bd2160f390&quot;&gt;&lt;span&gt;&lt;span&gt;5.3.3&lt;/span&gt;&lt;/span&gt;&lt;span&gt; bal&lt;/span&gt;&lt;span&gt;&lt;span&gt;ance&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-lines=&quot;2&quot; data-sign=&quot;12b979d65acbd06b938985bd2160f390&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span&gt;在&lt;/span&gt;&lt;code&gt;gcDrain&lt;/code&gt;&lt;span&gt;的源码中，如果全局工作&lt;/span&gt;&lt;code&gt;wbuf&lt;/code&gt;&lt;span&gt;为空，会尝试使用&lt;/span&gt;&lt;code&gt;balance()&lt;/code&gt;&lt;span&gt;函数将本地&lt;/span&gt;&lt;code&gt;wbuf&lt;/code&gt;&lt;span&gt;的一部分灰色对象贡献给全局&lt;/span&gt;&lt;code&gt;wbuf&lt;/code&gt;&lt;/span&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;w &lt;span&gt;*&lt;/span&gt;gcWork&lt;span&gt;)&lt;/span&gt; &lt;span&gt;balance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; w&lt;span&gt;.&lt;/span&gt;wbuf1 &lt;span&gt;==&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 这里wbuf1, wbuf2队列还没有初始化&lt;/span&gt;&lt;br/&gt;&lt;span&gt;return&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 如果wbuf2不为空，则上交到全局，并获取一个空的队列给wbuf2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; wbuf &lt;span&gt;:=&lt;/span&gt; w&lt;span&gt;.&lt;/span&gt;wbuf2&lt;span&gt;;&lt;/span&gt; wbuf&lt;span&gt;.&lt;/span&gt;nobj &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;putfull&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;wbuf&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;w&lt;span&gt;.&lt;/span&gt;flushedWork &lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;w&lt;span&gt;.&lt;/span&gt;wbuf2 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;getempty&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; wbuf &lt;span&gt;:=&lt;/span&gt; w&lt;span&gt;.&lt;/span&gt;wbuf1&lt;span&gt;;&lt;/span&gt; wbuf&lt;span&gt;.&lt;/span&gt;nobj &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;4&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 把未满的wbuf1分成两半，并把其中一半上交到全局队列&lt;/span&gt;&lt;br/&gt;w&lt;span&gt;.&lt;/span&gt;wbuf1 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;handoff&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;wbuf&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;w&lt;span&gt;.&lt;/span&gt;flushedWork &lt;span&gt;=&lt;/span&gt; &lt;span&gt;true&lt;/span&gt; &lt;span&gt;// handoff did putfull&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;return&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-lines=&quot;2&quot; data-sign=&quot;12b979d65acbd06b938985bd2160f390&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;451&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7794253938832252&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/E7QbOwiaziaT86Y9D2hV3EqIRTrDcvlOUkbQY1eOKqqdaWt8j27wdYjqTAhdOoX8hwPFUPgPvH9YAc85oYtibA10g/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1079&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;如果&lt;/span&gt;&lt;code&gt;wbuf2&lt;/code&gt;&lt;span&gt;不为空，意味着&lt;/span&gt;&lt;code&gt;wbuf1&lt;/code&gt;&lt;span&gt;与&lt;/span&gt;&lt;code&gt;wbuf2&lt;/code&gt;&lt;span&gt;已经进行过一次交换了，说明此时该&lt;/span&gt;&lt;code&gt;p&lt;/code&gt;&lt;span&gt;上的&lt;/span&gt;&lt;code&gt;gcWork&lt;/code&gt;&lt;span&gt;的工作量是比较大的，为了缓解工作压力，&lt;/span&gt;&lt;code&gt;balance()&lt;/code&gt;&lt;span&gt;函数会将&lt;/span&gt;&lt;code&gt;wbuf2&lt;/code&gt;&lt;span&gt;中的灰色对象全部&lt;/span&gt;&lt;code&gt;flush&lt;/code&gt;&lt;span&gt;到全局&lt;/span&gt;&lt;code&gt;wbuf&lt;/code&gt;&lt;span&gt;中。除了会扫描&lt;/span&gt;&lt;code&gt;wbuf2&lt;/code&gt;&lt;span&gt;以外，&lt;/span&gt;&lt;code&gt;balance()&lt;/code&gt;&lt;span&gt;还会扫描&lt;/span&gt;&lt;code&gt;wbuf1&lt;/code&gt;&lt;span&gt;中的灰色对象，如果&lt;/span&gt;&lt;code&gt;wbuf1&lt;/code&gt;&lt;span&gt;中的灰色对象的个数大于4，也会将&lt;/span&gt;&lt;code&gt;wbuf1&lt;/code&gt;&lt;span&gt;中的一半的灰色对象&lt;/span&gt;&lt;code&gt;flush&lt;/code&gt;&lt;span&gt;到全局&lt;/span&gt;&lt;code&gt;wbuf&lt;/code&gt;&lt;span&gt;中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5.3.4 &lt;/span&gt;&lt;span&gt;wbBufFlush&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;&lt;span&gt;除了&lt;/span&gt;&lt;code&gt;wbuf1&lt;/code&gt;&lt;span&gt;和&lt;/span&gt;&lt;code&gt;wbuf2&lt;/code&gt;&lt;span&gt;以外，还有一个专门存放由写屏障产生的灰色对象，我们称之为&lt;/span&gt;&lt;code&gt;wbbuf&lt;/code&gt;&lt;span&gt;，在&lt;/span&gt;&lt;code&gt;gcDrain&lt;/code&gt;&lt;span&gt;中只使用了&lt;/span&gt;&lt;code&gt;wbBufFlush&lt;/code&gt;&lt;span&gt;函数将&lt;/span&gt;&lt;code&gt;wbbuf&lt;/code&gt;&lt;span&gt;中的灰色对象&lt;/span&gt;&lt;code&gt;flush&lt;/code&gt;&lt;span&gt;到全局&lt;/span&gt;&lt;code&gt;wbuf&lt;/code&gt;&lt;span&gt;中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;476&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8220574606116775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/E7QbOwiaziaT86Y9D2hV3EqIRTrDcvlOUkzW5INLibwZNwBGlqVUwXFh7ySmQ2CMmAGjwiclpZW3xrERPRPWWtw5uA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1079&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;写屏障产生灰色对象后会把灰色对象放入到&lt;/span&gt;&lt;code&gt;wbbuf&lt;/code&gt;&lt;span&gt;中，等到&lt;/span&gt;&lt;code&gt;wbbuf&lt;/code&gt;&lt;span&gt;满了之后就&lt;/span&gt;&lt;code&gt;flush&lt;/code&gt;&lt;span&gt;到全局&lt;/span&gt;&lt;code&gt;wbuf&lt;/code&gt;&lt;span&gt;中。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-lines=&quot;2&quot; data-sign=&quot;12b979d65acbd06b938985bd2160f390&quot;&gt;&lt;span&gt;5.4 gcDrain函数&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;gcDrain&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;gcw &lt;span&gt;*&lt;/span&gt;gcWork&lt;span&gt;,&lt;/span&gt; flags gcDrainFlags&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 此处一定要开启写屏障，不开启就会抛出错误&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;writeBarrier&lt;span&gt;.&lt;/span&gt;needed &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;gcDrain phase incorrect&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 这一部分代码和调度有关，每个p都有固定的扫描灰色对象的工作量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 如果根对象未扫描，则先扫描根对象，Jobs为根对象总数，next相当于一个对象任务的取数器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; work&lt;span&gt;.&lt;/span&gt;markrootNext &lt;span&gt;&amp;lt;&lt;/span&gt; work&lt;span&gt;.&lt;/span&gt;markrootJobs &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 一直循环直到被抢占或者STW&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;gp&lt;span&gt;.&lt;/span&gt;preempt &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;preemptible &lt;span&gt;||&lt;/span&gt; atomic&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Load&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;sched&lt;span&gt;.&lt;/span&gt;gcwaiting&lt;span&gt;)&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 从根对象扫描队列取出一个值&lt;/span&gt;&lt;br/&gt;job &lt;span&gt;:=&lt;/span&gt; atomic&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Xadd&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;work&lt;span&gt;.&lt;/span&gt;markrootNext&lt;span&gt;,&lt;/span&gt; &lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; job &lt;span&gt;&amp;gt;=&lt;/span&gt; work&lt;span&gt;.&lt;/span&gt;markrootJobs &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;break&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 将会扫描根对象，并把它加入到标记队列gcWork中，即把对象变为灰色&lt;/span&gt;&lt;br/&gt;&lt;span&gt;markroot&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;gcw&lt;span&gt;,&lt;/span&gt; job&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 退出标记任务的条件，与调度有关&lt;/span&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;go&lt;/span&gt; done&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 当根对象全部put到标记队列中，消费标记队列，根据对象图进行消费&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 一直循环直到被抢占或者STW&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;gp&lt;span&gt;.&lt;/span&gt;preempt &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span&gt;(&lt;/span&gt;preemptible &lt;span&gt;||&lt;/span&gt; atomic&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Load&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&amp;amp;&lt;/span&gt;sched&lt;span&gt;.&lt;/span&gt;gcwaiting&lt;span&gt;)&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 如果全局工作缓存为空,将本地的一部分工作放回全局队列中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; work&lt;span&gt;.&lt;/span&gt;full &lt;span&gt;==&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/** balance函数用来平衡各个核的工作量**/&lt;/span&gt;&lt;br/&gt;gcw&lt;span&gt;.&lt;/span&gt;&lt;span&gt;balance&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 获取任务，消费workbuf中的灰色对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 使用tryGetFast快速获取工作队列中的对象，tryGet方法虽然可以获取，但是代价较大&lt;/span&gt;&lt;br/&gt;b &lt;span&gt;:=&lt;/span&gt; gcw&lt;span&gt;.&lt;/span&gt;&lt;span&gt;tryGetFast&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; b &lt;span&gt;==&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/****tryGet函数用来获取工作缓存中的灰色对象****/&lt;/span&gt;&lt;br/&gt;b &lt;span&gt;=&lt;/span&gt; gcw&lt;span&gt;.&lt;/span&gt;&lt;span&gt;tryGet&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; b &lt;span&gt;==&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/****wbBufFlush函数将写屏障生成的灰色对象flush到全局工作缓存****/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;wbBufFlush&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;nil&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;b &lt;span&gt;=&lt;/span&gt; gcw&lt;span&gt;.&lt;/span&gt;&lt;span&gt;tryGet&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 获取不到对象，标记队列已为空，跳出循环&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; b &lt;span&gt;==&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Unable to get work.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;break&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 扫描获取到的对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;scanobject&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;b&lt;span&gt;,&lt;/span&gt; gcw&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 与调度有关，每个p只干自己分内之事&lt;/span&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;done&lt;span&gt;:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 结束的相关收尾工作&lt;/span&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-lines=&quot;3&quot; data-type=&quot;p&quot; data-sign=&quot;5c08d5620bbfd8ff783779a50d44ba73&quot;&gt;对于&lt;code&gt;gcDrain&lt;/code&gt;函数，可以理解为一个生产者消费者问题，生产者生产灰色对象放入&lt;code&gt;wbuf&lt;/code&gt;中，&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;221&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.38286109191430545&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/E7QbOwiaziaT86Y9D2hV3EqIRTrDcvlOUkkCfXpGP4nKuWTbayVRicAplCCfcIObnV9tqOPRzqmU2yV38NS8ibAnMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1447&quot;/&gt;&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;7b826ed6a826a34ba3ab9a502edf5515&quot;&gt;其中&lt;code&gt;write Barrier&lt;/code&gt;、&lt;code&gt;mark root&lt;/code&gt;以及&lt;code&gt;scan stack&lt;/code&gt;都是提供灰色对象的，这些操作中都会有着&lt;code&gt;greyObject&lt;/code&gt;这个函数的影子。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;greyobject&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;,&lt;/span&gt; base&lt;span&gt;,&lt;/span&gt; off &lt;span&gt;uintptr&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; span &lt;span&gt;*&lt;/span&gt;mspan&lt;span&gt;,&lt;/span&gt; gcw &lt;span&gt;*&lt;/span&gt;gcWork&lt;span&gt;,&lt;/span&gt; objIndex &lt;span&gt;uintptr&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; span&lt;span&gt;.&lt;/span&gt;spanclass&lt;span&gt;.&lt;/span&gt;&lt;span&gt;noscan&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 将灰色对象涂黑&lt;/span&gt;&lt;br/&gt;gcw&lt;span&gt;.&lt;/span&gt;bytesMarked &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;uint64&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;span&lt;span&gt;.&lt;/span&gt;elemsize&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;return&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 将对象放入wbuf中，也就是将对象涂灰&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;gcw&lt;span&gt;.&lt;/span&gt;&lt;span&gt;putFast&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;/****put函数将灰色对象放入工作缓存中****/&lt;/span&gt;&lt;br/&gt;gcw&lt;span&gt;.&lt;/span&gt;&lt;span&gt;put&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;498a2d38d257b43ade236a0e4f06ca49&quot;&gt;这个函数不仅仅是一个消费者，它也是一个生产者。&lt;/p&gt;&lt;p data-lines=&quot;1&quot; data-type=&quot;p&quot; data-sign=&quot;1fb38947d2fdd7a4edc2d789c483d1ba&quot;&gt;&lt;code&gt;scanObject&lt;/code&gt;这个函数就是三色标记法中通过灰色对象去扫描该对象的引用对象，并将其涂灰&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;scanobject&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;b &lt;span&gt;uintptr&lt;/span&gt;&lt;span&gt;,&lt;/span&gt; gcw &lt;span&gt;*&lt;/span&gt;gcWork&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 获取 b 的 heapBits 对象&lt;/span&gt;&lt;br/&gt;hbits &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;heapBitsForAddr&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;b&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 获取span&lt;/span&gt;&lt;br/&gt;s &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;spanOfUnchecked&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;b&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// span对应的大小&lt;/span&gt;&lt;br/&gt;n &lt;span&gt;:=&lt;/span&gt; s&lt;span&gt;.&lt;/span&gt;elemsize&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; n &lt;span&gt;==&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;&quot;scanobject n == 0&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 如果对象过大，切割后扫描&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 每次最大只扫描128KB&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; n &lt;span&gt;&amp;gt;&lt;/span&gt; maxObletBytes &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; b &lt;span&gt;==&lt;/span&gt; s&lt;span&gt;.&lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; s&lt;span&gt;.&lt;/span&gt;spanclass&lt;span&gt;.&lt;/span&gt;&lt;span&gt;noscan&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;// 涂黑操作&lt;/span&gt;&lt;br/&gt;gcw&lt;span&gt;.&lt;/span&gt;bytesMarked &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;uint64&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;n&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;return&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 将多于128KB的对象重新放回gcworker中，下次再扫描&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; oblet &lt;span&gt;:=&lt;/span&gt; b &lt;span&gt;+&lt;/span&gt; maxObletBytes&lt;span&gt;;&lt;/span&gt; oblet &lt;span&gt;&amp;lt;&lt;/span&gt; s&lt;span&gt;.&lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;s&lt;span&gt;.&lt;/span&gt;elemsize&lt;span&gt;;&lt;/span&gt; oblet &lt;span&gt;+=&lt;/span&gt; maxObletBytes &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;!&lt;/span&gt;gcw&lt;span&gt;.&lt;/span&gt;&lt;span&gt;putFast&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;oblet&lt;span&gt;)&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;gcw&lt;span&gt;.&lt;/span&gt;&lt;span&gt;put&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;oblet&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;n &lt;span&gt;=&lt;/span&gt; s&lt;span&gt;.&lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;)&lt;/span&gt; &lt;span&gt;+&lt;/span&gt; s&lt;span&gt;.&lt;/span&gt;elemsize &lt;span&gt;-&lt;/span&gt; b&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; n &lt;span&gt;&amp;gt;&lt;/span&gt; maxObletBytes &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;n &lt;span&gt;=&lt;/span&gt; maxObletBytes&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; i &lt;span&gt;uintptr&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; i &lt;span&gt;&amp;lt;&lt;/span&gt; n&lt;span&gt;;&lt;/span&gt; i &lt;span&gt;+=&lt;/span&gt; sys&lt;span&gt;.&lt;/span&gt;PtrSize &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 为了求出偏移量i，与传入的b做计算得到灰色对象真正的内存地址&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 取出指针的值&lt;/span&gt;&lt;br/&gt;obj &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;uintptr&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;unsafe&lt;span&gt;.&lt;/span&gt;&lt;span&gt;Pointer&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;b &lt;span&gt;+&lt;/span&gt; i&lt;span&gt;)&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; obj &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;&amp;amp;&amp;amp;&lt;/span&gt; obj&lt;span&gt;-&lt;/span&gt;b &lt;span&gt;&amp;gt;=&lt;/span&gt; n &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 根据地址值去堆中查找对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; obj&lt;span&gt;,&lt;/span&gt; span&lt;span&gt;,&lt;/span&gt; objIndex &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;findObject&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;,&lt;/span&gt; b&lt;span&gt;,&lt;/span&gt; i&lt;span&gt;)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt; obj &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; &lt;span&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 调用 geryobject 标记对象并把对象放到标记队列中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;greyobject&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;obj&lt;span&gt;,&lt;/span&gt; b&lt;span&gt;,&lt;/span&gt; i&lt;span&gt;,&lt;/span&gt; span&lt;span&gt;,&lt;/span&gt; gcw&lt;span&gt;,&lt;/span&gt; objIndex&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;gcw&lt;span&gt;.&lt;/span&gt;bytesMarked &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;uint64&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;n&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;gcw&lt;span&gt;.&lt;/span&gt;scanWork &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;i&lt;span&gt;)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-lines=&quot;2&quot; data-type=&quot;p&quot; data-sign=&quot;72b1868d97ec23af964af6f05a17ad0f&quot;&gt;&lt;code&gt;scanObject&lt;/code&gt;除了生产灰色对象到&lt;code&gt;wbuf&lt;/code&gt;中以外，也会将灰色对象涂黑，所以&lt;code&gt;grayObject&lt;/code&gt;，&lt;code&gt;scanObject&lt;/code&gt;以及生产灰色对象的&lt;code&gt;write Barrier&lt;/code&gt;、&lt;code&gt;mark root&lt;/code&gt;以及&lt;code&gt;scan stack&lt;/code&gt;组成了一个生产和消费灰色对象的生态圈，从而实现了三色标记算法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;七. 总结&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;133&quot; data-backw=&quot;578&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.23057644110275688&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/E7QbOwiaziaT86Y9D2hV3EqIRTrDcvlOUkKiaQoXwFLfxI3Tn8XQSwjHicjLfmXzCeoIzMT21ziblSUclReFYicMp1HQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1197&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;说完上面的内容，再来看火焰图是不是就清晰很多了呢，大平顶出现的位置是&lt;/span&gt;&lt;code&gt;scanObject&lt;/code&gt;&lt;span&gt;，&lt;/span&gt;&lt;code&gt;findObject&lt;/code&gt;&lt;span&gt;等函数，这些函数主要的作用就是寻找灰色对象引用的对象并将其涂黑，为什么这里这些函数花费了大量的时间呢，是因为常驻于内存中结构体指针的数目太大了，所以减小垃圾回收压力的一个方法就是减少常驻于内存的结构体指针。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;参考文&lt;/span&gt;&lt;span&gt;献&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1.&lt;/span&gt;&lt;span&gt;【Golang】粗线条话GC（二）_哔哩哔哩_bilibili&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2.&lt;/span&gt;&lt;span&gt;GC 的认识 - 16. Go 历史各个版本在 GC 方面的改进？- 《Go 语言问题集(Go Questions)》 - 书栈网 · BookStack&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3.&lt;/span&gt;&lt;span&gt;Go 语言垃圾收集器的实现原理 | Go 语言设计与实现 (draveness.me)&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/E7QbOwiaziaTicnnEkDGarHVZp8HOhePeERq7s1kAicR1T8ZtvP0bDTfLPgI5zk9IY5BlbZGNMSTl14djzOgU4kicVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>