<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>59c01526d57395228d80f47c441110a6</guid>
<title>为什么放弃 Kafka，选择 Pulsar?</title>
<link>https://toutiao.io/k/wxrneux</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Spring Boot 作为主流微服务框架，拥有成熟的社区生态。市场应用广泛，为了方便大家，整理了一个基于spring boot的常用中间件快速集成入门系列手册，涉及RPC、缓存、消息队列、分库分表、注册中心、分布式配置等常用开源组件，大概有几十篇文章，陆续会开放出来，感兴趣同学请提前关注&amp;amp;收藏&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Pulsar 介绍&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 是 Yahoo 在 2013 年创建的，2016年贡献给了 Apache 基金会，目前已经是 Apache 的顶级项目。Yahoo、Verizon、Twitter 等很多公司都在使用 Pulsar 来处理海量消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 声称比 Kafka 更快、运行成本更低、解决了很多 Kafka 的痛点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 非常灵活，可以像&lt;code&gt;Kafka&lt;/code&gt; 一样作为分布式日志系统，也可以作为类似&lt;code&gt;RabbitMQ&lt;/code&gt; 这类简单的消息系统。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 有多种订阅类型、传递保障、保存策略。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;特性&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同的团队可以使用同一个集群，互相隔离。支持隔离、认证授权、配额。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar 使用特定的数据层来存储 topic 数据，使用了 Apache BookKeeper 作为数据账本。Broker 与存储分离。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用分隔机制可以解决集群的扩展、再平衡、维护等问题。也提升了可用性，不会丢失数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为使用了多层架构，对于 topic 数量没有限制，topic 与存储是分离的，也可以创建非持久化的 topic。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 中存储是很昂贵的，所以很少存储冷数据。Pulsar 使用了多层存储，可以自动把旧数据移动到专门的存储设备，例如 Amazon S3，但是对于客户端来讲是透明的，还可以正常使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Pulsar Function 是一种部署简单，轻量级计算、对开发人员友好的 API，无需像 Kafka 那样运行自己的流处理引擎。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内置了代理、多租户安全机制、可插入的身份验证等功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;partition 被分为了小块儿，所以再平衡时非常快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如 Kafka、RabbitMQ 等系统都可以轻松集成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如 Go、Java、Scala、Node、Python 等等&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么选择 Pulsar&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前业界使用比较多的是 Kafka，主要场景是大数据日志处理，较少用于金融场景。RocketMQ 对 Topic 运营不太友好，特别是不支持按 Topic 删除失效消息，以及不具备宕机 Failover 能力。选 Pulsar 是因为其原生的高一致性，基于 BookKeeper 提供高可用存储服务，采用了存储和服务分离架构方便扩容，同时还支持多种消费模式和多域部署模式。Kafka、RocketMQ 和 Pulsar 的对比如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7586705202312138&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/3Ohm6WHibeXLb8xCP32L8huVaUIW7nm3GfctVQTmqQrKEEKOp1PxibWnCDgbzAhleXsmaY4F807U3iaMJveRPSdqw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;692&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;Show me the code&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;外部依赖：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 pom.xml 中添加 Pulsar 依赖：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;org.apache.pulsar&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;pulsar-client&amp;lt;/artifactId&amp;gt;&lt;br/&gt;    &amp;lt;version&amp;gt;2.4.0&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;配置文件：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在配置文件 &lt;code&gt;application.yaml&lt;/code&gt;中配置 Pulsar 的相关参数，具体内容如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;pulsar:&lt;br/&gt;  service:&lt;br/&gt;    url: pulsar://127.0.0.1:6650&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Producer 发送消息：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产端提供了一个restful接口，模拟发送一条创建新用户消息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Long id = Long.valueOf(new Random().nextInt(1000));&lt;br/&gt;User user = User.builder().id(id).userName(&lt;span&gt;&quot;TomGE&quot;&lt;/span&gt;).age(29).address(&lt;span&gt;&quot;上海&quot;&lt;/span&gt;).build();&lt;br/&gt;userPulsarMsgProducer.send(user);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内部通过 &lt;code&gt;@PostConstruct&lt;/code&gt; 在应用启动时，初始化&lt;code&gt;org.apache.pulsar.client.api.Producer&lt;/code&gt;实例，并交由spring 容器统一管理。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public void send(T msg) {&lt;br/&gt;    String msgBody = JSON.toJSONString(msg);&lt;br/&gt;    try {&lt;br/&gt;        MessageId messageId = producer.send(msgBody.getBytes(StandardCharsets.UTF_8));&lt;br/&gt;        log.info(&lt;span&gt;&quot;pulsar msg send success, topic:{}, messageId:{}, msg:{}&quot;&lt;/span&gt;, getTopic(), messageId, msgBody);&lt;br/&gt;    } catch (Throwable e) {&lt;br/&gt;        log.error(&lt;span&gt;&quot;pulsar msg send failed, topic:{}, msg:{}&quot;&lt;/span&gt;, getTopic(), msgBody);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Producer 发送延迟消息：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;适用于一些有&lt;code&gt;延迟处理&lt;/code&gt;要求的业务场景，比如电商交易的&lt;code&gt;自动确认收货&lt;/code&gt;，在卖家发出货品后，有15天的观察期，这期间如果买家没有发起逆向流程/申请退款，将会由系统自动触发&lt;code&gt;超时确认收货&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同业务场景，设定不同的延迟时间值，可以让消费端在延迟指定时间后才能拉取到消息并进行消费。借助于该框架特性，有效节省开发成本和难度。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;producer.newMessage().deliverAfter(delay, unit)&lt;br/&gt;        .value(msgBody.getBytes(StandardCharsets.UTF_8))&lt;br/&gt;        .send();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Consumer 消费消息：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;系统启动时，自动创建consumer消费实例，并埋入&lt;code&gt;org.apache.pulsar.client.api.MessageListener&lt;/code&gt;接口实现，用于具体的消息消费处理逻辑。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@PostConstruct&lt;br/&gt;void init() throws PulsarClientException {&lt;br/&gt;    consumer = client.createConsumer(getTopic(), getSubscriptionName(), new DefaultJsonMsgListener());&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt; class DefaultJsonMsgListener implements MessageListener&amp;lt;byte[]&amp;gt; {&lt;br/&gt;&lt;br/&gt;        @Override&lt;br/&gt;        public void received(Consumer&amp;lt;byte[]&amp;gt; consumer, Message&amp;lt;byte[]&amp;gt; message) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (null != message &amp;amp;&amp;amp; null != message.getData() &amp;amp;&amp;amp; message.getData().length != 0) {&lt;br/&gt;                String msgBody = new String(message.getValue(), StandardCharsets.UTF_8);&lt;br/&gt;&lt;br/&gt;                log.warn(&lt;span&gt;&quot;topic:{} receive message:{}&quot;&lt;/span&gt;, getTopic(), msgBody);&lt;br/&gt;                try {&lt;br/&gt;                    T msg = JSON.parseObject(msgBody, clazzT);&lt;br/&gt;                    handleMsg(msg);&lt;br/&gt;                } catch (Exception e) {&lt;br/&gt;                    log.error(&lt;span&gt;&quot;handle msg failed, topic:{}, message:{}&quot;&lt;/span&gt;, getTopic(), msgBody, e);&lt;br/&gt;                    &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            try {&lt;br/&gt;                // 提交消费位移&lt;br/&gt;                consumer.acknowledge(message);&lt;br/&gt;            } catch (PulsarClientException e) {&lt;br/&gt;                log.error(&lt;span&gt;&quot;topic:{} ack failed&quot;&lt;/span&gt;, getTopic(), e);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;/code&gt;&lt;/pre&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2&gt;&lt;span&gt;演示代码地址&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;https://github.com/aalansehaiyang/spring-boot-bulking  &lt;br/&gt;&lt;br/&gt;模块：spring-boot-bulking-pulsar&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9f3cf9678bb7065369cffe0483b71728</guid>
<title>协程切换会引起什么问题</title>
<link>https://toutiao.io/k/xkhaihd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section class=&quot;post&quot;&gt;
&lt;p&gt;在微信的业务中协程被大规模应用，在使用的过程中遇到了一些和业务场景相关的问题。本文自下而上从 CPU 中断到 Linux 内核态、再到用户态进程、最后到协程，由这种视角去分析协程切换时引起问题的原因，希望可以更好地理解协程。&lt;/p&gt;

&lt;p&gt;计算机里有两类大的资源：CPU 资源和 IO 资源。计算型的任务主要消耗 CPU 资源，比如对字符串进行 base64 编码，我之前遇到 3W/min 的线上接口加了 base64 编码把 CPU 跑满；输入输出类的系统调用主要消耗 IO 资源，部分 IO 和硬件中断相关。CPU 芯片引脚上接入了很多控制芯片，比如中断控制器芯片 8259A。当键盘打字，中断芯片触发 CPU 上的硬件中断，CPU 被调度来处理键盘输入。&lt;/p&gt;

&lt;p&gt;计算机上有这么多的任务需要消耗 CPU 和 IO 资源，操作系统怎么去优化资源利用呢？&lt;/p&gt;

&lt;p&gt;对于计算密集型任务，可以用多进程/线程将任务分发到不同的 CPU 核上并行处理来提高效率；对于 IO 密集型任务，操作系统已经有中断回调机制，对于正在到来的 IO 事件进行处理。&lt;/p&gt;

&lt;hr/&gt;

&lt;h2 id=&quot;中断机制&quot;&gt;中断机制&lt;/h2&gt;

&lt;p&gt;外围硬件设备连接到中断控制器芯片上，产生的电信号经过中断控制器芯片编码后写到 CPU 的控制寄存器中。那 CPU 怎么知道寄存器发生了改变？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;当执行了一条指令后，cs 和 eip 这对寄存器包含了下一条将要执行的指令的逻辑地址。在处理那条指令之前，控制单元会检查在运行前一条指令时是否已经发生了一个中断或异常，如果发生了一个中断或异常，那么控制单元执行下列操作 ——「深入理解 linux 内核」&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;也就是 CPU 在每个指令周期都会去查看中断寄存器，这是硬件级别的轮询。用这种轮询来实现了中断控制，这种中断回调存在于内核态。&lt;/p&gt;

&lt;hr/&gt;

&lt;h2 id=&quot;操作系统之上再造系统&quot;&gt;操作系统之上再造系统&lt;/h2&gt;

&lt;p&gt;业务的进程中，既需要使用 CPU，又需要使用大量 IO。怎么去优化这种场景？&lt;/p&gt;

&lt;p&gt;在进程中再开线程？在线程中出现 IO 调用时（主要讨论同步 IO，Linux 中还没有完善的异步 IO），让线程睡眠，让其他的线程去处理任务。假设现在 8 核 CPU 上有 4 个进程，每个进程开 10 个线程，理论上也只能同步并行跑 8 个线程，其他线程都是假性的并行运行。如果这时出现大量的阻塞 IO 调用，所有的线程都会进入睡眠，等待同步 IO 的数据返回；如果是非阻塞 IO 调用（O_NONBLOCK），使用 poll/epoll 来轮询事件到来，虽然不会进入睡眠，但线程不断从内核态到用户态的上下文切换效率较低。&lt;/p&gt;

&lt;p&gt;有什么办法可以让用户态的进程/线程中拥有一种异步回调的能力，在发生 IO 调用时切换到其他进程/线程，又能保证不睡眠进入内核态。在 IO 事件到来时，再切换回这个进程/线程，整个过程都是在用户态完成。这相当于在操作系统上重新造了一个操作系统来进行进程/线程调度，梦境之上再造梦境。&lt;/p&gt;

&lt;hr/&gt;

&lt;h2 id=&quot;协程是什么&quot;&gt;协程是什么&lt;/h2&gt;

&lt;p&gt;想象一个人进入到进程中，现在有两个子函数：一个函数负责倒开水，一个函数负责晾衣服。当人看到开水烧开了，调用函数去倒开水；当看到衣服洗好了，调用函数晾衣服。这个人就是程序员本人，他来负责子程序的调度。子程序就是协程，这个人就是程序员本人，可以看作是人肉协程调度器。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Huangtuzhi/ucoroutine/blob/master/ucoroutine.cpp&quot;&gt;ucoroutine&lt;/a&gt; 是一个协程调度的示例，使用 Linux getcontext、makecontext、swapcontext 函数簇来实现协程切换。&lt;/p&gt;

&lt;p&gt;那么人肉调度器可以由什么来自动化替代呢？这个调度器需要实现这些功能&lt;/p&gt;



&lt;p&gt;比如对于网络应用场景，hook 掉 socket 簇 read、write、connect、send、recv 函数，让这些函数调用时发生用户态协程切换，同时记录下相应的上下文信息&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;加入异步回调机制，在 IO 事件到来时回调到事件对应的处理协程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个东西是不是可以用 epoll 实现？在 IO 调用时把事件注入到 epoll 事件池，同时发生协程切换，等 IO 事件到来时由主协程用 epoll 去回调切换到对应的协程。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;void ucoroutine_body(schedule_t *ps)
{
int id = ps-&amp;gt;running_coroutine;

if (id != -1) {
ucoroutine_t *t = &amp;amp;(ps-&amp;gt;coroutines[id]);
t-&amp;gt;func(t-&amp;gt;arg);
// 模拟函数阻塞，进行调度。在这里将事件注入到了 epoll 中即可
puts(&quot;before yield&quot;);
ucoroutine_yield(*ps);
puts(&quot;after yield&quot;);
t-&amp;gt;state = IDLE;
ps-&amp;gt;running_coroutine = -1;
}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就实现了用户态的操作系统。&lt;/p&gt;

&lt;p&gt;常见的协程库实现有三种方式：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用 glibc 的 ucontext 库&lt;/li&gt;
  &lt;li&gt;使用汇编代码切换上下文，微信 libco 使用这种方式&lt;/li&gt;
  &lt;li&gt;利用 C 语言的 setjmp 和 longjmp&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这些方式的原理都是通过保存和恢复寄存器的状态，来进行各协程上下文的保存和切换。&lt;/p&gt;

&lt;hr/&gt;

&lt;h2 id=&quot;切换引起的问题&quot;&gt;切换引起的问题&lt;/h2&gt;

&lt;p&gt;在使用 libco 时，已 hook 掉所有的 socket read/write/send/recv 系统调用，在发生这些系统调用时，libco 会切换协程，将当前的上下文保存，切换到其他协程使用 CPU。所以在业务代码中发起 RPC 调用会触发协程切换，这种切换会引起一些问题。&lt;/p&gt;

&lt;h4 id=&quot;问题-1幻读&quot;&gt;问题 1：”幻读“&lt;/h4&gt;

&lt;p&gt;最近在进行一个项目的改造，有这样一段代码&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;m_config = config; // 进程变量
m_config-&amp;gt;cmdid() = 100; // 这个值根据请求不同会变化

id_a = m_config-&amp;gt;cmdid()
CallRPC()
id_b = m_config-&amp;gt;cmdid()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个代码段有多个协程共用，最后发现 id_a != id_b，出现了”幻读“问题。&lt;/p&gt;

&lt;p&gt;这是因为 CallRPC 时会发生协程切换，等再次切换回来，cmdid 已经被其他协程修改了。&lt;/p&gt;

&lt;p&gt;使用协程原则：全局变量和静态变量为所有协程共享，不要使用全局变量，静态变量。&lt;/p&gt;

&lt;h4 id=&quot;问题-2死锁&quot;&gt;问题 2：死锁&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NoticeConfig::NoticeConfig()
{
CallRPC();
}

NoticeConfig* NoticeConfig::GetDefault()
{
static NoticeConfig conf; // 卡在这里
return &amp;amp;conf;
}

func()
{
auto conf = NoticeConfig::GetDefault();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;协程 A 中 func 调用 GetDefault 获取单例，GetDefault 中初始化 conf 时，构造函数调用了 RPC 发生了协程切换，CPU 让给协程 B。而对于 static 变量，gcc 在构造时会加锁，所以 A 获得了这把锁。当协程 B 调用 func 时，conf 还没初始化完成，会尝试再次加锁。所以其他协程都会卡死在这里。&lt;/p&gt;

&lt;p&gt;这种场景出现需要满足两个条件&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;构造函数中加了 RPC 操作&lt;/li&gt;
  &lt;li&gt;用 static 来实现单例&lt;/li&gt;
&lt;/ul&gt;

&lt;hr/&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;

&lt;p&gt;从上面的分析可以知道协程的使用场景&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;频繁发生 RPC 调用，可以最大程度使用协程的能力。相比线程节省系统资源&lt;/li&gt;
  &lt;li&gt;非计算密集型任务，CPU 计算不复杂。CPU 计算会占用大量时间，会让协程占用 CPU 时间过长，影响其他协程正常运行。同理 sleep 也不能使用，会让进程睡眠而无法进行切换，使用 poll(NULL, 0, sec) 代替。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;另外操作系统中存在这三种层次的回调&lt;/p&gt;

&lt;p&gt;1、硬件设备往内核态的回调通过硬件中断实现&lt;/p&gt;

&lt;p&gt;2、内核态往用户态的回调通过睡眠队列唤醒 + 进程切换实现&lt;/p&gt;

&lt;p&gt;3、用户态中进程/线程往协程的回调通过协程调度器（epoll）实现&lt;/p&gt;

&lt;hr/&gt;

&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/Tencent/libco&quot;&gt;微信 libco&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/80206565&quot;&gt;一次系统调用开销到底有多大？&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://sites.google.com/site/polarisnotme/linux/gcc&quot;&gt;GCC 优化编译指南&lt;/a&gt;&lt;/p&gt;

                          
&lt;/section&gt;



&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4103c399710dbdade8475a2b5cb3e864</guid>
<title>架构模式之分层架构总结</title>
<link>https://toutiao.io/k/fwtxydd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个问题，我们要把它搞清楚。需要深入的思考，从演进出发，从核心出发，探索它的本质。这样才能在工作中举一反三。探索本质的思想，对于架构者来说尤其重要。本文想探讨架构模式之分层设计的本质和核心。以便于更好的将正确的方式应用到项目中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;为什么分层&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;三层架构，多层架构我们听到的很多，那有没有考虑过为什么需要分层呢？不分不是更简单更方便吗，何必大费周折搞出一个分层架构？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;举一个例子，如果我们开一个饭店，一个人把采购，炒菜，上菜全部做了，一个月也有不错的收入。只是会比较忙，很辛苦。因为自己的能力毕竟有限，有时候也会把事情搞错，再比如哪天生病了，生意就没法做了。当人多了的时候就忙不过来了，大批的顾客就会跑到别人的饭店。这时候，我们就会考虑雇人，人多了就会考虑分工的问题，有的负责采购，有的负责炒菜，有的负责上菜，这样实际分层就产生了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分层本质是解耦和分类，解决职责不清的耦合问题，解决职责过大不利于发展的问题，在分层的基础上为团队分工和协作提供了依据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分层的好处&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;隔离业务复杂度和技术复杂度，可独立变化发展&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;职责清晰，减少耦合，提高复用性，可维护性，扩展性（部分）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;3、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;有利于团队分工协作&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分层的不足&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;1、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;代码理解的复杂度高了&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;性能低了，原本一次完成的事情，需要调多层实现&lt;/span&gt;&lt;/p&gt;&lt;p&gt;3、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;管理成本高了，需要考虑每层的边界，代码结构和团队情况&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;如何分层&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;         &lt;span&gt;分层设计也是一种抽象的思想，每层代表一个关注点，多层之间的协作实现了整个调用链路。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;1、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;基于职责（关注点）不同进行分层&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;基于变化的程度进行分层&lt;/span&gt;&lt;/p&gt;&lt;p&gt;3、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;同一抽象层次的组件放在同一层&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分层中的设计思想&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果用一句话描述的话，个人理解的就是高内聚，松耦合。展开讲的话有以下几点&lt;/span&gt;&lt;/p&gt;&lt;p&gt;1、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;单一职责原则，分离关注点，每个层的职责是单一的，只做一类事情；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;开闭原则：隔离变化，对扩展开放，对修改关闭；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;3、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;依赖倒置原则：基于接口（抽象）编程，层与层之间的调用都应该依赖抽象而不是具体。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分层的方式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;         &lt;span&gt;一般讲的都是逻辑分层，实际也存在物理层面进行分层。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;物理分层（&lt;/span&gt;Tier&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要从物理元素切入，个人理解从物理层面有两类，一类从部署的角度考虑，一类从项目结构角度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从部署角度考虑，典型的&lt;/span&gt;J2EE N Tire&lt;span&gt;架构，如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4935064935064935&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UHKG18j8iasYnpqicm3vOlKZoFDg2DAFLCEGFAicp5KR5MN1aW4KibL6taEZiaz7mn5QAfSoMAia2ibd4R3eVmolecWXw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;770&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;大型分布式系统的分层（简化版），如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9141630901287554&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UHKG18j8iasYnpqicm3vOlKZoFDg2DAFLCnFzxy5SbEFPxPGPp6ficoLF2njWBSmibeNU7nAib4MLDxAA3NuSAiaPKRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;466&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从项目结构考虑（很少有人这么讲）&lt;/span&gt;1&lt;span&gt;、项目的分包结构；&lt;/span&gt;2&lt;span&gt;、&lt;/span&gt;maven&lt;span&gt;中的父子项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;逻辑分层（&lt;/span&gt;Layer&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;         &lt;span&gt;大家常见的分层方式，典型的有三层，四层，七层，如下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.3875968992248062&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UHKG18j8iasYnpqicm3vOlKZoFDg2DAFLCVWtdL880OPRMgYMdqnolpvTiaOUib6E4IXuUd3b08uskX3s7hqxibicpKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;516&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中三层和四层从结构上看相差不大，主要是在三层数据访问层的基础上，扩展了如服务，设备等的调用。但是从架构层面，已经有比较大的改进。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;一个架构设计到这个程度就可以了吗？远远不够，下一步需要对分层架构进行细化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分层详解&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在做设计的时候，需要将每一个组件，每一个角色落地，让各个参与者都能清楚，明白。以四层架构为例，详细介绍每层的关注点和设计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;1、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;明确各层的关注点和职责。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9356223175965666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UHKG18j8iasYnpqicm3vOlKZoFDg2DAFLCl04zZsIayiaG7dbn85JS5v29SHlZOkBknWicQp9oGyLr5ymqTsf9gCpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;466&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（1）&lt;/span&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;表现层&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注点：&lt;/span&gt;&lt;span&gt;用户交互和页面渲染&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;职责：&lt;/span&gt;&lt;span&gt;接收用户输入，调用业务逻辑层，接收业务逻辑返回实现页面渲染。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（2）&lt;/span&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;业务逻辑层&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注点：领域模型和&lt;/span&gt;&lt;span&gt;业务逻辑&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;职责：&lt;/span&gt;&lt;span&gt;系统的核心部分，实现业务逻辑和业务规则，实现事务控制，调用资源访问层；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）&lt;/span&gt;&lt;span&gt;       &lt;/span&gt;&lt;span&gt;资源整合层：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关注点：&lt;/span&gt;&lt;span&gt;各类资源的调用和隔离&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;职责：&lt;/span&gt;&lt;span&gt;整合数据访问（读写），整合外部接口，整合设备交互。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;明确各层的设计（代码级）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;671&quot; data-ratio=&quot;1.159744408945687&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UHKG18j8iasYnpqicm3vOlKZoFDg2DAFLCaqDGia7IGGEaV3Q3XWdws8uEN18lmom1EwJEhcW8iciaLFPplWDb7UnIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;626&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    上图已经把代码层面的组件画出来了，按照这个方案就可以进行开发了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;（1）&lt;/span&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;VO&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;BO&lt;/span&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;Entity&lt;/span&gt;&lt;span&gt;可以使用同一套实体类也可以分开，比较推荐的做法是&lt;/span&gt;&lt;span&gt;VO&lt;/span&gt;&lt;span&gt;和&lt;/span&gt;&lt;span&gt;BO&lt;/span&gt;&lt;span&gt;使用一套，&lt;/span&gt;&lt;span&gt;Entity&lt;/span&gt;&lt;span&gt;使用一套。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;（2）&lt;span&gt;      &lt;/span&gt;&lt;span&gt;业务逻辑层：抽象了&lt;/span&gt;Logic&lt;span&gt;接口，用于定义每个服务方法的步骤，该部分会有一些通用的&lt;/span&gt;Logic&lt;span&gt;用于多个服务方法复用。&lt;/span&gt;Service&lt;span&gt;会调用具体的&lt;/span&gt;Logic&lt;span&gt;实现逻辑逻辑，达到了最大程度的解耦和复用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（3）&lt;/span&gt;&lt;span&gt;   &lt;/span&gt;&lt;span&gt;业务逻辑层：对于&lt;/span&gt;&lt;span&gt;Logic&lt;/span&gt;&lt;span&gt;内复用的，可以下沉到&lt;/span&gt;&lt;span&gt;Manager&lt;/span&gt;&lt;span&gt;中。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;（4）&lt;/span&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;业务逻辑层：还可以在&lt;/span&gt;&lt;span&gt;Servide&lt;/span&gt;&lt;span&gt;的基础上封装一层&lt;/span&gt;&lt;span&gt;Façade&lt;/span&gt;&lt;span&gt;，用于聚合多个&lt;/span&gt;&lt;span&gt;Servie&lt;/span&gt;&lt;span&gt;方法的调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;（5）资源整合层：包含传统的数据库访问层结构和，调用接口的实现。调用接口使用代理模式实现，隔离了外部差异。复杂的话，可以考虑使用策略+适配器的方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;3、&lt;span&gt;  &lt;/span&gt;&lt;span&gt;层之间的调用关系&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;    标准的调用是严格按照上次调用下层的顺序，实际也可以跨层调用（根据团队规范，约定好）。&lt;/span&gt;&lt;span&gt;但是，应避免循环调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.1612903225806452&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UHKG18j8iasYnpqicm3vOlKZoFDg2DAFLCoAPc3IzRNlejb0ibIrwoZkhVU0QyzfI7AvMicZhWAczKFNhWktSnDAcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;341&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;物理分层与逻辑分层的关系&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;        &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.773371104815864&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UHKG18j8iasYnpqicm3vOlKZoFDg2DAFLCoViawUz3q20A4wriafspocRib6pV0X7C5kZTYb50q90rdUql1a6ibkjkCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;706&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;逻辑架构会以不同的方式，表现到物理架构中。拿分层来讲，常见的方式有全部逻辑分层一起部署，逻辑分层部分分开部署和逻辑分层完全分开部署。分开部署后会涉及到&lt;/span&gt;RPC&lt;span&gt;调用和服务高可用等问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;文章总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;         分层架构是项目中用到的最多的架构模式之一，核心思想是归类和解耦，实现有多种方式，不应局限于三层，四层，也可能是两层，五层，六层，具体以实际的项目为准。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;          本文希望由浅入深的介绍分层相关的知识，使大家不仅知道分层，还知道为什么分，怎么分。从概念到落地是架构师必须跨过的一道坎。通过了这个坎就可以将架构知识灵活的运用到项目中，实现能力的升华，成为真正的架构师。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;           实际每一层还会有一些变化，不同的设计模式和架构模式实现的分层和代码的组织方式也是不同的，没有完全一样的架构，合适的就是最好的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>dbf33734ebfd118f37f9fae450ccab39</guid>
<title>JavaScript 垃圾回收策略</title>
<link>https://toutiao.io/k/i8pbfyr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section&gt;&lt;blockquote&gt;&lt;p&gt;前段时间，面了不少公司，不少面试官都会问到JavaScript垃圾回收。说实话，平时还真的了解不多，最近正在看“JavaScript高级程序设计”，从头把基础再巩固下。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;JavaScript 是使用垃圾回收的语言，通过自动内存管理实现内存分配和闲置资源回收。基本思路很简单：&lt;span&gt;垃圾收集器会按照固定的时间间隔或代码执行中预定的收集时间，周期性地执行操作--找出不再继续使用的变量，然后释放其占用的内存&lt;/span&gt;。如何找出不再继续使用的变量，浏览器发展怎么多年，出现了几种不同的实现方案，标记清理和引用计数。今天简单说说 JavaScript 最常用的垃圾回收策略 -【标记清理】。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;标记清理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;标记清理（mark-and-sweep）。当变量进入上下文，比如在函数内部声明一个变量时，&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; a = 1&lt;span/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这个变量会被加上存在于上下文中的标记。而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们。当变量离开上下文时，也会被加上离开上下文的标记。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以手动释放：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; a = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 释放&lt;/span&gt;&lt;br/&gt;a = &lt;span&gt;null&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。标记过程的实现并不重要，关键是策略。垃圾回收程序运行的时候，会标记内存中存储的所有变量（记住，标记方法有很多种）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还有种不太常用的垃圾回收策略-引用计数（reference counting）。引用计数的含义是跟踪记录每个值被引用的次数。由于不太常用，我们这里就不多介绍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面的内容，基本可以在“JavaScript高级程序设计”找到，感兴趣的可以读一读这本书，收获还是蛮大的，之后有时间，我会把书中的知识点整理，总结在公众号中，现在已经整理了一部分，后期会不定时更新。&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;我坚信，赞赏是不耍流氓的鼓励!&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>10808edbe7014ae101b34b48d8e132f1</guid>
<title>从 Serverless 看软件效能提升</title>
<link>https://toutiao.io/k/ykfvids</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 关注点过度集中于从问题到解决方案的阶段&lt;/span&gt;&lt;/strong&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我认为研发效能治理不能脱离最终的产品价值，需要建立端到端的视角，不仅仅关注问题到解决方案这个阶段，还需要思考解决方案是否可以真正满足客户诉求？是否可以支撑解决方案在更大的群体中扩大规模？我们对研发效能的关注点需要继续向用户和市场延伸。&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 对于研发流程中的反馈周期关注度不够&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;目前在很多研发效能治理框架中，我们可以见到很多指标，比如发布次数、构建次数、自动化构建速度等等，这些指标关注的是从左到右价值流动速度，但忽略了从右到左的价值反馈，而这些反馈可以加深我们对问题的理解，否则我们对于原先假设问题的认知仍然会停留在「低认知」水平。比如产品功能快速推广到市场之后，使用频率如何、用户反馈如何，通过这些反馈的收集，我们也许会意识到：原来一开始这就是一个错误的假设，从而及时去调整产品方向。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以回到研发效能治理本身，我认为研发效能治理只有一个目标，那就是：「加速价值流动，缩短反馈周期，用低成本验证对问题的假设」，加速价值流动和缩短反馈周期是手段，低成本验证问题假设是期望的结果。 &lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YHl6UWa9s61eicfRMTvkycUaiaFuRNCEv3mfmtE8TtsL19c7iaUG1icBw74OMHtcVUYCq4bAq7J7cGRGt5pJ3GoyoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从这个目标来思考研发效能提升，对于一些司空见惯的实践也会有更加深刻的理解，比如统一代码规范、引入自动化测试等等。因为我们认为符合规范的代码可以去提升软件的维护性，可以降低问题到解决方案的成本，所以我们要坚持代码符合规范；由于人工测试效率较低，在软件规模扩大时，我们认为通过引入自动化测试可以更加高效地验证解决方案和问题的匹配度，从而加速从左到右的价值流动，所以我们要坚持测试自动化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同时从这个目标出发，在实践层面会有更大的想象空间：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在产品设计中我们可以主张 MVP 的概念，一开始并不是要提供一个大而全的解决方案，而是找到 MVP -  最小化可行产品，快速验证想法，验证产品是否符合市场客户预期，然后取代手工部署应用的方式，做自动化运维、自动化应用部署，快速把解决方案推向市场与客户。也许我们可以参与到架构治理和产品设计中，制定指标定量分析软件架构的灵活度，让产品更加灵活，可以低成本适配客户需求；也许我们也可以尝试自动化的基础设施管理，缩短基础设施准备时间。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们交付的功能是否有真正创造价值？根据 Standish 的研究显示：20% 的软件特性经常被使用，而 30% 的特性偶尔使用，剩余 50% 的特性几乎很少使用或者完全不用。也许我们也可以主动尝试类似 A/B Testing、NPS（Net Promoter Score，净推荐值）等方法，让用户的反馈快速传递到产品团队。通过这个目标也可以驱动研发效能治理人员更多地参与到产品设计、架构设计、基础设施管理等工作中。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.7305555555555555&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YHl6UWa9s61eicfRMTvkycUaiaFuRNCEv3b4AIBWaFSNZSk3c2Nq5IE1KvSiboIsMH5cgQ0XwviaSvbRZASWTicXwew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;此外不合理的分工方式也会延长反馈周期，团队的组织结构划分应该从业务的视角还是从人员角色的视角？在敏捷软件开发中倡导的是全功能团队，在一个小的团队（Scrum Team）内部包括产品、研发、测试甚至是运维、UX，覆盖某个产品或者业务的全研发流程，在一个团队内部实现业务的闭环，在应对变化时具有更高的响应力；而基于角色的分工有时会导致交付流程的割裂，在整个研发过程中每引入一个新的角色就会增加一次上下文传递，还需要处理由此带来的术语转换和信息丢失问题。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.2 研发效能提升的阻力&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;围绕以上的目标，我们在整个研发流程中仍然有很多挑战和阻力，这次分享会着重从基础设施管理、软件架构设计和团队协作三个角度展开：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这是我曾经经历过的项目，客户的服务器主要是使用虚拟机部署，使用负载均衡做流量分发，这也是一种非常典型的部署结构。可以通过增加虚拟机，实现应用的可扩展。但由于预估容量不足，导致业务高峰期时，大量用户出现请求超时的情况，这对于客户意味着品牌声誉受损、用户流失。虽然可以通过创建虚拟机实例的方式进行扩容，但是仍然要做很多额外的配置。应用底层有很多依赖的框架或语言运行时需要安装，安装完成之后还需要配置和部署应用，这个周期至少需要 1-2 个小时。繁琐的基础设施运维限制了业务规模的扩大，限制了解决方案向更大的群体复制。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YHl6UWa9s61eicfRMTvkycUaiaFuRNCEv3jQTyEJtxLGUNBQndVIQ11UZibMRiahaRkro3EQtibu8CGic7gxAXJhwg8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;传统的运维方式还需要做容量预测，但难以在成本和效率之间平衡：当人工计划容量低于实际流量时，流量溢出、扩容速度慢，基础设施无法支撑实际业务需求；计划容量大于实际流量时，资源利用率低，企业成本的增加。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;可能有些同学会质疑：「基础设施的问题，似乎与研发没有什么关系」。但对于解决方案的复制，思考的视角不应该仅仅停留在基础设施级别，软件架构的设计也同样重要。从单体架构拆分成微服务，甚至更细粒度的函数（FaaS），是近年来业界非常流行的一个软件架构设计趋势，大大降低了解决方案复制的成本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基于传统的虚拟机部署，一个应用的各个组件可能部署在多个虚拟机上，对于新的客户通过复制虚拟机的方式来复制解决方案。这种方式不但维护成本高，而且只能通过复制虚拟机的方式来支撑更大体量的用户，来满足弹性的诉求，而通过进一步拆分架构，把单体架构拆成微服务之后，解决方案的复制可以进行更加细粒度的控制。以一个电商应用为例，订单、仓储、物车等各个业务模块对弹性的要求是不同的，不管我们选择什么技术实现，这些弹性特征都不会变化，本质上这是业务需求的一部分。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;除此之外，研发团队的工作负担重也是研发效能不足的重要原因之一，企业内部重复「造轮子」的现象屡见不鲜，也许这也是近年来中台、平台等概念流行的原因之一。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;前后端分离是一种典型的研发团队协作方式，后端提供 API，但有时候 API 无法及时提供，而前端开发者不了解服务器、数据库等搭建知识，也不了解后端的编程语言，具有一定的学习门槛，无法及时进行集成，导致上线时间延期，近而影响价值的流动速度，这些在制品（WIP）并没有形成完整的解决方案，也无法交付给客户使用，潜在的集成问题还有可能导致开发工作量增加。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.462037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YHl6UWa9s61eicfRMTvkycUaiaFuRNCEv3L0Sm1roEl0248DZzNeIlZvOhbRibibzmPL65Lrhu6juz7ycWICKsEibtw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上是我对于研发效能治理目标和挑战的一些理解，接下来和大家分享 Severless 如何去提升研发效能。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;02. &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;从 Serverless 的角度如何提升研发效能？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Serverless 的概念&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;大家也许是第一次接触 Serverless 这个概念，Serverless 是什么？具有什么价值？可以通过这个例子来理解 Serverless 的概念：比如有一个简单的出行需求，从出发地 A 到目的地 B，可以选择不同的解决方案，私家车 / 汽车租赁 / 网约车，不同方案有各自的特点：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;私家车：一次性付费，独占资源，维护成本很高，类似 IDC 机房里面的物理机；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;汽车租赁：租约期付费，有一定维护成本，但还是需要自己开车，类似虚拟机；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;网约车：按实际的用量计费，只需拿出手机 App，提出出行需求，这也是 Serverless 的理念；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Serverless 和传统的通用计算平台相比，能够真正做到按用量付费，可以大幅度节省服务器开销和运维成本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;云函数 SCF 是腾讯云 Serverless 产品，在不需要购买虚拟机的情况下，就可执行代码，目前支持所有的主流的编程语言，包括 Node.js、Python、Java 等等，主要有以下几个特点：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1. 节省服务器开销的节约&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，根据历史经验大概可以节省 10%-20%，具体的收益具体需结合业务场景、使用案例判断。&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2. 节省人工运维成本&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，与 Serverless 节省服务器成本相比，带来更大的价值在于降低人工运维成本。之前大量的保障可用性、可伸缩性的运维工作可以直接托管给云厂商来处理。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;举措一：托管基础设施能力，降低基础设施运维成本&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;Serverless 是如何解决之前所提到的研发效能挑战？当尝试把一个解决方案推向更广的群体时，首先会遇到基础设施的问题，尤其是对于很多处于业务高速扩张的业务，比如某大型零售企业，一个月会开上百家门店，把同样的业务模式在更多的城市或者下沉市场进行复制时，基础设施稳定是保障业务增长的基石，Serverless 通过把可用性、容灾、备份和监控等传统的运维工作托管到云端，可以大幅度节约企业的基础设施复制成本，通过执行一条命令，即可实现环境的跨区域复制。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;此外无服务架构通过自动扩缩容，能够做到资源消耗和实际流量线基本保持一致，大幅度降低企业容量计划的成本，让企业可以集中精力关注于业务价值本身。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6407407407407407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YHl6UWa9s61eicfRMTvkycUaiaFuRNCEv3ageokea1bIDaMV34iaWkdIRGyBia7GIUO69gicZFddeYmIL8TGQibIicxgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;举措二：分而治之，有的放矢分配投资&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section&gt;&lt;span&gt;「领域驱动设计」是微服务设计重要的方法论之一，其中分为战略设计和战术设计两部分。战略设计的核心价值在于帮助企业从更加宏观的视角看待自身业务能力，而不是走完全采购或者完全自研的两个极端。通过从业务能力的角度分析哪些是企业的核心域，哪些是支撑域，哪些是通用域，对于核心域投入 80% 的研发力量，给企业带来差异化的竞争力；对于通用域，比如内容管理系统、登录、认证等方面，与企业核心竞争力无关的，完全可以交给云厂商或者第三方企业，使用开箱即用的标准化功能：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.49722222222222223&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YHl6UWa9s61eicfRMTvkycUaiaFuRNCEv3vM0SSuYCDT1m80f8Afc7KYokaFial3lLFzTBfOjx9pPiafm1iaNFuZRIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;和微服务相比，Serverless 则借助于 FaaS（函数即服务）+ BaaS（后端即服务）的理念，在更细的粒度和场景进行能力的复用，对于研发效率的关注从服务级别提升至应用级别（如 Google Firebase 等），通过整合开箱即用的标准化 BaaS 服务以及可编程的函数进一步简化了应用的开发复杂度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;举措三：降低运维成本，优化组织内部分工&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;借助于服务端渲染技术（Server Side Rendering，SSR），前端开发者可以直接使用 JavaScript 编写后端 API。对于基础设施管理，Serverless 领域也有比较成熟的开发工具，比如 Serverless Framework，通过基本的 YAML 配置文件，就可以把完整的开发环境、测试环境构建出来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5351851851851852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YHl6UWa9s61eicfRMTvkycUaiaFuRNCEv3EPZiczDY3l2GsINaKW7cS44azxeicH5c4XlvcPjulnGfibq7qPRvBkehw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SSR 对于企业来说最大的价值在于实现业务自闭环，对于前端开发者来说，无需等待后端提供 API ，就可完成整个业务的端到端开发和测试，加速从左到右的价值流动；其次基于同样的基础设施描述文件，只需修改简单的配置，就可进行复制，进一步避免开发、测试和生产环境不一致的问题。&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/h1&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;03. &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Serverless 发展趋势预测&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;最后从个人的角度，分享一下对 Serverless 下一阶段发展的展望：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第一个趋势是：「Serverless + X」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;能够看到很多融合 Serverless 理念的产品在不断诞生，比如最近各大云厂商发布了 Serverless DB、Serverless 中间件、Serverless 容器平台等产品。从应用的视角来看，除了计算之外，还要考虑文件系统、对象存储、数据库等等，所以我认为未来动态伸缩、按量计费的 Serverless 产品矩阵会越来越丰富。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;另外一个趋势是：「Serverless 作为应用的执行引擎」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种形态下 Serverless 对于用户来说是无感知的，由于 Serverless 提供成本、可维护性、可扩展性等方面有巨大优势，Serverless 可以作为支撑 SaaS 等应用的底层驱动和引擎，进一步提升产品自身的竞争力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外基于 Serverless 理念的产品或者解决方案和边缘计算会有更好的融合，充分去利用云边端各个节点的算力，释放边端的潜能，在网络带宽延迟、能耗有限、数据敏感等复杂场景下会有更多的落地案例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后在开发工具、开发体验和方法论指导方面，和 Serverless 相关的工具和生态也会更加成熟。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上是我主要分享的内容，谢谢。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文作者：杨政权，&lt;/span&gt;&lt;span&gt;编辑：冯怀玉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NzEyMzI1NQ==&amp;amp;mid=2247483906&amp;amp;idx=2&amp;amp;sn=eb7909544f65b4a9fd1864b07e113e86&amp;amp;chksm=cf8e7e5af8f9f74c6e949afbf63a3d172f3401660fab5eb425066282183b9bfd58f476f9fa8d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.20366598778004075&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YHl6UWa9s61eicfRMTvkycUaiaFuRNCEv3icK4RadRcbz6kyGOsXckGaicOuOhZubqoJNF2gSAM6tC63gfRZUsF1UQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1964&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NzEyMzI1NQ==&amp;amp;mid=2247488192&amp;amp;idx=1&amp;amp;sn=4951caddf1a22eb72c0e3e0af6351b91&amp;amp;chksm=cf8e6e98f8f9e78e012c397d8b497b87c28c8c01b3e9a70714d8f95d75da6fd543824d5ffaf4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.20570264765784113&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YHl6UWa9s61eicfRMTvkycUaiaFuRNCEv3QUr2oAVh14heDy3PU3XWf0KMOYNk5EkVpUMtVOdYwPLX6XH8GsdOcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1964&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4NzEyMzI1NQ==&amp;amp;mid=2247490029&amp;amp;idx=1&amp;amp;sn=568d9cbdcffa793763e45e84a020b35e&amp;amp;chksm=cf8e65b5f8f9eca36b2659f994f099cb28283d12e5baa50201dbf092aa381748015d7c09e05f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;你已选中了添加链接的内容&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;1&quot;&gt;&lt;span class=&quot;js_jump_icon h5_image_link&quot; data-positionback=&quot;static&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.20468431771894094&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YHl6UWa9s61eicfRMTvkycUaiaFuRNCEv3Owq8ZpNa5wwfS0qRz6Y2Ysg1Uy5MHict5wPL6sPZPjls0YW3tzaaZIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1964&quot;/&gt;&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;One More Thing&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;span&gt;立即体验腾讯云 Serverless Demo，获取 Serverless 新用户礼包，请在 PC 端访问：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;section&gt;&lt;span&gt;serverless.cloud.tencent.com/start?c=wx20210414&lt;/span&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.28214285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YHl6UWa9s63s0prrYtdFbC8cD3Mr5lQt5F7ibaDJOxzp1nWzM2qj0u1JV1PBRicfyoEHMha6XjRsJV3kevN8HWcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1400&quot;/&gt;&lt;section&gt;&lt;span&gt;欢迎进入千人 QQ 群 (871445853) 交流 Serverless！&lt;/span&gt;&lt;/section&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;GitHub: github.com/serverless&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;官网: cloud.tencent.com/product/serverless-catalog&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;312&quot; data-backw=&quot;562&quot; data-ratio=&quot;0.5555555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YHl6UWa9s62ufGuYVrfVNc5K4WG6UicnogJgIJgs9jeicYFBsIVFI2HCDcZGBI2OZnJhZYyhcu8zvRjAEcT3icnQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;section&gt;&lt;span&gt;点击&lt;/span&gt;&lt;span&gt;&lt;strong&gt;「阅读原文」&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，轻松体验 Serverless 应用部署！&lt;/span&gt;&lt;/section&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>