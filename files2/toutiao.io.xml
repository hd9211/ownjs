<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>72806cfa33253887239c761c7d38f57d</guid>
<title>这几款 JVM 故障诊断处理工具你还不会？</title>
<link>https://toutiao.io/k/dux0ogl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前几天中午正在和同事最近聊股市较好，这几天每天都可以喝点肉汤，心里还是挺高兴的；正在这个时候收到了线上告警邮件和运维同学的消息，“你们有服务挂了！”，心里一紧，立马打开电脑看来下线上cat监控大盘，发现很多服务都在报错，根据cat上的监控日志很快发现了其中一个服务内存溢出导致其他调用服务也有问题，竟然已经定位到了出问题的服务，那就简单了，没有是重启解决不了的问题，重启之后很快服务都恢复正常了。几分钟之后又报错了，同样也是这个服务内存溢出，经过排查后发现该服务的堆内存被改小了，好家伙，运维同学不讲武德，搞偷袭，趁我没反应过来调了内存，内存调整回去之后服务就恢复了正常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事后把线上的快照文件拖了下来分析，发现本身这个项目的代码也有些问题，本文就整理了一下JVM常用的分析工具。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;命令行工具&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在安装完JDK之后在JAVA_HOME/bin目录下JDK已经提供了很多命令行的工具&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.06375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3L6TRz9Y0UdvzxE2DGJosqxbc4qu9pJCWZejq6WtqCssK83AEK3UMrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能我们最常用的就是&lt;code&gt;java&lt;/code&gt;、&lt;code&gt;javac&lt;/code&gt;这两个命令，除了这两个命令之外还有提供很多其他的实用工具，本文主要来一起学习对JVM监控诊断工具&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;虚拟机进程状况工具（jps）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该工具的功能比较单一，与linux中的ps功能类似，用来列出正在运行的虚拟机进程，并显示出运行的主类和进程号&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命令格式：&lt;code&gt;jps [option] [hostid]&lt;/code&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;如果需要查看远程机器的jvm进程需要填写&lt;code&gt;hostid&lt;/code&gt;，并且需要使用RMI，比如：&lt;code&gt;rmi://192.168.2.128:12345&lt;/code&gt;&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的选项：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-q&lt;/code&gt; : 只显示出虚拟机的进程id（lvmid），省略主类名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-m&lt;/code&gt; : 输出启动时传递给主类的参数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-l&lt;/code&gt; : 显示出主类的全名，包括jar包路径&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-v&lt;/code&gt; : 输出虚拟机进程启动时的JVM参数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23290203327171904&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3zIQRpQAtZibR8uPLX3MU1OoibCvIQQZLFLia31ermSkeW8icYvYdPLLPnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;541&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;虚拟机统计信息监控工具（jstat）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于监控虚拟机运行状态信息的命令行工具，可以提供内存，垃圾收集等运行时的数据&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命令格式：&lt;code&gt;jstat [option vmid] [interval [s|ms] [count]]&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;interval表示间隔多久时间查询一次，count表示查询多少次，比如：每个两秒查询一次进程52412的垃圾收集情况，共查询5次&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;jstat -gc 52412 2s 5&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.10375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3OObJnsw4ho5Gam75mB4vIA1kMeuFBLmdoHYajmf15ibYh1iaPz1GkZxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的选项：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-class&lt;/code&gt;: 监控类装载，卸载次数和总空间以及加载类的耗时&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-gc&lt;/code&gt;: 监控java堆的情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-gcutil&lt;/code&gt;: 主要输出各个空间使用的百分比&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-gcnew&lt;/code&gt;: 主要是监控新生代的GC状况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-gcold&lt;/code&gt;: 监控老年代的GC状况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-compiler&lt;/code&gt;: 输出JIT编译器编译过的方法和耗时信息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看堆空间的使用百分比: &lt;code&gt;jstat -gcutil 52412 2s 5&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.16973684210526316&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN39ticu2fcOAGShUKaqFQzmIfZtLAgGceHoruTjg6AOZibahyoIT9bwPJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;760&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;java配置信息工具（jinfo）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过&lt;code&gt;jinfo&lt;/code&gt;实时的查看和调整虚拟机的各项参数；可以通过&lt;code&gt;jps -v&lt;/code&gt;查看虚拟机启动时候指定的参数信息，如果需要查看未显示指定的参数默认值也可以通过&lt;code&gt;jinfo -flag&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;jinfo -flag CMSInitiatingOccupancyFraction 52412&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.08875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3HcQOFibOt6HbrdaIeRvEVMhicicPAfgichnqbgRCQSAjQes4J6ZtURl3Rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jinfo除了可以查看参数以外，还可以在运行时修改一些允许被修改的参数&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Java内存映像工具（jmap）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jmap用于生成JVM堆的快照文件，除了使用jmap工具，我们通常也会在配置JVM的启动参数 &lt;code&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/code&gt; 让JVM在发送内存溢出之后自动生成dump文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命令格式：&lt;code&gt;jmap [option] vmid&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如生成java堆的快照文件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;jmap -dump:live,format=b,file=/Users/huaan9527/Desktop/heap.hprof 59950&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的选项：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-F&lt;/code&gt;: 当虚拟机对-dump选项没有响应时可用选择使用这个参数强制生成快照&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-histo&lt;/code&gt;: 显示出堆中对象统计信息。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;堆栈跟踪工具（jstack）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于生成JVM当前线程的快照信息。通常用于查询什么原因导致线程长时间的停顿，比如：线程死循环，死锁，等待网络/IO&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命令格式：&lt;code&gt;jstack [option] vmid&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的选项：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-F&lt;/code&gt;: 当请求不被响应时强制输出&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-l&lt;/code&gt;: 除了显示堆栈外，还需要显示锁的信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-m&lt;/code&gt;: 如果调用到本地方法，显示出C/C++的堆栈&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;VisualVM 可视化工具&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VisualVM是目前JDK自带的功能最强的运行监视和故障处理程序，在VisualVM之前，JDK也提供了一款可视化工具JConsole，由于JConsole的所有功能在VisualVM都有，所以可视化工具大家几乎都选择使用VisualVM。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VisualVM本身是基于Netbean开发的，所以具备了插件扩展功能，安装插件之后上面介绍的所有命令行的工具的功能都可以在VisualVM中使用。可以在在JAVA_HOME/bin目录下执行&lt;code&gt;jvisualvm&lt;/code&gt;启动。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;插件安装
默认情况VisualVM提供的功能很少，需要我们在菜单栏-&amp;gt;工具-&amp;gt;插件里面安装插件，我这是全部插件都安装了&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.59875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3QGVcxoRL0D1EaoyiaI5tEqpBEGL0yXhmHe2NfcKJtyvic20C2RRhJP1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;功能演示&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46981627296587924&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3UEXOHP6iauXffDAODBG85QP4PqKosiajOGz9GVXUib8x6c9HDJed2DxVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;762&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显示出当前本机所有的JVM进程，这里显示的内容和前面说的命令行&lt;code&gt;jps&lt;/code&gt;显示的内容一样&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6975&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3ZZs5Y4qialznXKtKIj1MibSTrqWycDS8UYoiaadvzqXOn2IR9DOiaWc0Ww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当前虚拟机启动信息的展示，比如：JVM启动参数、系统参数&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.66&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3IuCCtJENo62LdUe0eVNAlVESYFVCQGKQjJib0TPxwcpWVLIuuCj6ia8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个页面相当于命令jstat的功能，显示出了CPU, 内存，线程，类装载当前处于什么情况&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成dump文件可以在应用程序窗口右键菜单中选择，也可以在这个页面点击右上角的&lt;code&gt;堆dump&lt;/code&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Visual GC
此页主要展示了GC相关的信息，这是在性能调优时常用的页面之一&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3uMn8Ciaga5rTDzRsjfjMa36O6GGgez4Cuj1EozA2VjwHnEiczK8EfxjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以写个程序来观看下这个截图各个内存区域的变化情况，为了让图的效果明显需要修改JVM的启动参数&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-Xmx100m -Xms100m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/Users/huaan9527/Desktop&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public static void main(String[] args) {&lt;br/&gt;    List&amp;lt;DataTest&amp;gt; datas = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    IntStream.range(0, 10000).forEach(index -&amp;gt; {&lt;br/&gt;        datas.add(new DataTest());&lt;br/&gt;&lt;br/&gt;        try {&lt;br/&gt;            Thread.sleep(50);&lt;br/&gt;        } catch (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    System.gc();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;static class DataTest {&lt;br/&gt;    byte[] bytes = new byte[1024];&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5325&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3TJRzV0hnQgqJyXvS7icdAw8Rdh0wDAeaY3evvibsq9kEloJF3VNYLxOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程
本页的功能相当于命令行工具&lt;code&gt;jstack&lt;/code&gt;，主要是用于检查什么原因导致线程长时间等待，我们写程序来演示下等待外部资源、锁等待、死循环这几种请求&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「等待外部资源」&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public static void main(String[] args) throws IOException {&lt;br/&gt;    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));&lt;br/&gt;    System.out.println(reader.readLine());&lt;br/&gt;    try {&lt;br/&gt;        Thread.sleep(1000000);&lt;br/&gt;    } catch (InterruptedException e) {&lt;br/&gt;        e.printStackTrace();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选中main线程，右侧会看到当前线程运行到了readBytes，等待键盘输入&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.395&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN30YP4cEJicbw4ibpa7HpHV68d8qiaExhstP9l0eMdQmrltjZJrwS7Is9JQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们在控制台输入之后再次查看main线程的状态，此时进入了TIME_WAIT状态&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3vF9IMG5fFrYAq5GkB0ta3yLZlHrm7ccRfCqU7VDHEz9hRVQJLsZKMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「锁等待」&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public static void main(String[] args) throws IOException, InterruptedException {&lt;br/&gt;    Thread thread = createLockThread(new Object());&lt;br/&gt;    thread.join();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public static Thread createLockThread(final Object lock) {&lt;br/&gt;    Thread lockThread = new Thread(() -&amp;gt; {&lt;br/&gt;        synchronized (lock) {&lt;br/&gt;            try {&lt;br/&gt;                lock.wait();&lt;br/&gt;            } catch (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }, &lt;span&gt;&quot;lockThread&quot;&lt;/span&gt;);&lt;br/&gt;    lockThread.start();&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; lockThread;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3TktpB0w3QcrBiadrLic8Jz2wErvo24dZRtXCCNc9os2CQJJrESuofvfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;lockThread线程在等待lock对象的notify方法被调用，此时处于WAITING状态，在被唤醒之前是不会再分配执行时间&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「死循环」&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public static void main(String[] args) throws IOException, InterruptedException {&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.25625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3LDibRDrJ6XM9pYXlHdpupiauyXORbYfdsDOsDzuACnEia4uURESibn4aWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程一直处于运行状态，从堆栈追踪里可以看出代码一直停留在了191行，在空循环上用尽分配的执行时间&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇介绍了命令行工具和可视化工具，下篇实战演示下如何通过这些工具对&lt;strong&gt;「Idea运行速度调优」&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;写到最后&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文中或许会存在或多或少的不足、错误之处，有建议或者意见也非常欢迎大家给我留言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，&lt;strong&gt;「白嫖不好，创作不易」&lt;/strong&gt;，希望朋友们可以&lt;strong&gt;「点赞」&lt;/strong&gt;，因为这些就是我分享的全部动力来源🙏&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>20ee1157d866bed603d03131c7cca4e6</guid>
<title>面试官问：“在项目中用过多线程吗？” 你就把这个案例讲给他听</title>
<link>https://toutiao.io/k/tgp1ua8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在面试当中，有时候会问到&lt;strong&gt;你在项目中用过多线程么？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于普通的应届生或者工作时间不长的初级开发  ？？？—— crud仔流下了没有技术的眼泪。&lt;/p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJjUTFMSmfLCYF8L6PlhgCQYp5sGBCIzm5HAVwv8sllu19YibQa32zfMg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;博主这里整理了项目中用到了多线程的一个简单的实例，希望能对你有所启发。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;多线程开发实例&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;应用背景&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用的背景非常简单，博主做的项目是一个审核类的项目，审核的数据需要推送给第三方监管系统，这只是一个很简单的对接，但是存在一个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要推送的数据大概三十万条，但是第三方监管提供的接口只支持单条推送（别问为什么不支持批量，问就是没&lt;span&gt;讨&lt;/span&gt;撕&lt;span&gt;论&lt;/span&gt;比&lt;span&gt;好&lt;/span&gt;过）。可以估算一下，三十万条数据，一条数据按3秒算，大概需要250（为什么恰好会是这个数）个小时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以就考虑到引入多线程来进行并发操作，降低数据推送的时间，提高数据推送的实时性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2850595783684693&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJoeKuibMZJrNYKWXOCuhKl5cib1GVQWTfibHN2qAozc2jkSM9X0OriaicicwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1091&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;业务示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;设计要点&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;防止重复&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们推送给第三方的数据肯定是不能重复推送的，必须要有一个机制保证各个线程推送数据的隔离。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有两个思路：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将所有数据取到集合（内存）中，然后进行切割，每个线程推送不同段的数据&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;2&quot;&gt;&lt;li&gt;&lt;section&gt;利用 数据库分页的方式，每个线程取 [start,limit] 区间的数据推送，我们需要保证start的一致性&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里采用了第二种方式，因为考虑到可能数据量后续会继续增加，把所有数据都加载到内存中，可能会有比较大的内存占用。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;失败机制&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还得考虑到线程推送数据失败的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是自己的系统，我们可以把多线程调用的方法抽出来加一个事务，一个线程异常，整体回滚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是是和第三方的对接，我们都没法做事务的，所以，我们采用了直接在数据库记录失败状态的方法，可以在后面用其它方式处理失败的数据。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;线程池选择&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际使用中，我们肯定是要用到线程池来管理线程，关于线程池，我们常用 ThreadPoolExecutor提供的线程池服务，SpringBoot中同样也提供了线程池异步的方式，虽然SprignBoot异步可能更方便一点，但是使用ThreadPoolExecutor更加直观地控制线程池，所以我们直接使用ThreadPoolExecutor构造方法创建线程池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大概的技术设计示意图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4625322997416021&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJ5Ndqibz0WmpUMk6xZmaO0wo6pO34Sode5OnXrQ0m7O6R1QbAjs1NhaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;774&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;设计示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;核心代码&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面叭叭了一堆，到了show you code的环节了。我将项目里的代码抽取出来，简化出了一个示例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;核心代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@Author&lt;/span&gt; 三分恶&lt;br/&gt; * &lt;span&gt;@Date&lt;/span&gt; 2021/3/5&lt;br/&gt; * &lt;span&gt;@Description&lt;/span&gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PushProcessServiceImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;PushProcessService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; PushUtil pushUtil;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; PushProcessMapper pushProcessMapper;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger logger = LoggerFactory.getLogger(PushProcessServiceImpl&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//每个线程每次查询的条数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Integer LIMIT = &lt;span&gt;5000&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;//起的线程数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Integer THREAD_NUM = &lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;//创建线程池&lt;/span&gt;&lt;br/&gt;    ThreadPoolExecutor pool = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(THREAD_NUM, THREAD_NUM * &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, TimeUnit.SECONDS, &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&amp;gt;(&lt;span&gt;100&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pushData&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ExecutionException, InterruptedException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//计数器，需要保证线程安全&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;//未推送数据总数&lt;/span&gt;&lt;br/&gt;        Integer total = pushProcessMapper.countPushRecordsByState(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        logger.info(&lt;span&gt;&quot;未推送数据条数：{}&quot;&lt;/span&gt;, total);&lt;br/&gt;        &lt;span&gt;//计算需要多少轮&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; num = total / (LIMIT * THREAD_NUM) + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        logger.info(&lt;span&gt;&quot;要经过的轮数:{}&quot;&lt;/span&gt;, num);&lt;br/&gt;        &lt;span&gt;//统计总共推送成功的数据条数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; totalSuccessCount = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; num; i++) {&lt;br/&gt;            &lt;span&gt;//接收线程返回结果&lt;/span&gt;&lt;br/&gt;            List&amp;lt;Future&amp;lt;Integer&amp;gt;&amp;gt; futureList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;32&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;//起THREAD_NUM个线程并行查询更新库，加锁&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; THREAD_NUM; j++) {&lt;br/&gt;                &lt;span&gt;synchronized&lt;/span&gt; (PushProcessServiceImpl&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;int&lt;/span&gt; start = count * LIMIT;&lt;br/&gt;                    count++;&lt;br/&gt;                    &lt;span&gt;//提交线程，用数据起始位置标识线程&lt;/span&gt;&lt;br/&gt;                    Future&amp;lt;Integer&amp;gt; future = pool.submit(&lt;span&gt;new&lt;/span&gt; PushDataTask(start, LIMIT, start));&lt;br/&gt;                    &lt;span&gt;//先不取值，防止阻塞,放进集合&lt;/span&gt;&lt;br/&gt;                    futureList.add(future);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//统计本轮推送成功数据&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (Future f : futureList) {&lt;br/&gt;                totalSuccessCount = totalSuccessCount + (&lt;span&gt;int&lt;/span&gt;) f.get();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//更新推送标志&lt;/span&gt;&lt;br/&gt;        pushProcessMapper.updateAllState(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        logger.info(&lt;span&gt;&quot;推送数据完成，需推送数据:{},推送成功：{}&quot;&lt;/span&gt;, total, totalSuccessCount);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 推送数据线程类&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PushDataTask&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Callable&lt;/span&gt;&amp;lt;&lt;span&gt;Integer&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; start;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; limit;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; threadNo;   &lt;span&gt;//线程编号&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        PushDataTask(&lt;span&gt;int&lt;/span&gt; start, &lt;span&gt;int&lt;/span&gt; limit, &lt;span&gt;int&lt;/span&gt; threadNo) {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.start = start;&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.limit = limit;&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.threadNo = threadNo;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Integer &lt;span&gt;call&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;//推送的数据&lt;/span&gt;&lt;br/&gt;            List&amp;lt;PushProcess&amp;gt; pushProcessList = pushProcessMapper.findPushRecordsByStateLimit(&lt;span&gt;0&lt;/span&gt;, start, limit);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (CollectionUtils.isEmpty(pushProcessList)) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; count;&lt;br/&gt;            }&lt;br/&gt;            logger.info(&lt;span&gt;&quot;线程{}开始推送数据&quot;&lt;/span&gt;, threadNo);&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (PushProcess process : pushProcessList) {&lt;br/&gt;                &lt;span&gt;boolean&lt;/span&gt; isSuccess = pushUtil.sendRecord(process);&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (isSuccess) {   &lt;span&gt;//推送成功&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;//更新推送标识&lt;/span&gt;&lt;br/&gt;                    pushProcessMapper.updateFlagById(process.getId(), &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;                    count++;&lt;br/&gt;                } &lt;span&gt;else&lt;/span&gt; {  &lt;span&gt;//推送失败&lt;/span&gt;&lt;br/&gt;                    pushProcessMapper.updateFlagById(process.getId(), &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            logger.info(&lt;span&gt;&quot;线程{}推送成功{}条&quot;&lt;/span&gt;, threadNo, count);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; count;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码很长，我们简单说一下关键的地方：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程创建：线程内部类选择了实现Callable接口，这样方便获取线程任务执行的结果，在示例里用于统计线程推送成功的数量&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PushDataTask&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Callable&lt;/span&gt;&amp;lt;&lt;span&gt;Integer&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用 ThreadPoolExecutor 创建线程池，&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;//创建线程池&lt;/span&gt;&lt;br/&gt;      ThreadPoolExecutor pool = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(THREAD_NUM, THREAD_NUM * &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, TimeUnit.SECONDS, &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&amp;gt;(&lt;span&gt;100&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要构造参数如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;-  corePoolSize：线程核心参数选择了5&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;- maximumPoolSize：最大线程数选择了核心线程数2倍数&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;- keepAliveTime：非核心闲置线程存活时间直接置为0&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;- unit：非核心线程保持存活的时间选择了 TimeUnit.SECONDS 秒&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;- workQueue：线程池等待队列，使用 容量初始为100的 LinkedBlockingQueue阻塞队列&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里还有没写出来的线程池拒绝策略，采用了默认AbortPolicy：直接丢弃任务，抛出异常。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用 synchronized 来保证线程安全，保证计数器的增加是有序的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;synchronized&lt;/span&gt; (PushProcessServiceImpl&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Future&amp;lt;Integer&amp;gt;&amp;gt; futureList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;32&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，主要的代码和简单的解析就到这里了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于这个简单的demo，这里只是简单地做推送数据处理。考虑一下，这个实例是不是可以用在你项目的某些地方。例如监管系统的数据校验、审计系统的数据统计、电商系统的数据分析等等，只要是有大量数据处理的地方，都可以把这个例子结合到你的项目里，这样你就有了多线程开发的经验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;完整代码仓库地址在文章底部👇👇&lt;/strong&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;对线面试官&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;面试官：小伙子，不错，你这个整挺好。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;老三：那是自然。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面试官：呦，小伙子，挺自信，那我得好好考考你。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;老三：放马过来，但考无妨。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;img data-ratio=&quot;0.9817813765182186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJplnicOJE2fe1ibB8MLlpJxFQJhx3CBhqdeXd2OIuicJTPuVwkST3VkeLA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;494&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：先从最简单的开始，说说什么是线程吧&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要说线程，必先说进程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进程是程序的⼀次执⾏过程，是系统运⾏程序的基本单位，因此进程是动态的。系统运⾏⼀个程序即是⼀个进程从创建，运⾏到消亡的过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程与进程相似，但线程是⼀个⽐进程更⼩的执⾏单位。⼀个进程在其执⾏的过程中可以产⽣多个线程。与进程不同的是同类的多个线程共享进程的堆和⽅法区资源，但每个线程有⾃⼰的程序计数器、虚拟机栈和本地⽅法栈，所以系统在产⽣⼀个线程，或是在各个线程之间作切换⼯作时，负担要⽐进程⼩得多，也正因为如此，线程也被称为轻量级进程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：说说Java里怎么创建线程吧&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java里创建线程主要有三种方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;继承 Thread类：Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过 Thread 类的 start()实例方法。start()方法是一个 native 方法，它将启动一个新线程，并执行 run()方法。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;实现 Runnable接口：如果自己的类已经 extends 另一个类，就无法直接 extends Thread，此时，可以实现一个Runnable 接口。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;实现 Callable接口：实现Callable接口，重写call()方法，可以返回一个 Future类型的返回值。我在上面的例子里就是用到了这种方式。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：说说线程的生命周期和状态&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java中，线程共有六种状态：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;状态&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;NEW&lt;/td&gt;&lt;td&gt;初始状态：线程被创建，但还没有调用start()方法&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;RUNNABLE&lt;/td&gt;&lt;td&gt;运行状态：Java线程将操作系统中的就绪和运行两种状态笼统的称作“运行”&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;BLOCKED&lt;/td&gt;&lt;td&gt;阻塞状态：表示线程阻塞于锁&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;WAITING&lt;/td&gt;&lt;td&gt;等待状态：表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TIME_WAITING&lt;/td&gt;&lt;td&gt;超时等待状态：该状态不同于 WAITIND，它是可以在指定的时间自行返回的&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TERMINATED&lt;/td&gt;&lt;td&gt;终止状态：表示当前线程已经执行完毕&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程在自身的生命周期中， 并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换，Java线程状态变化如图示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6393688955672426&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJwMXbeLwuiar3nicJXFSHGzgnzpP9d2NNGKUYbcS8fibkFeOTmNpzEQ5dQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1331&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Java线程状态变化&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：我看你提到了线程阻塞，那你再说说线程死锁吧&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程死锁描述的是这样⼀种情况：多个线程同时被阻塞，它们中的⼀个或者全部都在等待某个资源被释放。由于线程被⽆限期地阻塞，因此程序不可能正常终⽌。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对⽅的资源，所以这两个线程就会互相等待⽽进⼊死锁状态。&lt;/p&gt;&lt;img data-ratio=&quot;0.6206896551724138&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJvsVBVbkFS5uejiao5Q2nbCe7vygjTchP3PviaNSMDPJjZYfjXvBiarD5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;667&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产生死锁必须满足四个条件：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;互斥条件：该资源任意⼀个时刻只由⼀个线程占⽤。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;请求与保持条件：⼀个进程因请求资源⽽阻塞时，对已获得的资源保持不放。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;不剥夺条件:线程已获得的资源在末使⽤完之前不能被其他线程强⾏剥夺，只有⾃⼰使⽤完毕后才释放资源。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;循环等待条件:若⼲进程之间形成⼀种头尾相接的循环等待资源关系。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：怎么避免死锁呢？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我上⾯说了产⽣死锁的四个必要条件，为了避免死锁，我们只要破坏产⽣死锁的四个条件中的其中⼀个就可以了。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;破坏互斥条件 ：这个条件我们没有办法破坏，因为我们⽤锁本来就是想让他们互斥的（临界资源需要互斥访问）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;破坏请求与保持条件 ：⼀次性申请所有的资源。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;破坏不剥夺条件 ：占⽤部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释放它占有的资源。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;破坏循环等待条件 ：靠按序申请资源来预防。按某⼀顺序申请资源，释放资源则反序释放。破坏循环等待条件。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：我看你的例子里用到了synchronized，说说 synchronized的用法吧&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「synchronized」&lt;/strong&gt; 关键字最主要的三种使⽤⽅式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「1.&lt;strong&gt;「修饰实例⽅法」&lt;/strong&gt;:」&lt;/strong&gt; 作⽤于当前对象实例加锁，进⼊同步代码前要获得 当前对象实例的锁&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;method&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「2.&lt;strong&gt;「修饰静态⽅法」&lt;/strong&gt;:」&lt;/strong&gt; 也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得当前 &lt;strong&gt;「class」&lt;/strong&gt; 的锁。因为静态成员不属于任何⼀个实例对象，是类成员（ &lt;em&gt;static&lt;/em&gt; 表明这是该类的⼀个静态资源，不管 &lt;em&gt;new&lt;/em&gt; 了多少个对象，只有⼀份）。所以，如果⼀个线程 A 调⽤⼀个实例对象的⾮静态 synchronized ⽅法，⽽线程 B 需要调⽤这个实例对象所属类的静态 synchronized ⽅法，是允许的，不会发⽣互斥现象，因为访问静态 &lt;strong&gt;「synchronized」&lt;/strong&gt; ⽅法占⽤的锁是当前类的锁，⽽访问⾮静态 &lt;strong&gt;「synchronized」&lt;/strong&gt; ⽅法占⽤的锁是当前实例对象锁。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; staic &lt;span&gt;method&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**3.**修饰代码块 ：指定加锁对象，对给定对象/类加锁。synchronized(this|object) 表示进⼊同步代码库前要获得给定对象的锁。synchronized(类.class) 表示进⼊同步代码前要获得 当前 &lt;strong&gt;「class」&lt;/strong&gt; 的锁&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;) {&lt;br/&gt; &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我的例子里使用synchronized修饰代码块，给PushProcessServiceImpl类加锁，进⼊同步代码前要获得 当前 &lt;strong&gt;「class」&lt;/strong&gt; 的锁，防止PushProcessServiceImpl类的对象在控制层调用推送数据的方法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：除了使用synchronized，还有什么办法来加锁吗？详细说一下&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用juc包提供的锁。Lock接口主要相关的类和接口如下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3722044728434505&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJG4J44V9sDaKDh0FFLj48icG9E2fHqaJ4zST9FIbqC0Tl4hqvqrE8gMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;626&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306162316895&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lock中的主要方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;lock：用来获取锁，如果锁被其他线程获取，进入等待状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;lockInterruptibly：通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tryLock：tryLock方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tryLock（long，TimeUnit）：与tryLock类似，只不过是有等待时间，在等待时间内获取到锁返回true，超时返回false。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;unlock：释放锁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其它接口和类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ReetrantLock（可重入锁）：实现了Lock接口，可重入锁，内部定义了公平锁与非公平锁。可以完成synchronized 所能完成的所有工作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ReadWriteLock（读写锁）：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ReadWriteLock&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;    &lt;span&gt;Lock &lt;span&gt;readLock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;       &lt;span&gt;//获取读锁  &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;Lock &lt;span&gt;writeLock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;      &lt;span&gt;//获取写锁  &lt;/span&gt;&lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ReetrantReadWriteLock（可重入读写锁）：ReetrantReadWriteLock同样支持公平性选择，支持重进入，锁降级。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：说说synchronized和Lock的区别&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类别&lt;/th&gt;&lt;th&gt;synchronized&lt;/th&gt;&lt;th&gt;Lock&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;存在层次&lt;/td&gt;&lt;td&gt;Java的关键字，在jvm层面上&lt;/td&gt;&lt;td&gt;是一个接口，api级别&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;锁的释放&lt;/td&gt;&lt;td&gt;1、以获取锁的线程执行完同步代码，释放锁 2、线程执行发生异常，jvm会让线程释放锁&lt;/td&gt;&lt;td&gt;在finally中必须释放锁，不然容易造成线程死锁&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;锁的获取&lt;/td&gt;&lt;td&gt;假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待&lt;/td&gt;&lt;td&gt;分情况而定，Lock有多个锁获取的方式，具体下面会说道，大致就是可以尝试获得锁，线程可以不用一直等待&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;锁状态&lt;/td&gt;&lt;td&gt;无法判断&lt;/td&gt;&lt;td&gt;可以判断&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;锁类型&lt;/td&gt;&lt;td&gt;可重入 不可中断 非公平&lt;/td&gt;&lt;td&gt;可重入 可判断 可公平（两者皆可）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;性能&lt;/td&gt;&lt;td&gt;少量同步&lt;/td&gt;&lt;td&gt;大量同步&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：你提到了synchronized基于jvm层面，对这个有了解吗？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;synchronized是利用java提供的原⼦性内置锁（&lt;strong&gt;「monitor」&lt;/strong&gt; 对象），每个对象中都内置了⼀个 ObjectMonitor 对象。这种内置的并且使⽤者看不到的锁也被称为监视器锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;big&gt;同步语句块&lt;/big&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「synchronized」&lt;/strong&gt; 同步语句块的实现使⽤的是 &lt;strong&gt;「monitorenter」&lt;/strong&gt; 和 &lt;strong&gt;「monitorexit」&lt;/strong&gt; 指令，其中&lt;strong&gt;「monitorenter」&lt;/strong&gt; 指令指向同步代码块的开始位置&lt;strong&gt;「monitorexit」&lt;/strong&gt; 指令则指明同步代码块的结束位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执⾏monitorenter指令时会尝试获取内置锁，如果对象没有被锁定或者已经获得了锁，锁的计数器+1。此时其他竞争锁的线程则会进⼊等待队列中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执⾏monitorexit指令时则会把计数器-1，当计数器值为0时，则锁释放，处于等待队列中的线程再继续竞争锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;big&gt; &lt;strong&gt;「synchronized 修饰⽅法」&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;synchronized 修饰的⽅法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是ACC_SYNCHRONIZED 标识，该标识指明了该⽅法是⼀个同步⽅法。JVM 通过该ACC_SYNCHRONIZED 访问标志来辨别⼀个⽅法是否声明为同步⽅法，从⽽执⾏相应的同步调⽤。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，二者细节略有不同，但本质上都是获取原子性内置锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再深入一点，synchronized实际上有两个队列waitSet和entryList。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当多个线程进⼊同步代码块时，⾸先进⼊entryList&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;有⼀个线程获取到monitor锁后，就赋值给当前线程，并且计数器+1&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果线程调⽤wait⽅法，将释放锁，当前线程置为null，计数器-1，同时进⼊waitSet等待被唤醒，调⽤notify或者notifyAll之后⼜会进⼊entryList竞争锁&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果线程执⾏完毕，同样释放锁，计数器-1，当前线程置为null&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;img data-ratio=&quot;0.3701171875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJCQqkRia6AlWJCCkCiac1TAlGzgu2ShHRVnQmfG4c7q50pe9fEqa7Cuwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;synchronized的优化能说一说吗？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从JDK1.6版本之后，synchronized本身也在不断优化锁的机制，有些情况下他并不会是⼀个很重量级的锁。优化机制包括⾃适应锁、⾃旋锁、锁消除、锁粗化、偏向锁、轻量级锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;锁的状态从低到⾼依次为⽆锁**-&amp;gt;&lt;strong&gt;「偏向锁」&lt;/strong&gt;-&amp;gt;&lt;strong&gt;「轻量级锁」&lt;/strong&gt;-&amp;gt;**重量级锁，升级的过程就是从低到⾼。&lt;/p&gt;&lt;img data-ratio=&quot;0.08827785817655572&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJPvVAdbIhia0cc5ddicbLAWRLP9h8UzSw9w4iaa1zkellSYGwU1WPOrTAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;691&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「自旋锁」&lt;/strong&gt;：由于⼤部分时候，锁被占⽤的时间很短，共享变量的锁定时间也很短，所有没有必要挂起线程，⽤户态和内核态的来回上下⽂切换严重影响性能。⾃旋的概念就是让线程执⾏⼀个忙循环，可以理解为就是啥也不⼲，防⽌从⽤户态转⼊内核态，⾃旋锁可以通过设置-XX:+UseSpining来开启，⾃旋的默认次数是10次，可以使⽤-XX:PreBlockSpin设置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「自适应锁」&lt;/strong&gt;：自适应锁就是自适应的自旋锁，自旋锁的时间不是固定时间，而是由前⼀次在同⼀个锁上的⾃旋时间和锁的持有者状态来决定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「锁消除」&lt;/strong&gt;：锁消除指的是JVM检测到⼀些同步的代码块，完全不存在数据竞争的场景，也就是不需要加锁，就会进⾏锁消除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「锁粗化」&lt;/strong&gt;：锁粗化指的是有很多操作都是对同⼀个对象进⾏加锁，就会把锁的同步范围扩展到整个操作序列之外。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「偏向锁」&lt;/strong&gt;：当线程访问同步块获取锁时，会在对象头和栈帧中的锁记录⾥存储偏向锁的线程ID，之后这个线程再次进⼊同步块时都不需要CAS来加锁和解锁了，偏向锁会永远偏向第⼀个获得锁的线程，如果后续没有其他线程获得过这个锁，持有锁的线程就永远不需要进⾏同步，反之，当有其他线程竞争偏向锁时，持有偏向锁的线程就会释放偏向锁。可以⽤过设置-XX:+UseBiasedLocking开启偏向锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「轻量级锁」&lt;/strong&gt;：JVM的对象的对象头中包含有⼀些锁的标志位，代码进⼊同步块的时候，JVM将会使⽤CAS⽅式来尝试获取锁，如果更新成功则会把对象头中的状态位标记为轻量级锁，如果更新失败，当前线程就尝试⾃旋来获得锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;锁升级的过程非常复杂，简单点说，偏向锁就是通过对象头的偏向线程ID来对⽐，甚⾄都不需要CAS了，⽽轻量级锁主要就是通过CAS修改对象头锁记录和⾃旋来实现，重量级锁则是除了拥有锁的线程其他全部阻塞。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6295566502463055&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJiaFD7Ewdg0khfoiceO25NMrR1XWVmxiaapjd2BE5iaDCRGWO2caUliaUiaDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1015&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306142412015&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：说一下CAS&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAS（Compare And Swap/Set）比较并交换，CAS 算法的过程是这样：它包含 3 个参数CAS(V,E,N)。V 表示要更新的变量(内存值)，E 表示预期值(旧的)，N 表示新值。当且仅当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前 V 的真实值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAS是一种乐观锁，它总是认为自己可以成功完成操作。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;java.util.concurrent.atomic 包下的类大多是使用 CAS 操作来实现的 (AtomicInteger,AtomicBoolean,AtomicLong)。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：CAS会导致什么问题？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ABA 问题：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。从 Java1.5 开始 JDK 的 atomic 包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot; start=&quot;2&quot;&gt;&lt;li&gt;&lt;section&gt;循环时间长开销大：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot; start=&quot;3&quot;&gt;&lt;li&gt;&lt;section&gt;只能保证一个共享变量的原子操作：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：能说一下说下ReentrantLock原理吗&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReentrantLock 是基于 Lock 实现的可重入锁，所有的 Lock 都是基于 AQS 实现的，AQS 和 Condition 各自维护不同的对象，在使用 Lock 和 Condition 时，其实就是两个队列的互相移动。它所提供的共享锁、互斥锁都是基于对 state 的操作。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：能说一下AQS吗&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AbstractQueuedSynchronizer，抽象的队列式的同步器，AQS 定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReentrantLock/Semaphore/CountDownLatch。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「AQS」&lt;/strong&gt; 核⼼思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占⽤，那么就需要⼀套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 &lt;strong&gt;「AQS」&lt;/strong&gt; 是⽤ &lt;strong&gt;「CLH」&lt;/strong&gt; 队列锁实现的，即将暂时获取不到锁的线程加⼊到队列中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看个 AQS原理图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4160777385159011&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJmGic1XKMoG5Z3fN861cmupUyv3Z0cSb1nwicuSKj745fTUdTlvu5hn6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1132&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306144734263&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AQS 使⽤⼀个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队⼯作。AQS 使⽤ CAS 对该同步状态进⾏原⼦操作实现对其值的修改。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; state;&lt;span&gt;//共享变量，使⽤volatile修饰保证线程可⻅性&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;状态信息通过 protected 类型的 getState，setState，compareAndSetState 进⾏操作&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//返回同步状态的当前值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getState&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; state; }&lt;br/&gt;&lt;span&gt;// 设置同步状态的值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setState&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; newState)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; state = newState; }&lt;br/&gt;&lt;span&gt;//原⼦地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;compareAndSetState&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; expect, &lt;span&gt;int&lt;/span&gt; update)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; unsafe.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, stateOffset, expect, update);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尝试加锁的时候通过CAS(CompareAndSwap)修改值，如果成功设置为1，并且把当前线程ID赋值，则代表加锁成功，⼀旦获取到锁，其他的线程将会被阻塞进⼊阻塞队列⾃旋，获得锁的线程释放锁的时候将会唤醒阻塞队列中的线程，释放锁的时候则会把state重新置为0，同时当前线程ID置为空。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.436308926780341&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJeSTAsNxmibRjUoOdxmKgItEMhuxaQGPvrgRuzox1eSOS69YJOIt0zWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;997&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306145019137&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：能说一下Semaphore/CountDownLatch/CyclicBarrier吗&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Semaphore(信号量)&lt;/strong&gt;-允许多个线程同时访问：synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;CountDownLatch(倒计时器)&lt;/strong&gt;：CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;CyclicBarrier(循环栅栏)&lt;/strong&gt;：CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;volatile原理知道吗？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相⽐synchronized的加锁⽅式来解决共享变量的内存可⻅性问题，volatile就是更轻量的选择，他没有上下⽂切换的额外开销成本。使⽤volatile声明的变量，可以确保值被更新的时候对其他线程⽴刻可⻅。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;volatile使⽤&lt;strong&gt;内存屏障&lt;/strong&gt;来保证不会发⽣指令重排，解决了内存可⻅性的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，线程都是从主内存中读取共享变量到⼯作内存来操作，完成之后再把结果写会主内存，但是这样就会带来可⻅性问题。举个例⼦，假设现在我们是两级缓存的双核CPU架构，包含L1、L2两级缓存。&lt;/p&gt;&lt;img data-ratio=&quot;0.8811524609843937&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJp6C8HJnZuXTJhuyHtqPJ5plQKskBqhibvrR5Ukpib0HQj34ibc9ialicuibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;833&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如果X变量⽤volatile修饰的话，当线程A再次读取变量X的话，CPU就会根据缓存⼀致性协议强制线程A重新从主内存加载最新的值到⾃⼰的⼯作内存，⽽不是直接⽤缓存中的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来说&lt;strong&gt;内存屏障&lt;/strong&gt;的问题，volatile修饰之后会加⼊不同的内存屏障来保证可⻅性的问题能正确执⾏。这⾥写的屏障基于书中提供的内容，但是实际上由于CPU架构不同，重排序的策略不同，提供的内存屏障也不⼀样，⽐如x86平台上，只有StoreLoad⼀种内存屏障。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;StoreStore屏障，保证上⾯的普通写不和volatile写发⽣重排序&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;StoreLoad屏障，保证volatile写与后⾯可能的volatile读写不发⽣重排序&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LoadLoad屏障，禁⽌volatile读与后⾯的普通读重排序&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LoadStore屏障，禁⽌volatile读和后⾯的普通写重排序&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;img data-ratio=&quot;1.159322033898305&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJXJHlLMQzpAEEw4TAosJ9ccLDurob0zCLQpFMLjqeFtzwQTjICzicib6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;590&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：说说你对Java内存模型（JMM）的理解，为什么要用JMM&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本身随着CPU和内存的发展速度差异的问题，导致CPU的速度远快于内存，所以现在的CPU加⼊了⾼速缓存，⾼速缓存⼀般可以分为L1、L2、L3三级缓存。基于上⾯的例⼦我们知道了这导致了缓存⼀致性的问题，所以加⼊了缓存⼀致性协议，同时导致了内存可⻅性的问题，⽽编译器和CPU的重排序导致了原⼦性和有序性的问题，JMM内存模型正是对多线程操作下的⼀系列规范约束，通过JMM我们才屏蔽了不同硬件和操作系统内存的访问差异，这样保证了Java程序在不同的平台下达到⼀致的内存访问效果，同时也是保证在⾼效并发的时候程序能够正确执⾏。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7018121911037891&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJ00th6hBgy6hxkpJBuIzIRDMJSxHrOADPx9XRC986581P9mY8QMDqlw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;607&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306150619637&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：看你用到了线程池，能说说为什么吗&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;提高线程的利用率，降低资源的消耗。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提高响应速度，线程的创建时间为T1，执行时间T2，销毁时间T3，用线程池可以免去T1和T3的时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;便于统一管理线程对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可控制最大并发数&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：能说一下线程池的核心参数吗？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来看一ThreadPoolExecutor的构造方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; corePoolSize,&lt;br/&gt;                         &lt;span&gt;int&lt;/span&gt; maximumPoolSize,&lt;br/&gt;                         &lt;span&gt;long&lt;/span&gt; keepAliveTime,&lt;br/&gt;                         TimeUnit unit,&lt;br/&gt;                        BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,&lt;br/&gt;                        ThreadFactory threadFactory,&lt;br/&gt;                        RejectedExecutionHandler handler)&lt;/span&gt; &lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;核⼼线程数corePoolSize  :此值是用来初始化线程池中核心线程数，当线程池中线程池数&amp;lt; &lt;code&gt;corePoolSize&lt;/code&gt;时，系统默认是添加一个任务才创建一个线程池。可以通过调用&lt;code&gt;prestartAllCoreThreads&lt;/code&gt;方法一次性的启动&lt;code&gt;corePoolSize&lt;/code&gt;个数的线程。当线程数 = corePoolSize时，新任务会追加到workQueue中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;允许的最大线程数maximumPoolSize:&lt;code&gt;maximumPoolSize&lt;/code&gt;表示允许的最大线程数 = (非核心线程数+核心线程数)，当&lt;code&gt;BlockingQueue&lt;/code&gt;也满了，但线程池中总线程数 &amp;lt; &lt;code&gt;maximumPoolSize&lt;/code&gt;时候就会再次创建新的线程。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;活跃时间keepAliveTime：非核心线程 =(maximumPoolSize - corePoolSize ) ,非核心线程闲置下来不干活最多存活时间。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;保持存活时间unit：线程池中非核心线程保持存活的时间&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;等待队列workQueue：线程池 等待队列，维护着等待执行的&lt;code&gt;Runnable&lt;/code&gt;对象。当运行当线程数= corePoolSize时，新的任务会被添加到&lt;code&gt;workQueue&lt;/code&gt;中，如果&lt;code&gt;workQueue&lt;/code&gt;也满了则尝试用非核心线程执行任务&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;线程工厂 threadFactory：创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;拒绝策略RejectedExecutionHandler：&lt;code&gt;corePoolSize&lt;/code&gt;、&lt;code&gt;workQueue&lt;/code&gt;、&lt;code&gt;maximumPoolSize&lt;/code&gt;都不可用的时候执行的 饱和策略。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：完整说一下线程池的工作流程&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当调用 execute() 方法添加一个任务时，线程池会做如下判断：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;a) 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;b) 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;c) 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;d) 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会根据拒绝策略来对应处理。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot; start=&quot;3&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当一个线程完成任务时，它会从队列中取下一个任务来执行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;img data-ratio=&quot;0.5403788634097707&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJiabKkQuSUuAtzSXDvoGSaaYvVTbzPLyVvc3ibLpnIbknKcdHwEOAlCQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1003&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：拒绝策略有哪些&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要有4种拒绝策略：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AbortPolicy：直接丢弃任务，抛出异常，这是默认策略&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CallerRunsPolicy：只⽤调⽤者所在的线程来处理任务&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执⾏当前任务&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DiscardPolicy：直接丢弃任务，也不抛出异常&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：说一下你的核心线程数是怎么选的&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程在Java中属于稀缺资源，线程池不是越大越好也不是越小越好。任务分为计算密集型、IO密集型、混合型。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;计算密集型一般推荐线程池不要过大，一般是CPU数 + 1，+1是因为可能存在&lt;strong&gt;「页缺失」&lt;/strong&gt;(就是可能存在有些数据在硬盘中需要多来一个线程将数据读入内存)。如果线程池数太大，可能会频繁的 进行线程上下文切换跟任务调度。获得当前CPU核心数代码如下：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Runtime.getRuntime().availableProcessors();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot; start=&quot;2&quot;&gt;&lt;li&gt;&lt;section&gt;IO密集型：线程数适当大一点，机器的Cpu核心数*2。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;混合型：如果密集型站大头则拆分的必要性不大，如果IO型占据不少有必要，Mark 下。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：说一下有哪些常见阻塞队列&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;ArrayBlockingQueue ：由数组结构组成的有界阻塞队列。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DelayQueue：使用优先级队列实现的无界阻塞队列。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;SynchronousQueue：不存储元素的阻塞队列。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedTransferQueue：由链表结构组成的无界阻塞队列。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedBlockingDeque：由链表结构组成的双向阻塞队列&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：说一下有哪几种常见的线程池吧&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面我们直接用到了ThreadPoolExecutor的构造方法创建线程池，还有另一种方式，通过Executors 创建线程。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;需要注意的是，阿里巴巴Java开发手册强制禁止使用Executors创建线程&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2937608318890815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJ6Sf9ictaJYLZLV5nyqVTj2TlD5qhgic9FGOwsBRNyDmvZDsnibxM5ohicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1154&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306153832125&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比较典型常见的四种线程池包括：&lt;code&gt;newFixedThreadPool&lt;/code&gt;、 &lt;code&gt;newSingleThreadExecutor&lt;/code&gt; 、 &lt;code&gt;newCachedThreadPool&lt;/code&gt;、&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;newScheduledThreadPool&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;FixedThreadPool&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;定长的线程池，有核心线程，核心线程的即为最大的线程数量，没有非核心线程。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用的&lt;strong&gt;「无界」&lt;/strong&gt;的等待队列是&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;。使用时候有堵满等待队列的风险。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.17851500789889416&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJj8iaqmShUicGYeYhblGRG5NAfqTicVTkyKvGXicVrVrxmVrxTM6nhLdtZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;633&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306161851855&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;SingleThreadPool&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有一条线程来执行任务，适用于有顺序的任务的应用场景，也是用的&lt;strong&gt;「无」&lt;/strong&gt;界等待队列&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2006079027355623&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJCjQtia7UaYsRicWAZiaCjxKvXk4DciaS2yG8xicYdWnAZ4w6eoda9ceKj6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;658&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306161915934&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt; CachedThreadPool&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可缓存的线程池，该线程池中没有核心线程，非核心线程的数量为Integer.max_value，就是无限大，当有需要时创建线程来执行任务，没有需要时回收线程，适用于耗时少，任务量大的情况。任务队列用的是SynchronousQueue如果生产多快消费慢，则会导致创建很多线程需注意。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1841704718417047&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJRt6IRxgXUn7u7Ov5eRVDY18lI2yuCd0DhPF5c51rKVibEUUJ5WpxumA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;657&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306161950237&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt; ScheduledThreadPoolExecutor&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「周期性」&lt;/strong&gt;执行任务的线程池，按照某种特定的计划执行线程中的任务，有核心线程，但也有非核心线程，非核心线程的大小也为无限大。适用于执行周期性的任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看构造函数：调用的还是&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;构造函数，区别不同点在于任务队列是用的DelayedWorkQueue。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1598173515981735&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJWjOgicNxoqp79nVPJxq6UzYbSJWfmNHr8nhRGXCjNhcm3LnLIJJb8Xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;657&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306162020463&lt;/figcaption&gt;&lt;/figure&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;面试官：这些题都能回答出来，很好，小伙子，很有精神！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;老三：谢谢。那面试官老师，你看这一轮面试……&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面试官：虽然你答的很好，但你的项目数据量只有十万级，不符合我们的要求。所以，面试不能让你过。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老三上去就是一个左刺拳，再接一个右正蹬……&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;big&gt;&lt;strong&gt;代码地址：https://gitee.com/fighter3/thread-demo.git&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;好了，通过本文，相信你对多线程的应用和原理都有了一定的了解。文章开头提到的crud仔就是博主本人了，技术水平有限，难免错漏，欢迎指出，谢谢！&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;big&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【1】：[使用多线程查询百万条用户数据将汉字转化成拼音](https://juejin.cn/post/6844903665564647437)&lt;br/&gt;&lt;br/&gt;【2】：[讲真 这次绝对让你轻松学习线程池](https://mp.weixin.qq.com/s/dTMH1TdxiCKy5yotQ7u7cA)&lt;br/&gt;&lt;br/&gt;【3】：[SpringBoot学习笔记（十七：异步调用）](https://blog.csdn.net/sinat_40770656/article/details/107351205?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161495963016780274184752%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;amp;request_id=161495963016780274184752&amp;amp;biz_id=0&amp;amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-107351205.pc_v2_rank_blog_default&amp;amp;utm_term=%E5%BC%82%E6%AD%A5)&lt;br/&gt;&lt;br/&gt;【4】：JavaGuide编著《JavaGuide面试突击版》&lt;br/&gt;&lt;br/&gt;【5】：艾小仙编著 《我想进大厂面试总结》&lt;br/&gt;&lt;br/&gt;【6】：佚名编著 《Java核心知识点整理》&lt;br/&gt;&lt;br/&gt;【7】：[Java并发基础知识，我用思维导图整理好了](https://blog.csdn.net/sinat_40770656/article/details/113612422)&lt;br/&gt;&lt;br/&gt;【8】：[并发编程的锁机制：synchronized和lock ](https://juejin.cn/post/6844903542440869896#heading-11)&lt;br/&gt;&lt;br/&gt;【9】：[详解synchronized与Lock的区别与使用](https://blog.csdn.net/u012403290/article/details/64910926)&lt;br/&gt;&lt;br/&gt;【10】：bugstack小傅哥编著《Java面经手册》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;往期精选:&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247484838&amp;amp;idx=1&amp;amp;sn=01306c236ab7dc1bd744f07c2eb3ef69&amp;amp;chksm=c0cced03f7bb6415d36b294d7d3db382fad79e04be56c9424645547c16756f63c82f31a3d270&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;这些不可不知的JVM知识，我都用思维导图整理好了&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247485058&amp;amp;idx=1&amp;amp;sn=7e4273c31e97f2be4ec25c2c16577488&amp;amp;chksm=c0ccee27f7bb6731a9b749c2a8658541461b1054dafe057f5d1eec06f2738eeb963ec8abbea1&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;MySQL索引从基础到原理，看这一篇就够了&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247484269&amp;amp;idx=1&amp;amp;sn=4ed9f127f859fc6c06c4d6a28b68fbf2&amp;amp;chksm=c0ccebc8f7bb62deff86a8a13d32e31760aa86da15b94a3bb6d0f2946af4c32425dc34dfb56d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;这些并发基础知识，我都用思维导图整理好了&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9c1dc4845b178637eddcd355d6fd336a</guid>
<title>下一代微服务 Service Mesh 原理及实践</title>
<link>https://toutiao.io/k/hxrinvv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;微服务架构痛点&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;业务关注服务之间通信&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;会导致业务迭代速度变慢&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;微服务架构1.0&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.643&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmiajLDjc9MPXicibQiaAOrKpKhktXkwo2z5AvyvtbGM2G3zPx7EM1rAZHIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;网关层1个、业务逻辑层多个、数据访问层多个、DB/Cache多个，注册中心、配置中心&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;微服务2.0架构-服务网格&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3867735470941884&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm04yhHth8b2E02ib2USEvHaksgazdibxTMQGWicTTrqD0cJOpTt1nDl4JA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1996&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基础设施升级困难&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;影响基础设施团队的交付能力和交付速度&lt;br/&gt;因为应用程序通过jar包方式引入通信组件&lt;br/&gt;通信组件升级需要应用程序配合jar包版本升级&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.35850956696878145&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmuVcXnTB12CTiaZVfCDZD4XLTEMxuT7JD9dsQsD6yJdN6kH40neXsRpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1986&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;多编程语言之间&#x27;通信&#x27;问题&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;业务每种语言一套基础设施 成本大&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5065065065065065&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm0nkAfvnwft5wCfvspwQt3ia7UKuvn1duiatSHBlazZEfeb7yV48BwNjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1998&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;微服务架构演进&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6202404809619239&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm82tn8Emsn1QQJ8Gd8oVkUOgNrjGbk5Qo8eibwrgticTdSEsUjF7XP53A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1996&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务网格定义&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1494949494949495&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmdp8dbUuibwWlMgXtcKZMYHfjoGxouD6aP5llbqrpE6d5Ph50Vo4MOrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1980&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务网格架构&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3587939698492462&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm7ldtRY15MtRTHt4CFvCK0B7hlXA1NwmU6rsPIDRLmw4y7AxXl6av9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1990&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;带来的问题-链路会变长&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;性能里面的RT 平均响应延迟会变高&lt;br/&gt;但本机之间即应用程序放到本机的sidecar损耗不会超过1毫秒&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;开源框架&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;最早版本linkerd&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5393145161290323&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmhqnkic7NVOkx4vic78f0T6Bb5sQCA0OdszPgw7ohciaEuHbPrjke1Q6bg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1984&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;应用程序和sidecar之间通讯用tcp或http1.1以上都可以；两者需要保持长连接&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;istio&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5272177419354839&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmV5BVAcx02mtLnoX8k72PeIgfZ2fy57ybnMcrh18FCtchUETXwkNPqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1984&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;控制中心&lt;br/&gt;1、控制proxy之间通讯&lt;br/&gt;2、负载均衡&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;数据收集服务：&lt;br/&gt;&lt;br/&gt;proxy之间通讯完之后 要上报一些mertics信息 （耗时、请求次数）&lt;br/&gt;全部同步上报&lt;br/&gt;集中式 不靠谱&lt;br/&gt;它的性能影响proxy本身的性能&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;做鉴权安全相关的&lt;br/&gt;proxy之间权限鉴权比如TLS、SSL&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;sofa mesh&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;蚂蚁金服开源&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;架构&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5371485943775101&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmjb27vgyKDnVKosFmXPicLTPtNPaV3PeVibd8PCFnj6VRrdQOlTQhib0uw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1992&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、将istio中的proxy重写&lt;br/&gt;isotio proxy是用c++写的&lt;br/&gt;sofa用go重写&lt;br/&gt;2、istio数据收集节点是集中式的 sofa是分布式的即每个proxy中都有一个mixer&lt;br/&gt;3、目前还没有公司大规模在用 社区不活跃 建议使用istio&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;新浪weibo mesh&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5542046605876393&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm2AcJ10hv8sSMFHW5pnNv802fibw4icNZfxAkIlpdK3h0lh5IxypAqxGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1974&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务网格做什么&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5557809330628803&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmfqEgE9Iyuic9SDnQGfJF5lU2C32bibIZTfuB65QWzXxFAicbSdPL9xbmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1972&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;如何选型&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0440456769983686&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmoCLMeFcSWr3p7LHdyDm1sZbb56h6HF5y3u4oLH6RZeIrfVwCLWbmGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1226&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、业务升级代价太高 要让业务的升级成本降低到0 要兼容所有rpc用法 所以自研&lt;br/&gt;2、期望的是业务方只需要将rpc jar包换成这个rpc mesh jar包就行了&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;自研思路&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6939655172413793&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmbQfriaJyu4Rc3C2ibSQicXoEww4Ple3YtpZ12M5c4MIQtQDc3akNFH2mA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1856&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、要兼容传统(物理机、虚拟机)和云&lt;br/&gt;2、控制中心包括服务管理平台和数据收集中心&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;架构设计&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.624750499001996&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm6YibfraG2mpo9wpNsAs4fQVaxH903whNVe2ssxQUYIAbkiaamplfmqBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2004&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、数据收集中心：&lt;br/&gt;a、Metric:收集耗时、响应情况&lt;br/&gt;b、Trace:分布式请求跟踪系统APM&lt;br/&gt;c、Alarm：报警功能&lt;br/&gt;2、Protocol&lt;br/&gt;a、RPC:兼容老的RPC协议&lt;br/&gt;b、mesh包括通讯协议(http1.1和2.0)和数据协议(protobuff)&lt;br/&gt;&lt;br/&gt;（注：http1.0不支持 因为是短连接;http1.1和http2.0支持keep alive长连接;tpc是长连接;连接还在 server短可以直接推送消息给client）&lt;br/&gt;&lt;br/&gt;2、sidecar之间的健康检查没有通过注册中心而是本身&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总体流程&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5563380281690141&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmrSJdXxcYt152vciaR2Ob4vQiagxHDFXu7AK2qTtD6qbiadr6oXczw4Y3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1988&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;用户发起一个熔断服务B的指令&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6687179487179488&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm2TJRQWtdicfY7JJaRtb3QRUad370WicLSQK8RDpLUWLb53ialyPKNqRQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1950&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、服务管理平台、控制中心、数据收集中心都是现成的服务（之前文章介绍过）那么自研Service Mesh只需要实现proxy就可以了&lt;br/&gt;2、之前Service和Proxy是一个进程&lt;br/&gt;现在需要修改成2个独立的进程即可&lt;br/&gt;3、将二者放到同一个pod中&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;如果sidecar挂了对整体是否有影响?&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;没有影响。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4915514592933948&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmha1K9PrBecoN7mhbfYdUAa1bledkmlrEMYdwwf9lWovsiaYndOL5I9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1302&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sidecar挂掉 pod如何处理？&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;如果sidecar挂掉了 就会被监控到 直接把当前pod杀死就行了 k8s会自动重启一个pod&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;2个应用程序放在同一个物理机上架构怎样？&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5741758241758241&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmVVtyS2E1ZDIlJRdTiceHsjug11thSR3uOZQtjtbuzwg9uPqM5wn3ldw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;728&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;漂移&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、日志漂移&lt;br/&gt;&lt;br/&gt;服务器1上有服务1生成日志1&lt;br/&gt;如果服务器1上面的服务1挂了&lt;br/&gt;在服务器2上启动服务2生成日志2 &lt;br/&gt;如果日志1和日志2有强依赖关系 &lt;br/&gt;那么必须得在服务器1上启动服务1继续在日志1的基础上生成日志&lt;br/&gt;&lt;br/&gt;2、重试漂移&lt;br/&gt;pod如果挂了 再次重启 那么ip就会改变&lt;br/&gt;重试漂移到云上任何节点都没有关系&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;完整流程图&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;这个完整的流程图涵盖了&lt;br/&gt;DNS、CDN、Nginx、FastDFS（或Ceph）、&lt;br/&gt;LVS、ServiceMash、数据收集中心、&lt;br/&gt;注册中心、控制中心、网关、业务逻辑层、&lt;br/&gt;数据访问层、存储层等数据交互过程&lt;br/&gt;&lt;br/&gt;价值不菲 想要的话 &lt;br/&gt;可以添加我微信15900411193&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;调用链路&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3782696177062374&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmgLOSWZMwhkiaN5VeySCQn6QUbjIibuHr4MOWQGibSzNlhfuqibGBpyUHCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1988&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、做协议解析的目的是兼容老的协议&lt;br/&gt;客户端发出请求后 在客户端service和服务方service要做协议解析&lt;br/&gt;如果都是mesh协议 是不需要协议解析的、协议封装也不需要&lt;br/&gt;2、客户端一定要做序列化、反序列化 这和通讯没啥关系 就是一个数据包&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;调用方时序图&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.1094017094017095&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmo2ZqydDFr5mLALib7TFtOxoFyrW4put3x8MzSwP5TpsW6bgLplp3umw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1170&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务方时序图&lt;br/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.4110671936758894&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmA6dmticzO1uAO4jXEy5NC7T1wPfmuNmr99yWrOibPd2ic5iaXDKwB1E8xQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1012&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;缓存管理 多个Map:&lt;br/&gt;服务方提供哪些函数调用 通过扫描jar包 反射机制 获取服务提供的类名和方法名&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;协议设计&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;数据协议&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、Protocol Buffer&lt;br/&gt;2、分割符、版本号、Mesh消息构成&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.19497487437185929&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmk1YhLJzQ3xd5E9GbDmX1anKKgIqD6tuiaNG4EQIV52TrWIHF4yXApEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1990&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、一次传输协议中有版本号 &lt;br/&gt;比如 版本号1表示rpc协议 &lt;br/&gt;版本号2表示mesh协议&lt;br/&gt;通过版本号可以区分兼容老协议还是新协议&lt;br/&gt;2、多个数据包之间通过头和尾分割符分开&lt;br/&gt;3、分割符占5个字节&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Mesh通讯协议&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、TCP长连接&lt;br/&gt;2、Http1.1或2.0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;混合云部署&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、调用方&lt;br/&gt;a、SideCar+Service(Mesh)&lt;br/&gt;b、Service(RPC)&lt;br/&gt;2、服务方&lt;br/&gt;a、SideCar+Service(Mesh)&lt;br/&gt;b、Service(RPC)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;访问流程&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3229689067201605&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm20ht2oGM3KHs0CDYics7JXYjRJrPIEYplfbpOYS7zhQ9tgAIXzD1kFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1994&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、在服务启动的时候 mesh服务或普通的RPC服务都会去注册中心注册 此时就知道了该节点的服务类型&lt;br/&gt;2、调用方下拉服务信息 也就知道了提供方服务类型 然后选择不同的协议去调用&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小细节&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、熔断放在mesh里面做 不需要业务方参与&lt;br/&gt;2、下游重试次数是一样的 是服务粒度 非接口粒度&lt;br/&gt;3、proxy(mesh)之间做健康检测 是分布式的 一旦发现自己的上游或下游出现了问题 就更新本地的路由表&lt;br/&gt;4、负载均衡算法:Random、RR、Hash(主要用一致性&lt;span&gt;hash&lt;/span&gt;来做)&lt;br/&gt;（RR：(循环负载)&lt;br/&gt;第一次请求路由到第一个节点，&lt;br/&gt;第二次请求路由到第二个节点，&lt;br/&gt;第三次请求路由到第三个节点，&lt;br/&gt;第四次请求路由到第一个节点&lt;br/&gt;....）&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;架构未来&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;2平台1中心1趋势&lt;br/&gt;&lt;br/&gt;service mesh平台与业务解耦&lt;br/&gt;容器云弹性平台&lt;br/&gt;服务治理平台(控制中心、注册中心、数据收集中心)&lt;br/&gt;人工智能(AI)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务管理平台的调用关系-数据收集存储方法&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务方-调用方角度&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4020100502512563&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmnp3gibme5rHX7cQxzrJojyic7S72CvWH0Vr24WpDC8RGicKCuQYm2ogaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1990&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;服务方:1分钟500万条记录&lt;br/&gt;调用方:50万&lt;br/&gt;共550万&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;存储方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;方案1&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5426278836509528&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm0a7lakm422lTyImtA59Vo4GP3nsFjib63vAQQq6uuheS5AhqicIbW6rQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1994&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;方案二&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;重复数据提取出来作为元数据&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.46598984771573604&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm1ficWMZOiaX1GReepHV0qKPibWuE9zpYfhicnJ1a3EhXurnibZ7iaG6jRwWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1970&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;方案三&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;实际调用流量仅为方案1的1/10&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.295959595959596&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmMekAzNGwEOiarZTiakpzeibcXlV36Cen0DhAcna6ictLUKddPVBeE4iaVfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1980&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;、&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5daed062f927e6435ab95bf182f02b29</guid>
<title>从技术专家到技术管理，我对管理的思考</title>
<link>https://toutiao.io/k/r5kgujp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2 data-lake-id=&quot;c59d3ce6d8f3de38bc41f0ddf54f9231&quot;&gt;前言&lt;/h2&gt;&lt;p data-lake-id=&quot;af3634f9a47f9d77c40232118fb35431&quot;&gt;工作第七个年头，我从技术专家，变成了一名技术管理者。最近一直在忙碌中思考如何成为一名优秀的技术管理者。这篇文章，主要会从两个观点和维度，来谈谈自己的一些认知和思考总结。&lt;span data-mce-style=&quot;font-size: 10px&quot;/&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;8f2d278849f8aaa34c20d8cf8062c66a&quot;&gt;&lt;/p&gt;&lt;h2 data-lake-id=&quot;40b9e41847e55b8d4e1b3b023302ce0e&quot;&gt;观点&lt;/h2&gt;&lt;p data-lake-id=&quot;5b8334f08a8247b7564621261e23f7ab&quot;&gt;首先，从工程师到技术管理的转变，有两个观点要明确：&lt;/p&gt;&lt;p data-lake-id=&quot;e2d8767d6bcdfda62e182f65392ffc66&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span data-mce-style=&quot;font-size: 10px&quot;&gt;1）技术Leader是团队最好的工程师之一；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;f2da4fbfc10ea20dd0e497a3fdc9f56e&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span data-mce-style=&quot;font-size: 10px&quot;&gt;2）技术Leader是为团队服务，解决团队的问题；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;dda379e68872bf2ec7b133d94eefafc7&quot;&gt;&lt;span&gt;工程师只需要对自己负责，而管理者需要对团队负责。&lt;/span&gt;&lt;span&gt;这两个身份所立足的核心点是一样的，首先要有符合要求的专业性，专业性越强越能够给他人带来信任感；其次是良好的沟通能力。但是这两件事在管理者和工程师身上的要求和方向却有很大的差异。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;daf8d4ab8a1fd2ab2c5a66b8e7710085&quot;&gt;&lt;span&gt;专业性&lt;/span&gt;&lt;/h3&gt;&lt;p data-lake-id=&quot;8c38524d3ed4bb5c6f0b7fa0ed3739b6&quot;&gt;&lt;span&gt;     对于工程师来说，所谓的专业性单纯的指技术领域的专业性，因为工程师的核心产出主要依赖于其技术领域的造诣，主要的要求是对自己的产出负责，所以需要不停的钻研自己需要依赖的技术，打磨自己使用的工具，不断提升自己能做的事情的边界，不断的提升自己的深度；&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;9641e0e95cae78d8bc10b47dfae46f64&quot;&gt;&lt;span&gt;对于管理者来说，所谓的专业性则更加偏向于如何提升团队产出，所以核心的要求会和工程师有所变化，我个人认为可以拆解到以下几方面：&lt;/span&gt;&lt;/p&gt;&lt;ul data-lake-id=&quot;44f581f6d7cbfb60d5cf135d9733c193&quot; start=&quot;1&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;团队建设&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：核心包括招聘和团队层次搭建，团队和个人最直接的区别就是人数，团队是一个组织，对于管理者来说，首先需要的就是把这个组织建立起来，一个人的组织很难比10个人的组织产出高；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;设定目标&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：当团队已经搭建起来之后，最重要的事情就是要做什么了，如果团队的目标是错误的，那很可能导致整个团队负向产出，所以目标一定要对。在这一点上是最体现管理者的“专业性”的，方向走对了，整个团队事半功倍，整个团队都会信服管理者，反之，则全是管理者一个人的责任。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;提升效率&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：一般我们直观能想到的就是招更好的人提升效率，但站在管理者的角度还要考虑是否能在工具或流程上改造，是否能靠提升团队分工情况来改善效率等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;树立榜样&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;管理者是团队的模仿对象，是团队的行为标杆，将自身的能力、行为分享和传达给团队，建立积极的竞争氛围。竞争能够高效激发员工的潜力，要让团队中员工处理良性竞争状态，给团队创造“危机意识”。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-lake-id=&quot;582e6e65ed96c968061f42c62070c0a4&quot;&gt;&lt;span&gt;职业性&lt;/span&gt;&lt;/h3&gt;&lt;p data-lake-id=&quot;7269550dd666ace24d32984db19d4b62&quot;&gt;&lt;span&gt;对于工程师来说，核心的沟通方一般是团队内部和产品，沟通的要求主要是能和产品沟通清楚需求，能讲明白自己的技术方案即可。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;584bd55824a5a682718e668958c37a2c&quot;&gt;&lt;span&gt;对于团队管理来说，核心的沟通方都是其他团队，管理者需要帮团队解决的一个大问题就是外部资源依赖问题，所以对沟通的要求要高很多，如何能说服其他团队提供资源解决自己的问题是管理者需要解决的核心工作之一。&lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 10px&quot;&gt;你推进的不再是一个简单的、自闭环的事。你需要对上沟通，跨团队沟通，以及对下沟通，开始需要学习各种技能，更多的掌握业务，站在用户角度，然后再来思考如何通过系统来满足需求。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;584bd55824a5a682718e668958c37a2c&quot;&gt;&lt;span data-mce-style=&quot;font-size: 10px&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;e9d443b7a027bc82214a2f69ea675b43&quot;&gt;&lt;/p&gt;&lt;h2 data-lake-id=&quot;27d9eb02e9f9e9841111ab839d8e611c&quot;&gt;维度&lt;/h2&gt;&lt;h3 data-lake-id=&quot;a7f02a83be67ff42355179341ee11d2d&quot;&gt;团队维度&lt;/h3&gt;&lt;p data-lake-id=&quot;c54fbdcd3de056a1e2b620331c09527f&quot;&gt;&lt;span/&gt;从团队维度来讲，从一名工程师到技术管理的转变，我总结了四个方面：&lt;/p&gt;&lt;h4 data-lake-id=&quot;77ed77b111085a02c8009a414f1c5b0d&quot;&gt;1、躬身入局&lt;/h4&gt;&lt;p data-lake-id=&quot;f0ef8e2f712a1c0a3964465a1f8f153d&quot;&gt;如果只是以工程师的角度去工作，可能只会关注项目里面的某些点，容易陷入思维定势，不太容易去思考全局。因此在最开始应该学会“躬身入局”，了解团队工作中的重要节点，而不是高高在上。工程师和技术管理只是职责上不同，而非职级或者“阶级”上的区分。&lt;/p&gt;&lt;h4 data-lake-id=&quot;0b7e2ddf968b095371ea0186a0f46bad&quot;&gt;2、抓大放小&lt;/h4&gt;&lt;p data-lake-id=&quot;69e4d6d96d977350f4d77f8ec2cde27e&quot;&gt;团队要做的事情，从复杂程度以及数量多寡来说，肯定远远超过个人。因此要学会分辨那些是重要紧急的事项，从全局角度考虑，可以适当的做“局部牺牲”来保证整体拿到更好的结果。&lt;/p&gt;&lt;h4 data-lake-id=&quot;d03f7208c6c181b5424a74ca99693490&quot;&gt;3、向下赋能&lt;/h4&gt;&lt;p data-lake-id=&quot;43e6bc147cdf3682113f453e68aaec1a&quot;&gt;&lt;span data-mce-style=&quot;font-size: 10px&quot;&gt;个人的时间和精力都是有限的，&lt;/span&gt;从工程师到技术管理，&lt;span data-mce-style=&quot;font-size: 10px&quot;&gt;很多时候时间不再是自己的。尝试去&lt;/span&gt;相信团队里面的每个同学，给他们机会去做一些超过之前职责和能力的事情，当然过程中要及时给予指导和过程把控，相信他们能拿到更好的结果。&lt;/p&gt;&lt;h4 data-lake-id=&quot;7a8015eb4583869ba3e5fd2c3c27e1f7&quot;&gt;4、持续学习&lt;br/&gt;&lt;/h4&gt;&lt;p data-lake-id=&quot;fe9939db6c761d62fe14a468984da890&quot;&gt;作为技术出身的管理者，要时刻保持对新技术的学习，并在可能的范围之内承担一定的开发&amp;amp;测试工作或者说要对团队内技术项目足够深入，在成员遇到问题时要能给出解决方案或者思路。&lt;/p&gt;&lt;p data-lake-id=&quot;17b9fc245d6e67143a08abb074ac1c4e&quot;&gt;&lt;span data-mce-style=&quot;font-size: 10px&quot;&gt;保持耐性，有服务和指导以及培养团队的的意识，提升整个团队的实力。技术管理者要能规划和提出团队的目标，明确团队前进的方向，并确保大家能够不偏离轨道，不断纠正，直到达到目标。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;17b9fc245d6e67143a08abb074ac1c4e&quot;&gt;&lt;span data-mce-style=&quot;font-size: 10px&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;a5b1d117be8845df5ae97a882966bd21&quot;&gt;个人维度&lt;/h3&gt;&lt;h4 data-lake-id=&quot;5b1caf8796e87a80d15ebe35677c3f78&quot;&gt;1、持续学习&lt;/h4&gt;&lt;p data-lake-id=&quot;46705897c7ea0c922b7dc80dba878926&quot;&gt;技术Leader必须是团队最好的工程师之一，要能够基于自己的技术能力&amp;amp;业务认知做决策。要确保技术成长的速度，&lt;span data-mce-style=&quot;font-size: 10px&quot;&gt;通过现象看出背后的原因或原理，要能成为问题终结者。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-lake-id=&quot;10ccd978a8ee82305faffc5a020edc87&quot;&gt;2、目标明确&lt;/h4&gt;&lt;p data-lake-id=&quot;dd1e107dc12d7571c28c4a74373d6a65&quot;&gt;工程师更多是面向技术，是一个很小的圆；成为技术管理者后，需要调整自己的认知边界，成为更大的圆，及时补齐不同方面的能力缺失。&lt;/p&gt;&lt;ul data-lake-id=&quot;19f80dc8ef98a32f19cf5daba461a606&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;业务&lt;/strong&gt;：从单一功能模块设计、单一系统设计到思考业务发展趋势、结合现阶段公司情况能比较清晰认识到现阶段、中短期、中长期、长期业务的形态和该做的事情。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;团队&lt;/strong&gt;：首先要有能力打造团队(招聘、教化、引导)，然后思考团队目标是什么、团队面临的职责或使命是什么。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;规划&lt;/strong&gt;：认清做好规划是为了落地去实现它而不是为了PPT，需要具备一定的规划能力，这其中包含了对上对下的目标明确、资源协调争取、对外沟通合作等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;对上对下&lt;/strong&gt;：对上，明确公司业务战略方向，及时对齐目标，及时同步进展；对下，及时沟通了解个性了解述求、协调资源给与帮助。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-lake-id=&quot;ca70dd28aeeae59523efbce9e02a8031&quot;&gt;3、保持思考&lt;/h4&gt;&lt;p data-lake-id=&quot;57f883033b72f711af1c175971975c90&quot;&gt;当你作为一个技术管理者，需要保证一定的思考时间，转换埋头执行的工作方式。需要从单点模式的思考，快速过度到一个项目甚至更高维度的业务层级。这是一个“点-线-面”的过程，需要保持耐心。&lt;/p&gt;&lt;h4 data-lake-id=&quot;1915e6f9e47ae550be573d8689f9c329&quot;&gt;4、适当放手&lt;/h4&gt;&lt;p data-lake-id=&quot;7580b3010625bc238954b901fee38d35&quot;&gt;学会抓大放小，结果导向。精力有限很难面面俱到，学会放手让有能力的人去具体落地，自己做好跟进识别业务核心、把控方案设计、codereview等工作。&lt;/p&gt;&lt;p data-lake-id=&quot;c31547fc9ec678828e3e191fa91e3b95&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;5fbb517257a28e30ea61bc289260d500&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f36312a553d387c495a26ae10b5c582f</guid>
<title>iOS 稳定性问题治理：卡死崩溃监控原理及最佳实践</title>
<link>https://toutiao.io/k/8gc0m8s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不同于 Android 系统中的卡死（ANR）问题，目前业界对 iOS 系统中 App 发生的卡死崩溃问题并无成熟的解决方案，主要原因是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通常 App 卡死时间超过 20s 之后会触发操作系统的保护机制，发生崩溃，此时在用户的设备中能找到操作系统生成的卡死崩溃日志，但是因为 iOS 系统封闭生态的关系，App 层面没有权限拿到卡死崩溃的日志。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;一般而言用户遇到卡死问题的时候并没有耐心等待那么久的时间，可能在卡住 5s 时就已经失去耐心，直接手动关闭应用或者直接将应用退到后台，因此这两种场景下系统也就不会生成卡死崩溃日志。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于上面提到的两个原因，目前业界 iOS 生产环境中的卡死监控方案其实主要是基于卡顿监控，即当用户在使用 App 的过程中页面响应时间超过一定的卡顿的阈值（一般是几百 ms）之后判定为一次卡顿，然后抓取到当时现场的调用栈并且上报到后台分析。这种方案的缺陷主要体现在：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;没有将比较轻微的卡顿问题和严重的卡死问题区分开，导致上报的问题数量太多，很难聚焦到重点。实际上这部分问题对用户体验的伤害其实是远远大于卡顿的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;因为一些使用低端机型的用户更容易在短时间内遇到频繁的卡顿，但是调用栈抓取，日志写入和上报等监控手段都是性能有损的，这也是卡顿监控方案在生产环境中一般只能小流量而不能全量的原因。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;试想一次卡顿持续了 100ms，前 99ms 都卡在 A 方法的执行上，但是最后 1ms 刚好切换到了 B 方法在执行，这时候卡顿监控抓到的调用栈是 B 方法的调用栈，其实 B 方法并不是造成卡顿的主要原因，这样也就造成了误导。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于上述的痛点，字节跳动 APM 中台团队自研了一套专门用于定位生产环境中的卡死崩溃的解决方案，本文将详细的介绍该方案的思路和具体实现，以及通过本方案上线后总结出来的一些典型问题和最佳实践，期望对大家有所启发。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;卡死崩溃背景介绍&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是 watchdog&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果某一天我们的 App 在启动时卡住大概 20s 然后崩溃之后，从设备中导出的系统崩溃日志很可能是下面这种格式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Exception Type:  EXC_CRASH (SIGKILL)&lt;br/&gt;Exception Codes: 0x0000000000000000, 0x0000000000000000&lt;br/&gt;Exception Note:  EXC_CORPSE_NOTIFY&lt;br/&gt;Termination Reason: Namespace ASSERTIOND, Code 0x8badf00d&lt;br/&gt;Triggered by Thread:  0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面就其中最重要的前 4 行信息逐一解释：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Exception Type&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;EXC_CRASH&lt;/code&gt;：Mach 层的异常类型，表示进程异常退出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;SIGKILL&lt;/code&gt;：BSD 层的信号，表示进程被系统终止，而且这个信号不能被阻塞、处理和忽略。这时可以查看 &lt;code&gt;Termination Reason&lt;/code&gt; 字段了解终止的原因。&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Exception Codes&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个字段一般用不上，当崩溃报告包含一个未命名的异常类型时，这个异常类型将用这个字段表示，形式是十六进制数字。&lt;/p&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Exception Note&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;EXC_CORPSE_NOTIFY&lt;/code&gt; 和 &lt;code&gt;EXC_CRASH&lt;/code&gt; 定义在同一个文件中，意思是进程异常进入 CORPSE 状态。&lt;/p&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Termination Reason&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里主要关注 &lt;code&gt;Code 0x8badf00d&lt;/code&gt;，可以在苹果的官方文档中查看到 &lt;code&gt;0x8badf00d&lt;/code&gt; 意味着 App &lt;code&gt;ate bad food&lt;/code&gt;，表示进程因为 &lt;code&gt;watchdog&lt;/code&gt; 超时而被操作系统结束进程。通过上述已经信息可以得出 &lt;code&gt;watchdog&lt;/code&gt; 崩溃的定义：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;在iOS平台上，App如果在启动、退出或者响应系统事件时因为耗时过长触发系统保护机制，最终导致进程被强制结束的这种异常定义为watchdog类型的崩溃。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓的 &lt;code&gt;watchdog&lt;/code&gt; 崩溃也就是本文所说的卡死崩溃。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么要监控卡死崩溃&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家都知道在客户端研发中，因为会阻断用户的正常使用，闪退已经是最严重的 bug，会直接影响留存，收入等各项最核心的业务指标。之前大家重点关注的都是诸如 &lt;code&gt;unrecognized selector&lt;/code&gt;、&lt;code&gt;EXC_BAD_ACCESS&lt;/code&gt; 等可以在 App 进程内被捕获的崩溃（下文中称之为普通崩溃），但是对于 &lt;code&gt;SIGKILL&lt;/code&gt; 这类因为进程外的指令强制退出导致的异常，原有的监控原理是覆盖不到的，也导致此类崩溃在生产环境中被长期忽视。除此之外，还有如下理由：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;因为卡死崩溃最常见发生于 App 启动阶段，用户在开屏页面卡住 20s 后什么都做不了紧接着 App 就闪退了。这种体验对用户的伤害比普通的崩溃更加严重。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在卡死监控上线之初，今日头条 App 每天卡死崩溃发生的量级大概是普通崩溃的 3 倍，可见如果不做任何治理的话，这类问题的发生量级是非常大的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;OOM 崩溃也是由 &lt;code&gt;SIGKILL&lt;/code&gt; 异常信号最终触发的，目前 OOM 崩溃主流的监控原理还是排除法。不过传统方案在做排除法的时候漏掉了一类量级非常大的其他类型的崩溃就是这里的卡死崩溃。如果能准确的监控到卡死崩溃，也同样能大大提高 OOM 崩溃监控的准确性。关于 OOM 崩溃的具体监控原理和优化思路可以参考：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI1MzYzMjE0MQ==&amp;amp;mid=2247486858&amp;amp;idx=1&amp;amp;sn=ec5964b0248b3526836712b26ef1b077&amp;amp;chksm=e9d0c668dea74f7e1e16cd5d65d1436c28c18e80e32bbf9703771bd4e0563f64723294ba1324&amp;amp;token=1483621236&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;iOS 性能优化实践：头条抖音如何实现 OOM 崩溃率下降 50%+&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，基于以上信息我们可以得出结论：卡死崩溃的监控和治理是非常有必要的。经过近 2 年的监控和治理，目前今日头条 App 卡死崩溃每天发生的量级大致和普通崩溃持平。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;卡死崩溃监控原理&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;卡顿监控原理&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实从用户体验出发的话，卡死的定义就是长时间卡住并且最终也没有恢复的那部分卡顿，那么下面我们就先回顾一下卡顿监控的原理。我们知道在 iOS 系统中，主线程绝大部分计算或者绘制任务都是以 &lt;code&gt;runloop&lt;/code&gt; 为单位周期性被执行的。单次 &lt;code&gt;runloop&lt;/code&gt; 循环如果时长超过 16ms，就会导致 UI 体验的卡顿。那如何检测单次 &lt;code&gt;runloop&lt;/code&gt; 的耗时呢？&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaziacofGoEA5eGYP75Nyade54J1PC12ebfhThg3v25qsVLhcR8SJRfTLdkXsncGXtz5KJVwfj2NqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上图可以看到，如果我们注册一个 &lt;code&gt;runloop&lt;/code&gt; 生命周期事件的观察者，那么在 &lt;code&gt;afterWaiting=&amp;gt;beforeTimers，beforeTimers=&amp;gt;beforeSources&lt;/code&gt; 以及 &lt;code&gt;beforeSources=&amp;gt;beforeWaiting&lt;/code&gt; 这三个阶段都有可能发生耗时操作。所以对于卡顿问题的监控原理大概分为下面几步：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;注册 &lt;code&gt;runloop&lt;/code&gt; 生命周期事件的观察者。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在 &lt;code&gt;runloop&lt;/code&gt; 生命周期回调之间检测耗时，一旦检测到除休眠阶段之外的其他任意一个阶段耗时超过我们预先设定的卡顿阈值，则触发卡顿判定并且记录当时的调用栈。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在合适的时机上报到后端平台分析。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体流程如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaziacofGoEA5eGYP75NyadeCHGiaWN6QTUs7sn2B5sLIkqajxcLHeLnQFAq8k7e22sHuee0Dra4M7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;如何判定一次卡顿为一次卡死&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实通过上面的一些总结我们不难发现，长时间的卡顿最终无论是触发了系统的卡死崩溃，还是用户忍受不了主动结束进程或者退后台，他们的共同特征就是发生了长期时间卡顿且最终没有恢复，阻断了用户的正常使用流程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于这个理论的指导，我们就可以通过下面这个流程来判定某次卡顿到底是不是卡死：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;某次长时间的卡顿被检测到之后，记录当时所有线程的调用栈，存到数据库中作为卡死崩溃的怀疑对象。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;假如在当前 &lt;code&gt;runloop&lt;/code&gt; 的循环中进入到了下一个活跃状态，那么该卡顿不是一次卡死，就从数据库中删除该条日志。本次使用周期内，下次长时间的卡顿触发时再重新写入一条日志作为怀疑对象，依此类推。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在下次启动时检测上一次启动有没有卡死的日志（用户一次使用周期最多只会发生一次卡死），如果有，说明用户上一次使用期间最终遇到了一次长时间的卡顿，且最终 runloop 也没能进入下一个活跃状态，则标记为一次卡死崩溃上报。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4609375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaziacofGoEA5eGYP75NyadePt7iaxR1LicZJ0K4kxZmIbWHtSsu6zFbg1ns8VzxW9oAQBojibhe5fHmQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这套流程分析下来，我们不仅可以检测到系统的卡死崩溃，也可以检测到用户忍受不了长时间卡顿最终杀掉应用或者退后台之后被系统杀死等行为，这些场景虽然并没有实际触发系统的卡死崩溃，但是严重程度其实是等同的。也就是说本文提到的卡死崩溃监控能力是系统卡死崩溃的超集。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;卡死时间的阈值如何确定&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;系统的卡死崩溃日志格式截取部分如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Exception Type:  EXC_CRASH (SIGKILL)&lt;br/&gt;Exception Codes: 0x0000000000000000, 0x0000000000000000&lt;br/&gt;Exception Note:  EXC_CORPSE_NOTIFYTermination&lt;br/&gt;Reason: Namespace ASSERTIOND, Code 0x8badf00d&lt;br/&gt;Triggered by Thread:  0&lt;br/&gt;Termination Description: SPRINGBOARD, scene-&lt;span&gt;create&lt;/span&gt; watchdog transgression: application&amp;lt;com.ss.iphone.article.News&amp;gt;:&lt;span&gt;2135&lt;/span&gt; exhausted &lt;span&gt;real&lt;/span&gt; (wall clock) &lt;span&gt;time&lt;/span&gt; allowance &lt;span&gt;of&lt;/span&gt; &lt;span&gt;19.83&lt;/span&gt; &lt;span&gt;seconds&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到 iOS 系统的保护机制只有在 App 卡死时间超过一个异常阈值之后才会触发，那么这个卡死时间的阈值就是一个非常关键的参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;遗憾的是，目前没有官方的文档或者 api，可以直接拿到系统判定卡死崩溃的阈值。这里 &lt;code&gt;exhausted real (wall clock) time allowance of 19.83 seconds&lt;/code&gt; 其中的 19.83 并不是一个固定的数字，在不同的使用阶段，不同系统版本的实现里都可能有差异，在一些系统的崩溃日志中也遇到过 10s 的 case。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于以上信息，为了覆盖到大部分用户可以感知到的场景，屏蔽不同系统版本实现的差异，我们认为系统触发卡死崩溃的时间阈值为 10s，实际上有相当一部分用户在遇到 App 长时间卡顿的时候会习惯性的手动结束进程重启而不是一直等待，因此这个阈值不宜过长。为了给触发卡死判定之后的抓栈，日志写入等操作预留足够的时间，所以最终本方案的卡死时间阈值确定为 8s。发生 8s 卡死的概率比发生几百 ms 卡顿的概率要低的多，因此该卡死监控方案并没有太大的性能损耗，也就可以在生产环境中对全量用户开放。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;如何检测到用户一次卡死的时间&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在卡死发生之后，实际上我们也会关注一次卡死最终到底卡住了多久，卡死时间越长，对用户使用体验的伤害也就越大，更应该被高优解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在触发卡死阈值之后我们可以再以一个时间间隔比较短的定时器（目前策略默认 1s，线上可调整），每隔 1s 就检测当前 &lt;code&gt;runloop&lt;/code&gt; 有没有进入到下一个活跃状态，如果没有，则当前的卡死时间就累加 1s，用这种方式即使最终发生了闪退也可以逼近实际的卡死时间，误差不超过 1s，最终的卡死时间也会写入到日志中一起上报。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.43733333333333335&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaziacofGoEA5eGYP75NyadeNoBBcmXkPrtB4B00fHaBURwIwo4kjZrvLCweibCN05v8Oa9sIvy29dA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这种方案在上线后遇到了一些卡死时长特别长的 case，这种问题多发生在 App 切后台的场景。因为在后台情况下，App 的进程会被挂起(suspend)后，就可能被判定为持续很久的卡死状态。而我们在计算卡死时间的时候，采用的是现实世界的时间差，也就是说当前 App 在后台被挂起 10s 后又恢复时，我们会认为 App 卡死了 10s，轻易的超过了我们设定的卡死阈值，但其实 App 并没有真正卡死，而是操作系统的调度行为。这种误报常常是不符合我们的预期的。误报的场景如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.51875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaziacofGoEA5eGYP75Nyade3fACkT1ME5v3Wb1zIxM4a8n6hemgYrYK1F19hPmgVLeZmSM8RLmbUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;如何解决主线程调用栈可能有误报的问题&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决上面的问题，我们采用多段等待的方式来降低线程调度、挂起导致的程序运行时间与现实时间不匹配的问题，以下图为例。在 8s 的卡死阈值前，采用间隔等待的方式，每隔 1s 进行一次等待。等待超时后对当前卡死的时间进行累加 1s。如果在此过程中，App 被挂起，无论被挂起多久，再恢复时最多会造成 1s 的误差，这与之前的方案相比极大的增加了稳定性和准确性。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.434375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaziacofGoEA5eGYP75NyadeplOZ827THRxuwGA4GiagKgMEnBIib3wpMlamTWJ7lCEocuAHR7XHayVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，待卡死时间超过了设定的卡死阈值后，会对全线程进行抓栈。但是仅凭这一时刻的线程调用栈并不保证能够准确定位问题。因为此时主线程执行的可能是一个非耗时任务，真正耗时的任务已经结束；或者在后续会发生一个更加耗时的任务，这个任务才是造成卡死的关键。因此，为了增加卡死调用栈的置信度，在超过卡死阈值后，每隔 1s 进行一次间隔等待的同时，对当前主线程的堆栈进行抓取。为了避免卡死时间过长造成的线程调用栈数量膨胀，最多会保留距离 App 异常退出前的最近 10 次主线程调用栈。经过多次间隔等待，我们可以获取在 App 异常退出前主线程随着时间变化的一组函数调用栈。通过这组函数调用栈，我们可以定位到主线程真正卡死的原因，并结合卡死时间超过阈值时获取的全线程调用栈进一步定位卡死原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终的监控效果如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5265625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaziacofGoEA5eGYP75Nyade4c63UWFah6wic5XfHaazq7QWGOl40WGj7rgU2jiaQlftrH9UnYsVWHFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为图片大小的限制，这里仅仅截了卡死崩溃之前最后一次的主线程调用栈，实际使用的时候可以查看崩溃之前一段时间内每一秒的调用栈，如果发现每一次主线程的调用栈都没有变化，那就能确认这个卡死问题不是误报，例如这里就是一次异常的跨进程通信导致的卡死。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;卡死崩溃常见问题归类及最佳实践&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;多线程死锁&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;问题描述&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比较常见的就是在 &lt;code&gt;dispatch_once&lt;/code&gt; 中子线程同步访问主线程，最终造成死锁的问题。如上图所示，这个死锁的复现步骤是：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.0743243243243243&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaziacofGoEA5eGYP75NyadeDnMibZHWGQBN7I06VAXD4d6KjBTdhB2EqquLbmiavc6tAugt6oibD5cCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1184&quot;/&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;子线程先进入 &lt;code&gt;dispatch_once&lt;/code&gt; 的 block 中并加锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;然后主线程再进入 &lt;code&gt;dispatch_once&lt;/code&gt; 并等待子线程解锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;子线程初始化时触发了 &lt;code&gt;CTTelephonyNetworkInfo&lt;/code&gt; 对象初始化抛出了一个通知却要求主线程同步响应，这就造成了主线程和子线程因为互相等待而死锁，最终触发了卡死崩溃。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的其实是踩到了 &lt;code&gt;CTTelephonyNetworkInfo&lt;/code&gt; 一个潜在的坑。如果这里替换成一段 &lt;code&gt;dispatch_sync&lt;/code&gt; 到 &lt;code&gt;dispatch_get_main_queue()&lt;/code&gt;的代码，效果还是等同的，同样有卡死崩溃的风险。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;最佳实践&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;dispatch_once&lt;/code&gt; 中不要有同步到主线程执行的方法。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;CTTelephonyNetworkInfo&lt;/code&gt; 最好在 &lt;code&gt;+load&lt;/code&gt;方法或者 &lt;code&gt;main&lt;/code&gt; 方法之前的其他时机提前初始化一个共享的实例，避免踩到子线程懒加载时候要求主线程同步响应的坑。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;主线程执行代码与子线程耗时操作存在锁竞争&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;问题描述&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个比较典型的问题是卡死在&lt;code&gt;-[YYDiskCache containsObjectForKey:]&lt;/code&gt;，&lt;code&gt;YYDiskCache&lt;/code&gt; 内部针对磁盘多线程读写操作，通过一个信号量锁保证互斥。通过分析卡死堆栈可以发现是子线程占用锁资源进行耗时的写操作或清理操作引发主线程卡死，问题发生时一般可以发现如下的子线程调用栈：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4608333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaziacofGoEA5eGYP75NyadecuGOATny1heickseSsCYgibJQKYqD7WKxhFQEREnfZC5XicgzFphjVo6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;最佳实践&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;有可能存在锁竞争的代码尽量不在主线程同步执行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果主线程与子线程不可避免的存在竞争时，加锁的粒度要尽量小，操作要尽量轻。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;磁盘 IO 过于密集&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;问题描述&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此类问题，表现形式可能多种多样，但是归根结底都是因为磁盘 IO 过于密集最终导致主线程磁盘 IO 耗时过长。典型 case:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;主线程压缩/解压缩。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;主线程同步写入数据库，或者与子线程可能的耗时操作（例如 &lt;code&gt;sqlite&lt;/code&gt; 的 &lt;code&gt;vaccum&lt;/code&gt; 或者 &lt;code&gt;checkpoint&lt;/code&gt; 等）复用同一个串行队列同步写入。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;主线程磁盘 IO 比较轻量，但是子线程 IO 过于密集，常发生于一些低端设备。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;最佳实践&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;数据库读写，文件压缩/解压缩等磁盘 IO 行为不放在主线程执行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果存在主线程将任务同步到串行队列中执行的场景，确保这些任务不与子线程可能存在的耗时操作复用同一个串行队列。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;对于一些启动阶段非必要同步加载并且有比较密集磁盘 IO 行为的 SDK，如各种支付分享等第三方 SDK 都可以延迟，错开加载。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;系统 api 底层实现存在跨进程通信&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;问题描述&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为跨进程通信需要与其他进程同步，一旦其他进程发生异常或者挂起，很有可能造成当前 App 卡死。典型 case：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;UIPasteBoard&lt;/code&gt;，特别是 &lt;code&gt;OpenUDID&lt;/code&gt;。因为 &lt;code&gt;OpenUDID&lt;/code&gt; 这个库为了跨 App 可以访问到相同的 UDID，通过创建剪切板和读取剪切板的方式来实现的跨 App 通信，外部每次调用 &lt;code&gt;OpenUDID&lt;/code&gt; 来获取一次 UDID，OpenUDID 内部都会循环 100 次，从剪切板获取 UDID，并通过排序获得出现频率最高的那个 UDID，也就是这个流程可能最终会导致访问剪切板卡死。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;NSUserDefaults&lt;/code&gt; 底层实现中存在直接或者间接的跨进程通信，在主线程同步调用容易发生卡死。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;[[UIApplication sharedApplication] openURL]&lt;/code&gt;接口，内部实现也存在同步的跨进程通信。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;最佳实践&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;废弃 &lt;code&gt;OpenUDID&lt;/code&gt; 这个第三方库，一些依赖了 &lt;code&gt;UIPaseteBoard&lt;/code&gt; 的第三方 SDK 推动维护者下掉对 UIPasteBoard 的依赖并更新版本；或者将这些 SDK 的初始化统一放在非主线程，不过经验来看子线程初始化可能有 5%的卡死转化为闪退，因此最好加一个开关逐步放量观察。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;对于 kv 类存储需求，如果重度的使用可以考虑 &lt;code&gt;MMKV&lt;/code&gt;，如果轻度的使用可以参考 &lt;code&gt;firebase&lt;/code&gt; 的实现自己重写一个更轻量的 UserDefaults 类。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;iOS10 及以上的系统版本使用&lt;code&gt;[[UIApplication sharedApplication] openURL:options:completionHandler:]&lt;/code&gt;这个接口替换，此接口可以异步调起，不会造成卡死。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Objective-C Runtime Lock 死锁&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;问题描述&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此类问题虽然出现概率不大，但是在一些复杂场景下也是时有发生。主线程的调用栈一般都会卡死在一个看似很普通的 OC 方法调用，非常隐晦，因此想要发现这类问题，卡死监控模块本身就不能用 OC 语言实现，而应该改为 C/C++。此问题一般多发于&lt;code&gt;_dyld_register_func_for_add_image&lt;/code&gt; 回调方法中同步调用 OC 方法（先持有 dyld lock 后持有 OC runtime lock），以及 OC 方法同步调用 &lt;code&gt;objc_copyClassNamesForImage&lt;/code&gt; 方法（先持有 OC runtime lock 后持有 dyld lock）。典型 case：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;dyld lock、 selector lock 和 OC runtime lock 三个锁互相等待造成死锁的问题。三个锁互相等待的场景如下图所示：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.47734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/5EcwYhllQOiaziacofGoEA5eGYP75Nyadeic3w1PTtKNQ4dWR5M6vQmhKYmAkic6bXFQ6rWdUOo4vs5BWwbcTfHszg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在某次迭代的过程中 APM SDK 内部判定设备是否越狱的实现改为依赖 &lt;code&gt;fork&lt;/code&gt; 方法能否调用成功，但是 &lt;code&gt;fork&lt;/code&gt; 方法会调用 &lt;code&gt;_objc_atfork_prepare&lt;/code&gt;，这个函数会获取 objc 相关的 lock，之后会调用 &lt;code&gt;dyld_initializer&lt;/code&gt;，内部又会获取 dyld lock，如果此时我们的某个线程已经持有了 dyld lock，在等待 OC runtime lock，就会引发死锁。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;最佳实践&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;慎用&lt;code&gt;_dyld_register_func_for_add_image&lt;/code&gt; 和 &lt;code&gt;objc_copyClassNamesForImage&lt;/code&gt; 这两个方法，特别是与 OC 方法同步调用的场景。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;越狱检测，不依赖 &lt;code&gt;fork&lt;/code&gt; 方法的调用。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;试用路径&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前，字节 APM 中台自研的卡死监控功能已对外开发，搭载于字节跳动火山引擎旗下的应用性能监控平台上，以供外部开发者及企业使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用性能监控平台所集成的相关技术，经今日头条、抖音、西瓜视频等众多 APP 的打磨，已沉淀出一套完整的解决方案，能够定位移动端、浏览器、小程序等多端问题，除了支持崩溃、错误、卡顿、网络等基础问题的分析，还提供关联到应用启动、页面浏览、内存优化的众多能力，目前 Demo 已开放，欢迎大家试用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得注意的是，火山引擎近期针对中小企业及个人开发者推出了增长赋能计划——「火种计划」。符合条件的企业/开发者仅需于官网注册并提交相应申请，即可免费使用应用性能监控这一平台，有需要的同学抓紧申请吧～&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详情可点击传送门：&lt;span&gt;&lt;strong&gt;&lt;span&gt;https://zjsms.com/ed8ktbb/&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;加入我们&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本技术方案由字节跳动 APM 中台设计研发，欢迎对我们团队感兴趣的同学加入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字节跳动 APM 中台目前致力于提升整个集团内全系产品的性能和稳定性表现，技术栈覆盖 iOS/Android/Flutter/Web/Hybrid/PC/游戏/小程序等，工作内容包括但不限于线上监控，线上运维，深度优化，线下防劣化等。长期期望为业界输出更多更有建设性的问题发现和深度优化手段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欢迎各位有识之士加入我们，一起为了“更快，更稳，更省，更有品质”的极致目标携手前行。我们在北京，深圳两地均有招聘需求，简历投递邮箱：&lt;span&gt;&lt;strong&gt;tech@bytedance.com&lt;/strong&gt;&lt;/span&gt; ；邮件标题：&lt;span&gt;&lt;strong&gt;姓名 - 工作年限 - APM 中台 - 技术栈方向&lt;/strong&gt;&lt;/span&gt;（如 iOS/Android/Web/后端）。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;参考文献&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[1]https://developer.apple.com/documentation/xcode/diagnosing_issues_using_crash_reports_and_device_logs/identifying_the_cause_of_common_crashes/addressing_watchdog_terminations&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[2]https://geek-is-stupid.github.io/2018-10-15-0x8badf00d-ate-bad-food/&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[3]https://honchwong.github.io/2018/05/05/Crash%E5%88%86%E6%9E%90%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%EF%BC%9ALaunchDaemons%E4%B8%AD%E7%9A%84ReportCrash/&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[4]https://zhuanlan.zhihu.com/p/37652140&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;[5]http://openfibers.github.io/blog/2016/10/22/deadlock-caused-by-dispatch-once/&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>