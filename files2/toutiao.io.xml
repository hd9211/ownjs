<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>2966229644425e7c9339084bda74db2c</guid>
<title>2万字 + 50 张图，细说 JVM 内存分布、内存对齐、压缩指针！</title>
<link>https://toutiao.io/k/02whm5c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.75&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/J0g14CUwaZdwkxf9KpduegYClib9mbvJlw6YSlyXwar1e8wLuxcWPUmRpNOU9tZwdaLPx85rf14z0uXBLsaeASw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天为大家带来一篇 2 万字的硬核技术文章。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.3618421052631579&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZeaKYVicAZVk1VAnhiamA41gT2ojtuPGEJjia3kBwibBnsR9zTsFUWjwGWQvhAYSI5MhM59te7XE8Kadg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;304&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们将从计算机组成原理的角度详细阐述对象在JVM内存中是如何布局的，以及什么是内存对齐，如果我们头比较铁，就是不进行内存对齐会造成什么样的后果，最后引出压缩指针的原理和应用。同时我们还介绍了在高并发场景下，False Sharing产生的原因以及带来的性能影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信大家看完本文后，一定会收获很多，话不多说，下面我们正式开始本文的内容~~&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.2274193548387098&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3ricXgeszzmZ697l6f7qkJF65XDsfCVIyhTiagCtzNVc0qj75ULcmE8GWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;本文概要.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们的日常工作中，有时候我们为了防止线上应用发生&lt;code&gt;OOM&lt;/code&gt;，所以我们需要在开发的过程中计算一些核心对象在内存中的占用大小，目的是为了更好的了解我们的应用程序内存占用的一个大概情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进而根据我们服务器的内存资源限制以及预估的对象创建数量级计算出应用程序占用内存的高低水位线，如果内存占用量超过&lt;code&gt;高水位线&lt;/code&gt;，那么就有可能有发生&lt;code&gt;OOM&lt;/code&gt;的风险。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以在程序中根据估算出的&lt;code&gt;高低水位线&lt;/code&gt;，做一些防止&lt;code&gt;OOM&lt;/code&gt;的处理逻辑或者发出告警。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那么核心问题是如何计算一个Java对象在内存中的占用大小呢？？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在为大家解答这个问题之前，笔者先来介绍下Java对象在内存中的布局，也就是本文的主题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. Java对象的内存布局&lt;/span&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5758064516129032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r3I5lLLo8slEicxFgVfFAdGqDVOBdRPgVkduFxd2BEe6LplnF30pr72A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;Java对象的内存布局.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图所示，Java对象在JVM中是用&lt;code&gt;instanceOopDesc &lt;/code&gt;结构表示而Java对象在JVM堆中的内存布局可以分为三部分：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 对象头（Header）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个Java对象都包含一个对象头，对象头中包含了两类信息：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;MarkWord&lt;/code&gt;：在JVM中用&lt;code&gt;markOopDesc &lt;/code&gt;结构表示用于存储对象自身运行时的数据。比如：hashcode，GC分代年龄，锁状态标志，线程持有的锁，偏向线程Id，偏向时间戳等。在32位操作系统和64位操作系统中&lt;code&gt;MarkWord&lt;/code&gt;分别占用4B和8B大小的内存。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;类型指针&lt;/code&gt;：JVM中的类型指针封装在&lt;code&gt;klassOopDesc &lt;/code&gt;结构中，类型指针指向了&lt;code&gt;InstanceKclass对象&lt;/code&gt;，Java类在JVM中是用InstanceKclass对象封装的，里边包含了Java类的元信息，比如：继承结构，方法，静态变量，构造函数等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;在不开启指针压缩的情况下(-XX:-UseCompressedOops)。在32位操作系统和64位操作系统中类型指针分别占用4B和8B大小的内存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在开启指针压缩的情况下(-XX:+UseCompressedOops)。在32位操作系统和64位操作系统中类型指针分别占用4B和4B大小的内存。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果Java对象是一个数组类型的话，那么在数组对象的对象头中还会包含一个4B大小的用于记录数组长度的属性。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;由于在对象头中用于记录数组长度大小的属性只占4B的内存，所以Java数组可以申请的最大长度为：&lt;code&gt;2^32&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 实例数据（Instance Data)&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java对象在内存中的实例数据区用来存储Java类中定义的实例字段，包括所有父类中的实例字段。也就是说，虽然子类无法访问父类的私有实例字段，或者子类的实例字段隐藏了父类的同名实例字段，但是子类的实例还是会为这些父类实例字段分配内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java对象中的字段类型分为两大类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;基础类型：Java类中实例字段定义的基础类型在实例数据区的内存占用如下：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;long | double占用8个字节。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;int | float占用4个字节。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;short | char占用2个字节。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;byte | boolean占用1个字节。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;引用类型：Java类中实例字段的引用类型在实例数据区内存占用分为两种情况：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;不开启指针压缩(-XX:-UseCompressedOops)：在32位操作系统中引用类型的内存占用为4个字节。在64位操作系统中引用类型的内存占用为8个字节。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开启指针压缩(-XX:+UseCompressedOops)：在64为操作系统下，引用类型内存占用则变为为4个字节，32位操作系统中引用类型的内存占用继续为4个字节。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么32位操作系统的引用类型占4个字节，而64位操作系统引用类型占8字节？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java中，引用类型所保存的是被引用对象的内存地址。在32位操作系统中内存地址是由32个bit表示，因此需要4个字节来记录内存地址，能够记录的虚拟地址空间是2^32大小，也就是只能够表示4G大小的内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在64位操作系统中内存地址是由64个bit表示，因此需要8个字节来记录内存地址，&lt;strong&gt;但在 64 位系统里只使用了低 48 位，所以它的虚拟地址空间是 2^48大小，能够表示256T大小的内存&lt;/strong&gt;，其中低 128T 的空间划分为用户空间，高 128T 划分为内核空间，可以说是非常大了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们从整体上介绍完Java对象在JVM中的内存布局之后，下面我们来看下Java对象中定义的这些实例字段在实例数据区是如何排列布局的：&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 字段重排列&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实我们在编写Java源代码文件的时候定义的那些实例字段的顺序会被JVM重新分配排列，这样做的目的其实是为了内存对齐，那么什么是内存对齐，为什么要进行内存对齐，笔者会随着文章深入的解读为大家逐层揭晓答案~~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本小节中，笔者先来为大家介绍一下JVM字段重排列的规则:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM重新分配字段的排列顺序受&lt;code&gt;-XX:FieldsAllocationStyle&lt;/code&gt;参数的影响，默认值为&lt;code&gt;1&lt;/code&gt;，实例字段的重新分配策略遵循以下规则：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;如果一个字段占用&lt;code&gt;X&lt;/code&gt;个字节，那么这个字段的偏移量&lt;code&gt;OFFSET&lt;/code&gt;需要对齐至&lt;code&gt;NX&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;偏移量是指字段的内存地址与Java对象的起始内存地址之间的差值。比如long类型的字段，它内存占用8个字节，那么它的OFFSET应该是8的倍数8N。不足8N的需要填充字节。&lt;/p&gt;&lt;/blockquote&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在开启了压缩指针的64位JVM中，Java类中的第一个字段的OFFSET需要对齐至4N，在关闭压缩指针的情况下类中第一个字段的OFFSET需要对齐至8N。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;JVM默认分配字段的顺序为：long / double，int / float，short / char，byte / boolean，oops(Ordianry Object Point 引用类型指针)，&lt;strong&gt;并且父类中定义的实例变量会出现在子类实例变量之前&lt;/strong&gt;。当设置JVM参数&lt;code&gt;-XX +CompactFields &lt;/code&gt;时（默认），占用内存小于long / double 的字段会允许被插入到对象中第一个 long / double字段之前的间隙中，以避免不必要的内存填充。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;CompactFields选项参数在JDK14中以被标记为过期了，并在将来的版本中很可能被删除。详细细节可查看issue：https://bugs.openjdk.java.net/browse/JDK-8228750&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上边的三条字段重排列规则非常非常重要，但是读起来比较绕脑，很抽象不容易理解，笔者把它们先列出来的目的是为了让大家先有一个朦朦胧胧的感性认识，下面笔者举一个具体的例子来为大家详细说明下，在阅读这个例子的过程中也方便大家深刻的理解这三条重要的字段重排列规则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设现在我们有这样一个类定义&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Parent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; l;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Child&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Parent&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; l;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; i;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;根据上面介绍的&lt;code&gt;规则3&lt;/code&gt;我们知道父类中的变量是出现在子类变量之前的，并且字段分配顺序应该是long型字段l，应该在int型字段i之前。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果JVM开启了&lt;code&gt;-XX +CompactFields&lt;/code&gt;时，int型字段是可以插入对象中的第一个long型字段（也就是Parent.l字段）之前的空隙中的。如果JVM设置了&lt;code&gt;-XX -CompactFields&lt;/code&gt;则int型字段的这种插入行为是不被允许的。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据&lt;code&gt;规则1&lt;/code&gt;我们知道long型字段在实例数据区的OFFSET需要对齐至8N，而int型字段的OFFSET需要对齐至4N。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据&lt;code&gt;规则2&lt;/code&gt;我们知道如果开启压缩指针&lt;code&gt;-XX:+UseCompressedOops&lt;/code&gt;，Child对象的第一个字段的OFFSET需要对齐至4N，关闭压缩指针时&lt;code&gt;-XX:-UseCompressedOops&lt;/code&gt;，Child对象的第一个字段的OFFSET需要对齐至8N。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于JVM参数&lt;code&gt;UseCompressedOops &lt;/code&gt;和&lt;code&gt;CompactFields &lt;/code&gt;的存在，导致Child对象在实例数据区字段的排列顺序分为四种情况，下面我们结合前边提炼出的这三点规则来看下字段排列顺序在这四种情况下的表现。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 -XX:+UseCompressedOops  -XX -CompactFields 开启压缩指针，关闭字段压缩&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23629032258064517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rTn3QqBMZRFMoibE8Z73erHr9SbSXMZXXCUL9yztHqeZSueFdOxQMugA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;偏移量OFFSET = 8的位置存放的是类型指针，由于开启了压缩指针所以占用4个字节。对象头总共占用12个字节：MarkWord(8字节) + 类型指针(4字节)。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据&lt;code&gt;规则3：&lt;/code&gt;父类Parent中的字段是要出现在子类Child的字段之前的并且long型字段在int型字段之前。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;根据规则2：&lt;/code&gt;在开启压缩指针的情况下，Child对象中的第一个字段需要对齐至4N。这里Parent.l字段的OFFSET可以是12也可以是16。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;根据规则1：&lt;/code&gt;long型字段在实例数据区的OFFSET需要对齐至8N，所以这里Parent.l字段的OFFSET只能是16，因此OFFSET = 12的位置就需要被填充。Child.l字段只能在OFFSET = 32处存储，不能够使用OFFSET = 28位置，因为28的位置不是8的倍数无法对齐8N，因此OFFSET = 28的位置被填充了4个字节。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;规则1也规定了int型字段的OFFSET需要对齐至4N，所以Parent.i与Child.i分别存储以OFFSET = 24和OFFSET = 40的位置。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;因为JVM中的内存对齐除了存在于字段与字段之间还存在于对象与对象之间，Java对象之间的内存地址需要对齐至8N&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以Child对象的末尾处被填充了4个字节，对象大小由开始的44字节被填充到48字节。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2  -XX:+UseCompressedOops  -XX +CompactFields 开启压缩指针，开启字段压缩&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1814516129032258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rDUgEBKWWc9ahzQR8rqV39GoH6b2dbub8ViaiaCt5WE5n3pIOsaxFSFbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在第一种情况的分析基础上，我们开启了&lt;code&gt;-XX +CompactFields&lt;/code&gt;压缩字段，所以导致int型的Parent.i字段可以插入到OFFSET = 12的位置处，以避免不必要的字节填充。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据&lt;code&gt;规则2：&lt;/code&gt;Child对象的第一个字段需要对齐至4N，这里我们看到&lt;code&gt;int型&lt;/code&gt;的Parent.i字段是符合这个规则的。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据&lt;code&gt;规则1：&lt;/code&gt;Child对象的所有long型字段都对齐至8N，所有的int型字段都对齐至4N。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最终得到Child对象大小为36字节，由于Java对象与对象之间的内存地址需要对齐至8N，所以最后Child对象的末尾又被填充了4个字节最终变为40字节。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这里我们可以看到在开启字段压缩&lt;code&gt;-XX +CompactFields&lt;/code&gt;的情况下，Child对象的大小由48字节变成了40字节。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 -XX:-UseCompressedOops  -XX -CompactFields 关闭压缩指针，关闭字段压缩&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23306451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rUIwxgUGicbCZ6bkcIT0gnpMSRAm1Ky5MmEkcCticjCaialUgZBqUuxRcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先在关闭压缩指针&lt;code&gt;-UseCompressedOops&lt;/code&gt;的情况下，对象头中的类型指针占用字节变成了8字节。导致对象头的大小在这种情况下变为了16字节。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据&lt;code&gt;规则1：&lt;/code&gt;long型的变量OFFSET需要对齐至8N。根据&lt;code&gt;规则2：&lt;/code&gt;在关闭压缩指针的情况下，Child对象的第一个字段Parent.l需要对齐至8N。所以这里的Parent.l字段的OFFSET  = 16。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;由于long型的变量OFFSET需要对齐至8N，所以Child.l字段的OFFSET
需要是32，因此OFFSET = 28的位置被填充了4个字节。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样计算出来的Child对象大小为44字节，但是考虑到Java对象与对象的内存地址需要对齐至8N，于是又在对象末尾处填充了4个字节，最终Child对象的内存占用为48字节。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4  -XX:-UseCompressedOops  -XX +CompactFields 关闭压缩指针，开启字段压缩&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在第三种情况的分析基础上，我们来看下第四种情况的字段排列情况：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2153225806451613&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rkd3BpQQERqordT5gAdsgiaicyvIqEr9rFyFZmw1MqJjU29eaesHScn8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于在关闭指针压缩的情况下类型指针的大小变为了8个字节，所以导致Child对象中第一个字段Parent.l前边并没有空隙，刚好对齐8N，并不需要int型变量的插入。所以即使开启了字段压缩&lt;code&gt;-XX +CompactFields&lt;/code&gt;，字段的总体排列顺序还是不变的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;默认情况下指针压缩&lt;code&gt;-XX:+UseCompressedOops&lt;/code&gt;以及字段压缩&lt;code&gt;-XX +CompactFields&lt;/code&gt;都是开启的&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 对齐填充（Padding)&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前一小节关于实例数据区字段重排列的介绍中为了内存对齐而导致的字节填充不仅会出现在字段与字段之间，还会出现在对象与对象之间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边我们介绍了字段重排列需要遵循的三个重要规则，其中规则1，规则2定义了字段与字段之间的内存对齐规则。规则3定义的是对象字段之间的排列规则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了内存对齐的需要，对象头与字段之间，以及字段与字段之间需要填充一些不必要的字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如前边提到的字段重排列的第一种情况&lt;code&gt;-XX:+UseCompressedOops -XX -CompactFields&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.23629032258064517&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rTn3QqBMZRFMoibE8Z73erHr9SbSXMZXXCUL9yztHqeZSueFdOxQMugA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而以上提到的四种情况都会在对象实例数据区的后边在填充4字节大小的空间，原因是除了需要满足字段与字段之间的内存对齐之外，还需要满足对象与对象之间的内存对齐。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 虚拟机堆中对象之间的内存地址需要对齐至8N（8的倍数），如果一个对象占用内存不到8N个字节，那么就必须在对象后填充一些不必要的字节对齐至8N个字节。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;虚拟机中内存对齐的选项为&lt;code&gt;-XX:ObjectAlignmentInBytes&lt;/code&gt;，默认为8。也就是说对象与对象之间的内存地址需要对齐至多少倍，是由这个JVM参数控制的。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是以上边第一种情况为例说明：图中对象实际占用是44个字节，但是不是8的倍数，那么就需要再填充4个字节，内存对齐至48个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上这些为了内存对齐的目的而在字段与字段之间，对象与对象之间填充的不必要字节，我们就称之为&lt;code&gt;对齐填充（Padding）&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 对齐填充的应用&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们知道了对齐填充的概念之后，大家可能好奇了，为啥我们要进行对齐填充，是要解决什么问题吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么就让我们带着这个问题，来接着听笔者往下聊~~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1 解决伪共享问题带来的对齐填充&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了以上介绍的两种对齐填充的场景（字段与字段之间，对象与对象之间），在JAVA中还有一种对齐填充的场景，那就是通过对齐填充的方式来解决&lt;code&gt;False Sharing（伪共享）&lt;/code&gt;的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在介绍False Sharing（伪共享）之前，笔者先来介绍下CPU读取内存中数据的方式。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1.1 CPU缓存&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据摩尔定律：芯片中的晶体管数量每隔&lt;code&gt;18&lt;/code&gt;个月就会翻一番。导致CPU的性能和处理速度变得越来越快，而提升CPU的运行速度比提升内存的运行速度要容易和便宜的多，所以就导致了CPU与内存之间的速度差距越来越大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了弥补CPU与内存之间巨大的速度差异，提高CPU的处理效率和吞吐，于是人们引入了&lt;code&gt;L1,L2,L3&lt;/code&gt;高速缓存集成到CPU中。当然还有&lt;code&gt;L0&lt;/code&gt;也就是寄存器，寄存器离CPU最近，访问速度也最快，基本没有时延。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6556451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3ruGeiaJSUicRiboqYgiaAWqhLFI8lDanK1q52jytoe5w9xibl51u246UUmWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;CPU缓存结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个CPU里面包含多个核心，我们在购买电脑的时候经常会看到这样的处理器配置，比如&lt;code&gt;4核8线程&lt;/code&gt;。意思是这个CPU包含4个物理核心8个逻辑核心。4个物理核心表示在同一时间可以允许4个线程并行执行，8个逻辑核心表示处理器利用&lt;code&gt;超线程的技术&lt;/code&gt;将一个物理核心模拟出了两个逻辑核心，一个物理核心在同一时间只会执行一个线程，而&lt;code&gt;超线程芯片&lt;/code&gt;可以做到线程之间快速切换，当一个线程在访问内存的空隙，超线程芯片可以马上切换去执行另外一个线程。因为切换速度非常快，所以在效果上看到是8个线程在同时执行。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;图中的CPU核心指的是物理核心。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中我们可以看到L1Cache是离CPU核心最近的高速缓存，紧接着就是L2Cache，L3Cache，内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;离CPU核心越近的缓存访问速度也越快，造价也就越高，当然容量也就越小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中L1Cache和L2Cache是CPU物理核心私有的（&lt;strong&gt;注意：这里是物理核心不是逻辑核心&lt;/strong&gt;）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而L3Cache是整个CPU所有物理核心共享的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;CPU逻辑核心共享其所属物理核心的L1Cache和L2Cache&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;L1Cache&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;L1Cache离CPU是最近的，它的访问速度最快，容量也最小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中我们看到L1Cache分为两个部分，分别是：Data Cache和Instruction Cache。它们一个是存储数据的，一个是存储代码指令的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过&lt;code&gt;cd /sys/devices/system/cpu/&lt;/code&gt;来查看linux机器上的CPU信息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.10483870967741936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rQDoCpOjBGDjIRQFgYz5PpQvR7WjNkM34wibLLreU7cjhnicMyicyynTow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;/sys/devices/system/cpu/&lt;/code&gt;目录里，我们可以看到CPU的核心数，&lt;strong&gt;当然这里指的是逻辑核心&lt;/strong&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;笔者机器上的处理器并没有使用超线程技术所以这里其实是4个物理核心。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们进入其中一颗CPU核心（cpu0）中去看下L1Cache的情况：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU缓存的情况在&lt;code&gt;/sys/devices/system/cpu/cpu0/cache&lt;/code&gt;目录下查看：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.07231920199501247&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rdBic5LNCpCTfiacvTic6bE1vnpvQS8QtdA3okiaNE4BibjicFv6RTgw8IxdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;index0&lt;/code&gt;描述的是L1Cache中DataCache的情况：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1774193548387097&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r5Ztzic9ubE7Yao8kwqDNrE4Th9yFMGbjp02EgsDmWdP5D5NRTDRnz6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;level&lt;/code&gt;：表示该cache信息属于哪一级，1表示L1Cache。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;type&lt;/code&gt;：表示属于L1Cache的DataCache。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;size&lt;/code&gt;：表示DataCache的大小为32K。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;shared_cpu_list&lt;/code&gt;：之前我们提到L1Cache和L2Cache是CPU物理核所私有的，而由物理核模拟出来的逻辑核是&lt;strong&gt;共享L1Cache和L2Cache的&lt;/strong&gt;，&lt;code&gt;/sys/devices/system/cpu/&lt;/code&gt;目录下描述的信息是逻辑核。shared_cpu_list描述的正是哪些逻辑核共享这个物理核。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;index1&lt;/code&gt;描述的是L1Cache中Instruction Cache的情况：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.14965986394557823&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3raUkia8dMPfuZycmq6V3yxPEgsOibdPkXdOcf8jiacjsKibIoZCA0pTYwUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1176&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到L1Cache中的Instruction Cache大小也是32K。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;L2Cache&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;L2Cache的信息存储在&lt;code&gt;index2&lt;/code&gt;目录下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15172413793103448&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rBPG6d6wMicBXC6XNicM4Q4xmwAPvCUVoqicqtegyV1mibEr8gMCOlPjo9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1160&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;L2Cache的大小为256K，比L1Cache要大些。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;L3Cache&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;L3Cache的信息存储在&lt;code&gt;index3&lt;/code&gt;目录下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15411558669001751&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r8EhWk8gMQibcobiaSg6jBXwDYesjukUia4SRXU6d9h9Bf4rm4ZTRMAib4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1142&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里我们可以看到L1Cache中的DataCache和InstructionCache大小一样都是32K而L2Cache的大小为256K，L3Cache的大小为6M。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这些数值在不同的CPU配置上会是不同的，但是总体上来说L1Cache的量级是几十KB，L2Cache的量级是几百KB，L3Cache的量级是几MB。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.1.2 CPU缓存行&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边我们介绍了CPU的高速缓存结构，引入高速缓存的目的在于消除CPU与内存之间的速度差距，根据&lt;code&gt;程序的局部性原理&lt;/code&gt;我们知道，CPU的高速缓存肯定是用来存放热点数据的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;程序局部性原理表现为：时间局部性和空间局部性。时间局部性是指如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某块数据被访问，则不久之后该数据可能再次被访问。空间局部性是指一旦程序访问了某个存储单元，则不久之后，其附近的存储单元也将被访问。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么在高速缓存中存取数据的基本单位又是什么呢？？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上热点数据在CPU高速缓存中的存取并不是我们想象中的以单独的变量或者单独的指针为单位存取的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU高速缓存中存取数据的基本单位叫做缓存行&lt;code&gt;cache line&lt;/code&gt;。缓存行存取字节的大小为2的倍数，在不同的机器上，缓存行的大小范围在32字节到128字节之间。目前所有主流的处理器中缓存行的大小均为&lt;code&gt;64字节&lt;/code&gt;（&lt;strong&gt;注意：这里的单位是字节&lt;/strong&gt;）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1685483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rFp5pibic2ibgK0RhpiaNSzG8LY5TVRjoLibakY8jIicsxTu4EoYgUzGXq7tA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中我们可以看到L1Cache,L2Cache,L3Cache中缓存行的大小都是&lt;code&gt;64字节&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也就意味着每次CPU从内存中获取数据或者写入数据的大小为64个字节，即使你只读一个bit，CPU也会从内存中加载64字节数据进来。同样的道理，CPU从高速缓存中同步数据到内存也是按照64字节的单位来进行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如你访问一个long型数组，当CPU去加载数组中第一个元素时也会同时将后边的7个元素一起加载进缓存中。&lt;strong&gt;这样一来就加快了遍历数组的效率。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;long类型在Java中占用8个字节，一个缓存行可以存放8个long型变量。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事实上，你可以非常快速的遍历在连续的内存块中分配的任意数据结构，如果你的数据结构中的项在内存中不是彼此相邻的（比如：链表），这样就无法利用CPU缓存的优势。由于数据在内存中不是连续存放的，所以在这些数据结构中的每一个项都可能会出现缓存行未命中（&lt;code&gt;程序局部性原理&lt;/code&gt;）的情况。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;还记得我们在&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;amp;mid=2247483907&amp;amp;idx=1&amp;amp;sn=084c470a8fe6234c2c9461b5f713ff30&amp;amp;chksm=ce77c444f9004d52e7c6244bee83479070effb0bc59236df071f4d62e91e25f01715fca53696&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;?&lt;/span&gt;《Reactor在Netty中的实现(创建篇)》&lt;/a&gt;中介绍Selector的创建时提到，Netty利用数组实现的自定义SelectedSelectionKeySet类型替换掉了JDK利用HashSet类型实现的&lt;code&gt;sun.nio.ch.SelectorImpl#selectedKeys&lt;/code&gt;。&lt;strong&gt;目的就是利用CPU缓存的优势来提高IO活跃的SelectionKeys集合的遍历性能&lt;/strong&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.2 False Sharing（伪共享）&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看一个这样的例子，笔者定义了一个示例类FalseSharding，类中有两个long型的volatile字段a，b。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FalseSharding&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; a;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; b;&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字段a，b之间逻辑上是独立的，它们之间一点关系也没有，分别用来存储不同的数据，数据之间也没有关联。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FalseSharding类中字段之间的内存布局如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1282258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rIkusicdpvzH08AqomqdzO2kTIoFr11Zgm4AD8321M6juwibgGibBZeJiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FalseSharding类中的字段a,b在内存中是相邻存储，分别占用8个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果恰好字段a，b被CPU读进了同一个缓存行，而此时有两个线程，线程a用来修改字段a，同时线程b用来读取字段b。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7330645161290322&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rp7SqclFcyfHiaq64J2oQgXg8e9ictC2Er2TqjgGygFM9w9ToXhKakSxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;falsesharding1.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;在这种场景下，会对线程b的读取操作造成什么影响呢&lt;/strong&gt;？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道声明了&lt;code&gt;volatile关键字&lt;/code&gt;的变量可以在多线程处理环境下，确保内存的可见性。计算机硬件层会保证对被volatile关键字修饰的共享变量进行写操作后的内存可见性，而这种内存可见性是由&lt;code&gt;Lock前缀指令&lt;/code&gt;以及&lt;code&gt;缓存一致性协议（MESI控制协议）&lt;/code&gt;共同保证的。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Lock前缀指令可以使修改线程所在的处理器中的相应缓存行数据被修改后立马刷新回内存中，并同时&lt;code&gt;锁定&lt;/code&gt;所有处理器核心中缓存了该修改变量的缓存行，防止多个处理器核心并发修改同一缓存行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;缓存一致性协议主要是用来维护多个处理器核心之间的CPU缓存一致性以及与内存数据的一致性。每个处理器会在总线上嗅探其他处理器准备写入的内存地址，如果这个内存地址在自己的处理器中被缓存的话，就会将自己处理器中对应的缓存行置为&lt;code&gt;无效&lt;/code&gt;，下次需要读取的该缓存行中的数据的时候，就需要访问内存获取。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;基于以上volatile关键字原则，我们首先来看第一种影响&lt;/strong&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5919354838709677&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r7wY7nnNnOPoKmzuicta6VYXzeUqVyQ80rBPniabpvAhiaTFUqYFDDs4dA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;falsesharding2.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当线程a在处理器core0中对字段a进行修改时，&lt;code&gt;Lock前缀指令&lt;/code&gt;会将所有处理器中缓存了字段a的对应缓存行进行&lt;code&gt;锁定&lt;/code&gt;，&lt;strong&gt;这样就会导致线程b在处理器core1中无法读取和修改自己缓存行的字段b&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;处理器core0将修改后的字段a所在的缓存行刷新回内存中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从图中我们可以看到此时字段a的值在处理器core0的缓存行中以及在内存中已经发生变化了。但是处理器core1中字段a的值还没有变化，并且core1中字段a所在的缓存行处于&lt;code&gt;锁定状态&lt;/code&gt;，无法读取也无法写入字段b。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上述过程中我们可以看出即使字段a，b之间逻辑上是独立的，它们之间一点关系也没有，但是线程a对字段a的修改，导致了线程b无法读取字段b。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第二种影响&lt;/strong&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7693548387096775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rnB60WxJJOpAyczIn2FuP2j5QgEgr2MNN0qOlBhDVAjFjib9bzo92wpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;faslesharding3.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当处理器core0将字段a所在的缓存行刷新回内存的时候，处理器core1会在总线上嗅探到字段a的内存地址正在被其他处理器修改，所以将自己的缓存行置为&lt;code&gt;失效&lt;/code&gt;。当线程b在处理器core1中读取字段b的值时，发现缓存行已被置为&lt;code&gt;失效&lt;/code&gt;，core1需要重新从内存中读取字段b的值即使字段b没有发生任何变化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从以上两种影响我们看到字段a与字段b实际上并不存在共享，它们之间也没有相互关联关系，理论上线程a对字段a的任何操作，都不应该影响线程b对字段b的读取或者写入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但事实上线程a对字段a的修改导致了字段b在core1中的缓存行被锁定（Lock前缀指令），进而使得线程b无法读取字段b。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程a所在处理器core0将字段a所在缓存行同步刷新回内存后，导致字段b在core1中的缓存行被置为&lt;code&gt;失效&lt;/code&gt;（缓存一致性协议），进而导致线程b需要重新回到内存读取字段b的值无法利用CPU缓存的优势。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于字段a和字段b在同一个缓存行中，导致了字段a和字段b事实上的共享（原本是不应该被共享的）。这种现象就叫做&lt;code&gt;False Sharing（伪共享）&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在高并发的场景下，这种伪共享的问题，会对程序性能造成非常大的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果线程a对字段a进行修改，与此同时线程b对字段b也进行修改，这种情况对性能的影响更大，因为这会导致core0和core1中相应的缓存行相互失效。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.3 False Sharing的解决方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然导致False Sharing出现的原因是字段a和字段b在同一个缓存行导致的，那么我们就要想办法让字段a和字段b不在一个缓存行中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们怎么做才能够使得字段a和字段b一定不会被分配到同一个缓存行中呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候，本小节的主题字节填充就派上用场了~~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java8之前我们通常会在字段a和字段b前后分别填充7个long型变量(缓存行大小64字节)，目的是让字段a和字段b各自独占一个缓存行避免&lt;code&gt;False Sharing&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们将一开始的实例代码修改成这个这样子，就可以保证字段a和字段b各自独占一个缓存行了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FalseSharding&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; p1,p2,p3,p4,p5,p6,p7;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; a;&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; p8,p9,p10,p11,p12,p13,p14;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; b;&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; p15,p16,p17,p18,p19,p20,p21;&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改后的对象在内存中布局如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47580645161290325&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rUI6HrVY89690zicQejoWhiaIguq7jBiaujKzicrbqxjo3RJ53BGb45ozng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到为了解决False Sharing问题，我们将原本占用32字节的FalseSharding示例对象硬生生的填充到了200字节。这对内存的消耗是非常可观的。通常为了极致的性能，我们会在一些高并发框架或者JDK的源码中看到False Sharing的解决场景。因为在高并发场景中，任何微小的性能损失比如False Sharing，都会被无限放大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但解决False Sharing的同时又会带来巨大的内存消耗，所以即使在高并发框架比如disrupter或者JDK中也只是&lt;strong&gt;针对那些在多线程场景下被频繁写入的共享变量&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这里笔者想强调的是在我们日常工作中&lt;/strong&gt;，我们不能因为自己手里拿着锤子，就满眼都是钉子，看到任何钉子都想上去锤两下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rHkkic5QPnrIgdFMNicgPufSU5znYlN8rfUdVey7zP9GWl93fYqkdGO4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;255&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们要清晰的分辨出一个问题会带来哪些影响和损失，这些影响和损失在我们当前业务阶段是否可以接受？是否是瓶颈？同时我们也要清晰的了解要解决这些问题我们所要付出的代价。一定要综合评估，讲究一个投入产出比。某些问题虽然是问题，但是在某些阶段和场景下并不需要我们投入解决。而有些问题则对于我们当前业务发展阶段是瓶颈，我们&lt;strong&gt;不得不&lt;/strong&gt;去解决。我们在架构设计或者程序设计中，方案一定要&lt;code&gt;简单&lt;/code&gt;，&lt;code&gt;合适&lt;/code&gt;。并预估一些提前量留有一定的&lt;code&gt;演化空间&lt;/code&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.3.1 @Contended注解&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java8中引入了一个新注解&lt;code&gt;@Contended&lt;/code&gt;，用于解决False Sharing的问题，同时这个注解也会影响到Java对象中的字段排列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上一小节的内容介绍中，我们通过手段填充字段的方式解决了False Sharing的问题，但是这里也有一个问题，因为我们在手动填充字段的时候还需要考虑CPU缓存行的大小，因为虽然现在所有主流的处理器缓存行大小均为64字节，但是也还是有处理器的缓存行大小为32字节，有的甚至是128字节。我们需要考虑很多硬件的限制因素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java8中通过引入@Contended注解帮我们解决了这个问题，我们不在需要去手动填充字段了。下面我们就来看下@Contended注解是如何帮助我们来解决这个问题的~~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上小节介绍的手动填充字节是在共享变量前后填充64字节大小的空间，这样只能确保程序在缓存行大小为32字节或者64字节的CPU下独占缓存行。但是如果CPU的缓存行大小为128字节，这样依然存在False Sharing的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引入@Contended注解可以使我们忽略底层硬件设备的差异性，做到Java语言的初衷：平台无关性。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;@Contended注解默认只是在JDK内部起作用，如果我们的程序代码中需要使用到@Contended注解，那么需要开启JVM参数&lt;code&gt;-XX:-RestrictContended&lt;/code&gt;才会生效。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;br/&gt;&lt;span&gt;@Target&lt;/span&gt;({ElementType.FIELD, ElementType.TYPE})&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;@interface&lt;/span&gt; Contended {&lt;br/&gt;    &lt;span&gt;//contention group tag&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;String &lt;span&gt;value&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &quot;&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;@Contended注解可以标注在类上也可以标注在类中的字段上，被@Contended标注的对象会独占缓存行，不会和任何变量或者对象共享缓存行。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;@Contended标注在类上表示该类对象中的&lt;code&gt;实例数据整体&lt;/code&gt;需要独占缓存行。不能与其他实例数据共享缓存行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;@Contended标注在类中的字段上表示该字段需要独占缓存行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;除此之外@Contended还提供了分组的概念，注解中的value属性表示&lt;code&gt;contention group &lt;/code&gt;。属于统一分组下的变量，它们在内存中是连续存放的，可以允许共享缓存行。不同分组之间不允许共享缓存行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们来分别看下@Contended注解在这三种使用场景下是怎样影响字段之间的排列的。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;@Contended标注在类上&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Contended&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FalseSharding&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; a;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; b;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; c;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; d;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当@Contended标注在FalseSharding示例类上时，表示FalseSharding示例对象中的&lt;code&gt;整个实例数据区&lt;/code&gt;需要独占缓存行，不能与其他对象或者变量共享缓存行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种情况下的内存布局：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1870967741935484&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rwE6v9iaC7nRQBSTl61ibVbibmqCUHkVrex4zbnwLMrzbJiblBuuKoUuk3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图中所示，FalseSharding示例类被标注了@Contended之后，JVM会在FalseSharding示例对象的实例数据区前后填充&lt;code&gt;128个字节&lt;/code&gt;，保证实例数据区内的字段之间内存是连续的，并且保证整个实例数据区独占缓存行，不会与实例数据区之外的数据共享缓存行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;细心的朋友可能已经发现了问题，我们之前不是提到缓存行的大小为64字节吗？为什么这里会填充128字节呢&lt;/strong&gt;？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且之前介绍的手动填充也是填充的&lt;code&gt;64字节&lt;/code&gt;，为什么@Contended注解会采用&lt;code&gt;两倍&lt;/code&gt;的缓存行大小来填充呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实这里的原因有两个：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;首先第一个原因，我们之前也已经提到过了，目前大部分主流的CPU缓存行是64字节，但是也有部分CPU缓存行是32字节或者128字节，如果只填充64字节的话，在缓存行大小为32字节和64字节的CPU中是可以做到独占缓存行从而避免FalseSharding的，但在缓存行大小为&lt;code&gt;128字节&lt;/code&gt;的CPU中还是会出现FalseSharding问题，这里Java采用了悲观的一种做法，默认都是填充&lt;code&gt;128字节&lt;/code&gt;，虽然对于大部分情况下比较浪费，但是屏蔽了底层硬件的差异。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;不过@Contended注解填充字节的大小我们可以通过JVM参数&lt;code&gt;-XX:ContendedPaddingWidth&lt;/code&gt;指定，有效值范围&lt;code&gt;0 - 8192&lt;/code&gt;，默认为&lt;code&gt;128&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;第二个原因其实是最为核心的一个原因，主要是为了防止CPU Adjacent Sector Prefetch（CPU相邻扇区预取）特性所带来的FalseSharding问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;CPU Adjacent Sector Prefetch：https://www.techarp.com/bios-guide/cpu-adjacent-sector-prefetch/&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;CPU Adjacent Sector Prefetch&lt;/strong&gt;是Intel处理器特有的BIOS功能特性，默认是enabled。主要作用就是利用&lt;code&gt;程序局部性原理&lt;/code&gt;，当CPU从内存中请求数据，并读取当前请求数据所在缓存行时，&lt;code&gt;会进一步预取&lt;/code&gt;与当前缓存行相邻的下一个缓存行，这样当我们的程序在顺序处理数据时，会提高CPU处理效率。&lt;strong&gt;这一点也体现了程序局部性原理中的空间局部性特征&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当CPU Adjacent Sector Prefetch特性被disabled禁用时，CPU就只会获取当前请求数据所在的缓存行，不会预取下一个缓存行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在当&lt;code&gt;CPU Adjacent Sector Prefetch&lt;/code&gt;启用（enabled）的时候，CPU其实同时处理的是两个缓存行，在这种情况下，就需要填充两倍缓存行大小（128字节）来避免CPU Adjacent Sector Prefetch所带来的的FalseSharding问题。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;@Contended标注在字段上&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FalseSharding&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Contended&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; a;&lt;br/&gt;    &lt;span&gt;@Contended&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; b;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; c;&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; d;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20806451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rYjQZSvYydAafvXRFNYjiciax54q8PDibqKWRPZH4ZCTksjmkAurvXd7sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次我们将 @Contended注解标注在了FalseSharding示例类中的字段a和字段b上，这样带来的效果是字段a和字段b各自独占缓存行。从内存布局上看，字段a和字段b前后分别被填充了128个字节，来确保字段a和字段b不与任何数据共享缓存行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而没有被@Contended注解标注字段c和字段d则在内存中连续存储，可以共享缓存行。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;@Contended分组&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FalseSharding&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Contended&lt;/span&gt;(&lt;span&gt;&quot;group1&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; a;&lt;br/&gt;    &lt;span&gt;@Contended&lt;/span&gt;(&lt;span&gt;&quot;group1&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; b;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Contended&lt;/span&gt;(&lt;span&gt;&quot;group2&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;  c;&lt;br/&gt;    &lt;span&gt;@Contended&lt;/span&gt;(&lt;span&gt;&quot;group2&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; d;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20967741935483872&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r31YIiaAib4AemgAaw7rdkMDg478ibd9mt4B70FkK7YvsBEa7Eribqe6Ylg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次我们将字段a与字段b放在同一content group下，字段c与字段d放在另一个content group下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样处在同一分组&lt;code&gt;group1&lt;/code&gt;下的字段a与字段b在内存中是连续存储的，可以共享缓存行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同理处在同一分组group2下的字段c与字段d在内存中也是连续存储的，也允许共享缓存行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;但是分组之间是不能共享缓存行的&lt;/strong&gt;，所以在字段分组的前后各填充&lt;code&gt;128字节&lt;/code&gt;，来保证分组之间的变量不能共享缓存行。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 内存对齐&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过以上内容我们了解到Java对象中的实例数据区字段需要进行内存对齐而导致在JVM中会被重排列以及通过填充缓存行避免false sharding的目的所带来的字节对齐填充。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也了解到内存对齐不仅发生在对象与对象之间，也发生在对象中的字段之间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么在本小节中笔者将为大家介绍什么是内存对齐，在本节的内容开始之前笔者先来抛出两个问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;为什么要进行内存对齐？如果就是头比较铁，就是不内存对齐，会产生什么样的后果？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Java 虚拟机堆中对象的起始地址为什么需要对齐至 &lt;code&gt;8&lt;/code&gt;的倍数？为什么不对齐至4的倍数或16的倍数或32的倍数呢？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;带着这两个问题，下面我们正式开始本节的内容~~~&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1 内存结构&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们平时所称的内存也叫随机访问存储器（random-access memory）也叫RAM。而RAM分为两类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;一类是静态RAM（&lt;code&gt;SRAM&lt;/code&gt;），这类SRAM用于前边介绍的CPU高速缓存L1Cache，L2Cache，L3Cache。其特点是访问速度快，访问速度为&lt;code&gt;1 - 30个&lt;/code&gt;时钟周期，但是容量小，造价高。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;另一类则是动态RAM(&lt;code&gt;DRAM&lt;/code&gt;)，这类DRAM用于我们常说的主存上，其特点的是访问速度慢（相对高速缓存），访问速度为&lt;code&gt;50 - 200个&lt;/code&gt;时钟周期，但是容量大，造价便宜些（相对高速缓存）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存由一个一个的存储器模块（memory module）组成，它们插在主板的扩展槽上。常见的存储器模块通常以&lt;strong&gt;64位为单位（8个字节）&lt;/strong&gt;传输数据到存储控制器上或者从存储控制器传出数据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42318840579710143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rnrSgvb85ibv3U8g3LG5F8RVIA7kRicdROicicYCcnrISY4QFwhgakZhib0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;345&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图所示内存条上黑色的元器件就是存储器模块（memory module）。多个存储器模块连接到存储控制器上，就聚合成了主存。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.582258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rHJU9YqekfN52K1HLNncfs3WqVP9hde7eVPeat9VIddbGgEn7nLyZ6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;内存结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而前边介绍到的&lt;code&gt;DRAM芯片&lt;/code&gt;就包装在存储器模块中，每个存储器模块中包含&lt;code&gt;8个DRAM芯片&lt;/code&gt;，依次编号为&lt;code&gt;0 - 7&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5225806451612903&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rB3u6R4hGOFJRfKU90sxBFYVaR2ia3YBMKsXxxPkRXAibueRUZOZkM0zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;存储器模块.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而每一个&lt;code&gt;DRAM芯片&lt;/code&gt;的存储结构是一个二维矩阵，二维矩阵中存储的元素我们称为超单元（&lt;code&gt;supercell&lt;/code&gt;），每个supercell大小为一个字节（&lt;code&gt;8 bit&lt;/code&gt;）。每个supercell都由一个坐标地址（i，j）。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;i表示二维矩阵中的行地址，在计算机中行地址称为RAS(row access strobe，行访问选通脉冲)。j表示二维矩阵中的列地址，在计算机中列地址称为CAS(column access strobe,列访问选通脉冲)。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图中的supercell的RAS = 2，CAS = 2。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4161290322580645&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rTpkjjIriaZlz2u5aBwkVibNANtyB4fF4X9NxbbUuuCLmwtAeAoY1LsibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;DRAM结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;DRAM芯片&lt;/code&gt;中的信息通过引脚流入流出DRAM芯片。每个引脚携带&lt;code&gt;1 bit&lt;/code&gt;的信号。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图中DRAM芯片包含了两个地址引脚(&lt;code&gt;addr&lt;/code&gt;)，因为我们要通过RAS，CAS来定位要获取的&lt;code&gt;supercell&lt;/code&gt;。还有8个数据引脚（&lt;code&gt;data&lt;/code&gt;）,&lt;strong&gt;因为DRAM芯片的IO单位为一个字节（8 bit）&lt;/strong&gt;,所以需要8个data引脚从DRAM芯片传入传出数据。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意这里只是为了解释地址引脚和数据引脚的概念，实际硬件中的引脚数量是不一定的。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 DRAM芯片的访问&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们现在就以读取上图中坐标地址为（2，2）的supercell为例，来说明访问DRAM芯片的过程。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6290322580645161&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r7jkYERTnvHcJ8wQkly8dUiba6vorz5ziaEibDOA22B7QySuibElTW2o2pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;DRAM芯片访问.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;首先存储控制器将行地址&lt;code&gt;RAS = 2&lt;/code&gt;通过地址引脚发送给&lt;code&gt;DRAM芯片&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DRAM芯片根据&lt;code&gt;RAS = 2&lt;/code&gt;将二维矩阵中的第二行的全部内容拷贝到&lt;code&gt;内部行缓冲区&lt;/code&gt;中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;接下来存储控制器会通过地址引脚发送&lt;code&gt;CAS = 2&lt;/code&gt;到DRAM芯片中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DRAM芯片从内部行缓冲区中根据&lt;code&gt;CAS = 2&lt;/code&gt;拷贝出第二列的supercell并通过数据引脚发送给存储控制器。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;DRAM芯片的IO单位为一个supercell，也就是一个字节(8 bit)。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3 CPU如何读写主存&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边我们介绍了内存的物理结构，以及如何访问内存中的DRAM芯片获取supercell中存储的数据（&lt;code&gt;一个字节&lt;/code&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本小节我们来介绍下CPU是如何访问内存的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4443548387096774&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rBuTZIXQof8eoW6ibAYpcULFoibX0dKoES48Y3vG39BQibhEfbPtIuvMdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;CPU与内存之间的总线结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中关于CPU芯片的内部结构我们在介绍false sharding的时候已经详细的介绍过了，这里我们主要聚焦在CPU与内存之间的总线架构上。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.1 总线结构&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU与内存之间的数据交互是通过总线（bus）完成的，而数据在总线上的传送是通过一系列的步骤完成的，这些步骤称为总线事务（bus transaction）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中数据从内存传送到CPU称之为&lt;code&gt;读事务（read transaction）&lt;/code&gt;，数据从CPU传送到内存称之为&lt;code&gt;写事务（write transaction）&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总线上传输的信号包括：地址信号，数据信号，控制信号。其中控制总线上传输的控制信号可以同步事务，并能够标识出当前正在被执行的事务信息：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当前这个事务是到内存的？还是到磁盘的？或者是到其他IO设备的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这个事务是读还是写？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;总线上传输的地址信号（&lt;code&gt;内存地址&lt;/code&gt;），还是数据信号（&lt;code&gt;数据&lt;/code&gt;）？。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;还记得我们前边讲到的MESI缓存一致性协议吗？当core0修改字段a的值时，其他CPU核心会在总线上&lt;code&gt;嗅探&lt;/code&gt;字段a的内存地址，如果嗅探到总线上出现字段a的内存地址，说明有人在修改字段a，这样其他CPU核心就会&lt;code&gt;失效&lt;/code&gt;自己缓存字段a所在的&lt;code&gt;cache line&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图所示，其中系统总线是连接CPU与IO bridge的，存储总线是来连接IO bridge和主存的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;IO bridge&lt;/code&gt;负责将系统总线上的电子信号转换成存储总线上的电子信号。IO bridge也会将系统总线和存储总线连接到IO总线（磁盘等IO设备）上。这里我们看到IO bridge其实起的作用就是转换不同总线上的电子信号。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.2 CPU从内存读取数据过程&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设CPU现在要将内存地址为&lt;code&gt;A&lt;/code&gt;的内容加载到寄存器中进行运算。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4596774193548387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rN11lLbPfeAJzGCk3REBStPEKsvn2pemCqM0ib5C8OKcnNp9IicOq0toA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;CPU读取内存.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先CPU芯片中的&lt;code&gt;总线接口&lt;/code&gt;会在总线上发起读事务（&lt;code&gt;read transaction&lt;/code&gt;）。该读事务分为以下步骤进行：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CPU将内存地址A放到系统总线上。随后&lt;code&gt;IO bridge&lt;/code&gt;将信号传递到存储总线上。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;主存感受到存储总线上的&lt;code&gt;地址信号&lt;/code&gt;并通过存储控制器将存储总线上的内存地址A读取出来。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储控制器通过内存地址A定位到具体的存储器模块，从&lt;code&gt;DRAM芯片&lt;/code&gt;中取出内存地址A对应的&lt;code&gt;数据X&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储控制器将读取到的&lt;code&gt;数据X&lt;/code&gt;放到存储总线上，随后IO bridge将&lt;code&gt;存储总线&lt;/code&gt;上的数据信号转换为&lt;code&gt;系统总线&lt;/code&gt;上的数据信号，然后继续沿着系统总线传递。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CPU芯片感受到系统总线上的数据信号，将数据从系统总线上读取出来并拷贝到寄存器中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是CPU读取内存数据到寄存器中的完整过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是其中还涉及到一个重要的过程，这里我们还是需要摊开来介绍一下，那就是存储控制器如何通过&lt;code&gt;内存地址A&lt;/code&gt;从主存中读取出对应的&lt;code&gt;数据X&lt;/code&gt;的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们结合前边介绍的内存结构以及从DRAM芯片读取数据的过程，来总体介绍下如何从主存中读取数据。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.3 如何根据内存地址从主存中读取数据&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边介绍到，当主存中的存储控制器感受到了存储总线上的&lt;code&gt;地址信号&lt;/code&gt;时，会将内存地址从存储总线上读取出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随后会通过内存地址定位到具体的存储器模块。还记得内存结构中的存储器模块吗？？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.582258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rHJU9YqekfN52K1HLNncfs3WqVP9hde7eVPeat9VIddbGgEn7nLyZ6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;内存结构.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而每个存储器模块中包含了8个DRAM芯片，编号从&lt;code&gt;0 - 7&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5225806451612903&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rB3u6R4hGOFJRfKU90sxBFYVaR2ia3YBMKsXxxPkRXAibueRUZOZkM0zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;存储器模块.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;存储控制器会将内存地址转换为DRAM芯片中supercell在二维矩阵中的坐标地址(&lt;code&gt;RAS&lt;/code&gt;，&lt;code&gt;CAS&lt;/code&gt;)。并将这个坐标地址发送给对应的存储器模块。随后存储器模块会将&lt;code&gt;RAS&lt;/code&gt;和&lt;code&gt;CAS&lt;/code&gt;广播到存储器模块中的所有&lt;code&gt;DRAM芯片&lt;/code&gt;。依次通过(&lt;code&gt;RAS&lt;/code&gt;，&lt;code&gt;CAS&lt;/code&gt;)从DRAM0到DRAM7读取到相应的supercell。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6290322580645161&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3r7jkYERTnvHcJ8wQkly8dUiba6vorz5ziaEibDOA22B7QySuibElTW2o2pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;DRAM芯片访问.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道一个supercell存储了&lt;code&gt;8 bit&lt;/code&gt;数据，这里我们从DRAM0到DRAM7
依次读取到了8个supercell也就是&lt;code&gt;8个字节&lt;/code&gt;，然后将这8个字节返回给存储控制器，由存储控制器将数据放到存储总线上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;CPU总是以word size为单位从内存中读取数据，在64位处理器中的word size为8个字节。64位的内存也只能每次吞吐8个字节。&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;CPU每次会向内存读写一个&lt;code&gt;cache line&lt;/code&gt;大小的数据（&lt;code&gt;64个字节&lt;/code&gt;），但是内存一次只能吞吐&lt;code&gt;8个字节&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在内存地址对应的存储器模块中，&lt;code&gt;DRAM0芯片&lt;/code&gt;存储第一个低位字节（supercell），&lt;code&gt;DRAM1芯片&lt;/code&gt;存储第二个字节，......依次类推&lt;code&gt;DRAM7芯片&lt;/code&gt;存储最后一个高位字节。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;内存一次读取和写入的单位是8个字节。而且在程序员眼里连续的内存地址实际上在物理上是不连续的&lt;/strong&gt;。因为这连续的&lt;code&gt;8个字节&lt;/code&gt;其实是存储于不同的&lt;code&gt;DRAM芯片&lt;/code&gt;上的。每个DRAM芯片存储一个字节（supercell）。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6540322580645161&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rxuq3wSWAjzItUEATFbumn4CQ3nngGbG9ibK9ymH6xUCFiaicMicPzvBicMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;读取存储器模块数据.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3.4 CPU向内存写入数据过程&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们现在假设CPU要将寄存器中的数据X写到内存地址A中。同样的道理，CPU芯片中的总线接口会向总线发起写事务（&lt;code&gt;write transaction&lt;/code&gt;）。写事务步骤如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CPU将要写入的内存地址A放入系统总线上。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;通过&lt;code&gt;IO bridge&lt;/code&gt;的信号转换，将内存地址A传递到存储总线上。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储控制器感受到存储总线上的地址信号，将内存地址A从存储总线上读取出来，并等待数据的到达。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CPU将寄存器中的数据拷贝到系统总线上，通过&lt;code&gt;IO bridge&lt;/code&gt;的信号转换，将数据传递到存储总线上。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储控制器感受到存储总线上的数据信号，将数据从存储总线上读取出来。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;存储控制器通过内存地址A定位到具体的存储器模块，最后将数据写入存储器模块中的8个DRAM芯片中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 为什么要内存对齐&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在了解了内存结构以及CPU读写内存的过程之后，现在我们回过头来讨论下本小节开头的问题：为什么要内存对齐？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面笔者从三个方面来介绍下要进行内存对齐的原因：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;速度&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU读取数据的单位是根据&lt;code&gt;word size&lt;/code&gt;来的，在64位处理器中&lt;code&gt;word size = 8字节&lt;/code&gt;，所以CPU向内存读写数据的单位为&lt;code&gt;8字节&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在64位内存中，内存IO单位为&lt;code&gt;8个字节&lt;/code&gt;，我们前边也提到内存结构中的存储器模块通常以64位为单位（8个字节）传输数据到存储控制器上或者从存储控制器传出数据。因为每次内存IO读取数据都是从数据所在具体的存储器模块中包含的这8个DRAM芯片中以相同的(&lt;code&gt;RAM&lt;/code&gt;,&lt;code&gt;CAS&lt;/code&gt;)依次读取一个字节，然后在存储控制器中聚合成&lt;code&gt;8个字节&lt;/code&gt;返回给CPU。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6540322580645161&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rxuq3wSWAjzItUEATFbumn4CQ3nngGbG9ibK9ymH6xUCFiaicMicPzvBicMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;读取存储器模块数据.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;由于存储器模块中这种由8个DRAM芯片组成的物理存储结构的限制，内存读取数据只能是按照地址顺序8个字节的依次读取----8个字节8个字节地来读取数据。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4685483870967742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3ribMl20O9znTgEfP42FRNnCSg4ELsbIIU6r0se5xGJs9cHfLeqWUqibyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;内存IO单位.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;假设我们现在读取&lt;code&gt;0x0000 - 0x0007&lt;/code&gt;这段连续内存地址上的8个字节。由于内存读取是按照&lt;code&gt;8个字节&lt;/code&gt;为单位依次顺序读取的，&lt;strong&gt;而我们要读取的这段内存地址的起始地址是0（8的倍数）&lt;/strong&gt;，所以0x0000 - 0x0007中每个地址的坐标都是相同的（&lt;code&gt;RAS&lt;/code&gt;,&lt;code&gt;CAS&lt;/code&gt;）。所以他可以在8个DRAM芯片中通过相同的（&lt;code&gt;RAS&lt;/code&gt;,&lt;code&gt;CAS&lt;/code&gt;）一次性读取出来。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果我们现在读取&lt;code&gt;0x0008 - 0x0015&lt;/code&gt;这段连续内存上的8个字节也是一样的，&lt;strong&gt;因为内存段起始地址为8（8的倍数）&lt;/strong&gt;，所以这段内存上的每个内存地址在DREAM芯片中的坐标地址（&lt;code&gt;RAS&lt;/code&gt;,&lt;code&gt;CAS&lt;/code&gt;）也是相同的，我们也可以一次性读取出来。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意：&lt;code&gt;0x0000 - 0x0007&lt;/code&gt;内存段中的坐标地址（RAS,CAS）与&lt;code&gt;0x0008 - 0x0015&lt;/code&gt;内存段中的坐标地址（RAS,CAS）是不相同的。&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;但如果我们现在读取&lt;code&gt;0x0007 - 0x0014&lt;/code&gt;这段连续内存上的8个字节情况就不一样了，由于起始地址&lt;code&gt;0x0007&lt;/code&gt;在DRAM芯片中的（RAS,CAS）与后边地址&lt;code&gt;0x0008 - 0x0014&lt;/code&gt;的（RAS,CAS）不相同，所以CPU只能先从&lt;code&gt;0x0000 - 0x0007&lt;/code&gt;读取8个字节出来先放入&lt;code&gt;结果寄存器&lt;/code&gt;中并左移7个字节（目的是只获取&lt;code&gt;0x0007&lt;/code&gt;），然后CPU在从&lt;code&gt;0x0008 - 0x0015&lt;/code&gt;读取8个字节出来放入临时寄存器中并右移1个字节（目的是获取&lt;code&gt;0x0008 - 0x0014&lt;/code&gt;）最后与结果寄存器&lt;code&gt;或运算&lt;/code&gt;。最终得到&lt;code&gt;0x0007 - 0x0014&lt;/code&gt;地址段上的8个字节。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从以上分析过程来看，当CPU访问内存对齐的地址时，比如&lt;code&gt;0x0000&lt;/code&gt;和&lt;code&gt;0x0008&lt;/code&gt;这两个起始地址都是对齐至&lt;code&gt;8的倍数&lt;/code&gt;。CPU可以通过一次read transaction读取出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是当CPU访问内存没有对齐的地址时，比如&lt;code&gt;0x0007&lt;/code&gt;这个起始地址就没有对齐至&lt;code&gt;8的倍数&lt;/code&gt;。CPU就需要两次read transaction才能将数据读取出来。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;还记得笔者在小节开头提出的问题吗  ？&quot;Java 虚拟机堆中对象的&lt;code&gt;起始地址&lt;/code&gt;为什么需要对齐至 &lt;code&gt;8的倍数&lt;/code&gt;？为什么不对齐至4的倍数或16的倍数或32的倍数呢？&quot;
现在你能回答了吗？？？&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;原子性&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU可以原子地操作一个对齐的word size memory。64位处理器中&lt;code&gt;word size = 8字节&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;尽量分配在一个缓存行中&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边在介绍&lt;code&gt;false sharding&lt;/code&gt;的时候我们提到目前主流处理器中的&lt;code&gt;cache line&lt;/code&gt;大小为&lt;code&gt;64字节&lt;/code&gt;，堆中对象的起始地址通过内存对齐至&lt;code&gt;8的倍数&lt;/code&gt;，可以让对象尽可能的分配到一个缓存行中。&lt;strong&gt;一个内存起始地址未对齐的对象可能会跨缓存行存储，这样会导致CPU的执行效率慢2倍&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中对象中字段内存对齐的其中一个重要原因也是让字段只出现在同一 CPU 的缓存行中。如果字段不是对齐的，那么就有可能出现跨缓存行的字段。也就是说，该字段的读取可能需要替换两个缓存行，而该字段的存储也会同时污染两个缓存行。这两种情况对程序的执行效率而言都是不利的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外在《2. 字段重排列》这一小节介绍的三种字段对齐规则，&lt;strong&gt;是保证在字段内存对齐的基础上使得实例数据区占用内存尽可能的小&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. 压缩指针&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在介绍完关于内存对齐的相关内容之后，我们来介绍下前边经常提到的压缩指针。可以通过JVM参数&lt;code&gt;XX:+UseCompressedOops&lt;/code&gt;开启，当然默认是开启的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本小节内容开启之前，我们先来讨论一个问题，&lt;strong&gt;那就是为什么要使用压缩指针？？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们现在正在准备将32位系统切换到64位系统，起初我们可能会期望系统性能会立马得到提升，但现实情况可能并不是这样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JVM中导致性能下降的最主要原因就是64位系统中的&lt;code&gt;对象引用&lt;/code&gt;。在前边我们也提到过，64位系统中对象的引用以及类型指针占用&lt;code&gt;64 bit&lt;/code&gt;也就是8个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就导致了在64位系统中的对象引用占用的内存空间是32位系统中的两倍大小，因此间接的导致了在64位系统中更多的内存消耗以及更频繁的GC发生，GC占用的CPU时间越多，那么我们的应用程序占用CPU的时间就越少。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外一个就是对象的引用变大了，那么CPU可缓存的对象相对就少了，增加了对内存的访问。综合以上几点从而导致了系统性能的下降。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从另一方面来说，在64位系统中内存的寻址空间为&lt;code&gt;2^48 = 256T&lt;/code&gt;，在现实情况中我们真的需要这么大的寻址空间吗？？好像也没必要吧~~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;于是我们就有了新的想法：那么我们是否应该切换回32位系统呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们切换回32位系统，我们怎么解决在32位系统中拥有超过&lt;code&gt;4G&lt;/code&gt;的内存寻址空间呢？因为现在4G的内存大小对于现在的应用来说明显是不够的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我想以上的这些问题，也是当初JVM的开发者需要面对和解决的，当然他们也交出了非常完美的答卷，那就是&lt;strong&gt;使用压缩指针可以在64位系统中利用32位的对象引用获得超过4G的内存寻址空间&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.1 压缩指针是如何做到的呢？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还记得之前我们在介绍对齐填充和内存对齐小节中提到的，在Java虚拟机堆中对象的起始地址必须对齐至&lt;code&gt;8的倍数&lt;/code&gt;吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于堆中对象的起始地址均是对齐至8的倍数，所以对象引用在开启压缩指针情况下的32位二进制的后三位始终是&lt;code&gt;0&lt;/code&gt;（因为它们始终可以被8整除）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然JVM已经知道了这些对象的内存地址后三位始终是0，那么这些无意义的0就没必要在堆中继续存储。相反，我们可以利用存储0的这3位bit存储一些有意义的信息，这样我们就多出&lt;code&gt;3位bit&lt;/code&gt;的寻址空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样在存储的时候，JVM还是按照32位来存储，只不过后三位原本用来存储0的bit现在被我们用来存放有意义的地址空间信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当寻址的时候，JVM将这32位的对象引用&lt;code&gt;左移3位&lt;/code&gt;（后三位补0）。这就导致了在开启压缩指针的情况下，我们原本32位的内存寻址空间一下变成了&lt;code&gt;35位&lt;/code&gt;。可寻址的内存空间变为2^32 * 2^3 = 32G。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3604838709677419&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rV5yqCxeLpAbBDYhzdviaBKhfRic98w2ZC93tRwyBMHgg0Ku4iaQdjUicTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;压缩指针.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这样一来，JVM虽然额外的执行了一些位运算但是极大的提高了寻址空间，并且将对象引用占用内存大小降低了一半，节省了大量空间。况且这些位运算对于CPU来说是非常容易且轻量的操作&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过压缩指针的原理我挖掘到了&lt;strong&gt;内存对齐的另一个重要原因&lt;/strong&gt;就是通过内存对齐至&lt;code&gt;8的倍数&lt;/code&gt;，我们可以在64位系统中使用压缩指针通过32位的对象引用将寻址空间提升至&lt;code&gt;32G&lt;/code&gt;.&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;从Java7开始，当maximum heap size小于32G的时候，压缩指针是默认开启的。但是当maximum heap size大于32G的时候，压缩指针就会关闭。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那么我们如何在压缩指针开启的情况下进一步扩大寻址空间呢？？？&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;7.2 如何进一步扩大寻址空间&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边提到我们在Java虚拟机堆中对象起始地址均需要对其至&lt;code&gt;8的倍数&lt;/code&gt;，不过这个数值我们可以通过JVM参数&lt;code&gt;-XX:ObjectAlignmentInBytes &lt;/code&gt;来改变（默认值为8）。当然这个数值的必须是2的次幂，数值范围需要在&lt;code&gt;8 - 256之间&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正是因为对象地址对齐至8的倍数，才会多出3位bit让我们存储额外的地址信息，进而将4G的寻址空间提升至32G。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的道理，如果我们将&lt;code&gt;ObjectAlignmentInBytes&lt;/code&gt;的数值设置为16呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对象地址均对齐至16的倍数，那么就会多出4位bit让我们存储额外的地址信息。寻址空间变为2^32 * 2^4 = 64G。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过以上规律，我们就能知道，在64位系统中开启压缩指针的情况，寻址范围的计算公式：&lt;code&gt;4G * ObjectAlignmentInBytes = 寻址范围&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是笔者并不建议大家贸然这样做，因为增大了&lt;code&gt;ObjectAlignmentInBytes&lt;/code&gt;虽然能扩大寻址范围，但是这同时也可能增加了对象之间的字节填充，导致压缩指针没有达到原本节省空间的效果。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8. 数组对象的内存布局&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前边大量的篇幅我们都是在讨论Java普通对象在内存中的布局情况，最后这一小节我们再来说下Java中的数组对象在内存中是如何布局的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.1 基本类型数组的内存布局&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6774193548387096&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rpzq9LdqXNnfBciatEr9eg01iaTDSTZ4vJNqPBDqKeoXOdLryulBJPPzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;基本类型数组内存布局.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图表示的是基本类型数组在内存中的布局，基本类型数组在JVM中用&lt;code&gt;typeArrayOop&lt;/code&gt;结构体表示，基本类型数组类型元信息用&lt;code&gt;TypeArrayKlass &lt;/code&gt;结构体表示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数组的内存布局大体上和普通对象的内存布局差不多，唯一不同的是在数组类型对象头中多出了&lt;code&gt;4个字节&lt;/code&gt;用来表示数组长度的部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是分别以开启指针压缩和关闭指针压缩两种情况，通过下面的例子来进行说明：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;long&lt;/span&gt;[] longArrayLayout = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;[&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;开启指针压缩 -XX:+UseCompressedOops&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.12016129032258065&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rXQQicaytwdQoSvqrB3XCyoK1odU5kU3pqUFASKOyS4n6kdPgs7nIsGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到红框部分即为数组类型对象头中多出来一个&lt;code&gt;4字节&lt;/code&gt;大小用来表示数组长度的部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为我们示例中的long型数组只有一个元素，所以实例数据区的大小只有8字节。如果我们示例中的long型数组变为两个元素，那么实例数据区的大小就会变为16字节，以此类推................。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;关闭指针压缩  -XX:-UseCompressedOops&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.14919354838709678&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rrKkFvaCtPYvpI7x4FYk4eibF6d4NnXuGr365gsJ7WXXSVXWusuykxUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当关闭了指针压缩时，对象头中的MarkWord还是占用8个字节，但是类型指针从4个字节变为了8个字节。数组长度属性还是不变保持4个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们发现是实例数据区与对象头之间发生了对齐填充。大家还记得这是为什么吗？？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们前边在字段重排列小节介绍了三种字段排列规则在这里继续适用：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;规则1&lt;/code&gt;：如果一个字段占用&lt;code&gt;X&lt;/code&gt;个字节，那么这个字段的偏移量OFFSET需要对齐至&lt;code&gt;NX&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;规则2&lt;/code&gt;：在开启了压缩指针的64位JVM中，Java类中的第一个字段的OFFSET需要对齐至&lt;code&gt;4N&lt;/code&gt;，在关闭压缩指针的情况下类中第一个字段的OFFSET需要对齐至&lt;code&gt;8N&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里基本数组类型的实例数据区中是long型，在关闭指针压缩的情况下，根据规则1和规则2需要对齐至8的倍数，所以要在其与对象头之间填充4个字节，达到内存对齐的目的，起始地址变为&lt;code&gt;24&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;8.2 引用类型数组的内存布局&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6774193548387096&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rJsDCu7IWm5Lp5iaW2XTDpfRfQq8Fhuf4wGqPcgc2d7agzX7VGZhNxkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;引用类型数组的内存布局.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图表示的是引用类型数组在内存中的布局，引用类型数组在JVM中用&lt;code&gt;objArrayOop&lt;/code&gt;结构体表示，基本类型数组类型元信息用&lt;code&gt;ObjArrayKlass &lt;/code&gt;结构体表示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样在引用类型数组的对象头中也会有一个&lt;code&gt;4字节&lt;/code&gt;大小用来表示数组长度的部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是分别以开启指针压缩和关闭指针压缩两种情况，通过下面的例子来进行说明：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ReferenceArrayLayout&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt; a;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; b;&lt;br/&gt;    &lt;span&gt;short&lt;/span&gt; c;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;ReferenceArrayLayout[] referenceArrayLayout = &lt;span&gt;new&lt;/span&gt; ReferenceArrayLayout[&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;开启指针压缩 -XX:+UseCompressedOops&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1782258064516129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rI0EhfK0wH5ZBVhiaeHn6PNB7xIhtpjgIEbGw5yWHstINGM9brJqh2KQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引用数组类型内存布局与基础数组类型内存布局最大的不同在于它们的实例数据区。由于开启了压缩指针，所以对象引用占用内存大小为&lt;code&gt;4个字节&lt;/code&gt;，而我们示例中引用数组只包含一个引用元素，所以这里实例数据区中只有4个字节。相同的到道理，如果示例中的引用数组包含的元素变为两个引用元素，那么实例数据区就会变为8个字节，以此类推......。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后由于Java对象需要内存对齐至&lt;code&gt;8的倍数&lt;/code&gt;，所以在该引用数组的实例数据区后填充了4个字节。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;关闭指针压缩 -XX:-UseCompressedOops&lt;span/&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.16129032258064516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sOIZXFW0vUasjCUT8CJJQKVjdmjn0f3rqryHvFaRNvVKp50Hb27F97WroKVW73r2sHr1gxTWHT5bU5WBn8LrKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当关闭压缩指针时，对象引用占用内存大小变为了&lt;code&gt;8个字节&lt;/code&gt;，所以引用数组类型的实例数据区占用了8个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据字段重排列规则2，在引用数组类型对象头与实例数据区中间需要填充&lt;code&gt;4个字节&lt;/code&gt;以保证内存对齐的目的。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文笔者详细介绍了Java普通对象以及数组类型对象的内存布局，以及相关对象占用内存大小的计算方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以及在对象内存布局中的实例数据区字段重排列的三个重要规则。以及后边由字节的对齐填充引出来的false sharding问题，还有Java8为了解决false sharding而引入的@Contented注解的原理及使用方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了讲清楚内存对齐的底层原理，笔者还花了大量的篇幅讲解了内存的物理结构以及CPU读写内存的完整过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后又由内存对齐引出了压缩指针的工作原理。由此我们知道进行内存对齐的四个原因：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;CPU访问性能&lt;/code&gt;：当CPU访问内存对齐的地址时，可以通过一个read transaction读取一个字长（word size）大小的数据出来。否则就需要两个read transaction。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;原子性&lt;/code&gt;：CPU可以原子地操作一个对齐的word size memory。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;尽可能利用CPU缓存&lt;/code&gt;：内存对齐可以使对象或者字段尽可能的被分配到一个缓存行中，避免跨缓存行存储，导致CPU执行效率减半。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;提升压缩指针的内存寻址空间：&lt;/code&gt; 对象与对象之间的内存对齐，可以使我们在64位系统中利用32位对象引用将内存寻址空间提升至32G。既降低了对象引用的内存占用，又提升了内存寻址空间。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本文中我们顺带还介绍了和内存布局相关的几个JVM参数：-XX:+UseCompressedOops&lt;code&gt;,&lt;/code&gt; -XX +CompactFields &lt;code&gt;,&lt;/code&gt;-XX:-RestrictContended &lt;code&gt;,&lt;/code&gt;-XX:ContendedPaddingWidth&lt;code&gt;,&lt;/code&gt; -XX:ObjectAlignmentInBytes。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后感谢大家能看到这里，我们下篇文章再见~~~&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>210fe423e90540233ba5ca602a9aa026</guid>
<title>京东开源的轻量级移动端 Vue2、Vue3 组件库</title>
<link>https://toutiao.io/k/8rp1seo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0372cd541cbc6e5d67477d66177d3cbd</guid>
<title>2022年最值得关注的Chrome浏览器扩展插件</title>
<link>https://toutiao.io/k/lz60fko</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry&quot;&gt;
      
        &lt;p&gt;浏览器扩展，国内很多人说成浏览器插件，可以帮我们完成很多工作，比如剪辑、收藏、稍后阅读、英语翻译、屏幕截屏、收藏夹管理、广告拦截、初始Tab页等等，而用好一个扩展可以大大的提升效率！&lt;/p&gt;
&lt;p&gt;2022年又有哪些值得关注的有意思的扩展呢？我整理了10个最值得关注的浏览器扩展，这些扩展插件都有很多用户使用，用户评价也非常高，下面就一起来了解下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24egy1h06umtbttgj20zk0hrmyf.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;/&gt;
&lt;p&gt;1、Mote: 语音笔记&lt;/p&gt;
&lt;p&gt;2、Forest : 保持专注，构建你的专属森林&lt;/p&gt;
&lt;p&gt;3、Volume Master : 最简单，最可靠的音量增强器&lt;/p&gt;
&lt;p&gt;4、Homey : 高效而舒适的起始页&lt;/p&gt;
&lt;p&gt;5、Web Maker : 一个快速、可离线使用的网页端开发环境终端&lt;/p&gt;
&lt;p&gt;6、Awesome Screenshot : 超级截图录屏大师&lt;/p&gt;
&lt;p&gt;7、Find website used fonts : 找到并列出网页上使用的所有字体&lt;/p&gt;
&lt;p&gt;8、eJOY English : 看视频学英语&lt;/p&gt;
&lt;p&gt;9、Omni : 书签、历史 &amp;amp; Tab 管理，一体化浏览器效率工具&lt;/p&gt;
&lt;p&gt;10、Feedly Mini : 将浏览内容快速添加到Feedly网站&lt;/p&gt;
&lt;h2 id=&quot;1、Mote-语音笔记&quot;&gt;&lt;a href=&quot;#1、Mote-语音笔记&quot; class=&quot;headerlink&quot; title=&quot;1、Mote: 语音笔记&quot;/&gt;1、Mote: 语音笔记&lt;/h2&gt;&lt;p&gt;使用Mote可以轻松地将语音评论和音频内容添加到共享的文档、电子邮件和表单。&lt;/p&gt;
&lt;p&gt;只需要点击Chrome扩展菜单-浏览器图标访问Mote，就可以方便快捷的录制音频，并将音频上传到云存储或者使用到当前页面里。&lt;/p&gt;
&lt;p&gt;也可以将语音快速转换成文本形式，输入效率提升3X。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24egy1h06umwk1gyj20k80qc0ub.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/mote-voice-notes-feedback/ajphlblkfpppdpkgokiejbjfohfohhmk&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Mote 扩展地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;2、Forest-保持专注，构建你的专属森林&quot;&gt;&lt;a href=&quot;#2、Forest-保持专注，构建你的专属森林&quot; class=&quot;headerlink&quot; title=&quot;2、Forest : 保持专注，构建你的专属森林&quot;/&gt;2、&lt;strong&gt;Forest : 保持专注，构建你的专属森林&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Forest 利用一个轻松有趣的方式，帮助您远离网络成瘾的干扰。每当你希望有一段专心工作的时间，就可以在 Forest 中种下一颗种籽。在接下来的时间内，这颗种籽将会慢慢地成长为一棵大树。若是禁不起诱惑，在这段时间内去浏览了在你黑名单内列出的网站，充满生机、可爱的小树将会枯萎而死。利用这样游戏化的方式，你将可以更专注于生活与工作中。&lt;/p&gt;
&lt;p&gt;Chrome商店显示有900,000+ 位用户，1000+评价。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24egy1h06umwf4tsj20hs0b4gmk.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/forest-stay-focused-be-pr/kjacjjdnoddnpbbcjilcajfhhbdhkpgk&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Forest 扩展地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;3、Volume-Master-最简单，最可靠的音量增强器&quot;&gt;&lt;a href=&quot;#3、Volume-Master-最简单，最可靠的音量增强器&quot; class=&quot;headerlink&quot; title=&quot;3、Volume Master : 最简单，最可靠的音量增强器&quot;/&gt;3、&lt;strong&gt;Volume Master : 最简单，最可靠的音量增强器&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;一个完全免费，没有广告的小众领域的工具扩展。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;音量提升高达600％&lt;/li&gt;
&lt;li&gt;控制任何标签的音量&lt;/li&gt;
&lt;li&gt;细粒度控制：0％-600％&lt;/li&gt;
&lt;li&gt;一键切换到任何播放音频的标签&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2,000,000+ 位用户，18000+五星评价&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24egy1h06umw862yj20hs0b4my6.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/volume-master/jghecgabfgfdldnmbfkhmffcabddioke&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Volume Master应用商店地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;4、Homey-高效而舒适的起始页&quot;&gt;&lt;a href=&quot;#4、Homey-高效而舒适的起始页&quot; class=&quot;headerlink&quot; title=&quot;4、Homey : 高效而舒适的起始页&quot;/&gt;4、&lt;strong&gt;Homey : 高效而舒适的起始页&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;拥有漂亮的动态壁纸，天气和个人注释之类的小部件，创建易于访问的书签的功能和搜索栏！&lt;/p&gt;
&lt;p&gt;由于日常工作的单调乏味，我们有时会感到无聊，或者有时我们可能缺乏灵感来振作精神，使我们的生活变得有趣。&lt;/p&gt;
&lt;p&gt;40,000+ 位用户，2000+五星评价&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24egy1h06umvyiuyj20tq0ic41i.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://homey-app.online/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Homey 官网&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;5、Web-Maker-一个快速、可离线使用的网页端开发环境终端&quot;&gt;&lt;a href=&quot;#5、Web-Maker-一个快速、可离线使用的网页端开发环境终端&quot; class=&quot;headerlink&quot; title=&quot;5、Web Maker : 一个快速、可离线使用的网页端开发环境终端&quot;/&gt;5、Web Maker : 一个快速、可离线使用的网页端开发环境终端&lt;/h2&gt;&lt;p&gt;无论是Markdown、Jade、SCSS、LESS、Atomic CSS、JSX、CoffeeScript还是TypeScript，你都能得到。&lt;/p&gt;
&lt;p&gt;快速的添加依赖库&lt;/p&gt;
&lt;p&gt;50,000+ 位用户，975五星评价&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24egy1h06umvoep7j20hs0b475e.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/web-maker/lkfkkhfhhdkiemehlpkgjeojomhpccnh&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Web Maker应用商店地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;6、Awesome-Screenshot-超级截图录屏大师&quot;&gt;&lt;a href=&quot;#6、Awesome-Screenshot-超级截图录屏大师&quot; class=&quot;headerlink&quot; title=&quot;6、Awesome Screenshot : 超级截图录屏大师&quot;/&gt;6、&lt;strong&gt;Awesome Screenshot :&lt;/strong&gt; 超级截图录屏大师&lt;/h2&gt;&lt;p&gt;超级截图录屏大师是一款录屏神器，也是一款截屏神器．屏幕截图&amp;amp; 图片编辑，屏幕录像＆视频编辑，所有这些截图，录屏功能，都被一气呵成的集成到插件和对应的网站服务中．&lt;/p&gt;
&lt;p&gt;2,000,000+ 位用户，20000+五星评价&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24egy1h06umvi98gj20hs0b4756.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;屏幕录像功能&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对网页内容进行屏幕录像&lt;/li&gt;
&lt;li&gt;对全桌面进行录屏&lt;/li&gt;
&lt;li&gt;对某一个软件进行录屏&lt;/li&gt;
&lt;li&gt;录摄像头&lt;/li&gt;
&lt;li&gt;支持高清录制&lt;/li&gt;
&lt;li&gt;支持下载为MP4格式&lt;/li&gt;
&lt;li&gt;视频编辑功能(很快发布)&lt;/li&gt;
&lt;li&gt;既可以保存到云端，也可以保存到本地&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24egy1h06umvc8a9j21vu0tqjx9.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/awesome-screenshot-and-sc/nlipoenfbbikpbjkfpfillcgkoblgpmj&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Awesome Screenshot 应用商店地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;7、Find-website-used-fonts-找到并列出网页上使用的所有字体&quot;&gt;&lt;a href=&quot;#7、Find-website-used-fonts-找到并列出网页上使用的所有字体&quot; class=&quot;headerlink&quot; title=&quot;7、Find website used fonts : 找到并列出网页上使用的所有字体&quot;/&gt;7、&lt;strong&gt;Find website used fonts :&lt;/strong&gt; 找到并列出网页上使用的所有字体&lt;/h2&gt;&lt;p&gt;对网站上使用的字体样式感到好奇吗?&lt;/p&gt;
&lt;p&gt;找到网站使用的字体提供了最简单和最容易的方法来识别网站上的字体。只需单击扩展，并找到所有字体在一个网页上使用的列表。&lt;/p&gt;
&lt;p&gt;10,000+ 位用户&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24egy1h06umv10mlj20hs0b40t7.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/find-website-used-fonts/lnebjgioddkafaldaaeooeghlcholnnp&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Find website used fonts 应用商店地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;8、eJOY-English-看视频学英语&quot;&gt;&lt;a href=&quot;#8、eJOY-English-看视频学英语&quot; class=&quot;headerlink&quot; title=&quot;8、eJOY English : 看视频学英语&quot;/&gt;8、&lt;strong&gt;eJOY English : 看视频学英语&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;翻译Netflix、Youtube、iFlix上的字幕，点击就可以在看电影、短片、新闻、浏览社交媒体时获得译文，将新单词存储到单词本，并且以玩英文游戏的方式记牢单词。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24egy1h06umur9mlj20eq0aeq46.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你正在准备英文考试，eJOY会帮你掌握词汇表。eJOY提供包括托福、雅思等的能力检测，eJOY使用最新的算法帮助你记住单词。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24egy1h06umujv9fj20hs0b40tw.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/ejoy-english-learn-with-m/amfojhdiedpdnlijjbhjnhokbnohfdfb&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;eJOY 应用商店地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;9、Omni-书签、历史-amp-Tab-管理，一体化浏览器效率工具&quot;&gt;&lt;a href=&quot;#9、Omni-书签、历史-amp-Tab-管理，一体化浏览器效率工具&quot; class=&quot;headerlink&quot; title=&quot;9、Omni : 书签、历史 &amp;amp; Tab 管理，一体化浏览器效率工具&quot;/&gt;9、&lt;strong&gt;Omni : 书签、历史 &amp;amp; Tab 管理，一体化浏览器效率工具&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;这是一个浏览器插件，在Github上有开源代码。通过一个简单的命令界面，你可以像专业人士一样使用你的浏览器。管理标签，书签，你的浏览器历史，执行各种各样的操作。&lt;br/&gt;Omni 有酷酷的风格，跟Mac上的Alfred操作类似。这是新上线的应用，但是评价是全5星，10000+用户。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24egy1h06umucz7ej20hn0akgly.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://chrome.google.com/webstore/detail/omni-bookmark-history-tab/mapjgeachilmcbbokkgcbgpbakaaeehi&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Omni应用商店地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;10、Feedly-Mini-将浏览内容快速添加到Feedly网站&quot;&gt;&lt;a href=&quot;#10、Feedly-Mini-将浏览内容快速添加到Feedly网站&quot; class=&quot;headerlink&quot; title=&quot;10、Feedly Mini : 将浏览内容快速添加到Feedly网站&quot;/&gt;10、&lt;strong&gt;Feedly Mini : 将浏览内容快速添加到Feedly网站&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Feedly扩展快速添加新的RSS，也保存必要的文章到Dashboard。&lt;/p&gt;
&lt;p&gt;这个扩展是Feedly的官方扩展。它是由Feedly开发团队创建和维护的。&lt;/p&gt;
&lt;p&gt;你将能够为您保存到公告板上的文章添加注释。&lt;/p&gt;
&lt;p&gt;100,000+ 位用户，34000+五星评价&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24egy1h06umu6arrj20hs0b4wfd.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24egy1h06umty585j21ql0u0aex.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实现的就是将网上浏览的内容，快速整合到一个浏览的地方，方便分类、查找、整理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24egy1h06umtk0wkj21do0q8tbb.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://feedly.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Feedly应用商店地址&lt;/a&gt;&lt;/p&gt;

      
    &lt;/div&gt;
    &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c4946ddc33b694cadebb41ca9c2eb90c</guid>
<title>TypeScript 官方：JavaScript 中直接支持类型！</title>
<link>https://toutiao.io/k/xnrgzre</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个新的 stage0 的语法提案，暂时还未提交给 TC39。github 的仓库地址是 https://github.com/giltayar/proposal-types-as-comments&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;背景&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近在 JavaScript 领域看到的一个趋势是，需要更快的迭代时间和减少构建步骤。换句话说，“更快、更简单”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在某种程度上，这已经发生了。多亏了浏览器的成功，开发人员通常可以避免编译较新版本的JavaScript以在较旧的 runtime上运行。在某种程度上，构建也是如此 —— 大多数浏览器都内置了对 module 的支持，因此构建渐渐成为了一个优化步骤而不是必要步骤。这种情况下，TypeScript 如何跟进呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们回到2012年，TypeScript首次发布的时候，JavaScript的世界就大不相同了！一些浏览器经常更新，但另一些不会。我们还不清楚Internet Explorer的古老版本会持续多久，这导致构建工具和编译器等工具大行其道。在向JavaScript添加构建步骤的时代，TypeScript能够蓬勃发展——毕竟，如果你需要编译JavaScript，为什么不也顺便编译你的类型呢？但是，如果我们上面提到的这些趋势继续发展，编译类型可能是编写 TypeScript 代码到运行之间的唯一步骤，我们不想成为阻碍良好开发体验的人！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在某些方面，我们的 JavaScript 支持弥补了这一差距，如果您使用像Visual Studio或Visual Studio Code这样的编辑器，可能已经见过 JSDoc 形式添加类型注释：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@param &lt;/span&gt;a {number}&lt;br/&gt; * &lt;span&gt;@param &lt;/span&gt;b {number}&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;a, b&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; a + b;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为这些只是注释，它们根本不会改变代码的运行方式——它们只是一种文档形式，但TypeScript利用了它们，通过代码补全、自动重构等方式为您提供更好的JavaScript编辑体验。甚至可以通过在文件顶部添加 &lt;code&gt;// @ts check&lt;/code&gt;注释来添加&lt;span&gt;类型检查&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;，或者通过TypeScript编译器，开启 &lt;code&gt;checkJs&lt;/code&gt; 选项来运行这些文件。这个特性使得在不需要构建步骤的情况下就可以获得一部分的TypeScript体验，您可以将其用于小型的脚本、基本网页和 Node.js服务端代码等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过，您会注意到这有点冗长，失去了 TypeScript 写类型的简洁性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果我们全都要呢？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们可以有一些像TypeScript这样的语法，但在JavaScript中完全被忽略——有点像注释。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;a: &lt;span&gt;number&lt;/span&gt;, b: &lt;span&gt;number&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; a + b;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的团队相信这里有很大的潜力，本月我们希望将其&lt;span&gt;作为提案提交&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;给ECMAScript标准委员会TC39！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;如何工作？&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们被问到“JavaScript什么时候能拥有类型？”，我们回答的很犹豫。在过去，如果你问开发人员他们对JavaScript中的类型有什么想法，你会得到很多不同的答案。一些人认为类型应该被完全忽略，而另一些人则认为它们应该具有某种意义——可能是它们应该执行某种运行时验证，或者它们应该作为引擎优化的提示等等。但在过去几年里，我们看到人们更倾向于一种与TypeScript的发展方向一致的设计，即类型在运行时被完全忽略且可擦除。现在我们可以自信的提出“类型作为注释”的提案了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个提案的想法是&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;，可以开创一组语法，JavaScript 完全忽视它，但TypeScript、Flow等工具可以使用这些语法。这使我们能够保留您喜欢的TypeScript里的内容——它的类型检查和编辑体验，同时消除开发中需要的构建步骤。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，在编写和运行代码时，工具链看起来会有些不同。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5358024691358024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iagNW4Zy9CyaEwxYWTicRyLG4ick0r17Xt60eLcylAEEFxl5K0gDHeyBhmp8YLaNNGAJr2914tu9F7bzw1u8T9A4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;810&quot; title=&quot;屏幕截图.png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与此同时，编写代码和类型检查将保持不变。开发人员可以在支持TypeScript的编辑器中获得即时类型检查反馈，在命令行里运行TypeScript，将TypeScript添加到CI任务中。最大的区别是，因为我们不需要构建步骤，所以我们将大大降低JavaScript开发人员的入门门槛，让他们体验类型和优秀工具的强大功能。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5012594458438288&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/iagNW4Zy9CyaEwxYWTicRyLG4ick0r17Xt63ahwhDX0vmb6nPSBtOVsDicibA1iaEBP6WicIRZv3638bgtTPrKhIRrQibg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;794&quot; title=&quot;屏幕截图.png&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要实现这一点，JavaScript只需为变量和函数上的类型注释、可选性修饰符（&lt;code&gt;?&lt;/code&gt;）等添加语法对于参数和类成员、类型声明（&lt;code&gt;interface&lt;/code&gt;和&lt;code&gt;type&lt;/code&gt;别名）和类型断言运算符（&lt;code&gt;as&lt;/code&gt;和&lt;code&gt;!&lt;/code&gt;）——所有这些都不会影响周围代码的运行方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时也支持可见性修饰符（例如&lt;code&gt;public&lt;/code&gt;、&lt;code&gt;private&lt;/code&gt;和&lt;code&gt;protected&lt;/code&gt;）；然而， &lt;code&gt;enum&lt;/code&gt;、&lt;code&gt;namespace&lt;/code&gt;将参数属性不在本提案的范围内，因为它们具有可见的运行时行为。根据反馈，这些特性可以作为单独的ECMAScript特性提出，但我们当前的目标是支持TypeScript的一些大子集，我们认为这可能是JavaScript的一个很有价值的补充。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这一突破，我们为类型检查器提供了创新的空间。这确实意味着引擎会很顺利地运行代码，但我们相信类型检查器可以（也应该）是规范性的，并实施比运行时更严格的约束。结合起来，这就形成了一种类型语法，可以跨不同的检查器进行定制，或者如果有人认为他们对TypeScript或任何其他类型检查器不满意，也可以删除掉。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;这不是什么？&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得一提的是，这个提议&lt;strong&gt;不是什么&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的团队没有提出把 TypeScript 的类型检查器放到每个浏览器和JavaScript运行时中 —— 我们也没有提出要在浏览器中放入的任何新的类型检查器。我们认为这样做会导致JavaScript和TypeScript用户的一系列问题，例如运行时性能、兼容性问题以及扼杀类型领域的创新。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相反，我们只是提出了与TypeScript兼容并受其驱动的语法，任何类型检查器都可以使用它，但JavaScript引擎会跳过它。我们相信这种方法对每个人来说都是最有前途的，并将继续允许TypeScript、Flow和其他人继续创新。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;接下来？&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;鉴于所有这些，我们计划在即将到来的2022年3月TC39全体会议上提交 &lt;span&gt;Stage 1&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt; 的提案。我们将在这项提案的共同倡导者，彭博社的&lt;span&gt;Rob Palmer&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;和Igalia的&lt;span&gt;Romulo Cintra&lt;/span&gt;&lt;sup&gt;[6]&lt;/sup&gt;的支持和指导下完成这项工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;达到第1阶段意味着标准委员会认为支持类型语法对于ECMAScript是值得考虑的。这并不是一件肯定会引起轰动的事情——委员会内部有许多有价值的观点，我们确实期待一些怀疑的声音。这样的提案会得到大量反馈和适当的审查。这一过程可能涉及大量的设计变更，可能需要数年时间才能产生结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果我们完成了这一切，我们就有机会对JavaScript世界做出最有影响力的改进之一。我们对此感到兴奋，希望你们也一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您有兴趣了解更多关于细节和当前方向的信息，&lt;span&gt;请前往提案的仓库&lt;/span&gt;&lt;sup&gt;[7]&lt;/sup&gt;。我们期待着听到你的想法！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，TypeScript团队和champions group要感谢所有从事&lt;span&gt;现有技术&lt;/span&gt;&lt;sup&gt;[8]&lt;/sup&gt;工作的人，以及那些伸出援助之手帮助进行评论的撰稿人，尤其是帮助推动这项工作的&lt;span&gt;Gil Tayar&lt;/span&gt;&lt;sup&gt;[9]&lt;/sup&gt;。我们非常感激能成为这样一个充满激情的社区的一部分！&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI3NTM5NDgzOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/iagNW4Zy9CyYVSTPz12NWetu6ibLCFyv5KPSSUofUggicb8PK2wZz9uZZ2oCSTT7tOb2nPkyZ415VlxhavwDeKmCw/0?wx_fmt=png&quot; data-nickname=&quot;前端从进阶到入院&quot; data-alias=&quot;code_with_love&quot; data-signature=&quot;我是 ssh，只想用最简单的方式把原理讲明白。wx：sshsunlight，分享前端的前沿趋势和一些有趣的事情。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;span&gt;参考资料&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;类型检查: &lt;em&gt;https://www.typescriptlang.org/docs/handbook/intro-to-js-ts.html&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;作为提案提交: &lt;em&gt;https://github.com/giltayar/proposal-types-as-comments&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;这个提案的想法是: &lt;em&gt;https://github.com/giltayar/proposal-types-as-comments&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;Stage 1: &lt;em&gt;https://tc39.es/process-document/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;Rob Palmer: &lt;em&gt;https://github.com/robpalme&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;p&gt;Romulo Cintra: &lt;em&gt;https://github.com/romulocintra&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;p&gt;请前往提案的仓库: &lt;em&gt;https://github.com/giltayar/proposal-types-as-comments/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[8]&lt;/span&gt;&lt;p&gt;现有技术: &lt;em&gt;https://github.com/giltayar/proposal-types-as-comments#prior-art&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;p&gt;Gil Tayar: &lt;em&gt;https://github.com/giltayar/&lt;/em&gt;&lt;span/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b099ff082b756b5a8bcd8d4708647adc</guid>
<title>闲鱼策略中枢业务扩展模块实现</title>
<link>https://toutiao.io/k/fdv54qp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2 data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;扩展能力是我们在做平台、中台时都会面临的技术思考。&lt;/span&gt;&lt;span&gt;为了平台能尽可能覆盖更多的业务场景，我们需要设计可扩展，可复用的扩展模块，不断拓宽平台能力的边界。&lt;/span&gt;&lt;span&gt;本文介绍闲鱼策略中枢平台Luxury做业务扩展模块时遇到的问题以及解决思路，希望能为同样做平台扩展模块的读者提供一些启发。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;span&gt;闲鱼策略中枢Luxury是面向闲鱼全域业务的用户精细化策略运营平台，旨在引导用户认识、参与闲鱼的各业务场景、精准的传递平台价值。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;以下面的红包投放为例，它就是Luxury的一条投放策略投放到客户端上之后的展现形式。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8886925795053003&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1FnlMHA4nLMXowWHest5q0c9uwKrNKIvdDXgYZGKmacclDiaPeB7QUeuJQDw0fEnicOz0LBmicSvd65A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1132&quot;/&gt;&lt;span/&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;一条投放策略包含了：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;规则(策略触发时机)。对应红包例子，触发时机就是用户打开客户端首页时识别有未使用红包&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;触点(投放的素材样式)。对应红包例子，素材样式就是整个Pop大卡片样式&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;钩子(填充触点的动态数据)。对应红包例子，钩子就负责填充pop卡片中的红包金额，和标题文案&lt;/span&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;其中，钩子的定位是负责对接二三方的接口与服务，为素材投放提供动态数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;现状&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;614&quot; data-backw=&quot;578&quot; data-ratio=&quot;1.0624&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1FnlMHA4nLMXowWHest5q0clG7b2avcVkNkeA1iaew1rJVyucp8iaXr1rM46ylib76aNXwQEH4Bb5skg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1250&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;目标&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;技术方案&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;钩子模块的总体思路是采用适配器模式，抽象出钩子接口层，二三方服务可以通过实现接口来接入Luxury平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;适配器模式是可扩展性的经典解决方案。例如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;适配器模式做统一抽象的解决方案一般是对出入参做数据映射，适配到统一的接口模型，对上层屏蔽底层实现差异。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;钩子模块架构图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5244040862656073&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1FnlMHA4nLMXowWHest5q0crTiahibPFszFUjEumoEbayquUk41ZKia5AOq7AWhX9CwuSjryTPicL39zQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;881&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;钩子模块链路图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8696596669080376&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1FnlMHA4nLMXowWHest5q0c5fQHW6dY4IJGcRppFjzrPVk6tibULtd3p3LPBChwQWvXwrs0JoZkexg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1381&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;入参构造&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;问题：钩子是策略链路上独立可复用的模块，因此钩子不与某个具体策略耦合，也不与某个具体的客户端调用耦合。这意味着客户端的每次调用不知道要传哪些参数给钩子。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;解决方案：该类问题的常规解决思路是把入参的结构信息传递到调用方，让调用方感知每次调用的入参格式。但这意味着需要拆分成两次调用，一次获取入参结构，一次发起调用。但在我们在横向分析了自己的业务场景，发现策略的入参往往是精简，有限，可枚举的，比如用户id、商品id、页面id等等。因此我们转变方案，通过每次调用时客户端传递尽可能全的上下文，而钩子从调用上下文里取需要的字段。通过冗余的参数换取更简单的设计，更少的调用次数。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;静态配置可视化&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;问题：运营需要在后台配置钩子的静态配置，但问题是每个钩子的静态配置结构都不一样，服务端的静态配置结构需要透传到后台生成表单让运营感知并且理解。传统解决前后端参数传递的方式是前后端约定接口协议并且开发页面表单，但这种方式对钩子不太适用。每次变更都涉及到前后端联调，发布，不能满足钩子敏捷扩展的需求。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;解决方案：要解决表单多变且可持续拓展的问题，用schema动态生成表单是一个好的解决方案。该方案需要前后端约定schema协议，前端提供schema生成表单的引擎，后端提供类生成schema的工具。这样后端的类能直接映射为前端的表单样式，前端表单的一份配置就对应一个后端类实例。整个开发流程能大幅度缩短，支撑钩子敏捷迭代。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.197724039829303&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1FnlMHA4nLMXowWHest5q0cHoLEJZD3JoFia5nibgdq5kXbKAa0bSsx5GDMfumM95qyxtyT6ibunicu3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1406&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一份生成的表单与对应的schema例子如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8382165605095542&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1FnlMHA4nLMXowWHest5q0cgS4o1gM6E8fh898rzPSyS9kFLVyFaUmIFGKf1AJ1kV6hhgAbFMjCfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1570&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;json&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;object&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;properties&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;appId&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;integer&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;title&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;app id&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;required&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;callSource&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;string&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;default&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;fleamarket&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;title&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;call source&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;required&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;tppParam&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;array&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;items&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;object&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;properties&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;key&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;string&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;title&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;tpp入参&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;required&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;value&quot;&lt;/span&gt;: {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;type&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;string&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;default&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;${input.}&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;description&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;支持从input或config从动态获取参数&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;title&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;解析表达式&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;required&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      },&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;description&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;从input或config中根据mvel表达式获取参数，最后组装为kv结构的tppParam&quot;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__attr&quot;&gt;&quot;title&quot;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;tpp请求param&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3&gt;&lt;span&gt;出参标准化&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;问题：钩子作为业务扩展模块，出参结构是不可穷举的，难以约束和进一步抽象。但矛盾在于如果不做统一的抽象，就会把出参的复杂度暴露给外部，外部就需要感知钩子各种case下的数据结构，如何对出参做统一与抽象，屏蔽出参的复杂性？&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;分析：我们配置触点与数据的映射时。触点用一个一个占位符挖出来动态数据的“坑”，“坑”是有限且是单一层级的，不会出现一个“坑”里填了个大对象或者大列表的场景。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;解决方案：制定规范，要求将钩子的出参映射为平铺的结构，每份平铺的出参都是一份字典(KVKV结构)，每个KV语义清晰，运营同学配置策略时，从字典里挑选需要的动态数据字段填入触点，“将有限的数据填入有限的坑”。平铺经验证是满足扩展性需求的，就算是嵌套的List结构，例如K[0:[0,1], 1:[0,1]]也能平铺为K_0_0，K_0_1，K_1_0，K_1_1这种结构。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;一个通过字典配置触点的例子如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7357798165137615&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1FnlMHA4nLMXowWHest5q0cZQHD7jxXQkBGEEXXdtNicELFFviaJG2kMj4Z2RahX5vZN8e4XQIPYxYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2180&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;数据映射可配置化&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;问题：在做红包权益钩子的时候，我们发现红包权益钩子的可复用性不强，因为它仅是TPP算法中台上的一种业务场景，我们一旦需要接TPP算法中台的另一个算法业务场景，就需要重新扩展实现一遍钩子。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; 分析：可复用性不强的原因在于对接中台类钩子时，中台本身有很强的拓展能力，而我们的出入参的数据映射针对中台上的一种业务场景写死的，导致不能复用到中台上的其他业务场景。因此，我们需要做到数据映射的可配置化。&lt;/span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;354&quot; data-backw=&quot;557&quot; data-ratio=&quot;0.6356073211314476&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1FnlMHA4nLMXowWHest5q0cbLg9kItELicOPpZ6bxjwIG9VCoNdHgdrHCgvVulIIibeDps1NJqdU7ibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1202&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;解决方案：当发现数据映射成为扩展性的瓶颈时，就要着手解决数据映射灵活性的问题。因此需要实现数据映射的可配置化，钩子实现可配置的数据映射引擎，将入参出参的数据映射配置关系抽出放到静态参数里。这样中台钩子就不与任意一个场景耦合，变更场景时只需要修改数据映射配置，不需要重新开发。当钩子实现不与具体场景耦合时，也就实现了最大化灵活性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;367&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6356073211314476&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1FnlMHA4nLMXowWHest5q0chLZOmkwRHI4iavNzHO4VibEeGN30aPGhSbDf8De6avQuyvPIjNk46ZicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1202&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;效果&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;运营同学可以独立配置钩子到触点的映射关系，钩子成为了可以灵活替换的数据字典，可以按需挑选自己需要的动态数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;沉淀了常见中台钩子，能够覆盖大部分场景需求，服务接入仅需0.5day配置成本。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;覆盖促买入、促发布、促浏览、活动互动等多个业务场景。 &lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8608458390177354&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1FnlMHA4nLMXowWHest5q0cMMqQI0Jkj4hc6OoV0fGksbVOlCWPTKC9KbDFkia7vkCuO2ia6vtibpZlA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;733&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;扩展模块的设计都很“难”，难的原因在于为了保证可扩展性，在方案设计阶段就不能预设接入服务的结构。接入服务可以是任意一个接口，任意一个服务。对于这样没有边界的服务要做统一和抽象是很困难的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关键的地方在于统一接口层的定义，也是“规范”和“协议“定义。需要我们从业务特点出发，在保证可扩展性的前提下，保证接口层的语义清晰，在可扩展性和易用性之间找到最佳的平衡点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;2390&quot; data-backw=&quot;578&quot; data-ratio=&quot;4.13570487483531&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DUwiayJ0Mj1GLZDqvPfwuIUEJjtdPx4lYwPx0p9E4T3D1f164CCr18n4ms26HtWsUVrsLf8Szwb4Us8MuhOCe3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;759&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>