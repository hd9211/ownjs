<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>6da516fae7465adace861f0d1f853646</guid>
<title>越是不确定性的时代，你越需要这份确定！</title>
<link>https://toutiao.io/k/uy0frh6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                  &lt;strong class=&quot;profile_nickname&quot;&gt;我爱程序员&lt;/strong&gt;
                  &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;developerWorks&lt;/span&gt;
                  &lt;/p&gt;

                  &lt;p class=&quot;profile_meta&quot;&gt;
                  &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                  &lt;span class=&quot;profile_meta_value&quot;&gt;我们的产品：《码农周刊》 http://manong.io/ 、《开发者头条》 http://toutiao.io/&lt;/span&gt;
                  &lt;/p&gt;
                &lt;/div&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>adfc131b7ca050fd0791f4f6a39f4b78</guid>
<title>全栈工程师修炼手册</title>
<link>https://toutiao.io/k/9z9qrw5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA4Njk2NDAzMA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/t8lpVibticjQ5p4x0RLv7ZmauGJfcichQt3zPj5VRgP8EPt6fC2siaonvQPEwQBCSGicvz84j80wse9l297PtLEd8Bg/0?wx_fmt=png&quot; data-nickname=&quot;开发者头条&quot; data-alias=&quot;kaifazhetoutiao&quot; data-signature=&quot;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;第一次接触编程是在小学三年级，至今有二十多年了，虽然现在的主要职责是管理公司的工程师与数据团队，但仍时不时会手痒写点程序。这么多年来，从游戏到网站到移动应用，从前端到后端到系统架构，自动化运维，大数据平台，所有这些领域我都有所接触。以前像我这样乱点技能树的，只能叫作万精油，但如今这就叫全栈工程师。&lt;/p&gt;&lt;p&gt;回想起来，我觉得自己还是挺幸运的，比起某某某领域专家，我更喜欢自己现在的状态。如果你也想尝试这条路，今天我可以给你一些建议。&lt;/p&gt;&lt;h2 tabindex=&quot;-1&quot;&gt;全栈适合你吗？&lt;/h2&gt;&lt;p&gt;在开始之前，这是你该问自己的第一个问题。因为全栈只是一种选择，你也可以选择朝垂直领域专家的方向努力。如果你已经有自己的答案，那就跟随你的意愿去做。如果你在犹豫，那么让我来问你几个问题&lt;/p&gt;&lt;p&gt;第一个问题，你现在在大公司还是创业公司？将来又想去哪儿呢？虽然没有绝对，但在创业公司，你可以迅速锻炼全栈的能力。而大公司有更多的机会深入研究某个领域的问题。特别是对于运维和大数据方面，大公司有得天独厚的优势，许多挑战与经验是创业公司无法提供的。&lt;/p&gt;&lt;p&gt;第二个问题，你将来是否想成为一个管理者？现在很多公司提供了 dual-stack，就是说管理线与技术线是并行的，要走哪条路你自己选。我的建议是，如果你希望将来转管理，在做技术的时候，广度比深度更重要，也就是说你更应该往全栈方向发展。管理者到一定层次都需要对项目负责，而任何一个典型的互联网项目，前后端开发、线上部署、数据分析，这些部分都缺一不可。拥有全栈的知识，你就可以对项目与团队有更好的把控力。&lt;/p&gt;&lt;p&gt;第三个问题，首席科学家与首席架构师，哪个更吸引你？如果你不走管理线，继续走技术线，那前面两个选择基本就是你发展的目标。如果你选架构师，那你就更适合往全栈发展。其实架构师也是一个管理者，只是他管的不是人，而是一个个技术模块。架构师的功力体现在如何选取最适合的模块，并让它们之间无缝连接。所以你的技术知识面越宽广，你可设计的版图就越大。&lt;/p&gt;&lt;p&gt;最后一个问题，你在学生时代是否偏科？开半个玩笑，我想说的是人要学会从自己的过去总结经验。偏科可能预示着你更适合钻研一项技术而不适合全面发展，或许有一天你就能成为某个领域的大牛，不也是好事一桩？&lt;/p&gt;&lt;p&gt;除去个人的偏好外，你也要关注时代的趋势。这是个开了变速齿轮的时代，短短几年间，技术的热点一直在变化，从移动开发，到大数据，VR，再到深度学习，区块链。身上不多背几项技能，可能没几天就被淘汰了。但到最后“能否快速掌握一项新技术”或许才是唯一不会被淘汰的技能。而在成为全栈工程师的道路上，你可以很好地锻炼这项终极技能。&lt;/p&gt;&lt;h2&gt;全栈工程师修炼手册&lt;/h2&gt;&lt;p&gt;全栈并不是毫无章法的遍地开花，好的学习计划与方法可以事半功倍，以下是我总结的几点经验&lt;/p&gt;&lt;h4&gt;一到多再到一&lt;/h4&gt;&lt;p&gt;从编程入门开始，先花一至两年时间熟练掌握一门主流的编程语言。这个阶段的目标就是一个扎实的基本功，包括程序中的基本概念，例如值与引用，变量的作用域，对象与类，常用数据结构与算法等等。一旦基础扎实了，接下去的三年左右时间就要从一到多，迅速扩冲你的技能池。要做到快速学习，第一项要领就是读技术资料时要学会跳读。因为很多的技术有相通之处，学习一项新技术，只需学习它与你已掌握的技术之间的 diff 就行了。当你有了一定的技术储备之后，一到两天内学会一门新的语言与框架其实并不难。这个阶段的另一个要领是 20/80 原则，也就是用 20% 的时间来了解一项技术中 80% 的基础内容，将剩下最难啃的 20% 留在将来需要深挖时再研究。&lt;/p&gt;&lt;p&gt;那为什么最后还要再回到一呢？当你有了足够的技术广度之后，你对技术的洞察力与理解力都会提升一个层次，这使你能更准确地发现适合自己且有前途的技术领域。与初入行时的随大流不同，你此时的选择是经过深思熟虑，为自己量身定制的。在接下去的时间里重点深挖一个或少数几个领域，这样在俱备了技术广度的同时，你也拥有了自己的杀手锏，个人价值会再次大幅提升。&lt;/p&gt;&lt;h4&gt;任务导向&lt;/h4&gt;&lt;p&gt;所谓任务导向就是一切学习都应该以输出为目的。仅凭兴趣学习，往往是低效的。比如你的公司要做一款移动应用，初期的流程是开发 -&amp;gt; 上线 -&amp;gt; 运营，对应的技术能力就是前后端开发，自动化运维，数据平台与用户分析。当用户数到达一定体量以后，就需要高可用架构，推荐算法等技术。你技术学习的脉络应该顺应业务的发展，这样才有机会学以致用。&lt;/p&gt;&lt;p&gt;那如果你身在大公司，又该怎么做呢？有些大公司提供轮岗的机会，比如我之前在 Google，公司每 18 个月提供一次换岗机会。可以借此扩展你的技能池，要好好利用。在选择下一个岗位时，应保持一种连续性，比如从前端开发转后端开发，从开发部门转运维或是数据部门等。&lt;/p&gt;&lt;p&gt;不过总体来说，全栈工程师与创业公司或是发展期公司才是最佳组合。&lt;/p&gt;&lt;h4&gt;移花接木&lt;/h4&gt;&lt;p&gt;学技术要了解其思想，而不要留于表面形式。优秀的技术思想会从它的发源地流向其他领域。例如，&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;前端的 MVC 结构在后端一样适用。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;当你理解了 Java 的 Annotation 以后，再看 Python 的 Decorator 就会觉得非常熟悉（尽管两者的实现方式完全不同）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;当编译语言用类型推断（Type Inference）去除类型声明的同时，脚本语言却在用类型提示（Type Hint）添加类型声明。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;不可变（Immutable）的思想始于函数式编程，但可以用于运维（Immutable Infrastructure)，也可以用于大数据管理（Functional Data Engineering)。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;运维的核心是对各类服务器数据的监控与报警，同样的理念也可以用于产品与运营数据。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;技术之间的联系，有些是显而易见的，有些需要你沉淀思考。真正的全栈工程师可以用一个技术领域的思想，去解决另一个技术领域的问题。再举一个我公司的例子，在学习用 Ansible 做运维时，发现它的 Playbook 不是用脚本语言而是用 YAML 来写的，这让我意识到原来 YAML 不仅可以用来描述数据，也可以用来描述逻辑关系。这个思想后来被用在我们很多的项目中，比如在设计数据产品的报表时，各种指标的计算，包括指标之间的依赖与派生关系都是直接在 YAML 中定义的，主体程序不涉及任何业务逻辑，仅仅是解析与执行这些 YAML 文件。&lt;/p&gt;&lt;p&gt;所以我建议在学习技术时，多做一些交叉领域的思考，这会使你在提升技术广度的同时，加强你的技术思维。&lt;/p&gt;&lt;h4&gt;层次切换&lt;/h4&gt;&lt;p&gt;记得以前刚进 Google 时，听的第一个内部讲座就是 Life of a Search Request，讲从用户输入一个搜索关键词到得到结果的整个过程，这个过程涉及浏览器，TCP/IP的网络传输，后台的 Web 服务集群，索引数据库群等等。对于你公司的业务，你是否能清楚地描述从用户输入到产生结果的整个周期？对于每一个环节，你又能深入细节到什么程度？&lt;/p&gt;&lt;p&gt;有次和公司的 CEO 聊天，他说他衡量一个产品经理的能力时，会看这个人能否从产品细节到长期战略之间的各个层次来回切换。我觉得衡量一个全栈工程师能力也是类似的，看他是否在了解系统的全貌的同时，又能深入到单个模块的细节。当系统遇到真正棘手的难题时，就非常考验技术人员在各层次之间切换的能力。就如同玩竞技类游戏，只有同时拥有良好大局观与精湛微操作的选手，才能成为顶尖高手。&lt;/p&gt;&lt;p&gt;在学习全栈的路上，不但要试着横向地切换层次（前台，后台，运维），也要尝纵向地切换层次，除了写业务代码之外，向下了解一些框架的底层运行机制，读一读它们的源码。向上学习一下系统设计与分布式架构。你可能会觉得什么都学会不会精力太分散？我觉得并不会，只要你顺着一条合理的脉络去学（任务导向），花三到五年的时间迅速延展你的技术广度是非常值得的。这会使你比同龄人更具竞争优势。目标要定得高，实践时量力而为。&lt;/p&gt;&lt;h2&gt;全栈修炼入门级套餐&lt;/h2&gt;&lt;p&gt;每个人的技术学习路线可能都不太一样，这也是为什么这篇文章着重讲的是方法而不是具体的学习内容。不过对于刚进入移动互职网开发的新人，我可以推荐一个全栈学习的新手包。编程语言方面，可以优先去学习以下语言&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;Java&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;JavaScript&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Python&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;SQL&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Swift (如果不做 iOS 开发,可以不学)&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Java 不但可以写 Android 应用，也是目前大部分国内公司的后端主力语言，在分布式系统与大数据平台方面的生态圈非常完整，所以即使你公司不用 Java 也应该学。&lt;/p&gt;&lt;p&gt;写前端，JavaScript 是必备技能，要掌握一个主流前端框架，建议学 React。这是一个非常出色的框架，生态圈成熟，适用性广，在有了 ReactNative 加持之后还可以做移动应用开发。另外，在熟悉了 JS 之后，也可以用 NodeJS 来写后端。&lt;/p&gt;&lt;p&gt;Python 也是个全能型语言，如果之后要做自动化运维，大数据分析与机器学习，Python 在这些方面优势明显。国外有很多公司用 Python 写后端，国内相对少些，但对创业公司而言，用 Python 做大后端的主力语言（业务后端 + 运维 + 数据分析）其实是个不错的选择。&lt;/p&gt;&lt;p&gt;学 SQL 前期是为了研发与上线时的数据库查询与管理，后期是为了数据分析与商业智能。即使目前各数 NoSQL 百花齐放，但传统的关系型数据库，如 MySQL 或是 PostgreSQL，势头依然强劲 。而在大数据端，各类的数据仓库与数据计算框架都会提供类 SQL 的接口。在较小的公司里，开发人员还经常兼做数据分析师。所以我认为熟练掌握 SQL 是对全栈工程师一项基本要求。&lt;/p&gt;&lt;p&gt;除了这些编程语言外，另一部分就是了解运维的基础知识，包括 Linux 命令行，Docker，以及各类常用的基础服务与数据库，如 Nginx，MySQL，Redis，MongoDB 等。&lt;/p&gt;&lt;p&gt;有了这些技术基础之后，你对于一个移动应用的系统全貌，就有了大致的了解。可以再根据公司实际的业务情况，选择进一步学习的内容。&lt;/p&gt;&lt;h2&gt;小结&lt;/h2&gt;&lt;p&gt;全栈的路很慢长，也很有趣，祝大家成功！今天的分享就到这里，欢迎留言。&lt;/p&gt;&lt;p&gt;（完）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;加入「码农周刊VIP会员」，成为更好的开发者！&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicibroqCN98y5SNT9NbfA3oHYQiaicFScHFfppgek7ZGicJiaHK45qc2zoccBibfEzIvzTsI4AB2xO2IaOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f7c8889c6b806bdd185e8322a56287bf</guid>
<title>博文推荐｜深入解析 BookKeeper 多副本协议（一）</title>
<link>https://toutiao.io/k/8vk008d</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;blockquote&gt;&lt;p&gt;本文翻译自《A Guide to the BookKeeper Replication Protocol (TLA+ Series Part 2)》，作者 Jack Vanlightly。原文链接：https://medium.com/splunk-maas/a-guide-to-the-bookkeeper-replication-protocol-tla-series-part-2-29f3371fe395。&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote&gt;&lt;h1&gt;译者简介&lt;/h1&gt;&lt;p&gt;王嘉凌@中国移动云能力中心，移动云Pulsar产品负责人，Apache Pulsar Contributor，活跃于 Apache Pulsar 等开源项目和社区&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我们知道关系型数据库中的数据是按表结构来存储，客户端可以将数据存储到表中以及从表中读取数据。Apache BookKeeper 中的数据是按日志结构来存储，客户端以日志的形式读写数据。日志结构是一种只支持数据追加操作的简单数据结构，支持多个客户端同时读取，以及非破坏性读取。&lt;/p&gt;&lt;p&gt;作为数据结构，日志和队列的功能非常相似，区别在于日志支持多个客户端同时独立地从不同位置读取完整的数据。因此，日志必须支持非破坏性读取。而队列则是破坏性读取， 队列的头部元素被读取后会被删除。这意味着队列中的每个元素只会被一个客户端读取到。&lt;/p&gt;&lt;p&gt;作为 Apache Pulsar 数据存储层的 Apache BookKeeper，本身也是一个复杂的分布式系统。BookKeeper 利用多副本机制来实现数据的安全和高可用。多副本指的是每一份 entry 数据都会被复制到多个节点保存，以便在发生部分节点故障时仍然可以提供读写服务，并且保证已保存的数据不会丢失。BookKeeper 使用一套独有的多副本协议，这个协议规定了多个服务节点之间如何协同来实现服务的高可用以及保证数据的安全。&lt;/p&gt;&lt;h1&gt;基于分片的日志数据结构&lt;/h1&gt;&lt;p&gt;诸如 Apache Kafka 和 RabbitMQ 这样使用基于队列和日志的消息队列，都是将每个队列或分区的数据视为一个整体来存储，这样一来整个数据必须全部存储在同一个存储节点。BookKeeper 使用了一套基于分片的日志数据结构，每个日志数据由一系列的分片数据（Segment）串联组成。Pulsar 的一个 Topic 分区 数据实际上是分为多个数据分片来保存。&lt;/p&gt;&lt;p&gt;我们知道每个 Pulsar Topic 都有一个唯一的 Pulsar broker 作为 owner，这个 broker 负责给所属的 Topic 创建数据分片，并将这些数据分片进行串联以便在逻辑上组成一个完整的日志数据。 &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;80&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1425925925925926&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWPlQseAkmjic5zfNFy3lTtex1xMzaltbNkj8cV9DT5xArkkWmFamk9mEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1：Pulsar Topic 的数据由一组数据分片串联组成&lt;/span&gt;&lt;/p&gt;&lt;p&gt;BookKeeper 将这些数据分片称为 Ledger，并将它们保存在 BookKeeper server 节点（称为 bookie 节点）。&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;412&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7320837927232635&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWPDysaXNr1wmic17ZQbeOoibYlmF86zdpJ3KOmUttRrRaV7QTXl9QBh3CQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;907&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2：Pulsar broker 将 topic 数据存储到多个 Bookie 节点&lt;/span&gt;&lt;/p&gt;&lt;p&gt;BookKeeper 多副本协议和每个 ledger 的生命周期息息相关。多副本协议本身的实现封装在 BookKeeper 客户端类库中， 每个 Pulsar broker 通过调用BookKeeper 客户端类库中的接口来和 BookKeeper 进行交互，如创建 ledger，关闭 ledger，以及读写 entry。这些接口背后包含了非常复杂的协议逻辑，在本篇博客中我们会逐层分析并展示协议的实现细节。&lt;/p&gt;&lt;p&gt;首先，创建 ledger 的客户端即为这个 ledger 的唯一owner，只有 owner 可以往 ledger 里写数据。对于 Pulsar 来说，这个客户端就是作为分区 Topic owner 的 broker，Broker 负责创建 ledger 来组成这个 Topic 的数据段。当这个客户端由于某些原因发生故障时，另一个客户端（对于 Pulsar 来说就是另一个 broker）会介入并接管这个 Topic，这个时候需要修复之前的 ledger 中处于正在复制（under-replicated ）状态的 entry 数据（即 recovery 操作）并将 ledger 关闭。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;220&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.39166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWP0XCURyDexdFbeMX70zrZ0uiaAeM8CQeCoVBwNcuazwzicdSKOhOAEEyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3: Ledger 的生命周期&lt;/span&gt;&lt;/p&gt;&lt;p&gt;每个 Pulsar topic 仅包含一个 open 状态的 ledger 和多个 close 状态的 ledger。所有的写操作都会写入到 open 状态的 ledger，而读操作则可以从任何 ledger 中读取数据。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;108&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1925925925925926&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWPricxEhy8kACQA3Ev4G8B9o0NialRDAGXsvwO3Bd5K4X1TbTicDyNZiaibjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4: 写操作只会写入到 open 状态的 ledger&lt;/span&gt;&lt;/p&gt;&lt;p&gt;每个 ledger 都会保存到多个 bookie 节点上，每个 ledger 和存有这个 ledger 的 bookie 池（称为 ensemble）的对应关系保存在 ZooKeeper。当 open 状态的 ledger 大小达到了阈值，或者这个 ledger 的 owner 发生了故障，就会关闭这个 ledger 并重新创建一个新的 ledger。根据配置的多副本参数，新创建的 ledger 可能会被保存到另一组 bookie 池上。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;346&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6153846153846154&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWPCSZ4g5p2t85WwYBFTM4MjmNA8e8FibutqrwBTldGRbUhkdBU5Qjl0Sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;767&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图5：Ledger 数据的多个副本保存在多个 bookie 节点，每个 Ledger 的元数据以及一个 Topic 包含的 ledger 信息保存在 ZooKeeper&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;数据写入 ledger 的过程&lt;/h1&gt;&lt;p&gt;BookKeeper 包含以下 ledger 多副本配置相关的参数：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;• Write quorum (每份 entry 数据需要写入多少个 bookie 节点), 简称 WQ。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• Ack Quorum (需要从多少个 bookie 节点收到写入成功的响应后可以确认这份 entry 写入成功 ), 简称 AQ。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• Ensemble size (用于存储 ledger 数据的 bookie 池的节点数量), 简称 E。当 E &amp;gt; WQ 时，entry 数据会交错地写入到不同的 bookie 节点。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;一条 entry 数据实际写入的 bookie 节点的集合成为写入集合。当 E &amp;gt; WQ 时，相邻的 entry 的写入集合可能会不一样。&lt;/p&gt;&lt;p&gt;Pulsar 为每个 Topic 暴露了设置 AQ、WQ、E 参数的 API 来自定义副本设置。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;596&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0612855007473843&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWPs7UXQFJrDP5NLQgdLXKAmhbF5QCOzdLZsVzb80xicbFyevAOU3x16vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;669&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图6：WQ=3，AQ=2 时的消息写入和确认&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;最后添加确认 (Last Add Confirmed, LAC)&lt;/h1&gt;&lt;p&gt;BookKeeper 客户端会持续更新已确认写入的 entry 中连续且最高的 entry ID，我们称之为 Last Add Confirmed (LAC)。这是一条水位线，高于这个 entry ID 的 entry 都还没有被确认写入，而低于和等于这个 entry ID 的 entry 都已经被确认写入。每一条发往 bookie 的 entry 数据中包含了当前最新的 LAC，这样每个 bookie 都可以知道当前 LAC 的值，尽管有一些延迟存在。我们还会在下文看到 LAC 除了作为已提交 entry 的水位线，还发挥着其他作用。&lt;/p&gt;&lt;h1&gt;Ledger 数据段&lt;/h1&gt;&lt;p&gt;Ledger 本身也可以分成一个或多个数据段（fragment）。当 Ledger 创建时，包含了一个数据段，分配了一个 bookie 池用于存储这个 Ledger 的数据。当发生某个 bookie 写入失败时，客户端会用一个新的 bookie 来替代。这个时候会创建一个新的数据段，并重新发送未确认的 entry 数据和之后的 entry 数据到新的 bookie 上。当 bookie 再次写入失败时，又会再次创建一个新的数据段，以此类推。Bookie 写入失败并不意味着这个 bookie 节点不可用，网络波动等其他情况也会造成单次的写入失败。不同数据段的数据存储在不同的 bookie 池上。数据段也通常被认为是写入集合（Ensemble）。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;572&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0170261066969353&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWPc9bg9MyP91X3hicQAjibKibfuTUK3bjibGq3HYdbwkghKDeqNhYdcjoeicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;881&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图7：第二个数据段的创建过程&lt;/span&gt;&lt;/p&gt;&lt;p&gt;Ledger 数据段可以看作是告诉 BookKeeper 客户端去哪里找到某个 ledger 中的 entry 数据的元数据。Bookie 节点自身是不知道这些元数据信息的，它们只负责存储接收到的 entry 数据并创建基于 ledger ID 和 entry ID 的索引。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8425324675324676&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWPwkSc2zTo1MVXllhmB7YiaDRMkTHwYZyYfwmX7XR2nKLGUoAibA29r97g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;616&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图8：往 B3 bookie 节点写入 entry 1000 失败并导致 ledger 创建第二个数据段 &lt;/span&gt;&lt;/p&gt;&lt;h1&gt;从 ledger 读取数据的过程&lt;/h1&gt;&lt;p&gt;从 ledger 中读取数据的操作分为以下几种情况：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;• 正常读取 entry 数据&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• 长轮询读取 LAC 数据&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• Quorum LAC 机制下的读取数据 &lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;• 恢复性读取数据&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;和写数据不一样的是，我们只需要读取一个存有数据的 bookie 节点就可以得到想要的数据。如果这次读取失败了，也只需要从存有这个数据其他副本的 bookie 节点上重新读取数据即可。&lt;/p&gt;&lt;p&gt;客户端通常只希望读取到已确认的数据，所以只会读取到 LAC 值标识的位置。在读取历史数据时，bookie 节点会依据当前的 LAC 值来通知客户端何时停止读取。当客户端读取到 LAC 值并停止读取时，可以发起长轮询读取 LAC 数据。这个请求会先被 bookie 挂起，直到有新的 entry 数据被确认时才响应并返回新的 entry 数据。&lt;/p&gt;&lt;p&gt;另外两种读取数据的情况主要发生在数据修复时，我们稍后再介绍。&lt;/p&gt;&lt;h1&gt;完成不同的操作需要不同的响应数量&lt;/h1&gt;&lt;p&gt;完成不同的操作需要从 bookie 节点接收到的成功响应的数量不一样。比如，对于正常读数据的操作，只需要从一个 bookie 节点成功收到响应即可完成。而有些操作则需要从多个 bookie 节点（quorum）收到成功的响应才可完成。&lt;/p&gt;&lt;p&gt;这些操作根据需要收到响应数量的不同，可以分为以下几种类型：&lt;/p&gt;&lt;p&gt;Quorum Coverage (QC) 和 Ensemble Coverage (EC) 都满足于以下定义（以下两种定义本质上相同，只是说法不同），QC 和 EC 的区别仅在于“集合”的范围 ：&lt;/p&gt;&lt;p&gt;对于 Quorum Coverage (QC) 来说，这个集合是指某个 entry 的写入集合。QC 主要用于保证单个 entry 数据一致性的场景，如校验单个 entry 写入操作是否已被客户端确认。对于Ensemble Coverage (EC) 来说，这个集合是指存储当前 ledger 数据段对应的 bookie 池，EC 主要用于保证 ledger 数据段一致性的场景，如设置 ledger 的 fence 状态。&lt;/p&gt;&lt;p&gt;WQ 和 AQ 主要用于写数据，而 QC 和 EC 主要用于 ledger 修复过程。&lt;/p&gt;&lt;h1&gt;Ledger 修复的过程&lt;/h1&gt;&lt;p&gt;前面我们讲到每个 ledger 只有一个客户端作为 owner，当这个客户端不可用时，另一个客户端就会介入并触发 ledger 修复过程然后关闭这个 ledger。对于 Pulsar 来说就相当于作为一个 Topic owner 的 broker 变得不可用，然后这个 Topic 的所有权转移到另一个 broker 上。 &lt;/p&gt;&lt;p&gt;Ledger 修复过程包括找到最高的已被 bookie 确认的 entry ID，保证在这之前的每个 entry 都已复制了足够多的副本数量。之后将这个 ledger 关闭，此时会将这个 ledger 的状态设置为 CLOSED，并将最新的 entry ID 设置为最后被确认的 entry ID。&lt;/p&gt;&lt;h2&gt;如何防止脑裂&lt;/h2&gt;&lt;p&gt;BookKeeper 是一个分布式系统，这意味着网络波动可能会导致集群被分隔成两个或者更多的区块。我们设想如果一个客户端和 ZooKeeper 断开连接，那么这个客户端就被认为已不可用，另一个客户端会接管这个客户端负责的 ledger 并开始 ledger 修复流程。但这个客户端可能仍在正常运行，它可以正常的连接到 BookKeeper 集群，于是就会出现两个客户端试图同时操作同一个 ledger，这种情况就属于脑裂。脑裂是指一个分布式系统由于网络波动分裂为多个独立的系统，在一定时间后网络恢复导致的数据不一致的情况。&lt;/p&gt;&lt;p&gt;BookKeeper 引入了 fence 这个概念来防止脑裂的发生。当第二个客户端 （例如另一个 Pulsar broker）试图开始 ledger 修复流程时，会先将 ledger 设置为 fence 状态，在这个状态下 ledger 会拒接所有新的写入请求。当足够多的 bookie 节点将这个 ledger 状态设置为 fence 时，就算第一个客户端仍然处于正常运行状态，它也不能再进行任何新的写入操作。然后第二个客户端就可以在没有其他客户端会继续写入数据或者试图修复同一个 ledger 的安全状态下开始 ledger 修复流程。 &lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;455&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8106382978723404&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWPzjg5MZ5QM46UdU9wPEZTj680ecHg98zXia3E749u4D6yR0PiacGYWFsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;940&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图9：一个新的 Topic owner 开始将 ledger 设置为 fence，原先的 owner 写入新数据时无法写入 Ack Quorum 设定的副本数，则无法完成写入&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;修复流程第一步 — 设置 fence 状态&lt;/h2&gt;&lt;p&gt;将 ledger 设为 fence 状态，并确认 LAC 的值。&lt;/p&gt;&lt;p&gt;Fence 请求实际上是一次 Ensemble Coverage 类型的读请求，获取 LAC 的值并带有 fencing 标识。每个 bookie 节点收到这个请求时会将这个 ledger 的状态设为 fence，并返回这个节点上对应 ledger 的 LAC 值。当客户端从足够多的 bookie 节点收到响应时，就表示请求成功可以进行下一步操作。那么从多少个 bookie 节点收到响应才算足够呢？&lt;/p&gt;&lt;p&gt;我们将 ledger 设置为 fence 状态是为了防止之前的客户端继续往 ledger 里写入数据。所以我们只要保证还没有将这个 ledger 设置为 fence 状态的 bookie 节点的数量小于设置的 Ack Quorum 值，那么之前的客户端因为无法收到足够多的写入确认而无法写入新数据。新的客户端发起的 fence 操作不需要等到所有的 bookie 节点都将这个 ledger 设置为 fence，只需要满足还没有设置为 fence 状态的 bookie 节点数小于设置的 Ack Quorum 就可确认 fence 操作完成。满足这个条件所需要收到的响应数量就是 Ensemble Coverage。&lt;/p&gt;&lt;h2&gt;修复流程第二步 — 修复 entry 数据&lt;/h2&gt;&lt;p&gt;接下来，客户端从 LAC + 1 的 entry ID 开始发送恢复性读取数据的请求，并将这些 entry 数据重新写到新的 bookie 池中。写操作属于幂等操作，也就是说如果这个 entry 已经写入到了某个 bookie 节点，再次向这个节点写入同样的 entry 不会造成数据重复写入。客户端会持续进行读和写的操作直到读完所有数据。确保在关闭 ledger 之前，这个 entry 的写入集合中的所有 bookie 节点都写入了该 entry 的副本。&lt;/p&gt;&lt;p&gt;正常的读操作只需要从一个 bookie 节点接收到响应。与之不同的是，Recovery读操作需要根据从这个 entry 的所有写入集合的 bookie 节点上收到的响应内容来明确这个 entry 是否已确认。具体来说有以下两种情况：&lt;/p&gt;&lt;p&gt;如果所有响应都已收到，但两个阈值都未达到，那就无法判断这个 entry 是否已确认，修复流程就会终止（可能存在收到其他错误类型响应的情况，如网络波动，这种情况无法判断 entry 是否已成功写入对应 bookie 节点）。修复流程可以重复执行直到可以明确每个 entry 最终的确认状态。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;600&quot; data-backw=&quot;562&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0669781931464175&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0ZYnib9AbuqDwN7abdiaXOOWPz7zAaYiaVicAwe4sHtQWdW6OxYeHsV6oglAspjue9o7SuYwCIW19M9gw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;642&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图10：新的客户端在读取 entry 3 时收到了足够多的数据不存在请求，可以判断 entry 3 的状态为未确认。然后保证到 entry 2 为止的数据都复制到足够多的副本数&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;修复流程第三步 — 关闭 Ledger&lt;/h2&gt;&lt;p&gt;一旦明确了所有已确认的 entry ，且这些 entry 复制了足够多的副本数，客户端就会关闭 ledger。关闭 ledger 的操作主要是对 ZooKeeper 上 ledger 元数据的更新，将状态设置为 CLOSED，并将 Last Entry Id 设置为最新的已确认的 entry ID。这些操作和 bookie 本身不相关，bookie 也不会感知 ledger 是否被关闭，bookie 自身没有 open 或 closed 的概念。&lt;/p&gt;&lt;p&gt;ZooKeeper 上元数据的更新是一个基于版本控制的 CAS 操作。如果有另一个客户端同时在修复这个 ledger 并且已经将 ledger 关闭，那么这次 CAS 操作就会失败。通过这种方式可以防止多个客户端同时对同一个 ledger 进行修复操作。 &lt;/p&gt;&lt;h1&gt;总结&lt;/h1&gt;&lt;p&gt;本篇博客介绍了 BookKeeper 多副本协议的大部分实现内容。需要记住的重点是，bookie 节点只是单纯用来存储和读取 entry 数据的存储节点，在 BookKeeper 客户端中包含了创建 ledger、选择存储 ledger 的 bookie 池、创建 ledger 数据段的操作，通过 Write Quorum 和 Ack Quorum 来保证多副本的机制，以及在发生故障时对 ledger 进行修复和关闭等一系列逻辑。&lt;/p&gt;&lt;h1&gt;相关阅读&lt;/h1&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMjkzMjA1Ng==&amp;amp;mid=2247489945&amp;amp;idx=1&amp;amp;sn=a9dcb508a14eaa96052e783ef79f0e75&amp;amp;chksm=f9c503aeceb28ab8463c1149dd5a6a3c88b6d631d82621813f009bdc676619fb17511faf065d&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;博文推荐｜深入解析Apache BookKeeper 系列：第一篇 — 架构原理&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;•&lt;/span&gt; &lt;span&gt;博文推荐｜深入解析Apache BookKeeper 系列：第一篇 — 架构原理&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;• &lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyMjkzMjA1Ng==&amp;amp;mid=2247488980&amp;amp;idx=2&amp;amp;sn=7ab01fd746384dbcd934ae0d3c3f3e7b&amp;amp;chksm=f9c50fe3ceb286f57035082aeac2d407aded4f013c9e10a029fcadce179a49dd4aca984813c0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;博文干货｜5张图带你快速入门 Pulsar 的存储引擎 BookKeeper&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;博文干货｜5 张图带你快速入门 Pulsar 的存储引擎 BookKeeper&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;📣 Pulsar Storage 特别兴趣小组（SIG）已成立！&lt;span&gt;扫描下方&lt;/span&gt;&lt;span&gt;🤖️ &lt;/span&gt;&lt;span&gt;Pulsar Bot 二维码，&lt;/span&gt;回复 &lt;span&gt;BookKeeper&lt;/span&gt; 加入 Pulsar Storage 讨论群。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4ibRRsibIGr0ZSe03QyMcdYDoPThku7hjSJibg8nI1vtB8bde5jr1XSdz5iaPJDp7y1aOHupWAIQT1Qr3c1iafE5HXw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;扫/码/加/入&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;▼ 关注「Apache Pulsar」，获取更多技术干货 ▼&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUyMjkzMjA1Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/4ibRRsibIGr0Y7icPiahxgXFRw8a0xAIxOhPqYtRDr0IRNpGRl2oSfGHuvkG9VtahW9thH3btBGXJu9y2dZgb3oOuQ/0?wx_fmt=png&quot; data-nickname=&quot;ApachePulsar&quot; data-alias=&quot;ApachePulsar&quot; data-signature=&quot;Apache 软件基金会顶级项目，下一代云原生分布式消息流平台，集消息、存储、轻量化函数式计算为一体，采用计算与存储分离架构设计，支持多租户、持久化存储、多机房跨区域数据复制，具有强一致性、高吞吐、低延时及高可扩展性等流数据存储特性。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1486aa973a0dba8e7c8770a5c7449946</guid>
<title>点击页面元素，这个Vite插件竟然帮我打开了Vue组件文件！超级好用！</title>
<link>https://toutiao.io/k/pmc5cbe</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;大家好，我是&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5MjQwMzQyNw==&amp;amp;mid=2650757158&amp;amp;idx=1&amp;amp;sn=1f1cad678916031fb0e77eefcfa1dddc&amp;amp;chksm=88665baabf11d2bc7dce837e90cbe0b755d4e082362363e1ebc8912a77367b79ba59ea43a32e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;若‍川&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;若川&lt;/a&gt;。&lt;span&gt;持续组织了8个月&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5MjQwMzQyNw==&amp;amp;mid=2650761094&amp;amp;idx=2&amp;amp;sn=0d0e9de8fc6554b3074913697511c9a2&amp;amp;chksm=8866640abf11ed1c0bdf43f4758c3bb9a74c90c48ed76eed46dca1af6e9b63b992def9b3655c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;源码共读‍活动&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;&lt;strong&gt;源码共读活动&lt;/strong&gt;&lt;/a&gt;&lt;span&gt;，感兴趣的可以&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5MjQwMzQyNw==&amp;amp;mid=2650761094&amp;amp;idx=2&amp;amp;sn=0d0e9de8fc6554b3074913697511c9a2&amp;amp;chksm=8866640abf11ed1c0bdf43f4758c3bb9a74c90c48ed76eed46dca1af6e9b63b992def9b3655c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;点此加我微信 ruochuan‍12&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot; wah-hotarea=&quot;click&quot;&gt;点此加我微信 ruochuan12&lt;/a&gt;&lt;span&gt; 参与，每周大家一起学习200行左右的源码，共同进步。同时极力推荐订阅我写的&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA5MjQwMzQyNw==&amp;amp;action=getalbum&amp;amp;album_id=1342211915371675650&amp;amp;scene=173&amp;amp;from_msgid=2650759428&amp;amp;from_itemidx=1&amp;amp;count=3&amp;amp;nolastread=1#wechat_redirect&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;《学习源码整体架构系列》&lt;/a&gt;&lt;span&gt; 包含20余篇源码文章。&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA5MjQwMzQyNw==&amp;amp;action=getalbum&amp;amp;album_id=1932984266565484545#wechat_redirect&quot; textvalue=&quot;历史面试系列&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;历史面试系列&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;前言&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两天肝了个Vite插件,本文主要跟大家分享一下它的功能和实现思路.如果你觉得它对你有帮助,请给一个star支持作者 💗.&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;介绍&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;vite-plugin-vue-inspector的功能是点击页面元素,自动打开本地IDE并跳转到对应的Vue组件.类似于&lt;code&gt;Vue DevTools&lt;/code&gt;的 &lt;code&gt;Open component in editor&lt;/code&gt;功能。（若川批注：关于原理可以看我写过的文章：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5MjQwMzQyNw==&amp;amp;mid=2650751278&amp;amp;idx=1&amp;amp;sn=3ac07b110e84e3ded5fa4ec4407ce13b&amp;amp;chksm=886642a2bf11cbb4cea35f0d208815c39c9cd13a0522e7cdc4a466bc55cb5b3071143a38bb04&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;据说 99% 的人不知道 vue-devtools 还能直接打开对应组件文件？本文原理揭秘&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;据说 99% 的人不知道 vue-devtools 还能直接打开对应组件文件？本文原理揭秘&lt;/a&gt;）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5053680981595092&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/Mpt86EGjlpvVXr0Fgyg2FKxvMMoxmgn3VgbOYAibY0OaiadYkwfBO38nQoLOuJpOicv05DE5Zx4vz2Auu2sWjTSMQ/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1304&quot;/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;用法&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;vite-plugin-vue-inspector支持Vue2 &amp;amp; Vue3,并且只需要进行简单的配置就可以使用.&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Vue2&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// vite.config.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { defineConfig } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vite&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { createVuePlugin } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vite-plugin-vue2&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Inspector &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vite-plugin-vue-inspector&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; defineConfig({&lt;br/&gt;  &lt;span&gt;plugins&lt;/span&gt;: [&lt;br/&gt;    createVuePlugin(),&lt;br/&gt;    Inspector({&lt;br/&gt;      &lt;span&gt;vue&lt;/span&gt;: &lt;span&gt;2&lt;/span&gt;,&lt;br/&gt;    }),&lt;br/&gt;  ],&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Vue3&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// vite.config.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { defineConfig } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vite&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Vue &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@vitejs/plugin-vue&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; Inspector &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;vite-plugin-vue-inspector&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; defineConfig({&lt;br/&gt;  &lt;span&gt;plugins&lt;/span&gt;: [Vue(), Inspector()],&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IDE也要进行配置,这里就不啰嗦了, 👉 传送门.&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实现思路&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里,如果你觉得这个插件索然无味的话先别跑,插件没意思,看看怎么写插件还是有点意思的嘛 ! 接下来跟大家介绍一下这个插件的实现思路.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来分析一下实现这个功能我们需要有哪些元素 :&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Open IDE&lt;/code&gt;: 打开编辑器功能.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Web&lt;/code&gt;层: 提供该功能所需的页面元素及交互功能.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Server&lt;/code&gt;层: 用户交互时传递数据到&lt;code&gt;Server&lt;/code&gt;层,由&lt;code&gt;Server&lt;/code&gt;层调用&lt;code&gt;Open IDE&lt;/code&gt;功能.&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;DOM&lt;/code&gt;=&amp;gt;&lt;code&gt;Vue SFC&lt;/code&gt;映射关系: 告诉&lt;code&gt;OPen IDE&lt;/code&gt;打开哪个文件并定位到对应的行列.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;明确我们需要什么元素,我们就可以进一步来梳理它的实现方式,直接晒图:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5165343915343915&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/C527icpHV4scIEXR8hD9fQ2401ac7wqYtVUfeYYjoNW50HDUBy9vCUVmyxUzkajVXjQlNGqqSjc2kIQsTs5UVQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1512&quot;/&gt;&lt;figcaption&gt;vite-plugin-step.drawio (2).png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实现细节&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来,我们来看具体的实现细节.在这之前,我们先简单看下我们需要用到的几个Vite插件API:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;VitePluginInspector&lt;/span&gt;(&lt;span/&gt;): &lt;span&gt;Plugin&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    name: &lt;span&gt;&quot;vite-plugin-vue-inspector&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;// 应用顺序&lt;/span&gt;&lt;br/&gt;    enforce: &lt;span&gt;&quot;pre&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;// 应用模式 (只在开发模式应用)&lt;/span&gt;&lt;br/&gt;    apply: &lt;span&gt;&quot;serve&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;// 含义: 转换钩子,接收每个传入请求模块的内容和文件路径&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 应用: 在这个钩子对SFC模版进行解析并注入自定义属性&lt;/span&gt;&lt;br/&gt;    transform(code, id) {&lt;br/&gt;&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;// 含义: 配置开发服务器钩子,可以添加自定义中间件&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 应用: 在这个钩子实现Open Editor调用服务&lt;/span&gt;&lt;br/&gt;    configureServer(server) {&lt;br/&gt;&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;// 含义: 转换index.html的专用钩子,接收当前HTML字符串和转换上下文&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 应用: 在这个钩子注入交互功能&lt;/span&gt;&lt;br/&gt;    transformIndexHtml(html) {&lt;br/&gt;&lt;br/&gt;    },&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解析SFC模版 &amp;amp; 注入自定义属性&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这部分的实现主要分为两步:&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;SFC Template&lt;/code&gt; =&amp;gt; &lt;code&gt;AST&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;获取元素所在组件的行和列的编号&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;获取自定义属性插入的位置&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;注入自定义属性&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;file (SFC路径,用于跳转到指定文件)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;line (元素所在行编号,用于跳转到指定行)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;column (元素所在列编号,用于跳转到指定列)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;title (SFC名称,用于展示)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;// vite.config.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;VitePluginInspector&lt;/span&gt;(&lt;span/&gt;): &lt;span&gt;Plugin&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    name: &lt;span&gt;&quot;vite-plugin-vue-inspector&quot;&lt;/span&gt;,&lt;br/&gt;    transform(code, id) {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; { filename, query } = parseVueRequest(id)&lt;br/&gt;      &lt;span&gt;// 只处理SFC文件&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (filename.endsWith(&lt;span&gt;&quot;.vue&quot;&lt;/span&gt;) &amp;amp;&amp;amp; query.type !== &lt;span&gt;&quot;style&quot;&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; compileSFCTemplate(code, filename)&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; code&lt;br/&gt;    },&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;// compiler.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; path &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;path&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; MagicString &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;magic-string&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; { parse, transform } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&quot;@vue/compiler-dom&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; EXCLUDE_TAG = [&lt;span&gt;&quot;template&quot;&lt;/span&gt;, &lt;span&gt;&quot;script&quot;&lt;/span&gt;, &lt;span&gt;&quot;style&quot;&lt;/span&gt;]&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;compileSFCTemplate&lt;/span&gt;(&lt;span&gt;&lt;br/&gt;  code: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;  id: &lt;span&gt;string&lt;/span&gt;,&lt;br/&gt;&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// MagicString是一个非常好用的字符串操作库,也如它的名字一样,非常的神奇 !&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 有了它,我们可以直接操作字符串,避免操作AST,换来更好的性能. Vue3的实现也大量的用到了它.&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; s = &lt;span&gt;new&lt;/span&gt; MagicString(code)&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;// SFC =&amp;gt; AST&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; ast = parse(code, { comments: &lt;span&gt;true&lt;/span&gt; })&lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Promise&lt;/span&gt;(&lt;span&gt;(&lt;span&gt;resolve&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    transform(ast, {&lt;br/&gt;      &lt;span&gt;// ast node节点访问器&lt;/span&gt;&lt;br/&gt;      nodeTransforms: [&lt;br/&gt;        &lt;span&gt;(&lt;span&gt;node&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;          &lt;span&gt;if&lt;/span&gt; (node.type === &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;           &lt;span&gt;// 只解析html标签 &lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (node.tagType === &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; !EXCLUDE_TAG.includes(node.tag)) {&lt;br/&gt;              &lt;span&gt;const&lt;/span&gt; { base } = path.parse(id)&lt;br/&gt;              &lt;span&gt;// 获取到相关信息,并进行自定义属性注入&lt;/span&gt;&lt;br/&gt;              !node.loc.source.includes(&lt;span&gt;&quot;data-v-inspecotr-file&quot;&lt;/span&gt;)&lt;br/&gt;                &amp;amp;&amp;amp; s.prependLeft(&lt;br/&gt;                  node.loc.start.offset + node.tag.length + &lt;span&gt;1&lt;/span&gt;,&lt;br/&gt;                  &lt;span&gt;` data-v-inspecotr-file=&quot;&lt;span&gt;${id}&lt;/span&gt;&quot; data-v-inspecotr-line=&lt;span&gt;${node.loc.start.line}&lt;/span&gt; data-v-inspecotr-column=&lt;span&gt;${node.loc.start.column}&lt;/span&gt; data-v-inspecotr-title=&quot;&lt;span&gt;${base}&lt;/span&gt;&quot;`&lt;/span&gt;,&lt;br/&gt;                )&lt;br/&gt;            }&lt;br/&gt;          }&lt;br/&gt;        },&lt;br/&gt;      ],&lt;br/&gt;    })&lt;br/&gt;    resolve(s.toString())&lt;br/&gt;  })&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; result&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注入后的&lt;code&gt;DOM元素&lt;/code&gt;长这样 :&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;h3&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;data-v-inspector-file&lt;/span&gt;=&lt;span&gt;&quot;/xxx/src/Hi.vue&quot;&lt;/span&gt;   &lt;br/&gt;    &lt;span&gt;data-v-inspector-line&lt;/span&gt;=&lt;span&gt;&quot;3&quot;&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;data-v-inspector-column&lt;/span&gt;=&lt;span&gt;&quot;5&quot;&lt;/span&gt; &lt;br/&gt;    &lt;span&gt;data-v-inspector-title&lt;/span&gt;=&lt;span&gt;&quot;Hi.vue&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;h3&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Open Editor Server服务&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们提到了创建Server服务的思路是在vite的&lt;code&gt;configureServer&lt;/code&gt;的钩子函数注入中间件:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;// vite.config.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;VitePluginInspector&lt;/span&gt;(&lt;span/&gt;): &lt;span&gt;Plugin&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    name: &lt;span&gt;&quot;vite-plugin-vue-inspector&quot;&lt;/span&gt;,&lt;br/&gt;    configureServer(server) {&lt;br/&gt;      &lt;span&gt;// 注册中间件&lt;/span&gt;&lt;br/&gt;      &lt;br/&gt;      &lt;span&gt;// 请求Query参数解析中间件 &lt;/span&gt;&lt;br/&gt;      server.middlewares.use(queryParserMiddleware)&lt;br/&gt;      &lt;span&gt;// Open Edito服务中间件&lt;/span&gt;&lt;br/&gt;      server.middlewares.use(launchEditorMiddleware)&lt;br/&gt;    },&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// middleware.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 请求Query参数解析中间件 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; queryParserMiddleware: Connect.NextHandleFunction = (&lt;br/&gt;  req: RequestMessage &amp;amp; {query?: object},&lt;br/&gt;  _,&lt;br/&gt;  next,&lt;br/&gt;) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!req.query &amp;amp;&amp;amp; req.url?.startsWith(SERVER_URL)) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; url = &lt;span&gt;new&lt;/span&gt; URL(req.url, &lt;span&gt;&quot;http://domain.inspector&quot;&lt;/span&gt;)&lt;br/&gt;    req.query = &lt;span&gt;Object&lt;/span&gt;.fromEntries(url.searchParams.entries())&lt;br/&gt;  }&lt;br/&gt;  next()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Open Editor服务中间件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; launchEditorMiddleware: Connect.NextHandleFunction = (&lt;br/&gt;  req: RequestMessage &amp;amp; {&lt;br/&gt;    query?: { line: &lt;span&gt;number&lt;/span&gt;; column: &lt;span&gt;number&lt;/span&gt;; file: &lt;span&gt;string&lt;/span&gt; }&lt;br/&gt;  },&lt;br/&gt;  res,&lt;br/&gt;  next,&lt;br/&gt;) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;// 只处理Open Editor接口&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (req.url.startsWith(SERVER_URL)) {&lt;br/&gt;    &lt;span&gt;// 解析SFC路径,行号,列号&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; { file, line, column } = req.query&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!file) {&lt;br/&gt;      res.statusCode = &lt;span&gt;500&lt;/span&gt;&lt;br/&gt;      res.end(&lt;span&gt;&quot;launch-editor-middleware: required query param \&quot;file\&quot; is missing.&quot;&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; lineNumber = +line || &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; columnNumber = +column || &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;// 见下方链接&lt;/span&gt;&lt;br/&gt;    launchEditor(file, lineNumber, columnNumber)&lt;br/&gt;    res.end()&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    next()&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于&lt;code&gt;launchEditor&lt;/code&gt;的具体逻辑我直接fork了react-dev-utils的实现,它支持很多IDE (&lt;code&gt;vscode&lt;/code&gt;,&lt;code&gt;atom&lt;/code&gt;,&lt;code&gt;webstorm&lt;/code&gt;...),它的大致原理就是通过维护一些进程映射表和环境变量,然后通过调用&lt;code&gt;Node.js&lt;/code&gt;的子进程唤醒IDE:&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;child_process.spawn(editor, args, { &lt;span&gt;stdio&lt;/span&gt;: &lt;span&gt;&#x27;inherit&#x27;&lt;/span&gt; });&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;交互功能注入&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个功能的实现原理其实就在&lt;code&gt;transformIndexHtml&lt;/code&gt;注入功能所需要的&lt;code&gt;html,scripts,styles&lt;/code&gt;.&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// vite.config.ts&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;VitePluginInspector&lt;/span&gt;(&lt;span/&gt;): &lt;span&gt;Plugin&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    transformIndexHtml(html) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;            html,&lt;br/&gt;            tags: [{&lt;br/&gt;              tag: &lt;span&gt;&quot;script&quot;&lt;/span&gt;,&lt;br/&gt;              children: ...,&lt;br/&gt;              injectTo: &lt;span&gt;&quot;body&quot;&lt;/span&gt;,&lt;br/&gt;            }, {&lt;br/&gt;              tag: &lt;span&gt;&quot;script&quot;&lt;/span&gt;,&lt;br/&gt;              attrs: {&lt;br/&gt;                &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&quot;module&quot;&lt;/span&gt;,&lt;br/&gt;              },&lt;br/&gt;              children: scripts,&lt;br/&gt;              injectTo: &lt;span&gt;&quot;body&quot;&lt;/span&gt;,&lt;br/&gt;            }, {&lt;br/&gt;              tag: &lt;span&gt;&quot;style&quot;&lt;/span&gt;,&lt;br/&gt;              children: styles,&lt;br/&gt;              injectTo: &lt;span&gt;&quot;head&quot;&lt;/span&gt;,&lt;br/&gt;            }],&lt;br/&gt;          }&lt;br/&gt;       }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于交互的页面实现有很多种,最简单的无非就是编写原生&lt;code&gt;js&lt;/code&gt;,这样我们无需任何编译就可以直接注入到&lt;code&gt;html&lt;/code&gt;中,但是用原生&lt;code&gt;js&lt;/code&gt;来写页面真的是慢又不好维护,于是我选择了&lt;code&gt;Vue&lt;/code&gt;进行开发,使用&lt;code&gt;Vue&lt;/code&gt;就意味着要进行编译才能在浏览器中跑起来.为了这个所谓的研发体验,又折腾了一波,大概过程就是通过&lt;code&gt;compile-sfc&lt;/code&gt;等包编译出&lt;code&gt;render函数,样式代码等&lt;/code&gt;,为了兼容&lt;code&gt;Vue2&lt;/code&gt;,我又引入了祖传的&lt;code&gt;vue-template-compiler&lt;/code&gt;...噼里啪啦噼里啪啦..感兴趣的童鞋可以点传送门详看. (u1s1,还是有点意思的!!) 当然了,这部分的编译都是在插件打包时完成的,用户在使用插件的时候并不会有这部分的运行时开销.&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;致谢&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个项目的灵感来自于react-dev-inspector,使用&lt;code&gt;React&lt;/code&gt;的童鞋可以看看.&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;结语&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在做这个插件的时候也踩了一些坑,通过查看&lt;code&gt;vue,vite&lt;/code&gt;等源码排查解决.这里给想看源码的童鞋一个建议,从实践和带着问题的角度出发,也许会有更好的效果和更深刻的印象 (&lt;span&gt;教训&lt;/span&gt;) :)&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>148eecfdee223623d0ac61f83b40cf69</guid>
<title>Go 泛型基准测试：性能更差还是更好？</title>
<link>https://toutiao.io/k/zql4z5a</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go1.18 已经发布了，泛型终于正式进入了 Go 语言。那泛型将如何影响性能？让我们通过对几个用例进行基准测试来弄清楚。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jdTRWcqrowRyLufWr2fIj8yBoMct1hLa2NwjNoeNXrmrxD7ded2HibITR2VvB5rYg8DNnibFjDAPGIx0Im8WlX1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;图片由 Percy Bolmér 拍摄。Takuya Ueda 的 Gopher，Renée French 的原创 Go Gopher（CC BY 3.0）&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于 Go1.18 新特性的文章有很多，讨论也不少。其中一个讨论是我想写的一个主题，即泛型对性能有什么影响？许多读者担心泛型会降低性能，但我的观点是泛型会提高性能。我的观点背后的原因是泛型将允许我们在运行时跳过类型转换、断言和反射，而是依赖编译器在编译时决定这个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我关于&lt;span&gt;学习泛型&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;的文章中，我解释了泛型的用法，两个主要好处是减少了基于数据类型的重复函数并避免了&lt;code&gt;interface{}&lt;/code&gt;. 这些是我们将在本文中进行基准测试的用例，以发现更改的性能。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;说明下：我不是基准测试专家。我只是一个基准测试菜鸟。在我看来，基准测试非常困难。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了做出公平的基准测试，我们将为每个用例设置一个测试用例。这将意味着我们将&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;使用重复函数进行基准测试&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用泛型进行基准测试&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用使用 &lt;code&gt;interface{}&lt;/code&gt; 进行基准测试&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;准备函数进行基准测试&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们将重用&lt;span&gt;学习泛型&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;中的一些代码，在其中，我们有一个&lt;code&gt;Subtract&lt;/code&gt;函数可以减去三种&lt;code&gt;Subtractable&lt;/code&gt;数据类型之间的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们将要确定哪些 Subtract 方法性能最好。可以在 &lt;span&gt;Playground&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt; 尝试一下。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; functions&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Subtract will subtract the second value from the first&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;SubtractInt&lt;/span&gt;&lt;span&gt;(a, b &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; a - b&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Subtract64 will subtract the second value from the first&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;SubtractInt64&lt;/span&gt;&lt;span&gt;(a, b &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; a - b&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// SubtractFloat32 will subtract the second value from the first&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;SubtractFloat32&lt;/span&gt;&lt;span&gt;(a, b &lt;span&gt;float32&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;float32&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; a - b&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// SubtractTypeSwitch is used to subtract using interfaces&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;SubtractTypeSwitch&lt;/span&gt;&lt;span&gt;(a, b &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;/span&gt;{} {&lt;br/&gt; &lt;span&gt;switch&lt;/span&gt; a.(&lt;span&gt;type&lt;/span&gt;) {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; a.(&lt;span&gt;int&lt;/span&gt;) - b.(&lt;span&gt;int&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; a.(&lt;span&gt;int64&lt;/span&gt;) - b.(&lt;span&gt;int64&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; &lt;span&gt;float32&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; a.(&lt;span&gt;float32&lt;/span&gt;) - b.(&lt;span&gt;float32&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Subtract will subtract the second value from the first&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Subtract&lt;/span&gt;[&lt;span&gt;V&lt;/span&gt; &lt;span&gt;int64&lt;/span&gt; | &lt;span&gt;int&lt;/span&gt; | &lt;span&gt;float32&lt;/span&gt;]&lt;span&gt;(a, b V &quot;V &lt;span&gt;int64&lt;/span&gt; | &lt;span&gt;int&lt;/span&gt; | &lt;span&gt;float32&lt;/span&gt;&quot;)&lt;/span&gt; &lt;span&gt;V&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; a - b&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在那里，我们将开始对功能进行基准测试。它们应该相当容易理解，并且我们涵盖了减法、基于数据类型、类型切换和泛型的可能解决方案。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;准备基准测试&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个常规的测试文件，我们可以在其中存储基准，如果你熟悉 Go 中的基准，你可以阅读这里的&lt;span&gt;教程&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在基准测试的顶部，我将生成两个切片，一个随机整数切片，一个随机 float32 切片。这些随机切片将用作减法方法的输入参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们创建一个&lt;code&gt;b.Run&lt;/code&gt;函数，它会一次触发一个函数，次数与我们设置为基准测试器的次数一样多，使用&lt;code&gt;-benchtime&lt;/code&gt;标志运行。对于这个基准测试，我将强制基准测试器运行每个函数 1000000000 次。如果你未指定运行函数的次数，则基准测试程序会在特定时间内尽可能多次地运行该函数。这将以它们没有运行相同数量的操作而告终，我希望它们这样做。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是我最终的基准测试的样子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于执行基准测试以确定泛型性能影响的测试文件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; functions&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;math/rand&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;testing&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;span&gt;// Benchmark_Subtract is used to determine the most performant solution to subtraction&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Benchmark_Subtract&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// Create a slice of random numbers based on the number of iterations set&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// to test the performance of the function&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// Default iterations for me is 1000000000&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// b.N is always 1 so we can use that to set the number of iterations&lt;/span&gt;&lt;br/&gt; numbers := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;1000000001&lt;/span&gt;)&lt;br/&gt; floatNumbers := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;float32&lt;/span&gt;, &lt;span&gt;1000000001&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;// Create a random seed&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; seed := rand.NewSource(time.Now().UnixNano())&lt;br/&gt; &lt;span&gt;// Give the seed to the random package&lt;/span&gt;&lt;br/&gt; randomizer := rand.New(seed)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;// randomize numbers between 0-100&lt;/span&gt;&lt;br/&gt;  numbers[i] = randomizer.Intn(&lt;span&gt;100&lt;/span&gt;)&lt;br/&gt;  floatNumbers[i] = &lt;span&gt;float32&lt;/span&gt;(randomizer.Intn(&lt;span&gt;100&lt;/span&gt;))&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// run a benchmark for regular Ints&lt;/span&gt;&lt;br/&gt; b.Run(&lt;span&gt;&quot;SubtractInt&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;   SubtractInt(numbers[i], numbers[i+&lt;span&gt;1&lt;/span&gt;])&lt;br/&gt;  }&lt;br/&gt; })&lt;br/&gt; &lt;span&gt;// run a benchmark for regular Floats&lt;/span&gt;&lt;br/&gt; b.Run(&lt;span&gt;&quot;SubtractFloat&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;   SubtractFloat32(floatNumbers[i], floatNumbers[i+&lt;span&gt;1&lt;/span&gt;])&lt;br/&gt;  }&lt;br/&gt; })&lt;br/&gt; &lt;span&gt;// run a benchmark for TypeSwitched Ints&lt;/span&gt;&lt;br/&gt; b.Run(&lt;span&gt;&quot;Type_Subtraction_int&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;   SubtractTypeSwitch(numbers[i], numbers[i+&lt;span&gt;1&lt;/span&gt;])&lt;br/&gt;  }&lt;br/&gt; })&lt;br/&gt; &lt;span&gt;// run a benchmark for TypeSwitched Floats&lt;/span&gt;&lt;br/&gt; b.Run(&lt;span&gt;&quot;Type_Subtraction_float&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;   SubtractTypeSwitch(floatNumbers[i], floatNumbers[i+&lt;span&gt;1&lt;/span&gt;])&lt;br/&gt;  }&lt;br/&gt; })&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// run a benchmark for Generic Ints&lt;/span&gt;&lt;br/&gt; b.Run(&lt;span&gt;&quot;Generic_Subtraction_int&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;   Subtract[&lt;span&gt;int&lt;/span&gt;](numbers[i], numbers[i+&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;&quot;int&quot;&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt; })&lt;br/&gt; &lt;span&gt;// run a benchmark for Generic Floats&lt;/span&gt;&lt;br/&gt; b.Run(&lt;span&gt;&quot;Generic_Subtraction_float&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;   Subtract[&lt;span&gt;float32&lt;/span&gt;](floatNumbers[i], floatNumbers[i+&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;&quot;float32&quot;&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt; })&lt;br/&gt; &lt;span&gt;// run a benchmark where generic type is infered&lt;/span&gt;&lt;br/&gt; b.Run(&lt;span&gt;&quot;Generic_Inferred_int&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;   Subtract(numbers[i], numbers[i+&lt;span&gt;1&lt;/span&gt;])&lt;br/&gt;  }&lt;br/&gt; })&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在泛型基准测试中，基准测试将测试所有用例中&lt;code&gt;int&lt;/code&gt;和&lt;code&gt;float32&lt;/code&gt;的减法函数，我添加了第三个选项，推断数据类型。我还想确定如果我们让泛型函数将数据类型推断为&lt;code&gt;int&lt;/code&gt;会有怎样的表现.&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要运行基准测试，请使用以下命令。请注意，该&lt;code&gt;-count 5&lt;/code&gt;参数用于将每个基准测试运行 5 次。这是因为如果你运行每个基准测试一次，你可能会得到不公平的结果。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;go &lt;span&gt;test&lt;/span&gt; -v -bench=Benchmark -benchtime=1000000000x -count 5&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分析结果&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基准测试将与正在运行的函数的名称一起输出，我们可以使用它来识别不同的函数。第二个值是运行的操作数，在我们的例子中，我们将其设置为固定数字，因此所有行都应该显示相同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三个输出很有趣，它是每次操作的纳秒数 (ns/op)。这是显示函数平均速度的指标。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 测试工具的基准测试结果。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;goos: windows&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: programmingpercy/benchgeneric&lt;br/&gt;cpu: Intel(R) Core(TM) i7&lt;span&gt;-10750&lt;/span&gt;H CPU @ &lt;span&gt;2.60&lt;/span&gt;GHz&lt;br/&gt;Benchmark_Subtract&lt;br/&gt;Benchmark_Subtract/SubtractInt&lt;br/&gt;Benchmark_Subtract/SubtractInt&lt;span&gt;-4&lt;/span&gt;                &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;0.9002&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/SubtractInt&lt;span&gt;-4&lt;/span&gt;                &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;0.8904&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/SubtractInt&lt;span&gt;-4&lt;/span&gt;                &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;0.8277&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/SubtractInt&lt;span&gt;-4&lt;/span&gt;                &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;0.8290&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/SubtractInt&lt;span&gt;-4&lt;/span&gt;                &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;0.8266&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/SubtractFloat&lt;br/&gt;Benchmark_Subtract/SubtractFloat&lt;span&gt;-4&lt;/span&gt;              &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;0.8591&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/SubtractFloat&lt;span&gt;-4&lt;/span&gt;              &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;0.8033&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/SubtractFloat&lt;span&gt;-4&lt;/span&gt;              &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;0.8108&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/SubtractFloat&lt;span&gt;-4&lt;/span&gt;              &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;0.8168&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/SubtractFloat&lt;span&gt;-4&lt;/span&gt;              &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;0.8040&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/Type_Subtraction_int&lt;br/&gt;Benchmark_Subtract/Type_Subtraction_int&lt;span&gt;-4&lt;/span&gt;               &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;1.597&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/Type_Subtraction_int&lt;span&gt;-4&lt;/span&gt;               &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;1.711&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/Type_Subtraction_int&lt;span&gt;-4&lt;/span&gt;               &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;1.607&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/Type_Subtraction_int&lt;span&gt;-4&lt;/span&gt;               &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;1.570&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/Type_Subtraction_int&lt;span&gt;-4&lt;/span&gt;               &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;1.588&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/Type_Subtraction_float&lt;br/&gt;Benchmark_Subtract/Type_Subtraction_float&lt;span&gt;-4&lt;/span&gt;             &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;1.320&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/Type_Subtraction_float&lt;span&gt;-4&lt;/span&gt;             &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;1.311&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/Type_Subtraction_float&lt;span&gt;-4&lt;/span&gt;             &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;1.323&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/Type_Subtraction_float&lt;span&gt;-4&lt;/span&gt;             &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;1.424&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/Type_Subtraction_float&lt;span&gt;-4&lt;/span&gt;             &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;1.321&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/Generic_Subtraction_int&lt;br/&gt;Benchmark_Subtract/Generic_Subtraction_int&lt;span&gt;-4&lt;/span&gt;            &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;0.8251&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/Generic_Subtraction_int&lt;span&gt;-4&lt;/span&gt;            &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;0.8288&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/Generic_Subtraction_int&lt;span&gt;-4&lt;/span&gt;            &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;0.8420&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/Generic_Subtraction_int&lt;span&gt;-4&lt;/span&gt;            &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;0.8377&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/Generic_Subtraction_int&lt;span&gt;-4&lt;/span&gt;            &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;0.8357&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/Generic_Subtraction_float&lt;br/&gt;Benchmark_Subtract/Generic_Subtraction_float&lt;span&gt;-4&lt;/span&gt;          &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;0.7952&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/Generic_Subtraction_float&lt;span&gt;-4&lt;/span&gt;          &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;0.7987&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/Generic_Subtraction_float&lt;span&gt;-4&lt;/span&gt;          &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;0.7877&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/Generic_Subtraction_float&lt;span&gt;-4&lt;/span&gt;          &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;0.8037&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/Generic_Subtraction_float&lt;span&gt;-4&lt;/span&gt;          &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;0.8283&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/Generic_Inferred_int&lt;br/&gt;Benchmark_Subtract/Generic_Inferred_int&lt;span&gt;-4&lt;/span&gt;               &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;0.8297&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/Generic_Inferred_int&lt;span&gt;-4&lt;/span&gt;               &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;0.8283&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/Generic_Inferred_int&lt;span&gt;-4&lt;/span&gt;               &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;0.8319&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/Generic_Inferred_int&lt;span&gt;-4&lt;/span&gt;               &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;0.8366&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Subtract/Generic_Inferred_int&lt;span&gt;-4&lt;/span&gt;               &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;0.8623&lt;/span&gt; ns/op&lt;br/&gt;PASS&lt;br/&gt;ok      programmingpercy/benchgeneric   &lt;span&gt;37.114&lt;/span&gt;s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从结果中，我们可以确定类型断言函数要慢得多。它*慢了大约 50-90%*。在这个测试用例中，这似乎很荒谬，因为我们谈论的是半纳秒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;泛型函数的执行与特定于数据类型的函数大致相同，但速度略有提高。速度的这种小幅提高可能是由于我计算机上运行的其他软件。以我的心态，我认为编译器完成其工作后，泛型函数调用应该与常规函数调用相同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以在结果中看到的另一个要点是&lt;code&gt;int&lt;/code&gt;减法比&lt;code&gt;float32&lt;/code&gt;减法更耗时。常规&lt;code&gt;int&lt;/code&gt;减法的平均速度为 &lt;em&gt;0,85478 ns/op&lt;/em&gt;，常规&lt;code&gt;float32&lt;/code&gt;减法的平均速度为&lt;em&gt;0,8188 ns/op&lt;/em&gt;。这意味着在我的基准测试中，&lt;code&gt;float32&lt;/code&gt;减法大约快 &lt;em&gt;5%&lt;/em&gt; 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，该基准的关键要点是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;根据我的观点，类型断言/类型转换解决方案最慢&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;泛型和常规数据类型函数的性能相同&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Float32&lt;/code&gt;减法比&lt;code&gt;int&lt;/code&gt;快&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;以真实场景为基准&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们比较一个真实的场景。在用例中，我们有两个有 Move 的结构&lt;code&gt;Person&lt;/code&gt;，&lt;code&gt;Car&lt;/code&gt;。这两个结构都有一个&lt;code&gt;Move&lt;/code&gt;接受距离的函数，但是，Person 距离被传递为&lt;code&gt;float32&lt;/code&gt; 而 Car 接受一个&lt;code&gt;int&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这两种结构都在同一个工作流中处理，因此我们希望在同一个函数中处理它们。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对此的泛型解决方案是创建泛型结构，我们可以在其中定义要在创建时使用的数据类型。接口解决方案是接受结构作为输入，并对它们进行类型断言并转换正确的数据类型。我们不能为它们提供共享接口，因为数据类型不一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在代码示例中，有一个泛型和旧类型断言解决方案的实现，类型断言带有后缀&lt;code&gt;Regular&lt;/code&gt;，因此我们可以更容易地知道什么与什么解决方案相关。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在具有不同数据类型的Cars和Persons 上执行 Move 的泛型解决方案。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; benchmarking&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Subtractable is a type constraint that defines subtractable datatypes to be used in generic functions&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Subtractable &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;int&lt;/span&gt; | &lt;span&gt;int64&lt;/span&gt; | &lt;span&gt;float32&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// Moveable is the interace for moving a Entity&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Moveable[S Subtractable] &lt;span&gt;interface&lt;/span&gt; {&lt;br/&gt; Move(S)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Car is a Generic Struct with the type S to be defined&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Car[S Subtractable] &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Name &lt;span&gt;string&lt;/span&gt;&lt;br/&gt; DistanceMoved S&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Person is a Generic Struct with the type S to be defined&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Person[S Subtractable] &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Name &lt;span&gt;string&lt;/span&gt;&lt;br/&gt; DistanceMoved S&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Person is a struct that accepts a type definition at initialization&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// And uses that Type as the data type for meters as input&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(p *Person[S])&lt;/span&gt; &lt;span&gt;Move&lt;/span&gt;&lt;span&gt;(meters S)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; p.DistanceMoved += meters&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Car[S])&lt;/span&gt; &lt;span&gt;Move&lt;/span&gt;&lt;span&gt;(meters S)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; c.DistanceMoved += meters&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Move is a generic function that takes in a Generic Moveable and moves it&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Move&lt;/span&gt;[&lt;span&gt;S&lt;/span&gt; &lt;span&gt;Subtractable&lt;/span&gt;, &lt;span&gt;V&lt;/span&gt; &lt;span&gt;Moveable&lt;/span&gt;[&lt;span&gt;S&lt;/span&gt;]]&lt;span&gt;(v V, meters S &quot;S Subtractable, V Moveable[S]&quot;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; v.Move(meters)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类型断言方案的 Move：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; benchmarking&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Below is the Type casting based Solution&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; CarRegular &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Name          &lt;span&gt;string&lt;/span&gt;&lt;br/&gt; DistanceMoved &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; PersonRegular &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Name          &lt;span&gt;string&lt;/span&gt;&lt;br/&gt; DistanceMoved &lt;span&gt;float32&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(p *PersonRegular)&lt;/span&gt; &lt;span&gt;Move&lt;/span&gt;&lt;span&gt;(meters &lt;span&gt;float32&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; p.DistanceMoved += meters&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *CarRegular)&lt;/span&gt; &lt;span&gt;Move&lt;/span&gt;&lt;span&gt;(meters &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; c.DistanceMoved += meters&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;MoveRegular&lt;/span&gt;&lt;span&gt;(v &lt;span&gt;interface&lt;/span&gt;{}, distance &lt;span&gt;float32&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;switch&lt;/span&gt; v.(&lt;span&gt;type&lt;/span&gt;) {&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; *PersonRegular:&lt;br/&gt;  v.(*PersonRegular).Move(distance)&lt;br/&gt; &lt;span&gt;case&lt;/span&gt; *CarRegular:&lt;br/&gt;  v.(*CarRegular).Move(&lt;span&gt;int&lt;/span&gt;(distance))&lt;br/&gt; &lt;span&gt;default&lt;/span&gt;:&lt;br/&gt;  &lt;span&gt;// Handle Unsupported types, not needed by Generic solution as Compiler does this for you&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们已经有了解决方案，是时候开始基准测试了。我将在基准测试之前创建 Persons 和 Cars，我们将测量&lt;code&gt;Move&lt;/code&gt; 和&lt;code&gt;MoveRegular&lt;/code&gt; 的性能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; benchmarking&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;testing&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Benchmark_Structures&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// Init the structs&lt;/span&gt;&lt;br/&gt; p := &amp;amp;Person[&lt;span&gt;float32&lt;/span&gt;]{Name: &lt;span&gt;&quot;John&quot;&lt;/span&gt;}&lt;br/&gt; c := &amp;amp;Car[&lt;span&gt;int&lt;/span&gt;]{Name: &lt;span&gt;&quot;Ferrari&quot;&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt; pRegular := &amp;amp;PersonRegular{Name: &lt;span&gt;&quot;John&quot;&lt;/span&gt;}&lt;br/&gt; cRegular := &amp;amp;CarRegular{Name: &lt;span&gt;&quot;Ferrari&quot;&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// Run the test&lt;/span&gt;&lt;br/&gt; b.Run(&lt;span&gt;&quot;Person_Generic_Move&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;   &lt;span&gt;// generic will try to use float64 if we dont tell it is a float32&lt;/span&gt;&lt;br/&gt;   Move[&lt;span&gt;float32&lt;/span&gt;](p, &lt;span&gt;10.2&lt;/span&gt; &lt;span&gt;&quot;float32&quot;&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt; })&lt;br/&gt;&lt;br/&gt; b.Run(&lt;span&gt;&quot;Car_Generic_Move&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;   Move(c, &lt;span&gt;10&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt; })&lt;br/&gt;&lt;br/&gt; b.Run(&lt;span&gt;&quot;Person_Regular_Move&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;   MoveRegular(pRegular, &lt;span&gt;10.2&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt; })&lt;br/&gt;&lt;br/&gt; b.Run(&lt;span&gt;&quot;Car_Regular_Move&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;   MoveRegular(cRegular, &lt;span&gt;10&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt; })&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我使用以下命令运行测试&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;go &lt;span&gt;test&lt;/span&gt; -v -bench=Benchmark_Structures -benchtime=1000000000x -count 5&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行基准测试的结果&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;goos: windows&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: programmingpercy/benchgeneric&lt;br/&gt;cpu: Intel(R) Core(TM) i7&lt;span&gt;-10750&lt;/span&gt;H CPU @ &lt;span&gt;2.60&lt;/span&gt;GHz&lt;br/&gt;Benchmark_Structures&lt;br/&gt;Benchmark_Structures/Person_Generic_Move&lt;br/&gt;Benchmark_Structures/Person_Generic_Move&lt;span&gt;-4&lt;/span&gt;              &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;4.690&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Structures/Person_Generic_Move&lt;span&gt;-4&lt;/span&gt;              &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;4.668&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Structures/Person_Generic_Move&lt;span&gt;-4&lt;/span&gt;              &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;4.727&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Structures/Person_Generic_Move&lt;span&gt;-4&lt;/span&gt;              &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;4.664&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Structures/Person_Generic_Move&lt;span&gt;-4&lt;/span&gt;              &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;4.699&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Structures/Car_Generic_Move&lt;br/&gt;Benchmark_Structures/Car_Generic_Move&lt;span&gt;-4&lt;/span&gt;                 &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;3.176&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Structures/Car_Generic_Move&lt;span&gt;-4&lt;/span&gt;                 &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;3.188&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Structures/Car_Generic_Move&lt;span&gt;-4&lt;/span&gt;                 &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;3.296&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Structures/Car_Generic_Move&lt;span&gt;-4&lt;/span&gt;                 &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;3.144&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Structures/Car_Generic_Move&lt;span&gt;-4&lt;/span&gt;                 &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;3.156&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Structures/Person_Regular_Move&lt;br/&gt;Benchmark_Structures/Person_Regular_Move&lt;span&gt;-4&lt;/span&gt;              &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;4.694&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Structures/Person_Regular_Move&lt;span&gt;-4&lt;/span&gt;              &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;4.634&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Structures/Person_Regular_Move&lt;span&gt;-4&lt;/span&gt;              &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;4.677&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Structures/Person_Regular_Move&lt;span&gt;-4&lt;/span&gt;              &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;4.660&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Structures/Person_Regular_Move&lt;span&gt;-4&lt;/span&gt;              &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;4.626&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Structures/Car_Regular_Move&lt;br/&gt;Benchmark_Structures/Car_Regular_Move&lt;span&gt;-4&lt;/span&gt;                 &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;2.560&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Structures/Car_Regular_Move&lt;span&gt;-4&lt;/span&gt;                 &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;2.555&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Structures/Car_Regular_Move&lt;span&gt;-4&lt;/span&gt;                 &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;2.553&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Structures/Car_Regular_Move&lt;span&gt;-4&lt;/span&gt;                 &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;2.579&lt;/span&gt; ns/op&lt;br/&gt;Benchmark_Structures/Car_Regular_Move&lt;span&gt;-4&lt;/span&gt;                 &lt;span&gt;1000000000&lt;/span&gt;               &lt;span&gt;2.560&lt;/span&gt; ns/op&lt;br/&gt;PASS&lt;br/&gt;ok      programmingpercy/benchgeneric   &lt;span&gt;75.830&lt;/span&gt;s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到类型断言解决方案比泛型解决方案更快，我有点惊讶。我确保多次运行的基准测试，它不是偶然的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以从基准中看到，基于 Cars 的 &lt;code&gt;Int&lt;/code&gt; 解决方案都比基于 Person 的 &lt;code&gt;float32&lt;/code&gt; 的更快。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Person&lt;/code&gt; move 方法具有相同的性能，无论是泛型解决方案还是常规解决方案。但是，你可以看到 Cars 的不同之处，类型断言的 Cars 是最快的。类型断言执行比泛型快 20%。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，该基准的关键要点如下。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;基于浮点的类型具有相同的性能，而类型断言的整数 cars 速度更快，这不是我的观点&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Float32&lt;/code&gt; 加法比 &lt;code&gt;int&lt;/code&gt; 慢&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;结论&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我们现在已经测试了一些我可以看到泛型有用的用例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老实说，我确实希望第二个基准也能证明泛型更快。这将进一步证明我的说法，即泛型由于是在编译时而不是运行时决定的，因此性能更高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过使用泛型或特定于数据类型的函数，我们可以在第一个用例中看到相当大的性能提升。我知道几纳秒可能看起来很荒谬，但是在某些用例中，这些类型的极端优化很重要。我曾经做过一个高性能的网络嗅探器，它必须实时处理大量的网络数据。编写这样的软件将需要所有的优化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们已经看到，选择正确的数据类型会对性能产生很大影响。但是，我认为我们可以说，那些表示担心泛型会拖慢软件速度的读者可以冷静下来。从好的方面来说，我看到泛型解决方案允许我们更轻松地交换数据类型，从而提高性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一方面，Go 中的类型断言和类型转换似乎具有超强的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正如我们所看到的，许多因素都会对结果产生影响，例如使用的&lt;span&gt;算术运算符&lt;/span&gt;&lt;sup&gt;[5]&lt;/sup&gt;、数据类型等。在我的基准测试中可能会出现我不知道的错误。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原文链接：https://programmingpercy.tech/blog/benchmarking-generics-in-go&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;学习泛型: &lt;span&gt;https://programmingpercy.tech/blog/learning-generics-in-go&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;学习泛型: &lt;span&gt;https://programmingpercy.tech/blog/learning-generics-in-go&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;Playground: &lt;span&gt;https://go.dev/play/p/BLU8pHOzmvS&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;教程: &lt;span&gt;https://betterprogramming.pub/we-measure-the-power-of-cars-computers-and-cellphones-but-what-about-code-91ed5583f298&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;p&gt;算术运算符: &lt;span&gt;https://www.techopedia.com/definition/25582/arithmetic-operator&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>