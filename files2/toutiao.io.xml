<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>078c622dcd1a25c5de0fe52487109072</guid>
<title>技术方案设计的方法</title>
<link>https://toutiao.io/k/jc76sul</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;前段时间接手了一个还处于方案设计阶段的工作，我重新做了设计。觉得新方案比旧方案业务清晰明朗、解决了旧方案的缺陷。我就很高兴，跟同事聊这个事情。同事就问我是怎么想到这些的呢。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我说了一些细节的，但是没有把核心本质讲出来。我觉得这是个很难回答的问题。因为一个方案怎么更合适，主要因素包含业务理解、个人经验、思维逻辑。这3个要素一般都是靠经年累月的积累才获得的。从这些中提取出别人可以学习和使用的方法确实不是一会儿就能想出来的事情。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;市面上可以看到的关于技术方案设计的经典的书都没有仔细的去讲这个问题。比如《人月神话》讲的是项目大了怎么办、《架构即未来》讲的是架构扩展性的问题。那对于最普通的CURD(创建更新读取删除)系统究竟怎么去设计。都是做CURD的，架构师和普通开发区别在哪里。本文就来探讨一下这个问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;CURD系统怎么做出技术含量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我前几年在面试别人的时候，遇到过一些面试者，已经带领别人做过项目了。可能人家的管理能力是不错的。项目管理是个博大精深的学问，可能一个项目在不同的阶段，更上层会找不同的管理者来做。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;比如初创团队，会找些善于创业、擅长打造敏捷团队的管理者。这样的管理者可能会比较善于鼓舞团队士气。而到了一定阶段，项目业务量起来之后，不再求快，而是求稳。这时候管理者可能会换人，新的管理者做事并不那么快，但是做决策的路很正。路很正怎么理解，打个比方说：别人提了需求，前一个领导人很好，人家来需求他就接。这个领导不是，他会分析利弊和领域、业务是否合适放在这里。再比如更一层领导提了一个需求，要求什么什么时间做完。这个领导会去分析上层领导更本质的需求，宁可延期，要做稳做好。而项目稳定之后，继续稳定下去已经没有什么业绩了。这时候可能会再换领导，这个领导会带来一些原来积累的规划、方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;总之，这个面试者可能有这些能力，但是我们要招聘一个技术人员，先考察硬实力，所以很自然的先请他介绍之前的项目做了什么和怎么做的。他自己也很没底气的说就是CURD嘛。给人感觉就是没有想法，在工作过程中思考的少。&lt;br/&gt;&lt;/p&gt;&lt;p&gt;拿一个后台管理系统来说，要对重要数据进行添加修改删除，一般需要审核、审计，敏感数据脱敏，甚至需要数据灰度。将这整套流程串联起来，需要一个工作流系统，可能会用到工作流引擎。目前有些数据脱敏已经用上了NLP(自然语言处理)技术。这里面每一步都涉及知识点。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据模型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;有限状态机设计&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;刚才提到后台管理系统里用到审核、审计、灰度。这三个可以与业务流程分离，做成三个工具组件。审核有审核状态：审核中、审核成功，审核失败。灰度也有待灰度、灰度中、灰度成功、灰度失败四种状态。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;假如有一条数据，目前它的状态可以分成数据状态：有效数据和无效数据。另外还有审核状态和灰度状态。这时候数据模型(可以简单理解成数据库的数据表设计)应该设计成三个状态用三个数据字段表示呢，还是用一个数据字段来表示这三种状态呢。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这要看情况，一般来说，如果三种状态之前是相互独立的，比如：审核中是否可以待灰度，也可能是灰度中？对于一个工作流系统来说，一般要先审核通过才会进行灰度流程。就是说各个状态是互斥的。所以设计成三个字段，程序的判断逻辑会很复杂，因为有些组合是不成立的。这时候更合理的一个设计是用一个状态字段表示，通过状态机流转来控制。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;设计方案中可以通过类似下面的流转图来体现：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.70917225950783&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8l6wfnRA330O2MsEGAdjo4UXbicbGAk4J6D65icIQOBXJHgzEu9uhZLpcia7DfTnApRXk5qLS2YvWQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;894&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;实际方案设计过程中我改造了一下，状态正常从左到右流转，将终态用不同的形状(这里用椭圆)来表示。这样表示秩序感强些，更好理解。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4270531400966184&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8l6wfnRA330O2MsEGAdjo4CT9KTLDLRCsUYWDb9vHQDW5BhUdnbzQFOpfxcKD33ncHb7KlC14L3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1035&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数据表设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在数据表设计时，要至少考虑数据类型、是否默认、是否为空和索引设计。比如对于钱什么的，需要用decimal(10,2)，具体精确到多少位，要根据业务理解来定。对于加密字符什么的，加密如果是md5的，可以用char，而不用varchar来提高效率。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里面就好像《红楼梦》里的台词一样，每条都很有学问。所以面试时的场景题也经常爱让进行一个数据表设计。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3135646687697161&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8l6wfnRA330O2MsEGAdjo4d6qxbIx3879enMZOOw4MR9HkqIz1geR7iaPxib0txhKKr0qe10WSMW4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1585&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;流程设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我比较建议在一个设计方案开始时先把设计流程图先给出来，便于对方案有个整体认知。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;流程图也很有学问，【亿图】软件上把流程图分成了下面的子类。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.23336006415396954&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8l6wfnRA330O2MsEGAdjo41opFVQ2AJ6KMmQb4o7ic9OehJjEI5jM7e97SAYAXxZPK5nJTzzdMIIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1247&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我个人最常用的是泳道图和BPMN。BPMN可以简单理解为业务流程图和泳道图差别不大。就是在普通流程图基础上增加一个分类，这个分类可以是阶段、也可以是执行者这些。就是给流程图多增加一个维度的信息，理解起来更清晰。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7156511350059738&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8l6wfnRA330O2MsEGAdjo4iagBDgFFPI4dhnUWbtLACSc9Kibofoict49HzaKVv6t97M5m5hnibNc61Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;837&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在设计方案里还必须要有里程碑和未来规划。有句废话叫只怕有心人。在工作中，往往工作出色的并不是最聪明的，也不是花时间最长的。而是真正用心做的人。特别是设计方案，建议多用前人和大家总结的设计模板。模板最能代表一种设计思路。自己想到的、设计模板想到的都要考虑清楚，把方案做细。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;遇到具体的问题，要做业界调研。之前听过一个实习生做的方案，他说业界调研的时候并没有查到特别相关的方案资料。当时我的领导就说了一句特别值得思考的话：如果没有查到，肯定是你的检索关键词不对。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我后来反复斟酌这句话，发现能想到的检索关键词才是真正体现自己对业务理解的。同时，业界调研的时候不仅要对业务相关做调研，需求可以分解，具体到每个步骤也需要调研。调研过程是个极好的学习机会。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下功夫和不下功夫的区别，想想《红楼梦》，之所以这么多红学者。人家红楼梦的作者设计每句话都是剧透，人物说出的话，都会被啪啪打脸。里面的每道菜谱都是值得专业厨师来研究的。这都是心用到了。优秀架构师也是这样炼成的。之所以说这个废话，因为我就被diss过方案做的不够细，我也看过别人的方案不够细的。时常回想被diss不够细的那句话，觉得真的是金玉良言。心怀感激。&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b58c7ce8139ec9b8af0ccf5c01db3415</guid>
<title>设计模式大冒险第一关：观察者模式</title>
<link>https://toutiao.io/k/l6bta2w</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近把之前学习过的这些设计模式又再次温习了一下，觉得还是有很多收获的。确实有了&lt;strong&gt;温故知新&lt;/strong&gt;的感觉，所以准备在每个设计模式复习完之后都能够写一篇关于这个设计模式的文章，这样会让自己能够加深对这个设计模式的理解；也能够跟大家一起来探讨一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们来一起学习一下&lt;strong&gt;观察者模式&lt;/strong&gt;，刚开始我们不需要知道观察者模式的定义是什么，这些我们到后面再去了解。我想先带着大家从生活中的一个小事例开始。&lt;strong&gt;从生活中熟悉的事情入手，会让我们更快速的理解这个模式的用途&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;生活中的小例子&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信大家都关注过一些公众号，&lt;strong&gt;那么对于一个公众号来说，如果有新的文章发布的话；那么所有关注这个公众号的用户都会收到更新的通知，如果一个用户没有关注或者关注后又取消了关注，那么这个用户就不会收到该公众号更新的通知&lt;/strong&gt;。相信这个场景大家都很熟悉吧。那么如果我们把这个过程抽象出来，用代码来实现的话，你会怎么处理呢？不妨现在停下来思考一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的描述，我们知道这是一个&lt;strong&gt;一对多的关系&lt;/strong&gt;。也就是一个公众号对应着许多关注这个公众号的用户。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6748878923766816&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fj9xyC53hPX4W4Sf8cgG3UjicjvVS9QFjWmKMcBqDjHAWDEJe28zaZeiaQibYbUNaM7CIqXOnWwM6SOXFIFrmicIoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;446&quot;/&gt;&lt;figcaption&gt;关注公众号&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么对于这个公众号来说，&lt;strong&gt;它的内部需要有一个列表记录着关注这个公众号的用户&lt;/strong&gt;，一旦公众号有了新的内容。那么对于公众号来说，&lt;strong&gt;它会遍历这个列表。然后给列表中的每一个用户发送一个内容跟新的通知&lt;/strong&gt;。我们可以通过代码来表示这个过程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 用户&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; user = {&lt;br/&gt; update() {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;公众号更新了新的内容&#x27;&lt;/span&gt;);&lt;br/&gt; },&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 公众号&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; officialAccount = {&lt;br/&gt;    &lt;span&gt;// 关注当前公众号的用户列表&lt;/span&gt;&lt;br/&gt; followList: [user],&lt;br/&gt;    &lt;span&gt;// 公众号更新时候调用的通知函数&lt;/span&gt;&lt;br/&gt; notify() {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; len = &lt;span&gt;this&lt;/span&gt;.followList.length;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (len &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;// 通知已关注该公众号的每个用户，有内容更新&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; user &lt;span&gt;of&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.followList) {&lt;br/&gt;    user.update();&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; },&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 公众号有新内容更新&lt;/span&gt;&lt;br/&gt;officialAccount.notify();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行的结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;公众号更新了新的内容&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码能够简单的表示，当公众号的内容发生了更新的时候，去通知关注该公众号的用户的过程。但是这个实现是很简陋的，还缺少一些内容。我们接下来把这些缺少的过程补充完整。&lt;strong&gt;对于公众号来说，还需要可以添加新的关注的用户，移除不再关注的用户，获取关注公众号的用户总数等&lt;/strong&gt;。我们来实现一下上面的过程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 公众号&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; officialAccount = {&lt;br/&gt; &lt;span&gt;// 关注当前公众号的用户列表&lt;/span&gt;&lt;br/&gt; followList: [],&lt;br/&gt; &lt;span&gt;// 公众号更新时候调用的通知函数&lt;/span&gt;&lt;br/&gt; notify() {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; len = &lt;span&gt;this&lt;/span&gt;.followList.length;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (len &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;   &lt;span&gt;// 通知已关注该公众号的每个用户，有内容更新&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; user &lt;span&gt;of&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.followList) {&lt;br/&gt;    user.update();&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; },&lt;br/&gt; &lt;span&gt;// 添加新的关注的用户&lt;/span&gt;&lt;br/&gt; add(user) {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.followList.push(user);&lt;br/&gt; },&lt;br/&gt; &lt;span&gt;// 移除不再关注的用户&lt;/span&gt;&lt;br/&gt; remove(user) {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; idx = &lt;span&gt;this&lt;/span&gt;.followList.indexOf(user);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (idx !== &lt;span&gt;-1&lt;/span&gt;) {&lt;br/&gt;   &lt;span&gt;this&lt;/span&gt;.followList.splice(idx, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt; },&lt;br/&gt; &lt;span&gt;// 计算关注公众号的总的用户数&lt;/span&gt;&lt;br/&gt; count() {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.followList.length;&lt;br/&gt; },&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 新建用户的类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;constructor&lt;/span&gt;(name) {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.name = name;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 接收公众号内容更新的通知&lt;/span&gt;&lt;br/&gt; update() {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`&lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.name}&lt;/span&gt;接收到了公众号的内容更新`&lt;/span&gt;);&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 创建两个新的用户&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; zhangSan = &lt;span&gt;new&lt;/span&gt; User(&lt;span&gt;&#x27;张三&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; liSi = &lt;span&gt;new&lt;/span&gt; User(&lt;span&gt;&#x27;李四&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 公众号添加关注的用户&lt;/span&gt;&lt;br/&gt;officialAccount.add(zhangSan);&lt;br/&gt;officialAccount.add(liSi);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 公众号有新内容更新&lt;/span&gt;&lt;br/&gt;officialAccount.notify();&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`当前关注公众号的用户数量是：&lt;span&gt;${officialAccount.count()}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 张三不再关注公众号&lt;/span&gt;&lt;br/&gt;officialAccount.remove(zhangSan);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 公众号有新内容更新&lt;/span&gt;&lt;br/&gt;officialAccount.notify();&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`当前关注公众号的用户数量是：&lt;span&gt;${officialAccount.count()}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出的结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;张三接收到了公众号的内容更新&lt;br/&gt;李四接收到了公众号的内容更新&lt;br/&gt;当前关注公众号的用户数量是：2&lt;br/&gt;李四接收到了公众号的内容更新&lt;br/&gt;当前关注公众号的用户数量是：1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码完善了关注和取消关注的过程，并且可以获取当前公众号的关注人数。我们还实现了一个用户类，能够让我们快速创建需要添加到公众号关注列表的用户。当然你也可以把公众号的实现通过一个类来完成，这里就不再展示实现的过程了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面这个简单的例子，你是不是有所感悟，有了一些新的收获？&lt;strong&gt;我们上面实现的其实就是一个简单的观察者模式&lt;/strong&gt;。接下来我们来聊一聊观察者模式的定义，以及一些在实际开发中的用途。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;观察者模式的定义&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;所谓的观察者模式指的是一种一对多的关系，我们把其中的&lt;code&gt;一&lt;/code&gt;叫做&lt;code&gt;Subject&lt;/code&gt;（类比上文中的公众号），把其中的&lt;code&gt;多&lt;/code&gt;叫做&lt;code&gt;Observer&lt;/code&gt;（类比上文中关注公众号的用户），也就是观察者。因为多个&lt;code&gt;Observer&lt;/code&gt;的变动依赖&lt;code&gt;Subject&lt;/code&gt;的状态更新，所以&lt;code&gt;Subject&lt;/code&gt;在内部维护了一个&lt;code&gt;Observer&lt;/code&gt;的列表，一旦&lt;code&gt;Subject&lt;/code&gt;的状态有更新，就会遍历这个列表，通知列表中每一个&lt;code&gt;Observer&lt;/code&gt;进行相应的更新。因为有了这个列表，&lt;code&gt;Subject&lt;/code&gt;就可以对这个列表进行增删改查的操作。也就实现了&lt;code&gt;Observer&lt;/code&gt;对&lt;code&gt;Subject&lt;/code&gt;依赖的更新和解绑&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看一下观察者模式的&lt;code&gt;UML&lt;/code&gt;图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4131944444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fj9xyC53hPX4W4Sf8cgG3UjicjvVS9QFj3ESHeV5wricu9IRuq9REDiatN085rnxbSLrOicics7gL34lPMsaGSCDptQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2880&quot;/&gt;&lt;figcaption&gt;观察者模式UML模式&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图我们这可以看到，对于&lt;code&gt;Subject&lt;/code&gt;来说，它自身需要维护一个&lt;code&gt;observerCollection&lt;/code&gt;，这个列表里面就是&lt;code&gt;Observer&lt;/code&gt;的实例。然后在&lt;code&gt;Subject&lt;/code&gt;内部实现了增加观察者，移除观察者，和通知观察者的方法。其中通知观察者的方式就是遍历&lt;code&gt;observerCollection&lt;/code&gt;列表，依次调用列表中每一个&lt;code&gt;observer&lt;/code&gt;的&lt;code&gt;update&lt;/code&gt;方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里为止，你现在已经对这个设计模式有了一些了解。那我们学习这个设计模式有什么作用呢？&lt;strong&gt;首先如果我们在开发中遇到这种类似上面的一对多的关系，并且&lt;code&gt;多&lt;/code&gt;的状态更新依赖&lt;code&gt;一&lt;/code&gt;的状态；那么我们就可以使用这种设计模式去解决这种问题。而且我们也可以使用这种模式解耦我们的代码，让我们的代码更好拓展与维护&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然一些同学会觉得自己在平时的开发中好像没怎么使用过这种设计模式，那是因为我们平时在开发中一般都会使用一些框架，比如&lt;code&gt;Vue&lt;/code&gt;或者&lt;code&gt;React&lt;/code&gt;等，&lt;strong&gt;这个设计模式已经被这些框架在内部实现好了。我们可以直接使用，所以我们对这个设计模式的感知会少一些&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实战：实现一个简单的TODO小应用&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前我开发的一个组队打卡小程序&lt;a class=&quot;weapp_text_link js_weapp_entry&quot; data-miniprogram-appid=&quot;wx1fffeba49d074af6&quot; data-miniprogram-path=&quot;pages/main-thread/index/index&quot; data-miniprogram-nickname=&quot;主线程&quot; href=&quot;&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-servicetype=&quot;&quot;&gt;主线程&lt;/a&gt;，其中首页待办的一些功能就使用了&lt;strong&gt;观察者模式&lt;/strong&gt;，今天我们利用观察者模式实现一个粗糙的版本&lt;span&gt;，&lt;/span&gt;&lt;strong&gt;就是能够让用户添加自己的待办，并且需要显示已添加的待办事项的数量&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解了需求之后，我们需要确定那些是&lt;code&gt;一&lt;/code&gt;，哪些是&lt;code&gt;多&lt;/code&gt;。当然我们知道整个TODO的&lt;code&gt;状态&lt;/code&gt;就是我们所说的&lt;code&gt;一&lt;/code&gt;，那么对于&lt;code&gt;待办列表的展示&lt;/code&gt;以及&lt;code&gt;待办列表的计数&lt;/code&gt;就是我们所说的&lt;code&gt;多&lt;/code&gt;。理清了思路之后，实现这个小应用就变得很简单了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;可以点击👉这里提前体验一下这个简单的小应用&lt;/strong&gt;。&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.142156862745098&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/fj9xyC53hPX4W4Sf8cgG3UjicjvVS9QFjMSHZIjAibEo2CiblxsXk3bf3dv3pA9XlCqfWgkgzTYGnyboHyic4HoI5A/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;816&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;TODO小应用&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们需要先实现观察者模式中的&lt;code&gt;Subject&lt;/code&gt;和&lt;code&gt;Observer&lt;/code&gt;类，代码如下所示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Subject&lt;/code&gt;类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Subject&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Subject&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;constructor&lt;/span&gt;() {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.observerCollection = [];&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 添加观察者&lt;/span&gt;&lt;br/&gt; registerObserver(observer) {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.observerCollection.push(observer);&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 移除观察者&lt;/span&gt;&lt;br/&gt; unregisterObserver(observer) {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; observerIndex = &lt;span&gt;this&lt;/span&gt;.observerCollection.indexOf(observer);&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.observerCollection.splice(observerIndex, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 通知观察者&lt;/span&gt;&lt;br/&gt; notifyObservers(subject) {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; collection = &lt;span&gt;this&lt;/span&gt;.observerCollection;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; len = collection.length;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (len &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; observer &lt;span&gt;of&lt;/span&gt; collection) {&lt;br/&gt;    observer.update(subject);&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Observer&lt;/code&gt;类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 观察者&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Observer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; update() {}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么接下来的代码就是关于上面待办的具体实现了，代码中也添加了相应的注释，我们来看一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;待办应用的逻辑部分：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 表单的状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Todo&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Subject&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;constructor&lt;/span&gt;() {&lt;br/&gt;  &lt;span&gt;super&lt;/span&gt;();&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.items = [];&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 添加todo&lt;/span&gt;&lt;br/&gt; addItem(item) {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.items.push(item);&lt;br/&gt;  &lt;span&gt;super&lt;/span&gt;.notifyObservers(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 列表渲染&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ListRender&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Observer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;constructor&lt;/span&gt;(el) {&lt;br/&gt;  &lt;span&gt;super&lt;/span&gt;();&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.el = &lt;span&gt;document&lt;/span&gt;.getElementById(el);&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 更新列表&lt;/span&gt;&lt;br/&gt; update(todo) {&lt;br/&gt;  &lt;span&gt;super&lt;/span&gt;.update();&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; items = todo.items;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.el.innerHTML = items.map(&lt;span&gt;&lt;span&gt;text&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;`&amp;lt;li&amp;gt;&lt;span&gt;${text}&lt;/span&gt;&amp;lt;/li&amp;gt;`&lt;/span&gt;).join(&lt;span&gt;&#x27;&#x27;&lt;/span&gt;);&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 列表计数观察者&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CountObserver&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Observer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;constructor&lt;/span&gt;(el) {&lt;br/&gt;  &lt;span&gt;super&lt;/span&gt;();&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.el = &lt;span&gt;document&lt;/span&gt;.getElementById(el);&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 更新计数&lt;/span&gt;&lt;br/&gt; update(todo) {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.el.innerText = &lt;span&gt;`&lt;span&gt;${todo.items.length}&lt;/span&gt;`&lt;/span&gt;;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 列表观察者&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; listObserver = &lt;span&gt;new&lt;/span&gt; ListRender(&lt;span&gt;&#x27;item-list&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// 计数观察者&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; countObserver = &lt;span&gt;new&lt;/span&gt; CountObserver(&lt;span&gt;&#x27;item-count&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; todo = &lt;span&gt;new&lt;/span&gt; Todo();&lt;br/&gt;&lt;span&gt;// 添加列表观察者&lt;/span&gt;&lt;br/&gt;todo.registerObserver(listObserver);&lt;br/&gt;&lt;span&gt;// 添加计数观察者&lt;/span&gt;&lt;br/&gt;todo.registerObserver(countObserver);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 获取todo按钮&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; addBtn = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;add-btn&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// 获取输入框的内容&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; inputEle = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;new-item&#x27;&lt;/span&gt;);&lt;br/&gt;addBtn.onclick = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;const&lt;/span&gt; item = inputEle.value;&lt;br/&gt; &lt;span&gt;// 判断添加的内容是否为空&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (item) {&lt;br/&gt;  todo.addItem(item);&lt;br/&gt;  inputEle.value = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt; }&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的代码我们可以清楚地知道这个应用的每一个部分，被观察的&lt;code&gt;Subject&lt;/code&gt;就是我们的&lt;code&gt;todo&lt;/code&gt;对象，它的状态就是待办列表。它维护的观察者列表分别是展示待办列表的&lt;code&gt;listObserver&lt;/code&gt;和展示待办数量的&lt;code&gt;countObserver&lt;/code&gt;。一旦&lt;code&gt;todo&lt;/code&gt;的列表新增加了一项待办，那么就会通知这两个观察者去做相应的内容更新。这样代码的逻辑就很直观明了。如果以后在状态变更的时候还要添加新的功能，我们只需要再次添加一个相应的&lt;code&gt;observer&lt;/code&gt;就可以了，维护起来也很方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然上面的代码只实现了很基础的功能，&lt;strong&gt;还没有包含待办的完成和删除，以及对于未完成和已完成的待办的分类展示。而且列表的渲染每次都是重新渲染的，没有复用的逻辑&lt;/strong&gt;。因为我们本章的内容是跟大家一起来探讨一下观察者模式，所以上面的代码比较简陋，也只是为了说明观察者模式的用法。相信优秀的你能够在这个基础上，把这些功能都完善好，快去试试吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;其实我们学习这些设计模式，都是为了让代码的逻辑更加清晰明了，能够复用一些代码的逻辑，减少重复的工作，提升开发的效率。让整个应用更加容易维护和拓展。当然不能为了使用而使用，在使用之前，需要对当前的问题做一个全面的了解。到底需不需要使用某个设计模式是一个需要考虑清楚的问题。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好啦，关于观察者模式到这里就结束啦，大家如果有什么意见和建议可以在文章下面下面留言，我们一起探讨一下。也可以在这里提出来，我们更好地进行讨论。也欢迎大家关注我的公众号&lt;strong&gt;关山不难越&lt;/strong&gt;，随时随地获取文章的更新。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家如果有兴趣的话，可以看一下我之前的作品&lt;a class=&quot;weapp_text_link js_weapp_entry&quot; data-miniprogram-appid=&quot;wx1fffeba49d074af6&quot; data-miniprogram-path=&quot;pages/main-thread/index/index&quot; data-miniprogram-nickname=&quot;主线程&quot; href=&quot;&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-servicetype=&quot;&quot;&gt;主线程&lt;/a&gt;，如果这个小程序能够对你有一些帮助的话就更好了~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考链接：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;The Observer Pattern&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;How to Use the Observable Pattern in JavaScript&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章封面图来源：unDraw&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1efa1aef55157d09a044561945f9cae9</guid>
<title>工具 | 一个轻量级业务中台开发框架</title>
<link>https://toutiao.io/k/6qs3yvv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cbebcab2233fbfa82a238a123319f07b</guid>
<title>几个有用的 C++ 在线工具</title>
<link>https://toutiao.io/k/2x6txgc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ea0c7e9327b158461c312aac885c1796</guid>
<title>业务压力一大就宕机？一文带你搞懂限流熔断</title>
<link>https://toutiao.io/k/wodn2gj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“在分布式应用中，最常见的问题是什么呢？”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“一个分布式应用部署上去后，还要关注什么？”&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5603715170278638&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4jDrh1vIHLPh0nz30kZpJxyouM609fywaIrD4ZVNmuYhkdu1E85WzDr912Xy5CVtUa1j6uIEJ5pvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;646&quot;/&gt;&lt;figcaption&gt;图来自网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“这服务的远程调用依赖似乎有点多...”&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前言&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 《微服务的战争：级联故障和雪崩》中有提到，在一个分布式应用中，最常见，最有危险性之一的点就是级联故障所造成的雪崩，而其对应的解决方案为&lt;strong&gt;根据特定的规则/规律进行流量控制和熔断降级&lt;/strong&gt;，避免请求发生堆积，保护自身应用，也防止服务提供方进一步过载。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5654596100278552&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4jDrh1vIHLPh0nz30kZpJxy8FZvPC8ErPOCVKMoQmyKIHLVXNy7o8oiam8Q8fOqYImPFsWibMTVlwug/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1436&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来讲就是，要控制访问量的流量，要防各类调用的强/弱依赖，才能保护好应用程序的底线。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;诉求，期望&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;诉求：作为一个业务，肯定是希望自家的应用程序，能够全年无休，最低限度也要有个 4 个 9，一出突发性大流量，在资源贫乏的窗口期，就马上能够自动恢复。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;期望：万丈高楼平地起，我们需要对应用程序进行流量控制、熔断降级。确保在特定的规则下，系统能够进行容错，只处理自己力所能及的请求。若有更一步诉求，再自动扩缩容，提高系统资源上限。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解决方案&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要如何解决这个问题，或者说是达到这个目的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;咱们可以关注到问题的核心点是 “系统没有任何的保护的情况下”，因此方向上就是让系统，让应用程序有流量控制的保护。一般含以下几个方面：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;来自端控制：在业务/流量网关处内置流量控制、熔断降级的外部插件，起到端控制的效果。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;来自集群/节点控制：在统一框架中内建流量控制、熔断降级的处理逻辑，起到集群/节点控制的效果。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;来自 Mesh 控制：通过 ServiceMesh 来实现流量控制、熔断降级。侵入性小，能带来多种控制模式，但有利有弊。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上的多种方式均可与内部的治理平台打通，且流量控制、熔断降级是不止面试应用程序的，就看资源埋点上如何设计、注入。常见有如下几种角度：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;资源的调用关系：例如远程调用，像是面向 HTTP、SQL、Redis、RPC 等调用均，另外针对文件句柄控制也可以。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;运行指标：例如 QPS、线程池、系统负载等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;流量控制&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在资源不变的情况下，系统所能提供的处理能力是有限的。而系统所面对的请求所到来的时间和量级往往是随机且不可控的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此就会存在可能出现突发性流量，而&lt;span&gt;系统&lt;/span&gt;在没有任何的保护的情况下，很有可能会在数分钟内就无法提供正常服务。常见的前导现象是先出现调用延迟，接着持续出现饱和度上升，最终假死。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5761024182076814&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4jDrh1vIHLPh0nz30kZpJxyQGNiakYvM4EREX9XXwL975RdfDhFXNsicHdC24t5V5N9JjWwRibKXbxlQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1406&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流量控制一般常见的有两种方式，分别是：基于 QPS、基于并发隔离。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基于 QPS&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最常用的流量控制场景，就是基于 QPS 来做流控，在一定的时间窗口内按照特定的规则达到所设定的阈值则进行调控：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5609418282548476&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4jDrh1vIHLPh0nz30kZpJxydibYnEXXYL8gk5VCNaAjwISdtrpkjicjsMsptTPiaicTjopA5Nt44GXfCg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1444&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;案例&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本文中借助 sentinel-golang 来实现案例所需的诉求，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;import (&lt;br/&gt; ...&lt;br/&gt; sentinel &lt;span&gt;&quot;github.com/alibaba/sentinel-golang/api&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/alibaba/sentinel-golang/core/base&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/alibaba/sentinel-golang/core/flow&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/alibaba/sentinel-golang/util&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; _ = sentinel.InitDefault()&lt;br/&gt; _, _ = flow.LoadRules([]*flow.Rule{&lt;br/&gt;  {&lt;br/&gt;   Resource:               &lt;span&gt;&quot;控制吃煎鱼的速度&quot;&lt;/span&gt;,&lt;br/&gt;   Threshold:              60,&lt;br/&gt;   ControlBehavior:        flow.Reject,&lt;br/&gt;  },&lt;br/&gt; })&lt;br/&gt;&lt;br/&gt; ...&lt;br/&gt; e, b := sentinel.Entry(&lt;span&gt;&quot;控制吃煎鱼的速度&quot;&lt;/span&gt;, sentinel.WithTrafficType(base.Inbound))&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; b != nil {&lt;br/&gt;     // Blocked&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;     // Passed&lt;br/&gt;     e.Exit()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总的来讲，上述规则结果就是 1s 内允许通过 60 个请求，超出的请求的处理策略为直接拒绝（Reject）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们初始化了 Sentinel 并定义资源（Resource）为 “控制吃煎鱼的速度”。其 Threshold 配置为 3，也就是 QPS 的阈值为 3，统计窗口未设置默认值为 1s，ControlBehavior 控制的行为为直接拒绝。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在满足阈值条件后，常见的处理策略还有匀速排队（Throttling），匀速排队方式会严格控制请求通过的间隔时间，也就是让请求以均匀的速度通过。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基于并发隔离&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于资源访问的并发协程数来控制对资源的访问数量，主要是控制对资源访问的最大协程数，避免因为资源的异常导致协程耗尽。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7390510948905109&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4jDrh1vIHLPh0nz30kZpJxycaRhTQdwmTnxzHDGJpVa2ia6bHGrVAJ0CDXT35ZkgJTbKjr6NnblFAg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1096&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这类情况，Go 语言在设计上常常可以使用协程池来进行控制，但设计总是赶不上计划的，且不同场景情况可能不同，因此作为一个日常功能也是非常有存在的必要性。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;熔断降级&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式应用中，随着不断地业务拆分，远程调用逐渐变得越来越多。且在微服务盛兴的情况下，一个小业务拆出七八个服务的也常有。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时就会出现一个经典的问题，那就是客户端的一个普通调用，很有可能就要经过好几个服务，而一个服务又有可能远程调用外部 HTTP、SQL、Redis、RPC 等，调用链会特别的长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若其中一个调用流程出现了问题，且没有进行调控，就会出现级联故障，最终导致系统雪崩：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3888888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4jDrh1vIHLPh0nz30kZpJxyyibbgQIRj7KFwToKPtbzh1vHWGrEDAcAOL4HDOiaupiaTb87f1GPxoibYw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1692&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务 D 所依赖的外部接口出现了故障，而他并没有做任何的控制，因此扩散到了所有调用到他的服务，自然也就包含服务 B，因此最终出现系统雪崩。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种最经典的是出现在默认 Go http client 调用没有设置 Timeout，从而只要出现一次故障，就足矣让记住这类 “坑”，毕竟崩的 ”慢“，错误日志还多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（via: 《微服务的战争：级联故障和雪崩》）&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;目的和措施&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决上述问题所带来的灾难，在分布式应用中常需要对服务依赖进行熔断降级。在存在问题时，暂时切断内部调用，避免局部不稳定因素导致整个分布式系统的雪崩。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而熔断降级作为保护服务自身的手段，通常是在客户端进行规则配置和熔断识别：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5306451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4jDrh1vIHLPh0nz30kZpJxygvao4KANcCYAy7Oj8lEpgPHqDnibHLKHETTLT4j8CsprfazE3xMOsZw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的有三种熔断降级措施：慢调用比例策略、错误比例策略、错误计数策略。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;慢调用比例&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在所设定的时间窗口内，慢调用的比例大于所设置的阈值，则对接下来访问的请求进行自动熔断。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;错误比例&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在所设定的时间窗口内，调用的访问错误比例大于所设置的阈值，则对接下来访问的请求进行自动熔断。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;错误计数&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在所设定的时间窗口内，调用的访问错误次数大于所设置的阈值，则对接下来访问的请求进行自动熔断。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实践案例&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道流量控制、熔断降级的基本概念和功能后，在现实环境中应该如何结合项目进行使用呢。最常见的场景是可针对业务服务的 HTTP 路由进行流量控制，以 HTTP 路由作为资源埋点，这样子就可以实现接口级的调控了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5177419354838709&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4jDrh1vIHLPh0nz30kZpJxyGAPAugvVBN1br9KuBc4gjD1TxXn35oWj2KF4HxUnKq6CJXUwU54ibWA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还可以增强其功能特性，针对参数也进行多重匹配。常会有这种限流诉求：针对 &lt;code&gt;HTTP GET /eddycjy/info&lt;/code&gt; 且 language 为 go 的情况下进行限流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外还可以针对 HTTP 调用封装统一方法，进行默认的熔断注入，实现多重保障。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而结合系统负载、服务 QPS 等，可以对限流熔断的规则数据源进行实时调控，再结合 Watch 机制，就能够比较平滑的实现自适应限流熔断的接入。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式应用中，限流熔断是非常重要的一环，越早开始做越有益处。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但需要注意的是，不同公司的业务模型多多少少有些不一样，所针对的匹配维度多少有些不同，因此需要提前进行业务调研。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在做业务的限流熔断时，注意把度量指标的打点做上，这样子后续就能够结合 Prometheus+Grafana+Alertmanager 做一系列的趋势图，熔断告警，自动扩缩容等相关工作了，会是一个很好的助力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分享 Go 语言、微服务架构和奇怪的系统设计&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>