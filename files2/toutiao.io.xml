<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>59b0073567bd95b462182cded9a48649</guid>
<title>用 Pandas 做用户留存分析</title>
<link>https://toutiao.io/k/13jbibt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;%matplotlib inline
import matplotlib 
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
sns.set(rc={&quot;figure.figsize&quot;: (16, 10)})
matplotlib.rc(&#x27;font&#x27;, family=&#x27;simhei&#x27;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们聚合出了一份 2019 年度的用户下单样例数据，有三个字段，首单月，下单月，用户量&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;df1 = pd.read_csv(&quot;./data/order_user_cnt_cohort_sample_data.csv&quot;)
df1.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th/&gt;
      &lt;th&gt;首单年月&lt;/th&gt;
      &lt;th&gt;下单年月&lt;/th&gt;
      &lt;th&gt;user_cnt&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;2019-01&lt;/td&gt;
      &lt;td&gt;2019-01&lt;/td&gt;
      &lt;td&gt;88760&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;2019-01&lt;/td&gt;
      &lt;td&gt;2019-02&lt;/td&gt;
      &lt;td&gt;9552&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;2019-02&lt;/td&gt;
      &lt;td&gt;2019-02&lt;/td&gt;
      &lt;td&gt;87155&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;2019-03&lt;/td&gt;
      &lt;td&gt;2019-03&lt;/td&gt;
      &lt;td&gt;101254&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;2019-02&lt;/td&gt;
      &lt;td&gt;2019-03&lt;/td&gt;
      &lt;td&gt;10453&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;创建透视表，其实透视表就可以看出留存情况了，只是没那么好理解&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;df2 = df1.pivot_table(
    index=[&#x27;首单年月&#x27;], columns=&#x27;下单年月&#x27;, values=&#x27;user_cnt&#x27;)
df2
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;下单年月&lt;/th&gt;
      &lt;th&gt;2019-01&lt;/th&gt;
      &lt;th&gt;2019-02&lt;/th&gt;
      &lt;th&gt;2019-03&lt;/th&gt;
      &lt;th&gt;2019-04&lt;/th&gt;
      &lt;th&gt;2019-05&lt;/th&gt;
      &lt;th&gt;2019-06&lt;/th&gt;
      &lt;th&gt;2019-07&lt;/th&gt;
      &lt;th&gt;2019-08&lt;/th&gt;
      &lt;th&gt;2019-09&lt;/th&gt;
      &lt;th&gt;2019-10&lt;/th&gt;
      &lt;th&gt;2019-11&lt;/th&gt;
      &lt;th&gt;2019-12&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;首单年月&lt;/th&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;2019-01&lt;/th&gt;
      &lt;td&gt;88760.0&lt;/td&gt;
      &lt;td&gt;9552.0&lt;/td&gt;
      &lt;td&gt;8207.0&lt;/td&gt;
      &lt;td&gt;6403.0&lt;/td&gt;
      &lt;td&gt;5178.0&lt;/td&gt;
      &lt;td&gt;4894.0&lt;/td&gt;
      &lt;td&gt;3343.0&lt;/td&gt;
      &lt;td&gt;3063.0&lt;/td&gt;
      &lt;td&gt;2443.0&lt;/td&gt;
      &lt;td&gt;1966.0&lt;/td&gt;
      &lt;td&gt;3212.0&lt;/td&gt;
      &lt;td&gt;2278.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2019-02&lt;/th&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;87155.0&lt;/td&gt;
      &lt;td&gt;10453.0&lt;/td&gt;
      &lt;td&gt;6388.0&lt;/td&gt;
      &lt;td&gt;5511.0&lt;/td&gt;
      &lt;td&gt;4673.0&lt;/td&gt;
      &lt;td&gt;3335.0&lt;/td&gt;
      &lt;td&gt;3024.0&lt;/td&gt;
      &lt;td&gt;2503.0&lt;/td&gt;
      &lt;td&gt;1815.0&lt;/td&gt;
      &lt;td&gt;2889.0&lt;/td&gt;
      &lt;td&gt;1991.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2019-03&lt;/th&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;101254.0&lt;/td&gt;
      &lt;td&gt;10673.0&lt;/td&gt;
      &lt;td&gt;8068.0&lt;/td&gt;
      &lt;td&gt;6835.0&lt;/td&gt;
      &lt;td&gt;4769.0&lt;/td&gt;
      &lt;td&gt;4180.0&lt;/td&gt;
      &lt;td&gt;3531.0&lt;/td&gt;
      &lt;td&gt;2671.0&lt;/td&gt;
      &lt;td&gt;4078.0&lt;/td&gt;
      &lt;td&gt;2841.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2019-04&lt;/th&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;102449.0&lt;/td&gt;
      &lt;td&gt;10497.0&lt;/td&gt;
      &lt;td&gt;9495.0&lt;/td&gt;
      &lt;td&gt;5869.0&lt;/td&gt;
      &lt;td&gt;5164.0&lt;/td&gt;
      &lt;td&gt;4244.0&lt;/td&gt;
      &lt;td&gt;3177.0&lt;/td&gt;
      &lt;td&gt;5519.0&lt;/td&gt;
      &lt;td&gt;3600.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2019-05&lt;/th&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;89913.0&lt;/td&gt;
      &lt;td&gt;11471.0&lt;/td&gt;
      &lt;td&gt;6562.0&lt;/td&gt;
      &lt;td&gt;5420.0&lt;/td&gt;
      &lt;td&gt;4240.0&lt;/td&gt;
      &lt;td&gt;3090.0&lt;/td&gt;
      &lt;td&gt;5278.0&lt;/td&gt;
      &lt;td&gt;3611.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2019-06&lt;/th&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;82524.0&lt;/td&gt;
      &lt;td&gt;7230.0&lt;/td&gt;
      &lt;td&gt;5491.0&lt;/td&gt;
      &lt;td&gt;4311.0&lt;/td&gt;
      &lt;td&gt;3013.0&lt;/td&gt;
      &lt;td&gt;6027.0&lt;/td&gt;
      &lt;td&gt;3579.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2019-07&lt;/th&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;66243.0&lt;/td&gt;
      &lt;td&gt;6927.0&lt;/td&gt;
      &lt;td&gt;4457.0&lt;/td&gt;
      &lt;td&gt;3309.0&lt;/td&gt;
      &lt;td&gt;5105.0&lt;/td&gt;
      &lt;td&gt;3090.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2019-08&lt;/th&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;63119.0&lt;/td&gt;
      &lt;td&gt;5325.0&lt;/td&gt;
      &lt;td&gt;3454.0&lt;/td&gt;
      &lt;td&gt;4656.0&lt;/td&gt;
      &lt;td&gt;3245.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2019-09&lt;/th&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;55891.0&lt;/td&gt;
      &lt;td&gt;4336.0&lt;/td&gt;
      &lt;td&gt;5745.0&lt;/td&gt;
      &lt;td&gt;3748.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2019-10&lt;/th&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;45593.0&lt;/td&gt;
      &lt;td&gt;5389.0&lt;/td&gt;
      &lt;td&gt;3550.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2019-11&lt;/th&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;69600.0&lt;/td&gt;
      &lt;td&gt;5860.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2019-12&lt;/th&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;47870.0&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;现在我们按下单月顺序排列&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;def cohort_period(df):
    df[&#x27;CohortPeriod&#x27;] = np.arange(len(df)) + 1
    return df

cohorts = df1.groupby(&#x27;首单年月&#x27;).apply(cohort_period)
cohorts.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th/&gt;
      &lt;th&gt;首单年月&lt;/th&gt;
      &lt;th&gt;下单年月&lt;/th&gt;
      &lt;th&gt;user_cnt&lt;/th&gt;
      &lt;th&gt;CohortPeriod&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;2019-01&lt;/td&gt;
      &lt;td&gt;2019-01&lt;/td&gt;
      &lt;td&gt;88760&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;2019-01&lt;/td&gt;
      &lt;td&gt;2019-02&lt;/td&gt;
      &lt;td&gt;9552&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;2019-02&lt;/td&gt;
      &lt;td&gt;2019-02&lt;/td&gt;
      &lt;td&gt;87155&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;2019-03&lt;/td&gt;
      &lt;td&gt;2019-03&lt;/td&gt;
      &lt;td&gt;101254&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;2019-02&lt;/td&gt;
      &lt;td&gt;2019-03&lt;/td&gt;
      &lt;td&gt;10453&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;cohorts.set_index([&#x27;首单年月&#x27;, &#x27;CohortPeriod&#x27;], inplace=True)
cohorts.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th&gt;下单年月&lt;/th&gt;
      &lt;th&gt;user_cnt&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;首单年月&lt;/th&gt;
      &lt;th&gt;CohortPeriod&lt;/th&gt;
      &lt;th/&gt;
      &lt;th/&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th rowspan=&quot;2&quot; valign=&quot;top&quot;&gt;2019-01&lt;/th&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;2019-01&lt;/td&gt;
      &lt;td&gt;88760&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;2019-02&lt;/td&gt;
      &lt;td&gt;9552&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2019-02&lt;/th&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;2019-02&lt;/td&gt;
      &lt;td&gt;87155&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2019-03&lt;/th&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;2019-03&lt;/td&gt;
      &lt;td&gt;101254&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2019-02&lt;/th&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;2019-03&lt;/td&gt;
      &lt;td&gt;10453&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;cohort_group_size = cohorts[&#x27;user_cnt&#x27;].groupby(&#x27;首单年月&#x27;).first()
cohort_group_size
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;首单年月
2019-01     88760
2019-02     87155
2019-03    101254
2019-04    102449
2019-05     89913
2019-06     82524
2019-07     66243
2019-08     63119
2019-09     55891
2019-10     45593
2019-11     69600
2019-12     47870
Name: user_cnt, dtype: int64
&lt;/code&gt;&lt;/pre&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;cohorts[&#x27;user_cnt&#x27;].unstack(0)
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;首单年月&lt;/th&gt;
      &lt;th&gt;2019-01&lt;/th&gt;
      &lt;th&gt;2019-02&lt;/th&gt;
      &lt;th&gt;2019-03&lt;/th&gt;
      &lt;th&gt;2019-04&lt;/th&gt;
      &lt;th&gt;2019-05&lt;/th&gt;
      &lt;th&gt;2019-06&lt;/th&gt;
      &lt;th&gt;2019-07&lt;/th&gt;
      &lt;th&gt;2019-08&lt;/th&gt;
      &lt;th&gt;2019-09&lt;/th&gt;
      &lt;th&gt;2019-10&lt;/th&gt;
      &lt;th&gt;2019-11&lt;/th&gt;
      &lt;th&gt;2019-12&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;CohortPeriod&lt;/th&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;88760.0&lt;/td&gt;
      &lt;td&gt;87155.0&lt;/td&gt;
      &lt;td&gt;101254.0&lt;/td&gt;
      &lt;td&gt;102449.0&lt;/td&gt;
      &lt;td&gt;89913.0&lt;/td&gt;
      &lt;td&gt;82524.0&lt;/td&gt;
      &lt;td&gt;66243.0&lt;/td&gt;
      &lt;td&gt;63119.0&lt;/td&gt;
      &lt;td&gt;55891.0&lt;/td&gt;
      &lt;td&gt;45593.0&lt;/td&gt;
      &lt;td&gt;69600.0&lt;/td&gt;
      &lt;td&gt;47870.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;9552.0&lt;/td&gt;
      &lt;td&gt;10453.0&lt;/td&gt;
      &lt;td&gt;10673.0&lt;/td&gt;
      &lt;td&gt;10497.0&lt;/td&gt;
      &lt;td&gt;11471.0&lt;/td&gt;
      &lt;td&gt;7230.0&lt;/td&gt;
      &lt;td&gt;6927.0&lt;/td&gt;
      &lt;td&gt;5325.0&lt;/td&gt;
      &lt;td&gt;4336.0&lt;/td&gt;
      &lt;td&gt;5389.0&lt;/td&gt;
      &lt;td&gt;5860.0&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;8207.0&lt;/td&gt;
      &lt;td&gt;6388.0&lt;/td&gt;
      &lt;td&gt;8068.0&lt;/td&gt;
      &lt;td&gt;9495.0&lt;/td&gt;
      &lt;td&gt;6562.0&lt;/td&gt;
      &lt;td&gt;5491.0&lt;/td&gt;
      &lt;td&gt;4457.0&lt;/td&gt;
      &lt;td&gt;3454.0&lt;/td&gt;
      &lt;td&gt;5745.0&lt;/td&gt;
      &lt;td&gt;3550.0&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;6403.0&lt;/td&gt;
      &lt;td&gt;5511.0&lt;/td&gt;
      &lt;td&gt;6835.0&lt;/td&gt;
      &lt;td&gt;5869.0&lt;/td&gt;
      &lt;td&gt;5420.0&lt;/td&gt;
      &lt;td&gt;4311.0&lt;/td&gt;
      &lt;td&gt;3309.0&lt;/td&gt;
      &lt;td&gt;4656.0&lt;/td&gt;
      &lt;td&gt;3748.0&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;5178.0&lt;/td&gt;
      &lt;td&gt;4673.0&lt;/td&gt;
      &lt;td&gt;4769.0&lt;/td&gt;
      &lt;td&gt;5164.0&lt;/td&gt;
      &lt;td&gt;4240.0&lt;/td&gt;
      &lt;td&gt;3013.0&lt;/td&gt;
      &lt;td&gt;5105.0&lt;/td&gt;
      &lt;td&gt;3245.0&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;6&lt;/th&gt;
      &lt;td&gt;4894.0&lt;/td&gt;
      &lt;td&gt;3335.0&lt;/td&gt;
      &lt;td&gt;4180.0&lt;/td&gt;
      &lt;td&gt;4244.0&lt;/td&gt;
      &lt;td&gt;3090.0&lt;/td&gt;
      &lt;td&gt;6027.0&lt;/td&gt;
      &lt;td&gt;3090.0&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;td&gt;3343.0&lt;/td&gt;
      &lt;td&gt;3024.0&lt;/td&gt;
      &lt;td&gt;3531.0&lt;/td&gt;
      &lt;td&gt;3177.0&lt;/td&gt;
      &lt;td&gt;5278.0&lt;/td&gt;
      &lt;td&gt;3579.0&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;8&lt;/th&gt;
      &lt;td&gt;3063.0&lt;/td&gt;
      &lt;td&gt;2503.0&lt;/td&gt;
      &lt;td&gt;2671.0&lt;/td&gt;
      &lt;td&gt;5519.0&lt;/td&gt;
      &lt;td&gt;3611.0&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;9&lt;/th&gt;
      &lt;td&gt;2443.0&lt;/td&gt;
      &lt;td&gt;1815.0&lt;/td&gt;
      &lt;td&gt;4078.0&lt;/td&gt;
      &lt;td&gt;3600.0&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;10&lt;/th&gt;
      &lt;td&gt;1966.0&lt;/td&gt;
      &lt;td&gt;2889.0&lt;/td&gt;
      &lt;td&gt;2841.0&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;11&lt;/th&gt;
      &lt;td&gt;3212.0&lt;/td&gt;
      &lt;td&gt;1991.0&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;12&lt;/th&gt;
      &lt;td&gt;2278.0&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;转换成百分比&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;user_retention = cohorts[&#x27;user_cnt&#x27;].unstack(0).divide(cohort_group_size, axis=1)
user_retention
&lt;/code&gt;&lt;/pre&gt;

&lt;div&gt;
&lt;table border=&quot;1&quot; class=&quot;dataframe&quot;&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;首单年月&lt;/th&gt;
      &lt;th&gt;2019-01&lt;/th&gt;
      &lt;th&gt;2019-02&lt;/th&gt;
      &lt;th&gt;2019-03&lt;/th&gt;
      &lt;th&gt;2019-04&lt;/th&gt;
      &lt;th&gt;2019-05&lt;/th&gt;
      &lt;th&gt;2019-06&lt;/th&gt;
      &lt;th&gt;2019-07&lt;/th&gt;
      &lt;th&gt;2019-08&lt;/th&gt;
      &lt;th&gt;2019-09&lt;/th&gt;
      &lt;th&gt;2019-10&lt;/th&gt;
      &lt;th&gt;2019-11&lt;/th&gt;
      &lt;th&gt;2019-12&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;CohortPeriod&lt;/th&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
      &lt;th/&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;1.000000&lt;/td&gt;
      &lt;td&gt;1.000000&lt;/td&gt;
      &lt;td&gt;1.000000&lt;/td&gt;
      &lt;td&gt;1.000000&lt;/td&gt;
      &lt;td&gt;1.000000&lt;/td&gt;
      &lt;td&gt;1.000000&lt;/td&gt;
      &lt;td&gt;1.000000&lt;/td&gt;
      &lt;td&gt;1.000000&lt;/td&gt;
      &lt;td&gt;1.000000&lt;/td&gt;
      &lt;td&gt;1.000000&lt;/td&gt;
      &lt;td&gt;1.000000&lt;/td&gt;
      &lt;td&gt;1.0&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;0.107616&lt;/td&gt;
      &lt;td&gt;0.119936&lt;/td&gt;
      &lt;td&gt;0.105408&lt;/td&gt;
      &lt;td&gt;0.102461&lt;/td&gt;
      &lt;td&gt;0.127579&lt;/td&gt;
      &lt;td&gt;0.087611&lt;/td&gt;
      &lt;td&gt;0.104570&lt;/td&gt;
      &lt;td&gt;0.084364&lt;/td&gt;
      &lt;td&gt;0.077580&lt;/td&gt;
      &lt;td&gt;0.118198&lt;/td&gt;
      &lt;td&gt;0.084195&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;td&gt;0.092463&lt;/td&gt;
      &lt;td&gt;0.073295&lt;/td&gt;
      &lt;td&gt;0.079681&lt;/td&gt;
      &lt;td&gt;0.092680&lt;/td&gt;
      &lt;td&gt;0.072982&lt;/td&gt;
      &lt;td&gt;0.066538&lt;/td&gt;
      &lt;td&gt;0.067283&lt;/td&gt;
      &lt;td&gt;0.054722&lt;/td&gt;
      &lt;td&gt;0.102789&lt;/td&gt;
      &lt;td&gt;0.077863&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;td&gt;0.072138&lt;/td&gt;
      &lt;td&gt;0.063232&lt;/td&gt;
      &lt;td&gt;0.067504&lt;/td&gt;
      &lt;td&gt;0.057287&lt;/td&gt;
      &lt;td&gt;0.060280&lt;/td&gt;
      &lt;td&gt;0.052239&lt;/td&gt;
      &lt;td&gt;0.049952&lt;/td&gt;
      &lt;td&gt;0.073765&lt;/td&gt;
      &lt;td&gt;0.067059&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;td&gt;0.058337&lt;/td&gt;
      &lt;td&gt;0.053617&lt;/td&gt;
      &lt;td&gt;0.047099&lt;/td&gt;
      &lt;td&gt;0.050406&lt;/td&gt;
      &lt;td&gt;0.047157&lt;/td&gt;
      &lt;td&gt;0.036511&lt;/td&gt;
      &lt;td&gt;0.077065&lt;/td&gt;
      &lt;td&gt;0.051411&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;6&lt;/th&gt;
      &lt;td&gt;0.055137&lt;/td&gt;
      &lt;td&gt;0.038265&lt;/td&gt;
      &lt;td&gt;0.041282&lt;/td&gt;
      &lt;td&gt;0.041425&lt;/td&gt;
      &lt;td&gt;0.034367&lt;/td&gt;
      &lt;td&gt;0.073033&lt;/td&gt;
      &lt;td&gt;0.046646&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;7&lt;/th&gt;
      &lt;td&gt;0.037663&lt;/td&gt;
      &lt;td&gt;0.034697&lt;/td&gt;
      &lt;td&gt;0.034873&lt;/td&gt;
      &lt;td&gt;0.031011&lt;/td&gt;
      &lt;td&gt;0.058701&lt;/td&gt;
      &lt;td&gt;0.043369&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;8&lt;/th&gt;
      &lt;td&gt;0.034509&lt;/td&gt;
      &lt;td&gt;0.028719&lt;/td&gt;
      &lt;td&gt;0.026379&lt;/td&gt;
      &lt;td&gt;0.053871&lt;/td&gt;
      &lt;td&gt;0.040161&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;9&lt;/th&gt;
      &lt;td&gt;0.027524&lt;/td&gt;
      &lt;td&gt;0.020825&lt;/td&gt;
      &lt;td&gt;0.040275&lt;/td&gt;
      &lt;td&gt;0.035139&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;10&lt;/th&gt;
      &lt;td&gt;0.022150&lt;/td&gt;
      &lt;td&gt;0.033148&lt;/td&gt;
      &lt;td&gt;0.028058&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;11&lt;/th&gt;
      &lt;td&gt;0.036187&lt;/td&gt;
      &lt;td&gt;0.022844&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;12&lt;/th&gt;
      &lt;td&gt;0.025665&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
      &lt;td&gt;NaN&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;通过颜色渐变的方式用热图展示出来，现在我们可以对比第三个月的留存情况&lt;/p&gt;

&lt;pre lang=&quot;python&quot;&gt;&lt;code&gt;plt.figure(figsize=(20, 10))
plt.title(&#x27;用户下单留存分析&#x27;)
sns.heatmap(user_retention.T, mask=user_retention.T.isnull(), annot=True, cmap=&quot;rocket_r&quot;, fmt=&#x27;.2%&#x27;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/attachment/cda6df9b949d4e2ca816e0a1cc3ae3b4/w600&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;HowTos 项目 Github 地址： &lt;a href=&quot;https://github.com/toutiaoio/HowTos&quot;&gt;https://github.com/toutiaoio/HowTos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>55a6f34dc6fa9d286e4a1c9d19e487ad</guid>
<title>Golang 性能诊断看这篇就够了</title>
<link>https://toutiao.io/k/3loin1u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.0909090909090908&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zKDkic1rP1QqFfULibMaiaSmYUW7hCHZWPJIZHepEibOw1peSm7T1cU4N760yuUkh33VV0WdUkM7iadUxpiabR0CYaDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;44&quot;/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;点击上方&lt;span data-mid=&quot;&quot;&gt;蓝字&lt;/span&gt;关注我们&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.1176470588235294&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/l6ryX6MCe8gbTZCu4DCDb0G8icjTQbP0oAp7UwiaVCX2bFe7EqIKj0OQmSX1dveSTOOiafythEico4lRx5jRXKricXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;34&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.66640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/brwbhUj36Sx7lCvulE3DIfgAPYFGGUfOf2ruibNMpw9CMr3jO4qp4yN4vsuVf18Ueu6bcq50jbELCFXQRpNQqjg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;我们日常接触性能诊断问题，一般分为两种情况，一是线上应用真的出现性能问题；二是我们需要对准备上线的系统进行性能预估；后者需要压力测试辅助进行，此处不表。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;针对GO应用，性能诊断工具主要分为两层:OS层面和GO应用层面(go tool pprof /trace /gc)&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;OS诊断&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;系统诊断，我们一般主要关注三个方面: CPU 、Memory、I/O&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2 mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;1.1 CPU&lt;/span&gt;&lt;/h2&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;CPU诊断主要关注平均负载（Load Average），CPU使用率，上下文切换（Context Switch）。常用&lt;span&gt;&lt;strong&gt;top&lt;/strong&gt;&lt;/span&gt;命令查看cpu使用率以及服务器负载情况。&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.1296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/brwbhUj36Sx7lCvulE3DIfgAPYFGGUfOouKulWoXicmX7ib8xnpJQmSZjB1EZQjLEFl6472bIYfUorhWVEibYarSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;平均负载:0.14 0.07 0.06 分别表示过去1分钟、5分钟、15分钟的机器负载的平均值，根据经验，若负载数值小于0.7*CPU个数则正常，超过或者达到CPU核数的四五倍，则系统的负载就明显偏高。&lt;/p&gt;&lt;p&gt;CPU的上下文切换情况可&lt;span&gt;通过&lt;/span&gt;&lt;strong&gt;&lt;span&gt;vmstat&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;命令可以查看，上下文切换发生的场景有如下几种:&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;时间片用完，CPU正常调度下一个任务&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;被其他优先级更高的任务抢占&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;执行任务碰到I/O阻塞，挂起当前任务，切换到下一个任务&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;用户代码主动挂起当前任务让出CPU&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;多任务抢占资源，因没抢到而被挂起&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;硬件中断&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2 mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;1.2  Memory&lt;/span&gt;&lt;/h2&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;从操作系统角度，内存关注应用进程是否足够，可以使用 free –m 命令查看内存的使用情况。&lt;/p&gt;&lt;p&gt;通过 top 命令可以查看进程使用的虚拟内存 VIRT 和物理内存 RES，根据公式 VIRT = SWAP + RES 可以推算出具体应用使用的交换分区（Swap）情况，使用交换分区过大会影响 应用性能，可以将 swappiness 值调到尽可能小。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2 mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;1.3 I/O&lt;/span&gt;&lt;/h2&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;I/O 包括磁盘 I/O 和网络 I/O，一般情况下磁盘更容易出现 I/O 瓶颈。通过&lt;span&gt;&lt;strong&gt;iostat&lt;/strong&gt;&lt;/span&gt;可以查看磁盘的读写情况，通过 CPU 的 I/O wait 可以看出磁盘 I/O 是否正常。&lt;/p&gt;&lt;p&gt;如果磁盘 I/O 一直处于很高的状态，说明磁盘太慢或故障，成为了性能瓶颈，需要进行应用优化或者磁盘更换。&lt;/p&gt;&lt;p&gt;除了常用的 top、 ps、vmstat、iostat 等命令，还有其他 Linux 工具可以诊断系统问题，如 mpstat、tcpdump、netstat、pidstat、sar 等 更多Linux性能诊断工具如下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5873873873873874&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/brwbhUj36Sx7lCvulE3DIfgAPYFGGUfODpGoMKJia5YRHkgWiaFicyBDjM2rAfnNC4crRBOtUHVrPV84picvtg9zAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;555&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;GO应用诊断&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;go生态已经为我们提供了大量的API和诊断工具帮助我们解决go应用的性能问题。我们常用的大致可以分为两类:&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2 mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2.1 profiling&lt;/span&gt;&lt;/h2&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;profile一般被称为性能分析，对程序而言，就是程序运行时的各种概况信息，包括cpu占用情况、内存情况、线程情况等。方便分析昂贵或频繁调用的程序场景。&lt;/section&gt;&lt;section&gt;&lt;span&gt;如何使用？&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;1.首先&lt;/span&gt;&lt;span&gt;profiling代码埋入&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; _ &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;net/http/pprof&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        log.Println(http.ListenAndServe(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;0.0.0.0:9090&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.保存特定时间点的profile，例如保存heap信息&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;curl&lt;/span&gt; http://localhost:6060/debug/pprof/heap --output heap.tar.gz&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;3.使用go tool pprof 分析保存的profile快照，如分析上述heap信息&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;tool&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;pprof&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;heap&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.tar&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.gz&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2 mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2.1.1  CPU Profiling&lt;/span&gt;&lt;/h2&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;pprof可以帮忙我们分析出函数执行缓慢问题 &lt;span&gt; &lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;PU占用过高问题&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;go tool pprof &lt;span class=&quot;code-snippet__symbol&quot;&gt;http:&lt;/span&gt;/&lt;span class=&quot;code-snippet__regexp&quot;&gt;/localhost:6060/debug&lt;/span&gt;&lt;span class=&quot;code-snippet__regexp&quot;&gt;/pprof/profile&lt;/span&gt;?second=&lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;命令行方式: 常用命令 top  list traces&lt;/p&gt;&lt;p&gt;top: 查看按照占用内存或cpu多少排序的前10的函数信息&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;flat:当前函数占用的CPU时长（&lt;span&gt;&lt;strong&gt;不包含其调用的其他函数&lt;/strong&gt;&lt;/span&gt;）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;flat%:当前函数使用CPU占总CPU时长的百分比&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;sum%:前面每一行flat百分比的和&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;cum: 累计量，当前函数及其子函数占用CPU时长 &lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;cum%:累计量占总量的百分比&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;       cum&amp;gt;=flat&lt;/p&gt;&lt;p&gt;list: 查看某个函数的代码 以及该函数每行代码的指标信息&lt;/p&gt;&lt;p&gt;traces:打印所有函数调用栈 以及调用栈的指标信息&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.0140625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/brwbhUj36Sx7lCvulE3DIfgAPYFGGUfOeQA3ECiaHM1QIZqylVJPwcDpH681RanMxxdVgMpIibAvZ1HvfKfI5CQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;UI界面方式：从服务器download下生成的sample文件  &lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;go&lt;/span&gt; tool pprof -http=:&lt;span class=&quot;code-snippet__number&quot;&gt;8080&lt;/span&gt; pprof.xxx.samples.cpu.&lt;span class=&quot;code-snippet__number&quot;&gt;001&lt;/span&gt;.pb.gz&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.61328125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/brwbhUj36Sx7lCvulE3DIfgAPYFGGUfOyicag1qDSS6EXqGTCWA0icI2Ilm5SZwk8qMMGoicfic8iclm8nBNmS5wiaEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.51015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/brwbhUj36Sx7lCvulE3DIfgAPYFGGUfO87PlJ6OgdxD0SA79sGG7rwZPvoYsbVAeZ1luAwCkrfzJO3OJgh3wOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;Flame graph很清晰得可以看到当前CPU被哪些函数执行栈占用&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1.2 Heap Profiling&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;go tool pprof &lt;span class=&quot;code-snippet__symbol&quot;&gt;http:&lt;/span&gt;/&lt;span class=&quot;code-snippet__regexp&quot;&gt;/localhost:6060/debug&lt;/span&gt;&lt;span class=&quot;code-snippet__regexp&quot;&gt;/pprof/heap&lt;/span&gt;?second=&lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;命令行 UI查看方式 同理&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.66796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/brwbhUj36Sx7lCvulE3DIfgAPYFGGUfO37ZQPFXLfV6gS3hj3THd6nXBWalicznicS3jXvhIl1fWom5IZvKIaVZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.396875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/brwbhUj36Sx7lCvulE3DIfgAPYFGGUfO6Gib1BCUmRKqKu43LWRI2ZaqS7icB1pAItMlsbiceTwbibKxZM3ouibp0CA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;graph中方框越大 占用内存越多  火焰图 宽度越大 占用内存越多&lt;/p&gt;&lt;p&gt;SAMPLE-&amp;gt;inuse_objects可以查看当前的对象数量 这个参数对于分析gc线程占用较高cpu时很有用处 它侧重查看对象数量&lt;/p&gt;&lt;p&gt;inuse_space图可以查看具体的内存占用&lt;/p&gt;&lt;p&gt;毕竟对于10个100m的对象和1亿个10字节的对象占用内存几乎一样大，但是回收起来一亿个小对象肯定比10个大对象要慢很多。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;go tool pprof -inuse_space &lt;span class=&quot;code-snippet__symbol&quot;&gt;http:&lt;/span&gt;/&lt;span class=&quot;code-snippet__regexp&quot;&gt;/localhost:6060/debug&lt;/span&gt;&lt;span class=&quot;code-snippet__regexp&quot;&gt;/pprof/heap&lt;/span&gt; : 分析应用程序的常驻内存占用情况 （默认）&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;go tool pprof -alloc_objects &lt;span class=&quot;code-snippet__symbol&quot;&gt;http:&lt;/span&gt;/&lt;span class=&quot;code-snippet__regexp&quot;&gt;/localhost:6060/debug&lt;/span&gt;&lt;span class=&quot;code-snippet__regexp&quot;&gt;/pprof/heap&lt;/span&gt;: 分析应用程序的内存临时分配情况&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;.3 并发请求问题 查看方式跟上面类似。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;go tool pprof &lt;span class=&quot;code-snippet__symbol&quot;&gt;http:&lt;/span&gt;/&lt;span class=&quot;code-snippet__regexp&quot;&gt;/localhost:6060/debug&lt;/span&gt;&lt;span class=&quot;code-snippet__regexp&quot;&gt;/pprof/goroutine&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;go tool pprof &lt;span class=&quot;code-snippet__symbol&quot;&gt;http:&lt;/span&gt;/&lt;span class=&quot;code-snippet__regexp&quot;&gt;/localhost:6060/debug&lt;/span&gt;&lt;span class=&quot;code-snippet__regexp&quot;&gt;/pprof/block&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;go tool pprof &lt;span class=&quot;code-snippet__symbol&quot;&gt;http:&lt;/span&gt;/&lt;span class=&quot;code-snippet__regexp&quot;&gt;/localhost:6060/debug&lt;/span&gt;&lt;span class=&quot;code-snippet__regexp&quot;&gt;/pprof/mutex&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2 mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;2.2 tracing&lt;/span&gt;&lt;/h2&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;trace并不是万能的，它更侧重于记录分析 采样时间内运行时系统具体干了什么。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;收集trace数据的三种方式:&lt;/p&gt;&lt;p&gt;1. 使用runtime/trace包 调用trace.Start()和trace.Stop()&lt;/p&gt;&lt;p&gt;2. 使用go test -trace=&amp;lt;file&amp;gt;测试标识&lt;/p&gt;&lt;p&gt;3. 使用debug/pprof/trace handler 获取运行时系统最好的方法&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;例如，通过 &lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;go&lt;/span&gt; tool pprof http://localhost:6060/debug/pprof/trace?seconds=20 &amp;gt; trace.out&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;获取运行时服务的trace信息，&lt;span&gt;使用&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;go tool trace trace.&lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt; 会自动打开浏览器展示出UI界面&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.846875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/brwbhUj36Sx7lCvulE3DIfgAPYFGGUfO1kJnnAJbibgqlVmbOcx0jmmhW3ibZY7ySAibq3pubELMicZbufq4CyduFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;其中trace view 只能使用chrome浏览器查看，这里go截止1.14版本存在一个 bug，解决办法如下：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;tool trace trace.out 无法查看trace view&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;bug:https://github.com/golang/go/issues/25151&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;mac&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;解决版本：安装gotip&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;get golang.org/dl/gotip&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;gotip&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;download&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;then&lt;/span&gt;  &lt;span class=&quot;code-snippet__string&quot;&gt;使用 gotip tool trace trace.out即可&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;获取的trace.out 二进制文件也可以转化为pprof格式的文件&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;tool trace -pprof=TYPE trace.out &amp;gt; TYPE.pprof&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Tips&lt;/span&gt;:&lt;span class=&quot;code-snippet__string&quot;&gt;生成的profile文件 支持 network profiling、synchronization profiling、syscall profiling、scheduler profiling&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;tool pprof TYPE.pprof&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用gotip tool trace trace.out可以查看到trace view的丰富操作界面：&lt;/p&gt;&lt;p&gt;操作技巧：&lt;/p&gt;&lt;p&gt;ctrl + 1  选择信息&lt;/p&gt;&lt;p&gt;ctrl + 2 移动选区&lt;/p&gt;&lt;p&gt;ctrl + 3 放大选区&lt;/p&gt;&lt;p&gt;ctrl + 4 指定选区区间&lt;/p&gt;&lt;p&gt;shift + ? 帮助信息&lt;/p&gt;&lt;p&gt;AWSD跟游戏快捷键类似 玩起来跟顺手&lt;/p&gt;&lt;p&gt;整体的控制台信息 如下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.315625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/brwbhUj36Sx7lCvulE3DIfgAPYFGGUfOMqvic3WmearPhlg0IoCRzXnN2L3ItRSd5FO6lzldibj6giaeGiaWMR1jmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;goroutine区域选中时间区间&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5934065934065934&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/brwbhUj36Sx7lCvulE3DIfgAPYFGGUfOk2LAklZclufTyWe4EntS6n3bRrApTQNPBnf8FiaUUha5ozQQ9icwGa5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1274&quot;/&gt;&lt;/p&gt;&lt;p&gt;OS线程(Machine): 显示在执行期间有多少个线程在运行，其包含正在调用 Syscall（InSyscall）、运行中（Running）这两种状态。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.55390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/brwbhUj36Sx7lCvulE3DIfgAPYFGGUfOmz7lJXS0aO6yOOZwHrODvXLD6G7MxkL9tGK9bTv8dCD2vicRYJwic1Cw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;每个Processor分两层，上一层表示Processor上运行的goroutine的信息，下一层表示processor附加的事件比如SysCall 或runtime system events&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.34609375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/brwbhUj36Sx7lCvulE3DIfgAPYFGGUfO9kkhzmn68CvaZQGcDLvutOEPz48BHMkcd1lCkHmPib0YdXuAHx3gK5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;ctrl+3 放大选区，选中goroutine 可以查看，特定时间点 特定goroutine的执行堆栈信息以及关联的事件信息&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.55078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/brwbhUj36Sx7lCvulE3DIfgAPYFGGUfOEtDxDXIF2PNnhDqnksOAHCSn92GQsubINZUrWfaNnXXV6hCJnTsJXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;goroutine analysis&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.63046875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/brwbhUj36Sx7lCvulE3DIfgAPYFGGUfO23bdp926gOtQV45lJKeqXPHoicicjbMDW2FyZyQNXLodK0CKgvMAIM7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;点击goroutine的id 可以跳到trace view 详细查看goroutine具体干了什么&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;名称&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;含义&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;Execution&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;执行时间&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;Network wait&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;网络等待时间&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;Sync Block&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;同步阻塞时间&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;Blocking syscall&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;系统调用阻塞时间&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;Scheduler wait&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;调度等待时间&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;GC Sweeping&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;GC清扫时间&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;GC Pause&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;GC暂停时间&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;实践 一个延迟问题诊断&lt;/p&gt;&lt;p&gt;当我们一个执行关键任务的协程从运行中被阻塞。这里可能的原因：被syscall阻塞 、阻塞在共享内存(channel/mutex etc)、阻塞在运行时(如 GC)、甚至有可能是运行时调度器不工作导致的。这种问题使用pprof很难排查，&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用trace只要我们确定了时间范围就可以在proc区域很容易找到问题的源头&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.321875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/brwbhUj36Sx7lCvulE3DIfgAPYFGGUfOVgb9CFk7SuDlOXq3bcIfwarPKrQdm8iaXhILvmTmpydMAK1fMzKMYEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;上图可见，GC 的MARK阶段阻塞了主协程的运行&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;h2 mpa-is-content=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;2.3 GC&lt;/span&gt;&lt;/h2&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;golang的gc算法是根据标记清除改进的三色标记法，大概流程:&lt;br/&gt;&lt;/section&gt;&lt;p&gt;初始所有对象都是白色&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Stack scan阶段:&lt;span&gt;从root&lt;/span&gt;&lt;span&gt;出发扫描所有可达对象，标记为灰色并放入待处理队列；root包括全局指针和goroutine栈上的指针&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Mark阶段:1.&lt;span&gt;从待处理队列取出灰色对象，将其引用的对象标记为灰色并放入队列，自身标记为黑色 2. re-scan全局指针和栈，因为mark和用户程序并行运行，故过程1的时候可能会有新的对象分配，这时需要通过写屏障(write barrier)记录下来；re-scan再完成检查；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;重复步骤Mark阶段，直到灰色对象队列为空，执行清扫工作（白色即为垃圾对象）&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;go的三色标记法也存在STW(Stop The World&lt;span&gt;),大致有两个场景&lt;/span&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;GC即将开始时，需要STW 做一些准备工作， 如enable write barrier&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;re-scan也需要STW，否则上面Mark阶段的re-scan无法终止&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;通过GODEBUG=gctrace=1可以开启gc日志，查看gc的结果信息&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;$&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;GODEBUG=gctrace=1 go run main.go   &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;gc&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;1 @0.001s 19%: 0.014+3.7+0.015 ms clock, 0.11+2.8/5.7/3.2+0.12 ms cpu, 5-&amp;gt;6-&amp;gt;6 MB, 6 MB goal, 8 P&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;gc&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;2 @0.024s 6%: 0.004+3.4+0.010 ms clock, 0.032+1.4/4.5/5.3+0.085 ms cpu, 13-&amp;gt;14-&amp;gt;13 MB, 14 MB goal, 8 P&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;gc&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;3 @0.093s 3%: 0.004+6.1+0.027 ms clock, 0.032+0.19/11/15+0.22 ms cpu, 24-&amp;gt;25-&amp;gt;22 MB, 26 MB goal, 8 P&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;scvg&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;0 MB released&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;scvg&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;inuse: 4, idle: 58, sys: 63, released: 58, consumed: 4 (MB)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;scvg&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;0 MB released&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;scvg&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;inuse: 4, idle: 58, sys: 63, released: 58, consumed: 4 (MB)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;scvg&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;0 MB released&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;scvg&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;inuse: 4, idle: 58, sys: 63, released: 58, consumed: 4 (MB)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;scvg&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;0 MB released&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;scvg&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;inuse: 4, idle: 58, sys: 63, released: 58, consumed: 4 (MB)&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;格式&lt;/p&gt;&lt;p&gt;gc # @#s #%: #+#+# ms clock, #+#/#/#+# ms cpu, #-&amp;gt;#-&amp;gt;# MB, # MB goal, # P&lt;/p&gt;&lt;p&gt;含义&lt;/p&gt;&lt;p&gt;gc#：GC 执行次数的编号，每次叠加。&lt;/p&gt;&lt;p&gt;@#s：自程序启动后到当前的具体秒数。&lt;/p&gt;&lt;p&gt;#%：自程序启动以来在GC中花费的时间百分比。&lt;/p&gt;&lt;p&gt;#+...+#：GC 的标记工作共使用的 CPU 时间占总 CPU 时间的百分比。&lt;/p&gt;&lt;p&gt;#-&amp;gt;#-&amp;gt;# MB：分别表示 GC 启动时, GC 结束时, GC 活动时的堆大小.&lt;/p&gt;&lt;p&gt;#MB goal：下一次触发 GC 的内存占用阈值。&lt;/p&gt;&lt;p&gt;#P：当前使用的处理器 P 的数量。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;拓展&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;当我们的程序陷入CPU 和IO混和负载过高时，我们使用pprof profile只能检测出CPU耗时的函数，但是屏蔽了IO等待过长的函数。&lt;/section&gt;&lt;p&gt;https://github.com/felixge/fgprof  给出了一个解决方案：&lt;/p&gt;&lt;section&gt;具体做法是:用一个后台协程在采样时间区间内每秒99次调用runtime.GoruntineProfile，返回的结果忽略了协程当时消耗CPU还是非消耗CPU的区别 进行统计，保存在内存中的map中，可导出转化为pprof&lt;/section&gt;&lt;p&gt;具体用法：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;package&lt;/span&gt; main&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt;(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    _ &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;net/http/pprof&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;github.com/felixge/fgprof&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    http.DefaultServeMux.Handle(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;/debug/fgprof&quot;&lt;/span&gt;, fgprof.Handler())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        log.Println(http.ListenAndServe(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;:6060&quot;&lt;/span&gt;, &lt;span class=&quot;code-snippet__literal&quot;&gt;nil&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;git clone https:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;cd FlameGraph&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;curl -s &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;localhost:6060/debug/fgprof?seconds=3&#x27;&lt;/span&gt; &amp;gt; fgprof.fold&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;./flamegraph.pl fgprof.fold &amp;gt; fgprof.svg&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;如果遇到这种CPU消耗型和非CPU消耗型混合的情况下 可以试试排查下。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-category=&quot;引导&quot; data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;扫描二维码&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;获取更多精彩&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;光华路程序猿&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;120&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;120&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/brwbhUj36SyoCoJyPpV17ks2fEH3zn3D4nqD0TiaoytDa1nWVy2otQWNbQQKtvESltEUzqLyMOeAicCSPH2fMvwQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt; &lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6190751319d9314e97acfac4e768aba9</guid>
<title>万字长文聊缓存（下）：应用级缓存</title>
<link>https://toutiao.io/k/c1uc4c2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;摘要&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上一篇文章 万字长文聊缓存（上）中，我们主要如何围绕着Http做缓存优化，在后端服务器的应用层同样有很多地方可以做缓存，提高服务的效率；本篇我们就来继续聊聊应用级的缓存。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;缓存的命中率&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存的命中率是指从缓存中获取到数据的次数和总读取次数的比率，命中率越高证明缓存的效果越好。这是一个很重要的指标，应该通过监控这个指标来判断我们的缓存是否设置的合理。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;缓存的回收策略&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;基于时间&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;存活期：在设置缓存的同时设置该缓存可以存活多久，不论在存活期内被访问了多少次，时间到了都会过期&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;空闲期：是指缓存的数据多久没有被访问就过期&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;基于空间&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置缓存的存储空间，比如：设置缓存的空间是 1G，当达到了1G之后就会按照一定的策略将部分数据移除&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;基于缓存数量&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置缓存的最大条目数，当达到了设置的最大条目数之后按照一定的策略将旧的数据移除&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;基于Java对象引用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;弱引用：当垃圾回收器开始回收内存的时候，如果发现了弱引用，它将立即被回收。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;软引用：当垃圾回收器发现内存已不足的情况下会回收软引用的对象，从而腾出一下空间，防止发生内存溢出。软引用适合用来做堆缓存&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;缓存的回收算法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;FIFO 先进先出算法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LRU 最近最少使用算法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;LFU 最不常用算法&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Java缓存的类型&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;堆缓存&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆缓存是指把数据缓存在JVM的堆内存中，使用堆缓存的好处是没有序列化和反序列化的操作，是最快的缓存。如果缓存的数据量很大，为了避免造成OOM通常情况下使用的时软引用来存储缓存对象；堆缓存的缺点是缓存的空间有限，并且垃圾回收器暂停的时间会变长。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Gauva Cache实现堆缓存&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Cache&amp;lt;String, String&amp;gt; cache = CacheBuilder.newBuilder()&lt;br/&gt;                .build();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过&lt;code&gt;CacheBuilder&lt;/code&gt;构建缓存对象&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Gauva Cache的主要配置和方法&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;put&lt;/code&gt; : 向缓存中设置key-value&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;V get(K key, Callable&amp;lt;? extends V&amp;gt; loader)&lt;/code&gt; : 获取一个缓存值，如果缓存中没有，那么就调用loader获取一个然后放入到缓存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;expireAfterWrite&lt;/code&gt; : 设置缓存的存活期，写入数据后指定时间之后失效&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;expireAfterAccess&lt;/code&gt; : 设置缓存的空闲期，在给定的时间内没有被访问就会被回收&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;maximumSize&lt;/code&gt; : 设置缓存的最大条目数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;weakKeys/weakValues&lt;/code&gt; : 设置弱引用缓存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;softValues&lt;/code&gt; : 设置软引用缓存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;invalidate/invalidateAll&lt;/code&gt;: 主动失效指定key的缓存数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;recordStats&lt;/code&gt; : 启动记录统计信息，可以查看到命中率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;removalListener&lt;/code&gt; : 当缓存被删除的时候会调用此监听器，可以用于查看为什么缓存会被删除&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Caffeine实现堆缓存&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Caffeine是使用Java8对Guava缓存的重写版本，高性能Java本地缓存组件，也是Spring推荐的堆缓存的实现，与spring的集成可以查看文档https://docs.spring.io/spring-framework/docs/current/reference/html/integration.html#cache-store-configuration-caffeine。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于是对Guava缓存的重写版本，所以很多的配置参数都是和Guava缓存一致：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;initialCapacity&lt;/code&gt;: 初始的缓存空间大小&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;maximumSize&lt;/code&gt;: 缓存的最大条数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;maximumWeight&lt;/code&gt;: 缓存的最大权重&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;expireAfterAccess&lt;/code&gt;: 最后一次写入或访问后经过固定时间过期&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;expireAfterWrite&lt;/code&gt;: 最后一次写入后经过固定时间过期&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;expireAfter&lt;/code&gt; : 自定义过期策略&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;refreshAfterWrite&lt;/code&gt;: 创建缓存或者最近一次更新缓存后经过固定的时间间隔，刷新缓存&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;weakKeys&lt;/code&gt;: 打开key的弱引用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;weakValues&lt;/code&gt;：打开value的弱引用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;softValues&lt;/code&gt;：打开value的软引用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;recordStats&lt;/code&gt;：开启统计功能&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Caffeine的官方文档：https://github.com/ben-manes/caffeine/wiki&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;pom.xml中添加依赖&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;com.github.ben-manes.caffeine&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;caffeine&amp;lt;/artifactId&amp;gt;&lt;br/&gt;    &amp;lt;version&amp;gt;2.8.4&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Caffeine Cache提供了三种缓存填充策略：手动、同步加载和异步加载。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;手动加载：在每次get key的时候指定一个同步的函数，如果key不存在就调用这个函数生成一个值&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public Object manual(String key) {&lt;br/&gt;    Cache&amp;lt;String, Object&amp;gt; cache = Caffeine.newBuilder()&lt;br/&gt;            .expireAfterAccess(1, TimeUnit.SECONDS) //设置空闲期时长&lt;br/&gt;            .maximumSize(10)&lt;br/&gt;            .build();&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; cache.get(key, t -&amp;gt; setValue(key).apply(key));&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public Function&amp;lt;String, Object&amp;gt; setValue(String key){&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; t -&amp;gt; &lt;span&gt;&quot;https://silently9527.cn&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;同步加载：构造Cache时候，build方法传入一个CacheLoader实现类。实现load方法，通过key加载value。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public Object sync(String key){&lt;br/&gt;    LoadingCache&amp;lt;String, Object&amp;gt; cache = Caffeine.newBuilder()&lt;br/&gt;            .maximumSize(100)&lt;br/&gt;            .expireAfterWrite(1, TimeUnit.MINUTES) //设置存活期时长&lt;br/&gt;            .build(k -&amp;gt; setValue(key).apply(key));&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; cache.get(key);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public Function&amp;lt;String, Object&amp;gt; setValue(String key){&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; t -&amp;gt; &lt;span&gt;&quot;https://silently9527.cn&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;异步加载：AsyncLoadingCache是继承自LoadingCache类的，异步加载使用Executor去调用方法并返回一个CompletableFuture&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public CompletableFuture async(String key) {&lt;br/&gt;    AsyncLoadingCache&amp;lt;String, Object&amp;gt; cache = Caffeine.newBuilder()&lt;br/&gt;            .maximumSize(100)&lt;br/&gt;            .expireAfterWrite(1, TimeUnit.MINUTES)&lt;br/&gt;            .buildAsync(k -&amp;gt; setAsyncValue().get());&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; cache.get(key);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public CompletableFuture&amp;lt;Object&amp;gt; &lt;span&gt;&lt;span&gt;setAsyncValue&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; CompletableFuture.supplyAsync(() -&amp;gt; &lt;span&gt;&quot;公众号：贝塔学JAVA&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;监听缓存被清理的事件&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public void &lt;span&gt;&lt;span&gt;removeListener&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    Cache&amp;lt;String, Object&amp;gt; cache = Caffeine.newBuilder()&lt;br/&gt;            .removalListener((String key, Object value, RemovalCause cause) -&amp;gt; {&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;remove lisitener&quot;&lt;/span&gt;);&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;remove Key:&quot;&lt;/span&gt; + key);&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;remove Value:&quot;&lt;/span&gt; + value);&lt;br/&gt;            })&lt;br/&gt;            .build();&lt;br/&gt;    cache.put(&lt;span&gt;&quot;name&quot;&lt;/span&gt;, &lt;span&gt;&quot;silently9527&quot;&lt;/span&gt;);&lt;br/&gt;    cache.invalidate(&lt;span&gt;&quot;name&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;4&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;统计&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public void &lt;span&gt;&lt;span&gt;recordStats&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    Cache&amp;lt;String, Object&amp;gt; cache = Caffeine.newBuilder()&lt;br/&gt;            .maximumSize(10000)&lt;br/&gt;            .recordStats()&lt;br/&gt;            .build();&lt;br/&gt;    cache.put(&lt;span&gt;&quot;公众号&quot;&lt;/span&gt;, &lt;span&gt;&quot;贝塔学JAVA&quot;&lt;/span&gt;);&lt;br/&gt;    cache.get(&lt;span&gt;&quot;公众号&quot;&lt;/span&gt;, (t) -&amp;gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;);&lt;br/&gt;    cache.get(&lt;span&gt;&quot;name&quot;&lt;/span&gt;, (t) -&amp;gt; &lt;span&gt;&quot;silently9527&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    CacheStats stats = cache.stats();&lt;br/&gt;    System.out.println(stats);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 &lt;code&gt;Cache.stats()&lt;/code&gt; 获取到&lt;code&gt;CacheStats&lt;/code&gt;。&lt;code&gt;CacheStats&lt;/code&gt;提供以下统计方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;hitRate()&lt;/code&gt;: 返回缓存命中率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;evictionCount()&lt;/code&gt;: 缓存回收数量&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;averageLoadPenalty()&lt;/code&gt;: 加载新值的平均时间&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;EhCache实现堆缓存&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;EhCache 是老牌Java开源缓存框架，早在2003年就已经出现了，发展到现在已经非常成熟稳定，在Java应用领域应用也非常广泛，而且和主流的Java框架比如Srping可以很好集成。相比于 Guava Cache，EnCache 支持的功能更丰富，包括堆外缓存、磁盘缓存，当然使用起来要更重一些。使用 Ehcache 的Maven 依赖如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;    &amp;lt;groupId&amp;gt;org.ehcache&amp;lt;/groupId&amp;gt;&lt;br/&gt;    &amp;lt;artifactId&amp;gt;ehcache&amp;lt;/artifactId&amp;gt;&lt;br/&gt;    &amp;lt;version&amp;gt;3.6.3&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CacheManager cacheManager = CacheManagerBuilder.newCacheManagerBuilder().build(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;ResourcePoolsBuilder resource = ResourcePoolsBuilder.heap(10); //设置最大缓存条目数&lt;br/&gt;&lt;br/&gt;CacheConfiguration&amp;lt;String, String&amp;gt; cacheConfig = CacheConfigurationBuilder&lt;br/&gt;        .newCacheConfigurationBuilder(String.class, String.class, resource)&lt;br/&gt;        .withExpiry(ExpiryPolicyBuilder.timeToIdleExpiration(Duration.ofMinutes(10)))&lt;br/&gt;        .build();&lt;br/&gt;&lt;br/&gt;Cache&amp;lt;String, String&amp;gt; cache = cacheManager.createCache(&lt;span&gt;&quot;userInfo&quot;&lt;/span&gt;, cacheConfig);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ResourcePoolsBuilder.heap(10)&lt;/code&gt;设置缓存的最大条目数，这是简写方式，等价于&lt;code&gt;ResourcePoolsBuilder.newResourcePoolsBuilder().heap(10, EntryUnit.ENTRIES);&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;ResourcePoolsBuilder.newResourcePoolsBuilder().heap(10, MemoryUnit.MB)&lt;/code&gt;设置缓存最大的空间10MB&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;withExpiry(ExpiryPolicyBuilder.timeToIdleExpiration(Duration.ofMinutes(10)))&lt;/code&gt; 设置缓存空闲时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;withExpiry(ExpiryPolicyBuilder.timeToLiveExpiration(Duration.ofMinutes(10)))&lt;/code&gt; 设置缓存存活时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;remove/removeAll&lt;/code&gt;主动失效缓存，与Guava Cache类似，调用方法后不会立即去清除回收，只有在get或者put的时候判断缓存是否过期&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;withSizeOfMaxObjectSize(10,MemoryUnit.KB)&lt;/code&gt;限制单个缓存对象的大小，超过这两个限制的对象则不被缓存&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;堆外缓存&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;堆外缓存即缓存数据在堆外内存中，空间大小只受本机内存大小限制，不受GC管理，使用堆外缓存可以减少GC暂停时间，但是堆外内存中的对象都需要序列化和反序列化，KEY和VALUE必须实现Serializable接口，因此速度会比堆内缓存慢。在Java中可以通过 &lt;code&gt;-XX:MaxDirectMemorySize&lt;/code&gt; 参数设置堆外内存的上限&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CacheManager cacheManager = CacheManagerBuilder.newCacheManagerBuilder().build(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;// 堆外内存不能按照存储条目限制，只能按照内存大小进行限制，超过限制则回收缓存&lt;br/&gt;ResourcePoolsBuilder resource = ResourcePoolsBuilder.newResourcePoolsBuilder().offheap(10, MemoryUnit.MB);&lt;br/&gt;&lt;br/&gt;CacheConfiguration&amp;lt;String, String&amp;gt; cacheConfig = CacheConfigurationBuilder&lt;br/&gt;        .newCacheConfigurationBuilder(String.class, String.class, resource)&lt;br/&gt;        .withDispatcherConcurrency(4)&lt;br/&gt;        .withExpiry(ExpiryPolicyBuilder.timeToLiveExpiration(Duration.ofMinutes(10)))&lt;br/&gt;        .withSizeOfMaxObjectSize(10, MemoryUnit.KB)&lt;br/&gt;        .build();&lt;br/&gt;&lt;br/&gt;Cache&amp;lt;String, String&amp;gt; cache = cacheManager.createCache(&lt;span&gt;&quot;userInfo2&quot;&lt;/span&gt;, cacheConfig);&lt;br/&gt;cache.put(&lt;span&gt;&quot;website&quot;&lt;/span&gt;, &lt;span&gt;&quot;https://silently9527.cn&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(cache.get(&lt;span&gt;&quot;website&quot;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;磁盘缓存&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把缓存数据存放到磁盘上，在JVM重启时缓存的数据不会受到影响，而堆缓存和堆外缓存都会丢失；并且磁盘缓存有更大的存储空间；但是缓存在磁盘上的数据也需要支持序列化，速度会被比内存更慢，在使用时推荐使用更快的磁盘带来更大的吞吐率，比如使用闪存代替机械磁盘。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CacheManagerConfiguration&amp;lt;PersistentCacheManager&amp;gt; persistentManagerConfig = CacheManagerBuilder&lt;br/&gt;        .persistence(new File(&lt;span&gt;&quot;/Users/huaan9527/Desktop&quot;&lt;/span&gt;, &lt;span&gt;&quot;ehcache-cache&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;PersistentCacheManager persistentCacheManager = CacheManagerBuilder.newCacheManagerBuilder()&lt;br/&gt;        .with(persistentManagerConfig).build(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;//disk 第三个参数设置为 &lt;span&gt;true&lt;/span&gt; 表示将数据持久化到磁盘上&lt;br/&gt;ResourcePoolsBuilder resource = ResourcePoolsBuilder.newResourcePoolsBuilder().disk(100, MemoryUnit.MB, &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;CacheConfiguration&amp;lt;String, String&amp;gt; config = CacheConfigurationBuilder&lt;br/&gt;        .newCacheConfigurationBuilder(String.class, String.class, resource).build();&lt;br/&gt;Cache&amp;lt;String, String&amp;gt; cache = persistentCacheManager.createCache(&lt;span&gt;&quot;userInfo&quot;&lt;/span&gt;,&lt;br/&gt;        CacheConfigurationBuilder.newCacheConfigurationBuilder(config));&lt;br/&gt;&lt;br/&gt;cache.put(&lt;span&gt;&quot;公众号&quot;&lt;/span&gt;, &lt;span&gt;&quot;贝塔学JAVA&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(cache.get(&lt;span&gt;&quot;公众号&quot;&lt;/span&gt;));&lt;br/&gt;persistentCacheManager.close();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在JVM停止时，一定要记得调用&lt;code&gt;persistentCacheManager.close()&lt;/code&gt;，保证内存中的数据能够dump到磁盘上。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9418181818181818&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9F2ju7gN8IBGuHEx94w4UMPM8pORdbfyQj7PYPgpkGpkWibHaXwJUslSuquYeaSDbX9ZoicRottmTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;275&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是典型 heap + offheap + disk 组合的结构图，上层比下层速度快，下层比上层存储空间大，在ehcache中，空间大小设置 &lt;code&gt;heap &amp;gt; offheap &amp;gt; disk&lt;/code&gt;，否则会报错；ehcache 会将最热的数据保存在高一级的缓存。这种结构的代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CacheManagerConfiguration&amp;lt;PersistentCacheManager&amp;gt; persistentManagerConfig = CacheManagerBuilder&lt;br/&gt;        .persistence(new File(&lt;span&gt;&quot;/Users/huaan9527/Desktop&quot;&lt;/span&gt;, &lt;span&gt;&quot;ehcache-cache&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;PersistentCacheManager persistentCacheManager = CacheManagerBuilder.newCacheManagerBuilder()&lt;br/&gt;        .with(persistentManagerConfig).build(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;ResourcePoolsBuilder resource = ResourcePoolsBuilder.newResourcePoolsBuilder()&lt;br/&gt;        .heap(10, MemoryUnit.MB)&lt;br/&gt;        .offheap(100, MemoryUnit.MB)&lt;br/&gt;        //第三个参数设置为&lt;span&gt;true&lt;/span&gt;，支持持久化&lt;br/&gt;        .disk(500, MemoryUnit.MB, &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;CacheConfiguration&amp;lt;String, String&amp;gt; config = CacheConfigurationBuilder&lt;br/&gt;        .newCacheConfigurationBuilder(String.class, String.class, resource).build();&lt;br/&gt;&lt;br/&gt;Cache&amp;lt;String, String&amp;gt; cache = persistentCacheManager.createCache(&lt;span&gt;&quot;userInfo&quot;&lt;/span&gt;,&lt;br/&gt;        CacheConfigurationBuilder.newCacheConfigurationBuilder(config));&lt;br/&gt;&lt;br/&gt;//写入缓存&lt;br/&gt;cache.put(&lt;span&gt;&quot;name&quot;&lt;/span&gt;, &lt;span&gt;&quot;silently9527&quot;&lt;/span&gt;);&lt;br/&gt;// 读取缓存&lt;br/&gt;System.out.println(cache.get(&lt;span&gt;&quot;name&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;// 再程序关闭前，需要手动释放资源&lt;br/&gt;persistentCacheManager.close();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;分布式集中缓存&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面提到的堆内缓存和堆外缓存如果在多个JVM实例的情况下会有两个问题：1.单机容量毕竟有限；2.多台JVM实例缓存的数据可能不一致；3.如果缓存数据同一时间都失效了，那么请求都会打到数据库上，数据库压力增大。这时候我们就需要引入分布式缓存来解决，现在使用最多的分布式缓存是redis&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6351351351351351&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9F2ju7gN8IBGuHEx94w4UM1zxrCeWl4MRrFl6G5VjSVbjcDyBtPvraH9QKco8FA7uyQsu68L1HOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;740&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当引入分布式缓存之后就可以把应用缓存的架构调整成上面的结构。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;缓存使用模式的实践&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存使用的模式大概分为两类：Cache-Aside、Cache-As-SoR（SoR表示实际存储数据的系统，也就是数据源）&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Cache-Aside&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务代码围绕着缓存来写，通常都是从缓存中来获取数据，如果缓存没有命中，则从数据库中查找，查询到之后就把数据放入到缓存；当数据被更新之后，也需要对应的去更新缓存中的数据。这种模式也是我们通常使用最多的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;value = cache.get(key); //从缓存中读取数据&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(value == null) {&lt;br/&gt;    value = loadFromDatabase(key); //从数据库中查询&lt;br/&gt;    cache.put(key, value); //放入到缓存中&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;wirteToDatabase(key, value); //写入到数据库&lt;br/&gt;cache.put(key, value); //放入到缓存中 或者 可以删除掉缓存 cache.remove(key) ，再读取的时候再查一次&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring的Cache扩展就是使用的Cache-Aside模式，Spring为了把业务代码和缓存的读取更新分离，对Cache-Aside模式使用AOP进行了封装，提供了多个注解来实现读写场景。官方参考文档：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;@Cacheable&lt;/code&gt; : 通常是放在查询方法上，实现的就是&lt;code&gt;Cache-Aside&lt;/code&gt;读的场景，先查缓存，如果不存在在查询数据库，最后把查询出来的结果放入到缓存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;@CachePut&lt;/code&gt; : 通常用在保存更新方法上面，实现的就是&lt;code&gt;Cache-Aside&lt;/code&gt;写的场景，更新完成数据库后把数据放入到缓存中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;@CacheEvict&lt;/code&gt; : 从缓存中删除指定key的缓存&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;对于一些允许有一点点更新延迟基础数据可以考虑使用canal订阅binlog日志来完成缓存的增量更新。&lt;/p&gt;&lt;p&gt;Cache-Aside还有个问题，如果某个时刻热点数据缓存失效，那么会有很多请求同时打到后端数据库上，数据库的压力会瞬间增大&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Cache-As-SoR&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Cache-As-SoR模式也就会把Cache看做是数据源，所有的操作都是针对缓存，Cache在委托给真正的SoR去实现读或者写。业务代码中只会看到Cache的操作，这种模式又分为了三种&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Read Through&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用程序始终从缓存中请求数据，如果缓存中没有数据，则它负责使用提供的数据加载程序从数据库中检索数据，检索数据后，缓存会自行更新并将数据返回给调用的应用程序。Gauva Cache、Caffeine、EhCache都支持这种模式；&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Caffeine实现Read Through
由于Gauva Cache和Caffeine实现类似，所以这里只展示Caffeine的实现，以下代码来自Caffeine官方文档&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;LoadingCache&amp;lt;Key, Graph&amp;gt; cache = Caffeine.newBuilder()&lt;br/&gt;    .maximumSize(10_000)&lt;br/&gt;    .expireAfterWrite(10, TimeUnit.MINUTES)&lt;br/&gt;    .build(key -&amp;gt; createExpensiveGraph(key));&lt;br/&gt;&lt;br/&gt;// Lookup and compute an entry &lt;span&gt;if&lt;/span&gt; absent, or null &lt;span&gt;if&lt;/span&gt; not computable&lt;br/&gt;Graph graph = cache.get(key);&lt;br/&gt;// Lookup and compute entries that are absent&lt;br/&gt;Map&amp;lt;Key, Graph&amp;gt; graphs = cache.getAll(keys);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在build Cache的时候指定一个&lt;code&gt;CacheLoader&lt;/code&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;[1] 在应用程序中直接调用&lt;code&gt;cache.get(key)&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;[2] 首先查询缓存，如果缓存存在就直接返回数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;[3] 如果不存在，就会委托给&lt;code&gt;CacheLoader&lt;/code&gt;去数据源中查询数据，之后在放入到缓存，返回给应用程序&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;&lt;code&gt;CacheLoader&lt;/code&gt;不要直接返回null，建议封装成自己定义的Null对像，在放入到缓存中，可以防止缓存击穿&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了防止因为某个热点数据失效导致后端数据库压力增大的情况，我可以在&lt;code&gt;CacheLoader&lt;/code&gt;中使用锁限制只允许一个请求去查询数据库，其他的请求都等待第一个请求查询完成后从缓存中获取，在上一篇 《万字长文聊缓存（上）》中我们聊到了Nginx也有类似的配置参数&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;value = loadFromCache(key);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(value != null) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; value;&lt;br/&gt;}&lt;br/&gt;synchronized (lock) {&lt;br/&gt;    value = loadFromCache(key);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(value != null) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; value;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; loadFromDatabase(key);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;EhCache实现Read Through&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CacheManager cacheManager = CacheManagerBuilder.newCacheManagerBuilder().build(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;ResourcePoolsBuilder resource = ResourcePoolsBuilder.newResourcePoolsBuilder().heap(10, MemoryUnit.MB); //设置最大缓存条目数&lt;br/&gt;CacheConfiguration&amp;lt;String, String&amp;gt; cacheConfig = CacheConfigurationBuilder&lt;br/&gt;        .newCacheConfigurationBuilder(String.class, String.class, resource)&lt;br/&gt;        .withExpiry(ExpiryPolicyBuilder.timeToLiveExpiration(Duration.ofMinutes(10)))&lt;br/&gt;        .withLoaderWriter(new CacheLoaderWriter&amp;lt;String, String&amp;gt;(){&lt;br/&gt;            @Override&lt;br/&gt;            public String load(String key) throws Exception {&lt;br/&gt;                //load from database&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;silently9527&quot;&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            @Override&lt;br/&gt;            public void write(String key, String value) throws Exception {&lt;br/&gt;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            @Override&lt;br/&gt;            public void delete(String key) throws Exception {&lt;br/&gt;&lt;br/&gt;            }&lt;br/&gt;        })&lt;br/&gt;        .build();&lt;br/&gt;&lt;br/&gt;Cache&amp;lt;String, String&amp;gt; cache = cacheManager.createCache(&lt;span&gt;&quot;userInfo&quot;&lt;/span&gt;, cacheConfig);&lt;br/&gt;System.out.println(cache.get(&lt;span&gt;&quot;name&quot;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在EhCache中使用的是&lt;code&gt;CacheLoaderWriter&lt;/code&gt;来从数据库中加载数据；解决因为某个热点数据失效导致后端数据库压力增大的问题和上面的方式一样，也可以在&lt;code&gt;load&lt;/code&gt;中实现。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Write Through&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和Read Through模式类似，当数据进行更新时，先去更新SoR，成功之后在更新缓存。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Caffeine实现Write Through&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Cache&amp;lt;String, String&amp;gt; cache = Caffeine.newBuilder()&lt;br/&gt;        .maximumSize(100)&lt;br/&gt;        .writer(new CacheWriter&amp;lt;String, String&amp;gt;() {&lt;br/&gt;            @Override&lt;br/&gt;            public void write(@NonNull String key, @NonNull String value) {&lt;br/&gt;                //write data to database&lt;br/&gt;                System.out.println(key);&lt;br/&gt;                System.out.println(value);&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            @Override&lt;br/&gt;            public void delete(@NonNull String key, @Nullable String value, @NonNull RemovalCause removalCause) {&lt;br/&gt;                //delete from database&lt;br/&gt;            }&lt;br/&gt;        })&lt;br/&gt;        .build();&lt;br/&gt;&lt;br/&gt;cache.put(&lt;span&gt;&quot;name&quot;&lt;/span&gt;, &lt;span&gt;&quot;silently9527&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Caffeine通过使用&lt;code&gt;CacheWriter&lt;/code&gt;来实现Write Through，&lt;code&gt;CacheWriter&lt;/code&gt;可以同步的监听到缓存的创建、变更和删除操作，只有写成功了才会去更新缓存&lt;/p&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;EhCache实现Write Through&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CacheManager cacheManager = CacheManagerBuilder.newCacheManagerBuilder().build(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;ResourcePoolsBuilder resource = ResourcePoolsBuilder.newResourcePoolsBuilder().heap(10, MemoryUnit.MB); //设置最大缓存条目数&lt;br/&gt;CacheConfiguration&amp;lt;String, String&amp;gt; cacheConfig = CacheConfigurationBuilder&lt;br/&gt;        .newCacheConfigurationBuilder(String.class, String.class, resource)&lt;br/&gt;        .withExpiry(ExpiryPolicyBuilder.timeToLiveExpiration(Duration.ofMinutes(10)))&lt;br/&gt;        .withLoaderWriter(new CacheLoaderWriter&amp;lt;String, String&amp;gt;(){&lt;br/&gt;            @Override&lt;br/&gt;            public String load(String key) throws Exception {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;silently9527&quot;&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            @Override&lt;br/&gt;            public void write(String key, String value) throws Exception {&lt;br/&gt;                //write data to database&lt;br/&gt;                System.out.println(key);&lt;br/&gt;                System.out.println(value);&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            @Override&lt;br/&gt;            public void delete(String key) throws Exception {&lt;br/&gt;                //delete from database&lt;br/&gt;            }&lt;br/&gt;        })&lt;br/&gt;        .build();&lt;br/&gt;&lt;br/&gt;Cache&amp;lt;String, String&amp;gt; cache = cacheManager.createCache(&lt;span&gt;&quot;userInfo&quot;&lt;/span&gt;, cacheConfig);&lt;br/&gt;System.out.println(cache.get(&lt;span&gt;&quot;name&quot;&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;cache.put(&lt;span&gt;&quot;website&quot;&lt;/span&gt;,&lt;span&gt;&quot;https://silently9527.cn&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;EhCache还是通过&lt;code&gt;CacheLoaderWriter&lt;/code&gt;来实现的，当我们调用&lt;code&gt;cache.put(&quot;xxx&quot;,&quot;xxx&quot;)&lt;/code&gt;进行写缓存的时候，EhCache首先会将写的操作委托给&lt;code&gt;CacheLoaderWriter&lt;/code&gt;，有&lt;code&gt;CacheLoaderWriter.write&lt;/code&gt;去负责写数据源&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Write Behind&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种模式通常先将数据写入缓存，再异步地写入数据库进行数据同步。这样的设计既可以减少对数据库的直接访问，降低压力，同时对数据库的多次修改可以合并操作，极大地提升了系统的承载能力。但是这种模式也存在风险，如当缓存机器出现宕机时，数据有丢失的可能。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Caffeine要想实现Write Behind可以在&lt;code&gt;CacheLoaderWriter.write&lt;/code&gt;方法中把数据发送到MQ中，实现异步的消费，这样可以保证数据的安全，但是要想实现合并操作就需要扩展功能更强大的&lt;code&gt;CacheLoaderWriter&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;EhCache实现Write Behind&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;//1 定义线程池&lt;br/&gt;PooledExecutionServiceConfiguration testWriteBehind = PooledExecutionServiceConfigurationBuilder&lt;br/&gt;        .newPooledExecutionServiceConfigurationBuilder()&lt;br/&gt;        .pool(&lt;span&gt;&quot;testWriteBehind&quot;&lt;/span&gt;, 5, 10)&lt;br/&gt;        .build();&lt;br/&gt;&lt;br/&gt;CacheManager cacheManager = CacheManagerBuilder.newCacheManagerBuilder()&lt;br/&gt;        .using(testWriteBehind)&lt;br/&gt;        .build(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;ResourcePoolsBuilder resource = ResourcePoolsBuilder.newResourcePoolsBuilder().heap(10, MemoryUnit.MB); //设置最大缓存条目数&lt;br/&gt;&lt;br/&gt;//2 设置回写模式配置&lt;br/&gt;WriteBehindConfiguration testWriteBehindConfig = WriteBehindConfigurationBuilder&lt;br/&gt;        .newUnBatchedWriteBehindConfiguration()&lt;br/&gt;        .queueSize(10)&lt;br/&gt;        .concurrencyLevel(2)&lt;br/&gt;        .useThreadPool(&lt;span&gt;&quot;testWriteBehind&quot;&lt;/span&gt;)&lt;br/&gt;        .build();&lt;br/&gt;&lt;br/&gt;CacheConfiguration&amp;lt;String, String&amp;gt; cacheConfig = CacheConfigurationBuilder&lt;br/&gt;        .newCacheConfigurationBuilder(String.class, String.class, resource)&lt;br/&gt;        .withLoaderWriter(new CacheLoaderWriter&amp;lt;String, String&amp;gt;() {&lt;br/&gt;            @Override&lt;br/&gt;            public String load(String key) throws Exception {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;silently9527&quot;&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            @Override&lt;br/&gt;            public void write(String key, String value) throws Exception {&lt;br/&gt;                //write data to database&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            @Override&lt;br/&gt;            public void delete(String key) throws Exception {&lt;br/&gt;            }&lt;br/&gt;        })&lt;br/&gt;        .add(testWriteBehindConfig)&lt;br/&gt;        .build();&lt;br/&gt;&lt;br/&gt;Cache&amp;lt;String, String&amp;gt; cache = cacheManager.createCache(&lt;span&gt;&quot;userInfo&quot;&lt;/span&gt;, cacheConfig);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先使用&lt;code&gt;PooledExecutionServiceConfigurationBuilder&lt;/code&gt;定义了线程池配置；然后使用&lt;code&gt;WriteBehindConfigurationBuilder&lt;/code&gt;设置会写模式配置，其中&lt;code&gt;newUnBatchedWriteBehindConfiguration&lt;/code&gt;表示不进行批量写操作，因为是异步写，所以需要把写操作先放入到队列中，通过&lt;code&gt;queueSize&lt;/code&gt;设置队列大小，&lt;code&gt;useThreadPool&lt;/code&gt;指定使用哪个线程池; &lt;code&gt;concurrencyLevel&lt;/code&gt;设置使用多少个并发线程和队列进行Write Behind&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;EhCache实现批量写的操作也很容易&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先把&lt;code&gt;newUnBatchedWriteBehindConfiguration()&lt;/code&gt;替换成&lt;code&gt;newBatchedWriteBehindConfiguration(10, TimeUnit.SECONDS, 20)&lt;/code&gt;，这里设置的是数量达到20就进行批处理，如果10秒内没有达到20个也会进行处理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其次在&lt;code&gt;CacheLoaderWriter&lt;/code&gt;中实现wirteAll 和 deleteAll进行批处理&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;如果需要把对相同的key的操作合并起来只记录最后一次数据，可以通过&lt;code&gt;enableCoalescing()&lt;/code&gt;来启用合并&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;写到最后 点关注，不迷路&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文中或许会存在或多或少的不足、错误之处，有建议或者意见也非常欢迎大家与我交流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，&lt;strong&gt;「白嫖不好，创作不易」&lt;/strong&gt;，希望朋友们可以&lt;strong&gt;「点赞」&lt;/strong&gt;，因为这些就是我分享的全部动力来源🙏&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;源码地址：https://github.com/silently9527/CacheTutorial&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8764044943820225&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ggRgNal7zG9F2ju7gN8IBGuHEx94w4UMydibnddeSnUT3qibF1VjpOBzlVbcL7SbbLl6P2eKgzYOicNtupI6nBY0A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;267&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f191715275b058b272c94e60ac72f4ce</guid>
<title>程序员的发展空间有多大，如何突破 35 岁瓶颈？</title>
<link>https://toutiao.io/k/rampztn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA3ODk1Mzg0Mg==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/wzyc1ToJM6ia6icRKFLmvF8YJDluMxibzHolMFib4E1hXicpaKibTtn3QBHjGJROqpuOgLLhRjdpAy2pZkGRkW7NgMpA/0?wx_fmt=png&quot; data-nickname=&quot;老王说编程&quot; data-alias=&quot;lwsbc1024&quot; data-signature=&quot;还原编程思想、深入日常开发、分享最新技术及编程经验&quot;/&gt;&lt;/section&gt;&lt;p cid=&quot;n0&quot; mdtype=&quot;paragraph&quot;&gt;&lt;em&gt;&lt;span&gt;漫漫编程路，多少个日夜我们沉浸在扫除 BUG 的路上，永远在变的需求使我们养成了独特的好脾气。即使这样，还要面对在 35 岁的瓶颈时被扫地出门的窘况，这是很多程序员思考最多的问题，然而，只要梳理好每个阶段的规划，在每个阶段里不断进步这条程序路也能走出不一样的光彩。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.39655172413793105&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wzyc1ToJM6iacGByibqaBuibO8ibxHOJCXa716R1xqy9ia5ADfJM6BmhIOTczgJsnlwpZO62GHV35OdTuEVoGM9iadLg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;580&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n4&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;根据资料显示，在一般的职业发展中主要分为三个阶段：1-3 年是初级阶段，3-5 年是中级阶段，5-10 年是高级阶段，再往后可以是技术专家、技术总监、项目管理者等等。随着这几个阶段越来越高的情况下程序员的薪资水平也是越来越高的，工作年限越长企业自然认为你的能力也越强，但是你如果到了高级阶段的年龄却仍然还是中级阶段的技术或管理水平，这个时候企业当然会选择比你更年轻、身体状态更好的年轻人来做这件事情。所谓程序员的 35 岁瓶颈其实就是你的年龄和你的能力不匹配的问题，作为猿童鞋不能只做编码的搬运工，活到老、学到老这是我们必须具备的一种编程素质。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n4&quot; mdtype=&quot;paragraph&quot;&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1614007248101&quot; data-category_id_list=&quot;42&quot; data-id=&quot;1614007248101&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n6&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;plain&quot;&gt;一般在工作 5 年时间的时候就应该提前认真考虑自己的发展方向了，作为项目开发的猿童鞋发展方向还是比较多的。如果一直钟爱技术，那就必须积累系统架构方面的知识，因为以后你是要掌控全局的，没有对项目整体的技术把控那是不可行的。当然，测试岗位也是一个不错的选择，而且薪资也不错，在这里我要说一下 “千万不要小看测试”，大多数项目中测试人员的分量比需求还大，面对不断变化的需求有时候只有测试人员才说的清楚。另外，还可以转型为管理岗，作为 PM 猿童鞋转过来也是比较容易的，但是要特别注意的就是自己的沟通态度得好好练练。也有猿童鞋能够凭借自己的努力当上 CTO，那也是令多数猿童鞋比较羡慕的。如果可以，数据库 DBA 也是比较好的。最后就是自己创业或者做一个自由职业者，凭借自己的技术、经验选择一个自己喜欢的方向。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n6&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;欢迎关注 “老王说编程“，每天进步一点点，您的每一个点赞、在看、分享都是在致力于减少 “攻城狮” 产出的 BUG，欢迎大家在评论区进行留言，一起学习，一起成长！&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;h5 cid=&quot;n22&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;&lt;em&gt;&lt;span md-inline=&quot;plain&quot;&gt;往期精彩&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;span md-inline=&quot;plain&quot;/&gt;&lt;/h5&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;span md-inline=&quot;plain&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3ODk1Mzg0Mg==&amp;amp;mid=2649848595&amp;amp;idx=1&amp;amp;sn=5deeb995e4c42ae4decf4785f5254b1d&amp;amp;chksm=87bf370eb0c8be183538b1717b2422ebd40f2d3decc05b891a5d19adce1984301dbaedbe7458&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Linux 的常用命令你真的都了解吗，100 个必须要学会的 Shell 命令&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3ODk1Mzg0Mg==&amp;amp;mid=2649848581&amp;amp;idx=1&amp;amp;sn=09371d0291c7e3790d4ba7a41bdfe4d0&amp;amp;chksm=87bf3718b0c8be0e918aff84cf41a3bf78f063fcf0981ecb626893d9c9663f62713f0d6b062d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;IPython 的编程技巧（Python 开发必备神器）&lt;/a&gt;&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3ODk1Mzg0Mg==&amp;amp;mid=2649848575&amp;amp;idx=1&amp;amp;sn=c96eeba40c46e907556e88fd8cf79a5e&amp;amp;chksm=87bf36e2b0c8bff48bbf2d8a7f938c96771874c3348d41e757e1090b9cf2d929aa42dd663d02&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Tomcat 性能调优应该注意什么？&lt;/a&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3ODk1Mzg0Mg==&amp;amp;mid=2649848555&amp;amp;idx=1&amp;amp;sn=7e62c6396761c41da77992ef6225b360&amp;amp;chksm=87bf36f6b0c8bfe08b78892983cabe8dabeb2ea825fd380d899987b9c59b190d076de810bd2b&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;em&gt;&lt;span&gt;Java8 的 Lambda 表达式&lt;/span&gt;&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3ODk1Mzg0Mg==&amp;amp;mid=2649848550&amp;amp;idx=1&amp;amp;sn=ebf37329e00c2622f0271bc3fb0118e9&amp;amp;chksm=87bf36fbb0c8bfed9f1f8411d21bfaed8a11d85401a5680265d75f4998e9df9c90598dfbd020&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;em&gt;&lt;span&gt;Python 如何实现最简单的多人聊天室&lt;/span&gt;&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3ODk1Mzg0Mg==&amp;amp;mid=2649848514&amp;amp;idx=1&amp;amp;sn=e330c08961a24b710bb713e9641aefc2&amp;amp;chksm=87bf36dfb0c8bfc9d95f3655cd0b6d0fe455a7c3ec370e783a629d94cd3204d4511202be9911&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;em&gt;&lt;span&gt;Python 如何正确使用 MongoDB 数据库&lt;/span&gt;&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3ODk1Mzg0Mg==&amp;amp;mid=2649848483&amp;amp;idx=1&amp;amp;sn=f000a9164091cfda69e57b89756a9c0a&amp;amp;chksm=87bf36beb0c8bfa8e80334c9e26e518c53597f1ac055ae1d83248a5669d086c4f5fc78ae6647&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;em&gt;&lt;span&gt;Crontab 定时任务的正则表达式&lt;/span&gt;&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>966cea8510463a46914847c005d19c05</guid>
<title>红蓝对抗中的云原生漏洞挖掘及利用实录</title>
<link>https://toutiao.io/k/374s1bi</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.153125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSft3kiaFeL3sNcKuFicncMlK5gCgqIDPCPtaetXqMkNiaG5R8Zqby04P7h9g/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;文｜&lt;/strong&gt;腾讯蓝军 neargle、pk&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;2.0536585&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftD1uLz0ib8l98OVVoJ1H8Da7JTGbyR9SgnR9eG6qjRzRhPG1jJCJ4g1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;820&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;1. 背景&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2020年年末的时候，我们于CIS2020上分享了议题《Attack in a Service Mesh》讲述我们在近一年红蓝对抗演练中所遇到的云原生企业架构以及我们在服务网格攻防场景沉淀下来的一些方法论。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;回顾近几年腾讯蓝军在云原生安全上的探索和沉淀，我们在2018年的时候开始正式投入对Serverless和容器编排技术在攻防场景的预研，并把相关的沉淀服务于多个腾讯基础设施和产品之上，而在近期内外部的红蓝对抗演练中腾讯蓝军也多次依靠在云原生场景上的漏洞挖掘和漏洞利用，进而突破防御进入到内网或攻破核心靶标；特别是2020年度的某云安全演习更是通过云原生的安全问题才一举突破层层对抗进入内网。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本篇文章我们想聚焦于攻防对抗中所沉淀下来的漏洞，分享我们在多处攻防场景所遇到的云原生相关的漏洞挖掘和漏洞利用实例。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注：本材料所有内容仅供安全研究和企业安全能力建设参考，请勿用于未授权渗透测试和恶意入侵攻击。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;2. 攻防演练中的云原生安全&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;CNCF（云原生计算基金会  Cloud Native Computing Foundation）在对云原生定义的描述中提到“云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式API”；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们今天所聊到的漏洞和利用手法也紧紧围绕着上述的几类技术和由云原生相关技术所演化出来的多种技术架构进行，包括但不限于容器、服务网格、微服务、不可变基础设施、声明式API、无服务架构、函数计算、DevOps等，并涉及研发团队在使用的一些云原生开源组件和自研、二次开发时常见的安全问题。不在“云原生安全”这个概念上做过多的延伸和扩展，且提及所有的安全漏洞都在“腾讯蓝军”对内对外的攻防演练和漏洞挖掘中有实际的利用经验积累。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在实际的攻防中我们所进行的攻击路径并非完全契合在CIS2020上总结的攻击模型：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.3981481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftBdfO2wkP8CxGyLPo3g9YnEbsMnrYicqc20yEgrxWVmdLEWUwue54Skw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因为大部分情况下我们遇到的内网并非完全基于容器技术所构建的，所以内网的起点并不一定是一个权限受限的容器，但攻击的方向和目标却大同小异：为了获取特定靶标的权限、资金和数据，我们一般需要控制更多乃至全部的容器、主机和集群。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;也由于业界云原生实践的发展非常迅速，虽然进入内网之后我们所接触的不一定是全是Kubernetes所编排下的容器网络和架构，但基于云原生技术所产生的新漏洞和利用手法往往能帮蓝军打开局面。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;举个例子，当我们通过远控木马获取某个集群管理员PC上的 kubeconfig 文件 （一般位于 ~/.kube/config 目录），此时我们就拥有了管理Kubernetes集群的所有能力了，具体能做的事情后面会有更详细的探讨。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果此时该集群没有设置严格的 security policy 且目标企业的HIDS没有针对容器特性进行一定策略优化的话，那创建一个能获取NODE权限的POD或许就是一个不错的选择，因为只有这样获取的shell才能更方便的在容器母机上进行信息收集，例如 strace 母机 sshd 进程抓取我们想要的用户名和密码、使用 tcpdump 抓取内网系统的管理员登录态等，目前正在运行的容器一般是没有这些权限的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以下是这种情况下我们常用的 POD yaml 配置：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.6312741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftwCHtcUarg5Q2TibAGToyUjjicA79dtZD5WicGABfq5W5Td7yPAaRicHLqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;518&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果对Kubernetes的POD不熟悉，其实上述的配置就比较类似于在想要ROOT权限的业务服务器上执行以下 docker 命令:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;docker -H ${host_docker_sock} run -d -it --name neartest_Kubernetes_hashsubix -v &quot;/proc:/host/proc&quot; -v &quot;/sys:/host/sys&quot; -v &quot;/:/near_sandbox&quot; --network=host --privileged=true --cap-add=ALL alpine:latest /bin/sh -c tail -f /dev/null&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;执行的结果和作用如下(注：所有的挂载和选项并非都必须，实战中填写需要的权限和目录即可，此处提供一个较全的参考)：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftgtxzp2bHN2wPiclVFXdjiaI3GThc2EllRLEjqhe5VhQNH4FDsz0srf8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当然上述大部分配置都会被多租户集群下的 Kubernetes Security Policy 所拦截，且如果目前主机上的HIDS 有一定容器安全能力的话，这类配置的容器创建行为也比较容易会被标记为异常行为。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不过，显然我们在真实的对抗中如果只是想达到执行 strace 抓取 sshd 的目的，配置可以更加简化一点，只需添加 SYS_PTRACE 的 capabilities 即可，我在演习中也正是这么做的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因为具有 SYS_PTRACE 权限的容器并且进行 kubectl exec 的行为在实际的研发运维流程中非常常见，是HIDS比较不容易察觉的类业务型操作；另外也可以寻找节点上已有该配置的容器和POD进行控制，同样是不易被防御团队所察觉的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1101852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftEhyicH6Zpv2lsLiap7t9dLyM2r8QPyLrLaNvOpkmicQZZxwkltSsIiaaPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;接下来我们也会一个个讨论这类漏洞和手法和我们实际在对抗中遇到的场景。同时，无论是在CNCF对云原生的定义里，还是大家对云原生技术最直观的感受，大部分技术同学都会想到容器以及容器编排相关的技术，这里我们就以容器为起始，开启我们今天的云原生安全探索之旅吧~&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;3. 单容器环境内的信息收集&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当我们获取了一个容器的shell，或许 cat /proc/1/cgroup 是我们首要要执行的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.2425926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftGKIPgDbCSJNK6zfH8HMBPGtTt0A7ofib1Ricj5SMtTmM01ItbDpwn8uA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;毕竟从内核角度看容器技术的关键就是 CGroup 和 Namespace，或许应该再加一个Capabilities。从 CGroup 信息中，不仅可以判断我们是否在容器内，也能很方便判断出当前的容器是否在 Kubernetes 的编排环境中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;毕竟没使用Kubernetes的docker容器，其cgroup信息长这样：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;12:hugetlb:/docker/9df9278580c5fc365cb5b5ee9430acc846cf6e3207df1b02b9e35dec85e86c36&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而 Kubernetes默认的，长这样：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;12:hugetlb:/kubepods/burstable/pod45226403-64fe-428d-a419-1cc1863c9148/e8fb379159f2836dbf990915511a398a0c6f7be1203e60135f1cbdc31b97c197&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;同时，这里的CGroup信息也是宿主机内当前容器所对应的CGroup路径，在后续的多个逃逸场景中获取 CGroup 的路径是非常重要的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;同类判断当前shell环境是否是容器，并采集容器内信息的还有很多，举个不完全的例子：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;ps aux&lt;/p&gt;&lt;p&gt;ls -l .dockerenv&lt;/p&gt;&lt;p&gt;capsh --print&lt;/p&gt;&lt;p&gt;env | grep KUBE&lt;/p&gt;&lt;p&gt;ls -l /run/secrets/Kubernetes.io/&lt;/p&gt;&lt;p&gt;mount&lt;/p&gt;&lt;p&gt;df -h&lt;/p&gt;&lt;p&gt;cat /etc/resolv.conf&lt;/p&gt;&lt;p&gt;cat /etc/mtab&lt;/p&gt;&lt;p&gt;cat /proc/self/status&lt;/p&gt;&lt;p&gt;cat /proc/self/mounts&lt;/p&gt;&lt;p&gt;cat /proc/net/unix&lt;/p&gt;&lt;p&gt;cat /proc/1/mountinfo&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6546763&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftPaEEMDapm7RgLEpRRPibpPezFWy7K4D44qhOs2UgdRENTicibzaCicFC2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;834&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其中 capsh --print 获取到信息是十分重要的，可以打印出当前容器里已有的 Capabilities 权限；历史上，我们曾经为了使用 strace 分析业务进程，而先设法进行容器逃逸忘记看当前容器的 Capabilities 其实已经拥有了 ptrace 权限，绕了一个大弯子。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.237963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftcgCLWayVj5MuKrHtibFOsoIsWrDc7Onr5cTbzIPXpafkq2hjnAv16Jg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是，容器的 SHELL 环境里经常遇到无法安装新工具，且大部分常用工具都在镜像里被精简或阉割了。这时理解工具背后的原理并根据原理达到相同的效果就很重要。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以 capsh 为例，并非所有的容器镜像里都可以执行 capsh，这时如果想要获取当前容器的  Capabilities 权限信息，可以先 cat /proc/1/status 获取到 Capabilities hex 记录之后，再使用 capsh --decode 解码出 Capabilities 的可读字符串即可。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.162963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSft1HBSRN9nBvtlv2iaVEWKYyYdEVx12K1qRjDGeOic5USvFXCaAx23RtvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其他如 mount, lsof 等命令也类似。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另外一个比较常见就是 kubectl 命令的功能复现，很多情况下我们虽然获得了可以访问 APIServer 的网络权限和证书（又或者不需要证书）拥有了控制集群资源的权限，却无法下载或安装一个 kubectl 程序便捷的和 APIServer 通信，此时我们可以配置 kubectl 的 logging 登机，记录本地 kubectl 和测试APIServer的请求详情，并将相同的请求包发送给目标的 APIServer以实现相同的效果。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;kubectl create -f cronjob.yaml -v=8&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果需要更详细的信息，也可以提高 logging level, 例如 kubectl -v=10 等，其他 Kubernetes 组件也能达到相同的目的。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.1777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSft3BicWNtm2RTCWS67EMSES3h6thcljtORdUEWb73W5ibvtHZOve5x18bw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;4. 容器网络&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以 Kubernetes 为例，容器与容器之间的网络是极为特殊的。虽然大部分经典IDC内网的手法和技巧依然可以使用，但是容器技术所构建起来的是全新的内网环境，特别是当企业引入服务网格等云原生技术做服务治理时，整个内网和IDC内网的差别就非常大了；因此了解一下 Kubernetes 网络的默认设计是非常重要的，为了避免引入复杂的Kubernetes网络知识，我们以攻击者的视角来简述放在蓝军面前的Kubernetes网络。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7619893&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftcXMH816vZg00WRsgnomrkInQYzToiaJU76Rv4wmF7x2srIEiaOXG4dJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;563&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从上图可以很直观的看出，当我们获取Kubernetes集群内某个容器的shell，默认情况下我们可以访问以下几个内网里的目标：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;1. 相同节点下的其它容器开放的端口&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2. 其他节点下的其它容器开放的端口&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;3. 其它节点宿主机开放的端口&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;4. 当前节点宿主机开放的端口&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;5. Kubernetes Service 虚拟出来的服务端口&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;6. 内网其它服务及端口，主要目标可以设定为 APISERVER、ETCD、Kubelet 等&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;br/&gt;不考虑对抗和安装门槛的话，使用 masscan 和 nmap 等工具在未实行服务网格的容器网络内进行服务发现和端口探测和在传统的IDC网络里区别不大；当然，因为 Kubernetes Service 虚拟出来的服务端口默认是不会像容器网络一样有一个虚拟的 veth 网络接口的，所以即使 Kubernetes Service 可以用 IP:PORT 的形式访问到，但是是没办法以 ICMP 协议做 Service 的 IP 发现（Kubernetes Service 的 IP 探测意义也不大）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另如果HIDS、NIDS在解析扫描请求时，没有针对 Kubernetes的 IPIP Tunnle 做进一步的解析，可能产生一定的漏报。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;注：若Kubernetes集群使用了服务网格，其中最常见的就是 istio，此时服务网格下的内网和内网探测手法变化是比较大的。可以参考引用中：《腾讯蓝军： CIS2020 - Attack in a Service Mesh》；由于 ISTIO 大家接触较少，此处不再展开。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;也因此多租户集群下的默认网络配置是我们需要重点关注的，云产品和开源产品使用容器做多租户集群下的隔离和资源限制的实现并不少见，著名的产品有如 Azure Serverless、Kubeless 等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;若在设计多租户集群下提供给用户代码执行权限即容器权限的产品时，还直接使用 Kubernetes 默认的网络设计是不合理的且非常危险。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;很明显一点是，用户创建的容器可以直接访问内网和Kubernetes网络。在这个场景里，合理的网络设计应该和云服务器VPS的网络设计一致，用户与用户之间的内网网络不应该互相连通，用户网络和企业内网也应该进行一定程度的隔离，上图中所有对内的流量路径都应该被切断。把所有用户 POD 都放置在一个Kubernetes namespace下就更不应该了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;5. 关于逃逸的那些事&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;要更好的理解容器逃逸的手法，应该知道本质上容器内的进程只是一个受限的普通Linux进程，容器内部进程的所有行为对于宿主机来说是透明的，这也是众多容器EDR产品可以直接在主机或SideCar内做容器运行时安全的基础之一。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们可以很容易在宿主机用 ps 看到容器进程信息：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.0703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftq0qxLqTBAK3nWHNkMplc0oMG5sxyGVBhR93gDhEvtwGXKjeAQFuKIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以，容器逃逸的本质和硬件虚拟化逃逸的本质有很大的不同(不包含 Kata Containers 等 )，我的理解里容器逃逸的过程是一个受限进程获取未受限的完整权限，又或某个原本受Cgroup/Namespace限制权限的进程获取更多权限的操作，更趋近于提权。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而在对抗上，不建议将逃逸的行为当成可以写入宿主机特定文件(如 /etc/cron*, /root/.ssh/authorized_keys 等文件)的行为，应该根据目标选择更趋近与业务行为的手法，容器逃逸的利用手段会比大部分情况下的命令执行漏洞利用要灵活。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以目标“获取宿主机上的配置文件”为例，以下几种逃逸手法在容易在防御团队中暴露的概率从大到小，排序如下(部分典型手法举例，不同的EDR情况不同)：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;1. mount /etc + write crontab&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2. mount /root/.ssh + write authorized_keys&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;3. old CVE/vulnerability exploit&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;4. write cgroup notify_on_release&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;5. write procfs core_pattern&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;6. volumeMounts: / + chroot&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;7. remount and rewrite cgroup&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;8. create ptrace cap container&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;9. websocket/sock shell + volumeMounts: /path&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们来一一看一下利用场景和方法：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;5.1. privileged 容器内 mount device&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用privileged特权容器是业界最常见以及最广为人知的逃逸手法，对容器安全有一定要求的产品一般都会严格限制特权容器的使用和监控。不过依然会有一些著名的云产品犯类似的低级错误，例如微软的 Azure 出现的问题：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;https://thehackernews.com/2021/01/new-docker-container-escape-bug-affects.html&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;privileged特权容器的权限其实有很多，所以也有很多不同的逃逸方式，挂载设备读写宿主机文件是特权容器最常见的逃逸方式之一。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当你进入 privileged 特权容器内部时，你可以使用 `fdisk -l` 查看宿主机的磁盘设备：&lt;/p&gt;&lt;p&gt;fdisk -l&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4092593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftGfNAXmbY6uvBia2ssPzWPZO09zlxyoeQfGY2Et96NickicqVYhYSLgibMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果不在 privileged 容器内部，是没有权限查看磁盘列表并操作挂载的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1973929&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSft8w0dfp2xjr4r6BWKCfs5uKpR58aj9YqAsJZPR542xnKC56Tdmiczf1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1074&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因此，在特权容器里，你可以把宿主机里的根目录 / 挂载到容器内部，从而去操作宿主机内的任意文件，例如 crontab config file, /root/.ssh/authorized_keys, /root/.bashrc 等文件，而达到逃逸的目的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.387037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSft2Q8Gdwwz7Kslf31TXMuUu1pPPnCHYGpCDibcltRdeGczics9V11EiaD5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;当然这类的文件的读写是EDR和HIDS重点监控的对象，所以是极易触发告警的；即使HIDS不一定有针对容器安全的特性进行优化，对此类的逃逸行为依旧有一些检测能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;5.2. 攻击 lxcfs&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;lxcfs 的场景和手法应该是目前业界HIDS较少进行覆盖的，我们目前也未在真实的攻防场景中遇到 lxcfs 所导致的容器逃逸利用，学习到这个有趣的场景主要还是来自于 @lazydog 师傅在开源社区和私聊里的分享，他在自己的实际蓝军工作中遇到了 lxcfs 的场景，并调研文档和资料构建了一套相应的容器逃逸思路；由此可见，这个场景和手法在实际的攻防演练中也是非常有价值的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;lxcfs： https://linuxcontainers.org/lxcfs/&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;假设业务使用 lxcfs 加强业务容器在 /proc/ 目录下的虚拟化，以此为前提，我们构建出这样的 demo pod:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7438424&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSft1G5hEGn2nOicDpFookOYNsyicbG6RARkn8o9licXQRlhpNooetfuzqBNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;812&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;并使用 `lxcfs /data/test/lxcfs/` 修改了 data 目录下的权限。若蓝军通过渗透控制的是该容器实例，则就可以通过下述的手法达到逃逸访问宿主机文件的目的，这里简要描述一下关键的流程和原理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（1）首先在容器内，蓝军需要判断业务是否使用了 lxcfs，在 mount 信息里面可以进行简单判断，当然容器不一定包含 mount 命令，也可以使用 cat /proc/1/mountinfo 获取&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftqyVYKOTgP0AoQNODZ1K4HIZCmIVEY26jluyICLqtt7KqaJzx2SnpCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（2）此时容器内会出现一个新的虚拟路径：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1712963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftv1x875RksBQzoI6fufzz26pmIYOvumjBUg1Lq6NXCCjfgqHn8K4AIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;（3）更有趣的是，该路径下会绑定当前容器的 devices subsystem cgroup 进入容器内，且在容器内有权限对该 devices subsystem 进行修改。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用 echo a &amp;gt; devices.allow 可以修改当前容器的设备访问权限，致使我们在容器内可以访问所有类型的设备。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1694444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftlHhr7YzFOqx19KDYSy28icQTXFmWKdeZkjYSCpao7CU3LX63kvSds5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（4）如果跟进过 CVE-2020-8557 这个具有Kubernetes特色的拒绝服务漏洞的话，应该知道&lt;/p&gt;&lt;p&gt;/etc/hosts， /dev/termination-log，/etc/resolv.conf， /etc/hostname 这四个容器内文件是由默认从宿主机挂载进容器的，所以在他们的挂载信息内很容易能获取到主设备号ID。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.0925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftaDwpX3m03LqY7DkaWfzPOFB57iatun8yhuOJODZtXDO1SoR07LYTRKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（5）我们可以使用 mknod 创建相应的设备文件目录并使用 debugfs 进行访问，此时我们就有了读写宿主机任意文件的权限。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.3472222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftwacESL1sXDo8ZDKpia4qGyyibXtqtQbcSIh95DCRgjpuXYIoJTIly3Gw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个手法和利用方式不仅可以作用于 lxcfs 的问题，即使没有安装和使用 lxcfs，当容器为 privileged、sys_admin 等特殊配置时，可以使用相同的手法进行逃逸。我们曾经多次使用类似的手法逃逸 privileged、sys_admin 的场景(在容器内 CAPABILITIES sys_admin 其实是 privileged 的子集)，相较之下会更加隐蔽。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当然自动化的工具可以帮我们更好的利用这个漏洞并且考虑容器内的更多情况，这里自动化EXP可以使用CDK工具(该工具由笔者 neargle 和 CDXY 师傅一同研发和维护，并正在持续迭代中)：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;https://github.com/cdk-team/CDK/wiki/Exploit:-lxcfs-rw&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;逃逸章节所使用的技巧很多都在 CDK 里有自动化的集成和实现。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;5.3. 创建 cgroup 进行容器逃逸&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上面提到了 privileged 配置可以理解为一个很大的权限集合，可以直接 mount device 并不是它唯一的权限和利用手法，另外一个比较出名的手法就是利用 cgroup release_agent 进行容器逃逸以在宿主机执行命令，这个手法同样可以作用于 sys_admin 的容器。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;shell 利用脚本如下（bash 脚本参考： https://github.com/neargle/cloud_native_security_test_case/blob/master/privileged/1-host-ps.sh）：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.9833333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftEWoZ2qyfQR8GX93YnMXf5adbPsONoOGjWgdznasxJdciaib9PNHZVrDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;br/&gt;输出示例：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.8046296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftd0OAOT3fzaDQCAlAaIRQSgEWIol1sKbUxz1Ttg9BxcCMcpLcw46jcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其中&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;host_path=`sed -n &#x27;s/.*\perdir=\([^,]*\).*/\1/p&#x27; /etc/mtab` &lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;的做法经常在不同的 Docker 容器逃逸 EXP 被使用到；如果我们在漏洞利用过程中，需要在容器和宿主机内进行文件或文本共享，这种方式是非常棒且非常通用的一个做法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其思路在于利用Docker容器镜像分层的文件存储结构(Union FS)，从 mount 信息中找出宿主机内对应当前容器内部文件结构的路径；则对该路径下的文件操作等同于对容器根目录的文件操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftiauaaBrb6vQiarVSQpAfSdVPiaqxX6ibhHGvFWruakuTM85UIYQ40J6TZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;此类手法如果HIDS并未针对容器逃逸的特性做一定优化的话，则HIDS对于逃逸在母机中执行命令的感知能力可能就会相对弱一点。不过业界的EDR和HIDS针对此手法进行规则覆盖的跟进速度也很快，已有多款HIDS对此有一定的感知能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另外一个比较小众方法是借助上面 lxcfs 的思路，复用到 sys_admin 或特权容器的场景上读写母机上的文件。&lt;span&gt;（腾讯蓝军的兄弟们问得最多的手法之一，每过一段时间就有人过来问一次 ~）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1. 首先我们还是需要先创建一个 cgroup 但是这次是 device subsystem 的。&lt;/p&gt;&lt;p&gt;mkdir /tmp/dev&lt;/p&gt;&lt;p&gt;mount -t cgroup -o devices devices /tmp/dev/&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2. 修改当前已控容器 cgroup 的 devices.allow，此时容器内已经可以访问所有类型的设备, &lt;/p&gt;&lt;p&gt;命令： echo a &amp;gt;&lt;/p&gt;&lt;p&gt;/tmp/dev/docker/b76c0b53a9b8fb8478f680503164b37eb27c2805043fecabb450c48eaad10b57/devices.allow&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;3. 同样的，我们可以使用 mknod 创建相应的设备文件目录并使用 debugfs 进行访问，此时我们就有了读写宿主机任意文件的权限。&lt;/p&gt;&lt;p&gt;mknod near b 252 1&lt;/p&gt;&lt;p&gt;debugfs -w near&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7712963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSft26N0dJav4icNaXnENfhzLNH3K7R4ODLpCDsEmWyiawlw3HjBaib8Mx8OQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;5.4. 特殊路径挂载导致的容器逃逸&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这类的挂载很好理解，当例如宿主机的内的 /, /etc/, /root/.ssh 等目录的写权限被挂载进容器时，在容器内部可以修改宿主机内的 /etc/crontab、/root/.ssh/、/root/.bashrc 等文件执行任意命令，就可以导致容器逃逸。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;执行下列命令可以很容易拥有这样的环境：&lt;/p&gt;&lt;p&gt;➜  ~ docker run -it -v /:/tmp/rootfs ubuntu bash&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.0981481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftatOPnCicAiaV8lXHkvKuPQFT4aUSJicKE5FhfKibxWx3PQVAQAzJpMdxibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.4.1 Docker in Docker&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其中一个比较特殊且常见的场景是当宿主机的 /var/run/docker.sock 被挂载容器内的时候，容器内就可以通过 docker.sock 在宿主机里创建任意配置的容器，此时可以理解为可以创建任意权限的进程；当然也可以控制任意正在运行的容器。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1175926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftw32wVunQaYQ1iczSQ50LvsNLQrqa0rG6mE3Ob2VSHh9gIj8gv5tgdVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这类的设计被称为： Docker in Docker。常见于需要对当前节点进行容器管理的编排逻辑容器里，历史上我遇到的场景举例：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;a. 存在于 Serverless 的前置公共容器内&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;b. 存在于每个节点的日志容器内&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如果你已经获取了此类容器的 full tty shell, 你可以用类似下述的命令创建一个通往母机的shell。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;./bin/docker -H unix:///tmp/rootfs/var/run/docker.sock run -d -it --rm --name rshell -v &quot;/proc:/host/proc&quot; -v &quot;/sys:/host/sys&quot; -v &quot;/:/rootfs&quot; --network=host --privileged=true --cap-add=ALL alpine:latest&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如果想现在直接尝试此类逃逸利用的魅力，不妨可以试试 Google Cloud IDE 天然自带的容器逃逸场景，拥有Google账号可以直接点击下面的链接获取容器环境和利用代码，直接执行利用代码 try_google_cloud/host_root.sh 再 chroot 到 /rootfs 你就可以获取一个完整的宿主机shell：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;https://ssh.cloud.google.com/cloudshell/editor?cloudshell_git_repo=https://github.com/neargle/cloud_native_security_test_case.git&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.0185185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftJ2vstIzkOJLNRZNzSwMyPUDLiagDBia53jYDqCTFD5Jpy07WbxBJpNhg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当然容器内部不一定有条件安装或运行 docker client，一般获取的容器shell其容器镜像是受限且不完整的，也不一定能安装新的程序，即使是用 pip 或 npm 安装第三方依赖包也很困难。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;此时基于golang编写简易的利用程序，利用交叉编译编译成无需依赖的单独bin文件下载到容器内执行就是经常使用的方法了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.4.2 攻击挂载了主机 /proc 目录的容器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另一个比较有趣的场景就是挂载了主机 /proc 目录的容器，在历史的攻防演练中当我们遇到挂载了主机 /proc 目录的容器，一般都会有其它可以逃逸的特性，如 sys_ptrace 或者 sys_admin 等，但是其实挂载了主机 /proc 目录这个设置本身，就是一个可以逃逸在宿主机执行命令的特性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们可以简单的执行以下命令创建一个具有该配置的容器并获得其shell：&lt;/p&gt;&lt;p&gt;docker run -v /proc:/host_proc --rm -it ubuntu bash&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1074074&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftAB4cUYkuAw8qAOpVUiclIpDNYUxspI6KP34Zf91eVQ6xwiaNUqjm19hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里逃逸并在外部执行命令的方式主要是利用了 linux 的 /proc/sys/kernel/core_pattern 文件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;a. 首先我们需要利用在 release_agent 中提及的方法从 mount 信息中找出宿主机内对应当前容器内部文件结构的路径。&lt;/p&gt;&lt;p&gt;sed -n &#x27;s/.*\perdir=\([^,]*\).*/\1/p&#x27; /etc/mtab&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1175926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftR3jLLNribmw1DuJ0NO9kjn0fYslX59rhRdZVYMNl1mKYIS8M5gUkbdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;b. 此时我们在容器内的 /exp.sh 就对应了宿主机的 /var/lib/docker/overlay2/a1a1e60a9967d6497f22f5df21b185708403e2af22eab44cfc2de05ff8ae115f/diff/exp.sh 文件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1851852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftH6nUncxl6ibtrUumbDmWNOdnibrBCJFwpf3HrTFZ9xFhhvkRa4BCgCjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;c. 因为宿主机内的 /proc 文件被挂载到了容器内的 /host_proc 目录，所以我们修改 /host_proc/sys/kernel/core_pattern 文件以达到修改宿主机 /proc/sys/kernel/core_pattern 的目的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;echo -e&lt;/p&gt;&lt;p&gt;&quot;|/var/lib/docker/overlay2/a1a1e60a9967d6497f22f5df21b185708403e2af22eab44cfc2de05ff8ae115f/diff/exp.sh \rcore       &quot; &amp;gt; /host_proc/sys/kernel/core_pattern&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;d. 此时我们还需要一个程序在容器里执行并触发 segmentation fault 使植入的 payload 即exp.sh 在宿主机执行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里我们参考了 https://wohin.me/rong-qi-tao-yi-gong-fang-xi-lie-yi-tao-yi-ji-zhu-gai-lan/#4-2-procfs- 里的 c 语言代码和 CDK-TEAM/CDK 里面的 GO 语言代码：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5856574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftEOJquTPhAf5XtlOBCEjRNM4qALicMhjMymWib58D2HkicTv7N9OcmpwZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;502&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;e. 当然不能忘记给 exp.sh 赋予可执行权限。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.0851852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftYW4ibU65yhwJFibysUswDMOdiaSJbEIQkaZNdSusFBShsaHSS81KjZC0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当容器内的 segmentation fault 被触发时，我们就达到了逃逸到宿主机在容器外执行任意代码的目的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;5.5. SYS_PTRACE 安全风险&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当 docker 容器设置 --cap-add=SYS_PTRACE 或 Kubernetes PODS 设置 securityContext.capabilities 为 SYS_PTRACE 配置等把 SYS_PTRACE capabilities 权限赋予容器的情况，都可能导致容器逃逸。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.3490741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftiatm1LG35dC04AKvK7vbmJibx5iciaena0ptqib9W2xOY9cVTVShyFmBMFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个场景很常见，因为无论是不是线上环境，业务进行灾难重试和程序调试都是没办法避免的，所以容器经常被设置 ptrace 权限。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用 capsh --print 可以判断当前容器是否附加了 ptrace capabilities。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1712963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftA5xR0WNgNA3DwdiaIoGn2mWmGGTzCwibmeRsejfKo8daibJ3fib6vxMWiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里的利用方式和进程注入的方式大致无二，如果是使用 pupy 或 metasploit 维持容器的shell权限的话，利用框架现有的功能就能很方便的进行注入和利用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当然，就如上面所述，拥有了该权限就可以在容器内执行 strace 和 ptrace 等工具，若只是一些常见场景的信息收集也不一定需要注入恶意 shellcode 进行逃逸才可以做到。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;5.6. 利用大权限的 Service Account&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;使用Kubernetes做容器编排的话，在POD启动时，Kubernetes会默认为容器挂载一个 Service Account 证书。同时，默认情况下Kubernetes会创建一个特有的 Service 用来指向 ApiServer。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有了这两个条件，我们就拥有了在容器内直接和APIServer通信和交互的方式。&lt;/p&gt;&lt;p&gt;Kubernetes Default Service&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1009259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftF3icYrbEyoajYW3lxKIYcevm66b3clvlQUIXxneO7LJLVqEibrEhHziaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4925926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftTvug1uFW0iaib9xCxBAGmXIO0M5xgOpWb3SlNabapWZnkko7SQGf5gOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Default Service Account&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.3027778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSft7TibDhibGHJ9Hrb2uIPSCEGiaUgacRkL4THkcThMyGmN2gPDUADeJLBzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;默认情况下，这个 Service Account 的证书和 token 虽然可以用于和 Kubernetes Default Service 的 APIServer 通信，但是是没有权限进行利用的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是集群管理员可以为 Service Account 赋予权限：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.0537037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftKYhULXklPpLiciaR5icMSuVehOY3FTUrkfIyCtvmj9IoiclZkZt5eW5gZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;此时直接在容器里执行 kubectl 就可以集群管理员权限管理容器集群。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4309278&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftia4aojurXia3vykNrLmzUp1LxDKqalKT9wofHFks3F7f3v9OAjiaKMm4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;970&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因此获取一个拥有绑定了 ClusterRole/cluster-admin Service Account 的 POD，其实就等于拥有了集群管理员的权限。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;实际攻防演练利用过程中，有几个坑点：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1. 老版本的 kubectl 不会自动寻找和使用 Service Account 需要用 kubectl config set-cluster cfc 进行绑定或下载一个新版本的 kubectl 二进制程序；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2. 如果当前用户的目录下配置了 kubeconfig 即使是错误的，也会使用 kubeconfig 的配置去访问不会默认使用 Service Account ；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;3. 历史上我们遇到很多集群会删除 Kubernetes Default Service，所以需要使用容器内的资产探测手法进行信息收集获取 apiserver 的地址。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;5.7. CVE-2020-15257利用&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1009259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftkxc6w0j4uicMY3jcHMyYhwBHL3cqqVoavpqlOQMQhLBtUEKmCZW6OUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;此前 containerd 修复了一个逃逸漏洞，当容器和宿主机共享一个 net namespace 时（如使用 --net=host 或者 Kubernetes 设置 pod container 的 .spec.hostNetwork 为 true）攻击者可对拥有特权的 containerd shim API进行操作，可能导致容器逃逸获取主机权限、修改主机文件等危害。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;官方建议升级 containerd 以修复和防御该攻击；当然业务在使用时，也建议如无特殊需求不要将任何 host 的 namespace 共享给容器，如 Kubernetes PODS 设置 hostPID: true、hostIPC: true、hostNetwork: true 等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们测试升级 containerd 可能导致运行容器退出或重启，有状态容器节点的升级要极为慎重。也因为如此，业务针对该问题进行 containerd 升级的概率并不高。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;利用目前最方便的EXP为：&lt;/p&gt;&lt;p&gt;https://github.com/cdk-team/CDK/wiki/Exploit:-shim-pwn&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.387963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSft66U7coycRmetNGibBpXjwjN6mjYogWazh856zC1Ajmeq34tC2jXdI0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;5.8. runc CVE-2019-5736 和容器组件历史逃逸漏洞综述&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个由RUNC实现而导致的逃逸漏洞太出名了，出名到每一次提及容器安全能力或容器安全研究都会被拿出来当做案例或DEMO。但不得不说，这里的利用条件在实际的攻防场景里还是过于有限了；实际利用还是需要一些特定的场景才能真的想要去使用和利用它。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里公开的POC很多，不同的环境和操作系统发行版本利用起来有一定的差异，可以参考进行利用：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1. github.com/feexd/pocs&lt;/p&gt;&lt;p&gt;2. github.com/twistlock/RunC-CVE-2019-5736&lt;/p&gt;&lt;p&gt;3. github.com/AbsoZed/DockerPwn.py&lt;/p&gt;&lt;p&gt;4. github.com/q3k/cve-2019-5736-poc&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;至于我们实际遇到的场景可以在“容器相关组件的历史漏洞”一章中查看。从攻防角度不得不说的是，这个漏洞的思路和EXP过于出名，几乎所有的HIDS都已经具备检测能力，甚至对某些EXP文件在静态文件规则上做了拉黑，所以大部分情况是使用该方法就等于在一定程度上暴露了行踪，需要谨慎使用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;5.9. 内核漏洞提权和逃逸概述&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;容器共享宿主机内核，因此我们可以使用宿主机的内核漏洞进行容器逃逸，比如通过内核漏洞进入宿主机内核并更改当前容器的namespace，在历史内核漏洞导致的容器逃逸当中最广为人知的便是脏牛漏洞（CVE-2016-5195）了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;同时，近期还有一个比较出名的内核漏洞是 CVE-2020-14386，也是可以导致容器逃逸的安全问题。&lt;/p&gt;&lt;p&gt;这些漏洞的POC 和 EXP都已经公开，且不乏有利用行为，但同时大部分的EDR和HIDS也对EXP的利用具有检测能力，这也是利用内核漏洞进行容器逃逸的痛点之一。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;6. 容器相关组件的历史漏洞&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2020年我们和腾讯云的同学一起处理跟进分析了多个官方开源分支所披露的安全问题，并在公司内外的云原生能力上进行复现、分析，从产品和安全两个角度出发探讨攻击场景，保障云用户和业务的安全。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其中投入时间比较多的，主要是以下十个漏洞，每个都非常有趣，且都在云产品上得到了妥善的跟进和安全能力建设：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1898148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftfyYibISQBmbTeyibKy0TwkdDMtGJIqoqlCDKkH4vaHxbb2MkzU3W6LRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;实际攻防场景里面我真实用过且在关键路径里起到作用的也就 CVE-2020-15257，其它漏洞的POC都只在漏洞公开时自建测试的环境复现和公司内服务的漏洞挖掘用了一下，有些环境虽然有漏洞，但是实际打真实目标却没怎么用得上。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;值得一提的是最开始跟进分析时，因为EXP需要钓鱼让管理员去执行 docker exec 或 kubectl exec 才可以触发，所以不怎么看好的 CVE-2019-5736 RUNC 容器逃逸漏洞；反而是真的遇到几个无交互即可触发的场景。主要是 vscode server、jupyter notebook、container webconsole 等这种提供容器内交互式shell的多租户场景在企业内网里变多了，容器逃逸之后就是新的网络环境和主机环境。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;7. 容器、容器编排组件API配置不当或未鉴权&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;就安全问题来说，业界普遍接触最多、最首当其冲的就是容器组件服务的未鉴权问题。我们在2019年的时候整理了一份Kubernetes架构下常见的开放服务指纹，提供给到了地表最强的扫描器洞犀团队，就现在看来这份指纹也是比较全的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;kube-apiserver: 6443, 8080&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;kubectl proxy: 8080, 8081&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;kubelet: 10250, 10255, 4149&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;dashboard: 30000&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;docker api: 2375&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;etcd: 2379, 2380&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;kube-controller-manager: 10252&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;kube-proxy: 10256, 31442&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;kube-scheduler: 10251&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;weave: 6781, 6782, 6783&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;kubeflow-dashboard: 8080&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;前六个服务的非只读接口我们都曾经在渗透测试里遇到并利用过，都是一旦被控制可以直接获取相应容器、相应节点、集群权限的服务，也是广大公网蠕虫的必争之地。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;7.1. 组件分工&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;各个组件未鉴权所能造成的风险，其实从它们在Kubernetes集群环境里所能起到的作用就能很明显的判断出来，如 APIServer 是所有功能的主入口，则控制 APIServer 基本上等同控制集群的所有功能；而 kubelet 是单个节点用于进行容器编排的 Agent，所以控制 kubelet 主要是对单个节点下的容器资源进行控制。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;组件分工上较为完整的图例可参考：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.9703704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftdtJiaulxvzaFwvM2qeOiatjO2G11dHW3xZmiaicBunCZiazicZKPH7gZYhpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;想必这样也相对晦涩难懂，我简化了一下，假如用户想在集群里面新建一个容器集合单元，那各个组件以此会相继做什么事情呢？&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1. 用户与 kubectl 或者 Kubernetes Dashboard 进行交互，提交需求。（例: kubectl create -f pod.yaml）;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2. kubectl 会读取 ~/.kube/config 配置，并与 apiserver 进行交互，协议：http/https;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;3. apiserver 会协同 ETCD 等组件准备下发新建容器的配置给到节点，协议：http/https（除 ETCD 外还有例如 kube-controller-manager, scheduler等组件用于规划容器资源和容器编排方向，此处简化省略）;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;4. apiserver 与 kubelet 进行交互，告知其容器创建的需求，协议：http/https；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;5. kubelet 与Docker等容器引擎进行交互，创建容器，协议：http/unix socket.&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;至此我们的容器已然在集群节点上创建成功，创建的流程涉及ETCD、apiserver、kubelet、dashboard、docker remote api等组件，可见每个组件被控制会造成的风险和危害，以及相应的利用方向；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于这些组件的安全性，除了不同组件不一样的鉴权设计以外，网络隔离也是非常必要的，常规的 iptables 设置和规划也可以在容器网络中起到作用（容器网络的很多能力也是基于 iptables 实现的）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另外比较有容器特色的方案就是 Network Policy 的规划和服务网格的使用，能从容器、POD、服务的维度更加优雅的管理和治理容器网络以及集群内流量。这些组件的资料和对应渗透手法，这里我们一一介绍一下:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;7.2. apiserver&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果想要攻击 apiserver, 下载 kubectl 是必经之路。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;curl -LO &quot;https://dl.Kubernetes.io/release/$(curl -L -s https://dl.Kubernetes.io/release/stable.txt)/bin/linux/amd64/kubectl&quot;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;默认情况下，apiserver 都是有鉴权的：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5805556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftM9oEyDHU4pstSLynedSxPkZn3uuzJ4VXzdHrnUh00cljFu0UOibnc3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当然也有未鉴权的配置：kube-apiserver --insecure-bind-address=0.0.0.0 --insecure-port=8080，此时请求接口的结果如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.7425373&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftibmOReZolOmwMr0YkrznWE9ZJ0BN3sE1QOlw5LSgMWpUv8c2znbNAiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1072&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于这类的未鉴权的设置来说，访问到 apiserver 一般情况下就获取了集群的权限：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.2018519&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftqK18Uoe76DboIH9ffRN54PjPXaYDheClyBAEZ37ib7v0ibzZ792oNNNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;可能还有同学不知道 apiserver 在 Kubernetes/容器编排集群里的重要地位，这里简单介绍一下：在蓝军眼中的 Kubernetes APIServer其重要性，如下图:&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4672619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftXeGING1DWkTWc8UOib0eJabJvib590vZU3o9LhrKW8ZZFXHdLInRAq3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1008&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以，对于针对Kubernetes集群的攻击来说，获取 admin kubeconfig 和 apiserver 所在的 master node 权限基本上就是获取主机权限路程的终点。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;至于如何通过 apiserver 进行持续渗透和控制，参考 kubectl 的官方文档是最好的：&lt;/p&gt;&lt;p&gt;https://Kubernetes.io/docs/reference/generated/kubectl/kubectl-commands&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;7.3. kubelet&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;每一个Node节点都有一个kubelet服务，kubelet监听了10250，10248，10255等端口。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其中10250端口是kubelet与apiserver进行通信的主要端口，通过该端口kubelet可以知道自己当前应该处理的任务，该端口在最新版Kubernetes是有鉴权的，但在开启了接受匿名请求的情况下，不带鉴权信息的请求也可以使用10250提供的能力；因为Kubernetes流行早期，很多挖矿木马基于该端口进行传播和利用，所以该组件在安全领域部分群体内部的知名度反而会高于 APIServer。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在新版本Kubernetes中当使用以下配置打开匿名访问时便可能存在kubelet未授权访问漏洞：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6166667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftjpiaZkeEpJDRXf1GS3Nlm9abfNO8O1dRRxUkfZqZ348GMgcib4JgdkRw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果10250端口存在未授权访问漏洞，那么我们可以先使用/pods接口获取集群的详细信息，如namespace，pods，containers等&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.2972222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftza2qbic1CqZm3icSicwqGdQnlEh3tsbyKjicmgeh1jVibjb2gibHLaHDYI4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;之后再通过&lt;/p&gt;&lt;p&gt;curl -k https://Kubernetes-node-ip:10250/run/// -d “cmd=id” 的方式在任意容器里执行命令&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.3287037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftzyicibzfCRmZZVmRdbO0Aibn7LI4132GPk73g7pwkqepME7ekBaZEw7tQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;此时，选择我们所有控制的容器快速过滤出高权限可逃逸的容器就很重要，在上述 /pods API 中可以获取到每个 POD 的配置，包括了 host*、securityContext、volumes 等配置，可以根据容器逃逸知识快速过滤出相应的POD进行控制。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4398148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSfttdDKiaAdhbeGWsnJzJibwcbfDOwFibRibvylp5hobyicibzG028FENiaF8rbw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由于这里10250鉴权当前的Kubernetes设计是默认安全的，所以10255的开放就可能更加容易在红蓝对抗中起到至关重要的作用。10255 本身为只读端口，虽然开放之后默认不存在鉴权能力，无法直接利用在容器中执行命令，但是可以获取环境变量ENV、主进程CMDLINE等信息，里面包含密码和秘钥等敏感信息的概率是很高的，可以快速帮我们在对抗中打开局面。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;7.4. dashboard&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;dashboard是Kubernetes官方推出的控制Kubernetes的图形化界面，在Kubernetes配置不当导致dashboard未授权访问漏洞的情况下，通过dashboard我们可以控制整个集群。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在dashboard中默认是存在鉴权机制的，用户可以通过kubeconfig或者Token两种方式登录，当用户开启了enable-skip-login时可以在登录界面点击Skip跳过登录进入dashboard&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6747664&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftxutjWrROJS2HetWnJL1wzjMU355bCb7KjSBfu9yCxeVjiaKoKjh2rlw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;535&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;然而通过点击Skip进入dashboard默认是没有操作集群的权限的，因为Kubernetes使用RBAC(Role-based access control)机制进行身份认证和权限管理，不同的serviceaccount拥有不同的集群权限。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们点击Skip进入dashboard实际上使用的是Kubernetes-dashboard这个ServiceAccount，如果此时该ServiceAccount没有配置特殊的权限，是默认没有办法达到控制集群任意功能的程度的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但有些开发者为了方便或者在测试环境中会为Kubernetes-dashboard绑定cluster-admin这个ClusterRole（cluster-admin拥有管理集群的最高权限）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个极具安全风险的设置，具体如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1. 新建dashboard-admin.yaml内容如下（该配置也类似于“利用大权限的 Service Account”一小节的配置 ）&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5054466&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSfticH5NXjL1A5BAceJmkqQHSHL0NcKWevHlFricISGwLaIQiayeuU0RebIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;459&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2. 执行kubectl create -f dashboard-admin.yaml&lt;/p&gt;&lt;p&gt;此时用户通过点击Skip进入dashboard即可拥有管理集群的权限了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4796296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftYmIEUwGXaNtDvxLrYmbMgYp470KFrZEugWXdTdBeVY2dLKVHRFayOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;进入到dashboard我们可以管理Pods、CronJobs等，这里介绍下我们如何通过创建Pod控制node节点。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们新建一个以下配置的Pod，该pod主要是将宿主机根目录挂载到容器tmp目录下。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.8918919&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftXETcKPkAS5r8rm1ZoyACLWGx74PftXkJSs0zBA0unAYMPT9E7bgWBQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;814&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;之后我们便可以通过该容器的tmp目录管理node节点的文件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.2037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftwota0l4oVnG2gI2D4mS6TlQaaljFHgTcwZ84ujRBibh5OdP5Jz4fzkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.2148148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftOne3a77LTdFNhia8tudS6uo4eXP8wwL83KLGK41ibx4h04fOandVQ0bg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;值得注意的是，为了集群的稳定性和安全性要求，在Kubernetes默认设计的情况下Pod是不能调度到master节点的，但如果用户自行设置关闭了Master Only状态，那么我们可以直接在master节点新建Pod更直接的控制master node；不过目前各大主流云产商上的Kubernetes集群服务，都会默认推荐让Master节点由云厂商托管，更加加剧了Master节点渗透和控制的难度 。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;7.5. etcd&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;etcd被广泛用于存储分布式系统或机器集群数据，其默认监听了2379等端口，如果2379端口暴露到公网，可能造成敏感信息泄露，本文我们主要讨论Kubernetes由于配置错误导致etcd未授权访问的情况。Kubernetes默认使用了etcd v3来存储数据，如果我们能够控制Kubernetes etcd服务，也就拥有了整个集群的控制权。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在Kubernetes中用户可以通过配置/etc/Kubernetes/manifests/etcd.yaml更改etcd pod相关的配置，倘若管理员通过修改配置将etcd监听的host修改为0.0.0.0，则通过ectd获取Kubernetes的认证鉴权token用于控制集群就是自然而然的思路了，方式如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首先读取用于访问apiserver的token&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.287963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSft9L0VJiaVHwkv7NYMms1GE6x8atYPbJGn3GjMLP8GyoVuialJY8boeg1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.2787037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftSKBkEC7icKASMRq3ccycnKCSaWyEAoK3ib2Q2WDHXDpgGZGcSoicv6wuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;利用token我们可以通过apiserver端口6443控制集群：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.237037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftLhA7tToh4wYcXDpeico3iaTgcaiaQdiaiajQF2jw0aXc6iaDrGdEb0ibB1epA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;7.6. docker remote api&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Docker Engine API是Docker提供的基于HTTP协议的用于Docker客户端与Docker守护进程交互的API，Docker daemon接收来自Docker Engine API的请求并处理，Docker daemon默认监听2375端口且未鉴权，我们可以利用API来完成Docker客户端能做的所有事情。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Docker daemon支持三种不同类型的socket: unix, tcp, fd。默认情况下，Docker daemon监听在unix:///var/run/docker.sock，开发者可以通过多种方式打开tcp socket，比如修改Docker配置文件如/usr/lib/systemd/system/docker.service：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.3342912&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSft5rRHUuRvfdbtVIQT9KvN9jN6fuMMR6DEqkOmQq5Qk7eZjTDAYBFQ7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1044&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;之后依次执行systemctl daemon-reload、systemctl restart docker便可以使用docker -H tcp://[HOST]:2375这种方式控制目标docker&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1342593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftFYmmUrU7CwrIjs8FWGmjVppvdeq1LsdgFuUDQKsWHUX5zic4rgEwDdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1972222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftMyam51E9TJW5XdHt0BR9pfGsRhuITsxFcSqFuR5vjgJDqq31naglFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因此当你有访问到目标Docker API 的网络能力或主机能力的时候，你就拥有了控制当前服务器的能力。我们可以利用Docker API在远程主机上创建一个特权容器，并且挂载主机根目录到容器，对主机进行进一步的渗透，更多利用方法参考容器逃逸章节。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;检测目标是否存在docker api未授权访问漏洞的方式也很简单，访问http://[host]:[port]/info路径是否含有ContainersRunning、DockerRootDir等关键字。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;7.7. kubectl proxy&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;kubectl proxy这个子命令大家可能遇到比较少，这里单独介绍一下；由于上述几个组件的安全问题较为常见和出名，且在目前开源分支里它们在鉴权这个方面都是默认安全的，所以直接出现问题的可能性较小，企业在内外网也都收敛得不错；此时 kubectl proxy 这个子命令反而是另一个常见且蠕虫利用起来非常简单粗暴的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;了解使用过Kubernetes的同学应该知道，如果你在集群的POD上开放一个端口并用ClusterIP Service绑定创建一个内部服务，如果没有开放NodePort或LoadBalancer等Service的话，你是无法在集群外网访问这个服务的（除非修改了CNI插件等）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.2858491&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftTo2SWAYNZmQYibibfOa1ur0j4rV4vfytPaVS9yx1C03Sc4xPulcibyG5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1060&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;如果想临时在本地和外网调试的话，kubectl proxy 似乎是个不错的选择。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.2453704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftMCKwyeAcnN0P2vs5POWIRoAzSCsicLWRiaFaWhOOFI3YkZdCVFwltISA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但其实 kubectl proxy 转发的是 apiserver 所有的能力，而且是默认不鉴权的，所以 --address=0.0.0.0 就是极其危险的了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4176744&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSft3OEqmTq1QzrDCBqE9UibQn3hiboicicYHCaMbn3dAjDdJxrt4QHibAqZV9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1075&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;所以这里的利用和危害和 APIServer 的小节是相似的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;8. 容器镜像安全问题&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;容器镜像的安全扫描能力是很多乙方商业产品和甲方安全系统首先会推进的容器安全建设方向。不像容器运行时安全监控需要较高的成本、稳定性要求和技术积累，也有业界相对成熟的开源方案。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;容器镜像是容器安全非常关键且重要的一环，当获取到节点权限或管理员PC权限时，~/.docker/config.json 文件内就可能存有镜像仓库账号和密码信息，用户名和密码只用 Base64 编码了一下，对于安全人员来说和没有是一样的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.2731481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftblRJtmc8ibDkyGhiay04AvRp9kpUbP0urpobAKnXXbcAhGqfDq0YKH0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;很多POD和线上容器在使用镜像时，可能用 latest 或默认没有指定版本，所以劫持镜像源之后只要在原本的 latest 之上植入恶意代码并 push 新的版本镜像，就可以在获取镜像权限之后进而获取线上的容器权限。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不仅在安全攻防领域，作为一个长期依赖容器技术的半吊子开发者，我也不建议用 latest 镜像标签作为线上环境的长期方案；从研发运维角度的最佳实践来看，使用特定版本的TAG且可以和代码版本控制相对应是比较推荐的方案，应该保障每个镜像都是可追踪溯源的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;比较有趣的是，我们曾经遇到企业在基础容器镜像里打入 sshd 并且在 init.sh 主程序中启动 sshd 程序（无论是安全还是容器架构最佳实践都是不建议的），导致所有Kubernetes集群里的容器都会开放22端口并且拥有一样的/etc/shadow文件和/root/.ssh/authorized_keys。这就代表所有的容器都可以使用一个通用密码和ssh证书去登录。因此在逃逸获取容器的宿主机权限后，分析容器基础镜像的通用安全问题确实可以很快扩大影响面。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;9. 二次开发所产生的安全问题&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;9.1. 对Kubernetes API的请求转发或拼接&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;熟悉Kubernetes架构的同学可能知道，管理员管理Kubernetes无论是使用 kubectl 或 Kubernetes dashboard 的UI功能，其实都是间接在和 APIServer 做交互。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;参考官方的架构图：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6648148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftE9uEUhww0LFR8Tbs7YDicEddrKdZnGEVVqa495YOsUzGODrvj29sVsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么如果需求需要在Kubernetes原本的能力上做开发的话，很有可能产品后端就是请求了 APIServer 的 Rest API 实现的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;攻击者破坏程序原本想对 APIServer 所表达的语义，注入或修改 Rest API 请求里所要表达的信息，就可以达到意想不到的效果。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;例如下面的代码，用户传入 namespace、pod和容器名即可获取相应容器的日志：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1318553&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftljXMiblpicwPTFm2fiaicCwpxO9s7kz24VWeubW8INcGcu7fHOVjibu2n0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;857&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;相似的需求和API还有例如：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1. 到用户自己的容器内创建一个 web console 供用户进行远程调试, &lt;span&gt;POST https:/apiserver:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;8443/api/v1/namespaces/default/pods/nginx/exec?command=bash&amp;amp;container=nginx&amp;amp;stdin=true&amp;amp;stdout=true&amp;amp;tty=true&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2. 给用户销毁自己POD的能力， &lt;span&gt;DELETE &lt;/span&gt;https://apiserver:&lt;/p&gt;&lt;p&gt;&lt;span&gt;8443/api/v1/namespaces/default/pods/sleep-75c6fd99c-g5kss&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这类型的需求在多租户的集群设计里比较常见。渗透测试选手看到这样的代码或API，首先想到的就是越权，把 namespace、pod和容器名修改为他人的，就可以让二次开发的代码去删除其他用户的POD、进入其他用户的容器里执行命令、获取其它POD的日志等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;除了上述的功能点，这里比较容易出问题且影响较大的功能和业务逻辑是多租户集群平台的自研 Web Console功能，Web Console的越权问题可以直接导致任意容器登录和远程控制，也是非常值得关注的一个点。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;其实我们甚至可以修改获取日志、删除POD、执行命令的 Rest API 语义：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;例如在上述 namespace 命名空间处插入 &lt;span&gt;“default/configmaps/istio-ca-root-cert?ingore=”，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;原本请求的&lt;/p&gt;&lt;p&gt;&lt;span&gt;&quot;https://apiserver:6443/api/v1/namespaces/istio-dev/pods/service-account-simple/lo g?container&lt;/span&gt;&lt;span&gt;=test-container&quot; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;就会转变为&lt;/p&gt;&lt;p&gt;&lt;span&gt;&quot;https://apiserver:6443/api/v1/namespaces/default/configmaps/istio-ca-root-cert?ingore=/pods/service-account-simple/lo g?container=test-container&quot;，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;实际就是请求了&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://apiserver:6443/api/v1/namespaces/default/configmaps/istio-ca-root-cert&lt;/span&gt;，从获取日志转变了为获取 configmap。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4138889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftO66YjDQMVGFz5zhTJLiaNA9ySASneO662ARGOsDp7sm4rYkib4E1MyAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;10. Serverless&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Serverless还有一个比较大漏洞挖掘的方向是资源占用，例如驻留进程，驻留文件，进程偷跑，句柄耗尽等条件竞争漏洞，用于影响多租户集群，占用计算资源等。我们之前也研究过相关的安全漏洞和利用方法，但因为和传统的黑客攻防对抗相关性较少，此处暂且不表。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里只描述那些确实成为安全演习关键路径一环的漏洞。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;10.1. 文件驻留导致命令执行&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;有些Serverless实现在应用程序生命周期结束之后，程序文件的清理上进入了僵局。一方面开发者希望借助容器“对Linux Cgroup和Namespace进行管理的特性”用于实现限制应用的资源访问能力和进程权限的需求；在此之上，开发者希望能更快的达到用户文件清理的目的，避免反复初始化容器环境带来的时间和资源上的消耗，复用同一个容器环境。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而在蓝军的视角里，这样的处理方式会导致多个用户的应用会存在多个用户在不同时间段使用一个容器环境的情况，在安全性上是比较难得到保障的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以面向Python开发者的Serverless架构为例，开发者所构想的简化模型是这样的：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5851852&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftrDqh6Mv2jkjXAsnotwCywtqGaNCDdHt7PavrjRInTzUVOY9eUwhdUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;用户文件清理的代码实现上，简化可参考：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.2731481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftypEhfurOuOClWQrtN3z8IhAL84xibuB2W8ERiaVN8uk2euZViaGvvH2ew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在进行包括上述文件删除动作在内的一系列环境清理工作之后，容器内外的主调度进程会写入其他租户的代码到当前容器内，此时这个容器就进入了下一个应用的Serverless生命周期。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;虽然，主框架代码实现内有很多类似调用系统命令拼接目录等参数进行执行的代码实现，但是类似命令注入的问题大多只能影响到当前的生命周期；而又因为用户权限的问题，我们没办法修改其他目录下的文件。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;于是我们构建了这样一个目录和文件：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.304038&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftuEbNuIjDbKaMYLBwvlAVozHU0ZcicdsnOor5ZND4Hgy3vRn6CXskQFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;842&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当程序执行 rm -rf * 时，因为 bash glob 对 * 号的返回是有默认排序的，这里可参考下方 bash 的文档，只要我们不去修改 LC_ALL 的环境变量，我们构造的 --help 文件会排列在文件列表的最前方，导致 rm 会执行 rm --help 而终止，恶意文件得以保留。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;Pathname Expansion&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;After word splitting, unless the -f option has been set, bash scans each word for the characters *, ?, and [. If one of these characters appears, then the word is regarded as a pattern, and replaced with an alphabetically sorted list of file names matching the pattern.&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们可以简单在 bash 内进行验证，可以看到 rm -rf * 命令被 --help 强行终止，我们所植入的恶意文件还依然存在没有被清理掉，同时 rm --help 的命令执行返回为 0，不会产生 OS ERROE Code，清理进程会认为这里的清除命令已经成功执行：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.5018519&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftpjnbtv45r37Ov4icyG36okaRFb5uywHMRbPPmRAiaP1cuk33ORSwhicLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而实际在serverless log里的返回，可参考：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.1203704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftD7gxhR3T4yGxysBJPlceL9wS1Cfvw7kVEgFibFrLqkMGaHfIrcyAOCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;此时，serverless的主调度程序会以为自己已经正常清理了容器环境，并写入另外一个租户的源码包进行执行，而当另外一个租户的代码执行至 import requests 时，我们驻留在应用目录下的 requests.py 内的恶意代码就会被执行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1796296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftTLwvYdm6tuj1pzCs8k7x3S2aPQ6cYRkUbvs2TADAYX7pQUVJMD4tiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不过值得注意的是，因为 serverless 的生命周期一般极为有限，所以此时获取的shell可能会在短时间结束，触发新一轮的反弹shell，且Servless容器环境内的信息相对单一和简便。所以容器环境里值得我们探索和翻找的地方也不多，一般需要关注：]&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;新的代码&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;代码内部配置&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;环境变量&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;秘钥、证书、密码信息等&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不同的serverless架构实现对于存储和传递相应信息的方式各有不同。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;10.2. 攻击公用容器/镜像&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;现在我们知道了，很多Serverless的用户代码都跑在一个个容器内。不同应用的代码运行于不同的容器之上，依靠容器原本的能力进行资源回收和隔离。由于Serverless应用的代码会进行相应的结构化解耦，且每个应用容器的底层环境相对来说是一致的。所以其实，根据应用漏洞获取更多应用类Serverless容器不仅困难而且在内网渗透中作用相对较为有限，能做的事情也相对较少。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但其实在不同的 Serverless 架构中，都有多类持久化且公用的容器以实现程序调度、代码预编译、代码下载运行等逻辑。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4157407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftqufjNJKdpiaBRywruibXuUElXU2rDiaicQnIAPcruJ2SLJpPmVOicMQOFWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这类容器一般拥有获取所有用户代码、配置和环境变量的能力，同时也比较容易出现 Docker IN Docker或大权限 Service Account的设计。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如何控制这类型的容器呢？以下是我们在攻防过程中遇到的场景：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1. 在下载源代码时，使用 git clone 进行命令拼接，导致存在命令注入；&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5454545&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftWvSD1Tu67qCpVSOavKtibTv8WYEiaKaRbVPOlh1FHPrWLqktY5eRUj2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;814&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2. 在安装 node.js 依赖包时，构造特殊的 package.json 利用 preinstall 控制公用容器。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.563591&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftSBprNNstw3ok5GDpMaQbvjmoW0IRy05SzlY72qwKOtblrRVqUrx6Pg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;3. 配置指向恶意第三方仓库的 pip requirements.txt，利用恶意 pip 包获取依赖打包容器的权限，同类的利用手法还可以作用于nodejs、ruby等语言的包管理器。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4685185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSft6kHyR00oTMD2dW0589S9ib2XpiaTUrhLw4ryWKL065aODR2u4FQVhG1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;4. 因为容器镜像里的打了低版本git、go等程序，在执行 git clone,  git submodule update(CVE-2019-19604), go get 时所导致的命令执行，&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下图为 CVE-2018-6574 的 POC 可参考： https://github.com/neargle/CVE-2018-6574-POC/blob/master/main.go。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6564815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSft6DuCaxYUibWhNTmguQic2JNtwZLTibhFjtgRGecfANIlCKoLITr8ap3rQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;11. DevOps&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们从2019年开始研究 DevOps 安全攻防对抗的战场，不仅研究企业内部 DevOps 平台和产品的安全性，同时也不断在内部的研发流程中积极引入 DevOps 做蓝军武器化自动化研发的测试、发布、打包和编译等流程中。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;从蓝军的角度，在我们历史攻防对抗中比较值得注意的场景有以下几点：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1. 目前不同的DevOps平台可能会包含不同的 Low-Code 流水线特性，隔离上也会大量采用我们上面提及的多租户容器集群设计，所以多租户集群下的渗透测试技巧也大致无二。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2. 控制了上述的多租户容器集群是可以控制集群所用节点服务器的，这些服务器的作用一般用于编译和构建业务代码，并接入代码管理站点如 Gitlab、Github等，所以一般拥有获取企业程序各业务源码的权限。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;3. DevOps 及其相关的平台其最重要的能力之一就是 CICD，因此控制 DevOps 也就间接拥有了从办公网、开发网突破进入生产网的方法；控制的应用数量和业务种类越多，也能根据应用的不同进入不同的隔离区。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另外在DevOps平台内若集成了日志组件（云原生的重点之一：可观察性）的话，那么日志组件和Agent的升级、安装问题一般会是重中之重，蓝军可以根据这个点达到获取公司内任意主机权限的目地。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;12. 云原生API网关&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;作为API网关，它具有管理集群南北流量的功能，一般也可能作为集群流量的入口和出口（ingress/egress）。而作为标榜云原生特性的API网关产品，似乎无一例外都会具有动态配置、灵活修改、远程管理的特性，而这些特性往往以 REST API 对外提供服务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;然而在远程配置逻辑的鉴权能力上，身为网关这种基础网络的产品，各个受欢迎的开源组件在默认安全的实现上似乎还需努力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;以 Kong 为例，Kong API 网关 (https://github.com/Kong/kong) 是目前最受欢迎的云原生 API 网关之一，有开源版和企业版两个分支，被广泛应用于云原生、微服务、分布式、无服务云函数等场景的API接入中间件，为云原生应用提供鉴权，转发，负载均衡，监控等能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们曾经在一次渗透测试中使用Kong的远程配置能力突破外网进入到内网环境中，可以参考之前的预警文章&lt;strong&gt;&lt;span&gt;《腾讯蓝军安全提醒：开源云原生API网关 Kong 可能会成为攻击方进入企业内网的新入口》&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;Kong 使用 Kong Admin Rest API 作为管理 Kong Proxy 能力的关键入口，以支持最大程度的灵活性；在开源分支里，这个管理入口是没有鉴权能力的(Kong企业版支持对 Kong Admin Rest API 进行角色控制和鉴权)，Kong建议用户在网络层进行访问控制；当攻击方可以访问到这个 API，他就具有了 Kong Proxy 的所有能力，可以查看和修改企业当前在南北流量管理上的配置，可以直接控制 API 网关使其成为一个开放性的流量代理(比SSRF更便于使用和利用)；从攻击方的角度思考，控制了这个 API 等于是拥有了摸清网络架构和打破网络边界的能力。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当蓝军可以访问到 Kong Admin Rest API  和  Kong Proxy 时，蓝军可以通过以下步骤创建一个通往内网的代理：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.2407407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftiaxerLLF2Lib6bAylq9yJDuxgYKKhEHdljWZRqe0bhoF3mQc3ydxZQZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;至此，蓝军从外网发往 Kong Proxy 的流量只要 host 头带有 target.com 就会转发到内网的 target.com:443 中，实际利用手法会根据内网和目标站点配置的不同而变化。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;而目前 Kong 的开源分支里是不支持给 Kong Admin Rest API 添加相应的鉴权能力的，只可以改变监听的网卡，或使用设置 Network Policy、 iptables、安全组等方式进行网络上隔离。现在最常见的方式就是不开放外网，只允许内网访问。也因为如此，如果已经进入到内网，API 网关的管理接口会成为我首要的攻击目标之一，借此我们可以摸清当前集群对内对外提供的相关能力，更有可能直接获取流量出入口容器的Shell权限。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;12.1. APISIX 的 RCE 利用&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另外一个值得深入的开源组件就是Apache APISIX，这是一款基于lua语言开发，是一个动态、实时、高性能的 API 网关， 提供负载均衡、动态上游、灰度发布、服务熔断、身份认证、可观测性等丰富的流量管理功能。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;APISIX提供了REST Admin API功能，用户可以使用REST Admin API来管理APISIX，默认情况下只允许127.0.0.1访问，用户可以修改conf/config.yaml中的allow_admin字段，指定允许调用Admin API的ip列表。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当用户对外开启了Admin API且未修改硬编码的缺省admin_key的情况下，攻击者可以利用该admin_key执行任意lua代码。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.5416667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSfto8mHNHeB77LoDPhFESbBegaNiaib0BALNkDWrh3x1EBAdoK89x01Hq1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;根据apisix官方文档可以知道，在创建路由时用户可以定义一个filter_func参数用于处理请求，filter_func的内容可以是任意的lua代码。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1861111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftIfSbPDUz124AichVhhvGTaueXiba0Ja0E4ZyFYZRQWOp9yfsRCpRDlAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;那么我们便可以使用默认的admin_key创建恶意的route并访问以触发lua代码执行，达到rce的目的，下面是具体步骤：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;（1）创建可用的services:&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.6099426&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftst9v4ibA2LYdvG3nqMhTHDicGqXvKq7PmofK2tK15SPF6DNVMLWf8BJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1046&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;（2）创建恶意的route:&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.4944444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftLVN26q4XLteqAicQINLQ2bBY9jmnP0Jp3hCf5Jn9WriaXiagfaibMYLl8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后访问&lt;/span&gt; http://127.0.0.1:9080/api/tforce_test 即可触发预定义的lua代码执行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因此，在内网里攻击云原生API网关是比较容易打开一定局面的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;13. 其它利用场景和手法&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;13.1. 从 CronJob 谈持久化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因为 CronJob 的设计和 Linux CronTab 过于相似，所以很多人都会把其引申为在Kubernetes集群攻击的一些持久化思路。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;官方文档&lt;/p&gt;&lt;p&gt;https://Kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/ 里也谈及了 CronJob 和 CronTab 的对比， 这个技术也确实可以和 CronTab 一样一定程度上可以满足持久化的场景。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里有一个我们预研时使用的  CronJob 配置：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.6257143&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftrrCeuxvK2FlC1SVIZx0jOQOrVfgibPg7Acwq8xadYojuKht8HvebhyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.3740741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftWJSdjSw4orHiagibFcg9JWAE78DBABCVudY6DVfAHKs6ibbKQntYicsjFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;此处的配置会隔每分钟创建一个具有生命周期的POD，同时这些容器也可以使用特权容器（如上述配置）、挂载大目录等设置，此时持久化创建的 POD 就可以拥有特权和访问宿主机根目录文件的权限。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;不过实际对抗过程中，虽然我们也会对恶意的POD和容器做一定的持久化，但是直接使用 CronJob 的概率却不高。在创建后门POD的时候，直接使用 restartPolicy: Always 就可以方便优雅的进行后门进程的重启和维持，所以对 CronJob 的需求反而没那么高。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.1453704&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JMH1pEQ7qP5lIovB8NLL2Anic3icVltSftVUtO0jicZWfyBIVotbJ1D2uhQ3slMibqowUq21tdNoPlZeHQciauJN0Fw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;14. 致谢&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;感谢 Lake2、Mark4z5等蓝军各位技术和运营师傅在成文前后中的审核和修正，感谢业界 CDXY 和 LAZYDOG 两位师傅在容器安全研究中的交流和讨论。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;也感谢您读到现在，这篇文章匆忙构成肯定有不周到或描述不正确的地方，期待业界师傅们用各种方式指正勘误。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;15. 引用&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;https://github.com/cdk-team/CDK/&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://force.tencent.com/docs/CIS2020-Attack-in-a-Service-Mesh-Public.pdf?v=1&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://github.com/cncf/toc/blob/master/DEFINITION.md&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://www.cncf.io/blog/2017/04/26/service-mesh-critical-component-cloud-native-stack/&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://github.com/lxc/lxcfs&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://github.com/cdr/code-server&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://Kubernetes.io/docs/reference/generated/kubectl/kubectl-commands&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://thehackernews.com/2021/01/new-docker-container-escape-bug-affects.html&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://medium.com/jorgeacetozi/Kubernetes-master-components-etcd-api-server-controller-manager-and-scheduler-3a0179fc8186&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://wohin.me/rong-qi-tao-yi-gong-fang-xi-lie-yi-tao-yi-ji-zhu-gai-lan/#4-2-procfs-&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://security.tencent.com/index.php/announcement/msg/193&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://www.freebuf.com/vuls/196993.html&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://Kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://Kubernetes.io/zh/docs/reference/command-line-tools-reference/kubelet/&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://www.cdxy.me/?p=827&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://medium.com/jorgeacetozi/kubernetes-master-components-etcd-api-server-controller-manager-and-scheduler-3a0179fc8186&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://github.com/neargle/CVE-2018-6574-POC&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://www.serverless.com/blog/serverless-faas-vs-containers/&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;关于腾讯蓝军&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;腾讯蓝军（Tencent Force）由腾讯TEG安全平台部于2006年组建，十余年专注前沿安全攻防技术研究、实战演练、渗透测试、安全评估、培训赋能等，采用APT攻击者视角在真实网络环境开展实战演习，全方位检验安全防护策略、响应机制的充分性与有效性，最大程度发现业务系统的潜在安全风险，并推动优化提升，助力企业领先于攻击者，防患于未然。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;自组建以来，腾讯蓝军一方面实施大规模多频次内部红蓝对抗演练，覆盖网络安全、主机安全、应用安全、数据安全等多个层面，持续助力提升腾讯安全防护能力，另一方面对QQ、QQ空间、微信、支付、小程序、腾讯云、游戏等重要业务和内网基础设施开展渗透测试，发现潜在安全风险，大幅提升了公司业务及系统的安全性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;与此同时，腾讯蓝军还积极对外输出安全能力，参与了数字广东等多个大型政企项目的安全建设工作，配合开展网络攻防演练工作，做各行各业的数字化安全助手，持续为产业互联网的数字安全保驾护航。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;腾讯蓝军坚持以攻促防、攻防相长，始终与时俱进，走在网络安全攻防实战研究的最前沿。未来，腾讯蓝军也将继续通过攻防多方视角，探索互联网安全新方向，共建互联网生态安全。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>