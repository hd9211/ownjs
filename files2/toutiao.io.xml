<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1b241b77409b0f9aad775cb49326e1ad</guid>
<title>2022 年来了！抓紧啦！</title>
<link>https://toutiao.io/k/rf8ezjy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a33a2ff093fa43e0d255bd4a7d5a7d25</guid>
<title>非常哇塞的 ES读场景、写场景 性能优化指南！你值得拥有！</title>
<link>https://toutiao.io/k/5pjb28q</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;174&quot; data-backw=&quot;365&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4767123287671233&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/cvQbJDZsKLp6wejHtKTRbqqQyt0wMk9K1wNtuwRqQTJAPOJ1KiaqSeSRbIJRTicVicKpDKRndBodY2DBNN20tvWwA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;365&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原创：小姐姐味道（微信公众号ID：xjjdog），欢迎分享，转载请保留出处。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ES作为NoSQL数据库里非常重要的一员，使用越来越广泛。虽然它因为索引延迟的原因，数据在时效性上有一些缺陷，但其大容量、分布式的优秀设计，使得它在时效性要求并不是特别高的类实时搜索领域，能够大展身手。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据使用场景和用途，ES可以分为写入和读取两种典型的应用方式。比如ELKB，我们就需要额外关注它的&lt;code&gt;写优化&lt;/code&gt;；再比如从MySQL中同步数据到ES的宽表，我们就需要额外关注它的&lt;code&gt;读优化&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;废话不多说，我们直接show一下优化方法。如果你对ES的一些概念还不是很清楚，建议收藏本文慢慢看。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.写入优化&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日志属于写多读少的业务场景，对写入速度要求很高。拿我们其中一个集群来说，单集群日志量达到百TB，每秒钟日志写入量达到10W条。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据写入，主要有三个动作：flush、refresh和merge。通过调整它们的行为，即可在性能和数据可靠性之间进行权衡。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 translog异步化&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，ES需要写一份translog，它类似于MySQL中的redolog，为的是避免在断电的时候数据丢失。ES默认每次请求都进行一次flush，但对于日志来说，这没有必要，可以将这个过程改为异步的，刷盘间隔为60秒。参数如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;curl-H&lt;span&gt;&quot;Content-Type: application/json&quot;&lt;/span&gt;-XPUT&lt;span&gt;&#x27;http://localhost:9200/_all/_settings?preserve_existing=true&#x27;&lt;/span&gt;-d&lt;span&gt;&#x27;{&lt;br/&gt;  &quot;index.translog.durability&quot; : &quot;async&quot;,&lt;br/&gt;  &quot;index.translog.flush_threshold_size&quot; : &quot;512mb&quot;,&lt;br/&gt;  &quot;index.translog.sync_interval&quot; : &quot;60s&quot;&lt;br/&gt;}&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这可以说是最重要的一步优化了，对性能的影响最大，但在极端情况下会有丢失部分数据的可能。对于日志系统来说，是可以忍受的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 增加refresh间隔&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了写translog，ES还会将数据写入到一个缓冲区中。但是注意了！此时，缓冲区的内容是无法被搜索到的，它还需要写入到segment里面才可以，也就是刷新到lucence索引里面。这就是refresh动作，默认1秒。也就是你写入的数据，大概率1秒之后才会被搜索到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是为什么ES不是实时搜索系统的原因，它从数据写入到数据读出，一般是有一个合并过程的，有一定的时间差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过index.refresh_interval可以修改这个刷新间隔。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于日志系统来说，当然要把它调大一点啦。xjjdog这里调整到了120s，减少了这些落到segment的频率，I/O的压力自然会小，写入速度自然会快。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;curl-H&lt;span&gt;&quot;Content-Type: application/json&quot;&lt;/span&gt;-XPUT&lt;span&gt;&#x27;http://localhost:9200/_all/_settings?preserve_existing=true&#x27;&lt;/span&gt;-d&lt;span&gt;&#x27;{&lt;br/&gt;  &quot;index.refresh_interval&quot; : &quot;120s&quot;&lt;br/&gt;}&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3 merge&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;merge其实是lucene的机制，它主要是合并小的segment块，生成更大的segment，来提高检索的速度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因就是refresh过程会生成一大堆小segment文件，数据删除也会产生空间碎片。所以merge，通俗来讲就像是碎片整理进程。像postgresql等，也有vaccum进程在干同样的事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显而易见，这种整理操作，既浪费I/O，又浪费CPU。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你的系统merge非常频繁，那么调整merge的块大小和频率，是一个比较好的方法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.读取优化&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 指定路由&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你向ES里写数据，那么它会为你设置一个离散的隐藏ID，落到哪个分片，是不一定的。如果你根据一个查询条件查询数据，你设置了6个shards的话，它要查询6次才行。如果能够在路由的时候就知道数据在哪个分片上，查询速度自然会上升，这就要求我们在构造数据的时候，人工指定路由规则。它的实际运行规则如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;shard = &lt;span&gt;hash&lt;/span&gt;(routing) % number_of_primary_shards&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，一个查询会变成这样。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;GET my-index-000001/_search&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;query&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;terms&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;_routing&quot;&lt;/span&gt;: [ &lt;span&gt;&quot;user1&quot;&lt;/span&gt; ] &lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，如果你的查询维度较多，又对数据的查询速度有非常高的有求，根据routing存放多份数据是一个比较好的选择。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 rollover冷热分离&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;rollover根据索引大小，文档数或使用期限自动过渡到新索引。当rollover触发后，将创建新索引，写别名将更新为指向新索引，所有后续更新都将写入新索引，比如&lt;code&gt;indexname-000001.&lt;/code&gt;这种模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从rollover这个名字可以看出来，它和Java的log日志有一定的相似之处，比如Log4j的RollingFileAppender。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当索引变的非常大，通常是几十GB，那它的查询效率将变的非常的低，索引重建的成本也较大。实际上，很多索引的数据在时间维度上有较为明显的规律，一些冷数据将很少被用到。这个时候，建立滚动索引将是一个比较好的办法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;滚动索引一般可以与索引模板结合使用，实现按一定条件自动创建索引，ES的官方文档有具体的_rollover建立方法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 使用BoolQuery替代TermQuery&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Bool查询现在包括四种子句，must、filter、should和must_not。Bool查询是true、false对比，而TermQuery是精确的字符串比对，所以如果需求相似，BoolQuery自然会快于TermQuery。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 将大查询拆成分段查询&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些业务的查询比较复杂，我们不得不拼接一张非常大的宽表放在ES中，这有两个比较明显的问题。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;宽表的数据往往需要从其他数据源中回查拼接而成，数据更新时对源库或者ES本身都有较大的压力&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务的查询JSON需要书写的非常复杂，查询效率未知，一次查询锁定的内存过高，无法进行深入优化&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，宽表不论在RDBMS中还是ES中，都会与复杂的查询语句有关，其锁定时间都较长，业务也不够灵活。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应对这种场景的策略，通常将复杂的数据查询，转移到业务代码的拼接上来。比如，将一段非常冗长的单条查询，拆分成循环遍历的100条小查询。所有的数据库都对较小的查询请求有较好的响应，其整体性能整体上将优于复杂的单条查询。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这对我们的ES索引建模能力和编码能力提出了挑战。毕竟，在ES层面，互不相关的几个索引，将作为整体为其他服务提供所谓的数据中台接口。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5 增加第一次索引的速度&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多业务的索引数据往往来自于MySQL等传统数据库，第一次索引往往是全量索引，后面才是增量索引。必要的时候，也会进行索引的重建，大量的数据灌入造成了ES的索引速度建立缓慢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了缓解这种情况，建议在创建索引的时候，把副本数量设置成1，即没有从副本。等所有数据索引完毕，再将副本数量增加到正常水平。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，数据能够快速索引，副本会在后台慢慢复制。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.通用优化&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，我们还可以针对ES做一些通用的优化。比如，使用监控接口或者trace工具，发现线程池有明显的瓶颈，则需要调整线程池的大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的优化项如下。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 线程池优化&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新版本对线程池的配置进行了优化，不需要配置复杂的search、bulk、index线程池。有需要配置下面几个就行了：thread_pool.get.size, thread_pool.write.size, thread_pool.listener.size, thread_pool.analyze.size。具体可观测_cat/thread_pool接口暴露的数据进行调整。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 物理冷热分离&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的rollover接口，我们可以实现索引滚动。但是如何将冷数据存放在比较慢但是便宜的节点上？如何将某些索引移动过去？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ES支持给节点打标签，具体方式是在elasticsearch.yml文件中增加一些属性。比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//热节点&lt;/span&gt;&lt;br/&gt;node.attr.temperature: hot &lt;br/&gt;&lt;span&gt;//冷节点&lt;/span&gt;&lt;br/&gt;node.attr.temperature: cold &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;节点有了冷热属性后，接下来就是指定数据的冷热属性，来设置和调整数据分布。ES提供了index shard filtering功能来实现索引的迁移。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，可以对索引也设置冷热属性。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;PUT hot_data_index/_settings&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;&quot;index.routing.allocation.require.temperature&quot;&lt;/span&gt;: &lt;span&gt;&quot;hot&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些索引将自动转移到冷设备上。我们可以写一些定时任务，通过_cat接口的数据，自动的完成这个转移过程。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 多磁盘分散I/O&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，可以通过配置多块磁盘的方式，来分散I/O的压力，但容易会造成数据热点集中在单块磁盘上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ES支持在一台机器上配置多块磁盘，所以在存储规模上有更大的伸缩性。在配置文件中，配置path.data属性，即可挂载多块磁盘。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;path.data : /data1, /data2, /data3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得注意的是，如果你是在扩容，那么就需要配合reroute接口进行索引的重新分配。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 减少单条记录的大小&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lucene的索引建立过程，非常耗费CPU，可以减少倒排索引的数量来减少CPU的损耗。第一个优化就是减少字段的数量；第二个优化就是减少索引字段的数量。具体的操作，是将不需要搜索的字段，index属性设置为not_analyzed或者no。至于_source和_all，在实际调试中效果不大，不再赘述。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;End&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ES的使用越来越广泛，从ELKB到APM，从NoSQL到搜索引擎，ES在企业中的地位也越来越重要。本文通过分析ES写入和读取场景的优化，力求从原理到实践层面，助你为ES加速。希望你在使用ES时能够更加得心应手。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通常，一个ES集群对配置的要求是较高的，尤其是APM等场景，甚至会占到PaaS平台的1/3资源甚至更多。ES提供了较多的配置选项，我们可以根据应用场景，调整ES的表现，使其更好的为我们服务。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;作者简介：&lt;strong&gt;小姐姐味道&lt;/strong&gt;  (xjjdog)，一个不允许程序员走弯路的公众号。聚焦基础架构和Linux。十年架构，日百亿流量，与你探讨高并发世界，给你不一样的味道。我的个人微信xjjdog0，欢迎添加好友，进一步交流。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a3a91c3e38a3b1a4f437680ec48e32cd</guid>
<title>关于项目使用组件版本选择的思考</title>
<link>https://toutiao.io/k/6if9mg1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485934&amp;amp;idx=1&amp;amp;sn=71bc51653cef4a1b3c86e663fb2a3c62&amp;amp;chksm=fafde340cd8a6a5646411696514f350cc1cb00dbac89d6989115f3eeaf1b05d9bb4167b6011e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《项目中怎样做技术选型》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《项目中怎样做技术选型》&lt;/a&gt;中，我介绍了技术选型的一些思考。一旦选定了用什么技术，还涉及到版本的选择。版本不是越高越好，也不是用的越多越好，涉及很多因素。今天从具体实例入手来聊一聊版本选择的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;实例一 servlet版本&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我最近在带一个新项目，因为搭建环境的时候，选择的版本比较新。下游是运行了好多年的老项目，版本相对老一些。其中servlet版本，新项目使用4.0.1版本，它在处理httpHeader时全转成了小写。下游使用3.1.0版本，它是按照原来的大小写原样透传的。这个问题不难处理，下游要兼容一下，做小写转换后再处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;问题是由此引起的思考：新项目很多的版本比较新，是否是最合适的呢？这个问题我没有马上给出结论。而是说这个是个重要不紧急的事情，并不会阻塞开发进度，所以先保持现状不动，我过节有时间好好调研一下再决定。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这是新项目中的使用的一些jar包：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.3338557993730407&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlicSPnJ1lKHwPLDJXqfjpatOj9b3oEEZU9gr4ZmzfOwV5EWbOR1Ws6jClo1G9BR39SWeBj6T0Rwt8Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1276&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这是老项目中使用的一些jar包：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.3338557993730407&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlicSPnJ1lKHwPLDJXqfjpatOuGR7KJb9c4ybdz1z1CIn9AdILHFtj7Ed8z4mGjjARJZhEBmjswqpPQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1276&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;欢迎大家指出使用版本的问题，帮助我们保持系统稳定性。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上面总共涉及三个servlet版本：&lt;/p&gt;&lt;p&gt;servlet-api---2.5(实际没有用)&lt;/p&gt;&lt;p&gt;javax.servlet-api---3.1.0&lt;/p&gt;&lt;p&gt;javax.servlet-api---4.0.1&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;分别进行调研结果如下。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;servlet-api---2.5&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;支持配置文件形式注册servlet、listener、filter等&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;javax.servlet-api---3.1.0&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;同时支持注解形式注入&lt;/p&gt;&lt;p&gt;同时支持动态注入&lt;/p&gt;&lt;p&gt;支持扩展插件&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;javax.servlet-api---4.0.1&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;支持&lt;span&gt;从HTTP请求推送生成器等新特性&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;结论&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因为实际我们这个项目用&lt;strong&gt;&lt;span&gt;javax.servlet-api&lt;/span&gt;&lt;/strong&gt;只是要获取http请求信息，别的都用不到。所以更合适使用线上稳定运行的版本&lt;strong&gt;&lt;span&gt;3.1.0&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;实例二 spring-boot版本&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们新项目中spring-boot的版本用的是2.3.2.&lt;span&gt;RELEASE。这个也高于目前项目中使用的2.1.*的版本。我也调研了一下官网。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7717502558853634&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9mx4E8rZzxHXAlN9gOAiaRzjBtOZaV0HNK7BL2AC0f2HteSfoYH0Nf70S20N4ztF56VQMqFhpEdtw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;977&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;2.1.x版本已经在19年停止维护，商业支持(商业支持是要收费的，但是如果发现重大bug问题会公开)也在21年初停止了。如果继续使用这个版本，一旦有问题，得不到官方支持，不建议使用。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2.3.x也已经在去年停止维护，商业支持会支持到今年8月份。这表明2.3.x是一个很成熟的版本了。相比而言，虽然免费维护上已经不再支持，但是看下面：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7215909090909091&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9mx4E8rZzxHXAlN9gOAiaRzTVXmODgPoC6WRh5goXbUMPY7T6jNXTkNUspowYnibWicFRT2a5Eabl8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1056&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;上面可以看到2.3.x的版本官方还是建议使用的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那在2.3.x中到底使用哪个版本呢？官网中GA(正式版本)建议的是2.3.12.RELEASE。先看一下，各个版本的变更主要变更了什么。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;通过调研，变更主要是两项：&lt;/p&gt;&lt;p&gt;1&amp;gt;bug修复&lt;/p&gt;&lt;p&gt;2&amp;gt;Spring Framework等框架的版本升级&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;bug修复&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h1 itemprop=&quot;name&quot;&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1 itemprop=&quot;name&quot;&gt;Spring Boot 2.3.2 发布，解决 Too many open files 导致的应用宕机问题。&lt;/h1&gt;&lt;h1&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1&gt;Spring Boot 2.3.6 也是一个重要的fix bug版本&lt;/h1&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;修复配置元数据注解处理器可能会对布尔属性使用错误访问器的问题 #24058&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用 Tomcat 时，当 Spring Boot 的等价属性 (equivalent property) 没有设置，通过 javax.net.ssl 系统属性设置的密钥和信任存储密码会被 null 覆盖 #24052&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;@DataJpaTest无法将 H2 和 schema.sql 以及 spring.datasource.schema-username 一起使用 #24023&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;当 Quartz 数据源不是主要数据源时，JdbcStoreTypeConfiguration 会选择主要数据源的事务 #24014&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;修复 TestTypeExcludeFilter 没有实现其超类所需要的 hashCode 和 equals #24012&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;自动配置不应使用@PostConstruct，因为在没有依赖 jakarta-annotation-api 的情况下，它在 Java 11+ 上是被忽略的 #24009&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果配置文件包含一个隐藏的路径元素，则不再加载 #23983&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;当调用 spring-boot-loader 的 JarFileWrapper.stream() 时，出现 &quot;java.lang.IllegalStateException: zip file closed&quot; #23821&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;h1&gt;Spring Boot 2.3.9 BUG修复：&lt;/h1&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;在通过jOOQ ＃25279访问数据库之前，由Flyway或Liquibase执行的迁移可能尚未完成。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Hibernate的新的hibernate-micrometer模块的依赖性管理丢失了＃25277&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;DatabaseDriver无法正确检测到Amazon Redshift ＃25265&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果将bean定义为ConnectionFactory ＃25138，则缺少RabbitMQ指标&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用JPA延迟存储库时，子上下文的ContextRefreshedEvent可能导致死锁＃24966&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Spring Data Solr支持未标记为已弃用 ＃24942&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在MetricsClientHttpRequestInterceptor中记录指标时失败可能会干扰RestTemplate的主要行为＃24753&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;WebMvcTest和WebFluxTest忽略用户提供的Thymeleaf IDialect bean ＃24149&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Spring Framework等框架的版本升级&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们之前线上有用spring boot 2.1.x的版本，对应spring的5.1.x。spring boot 2.3.x的版本对应的主要是spring 5.2.x。看官网怎么说：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6683070866141733&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9mx4E8rZzxHXAlN9gOAiaRzOmKgFJV327Z2RtM0Ov2bzrM94dMPZPLImVS7u9VI0I1Hic7jN3qjyXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1016&quot;/&gt;&lt;/p&gt;&lt;p&gt;5.2.x版本这几年刚刚停止维护，商业维护还有近两年的时间。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7294921875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9mx4E8rZzxHXAlN9gOAiaRztnR2bxDc5yvsziay4huPCwdeDLva0GXbl5sGvEjObIoC2WKv0WhVW0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;p&gt;官方推荐学习的正式版本除了最新版外，就是5.2.19.RELEASE。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;spring boot除了spring framework还有一个重要组成netty。官网有介绍2.3.12.RELEASE对应的netty版本是netty4。目前公司已经在推升级组件，其中就涉及netty使用的netty4，与公司要求相符。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.547378104875805&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9mx4E8rZzxHXAlN9gOAiaRzuTfyibcGS7BqZqwA9ibypw7sxnDQR7aTxoDJbQPjnibvWvVJzu0bbHLHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1087&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另外，我查了spring boot 2.3.x明确表示提供对jdk8及以上的支持，并且在jdk8上有全面的测试。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;建议采用 spring boot 2.3.12.RELEASE 版本。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因为2.3.x版本已经非常稳定，而2.3的小版本更新基本上都是在修复bug。而且修复的是linux交互、死锁等相对底层bug。其依赖版本也符合公司要求。&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ae039a918685ff89831ceed4be90800b</guid>
<title>手工模拟实现 Docker 容器网络</title>
<link>https://toutiao.io/k/2th2vk6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;网络虚拟化，其实用一句话来概括就是用软件来模拟实现真实的物理网络连接。比如 Docker 就是用纯软件的方式在宿主机上模拟出来的独立网络环境。我们今天来徒手打造一个虚拟网络，实现在这个网络里访问外网资源，同时监听端口提供对外服务的功能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6301369863013698&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoZkkNJTcgw7roGdXGbylAWbaAUle7MUDP6EJGBic8s6x3KGJibuhxDjWQ2MoPx7ELHia419JdxD2rmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;511&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完这一篇后，相信你对 Docker 虚拟网络能有进一步的理解。好了，我们开始！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 基础知识回顾&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.1 veth、bridge 与 namespace&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Linux 下的 veth 是一对儿虚拟网卡设备，和我们常见的 lo 很类似。在这儿设备里，从一端发送数据后，内核会寻找该设备的另一半，所以在另外一端就能收到。不过 veth 只能解决一对一通信的问题。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果有很多对儿 veth 需要互相通信的话，就需要引入 bridge 这个虚拟交换机。各个 veth 对儿可以把一头连接在 bridge 的接口上，bridge 可以和交换机一样在端口之间转发数据，使得各个端口上的 veth 都可以互相通信。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;每个虚拟网卡设备、进程、socket、路由表等等网络栈相关的对象默认都是归属在 init_net 这个缺省的 namespace 中的。&lt;/span&gt;&lt;span&gt;不过我们希望不同的虚拟化环境之间是隔离的，用 Docker 来举例，那就是不能让 A 容器用到 B 容器的设备、路由表、socket 等资源，甚至连看一眼都不可以。&lt;/span&gt;&lt;span&gt;只有这样才能保证不同的容器之间复用资源的同时，还不会影响其它容器的正常运行。&lt;/span&gt;&lt;span&gt;而且它们之间、和宿主机之间都可以互相通信。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5733855185909981&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoZkkNJTcgw7roGdXGbylAWIt7SBGMjwysgxlDu5J2TER1D1WUowlc95TibfA9ck2MMxLR1DUonOiaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;511&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这里有一个问题没有解决，那就是虚拟出来的网络环境和外部网络的通信。&lt;/span&gt;&lt;span&gt;还拿 Docker 容器来举例，你启动的容器里的服务肯定是需要访问外部的数据库的。&lt;/span&gt;&lt;span&gt;还有就是可能需要暴露比如 80 端口对外提供服务。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们今天的文章主要就是解决这两个问题的，一是从虚拟网络中访问外网，二是在虚拟网络中提供服务供外网使用。解决它们需要用到路由和 NAT 技术。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1.2 路由选择&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Linux 是在发送数据包的时候，会涉及到路由过程。这个发送数据包既包括本机发送数据包，也包括途径当前机器的数据包的转发。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;先来看本机发送数据包。&lt;/span&gt;&lt;span&gt;所谓路由其实很简单，就是该选择哪张网卡（虚拟网卡设备也算）将数据写进去。&lt;/span&gt;&lt;span&gt;到底该选择哪张网卡呢，规则都是在路由表中指定的。&lt;/span&gt;&lt;span&gt;Linux 中可以有多张路由表，最重要和常用的是 local 和 main。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;local 路由表中统一记录本地，确切的说是本网络命名空间中的网卡设备 IP 的路由规则。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-id&quot;&gt;#ip&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;route&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;local&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;local&lt;/span&gt; 10&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.143&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.x&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.y&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;dev&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;eth0&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;proto&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;kernel&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;scope&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;host&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;src&lt;/span&gt; 10&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.143&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.x&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.y&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;local&lt;/span&gt; 127&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.1&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;dev&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;lo&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;proto&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;kernel&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;scope&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;host&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;src&lt;/span&gt; 127&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其它的路由规则，一般都是在 main 路由表中记录着的。&lt;/span&gt;&lt;span&gt;可以用 &lt;/span&gt;&lt;span&gt;ip route list table local&lt;/span&gt;&lt;span&gt; 查看，也可以用更简短的 &lt;/span&gt;&lt;span&gt;route -n。&lt;/span&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.15390625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoZkkNJTcgw7roGdXGbylAWnP0aXtaibKmL0enu4pCNFVymaKqAgicrRicK0xsgc8xevYrfHUykEibxQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;再看途径当前机器的数据包的转发。除了本机发送以外，转发也会涉及路由过程。如果 Linux 收到数据包以后发现目的地址并不是本地的地址的话，就可以选择把这个数据包从自己的某个网卡设备上转发出去。这个时候和本机发送一样，也需要读取路由表。根据路由表的配置来选择从哪个设备将包转走。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不过值得注意的是，Linux 上转发功能默认是关闭的。也就是发现目的地址不是本机 IP 地址默认是将包直接丢弃。需要做一些简单的配置，然后 Linux 才可以干像路由器一样的活儿，实现数据包的转发。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;1.3 iptables 与 NAT&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Linux 内核网络栈在运行上基本上是一个纯内核态的东西，但为了迎合各种各样用户层不同的需求，内核开放了一些口子出来供用户层来干预。其中 iptables 就是一个非常常用的干预内核行为的工具，它在内核里埋下了五个钩子入口，这就是俗称的五链。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Linux 在接收数据的时候，在 IP 层进入 ip_rcv 中处理。再执行路由判断，发现是本机的话就进入 ip_local_deliver 进行本机接收，最后送往 TCP 协议层。在这个过程中，埋了两个 HOOK，第一个是 PRE_ROUTING。这段代码会执行到 iptables 中 pre_routing 里的各种表。发现是本地接收后接着又会执行到 LOCAL_IN，这会执行到 iptables 中配置的 input 规则。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在发送数据的时候，查找路由表找到出口设备后，依次通过 __ip_local_out、 ip_output 等函数将包送到设备层。在这两个函数中分别过了 OUTPUT 和 POSTROUTING 开的各种规则。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果是转发过程，Linux 收到数据包发现不是本机的包可以通过查找自己的路由表找到合适的设备把它转发出去。那就先是在 ip_rcv 中将包送到 ip_forward 函数中处理，最后在 ip_output 函数中将包转发出去。在这个过程中分别过了 PREROUTING、FORWARD 和 POSTROUTING 三个规则。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;综上所述，iptables 里的五个链在内核网络模块中的位置就可以归纳成如下这幅图。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7584541062801933&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoZkkNJTcgw7roGdXGbylAW0CibcvvwFsGnhnGHT3wLATQXkc8mKNArUowqmfmiaykeNfue5wlePoYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;621&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数据接收过程走的是 1 和 2，发送过程走的是 4 、5，转发过程是 1、3、5。有了这张图，我们能更清楚地理解 iptable 和内核的关系。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 iptables 中，根据实现的功能的不同，又分成了四张表。分别是 raw、mangle、nat 和 filter。其中 nat 表实现我们常说的 NAT（Network AddressTranslation） 功能。其中 nat 又分成 SNAT（Source NAT）和 DNAT（Destination NAT）两种。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;SNAT 解决的是内网地址访问外部网络的问题。它是通过在 POSTROUTING 里修改来源 IP 来实现的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;DNAT 解决的是内网的服务要能够被外部访问到的问题。它在通过 PREROUTING 修改目标 IP 实现的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2.  实现虚拟网络外网通信&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基于以上的基础知识，我们用纯手工的方式搭建一个可以和 Docker 类似的虚拟网络。而且要实现和外网通信的功能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;2.1 实验环境准备&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们先来创建一个虚拟的网络环境出来，其命名空间为 net1。宿主机的 IP 是 10.162 的网段，可以访问外部机器。虚拟网络为其分配 192.168.0 的网段，这个网段是私有的，外部机器无法识别。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7335526315789473&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoZkkNJTcgw7roGdXGbylAWuafE6lYJrZguqBcMZiakPicKHaRiaY6Hfibc4CsYmxVw4JHLe50OvZ9T6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;304&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个虚拟网络的搭建过程如下。先创建一个 netns 出来，命名为 net1。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;apache&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;创建一个 veth 对儿（veth1 - veth1_p），把其中的一头 veth1 放在 net1 中，给它配置上 IP，并把它启动起来。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;/span&gt; ip link add veth1 &lt;span class=&quot;code-snippet__built_in&quot;&gt;type&lt;/span&gt; veth peer name veth1_p&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;/span&gt; ip link &lt;span class=&quot;code-snippet__built_in&quot;&gt;set&lt;/span&gt; veth1 netns net1&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;/span&gt; ip netns &lt;span class=&quot;code-snippet__built_in&quot;&gt;exec&lt;/span&gt; net1 ip addr add 192.168.0.2/24 dev veth1  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;/span&gt; ip netns &lt;span class=&quot;code-snippet__built_in&quot;&gt;exec&lt;/span&gt; net1 ip link &lt;span class=&quot;code-snippet__built_in&quot;&gt;set&lt;/span&gt; veth1 up&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;创建一个 bridge，给它也设置上 ip。&lt;/span&gt;&lt;span&gt;接下来把 veth 的另外一端 veth1_p 插到 bridge 上面。&lt;/span&gt;&lt;span&gt;最后把网桥和 veth1_p 都启动起来。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;/span&gt; brctl addbr br0&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;/span&gt; ip addr add 192.168.0.1/24 dev br0&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;/span&gt; ip link &lt;span class=&quot;code-snippet__built_in&quot;&gt;set&lt;/span&gt; dev veth1_p master br0&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;/span&gt; ip link &lt;span class=&quot;code-snippet__built_in&quot;&gt;set&lt;/span&gt; veth1_p up&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;/span&gt; ip link &lt;span class=&quot;code-snippet__built_in&quot;&gt;set&lt;/span&gt; br0 up&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样我们就在 Linux 上创建出了一个虚拟的网络。&lt;/span&gt;&lt;/pre&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;2.2 请求外网资源&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在假设我们上面的 net1 这个网络环境中想访问外网。这里的外网是指的虚拟网络宿主机外部的网络。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们假设它要访问的另外一台机器 IP 是 10.153.*.* ，这个 10.153.*.* 后面两段由于是我的内部网络，所以隐藏起来了。你在实验的过程中，用自己的 IP 代替即可。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.451417004048583&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoZkkNJTcgw7roGdXGbylAWVjWLVC4BHKyGQAj71powwvwAKlNejmlndED5aHoXyiaKy84P6jeFWrg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;494&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们直接来访问一下试试：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;/span&gt; ip netns &lt;span class=&quot;code-snippet__built_in&quot;&gt;exec&lt;/span&gt; net1 ping 10.153.*.*&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;connect: Network is unreachable&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;提示网络不通，这是怎么回事？用这段报错关键字在内核源码里搜索一下：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;span class=&quot;code-snippet__meta-keyword&quot;&gt;define&lt;/span&gt; ENETUNREACH 229 /* Network is unreachable */&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;ping_sendmsg&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; kiocb *iocb, &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; sock *sk, &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; msghdr *msg,&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   size_t len&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   rt = ip_route_output_flow(net, &amp;amp;fl4, sk);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (IS_ERR(rt)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      err = PTR_ERR(rt);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      rt = NULL;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (err == -ENETUNREACH)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       IP_INC_STATS_BH(net, IPSTATS_MIB_OUTNOROUTES);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      &lt;span class=&quot;code-snippet__keyword&quot;&gt;goto&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   ...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;out&lt;/span&gt;: &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; err; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 ip_route_output_flow 这里的返回值判断如果是 ENETUNREACH 就退出了。这个宏定义注释上来看报错的信息就是 “Network is unreachable”。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个 ip_route_output_flow 主要是执行路由选路。所以我们推断可能是路由出问题了，看一下这个命名空间的路由表。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;ip&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;netns&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;net1&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;route&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-n&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Kernel&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;IP&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;routing&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;table&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Destination&lt;/span&gt;     &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Gateway&lt;/span&gt;         &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Genmask&lt;/span&gt;         &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Flags&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Metric&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Ref&lt;/span&gt;    &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Use&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Iface&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;192&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;     0&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;         255&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.255&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.255&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;   &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;U&lt;/span&gt;     0      0        0 &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;veth1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;怪不得，原来 net1 这个 namespace 下默认只有 192.168.0.* 这个网段的路由规则。我们 ping 的 IP 是 10.153.*.* ，根据这个路由表里找不到出口。自然就发送失败了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们来给 net 添加上默认路由规则，只要匹配不到其它规则就默认送到 veth1 上，同时指定下一条是它所连接的 bridge（192.168.0.1）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;ip&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;netns&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;net1&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;route&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-n&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Kernel&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;IP&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;routing&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;table&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Destination&lt;/span&gt;     &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Gateway&lt;/span&gt;         &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Genmask&lt;/span&gt;         &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Flags&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Metric&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Ref&lt;/span&gt;    &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Use&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;Iface&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;192&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;     0&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;         255&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.255&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.255&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;   &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;U&lt;/span&gt;     0      0        0 &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;veth1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;ip&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;netns&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;net1&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;route&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;add&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;gw&lt;/span&gt; 192&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.1&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;veth1&lt;/span&gt; &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;再 ping 一下试试。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;ip&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;netns&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;exec&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;net1&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;ping&lt;/span&gt; 10&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.153&lt;/span&gt;.*.* &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-c&lt;/span&gt; 2&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;PING&lt;/span&gt; 10&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.153&lt;/span&gt;.*.* (10&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.153&lt;/span&gt;.*.*) 56(84) &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;bytes&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;data&lt;/span&gt;.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;---&lt;/span&gt; 10&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.153&lt;/span&gt;.*.* &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;ping&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;statistics&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;---&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;2 &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;packets&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;transmitted&lt;/span&gt;, 0 &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;received&lt;/span&gt;, 100% &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;packet&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;loss&lt;/span&gt;, &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;time&lt;/span&gt; 999&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;ms&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;额好吧，仍然不通。上面路由帮我们把数据包从 veth 正确送到了 bridge 这个网桥上。接下来网桥还需要 bridge 转发到 eth0 网卡上。所以我们得打开下面这两个转发相关的配置&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;apache&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不过这个时候，还存在一个问题。那就是外部的机器并不认识 192.168.0.* 这个网段的 ip。它们之间都是通过 10.153.*.* 来进行通信的。设想下我们工作中的电脑上没有外网 IP 的时候是如何正常上网的呢？外部的网络只认识外网 IP。没错，那就是我们上面说的 NAT 技术。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们这次的需求是实现内部虚拟网络访问外网，所以需要使用的是 SNAT。它将 namespace 请求中的 IP（192.168.0.2）换成外部网络认识的 10.153.*.*，进而达到正常访问外部网络的效果。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;apache&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;来再 ping 一下试试，欧耶，通了！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;markdown&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__section&quot;&gt;# ip netns exec net1 ping 10.153.*.*&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;PING 10.153.&lt;span class=&quot;code-snippet__emphasis&quot;&gt;*.*&lt;/span&gt; (10.153.&lt;span class=&quot;code-snippet__emphasis&quot;&gt;*.*&lt;/span&gt;) 56(84) bytes of data.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;64 bytes from 10.153.&lt;span class=&quot;code-snippet__emphasis&quot;&gt;*.*&lt;/span&gt;: icmp_seq=1 ttl=57 time=1.70 ms&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;64 bytes from 10.153.&lt;span class=&quot;code-snippet__emphasis&quot;&gt;*.*&lt;/span&gt;: icmp_seq=2 ttl=57 time=1.68 ms&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这时候我们可以开启 tcpdump 抓包查看一下，在 bridge 上抓到的包我们能看到还是原始的源 IP 和 目的 IP。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.0958904109589041&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoZkkNJTcgw7roGdXGbylAWNNQ50qrcVO5DLht7JFUlia9wgpjf96knQFHV7DAaHHAuMTkIXY1gO4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;657&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;再到 eth0 上查看的话，源 IP 已经被替换成可和外网通信的 eth0 上的 IP 了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.10060975609756098&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoZkkNJTcgw7roGdXGbylAWjtVspAltUWPR223xO2lBnKBYSo1HLLafs8ZktYlqtvJVW4PboooJEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;656&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;至此，容器就可以通过宿主机的网卡来访问外部网络上的资源了。我们来总结一下这个发送过程。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.36319218241042345&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoZkkNJTcgw7roGdXGbylAWmPCXhCE8ZNdyxaBUAcPDvtS131NFzoHm5CGle9d4DO5224yAoyNoaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;614&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;3. 开放容器端口&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们再考虑另外一个需求，那就是把在这个命名空间内的服务提供给外部网络来使用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;和上面的问题一样，我们的虚拟网络环境中 192.168.0.2 这个 IP 外界是不认识它的。只有这个宿主机知道它是谁。所以我们同样还需要 NAT 功能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这次我们是要实现外部网络访问内部地址，所以需要的是 DNAT 配置。DNAT 和 SNAT 配置中有一个不一样的地方就是需要明确指定容器中的端口在宿主机上是对应哪个。比如在 docker 的使用中，是通过 -p 来指定端口的对应关系。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;apache&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们通过如下这个命令来配置 DNAT 规则&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;iptables&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-t&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;nat&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-A&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;PREROUTING&lt;/span&gt;  ! &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-i&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;br0&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-p&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;tcp&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-m&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;tcp&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;--dport&lt;/span&gt; 8088 &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;-j&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;DNAT&lt;/span&gt; &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;--to-destination&lt;/span&gt; 192&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.0&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-class&quot;&gt;.2&lt;/span&gt;&lt;span class=&quot;code-snippet__selector-pseudo&quot;&gt;:80&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里表示的是宿主机在路由之前判断一下如果流量不是来自 br0，并且是访问 tcp 的 8088 的话，那就转发到 192.168.0.2:80 。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 net1 环境中启动一个 Server&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;shell&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;#&lt;/span&gt; ip netns &lt;span class=&quot;code-snippet__built_in&quot;&gt;exec&lt;/span&gt; net1 nc -lp 80&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;外部选一个ip，比如 10.143.*.*， telnet 连一下 10.162.*.* 8088 试试，通了！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Trying&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;10.162.*.*...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Connected&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;to 10.162.*.*.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;Escape&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;character is &#x27;^]&#x27;.&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;开启抓包， # tcpdump -i eth0 host 10.143.*.*。可见在请求的时候，目的是宿主机的 IP 的端口。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2237163814180929&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoZkkNJTcgw7roGdXGbylAWJLicAbW9C66qOPXbnsX3icftThAy48s0hLDWQUEAkp7tb2yIjF3UpaPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;818&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但数据包到宿主机协议栈以后命中了我们配置的 DNAT 规则，宿主机把它转发到了 br0 上。在 bridge 上由于没有那么多的网络流量包，所以不用过滤直接抓包就行，# tcpdump -i br0。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 br0 上抓到的目的 IP 和端口是已经替换过的了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.22413793103448276&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoZkkNJTcgw7roGdXGbylAWMuIj7t0YrNVtdjIvwEKDPBjj4qiaAhVyicBzCQySt7ujlQHiaFUdMyg7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;812&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;bridge 当然知道 192.168.0.2 是 veth 1。于是，在 veth1 上监听 80 的服务就能收到来自外界的请求了！我们来总结一下这个接收过程：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4099264705882353&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoZkkNJTcgw7roGdXGbylAW8Bt6a1yBTicU8cY7fGLZEf3LKic978uw42hSefmIYRGUFtHjMClazPiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;544&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;3. 总结&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在业界已经有很多公司都迁移到容器上了。我们的开发写出来的代码大概率是要运行在容器上的。因此深刻理解容器网络的工作原理非常的重要。这有这样将来遇到问题的时候才知道该如何下手处理。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文开头我们先是简单介绍了 veth、bridge、namespace、路由、iptables 等基础知识。Veth 实现连接，bridge 实现转发，namespace 实现隔离，路由表控制发送时的设备选择，iptables 实现 nat 等功能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接着基于以上基础知识，我们采用纯手工的方式搭建了一个虚拟网络环境。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.281496062992126&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/BBjAFF4hcwoZkkNJTcgw7roGdXGbylAWtTvYNq60Hvwjf2iaHN9rdTtgZicX2pmNLHGcO3FicXqzu97sFicmTGGMYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;508&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个虚拟网络可以访问外网资源，也可以提供端口服务供外网来调用。这就是 Docker 容器网络工作的基本原理。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;整个实验我打包写成一个 Makefile，放到了这里：&lt;/span&gt;&lt;span&gt;https://github.com/yanfeizhang/coder-kung-fu/tree/main/tests/network/test07&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后，我们再扩展一下。今天我们讨论的问题是 Docker 网络通信的问题。Docker 容器通过端口映射的方式提供对外服务。外部机器访问容器服务的时候，仍然需要通过容器的宿主机 IP 来访问。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在 Kubernets 中，对跨主网络通信有更高的要求，要不同宿主机之间的容器可以直接互联互通。所以 Kubernets 的网络模型也更为复杂。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6d828edbb2f1d67b99cc50ca0cd2ece1</guid>
<title>Apache Flink 2022 新年大礼包</title>
<link>https://toutiao.io/k/p0ew92i</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single js_wx_tap_highlight wx_tap_card&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left js_a11y_comma js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzI0OTYwNTQ4Ng==&amp;amp;action=getalbum&amp;amp;album_id=1527102622220992512#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;1527102622220992512&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#Flink&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;50个&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot; aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_title&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p role=&quot;option&quot; aria-labelledby=&quot;js_a11y_reward_qr_word js_a11y_comma js_a11y_reward_qr_title js_a11y_reward_qr_money&quot; aria-describedby=&quot;js_a11y_reward_qr_tips &quot; class=&quot;reward_tips&quot; id=&quot;js_a11y_reward_qr_word&quot;&gt;觉得可以，打赏一元&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img alt=&quot;赞赏二维码&quot; class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_tips&quot; class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>