<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>d248b35f484177c7e4ebe8cd3174cc04</guid>
<title>Redis 字符串命令不止 SET 与 GET</title>
<link>https://toutiao.io/k/75rtacx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>12afbc1d01ccf8d0df6eb7a944495076</guid>
<title>使用稀疏推理加速移动和 Web 上的神经网络</title>
<link>https://toutiao.io/k/vsf8leu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;神经网络的设备端推理以低延迟和注重隐私的方式支持各种实时应用，如姿势估计和背景模糊。使用带有XNNPACK ML 加速库的TensorFlow Lite等 ML 推理框架，工程师通过找到模型大小、推理速度和预测质量之间的最佳点来优化他们的模型以在各种设备上运行。&lt;/p&gt;&lt;p&gt;来优化模型的一种方法是通过使用稀疏神经网络[的1，2，3 ]，其具有它们的权重设为零的显著部分。一般来说，这是一种理想的质量，因为它不仅通过压缩减小了模型大小，而且还可以跳过大部分乘加运算，从而加快推理速度。此外，可以增加模型中的参数数量，然后对其进行稀疏化以匹配原始模型的质量，同时仍然受益于加速推理。然而，这种技术在生产中的使用仍然受到限制，这主要是由于缺乏稀疏流行卷积架构的工具，以及对在设备上运行这些操作的支持不足。&lt;/p&gt;&lt;p&gt;今天，我们宣布为XNNPACK 加速库和 TensorFlow Lite发布一组新功能，这些新功能可实现稀疏网络的高效推理，以及有关如何稀疏化神经网络的指南，目的是帮助研究人员开发自己的设备上稀疏楷模。在合作开发DeepMind，这些工具提供动力的新一代实时感知经验，包括手跟踪在MediaPipe和后台功能在 Google Meet 中，将推理速度从 1.2 倍提高到 2.4 倍，同时将模型大小减少一半。在这篇文章中，我们提供了稀疏神经网络的技术概述——从在训练期间引入稀疏性到设备上部署——并提供一些关于研究人员如何创建自己的稀疏模型的想法。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceHDAwzMibNWRLEVNtL9TgUB0XXzb1ibiaALZgcsicD1EzVqEQfbrAiacStBMUMXD2k89qSdOHUkaQmPJrg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;em&gt;稀疏化神经网络&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;许多现代深度学习架构，如MobileNet和EfficientNetLite，主要由具有小空间内核的深度卷积和线性组合输入图像特征的1x1 卷积组成。虽然此类架构有许多潜在的稀疏化目标，包括在许多网络开始时经常出现的完整2D 卷积或深度卷积，但以推理时间衡量，1x1 卷积是最昂贵的算子。由于它们占总计算量的 65% 以上，因此它们是稀疏化的最佳目标。&lt;/p&gt;&lt;p&gt;建筑学 推理时间 移动网 85% 移动网络V2 71% 移动网络V3 71% EfficientNet-Lite 66% 现代移动架构中专用于 1x1 卷积的推理时间的比较（以百分比为单位）。&lt;/p&gt;&lt;p&gt;在现代设备端推理引擎中，如 XNNPACK，深度学习模型中 1x1 卷积的实现以及其他操作依赖于 HWC 张量布局，其中张量维度对应于高度、宽度和通道（例如，输入图像的红色、绿色或蓝色）。这种张量配置允许推理引擎并行处理对应于每个空间位置（即图像的每个像素）的通道。然而，张量的这种排序不太适合稀疏推理，因为它将通道设置为张量的最内维，并且使得访问的计算成本更高。&lt;/p&gt;&lt;p&gt;我们对 XNNPACK 的更新使其能够检测模型是否稀疏。如果是，则从其标准密集推理模式切换到稀疏推理模式，它采用 CHW（通道、高度、宽度）张量布局。张量的这种重新排序允许加速实现稀疏的 1x1 卷积核，原因有两个：1）当在单个条件检查后相应的通道权重为零时，可以跳过张量的整个空间切片，而不是逐像素测试; 2) 当通道权重不为零时，通过将相邻像素加载到同一内存单元中可以提高计算效率。这使我们能够同时处理多个像素，同时还可以跨多个线程并行执行每个操作。当至少 80% 的权重为零时，这些变化一起导致 1.8 倍到 2.3 倍的加速。&lt;/p&gt;&lt;p&gt;为了避免在每次操作后在最适合稀疏推理的 CHW 张量布局和标准 HWC 张量布局之间来回转换，XNNPACK在 CHW 布局中提供了几个 CNN 算子的有效实现。&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;em&gt;训练稀疏神经网络的指南&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;要创建稀疏神经网络，此版本中包含的指南建议从密集版本开始，然后在训练期间逐渐将其权重的一部分设置为零。这个过程称为修剪。在许多可用的剪枝技术中，我们建议使用幅度剪枝（可在TF 模型优化工具包中获得）或最近引入的RigL方法。随着训练时间的适度增加，这两种方法都可以成功地稀疏深度学习模型而不会降低其质量。生成的稀疏模型可以以压缩格式有效存储，与密集等效模型相比，该格式将大小减少了两倍。&lt;/p&gt;&lt;p&gt;稀疏网络的质量受几个超参数的影响，包括训练时间、学习率和修剪时间表。该TF修剪API提供了如何选择这些，还有一些技巧训练这种模式一个很好的例子。我们建议运行超参数搜索以找到适合您的应用程序的最佳位置。&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;em&gt;应用&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;我们证明可以稀疏分类任务、密集分割（例如，满足背景模糊）和回归问题（MediaPipe Hands），这为用户提供了切实的好处。例如，在 Google Meet 的案例中，稀疏化将模型的推理时间降低了 30%，这为更多用户提供了访问更高质量模型的机会。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceHDAwzMibNWRLEVNtL9TgUB01cDMCNd4etOE8Kaq7iacStiaZyPdAmbUKyHnhGTFybeAAMSFfibReSzIw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;p&gt;此处描述的稀疏方法最适用于基于反向残差块的架构，例如MobileNetV2、MobileNetV3和EfficientNetLite。. 网络中的稀疏程度会影响推理速度和质量。从固定容量的密集网络开始，我们发现即使在 30% 的稀疏度下也能获得适度的性能提升。随着稀疏度的增加，模型的质量保持相对接近于密集基线，直到达到 70% 的稀疏度，超过 70% 时，准确度下降更为明显。然而，可以通过将基础网络的大小增加 20% 来补偿 70% 稀疏度时精度的降低，从而在不降低模型质量的情况下加快推理时间。运行稀疏模型不需要进一步的更改，因为 XNNPACK 可以识别并自动启用稀疏推理。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceHDAwzMibNWRLEVNtL9TgUB08MMzMSNTRMmTBlU9pYQoAwqoSiaStv0Xr9ibgkwe6yOWw1RdwU2DKM3A/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;em&gt;稀疏性作为蒸馏的自动替代方案&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Google Meet 中的背景模糊使用基于带有注意块的修改后的 MobileNetV3 主干的分割模型。通过应用 70% 的稀疏化，我们能够将模型速度提高 30%，同时保持前景蒙版的质量。我们检查了稀疏和密集模型对来自 17 个地理子区域的图像的预测，没有发现显着差异，并在相关的模型卡中发布了详细信息。&lt;/p&gt;&lt;p&gt;类似地，MediaPipe Hands使用基于 EfficientNetLite 主干的模型在移动设备和网络上实时预测手部地标。这个主干模型是手动蒸馏的来自大型密集模型，这是一个计算成本高的迭代过程。使用密集模型的稀疏版本而不是蒸馏模型，我们能够保持相同的推理速度，但没有从密集模型中提取的劳动密集型过程。与密集模型相比，稀疏模型将推理提高了两倍，实现了与蒸馏模型相同的地标质量。从某种意义上说，稀疏化可以被认为是非结构化模型蒸馏的一种自动方法，它可以在不进行大量人工操作的情况下提高模型性能。我们评估的geodiverse数据集稀疏模式并取得了模卡公开可用的。&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eG1jA7faiceHDAwzMibNWRLEVNtL9TgUB0NhSHC6dPLqgBe4WM37ajFyPuoibicHWGticMORNOIF1gEa6pzjsSkpoUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/p&gt;&lt;h2&gt;&lt;strong&gt;&lt;em&gt;未来的工作&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;我们发现稀疏化是一种简单而强大的技术，可以改善神经网络的 CPU 推理。稀疏推理允许工程师运行更大的模型而不会产生显着的性能或大小开销，并为研究提供了一个有前途的新方向。我们将继续扩展 XNNPACK，为 CHW 布局中的操作提供更广泛的支持，并正在探索如何将其与其他优化技术（如量化）相结合。我们很高兴看到您可以使用这项技术构建什么！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_weapp_entry&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/eG1jA7faiceHDAwzMibNWRLEVNtL9TgUB0rZ5nU3cPhzpicTWTicEBJulDqBmpp8iaFK61RDou7hvneCtxM4IvDLosg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7256f7e04f58895a0986f2394ba5c8e1</guid>
<title>大数据之分布式协调神器：Zookeeper 选举</title>
<link>https://toutiao.io/k/ex5k7x0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI4MjU4MzkwOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dRCmOAs1H8E7QUDiaFQv0m4w2P7f4EkiacNxALJM0S7jPa7uL2a9sibAsHC6SzKZjZvylEhm4feUjlTQ/0?wx_fmt=png&quot; data-nickname=&quot;大数据左右手&quot; data-alias=&quot;ykc20161218&quot; data-signature=&quot;大数据开发工作者。致力于大数据技术学习与工作。实时，离线，面试与总结，或者生活小矫情类文章，总有适合你的那一篇。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6933333333333334&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dS2icMOy4y8Q4XFY1rTPIlxm1qjRWKVXFRoKibdQBZeB3jRIe0ibq6dtuM3aTaoHZRHYam7QIQn4icRjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分布式系统设计成主从节点主要是为了保障数据一致性，主从设计是一种最直观的数据一致性保障机制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;span&gt;比&lt;/span&gt;&lt;span&gt;如主从复制，主节点负责写，从节点负责读，提高读的性能。从节点定期通过心跳与主节点沟通，一旦主节点挂掉了，从节点马上接手主节点的任务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;但是主节点暂时失去响应，如瞬时负载过高，网络拥塞或者其他原因导致主节点暂时失去响应，超过响应超时时间，这个时候从节点启动，承担起leader的职责，但是原先的主节点又恢复了服务。&lt;/span&gt;&lt;span&gt;这个时候，如果没有选举机制（不能仅仅自己宣告自己是leader，还要广而告之，让其他服务器或者客户端知道自己是leader），有可能会存在两个leader节点，导致集群发生混乱。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;所以有了以下关于大数据框架主从选举的总结，赶快收藏吧！总有一个不经意时刻你会用到。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1626685445103&quot; data-category_id_list=&quot;1|11|16|17|22|24|26|27|28|29|3|31|32|35|36|37|39|41|42|43|45|46|47|48|49|5|50|51|52|53|54|55|6|7|8&quot; data-id=&quot;1626685445103&quot;/&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Zookeeper选举&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Zookeeper介绍&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zookeeper从设计模式角度来理解，是一个基于观察者模式设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生了变化，Zookeeper就负责通知已经在Zookeeper上注册的那些观察者做出相应的反应。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Zookeeper特点&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;集群种只要有半数以上节点存活，Zookeeper集群就能正常提供服务。所以这就是选举机制的奇数原则（Zookeeper适合安装奇数台服务）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个领导者Leaders和多个跟随者Follower组成的集群。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Zookeeper的选举机制&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;全新集群选举&lt;span/&gt;&lt;/h6&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.31057563587684067&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dS2icMOy4y8Q4XFY1rTPIlxmHg4ytQX6WkG8P3tfDuia88RtEM6B6xiazQmKTJxRNVCOsDTB3WEAiaibUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;747&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设有五台服务器组成的Zookeeper集群，它们的id从Service1到Service5，同时它们都是最新启动的，也就是没有历史数据，在存放数据量这一点上，都是一样的。假设这些服务器依序启动，来看看会发生什么。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;服务器1启动，发起一次选举。服务器1投自己一票。此时服务器1票数一票，不够半数以上（3票），选举无法完成，服务器1状态保持为LOOKING；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务器2启动，再发起一次选举。服务器1和2分别投自己一票并交换选票信息：此时服务器1发现服务器2的ID比自己目前投票推举的（服务器1）大，更改选票为推举服务器2。此时服务器1票数0票，服务器2票数2票，没有半数以上结果，选举无法完成，服务器1，2状态保持LOOKING。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务器3启动，发起一次选举。此时服务器1和2都会更改选票为服务器3。此次投票结果：服务器1为0票，服务器2为0票，服务器3为3票。此时服务器3的票数已经超过半数，服务器3当选Leader。服务器1，2更改状态为FOLLOWING，服务器3更改状态为LEADING。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务器4启动，发起一次选举。此时服务器1，2，3已经不是LOOKING状态，不会更改选票信息。交换选票信息结果：服务器3为3票，服务器4为1票。此时服务器4服从多数，更改选票信息为服务器3，并更改状态为FOLLOWING。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务器5启动，同第4步一样当FOLLOWING。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;非全新集群选举&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于运行正常的zookeeper集群，中途有机器down掉，需要重新选举时，选举过程就需要加入数据ID、服务器ID、和逻辑时钟。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;逻辑时钟：这个值从0开始，每次选举必须一致。小的选举结果被忽略，重新投票（除去选举次数不完整的服务器）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数据id：数据新的version大，数据每次更新都会更新version。数据id大的胜出（选出数据最新的服务器）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务器id：即myid。数据id相同的情况下，服务器id大的胜出（数据相同的情况下，选择服务器id最大，即权重最大的服务器）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Kafka依赖Zookeeper的选举&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6043956043956044&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dS2icMOy4y8Q4XFY1rTPIlxmVMGE6grniaxbBWLfrBX5Oicq4F9bt0DscOeXsBtOv1YRjZ3TT54YJicpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;637&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Kafka依赖ZK做了哪些事&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZooKeeper 作为给分布式系统提供协调服务的工具被 kafka 所依赖。在分布式系统中，消费者需要知道有哪些生产者是可用的，而如果每次消费者都需要和生产者建立连接并测试是否成功连接，那效率也太低了，显然是不可取的。而通过使用 ZooKeeper 协调服务，Kafka 就能将 Producer，Consumer，Broker 等结合在一起，同时借助 ZooKeeper，Kafka 就能够将所有组件在无状态的条件下建立起生产者和消费者的订阅关系，实现负载均衡。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Kafka选举&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Leader维护了一个动态的in-sync replica set (ISR)，意为和leader保持同步的follower集合。当ISR中的follower完成数据的同步之后，leader就会给follower发送ack。如果follower长时间未向leader同步数据，则该follower将被踢出ISR，该时间阈值由replica.lag.time.max.ms参数设定。Leader发生故障之后，就会从ISR中选举新的leader。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此这个集合中的任何一个节点随时都可以被选为leader。ISR在ZooKeeper中维护。ISR中有f+1个节点（follow+leader），就可以允许在f个节点down掉的情况下不会丢失消息并正常提供服。ISR的成员是动态的，如果一个节点被淘汰了，当它重新达到“同步中”的状态时，他可以重新加入ISR。因此如果leader宕了，直接从ISR中选择一个follower就行。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4990859232175503&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dS2icMOy4y8Q4XFY1rTPIlxmOiclXoUUZaOVpbWaczLIoGVZdAAGt12nXBvBmO4YmpyXibibFEqn0FYrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;547&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果全挂呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一旦所有节点都down了，Kafka不会保证数据的不丢失。所以当副本都down掉时，必须及时作出反应。等待ISR中的任何一个节点恢复并担任leader。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;附：Kafka为什么要放弃ZK&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;本身就是一个分布式系统，但是需要另一个分布式系统来管理，复杂性无疑增加了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;部署的时候必须要部署两套系统，的运维人员必须要具备的运维能力。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Controller故障处理：依赖一个单一节点跟进行交互，如果这个节点发生了故障，就需要从中选择新的，新的选举成功后，会重新从拉取元数据进行初始化，并且需要通知其他所有的更新。老的需要关闭监听、事件处理线程和定时任务。分区数非常多时，这个过程非常耗时，而且这个过程中集群是不能工作的。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5117370892018779&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dS2icMOy4y8Q4XFY1rTPIlxm5HzejSrkicflSKQVibytSIyiccW19oyD7zzfwM2NesMcO2OjzCcdYbsLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;639&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当分区数增加时，保存的元数据变多，集群压力变大&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基于ZooKeeper的Hadoop高可用&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;HDFS 高可用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;介绍&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个典型的HA集群，NameNode会被配置在两台独立的机器上，在任何时间上，一个NameNode处于活动状态，而另一个NameNode处于备份状态，活动状态的NameNode会响应集群中所有的客户端，备份状态的NameNode只是作为一个副本，保证在必要的时候提供一个快速的转移。所以对于HDFS来说，高可用其实就是针对NameNode的高可用。因为NameNode保存着集群的元数据信息，一旦丢失整个集群将不复存在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主备切换控制器 ZKFailoverController：ZKFC 作为独立的进程运行，对 NameNode 的主备切换进行总体控制。ZKFailoverController 能及时检测到 NameNode 的健康状况，在主 NameNode 故障时借助 Zookeeper 实现自动的主备选举和切换，当然 NameNode 目前也支持不依赖于 Zookeeper 的手动主备切换。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;原理&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当HDFS的两台NN启动时，ZKFC（Zookeeper FailoverController）也会启动，ZKFC会向ZK上写一个临时序列化的节点（默认节点名是：/hadoop-ha）并取得和ZK的连接，一旦NN挂掉，那么ZKFC也会挂掉，该节点会被ZK自动删除掉，ZKFC有Watcher机制（当子节点发生变化时触动），另一个伴随着NN启动的ZKFC发现子节点变化了，是不是排在第一位，是，就通知第二台NN开始接管，向JN同步数据（下载IDS文件并和FImage合并，并生成新的FImage），将元数据都变成最新的，若是挂掉的NN重新启动，那么ZKFC还会向ZK写个节点，等现接管的NN挂掉后再接管成为Master。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是ZKFC？&lt;span/&gt;&lt;/h5&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ZKFC是一个Zookeeper的客户端，它主要用来监测和管理NameNodes的状态，每个NameNode机器上都会运行一个ZKFC程序，它的职责主要有：一是健康监控。ZKFC间歇性的ping NameNode，得到NameNode返回状态，如果NameNode失效或者不健康，那么ZKFS将会标记其为不健康；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Zookeeper会话管理。当本地NaneNode运行良好时，ZKFC将会持有一个Zookeeper session，如果本地NameNode为Active，它同时也持有一个“排他锁”znode，如果session过期，那么次lock所对应的znode也将被删除；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;选举。当集群中其中一个NameNode宕机，Zookeeper会自动将另一个激活。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;内部操作与原理&lt;span/&gt;&lt;/h5&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5134529147982063&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dS2icMOy4y8Q4XFY1rTPIlxm4b3lRcutQc7XiaQa3y8xEQbGsCLBlSHXLPZVDiaw6vibcesusibL6zrYdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;HealthMonitor 初始化完成之后会启动内部的线程来定时调用对应 NameNode 的 HAServiceProtocol RPC 接口的方法，对 NameNode 的健康状态进行检测。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HealthMonitor 如果检测到 NameNode 的健康状态发生变化，会回调 ZKFailoverController 注册的相应方法进行处理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 ZKFailoverController 判断需要进行主备切换，会首先使用 ActiveStandbyElector 来进行自动的主备选举。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ActiveStandbyElector 与 Zookeeper 进行交互完成自动的主备选举。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ActiveStandbyElector 在主备选举完成后，会回调 ZKFailoverController 的相应方法来通知当前的 NameNode 成为主 NameNode 或备 NameNode。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ZKFailoverController 调用对应 NameNode 的 HAServiceProtocol RPC 接口的方法将 NameNode 转换为 Active 状态或 Standby 状态。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;几句话描述就是：ZooKeeper提供了简单的机制来实现Acitve Node选举，如果当前Active失效，Standby将会获取一个特定的排他锁，那么获取锁的Node接下来将会成为Active。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Yarn高可用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;介绍&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;YARN ResourceManager 的高可用与 HDFS NameNode 的高可用类似但是 ResourceManager 不像 NameNode ，没有那么多的元数据信息需要维护，所以它的状态信息可以直接写到 Zookeeper 上，并依赖 Zookeeper 来进行主备选举。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6049382716049383&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dS2icMOy4y8Q4XFY1rTPIlxmoI63NTMmDGOq2Ic05aUe3hnlY9Imnhf7VkibIbgxP9rVlt2PYl94DUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;486&quot;/&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;内部操作与原理&lt;span/&gt;&lt;/h5&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在ZooKeeper上会有一个/yarn-leader-election/yarn1的锁节点，所有的ResourceManager在启动的时候，都会去竞争写一个Lock子节点：/yarn-leader-election/yarn1/ActiveBreadCrumb，该节点是临时节点。ZooKeepr能够保证最终只有一个ResourceManager能够创建成功。创建成功的那个ResourceManager就切换为Active状态，没有成功的那些ResourceManager则切换为Standby状态。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;RM会把job的信息存放在zookeeper的/rmstore目录下，active RM会向这个目录写app的信息。当active RM挂掉之后，standby RM会通过zkfc切换为active状态，然后从zookeeper的/rmstore目录下读取相应的作业信息。重新构建作业的内存信息，启动内部服务，开始接受NM的心跳信息，构建集群的资源信息，并且接受客户端的作业提交请求。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;其他与总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在大数据领域，还有许多框架依赖与Zookeeper去选择主从：比如Hbase集群，Kudu集群，Impala集群等等，最底层的原理大径相同。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选举：Zookeeper能够很容易的实现集群管理的功能，若有多台Server组成一个服务集群，则必须要一个leader知道集群中每台机器的服务状态，从而做出调整重新分配服务策略。当集群中增加一台或多台Server时，leader同样需要知道。Zookeeper不仅能够维护当前的集群中机器的服务状态，而且能够选出一个leader来管理集群。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HA(分布式锁的应用)：Master挂掉之后迅速切换到slave节点。&lt;span/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我要去大厂专题 往期回顾&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI4MjU4MzkwOQ==&amp;amp;mid=2247484713&amp;amp;idx=1&amp;amp;sn=b1c6fb7cedcfbfa6fb22d2e02e8b375c&amp;amp;chksm=eb96f323dce17a35fb5f81996199cffb0a1d6797be3feae3ccc61d051a0f9acd88fd07535276&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Flink吐血总结，学习与面试收藏这一篇就够了！！！&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI4MjU4MzkwOQ==&amp;amp;mid=2247484735&amp;amp;idx=1&amp;amp;sn=8f910ab0c7b48f1b699207eb22fbf14a&amp;amp;chksm=eb96f335dce17a23e569ec4187d2f323b8747132d62c4611665e6d028a71e26234ef5f950a6a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;你的数据倾斜了吗？一文帮你数据处理再均衡&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI4MjU4MzkwOQ==&amp;amp;mid=2247484677&amp;amp;idx=1&amp;amp;sn=00ce05f7cb76cad7af960e47172154f4&amp;amp;chksm=eb96f30fdce17a191919b43e99893d15e3f04017681d64aa09e6c7a6d8108ccd2e051fafff7e&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Kafka面试准备，收藏这一篇就够了！！！&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI4MjU4MzkwOQ==&amp;amp;mid=2247484635&amp;amp;idx=1&amp;amp;sn=17436dd8178800fe0d2e2e2cb1768a7a&amp;amp;chksm=eb96f2d1dce17bc7279c457551a682382b9d10f3bbafac5ee66a72d1d5e505b2338fc6f9e8bb&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;查询引擎怎么选？7000字解析所有开源引擎的秘密&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI4MjU4MzkwOQ==&amp;amp;mid=2247484632&amp;amp;idx=1&amp;amp;sn=c99cb782ed0a2f3c82d6f92478a55aa5&amp;amp;chksm=eb96f2d2dce17bc464e9d1c2a84b95f024aec2f97e7f1da05848c57923d320e95640b5a08e7e&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;大数据调度系统选得好,下班回家早;调度用得对,半夜安心睡&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzI4MjU4MzkwOQ==&amp;amp;mid=2247484600&amp;amp;idx=1&amp;amp;sn=53420bb2919e200e95fd320e37b7b487&amp;amp;chksm=eb96f2b2dce17ba48b6857af63ba70a91a12f8b12d5a106a58c32b58367449b6f67de601ab9f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;六千字总结:大数据框架(分区，分桶，分片),建议收藏&lt;/a&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI4MjU4MzkwOQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dRCmOAs1H8E7QUDiaFQv0m4w2P7f4EkiacNxALJM0S7jPa7uL2a9sibAsHC6SzKZjZvylEhm4feUjlTQ/0?wx_fmt=png&quot; data-nickname=&quot;大数据左右手&quot; data-alias=&quot;ykc20161218&quot; data-signature=&quot;大数据开发工作者。致力于大数据技术学习与工作。实时，离线，面试与总结，或者生活小矫情类文章，总有适合你的那一篇。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同&lt;/span&gt;&lt;span&gt;学&lt;/span&gt;&lt;span&gt;共进，点赞，转发，在看，关注，是我学习之动力。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;和我联系吧，交流大数据知识,一起成长~~~&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>39ebdde5518ad72fc709061d6b7d35c1</guid>
<title>Go 语言如何操纵 Kafka 保证无消息丢失</title>
<link>https://toutiao.io/k/r6p3osc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前一些互联网公司会使用消息队列来做核心业务，因为是核心业务，所以对数据的最后一致性比较敏感，如果中间出现数据丢失，就会引来用户的投诉，年底绩效就变成325了。之前和几个朋友聊天，他们的公司都在用&lt;code&gt;kafka&lt;/code&gt;来做消息队列，使用&lt;code&gt;kafka&lt;/code&gt;到底会不会丢消息呢？如果丢消息了该怎么做好补偿措施呢？本文我们就一起来分析一下，并介绍如何使用&lt;code&gt;Go&lt;/code&gt;操作&lt;code&gt;Kafka&lt;/code&gt;可以不丢失数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文操作&lt;code&gt;kafka&lt;/code&gt;基于：https://github.com/Shopify/sarama&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;初识&lt;code&gt;kafka&lt;/code&gt;架构&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;维基百科对&lt;code&gt;kafka&lt;/code&gt;的介绍：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Kafka是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。该项目的目标是为处理实时数据提供一个统一、高吞吐、低延迟的平台。其持久化层本质上是一个“按照分布式事务日志架构的大规模发布/订阅消息队列”，这使它作为企业级基础设施来处理流式数据非常有价值。此外，Kafka可以通过Kafka Connect连接到外部系统（用于数据输入/输出），并提供了Kafka Streams——一个Java]流式处理库。该设计受事务日志的影响较大。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;kafka&lt;/strong&gt;的整体架构比较简单，主要由&lt;code&gt;producer&lt;/code&gt;、&lt;code&gt;broker&lt;/code&gt;、&lt;code&gt;consumer&lt;/code&gt;组成：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5933660933660934&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CqB2u93NwBibbdIf4ZdWxvCVNB3uXmJAu2cdp1eibNCW4k8CsU7ZbCSr1ScHHdNqv6o3VOrUqfdT9HdEjJ1YibYrA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1628&quot;/&gt;&lt;figcaption&gt;截屏2021-09-12 上午10.00.13&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对架构图我们解释一个各个模块：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Producer&lt;/strong&gt;：数据的生产者，可以将数据发布到所选择的&lt;code&gt;topic&lt;/code&gt;中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Consumer&lt;/strong&gt;：数据的消费者，使用&lt;strong&gt;Consumer Group&lt;/strong&gt;进行标识，在&lt;code&gt;topic&lt;/code&gt;中的每条记录都会被分配给订阅消费组中的一个消费者实例，消费者实例可以分布在多个进程中或者多个机器上。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Broker&lt;/strong&gt;：消息中间件处理节点（服务器），一个节点就是一个broker，一个Kafka集群由一个或多个broker组成。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有些概念我们也介绍一下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;topic&lt;/strong&gt;：可以理解为一个消息的集合，topic存储在broker中，一个topic可以有多个partition分区，一个topic可以有多个Producer来push消息，一个topic可以有多个消费者向其pull消息，一个topic可以存在一个或多个broker中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;partition&lt;/strong&gt;：其是topic的子集，不同分区分配在不同的broker上进行水平扩展从而增加kafka并行处理能力，同topic下的不同分区信息是不同的，同一分区信息是有序的；每一个分区都有一个或者多个副本，其中会选举一个&lt;code&gt;leader&lt;/code&gt;，&lt;code&gt;fowller&lt;/code&gt;从&lt;code&gt;leader&lt;/code&gt;拉取数据更新自己的log（每个分区逻辑上对应一个log文件夹），消费者向leader中pull信息。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;kafka丢消息的三个节点&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;生产者push消息节点&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看一下producer的大概写入流程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;producer先从kafka集群找到该partition的leader&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;producer将消息发送给leader，leader将该消息写入本地&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;follwers从leader pull消息，写入本地log后leader发送ack&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;leader 收到所有 ISR 中的 replica 的 ACK 后，增加high watermark，并向 producer 发送 ack&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4105145413870246&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CqB2u93NwBibbdIf4ZdWxvCVNB3uXmJAuY0m6FpHNhmf87NAAA1K0ZPoDZBZdEKicI0el8Fg2icowdxhtibMuwcNKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1788&quot;/&gt;&lt;figcaption&gt;截屏2021-09-12 上午11.16.43&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这个流程我们可以看到kafka最终会返回一个ack来确认推送消息结果，这里kafka提供了三种模式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;NoResponse RequiredAcks = &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;WaitForLocal RequiredAcks = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;WaitForAll RequiredAcks = &lt;span&gt;-1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;NoResponse RequiredAcks = 0&lt;/code&gt;：这个代表的就是数据推出的成功与否都与我无关了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;WaitForLocal RequiredAcks = 1&lt;/code&gt;：当local(leader)确认接收成功后，就可以返回了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;WaitForAll RequiredAcks = -1&lt;/code&gt;：当所有的leader和follower都接收成功时，才会返回&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以根据这三种模式我们就能推断出生产者在push消息时有一定几率丢失的，分析如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果我们选择了模式&lt;code&gt;1&lt;/code&gt;，这种模式丢失数据的几率很大，无法重试&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果我们选择了模式&lt;code&gt;2&lt;/code&gt;，这种模式下只要leader不挂，就可以保证数据不丢失，但是如果leader挂了，follower还没有同步数据，那么就会有一定几率造成数据丢失&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果选择了模式&lt;code&gt;3&lt;/code&gt;，这种情况不会造成数据丢失，但是有可能会造成数据重复，假如leader与follower同步数据是网络出现问题，就有可能造成数据重复的问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在生产环境中我们可以选择模式2或者模式3来保证消息的可靠性，具体需要根据业务场景来进行选择，在乎吞吐量就选择模式2，不在乎吞吐量，就选择模式3，要想完全保证数据不丢失就选择模式3是最可靠的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;kafka集群自身故障造成&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;kafka集群接收到数据后会将数据进行持久化存储，最终数据会被写入到磁盘中，在写入磁盘这一步也是有可能会造成数据损失的，因为写入磁盘的时候操作系统会先将数据写入缓存，操作系统将缓存中数据写入磁盘的时间是不确定的，所以在这种情况下，如果&lt;code&gt;kafka&lt;/code&gt;机器突然宕机了，也会造成数据损失，不过这种概率发生很小，一般公司内部kafka机器都会做备份，这种情况很极端，可以忽略不计。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消费者pull消息节点&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;push消息时会把数据追加到Partition并且分配一个偏移量，这个偏移量代表当前消费者消费到的位置，通过这个Partition也可以保证消息的顺序性，消费者在pull到某个消息后，可以设置自动提交或者手动提交commit，提交commit成功，offset就会发生偏移:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4832116788321168&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CqB2u93NwBibbdIf4ZdWxvCVNB3uXmJAulZ6JGrddsiadickdPHOYYmNeKC1uu4ft33biclibC9jIibMRUrLvYz5rZeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1370&quot;/&gt;&lt;figcaption&gt;截屏2021-09-12 下午3.37.33&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以自动提交会带来数据丢失的问题，手动提交会带来数据重复的问题，分析如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在设置自动提交的时候，当我们拉取到一个消息后，此时offset已经提交了，但是我们在处理消费逻辑的时候失败了，这就会导致数据丢失了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在设置手动提交时，如果我们是在处理完消息后提交commit，那么在commit这一步发生了失败，就会导致重复消费的问题。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比起数据丢失，重复消费是符合业务预期的，我们可以通过一些幂等性设计来规避这个问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实战&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整代码已经上传github：https://github.com/asong2020/Golang_Dream/tree/master/code_demo/kafka_demo&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;解决push消息丢失问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要是通过两点来解决：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过设置&lt;code&gt;RequiredAcks&lt;/code&gt;模式来解决，选用&lt;code&gt;WaitForAll&lt;/code&gt;可以保证数据推送成功，不过会影响时延时&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;引入重试机制，设置重试次数和重试间隔&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此我们写出如下代码（摘出创建client部分）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewAsyncProducer&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;sarama&lt;/span&gt;.&lt;span&gt;AsyncProducer&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; cfg := sarama.NewConfig()&lt;br/&gt; version, err := sarama.ParseKafkaVersion(VERSION)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt;{&lt;br/&gt;  log.Fatal(&lt;span&gt;&quot;NewAsyncProducer Parse kafka version failed&quot;&lt;/span&gt;, err.Error())&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; cfg.Version = version&lt;br/&gt; cfg.Producer.RequiredAcks = sarama.WaitForAll &lt;span&gt;// 三种模式任君选择&lt;/span&gt;&lt;br/&gt; cfg.Producer.Partitioner = sarama.NewHashPartitioner&lt;br/&gt; cfg.Producer.Return.Successes = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; cfg.Producer.Return.Errors = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; cfg.Producer.Retry.Max = &lt;span&gt;3&lt;/span&gt; &lt;span&gt;// 设置重试3次&lt;/span&gt;&lt;br/&gt; cfg.Producer.Retry.Backoff = &lt;span&gt;100&lt;/span&gt; * time.Millisecond&lt;br/&gt; cli, err := sarama.NewAsyncProducer([]&lt;span&gt;string&lt;/span&gt;{ADDR}, cfg)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt;{&lt;br/&gt;  log.Fatal(&lt;span&gt;&quot;NewAsyncProducer failed&quot;&lt;/span&gt;, err.Error())&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; cli&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;解决pull消息丢失问题&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个解决办法就比较粗暴了，直接使用自动提交的模式，在每次真正消费完之后在自己手动提交offset，但是会产生重复消费的问题，不过很好解决，使用幂等性操作即可解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码示例：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewConsumerGroup&lt;/span&gt;&lt;span&gt;(group &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;sarama&lt;/span&gt;.&lt;span&gt;ConsumerGroup&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; cfg := sarama.NewConfig()&lt;br/&gt; version, err := sarama.ParseKafkaVersion(VERSION)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt;{&lt;br/&gt;  log.Fatal(&lt;span&gt;&quot;NewConsumerGroup Parse kafka version failed&quot;&lt;/span&gt;, err.Error())&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; cfg.Version = version&lt;br/&gt; cfg.Consumer.Group.Rebalance.Strategy = sarama.BalanceStrategyRange&lt;br/&gt; cfg.Consumer.Offsets.Initial = sarama.OffsetOldest&lt;br/&gt; cfg.Consumer.Offsets.Retry.Max = &lt;span&gt;3&lt;/span&gt;&lt;br/&gt; cfg.Consumer.Offsets.AutoCommit.Enable = &lt;span&gt;true&lt;/span&gt; &lt;span&gt;// 开启自动提交，需要手动调用MarkMessage才有效&lt;/span&gt;&lt;br/&gt; cfg.Consumer.Offsets.AutoCommit.Interval = &lt;span&gt;1&lt;/span&gt; * time.Second &lt;span&gt;// 间隔&lt;/span&gt;&lt;br/&gt; client, err := sarama.NewConsumerGroup([]&lt;span&gt;string&lt;/span&gt;{ADDR}, group, cfg)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  log.Fatal(&lt;span&gt;&quot;NewConsumerGroup failed&quot;&lt;/span&gt;, err.Error())&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; client&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面主要是创建ConsumerGroup部分，细心的读者应该看到了，我们这里使用的是自动提交，说好的使用手动提交呢？这是因为我们这个kafka库的特性不同，这个自动提交需要与MarkMessage()方法配合使用才会提交(有疑问的朋友可以实践一下，或者看一下源码)，否则也会提交失败，因为我们在写消费逻辑时要这样写：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(e EventHandler)&lt;/span&gt; &lt;span&gt;ConsumeClaim&lt;/span&gt;&lt;span&gt;(session sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim)&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; msg := &lt;span&gt;range&lt;/span&gt; claim.Messages() {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; data common.KafkaMsg&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err := json.Unmarshal(msg.Value, &amp;amp;data); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; errors.New(&lt;span&gt;&quot;failed to unmarshal message err is &quot;&lt;/span&gt; + err.Error())&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 操作数据，改用打印&lt;/span&gt;&lt;br/&gt;  log.Print(&lt;span&gt;&quot;consumerClaim data is &quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 处理消息成功后标记为处理, 然后会自动提交&lt;/span&gt;&lt;br/&gt;  session.MarkMessage(msg,&lt;span&gt;&quot;&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者直接使用手动提交方法来解决，只需两步：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一步：关闭自动提交：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;consumerConfig.Consumer.Offsets.AutoCommit.Enable = &lt;span&gt;false&lt;/span&gt;  &lt;span&gt;// 禁用自动提交，改为手动&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步：消费逻辑中添加如下代码，手动提交模式下，也需要先进行标记，在进行commit&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;session.MarkMessage(msg,&lt;span&gt;&quot;&quot;&lt;/span&gt;)&lt;br/&gt;session.Commit()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;完整代码可以到github上下载并进行验证！&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文我们主要说明了两个知识点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Kafka会产生消息丢失&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用Go操作Kafka如何配置可以不丢失数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日常业务开发中，很多公司都喜欢拿消息队列进行解耦，那么你就要注意了，使用Kafka做消息队列无法保证数据不丢失，需要我们自己手动配置补偿，别忘记了，要不又是一场P0事故。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;素质三连（分享、点赞、在看）都是笔者持续创作更多优质内容的动力！我是&lt;code&gt;asong&lt;/code&gt;，我们下期见。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;创建了一个Golang学习交流群，欢迎各位大佬们踊跃入群，我们一起学习交流。入群方式：关注公众号获取。更多学习资料请到公众号领取。&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkyNzI1NzM5NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/CqB2u93NwB96zTfSmymj9jWokyhvSIXMRcLRAfFJsrB4uz6HBsml4T6iaia3yyCSB4aicX97icT7xBUCgw4O1PsKFQ/0?wx_fmt=png&quot; data-nickname=&quot;Golang梦工厂&quot; data-alias=&quot;AsongDream&quot; data-signature=&quot;asong是一名后端程序员，目前就职于一家电商公司，专注于Golang技术，定期分享Go语言、MySQL、Redis、Elasticsearch、计算机基础、微服务架构设计、面试等知识。这里不仅有技术，还有故事！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7db468028e578e47ddb18083899eb37f</guid>
<title>写给互联网工程师的 5G 书（一）： 简介</title>
<link>https://toutiao.io/k/w9197y4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote&gt;&lt;p&gt;&lt;em&gt;早就想写一个系列，给互联网行业的朋友介绍一下移动通信网络，特别是5G移动通信系统，但一直没想好怎么写。最近看到ONF发布的开源书《5G Mobile Networks：A Systems Approach》，其目标读者正是互联网从业者，因此打算将全书翻译为中文，希望能让有兴趣的朋友们能够了解移动通信网络的一些基本概念、网络架构和演进方向。原文：5G Mobile Networks: A Systems Approach&lt;span&gt;[1]&lt;/span&gt;。中文版Github仓库：https://github.com/yuff100/5GSystemApproachCHN。&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;前言&lt;/h1&gt;&lt;p&gt;全球通信基础设施向5G的演进正在进行中，除非你一直试图主动忽略它，否则你肯定会听到很多这方面的声音。但是，如果你和世界上99%受过计算机科学训练、以系统为导向、精通云计算的人一样，那么对你来说，移动蜂窝网络在很大程度上还是个谜。你知道这是一项重要的技术，用于将人们连接到互联网，但实际上它已经在你的关注范围之外了。也许你还听说过一两个关于5G将如何导致一些可怕的副作用的阴谋论——这表明围绕5G的炒作可能没有取得预期的效果。&lt;/p&gt;&lt;p&gt;关于5G，需要了解的重要一点是，它不仅仅意味着更大的带宽（尽管这点也很重要）。更重要的是它关系到接入网的变革，这使得它更像现代的云。另外，一些重要的技术趋势，如软件定义网络（SDN，Software-Defined Networking）和开源软件，将导致接入网更加灵活和具有创新能力。5G将催生新的应用，尤其是大量物联网（IoT，Internet of Things ）应用。事实上，我们甚至可以看到“作为互联网前端的接入”的观点正在发生转变，因为接入网络本身就变成了云的集合，可以直接从“边缘云”提供新的服务。&lt;/p&gt;&lt;p&gt;本书的目标读者是那些对互联网和云计算有实际了解，但对蜂窝网络的无数专有名词了解不多的人。坦率的说，互联网有它的专有名词，但也提供了足够多的抽象集来帮助管理复杂性。对于蜂窝网络来说，情况就不一样了，没办法通过一条线索了解所有细节。还有一个原因，移动网络很大程度上被隐藏在专有设备中，这使得你不太可能自己把问题搞清楚。&lt;/p&gt;&lt;p&gt;本书是一位和我们在开源5G项目上合作的移动网络专家培训系统工程师的成果。该材料也被用于培训其他软件开发人员，我们希望它可以帮助任何想要更深入的了解5G及其提供的创新机会的人。想要亲手做一些实验的读者也可以访问书中介绍的开源软件。&lt;/p&gt;&lt;p&gt;在可预见的未来，这本书很可能还会不断的补充修订。它的目的并不是对每一个细节都采用百科全书式的视角和提供端到端完整性，但我们确实计划随着时间的推移充实内容。欢迎您对此提出建议（和贡献）。&lt;/p&gt;&lt;h1&gt;致谢&lt;/h1&gt;&lt;p&gt;本书中介绍的软件是ONF工程团队和开源社区辛勤工作的结果，感谢他们做出的贡献。感谢布鲁斯·戴维（Bruce Davie）、古鲁·帕鲁卡（Guru Parulkar）、金昌勋（Changhoon Kim）对本书早期手稿提供的反馈。&lt;/p&gt;&lt;p&gt;Larry Peterson 和 Oguz Sunay&lt;br/&gt;开放网络基金会&lt;br/&gt;2020年3月&lt;/p&gt;&lt;h1&gt;1. 简介&lt;/h1&gt;&lt;p&gt;与互联网类似，拥有40年历史的移动通信网络正在发生重大变化。前两代（1G和2G）支持语音和文本，3G过渡到宽带接入，支持每秒数百千比特的数据速率。如今，该行业正处于4G（支持的数据速率通常以每秒几兆计）阶段，并正在向5G过渡，数据速率有望进一步增长数十倍。&lt;/p&gt;&lt;p&gt;但5G不仅仅意味着更大的带宽。5G融合了几个关键技术趋势，使其走上支持实现更多创新的道路，代表了无线接入网的根本性重构。就像3G定义了从语音到宽带的过渡一样，5G的承诺主要是从单一接入服务（宽带连接）过渡到更丰富的边缘服务和设备。5G预计将为沉浸式用户体验（如AR/VR）、关键任务应用（如公共安全、自动驾驶）和物联网（IoT）提供支持。这些用例将包括从家用电器到工业机器人再到自动驾驶汽车等所有设备，因此5G将不仅支持人类通过智能手机访问互联网，还将支持大量自动设备并帮助它们一起工作。支持这些服务不仅仅是为单个用户提高带宽或减少延时。正如我们即将看到的，我们需要一个完全不同的边缘网络体系架构。&lt;/p&gt;&lt;p&gt;这个体系架构雄心勃勃，可以用三类功能来说明：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;支持&lt;em&gt;大规模物联网（Massive Internet-of-Things）&lt;/em&gt;，包括超低能耗（10年以上电池寿命）、超低复杂性（每秒10比特）和超高密度（每平方公里100万个节点）的设备。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;支持&lt;em&gt;关键任务控制（Mission-Critical Control）&lt;/em&gt;，包括超高可用性（大于99.999%或“5个9”)、超低延迟（低至1毫秒）和极端移动性（高达100公里/小时）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;支持&lt;em&gt;增强型移动宽带（Enhanced Mobile Broadband）&lt;/em&gt;，峰值数据速率超过1 Gbps，平均速率达到100Mbps以上，每平方公里总吞吐量达到10 Tbps。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;每一代移动通信网络都需要数十年的努力，因此这些目标不可能在一夜之间就实现。&lt;/p&gt;&lt;p&gt;除了这些接入网能力的量化改进之外，5G被视为一个构建支持创新平台的机会。以前的接入网通常是针对已知的服务（如语音呼叫和短信）进行优化的，而互联网之所以获得巨大成功，很大程度上是因为它支持了广泛的应用程序，而这些应用程序在最初设计时甚至都没有被想到过。5G网络的设计在很大程度上也是为了实现超越我们今天所认知的应用之外的各种未来应用。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;延伸阅读&lt;/span&gt;&lt;/p&gt;&lt;p&gt;要了解行业领袖对5G的宏伟愿景，请参阅高通在2016年12月发布的白皮书《让5G NR成为现实（Making 5G NR a Reality）》&lt;span&gt;[2]&lt;/span&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;5G正处于发展过程中，这不是一个单点解决方案，而是包括了标准规范、一系列实现选择和一长串雄心勃勃的目标，因此留下了很大的解释空间。我们在本书中将基于两个相互支持的原则来介绍5G。第一种是&lt;em&gt;应用系统视角&lt;/em&gt;，也就是说，我们会介绍当前解决方案的一系列设计决策，而不只是把大量首字母缩写的术语或者单个技术作为&lt;em&gt;既成事实&lt;/em&gt;。第二是解构这个体系。构建一个解耦的、虚拟化的、软件定义的5G接入网是该行业正在努力的一个发展方向（出于良好的技术和商业原因），但将5G网络分解成基本组件也是解释5G如何工作的最好方式。这也有助于说明5G在未来可能如何发展，以提供更多价值。&lt;/p&gt;&lt;p&gt;5G没有单一、全面的定义，就像互联网没有单一、全面的定义一样。它是一个复杂的、不断发展的系统，由一组标准所限定，而这些标准会给予所有相关方不同程度的自由。在接下来的章节中，可以清楚的看到我们是在讨论&lt;em&gt;标准&lt;/em&gt;（每个人都必须做什么才能进行互操作）、&lt;em&gt;趋势&lt;/em&gt;（行业有可能走向何方）还是&lt;em&gt;实现选择&lt;/em&gt;（具体的示例）。我们的目的是介绍5G，通过全面采用系统视角，帮助读者浏览这个丰富而快速发展的系统。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;演进路径&lt;/span&gt;&lt;/p&gt;&lt;p&gt;5G正处于发展过程中，这是本书的中心主题。我们在此提请注意它的重要性，并将本书中再次讨论这个话题。&lt;/p&gt;&lt;p&gt;我们为那些了解多方面系统知识的人写这本书，目的是帮助社区快速理解这个系统（他们对蜂窝网络所知甚少），以便他们能够在5G发展过程中发挥作用。这是一个了解如何快速迭代以及构建健壮可扩展系统的最佳实践的社区，因此可以在实现5G的所有潜力方面发挥重要作用。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;1.1. 标准全景图（Standardization Landscape）&lt;/h2&gt;&lt;p&gt;从3G开始，每一代移动通信都由&lt;em&gt;3GPP（3rd Generation Partnership Project，第三代合作伙伴项目）&lt;/em&gt;负责制定标准。尽管名称中有“3G”，但3GPP继续定义了4G和5G的标准，每一代标准都对应着该标准的一系列发布版本。第15版被认为是4G和5G之间的分界点，第17版定于2021年发布。4G处于一个被称为&lt;em&gt;LTE（Long Term Evolution，长期演进）&lt;/em&gt;的多版本演进路径，这让相关术语更复杂了。5G也在类似的发展道路上，在其生命周期内预计会有几个版本发布。&lt;/p&gt;&lt;p&gt;理解4G是理解5G的第一步，5G在若干方面提升到了新高度，是超越4G的一个雄心勃勃的技术进步。在接下来的章节中，为了给介绍5G相应组件奠定基础，我们会介绍一些4G的架构特性。&lt;/p&gt;&lt;p&gt;和Wi-Fi一样，蜂窝网络在无线频谱中以特定的带宽传输数据。Wi-Fi允许任何人使用2.4 GHz或5 GHz（这些都是不需要授权的频段）频谱，而移动通信频谱则不一样，政府通过拍卖将各频段的独家使用权卖给移动运营商，后者反过来向用户出售移动接入服务。&lt;/p&gt;&lt;p&gt;此外，还有一个3.5 GHz的共享许可频段，称为&lt;em&gt;CBRS（Citizens Broadband Radio Service，公民宽带无线电服务）&lt;/em&gt;，这一频段在北美地区专门用于蜂窝网络。其他国家也会预留类似作用的频谱。CBRS允许三类用户共享频谱资源：第一使用权归该频谱的原始所有者（海军雷达和卫星地面站）；其次是优先用户，他们通过区域拍卖获得超过10MHz频段的三年使用权；最后，其他授权用户只需要先去中央数据库查一下注册用户信息，就可以接入和使用部分可用频段。CBRS及其标准化工作将蜂窝网络扩展到非授权频段，为类似Wi-Fi的私人蜂窝网络打开了大门。&lt;/p&gt;&lt;p&gt;蜂窝网络的特定频段在世界各地都有所不同，而且由于运营商经常同时支持旧的遗留技术和新的下一代技术，每种技术占用不同的频段，让事情变得更加复杂。简单来说，传统的蜂窝网络频谱范围在700-2400 MHz，新的中频谱分配在6 GHz，毫米波（mmWave）为24 GHz。&lt;/p&gt;&lt;p&gt;虽然具体频段与从架构角度理解5G没有直接关系，但它确实会影响物理层组件，进而对整个5G系统产生间接影响。我们将在后面的章节中确定并解释这些内容。确保分配的频谱得到有效利用也是一个关键的设计指标。&lt;/p&gt;&lt;h2&gt;1.2. 接入网（Access Networks）&lt;/h2&gt;&lt;p&gt;蜂窝网络是实现互联网所谓最后一英里的接入网的一部分。其他接入技术包括&lt;em&gt;PON（Passive Optical Networks，无源光网络）&lt;/em&gt;，俗称光纤入户。这些接入网由大大小小的网络运营商提供。像AT&amp;amp;T（美国电话电报公司）这样的全球网络运营商在像美国这样的国家的数千个汇聚点上运行接入网络，并通过全国主干网络将这些站点连接起来。小规模的区域和城市网络运营商可能会运行一个有一两个汇聚点的接入网，然后通过一些大型运营商的主干网访问互联网。&lt;/p&gt;&lt;p&gt;不管是哪种情况，接入网都在物理上部署在接近终端用户的数千个汇聚点上，每个汇聚点根据人口密度的不同服务于1000 - 100,000个用户。实际上，这些“边缘”位置的物理部署因运营商而异，但一种可能的方案是将蜂窝网和有线接入网络都部署在TCO（Telco Central Offices，电信核心机房）。&lt;/p&gt;&lt;p&gt;历史上，核心机房的正式名称为&lt;em&gt;PSTN（Public Switched Telephone Network，公共交换电话网）&lt;/em&gt;核心机房，是部署有线接入（包括电话和宽带）的，而蜂窝网络则通过部署一套平行的&lt;em&gt;MTSO（Mobile Telephone Switching Offices，移动电话交换机房）&lt;/em&gt;而独立发展。每个MTSO作为给定地理区域内的一组蜂窝基站的移动聚合点。对于我们而言，重要的是要知道有这样的聚合点存在，并且可以合理地认为它们定义了运营商管理的接入网的边缘。为了简单起见，我们有时使用术语“核心机房（Central Office）”作为这两种边缘站点的同义词。&lt;/p&gt;&lt;h2&gt;1.3. 边缘云（Edge Cloud）&lt;/h2&gt;&lt;p&gt;由于核心机房分布广泛，距离终端用户很近，因此也是承载边缘云的理想场所。但这又提出了一个问题：究竟什么是边缘云？&lt;/p&gt;&lt;p&gt;简而言之，云最初是一组仓库大小的数据中心组成，每个数据中心都提供了一种经济有效的方式给一组数量可伸缩的服务器提供能源、降温和运维的能力。随着时间的推移，这种共享基础设施降低了部署可伸缩互联网服务的门槛。不过现在有越来越多的应用程序需要低延迟和高带宽的云服务，但集中式数据中心无法有效实现这一需求。AR（Augmented Reality，增强现实）、VR（Virtual Reality，虚拟现实）、IoT（Internet-of-Things，物联网）和自动驾驶汽车都是这类应用的例子。这导致了一种趋势，一些功能将从数据中心转移到更接近最终用户的网络边缘。这个优势物理位置在哪里取决于你问的是谁。如果你问一个已经拥有并运营数千个核心机房的网络运营商，他们的核心机房就是一个显而易见的答案。而有些人可能会说是星巴克，其优势在于遍布全美的14000家星巴克咖啡店，还有人可能会指出遍布全球的数万个手机信号塔。&lt;/p&gt;&lt;p&gt;我们的解决方案本身是位置无关的，但值得指出的是，在云迁移到边缘的同时，还有另一个趋势，那就是网络运营商使用和云服务商一样的通用硬件以及构建可伸缩软件的最佳实践重构接入网络。这种设计有时被称为&lt;em&gt;CORD（Central Office Re-architected as a Datacenter，核心机房重构为数据中心）&lt;/em&gt;，它同时支持位于共享云平台上的接入网和边缘服务。该平台随后可以被复制到数百或数千个站点（包括但不限于核心机房）。因此，虽然我们不应该局限于把核心机房作为边缘云的唯一选项，但它正在成为一个可行的选择。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;延伸阅读&lt;/span&gt;&lt;/p&gt;&lt;p&gt;CORD最初应用于基于光纤的接入网络（PON），要了解其技术起源，请参见《IEEE Communications》2016年10月版《将核心机房重新架构为数据中心（ Central Office Re-architected as a Datacenter）》&lt;span&gt;[3]&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;要理解CORD（以及其他受CORD启发的技术）的商业案例，请参阅A.D. Little在2019年9月发表的报告《谁敢赢! 接入转型如何快速推动运营商生产平台的发展（ Who Dares Wins! How Access Transformation Can Fast-Track Evolution of Operator Production Platforms）》&lt;span&gt;[4]&lt;/span&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;我们将以CORD为例，介绍5G如何在实践中实现的细节。目前，需要了解的重要事情是，5G是作为运行在通用硬件上的软件实现的，而不是运行在过去几代所使用的专有硬件上。这对我们如何看待5G（以及如何描述5G）有重大影响，5G将日益成为云中的另一种基于软件的组件，而不是环绕在云外围的独立和专门的技术。&lt;/p&gt;&lt;p&gt;请记住，我们使用CORD作为示例并不意味着边缘云仅限于核心机房。因为CORD被设计为在一个公共平台上承载边缘服务和5G等接入技术，而电信核心机房是部署此类平台的一个可能地点，因此这是一个很好的例子。&lt;/p&gt;&lt;p&gt;从这次讨论中得到的一个重要结论是，了解云是如何构建的对于理解5G是如何实现的很有帮助。这包括使用&lt;em&gt;通用硬件&lt;/em&gt;（包括服务器和白盒交换机）、水平可伸缩的&lt;em&gt;微服务&lt;/em&gt;（也称为&lt;em&gt;云原生&lt;/em&gt;）和&lt;em&gt;SDN（Software-Defined Networks，软件定义网络）&lt;/em&gt;。了解云软件是如何开发、测试、部署和运维的，包括&lt;em&gt;DevOps&lt;/em&gt;和&lt;em&gt;CI/CD（Continuous Integration / Continuous Deployment，持续集成/持续部署）&lt;/em&gt;等实践，也很有帮助。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;延伸阅读&lt;/span&gt;&lt;/p&gt;&lt;p&gt;如果你不熟悉SDN，我们推荐一本配套的书：《软件定义网络：一种系统方法（Software-Defined Networks：A System Approach）》&lt;span&gt;[5]&lt;/span&gt;。&lt;/p&gt;&lt;p&gt;如果您不熟悉devops，或者不熟悉云服务商面临的运营问题，我们推荐《站点可靠性工程：谷歌如何运行生产系统（Site Reliability Engineering：How Google Runs Production Systems）》&lt;span&gt;[6]&lt;/span&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;关于术语的最后一个注意事项。任何关注5G讨论的人肯定都听说过&lt;em&gt;NFV（Network Function Virtualization，网络功能虚拟化）&lt;/em&gt;，它主要关注将曾经运行在专有硬件设备上的功能移植到通用服务器上的虚拟机（或者容器）中。根据我们的经验，NFV是我们在本书中描述的完全解耦和云原生解决方案的基础，因此我们不打算详细讨论它。您可以认为NFV计划与本书所采用的方法基本一致，但一些具体的工程选择可能与这里描述的细节有所不同。&lt;/p&gt;&lt;p&gt;虽然将NFV等同于5G的实现选择完全没有问题，但还可以从另一个角度看待NFV，而这个角度更好的反映了当前正在进行的架构迁移的本质。当电信公司开始NFV计划时，他们设想将云技术整合到他们的网络中，创建一个所谓的&lt;em&gt;电信云（Telco Cloud）&lt;/em&gt;。然而实际情况是电信公司的接入技术被纳入云计算，作为另一种云托管工作负载运行，更准确的说法是&lt;em&gt;基于云计算的电信系统（Cloud-based Telco）&lt;/em&gt;。阅读本书将帮助你看清所有这一切。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;Reference:&lt;/span&gt;&lt;br/&gt;[1] https://5g.systemsapproach.org/index.html&lt;br/&gt;[2] https://www.qualcomm.com/media/documents/files/whitepaper-making-5g-nr-a-reality.pdf&lt;br/&gt;[3] https://wiki.opencord.org/download/attachments/1278027/PETERSON_CORD.pdf&lt;br/&gt;[4] https://www.adlittle.com/en/who-dares-wins&lt;br/&gt;[5] https://sdn.systemsapproach.org/&lt;br/&gt;[6] https://landing.google.com/sre/books&lt;span/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;article&gt;&lt;blockquote&gt;&lt;p&gt;你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术总监，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。&lt;br/&gt;微信公众号：DeepNoMind&lt;/p&gt;&lt;/blockquote&gt;&lt;/article&gt;&lt;p&gt;&lt;span aria-label=&quot;ic-others&quot;&gt;&lt;svg fill=&quot;currentColor&quot; aria-hidden=&quot;true&quot; focusable=&quot;false&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>