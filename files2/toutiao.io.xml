<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>42db61d130a472bc9e9997bf6256a91e</guid>
<title>[推荐] 技术方案设计的方法</title>
<link>https://toutiao.io/k/jc76sul</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;前段时间接手了一个还处于方案设计阶段的工作，我重新做了设计。觉得新方案比旧方案业务清晰明朗、解决了旧方案的缺陷。我就很高兴，跟同事聊这个事情。同事就问我是怎么想到这些的呢。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我说了一些细节的，但是没有把核心本质讲出来。我觉得这是个很难回答的问题。因为一个方案怎么更合适，主要因素包含业务理解、个人经验、思维逻辑。这3个要素一般都是靠经年累月的积累才获得的。从这些中提取出别人可以学习和使用的方法确实不是一会儿就能想出来的事情。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;市面上可以看到的关于技术方案设计的经典的书都没有仔细的去讲这个问题。比如《人月神话》讲的是项目大了怎么办、《架构即未来》讲的是架构扩展性的问题。那对于最普通的CURD(创建更新读取删除)系统究竟怎么去设计。都是做CURD的，架构师和普通开发区别在哪里。本文就来探讨一下这个问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;CURD系统怎么做出技术含量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我前几年在面试别人的时候，遇到过一些面试者，已经带领别人做过项目了。可能人家的管理能力是不错的。项目管理是个博大精深的学问，可能一个项目在不同的阶段，更上层会找不同的管理者来做。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;比如初创团队，会找些善于创业、擅长打造敏捷团队的管理者。这样的管理者可能会比较善于鼓舞团队士气。而到了一定阶段，项目业务量起来之后，不再求快，而是求稳。这时候管理者可能会换人，新的管理者做事并不那么快，但是做决策的路很正。路很正怎么理解，打个比方说：别人提了需求，前一个领导人很好，人家来需求他就接。这个领导不是，他会分析利弊和领域、业务是否合适放在这里。再比如更一层领导提了一个需求，要求什么什么时间做完。这个领导会去分析上层领导更本质的需求，宁可延期，要做稳做好。而项目稳定之后，继续稳定下去已经没有什么业绩了。这时候可能会再换领导，这个领导会带来一些原来积累的规划、方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;总之，这个面试者可能有这些能力，但是我们要招聘一个技术人员，先考察硬实力，所以很自然的先请他介绍之前的项目做了什么和怎么做的。他自己也很没底气的说就是CURD嘛。给人感觉就是没有想法，在工作过程中思考的少。&lt;br/&gt;&lt;/p&gt;&lt;p&gt;拿一个后台管理系统来说，要对重要数据进行添加修改删除，一般需要审核、审计，敏感数据脱敏，甚至需要数据灰度。将这整套流程串联起来，需要一个工作流系统，可能会用到工作流引擎。目前有些数据脱敏已经用上了NLP(自然语言处理)技术。这里面每一步都涉及知识点。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据模型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;有限状态机设计&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;刚才提到后台管理系统里用到审核、审计、灰度。这三个可以与业务流程分离，做成三个工具组件。审核有审核状态：审核中、审核成功，审核失败。灰度也有待灰度、灰度中、灰度成功、灰度失败四种状态。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;假如有一条数据，目前它的状态可以分成数据状态：有效数据和无效数据。另外还有审核状态和灰度状态。这时候数据模型(可以简单理解成数据库的数据表设计)应该设计成三个状态用三个数据字段表示呢，还是用一个数据字段来表示这三种状态呢。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这要看情况，一般来说，如果三种状态之前是相互独立的，比如：审核中是否可以待灰度，也可能是灰度中？对于一个工作流系统来说，一般要先审核通过才会进行灰度流程。就是说各个状态是互斥的。所以设计成三个字段，程序的判断逻辑会很复杂，因为有些组合是不成立的。这时候更合理的一个设计是用一个状态字段表示，通过状态机流转来控制。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;设计方案中可以通过类似下面的流转图来体现：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.70917225950783&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8l6wfnRA330O2MsEGAdjo4UXbicbGAk4J6D65icIQOBXJHgzEu9uhZLpcia7DfTnApRXk5qLS2YvWQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;894&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;实际方案设计过程中我改造了一下，状态正常从左到右流转，将终态用不同的形状(这里用椭圆)来表示。这样表示秩序感强些，更好理解。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4270531400966184&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8l6wfnRA330O2MsEGAdjo4CT9KTLDLRCsUYWDb9vHQDW5BhUdnbzQFOpfxcKD33ncHb7KlC14L3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1035&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数据表设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在数据表设计时，要至少考虑数据类型、是否默认、是否为空和索引设计。比如对于钱什么的，需要用decimal(10,2)，具体精确到多少位，要根据业务理解来定。对于加密字符什么的，加密如果是md5的，可以用char，而不用varchar来提高效率。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里面就好像《红楼梦》里的台词一样，每条都很有学问。所以面试时的场景题也经常爱让进行一个数据表设计。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3135646687697161&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8l6wfnRA330O2MsEGAdjo4d6qxbIx3879enMZOOw4MR9HkqIz1geR7iaPxib0txhKKr0qe10WSMW4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1585&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;流程设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我比较建议在一个设计方案开始时先把设计流程图先给出来，便于对方案有个整体认知。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;流程图也很有学问，【亿图】软件上把流程图分成了下面的子类。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.23336006415396954&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8l6wfnRA330O2MsEGAdjo41opFVQ2AJ6KMmQb4o7ic9OehJjEI5jM7e97SAYAXxZPK5nJTzzdMIIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1247&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我个人最常用的是泳道图和BPMN。BPMN可以简单理解为业务流程图和泳道图差别不大。就是在普通流程图基础上增加一个分类，这个分类可以是阶段、也可以是执行者这些。就是给流程图多增加一个维度的信息，理解起来更清晰。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7156511350059738&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8l6wfnRA330O2MsEGAdjo4iagBDgFFPI4dhnUWbtLACSc9Kibofoict49HzaKVv6t97M5m5hnibNc61Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;837&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在设计方案里还必须要有里程碑和未来规划。有句废话叫只怕有心人。在工作中，往往工作出色的并不是最聪明的，也不是花时间最长的。而是真正用心做的人。特别是设计方案，建议多用前人和大家总结的设计模板。模板最能代表一种设计思路。自己想到的、设计模板想到的都要考虑清楚，把方案做细。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;遇到具体的问题，要做业界调研。之前听过一个实习生做的方案，他说业界调研的时候并没有查到特别相关的方案资料。当时我的领导就说了一句特别值得思考的话：如果没有查到，肯定是你的检索关键词不对。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我后来反复斟酌这句话，发现能想到的检索关键词才是真正体现自己对业务理解的。同时，业界调研的时候不仅要对业务相关做调研，需求可以分解，具体到每个步骤也需要调研。调研过程是个极好的学习机会。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下功夫和不下功夫的区别，想想《红楼梦》，之所以这么多红学者。人家红楼梦的作者设计每句话都是剧透，人物说出的话，都会被啪啪打脸。里面的每道菜谱都是值得专业厨师来研究的。这都是心用到了。优秀架构师也是这样炼成的。之所以说这个废话，因为我就被diss过方案做的不够细，我也看过别人的方案不够细的。时常回想被diss不够细的那句话，觉得真的是金玉良言。心怀感激。&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f47b7c80e36fed8f236cd03688b31519</guid>
<title>[推荐] 《我想进大厂》之 Redis 夺命连环 11 问</title>
<link>https://toutiao.io/k/lko6b3m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;（给&lt;/span&gt;&lt;span&gt;数据分析与开发&lt;/span&gt;&lt;span&gt;加星标，提升数据技能&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;来源：科技缪缪 （本文来自作者投稿）&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;说说Redis基本数据类型有哪些吧&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;字符串：redis没有直接使用C语言传统的字符串表示，而是自己实现的叫做简单动态字符串SDS的抽象类型。C语言的字符串不记录自身的长度信息，而SDS则保存了长度信息，这样将获取字符串长度的时间由O(N)降低到了O(1)，同时可以避免缓冲区溢出和减少修改字符串长度时所需的内存重分配次数。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;链表linkedlist：redis链表是一个双向无环链表结构，很多发布订阅、慢查询、监视器功能都是使用到了链表来实现，每个链表的节点由一个listNode结构来表示，每个节点都有指向前置节点和后置节点的指针，同时表头节点的前置和后置节点都指向NULL。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;字典hashtable：用于保存键值对的抽象数据结构。redis使用hash表作为底层实现，每个字典带有两个hash表，供平时使用和rehash时使用，hash表使用链地址法来解决键冲突，被分配到同一个索引位置的多个键值对会形成一个单向链表，在对hash表进行扩容或者缩容的时候，为了服务的可用性，rehash的过程不是一次性完成的，而是渐进式的。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;跳跃表skiplist：跳跃表是有序集合的底层实现之一，redis中在实现有序集合键和集群节点的内部结构中都是用到了跳跃表。redis跳跃表由zskiplist和zskiplistNode组成，zskiplist用于保存跳跃表信息（表头、表尾节点、长度等），zskiplistNode用于表示表跳跃节点，每个跳跃表的层高都是1-32的随机数，在同一个跳跃表中，多个节点可以包含相同的分值，但是每个节点的成员对象必须是唯一的，节点按照分值大小排序，如果分值相同，则按照成员对象的大小排序。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;整数集合intset：用于保存整数值的集合抽象数据结构，不会出现重复元素，底层实现为数组。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;压缩列表ziplist：压缩列表是为节约内存而开发的顺序性数据结构，他可以包含多个节点，每个节点可以保存一个字节数组或者整数值。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基于这些基础的数据结构，redis封装了自己的对象系统，包含字符串对象string、列表对象list、哈希对象hash、集合对象set、有序集合对象zset，每种对象都用到了至少一种基础的数据结构。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;redis通过encoding属性设置对象的编码形式来提升灵活性和效率，基于不同的场景redis会自动做出优化。不同对象的编码如下：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;字符串对象string：int整数、embstr编码的简单动态字符串、raw简单动态字符串&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;列表对象list：ziplist、linkedlist&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;哈希对象hash：ziplist、hashtable&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;集合对象set：intset、hashtable&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;有序集合对象zset：ziplist、skiplist&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis为什么快呢？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;redis的速度非常的快，单机的redis就可以支撑每秒10几万的并发，相对于mysql来说，性能是mysql的几十倍。速度快的原因主要有几点：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;完全基于内存操作&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;C语言实现，优化过的数据结构，基于几种基础的数据结构，redis做了大量的优化，性能极高&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;使用单线程，无上下文的切换成本&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;基于非阻塞的IO多路复用机制&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那为什么Redis6.0之后又改用多线程呢?&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;redis使用多线程并非是完全摒弃单线程，redis还是使用单线程模型来处理客户端的请求，只是使用多线程来处理数据的读写和协议解析，执行命令还是使用单线程。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样做的目的是因为redis的性能瓶颈在于网络IO而非CPU，使用多线程能提升IO读写的效率，从而整体提高redis的性能。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;知道什么是热key吗？热key问题怎么解决？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所谓热key问题就是，突然有几十万的请求去访问redis上的某个特定key，那么这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机引发雪崩。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.41714285714285715&quot; data-type=&quot;jpeg&quot; data-w=&quot;1050&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmIwmSMLlrCHEj66HjJlAot2hSYkmxjb2lppicYuBMrmRia0jLg8zCMveicIHwbnFZ3dm7xo0xzyNOuA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;针对热key的解决方案：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;提前把热key打散到不同的服务器，降低压力&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;加入二级缓存，提前加载热key数据到内存中，如果redis宕机，走内存查询&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么是缓存击穿、缓存穿透、缓存雪崩？&lt;/span&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;缓存击穿&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存击穿的概念就是单个key并发访问过高，过期时导致所有请求直接打到db上，这个和热key的问题比较类似，只是说的点在于过期导致请求全部打到DB上而已。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;解决方案：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;加锁更新，比如请求查询A，发现缓存中没有，对A这个key加锁，同时去数据库查询数据，写入缓存，再返回给用户，这样后面的请求就可以从缓存中拿到数据了。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将过期时间组合写在value中，通过异步的方式不断的刷新过期时间，防止此类现象。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5056947608200456&quot; data-type=&quot;jpeg&quot; data-w=&quot;878&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmIwmSMLlrCHEj66HjJlAot15ia9NJVxN1r9QDltntLmqC5MxBBlIOOBDvnvNBiciaYXFcOut4ZD5p1g/640?wx_fmt=jpeg&quot;/&gt;&lt;span&gt;https://tva&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;缓存穿透&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存穿透是指查询不存在缓存中的数据，每次请求都会打到DB，就像缓存不存在一样。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5034802784222738&quot; data-type=&quot;jpeg&quot; data-w=&quot;862&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmIwmSMLlrCHEj66HjJlAotfyfg1VfmxRiaxwqyukuox5QNiazUlicn7FJ9Anicbl8bPGf25VMYNYhKuQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;针对这个问题，加一层布隆过滤器。布隆过滤器的原理是在你存入数据的时候，会通过散列函数将它映射为一个位数组中的K个点，同时把他们置为1。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这样当用户再次来查询A，而A在布隆过滤器值为0，直接返回，就不会产生击穿请求打到DB了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;显然，使用布隆过滤器之后会有一个问题就是误判，因为它本身是一个数组，可能会有多个值落到同一个位置，那么理论上来说只要我们的数组长度够长，误判的概率就会越低，这种问题就根据实际情况来就好了。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.43381180223285487&quot; data-type=&quot;jpeg&quot; data-w=&quot;1254&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmIwmSMLlrCHEj66HjJlAotwmfeKnHQeeQqYdkcqnYV61WpN3SKnJCxqpAZ1XauEAz6WyooC542KA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;缓存雪崩&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上，这样可能导致整个系统的崩溃，称为雪崩。雪崩和击穿、热key的问题不太一样的是，他是指大规模的缓存都过期失效了。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.45010183299389&quot; data-type=&quot;jpeg&quot; data-w=&quot;982&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmIwmSMLlrCHEj66HjJlAot0TVVVSI3kCN5mQIUwIU0jZeaZylKHeFRibbf473TNs9fF1Ut0Gg3rAg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;针对雪崩几个解决方案：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;针对不同key设置不同的过期时间，避免同时过期&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;限流，如果redis宕机，可以限流，避免同时刻大量请求打崩DB&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;二级缓存，同热key的方案。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Redis的过期策略有哪些？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;redis主要有2种过期删除策略&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;惰性删除&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;惰性删除指的是当我们查询key的时候才对key进行检测，如果已经达到过期时间，则删除。显然，他有一个缺点就是如果这些过期的key没有被访问，那么他就一直无法被删除，而且一直占用内存。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.28149300155520995&quot; data-type=&quot;jpeg&quot; data-w=&quot;1286&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmIwmSMLlrCHEj66HjJlAotTUJJNic94cee1OKFlibBEJpiazwQu2YRicbyicicpYiboFYicnDETibNddYdO7A/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;定期删除&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;定期删除指的是redis每隔一段时间对数据库做一次检查，删除里面的过期key。由于不可能对所有key去做轮询来删除，所以redis会每次随机取一些key去做检查和删除。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么定期+惰性都没有删除过期的key怎么办？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设redis每次定期随机查询key的时候没有删掉，这些key也没有做查询的话，就会导致这些key一直保存在redis里面无法被删除，这时候就会走到redis的内存淘汰机制。&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;volatile-lru：从已设置过期时间的key中，移出最近最少使用的key进行淘汰&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;volatile-ttl：从已设置过期时间的key中，移出将要过期的key&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;volatile-random：从已设置过期时间的key中随机选择key淘汰&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;allkeys-lru：从key中选择最近最少使用的进行淘汰&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;allkeys-random：从key中随机选择key进行淘汰&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;noeviction：当内存达到阈值的时候，新写入操作报错&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;持久化方式有哪些？有什么区别？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;redis持久化方案分为RDB和AOF两种。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;RDB&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;RDB持久化可以手动执行也可以根据配置定期执行，它的作用是将某个时间点上的数据库状态保存到RDB文件中，RDB文件是一个压缩的二进制文件，通过它可以还原某个时刻数据库的状态。由于RDB文件是保存在硬盘上的，所以即使redis崩溃或者退出，只要RDB文件存在，就可以用它来恢复还原数据库的状态。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以通过SAVE或者BGSAVE来生成RDB文件。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;SAVE命令会阻塞redis进程，直到RDB文件生成完毕，在进程阻塞期间，redis不能处理任何命令请求，这显然是不合适的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;BGSAVE则是会fork出一个子进程，然后由子进程去负责生成RDB文件，父进程还可以继续处理命令请求，不会阻塞进程。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;AOF&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;AOF和RDB不同，AOF是通过保存redis服务器所执行的写命令来记录数据库状态的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;AOF通过追加、写入、同步三个步骤来实现持久化机制。&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当AOF持久化处于激活状态，服务器执行完写命令之后，写命令将会被追加append到aof_buf缓冲区的末尾&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在服务器每结束一个事件循环之前，将会调用flushAppendOnlyFile函数决定是否要将aof_buf的内容保存到AOF文件中，可以通过配置appendfsync来决定。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;always &lt;span&gt;##aof_buf内容写入并同步到AOF文件&lt;/span&gt;&lt;br/&gt;everysec &lt;span&gt;##将aof_buf中内容写入到AOF文件，如果上次同步AOF文件时间距离现在超过1秒，则再次对AOF文件进行同步&lt;/span&gt;&lt;br/&gt;no &lt;span&gt;##将aof_buf内容写入AOF文件，但是并不对AOF文件进行同步，同步时间由操作系统决定&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果不设置，默认选项将会是everysec，因为always来说虽然最安全（只会丢失一次事件循环的写命令），但是性能较差，而everysec模式只不过会可能丢失1秒钟的数据，而no模式的效率和everysec相仿，但是会丢失上次同步AOF文件之后的所有写命令数据。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;怎么实现Redis的高可用？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;要想实现高可用，一台机器肯定是不够的，而redis要保证高可用，有2个可选方案。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;主从架构&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;主从模式是最简单的实现高可用的方案，核心就是主从同步。主从同步的原理如下：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;slave发送sync命令到master&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;master收到sync之后，执行bgsave，生成RDB全量文件&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;master把slave的写命令记录到缓存&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;bgsave执行完毕之后，发送RDB文件到slave，slave执行&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;master发送缓存中的写命令到slave，slave执行&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6389548693586699&quot; data-type=&quot;jpeg&quot; data-w=&quot;842&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmIwmSMLlrCHEj66HjJlAotdopLgAB9KKiah8qqA71ZkztXrn885zDVCyFSnricEAPyWdo9w9lxG6icg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里我写的这个命令是sync，但是在redis2.8版本之后已经使用psync来替代sync了，原因是sync命令非常消耗系统资源，而psync的效率更高。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;哨兵&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基于主从方案的缺点还是很明显的，假设master宕机，那么就不能写入数据，那么slave也就失去了作用，整个架构就不可用了，除非你手动切换，主要原因就是因为没有自动故障转移机制。而哨兵(sentinel)的功能比单纯的主从架构全面的多了，它具备自动故障转移、集群监控、消息通知等功能。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7674943566591422&quot; data-type=&quot;jpeg&quot; data-w=&quot;886&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmIwmSMLlrCHEj66HjJlAotgVjlOy0uURyKRueXhar16F3ndHj2sQOme4tLbAGwg4Pia5dzcucWhXA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;哨兵可以同时监视多个主从服务器，并且在被监视的master下线时，自动将某个slave提升为master，然后由新的master继续接收命令。整个过程如下：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;初始化sentinel，将普通的redis代码替换成sentinel专用代码&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;初始化masters字典和服务器信息，服务器信息主要保存ip:port，并记录实例的地址和ID&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;创建和master的两个连接，命令连接和订阅连接，并且订阅sentinel:hello频道&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;每隔10秒向master发送info命令，获取master和它下面所有slave的当前信息&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当发现master有新的slave之后，sentinel和新的slave同样建立两个连接，同时每个10秒发送info命令，更新master信息&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;sentinel每隔1秒向所有服务器发送ping命令，如果某台服务器在配置的响应时间内连续返回无效回复，将会被标记为下线状态&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;选举出领头sentinel，领头sentinel需要半数以上的sentinel同意&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;领头sentinel从已下线的的master所有slave中挑选一个，将其转换为master&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;让所有的slave改为从新的master复制数据&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将原来的master设置为新的master的从服务器，当原来master重新回复连接时，就变成了新master的从服务器&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;sentinel会每隔1秒向所有实例（包括主从服务器和其他sentinel）发送ping命令，并且根据回复判断是否已经下线，这种方式叫做主观下线。当判断为主观下线时，就会向其他监视的sentinel询问，如果超过半数的投票认为已经是下线状态，则会标记为客观下线状态，同时触发故障转移。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;能说说redis集群的原理吗？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果说依靠哨兵可以实现redis的高可用，如果还想在支持高并发同时容纳海量的数据，那就需要redis集群。redis集群是redis提供的分布式数据存储方案，集群通过数据分片sharding来进行数据的共享，同时提供复制和故障转移的功能。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;节点&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个redis集群由多个节点node组成，而多个node之间通过cluster meet命令来进行连接，节点的握手过程：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;节点A收到客户端的cluster meet命令&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;A根据收到的IP地址和端口号，向B发送一条meet消息&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;节点B收到meet消息返回pong&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;A知道B收到了meet消息，返回一条ping消息，握手成功&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;最后，节点A将会通过gossip协议把节点B的信息传播给集群中的其他节点，其他节点也将和B进行握手&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2459605026929982&quot; data-type=&quot;jpeg&quot; data-w=&quot;1114&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmIwmSMLlrCHEj66HjJlAot333fTiaaCA3ibxfwpnZ8VbzLkaM4cxHs23REHZVCibGUF4GdZmLNviaPYQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;槽slot&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;redis通过集群分片的形式来保存数据，整个集群数据库被分为16384个slot，集群中的每个节点可以处理0-16384个slot，当数据库16384个slot都有节点在处理时，集群处于上线状态，反之只要有一个slot没有得到处理都会处理下线状态。通过cluster addslots命令可以将slot指派给对应节点处理。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;slot是一个位数组，数组的长度是16384/8=2048，而数组的每一位用1表示被节点处理，0表示不处理，如图所示的话表示A节点处理0-7的slot。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.20159680638722555&quot; data-type=&quot;jpeg&quot; data-w=&quot;1002&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmIwmSMLlrCHEj66HjJlAot9WNKa3CWnMYFY4JK5MKCOdcUZYmsYtpa7RNofu11gamgcRibyU14y0g/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当客户端向节点发送命令，如果刚好找到slot属于当前节点，那么节点就执行命令，反之，则会返回一个MOVED命令到客户端指引客户端转向正确的节点。（MOVED过程是自动的）&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3784135240572172&quot; data-type=&quot;jpeg&quot; data-w=&quot;1538&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibBMVuDfkZUmIwmSMLlrCHEj66HjJlAotRea7czTYia2kyQric4rkZOdnbfD7U4WHLErfu6BjU4jvTGicGZFLVTaicA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果增加或者移出节点，对于slot的重新分配也是非常方便的，redis提供了工具帮助实现slot的迁移，整个过程是完全在线的，不需要停止服务。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;故障转移&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果节点A向节点B发送ping消息，节点B没有在规定的时间内响应pong，那么节点A会标记节点B为pfail疑似下线状态，同时把B的状态通过消息的形式发送给其他节点，如果超过半数以上的节点都标记B为pfail状态，B就会被标记为fail下线状态，此时将会发生故障转移，优先从复制数据较多的从节点选择一个成为主节点，并且接管下线节点的slot，整个过程和哨兵非常类似，都是基于Raft协议做选举。&lt;/span&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;了解Redis事务机制吗？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;redis通过MULTI、EXEC、WATCH等命令来实现事务机制，事务执行过程将一系列多个命令按照顺序一次性执行，并且在执行期间，事务不会被中断，也不会去执行客户端的其他请求，直到所有命令执行完毕。事务的执行过程如下：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;服务端收到客户端请求，事务以MULTI开始&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果客户端正处于事务状态，则会把事务放入队列同时返回给客户端QUEUED，反之则直接执行这个命令&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当收到客户端EXEC命令时，WATCH命令监视整个事务中的key是否有被修改，如果有则返回空回复到客户端表示失败，否则redis会遍历整个事务队列，执行队列中保存的所有命令，最后返回结果给客户端&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;WATCH的机制本身是一个CAS的机制，被监视的key会被保存到一个链表中，如果某个key被修改，那么REDIS_DIRTY_CAS标志将会被打开，这时服务器会拒绝执行事务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;a class=&quot;weapp_image_link&quot; data-miniprogram-appid=&quot;wx4b74228baa15489a&quot; data-miniprogram-path=&quot;lib/item/dist/pages/index/index?itemId=3715169443&amp;amp;vrk=&amp;amp;wfr=&amp;amp;feeSource=&quot; data-miniprogram-nickname=&quot;微店+&quot; href=&quot;&quot; data-miniprogram-type=&quot;image&quot; data-miniprogram-servicetype=&quot;&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/75TZzMDzrHibtibjlZicku5iavkCvWy2y2V8iaEeuYIWVUEzbjictJzAUILetyZQlxIMXk4ghnTBsTWvQPnMwd4vnjPA/640?wx_fmt=jpeg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5ODM5MDU3MA==&amp;amp;mid=2650868182&amp;amp;idx=2&amp;amp;sn=81c5789013e17ddb73fb1f81d33d09ac&amp;amp;chksm=8b67ee93bc106785c02b589e0c4302ebac580a30729512053a80577e9afbce8ca48d3102c442&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;1、一文把 Redis 主从复制、哨兵、Cluster 三种模式摸透&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;1、一文把 Redis 主从复制、哨兵、Cluster 三种模式摸透&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5ODM5MDU3MA==&amp;amp;mid=2650868079&amp;amp;idx=1&amp;amp;sn=0e579b8c26b32234cbfc4f3b44e785fd&amp;amp;chksm=8b67ee2abc10673c00be104be10dd41602ec783cc0ff432670e2f6d0f0bfcf5fd7a531f6f8a5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;2、还不懂 Redis？看完这个故事就明白了&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;2、还不懂 Redis？看完这个故事就明白了&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5ODM5MDU3MA==&amp;amp;mid=2650868046&amp;amp;idx=1&amp;amp;sn=e8a2519905475776b061f98d12815e5e&amp;amp;chksm=8b67ee0bbc10671dbec55063670fc4a500bd12f992c6095edbcd7aa0ce9796850fd523a4616e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;3、Redis 秒杀实战&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;3、Redis 秒杀实战&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;关注「数据分析与开发」加星标，提升数据技能&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-copyright=&quot;0&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DmibiaFiaAI4B3YpcZYPicgc9JTMiaACNXE5A9FePsKgBic7LNlibx2fwVycTN4Wq47TzYXTNnP2PCKCVAGibNmzDnD0zg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;好文章，我&lt;/span&gt;&lt;span&gt;在看&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>7e3ffd47bd2dad2394c63ba25380d314</guid>
<title>[推荐] 理解完这些基本上能解决面试中 MySQL 的事务问题</title>
<link>https://toutiao.io/k/szxq5t8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1 cid=&quot;n0&quot; mdtype=&quot;heading&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;欢迎关注公众号【&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;Ccww技术博客&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;】，原创技术文章第一时间推出&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/h1&gt;&lt;hr/&gt;&lt;blockquote cid=&quot;n4&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n1135&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;越努力，越幸运，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1136&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;本文已收藏在GitHub中JavaCommunity, 里面有面试分享、源码分析系列文章，欢迎收藏，点赞&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1139&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;https://github.com/Ccww-lx/JavaCommunity&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 cid=&quot;n1134&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n1126&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;在面试中，基本上都会问到关于数据库的事务问题，如果啥都不会或者只回答到表面的上知识点的话，那面试基本上是没戏了，为了能顺利通过面试，那MySql的事务问题就需要了解，所以就根据网上的资料总结一版Mysql事务的知识点，巩固一下事务的知识。&lt;/span&gt;&lt;/p&gt;&lt;h2 cid=&quot;n1128&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;事务&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n1130&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;事务是指逻辑上的一组操作，要么都执行，要么都不执行,&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n5&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;事务的特性（ACID）&lt;/span&gt;&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n6&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n8&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;原子性(&lt;code&gt;Atomicity&lt;/code&gt;)：事务是不可分割的工作单元，要么都成功，要么都失败， 如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n10&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;一致性(&lt;code&gt;Consistency&lt;/code&gt;)：事务不能破坏数据的完整性和业务的一致性 。例如在银行转账时，不管事务成功还是失败，双方钱的总额不变&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n12&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;隔离性(&lt;code&gt;Isolation&lt;/code&gt;)：一个事务所操作的数据在提交之前，对其他事务的可见性设定（一般是不可见）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n14&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;持久性(&lt;code&gt;Durability&lt;/code&gt;)：事务提交之后，所做的修改就会永久保存，不会因为系统故障导致数据丢失&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n15&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;严格来说，只有同时满足数据库的事务ACID特性才能算一个完整的事务，但现实中实现能够真正满足的完整的事务特性少之又少，但是在实现中也必须尽量达到事务要求的特性。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n592&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;那么事务ACID特性具体怎么实现的呢？我们来分析看看，首先先看看事务的特性。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h2 cid=&quot;n418&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;原子性(&lt;/span&gt;&lt;code&gt;&lt;span&gt;Atomicity&lt;/span&gt;&lt;/code&gt;&lt;span&gt;)&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n419&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;首先我们来看看事务的原子性特性，看看其如何实现的？&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n581&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;原子性(&lt;code&gt;Atomicity&lt;/code&gt;)：事务是不可分割的工作单元，要么都成功，要么都失败， 如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n428&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;原子性(&lt;code&gt;Atomicity&lt;/code&gt;)的实现离不开 MySQL的事务日志 &lt;code&gt;undo log&lt;/code&gt;日志类型，当事务需要回滚的时候需要将数据库状态回滚到事务开始前，即需要撤销所有已经成功执行的sql语句。那么&lt;code&gt;undo log&lt;/code&gt;起了关键性作用：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n432&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;当事务对数据库进行修改时，InnoDB会生成对应的&lt;code&gt;undo log&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;；如果事务执行失败或调用了&lt;code&gt;rollback&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;，导致事务需要回滚，便可以利用&lt;code&gt;undo log&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;中的信息将数据回滚到修改之前的样子。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n420&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;那么&lt;code&gt;undo log&lt;/code&gt;是什么呢？每个数据变更操作是怎么被记录下来的呢？&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n434&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;undo log（ 回滚日志 ）&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n421&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code&gt;undo log&lt;/code&gt; (回滚日志)：是采用&lt;strong&gt;段(&lt;code&gt;segment&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;)&lt;/strong&gt;的方式来记录的，每个&lt;code&gt;undo&lt;/code&gt;操作在记录的时候占用一个&lt;strong&gt;&lt;code&gt;undo log segment&lt;/code&gt;&lt;/strong&gt;。为什么会在数据更改操作的时候，记录了相对应的&lt;code&gt;undo log&lt;/code&gt;呢？其目的在于：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n523&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;其中，&lt;code&gt;undo log&lt;/code&gt;分为：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n455&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;数据更改的&lt;code&gt;undo log&lt;/code&gt;怎么记录的呢？&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n462&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt; 因为&lt;code&gt;insert&lt;/code&gt;操作的记录，只对事务本身可见，对其他事务不可见。故该&lt;code&gt;undo log&lt;/code&gt;可以在事务提交后直接删除，不需要进行&lt;code&gt;purge&lt;/code&gt;操作，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n536&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt; 而&lt;code&gt;Delete&lt;/code&gt;操作在事务中实际上并不是真正的删除掉数据行，而是一种Delete Mark操作，在记录上标识&lt;code&gt;Delete_Bit&lt;/code&gt;，而不删除记录。是一种&quot;假删除&quot;,只是做了个标记，真正的删除工作需要后台&lt;code&gt;purge&lt;/code&gt;线程去完成。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n546&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code&gt;update&lt;/code&gt;分为两种情况：&lt;code&gt;update&lt;/code&gt;的列是否是主键列。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n532&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;与&lt;code&gt;insert undo log&lt;/code&gt;不同的，&lt;code&gt;update undo log&lt;/code&gt;日志，当事务提交的时候，innodb不会立即删除&lt;code&gt;undo log&lt;/code&gt;， 会将该事务对应的&lt;code&gt;undo log&lt;/code&gt;放入到删除列表中，未来通过&lt;code&gt;purge&lt;/code&gt;线程来删除。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n542&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;因为后续还可能会用到&lt;code&gt;undo log&lt;/code&gt;，如隔离级别为&lt;code&gt;repeatable read&lt;/code&gt;时，事务读取的都是开启事务时的最新提交行版本，只要该事务不结束，该行版本就不能删除（即&lt;code&gt;undo log&lt;/code&gt;不能删除）,且&lt;code&gt;undo log&lt;/code&gt;分配的页可重用减少存储空间和提升性能。 &lt;/span&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n488&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n563&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Note：purge线程两个主要作用是：清理undo页和清除page里面带有Delete_Bit标识的数据行。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p cid=&quot;n588&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n590&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;接着我们来看看事务的隔离性，看看事务有哪些隔离级别，而且事务并发中会产生什么问题。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h2 cid=&quot;n570&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;隔离性(&lt;/span&gt;&lt;code&gt;&lt;span&gt;Isolation&lt;/span&gt;&lt;/code&gt;&lt;span&gt;)&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n584&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;隔离性(&lt;code&gt;Isolation&lt;/code&gt;)，是指事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰 ，一个事务所操作的数据在提交之前，对其他事务的可见性设定(一般是不可见)。&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n624&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;事务隔离级别&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n896&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;而且数据库为了在并发下有效保证读取数据正确性，数据库提供了&lt;span&gt;四种事务隔离级别&lt;/span&gt;&amp;gt;，分别为：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n614&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n616&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;读未提交(&lt;strong&gt;脏读&lt;/strong&gt;)：允许读取尚未提交的数据，允许脏读&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n618&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;读已提交（ &lt;strong&gt;不可重复读&lt;/strong&gt; ）：允许读取事务已经提交的数据&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n620&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;可重复读（ &lt;strong&gt;幻读&lt;/strong&gt; ）：在同一个事务内的查询结果都是和事务开始时刻查询一致的（ InnoDB默认级别 ）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n622&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;串行化：所有事务逐个依次执行， 每次读都需要获得表级共享锁，读写相互都会阻塞&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n572&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;其中，&lt;span&gt;不同的隔离级别可能会存在在不同并发问题&lt;/span&gt;，主要并发问题包括：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n780&quot; mdtype=&quot;list&quot; data-mark=&quot;+&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n782&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;数据丢失：&lt;/strong&gt; 两个或多个事务操作相同数据，基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题——最后的更新覆盖了其他事务所做的更新&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n786&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;脏读：&lt;/strong&gt;读到了其他事务还未提交的数据，事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n787&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.38437978560490044&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgyKx4nzfu3dK9SD5jxqxFmmXvxnaQq5p8dQSTj5K8EMicF2c6WyBkFbQfOSzcbq6jk8YJGFcOh46g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;653&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n789&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;不可重复读（重点是修改）：&lt;/strong&gt;在一个事务中，先后进行两次相同的读取，由于另一个事务修改了数据，导致前后两次结果的不一致，事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n790&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.35222052067381315&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgyKx4nzfu3dK9SD5jxqxFm6tdicD2HjhvRXibhXCtTn6rH5cLPuicuexv7oH3wYibnBrovbvo4JHxvkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;653&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n792&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;幻读（重点是新增、删除）：&lt;/strong&gt; 在一个事务中，先后进行两次相同的读取（一般是范围查询），由于另一个事务新增或删除了数据，导致前后两次结果不一致&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n793&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3592085235920852&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgyKx4nzfu3dK9SD5jxqxFm4d2C0AiaquwswcPdYyLxc9hTiamoyVbgdozoCSmNBmj2dvbykQyrZkdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;657&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote cid=&quot;n916&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n921&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;不可重复读和幻读的区别？&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n922&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n924&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;使用锁机制来实现这两种隔离级别，在可重复读中，相同sql第一次读取到数据后就将这些数据加锁，其它事务无法更新操作这些数据来实现可重复读了隔离。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n926&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;但这种处理方式却无法锁住insert的数据，因此会出现当事务A先前读取了数据，事务B再&lt;code&gt;insert&lt;/code&gt;数据提交，结果发现事务A就会发现莫名其妙多了些数据，这就是幻读，不能通过行锁来避免 。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p cid=&quot;n914&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;了解了并发问题后，来看看不同的隔离级别可能会存在在不同并发问题：&lt;/span&gt;&lt;/p&gt;&lt;figure cid=&quot;n868&quot; mdtype=&quot;table&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr cid=&quot;n869&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;span&gt;事务隔离级别&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;脏读&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;不可重复读&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;幻读&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n874&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;读未提交&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;是&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;是&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;是&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n879&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;不可重复读&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;是&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;是&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n884&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;可重复读&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;是&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n889&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;串行化&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;否&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p cid=&quot;n70&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;为了实现事务隔离，延伸出了数据库锁。其中，&lt;span&gt;&lt;strong&gt;innodb事务的隔离级别是由锁机制和MVCC（多版本并发控制）来实现的&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n71&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;那我们来先看看锁的原理，怎么使用锁来实现事务隔离的呢？&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n73&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;锁机制&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n971&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;锁机制的基本工作原理，事务在修改数据之前，需要先获得相应的锁；获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n74&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;MySQL主要分成三种类型（级别）的锁机制：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n75&quot; mdtype=&quot;list&quot; data-mark=&quot;+&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n77&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;表级锁：最大颗粒度的锁机制，锁定资源争用的概率也会最高 ，并发度最低 ，但开销小，加锁快，不会出现死锁，&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n79&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;行级锁：最大颗粒度的锁机制很小， 发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能 ，但 开销大，加锁慢；会出现死锁 ，&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n81&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;页级锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n82&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;而且不同的存储引擎支持不同的的锁机制，主要分析一下InnoDB锁。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n83&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;InnoDB锁&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n84&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt; InnoDB实现了以下两种类型的行锁&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n90&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;对于&lt;code&gt;UPDATE&lt;/code&gt;,&lt;code&gt;DELETE&lt;/code&gt;,&lt;code&gt;INSERT&lt;/code&gt;操作， InnoDB会自动给涉及及数据集加排他锁（Ｘ）；对于普通SELECT语句，InnoDB不会加任何锁,&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n91&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;而且因为InnoDB引擎允许行锁和表锁共存，实现多粒度锁机制，使用意向锁实现表锁机制，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n97&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;意向锁(IS、IX)是InnoDB数据操作之前自动加的，不需要用户干预。它的意义在于：当事务想去进行锁表时，可以先判断意向锁是否存在，存在时则可快速返回该表不能启用表锁，否则就需要等待，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n98&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;其中，四种锁的兼容性如下&lt;/span&gt;&lt;/p&gt;&lt;figure cid=&quot;n99&quot; mdtype=&quot;table&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr cid=&quot;n100&quot; mdtype=&quot;table_row&quot;&gt;&lt;th&gt;&lt;span&gt;当前锁模式/是否兼容/请求锁模式&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;X&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;IX&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;S&lt;/span&gt;&lt;/th&gt;&lt;th&gt;&lt;span&gt;IS&lt;/span&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr cid=&quot;n106&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;X&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;冲突&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;冲突&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;冲突&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;冲突&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n112&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;IX&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;冲突&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;兼容&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;冲突&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;兼容&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n118&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;S&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;冲突&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;冲突&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;兼容&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;兼容&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr cid=&quot;n124&quot; mdtype=&quot;table_row&quot;&gt;&lt;td&gt;&lt;span&gt;IS&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;冲突&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;兼容&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;兼容&lt;/span&gt;&lt;/td&gt;&lt;td&gt;&lt;span&gt;兼容&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p cid=&quot;n130&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;如果一个事务请求的锁模式与当前的锁兼容，InnoDB就请求的锁授予该事务；反之，如果两者两者不兼容，该事务就要等待锁释放。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n131&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;InnoDB行锁&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n132&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;InnoDB的行锁是通过给索引上的&lt;strong&gt;索引项加锁&lt;/strong&gt;来实现的。&lt;strong&gt;只有通过索引检索数据，才能使用行锁，否则将使用表锁（锁住索引的所有记录）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n133&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;innodb的行锁，默认是由&lt;strong&gt;&lt;code&gt;临键锁(next-key)&lt;/code&gt;&lt;/strong&gt;算法实现的，可以防止幻读。根据索引，划分为一个个&lt;strong&gt;左开右闭&lt;/strong&gt;的区间。当进行范围查询的时候，若命中索引且能够检索到数据，则锁住记录所在的区间和它的下一个区间,&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n134&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;其实，&lt;strong&gt;临键锁(Next-Key)&lt;/strong&gt;=&lt;strong&gt;记录锁(Record Locks)&lt;/strong&gt;+&lt;strong&gt;间隙锁(Gap Locks)&lt;/strong&gt;，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n140&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;具体的使用体现在哪里呢？如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.46060606060606063&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgyKx4nzfu3dK9SD5jxqxFmIvTG2Z905QUWVJgL5KYvySqTVgJf3licqul9aCZgbMvlFthtOpTYVww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;660&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n145&quot; mdtype=&quot;list&quot; data-mark=&quot;+&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n147&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当记录不存在（不论是等值查询，还是范围查询）时，next-key将退化成&lt;strong&gt;Gap Lock（间隙锁）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n148&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5150602409638554&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgyKx4nzfu3dK9SD5jxqxFmWpbMHJ8rEpFJyCiaa9vZGXPUsvricjWr0KxzQzHPyickY8zibqNLb6OemQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;664&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n150&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当条件是精准匹配（即为等值查询时）且记录存在时，并且是唯一索引，&lt;strong&gt;临键锁(Next-Key)&lt;/strong&gt;退化成&lt;strong&gt;Record Lock（记录锁）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n151&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4180790960451977&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgyKx4nzfu3dK9SD5jxqxFmsdCoFtlnGsncibWh7DLGCDy9lsEjbJsgKISMUpKVkcauW4Fuibd54L0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;708&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n153&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当条件是精准匹配（即为等值查询时）且记录存在，但不是唯一索引时，&lt;strong&gt;临键锁(Next-Key)&lt;/strong&gt;会有精准值的数据会增加&lt;strong&gt;Record Lock（记录锁）&lt;/strong&gt;和精准值前后的区间的数据会增加&lt;strong&gt;Gap Lock（间隙锁)&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n154&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4880597014925373&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgyKx4nzfu3dK9SD5jxqxFmz0VibbGWM6LPXzu6v2WfxfX41Xuo26h2StJrzu0GMpjtSojga6nbSVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;670&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 cid=&quot;n961&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;如何使用锁解决并发问题&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n962&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;利用锁解决脏读、不可重复读、幻读&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n960&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;&lt;code&gt;Multiversion concurrency control&lt;/code&gt; (&lt;code&gt;MVCC&lt;/code&gt; 多版本并发控制)&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n165&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;code&gt;InnoDB&lt;/code&gt;的&lt;code&gt;MVCC&lt;/code&gt;是通过在每行记录后面保存两个隐藏的列来实现的，&lt;strong&gt;一个保存了行的事务ID（事务ID就会递增 ）&lt;/strong&gt;，&lt;strong&gt;一个保存了行的回滚段的指针&lt;/strong&gt; 。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n398&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.21217391304347827&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgyKx4nzfu3dK9SD5jxqxFmR7uEiaSiaIwwML2kqPjwfcejNLV9I5qJrznHCtAhl7n3l6NiaDuMNCgGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;575&quot;/&gt;&lt;/p&gt;&lt;p cid=&quot;n400&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;每开始一个新的事务，都会自动递增产 生一个新的事务id。事务开始时刻的会把事务id放到当前事务影响的行事务id中，而&lt;code&gt;DB_ROLL_PTR&lt;/code&gt;表示指向该行回滚段的指针，该行记录上所有版本数据，在undo中都通过链表形式组织，该值实际指向undo中该行的历史记录链表，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n166&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span&gt;在并发访问数据库时，对正在事务中的数据做MVCC多版本的管理，以避免写操作阻塞读操作，并且会通过比较版本解决幻读&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n167&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;而且MVCC只在&lt;code&gt;REPEATABLE READ&lt;/code&gt;和&lt;code&gt;READ COMMITIED&lt;/code&gt;两个隔离级别下才会工作，&lt;strong&gt;其中，MVCC实现实质就是保存数据在某个时间点的&lt;span&gt;快照&lt;/span&gt;来实现的。&lt;/strong&gt; 那哪些操作是快照读？&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n168&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;快照读和当前读&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n169&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;快照读&lt;/strong&gt;，innodb快照读，数据的读取将由 cache(原本数据) + undo(事务修改前的数据) 两部分组成&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n173&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;当前读&lt;/strong&gt;，SQL读取的数据是最新版本。通过锁机制来保证读取的数据无法通过其他事务进行修改&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n186&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;那么在RR隔离级别下，MVCC具体是如何操作的。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n187&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;RR隔离级别下，MVCC具体操作&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n188&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;SELECT操作&lt;/strong&gt;，InnoDB遵循以后两个规则执行：&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n189&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n191&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span&gt;InnoDB只查找版本早于当前事务版本的数据行（即行的事务编号小于或等于当前事务的事务编号）&lt;/span&gt;，这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的记录。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n193&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span&gt;行的删除版本要么未定义,读取到事务开始之前状态的版本&lt;/span&gt;&amp;gt;,这可以确保事务读取到的行，在事务开始之前未被删除.只有同时满足的两者的记录，才能返回作为查询结果.&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p cid=&quot;n194&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;INSERT&lt;/strong&gt;：&lt;span&gt;InnoDB为新插入的每一行保存当前事务编号作为行版本号&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n195&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;DELETE&lt;/strong&gt;：&lt;span&gt;InnoDB为删除的每一行保存当前事务编号作为行删除标识&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n196&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;UPDATE&lt;/strong&gt;：&lt;span&gt;InnoDB为插入一行新记录，保存当前事务编号作为行版本号，同时保存当前事务编号到原来的行作为行删除标识&lt;/span&gt;&amp;gt;。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n197&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。&lt;span md-inline=&quot;tab&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n198&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;分析完了原子性和隔离性，我们继续看看事务的持久性。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n980&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h2 cid=&quot;n931&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;持久性(&lt;/span&gt;&lt;code&gt;&lt;span&gt;Durability&lt;/span&gt;&lt;/code&gt;&lt;span&gt;)&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n940&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;持久性(&lt;code&gt;Durability&lt;/code&gt;)：事务提交之后，所做的修改就会永久保存，不会因为系统故障导致数据丢失，&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n983&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;而且其实现的关键在于&lt;code&gt;redo log&lt;/code&gt;， 在执行SQL时会保存已执行的SQL语句到一个指定的Log文件，当执行&lt;code&gt;recovery&lt;/code&gt;时重新执行&lt;code&gt;redo log&lt;/code&gt;记录的SQL操作。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n991&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;那么&lt;code&gt;redo log&lt;/code&gt;如何实现的呢？&lt;/span&gt;&lt;/p&gt;&lt;h3 cid=&quot;n993&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;redo log&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n995&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;当向数据库写入数据时，执行过程会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏），这整一过程称为redo log。redo log 分为：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1019&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Buffer Pool的使用可以大大提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据在内存还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1016&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;为了确保事务的持久性，在当事务提交时，会调用&lt;code&gt;fsync&lt;/code&gt;接口对&lt;code&gt;redo log&lt;/code&gt;进行刷盘, （即&lt;code&gt;redo log buffer&lt;/code&gt;写日志到磁盘的&lt;code&gt;redo log file&lt;/code&gt;中 ）,刷新频率由 &lt;code&gt;innodb_flush_log_at_trx_commit&lt;/code&gt;变量来控制的：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1043&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;redo log有更加详细的解读，后续有时间再补上，到现在为止，已经将事务三个特性都理解了，那事务一致性呢？&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h2 cid=&quot;n1049&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;一致性(&lt;/span&gt;&lt;code&gt;&lt;span&gt;Consistency&lt;/span&gt;&lt;/code&gt;&lt;span&gt;)&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n989&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;一致性(&lt;code&gt;Consistency&lt;/code&gt;)：事务不能破坏数据的完整性和业务的一致性 ：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1065&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;那是如何保证数据一致性的？&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n1067&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;其实数据一致性是通过事务的原子性、持久性和隔离性来保证的&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n1072&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n1074&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;原子性：语句要么全执行，要么全不执行，是事务最核心的特性，事务本身就是以原子性来定义的；实现主要基于undo log&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1076&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;持久性：保证事务提交后不会因为宕机等原因导致数据丢失；实现主要基于redo log&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n1078&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;隔离性：保证事务执行尽可能不受其他事务影响；InnoDB默认的隔离级别是RR，RR的实现主要基于锁机制（包含next-key lock）、MVCC（包括数据的隐藏列、基于undo log的版本链、ReadView）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 cid=&quot;n4927&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p cid=&quot;n932&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;其中要同时满足ACID特性，这样的事务少之又少。实际中很多例子都只是满足一些特性，比如：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n4931&quot; mdtype=&quot;list&quot; data-mark=&quot;+&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n4934&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;MySQL的NDB Cluster事务不满足持久性和隔离性；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n4935&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;InnoDB默认事务隔离级别是可重复读，不满足隔离性；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n4941&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;Oracle默认的事务隔离级别为READ COMMITTED，不满足隔离性&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p cid=&quot;n4929&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;所以我们只能使用这个四个维度的特性去衡量事务的操作。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n934&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;blockquote cid=&quot;n7947&quot; mdtype=&quot;blockquote&quot;&gt;&lt;p cid=&quot;n7949&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;谢谢各位点赞，没点赞的点个赞支持支持&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n7949&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;最后，微信搜《Ccww技术博客》观看更多文章，也欢迎关注一波。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgfBz2Ve78FylxcGWmXaueSuqPguurBCWEkeY1ibeLl1wlxUyibdesc4YeuiaJJjSt6HTiab2iaHyXyyicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.36857142857142855&quot; data-w=&quot;350&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3b070a788ad7d2ed9f1ef1664a67bca7</guid>
<title>[推荐] 国庆期间，我造了台计算机</title>
<link>https://toutiao.io/k/x4os6i7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;每个时代，都不会亏待会学习的人。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是 yes。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于我们程序员来说计算机的重要性不言而喻，相信大家对计算机内部也有一定的了解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是大家有没想过为什么一堆逻辑门组合起来就能运算了？它是如何运作来实现加减法的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么 cpu 会不停地取指执行？是什么在驱动着它？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我就和大家一起来探索一下底层的奥秘，但是术业有专攻，我们大致的了解一下即可，很多细节不清晰也不影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过相信通过这篇文章你会对底层有不一样的认识，包括运算单元、内存、时钟、地址、溢出、补码等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先打个预防针吧，这篇文章有很多电路图，你可能感觉这啥啊，和我们开发有关系吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看下去你会懂的，虽说平日里我们都是 CRUD Boy，但是我们也得时刻保持着好奇心，要有求知欲和探索精神。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJLpLwbA9KPXiayib63ptKxheCE5OsVxHibUaibdChS7Vb6bpibMic7J6QsYoA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;320&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对了文末再送两本书。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;正文&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个故事得从「电」开始说起。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生活中电无处不在，而它却时刻保持着神秘感，为何插上电我们的屏幕就会亮？我们的服务器就能跑？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;电是如何来的？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;电起源于电子的运动，我们知道一切物质都是由原子组成的，而原子又是由中子、质子和电子构成。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.714859437751004&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJ2HwJPj8jZuFNZysJBW0fgZhLPkiccBh3lXntpJWDclRTJvGfJaC0nLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;498&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在某种情况下电子从原子中电离出来，这样电就产生了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;质子和电子都具有带电荷的特性，质子带正电荷、电子带负电荷。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而异电相吸，同电相斥，当质子数和电子数相等的时候是最稳定的，&lt;span&gt;如果数量不平衡也会往趋于平衡的方向发展&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像雷雨天气，云层下层积累电子而云层顶层失去电子，而闪电就是大量的电子迅速从一端转移到另一端产生的结果，为了趋于平衡。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;题外话 ：细心的朋友可能看到这原子核质子不都合在一起了啊，不是说同电相斥嘛？这是因为有个叫强内力的玩意聚集了它们，释放核能的原子核裂变就是由强内力导致的。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信大家都做过电池点亮灯泡的物理实验。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.42151481888035125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJicgx6aa60MZ1DAb6QR2Oc13hkvia6DRWq9EicxNkGRCd41W53LxhufjKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;911&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这其实就是电池发生化学反应，在负极产生多余的电子，然后通过回路中的原子类似接力的形式，一个原子得到电子之后会传递给相邻的另一个原子，如此循环传递电路就形成了，最终通过灯泡到达电池的正极。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改装下再套上个外壳，手电筒就这样被造出来了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而手电筒不仅仅可以用来照明，还能用来通信。相信大家都看过类似的电影场景，我这手电筒的光闪三下咱们就上！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而说到这样简易的通信就不得不提&lt;span&gt;摩尔斯电码&lt;/span&gt;，相信大家也从各渠道对摩尔斯电码有一定的了解，比如「星际穿越」这部贼好看的电影。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 19 世纪初期，那时候的远距离通信还得利用马车等工具长时间运输传递，人们一直在摸索即时远距离通信的方法。那时的摩尔斯就开始埋头实验，最终发明了电报。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;电报的思想和上述说的手电筒思想一样，手电筒通信的思想是通过开关来控制灯的亮暗，而电报利用的是电磁现象。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.43956043956043955&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJ4mJ79ogZvnFSsaOZXhm7VlcVRicFOyaRzpicdt71btoo4W25Ld2LkTVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;546&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将导线缠绕在铁棒上，然后通电之后铁棒就变成了磁铁，断电了磁性又会消失，然后再搞个发声器，通过磁性来吸引可动棒敲击发声。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.45555555555555555&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJP9vs73jnGnkWWJKdos4DQfhJNSibdpiaWyhHx539Z1icibYvfUCKW5xIMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;450&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通电后可动棒被拉下，敲击下方就会发出 “滴” 的声音，断电则可动棒复位，敲击上方发出 “嗒” 的声音。将快速的滴答作为点，慢速的滴答作为划。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过导线的长距离连接就能实现远距离通信，通过判别点和划的组合查阅摩尔斯电码表，转成最终的信息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.26913875598086123&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJ6fIRZr69nO0YFhOuLSS30sgYiaLDhru9r2BAcz58c0YZvZSiculRpt7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;836&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果要双向通信，就再搞一个反过来部署就好了，这就是电报机了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过导线是有电阻的，导线越长电阻越大，所以是有距离限制的，不过这难不倒我们，最简单的方法就是转发一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在中间距离也建个电报站，然后雇一个人，得到发送方的电报信息之后，重新敲一遍发送给真正的接收方，但是这需要多余的人力，所以可以如下图所示，&lt;span&gt;搞个棒子连起来带动下一个开关的输出&lt;/span&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2795275590551181&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJEeVCAJWbFhHs9BNEBGL8hNW6YYRAjJibfLwrvmmxSsk3Gqv1YGstCIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;762&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这其实就是继电器原理，我们来看看继电器是如何的设计的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6468531468531469&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJpKYU0m5YseyqSEEqfP3dxBUxjt4luvKCKcwfJOia1NxF0fkJqKgugdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;572&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下方通电产生磁力，吸引上方的金属杆挂下，然后上方形成回路因此也通电了，这样远距离传输的微弱电流就被又一次放大输出了，所以最终的远距离电报应该是这样的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.37753721244925575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJ8UnT7QwEJtpwyv9fqaK8lUxQ5xZnOeOJLQZtQWvrUhvaiaEpGSdpMkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;739&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到继电器这个发明是真的巧妙。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解了上面所述的电的生成、电报以及继电器之后我们再来看看&lt;span&gt;二进制&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于二进制的数字系统是最简单的，只有 0 和 1，不能再进一步简化了，而简单就代表着清晰，就像开关要么开要么关。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而二进制的组合又可以代表多种可能，比如第一个 0 表示男，1 表示女 ，第二个 0 表示胖，1 表示瘦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们再回到之前的电池电灯图中，这次搞两个开关。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5566343042071198&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJiakEltYHZxDEXxsWaMHjgmrnUOlibvmVoEwssUpoibr6pdsyPSxR5XOzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;618&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以得知两个开关都闭合电灯才会亮，如果转化成二进制表示，0 表示开关断开，1 表示开关闭合，0 表示灯泡不亮，1 表示灯泡亮，总结成一张表格的话就是：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这其实就是我们熟知的 AND 操作，如果把电路稍微改一下就是 OR 操作了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5803722504230119&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJmgRA8Kmn6CSJN88tKskv6xBXxJcoC0nwYp5UcnDZ1wgrSL7muJcSIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;591&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果把很多开关组合起来就能执行简单的逻辑任务，但是开关需要手动的去控制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记得之前提到的继电器吗？它也能串联或者并联电路，而且可以被其他继电器联动控制，不需要一个一个拨动，因此用继电器来组合更加合适，而继电器的组合称之为&lt;span&gt;逻辑门&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单点的就像下图所示，开关闭合灯泡就会亮。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3176470588235294&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJg1Ey03ialkCoN9obTcT4OtOCjPrtHjwCJceJhLJrs61ogicomn3EA0Ig/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;765&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些人觉得这不是多次一举吗，这其实是个缓冲器，可以延迟信号，也可以放大信号，而且这个电路比较简单，实际上有很多组合，比如下图的这个反向操作，开关闭合的灯反而不会亮。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4181222707423581&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJleyOUGjhyo4lf59kE8p53Oyb4OAn0brb7dI8ibBWdjLm8VLuSjjibZlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;916&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有像这样的串联组合，只有两个开关都闭合灯泡才会亮。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8672268907563025&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJiafeNDMK1VvOx2zKN1r9oL6nKu5qTgyics2bssutIWENQW8nMOvibx03w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;595&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这里的输入不一定得是开关，输出也不一定得是灯泡，只是为了更加直观的表现出来，不过这样画电路太麻烦了，于是电气工程师们就搞了个符号来表示这些电路，比如上面的串联其实就是 AND 操作，是与门。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.39072847682119205&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJIckhp6zG0hGGGScJN2U3boN4HQuTCawugNiceK9haUTvs0F4kKf6IRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;453&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简化一下上面的图就变成下面的样子。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.41743119266055045&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJk4tn8ibdsygzAjYRox8iajtmYI10ibUOLtXunR6xKPByecE65cJ33T2Cg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;436&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果电路图如下所示，就是并联，随便一个开关开了灯泡都会亮，这就是或门。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6341127922971114&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJHtu3BpdpUqpSQAL5iajXZiadL9g06PHzEBZdXdC7lYIdxpnI06G58eWA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;727&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简化符号是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.36186770428015563&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJlC0oczvl9zBLQxeia2DnIuwN4GQSdhHsQYR5RowNa6EEyLSrl8rMoBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;514&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面还提到个反向操作的，开关闭上灯泡反而不亮的叫反向器，符号如下图所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.35377358490566035&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJfiakFVoVWFfZ3BPyGKpTQsy6Ae1TJlCN0Q4bvIDFpibzy71g6Lmk3B2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;424&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看看这样的电路。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5777496839443742&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJEoeGxxy32s3PLn6MoZEZU0ZHI4RQll7W8QaSZ1VanWGZRAZlsx3Ptg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;791&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有当两个开关都断开的情况下灯泡才会亮，任何一个开关闭合灯泡都会熄灭，这个操作和 OR 操作相反，称之为 NOR 即或非门，简化后的符号比或门多了个小圆圈，代表反向。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4463768115942029&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJ7KOAPDBhoyY1unBaWrYkDq3tvLzRZ4CySaOgiaG6ATFyHNZtHNkiclAg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;345&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者这样，组合着画也一样。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.27607361963190186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJ9yX92ibN2a9doqobu9ge3ALrVc73T51bibUabHomVKy9b5CpvibjPlBaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;489&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们再来看看这种电路，只有两个开关都闭合才会熄灭，这和与门正好相反，称之为 NAND 与非门。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8281853281853282&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJDibDa3hSrKH6tlFWicUno4sqcSiadvzX1aiatwicNIlA4EPQ3KZP3o43iajQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;518&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简化符号是这样的，也是多了个圆圈：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.37017994858611825&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJv2JIEN8yHF2E4gTLwL2H9BK3MiaWmAc8mZH4agOJeib0pIzjYS0gS1NA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;389&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我再总结一下这几个简化图，加深一下印象。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.37453874538745385&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJzgWIoPraZfbUKN6hpZ5m3DwhxmPFcAPDiacfTxSC8LtvYdteJdxwic1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1084&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二进制加法机&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了上面这几样东西，我们就可以造个二进制加法机，不要小看加法，因为可以用加法来实现减法、乘法、除法等操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加法我们知道会得到当前的和、进位这两个信息，例如二进制中 1 + 1，当前和是 0 ，进位 1。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到只有 1 +1 进位 1 ，再仔细看看是不是和 AND 操作很像？只有 1 AND 1 结果才为1 。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看看当前和的计算&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家可以在脑子里面想象下，如果拿 OR 操作来套用的话右下角结果不对，如果是 NAND 操作的话左上角结果不对，所以得两个结合一下，电路图如下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.303236797274276&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJWib5iajLYQQtFERnRjNKHhf944wxcLAdU4T14WGNicIR5LObvuDia3CMcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;587&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分别通过或门和与非门之后再做与门，出来的结果就是当前和的结果，这个其实就是 XOR 异或门，简化表示就是：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.40816326530612246&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJ5hwr6JtYtibMwW33s5cBvkV9xQGBxHOIQdhvznjceurjmanYWmpA7XQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;392&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以加法需要通过两个逻辑门，分别是异或门来操作当前和，与门来操作进位，结合起来如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4139433551198257&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJvmEXR2EVTYzEmBSw4ym8NXk7cgm6ojcK0A0lRtaZ5sdEugY1UYvERQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;459&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这其实就是个半加器，简化的图如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.28859060402684567&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJlxH0Bqtx0hVBpUt89rs2GzNXztS6UcJhncyqNlQnQllc8oSu2XPPqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;447&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那为什么叫半加器？因为只能一位一位的加，而前一位的进位参与不到下一位的计算，如果要加入进位那下一位的运行就是 A 的当前位 + B 的当前位 + A 和 B 之前的进位。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此需要改装一下，两个半加器合起来再加一个或门。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2364341085271318&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJODUuibBGkbhLqDiah2wPNUCZ7phrYsy8AEyMxeXhPrIyNMOonH0RtUkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;774&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设 A 输入 1 ， B 输入 1， 进位输入 1，从最左边开始第一个半加器 S 输出 0 ， CO 输出 1，第二个半加器 S输出 1，CO 输出 0，最终和输出 1，进位输出 1，结果没毛病可行，这叫全加器，简化一下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.30303030303030304&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJ36dvZhHdch4ibRqqzgCm7n2hnbJ6hx5icLL8YKibuTs4nZfAzicvib0JALg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;495&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;全加器有了，咱们得组合起来，并且需要有输入和输出，我们通过开关来输入数字，由灯泡的亮暗显示结果。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3789954337899543&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJEtdVdj7HwjfvB4zebfJo2lurwGSpu4MX7QEGk8zs1Daffzhf1QqOibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;657&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是一个 8 位的计算器，有 9 个灯是因为两个 8 位相加结果可能是 9 位。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后从最右边开始如下图所示接上全加器，进位接地表示 0 输入&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4675324675324675&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJnvSPKxHvL84wmcaicVryqCEbH2vuLF1JjQ6BA8DT09XrmKnugMHWOkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;539&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;中间的都如下接法，前一个的进位输出是下一位的进位输入。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.374496644295302&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJhHUeIW2LN4d4uScYvE41M6diclDqzDyut7hu0ibUxTOJxibanTqYvNQMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;745&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后一个就是把进位输出直接接到第九个灯上就行了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.37997432605905007&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJEViaiah4xuv60Jk76hwQBdUibTeicUhyhlAApnRaz7JJqW8y6GKkat5TZg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;779&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时你摆动控制面板的开关，就可以通过机器得到相加的结果。简化的画法如下图所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5111111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJSUHVvsQIahKic84PDKAllAdFib8ZtTDsOeEpwdQAEDknDtVGibV59HzLg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;405&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们已经造出了八位加法器了，如果要 16 位呢？简单合一下就好了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4855195911413969&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJOLEFD8TGExLfibeYPSw70EC7Ib0S6Rp2DY4ic7oHfcj3mBiaZ9ACdZ3Qg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;587&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然真实的计算机原理差不多是这样的，不过会更复杂，比如不会像我们的加法器，一个一个的进位加，而是会先行进位，而且也不会用继电器，而是晶体管等等。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;减法怎么弄？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加法器我们搞出来了，那减法怎么做？减法需要有借位操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先拿熟悉的十进制来说。假设你的账户上限是499，你的透支额度是500，也就是说你的账户金额范围是 -500~499 这 1000 个数字，&lt;span&gt;要求不能用负号来表示。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到这是个三位数，而最大值就到 499 过，说明 500~999 之间的数没用，那拿来表示负数不就刚刚好吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以让 500 表示 - 500 ，501 表示  -499，以此类推。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;500,501.......998,999,000,001......498,499&lt;/code&gt;，&lt;span&gt;让5、6、7、8、9开头的数都代表负数&lt;/span&gt;，而且是不是看起来还形成了个环形， 499 + 1 就变成 500 了，然后 999 + 1 变成 1000 ，但是只能三位数表示，所以溢出了变成 000。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种处理叫 10 的补数，如果要把三位负数转为 10 的补数，就是让 999 减去它再加一，也就是说 10 的补数等于 9 的补数加一。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;补数的概念：拿 9 的补数来说，将一个数从一串 9 中减去得到的结果就叫这个数 9 的补数，比如 123 ，它是三位数 ，999-123 = 876 所以 123 的 9 的补数就是 876，如果把结果 + 1那就是 10 的补数了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就拿 -499 来说，我们要转化成补数，就是 &lt;code&gt;999 - 499 + 1&lt;/code&gt; 等于 501 ，看上面的排列确实用 501 来代表 - 499。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那减去一个数不就是加上一个数的负数吗？所以&lt;span&gt;通过补数我们就不需要做减法，只需要转成补数再相加就行了！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在我们再换成二进制，二进制相比于十进制就更简单了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拿八位二进制数来说，范围是 00000000~11111111， 对应的十进制是 0~255，但现在我们想让它能表示负数，前面十进制的时候我们将 5、6、7、8、9开头的正数来表示负数，对应于二进制我们可以将第一位以1开头的作为负数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那此时的范围就是：&lt;img data-ratio=&quot;1.4400977995110025&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJdYRSdOwpQbHNibmcETxDwpiaMIzBMMibiamwpJbibtJLickib8DNIbYWWZNPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;409&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你理解了上面的十进制转化，这个二进制肯定是没问题的，这其实就是算出 2 的补数，而 2 的补数又是 1 的补数 +1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们拿 125 来举个例子，125 二进制表示是 01111101，求 1 的补数就是 &lt;code&gt;11111111 - 01111101&lt;/code&gt;，这个减法在二进制中不需要，因为这其实就是求反，还记得上文提到的反向器吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;取反了之后再加一，就得到 2 的补码。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8537074148296593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJ7MvPgCuib0d8OKiazn58GzZ6p19icDmQZSvL8vtUCeD2gGmUvRDpUzfoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;499&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以  -125 就是 10000011。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这一切的前提都是数字的位数需要固定，所以计算机中的位数就是固定的，超出了就会溢出，到这里你应该可以理解计算机中的补码是怎么来的，而且理解了为什么最大值 +1会变成最小值？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以减法我们只需要改造一下上面的加法器，给个开关表示要这个数是负数，如果是负数则进行一波反向器操作然后再 +1，之后再进行加法操作即可得到最终的结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;乘法和除法我就不分析了，一样也能通过加减法来实现。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;振荡器(时钟)、锁存器（触发器）和计数器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这个和我们所认识的计算机还差很多，现在只能进行一些非常简陋的加减操作，别急我们先来看看这个电路。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48606271777003485&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJcz8Do7ibibtxrsuY4VMVhvmpSOQylbtuHuRxwJypjofPFoJv6mMcxvgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;574&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个电路很有意思，当你闭合开关的时候电路通了，此时由于电磁效应可动棒被吸了下来，电路就断了，断了之后磁性消失了可动棒又移了上去，这样电路又通了，&lt;span&gt;如此往复&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种电路叫振荡器，这是一个很关键的东西，记住它。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的来回振荡其实就是在输出 0 和 1 的交替序列，画成图如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.20441988950276244&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJlXCLpgtibYqsoBtyUmhof7b2FQ7cZ3DLpcx22460yahbR5iaCxXhsrlQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;543&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着时间的变化在 0 和 1之间交替变化，&lt;span&gt;因此也称之为时钟。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个变化循环所需要的时间称之为周期，频率是周期的倒数，如果周期是 0.05 秒，那么频率就是 20，每秒 20 个循环，用赫兹来作其单位，所以就是 20 Hz。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看下这个电路。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.33591331269349844&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJQd5o9GVTvUNUia0eMyKQZaGZhIPdYsruzx0sajaISO9SPyo1lXz1AUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;646&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时灯泡是不亮的。当上面的开关闭合后，左边的或非门输出 0 ，右边的或非门输出是 1，因此灯泡亮了。&lt;span&gt;神奇的地方来了&lt;/span&gt;，此时你断开上面的开关，灯泡依然是亮的，因为左边的或非门输出还是 0，而或非门只要有一个输入是 1，输出就是 0 。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.21075085324232082&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJhj0JJqtzXzL1BH86tOlhfSBOx9cxvCrBNal9kAIfXqwEEzzSGia8sIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1172&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时如果闭合下面的开关，灯泡就会熄灭，再断开下面的开关灯泡仍旧不亮。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1808695652173913&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJaUdPWf4weXniaSZ1x1BXc9QHIBZ21lWWxEdvICNyZbQlibfODJqjJPibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1150&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到这个电路是有记忆功能的，你看如果你发现此时的灯泡是亮的，你就能推断上一次闭合的是上面的开关，如果此时灯泡是暗的那么上次闭合的就是下面的开关！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这种电路叫触发器&lt;/span&gt;，其实上面的开关就等于置位(set)，下面的开关等于复位（Reset），所以这也叫 R-S触发器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不过更有用的电路应该能记住某个特定时间点的上上一个信号是 0 是 1&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以还需要搞个保持位，使得保持位关了之后，上下两个开关随意拨动都不影响之前保持结果（下面的图复位和置位位置和我们电路图是相反了，不过没影响一样的）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.43524416135881105&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJAqI6eGVhpf2Y3G0x9VzrNWlXDeuf29xsSuWHD2I4J38hvx3GKDL7uw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;471&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实就是当保持位 0 的时候，复位和置位通过与门的输出肯定是 0 根本影响不到之前的结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这样就有三位输入了，比较麻烦。从上面的观察来看有意义的输入其实是上面开下面关，或者上面关下面开，所以一定是相反的。所以搞个反向器这样就只有两个输入了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3993174061433447&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJWkgtpD5paT0kiccCN32JW6ia6iauCcNOlp1a7NejmgPnibO3tSCuP1B9nQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;586&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个叫电平触发的D型触发器&lt;/span&gt;，D表示 Data，数据的输入。电平触发就是当保持位为某一个特定电平时 （例子是 1），触发器就会保存数据端的输入值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解了保持位之后，我们需要引入时钟（标志为 clk），一个有规律的来回变化的时钟，当时钟从 1 切换到 0 的时候上一次操作的内容就被保存了，所以把保持位的输入替换成时钟输入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的电路叫做电平触发的D型锁存器，它表示电路锁存住一位数据，并保持到将来使用，它也称之为 1 位存储器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了 1 位存储器，那多位存储器就很简单了，就是将多个锁存器合在一起，如下图是八位锁存器。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3760330578512397&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJ6ISHdpRLmlgFHGwQrLG3Yzb0gtMDlmFVscRK9YEPMj7oDZS82fd9IA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;484&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里还需要提一下边沿触发器，不同于电平触发器的是&lt;span&gt;边沿触发器是在 0 变成 1 的瞬间记录结果&lt;/span&gt;，像电平触发器是在 1 的时候每个结果都会被覆盖性的记住，在某些场景下边沿触发器的瞬时性更合适。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;电路图如下，由两级 R-S 触发器链接而成，其实这种电路看不的很乱觉得很复杂没事，知道结果就行了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4283783783783784&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJkTSgBtvJuuPMPUSXpPo7Wd6hgWzgM9VuibyH8BEjXVUJgrzvETyeUCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;740&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简化的画法如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4649122807017544&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJE0JxlickF08icQWBWB5oqaicGUOM3fVuLZO6uicnQibvJd7Xo7TzqdUicRGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;228&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们再来看下这个电路：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4005167958656331&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJC44iah0yHddwJ2h66ZXweYUTYrPJePLOn1LB5eQFQkqiaN0T824IwxnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;387&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将振荡器的输出作为时钟的输入，然后反向 Q 端(上图中下面的Q代表反向Q，图少了一横)的输入又作为 D 的输入。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.36229205175600737&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJgRHeqQmu4NrqWab5vJhj3WygianAaeLHAHKWw4UH9Zt1LKL7pBLyngg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;541&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出来的波形图是这样的，可以看到 Q 的输出频率是时钟的一半，所以&lt;span&gt;这种电路称为分频器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而分频器的输出又可以是下一个分频器的输入，我们再来看下这个图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3284403669724771&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJNQPkmC97lfsr0PJVzcB99hecyzZJsmSYMKeoOzMwp52FW1tXW4ts7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;545&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;出来的波形图是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3721633888048411&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJJliaNwKa0zOWKMPtaQ6bF1P4pTrbicSmxpxg1xgy2icILfelOC7XTFjwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;661&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再填上 0 和 1：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3652694610778443&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJic650icozQS8IWbTGrMA3FaiaumU0cXEAKOgOnjuyMrJ7YagicG0ZnVoXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;668&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 Q3 开始每一列从下往上看，是不是 0000、0001、0010.... &lt;span&gt;这就是计数器&lt;/span&gt;，把 8 个集成一下放在黑盒中，就构成了 8 位的计数器。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3271186440677966&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJne8qZRyPQBvnemL7qKlXyhCnqLwy1lNVGRTxP2Qb2wO0chq3cdVVcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;590&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这个计数器是异步的，后面的得等前面的通知，比较不准确，所以更好的是同步计数器，不过比较复杂，这里就不介绍了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;简单组装一下&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此我们已经有了加法器、振荡器(时钟)、锁存器（触发器）和计数器，接下来我们就开始组装一下它们。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如现在我们有一个灯泡，想测试一下八个锁存器，八个锁存器的话那么需要 3 个开关来表示具体选择哪个锁存器，2 的 3 次方等于8。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.583232077764277&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJdKZNIb5CKbSegiaKuFV1dfibTZdLIYJWWXPAwEVVLcnqHmedY6ebrlibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;823&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;中间的黑盒肯定是拿来选择的，通过开关来控制通路，比较复杂我觉得稍微看看就行，反正就是电路选择。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3384879725085911&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJKI83icqN0kQZ3IgtN3n1k8KF9ZqhQjaGvTPgFIfu3IBJUMmcfSGaLkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1164&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输入的话也不用直接用八个，所以也搞个三个开关。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5479651162790697&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJmnST3Rm8uMkyy2PzIn0bd8LFhRaq7icicO56lt0Ksgzv398tjmCIgu8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;688&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内部构造我就不贴了，也和选择器一样复杂，这叫译码器，最终完整电路图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7004608294930875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJovPObCAhSxa2c3SQnheYvYal7RvtT7fSt5PAknWW8dXFxz7JWfhkKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;651&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而是S0、S1、S2 其实就是&lt;span&gt;地址&lt;/span&gt;，通过地址来选择写入哪个锁存器中，并且对应输出结果，&lt;span&gt;这种配置叫读/写存储器，也称为随机访问存储器即 RAM&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因为它能保存信息，所以叫存储器，因为能根据地址选择来写入读取所以是随机。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图电路简化图如下，能存储 8 个独立的 1 位数据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34791252485089463&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJSKiaxqjMQcHVHia9KiaFz6EZWrUZwv186kYDGzSlAbicvAexGjuibUzOCGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;503&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两个 8*1 RAM 结合一下就能表示存储 8 个独立的 2 位数据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5486322188449848&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJ2RUMx2DDztjV00ZQydJsPk5l3VWIG4QYgcvhZovUXK7rqG3Qwia4fxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;658&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是通过下面这样的组合，则能表示 16*1 RAM，那个 DI 其实就是第四根地址线，所以是 2 的 4 次方。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8029801324503312&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJ6NceSqkZGfZXBwTZfnksyBjIhQAjxI6ZoCcMEMwf50JOgUwIk8thKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;604&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到 RAM 阵列的存储容量等于 2 的地址数次方，然后注意下我们图是简化了的，里面其实有很多继电器的，像逻辑门都是由继电器构成的，当断电之后电磁效应就没了，所有的触点都回归原样，&lt;span&gt;这就是 RAM 为什么是易失性存储介质的原因。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;咱们现在已经把内存给搞出来了&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们的目标就是把要计算的数据输入内存中，然后让加法器计算了之后把结果写回内存，并且可以再通过内存查看结果，大致的组装样子如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7043478260869566&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJC7XA0CNYM3khRaQU6EEs4pdThjOyBZehtPItq1JbvibOG2mhCpngwSQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;690&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们可以将加法器和锁存器结合起来作为一个累加器，即每次加法的值存储到锁存器中并作为下一次累加的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了累加器之后，我们可以将存储器的值传到累加器中，称为 Load 装载，把下一个值添加到累加器中，称为 Add，然后将结果保存在某个位置，称为 Store。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过&lt;span&gt;控制面板先往存储器里面写好要操作的值并且可以通过控制面板上的灯来查看内存写入结果，然后一开始访问存储器的地址为 0000，由计数器来驱动地址的前进，然后进行相加，最终将结果存储回 RAM 阵列中，当然也需要设置停止信号&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把我们前面定义的 Load 等操作码，转化为特定的代码来控制整体的流程（你就认为这代码会指示电路做某种操作，没必要细想反正就是通过逻辑门组合产生的）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6791208791208792&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJ12vJFSp4lQILREs3Bdll0YiaDZd0mTiahQ3VuK8O23QjeHgu3HXj4mwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;455&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个操作码仅是个助记符，因为地址是固定的，并且操作码指令字节是固定长度（1个字节），所以我们可以在每条操作后面跟上地址，总的而言每条指令（除停止）需要 3 个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单的看下图，就是在存储器地址0000处存入以下“代码”。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5388059701492537&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJPqy0lrBiayyx3nw7SxmWIJgPiaGy3seES5xiaplXaxTTialzicYAbfuMedg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;670&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且可以搞个 Jump 指令用来跳转地址，可以通过设置计数器来达成跳转地址的功能，有了跳转我们就能做循环操作了。某些重复的指令只需要编写一次，通过条件跳转来完成循环，最终的组装示意图如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7255909558067831&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJ69L8IRWMicyDJDKNR3gcvv0HdW5eWxEicaibqNSF5OzomLJ7iarAKuL80Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;973&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2-1 选择器是切换计数器的地址输入或者是计算得出的输入，通过三个 8 位锁存器来分别代表代码，地址高位和低位，上图来看可能有点绕，不理解细节也没有关系，大致的流程还是简单的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至此我们其实已经组装了一台计算机了，之所以能叫计算机而不是计算器是因为它可以根据你写入存储器的指令自动取指执行，并且可以进行条件跳转和循环执行自动停止。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算机的处理器就是我们上面的累加器，可以称之为算数逻辑单元，即 ALU。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那个计数器就是我们的程序计数器PC。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;存储器就是内存了，输入就是控制面板，输出就是控制面板上的灯。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算机几个核心模块就都有了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于前面我们定义的操作码其实就是机器语言，而人类为了好记就会搞一些助记符来标识，发展到后来就是汇编语言，而汇编语言又太麻烦了，因此又抽象搞了高级语言，比如 C、Java 等等。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章最终所描述的计算机其实是相当简陋的，真正的计算机也肯定不会这样造的，比如不会用继电器，线路也会用各种总线啥的搭建起来各种集成电路等等，ALU 也不会如此简单，会有各种并行计算等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要是想借此大致的说下计算机基本的运行原理和构成，因为本质上的道理是一样的。如果要我把很多细节都说出来我也不会，我也就懂一点点点点皮毛，我也不是搞硬件的，啥模电的课我也没上过，我就会装装机的水准。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文大量借助了《编码的奥义》一书的例子，或者说是对此书一些章节的梳理和总结，如果对原文有兴趣的可以自己购买书籍，如果觉得囊中羞涩可以后台回「233」，我来帮你想想办法。&lt;/p&gt;&lt;section&gt;&lt;mp-qa class=&quot;js_uneditable custom_select_card qa_iframe&quot; data-pluginname=&quot;insertquestion&quot; data-id=&quot;1552322465014611968&quot; data-bizuin=&quot;Mzg2MjEyNTk1Ng==&quot; data-title=&quot;兄弟萌，怎么说？&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;送书&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我又来给大伙送书啦，这次联合电子工业出版社给大伙送两本《Spring Boot 实战派》，感谢电子工业出版社。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;2.1657407407407407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJTZP4dOQUdC4pYgDggcRfsEaBMzNic147O4LKt1YDVlUgo2J2WegrlpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有两种方式可以获取：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一种后台回复「666」即可抽奖，无套路简单粗暴。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二种点击文章右下角的&lt;span&gt;「&lt;/span&gt;在看&lt;span&gt;」&lt;/span&gt;，我到时候搞个随机数抽取，当然这个前提是你得加我好友，不然我看不到在看（目测这个参与的人少，中奖率高）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;10月10号19点开奖，两种方式可以任选一个也可以都参加，各凭喜好，任君采劼，当然不差钱的哥们可以自己买~&lt;/p&gt;&lt;section&gt;&lt;mpcps frameborder=&quot;0&quot; class=&quot;js_editor_cps&quot; data-datakey=&quot;1602117607863_0.6739263230202952&quot; data-uid=&quot;1602117607861&quot; data-type=&quot;1&quot; data-product=&quot;&quot; data-templateid=&quot;list&quot; data-pid=&quot;28488616&quot; data-categoryid=&quot;3&quot; data-appuin=&quot;3084391334&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对了，最近搞了个群，到时候可以搞个各大厂内推啊啥的，如果想进群就&lt;span&gt;备注下进群&lt;/span&gt;，我拉你。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1018711018711018&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJia3uojrYUyxpIO8UI1Z51hbYJzn7munuEJBm7yFx3dc97ZJcRosT9xQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;962&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>843632b534ca79d6c33758d6b6484653</guid>
<title>[推荐] 怎么排查 CPU 飙升</title>
<link>https://toutiao.io/k/rq3wyhs</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1&gt;&lt;span&gt;怎么排查CPU飙升&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;线上有些系统，本来跑的好好的，突然有一天就会出现报警，CPU使用率飙升，然后重启之后就好了。例如，多线程操作一个线程不安全的list往往就会出现这种现象。那么怎么定位到具体的代码范围呢？今天笔者就教大家一个小技巧&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;&lt;span&gt;代码准备&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;这次，笔者准备了一个demo代码，大致线程模型是这样的:&lt;img data-ratio=&quot;0.44745222929936307&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7ICuYI5fFbIIaXAlQFQ9tVtn0k5kS3CUIY0mEMwqGaAI4CUEyl68pEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1256&quot;/&gt;&lt;/p&gt;&lt;p&gt;代码下所示:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;public class CpuHighExample {&lt;br/&gt;&lt;br/&gt;    public static void &lt;span&gt;&lt;span&gt;cpuHigh&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        final List&amp;lt;String&amp;gt; list = new LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;        Thread thread1 = new Thread(new &lt;span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;            @Override&lt;br/&gt;            public void &lt;span&gt;&lt;span&gt;run&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;                int count = 1;&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;                    // 构造thread1为消耗很高cpu的线程&lt;br/&gt;                    count = count + 1;&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        thread1.setName(&lt;span&gt;&quot;thread1&quot;&lt;/span&gt;);&lt;br/&gt;        Thread thread2 = new Thread(new &lt;span&gt;&lt;span&gt;Runnable&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;            @Override&lt;br/&gt;            public void &lt;span&gt;&lt;span&gt;run&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;                &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;                    try {&lt;br/&gt;                        // 构造thread2为消耗很低cpu的线程&lt;br/&gt;                        Thread.sleep(1000);&lt;br/&gt;                    } catch (InterruptedException e) {&lt;br/&gt;                        e.printStackTrace();&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        thread2.setName(&lt;span&gt;&quot;thread2&quot;&lt;/span&gt;);&lt;br/&gt;        thread1.start();&lt;br/&gt;        thread2.start();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span/&gt;&lt;span&gt;案例运行&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;这个案例一运行，就听见笔者的电脑风扇起飞了，呼呼作响。直接top一下&lt;img data-ratio=&quot;0.27223230490018147&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7FtpGMeoqxWeUe09Hiaupmk6AB12ux7T8RUsiclic762iaQV8zU1u3789rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1102&quot;/&gt;&lt;/p&gt;&lt;p&gt;果然是java进程，占用最高，CPU 100%了(占用了一个核),而其PID是2717，正是我们跑的例子。那么下一步，我们就需要定位到底是那一个线程在耗CPU&lt;/p&gt;&lt;pre&gt;&lt;code&gt;top -H&lt;br/&gt;Threads toggle&lt;br/&gt;            Starts top with the last remembered ’H’ state reversed.  When this&lt;br/&gt;            toggle  is  On,  all individual threads will be displayed.  Other-&lt;br/&gt;            wise, top displays a summation of all threads &lt;span&gt;in&lt;/span&gt; a process.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如man文档所描述,top -H可以打印出线程信息，我们就top -H一下。&lt;img data-ratio=&quot;0.3611111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7gVWF29FYqvsdgCp0SxRbAHsuYlcGib6Ow25t2iaqoZqSaoKFSNEuIQUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;图中可以看到，占用最高的线程PID是2727,同时线程名是thread1。&lt;/p&gt;&lt;h2&gt;&lt;span/&gt;&lt;span&gt;继续jstack&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p&gt;我们知道jstack可以dump出jvm所有线程运行的快照，然后我们就可以通过刚才获取的PID去定位到jstack那个进程。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 注意，这边用top出来的进程号2717,而不是top -H出来的2727&lt;br/&gt;jstack 2717 &amp;gt; 1.txt&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于jstack打印出的线程号是以16进制的形式表现的，所以我们对2727的线程号做一次转换,得到aa7。&lt;br/&gt;&lt;img data-ratio=&quot;0.3513203214695752&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7Z1MYNZ7AngNmNOmfdOia7SGcP0W6zPLy29iaibDJjZTX1tp2qTJRibCf1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1742&quot;/&gt;&lt;/p&gt;&lt;p&gt;然后我们在1.txt中搜索2727,这里用的是less然后进去后搜索，而不是用grep。因为这样比较直观的能看出之前和之后的信息。less下&lt;img data-ratio=&quot;0.06093189964157706&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7k1icZP2z0uBTfeOhUUcV1YGL8dRA0XFNNqUaWTy4WrqN8dJJOK9Q2tg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1116&quot;/&gt;&lt;img data-ratio=&quot;0.27797202797202797&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7qGiaETjUfibeysR1DjicW6Hu1ib8Gbicy0IBD090xFA9eHoLjsd2OFM2UuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1144&quot;/&gt;&lt;/p&gt;&lt;p&gt;我们找到aa7后，就直接能发现代码一直跑在CpuHighExample.java第19行上面。&lt;img data-ratio=&quot;0.35304990757855825&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7icibozct5NMOfl5X1b5Q9pEYfEF1VCKJfstRQLEEr3m4sum5ntxdeozg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1082&quot;/&gt;&lt;/p&gt;&lt;p&gt;当然了，我们需要多jstack几次，如果每次jstack出来都刚好在这段代码左右，那么基本可以证明，是这段代码导致CPU飙升了。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;CPU突然飙升这个问题，我们很容易通过top -H和jstack找到对应的代码范围，这无疑极大的缩小了我们的定位范围。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.359781121751026&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yiaiaFLiaflYRSvxbPzBLMVugjJkyf5OrZ7x75CliawsSwbWnz6VZu2PrSTxAfA1Bl6MN5VdbWG06xzJzllCqZWPBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1462&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>