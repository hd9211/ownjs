<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1105f2d72fce32c238bcffed38e431fd</guid>
<title>[推荐] 网易云音乐基于 Flink + Kafka 的实时数仓建设实践</title>
<link>https://toutiao.io/k/rtixudv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c19c13967ef4564c5a9667d045b48dc3</guid>
<title>[推荐] 好的自我介绍，面试成功一大半</title>
<link>https://toutiao.io/k/lpyu6km</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p data-tools=&quot;西瓜插件，运行于电脑浏览器上的插件，可在公众号后台找优质文章素材，一键美化排版，检测文章违规，查看任意公众号粉丝阅读数&quot; data-label=&quot;Power by：chajian.xiguaji.com&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;这里是Z哥的个人公众号&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;每周五11：45 按时送达&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;当然了，也会时不时加个餐～&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;我的第「164」篇原创敬上&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;大家好，我是Z哥。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;关于面试时的自我介绍，我想大家遇到的情况都差不多，大部分面试的第一个环节基本都是这个。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;每个人也都知道留下好的第一印象很重要，但我估计很多人对这件事的解决方式，也就在网上找个自我介绍的模版就完事了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;先不说你找的模版会不会过于普通，导致面试官听到的千篇一律。更重要的是，如果你搞不清楚自我介绍背后的深意和价值，哪怕是套用模版也只是学了它的“形”而没学到“神”，效果自然不会太好。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我做面试官也有将近6年时间了，不管是从我自己的感受还是与其他面试官的交流后得到的信息来看，自我介绍环节能让人有惊喜的，只要后面不太“拉胯”基本都能被录用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;心理学中有一个概念阐述了这背后的原因——「&lt;/span&gt;&lt;strong&gt;&lt;span&gt;首因效应&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;」，由美国心理学家洛钦斯提出。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;71&quot; data-source-title=&quot;维基百科&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;首因效应是对“第一印象”或“先入为主”所产生的心理学现象，指在行为过程中，最先接触的事物会给人留下深刻的感知或认知，影响人对事物的感知和判断。&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;blockquote_info js_blockquote_source&quot; data-json=&quot;%7B%22type%22%3A%22out%22%2C%22source%22%3A%22url%22%2C%22digest%22%3A%22%22%2C%22digestLen%22%3A71%2C%22text%22%3A%22%E9%A6%96%E5%9B%A0%E6%95%88%E5%BA%94%E6%98%AF%E5%AF%B9%E2%80%9C%E7%AC%AC%E4%B8%80%E5%8D%B0%E8%B1%A1%E2%80%9D%E6%88%96%E2%80%9C%E5%85%88%E5%85%A5%E4%B8%BA%E4%B8%BB%E2%80%9D%E6%89%80%E4%BA%A7%E7%94%9F%E7%9A%84%E5%BF%83%E7%90%86%E5%AD%A6%E7%8E%B0%E8%B1%A1%EF%BC%8C%E6%8C%87%E5%9C%A8%E8%A1%8C%E4%B8%BA%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E6%9C%80%E5%85%88%E6%8E%A5%E8%A7%A6%E7%9A%84%E4%BA%8B%E7%89%A9%E4%BC%9A%E7%BB%99%E4%BA%BA%E7%95%99%E4%B8%8B%E6%B7%B1%E5%88%BB%E7%9A%84%E6%84%9F%E7%9F%A5%E6%88%96%E8%AE%A4%E7%9F%A5%EF%BC%8C%E5%BD%B1%E5%93%8D%E4%BA%BA%E5%AF%B9%E4%BA%8B%E7%89%A9%E7%9A%84%E6%84%9F%E7%9F%A5%E5%92%8C%E5%88%A4%E6%96%AD%E3%80%82%22%2C%22article%22%3A%7B%7D%2C%22hasReportOverSize%22%3Afalse%2C%22editorReportData%22%3A%5B%7B%22id%22%3A%22122333%22%2C%22key%22%3A%2276%22%2C%22len%22%3A1%7D%5D%2C%22from%22%3A%22%E7%BB%B4%E5%9F%BA%E7%99%BE%E7%A7%91%22%7D&quot;&gt;&lt;span class=&quot;blockquote_other&quot;&gt;维基百科&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;那么我们如何能够把握住这个机会，借助「首因效应」让你在激烈的岗位竞争中占得先机呢？自然就得做好自我介绍的准备，下面我就来分享一些我的经验。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/01  自我介绍的意义/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;很多人都会告诉你，自我介绍是你主动展示自己更多信息的机会，所以自我介绍的时候要讲一些简历里没有提到的内容。这个方式没错，但是思路其实不完全对。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;阐述一个残酷的现实，面试你的面试官不一定就是筛选你简历的人，大家平时工作都很忙的，他很可能没有看过你的简历。所以自我介绍环节不但是你主动展示自己的机会，也是让面试官现场评估你简历的“刚需”环节。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以重点来了，你脑子里一定要有这样一个画面：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;我在向一个一心二用的人做自我介绍&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在这个场景下，你的终极目的是：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;提醒他注意到你的亮点，以及为什么适合这个职位&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;知己知彼才能百战不殆，那么对于面试官来说，除了获得了一个熟悉你简历的缓冲期还有什么意义呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;破冰。两个陌生人之间建立良好沟通的方式永远是开放性问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;初步判断你的沟通能力。在一个组织协作的中，1对1的对话是常见的场景，能不能把话讲明白决定了你未来与他人一起共事的能力下限。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;初步判断你的逻辑能力。通过你自我介绍阐述的内容顺序、结构，判断你的逻辑能力如何，是有条不紊的、还是混乱的。这决定了你未来做事能力的上限。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;判断你的可塑性。这个大多数时候只是一种感觉，感觉从何而来？除了语言外，你的表情、眼神等肢体语言也能传递出相关的信号。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;搞清楚了自我介绍的意义，那么我们就可以提炼出一些要点了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;/02  六个要点/&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;01&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&lt;strong&gt;时长控制&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一般来说，好的简历最多不超过3页A4纸，所以自我介绍不用准备的太长。因为面试官熟悉完你的简历后基本上就要准备发问了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;大多数人快速阅读一页A4纸的内容大概也就1分钟，所以我建议自我介绍的时长控制在（简历页数*60 + 30）秒左右。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如，你的简历是3页，那么就是210秒，3分半；2页是150秒，2分半。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你是职场新人，那么最好能多准备一段1分钟左右的精简版，以防群面的时候做自我介绍。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;02&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&lt;strong&gt;内容构成&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先大家都知道的一点是，不要重复复述简历上的个人介绍，这就不多说了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外需要注意的是，不同的工作时长自我介绍的侧重点应该是不同的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如你作为一个拥有8年丰富工作经验的人，做自我介绍的时候还在花不少时间突出自己学习能力强、抗压能力强，其实反而会起反面效果（实际这样的人还不少）。而更应该突出自己解决问题的能力和所创造的价值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于不同资历的人需要阐述的内容组成，我大概划分了三个维度做了一个表供你参考，三个维度分别是：行业经历、业绩体现、可塑性。你在准备内容的时候可以参考这个比例来。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.410958904109589&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oB5bd6W6hI1YM0H3SbSu8C7sic16c1JslJOpa23NQ6oBgCQR9plLChJOWgXcvt58R9dzW4wYCmI2YMmkAD78CRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1022&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;如果你对自己的能力有自信，也可以提高一级来写。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;03&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&lt;strong&gt;精简内容&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;具体的内容信息就像写作文、写报告一样，内容太拖沓，会让人觉得你的逻辑不清晰，概括能力差，没有重点。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;要知道，对逻辑能力的印象其实就是在别人眼里你是不是一个聪明人。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，尽量把不影响信息完整性的那部分文字删掉，比如一些空话（只说自己学习能力强，并不举例），一些修饰性形容词什么的。然后再把剩下的内容按照某个顺序组织起来，并且要把why和how讲清楚。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;04&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&lt;strong&gt;量化相关指标&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;数字自己会说话，能量化的地方尽量去量化，这样可以减少很多冗长的文字描述。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;05&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&lt;strong&gt;注意做好内容承接准备，不要给自己挖坑&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;很多时候，面试官在你的自我介绍中发现了一个亮点，他后续会基于这个亮点展开来向你提问。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，在自我介绍部分你千万不能吹牛，不要把别人的业绩说成你的，否则面试官问你是怎么做到的，具体的细节是什么？你却支支吾吾的，那基本就要请你回家了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;06&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;&lt;strong&gt;语气不要过于谦虚&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这点对有一定工作年限的小伙伴非常重要。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;职场新人谦虚一点也可以理解，但是作为老人，如果过度的谦虚，会让人觉得，你要么不够自信，在以后的工作中会出现沟通不畅的问题；要么是自身能力达不到你阐述的和简历上写的，心虚。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;好了，意义和要点都清楚了，那么具体该怎么准备内容呢？你可以试试&lt;/span&gt;&lt;strong&gt;&lt;span&gt;「PME」框架&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;「PME」中的三个字母分别表示热情（Passion）、匹配（Match）、出众（Excellence）。思路是，先展现出你对这个行业、这个岗位的「热情」，然后证明你是「匹配」这个岗位的，最后再亮出自己「出众」的地方说明比其他候选人更棒。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;体现Passion，你可以从下面三个方向入手：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你对该领域有深入的体验或研究&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。比如说你就读的是计算机相关的专业、学习过十几个「某时间」的课程等、看多二十多本XX领域的书。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;你时刻关注该领域动态&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。比如说你经常浏览XX网站、XX社区，会对各个大厂新出的框架花几天时间去折腾一下。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你的兴趣爱好相近&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。比如你平常会写点东西，会把所学到的知识重新整理后发表在自己的博客上。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;体现Match，需要从你过去的经历中做两件事情：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;体现Excellence就是做好一点：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;用数字量化&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。比如，你通过引入了某个技术框架，并做了二次改造，使得某个系统的负载上限提高了3倍，资源消耗降低 了50%。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;体现Excellence是最后一部分内容，也是最重要的内容，因为这里说的内容是在表达你比别人牛逼，所以&lt;/span&gt;&lt;strong&gt;&lt;span&gt;很容易成为面试官接下去发问的点&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，不过你这也是一个你引导面试导向的一个机会，所以要把握好。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后来举个例子，感受一下。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;212&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;我叫 XX，就读于 XX 大学 XX 专业。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;我每周会写博客，会将当周从书本或者「某时间」的课程上学到的知识进行整理，并用自己的语言写出来分享给所有人，对软件开发行业充满兴趣。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;我了解到贵公司有对分布式系统方面的要求，恰好我在上一家公司的系统就是分布式的。我在其中工作了3年，主导过多项核心技术的落地。比如在XX年，我引入了XXX框架并做了二次改造，使得某个系统的负载上限提高了3倍，资源消耗降低 了50%。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;所以对于胜任当前的岗位很有信心。&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;好了，以后可千万不能再做下面这样的自我介绍了哦。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;98&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;我叫 XX，就读于 XX 大学 XX 专业，之前是 XX 公司的高级软件工程师。我在该公司负责的工作是A系统、B系统、C系统、……的开发。现在应聘贵公司高级软件工程师岗位，希望能得到这个宝贵的机会，非常感谢！&lt;span/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;好了，总结一下。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这篇呢，Z哥和你聊的是面试的时候自我介绍这件事。虽然这是一件很小的事，但是由于「&lt;/span&gt;&lt;strong&gt;&lt;span&gt;首因效应&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;」的存在，它对你能否拿到offer起到的作用可不小。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;自我介绍的意义其实除了展现你自己之外，大多数时候也是面试官熟悉你简历的时候，所以面对这样一个一心二用的人，你要注意以下六个要点：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;时长控制。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;内容构成。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;精简内容。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;量化相关指标。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;注意做好内容承接准备，不要给自己挖坑&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;语气不好过于谦虚。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你还是无从下手，可以使用「PME」结构来试试。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;就这么多，希望对你有所帮助。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原创不易，如果你觉得这篇文章还不错，就「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」或者「&lt;/span&gt;&lt;span&gt;&lt;strong&gt;分享&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;」一下吧。鼓励我的创作 ：）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.4428822495606327&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/oB5bd6W6hI1Xrkr3iaFRP5fErfmjHqlBw160icnia8yicWBlicnPEfqGE80alzGl9FLj6FxyuibIuliceoH9zicibj95loQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1138&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你有关于软件架构、分布式系统、产品、运营的困惑&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以试试点击「&lt;strong&gt;阅读原文&lt;/strong&gt;」&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>35b7635a5338faf92d3ba0f15660bc69</guid>
<title>[推荐] 想自己写框架？不会写 Java 注解可不行</title>
<link>https://toutiao.io/k/9j801i6</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;img data-ratio=&quot;0.5107066381156317&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoF5meUibw0yzDr8WJvWZZdqOIIwTs8SQTGtujhpO4wUf2bPiaCMDMfPJBydvqLFYSAFEHHOLekPcIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1868&quot;/&gt;&lt;/h1&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;用注解一时爽，一直用一直爽&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java后端开发进入spring全家桶时代后，开发一个微服务提供简单的增删改查接口跟玩泥巴似的非常简单，一顿操作猛如虎，回头一看代码加了一堆注解：@Controller @Autowired @Value，面向注解编程变成了大家不可缺少的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想象一下如果没有注解Java程序员可以要哭瞎😭&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然注解（annotation）这么重要，用的这么爽，那注解的实现原理你知道么？我猜你只会用注解不会自己写注解（手动滑稽）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，下面的内容带大家从零开始写一个注解，揭开注解神秘的面纱。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;原来注解不神秘&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注解用大白话来说就是一个标记或者说是特殊的注释，如果没有解析这些标记的操作那它啥也不是。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注解的格式如同类或者方法一样有自己特殊的语法，这个语法下文会详细介绍。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那如何去解析注解呢？这就要用到Java强大的反射功能了。反射大家应该都用过，可以通过类对象获取到这个类的各种信息比如成员变量、方法等，那注解标记能不能通过反射获取呢？当然可以了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以注解的原理其实很简单，本质上是通过反射功能动态获取注解标记，然后按照不同的注解执行不同的操作，比如@Autowired可以注入一个对象给变量赋值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里是不是很躁动啊，来吧自己也撸一个注解。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;造火箭啦，自己动手写一个注解&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;便于大家理解，这里先引入一个场景：在线教育火了，经理让我写一个模块实现学生信息管理功能，考虑到分布式并发问题，经理让我务必加上分布式锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经理问我几天能搞定？我说至少3天。如是脑补了以下代码：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6792452830188679&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoF5meUibw0yzDr8WJvWZZdqqlLKjLNNCtPCHibIuk1mn2diaf8Klgconujc6bl0oUkt0LnwnBZkFiarQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1060&quot;/&gt;&lt;figcaption&gt;未使用注解前&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经理走后我在思考，我能不能只花一天时间写完，剩下两天时间用来写博客划水呢？突然灵感来了，我可以把重复的代码逻辑抽出来用注解实现不就节省代码了，哈哈，赶紧写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用注解之后整个方法清爽了很多，HR小姐姐都夸我写的好呢。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34057971014492755&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoF5meUibw0yzDr8WJvWZZdqEmXvlkS1Os6hgkYAP7icgjSbNhw9dZY3kANTX6G2rGklJibFJDEkPE1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1104&quot;/&gt;&lt;figcaption&gt;使用注解后&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码已经写完上库了，现在我在划水写博客呢。是不是很简洁很优雅很牛逼，怎么做到的呢，主要分为三步：&lt;span&gt;1打开冰箱门，2把大象放进去，3把冰箱门关好&lt;/span&gt;。好了，扯远了，大家接着往下看。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第一步定义一个注解&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5019455252918288&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoF5meUibw0yzDr8WJvWZZdqMZ5FFRhuPEK5IFahHnN9HVuDN0Fg8g5dHTct84u3q32SWqVUl9hMWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1028&quot;/&gt;&lt;figcaption&gt;注解的三大组成部分&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个注解可以简单拆解为三个部分：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一部分：注解体&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注解的定义有点类似于接口（interface），只不过前面一个加了一个@符号，这个千万不能省。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二部分：注解变量&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注解变量的语法有点类似于接口里面定义的方法，变量名后面带一对括号，不同的是注解变量后面可以有默认值。另外返回值只能是Java基本类型、String类型或者枚举类，不可以是对象类型。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三部分：元注解&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;元注解（meta-annotation）说白了就是给注解加注解的注解，是不是有点晕了，这种注解是JDK提前内置好的，可以直接拿来用的。不太懂也没有关系反正数量也不多，总共就4个，我们背下来吧：@Target @Retention @Documented @Inherited&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用来描述注解的使用范围，即被修饰的注解可以用在什么地方 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数），在定义注解类时使用了@Target 能够更加清晰的知道它能够被用来修饰哪些对象，具体的取值范围定义在ElementType.java 枚举类中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如上面我们写的Redis锁的注解就只能用于方法上了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用来描述注解保留的时间范围，即注解的生命周期。在 RetentionPolicy 枚举类中定义了三个周期：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; RetentionPolicy {&lt;br/&gt;    SOURCE, &lt;span&gt;// 源文件保留&lt;/span&gt;&lt;br/&gt;    CLASS,  &lt;span&gt;// 编译期保留，默认值&lt;/span&gt;&lt;br/&gt;    RUNTIME &lt;span&gt;// 运行期保留，可通过反射去获取注解信息&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像我们熟知的@Override注解就只能保留在源文件中，代码编译后注解就消失了。比如上面我们写的Redis锁的注解就保留到了运行期，运行的时候可以通过反射获取信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用来描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息，很简单不多解释了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;被Inherited注解修饰的注解具有继承性，如果父类使用了被@Inherited修饰的注解，则其子类将自动继承该注解。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，这一步我们已经将注解定义好了，但是这个注解如何工作呢？接着看。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第二步实现注解的业务逻辑&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在第一步中我们发现定义的注解（@EnableRedisLock）中没有业务逻辑，只有一些变量，别忘了我们的注解是要使能Redis分布式锁的功能，那这个注解到底是怎么实现加锁和释放锁的功能呢？这个就需要我们借助反射的强大功能了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8320987654320988&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RXvHpViaz3EoF5meUibw0yzDr8WJvWZZdqUn3Q8519JibztRk3QLv37icMBdN7k9bGpbUSHaa1aWTxXc2Vv8z8JHXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1620&quot;/&gt;&lt;figcaption&gt;注解的操作&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里借助了切面的功能，将EnableRedisLock注解作为一个切点，只要方法上标注了这个注解就会自动执行这里的代码逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过反射机制拿到注解对象后就可以执行加锁解锁的常用逻辑啦。Redis实现分布式锁相信大家已经很熟悉了，这里就不在啰嗦了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第三步在业务代码中尽情的使用注解&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@EnableRedisLock&lt;/span&gt;(lockKey = &lt;span&gt;&quot;student&quot;&lt;/span&gt;, expireTime = &lt;span&gt;10&lt;/span&gt;, timeUnit = TimeUnit.SECONDS, retryTimes = &lt;span&gt;5&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;method1&lt;/span&gt;&lt;span&gt;(Student student)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 这里写业务逻辑&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在需要加锁的方法上直接加上注解就可以啦，怎么样是不是很简单呀，赶紧在你的项目中运用起来吧。 &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，自己写一个注解的内容就介绍到这里了，学会了吗？&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ea66a272f610660d37e25cdef6be11b9</guid>
<title>[推荐] Java 开发人员必知的常用类库，这些你都知道吗？</title>
<link>https://toutiao.io/k/rxo1rll</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;作为一名程序员，我们要避免重复发明轮子，尽可能使用一些成熟、优秀、稳定的的第三方库，站在巨人的肩膀上搭建可靠、稳定的系统。本篇我整理了Java开发人员经常会使用到的第三方类库，可能不是很全面，还在持续收集整理中，朋友们可以关注我的GitHub上的持续更新，GitHub搜wind7rui/Javalib，或者点击链接https://github.com/wind7rui/Javalib，然后点击watch/Star/Fork，如果您对项目中的内容有建议或者意见，欢迎提出专业方面的建议，共同维护，请直接在GitHub上以issue或者PR的形式提出，以下我们开始本篇的内容。&lt;/p&gt;&lt;h3&gt;应用开发脚手架&lt;/h3&gt;&lt;p&gt;1.Spring Framework&lt;/p&gt;&lt;p&gt;Spring框架为现代基于Java的企业应用程序提供了一个全面的编程和配置模型，使用开发基于Java语言的应用更加简单、便捷。&lt;/p&gt;&lt;p&gt;github：https://github.com/spring-projects/spring-framework/&lt;/p&gt;&lt;p&gt;官网：https://spring.io/projects/spring-framework&lt;/p&gt;&lt;p&gt;2.Spring Boot&lt;/p&gt;&lt;p&gt;Spring Boot使创建独立的、基于Spring的产品级应用程序变得非常容易。&lt;/p&gt;&lt;p&gt;官网：https://spring.io/projects/spring-boot&lt;/p&gt;&lt;p&gt;3.Spring Cloud Spring Cloud为开发人员提供了丰富的使用工具，开发人员基于这些工具可以快速构建分布式系统中的一些常见功能（例如，配置管理，服务发现，断路器，智能路由，微代理，控制总线，一次性令牌，全局锁，领导选举，分布式会话等）。&lt;/p&gt;&lt;p&gt;官网：https://spring.io/projects/spring-cloud&lt;/p&gt;&lt;h3&gt;Web服务接口&lt;/h3&gt;&lt;p&gt;1.Jersey&lt;/p&gt;&lt;p&gt;Jersey是一个REST框架，它提供JAX-RS参考实现等。Jersey提供了自己的api，这些api通过附加的特性和实用程序扩展了JAX-RS工具包，从而进一步简化了RESTful服务和客户端开发。Jersey还公开了许多扩展spi，以便开发人员可以扩展Jersey以最适合他们的需求。&lt;/p&gt;&lt;p&gt;github：https://github.com/eclipse-ee4j/jersey&lt;/p&gt;&lt;p&gt;2.Spring Web MVC&lt;/p&gt;&lt;p&gt;Spring Web MVC是基于Servlet API构建的原始Web框架，从一开始就已包含在Spring框架中。正式名称“ Spring Web MVC”来自其源模块的名称（spring-webmvc），但通常称为“Spring MVC”。&lt;/p&gt;&lt;p&gt;官网：https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/web.html&lt;/p&gt;&lt;h3&gt;数据持久化框架&lt;/h3&gt;&lt;p&gt;1.MyBatis&lt;/p&gt;&lt;p&gt;MyBatis是一个一流的持久性框架，支持自定义SQL、存储过程和高级映射，它几乎消除了JDBC代码、参数手动设置和结果检索。MyBatis可以使用简单的XML或注释进行配置，并将原语、接口和javapojo（普通的旧Java对象）映射到数据库记录。&lt;/p&gt;&lt;p&gt;官网：https://mybatis.org/mybatis-3/&lt;/p&gt;&lt;p&gt;github：https://github.com/mybatis/mybatis-3&lt;/p&gt;&lt;p&gt;2.Hibernate&lt;/p&gt;&lt;p&gt;Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。&lt;/p&gt;&lt;p&gt;官网：http://hibernate.org/&lt;/p&gt;&lt;h3&gt;Excel读写&lt;/h3&gt;&lt;p&gt;1.Alibaba EasyExcel&lt;/p&gt;&lt;p&gt;Java解析、生成Excel比较有名的框架有Apache poi、jxl。但他们都存在一个严重的问题就是非常的耗内存，poi有一套SAX模式的API可以一定程度的解决一些内存溢出的问题，但POI还是有一些缺陷，比如07版Excel解压缩以及解压后存储都是在内存中完成的，内存消耗依然很大。easyexcel重写了poi对07版Excel的解析，能够原本一个3M的excel用POI sax依然需要100M左右内存降低到几M，并且再大的excel不会出现内存溢出，03版依赖POI的sax模式。在上层做了模型转换的封装，让使用者更加简单方便。&lt;/p&gt;&lt;p&gt;github：https://github.com/alibaba/easyexcel&lt;/p&gt;&lt;p&gt;2.Apache POI&lt;/p&gt;&lt;p&gt;一个用于读写Microsoft Office二进制和OOXML文件格式的Java库，可用于读写Excel 97-2008。&lt;/p&gt;&lt;p&gt;github：https://github.com/apache/poi&lt;/p&gt;&lt;h3&gt;CSV读写&lt;/h3&gt;&lt;p&gt;1.Apache Commons CSV&lt;/p&gt;&lt;p&gt;Apache Commons CSV库提供了用于读取和写入各种类型CSV文件的接口。&lt;/p&gt;&lt;p&gt;github：https://github.com/apache/commons-csv&lt;/p&gt;&lt;p&gt;2.Java CSV&lt;/p&gt;&lt;p&gt;Java CSV是一个小型、快速且开源Java库，用于读、写各种CSV文件。&lt;/p&gt;&lt;p&gt;官网：https://www.csvreader.com/java_csv.php&lt;/p&gt;&lt;p&gt;API：http://javacsv.sourceforge.net/&lt;/p&gt;&lt;p&gt;3.Super CSV&lt;/p&gt;&lt;p&gt;Super CSV是一个快速、免费跨平台的CSV格式数据的读写库，可以方便的处理对象、Map、列表的读写操作，以及自动化的类型转换和数据检查功能。&lt;/p&gt;&lt;p&gt;官网：http://super-csv.github.io/super-csv/index.html&lt;/p&gt;&lt;p&gt;github：https://github.com/super-csv/super-csv&lt;/p&gt;&lt;h3&gt;JSON读写&lt;/h3&gt;&lt;p&gt;1.Jackson&lt;/p&gt;&lt;p&gt;Jackson被称为Java的标准JSON库，号称“Java的最佳JSON解析器”。&lt;/p&gt;&lt;p&gt;github：https://github.com/FasterXML/jackson&lt;/p&gt;&lt;p&gt;2.Gson&lt;/p&gt;&lt;p&gt;Gson是谷歌开源的一个Java库，可用于将Java对象转换为其JSON表示形式。它还可以用于将JSON字符串转换为等效的Java对象。Gson可以处理任意Java对象，包括您没有源代码的现有对象。&lt;/p&gt;&lt;p&gt;github：https://github.com/google/gson&lt;/p&gt;&lt;p&gt;3.fastjson&lt;/p&gt;&lt;p&gt;fastjson是阿里巴巴的开源JSON解析库，它可以解析JSON格式的字符串，支持将Java Bean序列化为JSON字符串，也可以从JSON字符串反序列化到JavaBean。&lt;/p&gt;&lt;p&gt;github：https://github.com/alibaba/fastjson&lt;/p&gt;&lt;h3&gt;XML读写&lt;/h3&gt;&lt;p&gt;1.dom4j&lt;/p&gt;&lt;p&gt;dom4j是用于处理XML的开源框架，该框架与XPath集成在一起，并完全支持DOM、SAX、JAXP和Java平台。&lt;/p&gt;&lt;p&gt;github：https://github.com/dom4j/dom4j&lt;/p&gt;&lt;p&gt;官网：https://dom4j.github.io/&lt;/p&gt;&lt;p&gt;2.StAX&lt;/p&gt;&lt;p&gt;StAX全称Streaming API for XML，一种全新的、基于流的Java XML解析标准类库。&lt;/p&gt;&lt;p&gt;3.jaxb-api&lt;/p&gt;&lt;p&gt;jaxb-api用于执行XML文档和Java对象之间的映射。&lt;/p&gt;&lt;p&gt;文档：https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/JAXB.html&lt;/p&gt;&lt;p&gt;4.XStream&lt;/p&gt;&lt;p&gt;XStream是一个可以轻易的将Java对象和xml文档相互转换的类库。&lt;/p&gt;&lt;p&gt;官网：http://x-stream.github.io/&lt;/p&gt;&lt;h3&gt;IO读写&lt;/h3&gt;&lt;p&gt;1.Apache Commons IO Apache Commons IO是一个实用程序库，可协助开发IO功能。&lt;/p&gt;&lt;p&gt;官网：https://commons.apache.org/proper/commons-io/&lt;/p&gt;&lt;p&gt;2.Okio&lt;/p&gt;&lt;p&gt;Okio是对java.io和java.nio的补充，使访问、存储和处理数据变得更加容易。&lt;/p&gt;&lt;p&gt;github：https://github.com/square/okio&lt;/p&gt;&lt;h3&gt;HTTP客户端&lt;/h3&gt;&lt;p&gt;1.OkHttp&lt;/p&gt;&lt;p&gt;OkHttp是一个HTTP客户端，使用OkHttp很容易，它的请求/响应API具有流畅的构建器和不变性。它支持同步阻塞调用和带有回调的异步调用。&lt;/p&gt;&lt;p&gt;github：https://github.com/square/okhttp&lt;/p&gt;&lt;p&gt;官网：https://square.github.io/okhttp/&lt;/p&gt;&lt;p&gt;2.Apache HttpClient&lt;/p&gt;&lt;p&gt;Apache HttpClient提供了对基本HTTP协议的强大支持，用于构建基于HTTP的客户端。&lt;/p&gt;&lt;p&gt;官网：http://hc.apache.org/index.html&lt;/p&gt;&lt;p&gt;github：https://github.com/apache/httpcomponents-client&lt;/p&gt;&lt;h3&gt;Java Bean复制&lt;/h3&gt;&lt;p&gt;1.Cglib BeanCopier&lt;/p&gt;&lt;p&gt;Cglib库内的BeanCopier提供了ava Bean到Java Bean的复制功能，性能优于Spring BeanUtils。&lt;/p&gt;&lt;section class=&quot;code-snippet__github&quot;&gt;&lt;pre data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;BeanCopier&lt;/span&gt;&lt;span&gt; beanCopier &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;BeanCopier&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;create&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;sourceClass&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; targetClass&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span&gt;beanCopier&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;copy&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;source&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; target&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;2.Spring BeanUtils&lt;/p&gt;&lt;p&gt;Spring框架的Spring Beans库中的BeanUtils也实现了Java Bean到Java Bean的复制。&lt;/p&gt;&lt;p&gt;3.Dozer&lt;/p&gt;&lt;p&gt;Dozer是Java Bean到Java Bean映射器，它以递归方式将数据从一个对象复制到另一个对象。Dozer支持简单属性映射、复杂类型映射、双向映射、隐式显式映射以及递归映射。Dozer不仅支持属性名称之间的映射，而且还可以在类型之间自动转换。开箱即用地支持大多数转换方案，同时也允许您通过XML或基于代码的配置指定自定义转换。&lt;/p&gt;&lt;p&gt;github：https://github.com/DozerMapper/dozer&lt;/p&gt;&lt;p&gt;文档：https://dozermapper.github.io/gitbook/&lt;/p&gt;&lt;h3&gt;Redis客户端&lt;/h3&gt;&lt;p&gt;1.Redission&lt;/p&gt;&lt;p&gt;Redis推荐的Java客户端Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid），它充分利用了Redis键值数据库提供的一系列优势，基于Java实用工具包中常用接口，为使用者提供了一系列具有分布式特性的常用工具类，让使用Redis更加简单、便捷，从而让使用者能够将更多精力集中到业务逻辑处理上。&lt;/p&gt;&lt;p&gt;github：https://github.com/redisson/redisson/&lt;/p&gt;&lt;p&gt;2.Jedis&lt;/p&gt;&lt;p&gt;Redis推荐的Java客户端。&lt;/p&gt;&lt;p&gt;github：https://github.com/xetorthio/jedis&lt;/p&gt;&lt;h3&gt;数据库连接池&lt;/h3&gt;&lt;p&gt;数据库连接池提供了一套高效的连接分配、使用策略， 最终实现连接的高效管理。&lt;/p&gt;&lt;p&gt;1.HikariCP&lt;/p&gt;&lt;p&gt;快速、简单、可靠。HikariCP是“零开销”生产就绪的JDBC连接池。&lt;/p&gt;&lt;p&gt;github：https://github.com/brettwooldridge/HikariCP&lt;/p&gt;&lt;p&gt;2.Druid&lt;/p&gt;&lt;p&gt;Druid是Java语言中最好的数据库连接池之一，Druid能够提供强大的监控和扩展功能。&lt;/p&gt;&lt;p&gt;github：https://github.com/alibaba/druid/&lt;/p&gt;&lt;p&gt;3.Tomcat JDBC&lt;/p&gt;&lt;p&gt;JDBC连接池是Apache Commons DBCP连接池的替代品。&lt;/p&gt;&lt;p&gt;官网：http://tomcat.apache.org/tomcat-7.0-doc/jdbc-pool.html&lt;/p&gt;&lt;h3&gt;网络编程&lt;/h3&gt;&lt;p&gt;1.Netty&lt;/p&gt;&lt;p&gt;Netty是一个广泛使用的Java网络编程框架。&lt;/p&gt;&lt;p&gt;github：https://github.com/netty/netty&lt;/p&gt;&lt;p&gt;官网：https://netty.io/&lt;/p&gt;&lt;h3&gt;文件上传&lt;/h3&gt;&lt;p&gt;1.Apache Commons FileUpload&lt;/p&gt;&lt;p&gt;Apache Commons FileUpload使高性能的文件上传功能变得容易。&lt;/p&gt;&lt;p&gt;官网：http://commons.apache.org/proper/commons-fileupload/&lt;/p&gt;&lt;h3&gt;发送邮件&lt;/h3&gt;&lt;p&gt;1.Apache Commons Email&lt;/p&gt;&lt;p&gt;Apache commons Email旨在提供用于发送电子邮件的API，它建立在Java Mail API之上，它的目标就是简便。&lt;/p&gt;&lt;p&gt;官网：http://commons.apache.org/proper/commons-email/&lt;/p&gt;&lt;h3&gt;编码和解码&lt;/h3&gt;&lt;p&gt;1.Apache Commons Codec&lt;/p&gt;&lt;p&gt;Apache Commons Codec提供了常见编码器和解码器的实现，例如Base64，Hex，Phonetic和URL。&lt;/p&gt;&lt;p&gt;官网：http://commons.apache.org/proper/commons-codec/&lt;/p&gt;&lt;h3&gt;IO操作&lt;/h3&gt;&lt;p&gt;1.Apache Commons IO&lt;/p&gt;&lt;p&gt;简单、快捷的IO操作。&lt;/p&gt;&lt;p&gt;官网：http://commons.apache.org/proper/commons-io/index.html&lt;/p&gt;&lt;p&gt;对象池&lt;/p&gt;&lt;p&gt;1.Apache Commons Pool&lt;/p&gt;&lt;p&gt;提供了通用对象池。&lt;/p&gt;&lt;p&gt;官网：http://commons.apache.org/proper/commons-pool/&lt;/p&gt;&lt;h3&gt;java.lang包工具类&lt;/h3&gt;&lt;p&gt;1.Apache Commons Lang&lt;/p&gt;&lt;p&gt;为java.lang中的类提供额外的功能，例如StringUtils、DateUtils、RandomUtils、FastDateFormat(线程安全版本的SimpleDateFormat)。&lt;/p&gt;&lt;p&gt;官网：http://commons.apache.org/proper/commons-lang/index.html&lt;/p&gt;&lt;h3&gt;集合操作&lt;/h3&gt;&lt;p&gt;1.Apache Commons Collections&lt;/p&gt;&lt;p&gt;集合相关操作工具类。&lt;/p&gt;&lt;p&gt;官网：http://commons.apache.org/proper/commons-collections/&lt;/p&gt;&lt;p&gt;2.Guava&lt;/p&gt;&lt;p&gt;Guava是Google的一组核心Java库，除了可以操作我们常用的集合类型之外，还可以操作新的集合类型（例如多图和多集）和不可变的集合。&lt;/p&gt;&lt;p&gt;github：https://github.com/google/guava&lt;/p&gt;&lt;h3&gt;全能型工具类&lt;/h3&gt;&lt;p&gt;1.Guava&lt;/p&gt;&lt;p&gt;Guava是Google的一组核心Java库，其中包括新的集合类型（例如多图和多集），不可变的集合，图形库以及用于并发，I / O，哈希，缓存，基元，字符串等的实用程序！它广泛用于Google的大多数Java项目中，也被许多其他公司广泛使用。&lt;/p&gt;&lt;p&gt;github：https://github.com/google/guava&lt;/p&gt;&lt;p&gt;2.Hutool&lt;/p&gt;&lt;p&gt;Hutool是一个Java工具包，也只是一个工具包，它帮助我们简化每一行代码，减少每一个方法，让Java语言也可以“甜甜的”。&lt;/p&gt;&lt;p&gt;github：https://github.com/looly/hutool&lt;/p&gt;&lt;h3&gt;日期和时间操作&lt;/h3&gt;&lt;p&gt;1.Joda-Time&lt;/p&gt;&lt;p&gt;Joda-Time提供了Java日期和时间类的质量替代。&lt;/p&gt;&lt;p&gt;官网：https://www.joda.org/joda-time/&lt;/p&gt;&lt;h3&gt;单元测试&lt;/h3&gt;&lt;p&gt;1.JUnit&lt;/p&gt;&lt;p&gt;官网：https://junit.org/junit5/&lt;/p&gt;&lt;p&gt;2.Mockito&lt;/p&gt;&lt;p&gt;Mockito是一个Java单元测试模拟框架。&lt;/p&gt;&lt;p&gt;官网：https://site.mockito.org/&lt;/p&gt;&lt;p&gt;3.PowerMock&lt;/p&gt;&lt;p&gt;PowerMock也是一个Java单元测试模拟框架，它可以模拟静态方法、构造函数、最终类和方法、私有方法、删除静态初始化器等。&lt;/p&gt;&lt;p&gt;官网：http://powermock.github.io/&lt;/p&gt;&lt;p&gt;4.moco&lt;/p&gt;&lt;p&gt;在日常接口测试的工作中，经常需要依赖其他系统的API，但是联调不常有，只能自己通过mock完成数据依赖。Moco是一个模拟服务器端服务的项目，可以用于测试打桩。&lt;/p&gt;&lt;p&gt;github：https://github.com/dreamhead/moco&lt;/p&gt;&lt;h3&gt;安全框架&lt;/h3&gt;&lt;p&gt;1.Apache Shiro&lt;/p&gt;&lt;p&gt;Apache Shiro是一个功能强大且易于使用的Java安全框架，它用于身份验证、授权、加密和会话管理。使用Shiro易于理解的API，可以快速轻松地保护任何应用程序，从最小的移动应用程序到最大的Web和企业应用程序。&lt;/p&gt;&lt;p&gt;官网：http://shiro.apache.org/&lt;/p&gt;&lt;h3&gt;日志&lt;/h3&gt;&lt;p&gt;1.SLF4J + Logback&lt;/p&gt;&lt;p&gt;SLF4J是为各种loging APIs提供一个简单统一的接口，从而使得最终用户能够在部署的时候配置自己希望的loging APIs实现，它是一个日志接口。&lt;/p&gt;&lt;p&gt;Logback是由log4j创始人设计的又一个开源日志组件，它是一个日志的实现。&lt;/p&gt;&lt;p&gt;SLF4J官网：http://www.slf4j.org/&lt;/p&gt;&lt;p&gt;Logback官网：https://logback.qos.ch/&lt;/p&gt;&lt;h3&gt;对象池&lt;/h3&gt;&lt;p&gt;1.Apache Commons Pool&lt;/p&gt;&lt;p&gt;Apache Commons Pool提供了对象池API和一系列对象池实现。&lt;/p&gt;&lt;p&gt;官网：https://commons.apache.org/proper/commons-pool/&lt;/p&gt;&lt;h3&gt;基本网络通讯&lt;/h3&gt;&lt;p&gt;1.Apache Commons Net&lt;/p&gt;&lt;p&gt;Apache Commons Net库实现了许多基本互联网协议的客户端。该库的目的是提供基本协议访问，而不是更高级别的抽象。&lt;/p&gt;&lt;p&gt;官网：http://commons.apache.org/proper/commons-net/index.html&lt;/p&gt;&lt;h3&gt;作业调度框架(定时任务)&lt;/h3&gt;&lt;p&gt;1.Quartz&lt;/p&gt;&lt;p&gt;Quartz是一个开源的作业调度框架，它完全由Java编写，能够用它来为执行一个作业而创建简单的或复杂的调度。&lt;/p&gt;&lt;p&gt;官网：http://www.quartz-scheduler.org/&lt;/p&gt;&lt;p&gt;github：https://github.com/quartz-scheduler/quartz&lt;/p&gt;&lt;p&gt;2.ElasticJob&lt;/p&gt;&lt;p&gt;ElasticJob是一种分布式调度解决方案，解决了Quartz不支持分布式的弊端。Elastic job主要的功能有支持弹性扩容，通过Zookepper集中管理和监控job，支持失效转移等。&lt;/p&gt;&lt;p&gt;github：https://github.com/apache/shardingsphere-elasticjob&lt;/p&gt;&lt;h3&gt;配置中心&lt;/h3&gt;&lt;p&gt;1.Nacos&lt;/p&gt;&lt;p&gt;Nacos是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。Nacos的动态配置服务让您能够以中心化、外部化和动态化的方式管理所有环境的配置。动态配置消除了配置变更时重新部署应用和服务的需要。配置中心化管理让实现无状态服务更简单，也让按需弹性扩展服务更容易。&lt;/p&gt;&lt;p&gt;官网：https://nacos.io/&lt;/p&gt;&lt;p&gt;github：https://github.com/alibaba/nacos&lt;/p&gt;&lt;p&gt;2.Spring Cloud Config&lt;/p&gt;&lt;p&gt;Spring Cloud Config为分布式系统中的外部化配置提供服务器端和客户端支持。使用Config Server，您可以在中心位置管理所有环境中应用程序的外部属性。&lt;/p&gt;&lt;p&gt;文档：https://cloud.spring.io/spring-cloud-config/reference/html/&lt;/p&gt;&lt;p&gt;3.Apollo&lt;/p&gt;&lt;p&gt;Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。&lt;/p&gt;&lt;p&gt;github：https://github.com/ctripcorp/apollo&lt;/p&gt;&lt;h3&gt;限流&lt;/h3&gt;&lt;p&gt;1.Guava RateLimiter&lt;/p&gt;&lt;p&gt;RateLimiter基于令牌桶算法，即以用户设定的恒定速率向令牌桶内放置令牌，用户来执行任务时，只有拿到令牌才能执行。&lt;/p&gt;&lt;p&gt;2.Sentinel&lt;/p&gt;&lt;p&gt;Sentinel是面向分布式服务架构的高可用防护组件，主要以流量为切入点，从流量控制、熔断降级、系统自适应保护等多个维度来帮助用户保障微服务的稳定性。&lt;/p&gt;&lt;p&gt;官网：https://sentinelguard.io/&lt;/p&gt;&lt;p&gt;github：https://github.com/alibaba/Sentinel&lt;/p&gt;&lt;h3&gt;熔断降级&lt;/h3&gt;&lt;p&gt;当调用链路中某个资源出现不稳定，例如，表现为timeout，异常比例升高的时候，则对这个资源的调用进行限制，并让请求快速失败，避免影响到其它的资源，最终产生雪崩的效果。&lt;/p&gt;&lt;p&gt;1.Sentinel&lt;/p&gt;&lt;p&gt;Sentinel通过并发线程数进行限制和通过响应时间对资源进行降级两种手段对资源调用进行限制，让请求快速失败，避免影响到其它的资源。&lt;/p&gt;&lt;p&gt;官网：https://sentinelguard.io/&lt;/p&gt;&lt;p&gt;github：https://github.com/alibaba/Sentinel&lt;/p&gt;&lt;p&gt;2.Hystrix&lt;/p&gt;&lt;p&gt;Hystrix 通过线程池的方式，来对资源进行了隔离。这样做的好处是资源和资源之间做到了最彻底的隔离。缺点是除了增加了线程切换的成本，还需要预先给各个资源做线程池大小的分配。Hystrix不再处于主动开发中，并且当前处于维护模式，官方推荐使用Resilience4j替代。&lt;/p&gt;&lt;p&gt;github：https://github.com/Netflix/Hystrix&lt;/p&gt;&lt;p&gt;3.Resilience4j&lt;/p&gt;&lt;p&gt;Resilience4j是受Netflix Hystrix启发的轻量级容错库，但专为Java 8和函数式编程而设计。轻巧，因为该库仅使用Vavr，而Vavr没有任何其他外部库依赖项。&lt;/p&gt;&lt;p&gt;github：https://github.com/resilience4j/resilience4j&lt;/p&gt;&lt;h3&gt;分库分表&lt;/h3&gt;&lt;p&gt;1.Apache ShardingSphere&lt;/p&gt;&lt;p&gt;Apache ShardingSphere定位为关系型数据库中间件，旨在充分合理地在分布式的场景下利用关系型数据库的计算和存储能力，而并非实现一个全新的关系型数据库。支持数据分片、读写分离、多数据副本、数据加密、影子库压测等功能。&lt;/p&gt;&lt;p&gt;官网：https://shardingsphere.apache.org/&lt;/p&gt;&lt;p&gt;github：https://github.com/apache/shardingsphere&lt;/p&gt;&lt;p&gt;2.Mycat&lt;/p&gt;&lt;p&gt;Mycat是数据库分库分表中间件。&lt;/p&gt;&lt;p&gt;官网：http://www.mycat.org.cn/&lt;/p&gt;&lt;p&gt;github：https://github.com/MyCATApache&lt;/p&gt;&lt;h3&gt;序列化&lt;/h3&gt;&lt;p&gt;1.Kryo&lt;/p&gt;&lt;p&gt;Kryo是用于Java的快速高效的二进制对象图序列化框架。该项目的目标是高速，小尺寸和易于使用的API。每当需要将对象持久保存到文件，数据库还是通过网络时，该项目都是有用的。&lt;/p&gt;&lt;p&gt;github：https://github.com/EsotericSoftware/kryo&lt;/p&gt;&lt;p&gt;2.Hessian&lt;/p&gt;&lt;p&gt;Hessian是一款支持多种语言进行序列化操作的框架技术，同时在进行序列化之后产生的码流也较小，处理数据的性能方面远超于java内置的jdk序列化方式。&lt;/p&gt;&lt;p&gt;官网：http://hessian.caucho.com/&lt;/p&gt;&lt;p&gt;3.Protobuf&lt;/p&gt;&lt;p&gt;Protobuf是谷歌开源的一个灵活的、高效的用于序列化数据的协议。相比较XML和JSON格式，protobuf更小、更快、更便捷。&lt;/p&gt;&lt;p&gt;github：https://github.com/protocolbuffers/protobuf&lt;/p&gt;&lt;p&gt;官网：https://developers.google.com/protocol-buffers/&lt;/p&gt;&lt;h3&gt;RPC框架&lt;/h3&gt;&lt;p&gt;1.Dubbo Apache Dubbo是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。&lt;/p&gt;&lt;p&gt;官网：http://dubbo.apache.org/zh-cn/&lt;/p&gt;&lt;p&gt;github：https://github.com/apache/dubbo&lt;/p&gt;&lt;p&gt;2.Thrift Thrift是一个软件框架（远程过程调用框架），用来进行可扩展且跨语言的服务的开发。它结合了功能强大的软件堆栈和代码生成引擎，以构建在C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml这些编程语言间无缝结合的、高效的服务。Thrift最初由facebook开发，07年四月开放源码，08年5月进入apache孵化器，现在是 Apache 基金会的顶级项目。Thrift允许你定义一个简单的定义文件中的数据类型和服务接口，以作为输入文件，编译器生成代码用来方便地生成RPC客户端和服务器通信的无缝跨编程语言。&lt;/p&gt;&lt;p&gt;官网：http://thrift.apache.org/&lt;/p&gt;&lt;p&gt;3.gRPC gRPC是一个现代的、开源的、高性能的远程过程调用（RPC）框架，可以在任何地方运行。gRPC使客户机和服务器应用程序能够透明地通信，并简化了连接系统的构建。目前提供C、Java和Go语言版本，分别是：grpc, grpc-java, grpc-go. 其中C版本支持C, C++, Node.js, Python, Ruby, Objective-C, PHP和C#支持。&lt;/p&gt;&lt;p&gt;官网：https://www.grpc.io/&lt;/p&gt;&lt;p&gt;github：https://github.com/grpc/grpc&lt;/p&gt;&lt;p&gt;&lt;strong&gt;学之多，而后知之少&lt;/strong&gt;&lt;span&gt;！以上是本次分享的内容，朋友们点【在看】是我持续更新的最大动力，我们下期见！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gDHRjEowjKSxTAD3licFmGltOsliao1ZVHCicnRtbiarMjXCkm2y0FjRlsJ596O4ibOAoOib1XWGhXlYX8x0wYXIPfxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.5555555555555556&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1ad71881daa6d31ddecbc26ecde2b611</guid>
<title>[推荐] 进阶必看的 RocketMQ ，就这篇了</title>
<link>https://toutiao.io/k/utkv7cg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;每个时代，都不会亏待会学习的人。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是 yes。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继上一篇 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MjEyNTk1Ng==&amp;amp;mid=2247485725&amp;amp;idx=1&amp;amp;sn=6a46ae2cd15984d74f0b39cecda271de&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;头条终面：写个消息中间件&lt;/a&gt; ，我提到实现消息中间件的一些关键点，今天就和大家一起深入生产级别消息中间件 - RocketMQ 的内核实现，来看看真正落地能支撑万亿级消息容量、低延迟的消息队列到底是如何设计的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章我会&lt;span&gt;先介绍整体的架构设计，然后再深入各核心模块的详细设计、核心流程的剖析&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还会提及使用的一些&lt;span&gt;注意点和最佳实践&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于消息队列的用处和一些概念不太清楚的同学强烈建议先看&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MjEyNTk1Ng==&amp;amp;mid=2247484130&amp;amp;idx=1&amp;amp;sn=0a936cc7f03074f1eb2e0a8d35de1423&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;消息队列面试连环问&lt;/a&gt;，这篇文章介绍了消息队列的使用场景、基本概念和常见面试题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;话不多说，上车。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;RocketMQ 整体架构设计&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体的架构设计主要分为四大部分，分别是：Producer、Consumer、Broker、NameServer。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5022341376228776&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8hUbkaTY0U841EVwZaXODlxwr76ORc4q0iccPZ698jibp5RvwGmFYyAoibDtNQrxcUmUdwqwiaHlZpFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1119&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更贴合实际，我画的都是集群部署，像 Broker 我还画了主从。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Producer：就是消息生产者，可以集群部署。它会先和 NameServer 集群中的随机一台建立长连接，得知当前要发送的 Topic 存在哪台 Broker Master上，然后再与其建立长连接，支持多种负载平衡模式发送消息。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Consumer：消息消费者，也可以集群部署。它也会先和 NameServer 集群中的随机一台建立长连接，得知当前要消息的 Topic 存在哪台 Broker Master、Slave上，然后它们建立长连接，支持集群消费和广播消费消息。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Broker：主要负责消息的存储、查询消费，支持主从部署，一个 Master 可以对应多个 Slave，Master 支持读写，Slave 只支持读。&lt;span&gt;Broker 会向集群中的每一台 NameServer 注册自己的路由信息。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;NameServer：是一个很简单的 Topic 路由注册中心，支持 Broker 的动态注册和发现，保存 Topic 和 Borker 之间的关系。通常也是集群部署，但是&lt;span&gt;各 NameServer 之间不会互相通信， 各 NameServer 都有完整的路由信息&lt;/span&gt;，即无状态。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我再用一段话来概括它们之间的交互：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8hUbkaTY0U841EVwZaXODln1onPPzgicuPLOS2DtShMZ02ibTLBdCw971N35CAicKsdP27FFOXs3tPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;220&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先启动 NameServer 集群，各 NameServer 之间无任何数据交互，Broker 启动之后会向所有 NameServer 定期（每 30s）发送心跳包，包括：IP、Port、TopicInfo，NameServer 会定期扫描 Broker 存活列表，如果超过 120s 没有心跳则移除此 Broker 相关信息，代表下线。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样每个 NameServer 就知道集群所有 Broker 的相关信息，此时 Producer 上线从 NameServer 就可以得知它要发送的某 Topic 消息在哪个 Broker 上，和对应的 Broker （Master 角色的）建立长连接，发送消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Consumer 上线也可以从 NameServer  得知它所要接收的 Topic 是哪个 Broker ，和对应的 Master、Slave 建立连接，接收消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单的工作流程如上所述，相信大家对整体数据流转已经有点印象了，我们再来看看每个部分的详细情况。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;NameServer&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的特点就是轻量级，无状态。角色类似于 Zookeeper 的情况，从上面描述知道其主要的两个功能就是：Broker 管理、路由信息管理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总体而言比较简单，我再贴一些字段，让大家有更直观的印象知道它存储了些什么。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.10580912863070539&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8hUbkaTY0U841EVwZaXODlBDQNqFQCjLJ5HZzvSD1Y4uLhws7dVEXmFbI2S3TIM6ArSu5P5dna9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;964&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Producer&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Producer 无非就是消息生产者，那首先它得知道消息要发往哪个 Broker ，于是每 30s 会从某台 NameServer 获取 Topic 和 Broker 的映射关系存在本地内存中，如果发现新的 Broker 就会和其建立长连接，每 30s 会发送心跳至 Broker 维护连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且会&lt;span&gt;轮询当前可以发送的 Broker 来发送消息&lt;/span&gt;，达到负载均衡的目的，在&lt;span&gt;同步发送情况&lt;/span&gt;下如果发送失败会默认重投两次（retryTimesWhenSendFailed = 2），并且不会选择上次失败的 broker，会向其他 broker 投递。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;span&gt;异步发送&lt;/span&gt;失败的情况下也会重试，默认也是两次 （retryTimesWhenSendAsyncFailed = 2），但是仅在同一个 Broker 上重试。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Producer 启动流程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们再来看看 Producer 的启动流程看看都干了些啥。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6401617250673854&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8hUbkaTY0U841EVwZaXODlSlFukg4kEwKDSZT7x78T4lvKCiao3yRxsohMvl0nxUs2YtZhmicTrEMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;742&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大致启动流程图中已经表明的很清晰的，但是有些细节可能还不清楚，比如重平衡啊，TBW102 啥玩意啊，有哪些定时任务啊，别急都会提到的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有人可能会问这生产者为什么要启拉取服务、重平衡？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为 Producer 和 Consumer 都需要用 MQClientInstance，而同一个 clientId 是共用一个 MQClientInstance 的， clientId 是通过本机 IP 和 instanceName（默认值 default）拼起来的，所以多个 Producer 、Consumer 实际用的是一个MQClientInstance。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于有哪些定时任务，请看下图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24500525762355416&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8hUbkaTY0U841EVwZaXODl7hcdDSD6oH36Y998oicgMGicQI97TLk3wqookcQ5iaP0A8huDp0HtkRdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;951&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Producer 发消息流程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看看发消息的流程，大致也不是很复杂，无非就是找到要发送消息的 Topic 在哪个 Broker 上，然后发送消息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8962131837307152&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8hUbkaTY0U841EVwZaXODlvIaBJHR57OJFZs1ianTtA3iaYMHW2P5JCK2uPHiaXVCzLcOZbbHJTKhvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;713&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在就知道 TBW102 是啥用的，就是接受自动创建主题的 Broker 启动会把这个默认主题登记到 NameServer，这样当 Producer 发送新 Topic 的消息时候就得知哪个 Broker 可以自动创建主题，然后发往那个 Broker。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 Broker 接受到这个消息的时候发现没找到对应的主题，但是它接受创建新主题，这样就会创建对应的 Topic 路由信息。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;自动创建主题的弊端&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;自动创建主题那么有可能该主题的消息都只会发往一台 Broker，起不到负载均衡的作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为创建新 Topic 的请求到达 Broker 之后，Broker 创建对应的路由信息，但是心跳是每 30s 发送一次，所以说 NameServer 最长需要 30s 才能得知这个新 Topic 的路由信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设此时发送方还在连续快速的发送消息&lt;/span&gt;，那 NameServer 上其实还没有关于这个 Topic 的路由信息，所以&lt;span&gt;有机会&lt;/span&gt;让别的允许自动创建的 Broker 也创建对应的 Topic 路由信息，这样集群里的 Broker 就能接受这个 Topic 的信息，达到负载均衡的目的，但也有个别 Broker 可能，没收到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果发送方这一次发了之后 30s 内一个都不发，之前的那个 Broker 随着心跳把这个路由信息更新到 NameServer 了，那么之后发送该 Topic 消息的 Producer 从 NameServer 只能得知该 Topic 消息只能发往之前的那台 Broker ，这就不均衡了，如果这个新主题消息很多，那台 Broker 负载就很高了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以不建议线上开启允许自动创建主题，即 autoCreateTopicEnable 参数。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;发送消息故障延迟机制&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一个参数是 sendLatencyFaultEnable，默认不开启。这个参数的作用是对于之前发送超时的 Broker 进行一段时间的退避。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发送消息会记录此时发送消息的时间，如果超过一定时间，那么此 Broker 就在一段时间内不允许发送。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.08833922261484099&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8hUbkaTY0U841EVwZaXODln7RiaGMqcicrlScIk8HbY07qcCg1BJ8ibibeJetysuuWicqNQy3DGm8iaUKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;849&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如发送时间超过 15000ms 则在 600000 ms 内无法向该 Broker 发送消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个机制其实很关键，发送超时大概率表明此 Broker 负载高，所以先避让一会儿，让它缓一缓，这也是实现消息发送高可用的关键。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结一下&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Producer 每 30s 会向 NameSrv 拉取路由信息更新本地路由表，有新的 Broker 就和其建立长连接，每隔 30s 发送心跳给 Broker 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要在生产环境开启 autoCreateTopicEnable。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Producer 会通过重试和延迟机制提升消息发送的高可用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Broker&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Broker 就比较复杂一些了，但是非常重要。大致分为以下五大模块，我们来看一下官网的图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5023255813953489&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8hUbkaTY0U841EVwZaXODl6cY89rZ0fdg9ZqF4hPkoy5faWV8t8MYAavsw4icN7keCOibKPJBKoumQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;860&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Remoting 远程模块，处理客户请求。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Client Manager 管理客户端，维护订阅的主题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Store Service 提供消息存储查询服务。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HA Serivce，主从同步高可用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Index Serivce，通过指定key 建立索引，便于查询。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有几个模块没啥可说的就不分析了，先看看存储的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Broker 的存储&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocketMQ 存储用的是本地文件存储系统，效率高也可靠。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要涉及到三种类型的文件，分别是 CommitLog、ConsumeQueue、IndexFile。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;CommitLog&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocketMQ 的所有主题的消息都存在 CommitLog 中，单个 CommitLog 默认 1G，并且文件名以起始偏移量命名，固定 20 位，不足则前面补 0，比如 00000000000000000000 代表了第一个文件，第二个文件名就是 00000000001073741824，表明起始偏移量为 1073741824，以这样的方式命名用偏移量就能找到对应的文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有消息都是顺序写入的，超过文件大小则开启下一个文件。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;ConsumeQueue&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ConsumeQueue 消息消费队列，可以认为是 CommitLog 中消息的索引，因为 CommitLog 是糅合了所有主题的消息，所以通过索引才能更加高效的查找消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ConsumeQueue 存储的条目是固定大小，只会存储 8 字节的 commitlog 物理偏移量，4 字节的消息长度和 8 字节 Tag 的哈希值，固定 20 字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际存储中，ConsumeQueue 对应的是一个Topic 下的某个 Queue，每个文件约 5.72M，由 30w 条数据组成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者是先从 ConsumeQueue 来得到消息真实的物理地址，然后再去 CommitLog 获取消息。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;IndexFile&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IndexFile 就是索引文件，是额外提供查找消息的手段，不影响主流程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 Key 或者时间区间来查询对应的消息，文件名以创建时间戳命名，固定的单个 IndexFile 文件大小约为400M，一个 IndexFile 存储 2000W个索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看看以上三种文件的内容是如何生成的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5296610169491526&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8hUbkaTY0U841EVwZaXODlgrMwbA8FJgiavy2NicTUEQmIyxUGzDP3TGmFlG9vMmGs5fUaHN4OqLjQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;944&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息到了先存储到 Commitlog，然后会有一个 ReputMessageService 线程接近实时地将消息转发给消息消费队列文件与索引文件，也就是说是异步生成的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消息刷盘机制&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocketMQ 提供消息同步刷盘和异步刷盘两个选择，关于刷盘我们都知道效率比较低，单纯存入内存中的话效率是最高的，但是可靠性不高，影响消息可靠性的情况大致有以下几种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Broker 被暴力关闭，比如 kill -9&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Broker 挂了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;操作系统挂了&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;机器断电&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;机器坏了，开不了机&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;磁盘坏了&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果都是 1-4 的情况，同步刷盘肯定没问题，异步的话就有可能丢失部分消息，5 和 6就得依靠副本机制了，如果同步双写肯定是稳的，但是性能太差，如果异步则有可能丢失部分消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以需要看场景来使用同步、异步刷盘和副本双写机制。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;页缓存与内存映射&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Commitlog 是混合存储的，所以所有消息的写入就是顺序写入，对文件的顺序写入和内存的写入速度基本上没什么差别。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且 RocketMQ 的文件都利用了内存映射即 Mmap，将程序虚拟页面直接映射到页缓存上，无需有内核态再往用户态的拷贝，来看一下我之前文章画的图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4167424931756142&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6Q8hUbkaTY0U841EVwZaXODlUMw38VO0lqGCrKP3rQPqUQNcMCwhju5jWERAen3MrfiawkNSpOPVqXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1099&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;页缓存其实就是操作系统对文件的缓存，用来加速文件的读写，也就是说对文件的写入先写到页缓存中，操作系统会不定期刷盘（时间不可控），对文件的读会先加载到页缓存中，并且根据局部性原理还会预读临近块的内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实也是因为使用内存映射机制，所以 RocketMQ 的文件存储都使用定长结构来存储，方便一次将整个文件映射至内存中。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;文件预分配和文件预热&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而内存映射也只是做了映射，只有当真正读取页面的时候产生缺页中断，才会将数据真正加载到内存中，所以 RocketMQ 做了一些优化，防止运行时的性能抖动。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;文件预分配&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CommitLog 的大小默认是1G，当超过大小限制的时候需要准备新的文件，而 RocketMQ 就起了一个后台线程 AllocateMappedFileService，不断的处理 AllocateRequest，AllocateRequest 其实就是预分配的请求，会提前准备好下一个文件的分配，防止在消息写入的过程中分配文件，产生抖动。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;文件预热&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一个 warmMappedFile 方法，它会把当前映射的文件，每一页遍历多去，写入一个0字节，然后再调用mlock 和 madvise(MADV_WILLNEED)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mlock：可以将进程使用的部分或者全部的地址空间锁定在物理内存中，防止其被交换到 swap 空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;madvise：给操作系统建议，说这文件在不久的将来要访问的，因此，提前读几页可能是个好主意。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结一下&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CommitLog 采用混合型存储，也就是所有 Topic 都存在一起，顺序追加写入，文件名用起始偏移量命名。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息先写入 CommitLog 再通过后台线程分发到 ConsumerQueue 和 IndexFile 中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者先读取 ConsumerQueue 得到真正消息的物理地址，然后访问 CommitLog 得到真正的消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用了 mmap 机制减少一次拷贝，利用文件预分配和文件预热提高性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提供同步和异步刷盘，根据场景选择合适的机制。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Broker 的 HA&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 Broker 会和主 Broker 建立长连接，然后获取主 Broker commitlog 最大偏移量，开始向主 Broker 拉取消息，主 Broker 会返回一定数量的消息，循环进行，达到主从数据同步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者消费消息会先请求主 Broker ，如果主 Broker 觉得现在压力有点大，则会返回从 Broker 拉取消息的建议，然后消费者就去从服务器拉取消息。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Consumer&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费有两种模式，分别是广播模式和集群模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;广播模式：一个分组下的每个消费者都会消费完整的Topic 消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;集群模式：一个分组下的消费者瓜分消费Topic 消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般我们用的都是集群模式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而消费者消费消息又分为推和拉模式，详细看我这篇文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MjEyNTk1Ng==&amp;amp;mid=2247485324&amp;amp;idx=1&amp;amp;sn=ce900c8438936ab6f3ed21105e099236&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;消息队列推拉模式&lt;/a&gt;，分别从源码级别分析了 RokcetMQ 和 Kafka 的消息推拉，以及推拉模式的优缺点。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Consumer 端的负载均衡机制&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Consumer 会定期的获取 Topic 下的队列数，然后再去查找订阅了该 Topic 的同一消费组的所有消费者信息，默认的分配策略是类似分页排序分配。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将队列排好序，然后消费者排好序，比如队列有 9 个，消费者有 3 个，那消费者-1 消费队列 0、1、2 的消息，消费者-2 消费队列 3、4、5，以此类推。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以如果负载太大，那么就加队列，加消费者，通过负载均衡机制就可以感知到重平衡，均匀负载。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Consumer 消息消费的重试&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;难免会遇到消息消费失败的情况，所以需要提供消费失败的重试，而一般的消费失败要么就是消息结构有误，要么就是一些暂时无法处理的状态，所以立即重试不太合适。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RocketMQ 会给&lt;span&gt;每个消费组&lt;/span&gt;都设置一个重试队列，Topic 是 &lt;code&gt;%RETRY%+consumerGroup&lt;/code&gt;，并且设定了很多重试级别来延迟重试的时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了利用 RocketMQ 的延时队列功能，重试的消息会先保存在 Topic 名称为“SCHEDULE_TOPIC_XXXX”的延迟队列，在消息的扩展字段里面会存储原来所属的 Topic 信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;delay 一段时间后再恢复到重试队列中，然后 Consumer 就会消费这个重试队列主题，得到之前的消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果超过一定的重试次数都消费失败，则会移入到死信队列，即 Topic &lt;code&gt;%DLQ%&quot; + ConsumerGroup&lt;/code&gt; 中，存储死信队列即认为消费成功，因为实在没辙了，暂时放过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们可以通过人工来处理死信队列的这些消息。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消息的全局顺序和局部顺序&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;全局顺序就是消除一切并发，一个 Topic 一个队列，Producer 和 Consuemr 的并发都为一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;局部顺序其实就是指某个队列顺序，多队列之间还是能并行的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过 MessageQueueSelector 指定 Producer 某个业务只发这一个队列，然后 Comsuer 通过MessageListenerOrderly 接受消息，其实就是加锁消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Broker 会有一个 mqLockTable ，顺序消息在创建拉取消息任务的时候需要在 Broker 锁定该消息队列，之后加锁成功的才能消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而严格的顺序消息其实很难，假设现在都好好的，如果有个 Broker 宕机了，然后发生了重平衡，队列对应的消费者实例就变了，就会有可能会出现乱序的情况，如果要保持严格顺序，那此时就只能让整个集群不可用了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一些注意点&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、订阅消息是以 ConsumerGroup 为单位存储的，所以ConsumerGroup 中的每个 Consumer 需要有相同的订阅。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为订阅消息是随着心跳上传的，如果一个 ConsumerGroup 中 Consumer 订阅信息不一样，那么就会出现互相覆盖的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如消费者 A 订阅 Topic a，消费者 B 订阅 Topic b，此时消费者 A 去 Broker 拿消息，然后 B 的心跳包发出了，Broker 更新了，然后接到 A 的请求，一脸懵逼，没这订阅关系啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、RocketMQ 主从读写分离&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从只能读，不能写，并且只有当前客户端读的 offset 和 当前 Broker 已接受的最大 offset 超过限制的物理内存大小时候才会去从读，所以&lt;span&gt;正常情况下从分担不了流量&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、单单加机器提升不了消费速度，队列的数量也需要跟上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、之前提到的，不要允许自动创建主题&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;RocketMQ 的最佳实践&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些最佳实践部分参考自官网。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Tags的使用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建议一个应用一个 Topic，利用 tages 来标记不同业务，因为 tages 设置比较灵活，且一个应用一个 Topic 很清晰，能直观的辨别。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Keys的使用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有消息业务上的唯一标识，请填写到 keys 字段中，方便日后的定位查找。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;提高 Consumer 的消费能力&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、提高消费并行度：增加队列数和消费者数量，提高单个消费者的并行消费线程，参数 consumeThreadMax。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、批处理消费，设置 consumeMessageBatchMaxSize 参数，这样一次能拿到多条消息，然后比如一个 update语句之前要执行十次，现在一次就执行完。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、跳过非核心的消息，当负载很重的时候，为了保住那些核心的消息，设置那些非核心的消息，例如此时消息堆积 1W 条了之后，就直接返回消费成功，跳过非核心消息。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;NameServer 的寻址&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请使用 HTTP 静态服务器寻址（默认），这样 NameServer 就能动态发现。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;JVM选项&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下抄自官网：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不关心 RocketMQ Broker的启动时间，通过“预触摸” Java 堆以确保在 JVM 初始化期间每个页面都将被分配。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那些不关心启动时间的人可以启用它：-XX:+AlwaysPreTouch
禁用偏置锁定可能会减少JVM暂停， -XX:-UseBiasedLocking
至于垃圾回收，建议使用带JDK 1.8的G1收集器。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;-XX:+UseG1GC -XX:G1HeapRegionSize=16m&lt;br/&gt;-XX:G1ReservePercent=25
-XX:InitiatingHeapOccupancyPercent=30&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外不要把-XX:MaxGCPauseMillis的值设置太小，否则JVM将使用一个小的年轻代来实现这个目标，这将导致非常频繁的minor GC，所以建议使用rolling GC日志文件:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;-XX:+UseGCLogFileRotation&lt;br/&gt;-XX:NumberOfGCLogFiles=5
-XX:GCLogFileSize=30m&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Linux内核参数&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下抄自官网：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;vm.extra_free_kbytes&lt;/span&gt;，告诉VM在后台回收（kswapd）启动的阈值与直接回收（通过分配进程）的阈值之间保留额外的可用内存。RocketMQ使用此参数来避免内存分配中的长延迟。（与具体内核版本相关）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;vm.min_free_kbytes&lt;/span&gt;，如果将其设置为低于1024KB，将会巧妙的将系统破坏，并且系统在高负载下容易出现死锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;vm.max_map_count&lt;/span&gt;，限制一个进程可能具有的最大内存映射区域数。RocketMQ将使用mmap加载CommitLog和ConsumeQueue，因此建议将为此参数设置较大的值。（agressiveness --&amp;gt; aggressiveness）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;vm.swappiness&lt;/span&gt;，定义内核交换内存页面的积极程度。较高的值会增加攻击性，较低的值会减少交换量。建议将值设置为10来避免交换延迟。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;File descriptor limits&lt;/span&gt;，RocketMQ需要为文件（CommitLog和ConsumeQueue）和网络连接打开文件描述符。我们建议设置文件描述符的值为655350。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Disk scheduler，RocketMQ建议使用I/O截止时间调度器，它试图为请求提供有保证的延迟。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实还有很多没讲，比如流量控制、消息的过滤、定时消息的实现，包括底层通信 1+N+M1+M2 的 Reactor 多线程设计等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要是内容太多了，而且也不太影响主流程，所以还是剥离出来之后写吧，大致的一些实现还是讲了的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;包括元信息的交互、消息的发送、存储、消费等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于事务消息的那一块我之前文章也分析过了，所以这个就不再贴了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到要实现一个生产级别的消息队列还是有很多很多东西需要考虑的，不过大致的架构和涉及到的模块差不多就这些了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于具体的细节深入，还是得靠大家自行研究了，我就起个抛砖引玉的作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后个人能力有限，如果哪里有纰漏请抓紧联系鞭挞我！还有我搞了个群如果想&lt;span&gt;进群就&lt;/span&gt;&lt;span&gt;备注下进群&lt;/span&gt;&lt;span&gt;，我拉你。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1018711018711018&quot; data-type=&quot;png&quot; data-w=&quot;962&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/azicia1hOY6QibmkLn34VaEbwibz2OoPFuAJia3uojrYUyxpIO8UI1Z51hbYJzn7munuEJBm7yFx3dc97ZJcRosT9xQ/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;span&gt;还有当当&lt;/span&gt;&lt;span&gt;四折买书&lt;/span&gt;&lt;span&gt;的优惠码没多少名额了，要囤书的抓紧了哟，下单使用优惠码「&lt;/span&gt;&lt;span&gt;MACNXV&lt;/span&gt;&lt;span&gt;&lt;span/&gt;」，&lt;/span&gt;&lt;span&gt;160买400的书&lt;/span&gt;&lt;span&gt;，&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MjEyNTk1Ng==&amp;amp;mid=2247485954&amp;amp;idx=2&amp;amp;sn=42e13e46a558e127707c5d8930416813&amp;amp;chksm=ce0de0e9f97a69ffc2672b5d1673a7881af8415708d7395f44b7f4235147d217ed8d92b2fcb1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;推荐的书单&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;推荐的书单&lt;/a&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我是 yes，从一点点到亿点点，我们下篇见&lt;/span&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>