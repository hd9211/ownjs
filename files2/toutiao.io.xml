<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>4a225e2d07d887526ac95e9ada8924b5</guid>
<title>面试过 200 人的经验，都在这里了 | 码农周刊第 325 期</title>
<link>https://toutiao.io/k/xvysg5s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;面试过 200 人的经验，都在这里了 | 码农周刊第 325 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第325期（2020-11-25）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=325&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3250&quot; target=&quot;_blank&quot;&gt;薪资翻番如何实现？程序员的涨薪秘诀&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=325&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3250&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_321.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=325&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;相比 cocos2d 引擎有着更低的入门门槛和维护成本，为复杂动画的实现提供了一种全新的方式，新的复杂动画开发将会变得更加简单高效。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;让您享受极简编程体验，快速访问支付宝开放平台开放的各项核心能力。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;一个不错的 Python 学习教程，30 天循序渐进地教你学会 Python。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;白皮书从技术、市场、趋势、挑战等多维度，对我国开源产业生态进行了全面、深度的剖析，指出了我国开源产业发展的几大重要趋势。&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        
        &lt;p&gt;经验总结&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;一步步教你&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        
        &lt;p&gt;供参考&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;收藏吧&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;实用&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;使用方便&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;一步步教你&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;良心教程&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;你怎么看？&lt;/p&gt;
        
        &lt;p&gt;深入研究&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;技术总结，经验分享&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 451179 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 429587 即可&lt;/p&gt;
        
        &lt;p&gt;分享计算机视觉与机器学习技术的最前沿&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 359575 即可&lt;/p&gt;
        
        &lt;p&gt;聚焦基础架构和Linux。十年架构，日百亿流量，与你探讨高并发世界，给你不一样的味道。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 351247 即可&lt;/p&gt;
        
        &lt;p&gt;学习就是不停的积累&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 24912 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;本手册以开发工程师为中心视角，划分为单元测试、安全规约、MySQL 数据库、工程结构等七个维度，相应的扩展解释和说明、正例和反例，全面、立体、形象地帮助开发工程师成长。欢迎到&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;兑换阅读。&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;个人经历&lt;/p&gt;
        
        &lt;p&gt;一直被追赶，从未被超越&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1f786ba95836ef5d64cf6bf036d47411</guid>
<title>[推荐] 最近做 Code Review 的 5 点经验分享</title>
<link>https://toutiao.io/k/5sw3syp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;最近两周项目代码提交到我这里来review的每周有20多个commit。也和同事聊天一起探讨了一下，几点自己认为需要注意的地方拿出来探讨一下。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;以尽量小的单元提交push&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;其实我review代码的时候比较开放。有些仁者见仁的风格问题，除非统一内部讨论定下来，我是会放过的。比如有些人喜欢用lambda表达式，有些人喜欢用传统的for each。风格不同，没有必要让别人按照自己的想法来。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但是有一点哈，每次提交到负责review人那边的代码尽量一次不要太多。可以将一个开发功能事先拆分好。每次以不超过2个新增类。除了全局替换的，共不超过5个修改类为宜。或者提交的代码功能单一。一些代码优化，删除废弃代码什么的至少要在修改内容里标出。最好单独提code review申请。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为什么要这样呢？因为一次提交的代码太多了。从code review者的角度来讲：看代码的时候很可能联系不起来到底是出于什么功能修改的，一些问题可能会被漏掉。降低code review的质量。从开发者的角度来讲，一次开发考虑太多的东西，很可能每个都没有考虑细致到位。思路相对也没有那么清晰。在写代码被打断的时候，可能会中断其中一点的思考，一些要改进的漏掉了。相对是危险的操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;lombok的callSuper属性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;这个是一个自己有没有思考的问题。拷贝别人的代码的时候要想一想。下面的代码大家想一想要不要cullSuper？&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Setter&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Getter&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@ToString&lt;/span&gt;(callSuper = &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; User &lt;span class=&quot;code-snippet__keyword&quot;&gt;implements&lt;/span&gt; Serializable {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; Integer id;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; name;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; password;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; Integer age;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;实际运行结果如下：这时候User的super类的toString方法调用的object的toString就是打印类的全限定名@内存地址。对我们来说没有实际的参考价值，不建议用callSuper。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.437636761487965&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8okc6NNSYkYmhRIUeZ7y24DANrZibH76OfKe7jz3xSV1BOzNuGMcB456qicE97iah5YlkCxGUIOuGEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;914&quot;/&gt;&lt;/p&gt;&lt;p&gt;大家再思考下下面呢？&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Data&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; Pojo {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; value;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__meta&quot;&gt;@NotBlank&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; detail;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Setter&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@Getter&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;@ToString&lt;/span&gt;(callSuper = &lt;span class=&quot;code-snippet__literal&quot;&gt;true&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;class&lt;/span&gt; User &lt;span class=&quot;code-snippet__keyword&quot;&gt;extends&lt;/span&gt; Pojo{&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; Integer id;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; name;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;code-snippet__built_in&quot;&gt;String&lt;/span&gt; password;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;private&lt;/span&gt; Integer age;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;这里的callSuper父类也是一个用户自己定义的类，它的属性是我们需要了解的，callSuper一点问题也没有。&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.44713656387665196&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8okc6NNSYkYmhRIUeZ7y24tZVMOnbBSt3tpasOT8VCjjreqDyueMVXlUEqEYpW2kXPIC2ibSZWiaZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;908&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;业务代码建议定义非RuntimeException&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;一般我们使用的jar包中已经定义好了基本足够用的异常类型，我们可以直接拿来用。但是自定义异常也经常被见到。而且它们被使用通常只有一种情况：要标识出这个异常是某个特定的服务或者功能抛出的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那为什么要用非RuntimeException呢？在《&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485101&amp;amp;idx=1&amp;amp;sn=c95f1a3fa03af199c78d59bb29ea411c&amp;amp;chksm=fafdec03cd8a6515f61cf42d3ce94ee7bc465f445cb61d4644d259c55a661cce4ab1a6dc4738&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Java异常处理总结&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Java异常处理总结&lt;/a&gt;&lt;span&gt;》&lt;/span&gt;这篇文章中有提到。RuntimeException是非检查异常，其他Exception是检查异常。非检查异常不需要显示处理，而检查异常会提示要try catch或者throw不然编译不通过。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;非检查异常一般用于开发者小心一点就可以避免的异常，比如除以零，操作异常这样的。对于业务开发来说，这种异常何必让系统处理呢，自己不除以零就好，正常操作就好。如果定义为非检查异常，有些需要用户自己处理的异常可能会被漏掉了。所以不建议。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;给客户端用的接口自己吞掉异常要小心&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;从代码架构上来讲，一个服务，如果分成给前端用的接口模块、给其他业务RPC用的接口模块、后台服务接口模块的话。前端用的接口模块我通常是自己处理异常不向外抛出。而所有的RPC接口都是明确抛出一个自定义异常的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;之所以这样是因为如果后端是java的话，前端一般是js等，异常的交互很不友好。前端处理很麻烦。而RPC接口，调用端也是后台语言。调用端是处理异常可以获取更详细的异常信息。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;举个之前遇到的异常的例子：&lt;/p&gt;&lt;p&gt;之前一个获取秘钥的接口，在获取秘钥失败的时候改了逻辑。没有抛出异常而是返回空字符串。调用端将其作为正常结果处理。结果有次这个接口出问题了。调用的服务正常启动，需要用秘钥来进行后续处理的地方全都异常了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果这个地方，秘钥接口出错是抛出异常。因为当时获取秘钥是启动时加载。那么发版时这台机器就会无法启动。错误立即暴露出来。而线上发布都是低峰期灰度发布。所以几台机器没有启动没有影响。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;java接口定义不要加任何修饰符号&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;阿里巴巴编程规范里有写：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2940038684719536&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibXVp5n1DFp1JtdRXTRzXDiaGYFV4lxviaia4lxjWS73m2S7lWkTGYGBLFtBibIbUDG7ojrgHmEUM8iaew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1034&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>077b7873d0d2767a3141e374b4d47c4d</guid>
<title>[推荐] 架构师之路：微服务技术选型</title>
<link>https://toutiao.io/k/bxvxty9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为一名架构师，需要规划产品技术路线，负责技术选型。而技术栈选型主要参考以下几个标准：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;安全稳定，不能经常被爆出安全漏洞&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;开源社区活跃度，加入Apache的组件优先考虑&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一线互联网公司落地产品，有大公司为其背书&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;文档阅读性好&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇为大家带来微服务架构的后端技术选型，当你需要进行技术选型时，可以参照他来设计自己的决策树。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;开发语言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;JAVA&lt;/strong&gt;&lt;br/&gt;主流编程语言，适合构建大型后台服务&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Golang&lt;/strong&gt;&lt;br/&gt;Go语言是谷歌2009发布的第二款开源编程语言。专门针对多处理器系统应用程序的编程进行了优化，使用Go编译的程序可以媲美C或C++代码的速度，而且更加安全、支持并行进程。Google对Go寄予厚望。其设计是让软件充分发挥多核心处理器同步多工的优点，并可解决面向对象程序设计的麻烦。目前作为云计算领域的不二之选！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;开发IDE&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;IntelliJ IDEA&lt;/strong&gt;&lt;br/&gt;jetbrains公司旗下产品，智能代码助手、J2EE支持、各类版本工具(git、svn、github等)、JUnit、CVS整合等。多语言支持，免费版只支持JAVA等少数语言。旗舰版为收费版本，同时提供免费版（功能上较旗舰版有减少）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;VS Code&lt;/strong&gt;&lt;br/&gt;VS Code是一款免费的、开源的、高性能的、跨平台的、轻量级的代码编辑器，同时，在性能，语言支持、开源社区方面也做的很不错！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;开发技术&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;微服务框架&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Spring Cloud / Spring Cloud alibaba&lt;/strong&gt;&lt;br/&gt;Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，提供了全套微服务解决方案。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;RPC框架&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;RestTemplate&amp;amp;WebClient&lt;br/&gt;&lt;/strong&gt;Spring RestTemplate 是 Spring 提供的用于访问 Rest 服务的客户端&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;gRPC&lt;/strong&gt;&lt;br/&gt;GRPC是google开源的一个高性能、跨语言的RPC框架，基于HTTP2协议，基于protobuf 3.x的一款rpc框架。多种语言支持；支持链接复用，集群内可采用长链接；性能简单调优后，可满足多数业务场景需求。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分布式事务&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Seata&lt;/strong&gt;&lt;br/&gt;阿里巴巴重点开源项目、Java开发、性能高、无锁、代码无侵入AT模式0代码、支持MT模式非事务型存储、社区活跃，版本更新快，使用简单！&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;流量控制、熔断降级&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Sentinel&lt;/strong&gt;&lt;br/&gt;阿里巴巴重点开源项目、Java开发、二次开发方便、社区活跃&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;API网关&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Spring Cloud Gateway&lt;/strong&gt;&lt;br/&gt;Spring首选、方便二次开发、支持异步非阻塞&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Kong&lt;/strong&gt;&lt;br/&gt;Kong是一款基于Nginx_Lua模块写的高可用，易扩展由Mashape公司开源的API Gateway项目。性能优异，插件丰富基本开箱即用，二开有一定的使用门槛。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;配置中心&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Nacos&lt;/strong&gt;：&lt;br/&gt;阿里巴巴重点开源项目、可同时作为注册/中心配置中心，简化技术栈、有完善管理界面、Java开发、二次开发方便、社区活跃、还在不断更新迭代。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Apollo&lt;/strong&gt;：&lt;br/&gt;是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;服务发现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Nacos:&lt;/strong&gt;&lt;br/&gt;阿里巴巴重点开源项目、可同时作为注册/中心配置中心，简化技术栈、有完善管理界面、Java开发、二次开发方便、社区活跃、AP/CP模式，还在不断更新迭代。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Zookeeper&lt;/strong&gt;：&lt;br/&gt;ZooKeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件；性能可以满足较大规模的服务发现和配置中心，生效实时性高，不适合大规模实时数据同步场景；CP模式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;监控&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Prometheus&lt;/strong&gt;&lt;br/&gt;功能较为全面的开源监控系统，CNCF技术栈、社区活跃&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Grafana&lt;/strong&gt;&lt;br/&gt;Grafana是一个开源的度量分析与可视化套件。纯 Javascript 开发的前端工具，通过访问库（如InfluxDB），展示自定义报表、显示图表等。大多使用在时序数据的监控方面，如同Kibana类似。Grafana的UI更加灵活，有丰富的插件，功能强大。界面简洁美观，支持自由定制，社区有丰富的Dashboard支持。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;SkyWalking&lt;/strong&gt;&lt;br/&gt;分布式追踪系统，国产链路跟踪、社区文档丰富，Apache顶级项目。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;日志&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ELK&lt;/strong&gt;&lt;br/&gt;分布式服务日志处理，围绕elasticsearch构建的日志生态系统。使用广泛，扩展方便。配合kibana可以很方便对日志进行检索，定位线上问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据库中间&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ShardingSphere&lt;/strong&gt;&lt;br/&gt;Apache ShardingSphere 定位为关系型数据库中间件，支持数据分片、读写分离、多数据副本、数据加密、影子库压测等功能；社区文档丰富，目前已经成为Apache顶级项目。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;序列化&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Jackson&lt;/strong&gt;&lt;br/&gt;Spring首选、稳定&lt;strong&gt;安全&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;protobuf&lt;/strong&gt;&lt;br/&gt;Protocol Buffer( 简称Protobuf) 是google开源的一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，很适合做数据存储或RPC 数据交换格式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;不建议使用fastjson&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;开发工具&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;构建工具&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Maven:&lt;/strong&gt;&lt;br/&gt;主流的项目构建和管理工具，Maven是 Apache 下的一个纯 Java 开发的开源项目，是一个项目构建和管理的工具；它提供了帮助管理 构建、文档、报告、依赖、scms、发布、分发的方法。可以方便的编译代码、进行依赖管理、管理二进制库等等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Gradle&lt;br/&gt;&lt;/strong&gt;Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化建构工具。Gradle 构建脚本使用的是 Groovy 或 Kotlin 的特定领域语言来编写,它可以自动处理包相依关系，自动处理布署问题，条件判断写法直觉。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;接口请求工具&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;postman&lt;/strong&gt;&lt;br/&gt;postman是一款功能强大的网页调试和模拟发送HTTP请求的Chrome插件，支持几乎所有类型的HTTP请求，操作简单且方便。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;容器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Docker&lt;/strong&gt;&lt;br/&gt;是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。使用Docker可以带来以下几个优势：1. 更快速的交付和部署；2. 高效的部署和扩容；3. 更高的资源利用率；4. 简单的管理&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;集群管理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Kubernetes&lt;/strong&gt;&lt;br/&gt;Kubernetes一个用于容器集群的自动化部署、扩容以及运维的开源平台。通过Kubernetes,你可以快速有效地响应用户需求;快速而有预期地部署你的应用;极速地扩展你的应用;无缝对接新应用功能;节省资源，优化硬件资源的使用。为容器编排管理提供了完整的开源方案。生态丰富，易扩展；功能丰富稳定，大公司背书；易上手。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;镜像管理工具&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Harbor&lt;/strong&gt;&lt;br/&gt;Harbor是个开源制品（artifact）仓库，是首个原创于中国、并且成为 CNCF 毕业级的开源项目。用户可通过策略和基于角色的访问控制来保护制品（如容器镜像、Helm Chart等），扫描镜像并避免受安全漏洞的危害。Harbor扩展了开源项目 Docker Distribution，添加了用户所需的功能（例如安全性，身份，漏洞扫描和管理）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;运行环境&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;操作系统：&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Linux&amp;lt;CentOS 7+&amp;gt;&lt;/strong&gt;&lt;br/&gt;Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Web服务器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Tomcat&amp;lt;8+&amp;gt;&lt;/strong&gt;&lt;br/&gt;Tomcat 服务器是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Nginx&lt;/strong&gt;&lt;br/&gt;轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;NodeJs&lt;/strong&gt;&lt;br/&gt;服务端JavaScript环境&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c9c1855f9927fa3dcea976f8cd9ccf97</guid>
<title>[推荐] 程序员必知必会的十大排序算法</title>
<link>https://toutiao.io/k/zoyne3a</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;绪论&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;身为程序员，十大排序是是所有合格程序员所必备和掌握的，并且热门的算法比如快排、归并排序还可能问的比较细致，对算法性能和复杂度的掌握有要求。bigsai作为一个负责任的Java和数据结构与算法方向的小博主，在这方面肯定不能让读者们有所漏洞。跟着本篇走，带你捋一捋常见的十大排序算法，轻轻松松掌握！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先对于排序来说大多数人对排序的概念停留在冒泡排序或者JDK中的Arrays.sort()，手写各种排序对很多人来说都是一种奢望，更别说十大排序算法了，不过还好你遇到了本篇文章！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于排序的分类，主要不同的维度比如复杂度来分、内外部、比较非比较等维度来分类。我们正常讲的十大排序算法是内部排序，我们更多将他们分为两大类：基于&lt;strong&gt;「比较和非比较」&lt;/strong&gt;这个维度去分排序种类。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「非比较类的有桶排序、基数排序、计数排序」&lt;/strong&gt;。也有很多人将排序归纳为8大排序，那就是因为基数排序、计数排序是建立在桶排序之上或者是一种特殊的桶排序，但是基数排序和计数排序有它特有的特征，所以在这里就将他们归纳为10种经典排序算法。而比较类排序也可分为&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;比较类排序也有更细致的分法，有基于交换的、基于插入的、基于选择的、基于归并的，更细致的可以看下面的脑图。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6503623188405797&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThzO89HSicFib3OHh3XbfTWfpkRha8Nz7KiacJSWJq6ORrM98v8aqdsZegeR4RjicjgH36HfrvSn2sicsGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2208&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;脑图&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;交换类&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;冒泡排序&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;冒泡排序，又称起泡排序，它是一种基于交换的排序典型，也是快排思想的基础，冒泡排序是一种稳定排序算法，时间复杂度为O(n^2).基本思想是：&lt;strong&gt;「循环遍历多次每次从前往后把大元素往后调，每次确定一个最大(最小)元素，多次后达到排序序列。」&lt;/strong&gt;(或者从后向前把小元素往前调)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体思想为(把大元素往后调)：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;从第一个元素开始往后遍历，每到一个位置判断是否比后面的元素大，如果比后面元素大，那么就交换两者大小，然后继续向后，这样的话进行一轮之后就可以保证&lt;strong&gt;「最大的那个数被交换交换到最末的位置可以确定」&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二次同样从开始起向后判断着前进，如果当前位置比后面一个位置更大的那么就和他后面的那个数交换。但是有点注意的是，这次并不需要判断到最后，只需要判断到倒数第二个位置就行(因为第一次我们已经确定最大的在倒数第一，这次的目的是确定倒数第二)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;同理，后面的遍历长度每次减一，直到第一个元素使得整个元素有序。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如&lt;code&gt;2 5 3 1 4&lt;/code&gt;排序过程如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5840867992766727&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThzO89HSicFib3OHh3XbfTWfpkFGxhaBkDice3bvxWU7CMeHAR7ZkoiaErmtTdRbsFD0yZLy3ic1tFo1Lyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2212&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;实现代码为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;  &lt;span&gt;maopaosort&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] a)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;// TODO Auto-generated method stub&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=a.length-&lt;span&gt;1&lt;/span&gt;;i&amp;gt;=&lt;span&gt;0&lt;/span&gt;;i--)&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;i;j++)&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt;(a[j]&amp;gt;a[j+&lt;span&gt;1&lt;/span&gt;])&lt;br/&gt;      {&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; team=a[j];&lt;br/&gt;        a[j]=a[j+&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;        a[j+&lt;span&gt;1&lt;/span&gt;]=team;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;快速排序&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;快速排序是对冒泡排序的一种改进，采用递归分治的方法进行求解。而快排相比冒泡是一种不稳定排序,时间复杂度最坏是O(n^2),平均时间复杂度为O(nlogn),最好情况的时间复杂度为O(nlogn)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于快排来说，&lt;strong&gt;「基本思想」&lt;/strong&gt;是这样的&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;快排需要将序列变成两个部分，就是&lt;strong&gt;「序列左边全部小于一个数」&lt;/strong&gt;，&lt;strong&gt;「序列右面全部大于一个数」&lt;/strong&gt;，然后利用递归的思想再将左序列当成一个完整的序列再进行排序，同样把序列的右侧也当成一个完整的序列进行排序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;其中这个数在这个序列中是可以随机取的，可以取最左边，可以取最右边，当然也可以取随机数。但是&lt;strong&gt;「通常」&lt;/strong&gt;不优化情况我们取最左边的那个数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4367606915377616&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThzO89HSicFib3OHh3XbfTWfpkBoom9vCVosjTa6mMOU9ESMmNOiaPP13iaubcwc5UOdNa3oEHy6WIPEsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2198&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;实现代码为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;quicksort&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; [] a,&lt;span&gt;int&lt;/span&gt; left,&lt;span&gt;int&lt;/span&gt; right)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; low=left;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; high=right;&lt;br/&gt;  &lt;span&gt;//下面两句的顺序一定不能混，否则会产生数组越界！！！very important！！！&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(low&amp;gt;high)&lt;span&gt;//作为判断是否截止条件&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; k=a[low];&lt;span&gt;//额外空间k，取最左侧的一个作为衡量，最后要求左侧都比它小，右侧都比它大。&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt;(low&amp;lt;high)&lt;span&gt;//这一轮要求把左侧小于a[low],右侧大于a[low]。&lt;/span&gt;&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(low&amp;lt;high&amp;amp;&amp;amp;a[high]&amp;gt;=k)&lt;span&gt;//右侧找到第一个小于k的停止&lt;/span&gt;&lt;br/&gt;    {&lt;br/&gt;      high--;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;//这样就找到第一个比它小的了&lt;/span&gt;&lt;br/&gt;    a[low]=a[high];&lt;span&gt;//放到low位置&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(low&amp;lt;high&amp;amp;&amp;amp;a[low]&amp;lt;=k)&lt;span&gt;//在low往右找到第一个大于k的，放到右侧a[high]位置&lt;/span&gt;&lt;br/&gt;    {&lt;br/&gt;      low++;&lt;br/&gt;    }&lt;br/&gt;    a[high]=a[low];   &lt;br/&gt;  }&lt;br/&gt;  a[low]=k;&lt;span&gt;//赋值然后左右递归分治求之&lt;/span&gt;&lt;br/&gt;  quicksort(a, left, low-&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;  quicksort(a, low+&lt;span&gt;1&lt;/span&gt;, right);  &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;插入类排序&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;直接插入排序&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接插入排序在所有排序算法中的是最简单排序方式之一。和我们上学时候 从前往后、按高矮顺序排序，那么一堆高低无序的人群中，从第一个开始，如果前面有比自己高的，就直接插入到合适的位置。&lt;strong&gt;「一直到队伍的最后一个完成插入」&lt;/strong&gt;整个队列才能满足有序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接插入排序遍历比较时间复杂度是每次O(n),交换的时间复杂度每次也是O(n),那么n次总共的时间复杂度就是O(n^2)。有人会问折半(二分)插入能否优化成O(nlogn),答案是不能的。因为二分只能减少查找复杂度每次为O(logn),而插入的时间复杂度每次为O(n)级别，这样总的时间复杂度级别还是O(n^2).&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;插入排序的具体步骤：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;选取当前位置(当前位置前面已经有序) 目标就是将当前位置数据插入到前面合适位置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;向前枚举或者二分查找，找到待插入的位置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;移动数组，赋值交换，达到插入效果。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.39831401475237094&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThzO89HSicFib3OHh3XbfTWfpkhwLBNnotVCL99PGSdiaHxuk51XWm6KydEx4gDgmsUzcfOlictse7gYKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1898&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;实现代码为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;insertsort&lt;/span&gt; &lt;span&gt;(&lt;span&gt;int&lt;/span&gt; a[])&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; team=&lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;1&lt;/span&gt;;i&amp;lt;a.length;i++)&lt;br/&gt;  {&lt;br/&gt;    System.out.println(Arrays.toString(a));&lt;br/&gt;    team=a[i];&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=i-&lt;span&gt;1&lt;/span&gt;;j&amp;gt;=&lt;span&gt;0&lt;/span&gt;;j--)&lt;br/&gt;    {&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt;(a[j]&amp;gt;team)&lt;br/&gt;      {&lt;br/&gt;        a[j+&lt;span&gt;1&lt;/span&gt;]=a[j];&lt;br/&gt;        a[j]=team; &lt;br/&gt;      } &lt;br/&gt;      &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  } &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;希尔排序&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接插入排序因为是O(n^2),在数据量很大或者数据移动位次太多会导致效率太低。很多排序都会想办法拆分序列，然后组合，希尔排序就是以一种特殊的方式进行预处理，考虑到了&lt;strong&gt;「数据量和有序性」&lt;/strong&gt;两个方面纬度来设计算法。使得序列前后之间小的尽量在前面，大的尽量在后面，进行若干次的分组别计算，最后一组即是一趟完整的直接插入排序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一个&lt;code&gt;长串&lt;/code&gt;，希尔首先将序列分割(非线性分割)而是&lt;strong&gt;「按照某个数模」&lt;/strong&gt;(&lt;code&gt;取余&lt;/code&gt;这个类似报数1、2、3、4。1、2、3、4)这样形式上在一组的分割先&lt;strong&gt;「各组分别进行直接插入排序」&lt;/strong&gt;,这样&lt;strong&gt;「很小的数在后面」&lt;/strong&gt;可以通过&lt;strong&gt;「较少的次数移动到相对靠前」&lt;/strong&gt;的位置。然后慢慢合并变长，再稍稍移动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为每次这样插入都会使得序列变得更加有序，稍微有序序列执行直接插入排序成本并不高。所以这样能够在合并到最终的时候基本小的在前，大的在后，代价越来越小。这样希尔排序相比插入排序还是能节省不少时间的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5086916742909423&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThzO89HSicFib3OHh3XbfTWfpkyr9XJQ5gwEaoH7maYp7oaLVfNfHQeA7QKZJoR0cKictREoatrjONZ6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2186&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;实现代码为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;shellsort&lt;/span&gt; &lt;span&gt;(&lt;span&gt;int&lt;/span&gt; a[])&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; d=a.length;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; team=&lt;span&gt;0&lt;/span&gt;;&lt;span&gt;//临时变量&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt;(;d&amp;gt;=&lt;span&gt;1&lt;/span&gt;;d/=&lt;span&gt;2&lt;/span&gt;)&lt;span&gt;//共分成d组&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=d;i&amp;lt;a.length;i++)&lt;span&gt;//到那个元素就看这个元素在的那个组即可&lt;/span&gt;&lt;br/&gt;    {&lt;br/&gt;      team=a[i];&lt;br/&gt;      &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=i-d;j&amp;gt;=&lt;span&gt;0&lt;/span&gt;;j-=d)&lt;br/&gt;      {    &lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(a[j]&amp;gt;team)&lt;br/&gt;        {&lt;br/&gt;          a[j+d]=a[j];&lt;br/&gt;          a[j]=team; &lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;          &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;    } &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;选择类排序&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;简单选择排序&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到&lt;strong&gt;「已排序序列的末尾」&lt;/strong&gt;。以此类推，直到所有元素均排序完毕。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6903137789904502&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThzO89HSicFib3OHh3XbfTWfpkgHZ9L9j69x9mic3NL6aTyzkzeh22JCvYcMIeYica5XI9ttnbbBpicNQcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1466&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;实现代码为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;selectSort&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] arr)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; arr.length - &lt;span&gt;1&lt;/span&gt;; i++) {&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; min = i; &lt;span&gt;// 最小位置&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = i + &lt;span&gt;1&lt;/span&gt;; j &amp;lt; arr.length; j++) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (arr[j] &amp;lt; arr[min]) {&lt;br/&gt;        min = j; &lt;span&gt;// 更换最小位置&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (min != i) {&lt;br/&gt;      swap(arr, i, min); &lt;span&gt;// 与第i个位置进行交换&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;swap&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] arr, &lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt; j)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; temp = arr[i];&lt;br/&gt;  arr[i] = arr[j];&lt;br/&gt;  arr[j] = temp;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;堆排序&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于堆排序，首先是建立在堆的基础上，堆是一棵完全二叉树，还要先认识下大根堆和小根堆，完全二叉树中所有节点均大于(或小于)它的孩子节点，所以这里就分为两种情况&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果所有节点&lt;strong&gt;「大于」&lt;/strong&gt;孩子节点值，那么这个堆叫做&lt;strong&gt;「大根堆」&lt;/strong&gt;，堆的最大值在根节点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果所有节点&lt;strong&gt;「小于」&lt;/strong&gt;孩子节点值，那么这个堆叫做&lt;strong&gt;「小根堆」&lt;/strong&gt;，堆的最小值在根节点。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3686030428769018&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThzO89HSicFib3OHh3XbfTWfpkibLdVLtsPpdcRUSTEfYbEjoibHCxRlHb1HIUZD5EXfv68DDTKZqkkskg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1446&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;堆排序首先就是&lt;strong&gt;「建堆」&lt;/strong&gt;，然后再是调整。对于二叉树(数组表示)，我们从下往上进行调整，从&lt;strong&gt;「第一个非叶子节点」&lt;/strong&gt;开始向前调整，对于调整的规则如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建堆是一个O(n)的时间复杂度过程，建堆完成后就需要进行删除头排序。给定数组建堆(creatHeap)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;①从第一个非叶子节点开始判断交换下移(shiftDown)，使得当前节点和子孩子能够保持堆的性质&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;②但是普通节点替换可能没问题，对如果交换打破子孩子堆结构性质，那么就要重新下移(shiftDown)被交换的节点一直到停止。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4158183241973375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThzO89HSicFib3OHh3XbfTWfpk8d13ULBl3fxpwVjxPydCtEmOXNFTRbmQiaictE6xEj8iaKxbOvibdJEFpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1277&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;堆构造完成，取第一个堆顶元素为最小(最大)，剩下左右孩子依然满足堆的性值，但是缺个堆顶元素，如果给孩子调上来，可能会调动太多并且可能破坏堆结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;①所以索性把最后一个元素放到第一位。这样只需要判断交换下移(shiftDown）,不过需要注意此时整个堆的大小已经发生了变化，我们在逻辑上不会使用被抛弃的位置，所以在设计函数的时候需要附带一个堆大小的参数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;②重复以上操作，一直堆中所有元素都被取得停止。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5374094931617055&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThzO89HSicFib3OHh3XbfTWfpksIDD39OT0wBiaafyQWr9OANTTvTUVPKMSia3Vv6h2hFST4xqmFmFTcuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1243&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;而堆算法复杂度的分析上，之前建堆时间复杂度是O(n)。而每次删除堆顶然后需要向下交换，每个个数最坏为logn个。这样复杂度就为O(nlogn).总的时间复杂度为O(n)+O(nlogn)=O(nlogn).&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实现代码为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;swap&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; arr[],&lt;span&gt;int&lt;/span&gt; m,&lt;span&gt;int&lt;/span&gt; n)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; team=arr[m];&lt;br/&gt;  arr[m]=arr[n];&lt;br/&gt;  arr[n]=team;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//下移交换 把当前节点有效变换成一个堆(小根)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;shiftDown&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; arr[],&lt;span&gt;int&lt;/span&gt; index,&lt;span&gt;int&lt;/span&gt; len)&lt;/span&gt;&lt;span&gt;//0 号位置不用&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; leftchild=index*&lt;span&gt;2&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;;&lt;span&gt;//左孩子&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; rightchild=index*&lt;span&gt;2&lt;/span&gt;+&lt;span&gt;2&lt;/span&gt;;&lt;span&gt;//右孩子&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(leftchild&amp;gt;=len)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(rightchild&amp;lt;len&amp;amp;&amp;amp;arr[rightchild]&amp;lt;arr[index]&amp;amp;&amp;amp;arr[rightchild]&amp;lt;arr[leftchild])&lt;span&gt;//右孩子在范围内并且应该交换&lt;/span&gt;&lt;br/&gt;  {&lt;br/&gt;    swap(arr, index, rightchild);&lt;span&gt;//交换节点值&lt;/span&gt;&lt;br/&gt;    shiftDown(arr, rightchild, len);&lt;span&gt;//可能会对孩子节点的堆有影响，向下重构&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(arr[leftchild]&amp;lt;arr[index])&lt;span&gt;//交换左孩子&lt;/span&gt;&lt;br/&gt;  {&lt;br/&gt;    swap(arr, index, leftchild);&lt;br/&gt;    shiftDown(arr, leftchild, len);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;//将数组创建成堆&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;creatHeap&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; arr[])&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=arr.length/&lt;span&gt;2&lt;/span&gt;;i&amp;gt;=&lt;span&gt;0&lt;/span&gt;;i--)&lt;br/&gt;  {&lt;br/&gt;    shiftDown(arr, i,arr.length);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;heapSort&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; arr[])&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  System.out.println(&lt;span&gt;&quot;原始数组为         ：&quot;&lt;/span&gt;+Arrays.toString(arr));&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; val[]=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[arr.length]; &lt;span&gt;//临时储存结果&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;//step1建堆&lt;/span&gt;&lt;br/&gt;  creatHeap(arr);&lt;br/&gt;  System.out.println(&lt;span&gt;&quot;建堆后的序列为  ：&quot;&lt;/span&gt;+Arrays.toString(arr));&lt;br/&gt;  &lt;span&gt;//step2 进行n次取值建堆，每次取堆顶元素放到val数组中，最终结果即为一个递增排序的序列&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;arr.length;i++)&lt;br/&gt;  {&lt;br/&gt;    val[i]=arr[&lt;span&gt;0&lt;/span&gt;];&lt;span&gt;//将堆顶放入结果中&lt;/span&gt;&lt;br/&gt;    arr[&lt;span&gt;0&lt;/span&gt;]=arr[arr.length-&lt;span&gt;1&lt;/span&gt;-i];&lt;span&gt;//删除堆顶元素，将末尾元素放到堆顶&lt;/span&gt;&lt;br/&gt;    shiftDown(arr, &lt;span&gt;0&lt;/span&gt;, arr.length-i);&lt;span&gt;//将这个堆调整为合法的小根堆，注意(逻辑上的)长度有变化&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;//数值克隆复制&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;arr.length;i++)&lt;br/&gt;  {&lt;br/&gt;    arr[i]=val[i];&lt;br/&gt;  }&lt;br/&gt;  System.out.println(&lt;span&gt;&quot;堆排序后的序列为:&quot;&lt;/span&gt;+Arrays.toString(arr));&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;归并类排序&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在归并类排序一般只讲归并排序，但是归并排序也分二路归并、多路归并，这里就讲较多的二路归并排序，且用递归方式实现。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;归并排序&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;归并和快排都是&lt;strong&gt;「基于分治算法」&lt;/strong&gt;的，分治算法其实应用挺多的，很多分治会用到递归，但事实上&lt;strong&gt;「分治和递归是两把事」&lt;/strong&gt;。分治就是分而治之，可以采用递归实现，也可以自己遍历实现非递归方式。而归并排序就是先将问题分解成代价较小的子问题，子问题再采取代价较小的合并方式完成一个排序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于归并的思想是这样的：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一次：整串先进行划分成一个一个单独，第一次是将序列中(&lt;code&gt;1 2 3 4 5 6---&lt;/code&gt;)两两归并成有序，归并完(&lt;code&gt;xx xx xx xx----&lt;/code&gt;)这样局部有序的序列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二次就是两两归并成若干四个(&lt;code&gt;1 2 3 4 5 6 7 8 ----&lt;/code&gt;)&lt;strong&gt;「每个小局部是有序的」&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;就这样一直到最后这个串串只剩一个，然而这个耗费的总次数logn。每次操作的时间复杂的又是&lt;code&gt;O(n)&lt;/code&gt;。所以总共的时间复杂度为&lt;code&gt;O(nlogn)&lt;/code&gt;.&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7037914691943128&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThzO89HSicFib3OHh3XbfTWfpkcjPHp459F3tpeU9HEFLzowFX3FJiczmia6icb9IbaH8jeN6f0JggY8nzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1688&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;合并为一个O(n)的过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7901234567901234&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThzO89HSicFib3OHh3XbfTWfpkicrYjJ1vFTEqT4nC3HyicDyndSHiclibUXEdUxic9lM1dfzvte1zthUGA1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1296&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;实现代码为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;mergesort&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] array, &lt;span&gt;int&lt;/span&gt; left, &lt;span&gt;int&lt;/span&gt; right)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; mid=(left+right)/&lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(left&amp;lt;right)&lt;br/&gt;  {&lt;br/&gt;    mergesort(array, left, mid);&lt;br/&gt;    mergesort(array, mid+&lt;span&gt;1&lt;/span&gt;, right);&lt;br/&gt;    merge(array, left,mid, right);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;merge&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] array, &lt;span&gt;int&lt;/span&gt; l, &lt;span&gt;int&lt;/span&gt; mid, &lt;span&gt;int&lt;/span&gt; r)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; lindex=l;&lt;span&gt;int&lt;/span&gt; rindex=mid+&lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; team[]=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[r-l+&lt;span&gt;1&lt;/span&gt;];&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; teamindex=&lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (lindex&amp;lt;=mid&amp;amp;&amp;amp;rindex&amp;lt;=r) {&lt;span&gt;//先左右比较合并&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(array[lindex]&amp;lt;=array[rindex])&lt;br/&gt;    {&lt;br/&gt;      team[teamindex++]=array[lindex++];&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;else&lt;/span&gt; {    &lt;br/&gt;      team[teamindex++]=array[rindex++];&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt;(lindex&amp;lt;=mid)&lt;span&gt;//当一个越界后剩余按序列添加即可&lt;/span&gt;&lt;br/&gt;  {&lt;br/&gt;    team[teamindex++]=array[lindex++];&lt;br/&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt;(rindex&amp;lt;=r)&lt;br/&gt;  {&lt;br/&gt;    team[teamindex++]=array[rindex++];&lt;br/&gt;  } &lt;br/&gt;  &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;teamindex;i++)&lt;br/&gt;  {&lt;br/&gt;    array[l+i]=team[i];&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;桶类排序&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;桶排序&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;桶排序是一种用空间换取时间的排序，桶排序重要的是它的思想，而不是具体实现，时间复杂度最好可能是线性O(n)，桶排序不是基于比较的排序而是一种分配式的。桶排序从字面的意思上看：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;桶：若干个桶，说明此类排序将数据放入若干个桶中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;桶：每个桶有容量，桶是有一定容积的容器，所以每个桶中可能有多个元素。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;桶：从整体来看，整个排序更希望桶能够更匀称，即既不溢出(太多)又不太少。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;桶排序的思想为：&lt;strong&gt;「将待排序的序列分到若干个桶中，每个桶内的元素再进行个别排序。」&lt;/strong&gt;  当然桶排序选择的方案跟具体的数据有关系，桶排序是一个比较广泛的概念，并且计数排序是一种特殊的桶排序，基数排序也是建立在桶排序的基础上。在数据分布均匀且每个桶元素趋近一个时间复杂度能达到O(n),但是如果数据范围较大且相对集中就不太适合使用桶排序。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8197146562905318&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThzO89HSicFib3OHh3XbfTWfpkg6DWXdnn4Yy7JGiboGMb9pj1R17wUYeZ3YT5H3DSibHsxUXJFibBMqT9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1542&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;实现一个简单桶排序：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; java.util.ArrayList;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; java.util.List;&lt;br/&gt;&lt;span&gt;//微信公众号：bigsai&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;bucketSort&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; a[]= {&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;8&lt;/span&gt;,&lt;span&gt;7&lt;/span&gt;,&lt;span&gt;44&lt;/span&gt;,&lt;span&gt;42&lt;/span&gt;,&lt;span&gt;46&lt;/span&gt;,&lt;span&gt;38&lt;/span&gt;,&lt;span&gt;34&lt;/span&gt;,&lt;span&gt;33&lt;/span&gt;,&lt;span&gt;17&lt;/span&gt;,&lt;span&gt;15&lt;/span&gt;,&lt;span&gt;16&lt;/span&gt;,&lt;span&gt;27&lt;/span&gt;,&lt;span&gt;28&lt;/span&gt;,&lt;span&gt;24&lt;/span&gt;};&lt;br/&gt;  List[] buckets=&lt;span&gt;new&lt;/span&gt; ArrayList[&lt;span&gt;5&lt;/span&gt;];&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;buckets.length;i++)&lt;span&gt;//初始化&lt;/span&gt;&lt;br/&gt;  {&lt;br/&gt;   buckets[i]=&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;a.length;i++)&lt;span&gt;//将待排序序列放入对应桶中&lt;/span&gt;&lt;br/&gt;  {&lt;br/&gt;   &lt;span&gt;int&lt;/span&gt; index=a[i]/&lt;span&gt;10&lt;/span&gt;;&lt;span&gt;//对应的桶号&lt;/span&gt;&lt;br/&gt;   buckets[index].add(a[i]);&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;buckets.length;i++)&lt;span&gt;//每个桶内进行排序(使用系统自带快排)&lt;/span&gt;&lt;br/&gt;  {&lt;br/&gt;   buckets[i].sort(&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j=&lt;span&gt;0&lt;/span&gt;;j&amp;lt;buckets[i].size();j++)&lt;span&gt;//顺便打印输出&lt;/span&gt;&lt;br/&gt;   {&lt;br/&gt;    System.out.print(buckets[i].get(j)+&lt;span&gt;&quot; &quot;&lt;/span&gt;);&lt;br/&gt;   }&lt;br/&gt;  } &lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;计数排序&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计数排序是一种特殊的桶排序，每个桶的大小为1，每个桶不在用List表示，而通常用一个值用来计数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;strong&gt;「设计具体算法的时候」&lt;/strong&gt;，先找到最小值min，再找最大值max。然后创建这个区间大小的数组,从min的位置开始计数，这样就可以最大程度的压缩空间，提高空间的使用效率。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6816568047337278&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThzO89HSicFib3OHh3XbfTWfpkPdhkTYOXhuyRHKnky7uPLW5o9ef8mgUO1ZW8dgmwxZ36G7tdia77DuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;845&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;countSort&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; a[])&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; min=Integer.MAX_VALUE;&lt;span&gt;int&lt;/span&gt; max=Integer.MIN_VALUE;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;a.length;i++)&lt;span&gt;//找到max和min&lt;/span&gt;&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(a[i]&amp;lt;min) &lt;br/&gt;      min=a[i];&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(a[i]&amp;gt;max)&lt;br/&gt;      max=a[i];&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; count[]=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;[max-min+&lt;span&gt;1&lt;/span&gt;];&lt;span&gt;//对元素进行计数&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;a.length;i++)&lt;br/&gt;  {&lt;br/&gt;    count[a[i]-min]++;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;//排序取值&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; index=&lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;count.length;i++)&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (count[i]--&amp;gt;&lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      a[index++]=i+min;&lt;span&gt;//有min才是真正值&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;基数排序&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基数排序是一种很容易理解但是比较难实现(优化)的算法。基数排序也称为卡片排序，基数排序的原理就是多次利用计数排序(计数排序是一种特殊的桶排序)，但是和前面的普通桶排序和计数排序有所区别的是，&lt;strong&gt;「基数排序并不是将一个整体分配到一个桶中」&lt;/strong&gt;，而是将自身拆分成一个个组成的元素，每个元素分别顺序分配放入桶中、顺序收集，当从前往后或者从后往前每个位置都进行过这样顺序的分配、收集后，就获得了一个有序的数列。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.418426103646833&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThzO89HSicFib3OHh3XbfTWfpkBibpnLFrHe3kOSq7ar4fTxQU16gEbiaoOWnM2CGRsHp1H9Wze4WyHssA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2084&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;如果是数字类型排序，那么这个桶只需要装0-9大小的数字，但是如果是字符类型，那么就需要注意ASCII的范围。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以遇到这种情况我们基数排序思想很简单，就拿 934，241，3366，4399这几个数字进行基数排序的一趟过程来看，第一次会根据各位进行分配、收集：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4780952380952381&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThzO89HSicFib3OHh3XbfTWfpkZa4LEm9soqTcgIBAJdw5dF9GN6ia7r2KrdXPKQxyhicnXY7RXtVRDQtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2100&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;分配和收集都是有序的，第二次会根据十位进行分配、收集，此次是在第一次个位分配、收集基础上进行的，所以所有数字单看个位十位是有序的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.485024154589372&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThzO89HSicFib3OHh3XbfTWfpkBrqDzfk6KP21dn2hU2BibcYlPnKVlB5tRR5c1Jn4zjWpfEo5lkVMYhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2070&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;而第三次就是对百位进行分配收集，此次完成之后百位及其以下是有序的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46948818897637795&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThzO89HSicFib3OHh3XbfTWfpkScWJOvm8zntbWuQa9nP9cm98AdLA6jWKpZrVJuecPBue42ZpbpFL3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2032&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;而最后一次的时候进行处理的时候，千位有的数字需要补零，这次完毕后后千位及以后都有序，即整个序列排序完成。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.47214076246334313&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThzO89HSicFib3OHh3XbfTWfpkohRCaJhwBg4QUFQfpg1XHzssIVSib9m4gcV2Yrs3rJeqTHPKHtg9MDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2046&quot;/&gt;&lt;span/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;简单实现代码为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;radixSort&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt;[] arr)&lt;/span&gt;&lt;span&gt;//int 类型 从右往左&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;  List&amp;lt;Integer&amp;gt;bucket[]=&lt;span&gt;new&lt;/span&gt; ArrayList[&lt;span&gt;10&lt;/span&gt;];&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;&lt;span&gt;10&lt;/span&gt;;i++)&lt;br/&gt;  {&lt;br/&gt;    bucket[i]=&lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;//找到最大值&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; max=&lt;span&gt;0&lt;/span&gt;;&lt;span&gt;//假设都是正数&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt;arr.length;i++)&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(arr[i]&amp;gt;max)&lt;br/&gt;      max=arr[i];&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;int&lt;/span&gt; divideNum=&lt;span&gt;1&lt;/span&gt;;&lt;span&gt;//1 10 100 100……用来求对应位的数字&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (max&amp;gt;&lt;span&gt;0&lt;/span&gt;) {&lt;span&gt;//max 和num 控制&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; num:arr)&lt;br/&gt;    {&lt;br/&gt;      bucket[(num/divideNum)%&lt;span&gt;10&lt;/span&gt;].add(num);&lt;span&gt;//分配 将对应位置的数字放到对应bucket中&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    divideNum*=&lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;    max/=&lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; idx=&lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;//收集 重新捡起数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt;(List&amp;lt;Integer&amp;gt;list:bucket)&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; num:list)&lt;br/&gt;      {&lt;br/&gt;        arr[idx++]=num;&lt;br/&gt;      }&lt;br/&gt;      list.clear();&lt;span&gt;//收集完需要清空留下次继续使用&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，基数排序还有字符串等长、不等长、一维数组优化等各种实现需要需学习，具体可以参考公众号内其他文章。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;结语&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本次十大排序就这么潇洒的过了一遍，我想大家都应该有所领悟了吧！对于算法总结，避免不必要的劳动力，我分享这个表格给大家：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;排序算法&lt;/th&gt;&lt;th&gt;平均时间复杂度&lt;/th&gt;&lt;th&gt;最好&lt;/th&gt;&lt;th&gt;最坏&lt;/th&gt;&lt;th&gt;空间复杂度&lt;/th&gt;&lt;th&gt;稳定性&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;冒泡排序&lt;/td&gt;&lt;td&gt;O(n^2)&lt;/td&gt;&lt;td&gt;O(n)&lt;/td&gt;&lt;td&gt;O(n^2)&lt;/td&gt;&lt;td&gt;O(1)&lt;/td&gt;&lt;td&gt;稳定&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;快速排序&lt;/td&gt;&lt;td&gt;O(nlogn)&lt;/td&gt;&lt;td&gt;O(nlogn)&lt;/td&gt;&lt;td&gt;O(n^2)&lt;/td&gt;&lt;td&gt;O(logn)&lt;/td&gt;&lt;td&gt;不稳定&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;插入排序&lt;/td&gt;&lt;td&gt;O(n^2)&lt;/td&gt;&lt;td&gt;O(n)&lt;/td&gt;&lt;td&gt;O(n^2)&lt;/td&gt;&lt;td&gt;O(1)&lt;/td&gt;&lt;td&gt;稳定&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;希尔排序&lt;/td&gt;&lt;td&gt;O(n^1.3)&lt;/td&gt;&lt;td&gt;O(n)&lt;/td&gt;&lt;td&gt;O(nlog2n)&lt;/td&gt;&lt;td&gt;O(1)&lt;/td&gt;&lt;td&gt;不稳定&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;选择排序&lt;/td&gt;&lt;td&gt;O(n^2)&lt;/td&gt;&lt;td&gt;O(n^2)&lt;/td&gt;&lt;td&gt;O(n^2)&lt;/td&gt;&lt;td&gt;O(1)&lt;/td&gt;&lt;td&gt;不稳定&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;堆排序&lt;/td&gt;&lt;td&gt;O(nlogn)&lt;/td&gt;&lt;td&gt;O(nlogn)&lt;/td&gt;&lt;td&gt;O(nlogn)&lt;/td&gt;&lt;td&gt;O(1)&lt;/td&gt;&lt;td&gt;不稳定&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;归并排序&lt;/td&gt;&lt;td&gt;O(nlogn)&lt;/td&gt;&lt;td&gt;O(nlogn)&lt;/td&gt;&lt;td&gt;O(nlogn)&lt;/td&gt;&lt;td&gt;O(n)&lt;/td&gt;&lt;td&gt;稳定&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;桶排序&lt;/td&gt;&lt;td&gt;O(n+k)&lt;/td&gt;&lt;td&gt;O(n+k)&lt;/td&gt;&lt;td&gt;O(n+k)&lt;/td&gt;&lt;td&gt;O(n+k)&lt;/td&gt;&lt;td&gt;稳定&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;计数排序&lt;/td&gt;&lt;td&gt;O(n+k)&lt;/td&gt;&lt;td&gt;O(n+k)&lt;/td&gt;&lt;td&gt;O(n+k)&lt;/td&gt;&lt;td&gt;O(k)&lt;/td&gt;&lt;td&gt;稳定&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;基数排序&lt;/td&gt;&lt;td&gt;O(n*k)&lt;/td&gt;&lt;td&gt;O(n*k)&lt;/td&gt;&lt;td&gt;O(n*k)&lt;/td&gt;&lt;td&gt;O(n+k)&lt;/td&gt;&lt;td&gt;稳定&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;原创不易，bigsai请你帮两件事帮忙一下:&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;点赞、在看、分享支&lt;/strong&gt;&lt;/span&gt;持一下， 您的肯定是我创作的源源动力。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;微信搜索「&lt;strong&gt;「bigsai」&lt;/strong&gt;」，关注我的公众号，不仅免费送你电子书，我还会第一时间在公众号分享知识技术。&lt;strong&gt;加我还可拉你进力扣打卡群&lt;/strong&gt;一起打卡LeetCode。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记得关注、咱们下次再见！&lt;/p&gt;&lt;section&gt;&lt;strong&gt;近期精彩：&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MTE1NjA2Mg==&amp;amp;mid=2247485498&amp;amp;idx=1&amp;amp;sn=1487f8657949d2cb849d2f0e6f953c96&amp;amp;chksm=ce1a2f8bf96da69db0778dd445662d8d1ed59706b716787f8bbb524560473bfae8221ddb0a3c&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;「万字图文」史上最姨母级Java继承详解&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MTE1NjA2Mg==&amp;amp;mid=2247485144&amp;amp;idx=1&amp;amp;sn=2624bdd152e1bbaba99d3363943999d3&amp;amp;chksm=ce1a2169f96da87fd4a36009a31c7567bdb34b009a2acf4ed17edeee645d147082a62b0a4532&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;图解|双轴快排分析&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MTE1NjA2Mg==&amp;amp;mid=2247484764&amp;amp;idx=1&amp;amp;sn=abc1ca0a2470f0bb2e3d543fc66ced4d&amp;amp;chksm=ce1a22edf96dabfba04b385be4c3dcc3e8b726572c9a947a9de23187ca505eaa207123fb02ed&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;MongoDB助力一个物流订单系统&lt;/a&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MTE1NjA2Mg==&amp;amp;mid=2247485126&amp;amp;idx=2&amp;amp;sn=d443dcabfacf4082ab089a453ca209dd&amp;amp;chksm=ce1a2177f96da861e0040e4afdd30ad2a668c5070e1a630b43df4f60b1f72f9fb2daff26e939&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;面试官:什么是缓存穿透、缓存雪崩、缓存击穿？&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MTE1NjA2Mg==&amp;amp;mid=2247485341&amp;amp;idx=1&amp;amp;sn=9322f5ea2eca0fb3f6927d87c3b532fb&amp;amp;chksm=ce1a202cf96da93a615868dba376b98d77561b88cdcc776bd58c4dd8e00d52b9b9267ad9f3a1&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;16张图带你彻底搞懂基数排序&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2MTE1NjA2Mg==&amp;amp;mid=2247485201&amp;amp;idx=1&amp;amp;sn=e2eb19410784b5bcb085d1e6775b6966&amp;amp;chksm=ce1a20a0f96da9b69778cabb9d09f70dfedef073fcc47acd131060934611c991099aac57dff9&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;8张图带你分析Redis与MySQL数据一致性问题&lt;/a&gt;&lt;/section&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3579175704989154&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Lia5wemIHThzO89HSicFib3OHh3XbfTWfpkz3MPz4z4aQWDDSdicmSz2qgghYda9psNPW2Jo37U0O5GhJB1yNosbxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2766&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d827e236b6a0f8512fcd66587d7cded6</guid>
<title>[推荐] 超全面分布式缓存高可用方案：哨兵机制</title>
<link>https://toutiao.io/k/1k0udg9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;1&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;2&quot;&gt;开发工作中对于分布式缓存高可用方案（搭建Redis缓存高可用方案），Redis主从架构下是如何保证高可用的呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;3&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;4&quot;&gt;我们知道是应用了哨兵机制来实现。那Redis 服务部署的哨兵模式主要是什么，又解决了什么问题呢，于是利用周末时间整理了下，相信看完这篇文章，你也可以去给别人做技术分享了。O(∩_∩)O哈哈~&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id-heading0=&quot;&quot; data-slate-type=&quot;pm_heading&quot; data-slate-object=&quot;block&quot; data-key=&quot;5&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;6&quot;&gt;问题铺垫&lt;/span&gt;&lt;/h2&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;7&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;8&quot;&gt;在讨论哨兵模式之前，我们先来看一个应用问题：&lt;span data-slate-leaf=&quot;true&quot; data-offset-key=&quot;9:0&quot; data-first-offset=&quot;true&quot;&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;Redis服务主机宕机&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;10&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;11&quot;&gt;实际使用过程中，会出现master宕机的情况（这样会导致没有写服务，只有读服务）。那我们要保证服务的可用，就需要从其他salve节点中选取一个来作为master节点，来继续提供服务能力。&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;12&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;13&quot;&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;那主要的动作抽象下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;12&quot;&gt;&lt;span&gt;将宕机的master下线&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;12&quot;&gt;&lt;span&gt;找一个slave作为master&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;12&quot;&gt;&lt;span&gt;通知所有的slave连接新的master&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;12&quot;&gt;&lt;span&gt;全量数据或者部分数据同步&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;27&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;28&quot;&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;其中存在几个问题：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;39&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;40&quot;&gt;其实引入&lt;span data-slate-leaf=&quot;true&quot; data-offset-key=&quot;41:0&quot; data-first-offset=&quot;true&quot;&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;哨兵机制&lt;/strong&gt;&lt;/span&gt;，就可以很好的解决上述问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4745011086474501&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgRzuof9uYrBaBicdVQUFNKQGeE7b36CFd05okdB5QbQjNicl4DjZaHu0HTtZluCRXb33ycxDnMHTTHg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;902&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;哨兵-Redis集群&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id-heading1=&quot;&quot; data-slate-type=&quot;pm_heading&quot; data-slate-object=&quot;block&quot; data-key=&quot;46&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;47&quot;&gt;什么是哨兵？&lt;/span&gt;&lt;/h2&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;48&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;49&quot;&gt;Sentinel（哨兵）是Redis 的高可用性解决方案：由一个或多个Sentinel 实例组成的Sentinel 系统可以监视任意多个主服务，以及这些主服务器属下的所有从服务，并在被监视的主服务进入下线（不可服务）状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器。&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;50&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;51&quot;&gt;﻿&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;52&quot;&gt;&lt;span&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;总结一下哨兵的作用：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;58&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;59&quot;&gt;    不断的检查master和slave是否正常运行（master存活检测、master与slave运行情况检测）&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;64&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;65&quot;&gt;    当被监控的服务器出现问题时，向其他哨兵、客户端发送通知&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;70&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;71&quot;&gt;    断开故障master与slave的连接，选取一个slave作为新master，将其他slave连接到新的master并告知客户端新的服务器地址。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-slate-type=&quot;pm_blockquote&quot; data-slate-object=&quot;block&quot; data-key=&quot;74&quot;&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;75&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;76&quot;&gt;注意：哨兵也是一台Redis服务器，只是不提供数据服务；通常哨兵配置的数量为单数。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-id-heading2=&quot;&quot; data-slate-type=&quot;pm_heading&quot; data-slate-object=&quot;block&quot; data-key=&quot;77&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;78&quot;&gt;哨兵的工作原理&lt;/span&gt;&lt;/h2&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;79&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;80&quot;&gt;下面主要针对哨兵在进行故障转移过程中经历的三个阶段分别进行阐述。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-id-heading3=&quot;&quot; data-slate-type=&quot;pm_heading&quot; data-slate-object=&quot;block&quot; data-key=&quot;81&quot;&gt;&lt;span&gt;1、集群监控&lt;/span&gt;&lt;/h3&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;83&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;84&quot;&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;step1：哨兵1连接到Redis集群&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;83&quot;&gt;&lt;span&gt;发送info命令到master，并建立cmd连接；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;83&quot;&gt;&lt;span&gt;哨兵端保存哨兵状态（SentinelStatus），保存所有哨兵状态，主节点和从节&lt;/span&gt;&lt;span&gt;点的信息；master端会记录 redis 实例的信息（SentinelRedisInstance）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;83&quot;&gt;&lt;span&gt;哨兵根据master中获取的每个slave信息，去连接每个slave，发送同样也是info命令。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5700197238658777&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgRzuof9uYrBaBicdVQUFNKQGxxPLNq0TXY3mJAGKUGGVJywOJazQmAvGFTUicJdozhhPuc2PADdSQtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1014&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;集群监控&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;96&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;97&quot;&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;step2：哨兵2加入进来后&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;96&quot;&gt;&lt;span&gt;同样会发送info命令到master节点，并建立cmd连接；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;96&quot;&gt;&lt;span&gt;发现master中存在其他哨兵节点的信息，哨兵2中保存哨兵信息（区别与哨兵1的是它保存了哨兵1和哨兵2的2个哨兵节点信息）；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;96&quot;&gt;&lt;span&gt;为了每个哨兵的信息都一致它们之间建立了一个发布订阅。为了哨兵之间的信息长期对称它们之间也会互发 ping 命令。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.46991869918699186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgRzuof9uYrBaBicdVQUFNKQGlojD0ib1yRRRG9n5Kp2y12BleUZjsmC7t0aY3IB1XCic99ZbKR0tczPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1230&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;集群监控&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;111&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;112&quot;&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;step3：哨兵3加入后&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6419354838709678&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgRzuof9uYrBaBicdVQUFNKQGZt1atOq0us0xswSM2DQ1ahy13bgE5Y75lXS46oo2jZo9vTqUvwFibpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;集群监控&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;123&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;124&quot;&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;小结一下：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-id-heading4=&quot;&quot; data-slate-type=&quot;pm_heading&quot; data-slate-object=&quot;block&quot; data-key=&quot;132&quot;&gt;&lt;span&gt;2、消息通知&lt;/span&gt;&lt;/h3&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;134&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;135&quot;&gt;1）Sentinel节点会通过master/slave 节点建立的cmd连接获取其工作状态&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;136&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;137&quot;&gt;2）Sentinel收到反馈结果之后，会在哨兵内部进行信息的互通&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4048059149722736&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgRzuof9uYrBaBicdVQUFNKQG8bwmsMVNqs7DysCvA5Nps2UHSop6fbYAzyDJiby1oGZDcmyniabPeh7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1082&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;消息通知&lt;/span&gt;&lt;/p&gt;&lt;h3 data-id-heading5=&quot;&quot; data-slate-type=&quot;pm_heading&quot; data-slate-object=&quot;block&quot; data-key=&quot;141&quot;&gt;&lt;span&gt;3、故障转移&lt;/span&gt;&lt;/h3&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;143&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;144&quot;&gt;关于故障转移，严格来讲可划分两个步骤：&lt;span data-slate-leaf=&quot;true&quot; data-offset-key=&quot;145:0&quot; data-first-offset=&quot;true&quot;&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;故障判定&lt;/strong&gt;&lt;/span&gt;、&lt;span data-slate-leaf=&quot;true&quot; data-offset-key=&quot;147:0&quot; data-first-offset=&quot;true&quot;&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;故障转移&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-id-heading6=&quot;&quot; data-slate-type=&quot;pm_heading&quot; data-slate-object=&quot;block&quot; data-key=&quot;149&quot;&gt;&lt;span&gt;Q1：如何判断一个节点出现故障？&lt;/span&gt;&lt;/h4&gt;&lt;blockquote data-slate-type=&quot;pm_blockquote&quot; data-slate-object=&quot;block&quot; data-key=&quot;155&quot;&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;156&quot;&gt;&lt;span&gt;直到主节点故障，哨兵报出 sdown，同时此哨兵还会向其他哨兵发布消息说这个主节点挂了。发送的指令是 sentinel is-master-down-by-address-port。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-slate-type=&quot;pm_blockquote&quot; data-slate-object=&quot;block&quot; data-key=&quot;164&quot;&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;165&quot;&gt;&lt;span&gt;其余的哨兵也会发送他们收到的信息并且发送指令 sentinel is-master-down-by-address-port 到自己的内网，确认一下第一个发送 sentinel is-master-down-by-address-port 的哨兵说你说的对，这个家伙确实挂了。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-slate-type=&quot;pm_blockquote&quot; data-slate-object=&quot;block&quot; data-key=&quot;173&quot;&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;174&quot;&gt;&lt;span&gt;当一个哨兵认为主节点挂了标记的是 sdown，当半数哨兵都认为挂了其标记的状态是 odown。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;176&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;177&quot;&gt;﻿&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;178&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;179&quot;&gt;一个哨兵认为master节点挂了称为主观下线（sdown），超半数哨兵认为master节点挂了则称为客观下线（odown）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.46855345911949686&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgRzuof9uYrBaBicdVQUFNKQGpV8htDDEVhmloCiahrbBbCDTGp7dulSXEe8HOicP9aEPzZXVz1tJ7Tag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1272&quot;/&gt;&lt;/p&gt;&lt;h4 data-id-heading7=&quot;&quot; data-slate-type=&quot;pm_heading&quot; data-slate-object=&quot;block&quot; data-key=&quot;183&quot;&gt;&lt;span&gt;Q2：如何进行故障转移？&lt;/span&gt;&lt;/h4&gt;&lt;section&gt;&lt;span&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;1）首先，哨兵选举出哨兵Leader去处理故障转移&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt; 此时选举方式应用的是Raft协议，这个之前有过介绍，感兴趣的同学可以移步了解：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA3MDg5MDkzOA==&amp;amp;mid=2448762601&amp;amp;idx=1&amp;amp;sn=8bfef19e832b46b423d7e48bdf836ed4&amp;amp;chksm=8b34623cbc43eb2a5abcf0a6e40c1c01d36929e4052cb9f77f82cc0c19fa9870e433c7cc8224&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;一致性算法Raft 简易入门&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;2）其次，哨兵Leader从所有的slave节点找出一个作为master节点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;193&quot;&gt;&lt;span&gt;主要的规则：&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;207&quot;&gt;&lt;span&gt;假如以上优先级均一致，会考虑其他优先原则：&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-slate-type=&quot;pm_blockquote&quot; data-slate-object=&quot;block&quot; data-key=&quot;213&quot;&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;214&quot;&gt;&lt;span&gt;假如说 slave1 的 offset 为 50，slave2 偏移量为 55，则哨兵就会选择 slave2 为新的主节点。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-slate-type=&quot;pm_blockquote&quot; data-slate-object=&quot;block&quot; data-key=&quot;222&quot;&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;223&quot;&gt;&lt;span&gt;这点类似于职场中的论资排辈，也就说根据 runid 的创建时间来判断，时间早的先上位。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;225&quot;&gt;&lt;span&gt;﻿&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;227&quot;&gt;&lt;span&gt;&lt;strong data-slate-type=&quot;pm_bold&quot; data-slate-object=&quot;mark&quot;&gt;3）数据转移&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id-heading8=&quot;&quot; data-slate-type=&quot;pm_heading&quot; data-slate-object=&quot;block&quot; data-key=&quot;236&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;237&quot;&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;238&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;239&quot;&gt;Redis 主从复制的作用中有这么一句话“主从复制是高可用的基石”，那实现高可用必不可少的就是哨兵和集群。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-id-heading9=&quot;&quot; data-slate-type=&quot;pm_heading&quot; data-slate-object=&quot;block&quot; data-key=&quot;240&quot;&gt;&lt;span&gt;1、Sentinel的作用&lt;/span&gt;&lt;/h3&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;246&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;247&quot;&gt;不断的检查master和slave是否正常运行（master存活检测、master与slave运行情况检测）&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;252&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;253&quot;&gt;当被监控的服务器出现问题时，向其他哨兵、客户端发送通知&lt;/span&gt;&lt;/p&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;258&quot;&gt;&lt;span data-slate-object=&quot;text&quot; data-key=&quot;259&quot;&gt;断开故障master与slave的连接，选取一个slave作为新master，将其他slave连接到新的master并告知客户端新的服务器地址。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-id-heading10=&quot;&quot; data-slate-type=&quot;pm_heading&quot; data-slate-object=&quot;block&quot; data-key=&quot;260&quot;&gt;&lt;span&gt;2、Sentinel的工作方式&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;blockquote data-slate-type=&quot;pm_blockquote&quot; data-slate-object=&quot;block&quot; data-key=&quot;269&quot;&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;270&quot;&gt;&lt;span&gt; 若 Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-slate-type=&quot;pm_blockquote&quot; data-slate-object=&quot;block&quot; data-key=&quot;279&quot;&gt;&lt;p data-slate-type=&quot;pm_paragraph&quot; data-slate-object=&quot;block&quot; data-key=&quot;280&quot;&gt;&lt;span&gt;若没有足够数量的 Sentinel 同意 Master 已经下线， Master 的客观下线状态就会被移除。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;hr/&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;往期热文推荐：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98311&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;395&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;395&quot; data-ratio=&quot;0.36484375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgSxEpr7AzM5lGCicdEjfuE6jaiae9Rmj1CVCg85GJKaFKuico89ZlnhGicQiciciccOiaqVibE5cmKXwO1AOuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;87502&quot;&gt;&lt;p&gt;&lt;span&gt;「技术架构精进」专注架构研究，技术分享&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Thanks for reading!&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>