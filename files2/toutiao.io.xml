<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>7c0d1705613a8c647790eeb3c956fa9a</guid>
<title>一年之计在于春！周末别闲着！</title>
<link>https://toutiao.io/k/32pyr3x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>082b56a83f77a5c414ae3d91f28a0ff1</guid>
<title>【真实案例】程序设计的陷阱-警惕大块数据</title>
<link>https://toutiao.io/k/423ti1x</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;无论是架构还是程序的设计，往大的方面说，逃不过&lt;/span&gt;&lt;strong&gt;&lt;span&gt;分治、分类&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;的范畴。&lt;/span&gt;&lt;span&gt;微服务是一种分治的思想；&lt;/span&gt;&lt;span&gt;service mesh是一种分治的思想；&lt;/span&gt;&lt;span&gt;G1是一种分治的思想；&lt;/span&gt;&lt;span&gt;大数据是一种分类的思想；&lt;/span&gt;&lt;span&gt;领域划分是一种分类的思想……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;数据大了会遇到问题，比如经典的redis的大key问题。遇到这类问题，主流解决方案是两个。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;一个是限制，比如超过多大就不处理了，只提示错误。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4225865209471767&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9csr5bLvWohaeCrKicQzMduqIgVnHOpIglV2eFJ0nSsHOMicxJiatUyW5CAicuyh7x3BiamO9vzic3zy0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;549&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;另外一个是分治，将数据分片处理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果这两个都没做？&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRl9csr5bLvWohaeCrKicQzMduhPoHiaGlJ34oicSSrTOUQKCAPjiat0CJrOhpMq9hKuNl0ialbcF09Gg82Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;案例一：请求超时了&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先回顾&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485729&amp;amp;idx=1&amp;amp;sn=325d273617410e48e3e8c1d8a103421c&amp;amp;chksm=fafde38fcd8a6a99b1c79a1b6bfd7d29cb925be129c2ad2608f28b7e93fb414384c5838568bd&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《近期做的稳定性建设总结》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《近期做的稳定性建设总结》&lt;/a&gt;里的一个案例：收到一个可用内存不足10%的告警，经过了两个小时才自动恢复到87%，所在的机器出现一笔请求超时。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;现象&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1、对业务进行了解发现开始出现问题的时间点，有收到外部MQ发过来的大块数据。虽然&lt;span&gt;大块数据&lt;/span&gt;做了分片，但是每个分片还是有几M大并且下发条数多，集中下发。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、分别在问题机器和其他相同应用的不同机器上执行top命令，观察到问题机器和其他机器上jvm内存占用差不多并且稳定。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3、执行free -h命令观察到&lt;span&gt;机器可用内存7.6G，&lt;/span&gt;cache/buffer下降到1G以下。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4、&lt;span&gt;收到外部MQ发过来的&lt;span&gt;大块数据&lt;/span&gt;&lt;/span&gt;时间段网卡占用情况从平时0.5M以下飙升到20M/S。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;5、&lt;span&gt;出现一笔请求超&lt;/span&gt;&lt;span&gt;时正在下发&lt;span&gt;大块数据&lt;/span&gt;的高峰期，请求方发请求到机器接收到请求时间间隔是几毫秒。收到请求后机器会将请求转发给MQ，用了3秒多。而请求方设置了5秒超时。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;6、所有环节cpu使用率都很低。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;7、20天前在另外一台机器上也发生了内存升高到90%以上的现象。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;总结来说：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;MQ集中接收10M内的大块数据，&lt;/span&gt;JVM内存占用正常，操作系统内存占用升高，网卡流量20M/S。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;此问题的根本原因是外部短时间内下发大量&lt;span&gt;大块数据&lt;/span&gt;(受节假日影响当天的&lt;span&gt;大块数据&lt;/span&gt;略高于其他天)，从根本上治理需要和外部(大佬级别，我们完全没有主动权)一起进行架构方面的调整，不现实也没有必要用此牛刀。&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;表现为虚机层面内存资源不足，影响了IO速率。因为高峰IO 20M/S，针对现在的千兆网卡、万兆网卡来说，并不大。问题并不在网络通道上，而在机器本身。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我写网络通信和linux操作系统系列也有一段时间了，大家可以用这个实际问题来小试牛刀。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486658&amp;amp;idx=1&amp;amp;sn=0067e6d161c0acac5cf20fda6231f692&amp;amp;chksm=fafde66ccd8a6f7a62114ebf73963d09253cb94bb8d47acea955f4b9bfacc37dfcb1ff22e4a5&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《深入浅出操作系统的零拷贝》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《深入浅出操作系统的零拷贝》&lt;/a&gt;中，我发起了一个投票：&lt;span&gt;使用零拷贝最少要进行几次拷贝？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;36%的人答对了，是2次。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;零拷贝如果只是从磁盘发送到网络，最低可以只用2次DMA拷贝，也就是内核空间拷贝。&lt;/span&gt;&lt;span&gt;但是实际情况是大多数场景，数据都需要回到用户空间进行数据处理，所以都需要3次以上。&lt;/span&gt;&lt;span&gt;加上数据往往进来还要出去。&lt;/span&gt;&lt;span&gt;所以10M的大块数据处理过程占用的内存是数倍于10M的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以最终我们提申请进行了纵向扩容。&lt;/span&gt;&lt;span&gt;纵向扩容说白了就是增加物理内存。&lt;/span&gt;&lt;span&gt;有人就要问了是不是扩机器数量也能解决问题。&lt;/span&gt;&lt;span&gt;这种处理方式大概是能治病但是不一定对症。&lt;/span&gt;&lt;span&gt;意思可以理解为吃广谱抗菌药来治疗感冒，有一定帮助但不是针对性的处理。&lt;/span&gt;&lt;span&gt;因为扩机器是减少了请求数从而减少了内存占用量。&lt;/span&gt;&lt;span&gt;但是万一有个大请求就是把内存飚高了呢？&lt;/span&gt;&lt;span&gt;并且扩内存实施成本更低，不需要程序的发布。&lt;/span&gt;&lt;span&gt;就是低峰期暂停程序，插个内存条。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;经过半年多的验证，超时再没有发生过，说明我们的处理方式是对症的。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;案例二：内存达到95%&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;生产环境有个不太核心的服务，共三台机器，一台机器内存达到95%。这个服务分成定时任务和实时请求处理两部分，其实定时任务流量占比居多，实时请求很少。所以我们将这台机器隔离掉定时任务。也就是说定时任务只走另外两台。目前内存稳定在95%，但是内存达到这么高的原因需要找到。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;服务的定时任务部分是调用RPC接口获取数据，之后RPC或者http请求发送到别处。每次处理的数据大小在几K。实时请求部分有个是处理文件上传的，文件的大小不固定，几M，几十M都是有可能的。这种请求一般情况下1天十笔，但是不固定。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;现象&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;1、使用pmap -x java程序进程号 命令，发现大量anon块，举例如下：&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;b7f0a000 8 rwx-- 00000000b7f0a000 000:00000 [ anon ]&lt;/span&gt;&lt;br/&gt;&lt;span&gt;b7f20000 8 rwx-- 00000000b7f20000 000:00000 [ anon ]&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、这个服务除了内存使用达到95%的这台机器，另外一台达到了93%，还有一台89%。备用机房的机器(无定时任务，也不接受实时请求)内存占用基本都是86%。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;分析&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;用pmap -x 查到的anon，中文叫匿名块。是通过malloc或mmap分配的“大”块。Java直接申请的堆内存之外的块就是堆外内存了。我查了代码，这个服务不涉及到数据库操作，没有使用guava等直接内存的。最有可能产生堆外内存的地方是&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486564&amp;amp;idx=2&amp;amp;sn=7ebfa62b34c22dd6c8170e67784d43dd&amp;amp;chksm=fafde6cacd8a6fdc4bded6a9bebe05bbac49cea08e06deb20d4a6d7ea1fe26864088b8857f83&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;nio&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;nio&lt;/a&gt;(使用了netty、jetty)。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;这个问题本来不是我在查，另外两个同事在做。但是一直没有结论，我就进行了介入。同事一直的思路是要找到内存泄露的地方。我分析可能不是内存泄露，因为最近几个月内存没有再增长。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;我任务运行的这半年内，有段时间可能有人批量上传大文件。&lt;span/&gt;&lt;span&gt;文件上传到哪台服务器是随机的，占用内存高的机器很有可能是当时处理的文件大或者多。&lt;/span&gt;&lt;span&gt;因为过去了快半年了，日志都清理了，我没有办法找到直接的证据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;同事还是想排查内存泄露问题。给出两个理由：第一，把定时任务停掉的机器最近内存稳定不再增长了。第二，他查了最近的日志，文件大小都在几M，而内存高的机器要内存使用高出了几百M。&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;我的答复：内存不再增长与定时任务停掉未必是因果。也可能是最近再也没有如此大块或大量的文件上传。另外，程序没有做限制，最近只有几M未必几个月前没有更的文件上传。另外，案例一里也说了，如果文件大于十几兆，其使用的内存要多出好几倍。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;同事觉得有道理，决定下周进行测试环境模拟验证，结果究竟如何呢？咱们来猜一猜。&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span class=&quot;vote_area&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;如果你的服务要处理大数据，但是又不想使用分治引入程序的复杂性，那么在申请机器的时候，要增加足够的内存冗余！&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有的朋友会觉得这个处理方式并不高大上。牛逼的处理方式是排查到内核层，调整个linux参数啥的。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;不推荐！&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;原因如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;现在也算比较流行的一个词叫做：不可变服务器。&lt;span&gt;“传统”的部署方式中，对系统的改动都会呈现在服务器上，从而增加了风险。&lt;/span&gt;&lt;span&gt;采用不可变部署方式，&lt;/span&gt;服务器都是公司统一标准化的，那么变更只要考虑应用程序的发布，而应用程序一旦发布也不允许改变，就成了不可变服务。不可变性可以增加系统的稳定性。在一个规模比较大的公司，就算可以通过技术解决资源的问题，从整体角度，还是通用方案更加可取。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外补充一个小知识：&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;使用pmap -x 命令查看内存地址的时候要注意起始地址：&lt;br/&gt;&lt;/section&gt;&lt;section&gt;64位的linux系统，对于虚拟地址空间的划分，将0x0000,0000,0000,0000 – 0x0000,7fff,ffff,f000这128T地址用于用户空间；而0xffff,8000,0000,0000以上的128T为系统空间地址。&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fa8759bf2823743d373834bd88b695b6</guid>
<title>通过例子学 Go pprof</title>
<link>https://toutiao.io/k/q5nfl3v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于大多数 Gopher 而言，一般平时最主要的工作内容除了实现各种无聊的业务逻辑之外，剩下的就是解决各种琐碎的问题。比如：查询性能瓶颈在哪里？查询内存泄漏在哪里？好在 pprof 是处理此类问题的利器，共有两套标准库，分别适用于不同的场景：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;runtime/pprof&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;：采集工具型应用运行数据进行分析&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;net/http/pprof&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;：采集服务型应用运行时数据进行分析&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命令行工具「go test」就包含了 runtime/pprof，相关参数请参考「go help testflag」：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;shell&amp;gt;&lt;/span&gt;&lt;span&gt; go &lt;span&gt;test&lt;/span&gt; -cpuprofile cpu.out -memprofile mem.out -bench .&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过和 runtime/pprof 相比，更常用的是 net/http/pprof，接下来我们主要通过它来解决一些常见问题，想要激活 net/http/pprof 的话很简单，只要导入对应的包并启动服务即可：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import _ &quot;net/http/pprof&quot;&lt;br/&gt;&lt;br/&gt;func main() {&lt;br/&gt; _ = http.ListenAndServe(&quot;localhost:6060&quot;, nil)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是，千万别让外网访问到 pprof，否则可能会导致出现安全问题。有兴趣的读者可以尝试通过 google 搜索「intitle:/debug/pprof/ inurl:/debug/pprof/」看看反面例子。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Profile&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;pprof 预置了很多种不同类型的 profile，我们可以按照自己的需要选择：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;allocs：A sampling of all past memory allocations&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;block：Stack traces that led to blocking on synchronization primitives&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;goroutine：Stack traces of all current goroutines&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;heap：A sampling of memory allocations of live objects&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mutex：Stack traces of holders of contended mutexes&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;profile：CPU profile&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;threadcreate：Stack traces that led to the creation of new OS threads&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中最常用的是 profile 和 heap，分别用来诊断 CPU 和内存问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;CPU profiling&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;演示代码模拟了 CPU 密集型任务（onCPU）和耗时的网络请求（offCPU）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;net/http&quot;&lt;/span&gt;&lt;br/&gt; _ &lt;span&gt;&quot;net/http/pprof&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;runtime&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/felixge/fgprof&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; cpuTime = &lt;span&gt;1000&lt;/span&gt; * time.Millisecond&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; runtime.SetBlockProfileRate(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt; runtime.SetMutexProfileFraction(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  http.Handle(&lt;span&gt;&quot;/debug/fgprof&quot;&lt;/span&gt;, fgprof.Handler())&lt;br/&gt;  log.Println(http.ListenAndServe(&lt;span&gt;&quot;:6060&quot;&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;))&lt;br/&gt; }()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  cpuIntensiveTask()&lt;br/&gt;  slowNetworkRequest()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;cpuIntensiveTask&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; start := time.Now()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; time.Since(start) &amp;lt;= cpuTime {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1000&lt;/span&gt;; i++ {&lt;br/&gt;   _ = i&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;slowNetworkRequest&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; resp, err := http.Get(&lt;span&gt;&quot;http://httpbin.org/delay/1&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  log.Fatal(err)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; resp.Body.Close()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 go tool pprof 查看 /debug/pprof/profile：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go tool pprof -http :8080 http://localhost:6060/debug/pprof/profile&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果发现 profile 只能检测到 onCPU（也就是 cpuIntensiveTask）部分，却不能检测到 offCPU （也就是 slowNetworkRequest）部分：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6732558139534883&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rJDC5vuwJCPcZXRDfXnxHC0CpDe7pf8ARlJricdIRibCUG9cwGSHmNygsRECHMH85GtYjTibbLHXxliapmK9omCsbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1720&quot;/&gt;&lt;figcaption&gt;profile&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了检测 offCPU 部分，我们引入 fgprof，通过 go tool pprof 查看 /debug/fgprof：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go tool pprof -http :8080 http://localhost:6060/debug/fgprof&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果发现 fgprof 不仅能检测到 onCPU（也就是 cpuIntensiveTask）部分，还能检测到 offCPU （也就是 slowNetworkRequest）部分：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6744186046511628&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rJDC5vuwJCPcZXRDfXnxHC0CpDe7pf8ARicGwQfboBVjyc1bhSF9BI8RCiaqxd9ia5COd7iazBJeUPkXf47iaMiaN4dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1720&quot;/&gt;&lt;figcaption&gt;fgprof&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际应用中，最好对你的瓶颈是 onCPU 还是 offCPU 有一个大体的认识，进而选择合适的工具，如果不确定就直接用 fgprof，不过需要注意的是 fgprof 对性能的影响较大。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Memory profiling&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;演示代码模拟了一段有内存泄漏问题的程序：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;log&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;net/http&quot;&lt;/span&gt;&lt;br/&gt; _ &lt;span&gt;&quot;net/http/pprof&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  log.Println(http.ListenAndServe(&lt;span&gt;&quot;:6060&quot;&lt;/span&gt;, &lt;span&gt;nil&lt;/span&gt;))&lt;br/&gt; }()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  leak()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;leak&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10000000&lt;/span&gt;; i++ {&lt;br/&gt;  s = &lt;span&gt;append&lt;/span&gt;(s, &lt;span&gt;&quot;leak&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (i % &lt;span&gt;10000&lt;/span&gt;) == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;   time.Sleep(&lt;span&gt;1&lt;/span&gt; * time.Second)&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  _ = s&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 go tool pprof 查看 /debug/pprof/head（这次不用 web，用命令行）：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-ratio=&quot;0.34765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rJDC5vuwJCPcZXRDfXnxHC0CpDe7pf8A76iaMaia08bOYCibkiaqyFzI0105ntM5a1DZrsb4cicW1y7JAkNqlgmBWbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;heap&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 top 命令可以很直观的看出哪里可能出现了内存泄漏问题。不过这里有一个需要说明的问题是内存占用大的地方本身可能是正常的，与内存的绝对值大小相比，我们更应该关注的是不同时间点内存相对变化大小，这里可以使用参数 base 或者 diff_base：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-ratio=&quot;0.4140625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/rJDC5vuwJCPcZXRDfXnxHC0CpDe7pf8AygsNE17yKPvh2AZRDyojeC2bIAIxlfYzQYFGOYDBOko3vChticO7keA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;heap&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文篇幅有限，无法列举更多的例子，有兴趣的读者推荐参考「&lt;span&gt;golang pprof 实战&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;」。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;runtime/pprof: &lt;em&gt;https://golang.org/pkg/runtime/pprof/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;net/http/pprof: &lt;em&gt;https://golang.org/pkg/net/http/pprof/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;golang pprof 实战: &lt;em&gt;https://blog.wolfogre.com/posts/go-ppof-practice/&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fee8b6db022c7061a4a4f7b8f04f5487</guid>
<title>快手OneService平台架构设计与实践</title>
<link>https://toutiao.io/k/dan1u1w</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/uBQWkS76AOuIK8nO4fJWQQciciaFgpYdbYxkw9GLfNhQnxkEomrViaARtOPtmMiaNp28HBYXtsx1Qkiajcz0efuyk3Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;300&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;关注快手大数据&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt; 获取大数据资讯&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOuIK8nO4fJWQQciciaFgpYdbY8obcA8X9XkicfNBc0JZaC9qLXrHCic8Ie4GNg5YfQ1Ssia6f3PzjGIekw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;导 读&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;本文主要介绍&lt;strong&gt;快手建设数据服务OneService平台的经验&lt;/strong&gt;。&lt;/span&gt;&lt;span&gt;OneService是一站式自助数据服务化平台，作为低代码平台，它能帮助用户零门槛创建、管理和运维API服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本文源自倪顺老师在『&lt;span&gt;&lt;strong&gt;快手大数据｜数据中台技术交流会&lt;/strong&gt;&lt;/span&gt;』上的演讲，相关视频回放可用&lt;strong&gt;快手APP搜索“快手大数据”&lt;/strong&gt;观看。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;本次分享分为五个部分：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;OneService平台建设背景&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;平台架构设计和关键技术&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;平台的可用性和效能建设之路&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;落地成果&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;未来规划&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、OneService平台建设背景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;快手是一家数据驱动的公司，每日新增数据量在PB级别。快手有很多业务如电商直播等会产生巨量数据，这些数据形成数据资产，最终被包装成数据服务，从而再次被业务所使用。数据服务由此构建了数据与业务之间的服务通道。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;数据服务是数据中台的一部分。数据中台从数据流向角度来讲，包含3个环节：&lt;/p&gt;&lt;p&gt;1）进：数据通过同步方式进入到数据中台；&lt;/p&gt;&lt;p&gt;2）产：数据通过离线和实时进行二次加工生产；&lt;/p&gt;&lt;p&gt;3）出：数据经由数据服务流出中台而服务于各类应用。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3990741&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOuIK8nO4fJWQQciciaFgpYdbY1qZ3G3r9ZSYdkPUCQcnAhTESeSGxEVjgibDS8OIBSja03pYITqXE2Iw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;快手于2017年开始建设数据服务平台，整体流程是手工式且流程较长。业务提完数据访问需求后，接着由数仓DE加工符合要求的数据表，然后他还要提JIRA工单描述把该数据表服务化，接着由数据后台研发同学手工开发、部署服务并且交付SDK给业务。总结起来有三个方面的痛点：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3935185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOuIK8nO4fJWQQciciaFgpYdbYiaVWbLIo5dth9CAAzNXtg9PGZ0BOsFsnamofG7eeHJZ9wOFruM5X0JQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;针对这些痛点，快手解决方式是引入 Kwai OneService 平台，它是一站式自助数据服务化平台，以低代码的方式来提供多样化的服务能力。通过它，能够帮助用户0门槛创建、管理和运维API服务。它采用了“配置即开发”的设计理念，允许用户通过配置化方式生成API数据服务，用户只需根据自己业务逻辑配置API而无需编写任何代码，其他技术相关复杂实现，包括数据服务代码生成、数据服务部署、缓存管理、服务降级、服务权限管控等均由平台完成。Kwai OneService平台真正实现了“数据复用而非复制”，也大大降低了API服务创建门槛，提升了API服务开发效率。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOuIK8nO4fJWQQciciaFgpYdbYhde19xZmFE3JYB5oGQA4hibYhX74L5go82mY5Diapl9TycwtSibxZLCzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;基于 Kwai OneService 平台的新开发模式，就更加简洁了。早期流程中的复杂逻辑，包括提工单、手工开发、部署服务、交付SDK等环节，均涵盖在该平台内部自动化实现。该平台主要有2类用户：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4185185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOuIK8nO4fJWQQciciaFgpYdbY5gaveHicPSXJhFycJeTic4H4Xhr88yAxOMODMRsG1ODicjTyTDRIZ24MQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;二、平台架构设计和关键技术&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;01 OneService平台技术架构&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;快手 OneService 平台的技术架构如下图所示。从下到上，分为三层，包括数据开发层、数据服务层、数据应用层。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5814815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOuIK8nO4fJWQQciciaFgpYdbYOM6ZrZGaczaAicup9dev1CbQvs6u8drj65HQI873Jiaaukw7OpHGOnVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;数据开发层中，DE同学通过离线和实时开发方式，从ODS表中加工出富有业务价值的数据资产，这些资产通常是按主题域方式呈现，如消费者数据、直播数据、电商数据等等。资产数据通常存储于离线的HIVE表中，读写速度相对较慢。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;数据服务层，是 OneService 平台核心技术部分，分为左右两部分。左侧是服务生成引擎，他的职责是针对用户提交的每个API创建，来自动化生成客户端代码和自动化部署对应服务端。右侧是生产完的服务的调用链路。调用链路，可细分为四层，从下往上看，数据资产表在经历数据质检后，从读写速度慢的大数据仓库加速到更快的存储介质中，如Redis、Hbase、CH以及快手自研的存储引擎。基于这一层异构存储引擎之上，构建了统一查询层，从而服务于多种不同场景的接口。面向不同业务场景，沉淀的数据服务接口模板较多，包括：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;KV API：点查类API，适合点状精确查询数据场景&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;SQL API：&lt;/span&gt;&lt;span&gt;类SQL API，适合灵活多维查询数据场景&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;模板 API：&lt;/span&gt;&lt;span&gt;模板式查询接口，适合固化的多条件查询场景&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;OneAPI：&lt;/span&gt;&lt;span&gt;统一查询接口，提供统一的DSL来查询前面各类场景数据&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;公共接口：&lt;/span&gt;&lt;span&gt;特定垂直领域沉淀的接口，如One ID 接口，地理位置查询等接口&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;02 关键技术 - API矩阵&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;OneService平台的第一个关键技术是API矩阵。API矩阵是指，平台面向不同的数据服务业务场景，而沉淀下来的API创建模板或者API类型。API类型非常多，我们将API类型从两个维度来划分，一是查询灵活度，二是查询速度，每个象限中都有API分布。用户在平台创建API时，可根据自己的需求，从对应象限中寻找符合自己场景的API。此外，针对单类API，面向不同的业务使用场景时，还可做到定制化，如设置数据压缩、热点数据加速等特性，从而更好满足业务需求。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4268519&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOuIK8nO4fJWQQciciaFgpYdbY8ukCEkj3fZb9a2jv6ECY8nW2l8Y9B3rf8DDgwnpFksMJtauSAKckpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;本文选取三类典型的API类型介绍：&lt;/p&gt;&lt;p&gt;1. KV API：KV API 底层基于KV 引擎，如Redis、Hbaes、Pika 等，因此取数很快，且可支撑百万QPS。KV API消息是基于Protobuf，传输效率也非常高。用户在使用时，拿到的结果对象也是基于PB（结果集是自动ORM），因此在编码时也很方便。典型使用场景包括用户标签查询、IP查询等点查类场景。&lt;/p&gt;&lt;p&gt;2. SQL API：SQL API底层基于OLAP引擎，如Clickhouse、Druid 等，其支持的查询速度相对慢一些，不过能够支持更加灵活自由的查询条件。SQL API提供了Fluent API风格的接口，调用者可在select中自行传入要查询的字段信息，也可在where方法中自由构造多种嵌套的过滤查询条件。SQL API典型使用场景是支持数据BI看板。&lt;/p&gt;&lt;p&gt;3. Template API：Template API 和 SQL API 类似，底层也是基于Clickhouse、Druid等，不过有个较大区别点是用户在使用Template API时，查询模板是预定义在服务端，然后在客户端动态传入参数变量，后台将模板和变量组合成完整语句查询。其典型场景和SQL API类似。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4175926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOuIK8nO4fJWQQciciaFgpYdbYBFlAWmIQjsrqL42M3AQ9mD26SOlCmT7zJTUtTviaFDxknWTplUUIIxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;03 关键技术 - 配置即开发&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;OneService平台的第二个关键技术是「配置即开发」的设计理念。早期快手建设数据服务依赖于手工开发，而「配置即开发」意味着，用户只需要配置好一个API，就相当于开发一个API接口。基于这个设计理念，用户通过平台创建API，主要包含三个阶段：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;1. 配置 API：配置创建API的必要信息，包括数据底表来源、接口本身形态（RPC or HTTP）、是否需要批量访问数据、访问QPS范围、测试链路独立数据源等等。&lt;/p&gt;&lt;p&gt;2. 自动生产接口：OneService平台根据前面的 API 配置信息，自动化生成客户端接口以及自动部署服务端。在不需要用户参与的情况下，后台自动化去做好数据加速、数据服务接口生成、接口验证、测试环境配置、接口上线和上架等操作。&lt;/p&gt;&lt;p&gt;3. 使用接口：待 OneService 平台自动化创建 API 接口之后，调用者只需要在平台上申请接口权限，即可在测试环境和正式环境访问数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4425926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOuIK8nO4fJWQQciciaFgpYdbYQqEojoSicaIpUGQDS7rwngsbVrdZiclVAHdDCGvA0z6lPUibfdYibxSvRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;上述三个阶段中，对用户提效最大的是第二阶段，即自动生产接口。这也是「配置即开发」的核心落脚点。OneService 平台自动化生产包括三个主要步骤：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;1. 基于Code Generation的客户端自动化生成&lt;/strong&gt;：用户提交的 KV API 创建申请，后端根据其配置详情信息，来生成 Java 代码，并且自动发布 SDK。该 Java 接口针对每个业务是定制化的，使用体验更好。除了 KV API 之外，针对 SQL API创建申请，后端无需再次创建定制化的Java 接口，用户是使用统一的固定的预先开发好的 Java 接口来访问 SQL API数据。未来趋势是，OneService 平台提供一个统一的接口，来应对所有类型的场景。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2. 热部署轻量虚拟服务&lt;/strong&gt;：KV API / SQL API 客户端的请求打到后端，会有对应的虚拟服务处理。虚拟服务保留了API粒度的处理逻辑，如数据存储地址、读取方式、解析逻辑等，由于其非常轻量，因此也可以动态迁移到其他物理集群上，来动态平衡流量和服务压力。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3. 数据加速&lt;/strong&gt;：由于数据资产主要存储于离线存储体系，读取速度较慢，因此需要进行数据加速，将数据以一次性或者周期性的方式加速到高速存储引擎，包括 KV 引擎或者 OLAP 引擎中。虚拟服务可直接从高速引擎中取数。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3805556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOuIK8nO4fJWQQciciaFgpYdbYgtfTJaicO89TDO6DB1fV2j7BHzx6963B3WicIzI5ZiabBTjB5DRAIm0yg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;04 关键技术 - 统一查询平台&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;由于平台内存在多种 API ，每类 API 都有可能查询到 Redis、Hbase、Druid、Clickhouse 等引擎，因此存在一定的重复建设，此外还有除了 OneService 平台之外的其他应用也可能查询这些引擎，因此快手沉淀了统一查询平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;统一查询平台对下屏蔽了各类异构引擎的复杂性，对上服务了KV API、SQL API 甚至外部应用等多种场景。统一查询平台内部提供了两类查询语法：1）OneSQL，以SQL子集定义了一套可查询KV、OLAP、OLTP 等引擎的语法；2）OneDSL，以自定义DSL来支持各类引擎原生的查询语法，可最大化发挥查询能力。查询平台执行模式也有多种，可类比Spark，有Local、Standalone、Cluster模式，以支持不同场景的查询诉求。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3722222&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOuIK8nO4fJWQQciciaFgpYdbYiaRDGe6f37oYiaQlLoUd4fMLoZbgk5AibdmId6rLBNAEtCYHyiadRice5Wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;查询平台执行流程如下。网关层主要负责安全和流量管控，具体执行计划解析后会发往对应模式（Local、Standalone、Cluster）节点上执行。针对 Standalone 和 Cluster 模式，执行节点可回取从多类引擎读到的数据，并且进行二次加工合并处理。最终将结果发送给客户端也有两种方式，其一是针对小数据量时直接以同步方式返回，其二是针对大量结果数据则以异步方式返回数据。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4157407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOuIK8nO4fJWQQciciaFgpYdbYJ2Az3HaMARZejlibbt1rfFKq7EznANhAjiabzKC2fUEkY5ibNgVmDnLiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;三、平台的可用性和效能建设之路&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;OneService 平台从 2019 年开始建设以来，快手除了建设平台功能，还花费较多精力建设平台稳定性和平台效能。第一，OneService 平台连续参加快手2020、2021元旦春节活动，因此平台本身的稳定性需要达到在线业务很高的可用性要求。第二，OneService 平台随着用户越来越多，规模越来越大，对自身性能和效率有更高的要求。本节就高可用建设和高效能建设两方面进行介绍。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;01 高可用性建设&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;OneService 平台在保证高可用时，遇到较多挑战，包括：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;服务繁多：服务数量达到数以千计，平台总QPS接近2千万级，且服务类型较多，所需保障方式也各有差异。这对于平台的保障挑战就非常大，包括QPS管控方式能够应对突发高流量。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;业务重要：平台上有90%都为在线类业务场景，他们直接承载B端或者C端用户的访问流量，因此需要平台有常态的高可用保障能力。此外平台上的部分服务还直接承载核心活动场景，如发红包、留存推送、集卡活动、年度总结活动等。此类活动相关API 对于平台也提出了更高的可用性要求。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;外部依赖：作为数据服务平台，他还依赖了较多外部组件，如各类存储引擎、配置分发服务、鉴权服务等，一旦某些组件出现问题，则用户数据访问都有可能失败，因此 OneService 需要有充足设计应对外部组件失败。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;特殊保障：如前所述，部分 API 如活动相关 API，对于保障手段方面还有些特殊的要求，比如数据加速完成时间监控、数据存储使用率监控等，这要求平台能提供定制化的保障能力。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;基于这些挑战，OneService 平台的可用性建设思路是：&lt;/p&gt;&lt;p&gt;1）首先在事前积极做好可用性建设，功能设计和开发要保证鲁棒性，通过分级部署等思路将线上问题影响面局部化；&lt;/p&gt;&lt;p&gt;2）事中通过全面报警来及时发现问题，从而快速介入解决问题，故障的自主发现率是衡量全链路报警的关键指标之一；&lt;/p&gt;&lt;p&gt;3）事后需要通过多种方式及时止损，包括降级限流，避免事态严重化。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.462963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOuIK8nO4fJWQQciciaFgpYdbYlkKmpibhQYXW6Bowj63xgJVQBTxrBzCN5Yl5aCQNa7n9ong1qQIdCFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;下面介绍两项关键的高可用建设经验。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;第一项是分级隔离&lt;/strong&gt;&lt;span&gt;。OneService 平台有千级服务接口数，业务方希望各自的接口互相不影响，且同一个业务线内部的不同优先级的接口也希望互不影响。为了达到这一目标，快手将大一统的部署模式转换为按舱位部署。快手将微服务和存储按业务加优先级的二维粒度进行切分，形成多个舱位，这些舱位物理隔离单独部署，因此互不影响。统一舱位空间，可能对应有多个服务接口，则可按需进一步做硬隔离或者混合部署以提升资源使用率。通过这种方式，OneService 平台从未发生过影响所有 API 服务接口的故障。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOuIK8nO4fJWQQciciaFgpYdbYQyI86Xa4KibcBSZEKiaW8teHMPVLyoUuf8Aibib6mKS4icf2o2bA32gmv1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;第二项是限流降级&lt;/strong&gt;。OneService 的核心链路中组件涵盖客户端、服务端、外部核心依赖、数据存储引擎等。外部有多种情况都可能导致此链路出现稳定性问题，比如曾经有业务在压测时，出现热点key情况，QPS达到近10万，这对于底层Redis风险是比较大的。因此我们针对核心链路的各个环节都有应对预案。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;请求降采样和管控：服务端有异常请求采样逻辑，可在分钟级发现热点key、大value请求、大流量请求，一旦发现此类问题，平台管理员可在客户端侧和服务端侧来管控此类异常请求。具体管控策略多样，包括按比例直接阻断请求、请求按规则直接返回固定值、按并发度限制请求量等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;外部依赖降级：平台依赖了外部鉴权服务、配置分发服务等，平台在进行功能设计时，就需要考虑外部组件异常时的应对策略，如通过配置快照等方式来降级。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;存储引擎降级：存储引擎多数有主备实例 + 双机房的策略，来保障存储高可用。当然如果某类引擎不可用了，OneService 平台还可将数据资产同步至备选异构存储中，从而提供降级在线访问能力。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;核心链路较长，因此平台也需要有自动化的全链路监控方案来及时发现问题。全链路监控系统从三个角度出发监控：&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4157407&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOuIK8nO4fJWQQciciaFgpYdbYEiaUPV0fsjZ1a5w06XwmDhSbw2tO4ycN3fkfRq2T0Gmbsg3rFypvy6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;02 高效能建设&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;OneService 平台从 2019 年开始建设，系统目前已经进入到精细化发展的阶段，在本阶段中，平台更多会关注到提升效率、降低成本等内容，从而更好提升产品核心价值。由此出发，OneService 会不断提升API接口的业务覆盖度，从而赋能更多业务；此外平台还会持续优化已有流程，从成本和性能等方面着手提效。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.387037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOuIK8nO4fJWQQciciaFgpYdbYA4J9jhk0UibDRHODw8PsaM7uQXJdT6zAuKMWYJzrpqSIYhBWu8Kml6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;第一项经验是&lt;strong&gt;数据复用而非复制&lt;/strong&gt;的思路。早期数据服务建设，比较容易陷入到新需求直接复制数据，单独建设一整套链路接口，这带来成本浪费和治理困难等问题。通过“数据复用而非复制”，让业务方都通过已有接口来访问数据，可以更快满足业务需求，而且也提升了已有 API 的价值。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;API在平台被创建后，进入到“上线状态”，此时 API 可以被同项目组的其他同学看到和使用。此时API 还可以上架到 API 市场，进入“上架状态”的 API ，可以被其他项目组的所有同学看到和使用。可以将 API 市场比喻成天猫、京东等商城系统，用户可以在 API 市场里进行搜索，可以看到 API 的商品详情，包括数据源、数据定义、接口定义、接口使用方式示例等，可直接按需申请权限访问。通过 API 市场，实现了“数据复用而非复制”，目前单 API 的调用方可达到数十个，极大提升了 API 的价值。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3305556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOuIK8nO4fJWQQciciaFgpYdbYNumhsqUxdocDkXBeQPwoU83uxN8icE9N2drcUW2VuTViboHiaY8vgq54w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;第二项经验是&lt;strong&gt;提升性能&lt;/strong&gt;。OneService 平台生产的 API 接口本质上是基于数据引擎的服务，在某些场景下业务对于数据访问的性能要求非常高。比如用户画像系统，访问数据QPS非常大，且访问延迟要求非常小，通常要在1ms内。针对此类特定场景，OneService 平台推出了直连存储方案，它允许Client SDK跳过 Server 侧来直连 Redis 引擎。直连存储，相比于普通数据访问模式，延迟减少50%，且节省了大量服务端计算资源。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;当然，除了直连存储方案外，OneService 平台在生产 API 时，还提供了多级缓存配置选项。用户在配置 API 创建工单可根据业务场景来增选L0~L2级缓存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4231481&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOuIK8nO4fJWQQciciaFgpYdbYbeZtia3q7n8ZO8xEaKfjYZRMHUiaQ9jhiaWNaC0aRWMheRadXwpMbanKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;四、落地成果&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;从2019年建设 OneService 平台以来，平台已经逐步承载起越来越多的业务需求。在体量上，平台上的 API 接口数量达到一千以上，QPS达到近两千万，存储量级达到百TB，接入业务线数量为百级。在保障上，平台本身 KV API 延迟在毫秒级，核心服务可用性达到4个9，并且零故障的支持了较多重要活动，包括过去两年的元旦春节、电商节、奥运会等。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.437963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOuIK8nO4fJWQQciciaFgpYdbYp9WnoWkzxY5qej55Enq4emhpxCTyQ6zDHvcFUD5icdZ37sPNmVibzz4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;除了上述产品运营成果外，平台还有较多技术方面的沉淀。相比于2017年的数据服务开发流程，目前平台的新流程在效率上有极大提升，创建一个API从近9天降低到1天内。在成本方面，平台也通过多项综合措施，包括多样化存储、存储压缩、API治理等，最终节省了15%的成本。在质量方面，平台上的API彻底打通快手质检体系，也确保API都自动化纳入全链路监控中，自动360度监控服务健康。在通用能力方面，平台沉淀了多种能力，包括异常请求管控、统一查询平台、高可用保障等。未来参与活动的API，无需额外措施，平台即可自动高效保障接口的稳定性。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4564815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOuIK8nO4fJWQQciciaFgpYdbYu3HRjiaZYpiamfcKIM42l9zHI5FzhWUkICzYOh7BELka7NEGMbwib2iccA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;五、未来规划&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;OneService 平台未来会朝着“统一数据服务化平台” 演进，作为业务使用数据的主要入口，提供丰富多样的数据服务能力。平台一方面会继续深耕数据资产，随时准备支持有更多形态（如图数据）的资产，另一方面，也会不断去紧贴业务需求，不断沉淀业务需求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;具体而言，分为四个方面建设未来平台的能力：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;基础能力：进一步扩展服务基础能力，如统一查询平台、统一数据集、统一指标服务等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;高阶能力：通过引入服务编排、函数计算等来构建更加灵活的服务能力，可支持服务定制化需求。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;产品效率：不断优化 OneService 平台，进一步提效，包括接口研发效率和运维效率。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;服务治理：通过引入智能化手段，来自动化提效服务治理和保障能力。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOuIK8nO4fJWQQciciaFgpYdbYFfQc0N786b6ZzOIuXMJdDtSsibKoa1WpFiaV2manXV0ibIeA6HNrzZQjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;作者简介：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;倪顺，快手大数据平台研发专家，5年数据开发经验，曾就职于HULU北京，负责快手API服务平台建设，主要关注数据中台领域、微服务领域技术。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9924528&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uBQWkS76AOuIK8nO4fJWQQciciaFgpYdbYHyIFG6ichdm79CHtUboflmFHKx57kYcZiaeH63ChuHicUC4wnZCGPvtwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;530&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;长按识别二维码关注『快手大数据』&lt;/p&gt;&lt;p&gt;查看交流会回放视频&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;分享、收藏、点赞，给个3连击吧！&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e89b4c4fb9b6b91e67dc57cfbf4f406d</guid>
<title>[推荐] 高并发是一种架构思维模式</title>
<link>https://toutiao.io/k/imslmgz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;什么是高并发，从字面上理解，就是在某一时刻产生大量的请求，那么多少量称为大量，业界并没有标准的衡量范围。&lt;span&gt;原因非常简单，不同的业务处理复杂度不一样&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而我所理解的&lt;/span&gt;&lt;span&gt;&lt;strong&gt;高并发，&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;它并不只是一个数字，而更是一种架构思维模式&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，它让你在面对不同的复杂情况下，从容地选择不同的技术手段，来提升应用系统的&lt;span&gt;处理能力。&lt;/span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是，并不意味应用系统从诞生的那一刻，就需要具备强大的处理能力，这种做法并不提倡。要知道，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;脱离实际情况的技术，会显得毫无价值，甚至是一种浪费的表现&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;言归正传，那高并发到底是一种怎样的架构思维模式，它对架构设计又有什么影响，以及如何通过它来驱动架构演进，让我们接着往下读，慢慢去体会这其中的精髓。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong data-darkmode-color-16428180129682=&quot;rgb(0, 104, 255)&quot; data-darkmode-original-color-16428180129682=&quot;#fff|rgb(0, 82, 255)&quot; data-darkmode-color-16439380253696=&quot;rgb(61, 170, 214)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)|rgb(61, 170, 214)&quot;&gt;性能是一种基础&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在架构设计的过程中，思考固然重要，但目标更为关键。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;通过目标的牵引力，可以始终确保推进方向，不会脱离成功的轨道&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;那高并发的目标是什么，估计你的第一反应就是性能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;没错，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;性能是高并发的目标之一，它不可或缺，但并不代表所有&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。而我将它视为是高并发的一种基础能力，它的能力高低将会直接影响到其他能力的取舍。例如：服务可用性，数据一致性等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;性能在软件研发过程中无处不在，不管是在非功能性需求中，还是在性能测试报告中，都能见到它的身影。那么如何来衡量它的高低呢，先来看看常用的性能指标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;每秒处理&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;事务&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;数（TPS）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每秒能够处理的事务数，其中T(Transactions)可以定义不同的含义，它可以是完整的一笔业务，也可以是单个的接口请求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;每秒请求数（RPS）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;每秒请求数量，也可以叫做QPS，但它与TPS有所不同，前者注重请求能力，后者注重处理能力。不过，若所有请求都在得到响应后再次发起，那么RPS基本等于TPS。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;响应时&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;长（RT）&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从发出请求到得到响应的耗时，一般可以采用毫秒单位来表示，而在一些对RT比较敏感的业务场景下，可以使用精度更高的微秒来表示。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;并发用户数（VU）&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;同时请求的用户数，很多人将它与并发数画上等号，&lt;/span&gt;但两者稍有不同，前者关注客户端，后者关注服务端，除非&lt;span&gt;每个&lt;/span&gt;&lt;span&gt;用户仅发送一笔请求，且请求从&lt;/span&gt;&lt;span&gt;&lt;span&gt;客户端到服务端&lt;/span&gt;没有延迟，同时服务端有足够的处&lt;/span&gt;&lt;/span&gt;&lt;span&gt;理线程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上都是些常用的性能指标，基本可以覆盖80%以上的性能衡量要求。但千万不要以单个指标的高低来衡量性能。比如：订单查询TPS=100万就认为性能很高，但RT=10秒。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这显然毫无意义。因此，&lt;/span&gt;&lt;span&gt;建议同时观察多个指标的方式来衡量性能的高低，大多数情况下主要会关注TPS和RT，而你可以&lt;/span&gt;&lt;strong&gt;&lt;span&gt;将TPS视为一种水平能力，注重并行处理能力，&lt;span&gt;将RT视为一种垂直能力，注重单笔处理能力，&lt;/span&gt;两者缺一不可&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接触过性能测试的同学，可能会见过如下这种性能测试结果图，图中包含了刚才提到过的三个性能指标，其中横坐标为VU，纵坐标分别为TPS和RT。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.491796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gusYCVib6QezRYG7TTupdtd6tAbjoxSAT3jdWVkPJicOUGibzYb5sCfaiaWwawbMFsrG0K9wHnxzDibUzqYsmNEKxFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.067578125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gusYCVib6QezRYG7TTupdtd6tAbjoxSAT4VKcATbkPbjCu9G3wDAMGggwEPbR0PnV97nHPBBP1vVico5U9BtIXyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注：表格中的数据都是理想情况下的，实际上会有上下抖动，而这里只是为了想用它来解释一种现象而已。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图中的&lt;span&gt;两条曲线，&lt;/span&gt;在不断增加VU的情况下，TPS不断上升，但RT保持稳定，但当VU增加到一定量级的时候，TPS开始趋于稳定，而RT不断上升。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果你仔细观察，还会&lt;/span&gt;&lt;span&gt;发现一个奇妙的地方，当RT=25ms时，它们三者存在着某种关系，即：TPS=VU/RT。但当RT&amp;gt;25ms时，这种关系似乎被打破了，这里暂时先卖个关子，稍后再说。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据表格中的数据，性&lt;/span&gt;&lt;span&gt;能测试报告结论：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;最大TPS=65000，当&lt;/span&gt;&lt;span&gt;RT=25ms(最短)时，最大可承受VU=1500&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;感觉有点不对劲，用刚才的公式来验证一下，1500/0.025s=60000，但最大却是TPS=65000。那是因为，当VU=1500时，应用系统的使用资源还有空间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再来观察一下表格中的数据，VU从1500增加到1750时，TPS继续上升，且到了最大值65000。此时，你是不是会理解为当VU增加到1750时，使用资源被耗尽了。话虽没错，但不严谨。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注：使用资源不一定是指硬件资源，也可能是其他方面，例如：应用系统设置的最大处理线程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其实在VU增加到1750前，使用资源就已饱和，那如何来测算VU的临界值呢。你可以将最大TPS作为已知条件，即：VU=TPS*RT，65000*0.025s=1625。也就是说，当VU=1625时，使用资源将出现瓶颈。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;调整性能测试报告&lt;/span&gt;&lt;span&gt;结论：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;最大TPS=65000，&lt;strong&gt;&lt;span&gt;当RT=25ms(最短)时&lt;/span&gt;&lt;/strong&gt;，最大可承受VU=1625&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有人会问，表格中的RT是不是平均值，首先回答为是。不过，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;高并发场景对RT会特别敏感，所以除了要考虑RT的平均值外，建议还要考虑它的分位值&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，例如：P99。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;举例：假设1000笔请求，其中900笔RT=23ms，50笔RT=36ms，50笔RT=50ms&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;strong&gt;&lt;span&gt;平均值&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;strong&gt;&lt;span&gt;P99值&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;strong&gt;&lt;span&gt;P95值&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;strong&gt;&lt;span&gt;P90值&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;25ms&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;50ms&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;36ms&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;23ms&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;P99的计算方式，是将1000笔请求的RT从小到大进行排序，然后取排在第99%位的数值，基于以上举例数据来进行计算，P99=50ms，其他分位值的计算方式类似。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再次调整性能测试报告结论：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;最大TPS=65000，当&lt;/span&gt;RT(平均)=25ms(最短)时，最大可承受VU=1625，RT(P99)=50ms，RT(P95)=36ms，RT(P90)=23ms&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在非功能性需求中，你可能会看到这样的需求，性能指标要求：&lt;span&gt;RT(平均)&lt;/span&gt;&amp;lt;=30。结合刚才的性能测试报告结论，&lt;/span&gt;&lt;span&gt;当&lt;/span&gt;&lt;span&gt;RT(平均)=25ms(最短)时，最大可承受VU=1625。那就等于在RT上还有5ms的容忍时间。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;既然是这样的话，那我们不妨就继续尝试增加VU，不过RT&lt;span&gt;(平均)&lt;/span&gt;会出现上升，但只要控制不要上升到30ms即可，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;这是一种通过牺牲耗时(RT)来换取并发用户数(VU)的行为&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。但请不要把它理解为每笔请求耗时都会上升5ms，这将是一个严重的误区。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;RT(平均)&lt;/span&gt;&lt;span&gt;的增加，完全可能&lt;/span&gt;&lt;span&gt;是&lt;/span&gt;&lt;span&gt;由于应用系统&lt;span&gt;当前&lt;/span&gt;没有足够的使用资源来处理请求所造成的，例如：处理线程。如果没有可用线程可以分配给请求时，就会将这请求先放入队列，等前面的请求处理完成并释放线程后，就可以继续处理队列中的请求了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那也就是说，没有进入队列的请求并不会增加额外的耗时，而只有进入队列的请求会增加。那么&lt;/span&gt;&lt;span&gt;进入队列的请求会&lt;/span&gt;&lt;span&gt;增加多少耗时呢，&lt;span&gt;在理想情况下(RT恒定)，&lt;/span&gt;可能会&lt;/span&gt;&lt;span&gt;是正常处理一笔请求耗时的倍数，而倍数的大小又取决于并发请求的数量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;假设&lt;span&gt;最大处理&lt;/span&gt;线程=1625，若每个用户仅发送一笔请求，且请求从&lt;span&gt;客户端到服务端没有延迟的条件下，&lt;/span&gt;当并发用户数=1625时，能够保证&lt;/span&gt;&lt;span&gt;RT=25ms，但当&lt;span&gt;并发用户数&lt;/span&gt;&amp;gt;1625时，因为线程只能分配给1625笔请求，那多余的请求就无法保证RT=25ms。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;超过1625笔的请求会先放入队列，等前面1625笔请求处理完成后，再从队列中拿出最多1625笔请求进行下一批处理，如果队列中还有剩余请求，那就继续按照这种方式循环处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;进入队列的请求，每等待一批就需要增加前一批的处理耗时。在理想情况下，每一批都是&lt;/span&gt;&lt;span&gt;RT=25ms，如果这笔请求在队列中等待了两批，那就要额外增加50ms的耗时。&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;VU&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;第一批&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;第二批&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;第三批&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;1000&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;1000笔请求&lt;br/&gt;RT=25ms&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;2000&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;1625笔请求&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RT&lt;/span&gt;&lt;span&gt;=25ms&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;375笔请求&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RT&lt;/span&gt;&lt;span&gt;=50ms&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;4000&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;1625笔请求&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RT&lt;/span&gt;&lt;span&gt;=25ms&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;span&gt;1625&lt;/span&gt;笔请求&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RT&lt;/span&gt;&lt;span&gt;=50ms&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;750笔请求&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RT&lt;/span&gt;&lt;span&gt;=75ms&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，并不能简单通过VU=TPS*RT=&lt;span&gt;65000*0.03=1950&lt;/span&gt;来计算最大可承受VU。而是需要&lt;/span&gt;&lt;span&gt;引入一种叫做&lt;/span&gt;&lt;span&gt;&lt;strong&gt;科特尔法则(Little’s Law)&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的排队模型来估算，不过由于这个法则比较复杂，这里暂时不做展开。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过粗略估算后，VU大约在2032，我们再对这个值用上述表格中再反向验算一下。&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;VU&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;第一批&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;第二批&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;RT&lt;/span&gt;&lt;span&gt;(平均)&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;2032&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;1625笔请求&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RT&lt;/span&gt;&lt;span&gt;=25ms&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;407笔请求&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RT&lt;/span&gt;&lt;span&gt;=50ms&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;(1625*25+407*50)/(1625+407&lt;/span&gt;&lt;span&gt;)≈30ms&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终&lt;span&gt;调整性能测试报告结论：&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;最大TPS=65000，当RT(平均)=25(最短)时，最大可承受VU=1625，RT(P99)=50，RT(P95)=36，RT(P90)=23；当RT(平均)=30(容忍)时，(理想情况)最大可承受VU=2032&lt;span&gt;，&lt;strong&gt;RT(P99)=RT(P95)=50，RT(P90)=25&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;这就解释了为什么当RT&amp;gt;25ms时，VU=TPS*RT会不成立的原因。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;不过，这些都是在理想情况下推演出来的，实际情况会比这要复杂得多。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，还是尽量采用多轮性能测试来得到性能指标，这样也更具备真&lt;/span&gt;&lt;span&gt;实性。毕竟&lt;/span&gt;&lt;span&gt;影响性能的因素实在大多且很难完全掌控，任何细微变化都将影响&lt;/span&gt;&lt;span&gt;性能指标的变化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;到这里，我们已经了解了可以用哪些&lt;span&gt;指标&lt;/span&gt;来衡量性能的高低。不过，这里更想强调的是，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;性能是高并发的基础能力，是实现高并发的基础条件，并且你需要有侧重性地提升不同维度的性能指标，而非仅关注某一项&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;hr data-style=&quot;font-size: 16px; outline: 0px; max-width: 100%; border-color: rgba(0, 0, 0, 0.1); caret-color: rgba(255, 255, 255, 0.6); color: rgba(255, 255, 255, 0.6); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.5440000295639038px; white-space: normal; border-style: solid; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; transform-origin: 0px 0px 0px; transform: scale(1, 0.5); box-sizing: border-box !important; word-wrap: break-word !important;&quot; class=&quot;js_darkmode__27&quot; data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;/&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;br data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;/&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span data-darkmode-color-16439380253696=&quot;rgb(61, 170, 214)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)|rgb(61, 170, 214)&quot;&gt;&lt;strong data-darkmode-color-16428180129682=&quot;rgb(0, 104, 255)&quot; data-darkmode-original-color-16428180129682=&quot;#fff|rgb(0, 82, 255)&quot; data-darkmode-color-16439380253696=&quot;rgb(61, 170, 214)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)|rgb(61, 170, 214)&quot;&gt;限制是一种设计&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上文说到，性能是高并发的目标之一。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;追求性能没有错，但并非永无止境&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;。想要提升&lt;/span&gt;性能，势必投入成本，不过它们并不是一直成正比，而是随着成本不断增加，性能提升幅度逐渐衰减，甚至可能不再提升。所以，有时间我们要懂得适可而止。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;思考一下，追求性能是为了解决什么问题，至少有一点，是为了让应用系统能够应对突发请求。换言之，如果能解决这个问题，是不是也算实现了高并发的目标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;而有时候，我们&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;在解决问题时，不要总是习惯做加法，还可以尝试做减法&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，架构设计同样如此。那么，如何通过做减法的方式，来解决应对突发请求的问题呢。让我们来讲讲限制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;限制，从狭义上可以理解为是一种约束或控制能力&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。在软件领域中，它可以针对功能性或非功能性，而在高并发的场景中，它更偏向于非功能性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;限制应用系统的处理能力，并不代表要降低应用系统的处理能力&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，而是通过某些控制手段，&lt;span&gt;让突发请求能够被平滑地处理，同时起到&lt;span&gt;应用系统的保护能力，&lt;span&gt;避免瘫痪，&lt;/span&gt;还能&lt;/span&gt;将应用系统的资源进行合理分配，避免浪费&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么，到底有哪些控制手段，既能实现以上这些能力，&lt;span&gt;又能减少对客户体验上的影响，下面就来介绍几种常用的控制手段&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong data-darkmode-color-16428180129682=&quot;rgb(0, 104, 255)&quot; data-darkmode-original-color-16428180129682=&quot;#fff|rgb(0, 82, 255)&quot; data-darkmode-color-16439380253696=&quot;rgb(61, 170, 214)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)|rgb(61, 170, 214)&quot;&gt;第一招：限流&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong data-darkmode-color-16428180129682=&quot;rgb(0, 104, 255)&quot; data-darkmode-original-color-16428180129682=&quot;#fff|rgb(0, 82, 255)&quot; data-darkmode-color-16439380253696=&quot;rgb(61, 170, 214)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)|rgb(61, 170, 214)&quot;&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;限流，是在一个时间窗口内，对请求进行速率控制&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。若请求达到提前设定的阈值&lt;span&gt;时&lt;/span&gt;，则对请求进行排队或拒绝。常用的限流算法有两种：漏桶算法和令牌桶算法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;漏桶算法，所有请求先进入漏桶，然后按照一个恒定的速率对漏桶里的请求进行处理，是一种控制处理速率的限流方式，用于平滑突发请求速率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它的优点是，能够确保资源不会瞬间耗尽，避免请求处理发生阻塞现象，另外，还能够保护被应用系统所调用的外部服务，也免受突发请求的冲击。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它的缺点是，对于突发请求仍然会以一个恒定的速率来进行处理，其灵活性会较弱一点，容易发生突发请求超过漏桶的容量，导致后续请求直接被丢弃。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;令牌桶算法，应用系统会以一个恒定的速率往桶里放入令牌，请求处理前，会从桶里获取令牌，当桶里没有令牌可取时，则拒绝服务，是一种平均流入速率的限流方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它的优点是，在限制平均流入速率的同时，还能在面对突发请求的情况下，确保资源被充分利用，不会被闲置或浪费。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它的缺点是，舍弃了处理速率的强控制能力，那么如果某些功能依赖外部服务，可能将会让外部服务无法承受压力，导致无法正常返回，而且还浪费了这次获取的令牌。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;综上，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;两种算法并没有绝对的好坏，而是需要根据实际的情况，选择合适的方式，从而在发挥限流作用的同时不会引发其他问题&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;但在一些秒杀活动中，软件党的高频请求，会很容易触发限流，导致大量正常请求被误杀的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然在请求被限流后，会返回友好话术，减轻对客户体验的影响，但也有可能他们的请求，会一直无法得到有效处理，这时候耐心再好的客户也会离开及抱怨。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，我们&lt;span&gt;除了使用限流这招外，还得搭配其他的招数组合一起使用，从而让&lt;span&gt;应用系统能够对资源进行合理分配，避免资源浪费，减少正常请求被误杀的情况。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong data-darkmode-color-16428180129682=&quot;rgb(0, 104, 255)&quot; data-darkmode-original-color-16428180129682=&quot;#fff|rgb(0, 82, 255)&quot; data-darkmode-color-16439380253696=&quot;rgb(61, 170, 214)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)|rgb(61, 170, 214)&quot;&gt;第二招：降频&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;降频，是在一个时间窗口内，对同一特征的请求进行速率控制&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;span&gt;若请求达到提前设定的阈值时，则会对请求进行拒绝。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然和限流&lt;/span&gt;&lt;span&gt;有点类似，但存在着细微的差别。对限流而言，它并不关心请求方，而只对服务端的速率进行控制，而对降频而言，它会基于某种特征，对请求方的请求速率进行控制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;而降频的目的，是为了减少&lt;/span&gt;&lt;span&gt;应用系统资源被不正常的请求所消耗，而导致正常的请求因限流被拒绝的情况发生&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。它的实现方式也有多种，而且在前端和后端都可以使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;识别不正常的请求是降频的第一步，也是最关键的一步。一般会制定某种特征+某段时间+请求数量这种三段式的识别规则。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;特征可以是账号、会话、IP地址、设备号等，时间一般会是1秒，也可以设置更长。账号+1秒+5笔，意思就是同一个账号在1秒内可以发生5笔请求，但是这里请求数量与限流的设定参考依据不同。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;限流大小主要依据性能来决定，而降频中的请求数量，一般会以正常人的交互速率作为参考&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。所以，并不能因为性能好，就设定账号+1秒+100笔这种识别规则，这不但不科学还会浪费资源。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来，有了识别规则还得搭配对应的处置手段，常见的有两种模式：挑战和拒绝。&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;挑战&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt;&lt;span&gt;弹出验证码，输入并验证通过后，可以继续请求&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt;&lt;span&gt;仅适用于前端&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;拒绝&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt;&lt;span&gt;弹出“请求频繁”提示，且这笔请求将直接被拒绝&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;left&quot;&gt;&lt;span&gt;适用于前端及后端&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;限流会发生误杀，难道降频就不会吗，其实也会发生，特别是用户的网络环境是一个出口IP地址时。所以，如果是基于IP地址特征的识别规则，请求数量建议适当放大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在降频策略方面，建议配置多层+渐进式的方式&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，&lt;span&gt;识别规则较为严格的&lt;/span&gt;采用挑战模式，&lt;span&gt;识别规则较为宽松的&lt;/span&gt;采用拒绝模式，减少因&lt;span&gt;降频而引发的误杀情况，参考如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;优先级&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;识别规则&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;处置手段&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;1&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;账号+1秒+5笔&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;挑战&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot;&gt;&lt;span&gt;2&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot;&gt;&lt;span&gt;账号+1秒+10笔&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot;&gt;&lt;span&gt;拒绝&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot;&gt;&lt;span&gt;3&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot;&gt;&lt;span&gt;IP地址+1秒+20笔&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot;&gt;&lt;span&gt;挑战&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot;&gt;&lt;span&gt;4&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot;&gt;&lt;span&gt;IP地址+1秒+40笔&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot; align=&quot;center&quot;&gt;&lt;span&gt;拒绝&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;降频确实可以使应用系统的资源，被合理地分配给请求方，但并不能保证万无一失，特别对于那些技术高超的软件党们，他们仍然可以通过其他方式绕开这种控制手段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;你可以将此视为一种攻防战，通过增强防守的方式，来提高攻击者成本&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，而攻击者一定会权衡成本和收益，当成本大于收益时，可能就不会有攻击，毕竟没有人会这么无聊透顶&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-darkmode-bgcolor-16440279916325=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16440279916325=&quot;#fff|rgb(255, 255, 255)&quot; data-darkmode-color-16440279916325=&quot;rgb(163, 163, 163)&quot; data-darkmode-original-color-16440279916325=&quot;#fff|rgb(62, 62, 62)&quot; data-style=&quot;max-width: 100%; min-height: 1em; white-space: pre-wrap; color: rgb(62, 62, 62); line-height: 25.6px; background-color: rgb(255, 255, 255); box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__574&quot;&gt;&lt;span&gt;虽然有了限流和降频这两招，但仍可能无法应对高并发的场景，况且在初期，限&lt;/span&gt;&lt;span&gt;流和&lt;/span&gt;&lt;span&gt;&lt;span&gt;降频的策略，也&lt;/span&gt;&lt;span&gt;无法&lt;/span&gt;&lt;/span&gt;&lt;span&gt;设计&lt;/span&gt;&lt;span&gt;得&lt;/span&gt;&lt;span&gt;非常完美。所以，有些时候还得使出最后一招。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong data-darkmode-color-16428180129682=&quot;rgb(0, 104, 255)&quot; data-darkmode-original-color-16428180129682=&quot;#fff|rgb(0, 82, 255)&quot; data-darkmode-color-16439380253696=&quot;rgb(61, 170, 214)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)|rgb(61, 170, 214)&quot;&gt;第三招：降级&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;降级，是当应用系统处理超载时，对其服务进行裁剪的一种机制&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。常见的是应用系统&lt;span&gt;处理阻塞时，会关闭&lt;span&gt;非核心服务，并将资源给到核心服务，从而确保核心服务正常。&lt;strong/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;经常有人将它与熔断混为一谈，但并非一回事&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。降级主要是针对应用系统本身，若处理能力不足则可触发，而熔断主要是针对应用系统所调用的外部服务，若外部服务不稳定时则可触发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;当然，两者也有一定的关系，因为当发生熔断时，也可以触发降级机制，比如当同步调用外部服务出现性能问题时，可以降级为异步调用，避免造成线程阻塞而瘫痪&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过在降级前，必须得先梳理应用系统中的核心服务，可以采用经典的二八原则，将服务划分为&lt;span&gt;20%核心服务+&lt;/span&gt;80%非核心服务。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;而&lt;/strong&gt;&lt;strong&gt;这种分法的意图，是希望让你找到真正重要的核心服务，不然，你会觉得都很重要&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在梳理过程中，建议通过多个维度来进行综合评判，如下是我经常采用的一种梳理方法，你可以将此作为一种参考，并结合自己的服务分类标准进行调整。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先，可以设计一张类似如下的矩阵图，请尽量地简约它，将应用系统中的各类服务，按照矩阵所设定的不同属性进行分门别类。&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;操作类&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;查询类&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;业务类&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;订单下单&lt;br/&gt;订单支付&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;订单退货&lt;br/&gt;&lt;/span&gt;...&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;商品查询&lt;br/&gt;订单查询&lt;br/&gt;退货进度&lt;br/&gt;...&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;strong&gt;&lt;span&gt;基础类&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;用户登录&lt;br/&gt;用户登出&lt;br/&gt;密码修改&lt;br/&gt;头像修改&lt;/span&gt;&lt;span&gt;&lt;br/&gt;...&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;用户查询&lt;br/&gt;历史浏览&lt;br/&gt;我的收藏&lt;br/&gt;我的分享&lt;br/&gt;...&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后，将业务类+操作&lt;/span&gt;&lt;span&gt;类的挑选出来作为&lt;span&gt;核心服务&lt;/span&gt;，你会不会认为这就结束了。不好意思，游戏才刚刚开始。不过你可以试想一下，假设&lt;/span&gt;&lt;span&gt;仅保留这些核心服务，会出现什么问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户登录不了无法订单支付，订单查询不了无法订单退货。所以，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;我们还需引入服务关键路径的概念，可以理解为在使用某个服务前，还必须要使用的其他服务&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分别对挑选出来的核心服务，进行服务关键路径的&lt;span&gt;梳理。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;路径1&lt;/span&gt;&lt;span&gt;：用户登录——&amp;gt;商品查询&lt;/span&gt;&lt;span&gt;——&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;订单下单&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;路径2：&lt;/span&gt;&lt;span&gt;用户登录——&lt;span&gt;&amp;gt;&lt;/span&gt;商品查询&lt;/span&gt;&lt;span&gt;——&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;订单下单——&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;订单支付&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;路径3：用户登录——&lt;span&gt;&amp;gt;&lt;/span&gt;订&lt;/span&gt;&lt;span&gt;单&lt;/span&gt;&lt;span&gt;查询——&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;订单退货&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;待服务关键路径梳理完成后，再对路径上的所有服务进行合并及去重，将会得到一组新的核心服务：用户登录/商品查询/订单下单/订单支付/订单查询/订单退货。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;来计算下核心服务的占比，所有服务14个/核心服务6个，占42.86%，远远超过了20%。所以，建议继续从这些核心服务中，识别更核心的部分，但仍然以服务关键路径为整体。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相比订单下单/订单支付/订单退货这三条服务关键路径，我想订单支付可能会更有价值。最后，我们可以仅将订单支付这条服务关键路径上的服务作为核心服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;重新再来计算下核心服务的占比，&lt;span&gt;所有服务14个/核心服务4个，占28.57%，&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;虽然还是超过了20%，但这并不是重点，重点是我们已经找到了最核心的服务&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其余的核心服务，可以降级为准核心服务，重组后得到如下这份服务重要程度清单。&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;核心服务&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;准核心服务&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;非核心服务&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;&lt;span&gt;用户登录&lt;br/&gt;商品查询&lt;br/&gt;订单下单&lt;br/&gt;订单支付&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;&lt;span&gt;订单查询&lt;br/&gt;订单退货&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot; align=&quot;center&quot;&gt;&lt;span&gt;退货进度&lt;br/&gt;用户登出&lt;br/&gt;密码修改&lt;br/&gt;头像修改&lt;br/&gt;用户查询&lt;br/&gt;历史浏览&lt;br/&gt;我的收藏&lt;br/&gt;我的分享&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当拥有这份清单后，若&lt;span&gt;应用系统处理阻塞时&lt;/span&gt;，就&lt;/span&gt;&lt;span&gt;可以按照非核心服务&amp;gt;准&lt;span&gt;核心服务&amp;gt;&lt;span&gt;核心服务这个顺序依次进行降级&lt;/span&gt;&lt;/span&gt;。不过，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;降级&lt;/strong&gt;&lt;strong&gt;不一定要拒绝请求，也可以是限流请求，这样可以减少对服务能力的裁剪力度&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以上只是一种相对较粗的降级策略，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如果你想要制定更精细化的降级策略，还需要&lt;span&gt;对&lt;/span&gt;&lt;/span&gt;每个服务进行优先级的设定&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，高低依据可以结合自身需要来制定，例如：&lt;span&gt;历史&lt;/span&gt;服务使用情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当有了限流、降频、降级这三招，基本就能够在资源有限的情况下，让突发请求能够被平滑地处理，将应用系统的资源能够被合理地分配，以及当应用系统处理堵塞时，&lt;span&gt;确保核心服务正常。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr data-style=&quot;font-size: 16px; outline: 0px; max-width: 100%; border-color: rgba(0, 0, 0, 0.1); caret-color: rgba(255, 255, 255, 0.6); color: rgba(255, 255, 255, 0.6); font-family: -apple-system, BlinkMacSystemFont, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.5440000295639038px; white-space: normal; border-style: solid; border-right-width: 0px; border-bottom-width: 0px; border-left-width: 0px; transform-origin: 0px 0px 0px; transform: scale(1, 0.5); box-sizing: border-box !important; word-wrap: break-word !important;&quot; class=&quot;js_darkmode__27&quot; data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;/&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;br data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;/&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span data-darkmode-color-16439380253696=&quot;rgb(61, 170, 214)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)|rgb(61, 170, 214)&quot;&gt;&lt;strong data-darkmode-color-16428180129682=&quot;rgb(0, 104, 255)&quot; data-darkmode-original-color-16428180129682=&quot;#fff|rgb(0, 82, 255)&quot; data-darkmode-color-16439380253696=&quot;rgb(61, 170, 214)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)|rgb(61, 170, 214)&quot;&gt;取舍是一种权衡&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;现在，我们已经基本了解了如何衡量性能的指标，以及大致掌握了如何保护应用系统的招数。但这些就是高并发全部了吗，我想说这仅仅只是入门级别。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;上述内容，主要是为了让你能够清晰地看到应用系统的性能水位在哪里，以及在资源有限下，当面对突发请求时可以采取哪些招数，能让应用系统安全地存活下来。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;strong&gt;&lt;span&gt;存活，即代表着可用性，它也是高并发的一个特性，而且是我认为相对比较重要的特性&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。设想一下，如果你的应用系统连可用性都无法保证，那再高的性能又有何意义。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;对于大部分应用系统而言，大家都会比较关注应用系统的可用性，99.9%不够那就99.99%，甚至还有想做到99.999%的，毕竟可用性的不足会直接影响到业务运作。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;但对于&lt;/span&gt;&lt;span&gt;&lt;strong&gt;一个想成为高并发的应用系统而言，仅单方面关注高可用，肯定无法称得上这个头衔&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，它仍然还需要在其他特性上具备极佳的表现。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;让我们拉回到最初的目标，性能是高并发的目标之一，&lt;/span&gt;&lt;span&gt;不过，这里我们不再谈论性能指标，而是来研究如何来提升性能。&lt;/span&gt;&lt;span&gt;因为，高性能是高并发的另外一个重要特性。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;想要提升性能，势必投入成本。随着成本不断增加，性能提升幅度逐渐衰减。这两句话，是不是觉得有点耳熟，但不管你是否还记得，先让我在这里打个问号再说。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;在架构设计的过程中，你是否经常会听到“取舍”的这个词，它是&lt;/span&gt;&lt;span&gt;&lt;strong&gt;通过牺牲一种能力来换取另外一种能力的方式&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，这些能力可以是性能、可用性、数据一致性或是其他能力。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;等等，你是不是突然有意识到，提升性能并不只有投入成本这种方式，至少是在硬件资源方面，我们还可以通过牺牲一种能力去换取。&lt;/span&gt;&lt;span&gt;那到底选择牺牲哪种能力呢，牺牲可用性，一般不会第一时间考虑，那是不是可以考虑牺牲数据一致性。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;但在考虑前得先声明一下，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;所谓牺牲数据一致性，并不是完全不要，而是将数据强一致性降级为最终一致性&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;而对于数据最终一致性的理解，就是在数据更新后，要过一段时间后才能看到，而时间的长短就代表着牺牲了多少。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;但并不是说，所有情况都必须牺牲数据一致性来提升性能，有些时候也可以考虑牺牲其他能力。但在取舍前，得先弄清楚当前要什么，但更需要弄清楚当前可以失去什么，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;不合理的取舍，不但无法换取收益，反而还会引来更多的问题&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;strong data-darkmode-color-16428180129682=&quot;rgb(0, 104, 255)&quot; data-darkmode-original-color-16428180129682=&quot;#fff|rgb(0, 82, 255)&quot; data-darkmode-color-16439380253696=&quot;rgb(61, 170, 214)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)|rgb(61, 170, 214)&quot;&gt;情况1：数据缓存&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;strong&gt;缓存，是高并发架构设计中一种不可或缺的能力&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，一般是指那些经常被访问的热点数据，可以将它放入缓存中，从而提升数据被读取的效率。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;但是否所有的数据都适合放入缓存中，如果是静态数据，那么你可以很安心地放入。原因很简单，静态数据不会更新，那么缓存和数据源始终保持一致，而且就算缓存中的数据丢失了，至少还有一份在数据源。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;通过将静态数据缓存，可以很轻易地提升静态数据的访问性能，甚至可能是几十倍的效果。但应用系统中还有大量的动态数据，仅提升静态数据可能对总体的提升并不一定显著。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;你是不是想说，那就把动态数据也放入缓存中不就行了。在下这个决定前，建议你先想一下，动态数据是会更新的，&lt;/span&gt;&lt;span&gt;这就意味着动态数据在放入缓存后，当数据源中的数据被更新后，再次访问返回的都是更新前的数据，这种效果你是否可以接受。&lt;/span&gt;&lt;/section&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;我想应该没有人会接受吧，而你是不是又想说，设置下缓存会过期不就能解决了。没错，但得等过期后才能解决，那还没过期前呢，这种方式只能缓解，但并不能根治，而且还会引入一个新的问题，请问过期设置多久才合适。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;设置缓存5秒钟过期，可能永远无法命中缓存，而且不但没有提升性能，还增加了代码复杂度，有点画蛇添足的感觉。&lt;/span&gt;&lt;span&gt;设置缓存5分钟过期，命中缓存的几率可能会提高，但缓存后在5分钟内的如果数据更新，要从缓存开始往后推5分钟才能看到。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;即：&lt;/span&gt;&lt;span&gt;第1分钟缓存，第1-6分钟内的任何数据更新，要第6分钟后才能看到。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;所以，如果你无法容忍这种情况，请你不要滥用缓存，虽然性能提高了，但问题可能也出现了。反之，如果你可以容忍这种情况，那就可以这么操作，而至于过期设置多久，可以结合业务场景及使用频率综合来评估，毕竟不同的业务容忍度是不同的。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;对于是否要将动态数据进行缓存，本质上，其实就是一种取舍，是一种性能与数据一致性的权衡，而&lt;/span&gt;&lt;span&gt;&lt;strong&gt;缓存的过期时长，就像是保持这种平衡的支点，从而让这种牺牲变得更有意义&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;strong data-darkmode-color-16428180129682=&quot;rgb(0, 104, 255)&quot; data-darkmode-original-color-16428180129682=&quot;#fff|rgb(0, 82, 255)&quot; data-darkmode-color-16439380253696=&quot;rgb(61, 170, 214)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)|rgb(61, 170, 214)&quot;&gt;情况2：单机限流&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;限流，前面已经有介绍过，它有两种常用的限流算法，&lt;span&gt;漏桶算法和令牌桶算法。不过&lt;/span&gt;，这两种算法都仅支持单机限流，不支持全局限流。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;单机限流，就是对单节点设定一个限流阈值，如果单节点上的请求到达阈值，则会拒绝请求。例如：&lt;span&gt;限流阈值=每秒100次请求，如果在1秒内单节点上，有第101次的请求则拒绝。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;全局限流，就是对一组节点设定一个限流总阈值，如果这组节点上的汇总请求到达阈值，则会拒绝请求。例如：&lt;/span&gt;&lt;span&gt;10个节点的限流总阈值=1000次请求，如果在1秒内这组节点上，汇总有第1001次请求则拒绝，不过单节点上有超过第100次的请求也会接受。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;这么看下来，感觉单机限流控制能力更厉害一点，它能保证单节点的请求不会超过100次。而全局限流在极端情况下，单节点都有可能在1秒内会接受1000次请求。当然，这种情况的可能性比较低，比如在突发请求时，9个节点同时宕机。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;既然如此，那全局限流有存在的意义吗，难道这就是&lt;span&gt;漏桶算法和令牌桶算法都不支持全局限流的原因。全局限流就真的没有存在的意义吗。&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;存在即合理，既然存在，那就一定有它存在的道理&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;换个情况，还是将&lt;span&gt;10个节点为一组，不过这次换成采用单机限流。问题来了，每个节点的限流阈值该如何设定，如果采用平均分配，则&lt;span&gt;限流阈值=每秒100次请求，让我们来测试一下，在1秒内依次发出1000次请求，会发生什么现象。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;结果是在第100次请求后，从第101次到第1000次的请求中，可能有些请求会发生被拒绝的情况，而且请求一会儿成功一会儿拒绝，没有任何规律。原因可能是10个节点请求负载不均所引发的，导致某个节点提前超过了100次请求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;基于以上情况，最终1000次请求没有全部成功，这种情况等同于降低了应用系统的吞吐能力。而在实际情况中，就算采用&lt;/span&gt;&lt;span&gt;轮询的负载算法，请求数不均的可能性仍然还是会存在的&lt;/span&gt;&lt;span&gt;。这么一看，单机限流好像也有缺陷。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;估计你已经被我说晕了吧，让我们整体再重新梳理一遍，并对&lt;span&gt;两&lt;/span&gt;&lt;span&gt;种不同限流模式的影响进行对比。不过，这次&lt;span&gt;还加上每秒不同的请求数量。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;每秒请求&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;单机限流&lt;br/&gt;10*100笔/秒&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;全局限流&lt;br/&gt;&lt;strong&gt;1000笔/秒&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;100笔&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;无影响&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;span&gt;无影&lt;/span&gt;&lt;span&gt;响&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;1000笔&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;少量请求拒绝&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot;&gt;&lt;span&gt;耗时小幅波动&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;10000笔&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;请求拒绝&amp;gt;9000&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;middle&quot; align=&quot;center&quot; colspan=&quot;1&quot; rowspan=&quot;1&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;请求拒绝=9000&lt;br/&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;耗时大幅&lt;/span&gt;&lt;span&gt;波动&lt;/span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;注：每个节点的处理能力为100笔/秒&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;两种限流对比下来，单机限流更强调单机的控制范围，但可能会造成额外的请求拒绝，但对单节点不会造成性能压力，而全局限流更强调整体的控制范围，虽不会造成额外的请求拒绝，但可能会对单节点造成性能压力，引发性能过载。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;除此之外，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;全局限流还是一种采用中心化的设计思路&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，因此在网络开销方面，还会产生额外的性能损耗，这种损耗在请求量少的时候估计还可以容忍，但在高并发的情况下可能是场灾难，因为在每次限流判断前，还会产生一次网络开销。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;所以，不能为了想要实现更精准的限流，就盲目地采用全局限流，它将在高并发的情况下损耗更多的性能。而单机限流所额外造成的少量请求拒绝，在某些情况下，可以考虑采用某些技术手段进行补偿。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;span&gt;不过，不管是单机限流还是全局限流，似乎都和数据一致性没有关系。但事实上，全局限流这种精准限流的方式，也可以视为另一种一致性的表现，而单机限流就是通过对这种一致性的牺牲，来减少性能损耗，何尝不是提升性能的另一种方式。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;以上，只是简单列举了两种不同情况下的取舍，而在高并发架构上，可取舍的地方远不止这些。你得知道，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;高并发的每一处设计或每一份设计方案的背后，都曾是通过不断地取舍所获得的&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，而没有取舍的高并发架构决策，将会显得毫无说服力。&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-darkmode-color-16439380253696=&quot;rgba(255, 255, 255, 0.6)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgba(255, 255, 255, 0.6)&quot;&gt;&lt;span&gt;&lt;strong&gt;取舍不但可以作为高并发架构决策的有力武器，也将是驱动架构演进最合理的一种方式&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。但要切记，取舍的方向并不是一成不变的，而是会随着外界环境的变化而变化，它将是一种独特的艺术。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;hr data-style=&quot;border-style: solid; border-width: 1px 0px 0px; border-color: rgba(0, 0, 0, 0.1); transform-origin: 0px 0px; transform: scale(1, 0.5);&quot; class=&quot;js_darkmode__107&quot;/&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong data-darkmode-color-16428180129682=&quot;rgb(0, 104, 255)&quot; data-darkmode-original-color-16428180129682=&quot;#fff|rgb(0, 82, 255)&quot; data-darkmode-color-16439380253696=&quot;rgb(61, 170, 214)&quot; data-darkmode-original-color-16439380253696=&quot;#fff|rgb(61, 170, 214)&quot;&gt;写在最后&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;高并发的魅力之处，就在于它没有唯一的答案，而答案是需要我们以不同的业务场景作为线索去不断地寻找，这种寻找的过程也是一种不断思考的过程&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，这就是我为什么说高并发是一种架构思维模式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文从浅到深依次讲述了性能是实现高并发的基础条件，控制是实现资源最大化利用的方式，以及如何通过取舍来换取当前应用系统更所需的能力，但这些仅仅只是高并发世界里的一个角落。因篇幅有限，今天就暂告一段落。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后想说，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;高并发其实并不可怕，可怕的是你知其然而不知其所以然&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;。对于追求技术的你，&lt;span&gt;需要不断地拓宽你的技术深度与广度，才能更好地掌握高并&lt;/span&gt;&lt;/span&gt;&lt;span&gt;发，以及运用高并发的思维模式来提升应用系统处理能力。&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p data-darkmode-color-16371208717484=&quot;rgb(157, 157, 157)&quot; data-darkmode-original-color-16371208717484=&quot;#fff|rgb(73, 73, 73)&quot; data-darkmode-bgcolor-16371208717484=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16371208717484=&quot;#fff|rgb(255, 255, 255)&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p data-darkmode-color-16371208717484=&quot;rgb(157, 157, 157)&quot; data-darkmode-original-color-16371208717484=&quot;#fff|rgb(73, 73, 73)&quot; data-darkmode-bgcolor-16371208717484=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16371208717484=&quot;#fff|rgb(255, 255, 255)&quot;&gt;&lt;/p&gt;&lt;p data-darkmode-color-16371208717484=&quot;rgb(157, 157, 157)&quot; data-darkmode-original-color-16371208717484=&quot;#fff|rgb(73, 73, 73)&quot; data-darkmode-bgcolor-16371208717484=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16371208717484=&quot;#fff|rgb(255, 255, 255)&quot;&gt;&lt;span&gt;期待同样追求技术的你，可以一起探讨与交流&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0085470085470085&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/gusYCVib6QexgrFKrleLJh7nmy0ooJyIsibiaJju0Tvc11FqcoNVUyV4BJGV5eo3ZsEOia3h5WSdTjG1InsgzINB6g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;351&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作者简介：金融业IT人士，熟悉信用卡业务领域。曾负责系统运维、软件开发、团队管理，现主要推动系统架构演进、技术组件自研、以及AI类产品规划等。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA5NTU2NTY5MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/gusYCVib6Qex4SJXYhiblbeQHnuDBAGouXicIK4uq3J3mtwdNWZMnfdra0qlJYwIV4WDdwfGl0gBuVCRNT3QeRcdw/0?wx_fmt=png&quot; data-nickname=&quot;技术奇妙物语&quot; data-alias=&quot;&quot; data-signature=&quot;让你沉浸在充满技术氧气的奇妙世界里，带你领略到技术改变未来的独特魅力。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>