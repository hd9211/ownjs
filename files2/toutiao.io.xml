<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>c6ea36f4e3b41e63796740a84b050e55</guid>
<title>Go 可用性（七）：总结</title>
<link>https://toutiao.io/k/hfpeg25</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;markdown-body&quot;&gt;&lt;div class=&quot;note note-info&quot;&gt;&lt;p&gt;本系列为 Go 进阶训练营 笔记，预计 2021Q2 完成更新，访问 &lt;a href=&quot;https://lailin.xyz/categories/Go%E8%BF%9B%E9%98%B6%E8%AE%AD%E7%BB%83%E8%90%A5/&quot;&gt;博客: Go进阶训练营&lt;/a&gt;, 即可查看当前更新进度，部分文章篇幅较长，使用 PC 大屏浏览体验更佳。&lt;/p&gt;&lt;/div&gt;&lt;p&gt;在前面的几篇文章当中我们聊到了 隔离设计、令牌桶算法、漏桶算法、自适应限流和熔断，可用性的建设远不止这些，这一部分的内容在进阶训练营中也讲了 7 个小时，其他部分如果感兴趣的话推荐购买源课程观看。&lt;/p&gt;&lt;p&gt;由于前面的文章大部分都在讲限流相关的内容，所以我们先看一下不同的限流方式的对比&lt;/p&gt;&lt;h2 id=&quot;限流对比&quot;&gt;&lt;a href=&quot;#限流对比&quot; class=&quot;headerlink&quot; title=&quot;限流对比&quot;/&gt;限流对比&lt;/h2&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类型&lt;/th&gt;&lt;th&gt;实现&lt;/th&gt;&lt;th&gt;优点&lt;/th&gt;&lt;th&gt;缺点&lt;/th&gt;&lt;th&gt;文章&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;单机限流&lt;/td&gt;&lt;td&gt;令牌桶&lt;/td&gt;&lt;td&gt;1. 稳定可靠，实现简单，性能高&lt;br/&gt;2. 支持突发流量应对&lt;/td&gt;&lt;td&gt;1. 流量不均匀会导致误限制&lt;br/&gt;2. 阈值设置较为困难，需要提前压测&lt;/td&gt;&lt;td&gt;&lt;a href=&quot;https://lailin.xyz/post/go-training-week6-2-token-bucket-1.html&quot;&gt;Go可用性(二) 令牌桶原理及使用&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://lailin.xyz/post/go-training-week6-3-token-bucket-2.html&quot;&gt;Go可用性(三) 令牌桶的实现 rate/limit&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;&lt;td&gt;漏桶&lt;/td&gt;&lt;td&gt;1. 稳定可靠，实现简单，性能高&lt;/td&gt;&lt;td&gt;1. 流量不均匀会导致误限制&lt;br/&gt;2. 阈值设置较为困难，需要提前压测&lt;br/&gt;3. 不支持突发流量&lt;/td&gt;&lt;td&gt;&lt;a href=&quot;https://lailin.xyz/post/go-training-week6-4-leaky-bucket.html&quot;&gt;Go可用性(四) 漏桶算法&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td/&gt;&lt;td&gt;自适应限流: BBR&lt;/td&gt;&lt;td&gt;1. 根据服务状态进行动态限流&lt;br/&gt;2. 阈值设置简单，无需提前进行压测&lt;br/&gt;3. 服务扩容无需手动调整阈值&lt;/td&gt;&lt;td&gt;1. 需要主动采集相关指标数据（cpu等）&lt;br/&gt;2. 客户端善意限流&lt;br/&gt;3. 应用场景较小&lt;/td&gt;&lt;td&gt;&lt;a href=&quot;https://lailin.xyz/post/go-training-week6-4-auto-limiter.html&quot;&gt;Go可用性(五) 自适应限流&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;全局限流&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;td&gt;1. 应用场景丰富&lt;br/&gt;2. 流量不均不会误触限流，有全局数据，可以合理进行分配&lt;br/&gt;3. 服务扩容无需手动调整阈值&lt;/td&gt;&lt;td&gt;1. 实现较为复杂&lt;br/&gt;2. 配置也较为复杂&lt;/td&gt;&lt;td&gt;-&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;微服务可用性设计总结&quot;&gt;&lt;a href=&quot;#微服务可用性设计总结&quot; class=&quot;headerlink&quot; title=&quot;微服务可用性设计总结&quot;/&gt;微服务可用性设计总结&lt;/h2&gt;&lt;p&gt;接下来我们就一起来串联我们之前讲到的和课程上讲到的一些内容总结一下可用性应该怎么做。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://mohuishou-blog-sz.oss-cn-shenzhen.aliyuncs.com/image/20210506135719.jpg&quot; srcset=&quot;/img/loading.gif&quot; alt=&quot;微服务可用性设计总结&quot;/&gt;&lt;/p&gt;&lt;p&gt;如上图所示，我们从一个简单的用户访问出发，用户访问到我们的服务一般是先通过我们的移动客户端或者是浏览器，然后请求再依次通过 CDN、防火墙、API网关、BFF以及各个后端服务，整条链路还是比较长的。&lt;/p&gt;&lt;p&gt;我们上图其实已经一部分体现了隔离设计，所以后面我就不再提了。&lt;/p&gt;&lt;h3 id=&quot;1-移动客户端-浏览器&quot;&gt;&lt;a href=&quot;#1-移动客户端-浏览器&quot; class=&quot;headerlink&quot; title=&quot;1. 移动客户端/浏览器&quot;/&gt;1. 移动客户端/浏览器&lt;/h3&gt;&lt;p&gt;客户端是触及用户的第一线，所以这一层做的可用性优化尤为的重要&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;降级:&lt;/strong&gt; 降级的本质是提供给用户有损服务，所以在触及用户的第一线如何安抚好或者说如何骗过用户的眼睛尤为重要&lt;ul&gt;&lt;li&gt;本地缓存，客户端需要有一些本地缓存数据，不仅可以加速用户首屏的加载时间，还可以在后端服务出现故障的时候起到一定的缓冲作用&lt;/li&gt;&lt;li&gt;降级数据兼容，服务端有时为了降级会返回一些 mock 数据或者是空数据，这些数据一定要和客户端的对接好，如果没有对接好很容易就会出现异常或者是白屏&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;流控:&lt;/strong&gt; 在服务出现问题的时候，用户总是会不断的主动尝试重试，如果不加以限制会让我们本就不堪重负的后端服务雪上加霜&lt;ul&gt;&lt;li&gt;所以在客户端需要做类似熔断的流控措施，常见的思路有指数级退让，或者是通过服务端的返回获取冷却的时间&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;2-BFF-Client&quot;&gt;&lt;a href=&quot;#2-BFF-Client&quot; class=&quot;headerlink&quot; title=&quot;2. BFF/Client&quot;/&gt;2. BFF/Client&lt;/h3&gt;&lt;p&gt;BFF 是我们后端服务的桥头堡，当请求来到 BFF 层的时候，BFF 既是服务端，又是客户端，因为它一般需要请求很多其他的后端服务来完成数据的编排，提供客户端想要的数据&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;超时控制：&lt;/strong&gt;超时控制需要注意的两点是默认值和超时传递&lt;ul&gt;&lt;li&gt;默认值，基础库需要有一些默认值，避免客户端用户漏填，错填，举个例子，如果开发填写一个明显过大的值 100s 才超时，这时候我们基础库可以直接抛出错误，或者是警告只有手动忽略才可以正常启动。我之前有一个应用就是因为忘记配置超时时间，依赖的服务 hang 住导致我的服务也无法正常服务了，即使我之前做了缓存也没有用，因为之前的逻辑是只有请求报错才会降级使用缓存数据。&lt;/li&gt;&lt;li&gt;超时传递，例如我们上图，假设我们整个请求的超时时间配置的 500ms，BFF 里面首先经过一些逻辑判断消耗了 100ms，然后去请求 redis，我们给 redis 配置的超时时间 &lt;code&gt;max_con&lt;/code&gt; 是 500ms，这时候就不能用 500ms 作为超时时间，得用 &lt;code&gt;min(请求剩余的超时时间，max_con)&lt;/code&gt;也就是 400ms 作为我们的超时时间，同样我们请求下游的服务也需要将超时时间携带到 header 信息里面，这样下游服务就可以继承上游的超时时间来进行超时判断。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;负载均衡：&lt;/strong&gt;一般我们比较常用的负载均衡策略就是轮训，或者说加个权重，这个比较大的问题就是，我们的服务性能并不是每个实例都一样，受到宿主机的型号，当前机器上服务的数量等等因素的影响，并且由于我们的服务是在随时漂移和变化的，所以我们没有办法为每个实例配上合适的权重。&lt;ul&gt;&lt;li&gt;所以我们可以根据一些统计数据，例如 cpu、load 等信息获取当前服务的负载情况，然后根据不同的负载情况进行打分，然后来进行流量的分配，这样就可以将我们的流量比较合理的分配到各个实例上了。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;重试：&lt;/strong&gt; &lt;strong&gt;重试一定要注意避免雪崩&lt;/strong&gt;&lt;ul&gt;&lt;li&gt;当我们的服务出现一些错误的时候，我们可以通过重试来解决，例如如果部分实例过载导致请求很慢，我们通过重试，加上面的负载均衡可以将请求发送到正常的实例，这样可以提高我们的 SLA&lt;/li&gt;&lt;li&gt;但是需要的注意的是，重试只能在错误发生的地方进行重试，不能级联重试，级联重试很容易造成雪崩，一般的做法就是约定一个 code 只要出现这个 code 我们就知道下游已经尝试过重试了，我们就不要再重试了&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;熔断：&lt;/strong&gt;一般来说如果只是部分实例出现了问题，我们通过负载均衡阶段+重试一般就可以解决，但如果服务整体出现了问题，作为客户端就需要使用熔断的措施了。&lt;ul&gt;&lt;li&gt;熔断常见的有开启，关闭，半开启的状态，例如 hystrix-go 的实现，但是这种方式比较死板，只要触发了熔断就一个请求都无法放过，所以就又学习了 Google SRE 的做法，同构计算概率来进行判断，没有了半开启的状态，开启的时候也不会说是一刀切。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;降级：&lt;/strong&gt;当我们请求一些不那么重要的服务出现错误时，我们可以通过降级的方式来返回请求，降级一般在 BFF 层做，可以有效的防止污染其他服务的缓存。常见的讨论有返回 mock 数据，缓存数据，空数据等&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;3-Server&quot;&gt;&lt;a href=&quot;#3-Server&quot; class=&quot;headerlink&quot; title=&quot;3. Server&quot;/&gt;3. Server&lt;/h3&gt;&lt;p&gt;BFF 其实也是服务端，但是为了流畅的讲解，主要将其作为了客户端的角色。服务端主要的是限流的措施，当流量从 BFF 来到我们的服务之后，我们会使用令牌桶算法尝试获取 token，如果 token 不够就丢弃，如果 token 足够就完成请求逻辑。&lt;/p&gt;&lt;p&gt;我们的 token 是从哪里来的呢？&lt;/p&gt;&lt;p&gt;拦截器会定时的向 Token Server 上报心跳数据，包含了一些统计信息，同时从 Token Server 获取一定数量的 Token，当 Token Server 接受到请求之后会通过最大最小公平分享的算法，根据每个服务实例上报的统计信息进行 Token 的分配。&lt;/p&gt;&lt;p&gt;这个其实就是之前没有讲到的分布式限流的思路，在单个服务实例上又使用了单机限流的算法&lt;/p&gt;&lt;h2 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;/&gt;总结&lt;/h2&gt;&lt;p&gt;到这里我们的可用性相关的知识点就算是告一段落了，前面的文章主要讲解了限流的相关知识点，虽然其他的没有细说，但是这一篇总结也算是都涉及到了，包括隔离设计、限流（单机限流、自适应限流、分布式限流）、超时控制、降级、熔断、负载均衡、重试，如果想要了解细节内容，可以区报名毛大的课程。OK，话不多说，我们下篇文章见。&lt;/p&gt;&lt;div class=&quot;note note-info&quot;&gt;&lt;p&gt;第 0 期已经结束，想要报名后面课程的同学，我联系极客时间为大家争取到了读者专属优惠&lt;br/&gt;&lt;strong&gt;扫描下方微信公众号二维码，发送【福利】获取专属优惠，比官方优惠更给力哦&lt;/strong&gt;&lt;/p&gt;&lt;/div&gt;&lt;h2 id=&quot;关注我获取更新&quot;&gt;&lt;a href=&quot;#关注我获取更新&quot; class=&quot;headerlink&quot; title=&quot;关注我获取更新&quot;/&gt;关注我获取更新&lt;a class=&quot;anchorjs-link&quot; aria-label=&quot;Anchor&quot; data-anchorjs-icon=&quot;&quot; href=&quot;#关注我获取更新&quot;/&gt;&lt;/h2&gt;&lt;h2 id=&quot;猜你喜欢&quot;&gt;猜你喜欢&lt;/h2&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>eec141d38d7bddd75cef0ad1d02a85ae</guid>
<title>开发团队如何选型支付网关</title>
<link>https://toutiao.io/k/vpwl7ir</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content&quot; itemprop=&quot;articleBody&quot;&gt;&amp;#13;
&lt;p&gt;支付是电子商务的最后一英里，只有顺利完成了支付，才能产生真正的业务价值。那么，对于商家来说，需要以最低的成本和最快的速度为用户提供最安全的支付功能。&lt;/p&gt;
&lt;p&gt;由于电子支付往往需要支持多种银行卡类型和第三方支付类型，同时需要满足较高的安全要求和技术标准，因此往往会借助支付网关来实现。但由于支付网关种类繁多，其功能复杂、安全标准参差不齐、集成方式众多，在选择时往往会给商家带来很大困扰。&lt;/p&gt;
&lt;p&gt;本文基于在ThoughtWorks帮助各类客户提供不同种类支付网关的经验，以及帮助客户开发和维护月交易量在百万级别的支付网关的经验，分别从功能、安全、集成方式三方面来帮助商家了解并快速选择适合自己的支付网关。&lt;/p&gt;
&lt;h3&gt;支付网关的功能&lt;/h3&gt;
&lt;h4&gt;介绍&lt;/h4&gt;
&lt;p&gt;我们将支付网关的功能分为核心功能和增值功能。核心功能包括了面向最终用户的支付功能，以及面向商家的收单服务；增值功能则包含了为支持一个完整的业务而提供的各种支撑功能。&lt;/p&gt;
&lt;h4&gt;支付功能&lt;/h4&gt;
&lt;p&gt;支付功能是支付网关的核心。支付功能包括支持的银行、卡机构、第三方支付等的种类和数量，以及支付成功率、支付处理速度、系统稳定性等技术指标。越大的支付网关，其银行和第三方支付种类覆盖范围就越广，技术更可靠，而收费也更高，且对于本地小银行的支持有限。&lt;/p&gt;
&lt;h4&gt;收单服务&lt;/h4&gt;
&lt;p&gt;由于法律监管和银行业务的要求，如果商家需要通过电子支付的方式来收款，需要在收单行开设一种特殊的银行账户：商家账户。支付网关面向商家提供收单服务，以大大降低商家与银行的谈判、申请账户、以及出问题后多方之间巨大的沟通成本。&lt;/p&gt;
&lt;h4&gt;增值功能&lt;/h4&gt;
&lt;p&gt;支付网关的差异化也体现在其增值功能的种类上：比如预授权，退款，取消支付，批量支付，定时自动支付，动态货币转换，多货币定价，报表，查询等。&lt;/p&gt;
&lt;h4&gt;我们的建议&lt;/h4&gt;
&lt;p&gt;对于核心支付功能，我们建议您根据自己的业务和用户的实际情况进行选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果是&lt;strong&gt;本地业务，最好选择一个品牌信誉好的、对本地银行业务支持更加友好的中小规模的支付网关，甚至只提供当地最流行的第三方支付就足够了。&lt;/strong&gt;当然，如果所选的小支付网关对国际业务支持的不够好，当未来业务扩展时，支付网关可能会成为制约因素。我们在项目上经常看到客户因为此原因需要更换支付网关的例子。因此，在前期的代码设计上，应该预先做好设计与隔离，为此最好准备。&lt;/li&gt;
&lt;li&gt;如果业务或用户涉及&lt;strong&gt;国外，则需要了解不同国家和地区的用户支付习惯，提供用户喜爱的本地化支付方式。此时，我们建议您选择一个将各个地区主流第三方支付打包到一起的支付网关，这样可以一次集成，多次应用。&lt;/strong&gt;我们在某项目上首先通过Worldpay帮助客户集成了Paypal，并在先期的代码设计上保留了扩展接口。后来当业务扩展需要支持支付宝和微信时，只做了一些配置的改动和非常少量的开发测试工作就上线了，节省了大量商务谈判、技术调研、从零开始的集成测试等工作。 &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于收单业务，&lt;strong&gt;我们建议您优先选择支付网关的收单服务&lt;/strong&gt;。这样，作为商家只需要跟支付网关一家打交道即可，从流程、技术、沟通等各方面，都省去了很多麻烦。&lt;/p&gt;
&lt;p&gt;对于技术指标的考量，我们必须知道，任何一笔支付，中间都会涉及多个系统的集成，出问题是非常正常的。我们在帮助客户维护支付网关的过程中，7人左右的团队往往会被各种线上问题搞得应接不暇。作为商家，以下几点可以帮助您将损失降到最低：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;不仅要看支付网关官网承诺的各项技术指标，还要与其签订明确的SLA以保护自己的权益&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在自己的系统中添加有效的监控和日志&lt;/strong&gt;，出问题时可以提供足够有价值的信息协助支付网关一起排查定位问题；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对支付网关的接口稳定性进行测试&lt;/strong&gt;，以及时发现支付网关的故障，从而采取相应措施；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现一套合理的fallback机制&lt;/strong&gt;，比如及时隐藏出问题的支付网关、切换到另一种支付网关或第三方支付等，以降低其对业务和用户的影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;对于各种增值功能，建议您按需进行考察，如果不是核心业务，可作为MVP之外的范畴，逐步纳入交付计划。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;对支付网关安全能力的考量&lt;/h3&gt;
&lt;p&gt;每年因为支付诈骗所造成的损失，对于大部分商家都是在线支付中最头疼的问题。用户支付数据泄露等安全事件还会给企业带来名誉损失和法律风险。因此，安全性应该成为我们选择支付网关时必不可少的考虑因素。&lt;/p&gt;
&lt;h4&gt;介绍&lt;/h4&gt;
&lt;p&gt;我们分别从PCI DSS、3D Secure、信用卡反欺诈和支付标记化四方面来做进一步介绍，并给出我们的建议。&lt;/p&gt;
&lt;h4&gt;PCI DSS（Payment Card Industry Data Security Standard）&lt;/h4&gt;
&lt;p&gt;PCI DSS是由支付卡产业安全标准委员会制定的第三方支付行业数据安全标准，从信息安全管理体系、网络安全、物理安全、数据加密等方方面面提出了一套保护持卡人数据的技术和操作的基线要求。PCI DSS会对支付网关等提供支付服务的机构进行年审，审计结束后，会对被认证企业提供相应的安全级别资质证明。&lt;/p&gt;
&lt;h4&gt;3D Secure&lt;/h4&gt;
&lt;p&gt;3D Secure（Three-Domain Secure，以下简称3DS）是国际卡组织为提高信用卡网上支付的安全性，向卡持卡人推出的一项安全验证服务。它规定，在使用信用卡进行支付时，必须输入支付密码、手机验证码等只有持卡人自己才知道的信息，以验证用户身份。&lt;/p&gt;
&lt;p&gt;对商家来说，3DS是一把双刃剑。如果使用了3DS，则意味着对持卡人身份更可靠的验证，如果未来发生投诉退单，其成本会由发卡行而不是商家来承担；但是由于在支付流程中需要跳转到发卡行的网站进行身份验证，从用户体验和技术上都会造成一定支付转换率的损失；同时，商家也需要为额外这一层安全保障付出成本。在某些国家或地区（比如欧洲），各大银行、支付网关和商家必须支持3DS已经是支付领域的法律要求。&lt;/p&gt;
&lt;h4&gt;信用卡反欺诈（Fraud Detection）&lt;/h4&gt;
&lt;p&gt;信用卡反欺诈是通过技术手段在支付发生前对可疑情况进行过滤，以降低支付诈骗率。最常见的一个场景，如果反欺诈系统检测到同一个IP地址在短时间内尝试使用不同卡号付款且大部分都会验证失败，则快速做出判断，认为该IP涉嫌诈骗，从而禁止所有该IP的后续请求。&lt;/p&gt;
&lt;h4&gt;支付标记化（Tokenization）&lt;/h4&gt;
&lt;p&gt;支付标记化技术是由国际芯片卡标准化组织于2014年正式发布的一项技术，其原理是：支付网关在第一次验证完用户身份后，针对每个银行卡号生成一个唯一的token并返回给商家，作为后续支付过程中代表该卡信息的凭证，这样就避免了频繁输入卡信息带来的风险。&lt;/p&gt;
&lt;h4&gt;我们的建议&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;对于PCI DSS&lt;/strong&gt;，支付网关的PCI安全认证资质证明可以作为证明其在技术、基础设施和流程等方面安全程度的最有力证明。我们在选择时，&lt;strong&gt;仔细审查其PCI安全级别资质证明即可&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于3DS，我们建议您选择支持3DS功能的支付网关，并将其作为必选项提供给您的用户&lt;/strong&gt;。不仅在现在和将来排除了法律风险，也是最有效的防支付诈骗的手段，同时可以为支付诈骗发生后做风险管理和转移提供有力证据。&lt;/p&gt;
&lt;p&gt;我们在维护支付网关的项目上，处理最多的问题就是那些因为没有使用反欺诈服务而被攻击的客户，一般遇到这种情况，来自该商家所有用户的支付请求都会被临时禁止直到攻击停止，这对正常业务会产生很大影响。&lt;strong&gt;因此，我们建议您不要吝啬投入，务必选择一个能提供有效反欺诈能力的支付网关或专业的反欺诈服务提供商&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于支付标记化，如果您的用户主要使用信用卡进行支付，那么我们建议您选择提供支付标记化功能的支付网关&lt;/strong&gt;，这样可以允许用户使用保存的卡信息进行支付，可以大大提高忠实用户的用户体验。&lt;strong&gt;对于支付标记化的考察，重点需要考察背后的卡信息是否存储在支付网关自己的数据库&lt;/strong&gt;，如果是，则需要确定其是否满足PCI Level 1的标准。&lt;/p&gt;
&lt;h3&gt;支付网关常见的集成方式&lt;/h3&gt;
&lt;h4&gt;介绍&lt;/h4&gt;
&lt;p&gt;从功能和安全性上确定您的需求后，下一个问题就是用户的支付体验和技术集成了。支付网关一般都会提供多种集成方式，每种集成方式在用户体验和技术要求上不尽相同。以下是几种最常见的集成方式：&lt;/p&gt;
&lt;h4&gt;Hosted Payment Page&lt;/h4&gt;
&lt;p&gt;当用户在商家网站确认订单并点击“继续支付”的按钮后，浏览器会直接从商家网站跳转到由支付网关提供的支付页面，在此页面输入卡信息并进行支付。&lt;/p&gt;
&lt;h4&gt;In-Context Popup&lt;/h4&gt;
&lt;p&gt;当用户在商家网站确认订单并点击“继续支付”的按钮后，直接在当前页面弹出一个由支付网关提供的支付模块弹出框，用户可以在不离开商家网站的情况下进行支付。最典型的例子就是 &lt;a href=&quot;http://https://developer.cybersource.com/library/documentation/dev_guides/AltPay_PayPal_Express_SCMP/html/Topics/PayPal_Express_Checkout_In-Context_Flow.htm&quot; title=&quot;PayPal in-context checkout 。&quot;&gt;PayPal in-context checkout 。&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;iFrame&lt;/h4&gt;
&lt;p&gt;支付网关将包含输入卡信息和支付按钮的部分提取成一个公共组件，允许商家在渲染支付页面的时候通过iFrame的形式将该支付组件加载到页面中。&lt;/p&gt;
&lt;h4&gt;API&lt;/h4&gt;
&lt;p&gt;当用户在商家网站输完支付信息、点击支付按钮后，直接从商家网站的后端发送API请求到支付网关。&lt;/p&gt;
&lt;h4&gt;我们的建议&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;不同的集成方式在用户体验、开发成本和其对商家网站PCI的要求程度是不同的，我们对此进行了一个对比&lt;/strong&gt;：&lt;br/&gt;
&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/05/截屏2021-05-11-下午3.12.29.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/05/截屏2021-05-11-下午3.12.29-768x242.png&quot; alt=&quot;how-to-choose-payment-gateway&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何选择，完全取决于现实情况，并无好坏之分。我们有下面几点建议&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于有能力满足PCI DSS、有一定技术能力来集成API的商家，用户体验最佳的API集成方式是最佳的选择；&lt;/li&gt;
&lt;li&gt;对于希望完全在PCI监管之外，或者希望以最快的速度提供支付功能，而对用户体验要求不太高的商家，Popup  或 Hosted Payment Page 是不错的选择；&lt;/li&gt;
&lt;li&gt;对于大部分商家来说，iFrame 由于不仅能帮商家规避PCI，同时具备较好的用户体验和较快的集成速度，是大部分场景的最优选择。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;其他需要考虑的因素&lt;/h3&gt;
&lt;p&gt;除了以上核心的考察点之外，下面这些因素不仅可以从侧面证明支付网关的业务和技术能力，也是我们在使用支付网关的服务时很重要的方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;是否提供清晰、快速的onboard流程&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;其技术文档是否足够信息、准确且包括必要的细节，是否提供设计优良的客户端SDK&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;是否提供沙盒环境和测试账号供我们在测试环境进行自动化和手工测试&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;技术支持是否专业、及时且有效&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;希望通过本文的介绍，让您对支付网关有了一定的了解，也有足够的知识和技巧来选择一个适合自己的支付网关。&lt;/p&gt;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9a8fd2e18946e09e0afbbe4dea1824fb</guid>
<title>深入源码，深度解析 Java 线程池的实现原理</title>
<link>https://toutiao.io/k/sorcj5w</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;article-content&quot;&gt;
&lt;p&gt;java 系统的运行归根到底是&lt;strong&gt;程序&lt;/strong&gt;的运行，程序的运行归根到底是代码的执行，代码的执行归根到底是虚拟机的执行，虚拟机的执行其实就是操作系统的线程在执行，并且会占用一定的系统资源，如CPU、内存、磁盘、网络等等。所以，&lt;strong&gt;如何高效的使用这些资源就是程序员在平时写代码时候的一个努力的方向&lt;/strong&gt;。本文要说的&lt;strong&gt;线程池&lt;/strong&gt;就是一种对 &lt;strong&gt;CPU&lt;/strong&gt; 利用的优化手段。&lt;/p&gt;
&lt;p&gt;线程池，百度百科是这么解释的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;线程池，其实就是维护了很多线程的池子，类似这样的技术还有很多的，例如：HttpClient 连接池、数据库连接池、内存池等等。&lt;/p&gt;
&lt;h2&gt;线程池的优点&lt;/h2&gt;
&lt;p&gt;在 Java 并发编程框架中的线程池是运用场景最多的技术，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来至少以下4个好处。&lt;/p&gt;
&lt;p&gt;第一：&lt;strong&gt;降低资源消耗&lt;/strong&gt;。通过重复利用已创建的线程降低线程创建和销毁造成的消耗；&lt;/p&gt;
&lt;p&gt;第二：&lt;strong&gt;提高响应速度&lt;/strong&gt;。当任务到达时，任务可以不需要等到线程创建就能立即执行；&lt;/p&gt;
&lt;p&gt;第三：&lt;strong&gt;提高线程的可管理性&lt;/strong&gt;。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。&lt;/p&gt;
&lt;p&gt;第四：&lt;strong&gt;提供更强大的功能，比如延时定时线程池；&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;线程池的实现原理&lt;/h2&gt;
&lt;p&gt;当向线程池提交一个任务之后，线程池是如何处理这个任务的呢？下面就先来看一下它的主要处理流程。先来看下面的这张图，然后我们一步一步的来解释。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogs-1302490380.cos.ap-nanjing.myqcloud.com/20210322132334.png&quot; alt=&quot;image-20210322132334799&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当使用者将一个任务提交到线程池以后，线程池是这么执行的：&lt;/p&gt;
&lt;p&gt;①首先判断&lt;strong&gt;核心的线程数&lt;/strong&gt;是否已满，如果没有满，那么就去创建一个线程去执行该任务；否则请看下一步&lt;/p&gt;
&lt;p&gt;②如果线程池的核心线程数已满，那么就继续判断&lt;strong&gt;任务队列&lt;/strong&gt;是否已满，如果没满，那么就将任务放到任务队列中；否则请看下一步&lt;/p&gt;
&lt;p&gt;③如果任务队列已满，那么就判断&lt;strong&gt;线程池是否已满&lt;/strong&gt;，如果没满，那么就创建线程去执行该任务；否则请看下一步；&lt;/p&gt;
&lt;p&gt;④如果线程池已满，那么就根据&lt;strong&gt;拒绝策略&lt;/strong&gt;来做出相应的处理；&lt;/p&gt;
&lt;p&gt;上面的四步其实就已经将线程池的执行原理描述结束了。如果不明白没有关系，先一步一步往下看，上面涉及到的线程池的专有名词都会详细的介绍到。&lt;/p&gt;
&lt;p&gt;我们在平时的开发中，线程池的使用基本都是基于&lt;code&gt;ThreadPoolExexutor&lt;/code&gt;类，他的继承体系是这样子的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogs-1302490380.cos.ap-nanjing.myqcloud.com/20210322133058.png&quot; alt=&quot;image-20210322133058425&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那既然说在使用中都是基于&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;的那么我们就重点分析这个类。&lt;/p&gt;
&lt;p&gt;至于他构造体系中的其他的类或者是接口中的属性，这里就不去截图了，完全没有必要。小伙伴如果实在想看就自己去打开代码看一下就行了。&lt;/p&gt;
&lt;h2&gt;ThreadPoolExecutor&lt;/h2&gt;
&lt;p&gt;在《阿里巴巴 java 开发手册》中指出了线程资源必须通过线程池提供，不允许在应用中自行显示的创建线程，这样一方面是线程的创建更加规范，可以合理控制开辟线程的数量；另一方面线程的细节管理交给线程池处理，优化了资源的开销。&lt;/p&gt;
&lt;p&gt;其原文描述如下：&lt;/p&gt;
&lt;p&gt;&lt;img loading=&quot;lazy&quot; src=&quot;https://www.hollischuang.com/wp-content/uploads/2021/05/Jietu20210525-235930-300x39.jpg&quot; alt=&quot;&quot; class=&quot;aligncenter size-medium wp-image-6346&quot; srcset=&quot;https://www.hollischuang.com/wp-content/uploads/2021/05/Jietu20210525-235930-300x39.jpg 300w, https://www.hollischuang.com/wp-content/uploads/2021/05/Jietu20210525-235930-1024x134.jpg 1024w, https://www.hollischuang.com/wp-content/uploads/2021/05/Jietu20210525-235930-768x101.jpg 768w, https://www.hollischuang.com/wp-content/uploads/2021/05/Jietu20210525-235930-1536x201.jpg 1536w, https://www.hollischuang.com/wp-content/uploads/2021/05/Jietu20210525-235930-2048x268.jpg 2048w&quot; sizes=&quot;(max-width: 300px) 100vw, 300px&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;类中提供了四个构造方法，但是他的四个构造器中，实际上最终都会调用同一个构造器，只不过是在另外三个构造器中，如果有些参数不传&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;会帮你使用默认的参数。所以，我们直接来看这个完整参数的构造器，来彻底剖析里面的参数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public  class  ThreadPoolExecutor  extends  AbstractExecutorService {
    ......

    public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,long keepAliveTime,TimeUnit unit,
                                  BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,ThreadFactory threadFactory,
                                  RejectedExecutionHandler handler) {
            if (corePoolSize &amp;lt; 0 || maximumPoolSize &amp;lt;= 0 || maximumPoolSize &amp;lt; corePoolSize || keepAliveTime &amp;lt; 0){
                throw new IllegalArgumentException();
            }
            if (workQueue == null || threadFactory == null || handler == null){
                throw new NullPointerException();
            }
            this.acc = System.getSecurityManager() == null ? null : AccessController.getContext();
            this.corePoolSize = corePoolSize;
            this.maximumPoolSize = maximumPoolSize;
            this.workQueue = workQueue;
            this.keepAliveTime = unit.toNanos(keepAliveTime);
            this.threadFactory = threadFactory;
            this.handler = handler;
        }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主要参数就是下面这几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;corePoolSize：线程池中的核心线程数，包括空闲线程，也就是核心线程数的大小；&lt;/li&gt;
&lt;li&gt;maximumPoolSize：线程池中允许的最多的线程数，也就是说线程池中的线程数是不可能超过该值的；&lt;/li&gt;
&lt;li&gt;keepAliveTime：当线程池中的线程数大于 corePoolSize 的时候，在超过指定的时间之后就会将多出 corePoolSize 的的空闲的线程从线程池中删除；&lt;/li&gt;
&lt;li&gt;unit：keepAliveTime 参数的单位（常用的秒为单位）；&lt;/li&gt;
&lt;li&gt;workQueue：用于保存任务的队列，此队列仅保持由 executor 方法提交的任务 Runnable 任务；&lt;/li&gt;
&lt;li&gt;threadFactory：线程池工厂，他主要是为了给线程起一个标识。也就是为线程起一个具有意义的名称；&lt;/li&gt;
&lt;li&gt;handler：拒绝策略&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;阻塞队列&lt;/h3&gt;
&lt;p&gt;workQueue 有多种选择，在 JDK 中一共提供了 7 中阻塞对列，分别为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;ArrayBlockingQueue ： 一个由数组结构组成的有界阻塞队列。 此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平地访问队列 ，所谓公平访问队列是指阻塞的线程，可按照阻塞的先后顺序访问队列。非公平性是对先等待的线程是不公平的，当队列可用时，阻塞的线程都可以竞争访问队列的资格。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LinkedBlockingQueue ： 一个由链表结构组成的有界阻塞队列。 此队列的默认和最大长度为Integer.MAX_VALUE。 此队列按照先进先出的原则对元素进行排序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PriorityBlockingQueue ： 一个支持优先级排序的无界阻塞队列。 （虽然此队列逻辑上是无界的，但是资源被耗尽时试图执行 add 操作也将失败，导致 OutOfMemoryError）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DelayQueue： 一个使用优先级队列实现的无界阻塞队列。 元素的一个无界阻塞队列，只有在延迟期满时才能从中提取元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SynchronousQueue： 一个不存储元素的阻塞队列。 一种阻塞队列，其中每个插入操作必须等待另一个线程的对应移除操作 ，反之亦然。（SynchronousQueue 该队列不保存元素）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LinkedTransferQueue： 一个由链表结构组成的无界阻塞队列。 相对于其他阻塞队列LinkedTransferQueue多了tryTransfer和transfer方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LinkedBlockingDeque： 一个由链表结构组成的双向阻塞队列。 是一个由链表结构组成的双向阻塞队列&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在以上的7个队列中，线程池中常用的是&lt;code&gt;ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;队列中的常用的方法如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;特点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;抛异常&lt;/td&gt;
&lt;td&gt;add&lt;/td&gt;
&lt;td&gt;添加一个元素&lt;/td&gt;
&lt;td&gt;如果队列满，抛出异常 IllegalStateException&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;抛异常&lt;/td&gt;
&lt;td&gt;remove&lt;/td&gt;
&lt;td&gt;返回并删除队列的头节点&lt;/td&gt;
&lt;td&gt;如果队列空，抛出异常 NoSuchElementException&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;抛异常&lt;/td&gt;
&lt;td&gt;element&lt;/td&gt;
&lt;td&gt;返回队列头节点&lt;/td&gt;
&lt;td&gt;如果队列空，抛出异常 NoSuchElementException&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;不抛异常，但是不阻塞&lt;/td&gt;
&lt;td&gt;offer&lt;/td&gt;
&lt;td&gt;添加一个元素&lt;/td&gt;
&lt;td&gt;添加成功，返回 true，添加失败，返回 false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;不抛异常，但是不阻塞&lt;/td&gt;
&lt;td&gt;poll&lt;/td&gt;
&lt;td&gt;返回并删除队列的头节点&lt;/td&gt;
&lt;td&gt;如果队列空，返回 null&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;不抛异常，但是不阻塞&lt;/td&gt;
&lt;td&gt;peek&lt;/td&gt;
&lt;td&gt;返回队列头节点&lt;/td&gt;
&lt;td&gt;如果队列空，返回 null&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;阻塞&lt;/td&gt;
&lt;td&gt;put&lt;/td&gt;
&lt;td&gt;添加一个元素&lt;/td&gt;
&lt;td&gt;如果队列满，阻塞&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;阻塞&lt;/td&gt;
&lt;td&gt;take&lt;/td&gt;
&lt;td&gt;返回并删除队列的头节点&lt;/td&gt;
&lt;td&gt;如果队列空，阻塞&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;关于阻塞队列，介绍到这里也就基本差不多了。&lt;/p&gt;
&lt;h3&gt;线程池工厂&lt;/h3&gt;
&lt;p&gt;线程池工厂，就像上面已经介绍的，目的是为了给线程起一个有意义的名字。用起来也非常的简单，只需要实现&lt;code&gt;ThreadFactory&lt;/code&gt;接口即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class CustomThreadFactory implements ThreadFactory {
    @Override
    public Thread newThread(Runnable r) {
        Thread thread = new Thread(r);
        thread.setName(&quot;我是你们自己定义的线程名称&quot;);
        return thread;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体的使用就不去废话了。&lt;/p&gt;
&lt;h3&gt;拒绝策略&lt;/h3&gt;
&lt;p&gt;线程池有四种默认的拒绝策略，分别为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;AbortPolicy：这是线程池默认的拒绝策略，在任务不能再提交的时候，抛出异常，及时反馈程序运行状态。如果是比较关键的业务，推荐使用此拒绝策略，这样子在系统不能承载更大的并发量的时候，能够及时的通过异常发现；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DiscardPolicy：丢弃任务，但是不抛出异常。如果线程队列已满，则后续提交的任务都会被丢弃，且是静默丢弃。这玩意不建议使用；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务。这玩意不建议使用；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CallerRunsPolicy：如果任务添加失败，那么主线程就会自己调用执行器中的 executor 方法来执行该任务。这玩意不建议使用；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也就是说关于线程池的拒绝策略，最好使用默认的。这样能够及时发现异常。如果上面的都不能满足你的需求，你也可以自定义拒绝策略，只需要实现 &lt;code&gt;RejectedExecutionHandler&lt;/code&gt; 接口即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class CustomRejection implements RejectedExecutionHandler {
    @Override
    public void rejectedExecution(Runnable r, ThreadPoolExecutor executor) {
        System.out.println(&quot;你自己想怎么处理就怎么处理&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;看到这里，我们再来画一张图来总结和概括下线程池的执行示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://blogs-1302490380.cos.ap-nanjing.myqcloud.com/20210322145600.png&quot; alt=&quot;image-20210322145600064&quot;/&gt;&lt;/p&gt;
&lt;p&gt;详细的执行过程全部在图中说明了。&lt;/p&gt;
&lt;h2&gt;提交任务到线程池&lt;/h2&gt;
&lt;p&gt;在 java 中，有两个方法可以将任务提交到线程池，分别是&lt;code&gt;submit&lt;/code&gt;和&lt;code&gt;execute&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;execute 方法&lt;/h3&gt;
&lt;p&gt;execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void execute(Runnable command);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过以下代码可知 execute() 方法输入的任务是一个Runnable类的实例。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;executorService.execute(()-&amp;gt;{
            System.out.println(&quot;ThreadPoolDemo.execute&quot;);
        });
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;submit 方法&lt;/h3&gt;
&lt;p&gt;submit()方法用于提交需要返回值的任务。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Future&amp;lt;?&amp;gt; submit(Runnable task);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;线程池会返回一个future类型的对象，通过这个 future 对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get() 方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Future&amp;lt;?&amp;gt; submit = executorService.submit(() -&amp;gt; {
            System.out.println(&quot;ThreadPoolDemo.submit&quot;);
        });
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;关闭线程池&lt;/h2&gt;
&lt;p&gt;其实，如果优雅的关闭线程池是一个令人头疼的问题，线程开启是简单的，但是想要停止却不是那么容易的。通常而言， 大部分程序员都是使用 jdk 提供的两个方法来关闭线程池，他们分别是：&lt;code&gt;shutdown&lt;/code&gt; 或 &lt;code&gt;shutdownNow&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;通过调用线程池的 &lt;code&gt;shutdown&lt;/code&gt; 或 &lt;code&gt;shutdownNow&lt;/code&gt; 方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的 interrupt 方法来中断线程（PS：&lt;strong&gt;中断，仅仅是给线程打上一个标记，并不是代表这个线程停止了，如果线程不响应中断，那么这个标记将毫无作用&lt;/strong&gt;），所以无法响应中断的任务可能永远无法终止。&lt;/p&gt;
&lt;p&gt;但是它们存在一定的区别，&lt;code&gt;shutdownNow&lt;/code&gt;首先将线程池的状态设置成 STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而 &lt;code&gt;shutdown&lt;/code&gt; 只是将线程池的状态设置成&lt;code&gt;SHUTDOWN&lt;/code&gt;状态，然后中断所有没有正在执行任务的线程。&lt;/p&gt;
&lt;p&gt;只要调用了这两个关闭方法中的任意一个，&lt;code&gt;isShutdown&lt;/code&gt; 方法就会返回 true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用&lt;code&gt;isTerminaed&lt;/code&gt;方法会返回 true。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用 &lt;code&gt;shutdown&lt;/code&gt;方法来关闭线程池，如果任务不一定要执行完，则可以调用 &lt;code&gt;shutdownNow&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;这里推荐使用稳妥的 &lt;code&gt;shutdownNow&lt;/code&gt; 来关闭线程池，至于更优雅的方式我会在以后的&lt;strong&gt;并发编程设计模式中的两阶段终止模式中&lt;/strong&gt;会再次详细介绍。&lt;/p&gt;
&lt;h2&gt;合理的参数&lt;/h2&gt;
&lt;p&gt;为什么叫合理的参数，那不合理的参数是什么样子的？在我们创建线程池的时候，里面的参数该如何设置才能称之为合理呢？其实这是有一定的依据的，我们先来看一下以下的创建的方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ExecutorService executorService = new ThreadPoolExecutor(5,
                5,
                5,
                TimeUnit.SECONDS,
                new ArrayBlockingQueue&amp;lt;&amp;gt;(5),
                r -&amp;gt; {
                    Thread thread = new Thread(r);
                    thread.setName(&quot;线程池原理讲解&quot;);
                    return thread;
                });
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你说他合理不合理？我也不知道，因为我们没有参考的依据，在实际的开发中，我们需要根据任务的性质（IO是否频繁？）来决定我们创建的核心的线程数的大小，实际上可以从以下的一个角度来分析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任务的性质：CPU密集型任务、IO密集型任务和混合型任务；&lt;/li&gt;
&lt;li&gt;任务的优先级：高、中和低；&lt;/li&gt;
&lt;li&gt;任务的执行时间：长、中和短；&lt;/li&gt;
&lt;li&gt;任务的依赖性：是否依赖其他系统资源，如数据库连接；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;性质不同的任务可以用不同规模的线程池分开处理。&lt;strong&gt;分为CPU密集型和IO密集型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CPU密集型任务&lt;/strong&gt;应配置尽可能小的线程，如配置 &lt;code&gt;Ncpu+1&lt;/code&gt;个线程的线程池。(可以通过&lt;code&gt;Runtime.getRuntime().availableProcessors()&lt;/code&gt;来获取CPU物理核数)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IO密集型任务&lt;/strong&gt;线程并不是一直在执行任务，则应配置尽可能多的线程，如 &lt;code&gt;2*Ncpu&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;混合型的任务，如果可以拆分，将其拆分成一个&lt;strong&gt;CPU密集型任务一个IO密集型任务&lt;/strong&gt;，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。&lt;/p&gt;
&lt;p&gt;如果这两个任务执行时间相差太大，则没必要进行分解。可以通过 &lt;code&gt;Runtime.getRuntime().availableProcessors()&lt;/code&gt; 方法获得当前设备的CPU个数。&lt;/p&gt;
&lt;p&gt;优先级不同的任务可以使用优先级队列 &lt;code&gt;PriorityBlockingQueue&lt;/code&gt;来处理。它可以让优先级高的任务先执行（注意：&lt;strong&gt;如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，等待的时间越长，则 CPU 空闲时间就越长，那么线程数应该设置得越大，这样才能更好地利用CPU。&lt;/p&gt;
&lt;p&gt;建议使用有界队列。有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点。方式因为提交的任务过多而导致 OOM；&lt;/p&gt;
&lt;h2&gt;7、本文小结&lt;/h2&gt;
&lt;p&gt;本文主要介绍的是线程池的实现原理以及一些使用技巧，在实际开发中，线程池可以说是稍微高级一点的程序员的必备技能。所以掌握好线程池这门技术也是重中之重！&lt;/p&gt;
&lt;center&gt;&lt;b&gt;(全文完)&lt;/b&gt;&lt;/center&gt;&lt;hr/&gt;&lt;center&gt;&lt;b&gt;扫描二维码，关注作者微信公众号&lt;/b&gt;&lt;/center&gt;&lt;img src=&quot;http://www.hollischuang.com/wp-content/uploads/2019/04/二维码.png&quot;/&gt;
&lt;/article&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3028a1debfcf28725377ee39e621ed00</guid>
<title>我这样升级 Go 版本，你呢？</title>
<link>https://toutiao.io/k/5rsuqjy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是 polarisxu。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些人可能注意到，每次 Go 发布新版本，官方都会提供类似这样的升级截图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5779411764705882&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UzjmETLXwBYmKfgnIJt7Z01IxoDE80VBxpgxevuDmsKpFKq0eNd8ozlgJ95iaVZHpmdibywDMbvhxWvZjEq4Gy9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;680&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这可以说是官方的 Go 多版本管理，也是升级 Go 的方式。今天就一起聊一聊这种多版本管理方式及其实现原理。（我之前介绍过一个第三方多版本管理工具 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzAxNzY0NDE3NA==&amp;amp;mid=2247485026&amp;amp;idx=1&amp;amp;sn=dcc047b6afe0e4e4daf37f8c9e499fce&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;goup&lt;/a&gt;，是我比较推荐的）。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意，Windows 用户应该使用 WSL2。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;01 为什么需要多个 Go 版本&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些人可能觉得没有这样的需求。实际工作中，这样的需求还是很常见的。以下一些场景，可能会希望有多版本：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;一般为了稳定，线上版本通常不会激进升级到最新版本，但你本地很可能想试用新版本的功能。这时候就希望能方便的支持多版本；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;为了测试或重现特定的问题，希望能够在特定的版本进行，这是为了避免不同版本干扰。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;。。。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多版本并存，让我们可以更自如的使用 Go。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;02 官方多版本的使用方式&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据上面的图，安装某个版本的 Go，跟一般 Go 包安装一样，执行 go get 命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ go get golang.org/dl/go&amp;lt;version&amp;gt;  // 其中 &amp;lt;version&amp;gt; 替换为你希望安装的 Go 版本&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一步，只是安装了一个特定 Go 版本的包装器，真正安装特定的 Go 版本，还需要执行如下命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ go&amp;lt;version&amp;gt; download   // 和上面一样，&amp;lt;version&amp;gt; 是具体的版本&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，如果需要安装 Go1.16.4，执行如下两个命令即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ go get golang.org/dl/go1.16.4&lt;br/&gt;$ go1.16.4 download&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;几个注意的点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;有一个特殊的版本标记：gotip，用来安装最新的开发版本；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;因为 golang.org 访问不了，你应该配置 GOPROXY（所以，启用 Module 是必须的）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;跟安装其他包一样，go get 之后，go1.16.4 这个命令会被安装到 &lt;code&gt;$GOBIN&lt;/code&gt; 目录下，默认是 &lt;code&gt;~/go/bin&lt;/code&gt; 目录，所以该目录应该放入 PATH 环境变量；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没有执行 download 之前，运行 go1.16.4，会提示 &lt;code&gt;go1.16.4: not downloaded. Run &#x27;go1.16.4 download&#x27; to install to ~/sdk/go1.16.4&lt;/code&gt;；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可见，最后下载下来的 Go 放在了 ~/sdk/go1.16.4 目录下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在你是否有这样的疑问：没执行 download 之前，直接运行 go1.16.4 会报错，执行之后，它就成了具体的 Go 命令了，怎么做到的？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;03 扒一扒原理&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;golang.org/dl/go&amp;lt;version&amp;gt;&lt;/code&gt; 对应的源码在 https://github.com/golang/dl（这是一个镜像）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看该仓库代码，发现一堆以各个版本命名的目录：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7323943661971831&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UzjmETLXwBYmKfgnIJt7Z01IxoDE80VBTcJVfNY4zz1BVjJIbVvIWYbDiaf8K70UqoGx7icHhvEPtPwOnSEInwLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;781&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可见，每次发布新版本，都需要往这个仓库增加一个对应的版本文件夹。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随便打开一个（比如 go1.16.4），看看里面包含什么文件：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就一个 main.go 文件（从 go get 安装操作，你应该猜到一定有一个 main.go 文件）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;main.go 文件的内容如下：（gotip 的内容不一样，它调用的是 version.RunTip()）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;golang.org/dl/internal/version&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; version.Run(&lt;span&gt;&quot;go1.16.4&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，关键在于 internal/version 包的 Run 函数（不同版本，version 参数不同）。注意以下代码我给的注释：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Run runs the &quot;go&quot; tool of the provided Go version.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Run&lt;/span&gt;&lt;span&gt;(version &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; log.SetFlags(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// goroot 获取 go 安装的目录，即 ~/sdk/go&amp;lt;version&amp;gt;&lt;/span&gt;&lt;br/&gt; root, err := goroot(version)&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  log.Fatalf(&lt;span&gt;&quot;%s: %v&quot;&lt;/span&gt;, version, err)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 执行下载操作&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;len&lt;/span&gt;(os.Args) == &lt;span&gt;2&lt;/span&gt; &amp;amp;&amp;amp; os.Args[&lt;span&gt;1&lt;/span&gt;] == &lt;span&gt;&quot;download&quot;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; err := install(root, version); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   log.Fatalf(&lt;span&gt;&quot;%s: download failed: %v&quot;&lt;/span&gt;, version, err)&lt;br/&gt;  }&lt;br/&gt;  os.Exit(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 怎么验证是否已经下载好了 Go？在下载的 Go 中会创建一个 .unpacked-success 文件，用来指示下载好了。&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; _, err := os.Stat(filepath.Join(root, unpackedOkay)); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  log.Fatalf(&lt;span&gt;&quot;%s: not downloaded. Run &#x27;%s download&#x27; to install to %v&quot;&lt;/span&gt;, version, version, root)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 运行下载好的 Go&lt;/span&gt;&lt;br/&gt; runGo(root)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里主要是下载和运行 Go。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;下载&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先看下载、安装 Go。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当执行 go1.16.4 download 时，会运行 install 函数，查看该函数发现，它调用了 versionArchiveURL 函数获取要下载的 Go 的 URL：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// versionArchiveURL returns the zip or tar.gz URL of the given Go version.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;versionArchiveURL&lt;/span&gt;&lt;span&gt;(version &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    goos := getOS()&lt;br/&gt;&lt;br/&gt;    ext := &lt;span&gt;&quot;.tar.gz&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; goos == &lt;span&gt;&quot;windows&quot;&lt;/span&gt; {&lt;br/&gt;        ext = &lt;span&gt;&quot;.zip&quot;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    arch := runtime.GOARCH&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; goos == &lt;span&gt;&quot;linux&quot;&lt;/span&gt; &amp;amp;&amp;amp; runtime.GOARCH == &lt;span&gt;&quot;arm&quot;&lt;/span&gt; {&lt;br/&gt;        arch = &lt;span&gt;&quot;armv6l&quot;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;https://dl.google.com/go/&quot;&lt;/span&gt; + version + &lt;span&gt;&quot;.&quot;&lt;/span&gt; + goos + &lt;span&gt;&quot;-&quot;&lt;/span&gt; + arch + ext&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是从 https://dl.google.com 下载 Go 包，最终的包（是一个归档文件，Wiindows 下是 .zip，其他系统是 .tar.gz）会放到 ~/sdk/go1.16.4 目录下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后通过 sha256 验证文件的完整性（因为服务端放了 sha256 校验文件），最后解压缩，并创建上面说的 &lt;code&gt;.unpacked-success&lt;/code&gt; 空标记文件。这样这个版本的 Go 就安装成功了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;注意，gotip 的下载是通过 git 获取源码的方式进行的，它会通过源码构建安装最新的 gotip 版本。具体逻辑在 internal/version/gotip.go 中。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;运行&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为下载的 Go 是预编译好的，因此可以直接使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是它将 Go 下载到了 &lt;code&gt;~/sdk/go&amp;lt;version&amp;gt;&lt;/code&gt; 目录下了，我们并没有将这个目录的 bin 目录加入 PATH，因此直接 go 命令运行的还是之前的版本，而不是刚安装的 go1.16.4。这个问题我们一会再说，先看看为什么这个时候 go1.16.4 命令可以当作 go 命令来使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上文说了，go1.16.4 只是一个包装器。当对应的 Go1.16.4 安装成功后，再次运行 go1.16.4，会执行 internal/version/version.go 中的 runGo(root) 函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;runGo&lt;/span&gt;&lt;span&gt;(root &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    gobin := filepath.Join(root, &lt;span&gt;&quot;bin&quot;&lt;/span&gt;, &lt;span&gt;&quot;go&quot;&lt;/span&gt;+exe())&lt;br/&gt;    cmd := exec.Command(gobin, os.Args[&lt;span&gt;1&lt;/span&gt;:]...)&lt;br/&gt;    cmd.Stdin = os.Stdin&lt;br/&gt;    cmd.Stdout = os.Stdout&lt;br/&gt;    cmd.Stderr = os.Stderr&lt;br/&gt;    newPath := filepath.Join(root, &lt;span&gt;&quot;bin&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; p := os.Getenv(&lt;span&gt;&quot;PATH&quot;&lt;/span&gt;); p != &lt;span&gt;&quot;&quot;&lt;/span&gt; {&lt;br/&gt;        newPath += &lt;span&gt;string&lt;/span&gt;(filepath.ListSeparator) + p&lt;br/&gt;    }&lt;br/&gt;    cmd.Env = dedupEnv(caseInsensitiveEnv, &lt;span&gt;append&lt;/span&gt;(os.Environ(), &lt;span&gt;&quot;GOROOT=&quot;&lt;/span&gt;+root, &lt;span&gt;&quot;PATH=&quot;&lt;/span&gt;+newPath))&lt;br/&gt;&lt;br/&gt;    handleSignals()&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; err := cmd.Run(); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// &lt;span&gt;TODO:&lt;/span&gt; return the same exit status maybe.&lt;/span&gt;&lt;br/&gt;        os.Exit(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;    }&lt;br/&gt;    os.Exit(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该函数通过 os/exec 包运行 &lt;code&gt;~/sdk/go1.16.4/bin/go&lt;/code&gt; 命令，并设置好响应的标准输入输出流等，同时为新运行的进程设置好相关环境变量，可以认为，执行 go1.16.4，相当于执行 &lt;code&gt;~/sdk/go1.16.4/bin/go&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，go1.16.4 这个命令，一直都只是一个包装器。如果你希望新安装的 go1.16.4 成为系统默认的 Go 版本，即希望运行 go 运行的是 go1.16.4，方法有很多：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将 &lt;code&gt;~/sdk/go1.16.4/bin/go&lt;/code&gt; 加入 PATH 环境变量（替换原来的）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;做一个软连，默认 go 执行 go1.16.4（推荐这种方式），不需要频繁修改 PATH；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;移动 go1.16.4 替换之前的 go（不推荐）；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;03 每次升级版本创建一个包装器&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;手动复制粘贴代码做这件事情肯定是很笨的办法。在 golang.org/dl 中提供了一个工具，可以快速生成对应版本的包装器：https://github.com/golang/dl/blob/master/internal/genv/main.go。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ genv go1.16.4&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就可以生成 go1.16.4 包装器。这里的实现，有一个点提一下，它使用了 go list -m -json 命令：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ go list -m -json&lt;br/&gt;{&lt;br/&gt;        &lt;span&gt;&quot;Path&quot;&lt;/span&gt;: &lt;span&gt;&quot;golang.org/dl&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;Main&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;Dir&quot;&lt;/span&gt;: &lt;span&gt;&quot;&amp;lt;workspace&amp;gt;/dl&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;GoMod&quot;&lt;/span&gt;: &lt;span&gt;&quot;&amp;lt;workspace&amp;gt;/dl/go.mod&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;GoVersion&quot;&lt;/span&gt;: &lt;span&gt;&quot;1.11&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以方便解析相关信息。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;04 总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方的 Go 多版本管理就介绍完了。总结一下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;官方通过 genv 命令生成对应版本的包装器；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 go get 命令下载安装对应的包装器；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;运行包装器，提供 download 这个 flag，下载对应版本的 Go 安装包并解压、校验；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;之后，运行包装器，会执行对应版本的 go 命令；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样达到了多版本管理的目的。这个设计思路还是可以的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这种多版本管理，我认为存在一些问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;上面说的，让某个版本成为默认 Go 版本，没有命令一键搞定；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;没法知道有哪些版本，比如无法方便的知晓 1.15.13 是否存在，更无法方便的知晓 1.15.x 系列，x 的最大版本；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;删除某个版本，得手动进行（删除包装器和下载的 Go 安装包）；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你喜欢这种方式管理还是类似 goup 这样的第三方工具呢？你现在是怎么管理多版本的，欢迎交流！&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3d2b25c4e3020b1304bbc17f0c9f8570</guid>
<title>mybatis-sql 输出小插曲</title>
<link>https://toutiao.io/k/5kl2svw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;pre&gt;&lt;p class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ConnectionLogger&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BaseJdbcLogger&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;InvocationHandler&lt;/span&gt; &lt;/span&gt;{&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Connection connection;&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ConnectionLogger&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Connection conn, Log statementLog, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; queryStack)&lt;/span&gt; &lt;/span&gt;{&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(statementLog, queryStack);&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.connection = conn;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;  }&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;title&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object proxy, Method method, Object[] params)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Throwable {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (Object.class.equals(method.getDeclaringClass())) {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; method.invoke(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, params);&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;      }&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&quot;prepareStatement&quot;&lt;/span&gt;.equals(method.getName())) {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isDebugEnabled()) {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;          debug(&lt;span class=&quot;string&quot;&gt;&quot; Preparing: &quot;&lt;/span&gt; + removeBreakingWhitespace((String) params[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]), &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;        }&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;        PreparedStatement stmt = (PreparedStatement) method.invoke(connection, params);&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;        stmt = PreparedStatementLogger.newInstance(stmt, statementLog, queryStack);&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; stmt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;      } &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;string&quot;&gt;&quot;prepareCall&quot;&lt;/span&gt;.equals(method.getName())) {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isDebugEnabled()) {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;          debug(&lt;span class=&quot;string&quot;&gt;&quot; Preparing: &quot;&lt;/span&gt; + removeBreakingWhitespace((String) params[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]), &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;        }&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;        ... &lt;span class=&quot;comment&quot;&gt;//省略非关键部分&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;    } &lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Throwable t) {&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; ExceptionUtil.unwrapThrowable(t);&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;    }&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;  }&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;   * Creates a logging version of a connection.&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;   *&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;   * &lt;span class=&quot;doctag&quot;&gt;@param&lt;/span&gt; conn - the original connection&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;   * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt; - the connection with logging&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;   */&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; Connection &lt;span class=&quot;title&quot;&gt;newInstance&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Connection conn, Log statementLog, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; queryStack)&lt;/span&gt; &lt;/span&gt;{&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;    InvocationHandler handler = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ConnectionLogger(conn, statementLog, queryStack);&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;    ClassLoader cl = Connection.class.getClassLoader();&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (Connection) Proxy.newProxyInstance(cl, &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Class[]{Connection.class}, handler);&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;  }&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;   * return the wrapped connection.&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;   *&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;   * &lt;span class=&quot;doctag&quot;&gt;@return&lt;/span&gt; the connection&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;   */&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Connection &lt;span class=&quot;title&quot;&gt;getConnection&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; connection;&lt;/p&gt;&lt;p class=&quot;line&quot;&gt;  }&lt;/p&gt;&lt;p class=&quot;line&quot;/&gt;&lt;p class=&quot;line&quot;&gt;}&lt;/p&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>