<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>0d11142d3e77f432b1ce84914178d5e0</guid>
<title>一文详解｜Go 分布式链路追踪实现原理</title>
<link>https://toutiao.io/k/876321c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;133703687913652224&quot; data-gallerysupplier=&quot;5&quot; data-ratio=&quot;0.530791788856305&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Y5KD25uXiaJHqL8NE8W0AECgCH3kCKPmZEE1ouHUA5Mh5WS37DtDMnkdNbEwXq8XtE92aq8LvibHcFIXxhcI3TLQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1023&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在分布式、微服务架构下，应用一个请求往往贯穿多个分布式服务，这给应用的故障排查、性能优化带来新的挑战。分布式链路追踪作为解决分布式应用可观测问题的重要技术，愈发成为分布式应用不可缺少的基础设施。本文将详细介绍分布式链路的核心概念、架构原理和相关开源标准协议，并分享我们在实现无侵入 Go 采集 Sdk 方面的一些实践。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;为什么需要分布式链路追踪系统&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;20&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;20&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2084&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y5KD25uXiaJGK0s05cwXgAfmUOZsfBTygvBO1zo3hwG9mYbVGS0VQwoic8kx26MOA1JjPmBGeFa1lph63D9VOxwA/640?wx_fmt=png&quot;/&gt; &lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;微服务架构给运维、排障带来新挑战&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在分布式架构下，当用户从浏览器客户端发起一个请求时，后端处理逻辑往往贯穿多个分布式服务，这时会浮现很多问题，比如：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;请求整体耗时较长，具体慢在哪个服务？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;请求过程中出错了，具体是哪个服务报错？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;某个服务的请求量如何，接口成功率如何？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9345088161209067&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y5KD25uXiaJHqL8NE8W0AECgCH3kCKPmZqGjdfc9g0ahY2QkyhsFmPibEGEgFoPtNJiaD6up5Lx3mIbodMl7Uor6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;794&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;回答这些问题变得不是那么简单，我们不仅仅需要知道某一个服务的接口处理统计数据，还需要了解两个服务之间的接口调用依赖关系，只有建立起整个请求在多个服务间的时空顺序，才能更好的帮助我们理解和定位问题，而这，正是分布式链路追踪系统可以解决的。&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;20&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;20&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2084&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y5KD25uXiaJGK0s05cwXgAfmUOZsfBTygvBO1zo3hwG9mYbVGS0VQwoic8kx26MOA1JjPmBGeFa1lph63D9VOxwA/640?wx_fmt=png&quot;/&gt; &lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;分布式链路追踪系统如何帮助我们&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;分布式链路追踪技术的核心思想：在用户一次分布式请求服务的调⽤过程中，将请求在所有子系统间的调用过程和时空关系追踪记录下来，还原成调用链路集中展示，信息包括各个服务节点上的耗时、请求具体到达哪台机器上、每个服务节点的请求状态等等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36324324324324325&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y5KD25uXiaJHqL8NE8W0AECgCH3kCKPmZiat5dlg43UKM8ZnDblctRjfOGEsV5UjgxHalqvibcuZZ4FfTzra8Dt1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1850&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如上图所示，通过分布式链路追踪构建出完整的请求链路后，可以很直观地看到请求耗时主要耗费在哪个服务环节，帮助我们更快速聚焦问题。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;同时，还可以对采集的链路数据做进一步的分析，从而可以建立整个系统各服务间的依赖关系、以及流量情况，帮助我们更好地排查系统的循环依赖、热点服务等问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5807365439093485&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y5KD25uXiaJHqL8NE8W0AECgCH3kCKPmZPGdYbNL2A2mafrMrZia7micBRB0D57oTib0uHUfBBRWwwYaHbV9pcXj8Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2824&quot;/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;分布式链路追踪系统架构概览&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;20&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;20&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2084&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y5KD25uXiaJGK0s05cwXgAfmUOZsfBTygvBO1zo3hwG9mYbVGS0VQwoic8kx26MOA1JjPmBGeFa1lph63D9VOxwA/640?wx_fmt=png&quot;/&gt; &lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;核心概念&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在分布式链路追踪系统中，最核心的概念，便是链路追踪的数据模型定义，主要包括 &lt;strong&gt;Trace&lt;/strong&gt; 和 &lt;strong&gt;Span&lt;/strong&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7254697286012526&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y5KD25uXiaJHqL8NE8W0AECgCH3kCKPmZ36eDG5R4EmRKnEiafJjBNJAvUPDZfuXibvJBqTbM54w3fsSNVFwbI2icg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1916&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其中，Trace 是一个逻辑概念，表示一次（分布式）请求经过的所有局部操作（Span）构成的一条完整的有向无环图，其中所有的 Span 的 TraceId 相同。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;Span 则是真实的数据实体模型，表示一次(分布式)请求过程的一个步骤或操作，代表系统中一个逻辑运行单元，Span 之间通过嵌套或者顺序排列建立因果关系。Span 数据在采集端生成，之后上报到服务端，做进一步的处理。其包含如下关键属性：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Name：操作名称，如一个 RPC 方法的名称，一个函数名&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;StartTime/EndTime：起始时间和结束时间，操作的生命周期&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;ParentSpanId：父级 Span 的 ID&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Attributes：属性，一组 &amp;lt;K,V&amp;gt; 键值对构成的集合&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Event：操作期间发生的事件&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;SpanContext：Span 上下文内容，通常用于在 Span 间传播，其核心字段包括 TraceId、SpanId&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;20&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;20&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2084&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y5KD25uXiaJGK0s05cwXgAfmUOZsfBTygvBO1zo3hwG9mYbVGS0VQwoic8kx26MOA1JjPmBGeFa1lph63D9VOxwA/640?wx_fmt=png&quot;/&gt; &lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;一般架构&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;分布式链路追踪系统的核心任务是：围绕 Span 的生成、传播、采集、处理、存储、可视化、分析，构建分布式链路追踪系统。其一般的架构如下如所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3240343347639485&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y5KD25uXiaJHqL8NE8W0AECgCH3kCKPmZKpMiaicj1GmzYLSABFaExFytS8buAUic9PQXJW2CL7iaKhPiaINVlI4NgzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1864&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;我们看到，在应用端需要通过侵入或者非侵入的方式，注入 Tracing Sdk，以跟踪、生成、传播和上报请求调用链路数据；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Collect agent 一般是在靠近应用侧的一个边缘计算层，主要用于提高 Tracing Sdk 的写性能，和减少 back-end 的计算压力；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;采集的链路跟踪数据上报到后端时，首先经过 Gateway 做一个鉴权，之后进入 kafka 这样的 MQ 进行消息的缓冲存储；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在数据写入存储层之前，我们可能需要对消息队列中的数据做一些清洗和分析的操作，清洗是为了规范和适配不同的数据源上报的数据，分析通常是为了支持更高级的业务功能，比如流量统计、错误分析等，这部分通常采用flink这类的流处理框架来完成；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;存储层会是服务端设计选型的一个重点，要考虑数据量级和查询场景的特点来设计选型，通常的选择包括使用 Elasticsearch、Cassandra、或 Clickhouse 这类开源产品；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;流处理分析后的结果，一方面作为存储持久化下来，另一方面也会进入告警系统，以主动发现问题来通知用户，如错误率超过指定阈值发出告警通知这样的需求等。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;刚才讲的，是一个通用的架构，我们并没有涉及每个模块的细节，尤其是服务端，每个模块细讲起来都要很花些功夫，受篇幅所限，我们把注意力集中到靠近应用侧的 Tracing Sdk，重点看看在应用侧具体是如何实现链路数据的跟踪和采集的。&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;20&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;20&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2084&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y5KD25uXiaJGK0s05cwXgAfmUOZsfBTygvBO1zo3hwG9mYbVGS0VQwoic8kx26MOA1JjPmBGeFa1lph63D9VOxwA/640?wx_fmt=png&quot;/&gt; &lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;协议标准和开源实现&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;刚才我们提到 Tracing Sdk，其实这只是一个概念，具体到实现，选择可能会非常多，这其中的原因，主要是因为：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;不同的编程语言的应用，可能采用不同技术原理来实现对调用链的跟踪&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;不同的链路追踪后端，可能采用不同的数据传输协议&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;当前，流行的链路追踪后端，比如 Zipin、Jaeger、PinPoint、Skywalking、Erda，都有供应用集成的 sdk，导致我们在切换后端时应用侧可能也需要做较大的调整。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;社区也出现过不同的协议，试图解决采集侧的这种乱象，比如 OpenTracing、OpenCensus 协议，这两个协议也分别有一些大厂跟进支持，但最近几年，这两者已经走向了融合统一，产生了一个新的标准 OpenTelemetry，这两年发展迅猛，已经逐渐成为行业标准。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5300207039337475&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y5KD25uXiaJHqL8NE8W0AECgCH3kCKPmZsN5956dRwfpF6sCQetdhicFeZVFGgEn0hNVfFaU47O1wicg8ZibeNuiadg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1932&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;OpenTelemetry 定义了数据采集的标准 api，并提供了一组针对多语言的开箱即用的 sdk 实现工具，这样，应用只需要与 OpenTelemetry 核心 api 包强耦合，不需要与特定的实现强耦合。&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;应用侧调用链跟踪实现方案概览&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;20&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;20&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2084&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y5KD25uXiaJGK0s05cwXgAfmUOZsfBTygvBO1zo3hwG9mYbVGS0VQwoic8kx26MOA1JjPmBGeFa1lph63D9VOxwA/640?wx_fmt=png&quot;/&gt; &lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;应用侧核心任务&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;应用侧围绕 Span，有三个核心任务要完成：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;生成 Span：操作开始构建 Span 并填充 StartTime，操作完成时填充 EndTime 信息，期间可追加 Attributes、Event 等&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;传播 Span：进程内通过 context.Context、进程间通过请求的 header 作为 SpanContext 的载体，传播的核心信息是 TraceId 和 ParentSpanId&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;上报 Span：生成的 Span 通过 tracing exporter 发送给 collect agent / back-end server&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;要实现 Span 的生成和传播，要求我们能够拦截应用的关键操作（函数）过程，并添加 Span 相关的逻辑。实现这个目的会有很多方法，不过，在罗列这些方法之前，我们先看看在 OpenTelemetry 提供的 go sdk 中是如何做的。&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;20&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;20&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2084&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y5KD25uXiaJGK0s05cwXgAfmUOZsfBTygvBO1zo3hwG9mYbVGS0VQwoic8kx26MOA1JjPmBGeFa1lph63D9VOxwA/640?wx_fmt=png&quot;/&gt; &lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;基于 OTEL 库实现调用拦截&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;OpenTelemetry 的 go sdk 实现调用链拦截的基本思路是：基于 AOP 的思想，采用装饰器模式，通过包装替换目标包（如 net/http）的核心接口或组件，实现在核心调用过程前后添加 Span 相关逻辑。当然，这样的做法是有一定的侵入性的，需要手动替换使用原接口实现的代码调用改为包装接口实现。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们以一个 http server 的例子来说明，在 go 语言中，具体是如何做的：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;假设有两个服务 serverA 和 serverB，其中 serverA 的接口收到请求后，内部会通过 httpclient 进一步发起到 serverB 的请求，那么 serverA 的核心代码可能如下图所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.29196337741607326&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y5KD25uXiaJHqL8NE8W0AECgCH3kCKPmZTCy1EUxskGwelMxhiaWkC6a4jGowoZLlic0giblD6Rk29D1VicNWAVn1aQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1966&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;以 serverA 节点为例，在 serverA 节点应该产生至少两个 Span：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Span1，记录 httpServer 收到一个请求后内部整体处理过程的一个耗时情况&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Span2，记录 httpServer 处理请求过程中，发起的另一个到 serverB 的 http 请求的耗时情况&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;并且 Span1 应该是 Span2 的 ParentSpan&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们可以借助 OpenTelemetry 提供的 sdk 来实现 Span 的生成、传播和上报，上报的逻辑受篇幅所限我们不再详述，重点来看看如何生成这两个 Span，并使这两个 Span 之间建立关联，即 Span 的生成和传播 。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;HttpServer Handler 生成 Span 过程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h4/&gt;&lt;section&gt;&lt;span&gt;对于 httpserver 来讲，我们知道其核心就是 http.Handler 这个接口。因此，可以通过实现一个针对 http.Handler 接口的拦截器，来负责 Span 的生成和传播。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package http&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type Handler interface {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ServeHTTP(ResponseWriter, *Request)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;http.ListenAndServe(&quot;:8090&quot;, http.DefaultServeMux)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;要使用 OpenTelemetry Sdk 提供的 http.Handler 装饰器，需要如下调整 http.ListenAndServe 方法：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;net/http&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;go.opentelemetry.io/otel&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;go.opentelemetry.io/otel/sdk/trace&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;wrappedHttpHandler := otelhttp.NewHandler(http.DefaultServeMux, ...)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;http.ListenAndServe(&quot;:8090&quot;, wrappedHttpHandler)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4645030425963489&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y5KD25uXiaJHqL8NE8W0AECgCH3kCKPmZ5VRGKhoTyTX7lpEjmTXNo6efpXH4IKyTSXstOOBckfYcRC1n4ibjYvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1972&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;如图所示，wrppedHttpHandler 中将主要实现如下逻辑（精简考虑，此处部分为伪代码）：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;① &lt;/strong&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;ctx := tracer.Extract(r.ctx, r.Header)&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：从请求的 header 中提取 traceparent header 并解析，提取 TraceId和 SpanId，进而构建 SpanContext 对象，并最终存储在 ctx 中；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;②&lt;/strong&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;ctx, span := tracer.Start(ctx, genOperation(r))&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：生成跟踪当前请求处理过程的 Span（即前文所述的Span1），并记录开始时间，这时会从 ctx 中读取 SpanContext，将 SpanContext.TraceId 作为当前 Span 的TraceId，将 SpanContext.SpanId 作为当前 Span的ParentSpanId，然后将自己作为新的 SpanContext 写入返回的 ctx 中；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;③&lt;/strong&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;r.WithContext(ctx)&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：将新生成的 SpanContext 添加到请求 r 的 context 中，以便被拦截的 handler 内部在处理过程中，可以从 r.ctx 中拿到 Span1 的 SpanId 作为其 ParentSpanId 属性，从而建立 Span 之间的父子关系；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;④&lt;/strong&gt; &lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;span.End()&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：当 innerHttpHandler.ServeHTTP(w,r) 执行完成后，就需要对 Span1 记录一下处理完成的时间，然后将它发送给 exporter 上报到服务端。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h4&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;HttpClient 请求生成 Span 过程&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/h4&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;h4/&gt;&lt;section&gt;&lt;span&gt;我们再接着看 serverA 内部去请求 serverB 时的 httpclient 请求是如何生成 Span 的（即前文说的 Span2）。我们知道，httpclient 发送请求的关键操作是 http.RoundTriper 接口：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;typescript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;package http&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type RoundTripper interface {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  RoundTrip(*Request) (*Response, error)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;OpenTelemetry 提供了基于这个接口的一个拦截器实现，我们需要使用这个实现包装一下 httpclient 原来使用的  RoundTripper 实现，代码调整如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import (&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;net/http&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;go.opentelemetry.io/otel&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;go.opentelemetry.io/otel/sdk/trace&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &quot;go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;wrappedTransport := otelhttp.NewTransport(http.DefaultTransport)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;client := http.Client{Transport: wrappedTransport}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48073022312373226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y5KD25uXiaJHqL8NE8W0AECgCH3kCKPmZvfL1ZpicXdZEd1CGGYc7ugiaUNGkYypVzjzjeibcoxZfTbqiaSnHXBAExA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1972&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如图所示，wrappedTransport 将主要完成以下任务（精简考虑，此处部分为伪代码）：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;① &lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;req, _ := http.NewRequestWithContext(r.ctx, “GET”,url, nil)&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;：这里我们将上一步 http.Handler 的请求的 ctx，传递到 httpclient 要发出的 request 中，这样在之后我们就可以从 request.Context() 中提取出 Span1 的信息，来建立 Span 之间的关联；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;② &lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;ctx, span := tracer.Start(r.Context(), url)&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：执行 client.Do() 之后，将首先进入 WrappedTransport.RoundTrip() 方法，这里生成新的 Span（Span2），开始记录 httpclient 请求的耗时情况，与前文一样，Start 方法内部会从 r.Context() 中提取出 Span1 的 SpanContext，并将其 SpanId 作为当前 Span（Span2）的 ParentSpanId，从而建立了 Span 之间的嵌套关系，同时返回的 ctx 中保存的 SpanContext 将是新生成的 Span（Span2）的信息；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;③ &lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;tracer.Inject(ctx, r.Header)&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：这一步的目的是将当前 SpanContext 中的 TraceId 和 SpanId 等信息写入到 r.Header 中，以便能够随着 http 请求发送到 serverB，之后在 serverB 中与当前 Span 建立关联；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;④ &lt;/span&gt;&lt;code&gt;&lt;span&gt;&lt;strong&gt;span.End()&lt;/strong&gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：等待 httpclient 请求发送到 serverB 并收到响应以后，标记当前 Span 跟踪结束，设置 EndTime 并提交给 exporter 以上报到服务端。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;基于 OTEL 库实现调用链跟踪总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;我们比较详细的介绍了使用 OpenTelemetry 库，是如何实现链路的关键信息（TraceId、SpanId）是如何在进程间和进程内传播的，我们对这种跟踪实现方式做个小的总结：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36086956521739133&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y5KD25uXiaJHqL8NE8W0AECgCH3kCKPmZhIb0updQI5KqicInqU4FXxRN9g0icRXZCvIjHfoX4NApLrb3Hh0Wtl5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1840&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如上分析所展示的，使用这种方式的话，对代码还是有一定的侵入性，并且对代码有另一个要求，就是保持 context.Context 对象在各操作间的传递，比如，刚才我们在 serverA 中创建 httpclient 请求时，使用的是&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;http.NewRequestWithContext(r.ctx, ...)&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 而非&lt;/span&gt;&lt;code&gt;&lt;span&gt;http.NewRequest(...)&lt;/span&gt;&lt;/code&gt;&lt;span&gt;方法，另外开启 goroutine 的异步场景也需要注意 ctx 的传递。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3617486338797814&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y5KD25uXiaJHqL8NE8W0AECgCH3kCKPmZ13L6FDuOw8aicXc3bVOibhMf1ooGUNOJ51281icen2uMXKRSNlGLwmxTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1830&quot;/&gt;&lt;/section&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;20&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;20&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;2084&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y5KD25uXiaJGK0s05cwXgAfmUOZsfBTygvBO1zo3hwG9mYbVGS0VQwoic8kx26MOA1JjPmBGeFa1lph63D9VOxwA/640?wx_fmt=png&quot;/&gt; &lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;非侵入调用链跟踪实现思路&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们刚才详细展示了基于常规的一种具有一定侵入性的实现，其侵入性主要表现在：我们需要显式的手动添加代码使用具有跟踪功能的组件包装原代码，这进一步会导致应用代码需要显式的引用具体版本的 OpenTelemetry instrumentation 包，这不利于可观测代码的独立维护和升级。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;那我们有没有可以实现非侵入跟踪调用链的方案可选？&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;所谓无侵入，其实也只是集成的方式不同，集成的目标其实是差不多的，最终都是要通过某种方式，实现对关键调用函数的拦截，并加入特殊逻辑，无侵入重点在于代码无需修改或极少修改。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35274725274725277&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y5KD25uXiaJHqL8NE8W0AECgCH3kCKPmZorGFejwXzfEUIOBib9ancErAL97036N9ux1r5Dom8q9ggfuF66YUnicw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1820&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上图列出了现在可能的一些无侵入集成的实现思路，与 .net、java 这类有 IL 语言的编程语言不同，go 直接编译为机器码，导致无侵入的方案实现起来相对比较麻烦，具体有如下几种思路：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;编译阶段注入：可以扩展编译器，修改编译过程中的ast，插入跟踪代码，需要适配不同编译器版本。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;启动阶段注入：修改编译后的机器码，插入跟踪代码，需要适配不同 CPU 架构。如 monkey, gohook。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;运行阶段注入：通过内核提供的 eBPF 能力，监听程序关键函数执行，插入跟踪代码，前景光明！如，tcpdump，bpftrace。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;Go 非侵入链路追踪实现原理&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Erda 项目的核心代码主要是基于 golang 编写的，我们基于前文所述的 OpenTelemetry sdk，采用基于修改机器码的的方式，实现了一种无侵入的链路追踪方式。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;前文提到，使用 OpenTelemetry sdk 需要代码做一些调整，我们看看这些调整如何以非侵入的方式自动的完成：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3545554335894621&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Y5KD25uXiaJHqL8NE8W0AECgCH3kCKPmZK5nZibfoicuHVol26atTs32zElfYCjLw3vQj5RdpPkejoa1djNRMjDAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1822&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们以 httpclient 为例，做简要的解释。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;gohook 框架提供的 hook 接口的签名如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// target 要hook的目标函数&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// replacement 要替换为的函数&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// trampoline 将源函数入口拷贝到的位置，可用于从replcement跳转回原target&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func Hook(target, replacement, trampoline interface{}) error&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于 &lt;/span&gt;&lt;code&gt;&lt;span&gt;http.Client&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，我们可以选择 &lt;/span&gt;&lt;code&gt;&lt;span&gt;hook DefaultTransport.RoundTrip()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法，当该方法执行时，我们通过 &lt;/span&gt;&lt;code&gt;&lt;span&gt;otelhttp.NewTransport()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 包装起原 &lt;/span&gt;&lt;code&gt;&lt;span&gt;DefaultTransport&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 对象，但需要注意的是，我们不能将 &lt;/span&gt;&lt;code&gt;&lt;span&gt;DefaultTransport&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 直接作为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;otelhttp.NewTransport()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的参数，因为其 &lt;/span&gt;&lt;code&gt;&lt;span&gt;RoundTrip()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法已经被我们替换了，而其原来真正的方法被写到了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;trampoline&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中，所以这里我们需要一个中间层，来连接 &lt;/span&gt;&lt;code&gt;&lt;span&gt;DefaultTransport&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 与其原来的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;RoundTrip&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 方法。具体代码如下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;//go:linkname RoundTrip net/http.(*Transport).RoundTrip&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;//go:noinline&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;// RoundTrip .&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func RoundTrip(t *http.Transport, req *http.Request) (*http.Response, error)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;//go:noinline&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func originalRoundTrip(t *http.Transport, req *http.Request) (*http.Response, error) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  return RoundTrip(t, req)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;type wrappedTransport struct {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  t *http.Transport&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;//go:noinline&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func (t *wrappedTransport) RoundTrip(req *http.Request) (*http.Response, error) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  return originalRoundTrip(t.t, req)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;//go:noinline&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func tracedRoundTrip(t *http.Transport, req *http.Request) (*http.Response, error) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  req = contextWithSpan(req)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  return otelhttp.NewTransport(&amp;amp;wrappedTransport{t: t}).RoundTrip(req)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;//go:noinline&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func contextWithSpan(req *http.Request) *http.Request {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  ctx := req.Context()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  if span := trace.SpanFromContext(ctx); !span.SpanContext().IsValid() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    pctx := injectcontext.GetContext()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if pctx != nil {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      if span := trace.SpanFromContext(pctx); span.SpanContext().IsValid() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        ctx = trace.ContextWithSpan(ctx, span)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        req = req.WithContext(ctx)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  return req&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;func init() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  gohook.Hook(RoundTrip, tracedRoundTrip, originalRoundTrip)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;init()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数实现了自动添加 hook，因此用户程序里只需要在 main 文件中 import 该包，即可实现无侵入的集成。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;值得一提的是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;req = contextWithSpan(req)&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数，内部会依次尝试从 &lt;/span&gt;&lt;code&gt;&lt;span&gt;req.Context()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 我们保存的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;goroutineContext map&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 中检查是否包含 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SpanContext&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，并将其赋值给 &lt;/span&gt;&lt;code&gt;&lt;span&gt;req&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，这样便可以解除了必须使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;http.NewRequestWithContext(...)&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 写法的要求。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;详细的代码可以查看 Erda 仓库：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;em&gt;&lt;span&gt;https://github.com/erda-project/erda-infra/tree/master/pkg/trace&lt;/span&gt;&lt;/em&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;span mpa-is-content=&quot;t&quot;&gt;参考链接&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;&lt;span&gt;https://opentelemetry.io/registry/&lt;/span&gt;&lt;/em&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;&lt;span&gt;https://opentelemetry.io/docs/instrumentation/go/getting-started/&lt;/span&gt;&lt;/em&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;&lt;span&gt;https://www.ipeapea.cn/post/go-asm/&lt;/span&gt;&lt;/em&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;&lt;span&gt;https://github.com/brahma-adshonor/gohook&lt;/span&gt;&lt;/em&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;&lt;span&gt;https://www.jianshu.com/p/7b3638b47845&lt;/span&gt;&lt;/em&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;em&gt;&lt;span&gt;https://paper.seebug.org/1749/&lt;/span&gt;&lt;/em&gt;&lt;span/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/jZXlUHNuBN5a6JWIdk82cPD8FSSoqjutJcFTXQH1jWPa2pUnwgsOkb95nNBTkMiamwxeAHKFba0FdqKDthpdlibQ/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;&lt;span&gt;戳原文，了解更多！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>eb4674f34c4c666bba0841bcb10203d1</guid>
<title>求你了，不要再在对外接口中使用枚举类型了！</title>
<link>https://toutiao.io/k/p4nf4fl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                           autoTypeSetting24psection&amp;#10;                          &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;最近，我们的线上环境出现了一个问题，线上代码在执行过程中抛出了一个IllegalArgumentException，分析堆栈后，发现最根本的的异常是以下内容：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;java&lt;/span&gt;&lt;span&gt;.lang.IllegalArgumentException&lt;/span&gt;: &lt;br/&gt;&lt;br/&gt;&lt;span&gt;No&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; &lt;span&gt;constant&lt;/span&gt; &lt;span&gt;com&lt;/span&gt;&lt;span&gt;.a.b.f.m.a.c.AType.P_M&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;大概就是以上的内容，看起来还是很简单的，提示的错误信息就是在AType这个枚举类中没有找到P_M这个枚举项。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;于是经过排查，我们发现，在线上开始有这个异常之前，该应用依赖的一个下游系统有发布，而发布过程中是一个API包发生了变化，主要变化内容是在一个RPC接口的Response返回值类中的一个枚举参数AType中增加了P_M这个枚举项。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是下游系统发布时，并未通知到我们负责的这个系统进行升级，所以就报错了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们来分析下为什么会发生这样的情况。&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;t9&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;section data-mid=&quot;&quot; data-contenteditable=&quot;false&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-is-content=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;问题重现&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先，下游系统A提供了一个二方库的某一个接口的返回值中有一个参数类型是枚举类型。&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;一方库指的是本项目中的依赖&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;二方库指的是公司内部其他项目提供的依赖&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;三方库指的是其他组织、公司等来自第三方的依赖&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; &lt;span&gt;AFacadeService&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; AResponse &lt;span&gt;doSth&lt;/span&gt;(&lt;span&gt;ARequest aRequest&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; Class AResponse{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Boolean success;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; AType aType;&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; AType{&lt;br/&gt;&lt;br/&gt;    P_T,&lt;br/&gt;&lt;br/&gt;    A_B&lt;br/&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;然后B系统依赖了这个二方库，并且会通过RPC远程调用的方式调用AFacadeService的doSth方法。&lt;/span&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    AFacadeService aFacadeService;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;doSth&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;        ARequest aRequest = &lt;span&gt;new&lt;/span&gt; ARequest();&lt;br/&gt;&lt;br/&gt;        AResponse aResponse = aFacadeService.doSth(aRequest);&lt;br/&gt;&lt;br/&gt;        AType aType = aResponse.getAType();&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;这时候，如果A和B系统依赖的都是同一个二方库的话，两者使用到的枚举AType会是同一个类，里面的枚举项也都是一致的，这种情况不会有什么问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是，如果有一天，这个二方库做了升级，在AType这个枚举类中增加了一个新的枚举项P_M，这时候只有系统A做了升级，但是系统B并没有做升级。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;那么A系统依赖的的AType就是这样的：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; AType{&lt;br/&gt;&lt;br/&gt;    P_T,&lt;br/&gt;&lt;br/&gt;    A_B,&lt;br/&gt;&lt;br/&gt;    P_M&lt;br/&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;而B系统依赖的AType则是这样的：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; AType{&lt;br/&gt;&lt;br/&gt;    P_T,&lt;br/&gt;&lt;br/&gt;    A_B&lt;br/&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;这种情况下&lt;strong&gt;，在B系统通过RPC调用A系统的时候，如果A系统返回的AResponse中的aType的类型为新增的P_M时候，B系统就会无法解析。一般在这种时候，RPC框架就会发生反序列化异常。导致程序被中断。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;t9&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;section data-mid=&quot;&quot; data-contenteditable=&quot;false&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-is-content=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;原理分析&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个问题的现象我们分析清楚了，那么再来看下原理是怎样的，为什么出现这样的异常呢。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其实这个原理也不难，这类&lt;strong&gt;RPC框架大多数会采用JSON的格式进行数据传输&lt;/strong&gt;，也就是客户端会将返回值序列化成JSON字符串，而服务端会再将JSON字符串反序列化成一个Java对象。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而JSON在反序列化的过程中，对于一个枚举类型，会尝试调用对应的枚举类的valueOf方法来获取到对应的枚举。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而我们查看枚举类的valueOf方法的实现时，就可以发现，&lt;strong&gt;如果从枚举类中找不到对应的枚举项的时候，就会抛出IllegalArgumentException&lt;/strong&gt;：&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T extends Enum&amp;lt;T&amp;gt;&amp;gt; &lt;span&gt;T &lt;span&gt;valueOf&lt;/span&gt;(&lt;span&gt;Class&amp;lt;T&amp;gt; enumType, String name&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    T result = enumType.enumConstantDirectory().&lt;span&gt;get&lt;/span&gt;(name);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (result != &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (name == &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; NullPointerException(&lt;span&gt;&quot;Name is null&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalArgumentException(&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&quot;No enum constant &quot;&lt;/span&gt; + enumType.getCanonicalName() + &lt;span&gt;&quot;.&quot;&lt;/span&gt; + name);&lt;br/&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;关于这个问题，其实在《阿里巴巴Java开发手册》中也有类似的约定：&lt;/span&gt;&lt;/section&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.094921875&quot; data-type=&quot;jpeg&quot; data-w=&quot;2560&quot; title=&quot;-w1538&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6fuT3emWI5KGz4UOJfG17P6I2nSObcjQUoM6XjElqtpLXN4Ia0bjuSjmgsC3JOP7hvFk8U0r26tFia3mFZmia7Xg/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;section&gt;￼&lt;/section&gt;&lt;section&gt;&lt;span&gt;这&lt;/span&gt;&lt;span&gt;里面规定&quot;&lt;/span&gt;&lt;strong&gt;对于二方库的参数可以使用枚举，但是返回值不允许使用枚举&lt;/strong&gt;&lt;span&gt;&quot;。&lt;/span&gt;&lt;span&gt;这背后的思考就是本文上面提到的内容。&lt;/span&gt;&lt;/section&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;t9&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;section data-mid=&quot;&quot; data-contenteditable=&quot;false&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-is-content=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;strong&gt;&lt;span&gt;扩展思考&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;为什么参数中可以有枚举？&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;不知道大家有没有想过这个问题，其实这个就和二方库的职责有点关系了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一般情况下，A系统想要提供一个远程接口给别人调用的时候，就会定义一个二方库，告诉其调用方如何构造参数，调用哪个接口。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而这个二方库的调用方会根据其中定义的内容来进行调用。而参数的构造过程是由B系统完成的，如果B系统使用到的是一个旧的二方库，使用到的枚举自然是已有的一些，新增的就不会被用到，所以这样也不会出现问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如前面的例子，B系统在调用A系统的时候，构造参数的时候使用到AType的时候就只有P_T和A_B两个选项，虽然A系统已经支持P_M了，但是B系统并没有使用到。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果B系统想要使用P_M，那么就需要对该二方库进行升级。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是，返回值就不一样了，返回值并不受客户端控制，服务端返回什么内容是根据他自己依赖的二方库决定的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但是，其实相比较于手册中的规定，&lt;strong&gt;我更加倾向于，在RPC的接口中入参和出参都不要使用枚举。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一般，我们要使用枚举都是有几个考虑：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;1、枚举严格控制下游系统的传入内容，避免非法字符。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2、方便下游系统知道都可以传哪些值，不容易出错。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;不可否认，使用枚举确实有一些好处，但是我不建议使用主要有以下原因：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;1、如果二方库升级，并且删除了一个枚举中的部分枚举项，那么入参中使用枚举也会出现问题，调用方将无法识别该枚举项。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;2、有的时候，上下游系统有多个，如C系统通过B系统间接调用A系统，A系统的参数是由C系统传过来的，B系统只是做了一个参数的转换与组装。这种情况下，一旦A系统的二方库升级，那么B和C都要同时升级，任何一个不升级都将无法兼容。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;我其实建议大家在接口中使用字符串代替枚举&lt;/strong&gt;，相比较于枚举这种强类型，字符串算是一种弱类型。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果使用字符串代替RPC接口中的枚举，那么就可以避免上面我们提到的两个问题，上游系统只需要传递字符串就行了，而具体的值的合法性，只需要在A系统内自己进行校验就可以了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;为了方便调用者使用，可以使用javadoc的@see注解表明这个字符串字段的取值从那个枚举中获取。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;Class&lt;/span&gt; &lt;span&gt;AResponse&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Boolean success;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;&lt;br/&gt;    *  &lt;span&gt;@see&lt;/span&gt; AType &lt;br/&gt;&lt;br/&gt;    */&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String aType;&lt;br/&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;section&gt;&lt;span&gt;对于像阿里这种比较庞大的互联网公司，&lt;strong&gt;随便提供出去的一个接口，可能有上百个调用方&lt;/strong&gt;，而接口升级也是常态，&lt;strong&gt;我们根本做不到每次二方库升级之后要求所有调用者跟着一起升级&lt;/strong&gt;，这是完全不现实的，并且对于有些调用者来说，他用不到新特性，完全没必要做升级。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;还有一种看起来比较特殊，但是实际上比较常见的情况，就是有的时候一个接口的声明在A包中，而一些枚举常量定义在B包中，比较常见的就是阿里的交易相关的信息，订单分很多层次，每次引入一个包的同时都需要引入几十个包。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于调用者来说，我肯定是不希望我的系统引入太多的依赖的，&lt;strong&gt;一方面依赖多了会导致应用的编译过程很慢，并且很容易出现依赖冲突问题。&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，在调用下游接口的时候，如果参数中字段的类型是枚举的话，那我没办法，必须得依赖他的二方库。但是如果不是枚举，只是一个字符串，那我就可以选择不依赖。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，我们在定义接口的时候，会尽量避免使用枚举这种强类型。规范中规定在返回值中不允许使用，而我自己要求更高，就是即使在接口的入参中我也很少使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;最后，我只是不建议在对外提供的接口的出入参中使用枚举，并不是说彻底不要用枚举，我之前很多文章也提到过，枚举有很多好处，我在代码中也经常使用。所以，切不可因噎废食。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当然，文中的观点仅代表我个人，具体是是不是适用其他人，其他场景或者其他公司的实践，需要读者们自行分辨下，建议大家在使用的时候可以多思考一下。&lt;/span&gt;&lt;/section&gt;&lt;pre data-darkmode-bgcolor-15923650965579=&quot;rgb(36, 36, 36)&quot; data-darkmode-original-bgcolor-15923650965579=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-15923650965579=&quot;rgb(167, 167, 167)&quot; data-darkmode-original-color-15923650965579=&quot;rgb(63, 63, 63)&quot; data-style=&quot;letter-spacing: 0.544px; font-size: 16px; color: rgb(63, 63, 63); word-spacing: 1px; line-height: inherit;&quot; class=&quot;js_darkmode__91&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;pre&gt;&lt;pre ng-bind-html=&quot;message.MMActualContent&quot;&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-paragraph-type=&quot;ignored&quot;&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651515391&amp;amp;idx=1&amp;amp;sn=4346820d62bff69cba7c68ed130ef861&amp;amp;chksm=bd2585808a520c9602f8566c5195488311c5075074646ac56a10953ed195119d03776d306ed2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;瞧瞧人家用SpringBoot写的后端API接口，那叫一个优雅！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;瞧瞧人家用SpringBoot写的后端API接口，那叫一个优雅！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651515399&amp;amp;idx=1&amp;amp;sn=e106c40b3248ada688dc7787ec3dfdd8&amp;amp;chksm=bd2586788a520f6eeabda8d44aa8a59075a194faa292450c8612121377314da1c72a94382368&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Redis+Guava，性能炸裂！&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Redis+Guava，性能炸裂！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzMyMjAwMA==&amp;amp;mid=2651515387&amp;amp;idx=1&amp;amp;sn=3d5ca26f8dd23e40247e4c82b5e24618&amp;amp;chksm=bd2585848a520c929d31f1d981000821c86b751cb6a1c4fc87638d444775b939c331ec67fe45&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;我是一个Dubbo数据包...&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot; hasload=&quot;1&quot;&gt;&lt;span&gt;我是一个Dubbo数据包...&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关注「ImportNew」，提升Java技能&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2A8tXicCG8ylbWIGfdoDED35IRRySQZTXUkJ1eop9MHApzFibKnOo0diboXpl0rmS5mH78YJhsWQv0dhv718A6kUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;点赞和在看就是最大的支持&lt;/span&gt;&lt;span&gt;❤️&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/pre&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>45a14ad3155a0aee864487bfd3bd0bf3</guid>
<title>商品系统架构设计与实践</title>
<link>https://toutiao.io/k/2r512r9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-darkmode-bgcolor-16452380856848=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16452380856848=&quot;#fff|rgb(255, 255, 255)&quot; data-style=&quot;margin: 25px 8px; outline: 0px; max-width: 100%; font-family: -apple-system, system-ui, &amp;quot;Helvetica Neue&amp;quot;, &amp;quot;PingFang SC&amp;quot;, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei UI&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; letter-spacing: 0.544px; white-space: normal; background-color: rgb(255, 255, 255); line-height: 2em; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__3&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span/&gt;&lt;span&gt;作者：vivo官网商城开发团队-Ju Changjiang&lt;/span&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;一、前言&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;随着用户量级的快速增长，vivo官方商城v1.0的单体架构逐渐暴露出弊端：模块愈发臃肿、开发效率低下、性能出现瓶颈、系统维护困难。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从2017年开始启动的v2.0架构升级，基于业务模块进行垂直的系统物理拆分，拆分出来业务线各司其职，提供服务化的能力，共同支撑主站业务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;商品模块是整个链路的核心，模块的增多严重影响系统的性能，服务化改造势在必行。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;本文将介绍vivo商城商品系统建设的过程中遇到的问题和解决方案，分享架构设计经验。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;二、商品系统演进&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;将商品模块从商城拆分出来，独立为商品系统，逐渐向底层发展，为商城，搜索，会员、营销等提供基础标准化服务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;商品系统架构图如下：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100008622&quot; data-ratio=&quot;0.5743415463041631&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5s8QhSSToFo341J7fnlMr1sm0Zqz6sulsxdsTtV6YVztXUA4EnoRbjAXYsMrS3eyYMgcAkSRMgcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1177&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;前期商品系统比较杂乱，包含业务模块比较多，如商品活动业务、秒杀业务，库存管理，随着业务的不断发展，商品系统承载更多的业务不利于系统扩展和维护。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;故思考逐渐将商品业务逐渐下沉并作为最底层、最基础的业务系统，并为众多调用方提供高性能的服务，下面介绍商品系统的升级历史。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.1 商品活动、赠品剥离&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;随着商品活动的不断增多，玩法多样，同时与活动相关的额外属性也相应增加，这些都并不是与商品信息强关联，更偏向于用户营销，不应该与核心商品业务耦合在一起，故将其合并入商城促销系统。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;赠品不仅仅是手机、配件，有可能会是积分、会员等，这些放在商品系统都不合适，也不属于商品模块的内容，故同步将其合并入商城促销系统。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.2 秒杀独立&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;众所周知，秒杀活动的特点是：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;限时：时间范围很短，超过设置的时间就结束了&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;限量：商品数量很少，远低于实际库存&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;访问量大：价格低，可以吸引非常多的用户&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;基于以上特性，做好一个秒杀活动不是一蹴而就，由于系统资源共享，当突发的大流量冲击会造成商品系统其他业务拒绝服务，会对核心的交易链路造成阻塞的风险，故将其独立为单独的秒杀系统，单独对外提供服务。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.3 代销系统成立&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;我们商城的主要销售品类还是手机以及手机配件等，商品的品类比较少，为了解决非手机商品品类不丰富的问题，运营考虑与知名电商进行合作，期望引入更多的商品品类。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了方便后续扩展，以及对原有系统的不侵入性，我们经过考虑专门独立出一个子系统，用于承接代销业务，最后期望做成一个完备平台，后续通过提供开放API的方式让其他电商主动接入我们业务。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2.4 库存剥离&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;库存管理的痛点：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;由于我们的库存都是到商品维度，仅仅一个字段标识数量，每次编辑商品都需要为商品调整库存，无法动态实现库存管理；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;同时营销系统也有自己活动库存管理机制，入口分散，关联性较弱；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可售库存和活动库存管理的依据都是实际库存，造成容易配置错误。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;基于以上痛点，同时为了更方便运营管理库存，也为未来使用实际库存进行销售打下基础，我们成立库存中心，并提供以下主要功能：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;三、挑战&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;作为最底层的系统，最主要的挑战就是具备稳定性，高性能，数据一致性的能力。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.1 稳定性&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;避免单机瓶颈：根据压测选择合适的节点数量，不浪费，同时也能保证沟通，可以应对突发流量。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;业务限流降级：对核心接口进行限流，优先保证系统可用，当流量对系统压力过大时将非核心业务进行降级，优先保证核心业务。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;设置合理的超时时间：对Redis、数据库的访问设置合理超时时间，不宜过长，避免流量较大时导致应用线程被占满。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;监控&amp;amp;告警：日志规范化，同时接入公司的日志监控和告警平台，做到主动发现问题并及时。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;熔断：外部接口接入熔断，防止因为外部接口异常导致本系统受到影响。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.2 高性能&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;多级缓存&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;为了提升查询速度，降低数据库的压力，我们采用多级缓存的方式，接口接入热点缓存组件，动态探测热点数据，如果是热点则直接从本地获取，如果不是热点则直接从redis获取。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;读写分离&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;数据库采用读写分离架构，主库进行更新操作，从库负责查询操作。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;接口限流&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;接入限流组件， 直接操作数据库的接口会进行限流，防止因为突发流量、或者不规范调用导致数据库压力增加，影响其他接口。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;不过早期也踩过一些坑：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;1、商品列表查询造成redis key过多，导致redis内存不够的风险&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由于是列表查询，进行缓存的时候是对入参进行hash，获取唯一的key，由于入参商品较多，某些场景下入参是随时变化的，根据排列组合，会造成基本每次请求都会回源，再缓存，可能造成数据库拒绝服务或者redis内存溢出。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;方案一&lt;/strong&gt;：循环入参列表，每次从redis获取数据，然后返回；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100008623&quot; data-ratio=&quot;0.9733924611973392&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5s8QhSSToFo341J7fnlMr1vjMQJm0By6xF1HbfOblCmSsiaOFwgh2p7uvNdmkKskefLABHCiaOJ0bQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;451&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这个方案解决了key过多导致内存溢出的问题，但是很明显，它增加了很多的网络交互，如果有几十个key，可想而知，对性能会有不小的影响，那有什么其他办法能减少网络交互呢，下面我们看方案二。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;方案二&lt;/strong&gt;：我们通过对原有的Redis 组件进行增强，由于Redis集群模式不支持mget，故我们采用pipeline的方式实现，先根据key计算出其所在的slot，然后聚合一次性提交，这样每个商品数据只需缓存一次即可，同时采用mget也大大提升了查询速度。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100008624&quot; data-ratio=&quot;0.700164744645799&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4g5IMGibSxt5s8QhSSToFo341J7fnlMr1PPIW3ZbfDvhNISySGarjSVpoJZDkp2ib5q1bNicYf2N752yv9hyKOicmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;607&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;这就即解决了key值过多的问题，也解决了方案一中多次网络交互的问题，经过压测对比，方案二比方案一性能提升50%以上，key越多，效果越明显。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;2、热点数据，导致redis单机瓶颈&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;商城经常有新品发布会，发布会结束后会直接跳转到新品商详页，此时新品商详页就会出现流量特别大且突发、数据单一，这就导致Redis节点负载不平衡，有些10%不到，有些达到90%多，而一些常规的扩容是没有效果的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;针对热点问题我们有以下解决方案：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;key的散列，将key分散到不同的节点&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;采用本地缓存的方式&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;开始我们采用的是基于开源的Caffeine完成本地缓存组件，本地自动计算请求量，当达到一定的阀值就缓存数据，根据不同的业务场景缓存不同的时间，一般不超过15秒，主要解决热点数据的问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;后来替换成我们自己研发的热点缓存组件，支持热点动态探测，热点上报，集群广播等功能。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;3.3 数据一致性&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;1、对于Redis的数据一致性比较好解决，采用“Cache Aside Pattern”：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于读请求采用先读缓存，命中直接返回，未命中读数据库再缓存。对于写请求采用先操作数据库，再删除缓存。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2、由于库存剥离出去，维护入口还是在商品系统，这就导致存在跨库操作，平常的单库事务无法解决。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;开始我们采用异常捕获，本地事务回滚的方式，操作麻烦点，但也能解决这个问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;后来我们通过开源的seata完成分布式事务组件，通过改写代码引入公司的基础组件，目前已经接入使用。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;四、总结&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;本篇主要介绍商城商品系统如何进行拆分、并慢慢下沉为最基础的系统，使其职责更加单一，能够提供高性能的商品服务，并分享在此过程中遇到的技术问题和解决方案，后续会有库存系统的演进历史、分布式事务相关内容，敬请期待。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;推荐：《深入分布式缓存》&lt;/p&gt;&lt;p&gt;&lt;span&gt;本书在逻辑上可分为三大篇章：基础概念篇、开源框架篇、应用案例篇。基础概念除了基础知识，也介绍了一些分布式方面的方法和思路；开源框架篇遴选了近年来流行的框架（比如Redis），同时对淘宝Tair、EVCache也做了一些探索。在Redis大行其道之时，对于memcached及其周边知识也做了介绍，某些公司还有大量的memcached实例，比如微博、Twitter等。工具的革新总是源自需求的不断被满足，而根据被满足的特性可以归纳其共性，比如解决单点高可用问题就是一个普适性问题，涉及主从模式、双活模式等，可用性同时又和性能、数据一致性相关。缓存为性能而生，但“缓存”设施的存在就决定了这个设施要符合分布式理论的要求。业界介绍理论和概要，或介绍设计原则的书不少，但拿出具体实践的稀有，比如新浪微博、Twitter这样的社交SNS具体如何设计缓存。简约而不简单！在应用案例篇，笔者邀请了对应领域的专家为大家解读案例，可以让大家触摸到真实的设计意图。重要的是大家可以获得不同场景下不同设计策略的启发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;mpcps class=&quot;js_editor_new_cps&quot; data-traceid=&quot;f5096e66-ec63-4aff-802b-c465fde46361&quot; data-goodssouce=&quot;1&quot; data-pid=&quot;107_25206694&quot; data-appuin=&quot;0&quot; data-buffer=&quot;{&amp;quot;category_id&amp;quot;:10,&amp;quot;pid&amp;quot;:&amp;quot;107_25206694&amp;quot;,&amp;quot;biz_uin&amp;quot;:0,&amp;quot;trace_id&amp;quot;:&amp;quot;f5096e66-ec63-4aff-802b-c465fde46361&amp;quot;,&amp;quot;sku_id&amp;quot;:&amp;quot;107_25206694&amp;quot;,&amp;quot;source_id&amp;quot;:7,&amp;quot;source_name&amp;quot;:&amp;quot;当当&amp;quot;,&amp;quot;audit_state&amp;quot;:1,&amp;quot;main_img&amp;quot;:&amp;quot;https://img.zhls.qq.com/3/40f7a919d2ab40d69909cfdf5361b5f1.jpg&amp;quot;,&amp;quot;product_name&amp;quot;:&amp;quot;深入分布式缓存：从原理到实践&amp;quot;,&amp;quot;current_price&amp;quot;:8910,&amp;quot;first_category_id&amp;quot;:&amp;quot;10&amp;quot;,&amp;quot;appuin&amp;quot;:0,&amp;quot;isNewCpsKOL&amp;quot;:1}&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;107447&quot;&gt;&lt;section&gt;&lt;section hm_fix=&quot;218:358&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;  往期推荐：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-width=&quot;100%&quot; data-opacity=&quot;1&quot; data-rotate=&quot;0&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;144&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;144&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/nhlGsolibOWH0hficYGBZI8qZSNxI5FiadxVSicSfvTZSNbNJGbX8d3bNJbTg1HfvOEIbM2rVa8I078ibV7wcKys75w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;长按二维码关注&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;以分布式设计、架构、体系思想为基础，兼论研发相关的点点滴滴，不限于代码、质量体系和研发管理。&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>28aba6c13717184120b0886d04401912</guid>
<title>OceanBase Meetup第五期：复杂业务场景下的数据库应用需求及挑战</title>
<link>https://toutiao.io/k/9x0g08k</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&amp;#13;
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c3f8402f21d12e9c048ba8b663a68b01</guid>
<title>node_modules 是该好好治一治了</title>
<link>https://toutiao.io/k/5bq88fv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是 Fly。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为前端开发者，大家有没有被 &lt;code&gt;node_modules&lt;/code&gt; 困扰过呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反正我是有。。。因为 npm 特殊的包管理机制，往往一个很小的项目就会携带一个很大的 &lt;code&gt;node_modules&lt;/code&gt; 。相信大家都刷到过下面这张图，这就是对前端依赖最大的讽刺了。😂&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6075174825174825&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdSxt5708baficNaCc7icpLOzgl3RCKu2Gx84ysoIx0FgTy8uWm989agcnfGSU6OVJymBrTusrYZnjJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2288&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候，可能不经意间我们就会引入一个意外的依赖包，或者不小心升级了一个有 &lt;code&gt;break chage&lt;/code&gt; 的依赖，还有可能在一个项目中安装了多个互相冲突的依赖版本。但是每次遇到这种问题，想要排查问题都要花费大量时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，我们想查询一个依赖在项目中的安装情况，我们可能会使用 &lt;code&gt;npm ls&lt;/code&gt; 命令，但是这个命令实在是太慢了，而且打印出来的信息而且混乱。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者直接去 lock 里面检查版本？你可能要花费更多的时间，而且不一定能找全。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;qnm&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近在逛 &lt;code&gt;Github&lt;/code&gt; 发现了一个宝藏 &lt;code&gt;CLI&lt;/code&gt; 工具：&lt;code&gt;qnm&lt;/code&gt;，它可以帮助我们快速梳理前端依赖信息，并且同时支持 &lt;code&gt;npm&lt;/code&gt; 和 &lt;code&gt;yarn&lt;/code&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdSxt5708baficNaCc7icpLOzgqrnibuwM3eXYgenKyYTR1wIZZXMDSq6qiaf5xMJSBUufVGnk6erjky0g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以把它安装到全局，或者使用 &lt;code&gt;npx&lt;/code&gt; 调用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm i --global qnm&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分析依赖&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用法：&lt;code&gt;qnm [module]&lt;/code&gt;， 我们尝试查看下所有安装的 &lt;code&gt;lodash&lt;/code&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7878260869565218&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdSxt5708baficNaCc7icpLOzgrdtRnSYlXwKO3mjzia4DYECtMoNjlumwMUkFJ1gjGFBiczLibQLCsr2IQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1150&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这意味着， &lt;code&gt;lodash&lt;/code&gt; 在我们的项目里被安装了 &lt;code&gt;15&lt;/code&gt; 次，我们项目直接依赖的版本是 &lt;code&gt;4.17.11&lt;/code&gt;，发布于 3 年前（已经很落后了），其他间接依赖的都是 &lt;code&gt;4.17.21&lt;/code&gt; 版本，发布于 1 周前。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来对比下实际的 &lt;code&gt;node_modules&lt;/code&gt; 目录，发现是可以一一对应上的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4729878721058434&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdSxt5708baficNaCc7icpLOzgibX8f71Je4NU0vYYnPlZEIWNhiaW7QCdoia9K6HXdD3RyWILkwvYNSJEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1814&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来对比下 &lt;code&gt;npm ls lodash&lt;/code&gt; 的结果，相比之下这个真的很慢而且展示比较乱：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.803680981595092&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdSxt5708baficNaCc7icpLOzgc22J7qJeYj7ht8lVzpRdDobkniaYHeH4OFGXBqDbzvNx5qvU9ibX3DsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1630&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你还可以对包进行模糊搜索（直接在命令行输入 &lt;code&gt;qnm&lt;/code&gt;）：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/e5Dzv8p9XdSxt5708baficNaCc7icpLOzgYBme1BkQFJUZk0kic9jYeXDyCr9pJePXcUiaicu2bGAbE2a2xMrnIXzng/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1024&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，还有一些参数选项：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--no-remote&lt;/code&gt;：禁止从 &lt;code&gt;npm&lt;/code&gt; 获取远程数据，可以加快命令速度；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-o , --open&lt;/code&gt;：使用默认编辑器打开模块的 &lt;code&gt;package.json&lt;/code&gt; 文件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-d, --debug&lt;/code&gt;：查看完整的错误消息，主要用于调试；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;--disable-colors&lt;/code&gt;：禁用大部分颜色和样式，例如版本颜色。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分析空间占用&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以使用 &lt;code&gt;qnm doctor&lt;/code&gt; 分析 &lt;code&gt;node_modules&lt;/code&gt; 目录中占用最多空间的内容，这个一分析还是挺让我吃惊的，有的老项目 &lt;code&gt;node_modules&lt;/code&gt; 已经占用了几个 G 的空间了。。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6940451745379876&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdSxt5708baficNaCc7icpLOzg8pZtcZkfB4CPHJibibW6nk9j8jvTyhvew4JJHNDgSmbRuJq4nyd9YNWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;974&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用 &lt;code&gt;qnm doctor --sort duplicates&lt;/code&gt; 查看重复依赖占用的空间：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7785547785547785&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdSxt5708baficNaCc7icpLOzglttCZ9uoyMErGhGuyLBQBLfmciaC2IUS4ylSozutmjcBjxxsobGibykQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;858&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;分析所有模块&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用 &lt;code&gt;qnm list&lt;/code&gt; 命令分析 &lt;code&gt;node_modules&lt;/code&gt; 目录中所有模块（等同于直接调用 &lt;code&gt;npm ls&lt;/code&gt; ，但是要比它的速度和可读性好太多了）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7132075471698113&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdSxt5708baficNaCc7icpLOzgaG68sgu72bgab9cMHGoGJg5k49audIficAzRkpbsp06CzP9opaBl3ZA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1060&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;模糊匹配&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;qnm match&lt;/code&gt; 命令类似于 &lt;code&gt;grep&lt;/code&gt; 命令，可以匹配包含某字符串的任何模块。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们想查找我们装了哪些 &lt;code&gt;babel&lt;/code&gt; 插件：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8308351177730193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/e5Dzv8p9XdSxt5708baficNaCc7icpLOzgUs3VpMPGiaO1rTplAwMpMr0xYplOr05MVqxLEcO0cDmWBjKBYJjHiajg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;934&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么样，有了这个命令行工具是不是感觉治理 &lt;code&gt;node_modules&lt;/code&gt; 要轻松一些了？赶紧收藏起来吧（&lt;span&gt;https://github.com/ranyitz/qnm&lt;/span&gt;）！&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;由于公众号的推荐机制，请将&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;「「前端图形」」设为星标&lt;/strong&gt;&lt;span&gt;，&lt;/span&gt;&lt;span&gt;及时&lt;/span&gt;&lt;span&gt;获&lt;/span&gt;&lt;span&gt;取更多好玩与有趣的图形知识。&lt;/span&gt;&lt;span&gt;「如果你也一样对技术热爱，喜欢&lt;/span&gt;&lt;strong&gt;「图形、数据可视化、游戏」&lt;/strong&gt;&lt;span&gt;📚并且为之着迷,欢迎加他的&lt;/span&gt;&lt;span&gt;个人微信&lt;/span&gt;&lt;span&gt;&lt;strong&gt;（wzf582344150）&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;，将会邀请你加入我的&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;可视化交流学习群&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;一起面向快乐编&lt;/span&gt;&lt;span&gt;程（摸鱼、爱情💑、各种话题&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;span&gt;~」 🦄。&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkyMjI2MDg3OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/pqcWLvSo2kg3mwicUiaA2hDwG0f4wGb2OzjF43CN344kGhtOrHgick57A7oB1kktyWicz5xiawg9Qot9Gvxl0Qxj8Ew/0?wx_fmt=png&quot; data-nickname=&quot;前端图形&quot; data-alias=&quot;&quot; data-signature=&quot;从图形的角度带你领略前端的美&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-fileid=&quot;100001764&quot; data-ratio=&quot;0.2777777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/CuarlDcuWP5EibmfIwxf9DdDsHBg1GrzR8ABN0XHR52CW40Btjv8qmZyNKoDViaBe60mglibocicPmWOys2brZv6ug/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>