<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f1ef14edd192d8b4de1db7cfa87b3342</guid>
<title>2021 值得推荐的优质在线服务</title>
<link>https://toutiao.io/k/l2t22c8</link>
<content:encoded>&lt;div&gt;&lt;html lang=&quot;zh-CN&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;/&gt;
  

    &lt;title&gt;2021 值得推荐的优质在线服务 | 晚晴幽草轩&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,user-scalable=no&quot;/&gt;
    
    &lt;meta name=&quot;author&quot; content=&quot;晚晴幽草轩轩主&quot;/&gt;
    
    &lt;meta name=&quot;theme-color&quot; content=&quot;#fffffb&quot;/&gt;
    &lt;meta name=&quot;baidu-site-verification&quot; content=&quot;PKEtLPjO56&quot;/&gt;
    

    &lt;meta name=&quot;keywords&quot; content=&quot;倾城之链, 网站, 服务, 语雀, 短链接, 文件托管, 短链接, URL 缩短, Terminal, 便民查询, 在线查询, 实用工具, 生活工具&quot;/&gt;
    &lt;meta name=&quot;description&quot; content=&quot;穿过波橘云诡的 2020，来到这暂不可测的 2021，虎视眈眈，危机重重，你我难免心怀忧虑，期盼中夹杂着祈祷；在这个百舸争流、物欲横流的时代，努力坚持，坚持努力，虽影响式微，只要选对方向，抓住机遇，须知：道阻且长，行则将至；行而不辍，未来可期。值此新年伊始，为您推荐 10 款优质在线服务，为您生活和工作，添一份助力、增几缕色彩。&quot;/&gt;
&lt;meta property=&quot;og:type&quot; content=&quot;article&quot;/&gt;
&lt;meta property=&quot;og:title&quot; content=&quot;2021 值得推荐的优质在线服务&quot;/&gt;
&lt;meta property=&quot;og:url&quot; content=&quot;https://www.jeffjade.com/2021/01/05/178-recommendations-for-quality-online-services-in-2021/index.html&quot;/&gt;
&lt;meta property=&quot;og:site_name&quot; content=&quot;晚晴幽草轩&quot;/&gt;
&lt;meta property=&quot;og:description&quot; content=&quot;穿过波橘云诡的 2020，来到这暂不可测的 2021，虎视眈眈，危机重重，你我难免心怀忧虑，期盼中夹杂着祈祷；在这个百舸争流、物欲横流的时代，努力坚持，坚持努力，虽影响式微，只要选对方向，抓住机遇，须知：道阻且长，行则将至；行而不辍，未来可期。值此新年伊始，为您推荐 10 款优质在线服务，为您生活和工作，添一份助力、增几缕色彩。&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/yuque.com.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/0x0.st.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/www.pexels.com.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/cloudconvert.com.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/send.firefox.com.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/www.51240.com.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/www.algolia.com.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/www.materialtools.com.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/www.wappalyzer.com.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/www.websiteplanet.com.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://image.nicelinks.site/nicelinks-miniprogram-code.jpeg?imageView2/1/w/300/h/300/interlace/1/ignore-error/1&quot;/&gt;
&lt;meta property=&quot;og:updated_time&quot; content=&quot;2021-01-06T14:26:31.002Z&quot;/&gt;
&lt;meta name=&quot;twitter:card&quot; content=&quot;summary&quot;/&gt;
&lt;meta name=&quot;twitter:title&quot; content=&quot;2021 值得推荐的优质在线服务&quot;/&gt;
&lt;meta name=&quot;twitter:description&quot; content=&quot;穿过波橘云诡的 2020，来到这暂不可测的 2021，虎视眈眈，危机重重，你我难免心怀忧虑，期盼中夹杂着祈祷；在这个百舸争流、物欲横流的时代，努力坚持，坚持努力，虽影响式微，只要选对方向，抓住机遇，须知：道阻且长，行则将至；行而不辍，未来可期。值此新年伊始，为您推荐 10 款优质在线服务，为您生活和工作，添一份助力、增几缕色彩。&quot;/&gt;
&lt;meta name=&quot;twitter:image&quot; content=&quot;https://oss.nicelinks.site/yuque.com.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta name=&quot;twitter:creator&quot; content=&quot;@nicejadeyang&quot;/&gt;

    
    
    
    
    
    
    
    
    
    

    
    
    

    
    
    
    
    

    
    
    

    
    
    
    
    
    
&lt;/head&gt;&lt;/html&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>210334d9a8eb4579c51c62d0f6ca8080</guid>
<title>技术人如何加速成长？提升你的思维和学习方式</title>
<link>https://toutiao.io/k/kon8rtq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fdb1b34f93a8af1f889a37cb2b78b702</guid>
<title>你的 Spring Boot 应用到底启动了哪些 Bean？这两种方式可以帮你获取</title>
<link>https://toutiao.io/k/3kq9pp8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 概述&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本文中，我们将探索在容器中获取所有spring管理的bean的相关技术。这有神马用？主要是用于排查问题。一般都是我们创建的某一个bean没有启动的问题。毕竟工作中总是会遇到各种各样的bug。提前了解一些没有坏处。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. IoC容器&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;bean是spring管理的应用程序的基础，所有bean都驻留在IOC容器中，该容器负责管理它们的生命周期。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过两种方式获取该容器内所有bean的列表:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用&lt;em&gt;ListableBeanFactory&lt;/em&gt;接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用Spring Boot Actuator&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.使用ListableBeanFactory接口&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ListableBeanFactory接口提供了getBeanDefinitionNames()方法，该方法返回在这个工厂中定义的所有bean的名称。您可以在官方文档中找到所有已知子接口及其实现类的列表。我们来看这种方式如何获取所有的bean。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;第一步：创建一个Controller&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Controller&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FooController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; FooService fooService;&lt;br/&gt;    &lt;span&gt;@RequestMapping&lt;/span&gt;(value=&lt;span&gt;&quot;/displayallbeans&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getHeaderAndBody&lt;/span&gt;&lt;span&gt;(Map model)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        model.put(&lt;span&gt;&quot;header&quot;&lt;/span&gt;, fooService.getHeader());&lt;br/&gt;        model.put(&lt;span&gt;&quot;message&quot;&lt;/span&gt;, fooService.getBody());&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;displayallbeans&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个Controller依赖于另一个FooService。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;第二步：创建Service&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FooService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getHeader&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;Display All Beans&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;getBody&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;展示所有beans的案例&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，我们在这里创建了两个不同的bean:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里使用applicationContext对象并调用它的getBeanDefinitionNames()方法，该方法将返回applicationContext容器中的所有bean:&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;第三步：设置SpringBootApplication启动类&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@SpringBootApplication&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DemoApplication&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ApplicationContext applicationContext;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        applicationContext = SpringApplication.run(DemoApplication&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;, &lt;span&gt;args&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;        displayAllBeans();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;displayAllBeans&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String[] allBeanNames = applicationContext.getBeanDefinitionNames();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt;(String beanName : allBeanNames) {&lt;br/&gt;            System.out.println(beanName);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;第四步：测试打印&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这将打印applicationContext容器中的所有bean:&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.28480340063761955&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/N8scgexEBuLMqBJ1WDfpl6z6lib2sTwvGBAvHSCIOSAYCQb9OHllTexA2PM8sCjY3IRVxZsIYNwwIBCDqcDyCTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;941&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，除了我们定义的bean之外，它还将记录该容器中的所有其他bean。为了清楚起见，我们在这里省略了它们，因为它们有很多。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 使用Spring Boot Actuator&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Boot Actuator提供了用于监控应用程序统计信息的端点。下面看看这种方式：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;第一步：添加依赖&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-actuator&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;第二步：修改application.properties&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;management.endpoints.web.exposure.include=*&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把上面代码添加到properties文件中。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;第三步：使用发布端点查看&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6779141104294478&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/N8scgexEBuLMqBJ1WDfpl6z6lib2sTwvGmANb8YMkWPTFoP114nXTqV1uAxcLdjU9joFFgG3bPMdRkIn2dm6s5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;652&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于这里的Actuator没有配置，所以显示的比较乱。关于Actuator的配置，会在下一篇文章中呈现。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 结论&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本文中，我们了解了如何使用ListableBeanFactory接口和Spring Boot Actuator在Spring IoC容器中显示所有bean。希望对你有点帮助。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.53375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/N8scgexEBuICia4zPYRV2L5IdwHia67cGql1yeibsYb0x5A0F44SRiarAZwsUJmjZfZiagzexIQ21gyQrheJtyIlmvQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;点击“阅读原文”获取java相关5T资源，&lt;/p&gt;&lt;p&gt;视频,电子书,面试,简历,IDEA破解等                     &lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>771650aca3d4ab89502180bc37532ec2</guid>
<title>面试官：能说一说 MySQL 缓存池吗？</title>
<link>https://toutiao.io/k/3e3cyll</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;点上面👆 &lt;span&gt;蓝色字体&lt;/span&gt; 关注我呀&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;qqmusic class=&quot;js_editor_qqmusic qqmusic_iframe js_uneditable custom_select_card&quot; musicid=&quot;213776882&quot; mid=&quot;004LuFjR3W7yE2&quot; albumurl=&quot;https://y.gtimg.cn/music/photo_new/T002R68x68M000003lFefO0r5bDD.jpg&quot; audiourl=&quot;http://isure6.stream.qqmusic.qq.com/C2000020TpX13Q66jl.m4a?guid=2000001731&amp;amp;vkey=111B6024E07334A8F1A4F272297F0875D1E92C7B869F3843BE58C81CAADEA3C5A62A411BB7C7E3561EE574BF1E67AAE9154CFA2D1C3A2402&amp;amp;uin=&amp;amp;fromtag=50&quot; music_name=&quot;Pray For You&quot; singer=&quot;杨和苏KeyNG - Pray For You&quot; play_length=&quot;202&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/qqmusic_tmpl&amp;amp;singer=%E6%9D%A8%E5%92%8C%E8%8B%8FKeyNG%20-%20Pray%20For%20You&amp;amp;music_name=Pray%20For%20You&amp;amp;albumurl=https%3A%2F%2Fy.gtimg.cn%2Fmusic%2Fphoto_new%2FT002R68x68M000003lFefO0r5bDD.jpg&amp;amp;musictype=1&quot; musictype=&quot;1&quot; otherid=&quot;004LuFjR3W7yE2&quot; albumid=&quot;003lFefO0r5bDD&quot; jumpurlkey=&quot;&quot; data-pluginname=&quot;insertaudio&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家好，我是狂聊君。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;今天来聊一聊 Mysql 缓存池原理。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;提纲附上，话不多说，直接干货。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.28475336322869954&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RM9eAwLoEFB4BTrdRkl9xicYTic9LbId0UlVBbYzdDQ1AcJDicwOVicSTFITUHRWnBpoPaM0miaibv8KFdzI24JSUGeA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;面试官：同学，你能说说Mysql 缓存池吗？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;狂聊君：啊，这么难吗，容我组织一下语言。（内心OS：&lt;span&gt;这TM还不简单？我能给你扯半小时！&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;面试官：可以，给你一分钟时间想一想吧。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;....一分钟后...&lt;span&gt;.&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;狂聊君：我准备好了，你可听好，我要开始表演了。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么要有缓存池？&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Mysql 的 innodb 存储引擎是基于磁盘存储的，并且是按照页的方式进行管理的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在数据库系统中，CPU 速度与磁盘速度之间的差距是非常大的，为了最大可能的弥补之间的差距，提出了缓存池的概念。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以缓存池，简单来说就是一块&lt;strong&gt;「内存区域」&lt;/strong&gt;，通过内存的速度来弥补磁盘速度较慢，导致对数据库造成性能的影响。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存池的基本原理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「读操作」&lt;/strong&gt;:&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在数据库中进行读取页的操作，首先把从磁盘读到的页存放在缓存池中，下一次读取相同的页时，首先判断该页是不是在缓存池中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;若在，称该页在缓存池中被命中，则直接读取该页，否则，还是去读取磁盘上的页。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「写操作」&lt;/strong&gt;:&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;对于数据库中页的修改操作，首先修改在缓存池中的页，然后在以一定的频率刷新到磁盘，并不是每次页发生改变就刷新回磁盘，而是通过 checkpoint 的机制把页刷新回磁盘。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;可以看到，无论是读操作还是写操纵，都是对缓存池进行操作，而不是直接对磁盘进行操纵。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存池结构&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Buffer Pool 是一片连续的内存空间，innodb 存储引擎是通过页的方式对这块内存进行管理的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存池的结构如下图：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46904315196998125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RM9eAwLoEFB4BTrdRkl9xicYTic9LbId0U7N0aFIbzkyjSnmeRiaibdRicvmf6B8ylOIXIdiazPLib0Vuo1f5KInOe3VQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1066&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以看到缓存池中包括数据页、索引页、插入缓存、自适应哈希索引、锁信息、数据字段。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其中数据页和索引页会用掉多数内存。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「但是，innodb 是如何管理缓存池中的这么多页呢？」&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了更好的管理这些缓存的页，innodb 为每一个缓存页都创建了一些所谓的控制信息，这些控制信息包括该页所属的：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;表空间编号(sapce id)&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;页号(page numeber)&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;页在 buffer Pool 的地址&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;一些锁信息以及 LSN 信息日志序列号&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;其他控制信息&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;每个缓存页对应的控制信息占用的内存大小是相同的，我们把每个页对应的控制信息占用的一块内存称为一个&lt;strong&gt;「控制块」。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「控制块」&lt;/strong&gt;和缓存页是一一对应的，它们都被存放到 Buffer Pool 中，其中控制块被存放到 Buffer Pool 的前边，缓存页被存放到 Buffer Pool 的后边。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Buffer Pool 对应的内存空间示意图：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.30740037950664134&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RM9eAwLoEFB4BTrdRkl9xicYTic9LbId0Uq7lPibDTEeZnDGC2LibZrb14MDXlMGZ2zVtfwJ6SYvOMm1pypL9kYgXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1054&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存池参数设置&lt;/span&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;innodb_buffer_pool_size：缓存池的大小最多应设置为物理内存的 80%&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;innodb_buffer_pool_instance：设置有多少个缓存池，通常建议把缓存池个数设置为 CPU 的个数，多个缓存池可以减少数据库内部的资源竞争，增加数据库并发访问的能力&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;innodb_old_blocks_pct：老生代占整个 LRU 的链长比例，默认是 3：7&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;innodb_old_blocks_time：老生代停留时间窗口，单位是毫秒，默认是 1000，即同时满足“被访问”与“在老生代停留时间超过 1 秒”两个条件，才会被插入到新生代头部&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;缓存池管理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「管理缓存池依赖的链表结构」：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Free 链表&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当启动 Mysql 服务器的时候，需要完成对 Buffer Pool 的初始化过程，即分配 Buffer Pool 的内存空间，把它划分为若干对控制块和缓存页，但是此时并没有真正的磁盘页被缓存到 Buffer Pool 中，之后随着程序的运行，会不断的有磁盘上的页被缓存到 Buffer Pool 中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在使用过程中，为了记录哪些缓存页是可用的，我们把所有空闲的页包装成一个节点组成一个链表，这个链表可以称作为 Free 链表（空闲链表）。因为刚刚完成初始化的 Buffer Pool 中所有的缓存页都是空闲的，所以每一个缓存页都会被加入到 Free 链表中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了方便管理 Free 链表，特意为这个链表定义了一些&lt;strong&gt;「控制信息」&lt;/strong&gt;，里面包含链表的头节点地址，尾节点地址，以及当前链表中节点的数量等信息。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;另外会在每个 Free 链表的节点中都记录了某个&lt;strong&gt;「缓存页控制块」&lt;/strong&gt;的地址，而每个&lt;strong&gt;「缓存页控制块」&lt;/strong&gt;都记录着对应的&lt;strong&gt;「缓存页地址」&lt;/strong&gt;，所以相当于每个 Free 链表节点都对应一个空闲的缓存页。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;给大家画了个结构图：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7570093457943925&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RM9eAwLoEFB4BTrdRkl9xicYTic9LbId0UZH5zZQvdLAa3IhDasmjUE7AfDibmEWtR6aH0fjw1XFCtPLyafdjhTzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1284&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这图怎么样，这下能看的懂了吧！&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、Lru 链表&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Lru 链表用来管理已经读取的页，当数据库刚启动时，Lru 链表是空的，此时页也都放在 Free 列表中，当需要读取数据时，会从 Free 链表中申请一个页，把从放入到磁盘读取的数据放入到申请的页中，这个页的集合叫做 Lru 链表。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、Flush 链表&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Flush 链表用来管理被修改的页，Buffer Pool 中被修改的页也被称之为&lt;strong&gt;「脏页」&lt;/strong&gt;，脏页既存在于 Lru 链表中，也存在于 Flush 链表中，Flush 链表中存的是一个指向 Lru 链表中具体数据的指针。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此只有 Lru 链表中的页第一次被修改时，对应的指针才会存入到 Flush 中，若之后再修改这个页，则是直接更新 Lru 链表中的页对应的数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这三者之间是这么个关系：&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2839506172839506&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RM9eAwLoEFB4BTrdRkl9xicYTic9LbId0UYZKoGqCJ4KGib4uJV2r9G25CnTwLTPic3SGYcJmM5QFJiapOuRshaRP3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;810&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;读操作&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Buffer Pool 一个最主要的功能是&lt;strong&gt;「加速读」&lt;/strong&gt;。加速读是当需要访问一个数据页面的时候，如果这个页面已经在缓存池中，那么就不再需要访问磁盘，直接从缓冲池中就能获取这个页面的内容。当我们需要访问某个页中的数据时，就会把该页加载到 Buffer Pool 中，如果该页已经在 Buffer Pool 中的话直接使用就可以了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;问题：那么如何快速查找在 Buffer Pool 中的页呢？&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了避免查询数据页时扫描 Lru，其实是根据表空间号 + 页号来定位一个页的，也就相当于表空间号 + 页号是一个 key，缓存页就是对应的 value。用表空间号 + 页号作为 key，缓存页作为 value 创建一个哈希表，在需要访问某个页的数据时，先从哈希表中根据表空间号 + 页号看看有没有对应的缓存页。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果有，直接使用该缓存页就好。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果没有，那就从 Free 链表中选一个空闲的缓存页，然后把磁盘中对应的页加载到该缓存页的位置。每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 Free 链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的 Free 链表节点从链表中移除，表示该缓存页已经被使用了，并且把该页写入 Lru 链表。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在初始化的时候，Buffer pool 中所有的页都是空闲页，需要读数据时，就会从 Free 链表中申请页，但是物理内存不可能无限增大，数据库的数据却是在不停增大的，所以 Free 链表的页是会用完的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;因此需要考虑把已经缓存的页从 Buffer pool 中删除一部分，进而需要考虑如何删除及删除哪些已经缓存的页。假设一共访问了 n 次页，那么被访问的页在缓存中的次数除以 n 就是缓存命中率，缓存命中率越高，和磁盘的 IO 交互也就越少 。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为了提高缓存命中率，InnoDB 在传统 Lru 算法的基础上做了优化，解决了两个问题：1、预读失效 2、缓存池污染&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;写操作&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Buffer pool 另一个主要的功能是&lt;strong&gt;「加速写」&lt;/strong&gt;，即当需要修改一个页面的时候，先将这个页面在缓冲池中进行修改，记下相关的重做日志，这个页面的修改就算已经完成了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;被修改的页面真正刷新到磁盘，这个是后台刷新线程来完成的。前面页面更新是在缓存池中先进行的，那它就和磁盘上的页不一致了，这样的缓存页被称为脏页（dirty page）。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;问题：这些被修改的页面什么时候刷新到磁盘？以什么样的顺序刷新到磁盘？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最简单的做法就是每发生一次修改就立即同步到磁盘上对应的页上，但是频繁的往磁盘中写数据会严重的影响程序的性能。所以每次修改缓存页后，不能立即把修改同步到磁盘上，而是在未来的某个时间点进行同步，由后台刷新线程依次刷新到磁盘，实现修改落地到磁盘。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;但是如果不立即同步到磁盘的话，那之后再同步的时候如何判断 Buffer Pool 中哪些页是脏页，哪些页从来没被修改过呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;InnoDB 并没有一次性把所有的缓存页都同步到磁盘上，InnoDB 创建一个存储脏页的链表，凡是在 Lru 链表中被修改过的页都需要加入这个链表中，因为这个链表中的页都是需要被刷新到磁盘上的，所以这个链表也叫 Flush 链表，链表的构造和 Free 链表一致。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里的脏页修改指的此页被加载进 Buffer Pool 后第一次被修改，只有第一次被修改时才需要加入 Flush 链表，对于已经存在在 Flush 链表中的页，如果这个页被再次修改就不会再放到 Flush 链表。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;需要注意，脏页数据实际还在 Lru 链表中，而 Flush 链表中的脏页记录只是通过指针指向 Lru 链表中的脏页。并且在 Flush 链表中的脏页是根据 oldest_lsn（这个值表示这个页第一次被更改时的 lsn 号，对应值 oldest_modification，每个页头部记录）进行排序刷新到磁盘的，值越小表示要最先被刷新，避免数据不一致。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;狂聊君：面试官，我就先说这些吧！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;面试官：行，回答的还凑合。（&lt;span&gt;内心OS：这小子知道的还挺多啊！&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;狂聊君：我可谢谢您嘞！&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;看累了吧，学到了吧，那就关注一下呗！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;欢迎在看、点赞、转发、您的认可是我原创的动力！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我是狂聊君，下篇见。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/RM9eAwLoEFB4BTrdRkl9xicYTic9LbId0UXODrrCjNqraXCmTsC2Yz3GCB3575qCTjGtzibj8tIicoVvd3K2157nIQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>074284239c38ee8cd4596bc79c972501</guid>
<title>分布式一致性协议：EPaxos</title>
<link>https://toutiao.io/k/odbscty</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-content&quot;&gt;&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;/&gt;总结&lt;/h3&gt;&lt;p&gt;epaxos作为paxos族中的一员，并不是单独存在的。所以我在文中开篇给出总结，罗列与basic-paxos、mutli-paxos之间的区别。带着目的学习，可能相对容易理解一些。&lt;/p&gt;
&lt;p&gt;回顾paxos的局限性，总结来说存在三个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;basic-paxos，多个proposal提出时，容易形成活锁，影响整个算法的活性。&lt;/li&gt;
&lt;li&gt;mutli-paxos，通过只允许leader提出proposal，解决活锁问题，同时影响了吞吐量（性能局限于leader）、可扩展性（必须要leader发起提案）、可用性（leader宕机服务不可用）。&lt;/li&gt;
&lt;li&gt;paxos，各提案乱序提交，不能明确各提案之间的依赖关系。&lt;/li&gt;
&lt;li&gt;raft，通过实现对日志项进行编号，解决日志项之间依赖关系，但是又不支持乱序提交。&lt;/li&gt;
&lt;li&gt;paxos、raft，client跨地域请求leader，延迟增大。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;paxos存在的活锁、提案依赖关系的问题。从某个角度来说：mutli-paxos、raft采用“曲线救国”的方案对问题进行规避，通过引入leader和事先对日志项编号来避免，或多或少都降低了可用性和吞吐量。而epaxos则是直面冲突，并给出了自己的解决冲突的方案。&lt;/p&gt;
&lt;h3 id=&quot;epaxos简介&quot;&gt;&lt;a href=&quot;#epaxos简介&quot; class=&quot;headerlink&quot; title=&quot;epaxos简介&quot;/&gt;epaxos简介&lt;/h3&gt;&lt;h4 id=&quot;epaxos特性&quot;&gt;&lt;a href=&quot;#epaxos特性&quot; class=&quot;headerlink&quot; title=&quot;epaxos特性&quot;/&gt;epaxos特性&lt;/h4&gt;&lt;p&gt;在epaxos开篇介绍时，都会提到一个词“leaderless”，这确实是epaxos最值得骄傲的特性了。leaderless描述的是：没有leader，各节点对等，任何节点都可处理事务请求（写请求）。&lt;/p&gt;
&lt;p&gt;在“leaderless”特性下，epaxos的优势很明显：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;epaxos省略了leader选举的开销，同时没有leader瓶颈限制的问题。&lt;/li&gt;
&lt;li&gt;各节点都能处理事务请求（写请求），拥有更高的性能。&lt;/li&gt;
&lt;li&gt;在跨地域场景下，不需要额外的同步（学习）的阶段。&lt;/li&gt;
&lt;li&gt;客户端可选择最近的副本提供服务，具有更小的延迟。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;epaxos的答卷&quot;&gt;&lt;a href=&quot;#epaxos的答卷&quot; class=&quot;headerlink&quot; title=&quot;epaxos的答卷&quot;/&gt;epaxos的答卷&lt;/h4&gt;&lt;p&gt;面对paxos遗留的两个问题：活锁、提案依赖关系。epaxos又是如何解决的呢？&lt;/p&gt;
&lt;p&gt;epxos将协议拆分为两部分，一部分是commit协议，一部分是恢复阶段。前者是处理写请求，在各副本中选择（提交）command并确定command附加的属性值（当前command依赖其他command的顺序）。后者是集群中某个副本异常时，其他副本尝试恢复其数据。&lt;/p&gt;
&lt;p&gt;在commit协议中，又具体分为三个阶段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阶段一：Establish ordering constraints，建立约束关系&lt;/li&gt;
&lt;li&gt;阶段二：Paxos-Accept，达成一致&lt;/li&gt;
&lt;li&gt;阶段三：commit阶段，一般异步提交，通常被大家一笔带过&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;commit协议中提出日志冲突的概念，阶段一也就是为了解决日志冲突而存在的。当多个command（写请求）对同一个值进行修改时，epaxos则认为发生冲突，需要先建立command之间的约束关系（command之间顺序）。&lt;/p&gt;
&lt;p&gt;对于是否冲突，commit协议给出不同达成一致的方案：fast-path, slow-path，二者分别对应没有冲突和有冲突的写请求。fast-path是指在没有冲突的写请求中，执行阶段一即可进行提交。slow-path是指在发生冲突的写请求中，需要执行两个阶段才能进行提交。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/theory/distributed/epaxos_1.png&quot; alt=&quot;fast-path, slow-path&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这张经典的图，还是得看，清晰的描述了fast-path, slow-path二者的不同之处。R1, R2,…R5是五个副本。C1, C2, C3, C4是command（即更新操作），R1和R5分别记为C1和C2的command-leader。为了清晰起见，我们省略了异步提交消息。&lt;/p&gt;
&lt;p&gt;左图中C1对obj_A修改，C2对obj_B修改，即两者不会发生冲突，因此两者都可以在fast-path上提交。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;R1收到update obj_A请求，将其发给多数派副本&lt;/li&gt;
&lt;li&gt;各副本在收该请求后，由于没有其他请求发生冲突，则返回成功R1&lt;/li&gt;
&lt;li&gt;异步提交&lt;/li&gt;
&lt;li&gt;R5同上&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;右图中C3和C4同时对obj_A修改，相互干扰，因此一个C3将在slow-path上执行。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;R1和R5分别收到update obj_A请求，将其分别封装为C3和C4发送其他多数派副本&lt;/li&gt;
&lt;li&gt;R3为多数派相交的副本，C4比C3先到到达R3&lt;/li&gt;
&lt;li&gt;R3在处理C4时，没有请求与之冲突，则提供通过fast-path提交&lt;/li&gt;
&lt;li&gt;R3在收到C3时，由于C4和C3发生冲突，则返回C3→C4，表示C3获得了对C4的依赖&lt;/li&gt;
&lt;li&gt;R1收到R3的响应，则将依赖关系整理后，发起accept给多数派&lt;/li&gt;
&lt;li&gt;多数派没有继续发生冲突，则返回成功&lt;/li&gt;
&lt;li&gt;异步提交&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;quorum特殊要求&quot;&gt;&lt;a href=&quot;#quorum特殊要求&quot; class=&quot;headerlink&quot; title=&quot;quorum特殊要求&quot;/&gt;quorum特殊要求&lt;/h4&gt;&lt;p&gt;需要注意，与paxos不同的是：paxos只需要多数派的副本正常响应后，便能正常提交。而对epaxos则略有差异：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;论文中指出在fast-path中，quorum数量为：$F+\lfloor(F+1)/2\rfloor$，其中F表示最大容忍的出错副本数量。即：command-leader需要收到$F+\lfloor(F+1)/2\rfloor$个副本（包含command-leader）的正常响应。在上面案例中，5副本的集群，最大容忍出错副本数量为2，则需要与2+[(2+1)/2] = 3.5，向下取整，即3个副本的正常响应。&lt;/li&gt;
&lt;li&gt;在slow-path中，quorum数量为：F+1，其中F表示最大容忍的出错副本数量。在上面案例中，5副本的集群，最大容忍出错副本数量为2，则需要收到2+1=3个副本的正常响应。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了解释这个特殊要求，我们看下面的案列，存在7个副本，大于等于4则为多数派，3个容错数量。R1收到修改x=1，R2收到修改x=2，二者分别发起epaxos。&lt;br/&gt;&lt;img src=&quot;/images/theory/distributed/epaxos_2.png&quot; alt=&quot;quorum特殊要求&quot;/&gt;&lt;br/&gt;R4, R5在fast-path先收到x=1再收到x=2。R6, R7在fast-path先收到x=2再收到x=1。如果R3是先收到x=1，那么R1、R3、R4、R5构成多数派，确定提交顺序为先提交x=1再提交x=2。如果R3是先收到x=2，那么R2、R3、R6、R7构成多数派，确定提交顺序为先提交x=2再提交x=1。&lt;br/&gt;那么如果此时R1, R2, R3宕机，那么剩下的副本将不知道是先提交x=1还是先提交x=2。所以在epxos中fast-path需要quorum数量为$F+\lfloor(F+1)/2\rfloor$，即：$3+\lfloor(3+1)/2\rfloor=5$。&lt;/p&gt;
&lt;h3 id=&quot;commit协议&quot;&gt;&lt;a href=&quot;#commit协议&quot; class=&quot;headerlink&quot; title=&quot;commit协议&quot;/&gt;commit协议&lt;/h3&gt;&lt;p&gt;正如上文提到，epaxos分为两部分，commit协议是指：&lt;/p&gt;
&lt;p&gt;当副本L收到来自客户端写请求时，将其封装为command γ（念：伽玛），并称为γ的command-leader，command-leader开始γ的提交过程。进入第一阶段，command-leader定义γ的初始属性deps, seq。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;deps：定义所有包含与γ冲突的command（不一定是已提交的command）的列表，也称为γ依赖于这些command。&lt;/li&gt;
&lt;li&gt;seq：用于execute算法过程中，打破循环依赖的序列号。取值为所有冲突command的最大的seq。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;command-leader将γ和γ的初始属性deps, seq&lt;strong&gt;至少&lt;/strong&gt;发送给fast-path所要求的quorum数量（$F+\lfloor(F+1)/2\rfloor$），论文中称之为PreAccept-Message。各副本收到PreAccept-Message后，再&lt;strong&gt;根据自己本地的cmds-log更新γ的deps, seq值&lt;/strong&gt;，并在自己的cmds-log中新增一条用来记录γ。将更新的γ返回给command-leader。&lt;/p&gt;
&lt;p&gt;如果command-leader收到足够多的响应，并且所有响应中的γ的属性都相同，即构成fast-path，便发送Commit-Message进行异步提交。&lt;br/&gt;如果command-leader没有收到足够多的响应，或者所有响应中的γ的属性存在不一致，即构成slow-path，command-leader需要基于所有响应更新γ的值（合并所有的deps作为新的deps，取最大的seq作为新的seq）。进入第二阶段，将新的γ&lt;strong&gt;至少&lt;/strong&gt;发送给$\lfloor N/2 \rfloor$个副本，这个过程类似经典的paxos，在本轮结束之后，如果收到大多数$\lfloor N/2 \rfloor$响应（包含command-leader）即可给客户端返回成功，并发送Commit-Message进行异步提交。&lt;/p&gt;
&lt;h4 id=&quot;commit伪代码&quot;&gt;&lt;a href=&quot;#commit伪代码&quot; class=&quot;headerlink&quot; title=&quot;commit伪代码&quot;/&gt;commit伪代码&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/images/theory/distributed/epaxos_3.png&quot; alt=&quot;commit伪代码&quot;/&gt;&lt;br/&gt;论文中提供了伪代码，我们简单来看看，副本L收到来自客户端的请求γ，成为γ的commandleader&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自增L的instance id $i_L$ ← $i_L$ + 1。&lt;/li&gt;
&lt;li&gt;$seq_γ$表示γ的seq，取值为：副本L已记录的command中最大的seq的值+1，与{0}取并集，是在没有command情况下，取0+1作为seq的值。&lt;/li&gt;
&lt;li&gt;$deps_γ$表示γ的deps，取值为：副本L中与γ冲突的command集合。&lt;/li&gt;
&lt;li&gt;副本L将 $ (γ,seq_γ,deps_γ,pre-accepted) $ 记录到自己 $cmds_L$ ，pre-accepted表示γ的状态。&lt;/li&gt;
&lt;li&gt;发送$ PreAccept(γ,seq_γ,deps_γ,L.i_L) $给所有副本，$L.i_L$即第一步自增的instance id。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;副本R收到PreAccept请求后&lt;br/&gt;6. 更新γ的seq值，取值为：副本R中已记录的command中最大的$seq+1$后与原来seq值，取最大。&lt;br/&gt;7. 更新γ的deps值，取值为：取副本R中与γ冲突集合和原本deps的并集。&lt;br/&gt;8. 副本R将$ (γ,seq_γ,deps_γ,pre-accepted) $记录到自己$cmds_R$，pre-accepted表示γ的状态。&lt;br/&gt;9. 回复PreAcceptOK给副本L。&lt;/p&gt;
&lt;p&gt;副本L收到最少$\lfloor N/2 \rfloor$个PreAcceptOK的响应后。（这里的$\lfloor N/2 \rfloor$感觉有问题）&lt;br/&gt;10. 如果所有副本响应中$seq_γ$, $deps_γ$都相同&lt;br/&gt;11. 副本L执行commit阶段，跳转至21步&lt;br/&gt;12. 如果存在不相同的 $seq_γ$, $deps_γ$&lt;br/&gt;13. 更新$deps_γ$，取值为：整合所有响应中的deps&lt;br/&gt;14. 更新$seq_γ$，取值为：所有响应中最大seq&lt;br/&gt;15. 副本L执行paxos-accept阶段&lt;/p&gt;
&lt;p&gt;副本L开始paxos-accept阶段&lt;br/&gt;16. 副本L将$(γ,seq_γ,deps_γ,accepted)$记录到自己$cmds_L$，accepted表示γ的状态。&lt;br/&gt;17. 发送$Accept(γ,seq_γ,deps_γ,L.i)$给至少$\lfloor N/2 \rfloor$个副本&lt;/p&gt;
&lt;p&gt;副本R收到Accept请求后&lt;br/&gt;18. 副本R将$(γ,seq_γ,deps_γ,accepted)$记录到自己$cmds_R$，accepted表示γ的状态。&lt;br/&gt;19. 回复AcceptOK给副本L。&lt;/p&gt;
&lt;p&gt;副本L收到至少$\lfloor N/2 \rfloor$个AcceptOK响应后&lt;br/&gt;20. 开始commit阶段，跳转至21步&lt;/p&gt;
&lt;p&gt;副本L开始commit阶段&lt;br/&gt;21. 副本L将$(γ,seq_γ,deps_γ,commited)$记录到自己$cmds_L$，commited表示γ的状态。&lt;br/&gt;22. 回复客户端已提交的响应&lt;br/&gt;23. 发送$Commit(γ,seq_γ,deps_γ,L.i)$给其他的副本&lt;/p&gt;
&lt;p&gt;副本R收到commit请求&lt;br/&gt;24. 副本R将$(γ,seq_γ,deps_γ,commited)$记录到自己$cmds_R$，commited表示γ的状态。&lt;/p&gt;
&lt;h3 id=&quot;Explicit-Prepare&quot;&gt;&lt;a href=&quot;#Explicit-Prepare&quot; class=&quot;headerlink&quot; title=&quot;Explicit Prepare&quot;/&gt;Explicit Prepare&lt;/h3&gt;&lt;p&gt;这一部分，论文描述的篇幅相对较少，因此也没有被大家重视，epaxos称之为Explicit Prepare，用于恢复异常副本所处理的command。这一部分在论文中也用于执行command。如要要在一个副本上执行command γ，需要经过以下几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;等待副本提交，或者显示调用Explicit Prepare&lt;/li&gt;
&lt;li&gt;构建γ所依赖的command的依赖图，对所有依赖command都进行Explicit Prepare&lt;/li&gt;
&lt;li&gt;找到紧密连接的组件（command），对它们进行拓扑排序&lt;/li&gt;
&lt;li&gt;以逆拓扑顺序，对于每个强烈连接的组件（command），执行:&lt;ol&gt;
&lt;li&gt;按顺序将强连接组件中的所有命令排序；&lt;/li&gt;
&lt;li&gt;以递增的编号顺序执行每个未执行的命令，将其标记为已执行&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;Explicit-Prepare伪代码&quot;&gt;&lt;a href=&quot;#Explicit-Prepare伪代码&quot; class=&quot;headerlink&quot; title=&quot;Explicit Prepare伪代码&quot;/&gt;Explicit Prepare伪代码&lt;/h4&gt;&lt;p&gt;在看伪代码之前，需要先描述一个概念。在经典的paxos中，每个proposal都有一个ballot，用于标示proposal唯一性，也用于表示proposal的先后顺序，epaxos当然也需要。为了保证ballot唯一性，所以ballot需要包含副本ID。同时新的周期要优先于旧的周期，所有还需要epoch值。最后ballot的格式为：epoch.b.R。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/theory/distributed/epaxos_4.png&quot; alt=&quot;Explicit Prepare&quot;/&gt;&lt;/p&gt;
&lt;p&gt;副本Q怀疑L失效，尝试去恢复L.i这个instance。&lt;br/&gt;25. 自增ballot，取值为epoch.(b+1).Q。（epoch.b.Q为副本Q最大的投票编号）&lt;br/&gt;26. 发送$Prepare(epoch.(b+1).Q,L.i)$ 给所有副本，并等待$\lfloor N/2 \rfloor+1$个回复。&lt;br/&gt;27. 假设所有回应中最大ballot的是$ballot_max$，定义R是所有回应中ballot等于$ballot_max$的响应的集合。&lt;br/&gt;28,29. 如果R包含$(γ,seq_γ,deps_γ,commited)$，执行commit阶段&lt;br/&gt;30,31. 如果R包含$(γ,seq_γ,deps_γ,acceprted)$，执行paxos-accept阶段&lt;br/&gt;32,33. 如果R包含至少$\lfloor N/2 \rfloor$一致的回复$(γ,seq_γ,deps_γ,pre-accepted)$，且这些回复都不是来自L，执行paxos-accept阶段&lt;br/&gt;34,35. 如果R至少包含一个$(γ,seq_γ,deps_γ,pre-accepted)$，执行第一阶段&lt;br/&gt;36,37. 如果R没有关于这个instance id的任何信息，那么推出退出恢复阶段，副本Q对L.i实例尝试去commit no-op&lt;/p&gt;
&lt;p&gt;副本R收到来自副本Q的Prepare(epoch.b.Q,L.i)请求&lt;br/&gt;38,39. R已接收来自L.i的最大的ballot为epoch.x.Y，如果epoch.b.Q大于epoch.x.Y，回复$PrepareOK(cmds_R,epoch.x.Y,L.i)$&lt;br/&gt;40,41.否则回复NACK&lt;/p&gt;
&lt;h3 id=&quot;存在的问题&quot;&gt;&lt;a href=&quot;#存在的问题&quot; class=&quot;headerlink&quot; title=&quot;存在的问题&quot;/&gt;存在的问题&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;论文中强调的Executing和Commiting是两个不同的action，但是几乎没有提交关于Execution Algorithm的内容。&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>