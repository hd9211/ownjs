<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>28fc89c56a2f09e1e5c6fb76d4be875c</guid>
<title>推荐几个开源类库，超好用，远离 996</title>
<link>https://toutiao.io/k/oi7zdzy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天给大家分享几个 Java 的开源类库，亲测非常好用！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了它们之后，你就可以和很多重复劳动说再见了。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;1. MapStruct&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2806349206349206&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KSnhEmJ0hk51vGmlPGAia7cBuEstA8ecmrWian3mjF0VvoAiaibNWTC5K3QMZ6yK4QwDYYo401lOymRrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3150&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;MapStruct是干什么的？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MapStruct是个代码产生器，它能直接根据注解生成 Java 对象对应的转换器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，直接把一个 A 类型的 Java 对象，给转成 B 类型的 Java 对象，只需要在他们之间配置上字段之间的映射关系即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么在项目里用它？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在随便一个项目都是多层的，尤其是 Web 项目，经常需要在多层之间做对象模型转换，比如 DTO 转换成 BO。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;DTO（Data Transfer Object）：数据传输对象，Service 向外传输的对象。&lt;br/&gt;BO（Business Object）：业务对象，由 Service 层输出的封装业务逻辑的对象。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这种转换工作就像是小时候，老师罚我们抄写名人名言 100 遍一样，十分枯燥，还容易出错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CarMapper&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;CarDto &lt;span&gt;carDoToCarDto&lt;/span&gt;&lt;span&gt;(Car car)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        CarDto carDto = &lt;span&gt;new&lt;/span&gt; CarDto();&lt;br/&gt;        carDto.setCarId(car.getCarId());&lt;br/&gt;        carDto.setWheel(car.getWheel());&lt;br/&gt;        carDto.setCarType(car.getCarType());&lt;br/&gt;        carDto.setCarColor(car.getCarColor());&lt;br/&gt;        ......&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要是 Car 有几十个字段，像 Car 一样的又有几十个类，你可以想一下，这种繁琐程度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 MapStruct 之前，我们都是通过 Apache 或者 Spring 的 BeanUtils 工具，去自动做这种事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是这类工具有两个问题：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.性能比较差&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;性能差主要是 Apache 的 BeanUtils 这套东西，它每次都要针对字段，做是否可读写的检查，还要根据字段生成对应的 PropertyDescriptor。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些严重影响了它的性能，所以，在阿里 Java 手册里，也不推荐用它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring 的 BeanUtils，虽然精简了很多 Apache 的 BeanUtils 的读写检查以及对应的属性信息记录，但是它依然是通过反射调用，而且是大量反射调用。这种性能也不能令人满意。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.运行期做转换，出错就代表损失&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BeanUtils 这类工具，有个统一的名称，叫做 Java 对象映射框架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它们大部分的实现都是在运行期去执行代码，然后在 Java 对象之间去拷贝对应的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行期间做这种事儿，有个最大的问题——整个项目启动运行后，才能发现错误。比如，转换的时候，类型不一致导致报错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于此种情况，咱们大家都知道，这事儿就像开业酬宾没搞好，变成了开业仇宾……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果能写完代码，编译的时候就发现问题，这种损失就可以避免了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MapStruct 的引入就是为了解决以上这两个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MapStruct 首先是个代码产生器，它是根据注解，去产生一个专门用来转换的工具类，这个工具类，就像我们自己写的 Java 类一样，可以直接被使用，这样就避免了反射。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时，它产生的转换类也特别简单，就是默认会在两个类型的 Java 对象之间，拷贝同名属性的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果有了配置，属性不同名也可以拷贝。所以它的性能很好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Mapper&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;CarMapper&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    CarMapper INSTANCE = Mappers.getMapper( CarMapper&lt;span&gt;.&lt;span&gt;class&lt;/span&gt; )&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Mapping&lt;/span&gt;(target = &lt;span&gt;&quot;seatCount&quot;&lt;/span&gt;, source = &lt;span&gt;&quot;numberOfSeats&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;CarDto &lt;span&gt;carBoToCarDto&lt;/span&gt;&lt;span&gt;(Car car)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MapStruct由于是个代码产生器，就带来了个巨大的好处，就是这家伙是在编译阶段就会生成对应的类，所以，如果有了类似类型转换不过去的问题，直接就编译报错了，根本等不到运行才发现。这样的话，就不会造成什么损失，这真是件十分 Nice 的事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码库地址&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/mapstruct/mapstruct&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;2. Retrofit&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2265193370165746&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KSnhEmJ0hk51vGmlPGAia7cBuMJpksx3ddxxaG2lyQlMjUZesVMWOJ64E1NkRLHOrziaCj9N1af8Qow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1086&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Retrofit 是干什么的？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Retrofit 就是一套 Http 客户端，可以用来访问第三方的 Http 服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，咱们代码里想调用一个 Http 协议的 URL，就可以用它来访问这个 URL，获取响应结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么在项目里用它？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在公司里，我们有些项目有如下的特点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不是基于 Spring 的项目&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要经常访问大量的第三方 Http 服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;访问 Http 服务的模型通常是异步回调&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以前的时候，我们访问 Http 服务，都是直接用的 HttpClient。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可是吧，HttpClient 用起来实在够麻烦的。主要也存在两个问题：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.请求参数和 URL 拼接实在繁琐&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求参数和 URL 拼接实在是太烦人了。你想想，每调用一个接口，就需要自己去拼接参数，有的 URL，甚至十几二十个参数需要拼接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拼接这事儿简单、枯燥、重复，还没有技术含量，但是工作量却不小，时间真的算浪费了。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;URIBuilder uriBuilder = &lt;span&gt;new&lt;/span&gt; URIBuilder(uriBase);&lt;br/&gt;uriBuilder.setParameter(&lt;span&gt;&quot;a&quot;&lt;/span&gt;, &lt;span&gt;&quot;valuea&quot;&lt;/span&gt;);&lt;br/&gt;uriBuilder.setParameter(&lt;span&gt;&quot;b&quot;&lt;/span&gt;, &lt;span&gt;&quot;valueb&quot;&lt;/span&gt;);&lt;br/&gt;uriBuilder.setParameter(&lt;span&gt;&quot;c&quot;&lt;/span&gt;, &lt;span&gt;&quot;valuec&quot;&lt;/span&gt;);&lt;br/&gt;uriBuilder.setParameter(&lt;span&gt;&quot;d&quot;&lt;/span&gt;, &lt;span&gt;&quot;valued&quot;&lt;/span&gt;);&lt;br/&gt;uriBuilder.setParameter(&lt;span&gt;&quot;e&quot;&lt;/span&gt;, &lt;span&gt;&quot;valuee&quot;&lt;/span&gt;);&lt;br/&gt;uriBuilder.setParameter(&lt;span&gt;&quot;f&quot;&lt;/span&gt;, &lt;span&gt;&quot;valuef&quot;&lt;/span&gt;);&lt;br/&gt;uriBuilder.setParameter(&lt;span&gt;&quot;g&quot;&lt;/span&gt;, &lt;span&gt;&quot;valueg&quot;&lt;/span&gt;);&lt;br/&gt;uriBuilder.setParameter(&lt;span&gt;&quot;h&quot;&lt;/span&gt;, &lt;span&gt;&quot;valueh&quot;&lt;/span&gt;);&lt;br/&gt;uriBuilder.setParameter(&lt;span&gt;&quot;i&quot;&lt;/span&gt;, &lt;span&gt;&quot;valuei&quot;&lt;/span&gt;);&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.异步回调需要自己搞&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;异步回调这种模型不好处理，主要就是需要自己去搞线程池，还要对线程池管理，还要考虑出错的重试之类的容错问题，实在麻烦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我们就需要一套能用法简单，不用我们一直搞拼接参数，自己搞线程管理就能完成对第三方 Http 服务访问的库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实我们也想过用 Feign 这套框架的。但是，这套东西和 Spring 绑定的太紧了。如果离开 Spring，它的一些功能就没法简单的通过注解直接使用，必须自己写代码调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且，Feign 要实现异步回调方式使用，尤其在协程方面，还是需要自己开发。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候，Retrofit 就跳进了我们的选型里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Retrofit 的模型里，异步回调模型它支持的很好，我们只需要实现一个 Callable 就够了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且最清爽的是，它和 Spring 没什么关系。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Retrofit retrofit = &lt;span&gt;new&lt;/span&gt; Retrofit.Builder()&lt;br/&gt;        .baseUrl(&lt;span&gt;&quot;http://xxx.example.com/&quot;&lt;/span&gt;)&lt;br/&gt;        .build();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;BlogService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@GET&lt;/span&gt;(&lt;span&gt;&quot;blog/{id}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;Call&amp;lt;ResponseBody&amp;gt; &lt;span&gt;getBlog&lt;/span&gt;&lt;span&gt;(@Path(&lt;span&gt;&quot;id&quot;&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; id)&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;BlogService service = retrofit.create(BlogService&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;Call&amp;lt;ResponseBody&amp;gt; call = service.getBlog(&lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// 用法和OkHttp的call如出一辙,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 回调&lt;/span&gt;&lt;br/&gt;call.enqueue(&lt;span&gt;new&lt;/span&gt; Callback&amp;lt;ResponseBody&amp;gt;() {&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onResponse&lt;/span&gt;&lt;span&gt;(Call&amp;lt;ResponseBody&amp;gt; call, Response&amp;lt;ResponseBody&amp;gt; response)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            System.out.println(response.body().string());&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onFailure&lt;/span&gt;&lt;span&gt;(Call&amp;lt;ResponseBody&amp;gt; call, Throwable t)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        t.printStackTrace();&lt;br/&gt;    }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你看，只需要写上这些代码，我们就不需要操心恼人的 Url 拼接和异步回调的管理问题了。全交给了 Retrofit，着实推荐。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码库地址&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/square/retrofit&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;3. Faker&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.18406593406593408&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KSnhEmJ0hk51vGmlPGAia7cBhx1f8kKSm5BYewyLsib7J37r8wwGLIlVL9PThILUwLgUYaJKGia37NVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;728&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Faker 是干什么的？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Faker 是专门用来产生各种假数据的辅助工具库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，你想产生个和真实数据一样的有姓名、有地址的用户。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么在项目里用它？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们经常需要造数据去测试，但是，如果没有工具辅助，我们自己造数据，存在一些问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1.数据是需要格式的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多关于项目，都需要一些格式上尽量能模仿真实世界的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，国内用户的姓名，大部分都是两字、三字的姓名，叫王大，就不能叫 王da 这种。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;又比如，国内的地址是 xx市xx区xx街道xx号 这种的，就不能胡写一个几个没意义的汉字来当地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用贴近真实格式的数据，一来可以测出我们对用户的数据解析是否存在问题，二来可以测出数据库内的字段长度是否没问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，格式对产生出可靠地测试结果，是很重要的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2.数据的量大&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有的测试数据量都是上十万、百万的，这些量级的数据并不是只会产生一次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;甚至几乎每个项目，每个项目的每次测试，可能都会需要新的数据，需要能源源不断地产生出来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更甚至的是，有时候还想要根据我们的要求，在恰当的时候，产生某种关系的数据，或者以某些特定频率产生。比如，两秒后产生一次数据；比如，产生一批姓王的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上这三种要求综合起来，要是我们自己造数据，那真是要了命了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与其自己开发，不如用现成的——Faker 库被我们找到了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Faker库可以创造三百多种数据，而且还很容易对它进行扩展改造，去产生更多的贴合我们需求的数据。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Faker faker = &lt;span&gt;new&lt;/span&gt; Faker();&lt;br/&gt;&lt;br/&gt;String name = faker.name().fullName(); &lt;span&gt;// Miss Samanta Schmidt&lt;/span&gt;&lt;br/&gt;String firstName = faker.name().firstName(); &lt;span&gt;// Emory&lt;/span&gt;&lt;br/&gt;String lastName = faker.name().lastName(); &lt;span&gt;// Barton&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;String streetAddress = faker.address().streetAddress(); &lt;span&gt;// 60018 Sawayn Brooks Suite 449&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;几行代码，我们需要的一个用户就有了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用上 Faker 后，小伙伴们纷纷表示“有更多的时间摸鱼了”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码库地址&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/DiUS/java-faker&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;4. Wiremock&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5228758169934641&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KSnhEmJ0hk51vGmlPGAia7cBxTkowASXfAumC5G20fMry7hyiciaI6F3jaRfkO7AicibBtwopQibIz4HlVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;306&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Wiremock 是干什么的？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Wiremock 是一个可以模拟服务的测试框架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，你想测试访问阿里的支付相关接口的代码逻辑，就可以用它来做测试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么在项目里用它？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，我们需要调用银行接口去做资金业务，调用微信接口去做微信登录……这些调用第三方服务的测试存在一个问题：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即太过依赖对方的平台。假如对方平台限制了一些 IP，或者限制了访问频率，又或者就是服务出现了维护，都会影响我们自身的功能测试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决上述问题，在之前，我们需要自己写代码模仿第三方的接口，等我们自己全部测试没问题了，再去和第三方联调。对于这种模拟出来的接口，我们称作挡板。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可是，这种方式是个苦活，没人愿意干。因为每接入一个第三方，可能都需要做挡板。辛苦做个挡板，就是单纯为了测试。如果第三方的接口做了改造，你这边还得跟着改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家可以想想，换成你自己，你愿意做这么件事儿吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候，Wiremock 的价值就体现出来了。有了 Wiremock，挡板这种东西就再也不存在了，直接在单元测试里模拟测试即可，像这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;WireMock.stubFor(get(urlPathMatching(&lt;span&gt;&quot;/aliyun/.*&quot;&lt;/span&gt;))&lt;br/&gt;                .willReturn(aResponse()&lt;br/&gt;                        .withStatus(&lt;span&gt;200&lt;/span&gt;)&lt;br/&gt;                        .withHeader(&lt;span&gt;&quot;Content-Type&quot;&lt;/span&gt;, APPLICATION_JSON)&lt;br/&gt;                        .withBody(&lt;span&gt;&quot;\&quot;testing-library\&quot;: \&quot;WireMock\&quot;&quot;&lt;/span&gt;)));&lt;br/&gt;&lt;br/&gt;CloseableHttpClient httpClient = HttpClients.createDefault();&lt;br/&gt;HttpGet request = &lt;span&gt;new&lt;/span&gt; HttpGet(String.format(&lt;span&gt;&quot;http://localhost:%s/aliyun/wiremock&quot;&lt;/span&gt;, port));&lt;br/&gt;HttpResponse httpResponse = httpClient.execute(request);&lt;br/&gt;String stringResponse = convertHttpResponseToString(httpResponse);&lt;br/&gt;&lt;br/&gt;verify(getRequestedFor(urlEqualTo(ALIYUN_WIREMOCK_PATH)));&lt;br/&gt;assertEquals(&lt;span&gt;200&lt;/span&gt;, httpResponse.getStatusLine().getStatusCode());&lt;br/&gt;assertEquals(APPLICATION_JSON, httpResponse.getFirstHeader(&lt;span&gt;&quot;Content-Type&quot;&lt;/span&gt;).getValue());&lt;br/&gt;assertEquals(&lt;span&gt;&quot;\&quot;testing-library\&quot;: \&quot;WireMock\&quot;&quot;&lt;/span&gt;, stringResponse);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码库地址&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/wiremock/wiremock&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;结语&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然 Java 有很多遭人诟病的地方，但是 Java 最重要的优点之一，就是它的生态，有其琳琅满目的各种工具类库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;希望大家都“懒”一点，不要埋头去做无效的苦干，不要自己造轮子，你要相信：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;你遇到的问题，基本已经有很多人遇到过了，而且已经被牛人给解决了，把轮子都给你造好了。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完有收获，可以随手点个&lt;span&gt;&lt;strong&gt;在看&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你好，我是四猿外。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一家上市公司的技术总监，管理的技术团队一百余人。想了解我如何管理团队——&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247485282&amp;amp;idx=1&amp;amp;sn=f368ffae1845809ccf06859f988a88a8&amp;amp;chksm=fcd8cb23cbaf4235db644759c3d8099045d10fc952b950d429e4a5e07ed9a806fddf85c451d3&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;我，管理100多人团队的二三事&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我从一名非计算机专业的毕业生，转行到程序员，一路打拼，一路成长。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我会通过公众号，&lt;br/&gt;把自己的成长故事写成文章，&lt;br/&gt;把枯燥的技术文章写成故事。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我建了一个读者交流群，里面大部分是程序员，一起聊技术、工作、八卦。欢迎加我微信，拉你入群。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9852216748768473&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6nbNnibOq5KQibCDibpTo0kqofPehQvDDibibcb3bQUELdY3Knsl4r0RcgsV9l4icr3icmZQfaBXtSFNTxmdQlAZT1OQg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;609&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9bfd7b5d30a6f953b408a594addd1c8d</guid>
<title>K8s 云原生时代的操作系统</title>
<link>https://toutiao.io/k/o9i0zik</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h1&gt;k8s云原生时代的操作系统&lt;/h1&gt;&lt;h2&gt;一、背景&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;kvm主机扩缩容需要运维、开发协同处理效率不高，遇到节假日流量突增处理繁琐&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;kvm主机普遍cpu、内存利用率不高，造成浪费资源&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;监控有open-falcon、zabbix组件太多，需要统一到prometheus平台&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;缺乏中间件、存储的监控和告警&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;二、核心概念&lt;/h2&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.53515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UZibibiaQhjHtnMBnnXh0SMH4FVwBI7O8WWApZCGwTH6ZH2QlD43g9VkM8VPgzYia3FVDCDqzCTAasFZ4aiay7ibTQrQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;h3&gt;1、Master组件&lt;br/&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1、kube-apiserver&lt;br/&gt;   Kubernetes API，集群的统一入口，各组件协调者，以RESTful API提供接口服务，所有对象资源的增删改查和监听操作都交给APIServer处理后再提交给Etcd存储。&lt;br/&gt;2、kube-controller-manager&lt;br/&gt;   处理集群中常规后台任务，一个资源对应一个控制器，而ControllerManager就是负责管理这些控制器的。&lt;br/&gt;3、kube-scheduler&lt;br/&gt;   根据调度算法为新创建的Pod选择一个Node节点，可以任意部署,可以部署在同一个节点上,也可以部署在不同的节点上。&lt;br/&gt;4、etcd&lt;br/&gt;   分布式键值存储系统。用于保存集群状态数据，比如Pod、Service等对象信息。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;2、Node组件&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;1、kubelet&lt;br/&gt;   kubelet是Master在Node节点上的Agent，管理本机运行容器的生命周期，比如创建容器、Pod挂载数据卷、下载secret、获取容器和节点状态等工作。kubelet将每个Pod转换成一组容器。&lt;br/&gt;2、kube-proxy&lt;br/&gt;   在Node节点上实现Pod网络代理，维护网络规则和四层负载均衡工作。&lt;br/&gt;3、docker或rocket&lt;br/&gt;   容器引擎，运行容器。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;3、名词解释&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7527443805541035&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UZibibiaQhjHtnMBnnXh0SMH4FVwBI7O8WW0yLzR31IUj04QdiczEyOLaibBN89xlibjfOibUfrPkyrKyiblgicTkDatH2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1913&quot;/&gt;&lt;/p&gt;&lt;p&gt;￼&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;1、Pod&lt;br/&gt;   最小部署单元、一组容器的集合、一个Pod中的容器共享网络命名空间、 Pod是短暂的 &lt;br/&gt;2、Controllers&lt;br/&gt;   Deployment ：无状态应用部署                                          &lt;br/&gt;   DaemonSet ：确保所有Node运行同一Pod                       &lt;br/&gt;   StatefulSet ：有状态应用部署&lt;br/&gt;   Job ：一次性任务&lt;br/&gt;   Cronjob ：定时任务、更高级层次对象，部署和管理Pod&lt;br/&gt;3、Service&lt;br/&gt;   防止Pod失联&lt;br/&gt;   定义一组Pod的访问策略&lt;br/&gt;4、Label&lt;br/&gt;   标签，附加到某个资源上，用于关联对象、查询和筛选&lt;br/&gt;5、Namespaces&lt;br/&gt;   命名空间，将对象逻辑上隔离&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;4、CICD规划图&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.415234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UZibibiaQhjHtnMBnnXh0SMH4FVwBI7O8WWticHjJFGOE0lEKlK8d9IZQuibdE8JW12vMbtWbIIiao67FBqibj7cHl9OQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2560&quot;/&gt;&lt;/p&gt;&lt;p&gt;￼&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;三、踩坑经验分享&lt;/h2&gt;&lt;p&gt;1、磁盘故障导致pod被oom？&lt;/p&gt;&lt;pre&gt;&lt;code&gt;问题：广告、代理层的pod同时触发了pod的重启告警，赶紧登上服务器看看咋回事？&lt;br/&gt;&lt;br/&gt;原因：分析发现pod被oom后并未触发node节点的扩容，而是一直处于pengding的状态，这就比较奇怪了，赶紧联系ucloud得知E区的云盘出现问题，而咱们有部分node节点正好在E区，沟通得知硬盘故障pod处于pengding状态这属于k8s官方的bug并未修复。&lt;br/&gt;&lt;br/&gt;解决办法：创建node节点尽量选多个可用区分散风险。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2、滚动更新之流量的丢失？&lt;/p&gt;&lt;pre&gt;&lt;code&gt;问题：研发反馈代理层上线期间所有的pod都从consul-server注销了,从而引发服务抖动?&lt;br/&gt;&lt;br/&gt;原因：因为yaml文件没有设置钩子，滚动更新默认30秒就删除容器导致业务逻辑处理不过来，而且yaml副本数默认设置为1，导致滚动更新期间只保留1个pod可用。&lt;br/&gt;&lt;br/&gt;解决方案：修改yaml的副本数和hpa最小值一致，增加容器删除等待时间为60秒&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;钩子配置&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5627240143369175&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UZibibiaQhjHtnMBnnXh0SMH4FVwBI7O8WWpNP9iashhTK0L44JHicLP7PUSMkGIE8BPVswY0v2tKpKc58gNG3P9zXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;279&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;副本数配置&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6307901907356949&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UZibibiaQhjHtnMBnnXh0SMH4FVwBI7O8WWKChNTeyAWGrdkYicqW6qaLk6ZicRSY7L8HibvvbmezRYrBYT2cJHaGxXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;734&quot;/&gt;&lt;/p&gt;&lt;p&gt;￼&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;3、pod内的consul-client容器内存溢出，导致注册失败？&lt;/p&gt;&lt;pre&gt;&lt;code&gt;问题：收到告警，详情、流服务、代理层的qps都低于阈值，赶紧登录k8s看看出什么问题了？&lt;br/&gt;&lt;br/&gt;原因：排查发现consul-client容器内存溢出超过了200M，导致consul-client容器重启consul-id变更，导致服务用之前的consul-id无法注册到consul-server。&lt;br/&gt;&lt;br/&gt;解决方案：代理层、流服务、广告、日志上报的consul-clinet最大内存调整为500M，增加容器内存使用大于90%告警。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;内存限制&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.7246376811594203&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UZibibiaQhjHtnMBnnXh0SMH4FVwBI7O8WWMTkywdEibGhnBkibkXLFrQ8v1XpG9gRBrbYhKy7ZT8yr2cfQkCbiaLZJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;276&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;内存告警&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2450037009622502&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UZibibiaQhjHtnMBnnXh0SMH4FVwBI7O8WWTScvbcvE5z006ibOSDR7lOtYhYRokoMibnMPSR0XUsG40zN2atrhcuCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1351&quot;/&gt;&lt;/p&gt;&lt;p&gt;￼&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bae3f51fb6140426e8a7d106047e3671</guid>
<title>Java 实现 5 种负载均衡算法</title>
<link>https://toutiao.io/k/pvq2wz7</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2&gt;概念&lt;/h2&gt;&lt;p&gt;负载均衡是将客户端请求访问，通过提前约定好的规则转发给各个server。其中有好几个种经典的算法，下面我们用Java实现这几种算法。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.8311111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ExViakhaSiafEYLyaGAObOnrl34Aap2moCODRd8Er9J8Nu0gLzKPa6ibT50KfZHZUvvEfWwMwPRG79un7m6VHK1Tg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1350&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;h2&gt;轮询算法&lt;/h2&gt;&lt;p&gt;轮询算法按顺序把每个新的连接请求分配给下一个服务器，最终把所有请求平分给所有的服务器。&lt;/p&gt;&lt;p&gt;优点：绝对公平&lt;/p&gt;&lt;p&gt;缺点：无法根据服务器性能去分配，无法合理利用服务器资源。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; &lt;span&gt;com&lt;/span&gt;&lt;span&gt;.monkeyjava&lt;/span&gt;&lt;span&gt;.learn&lt;/span&gt;&lt;span&gt;.basic&lt;/span&gt;&lt;span&gt;.robin&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;com&lt;/span&gt;&lt;span&gt;.google&lt;/span&gt;&lt;span&gt;.common&lt;/span&gt;&lt;span&gt;.collect&lt;/span&gt;&lt;span&gt;.Lists&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.util&lt;/span&gt;&lt;span&gt;.HashMap&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.util&lt;/span&gt;&lt;span&gt;.List&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.util&lt;/span&gt;&lt;span&gt;.Map&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestRound&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer  index = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;List&lt;/span&gt;&amp;lt;String&amp;gt; ips = Lists.newArrayList(&lt;span&gt;&quot;192.168.1.1&quot;&lt;/span&gt;, &lt;span&gt;&quot;192.168.1.2&quot;&lt;/span&gt;, &lt;span&gt;&quot;192.168.1.3&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;roundRobin&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;String&lt;/span&gt; serverIp;&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt;(index){&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;index&lt;/span&gt; &amp;gt;= ips.size()){&lt;br/&gt;                &lt;span&gt;index&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            serverIp= ips.&lt;span&gt;get&lt;/span&gt;(index);&lt;br/&gt;            &lt;span&gt;//轮询+1&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;index&lt;/span&gt; ++;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; serverIp;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        TestRound &lt;span&gt;test&lt;/span&gt;RoundRobin =new TestRound();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt; &lt;span&gt;10&lt;/span&gt; ;i++){&lt;br/&gt;            String serverIp= &lt;span&gt;test&lt;/span&gt;RoundRobin.roundRobin();&lt;br/&gt;            &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.out&lt;/span&gt;&lt;span&gt;.println&lt;/span&gt;(&lt;span&gt;serverIp&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;输出结果:&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h2&gt;加权轮询法&lt;/h2&gt;&lt;p&gt;该算法中，每个机器接受的连接数量是按权重比例分配的。这是对普通轮询算法的改进，比如你可以设定：第三台机器的处理能力是第一台机器的两倍，那么负载均衡器会把两倍的连接数量分配给第3台机器，轮询可以将请求顺序按照权重分配到后端。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; &lt;span&gt;com&lt;/span&gt;&lt;span&gt;.monkeyjava&lt;/span&gt;&lt;span&gt;.learn&lt;/span&gt;&lt;span&gt;.basic&lt;/span&gt;&lt;span&gt;.robin&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.util&lt;/span&gt;&lt;span&gt;.ArrayList&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.util&lt;/span&gt;&lt;span&gt;.HashMap&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.util&lt;/span&gt;&lt;span&gt;.List&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.util&lt;/span&gt;&lt;span&gt;.Map&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestWeight&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Integer index = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    static &lt;span&gt;Map&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, Integer&amp;gt; ipMap=&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&lt;span&gt;String&lt;/span&gt;, Integer&amp;gt;(&lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 1.map, key-ip,value-权重&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;ipMap&lt;/span&gt;&lt;span&gt;.put&lt;/span&gt;(&quot;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&quot;, 1);&lt;br/&gt;        &lt;span&gt;ipMap&lt;/span&gt;&lt;span&gt;.put&lt;/span&gt;(&quot;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&quot;, 2);&lt;br/&gt;        &lt;span&gt;ipMap&lt;/span&gt;&lt;span&gt;.put&lt;/span&gt;(&quot;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&quot;, 4);&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt; &lt;span&gt;getServerIpByWeight&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; ips = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt;(&lt;span&gt;32&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;Map&lt;/span&gt;.Entry&amp;lt;&lt;span&gt;String&lt;/span&gt;, Integer&amp;gt; entry : ipMap.entrySet()) {&lt;br/&gt;            &lt;span&gt;String&lt;/span&gt; ip = entry.getKey();&lt;br/&gt;            &lt;span&gt;Integer&lt;/span&gt; weight = entry.getValue();&lt;br/&gt;            &lt;span&gt;// 根据权重不同，放入list 中的数量等同于权重，轮询出的的次数等同于权重&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; ipCount =&lt;span&gt;0&lt;/span&gt;; ipCount &amp;lt; weight; ipCount++) {&lt;br/&gt;                &lt;span&gt;ips&lt;/span&gt;&lt;span&gt;.add&lt;/span&gt;(&lt;span&gt;ip&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ips;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;weightRobin&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        List&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; ips = &lt;span&gt;this&lt;/span&gt;.getServerIpByWeight();&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;index&lt;/span&gt; &amp;gt;= ips.size()){&lt;br/&gt;            &lt;span&gt;index&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        String serverIp= ips.&lt;span&gt;get&lt;/span&gt;(index);&lt;br/&gt;        &lt;span&gt;index&lt;/span&gt; ++;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;  serverIp;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        TestWeight &lt;span&gt;test&lt;/span&gt;WeightRobin=new TestWeight();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt;0&lt;/span&gt;;i&amp;lt; &lt;span&gt;10&lt;/span&gt; ;i++){&lt;br/&gt;            String server=&lt;span&gt;test&lt;/span&gt;WeightRobin.weightRobin();&lt;br/&gt;            &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.out&lt;/span&gt;&lt;span&gt;.println&lt;/span&gt;(&lt;span&gt;server&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;输出结果:&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h2&gt;加权随机法&lt;/h2&gt;&lt;p&gt;获取带有权重的随机数字，随机这种东西，不能看绝对，只能看相对，我们不用index 控制下标进行轮询，只用random 进行随机取ip，即实现算法。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; &lt;span&gt;com&lt;/span&gt;&lt;span&gt;.monkeyjava&lt;/span&gt;&lt;span&gt;.learn&lt;/span&gt;&lt;span&gt;.basic&lt;/span&gt;&lt;span&gt;.robin&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java.util.*&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestRandomWeight&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;    static &lt;span&gt;Map&lt;/span&gt;&amp;lt;&lt;span&gt;String&lt;/span&gt;, Integer&amp;gt; ipMap=&lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&lt;span&gt;String&lt;/span&gt;, Integer&amp;gt;(&lt;span&gt;16&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// 1.map, key-ip,value-权重&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;ipMap&lt;/span&gt;&lt;span&gt;.put&lt;/span&gt;(&quot;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&quot;, 1);&lt;br/&gt;        &lt;span&gt;ipMap&lt;/span&gt;&lt;span&gt;.put&lt;/span&gt;(&quot;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&quot;, 2);&lt;br/&gt;        &lt;span&gt;ipMap&lt;/span&gt;&lt;span&gt;.put&lt;/span&gt;(&quot;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&quot;, 4);&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;String&amp;gt; &lt;span&gt;getServerIpByWeight&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;        List&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; ips = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt;(&lt;span&gt;32&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;Map&lt;/span&gt;.Entry&amp;lt;&lt;span&gt;String&lt;/span&gt;, Integer&amp;gt; entry : ipMap.entrySet()) {&lt;br/&gt;            &lt;span&gt;String&lt;/span&gt; ip = entry.getKey();&lt;br/&gt;            &lt;span&gt;Integer&lt;/span&gt; weight = entry.getValue();&lt;br/&gt;            &lt;span&gt;// 根据权重不同，放入list 中的数量等同于权重，轮询出的的次数等同于权重&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; ipCount =&lt;span&gt;0&lt;/span&gt;; ipCount &amp;lt; weight; ipCount++) {&lt;br/&gt;                &lt;span&gt;ips&lt;/span&gt;&lt;span&gt;.add&lt;/span&gt;(&lt;span&gt;ip&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; ips;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;randomWeightRobin&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        List&amp;lt;&lt;span&gt;String&lt;/span&gt;&amp;gt; ips = &lt;span&gt;this&lt;/span&gt;.getServerIpByWeight();&lt;br/&gt;        &lt;span&gt;//循环随机数&lt;/span&gt;&lt;br/&gt;        Random random=&lt;span&gt;new&lt;/span&gt; Random();&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; =random.nextInt(ips.size());&lt;br/&gt;        String serverIp = ips.&lt;span&gt;get&lt;/span&gt;(index);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;  serverIp;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        TestRandomWeight &lt;span&gt;test&lt;/span&gt;RandomWeightRobin=new TestRandomWeight();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i =&lt;span&gt;0&lt;/span&gt;;i&amp;lt; &lt;span&gt;10&lt;/span&gt; ;i++){&lt;br/&gt;            String server= &lt;span&gt;test&lt;/span&gt;RandomWeightRobin.randomWeightRobin();&lt;br/&gt;            &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.out&lt;/span&gt;&lt;span&gt;.println&lt;/span&gt;(&lt;span&gt;server&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;输出结果:&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h2&gt;随机法&lt;/h2&gt;&lt;p&gt;负载均衡方法随机的把负载分配到各个可用的服务器上，通过随机数生成算法选取一个服务器，这种实现算法最简单，随之调用次数增大，这种算法可以达到每台服务器的请求量接近于平均。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; &lt;span&gt;com&lt;/span&gt;&lt;span&gt;.monkeyjava&lt;/span&gt;&lt;span&gt;.learn&lt;/span&gt;&lt;span&gt;.basic&lt;/span&gt;&lt;span&gt;.robin&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;com&lt;/span&gt;&lt;span&gt;.google&lt;/span&gt;&lt;span&gt;.common&lt;/span&gt;&lt;span&gt;.collect&lt;/span&gt;&lt;span&gt;.Lists&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.util&lt;/span&gt;&lt;span&gt;.List&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.util&lt;/span&gt;&lt;span&gt;.Random&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestRandom&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;List&lt;/span&gt;&amp;lt;String&amp;gt; ips = Lists.newArrayList(&lt;span&gt;&quot;192.168.1.1&quot;&lt;/span&gt;, &lt;span&gt;&quot;192.168.1.2&quot;&lt;/span&gt;, &lt;span&gt;&quot;192.168.1.3&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;randomRobin&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//随机数&lt;/span&gt;&lt;br/&gt;        Random random=&lt;span&gt;new&lt;/span&gt; Random();&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; =random.nextInt(ips.size());&lt;br/&gt;        String serverIp= ips.&lt;span&gt;get&lt;/span&gt;(index);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;  serverIp;&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        TestRandom &lt;span&gt;test&lt;/span&gt;RandomdRobin =new TestRandom();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=&lt;span&gt;0&lt;/span&gt;;i&amp;lt; &lt;span&gt;10&lt;/span&gt; ;i++){&lt;br/&gt;            String serverIp= &lt;span&gt;test&lt;/span&gt;RandomdRobin.randomRobin();&lt;br/&gt;            &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.out&lt;/span&gt;&lt;span&gt;.println&lt;/span&gt;(&lt;span&gt;serverIp&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;输出&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h2&gt;IP_Hash算法&lt;/h2&gt;&lt;p&gt;hash(ip)%N算法，通过一种散列算法把客户端来源IP根据散列取模算法将请求分配到不同的服务器上&lt;/p&gt;&lt;p&gt;优点：保证了相同客户端IP地址将会被哈希到同一台后端服务器，直到后端服务器列表变更。根据此特性可以在服务消费者与服务提供者之间建立有状态的session会话&lt;/p&gt;&lt;p&gt;缺点: 如果服务器进行了下线操作，源IP路由的服务器IP就会变成另外一台，如果服务器没有做session 共享话，会造成session丢失。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; &lt;span&gt;com&lt;/span&gt;&lt;span&gt;.monkeyjava&lt;/span&gt;&lt;span&gt;.learn&lt;/span&gt;&lt;span&gt;.basic&lt;/span&gt;&lt;span&gt;.robin&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;com&lt;/span&gt;&lt;span&gt;.google&lt;/span&gt;&lt;span&gt;.common&lt;/span&gt;&lt;span&gt;.collect&lt;/span&gt;&lt;span&gt;.Lists&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;java&lt;/span&gt;&lt;span&gt;.util&lt;/span&gt;&lt;span&gt;.List&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestIpHash&lt;/span&gt; {&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;List&lt;/span&gt;&amp;lt;String&amp;gt; ips = Lists.newArrayList(&lt;span&gt;&quot;192.168.1.1&quot;&lt;/span&gt;, &lt;span&gt;&quot;192.168.1.2&quot;&lt;/span&gt;, &lt;span&gt;&quot;192.168.1.3&quot;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;ipHashRobin&lt;/span&gt;&lt;span&gt;(String clientIp)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        int &lt;span&gt;hash&lt;/span&gt;Code=clientIp.hashCode();&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; serverListsize=ips.size();&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; = hashCode%serverListsize;&lt;br/&gt;        String serverIp= ips.&lt;span&gt;get&lt;/span&gt;(index);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;  serverIp;&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        TestIpHash &lt;span&gt;test&lt;/span&gt;IpHash =new TestIpHash();&lt;br/&gt;        String servername= &lt;span&gt;test&lt;/span&gt;IpHash.ipHashRobin(&lt;span&gt;&quot;192.168.88.2&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;System&lt;/span&gt;&lt;span&gt;.out&lt;/span&gt;&lt;span&gt;.println&lt;/span&gt;(&lt;span&gt;servername&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;输出结果&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;&quot;&gt;&lt;code&gt;192&lt;span&gt;.168&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;span&gt;.3&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;每次运行结果都一样&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA4Mzk3NDAyOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/ExViakhaSiafF9PQBaFnQkD6AO43WQdToSxBpzal8BoephuEeVU2X9rcGWwiavCibNLibQ4ib454XU0aTEibqx8y0o5yA/0?wx_fmt=png&quot; data-nickname=&quot;猴哥说Java&quot; data-alias=&quot;MonkeyTalkProgram&quot; data-signature=&quot;互联网码农一枚，Java 技术爱好者，喜欢分享交流&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fcad1337192e95e7de4626fb255d0bbe</guid>
<title>领域驱动设计下的服务高可用设计</title>
<link>https://toutiao.io/k/avyw7bz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;td class=&quot;blog_detail&quot;&gt;
&lt;input id=&quot;js_detail&quot; type=&quot;hidden&quot; value=&quot;我们知道领域驱动设计已经逐步应用落地，系统架构设计在后微服务时代，更快速的向DDD演进，微服务架构的设计面向系统维度的拆分，实现快速的独立部署，解决DevOps的效能问题，进入后微服务时代，领域模型的理解逐步深入，简单的设计微服务架构会使得系统过于松散，尤其在服务的高可用设计上，领域驱动设计的边界如何考量和把控，成为我们后微服务架构设计必须考虑的要素。&amp;#10;&amp;#10;今天的话题是讨论领域驱动设计下的服务高可用设计，首先举个例子，A调用B，B的服务高可用如何设计？&amp;#10;&amp;#10;方案一，A与B实现1:1的服务保障能力，RPC调用的SLA保障；&amp;#10;&amp;#10;方案二，A与B通过共享资源，降低RPC损耗，基于共享资源实现SLA保障；&amp;#10;&amp;#10;方案三，B提供二方包，封装RPC调用和存储资源，提供A本地调用的SLA保障。&amp;#10;&amp;#10;![](http://misc.linkedkeeper.com/misc/img/blog/202109/linkedkeeper0_63334c66-8187-431b-95c6-c7d9da964ed7.jpg)&amp;#10;&amp;#10;如何进行三种方案的技术选型？&amp;#10;&amp;#10;方案一，优点是架构简单，功能松耦合，领域定义清晰；缺点是1:1流量的服务保障，B服务的容器资源、调用性能、稳定性等衍生的稳定性风险，会有较大的高可用设计成本，尤其是若B提供的是一些配置数据，这个架构设计的性价比较低。&amp;#10;&amp;#10;方案二，优点是架构不复杂，功能清晰，领域定义明确，解决了静态数据1:1流量调度的弊端；缺点是A服务依赖了B服务的存储资源，在一定程度上形成了耦合，这体现在变更后的整体发布。这个架构设计降低了高可用设计的成本，但是随着时间推移A和B会演进成大泥潭。&amp;#10;&amp;#10;方案三，优点是功能清晰，领域定义明确，解决了A依赖B的耦合问题；缺点是架构复杂，B提供的Jar包变更仍需要A发布，存在一定的耦合。若A提供SPI的服务能力，成本会降低，但是A的高可用设计成本会加大。这个架构设计在选型时需慎重。&amp;#10;&amp;#10;&amp;lt;font size=1&amp;gt;微服务的九个核心特征：围绕业务能力构建，分散治理，通过服务来实现独立自治的组件，产品化思维，数据去中心化，强终端弱管道，容错性设计，演进式设计，基础设施自动化。&amp;lt;/font&amp;gt;&amp;#10;&amp;#10;其中，**通过服务来实现独立自治的组件**，微服务之所以强调通过服务Service而不是类库Library来构建组建，是因为类库在编译期静态连接到程序里，通过本地调用来提供功能，而服务时通过进程外调度，通过远程调度来提供服务。尽管远程服务有更高昂的调用成本，但这是为组件带来自治与隔离能力的必要代价。—— 摘自《凤凰架构》&amp;#10;&amp;#10;那么，基于微服务的设计理论基础，以及通过实践得出效果来看，绝大多数的业务架构都应该基于通过服务Service的模式进行设计，那么这就涉及到高可用的设计归属域的边界问题？就我个人而言，A服务已经完成领域的建模，那么高可用的设计则归属A服务，并与B确认服务的SLA。&amp;#10;&amp;#10;其中，**数据去中心化**，微服务明确提倡数据应该按领域分散管理、更新、维护、存储，那么通过共享资源的架构设计，这是否违背了微服务的设计原则？共享资源使得领域都必须修改和映射到同一个实体之中，这很可能使不同服务之间相互影响而丧失独立性。除此之外，共享资源带来的潜在隐患，B若是Ops系统，其发生问题可能影响到核心链路上的系统，比如A。&amp;#10;&amp;#10;那么，回到最开始的话题，A调用B，B的高可用设计就有了设计的变化。&amp;#10;&amp;#10;![](http://misc.linkedkeeper.com/misc/img/blog/202109/linkedkeeper0_dc2297ab-9fe5-46a9-becb-fb209f83c34d.jpg)&amp;#10;&amp;#10;如何进行三个方案的调整？&amp;#10;&amp;#10;方案二，共享缓存的架构设计，会造成A与B之间相互影响，进而调成独立缓存的架构设计。A与B共享缓存的设计，常见在系统已拆分，但组织架构未拆分的情况，这隐藏的约束是共享缓存专门服务于该业务，而非为领域服务。&amp;#10;&amp;#10;方案三，B提供二方包嵌入A，会造成A与B之间的相互影响，进而调整对B服务进行架构拆分的设计。这其实是领域设计已经逐步演进成需要对B服务进行垂直拆分的诉求，这也是B Jar出现的原罪，由此更应对B进行领域内的系统拆分。&amp;#10;&amp;#10;综述，今天讨论的内容就结束了，主要讨论了在分布式架构设计中服务间调用的高可用设计，以上不同的方案都有过实践，虽说代码写在哪里都可以，但领域驱动设计的愿景就是降低软件架构的设计复杂度，否则，终将是行走的恐龙巨兽。&quot;/&gt;
&lt;p id=&quot;markdown_detail&quot;/&gt;
&lt;br/&gt;
&lt;p&gt;本文受原创保护，未经作者授权，禁止转载。 linkedkeeper.com (文／然行)  &lt;a href=&quot;/site/copyright.action&quot;&gt;©著作权归作者所有&lt;/a&gt;&lt;/p&gt;

&lt;/td&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>85a3c60e64edc46c47fecd8225cfdd6b</guid>
<title>Gin 源码阅读（三）：Gin 路由的实现剖析</title>
<link>https://toutiao.io/k/ryqdil2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;hi, 大家好，我是 hhf。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;往期回顾：&lt;/p&gt;&lt;section&gt;&lt;span&gt;上面两篇文章基本讲清楚了 Web Server 如何接收客户端请求，以及如何将请求流转到 gin 的逻辑。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;gin 原理剖析说到这里，就完全进入 gin 的逻辑里面了。gin 已经拿到 http 请求了，第一件重要的事情肯定就是重写&lt;strong&gt;路由&lt;/strong&gt;了，所以本节内容主要是分析 gin 的路由相关的内容。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实 gin 的路由也不是完全自己写的，其实很重要的一部分代码是使用的开源的 julienschmidt/httprouter，当然 gin 也添加了部分自己独有的功能，如：routergroup。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是路由？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个其实挺容易理解的，就是根据不同的 URL 找到对应的处理函数即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前业界 Server 端 API 接口的设计方式一般是遵循 RESTful 风格的规范。当然我也见过某些大公司为了降低开发人员的心智负担和学习成本，接口完全不区分 GET/POST/DELETE 请求，完全靠接口的命名来表示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个简单的例子，如：&quot;删除用户&quot;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;RESTful:    DELETE  /user/hhf&lt;br/&gt;No RESTful: GET     /deleteUser?name=hhf&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种 No RESTful 的方式，有的时候确实减少一些沟通问题和学习成本，但是只能内部使用了。这种不区分 GET/POST 的 Web 框架一般设计的会比较灵活，但是开发人员水平参差不齐，会导致出现很多“接口毒瘤”，等你发现的时候已经无可奈何了，如下面这些接口：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GET /selectUserList?userIds=[1,2,3] -&amp;gt; 参数是否可以是数组？&lt;br/&gt;GET /getStudentlist?skuIdCntMap={&lt;span&gt;&quot;200207366&quot;&lt;/span&gt;:1} -&amp;gt; 参数是否可以是字典？&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的接口设计会导致开源的框架都是解析不了的，只能自己手动一层一层 decode 字符串，这里就不再详细铺开介绍了，等下一节说到 gin Bind 系列函数时再详细说一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续回到上面 RESTful 风格的接口上面来，拿下面这些简单的请求来说：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GET    /user/{userID} HTTP/1.1&lt;br/&gt;POST   /user/{userID} HTTP/1.1&lt;br/&gt;PUT    /user/{userID} HTTP/1.1&lt;br/&gt;DELETE /user/{userID} HTTP/1.1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是比较规范的 RESTful API设计，分别代表：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取 userID 的用户信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更新 userID 的用户信息（当然还有其 json body，没有写出来）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建 userID 的用户（当然还有其 json body，没有写出来）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;删除 userID 的用户&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到同样的 URI，不同的请求 Method，最终其他代表的要处理的事情也完全不一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里你可以思考一下，假如让你来设计这个路由，要满足上面的这些功能，你会如何设计呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;gin 路由设计&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何设计不同的 Method ?&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的介绍，已经知道 RESTful 是要区分方法的，不同的方法代表意义也完全不一样，gin 是如何实现这个的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实很简单，不同的方法就是一棵路由树，所以当 gin 注册路由的时候，会根据不同的 Method 分别注册不同的路由树。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GET    /user/{userID} HTTP/1.1&lt;br/&gt;POST   /user/{userID} HTTP/1.1&lt;br/&gt;PUT    /user/{userID} HTTP/1.1&lt;br/&gt;DELETE /user/{userID} HTTP/1.1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如这四个请求，分别会注册四颗路由树出来。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(engine *Engine)&lt;/span&gt; &lt;span&gt;addRoute&lt;/span&gt;&lt;span&gt;(method, path &lt;span&gt;string&lt;/span&gt;, handlers HandlersChain)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;//....&lt;/span&gt;&lt;br/&gt;    root := engine.trees.get(method)&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; root == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;        root = &lt;span&gt;new&lt;/span&gt;(node)&lt;br/&gt;        root.fullPath = &lt;span&gt;&quot;/&quot;&lt;/span&gt;&lt;br/&gt;        engine.trees = &lt;span&gt;append&lt;/span&gt;(engine.trees, methodTree{method: method, root: root})&lt;br/&gt;    }&lt;br/&gt;    root.addRoute(path, handlers)&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实代码也很容易看懂，&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;拿到一个 method 方法时，去 trees slice 中遍历&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果 trees slice 存在这个 method, 则这个URL对应的 handler 直接添加到找到的路由树上&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果没有找到，则重新创建一颗新的方法树出来, 然后将 URL对应的 handler 添加到这个路由 树上&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;gin 路由的注册过程&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    r := gin.Default()&lt;br/&gt;    r.GET(&lt;span&gt;&quot;/ping&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(c *gin.Context)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        c.JSON(&lt;span&gt;200&lt;/span&gt;, gin.H{&lt;br/&gt;            &lt;span&gt;&quot;message&quot;&lt;/span&gt;: &lt;span&gt;&quot;pong&quot;&lt;/span&gt;,&lt;br/&gt;        })&lt;br/&gt;    })&lt;br/&gt;    r.Run() &lt;span&gt;// listen and serve on 0.0.0.0:8080&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段简单的代码里，r.Get 就注册了一个路由 /ping 进入 GET tree 中。这是最普通的，也是最常用的注册方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过上面这种写法，一般都是用来测试的，正常情况下我们会将 handler 拿到 Controller 层里面去，注册路由放在专门的 route 管理里面，这里就不再详细拓展，等后面具体说下 gin 的架构分层设计。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//controller/somePost.go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;SomePostFunc&lt;/span&gt;&lt;span&gt;(ctx *gin.Context)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// do something&lt;/span&gt;&lt;br/&gt;    context.String(http.StatusOK, &lt;span&gt;&quot;some post done&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;```go&lt;br/&gt;// route.go&lt;br/&gt;router.POST(&lt;span&gt;&quot;/somePost&quot;&lt;/span&gt;, controller.SomePostFunc)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用 RouteGroup&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;v1 := router.Group(&lt;span&gt;&quot;v1&quot;&lt;/span&gt;)&lt;br/&gt;{&lt;br/&gt;    v1.POST(&lt;span&gt;&quot;login&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(context *gin.Context)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        context.String(http.StatusOK, &lt;span&gt;&quot;v1 login&quot;&lt;/span&gt;)&lt;br/&gt;    })&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;RouteGroup 是非常重要的功能，举个例子：一个完整的 server 服务，url 需要分为&lt;strong&gt;鉴权接口&lt;/strong&gt;和&lt;strong&gt;非鉴权接口&lt;/strong&gt;，就可以使用 RouteGroup 来实现。其实最常用的，还是用来区分接口的版本升级。这些操作, 最终都会在反应到gin的路由树上&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;gin 路由的具体实现&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    r := gin.Default()&lt;br/&gt;    r.GET(&lt;span&gt;&quot;/ping&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(c *gin.Context)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;        c.JSON(&lt;span&gt;200&lt;/span&gt;, gin.H{&lt;br/&gt;            &lt;span&gt;&quot;message&quot;&lt;/span&gt;: &lt;span&gt;&quot;pong&quot;&lt;/span&gt;,&lt;br/&gt;        })&lt;br/&gt;    })&lt;br/&gt;    r.Run() &lt;span&gt;// listen and serve on 0.0.0.0:8080&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是从这个简单的例子入手。我们只需要弄清楚下面三个问题即可：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;URL-&amp;gt;ping 放在哪里了？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;handler-&amp;gt; 放在哪里了？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;URL 和 handler 是如何关联起来的？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. GET/POST/DELETE/..的最终归宿&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(group *RouterGroup)&lt;/span&gt; &lt;span&gt;GET&lt;/span&gt;&lt;span&gt;(relativePath &lt;span&gt;string&lt;/span&gt;, handlers ...HandlerFunc)&lt;/span&gt; &lt;span&gt;IRoutes&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; group.handle(http.MethodGet, relativePath, handlers)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在调用&lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;GET&lt;/code&gt;, &lt;code&gt;HEAD&lt;/code&gt;等路由HTTP相关函数时, 会调用&lt;code&gt;handle&lt;/code&gt;函数。handle 是 gin 路由的统一入口。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// routergroup.go:L72-77&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(group *RouterGroup)&lt;/span&gt; &lt;span&gt;handle&lt;/span&gt;&lt;span&gt;(httpMethod, relativePath &lt;span&gt;string&lt;/span&gt;, handlers HandlersChain)&lt;/span&gt; &lt;span&gt;IRoutes&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    absolutePath := group.calculateAbsolutePath(relativePath)&lt;br/&gt;    handlers = group.combineHandlers(handlers)&lt;br/&gt;    group.engine.addRoute(httpMethod, absolutePath, handlers)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; group.returnObj()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 生成路由树&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面考虑一个情况，假设有下面这样的路由，你会怎么设计这棵路由树？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GET /abc &lt;br/&gt;GET /abd&lt;br/&gt;GET /af&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然最简单最粗暴的就是每个字符串占用一个树的叶子节点，不过这种设计会带来的问题：&lt;span&gt;占用内存会升高，我们看到 abc, abd, af 都是用共同的前缀的，如果能共用前缀的话，是可以省内存空间的。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;gin 路由树是一棵前缀树. 我们前面说过 gin 的每种方法(POST, GET ...)都有自己的一颗树，当然这个是根据你注册路由来的，并不是一上来把每种方式都注册一遍。gin 每棵路由大概是下面的样子&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7195402298850575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/picLDrXZzloYFhKhGxcP7f4XYmyeYqn6NhvA7lkv5jwxJFWhv8MGRibVTbasVOEp1BGUP4rzOM4nCmBzC8YjzJvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;435&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个流程的代码太多，这里就不再贴出具体代码里，有兴趣的同学可以按照这个思路看下去即可。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. handler 与 URL 关联&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; node &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    path      &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;    indices   &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;    wildChild &lt;span&gt;bool&lt;/span&gt;&lt;br/&gt;    nType     nodeType&lt;br/&gt;    priority  &lt;span&gt;uint32&lt;/span&gt;&lt;br/&gt;    children  []*node &lt;span&gt;// child nodes, at most 1 :param style node at the end of the array&lt;/span&gt;&lt;br/&gt;    handlers  HandlersChain&lt;br/&gt;    fullPath  &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;node 是路由树的整体结构&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;children 就是一颗树的叶子结点。每个路由的去掉前缀后，都被分布在这些 children 数组里&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;path 就是当前叶子节点的最长的前缀&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;handlers 里面存放的就是当前叶子节点对应的路由的处理函数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;当收到客户端请求时，如何找到对应的路由的handler？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《gin 源码阅读(2) - http请求是如何流入gin的?》第二篇说到 net/http 非常重要的函数 ServeHTTP，当 server 收到请求时，必然会走到这个函数里。由于 gin 实现这个 ServeHTTP，所以流量就转入 gin 的逻辑里面。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// gin.go:L439-443&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(engine *Engine)&lt;/span&gt; &lt;span&gt;ServeHTTP&lt;/span&gt;&lt;span&gt;(w http.ResponseWriter, req *http.Request)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    c := engine.pool.Get().(*Context)&lt;br/&gt;    c.writermem.reset(w)&lt;br/&gt;    c.Request = req&lt;br/&gt;    c.reset()&lt;br/&gt;&lt;br/&gt;    engine.handleHTTPRequest(c)&lt;br/&gt;&lt;br/&gt;    engine.pool.Put(c)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，当 gin 收到客户端的请求时, 第一件事就是去路由树里面去匹配对应的 URL，找到相关的路由, 拿到相关的处理函数。其实这个过程就是 handleHTTPRequest 要干的事情。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(engine *Engine)&lt;/span&gt; &lt;span&gt;handleHTTPRequest&lt;/span&gt;&lt;span&gt;(c *Context)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;    t := engine.trees&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; i, tl := &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;len&lt;/span&gt;(t); i &amp;lt; tl; i++ {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; t[i].method != httpMethod {&lt;br/&gt;            &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        root := t[i].root&lt;br/&gt;        &lt;span&gt;// Find route in tree&lt;/span&gt;&lt;br/&gt;        value := root.getValue(rPath, c.params, unescape)&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; value.params != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;            c.Params = *value.params&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; value.handlers != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;            c.handlers = value.handlers&lt;br/&gt;            c.fullPath = value.fullPath&lt;br/&gt;            c.Next()&lt;br/&gt;            c.writermem.WriteHeaderNow()&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; httpMethod != &lt;span&gt;&quot;CONNECT&quot;&lt;/span&gt; &amp;amp;&amp;amp; rPath != &lt;span&gt;&quot;/&quot;&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; value.tsr &amp;amp;&amp;amp; engine.RedirectTrailingSlash {&lt;br/&gt;                redirectTrailingSlash(c)&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; engine.RedirectFixedPath &amp;amp;&amp;amp; redirectFixedPath(c, root, engine.RedirectFixedPath) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;      &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  &lt;span&gt;// ...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从代码上看这个过程其实也很简单：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;遍历所有的路由树，找到对应的方法的那棵树&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;匹配对应的路由&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;找到对应的 handler&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到这里，基本上把 gin 路由的整个流程说清楚了，不过关于路由树的详细实现说的比较笼统，欢迎有兴趣的同学入群详聊（加我好友，我拉你入群）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写文章不易，如果你觉得本篇文章还不错，请大家帮忙 &lt;span&gt;&lt;strong&gt;点赞、&lt;/strong&gt;在看、&lt;/span&gt;&lt;span&gt;分享&lt;/span&gt;，感谢感谢。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欢迎关注公众号。更多学习资料分享，关注公众号回复指令：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;回复 0，获取 《Go 面经》&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;回复 1，获取 《Go 源码流程图》&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.30918595967139656&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/picLDrXZzloYFhKhGxcP7f4XYmyeYqn6NkoyRwEjNdWTPChw2JTzZEXQo0JBKSF8KU3AQRS0bd18TjKDqJPg7jA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2678&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>