<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>4a225e2d07d887526ac95e9ada8924b5</guid>
<title>面试过 200 人的经验，都在这里了 | 码农周刊第 325 期</title>
<link>https://toutiao.io/k/xvysg5s</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;面试过 200 人的经验，都在这里了 | 码农周刊第 325 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第325期（2020-11-25）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=325&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3250&quot; target=&quot;_blank&quot;&gt;薪资翻番如何实现？程序员的涨薪秘诀&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=325&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3250&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_321.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=325&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;业界实战&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;相比 cocos2d 引擎有着更低的入门门槛和维护成本，为复杂动画的实现提供了一种全新的方式，新的复杂动画开发将会变得更加简单高效。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;让您享受极简编程体验，快速访问支付宝开放平台开放的各项核心能力。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;一个不错的 Python 学习教程，30 天循序渐进地教你学会 Python。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;白皮书从技术、市场、趋势、挑战等多维度，对我国开源产业生态进行了全面、深度的剖析，指出了我国开源产业发展的几大重要趋势。&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        
        &lt;p&gt;经验总结&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;一步步教你&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        
        &lt;p&gt;供参考&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;收藏吧&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;实用&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;使用方便&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;一步步教你&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;良心教程&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;你怎么看？&lt;/p&gt;
        
        &lt;p&gt;深入研究&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;技术总结，经验分享&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 451179 即可&lt;/p&gt;
        
        &lt;p&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 429587 即可&lt;/p&gt;
        
        &lt;p&gt;分享计算机视觉与机器学习技术的最前沿&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 359575 即可&lt;/p&gt;
        
        &lt;p&gt;聚焦基础架构和Linux。十年架构，日百亿流量，与你探讨高并发世界，给你不一样的味道。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 351247 即可&lt;/p&gt;
        
        &lt;p&gt;学习就是不停的积累&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 24912 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;本手册以开发工程师为中心视角，划分为单元测试、安全规约、MySQL 数据库、工程结构等七个维度，相应的扩展解释和说明、正例和反例，全面、立体、形象地帮助开发工程师成长。欢迎到&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;兑换阅读。&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;个人经历&lt;/p&gt;
        
        &lt;p&gt;一直被追赶，从未被超越&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>14b963d34214dbdb0fe0ddfa42649d55</guid>
<title>CTO 怒了：“如果中台不省钱，我建个屁中台啊！”</title>
<link>https://toutiao.io/k/batmypd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;span&gt;点击“&lt;/span&gt;&lt;span&gt;技术领导力&lt;/span&gt;&lt;span&gt;”关注&lt;/span&gt;&lt;span&gt;∆&lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt;每天&lt;/span&gt;&lt;span&gt;早上8:30&lt;/span&gt;&lt;span&gt;推送&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;作者| Mr.K   整理| Emma&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;来源| 技术领导力(ID：jishulingdaoli)&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;“妈的，A厂说的什么玩意儿，老子听不懂！你就告诉我，这次中台建设，投资多少钱，投了这些钱后，以后的信息化系统是否可以集约化建设？大概平均每个系统能省多少钱？” L总参观完杭州的A厂、深圳的T厂，一脸懵逼地对小M说。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M急忙回复领导：“中台省钱这个事，它可以当成结果，但千万不能当成目标。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;L总一听又怒了：“我建中台的目的就是为了省钱，公司一年信息化开支几千万上亿，如果中台不省钱，我建个屁中台啊！你还是没搞明白中台，再回去研究！”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M是我的一位读者，他是某大型国企的中台项目经理，今年的工作目标就是规划和落地中台项目。L总是该国企IT部的负责人，相当于CTO。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M跟我吐槽了一个小时，我大概知道他们中台项目的问题所在了，先来听听小M公司上中台的故事。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6633333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sqibwUCydDhzLd7hhMrVTggQN9SbiasvsLGlc322Xx2pmCpQ6oyVWh6BChRctiaibhEreqY4qu5qamWUxtZJPicGpdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;01&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;云平台专家，初露锋芒&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M之前一直从事企业信息化改革工作，帮助过几家公司实现了云化，积累了一定的项目经验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span&gt;L总所在的企业，信息系统架构老旧，经过10几年的发展，形成了几十个大“烟囱”系统，数据的互联互通是难题，严重制约了业务的发展，让集团大领导非常不满。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如客服系统、BOSS系统（Business &amp;amp; Operation Support System），数据是不联通的，市场人员和客服人员工作难以协同，售后都跟不上，更不用说客户关系的主动维护了，这直接导致了客户流失率高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是L总聘用了小M，先是任命他为“基础资源整合”负责人，具体干什么呢？就是建云平台，把集团各部门的服务器、网络资源统一管理，提高硬件使用率，降低成本。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个事情，目标明确，又是小M经验所在，小M思路也很清晰：新系统全部上云，老旧系统改造迁移上云，实在无法改造迁云的系统，继续运行，但各部门得制定未来的业务升级计划，逐步实现业务迁云。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不到一年的时间就理顺了，L总对小M的工作表现非常满意，似乎觉得可以委以重任了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M是个有理想的年轻人，他的理想就是三十岁的时候，在北京拥有一套自己的房子。现在他的理想已经实现一半了：他已经三十岁了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;02&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;上中台：没吃过猪肉，还没薅过猪毛？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;去年年底的某一天，L总把小M叫到办公室。L总说，年底了，要提出明年的公司技术板块工作规划。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;L总认为，现在公司虽然做到了业务系统上云，实现了资源的统一调度、统一管理，但存在业务不通、业务架构老旧、重复建设等等很多问题，无法快速应对外部市场的变化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;L总经过调研，觉得现在热门的“数据中台”应该是公司技术架构改革的方向。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M领的任务就是，规划和落地数据中台项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M虽然一直在搞云计算，但是大数据这块，没吃过猪肉，也薅过猪毛。不敢说很懂，至少是略知一二吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是小M无知者无畏，接下了这个项目，赶紧开始学习，在百度上一查可把小M吓坏了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;原来，A厂们提出的数据中台、AI中台、视频中台、技术中台、移动中台......新概念层出不穷、眼花缭乱。各种敏捷开发、快速响应、集约建设、沉淀能力，网上的噱头一个比一个闪瞎狗眼。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是，小M整合了几篇文章，给L总写了个整体思路，“明年，公司将构建数据中台，整合公司内外数据资源，打造公司新一代技术基础设施，实现公司技术升级，支撑好公司未来的内外业务……”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;L总看了这个规划，非常满意，认可小M的思路，正式把中台建设写入了2020年度规划里。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/sqibwUCydDhzLd7hhMrVTggQN9SbiasvsLHLeblZktPKCwo39Z3x9mTrI8CzicdtmORaw1575adPW0zfSlLOyiazlA/0?wx_fmt=png&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;900&quot; data-cropy1=&quot;98.09688581314879&quot; data-cropy2=&quot;599.4809688581314&quot; data-ratio=&quot;0.5577777777777778&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/sqibwUCydDhzLd7hhMrVTggQN9SbiasvsL24mu30CHaLaufXAytaEmib57bWvynnHQ68Nbpc6kJJr3jT4fpW15gNg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;03&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;上中台吗？会送命的那种！&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M又看了一些中台实施文章，咨询了A厂、T厂们的中台架构师，制定出详细的中台规划。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M的报告指出，公司信息化存在的业务墙、数据墙、重复投资建设等问题，提出“三中台——数据中台、AI中台、视频中台”的技术架构。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;并提出几个推进机制：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、开展公司信息化资产盘点；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、研究公司发展战略规划、开展顶层设计；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、公司一把手牵头项目，各部门立军令状；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、制定里程碑：5月底完成调研，6月份完成方案设计，9月份前完成中台产品部署实施，年底前完成核心业务基于中台架构的改造。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;你闻到熟悉的味道了吗？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M初学中台，听信A厂的中台实施方法论套路，准备从顶层设计开始，盘点信息化资产，中台必须是一把手工程，得领导挂帅，中台急不得，是中长期战略......&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;L总不傻，把方案一棒子打死了：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“谁TM让你做顶层设计？老子都未必做得了顶层设计！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还盘点资产？盘你老木，捅出篓子，我TM都未必兜得住。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一把手挂帅？中台干好了，是领导英明，干不好你就给老子滚蛋。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;什么中长期规划？我明年还在不在这个位子上，都不好说......”&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;04&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;没有中台的命，却得了中台的病&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;故事讲到这，其实这个项目的命运已经基本注定了，总结下来有那么几个原因：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一，中台实施缺乏场景&lt;/strong&gt;。小M正在发愁中台怎么落地，A厂的顾问给他承诺：“我们做的很多中台项目，都是基于一些具体的需求来构建的。例如，一些公司要做某几个系统的数据治理，一些公司要做某些新业务要上中台。只要有场景，我们一定能建好中台。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可惜，小M不知道，供应商的承诺就像放屁，当时惊天动地，过后苍白无力。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M跑遍了各业务部门，推销他的中台梦想，得到的答复是，“这不是找事情做吗？我们的系统，一点儿问题都没有！”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M碰了一鼻子灰，回来给L总汇报，被L总一顿骂，“你去管那些业务部门的需求干什么？你先把中台搭建起来，就跟云一样！搭建起来后，后续我们不给他们批信息项目资金就可以了！”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在领导眼里，所有的问题都是人和钱的问题，没有人和钱搞不定的问题。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二，规划不充分、预算不足&lt;/strong&gt;。小M听L总的，赶紧和A厂、T厂的顾问商量，那就先搭建中台系统吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是，按照小M原先的三中台：数据中台、AI中台、视频中台的规划，让A厂、T厂拉了产品清单，报了产品价格。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;结果，A厂报了个上亿的价格，T厂好一点，才报了4000万。小M给L总汇报了下，L总冒火了：“我们是先行先试，不是要推翻全公司的技术设施！我们最多投资300万，先做出一些效果，落地一两个场景，再来推动后期建设！”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M心想，L总也真是“节俭”，中台这么好一副牌，就押这么点注，即使赢了又有多大意思？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M把情况跟A厂、T厂进行说明，看看能不能先按框架招标，再一步步实施。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A厂、T厂行走江湖多年，一看就明白了，给不起钱呗，没钱TM不早说。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是，翻脸比翻书还快，这些顾问，突然都变得忙起来，电话也经常接不通了，微信、钉钉也不怎么回了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M在技术世界里呆太久了，没被社会狠狠地毒打过。其实生活就是这样，一半是倒霉，别一半是如何处理倒霉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M自己不懂中台，项目预算还不够上个OA的，现在连供应商也不鸟他了，这还怎么玩啊？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;第三，中台建设的目标没搞清楚&lt;/strong&gt;。小M是正儿八经想操盘一把中台项目的，毕竟年轻的时候多吃点苦，到老了吃苦才会习惯。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可是L总不这么想，大家都是打工人，尤其是做到了他那么高职位，保住乌纱帽是最重要的，在此基础上如果能捞点油水，是最好的，其它都是扯淡。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;小M就没有领悟到这一点，一上来就提出资产盘点、顶层设计，一点都不懂领导的意图，你不死谁死？&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先不说它是个中台项目，但凡任何IT项目，有三个原则是要注意的：一，不要去折腾业务部门，要帮他们解决实际问题；二、花钱要花在看得见的地方，花小钱办大事；三、要尽可能争取更多干系人的支持，至少他们不反对。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这么看下来，中台项目要想“成功”，其实也不是那么难。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;第四，对中台的理解不在一个层面上&lt;/strong&gt;。L总看着小M负责的中台项目，半天嘣不出个屁来，于是自己琢磨起中台来了，L总是搞网络出身的，不懂研发，更不用说中台了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是宏观层面的理解是有的，经过研究后，L总给小M提出了中台建设的三个目标：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、让BOSS系统长在中台上&lt;/strong&gt;。公司的BOSS系统，十多年了，每年光是升级一点功能，都要几百万。中台要让BOSS系统接进来，以后BOSS的改造就用轻应用进行部署，每年只需要花几十万。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、用中台代替OA&lt;/strong&gt;。公司的OA系统不是很好用，要用这个中台来代替OA。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不得不佩服L总，“用中台代替OA”这个方案还是很有想象力的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、&lt;/strong&gt;&lt;strong&gt;用中台管理云、网络、业务系统&lt;/strong&gt;。这个中台要实现对公司云、网络、业务系统的统一运维。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;L总啊，人家可是个正经的中台，你把人家当什么了？（咦？这句话好像在哪里听过的样子）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;听到这里，小M已经崩溃了：这TM怎么搞啊。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6088888888888889&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sqibwUCydDhwCCIUY8bibBCSkQh5fm6U8rXBxHnmvLJflxyVfEG9hOTWJrYNqKsFsaDeib7KiaZplxaFx8ibtDe2IhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;05&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;写在末尾的话&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此时的小M感到很无力，&lt;/span&gt;&lt;span&gt;公司就他一个人在推动这个所谓的中台项目，业务方不搭理他、项目预算少得可怜、A厂和T厂也越来越不愿意配合、L总又一直责怪他项目推动不力......&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;仿佛被套在一个死循环里，无从解脱。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;俗话说，当局者迷，旁观者清。希望通过以上梳理，能让小M看清这个项目的全貌。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;混职场的核心能力是什么？就是做局与破局的能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有些局哪怕输个精光，也要All in。有些局即使赢面很大，也要选择退出。究竟路要怎么走，只能自己选择了。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后，祝福小M。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;作者简介&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;strong&gt;&lt;span&gt;Mr.&lt;/span&gt;&lt;span&gt;K&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，知名电商公司技术老K级人物。文出过畅销书，&lt;span&gt;武做过CTO&lt;/span&gt;，若非生活所迫，谁愿一身才华。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt; -END- &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p yahei=&quot;yahei&quot; sans=&quot;sans&quot; px=&quot;px&quot; normal=&quot;normal&quot; ui=&quot;ui&quot; gb=&quot;gb&quot; sc=&quot;sc&quot; neue=&quot;neue&quot; important=&quot;important&quot; helvetica=&quot;helvetica&quot; break-word=&quot;break-word&quot; sans-serif=&quot;sans-serif&quot; arial=&quot;arial&quot; microsoft=&quot;microsoft&quot; hiragino=&quot;hiragino&quot; pingfang=&quot;pingfang&quot; center=&quot;center&quot;&gt;&lt;span&gt;这是公众号作者老K的私人微信&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;围观老K的朋友圈！席位珍贵，快来占坑&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sqibwUCydDhzulVBFYfrZrhGoJyXbiaTKb98oJqVAGibhprOVrjuVSkoASNHQYu9DahrrM96gVGp0GxcYglD5yJtw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;大家在看：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5MjE3NDQ1Mw==&amp;amp;mid=2649711026&amp;amp;idx=1&amp;amp;sn=e49c1ecdcbd3dd54089d7bcc7ba8d4e8&amp;amp;chksm=886ae0a8bf1d69be984001bd3e9221d35a9506ad24f07d8eb65b9b9fa7d28d0184e42cb6f74e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;呼兰辞掉百万&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;呼兰辞掉百万年薪工作,去做脱口秀,有病吧？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5MjE3NDQ1Mw==&amp;amp;mid=2649710803&amp;amp;idx=1&amp;amp;sn=ed243eb16f7cb3607489b2e2f15ed13d&amp;amp;chksm=886ae1c9bf1d68df2c356a27a631dbbc6522fb6932135af6d98d91591a9d2cf3122b4b3d6be9&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;35岁，总监，离职创业，赔了魔都一套房&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5MjE3NDQ1Mw==&amp;amp;mid=2649710250&amp;amp;idx=1&amp;amp;sn=3b2bc771325ea94e78d2a5b21a4a9e8c&amp;amp;chksm=886adfb0bf1d56a6f00a4daf904ceced855c456b7db69f1569d62b7b95a5623221f55c43e36f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;张一鸣：成功的反义词不是失败，而是平庸！&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;.&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5MjE3NDQ1Mw==&amp;amp;mid=2649711005&amp;amp;idx=1&amp;amp;sn=fa7b21ab73ae119a6ee782fcfbbc384f&amp;amp;chksm=886ae087bf1d6991cde50210a496f66c9f8fb626286a2b71fa37410dd580d90de364ec6398e0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;阿里彭蕾：向上管理的最高境界，不是跪舔&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;.&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5MjE3NDQ1Mw==&amp;amp;mid=2649710978&amp;amp;idx=1&amp;amp;sn=073da9859691d43a4073aa36d19463d9&amp;amp;chksm=886ae098bf1d698eb74a7b164bc6040dad63a54720bdd01958e60b6d98e3815c6c08cd5d368f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;中台为什么做不好？拆系统“烟囱”容易...&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f772e2afc9b2deb2ee88c48d93827b7d</guid>
<title>如何优雅的实现分布式锁</title>
<link>https://toutiao.io/k/veeydsj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;概述&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提到分布式锁大家都会想到如下两种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;基于 &lt;code&gt;Redisson&lt;/code&gt;组件，使用redlock算法实现&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基于 &lt;code&gt;Apache Curator&lt;/code&gt;，利用Zookeeper的临时顺序节点模型实现&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们来说说第三种，使用 &lt;code&gt;Spring Integration&lt;/code&gt; 实现，也是我个人比较推荐的一种。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Spring Integration&lt;/code&gt;在基于Spring的应用程序中实现轻量级消息传递，并支持通过声明适配器与外部系统集成。Spring Integration的主要目标是提供一个简单的模型来构建企业集成解决方案，同时保持关注点的分离，这对于生成可维护，可测试的代码至关重要。我们熟知的
Spring Cloud Stream的底层就是Spring Integration。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;官方地址：https://github.com/spring-projects/spring-integration&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Integration提供的全局锁目前为如下存储提供了实现：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Gemfire&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;JDBC&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Zookeeper&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它们使用相同的API抽象，这意味着，不论使用哪种存储，你的编码体验是一样的。试想一下你目前是基于zookeeper实现的分布式锁，哪天你想换成redis的实现，我们只需要修改相关依赖和配置就可以了，无需修改代码。下面是你使用 &lt;code&gt;Spring Integration&lt;/code&gt; 实现分布式锁时需要关注的方法：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法名&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;lock()&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;Acquires the lock.&lt;/code&gt;   加锁，如果已经被其他线程锁住或者当前线程不能获取锁则阻塞&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;lockInterruptibly()&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;Acquires the lock unless the current thread is interrupted.&lt;/code&gt; 加锁，除非当前线程被打断。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;tryLock()&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;Acquires the lock only if it is free at the time of invocation.&lt;/code&gt; 尝试加锁，如果已经有其他锁锁住，获取当前线程不能加锁，则返回false，加锁失败；加锁成功则返回true&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;tryLock(long time, TimeUnit unit)&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;Acquires the lock if it is free within the given waiting time and the current thread has not been interrupted.&lt;/code&gt; 尝试在指定时间内加锁，如果已经有其他锁锁住，获取当前线程不能加锁，则返回false，加锁失败；加锁成功则返回true&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;unlock()&lt;/code&gt;&lt;/td&gt;&lt;td&gt;&lt;code&gt;Releases the lock.&lt;/code&gt; 解锁&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实战&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;话不多说，我们看看使用 &lt;code&gt;Spring Integration&lt;/code&gt;  如何基于redis和zookeeper快速实现分布式锁，至于Gemfire 和 Jdbc的实现大家自行实践。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基于Redis实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-integration&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.integration&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-integration-redis&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-data-redis&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在application.yml中添加redis的配置&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt; &lt;span&gt;redis:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;host:&lt;/span&gt; &lt;span&gt;172.31&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.149&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;port:&lt;/span&gt; &lt;span&gt;7111&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;建立配置类，注入 &lt;code&gt;RedisLockRegistry&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RedisLockConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; RedisLockRegistry &lt;span&gt;redisLockRegistry&lt;/span&gt;&lt;span&gt;(RedisConnectionFactory redisConnectionFactory)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RedisLockRegistry(redisConnectionFactory, &lt;span&gt;&quot;redis-lock&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;lock&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@Log&lt;/span&gt;4j2&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DistributedLockController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; RedisLockRegistry redisLockRegistry;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/redis&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Lock lock = redisLockRegistry.obtain(&lt;span&gt;&quot;redis&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;//尝试在指定时间内加锁，如果已经有其他锁锁住，获取当前线程不能加锁，则返回false，加锁失败；加锁成功则返回true&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(lock.tryLock(&lt;span&gt;3&lt;/span&gt;, TimeUnit.SECONDS)){&lt;br/&gt;                log.info(&lt;span&gt;&quot;lock is ready&quot;&lt;/span&gt;);&lt;br/&gt;                TimeUnit.SECONDS.sleep(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            log.error(&lt;span&gt;&quot;obtain lock error&quot;&lt;/span&gt;,e);&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            lock.unlock();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;测试&lt;br/&gt;启动多个实例，分别访问 &lt;code&gt;/lock/redis&lt;/code&gt; 端点，一个正常秩序业务逻辑，另外一个实例访问出现如下错误&lt;img data-ratio=&quot;0.22916666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4h9kamAaicVpoFTfGUrfT9nrLfnZy7QibI42VeMClsGhOoTg2CEFreHSxeHyf8nYZs36H4c9ZBKVMicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1488&quot;/&gt;说明第二个实例没有拿到锁，证明了分布式锁的存在。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;p&gt;注意，如果使用新版Springboot进行集成时需要使用Redis4版本，否则会出现下面的异常告警，主要是 unlock() 释放锁时使用了UNLINK命令，这个需要Redis4版本才能支持。&lt;/p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;2020-05-14 11:30:24,781 WARN  RedisLockRegistry:339 - The UNLINK &lt;span&gt;command&lt;/span&gt; has failed (not supported on the Redis server?); falling back to the regular DELETE &lt;span&gt;command&lt;/span&gt;&lt;br/&gt;org.springframework.data.redis.RedisSystemException: Error &lt;span&gt;in&lt;/span&gt; execution; nested exception is io.lettuce.core.RedisCommandExecutionException: ERR unknown &lt;span&gt;command&lt;/span&gt; &lt;span&gt;&#x27;UNLINK&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;基于Zookeeper实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-integration&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.integration&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-integration-zookeeper&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在application.yml中添加zookeeper的配置&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;zookeeper:&lt;/span&gt;  &lt;br/&gt;&lt;span&gt;    host:&lt;/span&gt; &lt;span&gt;172.31&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.43&lt;/span&gt;&lt;span&gt;:2181&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;建立配置类，注入 &lt;code&gt;ZookeeperLockRegistry&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ZookeeperLockConfiguration&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${zookeeper.host}&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String zkUrl;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; CuratorFrameworkFactoryBean &lt;span&gt;curatorFrameworkFactoryBean&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; CuratorFrameworkFactoryBean(zkUrl);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ZookeeperLockRegistry &lt;span&gt;zookeeperLockRegistry&lt;/span&gt;&lt;span&gt;(CuratorFramework curatorFramework)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ZookeeperLockRegistry(curatorFramework,&lt;span&gt;&quot;/zookeeper-lock&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RestController&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@RequestMapping&lt;/span&gt;(&lt;span&gt;&quot;lock&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@Log&lt;/span&gt;4j2&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DistributedLockController&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; ZookeeperLockRegistry zookeeperLockRegistry;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;/zookeeper&quot;&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Lock lock = zookeeperLockRegistry.obtain(&lt;span&gt;&quot;zookeeper&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;//尝试在指定时间内加锁，如果已经有其他锁锁住，获取当前线程不能加锁，则返回false，加锁失败；加锁成功则返回true&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(lock.tryLock(&lt;span&gt;3&lt;/span&gt;, TimeUnit.SECONDS)){&lt;br/&gt;                log.info(&lt;span&gt;&quot;lock is ready&quot;&lt;/span&gt;);&lt;br/&gt;                TimeUnit.SECONDS.sleep(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            log.error(&lt;span&gt;&quot;obtain lock error&quot;&lt;/span&gt;,e);&lt;br/&gt;        } &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;            lock.unlock();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;测试&lt;br/&gt;启动多个实例，分别访问 &lt;code&gt;/lock/zookeeper&lt;/code&gt; 端点，一个正常执行业务逻辑，另外一个实例访问出现如下错误：&lt;img data-ratio=&quot;0.254272043745728&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PxMzT0Oibf4h9kamAaicVpoFTfGUrfT9nrP70svZwaWl9dbMlaJ1VgDo059n3Q0fvfTJ0An3rRxYkL7CPNnKZReg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1463&quot;/&gt;说明第二个实例没有拿到锁，证明了分布式锁的存在。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>37710db61240f782f9cab1f608f3ed2d</guid>
<title>Gitlab CI 使用阿里云 kubernetes serverless</title>
<link>https://toutiao.io/k/q2ardl2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-header&quot;&gt;
&lt;h1 class=&quot;title&quot;&gt;Gitlab CI 使用阿里云 kubernetes serverless&lt;/h1&gt;
&lt;p class=&quot;meta&quot;&gt;冯宇 Posted at — Nov 27, 2020
&lt;span class=&quot;meta&quot; id=&quot;busuanzi_container_page_pv&quot;&gt;阅读 &lt;span id=&quot;busuanzi_value_page_pv&quot;/&gt;&lt;/span&gt;
&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;markdown&quot;&gt;

&lt;p&gt;Gitlab 自带一个轻量级的 CI &lt;a href=&quot;https://docs.gitlab.com/ce/ci/&quot;&gt;gitlab-ci&lt;/a&gt;，轻便好用，奈何我们的服务器资源有限，配置不是很高，一直将 gitlab runner 和 gitlab 放在同一台服务器上，每次大规模运行 CI 的时候总是煎熬。经常会因为 CI 负载太高导致 gitlab 暂时不可访问，或者构建产生的容器太多占满了磁盘的空间，苦不堪言。&lt;/p&gt;
&lt;p&gt;而&lt;a href=&quot;https://help.aliyun.com/document_detail/86366.html&quot;&gt;阿里云 kubernetes serverless&lt;/a&gt;的诞生非常好的弥补了这个短板，它非常契合 CI 的这种需求。本文我们分享下我们在 gitlab ci 的实践，使用阿里云 kubernetes serverless 跑 CI 任务。&lt;/p&gt;
&lt;h2 id=&quot;gitlab-runner-配置&quot;&gt;gitlab runner 配置&lt;/h2&gt;
&lt;p&gt;我们是将&lt;a href=&quot;https://about.gitlab.com/install/&quot;&gt;gitlab-ce omnibus&lt;/a&gt; 安装包和&lt;a href=&quot;https://docs.gitlab.com/runner/install/index.html&quot;&gt;gitlab-runner&lt;/a&gt;安装到同一台阿里云 ECS 服务器上。运行 gitlab-runner 的注册命令，添加一个&lt;a href=&quot;https://docs.gitlab.com/runner/executors/kubernetes.html&quot;&gt;k8s&lt;/a&gt;的 executor:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span&gt;# sudo gitlab-runner register&lt;/span&gt;
Runtime platform                                    &lt;span&gt;arch&lt;/span&gt;=amd64 &lt;span&gt;os&lt;/span&gt;=linux &lt;span&gt;pid&lt;/span&gt;=&lt;span&gt;2934&lt;/span&gt; &lt;span&gt;revision&lt;/span&gt;=8fa89735 &lt;span&gt;version&lt;/span&gt;=13.6.0
Running in system-mode.

Enter the GitLab instance URL (&lt;span&gt;for&lt;/span&gt; example, https://gitlab.com/):
https://mygitlab.domain.com   &lt;span&gt;# &amp;lt;===== 这里输入你的gitlab访问地址&lt;/span&gt;
Enter the registration token:
a1b2c3...  &lt;span&gt;# &amp;lt;===== 这里的token在gitlab admin页面runners配置页面下，复制出来即可&lt;/span&gt;
Enter a description &lt;span&gt;for&lt;/span&gt; the runner:
[gitlab]: k8s &lt;span&gt;# &amp;lt;==== 这里输入你想写的描述，默认gitlab&lt;/span&gt;
Enter tags &lt;span&gt;for&lt;/span&gt; the runner (comma-separated):
docker,k8s  &lt;span&gt;# &amp;lt;===== 这里输入tag，逗号分隔，用于匹配.gitlab-ci.yml中的tags选择&lt;/span&gt;
Registering runner... succeeded                     &lt;span&gt;runner&lt;/span&gt;=DRN6fxRz
Enter an executor: custom, docker, shell, ssh, virtualbox, kubernetes, docker-ssh, parallels, docker+machine, docker-ssh+machine:
kubernetes  &lt;span&gt;# &amp;lt;==== 这里我们要添加k8s serverless集群，当然是k8s&lt;/span&gt;
Runner registered successfully. Feel free to start it, but &lt;span&gt;if&lt;/span&gt; it&#x27;s running already the config should be automatically reloaded!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;注册成功在 gitlab admin 页面应该就能看到新的 runner 已经添加了(刚添加进去是&lt;code&gt;locked&lt;/code&gt;状态，在右边的 edit 按钮打开设置页面，激活即可使用)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;imgs/gitlab-ci-use-aliyun-k8s-serverless-1.png&quot; alt=&quot;gitlab admins runners页面&quot;/&gt;&lt;/p&gt;
&lt;p&gt;打开&lt;code&gt;/etc/gitlab-runner/config.toml&lt;/code&gt;文件，可以看到生成的模板类似于下面:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;[[&lt;span&gt;runners&lt;/span&gt;]]
  &lt;span&gt;name&lt;/span&gt; = &lt;span&gt;&quot;gitlab-k8s&quot;&lt;/span&gt;
  &lt;span&gt;url&lt;/span&gt; = &lt;span&gt;&quot;https://mygitlab.domain.com&quot;&lt;/span&gt;
  &lt;span&gt;token&lt;/span&gt; = &lt;span&gt;&quot;your_token&quot;&lt;/span&gt;
  &lt;span&gt;executor&lt;/span&gt; = &lt;span&gt;&quot;kubernetes&quot;&lt;/span&gt;
  [&lt;span&gt;runners&lt;/span&gt;.&lt;span&gt;custom_build_dir&lt;/span&gt;]
  [&lt;span&gt;runners&lt;/span&gt;.&lt;span&gt;cache&lt;/span&gt;]
    [&lt;span&gt;runners&lt;/span&gt;.&lt;span&gt;cache&lt;/span&gt;.&lt;span&gt;s3&lt;/span&gt;]
    [&lt;span&gt;runners&lt;/span&gt;.&lt;span&gt;cache&lt;/span&gt;.&lt;span&gt;gcs&lt;/span&gt;]
    [&lt;span&gt;runners&lt;/span&gt;.&lt;span&gt;cache&lt;/span&gt;.&lt;span&gt;azure&lt;/span&gt;]
  [&lt;span&gt;runners&lt;/span&gt;.&lt;span&gt;kubernetes&lt;/span&gt;]
    &lt;span&gt;host&lt;/span&gt; = &lt;span&gt;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;bearer_token_overwrite_allowed&lt;/span&gt; = &lt;span&gt;false&lt;/span&gt;
    &lt;span&gt;image&lt;/span&gt; = &lt;span&gt;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;namespace&lt;/span&gt; = &lt;span&gt;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;namespace_overwrite_allowed&lt;/span&gt; = &lt;span&gt;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;privileged&lt;/span&gt; = &lt;span&gt;false&lt;/span&gt;
    &lt;span&gt;service_account_overwrite_allowed&lt;/span&gt; = &lt;span&gt;&quot;&quot;&lt;/span&gt;
    &lt;span&gt;pod_annotations_overwrite_allowed&lt;/span&gt; = &lt;span&gt;&quot;&quot;&lt;/span&gt;
    [&lt;span&gt;runners&lt;/span&gt;.&lt;span&gt;kubernetes&lt;/span&gt;.&lt;span&gt;affinity&lt;/span&gt;]
    [&lt;span&gt;runners&lt;/span&gt;.&lt;span&gt;kubernetes&lt;/span&gt;.&lt;span&gt;pod_security_context&lt;/span&gt;]
    [&lt;span&gt;runners&lt;/span&gt;.&lt;span&gt;kubernetes&lt;/span&gt;.&lt;span&gt;volumes&lt;/span&gt;]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;到这里基本的 gitlab runner 配置就完成了(后续一些优化配置见后文)&lt;/p&gt;
&lt;h2 id=&quot;开通与配置阿里云-kubernetes-serverless&quot;&gt;开通与配置阿里云 kubernetes serverless&lt;/h2&gt;
&lt;p&gt;开通阿里云 kubernetes serverless 是免费的，只收取 ECI 实例的费用。有关 ECI 实例的计费参考&lt;a href=&quot;https://help.aliyun.com/document_detail/89142.html&quot;&gt;计费概述&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在阿里云的控制台上找到 k8s serverless 的入口创建集群就行了:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;imgs/gitlab-ci-use-aliyun-k8s-serverless-2.png&quot; alt=&quot;阿里云kubernetes serverless创建集群&quot;/&gt;&lt;/p&gt;
&lt;p&gt;等待集群创建成功，转到&lt;code&gt;连接信息&lt;/code&gt;页面，复制下来 kubectl 的配置内容:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;imgs/gitlab-ci-use-aliyun-k8s-serverless-3.png&quot; alt=&quot;kubectl配置内容&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 gitlab-runner 服务器上&lt;a href=&quot;https://kubernetes.io/zh/docs/tasks/tools/install-kubectl/&quot;&gt;安装 kubectl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;将&lt;code&gt;连接信息&lt;/code&gt;复制到&lt;code&gt;gitlab-runner&lt;/code&gt;用户的 kubectl 配置中(因为 gitlab-runner 服务使用&lt;code&gt;gitlab-runner&lt;/code&gt;这个用户运行，所以必须配置成这个用户的 kubectl 配置):&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;&lt;span&gt;# 切换成 gitlab-runner 用户，后续操作使用 gitlab-runner 身份&lt;/span&gt;
&lt;span&gt;# sudo sudo -iu gitlab-runner&lt;/span&gt;
$ mkdir -p ~/.kube
$ vim ~/.kube/config  &lt;span&gt;# &amp;lt;==== 将连接信息复制到这个文件中&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;检查 k8s serverless 集群连接，正常的话大概像这样:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;$ kubectl version
Client Version: version.Info{Major:&lt;span&gt;&quot;1&quot;&lt;/span&gt;, Minor:&lt;span&gt;&quot;19&quot;&lt;/span&gt;, GitVersion:&lt;span&gt;&quot;v1.19.4&quot;&lt;/span&gt;, GitCommit:&lt;span&gt;&quot;d360454c9bcd1634cf4cc52d1867af5491dc9c5f&quot;&lt;/span&gt;, GitTreeState:&lt;span&gt;&quot;clean&quot;&lt;/span&gt;, BuildDate:&lt;span&gt;&quot;2020-11-11T13:17:17Z&quot;&lt;/span&gt;, GoVersion:&lt;span&gt;&quot;go1.15.2&quot;&lt;/span&gt;, Compiler:&lt;span&gt;&quot;gc&quot;&lt;/span&gt;, Platform:&lt;span&gt;&quot;linux/amd64&quot;&lt;/span&gt;}
Server Version: version.Info{Major:&lt;span&gt;&quot;1&quot;&lt;/span&gt;, Minor:&lt;span&gt;&quot;18+&quot;&lt;/span&gt;, GitVersion:&lt;span&gt;&quot;v1.18.8-aliyun.1&quot;&lt;/span&gt;, GitCommit:&lt;span&gt;&quot;cff3030&quot;&lt;/span&gt;, GitTreeState:&lt;span&gt;&quot;&quot;&lt;/span&gt;, BuildDate:&lt;span&gt;&quot;2020-11-19T07:19:32Z&quot;&lt;/span&gt;, GoVersion:&lt;span&gt;&quot;go1.13.15&quot;&lt;/span&gt;, Compiler:&lt;span&gt;&quot;gc&quot;&lt;/span&gt;, Platform:&lt;span&gt;&quot;linux/amd64&quot;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;说明配置已经 OK 了，此时跑个 CI 任务看看。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意需要运行能跑在 docker 的 CI 任务，可以参考之前的文章&lt;a href=&quot;https://blog.dteam.top/posts/2019-11/gitlab_ci_migrate_to_docker.html&quot;&gt;耗时三天，我将 Gitlab CI 由 shell executor 平滑迁移 Docker 环境&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;imgs/gitlab-ci-use-aliyun-k8s-serverless-4.png&quot; alt=&quot;gitlab ci终端输出&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;imgs/gitlab-ci-use-aliyun-k8s-serverless-5.png&quot; alt=&quot;k8s serverless页面输出&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里基本的流程已经实现了。&lt;/p&gt;
&lt;h2 id=&quot;tips&quot;&gt;TIPS&lt;/h2&gt;
&lt;p&gt;为了节省构建时间以及一些费用，还需要一些优化，这里提供一些优化方案供参考&lt;/p&gt;
&lt;h3 id=&quot;使用-oss-存储构建缓存&quot;&gt;使用 OSS 存储构建缓存&lt;/h3&gt;
&lt;p&gt;目前 k8s serverless 集群支持 OSS 做 PVC，因此可以考虑将构建缓存放在 OSS 上加速构建过程。在控制台或者 yaml 文件中创建 OSS 的 PVC 即可，我这里的使用的配置如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yaml&quot; data-lang=&quot;yaml&quot;&gt;&lt;span&gt;apiVersion&lt;/span&gt;: v1
&lt;span&gt;kind&lt;/span&gt;: PersistentVolume
&lt;span&gt;metadata&lt;/span&gt;:
  &lt;span&gt;labels&lt;/span&gt;:
    &lt;span&gt;alicloud-pvname&lt;/span&gt;: gitlab-cache-pv
  &lt;span&gt;name&lt;/span&gt;: gitlab-cache-pv
&lt;span&gt;spec&lt;/span&gt;:
  &lt;span&gt;accessModes&lt;/span&gt;:
    - ReadWriteMany
  &lt;span&gt;capacity&lt;/span&gt;:
    &lt;span&gt;storage&lt;/span&gt;: 50Gi
  &lt;span&gt;claimRef&lt;/span&gt;:
    &lt;span&gt;apiVersion&lt;/span&gt;: v1
    &lt;span&gt;kind&lt;/span&gt;: PersistentVolumeClaim
    &lt;span&gt;name&lt;/span&gt;: gitlab-cache-pvc
    &lt;span&gt;namespace&lt;/span&gt;: default
  &lt;span&gt;flexVolume&lt;/span&gt;:
    &lt;span&gt;driver&lt;/span&gt;: alicloud/oss
    &lt;span&gt;options&lt;/span&gt;:
      &lt;span&gt;akId&lt;/span&gt;: 你的AK_ID
      &lt;span&gt;akSecret&lt;/span&gt;: 你的AK_SECRET
      &lt;span&gt;bucket&lt;/span&gt;: 你的bucket
      &lt;span&gt;otherOpts&lt;/span&gt;: &lt;span&gt;&quot;-o max_stat_cache_size=0 -o allow_other&quot;&lt;/span&gt;
      &lt;span&gt;# 使用的域名参考OSS文档: https://help.aliyun.com/document_detail/31837.html,我的环境是VPC&lt;/span&gt;
      &lt;span&gt;url&lt;/span&gt;: vpc100-oss-cn-hangzhou.aliyuncs.com
  &lt;span&gt;persistentVolumeReclaimPolicy&lt;/span&gt;: Retain
  &lt;span&gt;storageClassName&lt;/span&gt;: oss

---
&lt;span&gt;apiVersion&lt;/span&gt;: v1
&lt;span&gt;kind&lt;/span&gt;: PersistentVolumeClaim
&lt;span&gt;metadata&lt;/span&gt;:
  &lt;span&gt;name&lt;/span&gt;: gitlab-cache-pvc
  &lt;span&gt;namespace&lt;/span&gt;: default
&lt;span&gt;spec&lt;/span&gt;:
  &lt;span&gt;accessModes&lt;/span&gt;:
    - ReadWriteMany
  &lt;span&gt;resources&lt;/span&gt;:
    &lt;span&gt;requests&lt;/span&gt;:
      &lt;span&gt;storage&lt;/span&gt;: 50Gi
  &lt;span&gt;selector&lt;/span&gt;:
    &lt;span&gt;matchLabels&lt;/span&gt;:
      &lt;span&gt;alicloud-pvname&lt;/span&gt;: gitlab-cache-pv
  &lt;span&gt;storageClassName&lt;/span&gt;: oss
  &lt;span&gt;volumeName&lt;/span&gt;: gitlab-cache-pv
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;kubectl apply -f gitlab-cache.yml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;直接在阿里云控制台界面上创建是同样的效果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;imgs/gitlab-ci-use-aliyun-k8s-serverless-6.png&quot; alt=&quot;gitlab-cache-pv&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后在&lt;code&gt;/etc/gitlab-runner/config.toml&lt;/code&gt;中添加 PVC 的挂载:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;[[&lt;span&gt;runners&lt;/span&gt;]]
  &lt;span&gt;# ...&lt;/span&gt;
  [&lt;span&gt;runners&lt;/span&gt;.&lt;span&gt;kubernetes&lt;/span&gt;]
    &lt;span&gt;# ...&lt;/span&gt;
    [&lt;span&gt;runners&lt;/span&gt;.&lt;span&gt;kubernetes&lt;/span&gt;.&lt;span&gt;volumes&lt;/span&gt;]
      [[&lt;span&gt;runners&lt;/span&gt;.&lt;span&gt;kubernetes&lt;/span&gt;.&lt;span&gt;volumes&lt;/span&gt;.&lt;span&gt;pvc&lt;/span&gt;]]
        &lt;span&gt;name&lt;/span&gt; = &lt;span&gt;&quot;gitlab-cache-pvc&quot;&lt;/span&gt;
        &lt;span&gt;mount_path&lt;/span&gt; = &lt;span&gt;&quot;/cache&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样 &lt;a href=&quot;https://docs.gitlab.com/ce/ci/caching/&quot;&gt;gitlab ci cache&lt;/a&gt; 就可以存储在 OSS 上了，以后构建会快很多。&lt;/p&gt;
&lt;h3 id=&quot;使用阿里云的容器镜像&quot;&gt;使用阿里云的容器镜像&lt;/h3&gt;
&lt;p&gt;k8s serverless 集群使用阿里云的容器镜像，阿里云容器镜像如果没有镜像缓存会直接超时 500 错导致构建直接失败，因此有必要在本地就提前预热，建议将本地使用的 docker 镜像仓库配置为阿里云的&lt;code&gt;https://pqbap4ya.mirror.aliyuncs.com&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;docker 镜像仓库配置参考: &lt;a href=&quot;https://blog.dteam.top/mirrors.html#docker-hub&quot;&gt;国内开发资源镜像一览&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;也可以使用&lt;a href=&quot;https://help.aliyun.com/document_detail/141281.html&quot;&gt;镜像缓存&lt;/a&gt;加速 ECI 实例启动，不过会有额外的费用，请注意。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;使用-eci-抢占式实例节省费用&quot;&gt;使用 ECI 抢占式实例节省费用&lt;/h3&gt;
&lt;p&gt;由于 CI 对可用性没有那么高的要求，也不会持续运行太长时间，因此，使用&lt;a href=&quot;https://help.aliyun.com/document_detail/157759.html&quot;&gt;ECI 抢占式实例&lt;/a&gt;就足够了，可以进一步节省很多成本。&lt;/p&gt;
&lt;p&gt;在 gitlab-runner 中使用 ECI 抢占式实例的配置如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;[[&lt;span&gt;runners&lt;/span&gt;]]
  &lt;span&gt;# ...&lt;/span&gt;
  [&lt;span&gt;runners&lt;/span&gt;.&lt;span&gt;kubernetes&lt;/span&gt;]
    &lt;span&gt;# ...&lt;/span&gt;
    [&lt;span&gt;runners&lt;/span&gt;.&lt;span&gt;kubernetes&lt;/span&gt;.&lt;span&gt;pod_annotations&lt;/span&gt;]
      &lt;span&gt;&quot;k8s.aliyun.com/eci-spot-strategy&quot;&lt;/span&gt; = &lt;span&gt;&quot;SpotAsPriceGo&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;更多 annotations 配置参考: &lt;a href=&quot;https://help.aliyun.com/document_detail/165053.html&quot;&gt;使用抢占式实例&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;限制构建环境使用的资源配置&quot;&gt;限制构建环境使用的资源配置&lt;/h3&gt;
&lt;p&gt;ECI 按照配置规格按量付费，因此可以限制资源使用来达到节省费用的目的。有两种方式可以限制使用的 ECI 规格：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;声明使用的资源(CPU, 内存等)，ECI 会自动适配一个最接近的实例&lt;/li&gt;
&lt;li&gt;使用 annotations 直接声明具体要用的实例规格&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;这部分具体的详情规则参见官方文档: &lt;a href=&quot;https://help.aliyun.com/document_detail/114665.html&quot;&gt;实例概述&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我这边使用的是声明资源，由 ECI 自动适配实例规格的方案。gitlab-runner 配置中可以限定 helper，build，service 容器实例的规格，我的配置参考如下:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;[[&lt;span&gt;runners&lt;/span&gt;]]
  &lt;span&gt;# ...&lt;/span&gt;
  [&lt;span&gt;runners&lt;/span&gt;.&lt;span&gt;kubernetes&lt;/span&gt;]
    &lt;span&gt;# ...&lt;/span&gt;
    &lt;span&gt;cpu_request&lt;/span&gt; = &lt;span&gt;&quot;2&quot;&lt;/span&gt;
    &lt;span&gt;memory_request&lt;/span&gt; = &lt;span&gt;&quot;6Gi&quot;&lt;/span&gt;
    &lt;span&gt;service_cpu_request&lt;/span&gt; = &lt;span&gt;&quot;1&quot;&lt;/span&gt;
    &lt;span&gt;service_memory_request&lt;/span&gt; = &lt;span&gt;&quot;1Gi&quot;&lt;/span&gt;
    &lt;span&gt;helper_cpu_request&lt;/span&gt; = &lt;span&gt;&quot;250m&quot;&lt;/span&gt;
    &lt;span&gt;helper_memory_request&lt;/span&gt; = &lt;span&gt;&quot;512Mi&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;限定 build 容器使用 2 核 6G，service 容器使用 1 核 1G，helper 容器使用 1/4 核 512M，最终 ECI 自动适配了一个 4 核 8G 的实例（见上图）&lt;/p&gt;
&lt;p&gt;也可以通过 annotations 的方式直接指明要用的实例，参考&lt;a href=&quot;https://help.aliyun.com/document_detail/114664.html&quot;&gt;指定 ECS 规格创建 ECI&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;k8s-中-service-网络组建的问题&quot;&gt;k8s 中 service 网络组建的问题&lt;/h3&gt;
&lt;p&gt;在 docker executor 中，service 是通过 docker container link 的方式组建网络的(参考 gitlab ci 官方文档: &lt;a href=&quot;https://docs.gitlab.com/ee/ci/docker/using_docker_images.html#how-services-are-linked-to-the-job&quot;&gt;How services are linked to the job&lt;/a&gt;)，直观的表现就是&lt;strong&gt;要通过 container_name 作为域名访问到 service&lt;/strong&gt;。但是在 k8s 网络中，service 网络组建是直接通过&lt;code&gt;host&lt;/code&gt;的方式连接容器网络的，直观的表现就是&lt;strong&gt;可以通过&lt;code&gt;127.0.0.1&lt;/code&gt;直接访问到 service&lt;/strong&gt;，为了同时适配这两种可能的场景，需要在&lt;code&gt;.gitlab-ci.yml&lt;/code&gt;的配置中作下简单的适配，参考配置（主要参考来自于官方 issue: &lt;a href=&quot;https://gitlab.com/gitlab-org/gitlab-runner/-/issues/2229&quot;&gt;#2229&lt;/a&gt;）:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-yml&quot; data-lang=&quot;yml&quot;&gt;&lt;span&gt;test&lt;/span&gt;:
  &lt;span&gt;stage&lt;/span&gt;: test
  &lt;span&gt;image&lt;/span&gt;: adoptopenjdk/openjdk8-openj9:alpine-slim
  &lt;span&gt;services&lt;/span&gt;:
    - &lt;span&gt;name&lt;/span&gt;: postgres:&lt;span&gt;10&lt;/span&gt;-alpine
      &lt;span&gt;alias&lt;/span&gt;: db
  &lt;span&gt;variables&lt;/span&gt;:
    &lt;span&gt;POSTGRES_DB&lt;/span&gt;: mydb_test
    &lt;span&gt;POSTGRES_USER&lt;/span&gt;: my_user
    &lt;span&gt;POSTGRES_PASSWORD&lt;/span&gt;: my_pass
  &lt;span&gt;script&lt;/span&gt;:
    - DB_HOST=&lt;span&gt;&quot;${CI_SERVICE_HOST:-db}&quot;&lt;/span&gt;
    &lt;span&gt;# 你的测试需要支持从环境变量获取数据库连接方式&lt;/span&gt;
    - export dataSource_url=&lt;span&gt;&quot;jdbc:postgresql://${DB_HOST}:5432/${POSTGRES_DB}?useUnicode=true&amp;amp;characterEncoding=utf8&quot;&lt;/span&gt;
    - ./gradlew -Dorg.gradle.daemon=&lt;span&gt;false&lt;/span&gt; -Dfile.encoding=UTF&lt;span&gt;-8&lt;/span&gt; check
  &lt;span&gt;artifacts&lt;/span&gt;:
    &lt;span&gt;expose_as&lt;/span&gt;: &lt;span&gt;&quot;test reports&quot;&lt;/span&gt;
    &lt;span&gt;paths&lt;/span&gt;:
      - build/reports/tests/
    &lt;span&gt;reports&lt;/span&gt;:
      &lt;span&gt;junit&lt;/span&gt;: &lt;span&gt;&quot;build/test-results/**/*.xml&quot;&lt;/span&gt;
    &lt;span&gt;expire_in&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt; day
    &lt;span&gt;when&lt;/span&gt;: always
  &lt;span&gt;dependencies&lt;/span&gt;: []
  &lt;span&gt;rules&lt;/span&gt;:
    - &lt;span&gt;if&lt;/span&gt;: $CI_COMMIT_BRANCH
  &lt;span&gt;tags&lt;/span&gt;:
    - docker
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这里我们通过额外注入一个&lt;code&gt;CI_SERVICE_HOST&lt;/code&gt;环境变量控制 service 的实际连接地址，然后我们在 gitlab-runner 的配置中注入这个环境变量:&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;[[&lt;span&gt;runners&lt;/span&gt;]]
  &lt;span&gt;name&lt;/span&gt; = &lt;span&gt;&quot;k8s&quot;&lt;/span&gt;
  &lt;span&gt;executor&lt;/span&gt; = &lt;span&gt;&quot;kubernetes&quot;&lt;/span&gt;
  &lt;span&gt;# ...&lt;/span&gt;
  &lt;span&gt;environment&lt;/span&gt; = [&lt;span&gt;&quot;CI_SERVICE_HOST=127.0.0.1&quot;&lt;/span&gt;]
  &lt;span&gt;# ...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样无论 CI 是运行在 docker executor 还是 k8s executor 都可以正常通过测试了。&lt;/p&gt;
&lt;h3 id=&quot;pod-访问外网环境&quot;&gt;pod 访问外网环境&lt;/h3&gt;
&lt;p&gt;构建过程中可能需要从外网下载依赖，由于 pod 直接使用 VPC 网络环境，在不想额外增加成本的情况下，可以参考这篇文章使用外网 ECS 解决网络访问: &lt;a href=&quot;https://blog.dteam.top/posts/2018-08/%E9%98%BF%E9%87%8C%E4%BA%91vpc%E7%8E%AF%E5%A2%83%E5%86%85%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E5%A4%96%E7%BD%91.html&quot;&gt;阿里云 VPC 环境内网服务器如何访问外网&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;本文我们详细总结了使用阿里云 k8s serverless 服务对接 gitlab ci 的方案，以及我们的一些实践。&lt;/p&gt;


&lt;/div&gt;

&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0f0282e6a17f645fe4117251eccc9c51</guid>
<title>还不了解 Etcd？一文带你快速入门</title>
<link>https://toutiao.io/k/1eysos2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;br/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2018年12月 etcd 作为孵化项目 CNCF（云原生计算基金会），几天前 CNCF 宣布 etcd 正式毕业，成为 CNCF 顶级项目。CNCF 官方表示 etcd 项目的采用率持续增加，也有稳定的治理流程，功能已达一定成熟度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 已经被许多公司用于实际生产，其中包括亚马逊、百度、思科、EMC、谷歌、阿里、华为、IBM、Red Hat、Uber、Verizon 等；而且其身影也出现在包括 Kubernetes、CoreDNS、M3、Rook 以及 TiKV 等项目当中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面的系列 etcd 文章已经部分介绍了 etcd。本文将会做一个快速入门的介绍，带领大家十分钟快速入门云原生存储组件 etcd，主要内容如下（本文较长，建议收藏）：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;etcd 简介，以及其应用场景&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;etcd 的多种安装模式及高可用运维&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;etcd v3 的架构解析&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;etcdctl 的实践应用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1 etcd 介绍&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2013 年 6 月，CoreOS 发起了 etcd 项目。etcd 使用 Go 语言实现，是分布式系统中重要的基础组件，目前最新版本为 V3.4.9。etcd 可以用来构建高可用的分布式键值数据库，根据官网介绍，总结来说有如下的特点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;简单：etcd 的安装简单，且为用户提供了 HTTP API，用户使用起来也很简单&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;存储：etcd 的基本功能，数据分层存储在文件目录中，类似于我们日常使用的文件系统&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Watch 机制：Watch 指定的键、前缀目录的更改，并对更改时间进行通知&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;安全通信：SSL 证书验证&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高性能：etcd 单实例可以支持 2k/s 读操作，官方也有提供基准测试脚本&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一致可靠：基于 Raft 共识算法，实现分布式系统数据的高可用性、一致性&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0248447204968945&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Pd1oo3TBKydx40t8fXvNTX1kRLrVv0ywsTpNHBDlkYS462TzZqrzLgicUytQdIpSI8MJLtdtgWmaicsAh122D5mA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;322&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 是一个分布式键值存储数据库，支持跨平台，拥有强大的社区。etcd 的 Raft 算法，提供了可靠的方式存储分布式集群涉及的数据。etcd 广泛应用在微服务架构和 Kubernates 集群中，不仅可以作为服务注册与发现，还可以作为键值对存储的中间件。从业务系统 Web 到 Kubernetes 集群，都可以很方便地从 etcd 中读取、写入数据。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2 etcd 应用场景&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 在&lt;strong&gt;稳定性、可靠性和可伸缩性&lt;/strong&gt;表现极佳，同时也为云原生应用系统提供了协调机制。etcd 经常用于服务注册与发现的场景，此外还有键值对存储、消息发布与订阅、分布式锁等场景。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 键值对存储&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下是官方对 etcd 的描述：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;A highly-available key value store for shared configuration and service discovery.&lt;br/&gt;一个用于配置共享和服务发现的键值存储系统。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从其定义来看，etcd 是一个&lt;strong&gt;「键值存储」&lt;/strong&gt;的组件，存储是 etcd 最基本的功能，其他应用场景都是建立在 etcd 的可靠存储上。etcd 的存储有如下特点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;采用键值对数据存储，读写性能一般高于关系型数据库；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;etcd 集群分布式存储，多节点集群更加可靠；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;etcd 的存储采用类似文件目录的结构：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;叶子节点存储数据，其他节点不存储，这些数据相当于文件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非叶节点一定是目录，这些节点不能存储数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如 Kubernetes 将一些元数据存储在 etcd 中，将存储状态数据的的复杂工作交给 etcd，Kubernetes 自身的功能和架构能够更加专注。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 服务注册与发现&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式环境中，业务服务多实例部署，这个时候涉及到服务之间调用，就不能简单使用硬编码的方式指定服务实例信息。服务注册与发现就是解决如何找到分布式集群中的某一个服务（进程），并与之建立联系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务注册与发现涉及三个主要的角色：服务请求者、服务提供者和服务注册中心。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6691358024691358&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Pd1oo3TBKydx40t8fXvNTX1kRLrVv0ywtyhP6jGDcEnHG222odggENE7R7S6Yr9x5MPXf5WEKAPZX1aTAdPATA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;405&quot;/&gt;&lt;figcaption&gt;三大支柱&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务提供者启动的时候，在服务注册中心进行注册自己的服务名、主机地址、端口等信息；服务请求者需要调用对应的服务时，一般通过服务名请求服务注册中心，服务注册中心返回对应的实例地址和端口；服务请求者获取到实例地址、端口之后，绑定对应的服务提供者，实现远程调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 基于 Raft 算法，能够有力地保证分布式场景中的一致性。各个服务启动时注册到 etcd 上，同时为这些服务配置键的 TTL 时间，定时保持服务的心跳以达到监控健康状态的效果。通过在 etcd 指定的主题下注册的服务也能在对应的主题下查找到。为了确保连接，我们可以在每个服务机器上都部署一个 Proxy 模式的 etcd，这样就可以确保访问 etcd 集群的服务都能够互相连接。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 消息发布与订阅&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式系统中，服务之间还可以通过消息通信，即消息的发布与订阅。通过构建一个消息中间件，服务提供者发布对应主题的消息，而消费者则订阅他们关心的主题，一旦对应的主题有消息发布，即会产生订阅事件，消息中间件就会通知该主题所有的订阅者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6136783733826248&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Pd1oo3TBKydx40t8fXvNTX1kRLrVv0ywbSzxT7vujaTkd9FejeeUTXqMhNORYwglYwk81W2hyI4mw9TBROgejQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;541&quot;/&gt;如微服务架构中的认证鉴权服务，Auth 服务的实例地址、端口和实例节点的状态存放在 etcd 中，客户端应用订阅对应的主题，而 etcd 设置 key TTL 可以确保存储的服务实例的健康状态。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 分布式锁&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式系统中涉及到多个服务实例，存在跨进程之间资源调用，对于资源的协调分配，单体架构中的锁已经无法满足需要，需要引入分布式锁的概念。分布式锁可以将资源标记存储，这里的存储不是单纯属于某个进程，而是公共存储，诸如 Redis、Memcache、关系型数据库、文件等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 基于 Raft 算法，实现分布式集群的一致性，存储到 etcd 集群中的值必然是全局一致的，因此基于 etcd 很容易实现分布式锁。分布式锁有两种使用方式：保持独占和控制时序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.47643979057591623&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Pd1oo3TBKydx40t8fXvNTX1kRLrVv0yw19XsjYrgl5RiacwZSbibMFRGxRibxpwbremVQKYLNqy5IhKG6SGR6Wh9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;382&quot;/&gt;保持独占，从字面可以知道，所有获取资源的请求，只有一个成功。etcd 通过分布式锁原子操作 CAS 的 API，设置 prevExist 值，从而保证在多个节点同时去创建某个目录时，最后只有一个成功，创建成功的请求获取到锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;控制时序，有点类似于队列缓冲，所有的请求都会被安排分配资源，但是获得锁的顺序也是全局唯一的，执行按照先后的顺序。etcd 提供了一套自动创建有序键的 API，对一个目录的建值操作，这样 etcd 会自动生成一个当前最大的值为键，并存储该值。同时还可以使用 API 按顺序列出当前目录下的所有键值。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3 etcd 的多种安装方法&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 的安装非常简单，我们在本小节实践 etcd 单机和集群的几种安装方式。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1 etcd 概念词汇表&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下文的安装实践可能会涉及到 etcd 相关的概念词汇，因此我们首先了解下 etcd 的概念词汇表，以便于下文的理解。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Raft：分布式一致性算法；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Node：Raft 状态机实例；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Member：管理着 Node 的 etcd 实例，为客户端请求提供服务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Cluster：etcd 集群，由多个 Member 构成；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Peer：同一个 etcd 集群中的另一个 Member；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Client：客户端，向 etcd 发送 HTTP 请求；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;WAL：持久化存储的日志格式，预写式日志；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Snapshot：etcd 数据快照，防止 WAL 文件过多而设置的快照。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在了解了 etcd 的常用术语之后，我们下面开始介绍 etcd v3 的架构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 的安装有多种方式，笔者以 Centos 7 和 MacOS 10.15 为例，可以通过 &lt;code&gt;yum install etcd&lt;/code&gt; 和 &lt;code&gt;brew install etcd&lt;/code&gt;进行安装。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而通过系统工具安装的 etcd 版本比较滞后，如果需要安装最新版本的 etcd ，我们可以通过二进制包、源码编译以及 docker 容器安装。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2 etcd 单机安装部署&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 的安装有多种方式，笔者以 Centos 7 和 MacOS 10.15 为例，可以通过 &lt;code&gt;yum install etcd&lt;/code&gt; 和 &lt;code&gt;brew install etcd&lt;/code&gt;进行安装。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而通过系统工具安装的 etcd 版本比较滞后，如果需要安装最新版本的 etcd ，我们可以通过二进制包、源码编译以及 docker 容器安装。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2.1 二进制安装&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 macOS 下，安装 3.4.5，指定 etcd 版本，执行如下的脚本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;ETCD_VER=v3.4.5&lt;br/&gt;GITHUB_URL=https://github.com/etcd-io/etcd/releases/download&lt;br/&gt;DOWNLOAD_URL=&lt;span&gt;${GITHUB_URL}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;rm -f /tmp/etcd-&lt;span&gt;${ETCD_VER}&lt;/span&gt;-darwin-amd64.zip&lt;br/&gt;rm -rf /tmp/etcd-download-test &amp;amp;&amp;amp; mkdir -p /tmp/etcd-download-test&lt;br/&gt;&lt;br/&gt;curl -L &lt;span&gt;${DOWNLOAD_URL}&lt;/span&gt;/&lt;span&gt;${ETCD_VER}&lt;/span&gt;/etcd-&lt;span&gt;${ETCD_VER}&lt;/span&gt;-darwin-amd64.zip -o /tmp/etcd-&lt;span&gt;${ETCD_VER}&lt;/span&gt;-darwin-amd64.zip&lt;br/&gt;unzip /tmp/etcd-&lt;span&gt;${ETCD_VER}&lt;/span&gt;-darwin-amd64.zip -d /tmp &amp;amp;&amp;amp; rm -f /tmp/etcd-&lt;span&gt;${ETCD_VER}&lt;/span&gt;-darwin-amd64.zip&lt;br/&gt;mv /tmp/etcd-&lt;span&gt;${ETCD_VER}&lt;/span&gt;-darwin-amd64/* /tmp/etcd-download-test &amp;amp;&amp;amp; rm -rf mv /tmp/etcd-&lt;span&gt;${ETCD_VER}&lt;/span&gt;-darwin-amd64&lt;br/&gt;&lt;br/&gt;/tmp/etcd-download-test/etcd --version&lt;br/&gt;/tmp/etcd-download-test/etcdctl version&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行完上面的脚本，控制台即可输出如下的结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;etcd Version: 3.4.5&lt;br/&gt;Git SHA: c65a9e2dd&lt;br/&gt;Go Version: go1.12.12&lt;br/&gt;Go OS/Arch: darwin/amd64&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据控制台的显示，etcd 安装成功，版本为 etcd 3.4.5，基于的 Go 语言版本为 &lt;code&gt;1.12.12&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux 上的操作也类似，Centos 7 系统执行的脚本可以参考 etcd 官方提供的脚本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在这一小节演示了单机 etcd 在 macOS 和 Linux 上的安装。etcd 在 Windows 系统的安装比较简单，下载可执行文件，其中 etcd.exe 是 etcd Server，etcdctl.exe 命令行工具。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2527881040892193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Pd1oo3TBKydx40t8fXvNTX1kRLrVv0ywg8gYnklsYCOdLwTNnc4Bb48s2iaWXT985U5ll1xNJO1441pGT3iaj4eg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1076&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.2.2 源码安装&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于那些想尝试最新版本的同学，可以从 master 分支构建 etcd。使用源码安装，首先需要确保本地的 Go 语言环境。如未安装，请参考 https://golang.org/doc/install。需要 Go 版本为 1.13+，来构建最新版本的 etcd。本地的 Go 版本为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ go version&lt;br/&gt;&lt;br/&gt;go version go1.14.2 darwin/amd64&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于 master 分支构建 etcd，脚本如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;git &lt;span&gt;clone&lt;/span&gt; https://github.com/etcd-io/etcd.git&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; etcd&lt;br/&gt;./build&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装完记得执行测试命令，确保 etcd 源码编译安装成功。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3 etcd 集群部署&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 是分布式环境中重要的中间件，一般在生产环境不会单节点部署 etcd，为了 etcd 的高可用，避免单点故障，etcd 通常都是集群部署。本小节将会介绍如何进行 etcd 集群部署。引导 etcd 集群的启动有以下三种方式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;静态指定的方式需要事先知道集群中的所有节点。在许多情况下，群集成员的信息是动态生成。这种情况下，可以在动态发现服务的帮助下启动 etcd 群集。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们将会分别介绍这几种方式。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3.1 静态方式启动 etcd 集群&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想要在一台机器上实践 etcd 集群的搭建，可以通过 goreman 工具。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;goreman 是一个 Go 语言编写的多进程管理工具，是对 Ruby 下广泛使用的 foreman 的重写（foreman 原作者也实现了一个 Go 版本：forego，不过没有 goreman 好用）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要确认 Go 安装环境，然后直接执行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go get github.com/mattn/goreman&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译后的文件放在 &lt;code&gt;$GOPATH/bin&lt;/code&gt; 中，&lt;code&gt;$GOPATH/bin&lt;/code&gt;目录已经添加到了系统 &lt;code&gt;$PATH&lt;/code&gt; 中，所以我们可以方便执行命令 &lt;code&gt;goreman&lt;/code&gt; 命令。下面就是编写 Procfile 脚本，我们启动三个 etcd，具体对应如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;HostName&lt;/th&gt;&lt;th&gt;ip&lt;/th&gt;&lt;th&gt;客户端交互端口&lt;/th&gt;&lt;th&gt;peer 通信端口&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;infra1&lt;/td&gt;&lt;td&gt;127.0.0.1&lt;/td&gt;&lt;td&gt;2379&lt;/td&gt;&lt;td&gt;2380&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;infra2&lt;/td&gt;&lt;td&gt;127.0.0.1&lt;/td&gt;&lt;td&gt;22379&lt;/td&gt;&lt;td&gt;22380&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;infra3&lt;/td&gt;&lt;td&gt;127.0.0.1&lt;/td&gt;&lt;td&gt;32379&lt;/td&gt;&lt;td&gt;32380&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Procfile 脚本如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.16595289079229122&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Pd1oo3TBKydx40t8fXvNTX1kRLrVv0ywHibFykd6OQXzRfAG5OaQehKdHajA6M396UXswNiayUq37tpapy10Nhsg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1868&quot;/&gt;其他两个 etcd 成员的配置类似，不在赘述。配置项说明如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;--name：etcd 集群中的节点名；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--listen-peer-urls：用于节点之间通信的地址，可以监听多个；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--initial-advertise-peer-urls：与其他节点之间通信的地址；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--listen-client-urls：监听客户端通信的地址，可以有多个；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--advertise-client-urls：用于客户端与节点通信的地址；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--initial-cluster-token：标识不同 etcd 集群的 token；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--initial-cluster：即指定的 initial-advertise-peer-urls 的所有节点；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;--initial-cluster-state：new，新建集群的标志。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意上面的脚本，etcd 命令执行时需要根据本地实际的安装地址进行配置。下面我们启动 etcd 集群。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;goreman -f /opt/procfile start&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用如上的命令启动启动 etcd 集群，启动完成之后查看集群内的成员。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl --endpoints=http://localhost:22379  member list&lt;br/&gt;&lt;br/&gt;8211f1d0f64f3269, started, infra1, http://127.0.0.1:12380, http://127.0.0.1:12379, &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;91bc3c398fb3c146, started, infra2, http://127.0.0.1:22380, http://127.0.0.1:22379, &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;fd422379fda50e48, started, infra3, http://127.0.0.1:32380, http://127.0.0.1:32379, &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在单机搭建的伪集群成功，需要注意的是在集群启动时，我们通过静态的方式指定集群的成员，在实际环境中，集群成员的地址端口等信息可能不会事先知道。这时候就需要采用动态发现的机制。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.3.2 docker 启动集群&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 使用 gcr.io/etcd-development/etcd 作为容器的主要加速器， quay.io/coreos/etcd 作为辅助的加速器。可惜这两个加速器我们都没法访问，如果下载不了，可以使用笔者提供的地址：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;docker pull bitnami/etcd:3.4.7&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后将拉取的镜像重新 tag：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;docker image tag bitnami/etcd:3.4.7 quay.io/coreos/etcd:3.4.7&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;镜像设置好之后，我们启动 3 个节点的 etcd 集群，脚本命令如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;REGISTRY=quay.io/coreos/etcd&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# For each machine&lt;/span&gt;&lt;br/&gt;ETCD_VERSION=3.4.5&lt;br/&gt;TOKEN=my-etcd-token&lt;br/&gt;CLUSTER_STATE=new&lt;br/&gt;NAME_1=etcd-node-0&lt;br/&gt;NAME_2=etcd-node-1&lt;br/&gt;NAME_3=etcd-node-2&lt;br/&gt;HOST_1= 192.168.202.128&lt;br/&gt;HOST_2= 192.168.202.129&lt;br/&gt;HOST_3= 192.168.202.130&lt;br/&gt;CLUSTER=&lt;span&gt;${NAME_1}&lt;/span&gt;=http://&lt;span&gt;${HOST_1}&lt;/span&gt;:2380,&lt;span&gt;${NAME_2}&lt;/span&gt;=http://&lt;span&gt;${HOST_2}&lt;/span&gt;:2380,&lt;span&gt;${NAME_3}&lt;/span&gt;=http://&lt;span&gt;${HOST_3}&lt;/span&gt;:2380&lt;br/&gt;DATA_DIR=/var/lib/etcd&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# For node 1&lt;/span&gt;&lt;br/&gt;THIS_NAME=&lt;span&gt;${NAME_1}&lt;/span&gt;&lt;br/&gt;THIS_IP=&lt;span&gt;${HOST_1}&lt;/span&gt;&lt;br/&gt;docker run \&lt;br/&gt;  -p 2379:2379 \&lt;br/&gt;  -p 2380:2380 \&lt;br/&gt;  --volume=&lt;span&gt;${DATA_DIR}&lt;/span&gt;:/etcd-data \&lt;br/&gt;  --name etcd &lt;span&gt;${REGISTRY}&lt;/span&gt;:&lt;span&gt;${ETCD_VERSION}&lt;/span&gt; \&lt;br/&gt;  /usr/&lt;span&gt;local&lt;/span&gt;/bin/etcd \&lt;br/&gt;  --data-dir=/etcd-data --name &lt;span&gt;${THIS_NAME}&lt;/span&gt; \&lt;br/&gt;  --initial-advertise-peer-urls http://&lt;span&gt;${THIS_IP}&lt;/span&gt;:2380 --listen-peer-urls http://0.0.0.0:2380 \&lt;br/&gt;  --advertise-client-urls http://&lt;span&gt;${THIS_IP}&lt;/span&gt;:2379 --listen-client-urls http://0.0.0.0:2379 \&lt;br/&gt;  --initial-cluster &lt;span&gt;${CLUSTER}&lt;/span&gt; \&lt;br/&gt;  --initial-cluster-state &lt;span&gt;${CLUSTER_STATE}&lt;/span&gt; --initial-cluster-token &lt;span&gt;${TOKEN}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# For node 2&lt;/span&gt;&lt;br/&gt;THIS_NAME=&lt;span&gt;${NAME_2}&lt;/span&gt;&lt;br/&gt;THIS_IP=&lt;span&gt;${HOST_2}&lt;/span&gt;&lt;br/&gt;docker run \&lt;br/&gt;  -p 2379:2379 \&lt;br/&gt;  -p 2380:2380 \&lt;br/&gt;  --volume=&lt;span&gt;${DATA_DIR}&lt;/span&gt;:/etcd-data \&lt;br/&gt;  --name etcd &lt;span&gt;${REGISTRY}&lt;/span&gt;:&lt;span&gt;${ETCD_VERSION}&lt;/span&gt; \&lt;br/&gt;  /usr/&lt;span&gt;local&lt;/span&gt;/bin/etcd \&lt;br/&gt;  --data-dir=/etcd-data --name &lt;span&gt;${THIS_NAME}&lt;/span&gt; \&lt;br/&gt;  --initial-advertise-peer-urls http://&lt;span&gt;${THIS_IP}&lt;/span&gt;:2380 --listen-peer-urls http://0.0.0.0:2380 \&lt;br/&gt;  --advertise-client-urls http://&lt;span&gt;${THIS_IP}&lt;/span&gt;:2379 --listen-client-urls http://0.0.0.0:2379 \&lt;br/&gt;  --initial-cluster &lt;span&gt;${CLUSTER}&lt;/span&gt; \&lt;br/&gt;  --initial-cluster-state &lt;span&gt;${CLUSTER_STATE}&lt;/span&gt; --initial-cluster-token &lt;span&gt;${TOKEN}&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# For node 3&lt;/span&gt;&lt;br/&gt;THIS_NAME=&lt;span&gt;${NAME_3}&lt;/span&gt;&lt;br/&gt;THIS_IP=&lt;span&gt;${HOST_3}&lt;/span&gt;&lt;br/&gt;docker run \&lt;br/&gt;  -p 2379:2379 \&lt;br/&gt;  -p 2380:2380 \&lt;br/&gt;  --volume=&lt;span&gt;${DATA_DIR}&lt;/span&gt;:/etcd-data \&lt;br/&gt;  --name etcd &lt;span&gt;${REGISTRY}&lt;/span&gt;:&lt;span&gt;${ETCD_VERSION}&lt;/span&gt; \&lt;br/&gt;  /usr/&lt;span&gt;local&lt;/span&gt;/bin/etcd \&lt;br/&gt;  --data-dir=/etcd-data --name &lt;span&gt;${THIS_NAME}&lt;/span&gt; \&lt;br/&gt;  --initial-advertise-peer-urls http://&lt;span&gt;${THIS_IP}&lt;/span&gt;:2380 --listen-peer-urls http://0.0.0.0:2380 \&lt;br/&gt;  --advertise-client-urls http://&lt;span&gt;${THIS_IP}&lt;/span&gt;:2379 --listen-client-urls http://0.0.0.0:2379 \&lt;br/&gt;  --initial-cluster &lt;span&gt;${CLUSTER}&lt;/span&gt; \&lt;br/&gt;  --initial-cluster-state &lt;span&gt;${CLUSTER_STATE}&lt;/span&gt; --initial-cluster-token &lt;span&gt;${TOKEN}&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，上面的脚本是部署在三台机器上面，每台机器执行对应的脚本即可。在运行时可以指定 API 版本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;docker &lt;span&gt;exec&lt;/span&gt; etcd /bin/sh -c &lt;span&gt;&quot;export ETCDCTL_API=3 &amp;amp;&amp;amp; /usr/local/bin/etcdctl put foo bar&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;docker 的安装方式比较简单，读者根据需要可以定制一些配置。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4 动态发现启动 etcd 集群&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在大部分的情况下，集群成员的地址端口号等信息，并不会提前知道。在这种情况下，需要使用自动发现来引导 etcd 集群，而不是指定静态配置，这个过程被称为&lt;strong&gt;「发现」&lt;/strong&gt;。我们启动三个 etcd，具体对应如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;HostName&lt;/th&gt;&lt;th&gt;ip&lt;/th&gt;&lt;th&gt;客户端交互端口&lt;/th&gt;&lt;th&gt;peer 通信端口&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;etcd1&lt;/td&gt;&lt;td&gt;192.168.202.128&lt;/td&gt;&lt;td&gt;2379&lt;/td&gt;&lt;td&gt;2380&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;etcd2&lt;/td&gt;&lt;td&gt;192.168.202.129&lt;/td&gt;&lt;td&gt;2379&lt;/td&gt;&lt;td&gt;2380&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;etcd3&lt;/td&gt;&lt;td&gt;192.168.202.130&lt;/td&gt;&lt;td&gt;2379&lt;/td&gt;&lt;td&gt;2380&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4.1 协议的原理&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于 Discovery Service Protocol ，新的 etcd 节点加入时，使用共享 URL 在启动阶段发现集群中的其它成员。需要注意的是，发现协议仅在集群启动阶段生效，不能用于其它阶段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这其中涉及到发现令牌，用来标识唯一的 etcd 集群。一个发现令牌只能代表一个 etcd 集群。只要此令牌上的发现协议启动，即使启动失败，也不能用于引导其他的 etcd 集群。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有 etcd 节点都与发现服务通信，并生成集群成员列表。随后每个新节点使用此列表启动服务，该列表与 &lt;code&gt;--initial-cluster&lt;/code&gt; 选项具有相同的功能，用以设置集群的成员信息。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4.2 获取 discovery 的 token&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成将标识新集群的唯一令牌。在以下步骤中，它将用作发现键空间中的唯一前缀。一种简单的方法是使用 uuidgen，我们运行之后的结果为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ uuidgen&lt;br/&gt;&lt;br/&gt;9CBAF7C8-123B-4E72-89C9-F81E4BC5F173&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4.3 指定集群的大小&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取令牌时，必须指定群集大小。发现服务使用该大小来了解何时发现了最初将组成集群的所有成员。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;curl -X PUT http://10.0.10.10:2379/v2/keys/discovery/9CBAF7C8-123B-4E72-89C9-F81E4BC5F173/_config/size -d value=3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要把该 url 地址 http://10.0.10.10:2379/v2/keys/discovery/9CBAF7C8-123B-4E72-89C9-F81E4BC5F173 作为 &lt;code&gt;--discovery&lt;/code&gt; 参数来启动 etcd。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;节点会自动使用 http://10.0.10.10:2379/v2/keys/discovery/9CBAF7C8-123B-4E72-89C9-F81E4BC5F173 目录进行 etcd 的注册和发现服务。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4.4 公共发现服务&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们没有可用的本地 etcd 集群，则可以使用 etcd 官方提供的公共访问的 etcd 集群地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公共发现服务 &lt;code&gt;discovery.etcd.io&lt;/code&gt; 以相同的方式工作，但是有一层修饰，可以提取丑陋的 URL，自动生成 UUID，并提供针对过多请求的保护。公共发现服务在其上仍然使用 etcd 群集作为数据存储。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ curl http://discovery.etcd.io/new?size=3&lt;br/&gt;&lt;br/&gt;http://discovery.etcd.io/3e86b59982e49066c5d813af1c2e2579cbf573de&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4.5 以动态发现方式启动集群&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 发现模式下，启动 etcd 的命令如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# etcd1 启动&lt;/span&gt;&lt;br/&gt;$ /opt/etcd/bin/etcd  --name etcd1 --initial-advertise-peer-urls http://192.168.202.128:2380 \&lt;br/&gt;  --listen-peer-urls http://192.168.202.128:2380 \&lt;br/&gt;  --data-dir /opt/etcd/data \&lt;br/&gt;  --listen-client-urls http://192.168.202.128:2379,http://127.0.0.1:2379 \&lt;br/&gt;  --advertise-client-urls http://192.168.202.128:2379 \&lt;br/&gt;  --discovery https://discovery.etcd.io/3e86b59982e49066c5d813af1c2e2579cbf573de&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# etcd2 启动&lt;/span&gt;&lt;br/&gt; /opt/etcd/bin/etcd  --name etcd2 --initial-advertise-peer-urls http://192.168.202.129:2380 \&lt;br/&gt;  --listen-peer-urls http://192.168.202.129:2380 \&lt;br/&gt;  --data-dir /opt/etcd/data \&lt;br/&gt;  --listen-client-urls http://192.168.202.129:2379,http://127.0.0.1:2379 \&lt;br/&gt;  --advertise-client-urls http://192.168.202.129:2379 \&lt;br/&gt;  --discovery https://discovery.etcd.io/3e86b59982e49066c5d813af1c2e2579cbf573de&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# etcd3 启动&lt;/span&gt;&lt;br/&gt; /opt/etcd/bin/etcd  --name etcd3 --initial-advertise-peer-urls http://192.168.202.130:2380 \&lt;br/&gt;    --listen-peer-urls http://192.168.202.130:2380 \&lt;br/&gt;    --data-dir /opt/etcd/data \&lt;br/&gt;    --listen-client-urls http://192.168.202.130:2379,http://127.0.0.1:2379 \&lt;br/&gt;    --advertise-client-urls http://192.168.202.130:2379 \&lt;br/&gt;    --discovery https://discovery.etcd.io/3e86b59982e49066c5d813af1c2e2579cbf573de&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在每次启动新 etcd 集群时，使用新的 discovery token 进行注册。如果初始化启动的节点超过了请求 token 时指定的数量，则多的节点会自动转为 Proxy 模式的 etcd。需要注意的是，在我们完成了集群的初始化后，这些信息就失去了作用。当需要增加节点时，需要使用 etcdctl 进行操作。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.4.6 结果验证&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;集群启动好之后，进行验证，我们看一下集群的成员：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ /opt/etcd/bin/etcdctl member list&lt;br/&gt;&lt;span&gt;# 结果如下&lt;/span&gt;&lt;br/&gt;    40e2ac06ca1674a7, started, etcd3, http://192.168.202.130:2380, http://192.168.202.130:2379, &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    c532c5cedfe84d3c, started, etcd1, http://192.168.202.128:2380, http://192.168.202.128:2379, &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;    db75d3022049742a, started, etcd2, http://192.168.202.129:2380, http://192.168.202.129:2379, &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.17967914438502675&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Pd1oo3TBKydx40t8fXvNTX1kRLrVv0ywX63KhmeRNx6lUj71icr2YqFm5V95k5TnTRk71A4AOnaxHy1Twvk7ErA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;935&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，集群中的三个节点都是健康的正常状态。以动态发现方式启动集群成功。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4 etcd v3 的架构解析&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd v2 和 v3 在底层使用同一套 Raft 算法的两个独立应用，相互之间接口不一样、存储不一样，两个版本的数据互相隔离。由 etcd v2 升级到 etcd v3 的情况下，原有数据只能通过 etcd v2 接口访问，v3 接口创建的数据只能通过 新的 v3 的接口访问。本文重点讲解 v3 版本。etcd 总体的架构图如下所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5249569707401033&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Pd1oo3TBKydx40t8fXvNTX1kRLrVv0ywzzcibpSjVuTsTxg91stCUuDBEiaW5ZO3ibvKV1fgALcnlxLFHOvumribSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;581&quot;/&gt;分布式集群一般由奇数个节点组成，etcd 同样也是，多个 etcd 节点通过 Raft 算法相互协作。Raft 算法会选择一个主节点作为 Leader，负责数据同步和分发。当 Leader 发生故障时，系统会自动选择另一个节点作为 Leader，以再次完成数据同步。当 etcd 完成内部状态和数据协作时，仅需选择一个节点即可读取和写入数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Quorum（翻译成法定人数，简单理解为定义一个最少写入同步到多少个节点才算成功写入）机制是 etcd 中的关键概念。它定义为 (n + 1)/2，表示群集中超过一半的节点构成 Quorum。在三节点集群中，只要有两个节点可用，etcd 仍将运行。同样，在五节点集群中，只要有三个节点可用，etcd 仍会运行。这是 etcd 群集高可用性的关键。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了使 etcd 在某些节点出现故障后继续运行，必须解决分布式一致性问题。在 etcd 中，分布式共识算法由 Raft 实现。下面简要描述该算法。Raft 共识算法仅在任何两个 Quorum 具有共享成员时才可以工作。也就是说，任何有效的仲裁必须包含一个共享成员，该成员包含集群中所有已确认和已提交的数据。基于此，etcd 为 Raft 共识算法设计了一种数据同步机制，用于在更新 Leader 后同步最后 Quorum 所提交的所有数据。这样可以确保在群集状态更改时数据的一致性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4169139465875371&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Pd1oo3TBKydx40t8fXvNTX1kRLrVv0yw2HtvpibGaTdnu8bBQoIQo6jDP0bukY1kibtZ8wWseqnvR6ibaNdsZ9u3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;674&quot;/&gt;etcd 具有复杂的内部机制，但为客户端提供了简单直接的 API。如上图所示，我们可以通过 etcd 客户端访问群集数据，或通过 HTTP 直接访问 etcd，这与 curl 命令类似。etcd 中的数据结构很简单，我们可以将 etcd 的数据存储理解为存储键值数据的有序映射。etcd 还提供了一种 Watch 机制来为客户端订阅数据更改的事件。Watch 机制实时获取 etcd 中的增量数据更新，以使数据与 etcd 同步。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5 etcdctl 的实践应用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcdctl 是 etcd 的命令行客户端，用户通过 etcdctl 直接跟 etcd 进行交互，可以实现 HTTP API 的功能。在测试阶段，etcdctl 可以方便对服务进行操作或更新数据库内容。对于刚入门的同学，建议通过 etdctl 来熟悉 etcd 相关操作。需要注意的是，etcdctl 在两个不同的 etcd 版本下的行为方式也完全不同。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; ETCDCTL_API=2&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; ETCDCTL_API=3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里主要以讲解 API 3 为主。etcdctl 的命令分为数据库和非数据库两类操作。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1 常用命令介绍&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先查看一下 etcd 的版本：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ etcd --version&lt;br/&gt;&lt;br/&gt;etcd Version: 3.4.7&lt;br/&gt;Git SHA: e784ba73c&lt;br/&gt;Go Version: go1.12.12&lt;br/&gt;Go OS/Arch: linux/amd64&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们的版本是 etcd 3.4.7 ，下面介绍下 etcdctl 常用的命令。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl -h&lt;br/&gt;&lt;br/&gt;NAME:&lt;br/&gt; etcdctl - A simple &lt;span&gt;command&lt;/span&gt; line client &lt;span&gt;for&lt;/span&gt; etcd3.&lt;br/&gt;&lt;br/&gt;USAGE:&lt;br/&gt; etcdctl [flags]&lt;br/&gt;&lt;br/&gt;VERSION:&lt;br/&gt; 3.4.7&lt;br/&gt;&lt;br/&gt;API VERSION:&lt;br/&gt; 3.4&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;COMMANDS:&lt;br/&gt; alarm disarm  Disarms all alarms&lt;br/&gt; alarm list  Lists all alarms&lt;br/&gt; auth &lt;span&gt;disable&lt;/span&gt;  Disables authentication&lt;br/&gt; auth &lt;span&gt;enable&lt;/span&gt;  Enables authentication&lt;br/&gt; check datascale  Check the memory usage of holding data &lt;span&gt;for&lt;/span&gt; different workloads on a given server endpoint.&lt;br/&gt; check perf  Check the performance of the etcd cluster&lt;br/&gt; compaction  Compacts the event &lt;span&gt;history&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; etcd&lt;br/&gt; defrag   Defragments the storage of the etcd members with given endpoints&lt;br/&gt; del   Removes the specified key or range of keys [key, range_end)&lt;br/&gt; elect   Observes and participates &lt;span&gt;in&lt;/span&gt; leader election&lt;br/&gt; endpoint hashkv  Prints the KV &lt;span&gt;history&lt;/span&gt; &lt;span&gt;hash&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; each endpoint &lt;span&gt;in&lt;/span&gt; --endpoints&lt;br/&gt; endpoint health  Checks the healthiness of endpoints specified &lt;span&gt;in&lt;/span&gt; `--endpoints` flag&lt;br/&gt; endpoint status  Prints out the status of endpoints specified &lt;span&gt;in&lt;/span&gt; `--endpoints` flag&lt;br/&gt; get   Gets the key or a range of keys&lt;br/&gt; &lt;span&gt;help&lt;/span&gt;   Help about any &lt;span&gt;command&lt;/span&gt;&lt;br/&gt; lease grant  Creates leases&lt;br/&gt; lease keep-alive Keeps leases alive (renew)&lt;br/&gt; lease list  List all active leases&lt;br/&gt; lease revoke  Revokes leases&lt;br/&gt; lease timetolive Get lease information&lt;br/&gt; lock   Acquires a named lock&lt;br/&gt; make-mirror  Makes a mirror at the destination etcd cluster&lt;br/&gt; member add  Adds a member into the cluster&lt;br/&gt; member list  Lists all members &lt;span&gt;in&lt;/span&gt; the cluster&lt;br/&gt; member promote  Promotes a non-voting member &lt;span&gt;in&lt;/span&gt; the cluster&lt;br/&gt; member remove  Removes a member from the cluster&lt;br/&gt; member update  Updates a member &lt;span&gt;in&lt;/span&gt; the cluster&lt;br/&gt; migrate   Migrates keys &lt;span&gt;in&lt;/span&gt; a v2 store to a mvcc store&lt;br/&gt; move-leader  Transfers leadership to another etcd cluster member.&lt;br/&gt; put   Puts the given key into the store&lt;br/&gt; role add  Adds a new role&lt;br/&gt; role delete  Deletes a role&lt;br/&gt; role get  Gets detailed information of a role&lt;br/&gt; role grant-permission Grants a key to a role&lt;br/&gt; role list  Lists all roles&lt;br/&gt; role revoke-permission Revokes a key from a role&lt;br/&gt; snapshot restore Restores an etcd member snapshot to an etcd directory&lt;br/&gt; snapshot save  Stores an etcd node backend snapshot to a given file&lt;br/&gt; snapshot status  Gets backend snapshot status of a given file&lt;br/&gt; txn   Txn processes all the requests &lt;span&gt;in&lt;/span&gt; one transaction&lt;br/&gt; user add  Adds a new user&lt;br/&gt; user delete  Deletes a user&lt;br/&gt; user get  Gets detailed information of a user&lt;br/&gt; user grant-role  Grants a role to a user&lt;br/&gt; user list  Lists all users&lt;br/&gt; user passwd  Changes password of user&lt;br/&gt; user revoke-role Revokes a role from a user&lt;br/&gt; version   Prints the version of etcdctl&lt;br/&gt; watch   Watches events stream on keys or prefixes&lt;br/&gt;&lt;br/&gt;OPTIONS:&lt;br/&gt;      --cacert=&lt;span&gt;&quot;&quot;&lt;/span&gt;    verify certificates of TLS-enabled secure servers using this CA bundle&lt;br/&gt;      --cert=&lt;span&gt;&quot;&quot;&lt;/span&gt;     identify secure client using this TLS certificate file&lt;br/&gt;      --&lt;span&gt;command&lt;/span&gt;-timeout=5s   timeout &lt;span&gt;for&lt;/span&gt; short running &lt;span&gt;command&lt;/span&gt; (excluding dial timeout)&lt;br/&gt;      --debug[=&lt;span&gt;false&lt;/span&gt;]    &lt;span&gt;enable&lt;/span&gt; client-side debug logging&lt;br/&gt;      --dial-timeout=2s    dial timeout &lt;span&gt;for&lt;/span&gt; client connections&lt;br/&gt;  -d, --discovery-srv=&lt;span&gt;&quot;&quot;&lt;/span&gt;   domain name to query &lt;span&gt;for&lt;/span&gt; SRV records describing cluster endpoints&lt;br/&gt;      --discovery-srv-name=&lt;span&gt;&quot;&quot;&lt;/span&gt;   service name to query when using DNS discovery&lt;br/&gt;      --endpoints=[127.0.0.1:2379]  gRPC endpoints&lt;br/&gt;  -h, --&lt;span&gt;help&lt;/span&gt;[=&lt;span&gt;false&lt;/span&gt;]    &lt;span&gt;help&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; etcdctl&lt;br/&gt;      --hex[=&lt;span&gt;false&lt;/span&gt;]    &lt;span&gt;print&lt;/span&gt; byte strings as hex encoded strings&lt;br/&gt;      --insecure-discovery[=&lt;span&gt;true&lt;/span&gt;]  accept insecure SRV records describing cluster endpoints&lt;br/&gt;      --insecure-skip-tls-verify[=&lt;span&gt;false&lt;/span&gt;] skip server certificate verification&lt;br/&gt;      --insecure-transport[=&lt;span&gt;true&lt;/span&gt;]  &lt;span&gt;disable&lt;/span&gt; transport security &lt;span&gt;for&lt;/span&gt; client connections&lt;br/&gt;      --keepalive-time=2s   keepalive time &lt;span&gt;for&lt;/span&gt; client connections&lt;br/&gt;      --keepalive-timeout=6s   keepalive timeout &lt;span&gt;for&lt;/span&gt; client connections&lt;br/&gt;      --key=&lt;span&gt;&quot;&quot;&lt;/span&gt;     identify secure client using this TLS key file&lt;br/&gt;      --password=&lt;span&gt;&quot;&quot;&lt;/span&gt;    password &lt;span&gt;for&lt;/span&gt; authentication (&lt;span&gt;if&lt;/span&gt; this option is used, --user option shouldn&lt;span&gt;&#x27;t include password)&lt;br/&gt;      --user=&quot;&quot;     username[:password] for authentication (prompt if password is not supplied)&lt;br/&gt;  -w, --write-out=&quot;simple&quot;   set the output format (fields, json, protobuf, simple, table)&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，etcdctl 支持的命令很多，常用的命令选项：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;--debug 输出 CURL 命令，显示执行命令的时候发起的请求&lt;br/&gt;--no-sync 发出请求之前不同步集群信息&lt;br/&gt;--output, -o &lt;span&gt;&#x27;simple&#x27;&lt;/span&gt; 输出内容的格式(simple 为原始信息，json 为进行 json 格式解码，易读性好一些)&lt;br/&gt;--peers, -C 指定集群中的同伴信息，用逗号隔开(默认为: &lt;span&gt;&quot;127.0.0.1:4001&quot;&lt;/span&gt;)&lt;br/&gt;--cert-file HTTPS 下客户端使用的 SSL 证书文件&lt;br/&gt;--key-file HTTPS 下客户端使用的 SSL 密钥文件&lt;br/&gt;--ca-file 服务端使用 HTTPS 时，使用 CA 文件进行验证&lt;br/&gt;--&lt;span&gt;help&lt;/span&gt;, -h 显示帮助命令信息&lt;br/&gt;--version, -v 打印版本信息&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们将介绍其中常用的数据库命令。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 数据库操作&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 在键的组织上采用了如同类似文件目录的结构，即层次化的空间结构，我们可以为键指定单独的名字。etcd 数据库提供的操作，则主要围绕对键值和目录的增删改查。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2.1 键操作&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;set  指定某个键的值。例如：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl put /testdir/testkey &lt;span&gt;&quot;Hello world&quot;&lt;/span&gt;&lt;br/&gt;$ etcdctl put /testdir/testkey2 &lt;span&gt;&quot;Hello world2&quot;&lt;/span&gt;&lt;br/&gt;$ etcdctl put /testdir/testkey3 &lt;span&gt;&quot;Hello world3&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;成功写入三对键值，/testdir/testkey、/testdir/testkey2 和 /testdir/testkey3。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;get  获取指定键的值。例如：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl get /testdir/testkey&lt;br/&gt;Hello world&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;get 十六进制读指定的值：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl get /testdir/testkey --hex&lt;br/&gt;\x2f\x74\x65\x73\x74\x64\x69\x72\x2f\x74\x65\x73\x74\x6b\x65\x79 &lt;span&gt;#键&lt;/span&gt;&lt;br/&gt;\x48\x65\x6c\x6c\x6f\x20\x77\x6f\x72\x6c\x64 &lt;span&gt;#值&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;加上 &lt;code&gt;--print-value-only&lt;/code&gt; 可以读取对应的值。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;get 范围内的值&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt; $ etcdctl get /testdir/testkey /testdir/testkey3&lt;br/&gt;&lt;br/&gt;/testdir/testkey&lt;br/&gt;Hello world&lt;br/&gt;/testdir/testkey2&lt;br/&gt;Hello world2&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，获取了大于等于 /testdir/testkey，且小于 /testdir/testkey3 的键值对。testkey3 不在范围之内，因为范围是半开区间 [testkey, testkey3), 不包含 testkey3。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;获取某个前缀的所有键值对，通过 --prefix 可以指定前缀：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl get --prefix /testdir/testkey&lt;br/&gt;/testdir/testkey&lt;br/&gt;Hello world&lt;br/&gt;/testdir/testkey2&lt;br/&gt;Hello world2&lt;br/&gt;/testdir/testkey3&lt;br/&gt;Hello world3&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样既可获取所有以 /testdir/testkey 开头的键值对。当前缀获取的结果过多时，还可以通过  --limit=2 限制获取的数量：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;etcdctl get --prefix --&lt;span&gt;limit&lt;/span&gt;=2 /testdir/testkey&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;读取键过往版本的值
应用可能想读取键的被替代的值。例如，应用可能想通过访问键的过往版本来回滚到旧的配置。或者，应用可能想通过多个请求来得到一个覆盖多个键的统一视图，而这些请求可以通过访问键历史记录而来。因为 etcd 集群上键值存储的每个修改都会增加 etcd 集群的全局修订版本，应用可以通过提供旧有的 etcd 修改版本来读取被替代的键。现有如下这些键值对：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;foo = bar         &lt;span&gt;# revision = 2&lt;/span&gt;&lt;br/&gt;foo1 = bar2       &lt;span&gt;# revision = 3&lt;/span&gt;&lt;br/&gt;foo = bar_new     &lt;span&gt;# revision = 4&lt;/span&gt;&lt;br/&gt;foo1 = bar1_new   &lt;span&gt;# revision = 5&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以下是访问以前版本 key 的示例：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl get --prefix foo &lt;span&gt;# 访问最新版本的 key&lt;/span&gt;&lt;br/&gt;foo&lt;br/&gt;bar_new&lt;br/&gt;foo1&lt;br/&gt;bar1_new&lt;br/&gt;&lt;br/&gt;$ etcdctl get --prefix --rev=4 foo &lt;span&gt;# 访问第 4 个版本的 key&lt;/span&gt;&lt;br/&gt;foo&lt;br/&gt;bar_new&lt;br/&gt;foo1&lt;br/&gt;bar1&lt;br/&gt;&lt;br/&gt;$ etcdctl get --prefix --rev=3 foo &lt;span&gt;#  访问第 3 个版本的 key&lt;/span&gt;&lt;br/&gt;foo&lt;br/&gt;bar&lt;br/&gt;foo1&lt;br/&gt;bar1&lt;br/&gt;&lt;br/&gt;$ etcdctl get --prefix --rev=2 foo &lt;span&gt;#  访问第 3 个版本的 key&lt;/span&gt;&lt;br/&gt;foo&lt;br/&gt;bar&lt;br/&gt;&lt;br/&gt;$ etcdctl get --prefix --rev=1 foo &lt;span&gt;#  访问第 1 个版本的 key&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;读取大于等于指定键的 byte 值的键
应用可能想读取大于等于指定键 的 byte 值的键。假设 etcd 集群已经有下列键：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;a = 123&lt;br/&gt;b = 456&lt;br/&gt;z = 789&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;读取大于等于键 b 的 byte 值的键的命令：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl get --from-key b&lt;br/&gt;b&lt;br/&gt;456&lt;br/&gt;z&lt;br/&gt;789&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;删除键。客户端应用可以从 etcd 数据库中删除指定的键。假设 etcd 集群已经有下列键：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;foo = bar&lt;br/&gt;foo1 = bar1&lt;br/&gt;foo3 = bar3&lt;br/&gt;zoo = val&lt;br/&gt;zoo1 = val1&lt;br/&gt;zoo2 = val2&lt;br/&gt;a = 123&lt;br/&gt;b = 456&lt;br/&gt;z = 789&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;删除键 foo 的命令：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl del foo&lt;br/&gt;1 &lt;span&gt;# 删除了一个键&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;删除从 foo to foo9 范围的键的命令：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl del foo foo9&lt;br/&gt;2 &lt;span&gt;# 删除了两个键&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;删除键 zoo 并返回被删除的键值对的命令：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl del --prev-kv zoo&lt;br/&gt;1   &lt;span&gt;# 一个键被删除&lt;/span&gt;&lt;br/&gt;zoo &lt;span&gt;# 被删除的键&lt;/span&gt;&lt;br/&gt;val &lt;span&gt;# 被删除的键的值&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;删除前缀为 zoo 的键的命令：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl del --prefix zoo&lt;br/&gt;2 &lt;span&gt;# 删除了两个键&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;删除大于等于键 b 的 byte 值的键的命令：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl del --from-key b&lt;br/&gt;2 &lt;span&gt;# 删除了两个键&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2.2 watch 历史改动&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;watch 可以用来监测一个键值的变化，当该键值更新，控制台就会输出最新的值。例如：用户更新 watchkey 键值为 newwatchvalue。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl watch  watchkey&lt;br/&gt;&lt;span&gt;# 在另外一个终端: etcdctl put  watchkey newwatchvalue&lt;/span&gt;&lt;br/&gt;watchkey&lt;br/&gt;newwatchvalue&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从 foo to foo9 范围内键的命令：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl watch foo foo9&lt;br/&gt;&lt;span&gt;# 在另外一个终端: etcdctl put foo bar&lt;/span&gt;&lt;br/&gt;PUT&lt;br/&gt;foo&lt;br/&gt;bar&lt;br/&gt;&lt;span&gt;# 在另外一个终端: etcdctl put foo1 bar1&lt;/span&gt;&lt;br/&gt;PUT&lt;br/&gt;foo1&lt;br/&gt;bar1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以 16 进制格式在键 foo 上进行观察的命令：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl watch foo --hex&lt;br/&gt;&lt;span&gt;# 在另外一个终端: etcdctl put foo bar&lt;/span&gt;&lt;br/&gt;PUT&lt;br/&gt;\x66\x6f\x6f          &lt;span&gt;# 键&lt;/span&gt;&lt;br/&gt;\x62\x61\x72          &lt;span&gt;# 值&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;观察多个键 foo 和 zoo 的命令：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl watch -i&lt;br/&gt;$ watch foo&lt;br/&gt;$ watch zoo&lt;br/&gt;&lt;span&gt;# 在另外一个终端: etcdctl put foo bar&lt;/span&gt;&lt;br/&gt;PUT&lt;br/&gt;foo&lt;br/&gt;bar&lt;br/&gt;&lt;span&gt;# 在另外一个终端: etcdctl put zoo val&lt;/span&gt;&lt;br/&gt;PUT&lt;br/&gt;zoo&lt;br/&gt;val&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;查看 key 的历史修订版本。客户端应用需要获取某个键的所有修改。那么客户端应用连接到 etcd，watch 对应的 key 即可。如果 Watch 的过程中，etcd 或者客户端应用出错，又恰好发生了改动，这种情况下客户端应用可以在 Watch 时指定历史修订版本。&lt;br/&gt;假设我们完成了下列操作序列：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl put foo bar         &lt;span&gt;# revision = 2&lt;/span&gt;&lt;br/&gt;OK&lt;br/&gt;$ etcdctl put foo1 bar1       &lt;span&gt;# revision = 3&lt;/span&gt;&lt;br/&gt;OK&lt;br/&gt;$ etcdctl put foo bar_new     &lt;span&gt;# revision = 4&lt;/span&gt;&lt;br/&gt;OK&lt;br/&gt;$ etcdctl put foo1 bar1_new   &lt;span&gt;# revision = 5&lt;/span&gt;&lt;br/&gt;OK&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;观察历史改动：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 从修订版本 2 开始观察键 `foo` 的改动&lt;/span&gt;&lt;br/&gt;$ etcdctl watch --rev=2 foo&lt;br/&gt;PUT&lt;br/&gt;foo&lt;br/&gt;bar&lt;br/&gt;PUT&lt;br/&gt;foo&lt;br/&gt;bar_new&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从上一次历史修改开始观察：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 在键 `foo` 上观察变更并返回被修改的值和上个修订版本的值&lt;/span&gt;&lt;br/&gt;$ etcdctl watch --prev-kv foo&lt;br/&gt;&lt;span&gt;# 在另外一个终端: etcdctl put foo bar_latest&lt;/span&gt;&lt;br/&gt;PUT&lt;br/&gt;foo         &lt;span&gt;# 键&lt;/span&gt;&lt;br/&gt;bar_new     &lt;span&gt;# 在修改前键 foo 的上一个值&lt;/span&gt;&lt;br/&gt;foo         &lt;span&gt;# 键&lt;/span&gt;&lt;br/&gt;bar_latest  &lt;span&gt;# 修改后键 foo 的值&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;压缩修订版本。etcd 保存了历史修订版本，客户端应用可以读取键的历史版本。大量的历史版本数据，会占据很多存储，因此需要压缩历史修订版本。经过压缩，etcd 会删除历史修订版本，释放出资源。压缩修订版本之前的版本数据不可访问。压缩修订版本的命令如下所示：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl compact 5&lt;br/&gt;compacted revision 5  $ etcdctl get --rev=4 foo&lt;br/&gt;{&lt;span&gt;&quot;level&quot;&lt;/span&gt;:&lt;span&gt;&quot;warn&quot;&lt;/span&gt;,&lt;span&gt;&quot;ts&quot;&lt;/span&gt;:&lt;span&gt;&quot;2020-05-04T16:37:38.020+0800&quot;&lt;/span&gt;,&lt;span&gt;&quot;caller&quot;&lt;/span&gt;:&lt;span&gt;&quot;clientv3/retry_interceptor.go:62&quot;&lt;/span&gt;,&lt;span&gt;&quot;msg&quot;&lt;/span&gt;:&lt;span&gt;&quot;retrying of unary invoker failed&quot;&lt;/span&gt;,&lt;span&gt;&quot;target&quot;&lt;/span&gt;:&lt;span&gt;&quot;endpoint://client-c0d35565-0584-4c07-bfeb-034773278656/127.0.0.1:2379&quot;&lt;/span&gt;,&lt;span&gt;&quot;attempt&quot;&lt;/span&gt;:0,&lt;span&gt;&quot;error&quot;&lt;/span&gt;:&lt;span&gt;&quot;rpc error: code = OutOfRange desc = etcdserver: mvcc: required revision has been compacted&quot;&lt;/span&gt;}&lt;br/&gt;Error: etcdserver: mvcc: required revision has been compacted&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2.3 租约&lt;span/&gt;&lt;/h5&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;授予租约
客户端应用可以为 etcd 数据库存储内的键授予租约。当 etcd 中的键被授予租约时，该键的存活时间与租约的时间绑定，而租约的存活时间相应的被 time-to-live (TTL)管理。在租约授予时每个租约的最小 TTL 值由客户端应用指定。当租约的 TTL 到期，即代表租约就过期，此时该租约绑定的键都将被删除。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 授予租约，TTL 为 100 秒&lt;/span&gt;&lt;br/&gt;$ etcdctl lease grant 100&lt;br/&gt;lease 694d71ddacfda227 granted with TTL(10s)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 附加键 foo 到租约 694d71ddacfda227&lt;/span&gt;&lt;br/&gt;$ etcdctl put --lease=694d71ddacfda227 foo10 bar&lt;br/&gt;OK&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;建议时间设置久一点，否则来不及操作会出现如下的错误：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code/&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;撤销租约
应用通过租约 id 可以撤销租约。撤销租约将删除所有它附带的 key。假设我们完成了下列的操作：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl lease revoke 694d71ddacfda227&lt;br/&gt;lease 694d71ddacfda227 revoked&lt;br/&gt;&lt;br/&gt;$ etcdctl get foo10&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;刷新租期&lt;br/&gt;应用程序可以通过刷新其 TTL 来保持租约活着，因此不会过期。&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl lease keep-alive 694d71ddacfda227&lt;br/&gt;lease 694d71ddacfda227 keepalived with TTL(100)&lt;br/&gt;lease 694d71ddacfda227 keepalived with TTL(100)&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;查询租期
应用程序可能想要了解租赁信息，以便它们可以续订或检查租赁是否仍然存在或已过期。应用程序也可能想知道特定租约所附的 key。&lt;/p&gt;&lt;p&gt;假设我们完成了以下一系列操作：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl lease grant 300&lt;br/&gt;lease 694d71ddacfda22c granted with TTL(300s)&lt;br/&gt;&lt;br/&gt;$ etcdctl put --lease=694d71ddacfda22c foo10 bar&lt;br/&gt;OK&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;获取有关租赁信息以及哪些 key 使用了租赁信息：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;$ etcdctl lease timetolive 694d71ddacfda22c&lt;br/&gt;lease 694d71ddacfda22c granted with TTL(300s), remaining(282s)&lt;br/&gt;&lt;br/&gt;$ etcdctl lease timetolive --keys 694d71ddacfda22c&lt;br/&gt;lease 694d71ddacfda22c granted with TTL(300s), remaining(220s), attached keys([foo10])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6 etcd 安全运维&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 支持通过 TLS 协议进行的加密通信。TLS 通道可用于对等体之间的加密内部群集通信以及加密的客户端流量。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.1 TLS 与 SSL&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;互联网信息明文传播，带来了窃听风险，即第三方可以窃取通信内容；篡改风险，通信内容被篡改；冒充风险，身份被冒充，从而参与通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 SSL/TLS 协议实现互联网的通信安全。SSL/TLS 协议可以解决上述提到的三个问题，通信加密，使得第三方无法窃听；校验机制防止篡改，一旦被篡改，通信双方会立刻发现；安全身份证书防止身份被冒充。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TLS 是安全传输层协议，如果需要实现 HTTPS 加密访问，保障通信数据的安全，就需要 SSL 证书，下面我们开始实践如何实现 etcd 集群成员之间的通信。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.2 进行 TLS 加密实践&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了进行实践，我们将会安装一些实用的命令行工具，这包括 cfssl、cfssljson。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CFSSL 是 CloudFlare 的 PKI/TLS 工具，既是一个命令行工具，同时又可以用于签名，作为 HTTP API 服务器，验证和绑定 TLS 证书。它需要 Go 1.12+ 才能构建。环境配置如下：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;HostName&lt;/th&gt;&lt;th&gt;ip&lt;/th&gt;&lt;th&gt;客户端交互端口&lt;/th&gt;&lt;th&gt;peer 通信端口&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;etcd1&lt;/td&gt;&lt;td&gt;192.168.202.128&lt;/td&gt;&lt;td&gt;2379&lt;/td&gt;&lt;td&gt;2380&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;etcd2&lt;/td&gt;&lt;td&gt;192.168.202.129&lt;/td&gt;&lt;td&gt;2379&lt;/td&gt;&lt;td&gt;2380&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;etcd3&lt;/td&gt;&lt;td&gt;192.168.202.130&lt;/td&gt;&lt;td&gt;2379&lt;/td&gt;&lt;td&gt;2380&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.2.1 安装 cfssl&lt;span/&gt;&lt;/h5&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ ls ~/Downloads/cfssl&lt;br/&gt;cfssl-certinfo_1.4.1_linux_amd64 cfssl_1.4.1_linux_amd64          cfssljson_1.4.1_linux_amd64&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;chmod +x cfssl_1.4.1_linux_amd64 cfssljson_1.4.1_linux_amd64 cfssl-certinfo_1.4.1_linux_amd64&lt;br/&gt;&lt;br/&gt;mv cfssl_1.4.1_linux_amd64 /usr/&lt;span&gt;local&lt;/span&gt;/bin/cfssl&lt;br/&gt;mv cfssljson_1.4.1_linux_amd64 /usr/&lt;span&gt;local&lt;/span&gt;/bin/cfssljson&lt;br/&gt;mv cfssl-certinfo_1.4.1_linux_amd64 /usr/bin/cfssl-certinfo&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装完成之后，查看版本信息的结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ cfssl version&lt;br/&gt;&lt;br/&gt;Version: 1.4.1&lt;br/&gt;Runtime: go1.12.12&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.2.2 配置 CA 并创建 TLS 证书&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们将使用 CloudFlare&#x27;s PKI 工具 cfssl 来配置 PKI Infrastructure，然后使用它去创建 Certificate Authority（CA）， 并为 etcd 创建 TLS 证书。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先创建 ssl 配置目录：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;mkdir /data/etcd/{bin,cfg,ssl} -p&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; /data/etcd/ssl/&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd ca 配置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cat &amp;lt;&amp;lt; EOF | tee ca-config.json&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;signing&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;default&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;expiry&quot;&lt;/span&gt;: &lt;span&gt;&quot;87600h&quot;&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;&quot;profiles&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;etcd&quot;&lt;/span&gt;: {&lt;br/&gt;         &lt;span&gt;&quot;expiry&quot;&lt;/span&gt;: &lt;span&gt;&quot;87600h&quot;&lt;/span&gt;,&lt;br/&gt;         &lt;span&gt;&quot;usages&quot;&lt;/span&gt;: [&lt;br/&gt;            &lt;span&gt;&quot;signing&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;key encipherment&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;server auth&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;client auth&quot;&lt;/span&gt;&lt;br/&gt;        ]&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;EOF&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd ca 证书：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cat &amp;lt;&amp;lt; EOF | tee ca-csr.json&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;&quot;CN&quot;&lt;/span&gt;: &lt;span&gt;&quot;etcd CA&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;key&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;algo&quot;&lt;/span&gt;: &lt;span&gt;&quot;rsa&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;size&quot;&lt;/span&gt;: 2048&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;&quot;names&quot;&lt;/span&gt;: [&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;&quot;C&quot;&lt;/span&gt;: &lt;span&gt;&quot;CN&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;L&quot;&lt;/span&gt;: &lt;span&gt;&quot;Shanghai&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;ST&quot;&lt;/span&gt;: &lt;span&gt;&quot;Shanghai&quot;&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    ]&lt;br/&gt;}&lt;br/&gt;EOF&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成 CA 凭证和私钥：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ cfssl gencert -initca ca-csr.json | cfssljson -bare ca&lt;br/&gt;&lt;br/&gt;2020/04/30 20:36:58 [INFO] generating a new CA key and certificate from CSR&lt;br/&gt;2020/04/30 20:36:58 [INFO] generate received request&lt;br/&gt;2020/04/30 20:36:58 [INFO] received CSR&lt;br/&gt;2020/04/30 20:36:58 [INFO] generating key: rsa-2048&lt;br/&gt;2020/04/30 20:36:58 [INFO] encoded CSR&lt;br/&gt;2020/04/30 20:36:58 [INFO] signed certificate with serial number 252821789025044258332210471232130931231440888312&lt;br/&gt;&lt;br/&gt;$ ls&lt;br/&gt;&lt;br/&gt;ca-config.json  ca-csr.json  ca-key.pem  ca.csr  ca.pem&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd server 证书：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cat &amp;lt;&amp;lt; EOF | tee server-csr.json&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;&quot;CN&quot;&lt;/span&gt;: &lt;span&gt;&quot;etcd&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;hosts&quot;&lt;/span&gt;: [&lt;br/&gt;    &lt;span&gt;&quot;192.168.202.128&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;192.168.202.129&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;192.168.202.130&quot;&lt;/span&gt;&lt;br/&gt;    ],&lt;br/&gt;    &lt;span&gt;&quot;key&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;algo&quot;&lt;/span&gt;: &lt;span&gt;&quot;rsa&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;size&quot;&lt;/span&gt;: 2048&lt;br/&gt;    },&lt;br/&gt;    &lt;span&gt;&quot;names&quot;&lt;/span&gt;: [&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;&quot;C&quot;&lt;/span&gt;: &lt;span&gt;&quot;CN&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;L&quot;&lt;/span&gt;: &lt;span&gt;&quot;Beijing&quot;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&quot;ST&quot;&lt;/span&gt;: &lt;span&gt;&quot;Beijing&quot;&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    ]&lt;br/&gt;}&lt;br/&gt;EOF&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成 server 证书：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=etcd server-csr.json | cfssljson -bare server&lt;br/&gt;2020/04/30 20:44:37 [INFO] generate received request&lt;br/&gt;2020/04/30 20:44:37 [INFO] received CSR&lt;br/&gt;2020/04/30 20:44:37 [INFO] generating key: rsa-2048&lt;br/&gt;2020/04/30 20:44:37 [INFO] encoded CSR&lt;br/&gt;2020/04/30 20:44:37 [INFO] signed certificate with serial number 73061688633166283265484923779818839258466531108&lt;br/&gt;&lt;br/&gt;ls&lt;br/&gt;ca-config.json  ca-csr.json  ca-key.pem  ca.csr  ca.pem  server-csr.json  server-key.pem  server.csr  server.pem&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动 etcd 集群，命令的配置如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#etcd1 启动&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;$ /data/etcd/bin/etcd --name etcd1 --initial-advertise-peer-urls https://192.168.202.128:2380 \&lt;br/&gt;     --listen-peer-urls https://192.168.202.128:2380 \&lt;br/&gt;     --listen-client-urls https://192.168.202.128:2379,https://127.0.0.1:2379 \&lt;br/&gt;     --advertise-client-urls https://192.168.202.128:2379 \&lt;br/&gt;     --initial-cluster-token etcd-cluster-1 \&lt;br/&gt;     --initial-cluster etcd1=https://192.168.202.128:2380, etcd2=https://192.168.202.129:2380, etcd3=https://192.168.202.130:2380 \&lt;br/&gt;     --initial-cluster-state new \&lt;br/&gt;     --client-cert-auth --trusted-ca-file=/data/etcd/ssl/ca.pem \&lt;br/&gt;     --cert-file=/opt/etcd/ssl/server.pem --key-file=/data/etcd/ssl/server-key.pem \&lt;br/&gt;     --peer-client-cert-auth --peer-trusted-ca-file=/data/etcd/ssl/ca.pem \&lt;br/&gt;     --peer-cert-file=/opt/etcd/ssl/server.pem --peer-key-file= /data/etcd/ssl/server-key.pem&lt;br/&gt;&lt;br/&gt;&lt;span&gt;#etcd2、etcd3 类似，此处省略&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过三台服务器的控制台可以知道，集群已经成功建立，我们进行验证：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看三个节点的健康状况，&lt;code&gt;endpoint health&lt;/code&gt; ；其次，查看集群的成员列表，是否输出三个成员；最后，经过 TLS 加密的 etcd 集群，在进行操作时，需要加上认证相关的信息，尝试先写再读的操作是否能够正常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照上述的步骤进行操作，这个验证的实践交给读者自行尝试。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.2.3 自动证书&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果集群需要加密的通信但不需要经过身份验证的连接，则可以将 etcd 配置为自动生成其密钥。在初始化时，每个成员都基于其通告的 IP 地址和主机创建自己的密钥集。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在每台机器上，etcd 将使用以下标志启动：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ etcd --name etcd1 --initial-advertise-peer-urls https://192.168.202.128:2380 \&lt;br/&gt;  --listen-peer-urls https://192.168.202.128:2380 \&lt;br/&gt;  --listen-client-urls https://192.168.202.128:2379,https://127.0.0.1:2379 \&lt;br/&gt;  --advertise-client-urls https://10.0.1.10:2379 \&lt;br/&gt;  --initial-cluster-token etcd-cluster-1 \&lt;br/&gt;  --initial-cluster infra0=https://192.168.202.128:2380,infra1=https://192.168.202.129:2380,infra2=https://192.168.202.130:2380 \&lt;br/&gt;  --initial-cluster-state new \&lt;br/&gt;  --auto-tls \&lt;br/&gt;  --peer-auto-tls&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于自动签发证书并不认证身份，因此直接 curl 会返回错误。需要使用 curl 的 &lt;code&gt;-k&lt;/code&gt; 命令屏蔽对证书链的校验。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7 小结&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;etcd 具有极佳的稳定性、可靠性、可伸缩性，为云原生分布式系统提供了必要的协调机制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要介绍了 etcd 的入门知识以及相关的实践。etcd 被设计为大型分布式系统的存储基石，etcd 以一致且容错的方式存储元数据。etcd 集群旨在提供具有稳定性、可靠性、可伸缩性和性能的键值存储。使用 etcd 的常见分布式场景包括领导者选举、键值对存储、分布式锁和消息订阅与发布等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实践是最好的学习方式，在看完本文之后，希望大家能够参照本文的介绍，进行相应的实践，期待你的讨论交流。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>