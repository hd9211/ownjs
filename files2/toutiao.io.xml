<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>66b6f89cb243de9f9900eb88ed52dcd9</guid>
<title>趣谈IO多路复用的本质</title>
<link>https://toutiao.io/k/j4nqhbc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single js_wx_tap_highlight wx_tap_card&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left js_a11y_comma js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzUzNjAxODg4MQ==&amp;amp;action=getalbum&amp;amp;album_id=2155317684974993409#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;2155317684974993409&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#网络通信&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;15个&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;在&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486564&amp;amp;idx=1&amp;amp;sn=07ae2b4f11ceedb029f6351e3d67c2dc&amp;amp;chksm=fafde6cacd8a6fdc9f5b0ce668bcc7b57655f3cb3c427152ae70cf9f96bb6a6b778689e74dc4&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《轻松搞懂5种IO模型》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;《轻松搞懂5种IO模型》&lt;/a&gt;中，我发起了一个投票。&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;vote_area&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;答案是【同步IO多路复用】。目前，60%的朋友答对了。原因这里解释一下。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;同步和异步的概念&lt;/span&gt;区别&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;同步：线程自己去获取结果。(一个线程)&lt;/p&gt;&lt;p&gt;异步：线程自己不去获取结果，而由其他线程送结果。(至少两个线程)&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;异步执行如下图所示，除非不需要知道结果，否则一般会有一个回调方法。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6081632653061224&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibwAicyibKwptvaTrLpel9o7xt7uXTkFdFoPwoZdMWodV4Mic1JwZFDZo26aS8tKQUYaeJSN2eHcY9Pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;490&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;IO多路复用的本质&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;为了彻底理解IO多路复用是同步还是异步，咱们探究一下IO多路复用的本质。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;I/O多路复用，复用的IO监听等待这条路。实际上就是用select/poll/epoll监听多个io对象，当io对象有变化（有数据）的时候就通知用户进程。好处就是单个进程可以处理多个socket。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;select/poll/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;对于每一个socket，一般都设置成为non-blocking，但是，整个用户的process其实是一直被阻塞的。只不过process是被select这个函数阻塞，而不是被socket IO给阻塞。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7582644628099173&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlibwAicyibKwptvaTrLpel9o7x60ehaqKgCXiciadN6g65vhRgJRnwyv1BU2cLzMiaDbricyZbwxnnuDjBcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;484&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;I/O多路复用的流程如上图所示：&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;（1）当用户进程调用了select，那么整个进程会被阻塞；&lt;/p&gt;&lt;p&gt;（2）而同时，内核会“监视”所有select负责的socket；&lt;/p&gt;&lt;p&gt;（3）当任何一个socket中的数据准备好了，select就会返回；&lt;/p&gt;&lt;p&gt;（4）这个时候用户进程再调用read/accept/write操作，做一些数据从内核拷贝到用户进程这样的事情。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247486330&amp;amp;idx=1&amp;amp;sn=e85e201059c1c5575481e03531b06212&amp;amp;chksm=fafde1d4cd8a68c235ef3cbed83bf0b6ac3a80052c0a492d8c2a217006cf4fa530f2f74f01c3&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;文件描述符&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;文件描述符&lt;/a&gt;（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;事实上，I/O 多路复用有时候性能比同步阻塞IO还更差一些。因为这里需要使用两个系统调用(select 和 recvfrom)，而同步阻塞IO只调用了一个系统调用(recvfrom)。但是，用select的优势在于它可以同时处理多个连接。所以，如果处理的连接数不是很高的话，可能延迟还更大。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;打个比方：行军打仗讲究粮草先行。诸葛亮比较牛，他打仗只带少量粮草，其他靠敌军送。这天他又派了暗探去查看敌军粮草的守卫情况。如果敌人守备松懈，则趁机偷粮。如果这个暗探只偷一袋粮食，那效率最高的是不是他看到敌军守备松懈就直接进去偷粮（同步阻塞IO）？但是他要偷的是十万大军的粮食，那他就要先回去汇报一声：“守备松懈啦”。然后百人小分队一起去把粮草偷出来(I/O 多路复用)。当然啦，以诸葛亮的一贯作风而言，最后他还得放一把火。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;暗探在同步阻塞模式下，打探敌情也是他，偷粮也是他。在诸葛亮团队中，暗探在打探敌情时最终暗探是第一个获取到结果的。暗探在偷粮时也是第一个自己知道结果的。（同步）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;暗探在I/O 多路复用模式下，打探敌情也是他，偷粮是百人小分队。在诸葛亮团队中，暗探在打探敌情时最终执行者暗探是第一个获取到结果的。百人小分队在偷粮时也是百人小分队自己先知道结果的。（同步）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;综上，IO多路复用是同步的。&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>56499e8e5f25081a01c89ba021388f43</guid>
<title>MQTT、CoAP 还是 LwM2M？主流物联网协议如何选择</title>
<link>https://toutiao.io/k/10rarjx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;Zigbee 是一种网状网络无线协议，专为建筑和家庭自动化应用而设计，是物联网环境中最流行的网状协议之一。目前主要用于局域网内连接，在设备侧以网关的身份接入控制各类设备。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-renderer-start-pos=&quot;8617&quot;&gt;&lt;strong&gt;▍&lt;span&gt;协议特性&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;低功耗：发射功率仅为 1mW，在低耗电待机模式下，两节 5 号干电池可使用长达 2 年，免去了充电或者频繁更换电池的麻烦。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;低成本：由于简单而紧凑的协议大大降低了其对通信控制的要求从而降低硬件成本，同时免收协议专利费。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;低速率：ZigBee 工作在 20～250kbps 的速率，分别提供 250 kbps(2.4GHz)、40kbps(915 MHz) 和 20kbps(868 MHz) 的原始数据吞吐率，满足低速率传输数据的应用需求。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;近距离：相邻节点传输范围在 10～100m 之间，基本覆盖普通家庭和办公环境；增加发射功率后可增加到 1～3km，通过路由和节点间通信的接力，传输距离将可以更远。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;低时延：ZigBee 的响应速度较快，一般从睡眠转入工作状态只需 15ms，节点连接进入网络只需 30ms，进一步节省了电能。相比较，蓝牙需要 3～10s、WiFi 需要 3s。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;高容量：ZigBee 可采用星状、片状和网状网络结构，由一个主节点管理若干子节点，最多一个主节点可管理 254 个子节点；同时主节点还可由上一层网络节点管理，最多可组成 65000 个节点的大网。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;高安全：ZigBee 提供了 CRC 数据包完整性检查功能，支持鉴权和认证，采用了 AES-128 的加密算法，各个应用都可以灵活确定其安全属性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;免许可证频段：直接序列扩频用于工业科学医学（ISM）频段：2.4GHz（全球），915MHz（北美），868MHz（欧洲）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;h3 data-renderer-start-pos=&quot;9023&quot;&gt;&lt;strong&gt;▍&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;市场状况&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;Zigbee 技术具有低功耗、大节点容量、短时延、安全可靠等突出优点，可满足智能家居应用需求，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;是智能家居核心无线组网连接技术&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;得益于中国智能家居市场快速发展，应用 Zigbee 技术的智能家居设备数量不断增长，Zigbee 技术应用推广步伐日益加快。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相比同为无线局域网技术体系的 WiFi、蓝牙技术，Zigbee 技术在功耗、节点容量、自组网能力、安全性方面具有突出优势，应用规模不断扩大。&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;102891&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;NB-IoT&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;NB-IoT 是由 3GPP 标准化组织制定的一种新型蜂窝技术，属于低功率广域 （LPWA） 物联网连接的一种，主要用于连接带宽资源受限的终端，允许终端以比 GRPS、3G、LTE 等技术更少的资源收集和交换数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;NB-IoT 在 2017-2018 年发展迅速，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;全球众多运营商陆续实现了商用部署&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。NB-IoT 的低成本、低功耗和广覆盖使得用户能够实现传统蜂窝网络无法支持的新场景新应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2020 年 7 月 9 日，3GPP 宣布 5G R16 标准冻结，NB-IoT 正式纳入 5G 标准，成为 5G mMTC 海量物联网连接场景核心技术。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-renderer-start-pos=&quot;8617&quot;&gt;&lt;strong&gt;▍&lt;span&gt;协议特性&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;引入了低功耗的「睡眠」模式（PSM、eDRX）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;降低了对通信品质要求，简化了终端设计（半双工模式、协议栈简化等）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通过两种功能优化模式（CP 模式、UP 模式）简化流程，减少了终端和网络的交互量。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;超低覆盖，在 GPRS 的基础上覆盖增强 20dB，覆盖范围是 GPRS 的三倍。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;h3 data-renderer-start-pos=&quot;9023&quot;&gt;&lt;strong&gt;▍&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;市场状况&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;当前，NB-IoT 已进入亿级连接时代，后续随着全球运营商对商用 NB-IoT 5G 网络的全覆盖建设，NB-IoT 将在智能家居、智慧农业、工业制造、能源表计、消防烟感、物流跟踪、金融支付等各领域中持续爆发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以中国电信物联网开放平台为例，该平台实现了对中国电信 NB-IoT 以及其他网络物联网设备的集中接入，并为政企用户提供物联网设备管理、数据接口以及应用使能等服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;EMQ 从该平台建设之初即已参与，配合天翼物联为该平台研发 NB-IoT 设备接入与消息路由能力，并同时支持电信 TLINK、MQTT 等协议设备的接入，平台整体设计接入能力达亿级，详情请查看：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NjAyMjM0NQ==&amp;amp;mid=2247485925&amp;amp;idx=1&amp;amp;sn=9c153fa80e7bbf2f56efa963c744566c&amp;amp;chksm=cf39d6c3f84e5fd578ff12685cd519012e6d666d8b74f68aa0dfc92550068a6d6e47aeb4b032&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;NB-IoT 爆发户，EMQ 助力企业开启亿级物联网连接时代&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;NB-IoT 爆发期，EMQ 助力企业开启亿级物联网连接时代&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-renderer-start-pos=&quot;9023&quot;&gt;&lt;strong&gt;▍&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;102891&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;LoRa&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;LoRa 协议是一个低功耗、远距离、无线广域网的标准协议，其名称来自于「远距离（Long Range）」的简称。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;LoRa 相比其他无线传播协议如 ZigBee、蓝牙、WIFI 最大的特点是同功耗下传播距离更远，实现了低功耗和远距离的统一，它在同样的功耗下比传统的无线射频通信距离扩大 3-5 倍。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;LoRa 在物联网应用中的无线技术有多种，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;可组成局域网或广域网&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。LoRa 网络主要由终端（可内置 LoRa 模块）、网关（或称基站）、Server 和云四部分组成。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;LoRaWAN 的数据传输速率范围为 0.3 kbps 至 37.5 kbps，为了最大化终端设备电池的寿命和整个网络容量，LoRaWAN 网络服务器通过一种速率自适应（Adaptive Data Rate , ADR）方案来控制数据传输速率和每一终端设备的射频输出功率&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-renderer-start-pos=&quot;8617&quot;&gt;&lt;strong&gt;▍&lt;span&gt;协议特性&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;覆盖面：LoRa 单一网关的遮盖间距一般在 3-5km 的范畴，宽阔地区乃至达到 15km 之上。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;低功耗：充电电池供电系统能够 支撑点多年乃至十余年。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;高容量：得益于终端无联接情况的特点，可以保证大量终端的接入。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;低成本：通信网络成本费极低，另外适用窄带传输数据。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;安全系数：采用 AES128 加密，安全系数高。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3 data-renderer-start-pos=&quot;9023&quot;&gt;&lt;strong&gt;▍&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;市场状况&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;对于智慧农业、智慧城市、工业物联网 (IIoT)、智能环境、智能家居和楼宇、智能公用事业和计量以及智能供应链和物流中的农村或室内应用场景，LoRa 具有极高的灵活性。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;LoRa 组网方便，利用 LoRa 极强的穿透力，可以低成本实现对较大范围内的设备连接，相比通过 NB-IoT 和运营商 SIM 卡接入，LoRa 不需要每年换卡或缴费，长期使用拥有较低的成本。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-renderer-start-pos=&quot;9023&quot;&gt;&lt;strong&gt;▍&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;102891&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;MQTT&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;MQTT 协议是基于发布/订阅模式的物联网通信协议，凭借简单易实现、支持 QoS、报文小等特点，占据了物联网协议的半壁江山。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MQTT 协议广泛应用于物联网、移动互联网、智能硬件、车联网、电力、能源等领域，既能作为网关在设备侧接入通信，也能作为设备-云端的通信协议。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;ZigBee、LoRa 等绝大多数网关协议最终都转换为 MQTT 协议接入上云。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.37592592592592594&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hyalCR7bGa7UY3rXgB0JQpLqO8woCXE46X7icRQHvfdE7Ing4LfyppN10Vxv3VJeNc81PWTkeYMOyL9jVcCyHCg/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-renderer-start-pos=&quot;8617&quot;&gt;&lt;strong&gt;▍&lt;span&gt;协议特性&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;轻量可靠：MQTT 报文紧凑，可在严重受限的硬件设备和低带宽、高延迟的网络上实现稳定传输。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;发布/订阅模式：基于发布/订阅模式，发布订阅模式的优点在于发布者与订阅者的解耦：订阅者与发布者不需要建立直接连接、也不需要同时在线。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;为物联网而生：提供心跳机制、遗嘱消息、QoS 质量等级+离线消息、主题和安全管理等全面的物联网应用特性。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;生态更完善：覆盖全语言平台的客户端和 SDK，有成熟的 Broker 服务端软件，能够支持海量 Topic ，千万级设备接入量，提供丰富的企业集成能力。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3 data-renderer-start-pos=&quot;9023&quot;&gt;&lt;strong&gt;▍&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;通信模式&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;MQTT 采用发布订阅模式通信，发布订阅模式区别于传统的客户端-服务器模式，它使发送消息的客户端（发布者）与接收消息的客户端（订阅者）分离，发布者与订阅者不需要建立直接联系。我们既可以让多个发布者向一个订阅者发布消息，也可以让多个订阅者同时接收一个发布者的消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4444444444444444&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/hyalCR7bGa7UY3rXgB0JQpLqO8woCXE4ugDibTRxc3RialmiadJTdAbujFakmzPzuM4trnRI0bOqSNEYruDamUPQw/640?wx_fmt=png&quot; data-type=&quot;png&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-renderer-start-pos=&quot;9023&quot;&gt;&lt;strong&gt;▍&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;市场状况&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;MQTT 是 IoT 领域的最重要的标准协议之一，广泛用于物联网、车联网、工业物联网、智能家居、智慧城市、电力石油能源等行业。&lt;/span&gt;&lt;/p&gt;&lt;p data-renderer-start-pos=&quot;4343&quot;&gt;&lt;span&gt;MQTT 是 AWS IoT Core、 Azure IoT Hub、阿里云物联网平台等顶级云厂商物联网平台标准通信协议，是工业互联网、车联网、智能家居等各个行业以及诸多网关协议上云的首选协议。&lt;/span&gt;&lt;/p&gt;&lt;p data-renderer-start-pos=&quot;4442&quot;&gt;&lt;span&gt;EMQ X 作为全球最热门、最成熟的 MQTT Broker 之一，提供了「随处运行，无限连接，任意集成」云原生分布式物联网接入平台，一体化的分布式 MQTT 消息服务和强大的 IoT 规则引擎，为高可靠、高性能的物联网实时数据移动、处理和集成提供动力，助力企业快速构建关键业务的 IoT 平台与应用&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-renderer-start-pos=&quot;9023&quot;&gt;&lt;strong&gt;▍&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;102891&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;CoAP&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;CoAP 是一种在物联网世界的类 HTTP 的协议，使用在资源受限的物联网设备上，它的详细规范定义在 RFC 7252。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于物联网设备大多都是资源限制型的，比如 CPU、RAM、Flash、网络宽带等。对于这类设备来说，想要直接使用现有网络的TCP和HTTP来实现设备实现信息交换是不现实的。为了让这部分设备能够顺利接入网络，CoAP 协议应运而生&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-renderer-start-pos=&quot;8617&quot;&gt;&lt;strong&gt;▍&lt;span&gt;协议特性&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;CoAP 参考了很多 HTTP 的设计思路，同时也根据受限资源限制设备的具体情况改良了诸多的设计细节，增加了很多实用的功能。&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3 data-renderer-start-pos=&quot;9023&quot;&gt;&lt;strong&gt;▍&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;市场状况&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;相比于 MQTT，CoAP 更加轻量、开销更低，在某些特定的设备和网络环境下更为合适。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;EMQ X 以及部分公有云物联网平台都提供提供了 CoAP 接入能力，详情参考：&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NjAyMjM0NQ==&amp;amp;mid=2247487462&amp;amp;idx=1&amp;amp;sn=d660071d6ffe504328a20d55bb8a3840&amp;amp;chksm=cf39d0c0f84e59d6da5f341bb5cec31afe3d23d845842e140cf2be5f9aaff7ed16bd9708d1f2&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;MQTT 和 CoAP 在 EMQ X 世界的一次「约会」&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;MQTT 和 CoAP 在 EMQ X 世界的一次「约会」&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;102891&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;LwM2M&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;LwM2M 是适用于资源有限的终端设备管理的轻量级物联网协议。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;LwM2M 协议诞生于 2013 年底，由 OMA（Open Mobile Alliance）提出并定义。目前的成熟版本号依然是 1.0，OMA 的专家们正为 1.1 版而努力。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-renderer-start-pos=&quot;8617&quot;&gt;&lt;strong&gt;▍&lt;span&gt;协议特性&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;p&gt;&lt;span&gt;LwM2M 协议最主要的实体包括 LwM2M Server 和 LwM2M Client。&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;span&gt;此外，根据需要还可以加入LwM2M引导服务器（Bootstrap Server）或智能卡（SmartCard），对客户端完成初始的引导。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;LwM2M 协议有以下几个突出特点：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;协议基于 REST 架构。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;协议的消息传递是通过 CoAP 协议来达成的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;协议定义了一个紧凑高效又不乏扩展性的数据模型。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;考虑到与时俱进，实现简洁易懂的风格，LwM2M 协议采用了 REST。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但由于协议的服务对象是资源有限的终端设备，传统的 HTTP 数据传输方式显得过分笨重，难以支持受限资源，因此选择了具备 REST 风格的 CoAP 来完成消息和数据传递。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一方面 CoAP 基于 UDP，与 TCP 相比，在网络资源有限及无法确保设备始终在线的环境里更加游刃有余（出于安全性考虑，使用了基于 UDP 的 DTLS 安全传输协议）。另一方面 CoAP 本身的消息结构非常简单，报文压缩，主要部分可以做到特别小巧，无需占用过多资源。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;出于类似的考虑，协议的数据结构必须足够简单。LwM2M 协议定义了一个以资源（Resource）为基本单位的模型，每个资源可以携带数值，可以指向地址，以表示 LwM2M 客户端中每一项可用的信息。资源都存在于对象实例中（Object Instance），即对象（Object）的实例化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;LwM2M 协议预定义了 8 种对象（Object）来满足基本的需求，分别是：&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Object&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Object ID&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Security（安全对象）&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;0&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Server（服务器对象）&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;1&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Access Control（访问控制对象）&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;2&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Device（设备对象）&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;3&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Connectivity Monitoring（连通性监控对象）&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;4&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Firmware（固件对象）&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;5&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Location（位置对象）&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;6&lt;br/&gt;&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;Connectivity Statistics（连通性统计对象）&lt;/span&gt;&lt;/td&gt;&lt;td valign=&quot;top&quot;&gt;&lt;span&gt;7&lt;/span&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;考虑到扩展性，协议也允许根据实际需要自定义更多的对象。在这样的数据模型中，资源、对象实例以及对象都是用数字对应的ID来表示的，以实现最大程度的压缩，因此任何资源都可以用最多 3 级的简洁方式表示，例如 /1/0/1 表示服务器对象（Server Object）第 1 个实例中的服务器短 ID 资源。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在注册阶段，LwM2M 客户端把携带了资源信息的对象实例传递给 LwM2M 服务器，以通知服务器自身设备所具备的能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;EMQ 也实现了 EMQ X 服务器上的 LwM2M 接入能力，实现了 LwM2M 协议的大部分功能，LwM2M 设备可以注册至 EMQ X-LWM2M 上，从而通过 EMQ X-LWM2M 访问并管理设备，设备也可以向 EMQ X-LWM2M 上报信息，并使用 EMQ 后端的服务来采集数据。&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;title&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;102891&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;strong&gt;XMPP&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;XMPP 可拓展消息处理现场协议是基于 XML 的即时通讯协议，协议将通信上下文信息嵌入到 XML 结构化数据中，使得人与人之间、应用系统之间以及人与应用系统之间能即时通讯。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h3 data-renderer-start-pos=&quot;9023&quot;&gt;&lt;strong&gt;▍&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;协议特性&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;所有 XMPP 信息都是以 XML 为基础的，信息交换的事实标准，扩展性强。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;XMPP 系统是一个分布式系统，每台服务器控制自己的资源。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;XMPP 协议是公开开源的，使用 XML 定义了客户端和服务器端的交互。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;h3 data-renderer-start-pos=&quot;9023&quot;&gt;&lt;strong&gt;▍&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;市场状况&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;XMPP 特点在于协议和扩展协议成熟，功能完善，专门为即时聊天(IM)场景设计。XMPP 是老牌的即时聊天协议，像 &lt;/span&gt;&lt;span&gt;Google Hangouts&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;WhatsApp Messenger&lt;/span&gt;&lt;span&gt; 等即时聊天程序都是基于 XMPP 的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但由于 XMPP 依赖 XML 协议，放在 IoT 场景里过重，因此&lt;/span&gt;&lt;strong&gt;&lt;span&gt;基本不适合物联网传输使用&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b92b8029a9333ba3c848317aafb6eaf9</guid>
<title>12 个 Vue 开发中的性能优化小技巧</title>
<link>https://toutiao.io/k/smj29br</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAxODE4MTEzMA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/HLN2IKtpicicEzibgjagSQ7yicf4NY6Dkmf6DvDxBCbIchu1bia9LAP5wKGX0ckGtxdU7NEIduTsFIgCaVSnAVibicBSA/0?wx_fmt=png&quot; data-nickname=&quot;前端开发博客&quot; data-alias=&quot;caibaojian_com&quot; data-signature=&quot;回复 加群，秒进群，「前端开发博客」专注前端开发技术，分享前端开发资源和前沿技术资讯，助力前端开发工程师更好成长。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;关注公众号 &lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;前端开发博客&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;，回复“&lt;/span&gt;&lt;span data-style=&quot;color: rgb(255, 0, 0); letter-spacing: 0.544px; word-spacing: 2px; font-size: 14px; visibility: visible;&quot; data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(255, 23, 0)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(255, 0, 0)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(255, 23, 0)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(255, 0, 0)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(255, 23, 0)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(255, 0, 0)&quot;&gt;加群&lt;/span&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;”&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span data-darkmode-bgcolor-16021670869911=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16021670869911=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16021670869911=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030289161394=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030289161394=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030289161394=&quot;rgb(136, 136, 136)&quot; data-darkmode-bgcolor-16030315732716=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16030315732716=&quot;rgb(255, 255, 255)&quot; data-darkmode-color-16030315732716=&quot;rgb(136, 136, 136)&quot; data-darkmode-original-color-16030315732716=&quot;rgb(136, 136, 136)&quot;&gt;加入我们一起学习，天天进步&lt;/span&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;性能优化，是每一个开发者都会遇到的问题，特别是现在越来越重视体验，以及竞争越来越激烈的环境下，对于我们开发者来说，只完成迭代，把功能做好是远远不够的，最重要的是把产品做好，让更多人愿意使用，让用户用得更爽，这不也是我们开发者价值与能力的体现吗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重视性能问题，优化产品的体验，比起改几个无关痛痒的 bug 要有价值得多&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文记录了我在 Vue 项目日常开发中的一些小技巧，废话不多说，我们开始吧&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 长列表性能优化&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 不做响应式&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如会员列表、商品列表之类的，只是纯粹的数据展示，不会有任何动态改变的场景下，就不需要对数据做响应化处理，可以大大提升渲染速度&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如使用 &lt;code&gt;Object.freeze()&lt;/code&gt; 冻结一个对象，MDN的描述是 该方法冻结的对象不能被修改；即不能向这个对象添加新属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值，以及该对象的原型也不能被修改&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; default {&lt;br/&gt; data: () =&amp;gt; ({&lt;br/&gt;   userList: []&lt;br/&gt;}),&lt;br/&gt; async &lt;span&gt;&lt;span&gt;created&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;   const users = await axios.get(&lt;span&gt;&quot;/api/users&quot;&lt;/span&gt;);&lt;br/&gt;   this.userList = Object.freeze(users);&lt;br/&gt;}&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue2 的响应式源码地址：&lt;code&gt;src/core/observer/index.js - 144行&lt;/code&gt; 是这样的&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; defineReactive (...){&lt;br/&gt;   const property = Object.getOwnPropertyDescriptor(obj, key)&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (property &amp;amp;&amp;amp; property.configurable === &lt;span&gt;false&lt;/span&gt;) {&lt;br/&gt;       &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;   ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到一开始就判断 &lt;code&gt;configurable&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 的直接返回不做响应式处理&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;configurable&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 表示这个属性是不能被修改的，而冻结的对象的 &lt;code&gt;configurable&lt;/code&gt; 就是为 &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.21583850931677018&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4wjibJqLZFMWicbzJJ2Jh5Dnx5D5AyaCPyLA6yOHibgyLJw41PAQDNHUE7uh8rQBIibCfCcOY0pEAYCib7VFr2cJo4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;644&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue3 里则是添加了响应式&lt;code&gt;flag&lt;/code&gt;，用于标记目标对象类型&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. 虚拟滚动&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是大数据很长的列表，全部渲染的话一次性创建太多 DOM 就会非常卡，这时就可以用虚拟滚动，只渲染少部分(含可视区域)区域的内容，然后滚动的时候，不断替换可视区域的内容，模拟出滚动的效果&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;recycle-scroller&lt;br/&gt; class=&lt;span&gt;&quot;items&quot;&lt;/span&gt;&lt;br/&gt; :items=&lt;span&gt;&quot;items&quot;&lt;/span&gt;&lt;br/&gt; :item-size=&lt;span&gt;&quot;24&quot;&lt;/span&gt;&lt;br/&gt;&amp;gt;&lt;br/&gt; &amp;lt;template v-slot=&lt;span&gt;&quot;{ item }&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;   &amp;lt;FetchItemView&lt;br/&gt;     :item=&lt;span&gt;&quot;item&quot;&lt;/span&gt;&lt;br/&gt;     @vote=&lt;span&gt;&quot;voteItem(item)&quot;&lt;/span&gt;&lt;br/&gt;   /&amp;gt;&lt;br/&gt; &amp;lt;/template&amp;gt;&lt;br/&gt;&amp;lt;/recycle-scroller&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考 vue-virtual-scroller、vue-virtual-scroll-list&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原理是监听滚动事件，动态更新需要显示的 DOM，并计算出在视图中的位移，这也意味着在滚动过程需要实时计算，有一定成本，所以如果数据量不是很大的情况下，用普通的滚动就行&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. v-for 遍历避免同时使用 v-if&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么要避免同时使用 &lt;code&gt;v-for&lt;/code&gt; 和 &lt;code&gt;v-if&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Vue2 中 &lt;code&gt;v-for&lt;/code&gt; 优先级更高，所以编译过程中会把列表元素全部遍历生成虚拟 DOM，再来通过 v-if 判断符合条件的才渲染，就会造成性能的浪费，因为我们希望的是不符合条件的虚拟 DOM都不要生成&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Vue3 中 &lt;code&gt;v-if&lt;/code&gt; 的优先级更高，就意味着当判断条件是 v-for 遍历的列表中的属性的话，v-if 是拿不到的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在一些需要同时用到的场景，就可以通过计算属性来过滤一下列表，如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;br/&gt;   &amp;lt;ul&amp;gt;&lt;br/&gt;     &amp;lt;li v-for=&lt;span&gt;&quot;item in activeList&quot;&lt;/span&gt; :key=&lt;span&gt;&quot;item.id&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;      {{ item.title }}&lt;br/&gt;     &amp;lt;/li&amp;gt;&lt;br/&gt;   &amp;lt;/ul&amp;gt;&lt;br/&gt;&amp;lt;/template&amp;gt;&lt;br/&gt;&amp;lt;script&amp;gt;&lt;br/&gt;// Vue2.x&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; default {&lt;br/&gt;   computed: {&lt;br/&gt;     &lt;span&gt;&lt;span&gt;activeList&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;       &lt;span&gt;return&lt;/span&gt; this.list.filter( item =&amp;gt; {&lt;br/&gt;         &lt;span&gt;return&lt;/span&gt; item.isActive&lt;br/&gt;      })&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// Vue3&lt;br/&gt;import { computed } from &lt;span&gt;&quot;vue&quot;&lt;/span&gt;;&lt;br/&gt;const activeList = computed(() =&amp;gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; list.filter( item =&amp;gt; {&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; item.isActive&lt;br/&gt;})&lt;br/&gt;})&lt;br/&gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 列表使用唯一 key&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如有一个列表，我们需要在中间插入一个元素，在不使用 key 或者使用 index 作为 key 会发生什么变化呢？先看个图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;310&quot; data-backw=&quot;384&quot; data-fileid=&quot;100000299&quot; data-ratio=&quot;0.8073170731707318&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4wjibJqLZFMWicbzJJ2Jh5Dnx5D5AyaCPy70nkgCyE1eyu2pkGoicWVCqXzKUk1sItuQwyJS9R2VZP9YiaXzvrURmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;410&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图的 &lt;code&gt;li1&lt;/code&gt; 和 &lt;code&gt;li2&lt;/code&gt; 不会重新渲染，这个没有争议的。而 &lt;code&gt;li3、li4、li5&lt;/code&gt; 都会重新渲染&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为在不使用 &lt;code&gt;key&lt;/code&gt; 或者列表的 &lt;code&gt;index&lt;/code&gt; 作为 &lt;code&gt;key&lt;/code&gt; 的时候，每个元素对应的位置关系都是 index，上图中的结果直接导致我们插入的元素到后面的全部元素，对应的位置关系都发生了变更，所以在 patch 过程中会将它们全都执行更新操作，再重新渲染。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这可不是我们想要的，我们希望的是渲染添加的那一个元素，其他四个元素不做任何变更，也就不要重新渲染&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在使用唯一 &lt;code&gt;key&lt;/code&gt;  的情况下，每个元素对应的位置关系就是 &lt;code&gt;key&lt;/code&gt;，来看一下使用唯一 &lt;code&gt;key&lt;/code&gt; 值的情况下&lt;/p&gt;&lt;p cid=&quot;n33&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span md-inline=&quot;image&quot; data-src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1882d22f62b4433aa0a91dcbe0ad09d5~tplv-k3u1fbpfcp-watermark.image?&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;100000298&quot; data-ratio=&quot;0.8073170731707318&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4wjibJqLZFMWicbzJJ2Jh5Dnx5D5AyaCPyZ1rGSKCKSnuSZOqibq1fx1iczKWhEmNetTfPKcia6ibJpibGJTQP3kXsPUA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;410&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样如图中的 &lt;code&gt;li3&lt;/code&gt; 和 &lt;code&gt;li4&lt;/code&gt; 就不会重新渲染，因为元素内容没发生改变，对应的位置关系也没有发生改变。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是为什么 v-for 必须要写 key，而且不建议开发中使用数组的 index 作为 key 的原因&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4. 使用 v-show 复用 DOM&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;v-show&lt;/code&gt;：是渲染组件，然后改变组件的 display 为 block 或 none  &lt;code&gt;v-if&lt;/code&gt;：是渲染或不渲染组件&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以对于可以频繁改变条件的场景，就使用 v-show 节省性能，特别是 DOM 结构越复杂收益越大&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过它也有劣势，就是 v-show 在一开始的时候，所有分支内部的组件都会渲染，对应的生命周期钩子函数都会执行，而 v-if 只会加载判断条件命中的组件，所以需要根据不同场景使用合适的指令&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如下面的用 &lt;code&gt;v-show&lt;/code&gt; 复用DOM，比 &lt;code&gt;v-if/v-else&lt;/code&gt; 效果好&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;br/&gt; &amp;lt;div&amp;gt;&lt;br/&gt;   &amp;lt;div v-show=&lt;span&gt;&quot;status&quot;&lt;/span&gt; class=&lt;span&gt;&quot;on&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;     &amp;lt;my-components /&amp;gt;&lt;br/&gt;   &amp;lt;/div&amp;gt;&lt;br/&gt;   &amp;lt;section v-show=&lt;span&gt;&quot;!status&quot;&lt;/span&gt; class=&lt;span&gt;&quot;off&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;     &amp;lt;my-components &amp;gt;&lt;br/&gt;   &amp;lt;/section&amp;gt;&lt;br/&gt; &amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/template&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原理就是使用 v-if 当条件变化的时候，触发 diff 更新，发现新旧 vnode 不一致，就会移除整个旧的 &lt;code&gt;vnode&lt;/code&gt;，再重新创建新的 &lt;code&gt;vnode&lt;/code&gt;，然后创建新的 &lt;code&gt;my-components&lt;/code&gt; 组件，又会经历组件自身初始化，&lt;code&gt;render&lt;/code&gt;，&lt;code&gt;patch&lt;/code&gt; 等过程，而 &lt;code&gt;v-show&lt;/code&gt; 在条件变化的时候，新旧 &lt;code&gt;vnode&lt;/code&gt; 是一致的，就不会执行移除创建等一系列流程&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5. 无状态的组件用函数式组件&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一些纯展示，没有响应式数据，没有状态管理，也不用生命周期钩子函数的组件，我们就可以设置成函数式组件，提高渲染性能，因为会把它当成一个函数来处理，所以开销很低&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原理是在 &lt;code&gt;patch&lt;/code&gt; 过程中对于函数式组件的 &lt;code&gt;render&lt;/code&gt; 生成的虚拟 DOM，不会有递归子组件初始化的过程，所以渲染开销会低很多&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它可以接受 &lt;code&gt;props&lt;/code&gt;，但是由于不会创建实例，所以内部不能使用 &lt;code&gt;this.xx&lt;/code&gt; 获取组件属性，写法如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;template functional&amp;gt;&lt;br/&gt; &amp;lt;div&amp;gt;&lt;br/&gt;   &amp;lt;div class=&lt;span&gt;&quot;content&quot;&lt;/span&gt;&amp;gt;{{ value }}&amp;lt;/div&amp;gt;&lt;br/&gt; &amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/template&amp;gt;&lt;br/&gt;&amp;lt;script&amp;gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; default {&lt;br/&gt; props: [&lt;span&gt;&#x27;value&#x27;&lt;/span&gt;]&lt;br/&gt;}&lt;br/&gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&lt;br/&gt;// 或者&lt;br/&gt;Vue.component(&lt;span&gt;&#x27;my-component&#x27;&lt;/span&gt;, {&lt;br/&gt; functional: &lt;span&gt;true&lt;/span&gt;, // 表示该组件为函数式组件&lt;br/&gt; props: { ... }, // 可选&lt;br/&gt; // 第二个参数为上下文，没有 this&lt;br/&gt; render: &lt;span&gt;function&lt;/span&gt; (createElement, context) {&lt;br/&gt;   // ...&lt;br/&gt;}&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6. 子组件分割&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看个例子&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;br/&gt; &amp;lt;div :style=&lt;span&gt;&quot;{ opacity: number / 100 }&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;   &amp;lt;div&amp;gt;{{ someThing() }}&amp;lt;/div&amp;gt;&lt;br/&gt; &amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/template&amp;gt;&lt;br/&gt;&amp;lt;script&amp;gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; default {&lt;br/&gt; props:[&lt;span&gt;&#x27;number&#x27;&lt;/span&gt;],&lt;br/&gt; methods: {&lt;br/&gt;   &lt;span&gt;&lt;span&gt;someThing&lt;/span&gt;&lt;/span&gt; () { /* 耗时任务 */ }&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这样的代码中，每次父组件传过来的 &lt;code&gt;number&lt;/code&gt; 发生变化时，每次都会重新渲染，并且重新执行 &lt;code&gt;someThing&lt;/code&gt; 这个耗时任务&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以优化的话一个是用计算属性，因为计算属性自身有缓存计算结果的特性&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个是拆分成子组件，因为 Vue 的更新是组件粒度的，虽然第次数据变化都会导致父组件的重新渲染，但是子组件却不会重新渲染，因为它的内部没有任何变化，耗时任务自然也就不会重新执行，因此性能更好，优化代码如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;br/&gt;&amp;lt;div&amp;gt;  &lt;br/&gt; &amp;lt;my-child /&amp;gt;&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/template&amp;gt;&lt;br/&gt;&amp;lt;script&amp;gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; default {&lt;br/&gt;components: {  &lt;br/&gt; MyChild: {  &lt;br/&gt;  methods: {    &lt;br/&gt;   &lt;span&gt;&lt;span&gt;someThing&lt;/span&gt;&lt;/span&gt; () { /* 耗时任务 */ }    &lt;br/&gt;  },   &lt;br/&gt;   render (h) {  &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; h(&lt;span&gt;&#x27;div&#x27;&lt;/span&gt;, this.someThing())  &lt;br/&gt;  } &lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7. 变量本地化&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单说就是把会多次引用的变量保存起来，因为每次访问 &lt;code&gt;this.xx&lt;/code&gt; 的时候，由于是响应式对象，所以每次都会触发 &lt;code&gt;getter&lt;/code&gt;，然后执行依赖收集的相关代码，如果使用变量次数越多，性能自然就越差&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从需求上说在一个函数里一个变量执行一次依赖收集就够了，可是很多人习惯性的在项目中大量写 &lt;code&gt;this.xx&lt;/code&gt;，而忽略了 &lt;code&gt;this.xx&lt;/code&gt; 背后做的事，就会导致性能问题了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如下面例子&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;template&amp;gt; &lt;br/&gt; &amp;lt;div :style=&lt;span&gt;&quot;{ opacity: number / 100 }&quot;&lt;/span&gt;&amp;gt; {{ result&lt;br/&gt;}}&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/template&amp;gt;&lt;br/&gt;&amp;lt;script&amp;gt;&lt;br/&gt;import { someThing } from &lt;span&gt;&#x27;@/utils&#x27;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; default {&lt;br/&gt; props: [&lt;span&gt;&#x27;number&#x27;&lt;/span&gt;], &lt;br/&gt; computed: {  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;base&lt;/span&gt;&lt;/span&gt; () { &lt;span&gt;return&lt;/span&gt; 100 },  &lt;br/&gt;  &lt;span&gt;&lt;span&gt;result&lt;/span&gt;&lt;/span&gt; () {   &lt;br/&gt;   &lt;span&gt;let&lt;/span&gt; base = this.base, number = this.number // &lt;br/&gt;保存起来    &lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = 0; i &amp;lt; 1000; i++) {   &lt;br/&gt;   number += someThing(base) // 避免频繁引用&lt;br/&gt;this.xx   &lt;br/&gt;  }   &lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; number &lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8. 第三方插件按需引入&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如 &lt;code&gt;Element-UI&lt;/code&gt; 这样的第三方组件库可以按需引入避免体积太大，特别是项目不大的情况下，更没有必要完整引入组件库&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;// main.js&lt;br/&gt;import Element3 from &lt;span&gt;&quot;plugins/element3&quot;&lt;/span&gt;;&lt;br/&gt;Vue.use(Element3)&lt;br/&gt;&lt;br/&gt;// element3.js&lt;br/&gt;// 完整引入&lt;br/&gt;import element3 from &lt;span&gt;&quot;element3&quot;&lt;/span&gt;;&lt;br/&gt;import &lt;span&gt;&quot;element3/lib/theme-chalk/index.css&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;// 按需引入&lt;br/&gt;// import &lt;span&gt;&quot;element3/lib/theme-chalk/button.css&quot;&lt;/span&gt;;&lt;br/&gt;// ...&lt;br/&gt;// import { &lt;br/&gt;// ElButton, &lt;br/&gt;// ElRow, &lt;br/&gt;// ElCol, &lt;br/&gt;// ElMain, &lt;br/&gt;// .....&lt;br/&gt;// } from &lt;span&gt;&quot;element3&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; default &lt;span&gt;function&lt;/span&gt; (app) { &lt;br/&gt;// 完整引入 &lt;br/&gt;app.use(element3)  &lt;br/&gt;&lt;br/&gt;// 按需引入 &lt;br/&gt;// app.use(ElButton);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;9. 路由懒加载&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道 Vue 是单页应用，所以如果没有用懒加载，就会导致进入首页时需要加载的内容过多，时间过长，就会出现长时间的白屏，很不利于用户体验，SEO 也不友好&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以可以去用懒加载将页面进行划分，需要的时候才加载对应的页面，以分担首页的加载压力，减少首页加载时间&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没有用路由懒加载：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;import Home from &lt;span&gt;&#x27;@/components/Home&#x27;&lt;/span&gt;&lt;br/&gt;const router = new VueRouter({  &lt;br/&gt; routes: [  &lt;br/&gt;  { path: &lt;span&gt;&#x27;/home&#x27;&lt;/span&gt;, component: Home }&lt;br/&gt;]&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用了路由懒加载：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const router = new VueRouter({&lt;br/&gt;routes: [ &lt;br/&gt; { path: &lt;span&gt;&#x27;/home&#x27;&lt;/span&gt;, component: () =&amp;gt; &lt;br/&gt;import(&lt;span&gt;&#x27;@/components/Home&#x27;&lt;/span&gt;) }, &lt;br/&gt; { path: &lt;span&gt;&#x27;/login&#x27;&lt;/span&gt;, component: &lt;br/&gt;require(&lt;span&gt;&#x27;@/components/Home&#x27;&lt;/span&gt;).default }&lt;br/&gt;]&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在进入这个路由的时候才会走对应的 &lt;code&gt;component&lt;/code&gt;，然后运行 &lt;code&gt;import&lt;/code&gt; 编译加载组件，可以理解为 &lt;code&gt;Promise&lt;/code&gt; 的 &lt;code&gt;resolve&lt;/code&gt; 机制&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;import&lt;/code&gt;：Es6语法规范、编译时调用、是解构过程、不支持变量函数等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;require&lt;/code&gt;：AMD规范、运行时调用、是赋值过程，支持变量计算函数等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多有关前端模块化的内容可以看我另一篇文章 前端模块化规范详细总结&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;10. keep-alive缓存页面&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如在表单输入页面进入下一步后，再返回上一步到表单页时要保留表单输入的内容、比如在&lt;code&gt;列表页&amp;gt;详情页&amp;gt;列表页&lt;/code&gt;，这样来回跳转的场景等&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都可以通过内置组件 &lt;code&gt;&amp;lt;keep-alive&amp;gt;&amp;lt;/keep-alive&amp;gt;&lt;/code&gt; 来把组件缓存起来，在组件切换的时候不进行卸载，这样当再次返回的时候，就能从缓存中快速渲染，而不是重新渲染，以节省性能&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只需要包裹想要缓存的组件即可&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;template&amp;gt;&lt;br/&gt; &amp;lt;div id=&lt;span&gt;&quot;app&quot;&lt;/span&gt;&amp;gt; &lt;br/&gt;  &amp;lt;keep-alive&amp;gt;  &lt;br/&gt;   &amp;lt;router-view/&amp;gt; &lt;br/&gt;  &amp;lt;/keep-alive&amp;gt;&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/template&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;也可以用 &lt;code&gt;include/exclude&lt;/code&gt; 来 缓存/不缓存 指定组件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可通过两个生命周期 &lt;code&gt;activated/deactivated&lt;/code&gt; 来获取当前组件状态&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;11. 事件的销毁&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Vue 组件销毁时，会自动解绑它的全部指令及事件监听器，但是仅限于组件本身的事件&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而对于&lt;code&gt;定时器&lt;/code&gt;、&lt;code&gt;addEventListener&lt;/code&gt; 注册的监听器等，就需要在组件销毁的生命周期钩子中手动销毁或解绑，以避免内存泄露&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; default {  &lt;br/&gt; &lt;span&gt;&lt;span&gt;created&lt;/span&gt;&lt;/span&gt;() {   &lt;br/&gt;  this.timer = setInterval(this.refresh, 2000)  &lt;br/&gt;  addEventListener(&lt;span&gt;&#x27;touchmove&#x27;&lt;/span&gt;, &lt;br/&gt;this.touchmove, &lt;span&gt;false&lt;/span&gt;) &lt;br/&gt; }, &lt;br/&gt;  &lt;span&gt;&lt;span&gt;beforeDestroy&lt;/span&gt;&lt;/span&gt;() {  &lt;br/&gt;   clearInterval(this.timer)   &lt;br/&gt;   this.timer = null   &lt;br/&gt;   removeEventListener(&lt;span&gt;&#x27;touchmove&#x27;&lt;/span&gt;, &lt;br/&gt;this.touchmove, &lt;span&gt;false&lt;/span&gt;) &lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;12. 图片懒加载&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图片懒加载就是对于有很多图片的页面，为了提高页面加载速度，只加载可视区域内的图片，可视区域外的等到滚动到可视区域后再去加载&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个功能一些 UI 框架都有自带的，如果没有呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐一个第三方插件 &lt;code&gt;vue-lazyload&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;npm i vue-lazyload -S&lt;br/&gt;&lt;br/&gt;// main.js&lt;br/&gt;import VueLazyload from &lt;span&gt;&#x27;vue-lazyload&#x27;&lt;/span&gt;&lt;br/&gt;Vue.use(VueLazyload)&lt;br/&gt;&lt;br/&gt;// 接着就可以在页面中使用 v-lazy 懒加载图片了&lt;br/&gt;&amp;lt;img v-lazy=&lt;span&gt;&quot;/static/images/1.png&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者自己造轮子，手动封装一个自定义指令，这里封装好了一个兼容各浏览器的版本的，主要是判断浏览器支不支持 &lt;code&gt;IntersectionObserver&lt;/code&gt; API，支持就用它实现懒加载，不支持就用监听 scroll 事件+节流的方式实现&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;const LazyLoad = { &lt;br/&gt;// install方法 &lt;br/&gt;install(Vue, options) {  &lt;br/&gt; const defaultSrc = options.default &lt;br/&gt; Vue.directive(&lt;span&gt;&#x27;lazy&#x27;&lt;/span&gt;, {  &lt;br/&gt;  &lt;span&gt;bind&lt;/span&gt;(el, binding) {   &lt;br/&gt;   LazyLoad.init(el, binding.value, defaultSrc) &lt;br/&gt; },   &lt;br/&gt;  inserted(el) {     &lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; (IntersectionObserver) {    &lt;br/&gt;    LazyLoad.observe(el)     &lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {      &lt;br/&gt;    LazyLoad.listenerScroll(el)    &lt;br/&gt;  }  &lt;br/&gt; }, &lt;br/&gt;})&lt;br/&gt;}, &lt;br/&gt;// 初始化 &lt;br/&gt;init(el, val, def) { &lt;br/&gt; el.setAttribute(&lt;span&gt;&#x27;data-src&#x27;&lt;/span&gt;, val)  &lt;br/&gt; el.setAttribute(&lt;span&gt;&#x27;src&#x27;&lt;/span&gt;, def)&lt;br/&gt;}, &lt;br/&gt;// 利用IntersectionObserver监听el&lt;br/&gt;observe(el) {  &lt;br/&gt; var io = new IntersectionObserver((entries) =&amp;gt; {  &lt;br/&gt;  const realSrc = el.dataset.src    &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (entries[0].isIntersecting) {   &lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (realSrc) {      &lt;br/&gt;   el.src = realSrc       &lt;br/&gt;   el.removeAttribute(&lt;span&gt;&#x27;data-src&#x27;&lt;/span&gt;)    &lt;br/&gt;  }   &lt;br/&gt; } &lt;br/&gt;}) &lt;br/&gt; io.observe(el)&lt;br/&gt;}, &lt;br/&gt;// 监听scroll事件&lt;br/&gt;listenerScroll(el) {  &lt;br/&gt; const handler =&lt;br/&gt;LazyLoad.throttle(LazyLoad.load, 300) &lt;br/&gt; LazyLoad.load(el)  &lt;br/&gt; window.addEventListener(&lt;span&gt;&#x27;scroll&#x27;&lt;/span&gt;, () =&amp;gt; {   &lt;br/&gt;  handler(el) &lt;br/&gt; })&lt;br/&gt;}, &lt;br/&gt;// 加载真实图片 &lt;br/&gt;load(el) {  &lt;br/&gt; const windowHeight =&lt;br/&gt;document.documentElement.clientHeight&lt;br/&gt; const elTop = el.getBoundingClientRect().top  &lt;br/&gt; const elBtm = &lt;br/&gt;el.getBoundingClientRect().bottom &lt;br/&gt; const realSrc = el.dataset.src  &lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (elTop - windowHeight &amp;lt; 0 &amp;amp;&amp;amp; elBtm &amp;gt; 0) {  &lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (realSrc) {     &lt;br/&gt;   el.src = realSrc    &lt;br/&gt;   el.removeAttribute(&lt;span&gt;&#x27;data-src&#x27;&lt;/span&gt;)  &lt;br/&gt;  } &lt;br/&gt; }&lt;br/&gt;}, &lt;br/&gt;// 节流 &lt;br/&gt;throttle(fn, delay) {  &lt;br/&gt; &lt;span&gt;let&lt;/span&gt; timer  &lt;br/&gt; &lt;span&gt;let&lt;/span&gt; prevTime  &lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; (...args) {   &lt;br/&gt;  const currTime = Date.now() &lt;br/&gt;  const context = this    &lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!prevTime) prevTime = currTime  &lt;br/&gt;  clearTimeout(timer)   &lt;br/&gt;  &lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (currTime - prevTime &amp;gt; delay) {     &lt;br/&gt;   prevTime = currTime      &lt;br/&gt;   fn.apply(context, args)    &lt;br/&gt;   clearTimeout(timer)      &lt;br/&gt;   &lt;span&gt;return&lt;/span&gt;   &lt;br/&gt; }  &lt;br/&gt;&lt;br/&gt; timer = setTimeout(&lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;/span&gt; () {   &lt;br/&gt;  prevTime = Date.now()  &lt;br/&gt;  timer = null   &lt;br/&gt;  fn.apply(context, args)   &lt;br/&gt;}, delay) &lt;br/&gt;}&lt;br/&gt;},&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; default LazyLoad&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用上是这样的，用 &lt;code&gt;v-LazyLoad&lt;/code&gt; 代替 &lt;code&gt;src&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;img v-LazyLoad=&lt;span&gt;&quot;xxx.jpg&quot;&lt;/span&gt; /&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;13. SSR&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一点我在项目中也没有实践过，就不班门弄斧了&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;推荐链接&lt;/span&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxODE4MTEzMA==&amp;amp;mid=2650093957&amp;amp;idx=1&amp;amp;sn=f88f8bcdb29aba79c83a9b2b922a4985&amp;amp;chksm=83dba4e0b4ac2df6987dd2fd910d9b42f7608e7f8951a8deadbd386fc418a34c54e9ec02603e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;11 个高级 Vue 编码技巧&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;11 个高级 Vue 编码技巧&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxODE4MTEzMA==&amp;amp;mid=2650088662&amp;amp;idx=2&amp;amp;sn=e45779ebbc804cdedf2572287e937235&amp;amp;chksm=83dbb9b3b4ac30a50c898429c6c9649eb96078242d15ecc9142619355c4c1964babb60f953df&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Vue 项目性能优化技巧分享&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Vue 项目性能优化技巧分享&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzAxODE4MTEzMA==&amp;amp;mid=2650096625&amp;amp;idx=2&amp;amp;sn=b4b59afc72bfdc7f9ff8ff8eeb2cdf46&amp;amp;chksm=83dbde94b4ac57827eb3941bbda3b04e2083b34d5d7079fc2b6f07ebc530ac696442c634a0a5&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot; wah-hotarea=&quot;click&quot;&gt;小抄学习法: 4张图掌握JS核心要点&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAxODE4MTEzMA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/HLN2IKtpicicEzibgjagSQ7yicf4NY6Dkmf6DvDxBCbIchu1bia9LAP5wKGX0ckGtxdU7NEIduTsFIgCaVSnAVibicBSA/0?wx_fmt=png&quot; data-nickname=&quot;前端开发博客&quot; data-alias=&quot;caibaojian_com&quot; data-signature=&quot;回复 加群，秒进群，「前端开发博客」专注前端开发技术，分享前端开发资源和前沿技术资讯，助力前端开发工程师更好成长。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47619047619047616&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/HLN2IKtpicicEJY0tknbZeyFqAU7pttoLsa47IXdBVQ6PshiamMibyQz0siceDhj7bSoqx2t51e0ibgQP3vG9STh9Jcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;420&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;创作不易，&lt;/span&gt;&lt;strong&gt;加个&lt;/strong&gt;&lt;strong&gt;点赞、在看&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;span&gt;支持一下哦！&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.3255813953488373&quot; data-type=&quot;png&quot; data-w=&quot;86&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/13hL2eRjyS9E88SBrqoO3kPEuhciazwuq0YN54wgnXfKXYot6bic4je4Rdxwtia5BdjRxeic1N86RWvbBITMcGibn5A/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fa52abf8e53395559098ffea71ed99e1</guid>
<title>基于.NET 制作一个气象站 IoT 应用</title>
<link>https://toutiao.io/k/8ajh0b4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;点击“&lt;strong&gt;阅读原文&lt;/strong&gt;”获得最佳阅读体验。&lt;/p&gt;&lt;p&gt;和单片机不同，使用 Linux 开发板、现成的传感器套件以及合适的后端技术几乎可以做成任何东西。为了更好的整合前面章节介绍的内容，本文将制作一个简单的气象站（也许叫环境信息收集装置更合适），至于为何选择制作一个气象站，因为难度不高制作不复杂，并且温湿度传感器花费较低的价格即可获得，可以以低廉的价格换取一个 cool stuff。本文将使用 .NET 6 编写一个控制台应用程序，通过本文你可以学到：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;I2C &lt;code&gt;I2cDevice&lt;/code&gt; 类的使用；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;摄像头设备 &lt;code&gt;VideoDevice&lt;/code&gt; 类的使用；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;Iot.Device.Bindings&lt;/code&gt; NuGet 包的使用；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;时序数据库 &lt;code&gt;TimescaleDB&lt;/code&gt; 的简单使用；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;code&gt;Quartz&lt;/code&gt; 定时任务的使用；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在控制台应用中进行依赖注入；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;Docker&lt;/code&gt; 拉取镜像、部署应用。&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;硬件需求&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;电路&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;准备工作&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;配置 TimescaleDB 数据库&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;安装摄像头的依赖库&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;编写代码&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;项目结构&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;项目依赖&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;数据库上下文与实体类&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;配置文件&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;初始化与依赖注入配置&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;配置定时任务&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;部署应用&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;后续工作&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-line=&quot;11&quot;&gt;&lt;span&gt;硬件需求&lt;/span&gt;&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;名称&lt;/th&gt;&lt;th&gt;描述&lt;/th&gt;&lt;th&gt;数量&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Orange Pi Zero&lt;/td&gt;&lt;td&gt;Linux 开发板&lt;/td&gt;&lt;td&gt;x1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;BME280&lt;/td&gt;&lt;td&gt;提供温度、湿度以及气压数据&lt;/td&gt;&lt;td&gt;x1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;USB 摄像头&lt;/td&gt;&lt;td&gt;提供环境图像&lt;/td&gt;&lt;td&gt;x1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;杜邦线&lt;/td&gt;&lt;td&gt;传感器与开发板的连接线&lt;/td&gt;&lt;td&gt;若干&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-line=&quot;20&quot;&gt;&lt;span&gt;电路&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5233333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/09LgVyNibqhH2FckWjFMxMuNuFmq5eCwX7El5KF7GSsqcuIaw1kXOLdfy96n45hwUVcsYNL3PY2y0kNwwibTiciaWA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;传感器&lt;/th&gt;&lt;th&gt;接口&lt;/th&gt;&lt;th&gt;开发板接口&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;BME280&lt;/td&gt;&lt;td&gt;SDA&lt;/td&gt;&lt;td&gt;TWI0_SDA (Pin 3)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;SCL&lt;/td&gt;&lt;td&gt;TWI0_SCK (Pin 5)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;VCC&lt;/td&gt;&lt;td&gt;5V (Pin 4)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;GND&lt;/td&gt;&lt;td&gt;GND (Pin 6)&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;USB 摄像头&lt;/td&gt;&lt;td&gt;USB&lt;/td&gt;&lt;td&gt;USB&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p data-line=&quot;32&quot;&gt;&lt;span&gt;准备工作&lt;/span&gt;&lt;/p&gt;&lt;p data-line=&quot;34&quot;&gt;&lt;span&gt;配置 TimescaleDB 数据库&lt;/span&gt;&lt;/p&gt;&lt;p&gt;TimescaleDB 是一款基于 PostgreSQL 插件的时序数据库。考虑到收集的环境数据是按时间进行索引，并且数据基本上都是插入，没有更新的需求，因此选用了时序数据库作为数据存储。TimescaleDB 是 PostgreSQL 的一款插件，可以通过先安装 PostgreSQL 之后再安装插件的形式部署 TimescaleDB，这里直接使用 TimescaleDB 的 Docker 镜像进行部署。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;拉取 TimescaleDB 镜像：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;&quot;&gt;&lt;code&gt;docker pull timescale/timescaledb:latest-pg14&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;创建卷，用于持久化数据库数据：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;&quot;&gt;&lt;code&gt;docker volume create tsdb_data&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;运行镜像，端口映射为 &lt;code&gt;54321&lt;/code&gt;，密码配置为弱密码 &lt;code&gt;@Passw0rd&lt;/code&gt;：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;&quot;&gt;&lt;code&gt;docker run -d --name timescaledb -p 54321:5432 --restart=always -e POSTGRES_PASSWORD=&#x27;@Passw0rd&#x27; -e TZ=&#x27;Asia/Shanghai&#x27; -e ALLOW_IP_RANGE=0.0.0.0/0 -v tsdb_data:/var/lib/postgresql timescale/timescaledb:latest-pg14&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;4&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;使用熟悉的数据库管理工具（如 Navicat）创建数据库 &lt;code&gt;WeatherMetrics&lt;/code&gt;：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;sql&quot;&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;DATABASE&lt;/span&gt; &lt;span&gt;&quot;WeatherMetrics&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;WITH&lt;/span&gt; OWNER &lt;span&gt;=&lt;/span&gt; postgres ENCODING &lt;span&gt;=&lt;/span&gt; &lt;span&gt;&#x27;UTF8&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; metrics (&lt;br/&gt;   &lt;span&gt;time&lt;/span&gt; &lt;span&gt;TIMESTAMP&lt;/span&gt; WITHOUT &lt;span&gt;TIME&lt;/span&gt; ZONE &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;&#x27;now()&#x27;&lt;/span&gt;,&lt;br/&gt;   device_id &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;   weather_type &lt;span&gt;VARCHAR&lt;/span&gt;(&lt;span&gt;50&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;   temperature &lt;span&gt;DECIMAL&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;   humidity &lt;span&gt;DECIMAL&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;   pressure &lt;span&gt;DECIMAL&lt;/span&gt;(&lt;span&gt;8&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;) &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;   image_base64 &lt;span&gt;TEXT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;br/&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;SELECT&lt;/span&gt; create_hypertable(&lt;span&gt;&#x27;metrics&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;time&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;time&lt;/code&gt; 表示采集数据的时间，&lt;code&gt;device_id&lt;/code&gt; 记录采集设备的 id，&lt;code&gt;weather_type&lt;/code&gt; 记录从心知天气获取的天气名，&lt;code&gt;temperature&lt;/code&gt; 记录传感器获取的温度，&lt;code&gt;humidity&lt;/code&gt; 记录传感器获取的湿度，&lt;code&gt;pressure&lt;/code&gt; 记录传感器获取的气压，&lt;code&gt;image_base64&lt;/code&gt; 记录摄像头采集的图像。&lt;/p&gt;&lt;p&gt;&lt;span&gt;💡 提示&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在数据库中存储任何字符类型以外的数据都是愚蠢的，这里是为了演示，并且只是低分辨率的图像。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;超表（hypertable）是 TimescaleDB 的一个重要概念，由若干个块（chunks）组成，将超表中的数据按照时间列（即 &lt;code&gt;metrics&lt;/code&gt; 表中的 &lt;code&gt;time&lt;/code&gt; 字段）分成若干个块存储，而使用 PostgreSQL 层面上的表（table）实现 SQL 接口的暴露，因此使用 &lt;code&gt;create_hypertable()&lt;/code&gt; 将表转换为超表。上面创建的 &lt;code&gt;metrics&lt;/code&gt; 表并不是真正意义上的表，表中不存在主键字段，而是类似视图（view）一样的抽象结构。&lt;/p&gt;&lt;h3&gt;安装摄像头的依赖库&lt;/h3&gt;&lt;p&gt;VideoDevice 类是使用 PInvoke 操作实现的，依赖于 Video for Linux 2（V4L2），因此还需要安装 V4L2 工具：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;&quot;&gt;&lt;code&gt;sudo apt install v4l-utils&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;实现时还引用了 &lt;code&gt;System.Drawing&lt;/code&gt; NuGet 包，因此还需要安装 &lt;code&gt;System.Drawing&lt;/code&gt; 的前置依赖：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;&quot;&gt;&lt;code&gt;sudo apt install libc6-dev libgdiplus libx11-dev&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-line=&quot;88&quot;&gt;&lt;span&gt;编写代码&lt;/span&gt;&lt;/p&gt;&lt;p&gt;项目地址：https://github.com/ZhangGaoxing/weather-metrics&lt;/p&gt;&lt;p data-line=&quot;92&quot;&gt;&lt;span&gt;项目结构&lt;/span&gt;&lt;/p&gt;&lt;p&gt;创建一个控制台应用和类库，项目结构如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6391509433962265&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/09LgVyNibqhH2FckWjFMxMuNuFmq5eCwX7T4XfKTXr6w9oKfdGF6YSrMfDVGKYe5aspGNx71pvibmR3sUNL4Ok4g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;424&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;项目依赖&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;WeatherMetrics.ConsoleApp&lt;/code&gt; 添加如下 NuGet 包引用：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;xml&quot;&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;ItemGroup&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;PackageReference &lt;span&gt;Include&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;Iot.Device.Bindings&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;Version&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;2.0.0&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;PackageReference &lt;span&gt;Include&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;Microsoft.Extensions.Configuration.Json&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;Version&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;6.0.0&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;PackageReference &lt;span&gt;Include&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;Microsoft.Extensions.DependencyInjection&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;Version&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;6.0.0&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;PackageReference &lt;span&gt;Include&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;Newtonsoft.Json&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;Version&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;13.0.1&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;PackageReference &lt;span&gt;Include&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;Quartz&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;Version&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;3.3.3&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;PackageReference &lt;span&gt;Include&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;System.Device.Gpio&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;Version&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;2.0.0&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;ItemGroup&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;WeatherMetrics.Models&lt;/code&gt; 添加如下 NuGet 包引用：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;xml&quot;&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;ItemGroup&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;PackageReference &lt;span&gt;Include&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;Npgsql.EntityFrameworkCore.PostgreSQL&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;Version&lt;/span&gt;&lt;span&gt;&lt;span&gt;=&quot;&lt;/span&gt;6.0.3&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;ItemGroup&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p data-line=&quot;121&quot;&gt;&lt;span&gt;数据库上下文与实体类&lt;/span&gt;&lt;/p&gt;&lt;p&gt;TimescaleDB 本质上就是一个 PostgreSQL 数据库，因此数据库访问使用 Npgsql 驱动。首先添加实体类 &lt;code&gt;Metrics.cs&lt;/code&gt;：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;csharp&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;Metrics&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    [&lt;span&gt;Column&lt;/span&gt;(&lt;span&gt;&quot;time&quot;&lt;/span&gt;)]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;DateTime&lt;/span&gt; Time { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } &lt;span&gt;=&lt;/span&gt; DateTime.Now;&lt;br/&gt;&lt;br/&gt;    [&lt;span&gt;Column&lt;/span&gt;(&lt;span&gt;&quot;device_id&quot;&lt;/span&gt;)]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; DeviceId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;&lt;br/&gt;    [&lt;span&gt;Column&lt;/span&gt;(&lt;span&gt;&quot;weather_type&quot;&lt;/span&gt;)]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; WeatherType { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;&lt;br/&gt;    [&lt;span&gt;Column&lt;/span&gt;(&lt;span&gt;&quot;temperature&quot;&lt;/span&gt;)]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; Temperature { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;&lt;br/&gt;    [&lt;span&gt;Column&lt;/span&gt;(&lt;span&gt;&quot;humidity&quot;&lt;/span&gt;)]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; Humidity { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;&lt;br/&gt;    [&lt;span&gt;Column&lt;/span&gt;(&lt;span&gt;&quot;pressure&quot;&lt;/span&gt;)]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; Pressure { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;&lt;br/&gt;    [&lt;span&gt;Column&lt;/span&gt;(&lt;span&gt;&quot;image_base64&quot;&lt;/span&gt;)]&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ImageBase64 { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;接着添加数据库上下文 &lt;code&gt;WeatherContext.cs&lt;/code&gt;：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;csharp&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;WeatherContext&lt;/span&gt; : &lt;span&gt;DbContext&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; _connectString;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;WeatherContext&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt; connectString)&lt;br/&gt;    {&lt;br/&gt;        _connectString &lt;span&gt;=&lt;/span&gt; connectString;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;OnConfiguring&lt;/span&gt;(&lt;span&gt;DbContextOptionsBuilder&lt;/span&gt; optionsBuilder)&lt;br/&gt;    {&lt;br/&gt;        AppContext.&lt;span&gt;SetSwitch&lt;/span&gt;(&lt;span&gt;&quot;Npgsql.EnableLegacyTimestampBehavior&quot;&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;        optionsBuilder.&lt;span&gt;UseNpgsql&lt;/span&gt;(_connectString);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;OnModelCreating&lt;/span&gt;(&lt;span&gt;ModelBuilder&lt;/span&gt; modelBuilder)&lt;br/&gt;    {&lt;br/&gt;        modelBuilder.&lt;span&gt;Entity&lt;span&gt;&amp;lt;&lt;/span&gt;Metrics&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;()&lt;br/&gt;            .&lt;span&gt;ToTable&lt;/span&gt;(&lt;span&gt;&quot;metrics&quot;&lt;/span&gt;)&lt;br/&gt;            .&lt;span&gt;HasNoKey&lt;/span&gt;();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;这里使用了一个传递数据库连接字符串的构造函数，连接字符串从 &lt;code&gt;appsettings.json&lt;/code&gt; 文件中读取。由于 &lt;code&gt;metrics&lt;/code&gt; 表是无主键的，还需要使用 &lt;code&gt;HasNoKey()&lt;/code&gt; 进行标记。EF Core 由于使用了实体跟踪，因此无法对无主键的表进行修改，只能通过执行 SQL 的方式插入数据，在 &lt;code&gt;Metrics.cs&lt;/code&gt; 中新增方法：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;csharp&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; &lt;span&gt;Insert&lt;/span&gt;(&lt;span&gt;DbContext&lt;/span&gt; context, &lt;span&gt;Metrics&lt;/span&gt; metrics)&lt;br/&gt;{&lt;br/&gt;   &lt;span&gt;int&lt;/span&gt; row &lt;span&gt;=&lt;/span&gt; context.Database.&lt;span&gt;ExecuteSqlRaw&lt;/span&gt;(&lt;span&gt;&quot;INSERT INTO metrics VALUES ({0}, {1}, {2}, {3}, {4}, {5}, {6})&quot;&lt;/span&gt;, metrics.Time, metrics.DeviceId, metrics.WeatherType, metrics.Temperature, metrics.Humidity, metrics.Pressure, metrics.ImageBase64);&lt;br/&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; row &lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;⚠️ 警告&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;请不要在 SQL 中使用字符串内插。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;配置文件&lt;/h3&gt;&lt;p&gt;在 &lt;code&gt;appsettings.json&lt;/code&gt; 中添加如下内容：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;json&quot;&gt;{&lt;br/&gt;  &lt;span&gt;// 数据库连接字符串 &lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;ConnectionString&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;Server=localhost;Port=54321;Database=WeatherMetrics;User Id=postgres;Password=@Passw0rd;&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;// 定时任务设置&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;QuartzCron&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;0 0/1 * * * ? *&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;// 心知天气的配置&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&quot;Xinzhi&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;&quot;Key&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;Location&quot;&lt;/span&gt;&lt;span&gt;:&lt;/span&gt; &lt;span&gt;&quot;34.24:117.16&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p data-line=&quot;208&quot;&gt;&lt;span&gt;初始化与依赖注入配置&lt;/span&gt;&lt;/p&gt;&lt;p&gt;新建一个静态类 &lt;code&gt;AppConfig&lt;/code&gt;，用于保存依赖注入的 &lt;code&gt;ServiceProvider&lt;/code&gt; 变量：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;csharp&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;AppConfig&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;IServiceProvider&lt;/span&gt; ServiceProvider { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;在 &lt;code&gt;Program.cs&lt;/code&gt; 中添加初始化代码：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;csharp&quot;&gt;&lt;span&gt;// 读取配置文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; config &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ConfigurationBuilder&lt;/span&gt;()&lt;br/&gt;    .&lt;span&gt;AddJsonFile&lt;/span&gt;(&lt;span&gt;&quot;appsettings.json&quot;&lt;/span&gt;)&lt;br/&gt;    .&lt;span&gt;Build&lt;/span&gt;();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 实例化数据库上下文&lt;/span&gt;&lt;br/&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;WeatherContext&lt;/span&gt; context &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;WeatherContext&lt;/span&gt;(config[&lt;span&gt;&quot;ConnectionString&quot;&lt;/span&gt;]);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 配置 I2C，实例化传感器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;I2cConnectionSettings&lt;/span&gt; i2cSettings &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;I2cConnectionSettings&lt;/span&gt;(busId: &lt;span&gt;0&lt;/span&gt;, deviceAddress: Bmx280Base.SecondaryI2cAddress);&lt;br/&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;I2cDevice&lt;/span&gt; i2c &lt;span&gt;=&lt;/span&gt; I2cDevice.&lt;span&gt;Create&lt;/span&gt;(i2cSettings);&lt;br/&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;Bme280&lt;/span&gt; bme &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Bme280&lt;/span&gt;(i2c);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 实例化摄像头&lt;/span&gt;&lt;br/&gt;&lt;span&gt;VideoConnectionSettings&lt;/span&gt; videoSettings &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;VideoConnectionSettings&lt;/span&gt;(busId: &lt;span&gt;0&lt;/span&gt;, captureSize: (&lt;span&gt;640&lt;/span&gt;, &lt;span&gt;480&lt;/span&gt;));&lt;br/&gt;&lt;span&gt;using&lt;/span&gt; &lt;span&gt;VideoDevice&lt;/span&gt; video &lt;span&gt;=&lt;/span&gt; VideoDevice.&lt;span&gt;Create&lt;/span&gt;(videoSettings);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 配置依赖注入&lt;/span&gt;&lt;br/&gt;AppConfig.ServiceProvider &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;ServiceCollection&lt;/span&gt;()&lt;br/&gt;    .&lt;span&gt;AddSingleton&lt;/span&gt;(config)&lt;br/&gt;    .&lt;span&gt;AddSingleton&lt;/span&gt;(context)&lt;br/&gt;    .&lt;span&gt;AddSingleton&lt;/span&gt;(bme)&lt;br/&gt;    .&lt;span&gt;AddSingleton&lt;/span&gt;(video)&lt;br/&gt;    .&lt;span&gt;BuildServiceProvider&lt;/span&gt;();&lt;br/&gt;&lt;/pre&gt;&lt;p data-line=&quot;246&quot;&gt;&lt;span&gt;配置定时任务&lt;/span&gt;&lt;/p&gt;&lt;p&gt;定时任务通过 &lt;code&gt;appsettings.json&lt;/code&gt; 中的 &lt;code&gt;QuartzCron&lt;/code&gt; 字段设置。Cron 表达式分为 7 个部分，从左至右分别代表：Seconds、Minutes、Hours、DayofMonth、Month、DayofWeek 以及 Year。&lt;code&gt;*&lt;/code&gt; 出现的部分表示任意值都会触发定时任务，&lt;code&gt;/&lt;/code&gt; 左侧表示触发的起始时间，右侧表示触发间隔，以 &lt;code&gt;appsettings.json&lt;/code&gt; 中的为例，表示从每小时的第 0 分开始触发，每一分钟触发一次。&lt;/p&gt;&lt;p&gt;新建 &lt;code&gt;MetricsJob&lt;/code&gt; 类，用于实现定时任务：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;csharp&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; &lt;span&gt;MetricsJob&lt;/span&gt; : &lt;span&gt;IJob&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;Task&lt;/span&gt; &lt;span&gt;Execute&lt;/span&gt;(&lt;span&gt;IJobExecutionContext&lt;/span&gt; context)&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Task.&lt;span&gt;Run&lt;/span&gt;(&lt;span&gt;async&lt;/span&gt; () &lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;br/&gt;        {&lt;br/&gt;            &lt;span&gt;// TODO：在此处实现定时任务&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;// 需要完成传感器的读取，心知天气的请求，数据库的插入&lt;/span&gt;&lt;br/&gt;        });&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p data-line=&quot;265&quot;&gt;&lt;span&gt;传感器的读取&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在 &lt;code&gt;MetricsJob&lt;/code&gt; 类中添加方法：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;csharp&quot;&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;Metrics&lt;/span&gt; &lt;span&gt;GetMetrics&lt;/span&gt;()&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;// 获取依赖注入的 Bme280 对象&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;Bme280&lt;/span&gt; bme &lt;span&gt;=&lt;/span&gt; (Bme280)AppConfig.ServiceProvider.&lt;span&gt;GetService&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;Bme280&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 设置传感器的电源模式&lt;/span&gt;&lt;br/&gt;    bme.&lt;span&gt;SetPowerMode&lt;/span&gt;(Bmx280PowerMode.Normal);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 设置读取精度&lt;/span&gt;&lt;br/&gt;    bme.PressureSampling &lt;span&gt;=&lt;/span&gt; Sampling.UltraHighResolution;&lt;br/&gt;    bme.TemperatureSampling &lt;span&gt;=&lt;/span&gt; Sampling.UltraHighResolution;&lt;br/&gt;    bme.HumiditySampling &lt;span&gt;=&lt;/span&gt; Sampling.UltraHighResolution;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 读取数据&lt;/span&gt;&lt;br/&gt;    bme.&lt;span&gt;TryReadPressure&lt;/span&gt;(&lt;span&gt;out&lt;/span&gt; &lt;span&gt;UnitsNet&lt;span&gt;.&lt;/span&gt;Pressure&lt;/span&gt; p);&lt;br/&gt;    bme.&lt;span&gt;TryReadTemperature&lt;/span&gt;(&lt;span&gt;out&lt;/span&gt; &lt;span&gt;UnitsNet&lt;span&gt;.&lt;/span&gt;Temperature&lt;/span&gt; t);&lt;br/&gt;    bme.&lt;span&gt;TryReadHumidity&lt;/span&gt;(&lt;span&gt;out&lt;/span&gt; &lt;span&gt;UnitsNet&lt;span&gt;.&lt;/span&gt;RelativeHumidity&lt;/span&gt; h);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 传感器休眠&lt;/span&gt;&lt;br/&gt;    bme.&lt;span&gt;SetPowerMode&lt;/span&gt;(Bmx280PowerMode.Sleep);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Metrics&lt;/span&gt;&lt;br/&gt;    {&lt;br/&gt;        DeviceId &lt;span&gt;=&lt;/span&gt; Dns.&lt;span&gt;GetHostName&lt;/span&gt;(),&lt;br/&gt;        Temperature &lt;span&gt;=&lt;/span&gt; Math.&lt;span&gt;Round&lt;/span&gt;(t.DegreesCelsius, &lt;span&gt;2&lt;/span&gt;),&lt;br/&gt;        Humidity &lt;span&gt;=&lt;/span&gt; Math.&lt;span&gt;Round&lt;/span&gt;(h.Percent, &lt;span&gt;2&lt;/span&gt;),&lt;br/&gt;        Pressure &lt;span&gt;=&lt;/span&gt; Math.&lt;span&gt;Round&lt;/span&gt;(p.Pascals, &lt;span&gt;2&lt;/span&gt;)&lt;br/&gt;    };&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p data-line=&quot;300&quot;&gt;&lt;span&gt;摄像头捕获图像&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在 &lt;code&gt;MetricsJob&lt;/code&gt; 类中添加方法：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;csharp&quot;&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;span&gt;GetImage&lt;/span&gt;()&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;VideoDevice&lt;/span&gt; video &lt;span&gt;=&lt;/span&gt; (VideoDevice)AppConfig.ServiceProvider.&lt;span&gt;GetService&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;VideoDevice&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[]&lt;/span&gt;&lt;/span&gt; image &lt;span&gt;=&lt;/span&gt; video.&lt;span&gt;Capture&lt;/span&gt;();&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Convert.&lt;span&gt;ToBase64String&lt;/span&gt;(image);&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p data-line=&quot;313&quot;&gt;&lt;span&gt;心知天气 API 请求&lt;/span&gt;&lt;/p&gt;&lt;p&gt;通过请求心知天气 API 获得当前位置的天气名称，需要提前在 https://www.seniverse.com/api 申请 API Key。在 &lt;code&gt;MetricsJob&lt;/code&gt; 类中添加方法：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;csharp&quot;&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; &lt;span&gt;Task&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;GetXinzhiWeatherAsync&lt;/span&gt;()&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;IConfigurationRoot&lt;/span&gt; config &lt;span&gt;=&lt;/span&gt; (IConfigurationRoot)AppConfig.ServiceProvider.&lt;span&gt;GetService&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;IConfigurationRoot&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;using&lt;/span&gt; &lt;span&gt;HttpClient&lt;/span&gt; client &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;HttpClient&lt;/span&gt;();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt;&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; json &lt;span&gt;=&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; client.&lt;span&gt;GetStringAsync&lt;/span&gt;(&lt;span&gt;$&quot;https://api.seniverse.com/v3/weather/now.json?key=&lt;/span&gt;{config[&lt;span&gt;&quot;Xinzhi:Key&quot;&lt;/span&gt;]}&lt;span&gt;&amp;amp;location=&lt;/span&gt;{config[&lt;span&gt;&quot;Xinzhi:Location&quot;&lt;/span&gt;]}&lt;span&gt;&amp;amp;language=zh-Hans&amp;amp;unit=c&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;)JsonConvert.&lt;span&gt;DeserializeObject&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dynamic&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;(json).results[&lt;span&gt;0&lt;/span&gt;].now.text;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;catch&lt;/span&gt; (&lt;span&gt;Exception&lt;/span&gt;)&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;.Empty;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p data-line=&quot;335&quot;&gt;&lt;span&gt;完善定时任务&lt;/span&gt;&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;csharp&quot;&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Task&lt;/span&gt; &lt;span&gt;Execute&lt;/span&gt;(&lt;span&gt;IJobExecutionContext&lt;/span&gt; context)&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Task.&lt;span&gt;Run&lt;/span&gt;(&lt;span&gt;async&lt;/span&gt; () &lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;var&lt;/span&gt; metrics &lt;span&gt;=&lt;/span&gt; &lt;span&gt;GetMetrics&lt;/span&gt;();&lt;br/&gt;        metrics.WeatherType &lt;span&gt;=&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; &lt;span&gt;GetXinzhiWeatherAsync&lt;/span&gt;();&lt;br/&gt;        metrics.ImageBase64 &lt;span&gt;=&lt;/span&gt; &lt;span&gt;GetImage&lt;/span&gt;();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;WeatherContext&lt;/span&gt; context &lt;span&gt;=&lt;/span&gt; (WeatherContext)AppConfig.ServiceProvider.&lt;span&gt;GetService&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;WeatherContext&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;        Metrics.&lt;span&gt;Insert&lt;/span&gt;(context, metrics);&lt;br/&gt;    });&lt;br/&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p data-line=&quot;353&quot;&gt;&lt;span&gt;创建定时任务触发器&lt;/span&gt;&lt;/p&gt;&lt;p&gt;在 &lt;code&gt;Program.cs&lt;/code&gt; 中添加：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;csharp&quot;&gt;&lt;span&gt;// 创建一个触发器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; trigger &lt;span&gt;=&lt;/span&gt; TriggerBuilder.&lt;span&gt;Create&lt;/span&gt;()&lt;br/&gt;    .&lt;span&gt;WithCronSchedule&lt;/span&gt;(config[&lt;span&gt;&quot;QuartzCron&quot;&lt;/span&gt;])&lt;br/&gt;    .&lt;span&gt;Build&lt;/span&gt;();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 创建任务&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; jobDetail &lt;span&gt;=&lt;/span&gt; JobBuilder.&lt;span&gt;Create&lt;span&gt;&amp;lt;&lt;/span&gt;MetricsJob&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;()&lt;br/&gt;    .&lt;span&gt;WithIdentity&lt;/span&gt;(&lt;span&gt;&quot;job&quot;&lt;/span&gt;, &lt;span&gt;&quot;group&quot;&lt;/span&gt;)&lt;br/&gt;    .&lt;span&gt;Build&lt;/span&gt;();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 绑定调度器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ISchedulerFactory&lt;/span&gt; factory &lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;StdSchedulerFactory&lt;/span&gt;();&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; scheduler &lt;span&gt;=&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; factory.&lt;span&gt;GetScheduler&lt;/span&gt;();&lt;br/&gt;&lt;span&gt;await&lt;/span&gt; scheduler.&lt;span&gt;ScheduleJob&lt;/span&gt;(jobDetail, trigger);&lt;br/&gt;&lt;span&gt;await&lt;/span&gt; scheduler.&lt;span&gt;Start&lt;/span&gt;();&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;这样一个一分钟采集一次数据的简易气象站就完成了。&lt;/p&gt;&lt;h2&gt;部署应用&lt;/h2&gt;&lt;p data-line=&quot;378&quot;&gt;&lt;span&gt;发布到文件&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;切换到 &lt;code&gt;WeatherMetrics.ConsoleApp&lt;/code&gt; 项目运行发布命令：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;&quot;&gt;&lt;code&gt;dotnet publish -c release -r linux-arm&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;将发布后的文件通过 FTP 等方式复制到 Linux 开发板；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;为 &lt;code&gt;WeatherMetrics.ConsoleApp&lt;/code&gt; 文件增加可执行权限&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;&quot;&gt;&lt;code&gt;sudo chmod +x WeatherMetrics.ConsoleApp&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;4&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;运行程序&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;&quot;&gt;&lt;code&gt;sudo ./WeatherMetrics.ConsoleApp&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-line=&quot;394&quot;&gt;&lt;span&gt;打包 Docker 镜像&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;查看 TimescaleDB 容器的 IP，并修改 &lt;code&gt;appsettings.json&lt;/code&gt; 的数据库连接字符串：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;&quot;&gt;&lt;code&gt;docker inspect -f &#x27;{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}&#x27; timescaledb&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;在项目的根目录中创建 &lt;code&gt;Dockerfile&lt;/code&gt;，并将整个项目复制到 Linux 开发板中：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;Dockerfile&quot;&gt;&lt;span&gt;FROM&lt;/span&gt; mcr.microsoft.com/dotnet/core/sdk:6.0-focal-arm32v7 &lt;span&gt;AS&lt;/span&gt; build&lt;br/&gt;&lt;span&gt;WORKDIR&lt;/span&gt; /app&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# publish app&lt;/span&gt;&lt;br/&gt;&lt;span&gt;COPY&lt;/span&gt; src .&lt;br/&gt;&lt;span&gt;WORKDIR&lt;/span&gt; /app/WeatherMetrics.ConsoleApp&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt; dotnet restore&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt; dotnet publish -c release -r linux-arm -o out&lt;br/&gt;&lt;br/&gt;&lt;span&gt;## run app&lt;/span&gt;&lt;br/&gt;&lt;span&gt;FROM&lt;/span&gt; mcr.microsoft.com/dotnet/core/runtime:6.0-focal-arm32v7 &lt;span&gt;AS&lt;/span&gt; runtime&lt;br/&gt;&lt;span&gt;WORKDIR&lt;/span&gt; /app&lt;br/&gt;&lt;span&gt;COPY&lt;/span&gt; &lt;span&gt;--from&lt;/span&gt;=&lt;span&gt;build&lt;/span&gt; /app/WeatherMetrics.ConsoleApp/out ./&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# install native dependencies&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt; apt update &amp;amp;&amp;amp; &lt;span&gt;\&lt;/span&gt;&lt;br/&gt;    apt install -y --allow-unauthenticated v4l-utils libc6-dev libgdiplus libx11-dev&lt;br/&gt;&lt;br/&gt;&lt;span&gt;ENTRYPOINT&lt;/span&gt; [&lt;span&gt;&quot;dotnet&quot;&lt;/span&gt;, &lt;span&gt;&quot;WeatherMetrics.ConsoleApp.dll&quot;&lt;/span&gt;]&lt;br/&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;切换到项目目录，构建镜像：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;&quot;&gt;&lt;code&gt;docker build -t weather-metrics -f Dockerfile .&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;4&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;运行镜像：&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;&quot;&gt;&lt;code&gt;docker run --rm -it --device /dev/video0 --device /dev/i2c-0 weather-metrics&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;后续工作&lt;/h2&gt;&lt;p&gt;程序运行一段时间后，使用标准的 SQL 查询一下数据：&lt;/p&gt;&lt;pre data-role=&quot;codeBlock&quot; data-info=&quot;sql&quot;&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; metrics&lt;br/&gt;&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; &lt;span&gt;time&lt;/span&gt; &lt;span&gt;DESC&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4608788853161844&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/09LgVyNibqhH2FckWjFMxMuNuFmq5eCwX5tLxPr0n0sibK1DShJnVQYcia8uTnS7OBP4GlgSnv3BXIy0pvW24JefA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;933&quot;/&gt;&lt;/p&gt;&lt;p&gt;硬件是软件的基础，对收集到的数据后续可以使用其他技术进行处理，比如可以使用 ASP.NET 编写 WEB 应用对数据进行展示，或者可以使用 ML.NET 构建机器学习模型对天气进行预测等等。&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e12599b7e1b8083ac770cb7386fe80e2</guid>
<title>做好用户标签体系建设，打好精细化运营的底层根基</title>
<link>https://toutiao.io/k/4zaxevz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;上一篇文章&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5OTExMjkwMA==&amp;amp;mid=2651921382&amp;amp;idx=1&amp;amp;sn=170969b766c3fa8e952f24cccb896370&amp;amp;chksm=bd25c24d8a524b5b2eda755d6da9f71f48f9e2dd1b67a4434e7b6b31a99f4d7a45e6daebb5fb&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《用户标签——理解与洞察用户需求的关键》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《用户标签——理解与洞察用户需求的关键》&lt;/span&gt;&lt;/a&gt;，我们从用户标签在企业应用中的发展史，初步了解了什么是用户标签，以及用户标签的作用。&lt;/p&gt;&lt;p&gt;这篇文章将为大家介绍用户标签体系是什么、它的层次化结构，以及定义用户标签的6大规范。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;em&gt;First Point&lt;/em&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;认识用户标签体系&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;用户标签体系实际上就是标签的合集，以用户为中心，通过不同的观察角度将标签组合在一起，帮助我们从某些方面更快、更全面地了解用户，形成对用户综合的评价。&lt;/p&gt;&lt;p&gt;如下图所示，我们通过对用户标签进行有效的归类、梳理后，基于标签对用户的洞察将更为清晰、易于理解。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1ibVfXfhQiaUgVMHbGBdjpuCrugn2EaAGp8QhQJEDiaXBbibbw8m4yXpna7oWYFtZtibEzPPRXYb4NJsrxZkezvyibvQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;em&gt;Second Point&lt;/em&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;用户标签体系的层次结构&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;目前，主流的用户标签体系结构都是层次化的，通过标签的分类层次结构归纳不同业务部门、场景下的标签集合。&lt;/p&gt;&lt;p&gt;根据企业的不同需求，用户标签体系通常会被分为几个大类，每个大类下再进行逐层细分。在建设用户标签体系时，我们只需构建最下层的用户标签，就能映射到上层的用户标签。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1ibVfXfhQiaUgVMHbGBdjpuCrugn2EaAGpV6sZJF6dia4jgSmvjEYP7xfQaXzmILhXFjH7xxib9icaFibVU4ibYlhMr2w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;用户标签体系示例&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;在对用户标签体系进行分类时，我们一般遵循两个重要的原则：&lt;/p&gt;&lt;p&gt;当我们在设计整个用户标签体系的分类时，需要认识到组织、设计不同的分类实际上是在选择观察用户的角度。那应该从什么角度观察呢？答案是——业务的角度。&lt;/p&gt;&lt;p&gt;在企业中，我们应该从业务的角度去观察：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;用户在产品上有什么行为特点？具体在每一个业务环节又是怎样？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户对产品表现出了何种兴趣与偏好？在不同的场景下又是如何？&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;用户在不同业务的交易情况如何？有没有体现什么特征......&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;总的来说，围绕用户在产品上的行为、偏好等组织不同的分类，结合注册、浏览等用户行为路径，进一步细分。&lt;span&gt;在后续的文章中，我们将会带着大家一起深入的去掌握如何基于用户的旅程、需求场景去拆分、细化标签，归纳、汇总分类，最终形成标签体系。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;3&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;em&gt;Third Point&lt;/em&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;定义用户标签的六大规范&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;用户标签及其体系是要开放给所有业务部门共同使用的，因此，在企业内部统一对用户标签的规范非常重要。我们总结了如下6大规范。&lt;span&gt;关于这6大规范的详细讲解将在下一篇文章中展开。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562963&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1ibVfXfhQiaUgVMHbGBdjpuCrugn2EaAGpgUYtDHvfWaaDI1nZJXQkG7uuwIC6LfbBDiaovDDn63FBXqBuG4kPic2w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;标签名称应该直观、准确，让人一眼就能理解指代的是什么。&lt;/p&gt;&lt;p&gt;标签类型一般可以分为静态标签、动态标签，或分为事实标签、统计标签、规则标签、挖掘标签。&lt;/p&gt;&lt;p&gt;清楚描述标签的计算规则，帮助使用者了解是否与认知一致。&lt;/p&gt;&lt;p&gt;标签的取值类型是什么，关系到如何使用这些标签，是否支持二次计算。&lt;/p&gt;&lt;p&gt;标签是如何执行计算的？单次还是周期？多久一次？什么时候计算？&lt;/p&gt;&lt;p&gt;不同业务角色，谁来管理标签、谁来使用标签，需要明确权限。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;关于易观方舟&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;易观方舟是易观集团旗下的全场景私域用户运营解决方案服务商，拥有智能分析、智能运营、智能画像三大产品组件及配套咨询服务，帮助企业沉淀数字用户资产，打造数据驱动运营闭环，建立私域用户亲密关系，实现精益成长。&lt;/p&gt;&lt;p&gt;目前，易观方舟已经覆盖品牌零售、地产、汽车、金融、企业服务、互联网+等10余个行业，获得招商银行、工商银行、翼支付、平安集团、华润置地、越秀地产、中石化、用友、上汽EVCARD、相宜本草、幸福西饼等上百家客户的认可。&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;点击&lt;span&gt;「阅读原文」&lt;/span&gt;构建用户标签与画像&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;↓↓↓ &lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>