<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>2ee9f6222fa110d9e3f034bd3e6ee7c0</guid>
<title>云计算的全球变局与中国故事</title>
<link>https://toutiao.io/k/9z6dese</link>
<content:encoded>&lt;div&gt;&lt;body id=&quot;readabilityBody&quot;&gt;
&lt;p id=&quot;app&quot;/&gt;
&lt;img src=&quot;https://static001.infoq.cn/static/infoq/img/logo-121-75.yuij86g.png&quot; alt=&quot;云计算的全球变局与中国故事_云原生_刘燕_InfoQ精选文章&quot;/&gt;





    

&lt;/body&gt;
&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fab35e5893ba196e27a1c5855a39f500</guid>
<title>快用上PerformanceObserver，别再手动计算首屏时间了</title>
<link>https://toutiao.io/k/tbxln35</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天给大家介绍一个非常好用的浏览器api：&lt;strong&gt;PerformanceObserver&lt;/strong&gt; ， 我们可以用它来获取首屏、白屏的时间，就不用再麻烦地手动去计算了。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7795275590551181&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/FaeDdIfeuq4sKDyNWpYu0aYzrbGBbZvyww1AOVtJHd7BDEictrZgXjI1b3hKJ4QHRZFhbrzUono2YYfmQtiaFIDQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;254&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;/span&gt;&lt;span&gt;介绍&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;PerformanceObserver&lt;/strong&gt; 可用于获取性能相关的数据，例如&lt;strong&gt;首帧fp&lt;/strong&gt;、&lt;strong&gt;首屏fcp&lt;/strong&gt;、&lt;strong&gt;首次有意义的绘制 fmp&lt;/strong&gt;等等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;构造函数&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;PerformanceObserver()&lt;/code&gt;创建并返回一个新的 PerformanceObserver 对象。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;提供的方法&lt;/span&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;PerformanceObserver.observe()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当记录的性能指标在指定的 entryTypes 之中时，将调用性能观察器的回调函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;PerformanceObserver.disconnect()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;停止性能观察者回调接收到性能指标。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;PerformanceObserver.takeRecords()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;返回存储在性能观察器中的性能指标的列表，并将其清空。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;重点我们看看observer.observe(options);&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;options&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个只装了单个键值对的对象，该键值对的键名规定为 &lt;strong&gt;entryTypes&lt;/strong&gt;。e&lt;strong&gt;ntryTypes&lt;/strong&gt; 的取值要求如下:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;entryTypes 的值：一个放字符串的数组，字符串的有效值取值在性能条目类型 中有详细列出。如果其中的某个字符串取的值无效，浏览器会自动忽略它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另：若未传入 options 实参，或传入的 options 实参为空数组，会抛出 TypeError。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;2&lt;/span&gt;&lt;/span&gt;&lt;span&gt;实例&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;br/&gt; &lt;span&gt;const&lt;/span&gt; observer = &lt;span&gt;new&lt;/span&gt; PerformanceObserver(&lt;span&gt;(&lt;span&gt;list&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;const&lt;/span&gt; entry &lt;span&gt;of&lt;/span&gt; list.getEntries()){&lt;br/&gt;   &lt;span&gt;console&lt;/span&gt;.groupCollapsed(entry.name);&lt;br/&gt;   &lt;span&gt;console&lt;/span&gt;.log(entry.entryType);&lt;br/&gt;   &lt;span&gt;console&lt;/span&gt;.log(entry.startTime);&lt;br/&gt;   &lt;span&gt;console&lt;/span&gt;.log(entry.duration);&lt;br/&gt;   &lt;span&gt;console&lt;/span&gt;.groupEnd(entry.name);&lt;br/&gt;  }&lt;br/&gt; }) &lt;br/&gt; observer.observe({&lt;span&gt;entryTypes&lt;/span&gt;:[&lt;span&gt;&#x27;longtask&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;frame&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;navigation&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;resource&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;mark&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;measure&#x27;&lt;/span&gt;,&lt;span&gt;&#x27;paint&#x27;&lt;/span&gt;]});&lt;br/&gt;&amp;lt;&lt;span&gt;/script&amp;gt;&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获取结果&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7601522842639594&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FaeDdIfeuq4sKDyNWpYu0aYzrbGBbZvy9S9BZEibqp5smUeWNuoEvm7zjmVRlgbsDCIiaPzVEwH42FT81icTOREQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;788&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据打印结果我们可以推测出来：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;entryTypes里的值其实就是我们告诉PerformanceObserver，我们想要获取的某一方面的性能值。例如传入&lt;strong&gt;paint&lt;/strong&gt;，就是说我们想要得到fcp和fp。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们看打印，它打印出来了fp和fcp&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2964071856287425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FaeDdIfeuq4sKDyNWpYu0aYzrbGBbZvywXmOzGYvwKHbVP95xj64Z5iaQic5erYNOS1HIhDesibFgZcJI0DZTicsJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;668&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有必要解释一下什么是fp，fcp，fpm&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;TTFB：Time To First Byte，首字节时间&lt;br/&gt;FP：First Paint，首次绘制，绘制Body&lt;br/&gt;FCP：First Contentful Paint，首次有内容的绘制，第一个dom元素绘制完成&lt;br/&gt;FMP：First Meaningful Paint，首次有意义的绘制&lt;br/&gt;TTI：Time To Interactive，可交互时间，整个内容渲染完成&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/FaeDdIfeuq4sKDyNWpYu0aYzrbGBbZvyyneHZpsEibq7RaJBvkKwhcH2FQ1S6icjMEFLY1Xq6gA2icOuXbZKrGpBw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;270&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不懂？看图！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35789473684210527&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FaeDdIfeuq4sKDyNWpYu0aYzrbGBbZvyRArb0GharyamZNnPAA1WRczKLl534Bseh9XvFHZQWUwbicVtbmSxAGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;665&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;FP仅有一个div根节点&lt;br/&gt;FCP包含页面的基本框架，但没有数据内容&lt;br/&gt;FMP包含页面的所有元素及数据&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Wow！恍然大悟！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;3&lt;/span&gt;&lt;/span&gt;&lt;span&gt;实际使用&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，我们在实际项目中怎么取获取呢？可以看看我的实现参考一下下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;// 使用 PerformanceObserver 监听 fcp&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!!PerformanceObserver){&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; type = &lt;span&gt;&#x27;paint&#x27;&lt;/span&gt;;&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; ((PerformanceObserver.supportedEntryTypes || []).includes(type)) {&lt;br/&gt;        observer = &lt;span&gt;new&lt;/span&gt; PerformanceObserver(&lt;span&gt;(&lt;span&gt;entryList&lt;/span&gt;)=&amp;gt;&lt;/span&gt;{&lt;br/&gt;          &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;const&lt;/span&gt; entry &lt;span&gt;of&lt;/span&gt; entryList.getEntriesByName(&lt;span&gt;&#x27;first-contentful-paint&#x27;&lt;/span&gt;)){&lt;br/&gt;            &lt;span&gt;const&lt;/span&gt; { startTime,duration } = entry;&lt;br/&gt;            &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;[assets-load-monitor] PerformanceObserver fcp:&#x27;&lt;/span&gt;, startTime+&lt;span&gt;durati&lt;/span&gt;&lt;span&gt;on&lt;/span&gt;);&lt;br/&gt;            &lt;br/&gt;            &lt;span&gt;// 上报startTime操作&lt;/span&gt;&lt;br/&gt;          }&lt;br/&gt;        });&lt;br/&gt;        observer.observe({&lt;br/&gt;          &lt;span&gt;entryTypes&lt;/span&gt;: [type],&lt;br/&gt;        });&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;      }&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (e) {&lt;br/&gt;      &lt;span&gt;// ios 不支持这种entryTypes，会报错 https://caniuse.com/?search=PerformancePaintTiming&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.warn(&lt;span&gt;&#x27;[assets-load-monitor] PerformanceObserver error:&#x27;&lt;/span&gt;, (e || {}).message ? e.message : e);&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里用了判断是否可以使用PerformanceObserver，不能使用的话，我们是用其他方法的，例如MutationObserver，这个我们我们后面再讲。&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8733333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/FaeDdIfeuq4sKDyNWpYu0aYzrbGBbZvyC9BYibejt6iaLuXKnDMhUmBNwE4FLicCwaQJejnycialvM64zK4lV4l7dQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;150&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4139749505603164&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/FaeDdIfeuq4sKDyNWpYu0aYzrbGBbZvyz1NnBZOkqbKnXtocxPAgdsocNMkZINp1SJwWQ6BZSWAibEE7cLunFyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1517&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;4&lt;/span&gt;&lt;/span&gt;&lt;span&gt;参考文章：&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://blog.csdn.net/weixin_40970987/article/details/108121988 https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceObserver/observe&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>eb316818b048377a71f5cf41df051011</guid>
<title>介绍一个数据血缘的项目 OpenLineage</title>
<link>https://toutiao.io/k/pb9ns85</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;h4&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;“大数据”这个概念逐渐深入人心，很多公司都面临的着：&lt;/p&gt;&lt;p&gt;总的来说，就是“大数据”中的“大”不仅仅是数据量大，也指的是数据种类多、数据来源复杂，不同的数据被各式各样的人使用。如何发现数据，确定数据的来龙去脉就成了一个急迫的问题。&lt;/p&gt;&lt;p&gt;OpenLineage 应运而生。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;介绍 OpenLineage&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;OpenLineage 可以翻译成开源血缘。按照这个项目的发起者 Julien Le Dem 的说法，“数据血缘需要遵循开源社区贡献者商定的标准，以保证其各自解决方案生成的元数据的兼容性和一致性。”&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Data lineage needs to follow a standard agreed upon by contributors to the open source community to guarantee the compatibility and consistency of the metadata produced by their respective solutions.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;它回答的问题是：“谁生产数据？它是如何转变的？谁在使用它？数据血缘是 DataOps 的支柱，它提供了对组织内数据旅程中系统和数据集交互的可见性。”&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Data lineage is the backbone of DataOps, providing visibility into the interaction of systems and datasets across the journey of data within an organization.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;也给出了一个可用的数据血缘应该满足什么样的要求。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;它不仅需要捕获正在生成的数据集之间的依赖关系，还需要捕获生成和转换它们的业务逻辑&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;这些数据集和程序中的每一个都需要有一种统一命名的形式，以便可以轻松识别并跨不同域统一访问&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;这些数据集和程序中的所有变化都需要以细粒度和自动方式进行跟踪和版本控制，以更好地了解整个生态系统随时间的演变&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;考虑到它需要支持的各种用例，描述这些数据集和程序的元数据需要灵活且可扩展&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;现在的 OpenLineage 的参与者包括了下面的一些开源项目：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Airflow&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Amundsen&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Datahub&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;dbt&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Egeria&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Great Expectations&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Iceberg&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Marquez&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Pandas&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Parquet&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Prefect&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Spark&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Superset&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;OpenLineage 概览&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;正如上面列举的参与 OpenLineage 的项目，它们都有着独特的设计理念和实现思路，让数据发现平台去和这些计算引擎一对一对接的话，就会变成复杂的网状的的链路。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4766666666666667&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;300&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CFQZvsFct4ZtKq3njEjdMOeh0WZhYibAiclJSTyNpeJk78iaJ0Rqq1dZCsGGIk8y4N8gcwlmdRK1HRaqDGW3p76Jg/640?wx_fmt=png&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;而 OpenLineage 起到了中间件的作用，负责沟通上下游。&lt;br/&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5154639175257731&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;291&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/CFQZvsFct4ZtKq3njEjdMOeh0WZhYibAicWqJwbOOa81hSs1JwSicX0CvFEr1XyUCgw7yyGUkdjJ8bIP5kqH6MbqA/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;作为一个中间件，就是抛去所有花里胡哨的特性，直击本质。也就是上面提到的三个问题：&lt;/p&gt;&lt;p&gt;OpenLineage 的回答就是它的核心数据模型&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6382978723404256&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;940&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CFQZvsFct4ZtKq3njEjdMOeh0WZhYibAicY1o085MZ2RofngfeQXLOicKpYXlfC6GGlsMHo5RVF5WqfjCrg30WXdQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;Run 和 Job 回答的是“它是如何转变的？”，Inputs/Outputs 回答的是“谁生产数据”/“谁在使用它”。在  OpenLineage 的核心数据模型设计中，它没有选择实现更细节，也更麻烦的列级别血缘，而是只做到了表级别的血缘。在我看来，这个选择是非常棒的，因为要选择实现列级别的血缘，每一种特定类型的 SQL 势必要绑定对应的 SQL 解释器，这就让 OpenLineage 变得复杂，就谈不上通用的标准了。&lt;/p&gt;&lt;p&gt;OpenLineage 的表达方式选择了 Json 格式，具体细节可以参考：https://github.com/OpenLineage/OpenLineage/blob/main/spec/OpenLineage.md&lt;/p&gt;&lt;pre&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;eventType&quot;&lt;/span&gt;: &lt;span&gt;&quot;START&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;eventTime&quot;&lt;/span&gt;: &lt;span&gt;&quot;2020-12-09T23:37:31.081Z&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;run&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;runId&quot;&lt;/span&gt;: &lt;span&gt;&quot;3b452093-782c-4ef2-9c0c-aafe2aa6f34d&quot;&lt;/span&gt;,&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;job&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;namespace&quot;&lt;/span&gt;: &lt;span&gt;&quot;my-scheduler-namespace&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;myjob.mytask&quot;&lt;/span&gt;,&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;inputs&quot;&lt;/span&gt;: [&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;&quot;namespace&quot;&lt;/span&gt;: &lt;span&gt;&quot;my-datasource-namespace&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;instance.schema.table&quot;&lt;/span&gt;,&lt;br/&gt;    }&lt;br/&gt;  ],&lt;br/&gt;  &lt;span&gt;&quot;outputs&quot;&lt;/span&gt;: [&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;&quot;namespace&quot;&lt;/span&gt;: &lt;span&gt;&quot;my-datasource-namespace&quot;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&quot;name&quot;&lt;/span&gt;: &lt;span&gt;&quot;instance.schema.output_table&quot;&lt;/span&gt;,&lt;br/&gt;    }&lt;br/&gt;  ],&lt;br/&gt;  &lt;span&gt;&quot;producer&quot;&lt;/span&gt;: &lt;span&gt;&quot;https://github.com/OpenLineage/OpenLineage/blob/v1-0-0/client&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;schemaURL&quot;&lt;/span&gt;: &lt;span&gt;&quot;https://openlineage.io/spec/1-0-0/OpenLineage.json#/definitions/RunEvent&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;&lt;span&gt;介绍 Marquez&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;空有标准，没有实现是没有意义的，OpenLineage 官方推荐的实现是 Marquez。它和 Databub、Amundsen 类似，长得像下面这样。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6084745762711864&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1180&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CFQZvsFct4ZtKq3njEjdMOeh0WZhYibAicsD7iaO8eAF0dVN3QQmQQqD6icezS7kWUc6EzkbPE3t5UCLL21zNJqJFA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.53&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1800&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/CFQZvsFct4ZtKq3njEjdMOeh0WZhYibAicXicmVfHs4icSrsu3eAjQeCsOcY4EuEhFiaMp0JwcDUoLGRpuIONzPBYjg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;OpenLineage 是一个有野心的项目，它想和 HDFS 变成了分布式文件系统通用标准一样，变成数据血缘的通用标准。但是 OpenLineage 从 2020 年发布到现在，Databub、Amundsen 并没有受到 OpenLineage 的影响，依旧在按照项目自身的发展路径前进。&lt;/p&gt;&lt;p&gt;从个人实践来看，我很喜欢这个项目。国内很多谈数据治理的文章，都是在讲规章制度和规范这些，至于具体的落实，基本上很少会涉及，特别是像把数据血缘做成标准，可以让各种各样的数据计算引擎以同一套标准接入，就几乎上没有了。毕竟光讲理念、规章和制度，不去谈实现，略有“好高骛远”的嫌疑。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;参考链接&lt;/span&gt;&lt;/h4&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://datakin.com/introducing-openlineage/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://github.com/OpenLineage/OpenLineage&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://openlineage.io/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>13ede43ae9c37c8861721c3cd09ac68e</guid>
<title>更准更快的YOLOv6来了，美团出品并开源</title>
<link>https://toutiao.io/k/jylzk4r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                       &quot; id=&quot;js_content&quot;&gt;
            &lt;section data-mpa-powered-by=&quot;yiban.io&quot; data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; data-style=&quot;white-space: normal; max-width: 100%; letter-spacing: 0.544px; text-size-adjust: auto; background-color: rgb(255, 255, 255); font-family: &amp;quot;Helvetica Neue&amp;quot;, Helvetica, &amp;quot;Hiragino Sans GB&amp;quot;, &amp;quot;Microsoft YaHei&amp;quot;, Arial, sans-serif; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__0&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-id=&quot;85660&quot; data-custom=&quot;rgb(117, 117, 118)&quot; data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-id=&quot;85660&quot; data-custom=&quot;rgb(117, 117, 118)&quot; data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section data-darkmode-bgcolor-16095509242984=&quot;rgb(25, 25, 25)&quot; data-darkmode-original-bgcolor-16095509242984=&quot;rgb(255, 255, 255)&quot; data-style=&quot;margin-top: 2em; padding-top: 0.5em; padding-bottom: 0.5em; max-width: 100%; border-style: solid none; text-decoration: inherit; border-top-color: rgb(204, 204, 204); border-bottom-color: rgb(204, 204, 204); border-top-width: 1px; border-bottom-width: 1px; box-sizing: border-box !important; overflow-wrap: break-word !important;&quot; class=&quot;js_darkmode__1&quot; mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;section mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;NaN&quot;&gt;&lt;span mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;NaN&quot;&gt;机器之心发布&lt;/span&gt;&lt;/section&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;51&quot;&gt;&lt;span mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;51&quot;&gt;&lt;strong mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;51&quot;&gt;机器之心编辑部&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;12&quot; data-source-title=&quot;&quot; mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;section mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;section mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;p mp-original-font-size=&quot;15&quot; mp-original-line-height=&quot;24&quot;&gt;&lt;span&gt;YOLOv6的精度与速度都远超 YOLOv5 和 YOLOX。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;YOLOv6 是美团视觉智能部研发的一款目标检测框架，致力于工业应用。本框架同时专注于检测的精度和推理效率，在工业界常用的尺寸模型中：YOLOv6-nano 在 COCO 上精度可达 35.0% AP，在 T4 上推理速度可达 1242 FPS；YOLOv6-s 在 COCO 上精度可达 43.1% AP，在 T4 上推理速度可达 520 FPS。在部署方面，YOLOv6 支持 GPU（TensorRT）、CPU（OPENVINO）、ARM（MNN、TNN、NCNN）等不同平台的部署，极大地简化工程部署时的适配工作。目前，项目已开源至 Github，欢迎有需要的小伙伴们 Star 收藏，随时取用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.39985538684020244&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KmXPKA19gW9L53gxmhfMqgm8b0BYGfqSyDu3qYd8Iia0nWBr12ZdY743k8Qg6fPajquvtJ391le9RnQiaBHkfrcg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2766&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;项目地址：https://github.com/meituan/YOLOv6&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;精度与速度远超 YOLOv5 和 YOLOX 的新框架&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;目标检测作为计算机视觉领域的一项基础性技术，在工业界得到了广泛的应用，其中 YOLO 系列算法因其较好的综合性能，逐渐成为大多数工业应用时的首选框架。至今，业界已衍生出许多 YOLO 检测框架，其中以 YOLOv5[1]、YOLOX[2] 和 PP-YOLOE[3] 最具代表性，但在实际使用中，我们发现上述框架在速度和精度方面仍有很大的提升的空间。基于此，我们通过研究并借鉴了业界已有的先进技术，开发了一套新的目标检测框架——YOLOv6。该框架支持模型训练、推理及多平台部署等全链条的工业应用需求，并在网络结构、训练策略等算法层面进行了多项改进和优化，在 COCO 数据集上，YOLOv6 在精度和速度方面均超越其他同体量算法，相关结果如下图 1 所示：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7212962962962963&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9L53gxmhfMqgm8b0BYGfqSrbaYJibdMVhGXQL2dSXBFE52fJW6jKWCk84Y2pR39xouuTKQJxAEWgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;图 1-1 YOLOv6 各尺寸模型与其他模型性能对比&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7212962962962963&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9L53gxmhfMqgm8b0BYGfqSUvFibHM6S6FQiciaXI4Nibdwnj8tyFpbxkH7tJRauWEgQelDB5Z3UOGNCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;图 1-2 YOLOv6 与其他模型在不同分辨率下性能对比&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;图 1-1 展示了不同尺寸网络下各检测算法的性能对比，曲线上的点分别表示该检测算法在不同尺寸网络下（s/tiny/nano）的模型性能，从图中可以看到，YOLOv6 在精度和速度方面均超越其他 YOLO 系列同体量算法。图 1-2 展示了输入分辨率变化时各检测网络模型的性能对比，曲线上的点从左往右分别表示图像分辨率依次增大时（384/448/512/576/640）该模型的性能，从图中可以看到，YOLOv6 在不同分辨率下，仍然保持较大的性能优势。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;YOLOv6 关键技术介绍&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;YOLOv6 主要在 Backbone、Neck、Head 以及训练策略等方面进行了诸多的改进：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;我们统一设计了更高效的 Backbone 和 Neck ：受到硬件感知神经网络设计思想的启发，基于 RepVGG style[4] 设计了可重参数化、更高效的骨干网络 EfficientRep Backbone 和 Rep-PAN Neck。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;优化设计了更简洁有效的 Efficient Decoupled Head，在维持精度的同时，进一步降低了一般解耦头带来的额外延时开销。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在训练策略上，我们采用 Anchor-free 无锚范式，同时辅以 SimOTA[2] 标签分配策略以及 SIoU[9] 边界框回归损失来进一步提高检测精度。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2.1 Hardware-friendly 的骨干网络设计&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;YOLOv5/YOLOX 使用的 Backbone 和 Neck 都基于 CSPNet[5] 搭建，采用了多分支的方式和残差结构。对于 GPU 等硬件来说，这种结构会一定程度上增加延时，同时减小内存带宽利用率。下图 2 为计算机体系结构领域中的 Roofline Model[8] 介绍图，显示了硬件中计算能力和内存带宽之间的关联关系。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8175925925925925&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9L53gxmhfMqgm8b0BYGfqSOLmSyUHpeAo6LedTuQXhDL0vhqiaqQrsGN8UkQSPPXRnkhicfmjfbdibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;图 2 Roofline Model 介绍图&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;于是，我们基于硬件感知神经网络设计的思想，对 Backbone 和 Neck 进行了重新设计和优化。该思想基于硬件的特性、推理框架 / 编译框架的特点，以硬件和编译友好的结构作为设计原则，在网络构建时，综合考虑硬件计算能力、内存带宽、编译优化特性、网络表征能力等，进而获得又快又好的网络结构。对上述重新设计的两个检测部件，我们在 YOLOv6 中分别称为 EfficientRep Backbone 和 Rep-PAN Neck，其主要贡献点在于：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1. 引入了 RepVGG[4] style 结构。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. 基于硬件感知思想重新设计了 Backbone 和 Neck。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;RepVGG[4] Style 结构是一种在训练时具有多分支拓扑，而在实际部署时可以等效融合为单个 3x3 卷积的一种可重参数化的结构（融合过程如下图 3 所示）。通过融合成的 3x3 卷积结构，可以有效利用计算密集型硬件计算能力（比如 GPU），同时也可获得 GPU/CPU 上已经高度优化的 NVIDIA cuDNN 和 Intel MKL 编译框架的帮助。实验表明，通过上述策略，YOLOv6 减少了在硬件上的延时，并显著提升了算法的精度，让检测网络更快更强。以 nano 尺寸模型为例，对比 YOLOv5-nano 采用的网络结构，本方法在速度上提升了 21%，同时精度提升 3.6% AP。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.9192229038854806&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9L53gxmhfMqgm8b0BYGfqSlz2ia6X8AdBWm4wljwGz82zlzaRUVoOKFDCENg6h6GPAW1GyWpCBSMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;978&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;图 3 Rep 算子的融合过程 [4]&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;EfficientRep Backbone：在 Backbone 设计方面，我们基于以上 Rep 算子设计了一个高效的 Backbone。相比于 YOLOv5 采用的 CSP-Backbone，该 Backbone 能够高效利用硬件（如 GPU）算力的同时，还具有较强的表征能力。下图 4 为 EfficientRep Backbone 具体设计结构图，我们将 Backbone 中 stride=2 的普通 Conv 层替换成了 stride=2 的 RepConv 层。同时，将原始的 CSP-Block 都重新设计为 RepBlock，其中 RepBlock 的第一个 RepConv 会做 channel 维度的变换和对齐。另外，我们还将原始的 SPPF 优化设计为更加高效的 SimSPPF。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8979591836734694&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9L53gxmhfMqgm8b0BYGfqSzrgD90JCSBGn1RKFYl3SN8XMwib8bMlID1JGbc0IFiaY5zLypxcuULSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;784&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;图 4 EfficientRep Backbone 结构图&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Rep-PAN：在 Neck 设计方面，为了让其在硬件上推理更加高效，以达到更好的精度与速度的平衡，我们基于硬件感知神经网络设计思想，为 YOLOv6 设计了一个更有效的特征融合网络结构。Rep-PAN 基于 PAN[6] 拓扑方式，用 RepBlock 替换了 YOLOv5 中使用的 CSP-Block，同时对整体 Neck 中的算子进行了调整，目的是在硬件上达到高效推理的同时，保持较好的多尺度特征融合能力（Rep-PAN 结构图如下图 5 所示）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6638888888888889&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9L53gxmhfMqgm8b0BYGfqSiaXJIaRGxge7BET2JicGubg9OUK1q5w3pQNtSurLWDknbT1zo4mwNSjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;图 5 Rep-PAN 结构图&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2.2 更简洁高效的 Decoupled Head&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在 YOLOv6 中，我们采用了解耦检测头（Decoupled Head）结构，并对其进行了精简设计。原始 YOLOv5 的检测头是通过分类和回归分支融合共享的方式来实现的，而 YOLOX 的检测头则是将分类和回归分支进行解耦，同时新增了两个额外的 3x3 的卷积层，虽然提升了检测精度，但一定程度上增加了网络延时。因此，我们对解耦头进行了精简设计，同时综合考虑到相关算子表征能力和硬件上计算开销这两者的平衡，采用 Hybrid Channels 策略重新设计了一个更高效的解耦头结构，在维持精度的同时降低了延时，缓解了解耦头中 3x3 卷积带来的额外延时开销。通过在 nano 尺寸模型上进行消融实验，对比相同通道数的解耦头结构，精度提升 0.2% AP 的同时，速度提升 6.8%。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.700925925925926&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9L53gxmhfMqgm8b0BYGfqSVCVkibwCicLWqPOUvtoMqIgsjodhDge2H8PWpY4MdZeXNFkLTzbsaFsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;图 6 Efficient Decoupled Head 结构图&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;2.3 更有效的训练策略&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了进一步提升检测精度，我们吸收借鉴了学术界和业界其他检测框架的先进研究进展：Anchor-free 无锚范式 、SimOTA 标签分配策略以及 SIoU 边界框回归损失。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;YOLOv6 采用了更简洁的 Anchor-free 检测方法。由于 Anchor-based 检测器需要在训练之前进行聚类分析以确定最佳 Anchor 集合，这会一定程度提高检测器的复杂度；同时，在一些边缘端的应用中，需要在硬件之间搬运大量检测结果的步骤，也会带来额外的延时。而 Anchor-free 无锚范式因其泛化能力强，解码逻辑更简单，在近几年中应用比较广泛。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;经过对 Anchor-free 的实验调研，我们发现，相较于 Anchor-based 检测器的复杂度而带来的额外延时，Anchor-free 检测器在速度上有 51% 的提升。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了获得更多高质量的正样本，YOLOv6 引入了 SimOTA [4] 算法动态分配正样本，进一步提高检测精度。YOLOv5 的标签分配策略是基于 Shape 匹配，并通过跨网格匹配策略增加正样本数量，从而使得网络快速收敛，但是该方法属于静态分配方法，并不会随着网络训练的过程而调整。近年来，也出现不少基于动态标签分配的方法，此类方法会根据训练过程中的网络输出来分配正样本，从而可以产生更多高质量的正样本，继而又促进网络的正向优化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;例如，OTA[7] 通过将样本匹配建模成最佳传输问题，求得全局信息下的最佳样本匹配策略以提升精度，但 OTA 由于使用了 Sinkhorn-Knopp 算法导致训练时间加长，而 SimOTA[4] 算法使用 Top-K 近似策略来得到样本最佳匹配，大大加快了训练速度。故 YOLOv6 采用了 SimOTA 动态分配策略，并结合无锚范式，在 nano 尺寸模型上平均检测精度提升 1.3% AP。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了进一步提升回归精度，YOLOv6 采用了 SIoU[9] 边界框回归损失函数来监督网络的学习。目标检测网络的训练一般需要至少定义两个损失函数：分类损失和边界框回归损失，而损失函数的定义往往对检测精度以及训练速度产生较大的影响。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;近年来，常用的边界框回归损失包括 IoU、GIoU、CIoU、DIoU loss 等等，这些损失函数通过考虑预测框与目标框之前的重叠程度、中心点距离、纵横比等因素来衡量两者之间的差距，从而指导网络最小化损失以提升回归精度，但是这些方法都没有考虑到预测框与目标框之间方向的匹配性。SIoU 损失函数通过引入了所需回归之间的向量角度，重新定义了距离损失，有效降低了回归的自由度，加快网络收敛，进一步提升了回归精度。通过在 YOLOv6s 上采用 SIoU loss 进行实验，对比 CIoU loss，平均检测精度提升 0.3% AP。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;实验结果&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;经过以上优化策略和改进，YOLOv6 在多个不同尺寸下的模型均取得了卓越的表现。下表 1 展示了 YOLOv6-nano 的消融实验结果，从实验结果可以看出，我们自主设计的检测网络在精度和速度上都带来了很大的增益。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.33796296296296297&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9L53gxmhfMqgm8b0BYGfqSXVgNllO7Zww8EXHjBJHWQoUHm2g6wNcQcPvYRxS59N9CmBeiaOqa5Sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;表 1 YOLOv6-nano 消融实验结果&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下表 2 展示了 YOLOv6 与当前主流的其他 YOLO 系列算法相比较的实验结果。从表格中可以看到：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5425925925925926&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gW9L53gxmhfMqgm8b0BYGfqSyr6mbgxOCSGaF8xkc9000SOPOBR6SWib4l62to7icEzB3d8wo10evuLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;表 2 YOLOv6 各尺寸模型性能与其他模型的比较&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;YOLOv6-nano 在 COCO val 上 取得了 35.0% AP 的精度，同时在 T4 上使用 TRT FP16  batchsize=32 进行推理，可达到 1242FPS 的性能，相较于 YOLOv5-nano 精度提升 7% AP，速度提升 85%。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;YOLOv6-tiny 在 COCO val 上 取得了 41.3% AP 的精度， 同时在 T4 上使用 TRT FP16  batchsize=32 进行推理，可达到 602FPS 的性能，相较于 YOLOv5-s 精度提升 3.9% AP，速度提升 29.4%。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;YOLOv6-s 在 COCO val 上 取得了 43.1% AP 的精度， 同时在 T4 上使用 TRT FP16 batchsize=32 进行推理，可达到 520FPS 的性能，相较于 YOLOX-s 精度提升 2.6% AP，速度提升 38.6%；相较于 PP-YOLOE-s 精度提升 0.4% AP 的条件下，在 T4 上使用 TRT FP16 进行单 batch 推理，速度提升 71.3%。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;总结与展望&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;本文介绍了美团视觉智能部在目标检测框架方面的优化及实践经验，我们针对 YOLO 系列框架，在训练策略、主干网络、多尺度特征融合、检测头等方面进行了思考和优化，设计了新的检测框架 - YOLOv6，初衷来自于解决工业应用落地时所遇到的实际问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在打造 YOLOv6 框架的同时，我们探索和优化了一些新的方法，例如基于硬件感知神经网络设计思想自研了 EfficientRep Backbone、Rep-Neck 和 Efficient Decoupled Head，同时也吸收借鉴了学术界和工业界的一些前沿进展和成果，例如 Anchor-free、SimOTA 和 SIoU 回归损失。在 COCO 数据集上的实验结果显示，YOLOv6 在检测精度和速度方面都属于佼佼者。未来我们会持续建设和完善 YOLOv6 生态，主要工作包括以下几个方面：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1. 完善 YOLOv6 全系列模型，持续提升检测性能。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2. 在多种硬件平台上，设计硬件友好的模型。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3. 支持 ARM 平台部署以及量化蒸馏等全链条适配。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;4. 横向拓展和引入关联技术，如半监督、自监督学习等等。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;5. 探索 YOLOv6 在更多的未知业务场景上的泛化性能。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;同时也欢迎社区同学加入我们，共同建设一个适合工业应用的更快更准的目标检测框架。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;参考文献&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;[1] YOLOv5, https://github.com/ultralytics/yolov5&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;[2] YOLOX: Exceeding YOLO Series in 2021, https://arxiv.org/abs/2107.08430&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;[3] PP-YOLOE: An evolved version of YOLO, https://arxiv.org/abs/2203.16250&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;[4] RepVGG: Making VGG-style ConvNets Great Again, https://arxiv.org/pdf/2101.03697&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;[5] CSPNet: A New Backbone that can Enhance Learning Capability of CNN, https://arxiv.org/abs/1911.11929&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;[6] Path aggregation network for instance segmentation, https://arxiv.org/abs/1803.01534&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;[7] OTA: Optimal Transport Assignment for Object Detection, https://arxiv.org/abs/2103.14259&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;[8] Computer Architecture: A Quantitative Approach&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;[9] SIoU Loss: More Powerful Learning for Bounding Box Regression, https://arxiv.org/abs/2205.12740&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.13515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KmXPKA19gWibOtQXeDEwIroCPqGDVy2RMnQpQrLicFHaJXj97JhbLofkkiad4ciab3b32L6ibvmu0sOsm1cT8unoh7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;br mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;/&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;span mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19.200000762939453&quot;&gt;© THE END &lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;span mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19.200000762939453&quot;&gt;转载请联系本公众号获得授权&lt;/span&gt;&lt;/p&gt;&lt;p mp-original-font-size=&quot;17&quot; mp-original-line-height=&quot;27.200000762939453&quot;&gt;&lt;span mp-original-font-size=&quot;12&quot; mp-original-line-height=&quot;19.200000762939453&quot;&gt;投稿或寻求报道：content@jiqizhixin.com&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>25fadf5c9ea79e808646dda9062568d0</guid>
<title>[推荐] 高并发下如何防重？</title>
<link>https://toutiao.io/k/ulsc0so</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家好，我是苏三，又跟大家见面了。&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;文末留言送书啦！！！&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近测试给我提了一个bug，说我之前提供的一个批量复制商品的接口，产生了重复的商品数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;追查原因之后发现，这个事情没想象中简单，可以说一波多折。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 需求&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产品有个需求：用户选择一些品牌，点击确定按钮之后，系统需要基于一份&lt;code&gt;默认&lt;/code&gt;品牌的商品数据，复制出一批&lt;code&gt;新&lt;/code&gt;的商品。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拿到这个需求时觉得太简单了，三下五除二就搞定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我提供了一个复制商品的基础接口，给商城系统调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当时的流程图如下：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2962382445141066&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74v073cEphxgnuialQdxJ1APTqGmxga34icfB9dD7VVPPq7rjYbYF7Pdyqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1276&quot;/&gt;如果每次复制的商品数量不多，使用同步接口调用的方案问题也不大。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 性能优化&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但由于每次需要复制的商品数量比较多，可能有几千。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果每次都是用同步接口的方式复制商品，可能会有性能问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，后来我把复制商品的逻辑改成使用&lt;code&gt;mq&lt;/code&gt;异步处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;改造之后的流程图：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.25058823529411767&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vGmIG2UQ0ACq9ibuIG9mV02Bjdjtw4ibmE06BJucicvkBTaAgibNuEeLdsA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1700&quot;/&gt;复制商品的结果还需要通知商城系统：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4166666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vfCDzNOsHJ1a6TElFvSNKEEA8B7320Rhm2hje3tib4B8cdGUzMHK94KQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1128&quot;/&gt;这个方案看起来，挺不错的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但后来出现问题了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 出问题了&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试给我们提了一个bug，说我之前提供的一个批量复制商品的接口，产生了重复的商品数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过追查之后发现，商城系统为了性能考虑，也改成异步了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他们没有在接口中直接调用基础系统的复制商品接口，而是在&lt;code&gt;job&lt;/code&gt;中调用的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;站在他们的视角流程图是这样的：&lt;img data-ratio=&quot;0.28144458281444584&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vibicaial4QeBQweXfssQVwcqaMnTPY52iaBOGzRd6GuajlLDmicAsHKq0Pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1606&quot;/&gt;用户调用商城的接口，他们会往&lt;code&gt;请求记录表&lt;/code&gt;中写入一条数据，然后在另外一个&lt;code&gt;job&lt;/code&gt;中，异步调用基础系统的接口去复制商品。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但实际情况是这样的：商城系统内部出现了bug，在请求记录表中，同一条请求产生了重复的数据。这样导致的结果是，在job中调用基础系统复制商品接口时，发送了重复的请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;刚好基础系统现在是使用&lt;code&gt;RocketMQ&lt;/code&gt;异步处理的。由于商城的job一次会取一批数据（比如:20条记录），在极短的时间内（其实就是在一个for循环中）多次调用接口，可能存在相同的请求参数连续调用复制商品接口情况。于是，出现了并发插入重复数据的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么会出现这个问题呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4. 多线程消费&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;RocketMQ&lt;/code&gt;的消费者，为了性能考虑，默认是用多线程并发消费的，最大支持&lt;code&gt;64&lt;/code&gt;个线程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RocketMQMessageListener&lt;/span&gt;(topic = &lt;span&gt;&quot;${com.susan.topic:PRODUCT_TOPIC}&quot;&lt;/span&gt;,&lt;br/&gt;        consumerGroup = &lt;span&gt;&quot;${com.susan.group:PRODUCT_TOPIC_GROUP}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MessageReceiver&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;RocketMQListener&lt;/span&gt;&amp;lt;&lt;span&gt;MessageExt&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onMessage&lt;/span&gt;&lt;span&gt;(MessageExt message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String message = &lt;span&gt;new&lt;/span&gt; String(message.getBody(), StandardCharsets.UTF_8);&lt;br/&gt;        doSamething(message);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，如果在极短的时间内，连续发送重复的消息，就会被不同的线程消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即使在代码中有这样的判断：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Product oldProduct = query(hashCode);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(oldProduct == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;    productMapper.insert(product);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在插入数据之前，先判断该数据是否已经存在，只有不存在才会插入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但由于在并发情况下，不同的线程都判断商品数据不存在，于是同时进行了插入操作，所以就产生了&lt;code&gt;重复数据&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.432601880877743&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vqwIZ9vSeRvxOrn1vhCYibVaGM9Zz9z9sTlu9LrDFUoCROAiaMN4k81Xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;638&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 顺序消费&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决上述并发消费重复消息的问题，我们从两方面着手：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;商城系统修复产生重复记录的bug。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基础系统将消息改成&lt;code&gt;单线程顺序消费&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我仔细思考了一下，如果只靠商城系统修复bug，以后很难避免不出现类似的重复商品问题，比如：如果用户在极短的时间内点击创建商品按钮多次，或者商城系统主动发起重试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，基础系统还需进一步处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实&lt;code&gt;RocketMQ&lt;/code&gt;本身是支持顺序消费的，需要消息的生产者和消费者一起改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生产者改为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;rocketMQTemplate.asyncSendOrderly(topic, message, hashKey, &lt;span&gt;new&lt;/span&gt; SendCallback() {&lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onSuccess&lt;/span&gt;&lt;span&gt;(SendResult sendResult)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;      log.info(&lt;span&gt;&quot;sendMessage success&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onException&lt;/span&gt;&lt;span&gt;(Throwable e)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;      log.error(&lt;span&gt;&quot;sendMessage failed!&quot;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重点是要调用&lt;code&gt;rocketMQTemplate&lt;/code&gt;对象的&lt;code&gt;asyncSendOrderly&lt;/code&gt;方法，发送顺序消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费者改为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@RocketMQMessageListener&lt;/span&gt;(topic = &lt;span&gt;&quot;${com.susan.topic:PRODUCT_TOPIC}&quot;&lt;/span&gt;,&lt;br/&gt;        consumeMode = ConsumeMode.ORDERLY,&lt;br/&gt;        consumerGroup = &lt;span&gt;&quot;${com.susan.group:PRODUCT_TOPIC_GROUP}&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MessageReceiver&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;RocketMQListener&lt;/span&gt;&amp;lt;&lt;span&gt;MessageExt&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onMessage&lt;/span&gt;&lt;span&gt;(MessageExt message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        String message = &lt;span&gt;new&lt;/span&gt; String(message.getBody(), StandardCharsets.UTF_8);&lt;br/&gt;        doSamething(message);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接收消息的重点是&lt;code&gt;RocketMQMessageListener&lt;/code&gt;注解中的&lt;code&gt;consumeMode&lt;/code&gt;参数，要设置成&lt;code&gt;ConsumeMode.ORDERLY&lt;/code&gt;，这样就能顺序消费消息了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;修改后关键流程图如下：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;2.2842105263157895&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vmDcibWsNfwwiag30A8LHM0UIjibtV9tDYv9HFmL6xQuDxNe5MFfxC7kjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;380&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两边都修改之后，复制商品这一块就没有再出现重复商品的问题了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;But，修完bug之后，我又思考了良久。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;复制商品只是创建商品的其中一个入口，如果有其他入口，跟复制商品功能同时创建新商品呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不也会出现重复商品问题？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽说，这种概率非常非常小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果一旦出现重复商品问题，后续涉及到要合并商品的数据，非常麻烦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过这一次的教训，一定要防微杜渐。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管是用户，还是自己的内部系统，从不同的入口创建商品，都需要解决重复商品创建问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何解决这个问题呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 唯一索引&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决重复商品数据问题，最快成本最低最有效的办法是：&lt;code&gt;给表建唯一索引&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想法是好的，但我们这边有个规范就是：&lt;code&gt;业务表必须都是逻辑删除&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而我们都知道，要删除表的某条记录的话，如果用&lt;code&gt;delete&lt;/code&gt;语句操作的话。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;delete&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; product &lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;123&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种delete操作是&lt;code&gt;物理删除&lt;/code&gt;，即该记录被删除之后，后续通过sql语句基本查不出来。（不过通过其他技术手段可以找回，那是后话了）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有另外一种是逻辑删除，主要是通过&lt;code&gt;update&lt;/code&gt;语句操作的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;update&lt;/span&gt; product &lt;span&gt;set&lt;/span&gt; delete_status=&lt;span&gt;1&lt;/span&gt;,edit_time=&lt;span&gt;now&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;) &lt;br/&gt;&lt;span&gt;where&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;123&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;逻辑删除需要在表中额外增加一个&lt;code&gt;删除状态字段&lt;/code&gt;，用于记录数据是否被删除。在所有的业务查询的地方，都需要过滤掉已经删除的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这种方式删除数据之后，数据任然还在表中，只是从逻辑上过滤了删除状态的数据而已。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实对于这种逻辑删除的表，是没法加&lt;code&gt;唯一索引&lt;/code&gt;的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设之前给商品表中的name和model加了唯一索引，如果用户把某条记录删除了，delete_status设置成1了。后来，该用户发现不对，又重新添加了一模一样的商品。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于唯一索引的存在，该用户第二次添加商品会失败，即使该商品已经被删除了，也没法再添加了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题显然有点严重。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有人可能会说：把name、model和delete_status三个字段同时做成唯一索引不就行了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答：这样做确实可以解决用户逻辑删除了某个商品，后来又重新添加相同的商品时，添加不了的问题。但如果第二次添加的商品，又被删除了。该用户第三次添加相同的商品，不也出现问题了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此可见，如果表中有逻辑删除功能，是不方便创建唯一索引的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5. 分布式锁&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，你想到的第二种解决数据重复问题的办法可能是：&lt;code&gt;加分布式锁&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前最常用的性能最高的分布式锁，可能是&lt;code&gt;redis分布式锁&lt;/code&gt;了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用redis分布式锁的伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;  String result = jedis.set(lockKey, requestId, &lt;span&gt;&quot;NX&quot;&lt;/span&gt;, &lt;span&gt;&quot;PX&quot;&lt;/span&gt;, expireTime);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&quot;OK&quot;&lt;/span&gt;.equals(result)) {&lt;br/&gt;      doSamething();&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;} &lt;span&gt;finally&lt;/span&gt; {&lt;br/&gt;    unlock(lockKey,requestId);&lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过需要在&lt;code&gt;finally&lt;/code&gt;代码块中&lt;code&gt;释放锁&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中lockKey是由商品表中的name和model组合而成的，requestId是每次请求的唯一标识，以便于它每次都能正确得释放锁。还需要设置一个过期时间expireTime，防止释放锁失败，锁一直存在，导致后面的请求没法获取锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果只是单个商品，或者少量的商品需要复制添加，则加分布式锁没啥问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要流程如下：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.8079470198675496&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vGcexEIvtOkk5Jfh2JwW8cvMKIibvp3JvHQdQoia82efOcepStGicuTNcQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;604&quot;/&gt;可以在复制添加商品之前，先尝试加锁。如果加锁成功，则在查询商品是否存在，如果不存在，则添加商品。此外，在该流程中如果加锁失败，或者查询商品时不存在，则直接返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加分布式锁的目的是：保证查询商品和添加商品的两个操作是原子性的操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但现在的问题是，我们这次需要复制添加的商品数量很多，如果每添加一个商品都要加分布式锁的话，会非常影响性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然对于批量接口，加redis分布式锁，不是一个理想的方案。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6. 统一mq异步处理&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面我们已经聊过，在批量复制商品的接口，我们是通过RocketMQ的顺序消息，单线程异步复制添加商品的，可以暂时解决商品重复的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但那只改了一个添加商品的入口，还有其他添加商品的入口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;能不能把添加商品的底层逻辑统一一下，最终都调用同一段代码。然后通过RocketMQ的顺序消息，单线程异步添加商品。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要流程如下图所示：&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6787762906309751&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibJZVicC7nz5iaKjv5crmHjKwiakCWXlN74vp4QahsQibEx0YLVVX1xLYMzETZOdC0LNJP9VwkNo5MxANC3moic6ZZ2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1046&quot;/&gt;这样确实能够解决重复商品的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但同时也带来了另外两个问题：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;现在所有的添加商品功能都改成异步了，之前同步添加商品的接口如何返回数据呢？这就需要修改前端交互，否则会影响用户体验。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;之前不同的添加商品入口，是多线程添加商品的，现在改成只能由一个线程添加商品，这样修改的结果导致添加商品的整体效率降低了。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此，综合考虑了一下各方面因素，这个方案最终被否定了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7. insert on duplicate key update&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，在mysql中存在这样的语法，即：&lt;code&gt;insert on duplicate key update&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在添加数据时，mysql发现数据不存在，则直接&lt;code&gt;insert&lt;/code&gt;。如果发现数据已经存在了，则做&lt;code&gt;update&lt;/code&gt;操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过要求表中存在&lt;code&gt;唯一索引&lt;/code&gt;或&lt;code&gt;PRIMARY KEY&lt;/code&gt;，这样当这两个值相同时，才会触发更新操作，否则是插入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在的问题是PRIMARY KEY是商品表的主键，是根据&lt;code&gt;雪花算法&lt;/code&gt;提前生成的，不可能产生重复的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但由于商品表有逻辑删除功能，导致唯一索引在商品表中创建不了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此，insert on duplicate key update这套方案，暂时也没法用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，insert on duplicate key update在高并发的情况下，可能会产生&lt;code&gt;死锁&lt;/code&gt;问题，需要特别注意一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;感兴趣的小伙伴，也可以找我私聊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实insert on duplicate key update的实战，我在另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247490289&amp;amp;idx=1&amp;amp;sn=bc311da9f4a4d3f48ee5dc207bf31a8b&amp;amp;chksm=c0ebc219f79c4b0fc711116723b9df3a5531cda32f0f5d00f065910aa552af6ff03b3f1528fc&amp;amp;token=751314179&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;我用kafka两年踩过的一些非比寻常的坑&lt;/a&gt;》中介绍过的，感兴趣的小伙伴，可以看看。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8. insert ignore&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在mysql中还存在这样的语法，即：&lt;code&gt;insert ... ignore&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在insert语句执行的过程中：mysql发现如果数据重复了，就忽略，否则就会插入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它主要是用来忽略，插入重复数据产生的&lt;code&gt;Duplicate entry &#x27;XXX&#x27; for key &#x27;XXXX&#x27;&lt;/code&gt;异常的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过也要求表中存在&lt;code&gt;唯一索引&lt;/code&gt;或&lt;code&gt;PRIMARY KEY&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但由于商品表有逻辑删除功能，导致唯一索引在商品表中创建不了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此可见，这个方案也不行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;温馨的提醒一下，使用insert ... ignore也有可能会导致&lt;code&gt;死锁&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9. 防重表&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前聊过，因为有逻辑删除功能，给商品表加唯一索引，行不通。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面又说了加分布式锁，或者通过mq单线程异步添加商品，影响创建商品的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何解决问题呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们能否换一种思路，加一张&lt;code&gt;防重表&lt;/code&gt;，在防重表中增加商品表的name和model字段作为唯一索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;`product_unique`&lt;/span&gt; (&lt;br/&gt;  &lt;span&gt;`id`&lt;/span&gt; &lt;span&gt;bigint&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;id&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`name`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;130&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;名称&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`model`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;255&lt;/span&gt;)  &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;规格&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`user_id`&lt;/span&gt; &lt;span&gt;bigint&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;创建用户id&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`user_name`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;30&lt;/span&gt;)  &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;创建用户名称&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`create_date`&lt;/span&gt; datetime(&lt;span&gt;3&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;CURRENT_TIMESTAMP&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;) &lt;span&gt;COMMENT&lt;/span&gt; &lt;span&gt;&#x27;创建时间&#x27;&lt;/span&gt;,&lt;br/&gt;  PRIMARY &lt;span&gt;KEY&lt;/span&gt; (&lt;span&gt;`id`&lt;/span&gt;),&lt;br/&gt;  &lt;span&gt;UNIQUE&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt; &lt;span&gt;`ux_name_model`&lt;/span&gt; (&lt;span&gt;`name`&lt;/span&gt;,&lt;span&gt;`model`&lt;/span&gt;)&lt;br/&gt;) &lt;span&gt;ENGINE&lt;/span&gt;=&lt;span&gt;InnoDB&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;CHARSET&lt;/span&gt;=utf8mb4 &lt;span&gt;COMMENT&lt;/span&gt;=&lt;span&gt;&#x27;商品防重表&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中表中的id可以用商品表的id，表中的name和model就是商品表的name和model，不过在这张防重表中增加了这两个字段的唯一索引。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;视野一下子被打开了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在添加商品数据之前，先添加防重表。如果添加成功，则说明可以正常添加商品，如果添加失败，则说明有重复数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;防重表添加失败，后续的业务处理，要根据实际业务需求而定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果业务上允许添加一批商品时，发现有重复的，直接抛异常，则可以提示用户：系统检测到重复的商品，请刷新页面重试。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;  transactionTemplate.execute((status) -&amp;gt; {&lt;br/&gt;      productUniqueMapper.batchInsert(productUniqueList);&lt;br/&gt;      productMapper.batchInsert(productList);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;  });&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt;(DuplicateKeyException e) {&lt;br/&gt;   &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BusinessException(&lt;span&gt;&quot;系统检测到重复的商品，请刷新页面重试&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在批量插入数据时，如果出现了重复数据，捕获&lt;code&gt;DuplicateKeyException&lt;/code&gt;异常，转换成&lt;code&gt;BusinessException&lt;/code&gt;这样运行时的业务异常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一种业务场景，要求即使出现了重复的商品，也不抛异常，让业务流程也能够正常走下去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;  transactionTemplate.execute((status) -&amp;gt; {&lt;br/&gt;      productUniqueMapper.insert(productUnique);&lt;br/&gt;      productMapper.insert(product);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;  });&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt;(DuplicateKeyException e) {&lt;br/&gt;   product = productMapper.query(product);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在插入数据时，如果出现了重复数据，则捕获&lt;code&gt;DuplicateKeyException&lt;/code&gt;，在&lt;code&gt;catch&lt;/code&gt;代码块中再查询一次商品数据，将数据库已有的商品直接返回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果调用了同步添加商品的接口，这里非常关键的一点，是要返回已有数据的id，业务系统做后续操作，要拿这个id操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然在执行execute之前，还是需要先查一下商品数据是否存在，如果已经存在，则直接返回已有数据，如果不存在，才执行execute方法。这一步千万不能少。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Product oldProduct = productMapper.query(product);&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(Objects.nonNull(oldProduct)) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; oldProduct;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;  transactionTemplate.execute((status) -&amp;gt; {&lt;br/&gt;      productUniqueMapper.insert(productUnique);&lt;br/&gt;      productMapper.insert(product);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; Boolean.TRUE;&lt;br/&gt;  });&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt;(DuplicateKeyException e) {&lt;br/&gt;   product = productMapper.query(product);&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;return&lt;/span&gt; product;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;千万注意：防重表和添加商品的操作必须要在同一个事务中，否则会出问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顺便说一下，还需要对商品的删除功能做特殊处理一下，在逻辑删除商品表的同时，要物理删除防重表。用商品表id作为查询条件即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说实话，解决重复数据问题的方案挺多的，没有最好的方案，只有最适合业务场景的，最优的方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，如果你对重复数据衍生出的幂等性问题感兴趣的话，可以看看我的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&amp;amp;mid=2247490307&amp;amp;idx=1&amp;amp;sn=b9eeb427c33cb171da6c3f11243a88f4&amp;amp;chksm=c0ebc3ebf79c4afd0d5a1851a975534b672d86c531d28c5933013140173e794f5f53e78a6765&amp;amp;token=751314179&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;高并发下如何保证接口的幂等性？&lt;/a&gt;》，里面有非常详细的介绍。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>