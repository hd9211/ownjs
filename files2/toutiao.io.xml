<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b9d8a0b134d8dfb909f44cc16d23a201</guid>
<title>云上共享文件系统的兼容性大比拼</title>
<link>https://toutiao.io/k/cjuez0d</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post_content markdown&quot;&gt;&lt;p&gt;「一切皆文件」是 UNIX 的基本设计哲学。文件按照层级关系组织为树形目录，构成了&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F&quot;&gt;文件系统&lt;/a&gt; 的基本形态。用户使用文件系统来保存数据时，不必关心数据底层的存储方式，便可以按照约定的接口规范进行访问。&lt;/p&gt;&lt;h1 id=&quot;概念篇&quot;&gt;概念篇&lt;/h1&gt;&lt;p&gt;关于文件系统的接口规范，应用最为广泛的莫过于 &lt;a href=&quot;https://zh.wikipedia.org/wiki/POSIX&quot;&gt;POSIX&lt;/a&gt;，源于 IEEE 委员会编写的相关标准，其中有些章节是关于文件及目录操作的。标准本身比较冗长晦涩，在此不作深入探讨。我们可以参考 Quora 上的一个问答 &lt;a href=&quot;https://www.quora.com/What-does-POSIX-conformance-compliance-mean-in-the-distributed-systems-world&quot;&gt;“What does POSIX conformance/compliance mean in the distributed systems world?”&lt;/a&gt; ，对此概括的比较全面。&lt;/p&gt;&lt;p&gt;POSIX 兼容要求文件系统具备以下几项特征：&lt;/p&gt;&lt;blockquote&gt;&lt;ul&gt;&lt;li&gt;层级化的目录结构，支持任意深度&lt;/li&gt;&lt;li&gt;文件通过 &lt;code&gt;open(O_CREAT)&lt;/code&gt;，目录通过 &lt;code&gt;mkdir&lt;/code&gt; 创建等等&lt;/li&gt;&lt;li&gt;目录可以通过 &lt;code&gt;opendir/readdir&lt;/code&gt; 遍历&lt;/li&gt;&lt;li&gt;路径/命名空间可以通过 &lt;code&gt;rename&lt;/code&gt; 、 &lt;code&gt;link&lt;/code&gt; / &lt;code&gt;unlink&lt;/code&gt;、 &lt;code&gt;symlink&lt;/code&gt; / &lt;code&gt;readlink&lt;/code&gt; 等修改&lt;/li&gt;&lt;li&gt;数据通过 &lt;code&gt;write&lt;/code&gt; 或 &lt;code&gt;writev&lt;/code&gt; 写入， &lt;code&gt;fsync&lt;/code&gt; 时要求持久化，通过 &lt;code&gt;read&lt;/code&gt; 或 &lt;code&gt;readv&lt;/code&gt; 读取&lt;/li&gt;&lt;li&gt;其他一些接口如 &lt;code&gt;stat&lt;/code&gt;, &lt;code&gt;chmod&lt;/code&gt; / &lt;code&gt;chown&lt;/code&gt; 等&lt;/li&gt;&lt;li&gt;与某些流行的说法相悖，扩展属性看起来并不是 POSIX 的一部分，参见&lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/&quot;&gt;The Open Group Base Specifications Issue 7, 2018 edition&lt;/a&gt; 里的函数列表&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;h1 id=&quot;测试篇&quot;&gt;测试篇&lt;/h1&gt;&lt;p&gt;一个文件系统是否真正满足 POSIX 兼容性，我们可以通过测试工具来检验。比较流行的一个测试用例集是 &lt;a href=&quot;https://github.com/pjd/pjdfstest&quot;&gt;pjdfstest&lt;/a&gt;，来源于 FreeBSD，也适用于 Linux 等系统。pjdfstest 的测试用例需要以 root 身份来运行，并且要求系统里安装了 Perl 和 TAP::Harness（Perl 软件包），测试过程如下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;cd /path/to/filesystem/under/test
sudo prove --recurse --verbose /path/to/pjdfstest/tests
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们选取了几种云环境中的共享文件系统进行测试，统计测试结果中的失败用例如下：&lt;/p&gt;&lt;p&gt;因为 Amazon EFS 失败的测试用例相比其他产品大了几个数量级，为了方便比较，上图的横坐标使用了对数坐标。&lt;/p&gt;&lt;p&gt;我们还同时测试了 &lt;a href=&quot;https://github.com/s3fs-fuse/s3fs-fuse&quot;&gt;S3FS&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/kahing/goofys&quot;&gt;Goofys&lt;/a&gt;，失败的用例数均为数百项乃至上千项，其根本原因是这两个项目并不是严格按照文件系统来设计的：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Goofys&lt;/strong&gt; 可以将 S3 挂载为文件系统，但仅仅是 “POSIX-ish” 接口的 “Filey” 系统（这两个描述来自于官方项目介绍，翻译成中文即“似是而非”或“貌合神离”）。Goofys 在设计理念上为了性能而牺牲了 POSIX 兼容性，所支持的文件操作极大地受限于 S3 等对象存储本身。测试结果也验证了这一点。建议在生产使用之前全面评审应用的数据访问方式，以免落入陷阱。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;S3FS&lt;/strong&gt; 尽管名为文件系统，但实际上更接近于用&lt;strong&gt;文件系统视图&lt;/strong&gt;管理 S3 bucket 中对象的一种方法。尽管 S3FS 支持了 POSIX 的一个较大子集，但只是将系统调用一一映射为对象存储请求，并不支持常规文件系统的语义及一致性（例如目录的原子重命名，独占模式打开时的互斥，附加文件内容会导致重写整个文件以及不支持硬连接等等）。这些缺陷导致 S3FS 并不能用于替代常规文件系统（即便不考虑性能问题），因为当应用访问文件系统时，预期的行为应该是符合 POSIX 规范的，而 S3FS 远远不能满足这一点。&lt;/li&gt;&lt;/ul&gt;&lt;h1 id=&quot;分析篇&quot;&gt;分析篇&lt;/h1&gt;&lt;p&gt;下面我们将测试的失败用例进行分类统计，挑选几类比较有代表性的来分析下会对应用造成何种限制。&lt;/p&gt;&lt;p&gt;总的来说，无论从数量还是类别来看，JuiceFS 的失败用例都更少，有更好的兼容性。Amazon EFS 的失败用例无论从总数及类别均大大超出其它几种文件系统，无法放入同一图表对比，后面将单独分析。&lt;/p&gt;&lt;h2 id=&quot;juicefs&quot;&gt;JuiceFS&lt;/h2&gt;&lt;p&gt;JuiceFS 在本次测试中通过了8811项用例中的绝大多数，仅在 utimensat 测试集上失败了 3 项。对应日志如下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;…
/root/pjdfstest/tests/utimensat/08.t ........
not ok 5 - tried &#x27;lstat pjdfstest_bfaee1fc7f2c1f80768e30f203f41627 atime_ns&#x27;, expected 100000000, got 0
not ok 6 - tried &#x27;lstat pjdfstest_bfaee1fc7f2c1f80768e30f203f41627 mtime_ns&#x27;, expected 200000000, got 0
Failed 2/9 subtests
/root/pjdfstest/tests/utimensat/09.t ........
not ok 5 - tried &#x27;lstat pjdfstest_7911595d91adcf915009f551ac48e1f2 mtime&#x27;, expected 4294967296, got 0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这几个测试用例出自&lt;a href=&quot;https://github.com/pjd/pjdfstest/blob/master/tests/utimensat/08.t&quot;&gt;utimensat/08.t&lt;/a&gt;和&lt;a href=&quot;https://github.com/pjd/pjdfstest/blob/master/tests/utimensat/09.t&quot;&gt;utimensat/09.t&lt;/a&gt;。其中 08.t 是测试亚秒级的文件访问时间和修改时间精度，09.t 则是要求支持64位时间戳。&lt;/p&gt;&lt;p&gt;JuiceFS 目前只支持秒，时间戳保存为32位整数，故无法通过这三个测试（实际上本次测试涉及的所有文件系统都无法100%通过这个测试集）。如果您的应用场景要求秒以下的时间精度或者更大范围，欢迎联系我们商讨解决方案。&lt;/p&gt;&lt;h2 id=&quot;gcp-filestore&quot;&gt;GCP Filestore&lt;/h2&gt;&lt;p&gt;除了和 JuiceFS 一样在 utimesat 测试集上存在若干失败结果之外，GCP Filestore 还在 unlink 测试集中失败了 1 项。这一项在其他所有文件系统中也都是失败的。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;/root/pjdfstest/tests/unlink/14.t ...........
not ok 4 - tried &#x27;open pjdfstest_b03f52249a0c653a3f382dfe1237caa1 O_RDONLY : unlink pjdfstest_b03f52249a0c653a3f382dfe1237caa1 : fstat 0 nlink&#x27;, expected 0, got 1
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该测试集（&lt;a href=&quot;https://github.com/pjd/pjdfstest/blob/master/tests/unlink/14.t&quot;&gt;unlink/14.t&lt;/a&gt;）用于验证一个文件在打开状态下被删除时的行为：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;desc=&quot;An open file will not be immediately freed by unlink&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;删除文件的操作在系统层面实际对应于 unlink，即移除该文件名到对应 inode 的链接，对应 nlink 的值减 1，这个测试用例就是要验证这一点。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# A deleted file&#x27;s link count should be 0
expect 0 open ${n0} O_RDONLY : unlink ${n0} : fstat 0 nlink
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;文件内容只有在链接数（nlink）减少至 0 并且没有打开的文件描述符（fd）指向该文件时才会被真正删除。如果 nlink 没有被正确更新，可能会导致本该删除的文件仍然残留在系统里。&lt;/p&gt;&lt;h2 id=&quot;腾讯云-cfs&quot;&gt;腾讯云 CFS&lt;/h2&gt;&lt;p&gt;腾讯云 CFS 相比 Google Filestore，还未能通过 open 和 symlink 的几项测试。&lt;/p&gt;&lt;h3 id=&quot;open-失败用例&quot;&gt;open 失败用例&lt;/h3&gt;&lt;p&gt;选取其中一部分失败日志如下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;/root/pjdfstest/tests/open/07.t .............
not ok 5 - tried &#x27;-u 65534 -g 65534 open pjdfstest_f24a42815d59c16a4bde54e6559d0390 O_RDONLY,O_TRUNC&#x27;, expected EACCES, got 0
not ok 7 - tried &#x27;-u 65533 -g 65534 open pjdfstest_f24a42815d59c16a4bde54e6559d0390 O_RDONLY,O_TRUNC&#x27;, expected EACCES, got 0
not ok 9 - tried &#x27;-u 65533 -g 65533 open pjdfstest_f24a42815d59c16a4bde54e6559d0390 O_RDONLY,O_TRUNC&#x27;, expected EACCES, got 0
Failed 3/23 subtests
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此测试集 &lt;a href=&quot;https://github.com/pjd/pjdfstest/blob/master/tests/open/07.t&quot;&gt;open/07.t&lt;/a&gt; 用于验证不具备写权限时，应该对 O_TRUNC 模式返回 EACCES 错误这一行为。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;desc=&quot;open returns EACCES when O_TRUNC is specified and write permission is denied&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面这三个失败日志需要结合测试代码来分析，分别对应 owner，group 和 other 三种情况。不失一般性，我们仅就 owner 情况进行分析 ：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;expect 0 -u 65534 -g 65534 chmod ${n1} 0477
expect EACCES -u 65534 -g 65534 open ${n1} O_RDONLY,O_TRUNC
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;首先设置文件 owner 权限为 4，即 &lt;code&gt;r--&lt;/code&gt; 只读，然后尝试以 O_RDONLY,O_TRUNC 模式打开文件，预期应该返回 EACCES，实际返回了 0。&lt;/p&gt;&lt;p&gt;根据 &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/007908799/xsh/open.html&quot;&gt;The Single UNIX ® Specification, Version 2&lt;/a&gt; 中对 O_TRUNC 的说明&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;O_TRUNC
If the file exists and is a regular file, and the file is successfully opened O_RDWR or O_WRONLY, its length is truncated to 0 and the mode and owner are unchanged. It will have no effect on FIFO special files or terminal device files. Its effect on other file types is implementation-dependent. The result of using O_TRUNC with O_RDONLY is undefined.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;O_TRUNC 与 O_RDONLY 组合使用的结果是未知的，而且此用例的被测文件本身就是空文件，O_TRUNC 不会产生任何效果。&lt;/p&gt;&lt;h3 id=&quot;symlink-失败用例&quot;&gt;symlink 失败用例&lt;/h3&gt;&lt;p&gt;对应测试日志如下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;/root/pjdfstest/tests/symlink/03.t ..........
not ok 1 - tried &#x27;symlink 7ea12171c487d234bef89d9d77ac8dc2929ea8ce264150140f02a77fc6dcad7c3b2b36b5ed19666f8b57ad861861c69cb63a7b23bcc58ad68e132a94c0939d5/.../... pjdfstest_57517a47d0388e0c84fa1915bf11fe4a&#x27;, expected 0, got EINVAL
not ok 2 - tried &#x27;unlink pjdfstest_57517a47d0388e0c84fa1915bf11fe4a&#x27;, expected 0, got ENOENT
Failed 2/6 subtests
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该测试集（&lt;a href=&quot;https://github.com/pjd/pjdfstest/blob/master/tests/symlink/03.t&quot;&gt;symlink/03.t&lt;/a&gt;）用于测试路径超出 PATH_MAX 长度时 symblink 的行为&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;desc=&quot;symlink returns ENAMETOOLONG if an entire length of either path name exceeded {PATH_MAX} characters&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;失败的用例对应代码如下：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;n0=`namegen`
nx=`dirgen_max`
nxx=&quot;${nx}x&quot;

mkdir -p &quot;${nx%/*}&quot;
expect 0 symlink ${nx} ${n0}
expect 0 unlink ${n0}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该测试用例是要创建长度为 PATH_MAX (包括结尾的0在内）的符号链接，通不过表明无法在 腾讯云 NAS 上创建长度为 PATH_MAX 的符号链接。&lt;/p&gt;&lt;h2 id=&quot;阿里云-nas&quot;&gt;阿里云 NAS&lt;/h2&gt;&lt;p&gt;相比腾讯云 NAS，阿里云 NAS 在 symlink 上表现正常，但未能通过 chmod 和 rename 上的几项测试用例。&lt;/p&gt;&lt;h3 id=&quot;chmod-失败用例&quot;&gt;chmod 失败用例&lt;/h3&gt;&lt;p&gt;在这个测试集中，阿里云 NAS 失败了以下几个项目&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;/root/pjdfstest/tests/chmod/12.t ............
not ok 3 - tried &#x27;-u 65534 -g 65534 open pjdfstest_db85e6a66130518db172a8b6ce6d53da O_WRONLY : write 0 x : fstat 0 mode&#x27;, expected 0777, got 04777
not ok 4 - tried &#x27;stat pjdfstest_db85e6a66130518db172a8b6ce6d53da mode&#x27;, expected 0777, got 04777
not ok 7 - tried &#x27;-u 65534 -g 65534 open pjdfstest_db85e6a66130518db172a8b6ce6d53da O_RDWR : write 0 x : fstat 0 mode&#x27;, expected 0777, got 02777
not ok 8 - tried &#x27;stat pjdfstest_db85e6a66130518db172a8b6ce6d53da mode&#x27;, expected 0777, got 02777
not ok 11 - tried &#x27;-u 65534 -g 65534 open pjdfstest_db85e6a66130518db172a8b6ce6d53da O_RDWR : write 0 x : fstat 0 mode&#x27;, expected 0777, got 06777
not ok 12 - tried &#x27;stat pjdfstest_db85e6a66130518db172a8b6ce6d53da mode&#x27;, expected 0777, got 06777
Failed 6/14 subtests
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;该测试集（&lt;a href=&quot;https://github.com/pjd/pjdfstest/blob/master/tests/chmod/12.t&quot;&gt;chmod/12.t&lt;/a&gt;）用于测试 SUID/SGID 位的行为&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;desc=&quot;verify SUID/SGID bit behaviour&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们选取其中的第11和12个测试用例来详细解释一下，同时覆盖了这两个权限位&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;# Check whether writing to the file by non-owner clears the SUID+SGID.
expect 0 create ${n0} 06777
expect 0777 -u 65534 -g 65534 open ${n0} O_RDWR : write 0 x : fstat 0 mode
expect 0777 stat ${n0} mode
expect 0 unlink ${n0}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此处，我们先以 06777 的权限创建目标文件，然后修改文件内容，检查 SUID 和 SGID 是否被正确清除。文件权限里的 777 大家会比较熟悉，分别对应 owner，group和 other 的 rwx，即可读、可写、可执行。最前面的 0 表示八进制数。&lt;/p&gt;&lt;p&gt;第二位 6 需要着重解释下，这个八位元组（octet）代表特殊权限位，其中前两位分别对应 setuid/setgid（或称 SUID/SGID），可以应用于可执行文件及公共目录。该权限位被设置时，任何用户都会以 owner （或 group）身份来运行该文件。这个特殊的属性允许用户获取通常只对 owner 开放的文件和目录访问权限。例如 passwd 命令就设置了 setuid 权限，这允许普通用户修改密码，因为保存密码的文件是只允许 root 访问的，用户不可直接修改。&lt;/p&gt;&lt;p&gt;setuid/setgid 设计的出发点是提供一种方法，让用户以限定的方式（指定可执行文件）访问受限文件（非当前用户所有）。因此，当文件被非 owner 修改时应自动清除此权限位，以避免用户通过这个途径获取其他权限。&lt;/p&gt;&lt;p&gt;从测试结果中我们可以看到在阿里云 NAS 中，&lt;strong&gt;文件被非 owner 修改时，setuid/setgid 均未被清除，这样实际上用户可以通过修改文件内容以该 owner 身份进行任意操作，这将会是个安全隐患。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;参考阅读： &lt;a href=&quot;https://docs.oracle.com/cd/E19683-01/816-4883/secfile-69/index.html&quot;&gt;Special File Permissions (setuid, setgid and Sticky Bit) (System Administration Guide: Security Services)&lt;/a&gt;&lt;/p&gt;&lt;h3 id=&quot;rename-失败用例&quot;&gt;rename 失败用例&lt;/h3&gt;&lt;p&gt;阿里云 NAS 在这个测试集上失败数量较多，达到了 24 项，全部出现在 &lt;a href=&quot;https://github.com/pjd/pjdfstest/blob/master/tests/rename/09.t&quot;&gt;rename/09.t&lt;/a&gt; 中：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;desc=&quot;rename returns EACCES or EPERM if the directory containing &#x27;from&#x27; is marked sticky, and neither the containing directory nor &#x27;from&#x27; are owned by the effective user ID&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个测试集用于检验 sticky 位被设置时 rename 的行为：当包含源对象的目录设置了 sticky 权限位的时候，并且源对象和包含目录的 owner 都与有效用户ID（effective user ID）不同时，rename 应该返回 EACCES 或 EPERM。（这样的复杂逻辑令人联想到三国杀的武将技能设定……）。&lt;/p&gt;&lt;p&gt;sticky 位的典型应用是 /tmp 目录，允许所有人创建内容，但是只有 owner 才能删除文件。FTP 里面的公共上传目录通常也是这种设置。&lt;/p&gt;&lt;p&gt;几个失败的测试用例表明阿里云 NAS 对 sticky 位的支持还不够完善，非 owner 的 rename 操作没有被拒绝，并且产生了实际的效果——源文件被重命名。这种行为越过了文件系统的访问控制，对用户文件的安全性造成了威胁。&lt;/p&gt;&lt;h2 id=&quot;amazon-efs-中的失败用例&quot;&gt;Amazon EFS 中的失败用例&lt;/h2&gt;&lt;p&gt;Amazon Elastic File System (EFS) 在 pjdfstest 测试中的不仅失败比例极高（8811个测试用例失败了1533个），而且几乎覆盖了所有类别，这比较令人意外。&lt;/p&gt;&lt;p&gt;EFS 支持以 NFS 方式挂载，但对 NFS 特性的支持并不完整。比如EFS 不支持块设备和字符设备，这直接导致了 pjdfstest 中大量测试用例的失败。排除这两类文件之后，仍然有上百项不同类别的失败，所以在复杂场景中应用 EFS 必须慎之又慎。&lt;/p&gt;&lt;h1 id=&quot;总结篇&quot;&gt;总结篇&lt;/h1&gt;&lt;p&gt;通过上面的对比分析，JuiceFS 在兼容性方面表现最好，像大多数网络文件系统一样，为了性能牺牲了秒以下的时间精度和范围（1970 - 2106 年）。Google Filestore 和腾讯云 CFS 次之，有几类未能通过。而阿里云 NAS 和 Amazon EFS 的兼容性最差，有大量的兼容性测试通不过，其中包括有严重安全隐患的若干个测试用例，使用前建议做安全性评估。&lt;/p&gt;&lt;p&gt;JuiceFS 一直非常重视对 POSIX 标准的高度兼容，我们把 pjdfstest 等兼容性测试工具同其他随机和并发测试工具（比如 &lt;a href=&quot;https://github.com/billziss-gh/secfs.test/tree/master/fsracer&quot;&gt;fsracer&lt;/a&gt;、&lt;a href=&quot;https://github.com/billziss-gh/secfs.test/tree/master/fstools&quot;&gt;fstool&lt;/a&gt; 等）一起作为集成测试工具，在持续完善功能、提高性能的同时，尽力保持最大程度的 POSIX 兼容性，避免用户在使用过程中落入各种陷阱，从而更加专注于自身业务的发展。人生苦短，我用 JuiceFS！&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9372c50c10782b107c1fb72364698da1</guid>
<title>一文掌握go语言的泛型</title>
<link>https://toutiao.io/k/3fdrlea</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article&gt;
&lt;header&gt;
&lt;p&gt;&lt;i class=&quot;fa-regular fa-calendar&quot;/&gt; &lt;span class=&quot;app-item-time&quot;&gt;2022年2月12日&lt;/span&gt;
&lt;/p&gt;&lt;h1 class=&quot;center-text article-title&quot;&gt;Go 泛型初步&lt;/h1&gt;&lt;/header&gt;&lt;p&gt;
&lt;h4 class=&quot;text-center&quot;&gt;&lt;strong&gt;摘  要&lt;/strong&gt;&lt;/h4&gt;&lt;span&gt;Go 1.18 版本之后正式引入泛型，它被称作类型参数（type parameters），本文初步介绍 Go 中泛型的使用。&lt;/span&gt;
&lt;/p&gt;&lt;p&gt;
&lt;strong&gt;关键词: &lt;/strong&gt;
&lt;code class=&quot;keyword&quot;&gt;go&lt;/code&gt;
&lt;code class=&quot;keyword&quot;&gt;泛型&lt;/code&gt;
&lt;code class=&quot;keyword&quot;&gt;类型参数&lt;/code&gt;
&lt;/p&gt;&lt;aside data-toc-type=&quot;float-right&quot;&gt;
&lt;span&gt;目录&lt;/span&gt;
&lt;nav id=&quot;TableOfContents&quot;&gt;
&lt;/nav&gt;&lt;/aside&gt;&lt;h2 id=&quot;1-go-的泛型&quot;&gt;1. Go 的泛型&lt;/h2&gt;&lt;p&gt;长期以来 go 都没有泛型的概念，只有接口 &lt;code&gt;interface&lt;/code&gt; 偶尔类似的充当泛型的作用，然而接口终究无法满足一些基本的泛型需求，比如&lt;/p&gt;&lt;p&gt;(1). 函数体内需要对参数做运算而不是使用接口方法，如下的写法连编译都不可行。&lt;/p&gt;&lt;div class=&quot;highlight&quot; code=&quot;+b&quot;&gt;&lt;pre tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// Sum 函数尝试对输入的任意多个参数求和。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// 然而 interface{} 不可以做加法，这段代码是不能编译的
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Sum&lt;/span&gt;(&lt;span&gt;values&lt;/span&gt; &lt;span&gt;...&lt;/span&gt;&lt;span&gt;interface&lt;/span&gt;{}) &lt;span&gt;interface&lt;/span&gt;{} {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;sum&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;{}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;_&lt;/span&gt;, &lt;span&gt;v&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt; &lt;span&gt;values&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;sum&lt;/span&gt; &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;v&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;sum&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;(2). 使用接口常常存在极其令人厌恶的接口转换，一个例子是标准库 &lt;code&gt;container/heap&lt;/code&gt;。&lt;code&gt;Pop&lt;/code&gt; 方法返回值几乎总是需要在逻辑上再转换为 &lt;code&gt;Push&lt;/code&gt; 时传入的类型，这使得代码不仅丑陋而且低效（曾经因为 interface{} 实际是 int 类型，但是因为类型转换导致大量的内存分配次数）&lt;/p&gt;&lt;div class=&quot;highlight&quot; code=&quot;-&quot;&gt;&lt;pre tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// Push pushes the element x onto the heap.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// The complexity is O(log n) where n = h.Len().
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Push&lt;/span&gt;(&lt;span&gt;h&lt;/span&gt; &lt;span&gt;Interface&lt;/span&gt;, &lt;span&gt;x&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;{}) {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// Pop removes and returns the minimum element (according to Less) from the heap.
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// The complexity is O(log n) where n = h.Len().
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// Pop is equivalent to Remove(h, 0).
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Pop&lt;/span&gt;(&lt;span&gt;h&lt;/span&gt; &lt;span&gt;Interface&lt;/span&gt;) &lt;span&gt;interface&lt;/span&gt;{} {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因为没有泛型而带来的其他问题就不一一列举，相信许多开发者都有遇到需要泛型的场景。从 go 1.18 版本开始，将正式引入泛型，官方称谓叫做类型参数 &lt;code&gt;type parameter&lt;/code&gt;，由于各种原因，现阶段的泛型比起一些流行语言中的泛型功能上还是差很多，不过总比没有好了。目前泛型主要使用的方式有两类：&lt;code&gt;函数&lt;/code&gt;的类型参数，&lt;code&gt;类型&lt;/code&gt;的类型参数。&lt;/p&gt;&lt;h2 id=&quot;2-安装-go-118-以上的版本&quot;&gt;2. 安装 go 1.18 以上的版本&lt;/h2&gt;&lt;p&gt;在 go1.18 尚未正式发布时可以通过如下命令安装 beta 版本体验&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;&lt;span&gt;&lt;span&gt;go install golang.org/dl/go1.18beta2@latest
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;go1.18beta2 download
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;此后可以使用 &lt;code&gt;go1.18beta2&lt;/code&gt; 命令取代原来的 go 命令编译支持泛型的代码。&lt;/p&gt;&lt;h2 id=&quot;3-函数类型参数&quot;&gt;3. 函数类型参数&lt;/h2&gt;&lt;h3 id=&quot;31-泛型版本的求和函数&quot;&gt;3.1. 泛型版本的求和函数&lt;/h3&gt;&lt;p&gt;仍以求和函数为例，泛型版本的写法如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot; code=&quot;sum&quot;&gt;&lt;pre tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;import&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&quot;golang.org/x/exp/constraints&quot;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Sum&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt; &lt;span&gt;constraints&lt;/span&gt;.&lt;span&gt;Integer&lt;/span&gt;](&lt;span&gt;values&lt;/span&gt; &lt;span&gt;...&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;) &lt;span&gt;T&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;sum&lt;/span&gt; &lt;span&gt;T&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;_&lt;/span&gt;, &lt;span&gt;v&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt; &lt;span&gt;values&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;sum&lt;/span&gt; &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;v&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;sum&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;constraints 原本是放在标准库的包，但是近期被移除了，改到了 x/exp 中，参见 &lt;a href=&quot;https://github.com/golang/go/issues/50792&quot; target=&quot;_blank&quot;&gt;#50792&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;这个版本实现了对任意多个同类型的整数求和。&lt;code&gt;Sum&lt;/code&gt; 后面的中括号 &lt;code&gt;[]&lt;/code&gt; 内就是定义类型参数的地方，其中 &lt;code&gt;T&lt;/code&gt; 为类型参数名，&lt;code&gt;constraints.Integer&lt;/code&gt; 是对该类型参数的约束，即 T 应该满足的条件，在这里我们要求 &lt;code&gt;T&lt;/code&gt; 是一个整数。剩下的代码就和普通没有泛型的代码一致了，只不过后面 T 可以当作一个类型来使用。标准库 &lt;code&gt;constraints&lt;/code&gt; 中预定义了一些基本的约束，另外还有两个特殊的内置类型可用作约束：&lt;code&gt;any&lt;/code&gt; 和 &lt;code&gt;comparable&lt;/code&gt;，其中 &lt;code&gt;any&lt;/code&gt; 就是原来的 &lt;code&gt;interface{}&lt;/code&gt;，在 go1.18 开始所有空 interface{} 都改成 any 了，而 &lt;code&gt;comparable&lt;/code&gt; 则表示类型是可以通过 &lt;code&gt;==&lt;/code&gt; 运算符进行比较的。&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;go 的泛型参数为什么不使用其他流行语言的 &lt;code&gt;&amp;lt; &amp;gt;&lt;/code&gt; 定义泛型？这个主要是会引起语法上的歧义，比如下面这一段代码&lt;/p&gt;&lt;p&gt;x, y := a &amp;lt; b, c &amp;gt; d&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;现在可以来使用一下刚才定义的 &lt;code&gt;Sum&lt;/code&gt; 方法：&lt;/p&gt;&lt;div class=&quot;highlight&quot; code=&quot;sum+x&quot;&gt;&lt;pre tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;Sum&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;ints&lt;/span&gt; = []&lt;span&gt;int&lt;/span&gt;{&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;Sum&lt;/span&gt;(&lt;span&gt;ints&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;int32s&lt;/span&gt; = []&lt;span&gt;int32&lt;/span&gt;{&lt;span&gt;-&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;Sum&lt;/span&gt;(&lt;span&gt;int32s&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;uint32s&lt;/span&gt; = []&lt;span&gt;uint32&lt;/span&gt;{&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;Sum&lt;/span&gt;(&lt;span&gt;uint32s&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// 调用 Sum 函数时也可以将类型参数带上，只是经常都能够通过实际参数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;// 类型推断类型参数，所以常常省略
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;Sum&lt;/span&gt;[&lt;span&gt;uint32&lt;/span&gt;](&lt;span&gt;uint32s&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个版本仍有一些问题，比如可以做加法的不止整数啊，还有浮点数，甚至是复数。修改类型参数 &lt;code&gt;T&lt;/code&gt; 的约束来支持浮点数和复数：&lt;/p&gt;&lt;div class=&quot;highlight&quot; code=&quot;sum2+x&quot;&gt;&lt;pre tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;import&lt;/span&gt; (
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&quot;golang.org/x/exp/constraints&quot;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Sum&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt; &lt;span&gt;constraints&lt;/span&gt;.&lt;span&gt;Integer&lt;/span&gt; | &lt;span&gt;constraints&lt;/span&gt;.&lt;span&gt;Float&lt;/span&gt; | &lt;span&gt;constraints&lt;/span&gt;.&lt;span&gt;Complex&lt;/span&gt;](&lt;span&gt;values&lt;/span&gt; &lt;span&gt;...&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;) &lt;span&gt;T&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;sum&lt;/span&gt; &lt;span&gt;T&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;_&lt;/span&gt;, &lt;span&gt;v&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt; &lt;span&gt;values&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;sum&lt;/span&gt; &lt;span&gt;+=&lt;/span&gt; &lt;span&gt;v&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;sum&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;Sum&lt;/span&gt;(&lt;span&gt;1.0&lt;/span&gt;, &lt;span&gt;2.0&lt;/span&gt;, &lt;span&gt;3.5&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通过符号 &lt;code&gt;|&lt;/code&gt; 连接多个约束表示 &lt;code&gt;T&lt;/code&gt; 只需满足其中任意一个。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Sum&lt;/code&gt; 函数的例子只用了一个类型参数，go 的类型参数也支持多个，这个定义和函数参数的格式类似。&lt;/p&gt;&lt;div class=&quot;highlight&quot; code=&quot;-&quot;&gt;&lt;pre tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;FuncA&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt;, &lt;span&gt;U&lt;/span&gt; &lt;span&gt;any&lt;/span&gt;]() {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;FuncB&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt; &lt;span&gt;any&lt;/span&gt;, &lt;span&gt;U&lt;/span&gt;, &lt;span&gt;V&lt;/span&gt; &lt;span&gt;comparable&lt;/span&gt;]() {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来通过几个简单的例子熟练一下泛型函数的使用。&lt;/p&gt;&lt;h3 id=&quot;32-使用泛型实现一个类似脚本语言比如-javascript的或运算&quot;&gt;3.2. 使用泛型实现一个类似脚本语言（比如 javascript）的或运算&lt;/h3&gt;&lt;p&gt;这个例子用于判定 &lt;code&gt;a&lt;/code&gt; 是否为 zero 值，如果是则返回 &lt;code&gt;b&lt;/code&gt;，反之返回 &lt;code&gt;a&lt;/code&gt;。&lt;/p&gt;&lt;div class=&quot;highlight&quot; code=&quot;$+x&quot;&gt;&lt;pre tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Or&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt; &lt;span&gt;comparable&lt;/span&gt;](&lt;span&gt;a&lt;/span&gt;, &lt;span&gt;b&lt;/span&gt; &lt;span&gt;T&lt;/span&gt;) &lt;span&gt;T&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;zero&lt;/span&gt; &lt;span&gt;T&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;a&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;zero&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;b&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;doSomething&lt;/span&gt;(&lt;span&gt;x&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;y&lt;/span&gt;, &lt;span&gt;z&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;Or&lt;/span&gt;(&lt;span&gt;x&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;Or&lt;/span&gt;(&lt;span&gt;y&lt;/span&gt;, &lt;span&gt;&quot;default&quot;&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;Or&lt;/span&gt;(&lt;span&gt;z&lt;/span&gt;, &lt;span&gt;createString&lt;/span&gt;()))
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;createString&lt;/span&gt;() &lt;span&gt;string&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;hello&quot;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;doSomething&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;doSomething&lt;/span&gt;(&lt;span&gt;12&lt;/span&gt;, &lt;span&gt;&quot;y&quot;&lt;/span&gt;, &lt;span&gt;&quot;z&quot;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;不过不同于一般的或运算，这里 &lt;code&gt;Or(a, b)&lt;/code&gt; 时 b 的值已经确定，如果 b 是一个函数调用，那么当 a 不是 zero 值时，b 的函数调用完全浪费了。&lt;/p&gt;&lt;blockquote&gt;
&lt;p&gt;javascript 中的 &lt;code&gt;a || b()&lt;/code&gt; 不同于此处的 &lt;code&gt;Or(a, b())&lt;/code&gt;，前者在 a 非空时不会调用函数 b&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;可以再实现一个延迟函数调用的版本 &lt;code&gt;OrNew&lt;/code&gt; 处理这种情况：&lt;/p&gt;&lt;div class=&quot;highlight&quot; code=&quot;$+x&quot;&gt;&lt;pre tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Or&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt; &lt;span&gt;comparable&lt;/span&gt;](&lt;span&gt;a&lt;/span&gt;, &lt;span&gt;b&lt;/span&gt; &lt;span&gt;T&lt;/span&gt;) &lt;span&gt;T&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;zero&lt;/span&gt; &lt;span&gt;T&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;a&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;zero&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;b&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;OrNew&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt; &lt;span&gt;comparable&lt;/span&gt;](&lt;span&gt;a&lt;/span&gt; &lt;span&gt;T&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;()&lt;span&gt;T&lt;/span&gt;) &lt;span&gt;T&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;zero&lt;/span&gt; &lt;span&gt;T&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;a&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;zero&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; new()
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;doSomething&lt;/span&gt;(&lt;span&gt;x&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;, &lt;span&gt;y&lt;/span&gt;, &lt;span&gt;z&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;Or&lt;/span&gt;(&lt;span&gt;x&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;Or&lt;/span&gt;(&lt;span&gt;y&lt;/span&gt;, &lt;span&gt;&quot;default&quot;&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;OrNew&lt;/span&gt;(&lt;span&gt;z&lt;/span&gt;, &lt;span&gt;createString&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;createString&lt;/span&gt;() &lt;span&gt;string&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;hello&quot;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;doSomething&lt;/span&gt;(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&quot;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;doSomething&lt;/span&gt;(&lt;span&gt;12&lt;/span&gt;, &lt;span&gt;&quot;y&quot;&lt;/span&gt;, &lt;span&gt;&quot;z&quot;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&quot;33-使用泛型实现三元条件运算&quot;&gt;3.3. 使用泛型实现三元条件运算&lt;/h3&gt;&lt;p&gt;go 语言不存在三元条件运算符 &lt;code&gt;&amp;lt;condition&amp;gt;? value1 : value2&lt;/code&gt;，导致经常存在需要这种场景时只好用 &lt;code&gt;if&lt;/code&gt; 写好几行的代码，不过现在可以通过泛型实现一个条件运算了。&lt;/p&gt;&lt;div class=&quot;highlight&quot; code=&quot;$+x&quot;&gt;&lt;pre tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;If&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt; &lt;span&gt;any&lt;/span&gt;](&lt;span&gt;yes&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;, &lt;span&gt;a&lt;/span&gt;, &lt;span&gt;b&lt;/span&gt; &lt;span&gt;T&lt;/span&gt;) &lt;span&gt;T&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;yes&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;b&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;IfNew&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt; &lt;span&gt;any&lt;/span&gt;](&lt;span&gt;yes&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;, &lt;span&gt;a&lt;/span&gt;, &lt;span&gt;b&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;() &lt;span&gt;T&lt;/span&gt;) &lt;span&gt;T&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;yes&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;a&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;b&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;createA&lt;/span&gt;() &lt;span&gt;string&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;a&quot;&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;createB&lt;/span&gt;() &lt;span&gt;string&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;b&quot;&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;a&lt;/span&gt; = &lt;span&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;b&lt;/span&gt; = &lt;span&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;If&lt;/span&gt;(&lt;span&gt;a&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;IfNew&lt;/span&gt;(&lt;span&gt;b&lt;/span&gt;, &lt;span&gt;createA&lt;/span&gt;, &lt;span&gt;createB&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&quot;4-类型泛型&quot;&gt;4. 类型泛型&lt;/h2&gt;&lt;h3 id=&quot;41-类型泛型的基本使用方法&quot;&gt;4.1. 类型泛型的基本使用方法&lt;/h3&gt;&lt;p&gt;以一个 c++ 的 &lt;code&gt;std::pair&lt;/code&gt; 为例，来说明 go 的类型泛型的使用。&lt;code&gt;pair&lt;/code&gt; 包含 first 和 second 两个成员，并且每一个都有独立的类型，所以我们需要两个类型参数，先看代码：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Pair&lt;/span&gt;[&lt;span&gt;T1&lt;/span&gt;, &lt;span&gt;T2&lt;/span&gt; &lt;span&gt;any&lt;/span&gt;] &lt;span&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;First&lt;/span&gt;  &lt;span&gt;T1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Second&lt;/span&gt; &lt;span&gt;T2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;MakePair&lt;/span&gt;[&lt;span&gt;T1&lt;/span&gt;, &lt;span&gt;T2&lt;/span&gt; &lt;span&gt;any&lt;/span&gt;](&lt;span&gt;first&lt;/span&gt; &lt;span&gt;T1&lt;/span&gt;, &lt;span&gt;second&lt;/span&gt; &lt;span&gt;T2&lt;/span&gt;) &lt;span&gt;Pair&lt;/span&gt;[&lt;span&gt;T1&lt;/span&gt;, &lt;span&gt;T2&lt;/span&gt;] {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;Pair&lt;/span&gt;[&lt;span&gt;T1&lt;/span&gt;, &lt;span&gt;T2&lt;/span&gt;]{&lt;span&gt;First&lt;/span&gt;: &lt;span&gt;first&lt;/span&gt;, &lt;span&gt;Second&lt;/span&gt;: &lt;span&gt;second&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;pair&lt;/span&gt; &lt;span&gt;Pair&lt;/span&gt;[&lt;span&gt;T1&lt;/span&gt;, &lt;span&gt;T2&lt;/span&gt;]) &lt;span&gt;Elements&lt;/span&gt;() (&lt;span&gt;T1&lt;/span&gt;, &lt;span&gt;T2&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;pair&lt;/span&gt;.&lt;span&gt;First&lt;/span&gt;, &lt;span&gt;pair&lt;/span&gt;.&lt;span&gt;Second&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在定义 Pair 时在类型名称之后使用 &lt;code&gt;[T1, T2 any]&lt;/code&gt; 定义了类型参数，即 T1, T2 都可以是任意类型。&lt;/p&gt;&lt;p&gt;然后定义了泛型函数 &lt;code&gt;MakePair&lt;/code&gt; 用于创建 Pair 对象，函数的返回值类型为 &lt;code&gt;Pair[T1, T2]&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;最后实现了 Pair 的成员方法 &lt;code&gt;Elements&lt;/code&gt; 返回两个成员值，这个函数看起来很无聊，似乎没什么用，就是用来展示如何定义泛型类型的成员方法。和一般的类型的成员方法的定义的区别在于类型 Pair 之后必须要使用声明 Pair 类型时定义的类型参数（就是这里的 &lt;code&gt;[T1, T2]&lt;/code&gt;）。&lt;/p&gt;&lt;p&gt;另外 go 的泛型目前不支持给成员方法声明新的类型参数，比如这种成员方法的定义就不允许：&lt;/p&gt;&lt;div class=&quot;highlight&quot; code=&quot;+b&quot;&gt;&lt;pre tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// Bad: 成员方法后面不能声明类型参数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;pair&lt;/span&gt; &lt;span&gt;Pair&lt;/span&gt;[&lt;span&gt;T1&lt;/span&gt;, &lt;span&gt;T2&lt;/span&gt;]) &lt;span&gt;Something&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt; &lt;span&gt;any&lt;/span&gt;]() {}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;除了 &lt;code&gt;struct&lt;/code&gt; 之外，interface 的定义也支持类型参数（但是它的接口方法不支持类型参数），但是 &lt;code&gt;type alias&lt;/code&gt; 不支持类型参数&lt;/p&gt;&lt;div class=&quot;highlight&quot; code=&quot;-&quot;&gt;&lt;pre tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Interface&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt; &lt;span&gt;any&lt;/span&gt;] &lt;span&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// 自己定义的接口 User 可用作类型参数的约束
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;InterfaceTwo&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt; &lt;span&gt;any&lt;/span&gt;, &lt;span&gt;U&lt;/span&gt; &lt;span&gt;User&lt;/span&gt;] &lt;span&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;IntPair&lt;/span&gt; &lt;span&gt;Pair&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Slice&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt; &lt;span&gt;any&lt;/span&gt;] []&lt;span&gt;T&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// Bad: 这个不允许
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Vector&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt; &lt;span&gt;any&lt;/span&gt;] = []&lt;span&gt;T&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;类型约束除了内置的 &lt;code&gt;any&lt;/code&gt;, &lt;code&gt;comparable&lt;/code&gt; 以及 &lt;code&gt;golang.org/x/exp/constraints&lt;/code&gt; 中定义的之外，也可以使用自己定义的任意接口用作约束，就像上例中的 &lt;code&gt;User&lt;/code&gt;。另外现在除了以前概念中的 interface 定义之外，还有一种纯粹只能用于类型参数约束的 interface。像这类使用了基础类型或者 &lt;code&gt;|&lt;/code&gt; 运算的接口。&lt;/p&gt;&lt;div class=&quot;highlight&quot; code=&quot;-&quot;&gt;&lt;pre tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// 实数约束 Real 只能用于类型参数约束，而不能作为普通参数或变量类型。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Real&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;constraints&lt;/span&gt;.&lt;span&gt;Integer&lt;/span&gt; | &lt;span&gt;constraints&lt;/span&gt;.&lt;span&gt;Float&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// Number 包含一个只能用于约束的接口，所以也只能用于类型参数的约束了
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Number&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Real&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Cat&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Float&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;~&lt;/span&gt;&lt;span&gt;float32&lt;/span&gt; | &lt;span&gt;~&lt;/span&gt;&lt;span&gt;float64&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;~&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;PureString&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// Name 满足 String 约束，但是不满足 PureString
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Name&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;go 1.18 开始引入一个新的符号 &lt;code&gt;~&lt;/code&gt; 用于约束前缀，这表示该约束包含 underlying 为该类型的参数。比如上面的 &lt;code&gt;Name&lt;/code&gt; 类型的 underlying 是 string，所以 &lt;code&gt;Name&lt;/code&gt; 也满足 &lt;code&gt;String&lt;/code&gt; 约束，但是不满足 &lt;code&gt;PureString&lt;/code&gt; 约束。&lt;/p&gt;&lt;h3 id=&quot;42-实现一个通用的事件系统&quot;&gt;4.2. 实现一个通用的事件系统&lt;/h3&gt;&lt;p&gt;有了类型泛型可以实现一个比较实用的功能：事件派发系统。&lt;/p&gt;&lt;p&gt;首先我们需要定义一个事件接口：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// Event 是一个事件接口，类型参数 T 表示事件类别的数据类型，比如可以使用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//string
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//int
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//reflect.Type
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;//
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// 该接口定义 Type 方法获取事件类别
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Event&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt; &lt;span&gt;comparable&lt;/span&gt;] &lt;span&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Type&lt;/span&gt;() &lt;span&gt;T&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;然后定一个事件处理接口 &lt;code&gt;Listener&lt;/code&gt;，同时为了使用方便实现一个内置的 listener&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// Listener 接口用于处理被触发的事件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Listener&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt; &lt;span&gt;comparable&lt;/span&gt;] &lt;span&gt;interface&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;EventType&lt;/span&gt;() &lt;span&gt;T&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Handle&lt;/span&gt;(&lt;span&gt;Event&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// Listen 创建一个 Listener 对象
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Listen&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt; &lt;span&gt;comparable&lt;/span&gt;, &lt;span&gt;E&lt;/span&gt; &lt;span&gt;Event&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt;]](&lt;span&gt;eventType&lt;/span&gt; &lt;span&gt;T&lt;/span&gt;, &lt;span&gt;handler&lt;/span&gt; &lt;span&gt;func&lt;/span&gt;(&lt;span&gt;E&lt;/span&gt;)) &lt;span&gt;Listener&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt;] {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;listenerFunc&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt;, &lt;span&gt;E&lt;/span&gt;]{&lt;span&gt;eventType&lt;/span&gt;, &lt;span&gt;handler&lt;/span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;listenerFunc&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt; &lt;span&gt;comparable&lt;/span&gt;, &lt;span&gt;E&lt;/span&gt; &lt;span&gt;Event&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt;]] &lt;span&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;eventType&lt;/span&gt; &lt;span&gt;T&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;handler&lt;/span&gt;   &lt;span&gt;func&lt;/span&gt;(&lt;span&gt;E&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;h&lt;/span&gt; &lt;span&gt;listenerFunc&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt;, &lt;span&gt;E&lt;/span&gt;]) &lt;span&gt;EventType&lt;/span&gt;() &lt;span&gt;T&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;h&lt;/span&gt;.&lt;span&gt;eventType&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;h&lt;/span&gt; &lt;span&gt;listenerFunc&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt;, &lt;span&gt;E&lt;/span&gt;]) &lt;span&gt;Handle&lt;/span&gt;(&lt;span&gt;event&lt;/span&gt; &lt;span&gt;Event&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt;]) {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;e&lt;/span&gt;, &lt;span&gt;ok&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;.(&lt;span&gt;E&lt;/span&gt;); &lt;span&gt;ok&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;h&lt;/span&gt;.&lt;span&gt;handler&lt;/span&gt;(&lt;span&gt;e&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;} &lt;span&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;panic(&lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Sprintf&lt;/span&gt;(&lt;span&gt;&quot;unexpected event %T for type %v&quot;&lt;/span&gt;, &lt;span&gt;event&lt;/span&gt;, &lt;span&gt;event&lt;/span&gt;.&lt;span&gt;Type&lt;/span&gt;()))
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面这段代码需要特别说明一下 &lt;code&gt;Listen&lt;/code&gt; 函数，该函数有 2 个类型参数 &lt;code&gt;T&lt;/code&gt; 和 &lt;code&gt;E&lt;/code&gt;，前者是事件类别的类型参数，后者是事件类型参数，而 &lt;code&gt;E&lt;/code&gt; 的约束 &lt;code&gt;Event[T]&lt;/code&gt; 中依赖了前一个泛型参数，这样一来事件处理函数 &lt;code&gt;handler&lt;/code&gt; 的参数就不再是 &lt;code&gt;Event&lt;/code&gt; 接口而是一个泛型参数了，这避免了每次在回调函数中进行一次类型转换（因为已经统一在 listenerFunc.Handle 中转换了）。比如以前经常是这样写回调函数&lt;/p&gt;&lt;div class=&quot;highlight&quot; code=&quot;-&quot;&gt;&lt;pre tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;onSomething&lt;/span&gt;(&lt;span&gt;event&lt;/span&gt; &lt;span&gt;Event&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;somethingEvent&lt;/span&gt;, &lt;span&gt;ok&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;event&lt;/span&gt;.(&lt;span&gt;*&lt;/span&gt;&lt;span&gt;SomethingEvent&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; !&lt;span&gt;ok&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;errors&lt;/span&gt;.&lt;span&gt;New&lt;/span&gt;(&lt;span&gt;&quot;unexpected event type&quot;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// doSomething with somethingEvent
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而现在回调函数就可以避免每次手动转换类型了&lt;/p&gt;&lt;div class=&quot;highlight&quot; code=&quot;-&quot;&gt;&lt;pre tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;onSomething&lt;/span&gt;(&lt;span&gt;event&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;SomethingEvent&lt;/span&gt;) &lt;span&gt;error&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// doSomething with event
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;接下来实现事件派发管理器 &lt;code&gt;Dispatcher&lt;/code&gt;。&lt;code&gt;Dispatcher&lt;/code&gt; 需要实现事件注册(Add)，删除(Remove)，检查(Has)和派发(Dispatch) 方法。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// Dispatcher 管理事件注册与派发
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;Dispatcher&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt; &lt;span&gt;comparable&lt;/span&gt;] &lt;span&gt;struct&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;nextid&lt;/span&gt;    &lt;span&gt;int&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;listeners&lt;/span&gt; &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt;][]&lt;span&gt;Pair&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;Listener&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt;]]
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;mapping&lt;/span&gt;   &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;Pair&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// AddEventListener 注册事件回调
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;dispatcher&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Dispatcher&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt;]) &lt;span&gt;AddEventListener&lt;/span&gt;(&lt;span&gt;listener&lt;/span&gt; &lt;span&gt;Listener&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt;]) &lt;span&gt;int&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;dispatcher&lt;/span&gt;.&lt;span&gt;listeners&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;dispatcher&lt;/span&gt;.&lt;span&gt;listeners&lt;/span&gt; = make(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt;][]&lt;span&gt;Pair&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;Listener&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt;]])
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;dispatcher&lt;/span&gt;.&lt;span&gt;mapping&lt;/span&gt; = make(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;Pair&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt;, &lt;span&gt;int&lt;/span&gt;])
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;dispatcher&lt;/span&gt;.&lt;span&gt;nextid&lt;/span&gt;&lt;span&gt;++&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;id&lt;/span&gt; = &lt;span&gt;dispatcher&lt;/span&gt;.&lt;span&gt;nextid&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;eventType&lt;/span&gt; = &lt;span&gt;listener&lt;/span&gt;.&lt;span&gt;EventType&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;listeners&lt;/span&gt; = &lt;span&gt;dispatcher&lt;/span&gt;.&lt;span&gt;listeners&lt;/span&gt;[&lt;span&gt;eventType&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; = len(&lt;span&gt;listeners&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;dispatcher&lt;/span&gt;.&lt;span&gt;listeners&lt;/span&gt;[&lt;span&gt;eventType&lt;/span&gt;] = append(&lt;span&gt;listeners&lt;/span&gt;, &lt;span&gt;MakePair&lt;/span&gt;(&lt;span&gt;id&lt;/span&gt;, &lt;span&gt;listener&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;dispatcher&lt;/span&gt;.&lt;span&gt;mapping&lt;/span&gt;[&lt;span&gt;id&lt;/span&gt;] = &lt;span&gt;MakePair&lt;/span&gt;(&lt;span&gt;eventType&lt;/span&gt;, &lt;span&gt;index&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// HasEventListener 判定是否存在事件回调
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;dispatcher&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Dispatcher&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt;]) &lt;span&gt;HasEventListener&lt;/span&gt;(&lt;span&gt;id&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;) &lt;span&gt;bool&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;dispatcher&lt;/span&gt;.&lt;span&gt;mapping&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;_&lt;/span&gt;, &lt;span&gt;ok&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;dispatcher&lt;/span&gt;.&lt;span&gt;mapping&lt;/span&gt;[&lt;span&gt;id&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;ok&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// RemoveEventListener 删除事件回调
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;dispatcher&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Dispatcher&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt;]) &lt;span&gt;RemoveEventListener&lt;/span&gt;(&lt;span&gt;id&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;) &lt;span&gt;bool&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;dispatcher&lt;/span&gt;.&lt;span&gt;listeners&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;index&lt;/span&gt;, &lt;span&gt;ok&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;dispatcher&lt;/span&gt;.&lt;span&gt;mapping&lt;/span&gt;[&lt;span&gt;id&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; !&lt;span&gt;ok&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;eventType&lt;/span&gt; = &lt;span&gt;index&lt;/span&gt;.&lt;span&gt;First&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;listeners&lt;/span&gt; = &lt;span&gt;dispatcher&lt;/span&gt;.&lt;span&gt;listeners&lt;/span&gt;[&lt;span&gt;eventType&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;last&lt;/span&gt; = len(&lt;span&gt;listeners&lt;/span&gt;) &lt;span&gt;-&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;index&lt;/span&gt;.&lt;span&gt;Second&lt;/span&gt; &lt;span&gt;!=&lt;/span&gt; &lt;span&gt;last&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;listeners&lt;/span&gt;[&lt;span&gt;index&lt;/span&gt;.&lt;span&gt;Second&lt;/span&gt;] = &lt;span&gt;listeners&lt;/span&gt;[&lt;span&gt;last&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;newId&lt;/span&gt; = &lt;span&gt;listeners&lt;/span&gt;[&lt;span&gt;index&lt;/span&gt;.&lt;span&gt;Second&lt;/span&gt;].&lt;span&gt;First&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;dispatcher&lt;/span&gt;.&lt;span&gt;mapping&lt;/span&gt;[&lt;span&gt;newId&lt;/span&gt;] = &lt;span&gt;MakePair&lt;/span&gt;(&lt;span&gt;eventType&lt;/span&gt;, &lt;span&gt;index&lt;/span&gt;.&lt;span&gt;Second&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;listeners&lt;/span&gt;[&lt;span&gt;last&lt;/span&gt;].&lt;span&gt;Second&lt;/span&gt; = &lt;span&gt;nil&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;dispatcher&lt;/span&gt;.&lt;span&gt;listeners&lt;/span&gt;[&lt;span&gt;eventType&lt;/span&gt;] = &lt;span&gt;listeners&lt;/span&gt;[:&lt;span&gt;last&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;delete(&lt;span&gt;dispatcher&lt;/span&gt;.&lt;span&gt;mapping&lt;/span&gt;, &lt;span&gt;id&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// DispatchEvent 派发事件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;dispatcher&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;Dispatcher&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt;]) &lt;span&gt;DispatchEvent&lt;/span&gt;(&lt;span&gt;event&lt;/span&gt; &lt;span&gt;Event&lt;/span&gt;[&lt;span&gt;T&lt;/span&gt;]) &lt;span&gt;bool&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;dispatcher&lt;/span&gt;.&lt;span&gt;listeners&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;listeners&lt;/span&gt;, &lt;span&gt;ok&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;dispatcher&lt;/span&gt;.&lt;span&gt;listeners&lt;/span&gt;[&lt;span&gt;event&lt;/span&gt;.&lt;span&gt;Type&lt;/span&gt;()]
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt; !&lt;span&gt;ok&lt;/span&gt; &lt;span&gt;||&lt;/span&gt; len(&lt;span&gt;listeners&lt;/span&gt;) &lt;span&gt;==&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;for&lt;/span&gt; &lt;span&gt;i&lt;/span&gt; &lt;span&gt;:=&lt;/span&gt; &lt;span&gt;range&lt;/span&gt; &lt;span&gt;listeners&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;listeners&lt;/span&gt;[&lt;span&gt;i&lt;/span&gt;].&lt;span&gt;Second&lt;/span&gt;.&lt;span&gt;Handle&lt;/span&gt;(&lt;span&gt;event&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;至此，一个基本的事件系统就完成了，接下来看看如何使用。&lt;/p&gt;&lt;div class=&quot;highlight&quot; code=&quot;+x&quot;&gt;&lt;pre tabindex=&quot;0&quot;&gt;&lt;code class=&quot;language-go&quot; data-lang=&quot;go&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// 这个例子中事件的 Type 使用 string 类型
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;testEventA&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; {}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;type&lt;/span&gt; &lt;span&gt;testEventB&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt; {}
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;testEventA&lt;/span&gt;) &lt;span&gt;Type&lt;/span&gt;() &lt;span&gt;string&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;A&quot;&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; (&lt;span&gt;testEventB&lt;/span&gt;) &lt;span&gt;Type&lt;/span&gt;() &lt;span&gt;string&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;B&quot;&lt;/span&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;dispatcher&lt;/span&gt; &lt;span&gt;Dispatcher&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// 注册事件，listener 通过 Listen 方法构建
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;dispatcher&lt;/span&gt;.&lt;span&gt;AddEventListener&lt;/span&gt;(&lt;span&gt;Listen&lt;/span&gt;(&lt;span&gt;&quot;A&quot;&lt;/span&gt;, &lt;span&gt;func&lt;/span&gt;(&lt;span&gt;e&lt;/span&gt; &lt;span&gt;testEventA&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;&quot;test event &#x27;A&#x27; fired&quot;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}))
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;dispatcher&lt;/span&gt;.&lt;span&gt;AddEventListener&lt;/span&gt;(&lt;span&gt;Listen&lt;/span&gt;(&lt;span&gt;&quot;B&quot;&lt;/span&gt;, &lt;span&gt;func&lt;/span&gt;(&lt;span&gt;e&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;testEventB&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;fmt&lt;/span&gt;.&lt;span&gt;Println&lt;/span&gt;(&lt;span&gt;&quot;test event &#x27;B&#x27; fired&quot;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}))
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// 派发事件，注意由于通过 Listen 注册的时候回调函数的参数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;// 没有使用指针，所以这里派发事件时也不能用 testEvent 的指针。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;// 这两者的类型必须要一致
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;dispatcher&lt;/span&gt;.&lt;span&gt;DispatchEvent&lt;/span&gt;(&lt;span&gt;testEventA&lt;/span&gt;{})
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;// 事件 B 的类型就需要指针了，因为注册时使用了指针。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span/&gt;&lt;span&gt;dispatcher&lt;/span&gt;.&lt;span&gt;DispatchEvent&lt;/span&gt;(new(&lt;span&gt;testEventB&lt;/span&gt;))
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;除了这个例子中的使用 string 作为事件类别的类型外，还可以使用整数，reflect.Type 或其他任意可比较的类型。&lt;/p&gt;&lt;p&gt;事件系统的完整代码可参见 &lt;a href=&quot;https://github.com/gopherd/doge/blob/main/event/event.go&quot; target=&quot;_blank&quot;&gt;github.com/gopherd/doge/blob/main/event/event.go&lt;/a&gt;&lt;/p&gt;&lt;h2 id=&quot;5-结语&quot;&gt;5. 结语&lt;/h2&gt;&lt;p&gt;总体来说，go 的泛型功能还是较少的，使用限制较多。另外 go 1.18 版本的泛型存在一个严重的性能问题：范型参数存在不必要的内存逃逸，而且执行速度低下，在 go 1.19 的 Milestone 中已经有提交来修正这个问题了（&lt;a href=&quot;https://github.com/golang/go/issues/50182&quot; target=&quot;_blank&quot;&gt;#50182&lt;/a&gt;）。然而内存逃逸的问题修复了，性能却仍然比非范型的版本差。&lt;/p&gt;&lt;p&gt;目前建议只在满足以下条件之一的时候使用范型：&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;普通基础类型用作类型参数约束&lt;/li&gt;&lt;li&gt;参数类型约束没有成员方被调用&lt;/li&gt;&lt;li&gt;对性能没有极致要求&lt;/li&gt;&lt;/ul&gt;&lt;br/&gt;
&lt;/article&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cb0a51d8ebddc6b71980236f4745b12e</guid>
<title>「码农周刊 VIP 会员专属邮件周报」每周五发送，赶紧上车吧！</title>
<link>https://toutiao.io/k/vlohxda</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;明天周五啦！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第 082 期「码农周刊 VIP 会员专属邮件周报」，将于本周五晚发送。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数位上市公司 CTO 都在订阅，你还等什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;img class=&quot;rich_pages js_insertlocalimg wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;255&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;255&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ4LlicrXjOxMtaQDWoib2X24FnCibVaaZDqGa6VhDuw5a6cJtG8eg35xVuS75hozib0Z3Kib07lhzJsTSA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;274&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;码农周刊是什么？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;span&gt;码农周刊VIP会员&lt;/span&gt;」服务。&lt;br/&gt;&lt;strong&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;如何加入「码农周刊VIP会员」？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;391&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;425&quot; data-ratio=&quot;1.3478260869565217&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ6elqZKJKdKVMrGKUKjLwPpIFaDmrXyf1iaRtelGc6Fm6W4vp1uEAbb7Nz7QuBzxXNW96CiauDAL3Aw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;心动不如心动，赶快订阅吧！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1e9b3b05d6906c81131608099e5ffbaf</guid>
<title>微服务从代码到k8s部署应有尽有系列全集</title>
<link>https://toutiao.io/k/dcd3fuh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们用一个系列来讲解从需求到上线、从代码到k8s部署、从日志到监控等各个方面的微服务完整实践。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个项目使用了go-zero开发的微服务，基本包含了go-zero以及相关go-zero作者开发的一些中间件，所用到的技术栈基本是go-zero项目组的自研组件，基本是go-zero全家桶了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UyIojWicPOg0ZKAF1ZPmceo2iccqkuibkmN5ty7DznTjgXGYiaHDOY3baLZx5OlHkcy6KmBdXuYdf1tiafPWcJMiaeaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实战项目地址：https://github.com/Mikaelemmmm/go-zero-looklook&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;知乎文章列表：&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;系统介绍：https://zhuanlan.zhihu.com/p/464544668&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;网关：https://zhuanlan.zhihu.com/p/464810481&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;鉴权：https://zhuanlan.zhihu.com/p/465690784&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户中心：https://zhuanlan.zhihu.com/p/465720564&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;民宿服务：https://zhuanlan.zhihu.com/p/466923244&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;订单服务：https://zhuanlan.zhihu.com/p/467200888&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;支付服务：https://zhuanlan.zhihu.com/p/467805751&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;各种队列：https://zhuanlan.zhihu.com/p/468061200&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事务精讲：https://zhuanlan.zhihu.com/p/468513367&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;错误处理：https://zhuanlan.zhihu.com/p/468992801&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日志收集：https://zhuanlan.zhihu.com/p/470472858&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;链路追踪：https://zhuanlan.zhihu.com/p/470686081&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务监控：https://zhuanlan.zhihu.com/p/471273291&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;部署环境：https://zhuanlan.zhihu.com/p/471742493&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;k8s部署：https://zhuanlan.zhihu.com/p/472182788&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;更多实践系列&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了帮助大家更好的掌握微服务开发和 go-zero 的相关知识，我们后续会推出更多的微服务实践相关系列文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时也热烈欢迎广大 go-zero 用户投稿本公众号，文章的推广也会给文章作者带来人气、同时也可以帮助项目的推广，一般经过本公众号审核通过并推广的项目会有几百 stars。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;项目地址&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/zeromicro/go-zero&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欢迎使用 &lt;code&gt;go-zero&lt;/code&gt; 并 &lt;strong&gt;star&lt;/strong&gt; 支持我们！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;我的知乎&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关注我的知乎，所有「微服务实践」公众号的文章勘误都在这里。&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot; aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_title&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p role=&quot;option&quot; aria-labelledby=&quot;js_a11y_reward_qr_word js_a11y_comma js_a11y_reward_qr_title js_a11y_reward_qr_money&quot; aria-describedby=&quot;js_a11y_reward_qr_tips &quot; class=&quot;reward_tips&quot; id=&quot;js_a11y_reward_qr_word&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img alt=&quot;赞赏二维码&quot; class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p aria-hidden=&quot;true&quot; id=&quot;js_a11y_reward_qr_tips&quot; class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f5edc878010ec50bac740a76a51f05b9</guid>
<title>前端架构破局 -  NodeJS 落地 WebSocket</title>
<link>https://toutiao.io/k/eoi703i</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文从网络协议，技术背景，安全和生产应用的方向，详细介绍 WebSocket 在 Node.js 中的落地实践。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;大纲预览&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文介绍的内容包括以下方面：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;网络协议进化&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Socket.IO？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ws 模块实现&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Express 集成&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;WebSocket 实例&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息广播&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;安全与认证&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;BFF 应用&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;网络协议进化&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 协议是前端最熟悉的网络通信协议。我们通常的打开网页，请求接口，都属于 HTTP 请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 请求的特点是：&lt;code&gt;请求-&amp;gt; 响应&lt;/code&gt;。客户端发起请求，服务端收到请求后进行响应，一次请求就完成了。也就是说，HTTP 请求必须由客户端发起，服务端才能被动响应。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，发起 HTTP 请求之前，还需要通过三次握手建立 TCP 连接。HTTP/1.0 的特点是，每通信一次，都要经历 “三步走” 的过程 —— &lt;code&gt;TCP 连接 -&amp;gt; HTTP 通信 -&amp;gt; 断开 TCP 连接&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的每一次请求都是独立的，一次请求完成连接就会断开。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP1.1 对请求过程做了优化。TCP 连接建立之后，我们可以进行多次 HTTP 通信，等到一个时间段无 HTTP 请求发起 TCP 才会断开连接，这就是 HTTP/1.1 带来的&lt;strong&gt;长连接&lt;/strong&gt;技术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是即便如此，通信方式依然是客户端发起，服务端响应，这个根本逻辑不会变。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着应用交互的复杂，我们发现，有一些场景是必须要实时获取服务端消息的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如即时聊天，比如消息推送，用户并不会主动发起请求，但是当服务器有了新消息，客户端需要立刻知道并且反馈给用户。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 不支持服务端主动推送，但是这些场景又急需解决方案，于是早期出现了&lt;strong&gt;轮询&lt;/strong&gt;（polling）。轮询是客户端定时向服务器发起请求，检测服务端是否有更新，如果有则返回新数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种轮询方式虽然简单粗暴，但很显然有两个弊端：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;请求消耗太大&lt;/strong&gt;。客户端不断请求，浪费流量和服务器资源，给服务器造成压力。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;不能保证及时&lt;/strong&gt;。客户端需要平衡及时性和性能，请求间隔必然不能太小，因此会有延迟。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着 HTML5 推出 &lt;code&gt;WebSocket&lt;/code&gt;，即时通讯场景终于迎来了根本解决方案。&lt;code&gt;WebSocket&lt;/code&gt; 是全双工通信协议，当客户端与服务端建立连接之后，双方可以互相发送数据，这样的话就不需要客户端通过轮询这种低效的方式获取数据，服务端有新消息直接推送给客户端即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;传统 HTTP 连接方式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&lt;span&gt;# 普通连接&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;http://localhost:80/test&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&lt;span&gt;# 安全连接&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;https://localhost:80/test&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;WebSocket 是另一种协议，连接方式如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&lt;span&gt;# 普通连接&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;ws://localhost:80/test&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&lt;span&gt;# 安全连接&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;wss://localhost:80/test&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是 WebSocket 也不是完全脱离 HTTP 的，若要建立 WebSocket 连接，则必须要客户端主动发起一个建立连接的 HTTP 请求，连接成功之后客户端与服务端才能进行双向通信。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Socket.IO？&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提起用 Node.js 实现 WebSocket，大家一定会想到一个库：Socket.IO&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，Socket.IO 是目前 Node.js 在生产环境中开发 WebSocket 应用最好的选择。它功能强大，高性能，低延迟，并且可以一步集成到 &lt;code&gt;express&lt;/code&gt; 框架中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是也许你不清楚，Socket.IO 并不是一个纯粹的 WebSocket 框架。它是将 Websocket 和轮询机制以及其它的实时通信方式封装成了通用的接口，以实现更高效的双向通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;严格来说，Websocket 只是 Socket.IO 的一部分。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也许你会问：既然 Socket.IO 在 WebSocket 的基础上做了那么多的优化，并且非常成熟，那为什么还要搭一个原生 WebSocket 服务？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，Socket.IO 不能通过原生的 &lt;code&gt;ws&lt;/code&gt; 协议连接。比如你在浏览器试图通过 &lt;code&gt;ws://localhost:8080/test-socket&lt;/code&gt; 这种方式连接 Socket.IO 服务，是连接不上的。因为 Socket.IO 的服务端必须通过 Socket.IO 的客户端连接，不支持默认的 WebSocket 方式连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其次，Socket.IO 封装程度非常高，使用它可能不利于你了解 WebSocket 建立连接的原理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，我们本篇就用 Node.js 中基础的 &lt;code&gt;ws&lt;/code&gt; 模块，从头开始实现一个原生的 WebSocket 服务，并且在前端用 ws 协议直接连接，体验一把双向通信的感觉！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ws 模块实现&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;ws&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; 是 Node.js 下一个简单快速，并且定制程度极高的 WebSocket 实现方案，同时包含了服务端和客户端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用 &lt;code&gt;ws&lt;/code&gt; 搭建起来的服务端，浏览器可以通过原生 &lt;code&gt;WebSocket&lt;/code&gt; 构造函数直接连接，非常便捷。ws 客户端则是模拟浏览器的 WebSocket 构造函数，用于连接其他 WebSocket 服务器进行通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意一点：&lt;code&gt;ws&lt;/code&gt; 只能在 Node.js 环境中使用，浏览器中不可用，&lt;strong&gt;浏览器请直接使用原生 WebSocket 构造函数&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面开始接入，第一步，安装 ws：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ npm install ws&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;安装好后，我们先搭建一个 ws 服务端。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务端&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;搭建 websocket 服务器需要用 WebSocketServer 构造函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; { WebSocketServer } = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;ws&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; wss = &lt;span&gt;new&lt;/span&gt; WebSocketServer({&lt;br/&gt;  &lt;span&gt;port&lt;/span&gt;: &lt;span&gt;8080&lt;/span&gt;&lt;br/&gt;})&lt;br/&gt;wss.on(&lt;span&gt;&#x27;connection&#x27;&lt;/span&gt;, (ws, req) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;客户端已连接：&#x27;&lt;/span&gt;, req.socket.remoteAddress)&lt;br/&gt;  ws.on(&lt;span&gt;&#x27;message&#x27;&lt;/span&gt;, data =&amp;gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;收到客户端发送的消息：&#x27;&lt;/span&gt;, data)&lt;br/&gt;  })&lt;br/&gt;  ws.send(&lt;span&gt;&#x27;我是服务端&#x27;&lt;/span&gt;) &lt;span&gt;// 向当前客户端发送消息&lt;/span&gt;&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把这段代码写进 &lt;code&gt;ws-server.js&lt;/code&gt; 然后运行：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ node ws-server.js&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样一个监听 &lt;code&gt;8080&lt;/code&gt; 端口的 WebSocket 服务器就已经跑起来了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;客户端&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上一步建好了 WebSocket 服务器，现在我们在前端连接并监听消息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; ws = &lt;span&gt;new&lt;/span&gt; WebSocket(&lt;span&gt;&#x27;ws://localhost:8080&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;ws.onopen = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;mevt&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;客户端已连接&#x27;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;ws.onmessage = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;mevt&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;客户端收到消息: &#x27;&lt;/span&gt; + evt.data)&lt;br/&gt;  ws.close()&lt;br/&gt;}&lt;br/&gt;ws.onclose = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span&gt;mevt&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;连接关闭&#x27;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将代码写入 &lt;code&gt;wsc.html&lt;/code&gt; 然后用浏览器打开，看到打印如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2802197802197802&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mXiaYPiasyFP1G8y7VuDJCYuWeku2B4RaYobukxQLvqGJ4TICJQUCz734aJgnmSjTzFFQVeeHMEGMcicZNU6aWA8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;364&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以看到，浏览器连接成功后，收到服务端主动推送过来的消息，然后浏览器可以主动关闭连接。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Node.js 环境下我们看 ws 模块如何发起连接：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; WebSocket = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;ws&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; ws = &lt;span&gt;new&lt;/span&gt; WebSocket(&lt;span&gt;&#x27;ws://localhost:8080&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;ws.on(&lt;span&gt;&#x27;open&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;客户端已连接&#x27;&lt;/span&gt;)&lt;br/&gt;})&lt;br/&gt;ws.on(&lt;span&gt;&#x27;message&#x27;&lt;/span&gt;, data =&amp;gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;客户端收到消息: &#x27;&lt;/span&gt; + data)&lt;br/&gt;  ws.close()&lt;br/&gt;})&lt;br/&gt;ws.on(&lt;span&gt;&#x27;close&#x27;&lt;/span&gt;, () =&amp;gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;连接关闭&#x27;&lt;/span&gt;)&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码与浏览器的逻辑一模一样，只是写法稍有些不同，注意区别。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要特殊说明的一点，浏览器端监听 &lt;code&gt;message&lt;/code&gt; 事件的回调函数，参数是一个 MessageEvent 的实例对象，服务端发来的实际数据需要通过 &lt;code&gt;mevt.data&lt;/code&gt; 获取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在 ws 客户端，这个参数就是服务端的实际数据，直接获取即可。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Express 集成&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ws 模块一般不会单独使用，更优的方案是集成到现有的框架中。这节我们将 ws 模块集成到 Express 框架。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;集成到 Express 框架的优点是，我们不需要单独监听一个端口，使用框架启动的端口即可，并且我们还可以指定访问到某个路由，才发起 WebSocket 连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幸运的是这一切不需要手动实现，express-ws 模块已经帮我们做好了大部分的集成工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先安装，然后在入口文件引入：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; expressWs = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;express-ws&#x27;&lt;/span&gt;)(app)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和 Express 的 Router 一样，express-ws 也支持注册全局路由和局部路由。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看全局路由，通过 &lt;code&gt;[host]/test-ws&lt;/code&gt; 连接：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;app.ws(&lt;span&gt;&#x27;/test-ws&#x27;&lt;/span&gt;, (ws, req) =&amp;gt; {&lt;br/&gt;  ws.on(&lt;span&gt;&#x27;message&#x27;&lt;/span&gt;, msg =&amp;gt; {&lt;br/&gt;    ws.send(msg)&lt;br/&gt;  })&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;局部路由则是注册在一个&lt;strong&gt;路由组&lt;/strong&gt;下面的子路由。配置一个名为 &lt;code&gt;websocket&lt;/code&gt; 的路由组并指向 &lt;code&gt;websocket.js&lt;/code&gt; 文件，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// websocket.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; router = express.Router()&lt;br/&gt;&lt;br/&gt;router.ws(&lt;span&gt;&#x27;/test-ws&#x27;&lt;/span&gt;, (ws, req) =&amp;gt; {&lt;br/&gt;  ws.on(&lt;span&gt;&#x27;message&#x27;&lt;/span&gt;, msg =&amp;gt; {&lt;br/&gt;    ws.send(msg)&lt;br/&gt;  })&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;&lt;span&gt;module&lt;/span&gt;.exports = router&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;连接 &lt;code&gt;[host]/websocket/test-ws&lt;/code&gt; 就可以访问到这个子路由。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;路由组的作用是定义一个 websocket 连接组，不同需求连接这个组下的不同子路由。比如可以将 &lt;code&gt;单聊&lt;/code&gt; 和 &lt;code&gt;群聊&lt;/code&gt; 设置为两个子路由，分别处理各自的连接通信逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; express = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;express&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; app = express()&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; wsServer = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;express-ws&#x27;&lt;/span&gt;)(app)&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; webSocket = &lt;span&gt;require&lt;/span&gt;(&lt;span&gt;&#x27;./websocket.js&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;app.ws(&lt;span&gt;&#x27;/test-ws&#x27;&lt;/span&gt;, (ws, req) =&amp;gt; {&lt;br/&gt;  ws.on(&lt;span&gt;&#x27;message&#x27;&lt;/span&gt;, msg =&amp;gt; {&lt;br/&gt;    ws.send(msg)&lt;br/&gt;  })&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;app.use(&lt;span&gt;&#x27;/websocket&#x27;&lt;/span&gt;, webSocket)&lt;br/&gt;&lt;br/&gt;app.listen(&lt;span&gt;3000&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际开发中获取常用信息的小方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 客户端的IP地址&lt;/span&gt;&lt;br/&gt;req.socket.remoteAddress&lt;br/&gt;&lt;span&gt;// 连接参数&lt;/span&gt;&lt;br/&gt;req.query&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;WebSocket 实例&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;WebSocket 实例是指客户端连接对象，以及服务端连接的第一个参数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; ws = &lt;span&gt;new&lt;/span&gt; WebSocket(&lt;span&gt;&#x27;ws://localhost:8080&#x27;&lt;/span&gt;)&lt;br/&gt;app.ws(&lt;span&gt;&#x27;/test-ws&#x27;&lt;/span&gt;, (ws, req) =&amp;gt; {}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码中的 &lt;code&gt;ws&lt;/code&gt; 就是 WebSocket 实例，表示建立的连接。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;浏览器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;浏览器的 ws 对象中包含的信息如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;binaryType&lt;/span&gt;: &lt;span&gt;&#x27;blob&#x27;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;bufferedAmount&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;extensions&lt;/span&gt;: &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;onclose&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;onerror&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;onmessage&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;onopen&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;protocol&lt;/span&gt;: &lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;readyState&lt;/span&gt;: &lt;span&gt;3&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;url&lt;/span&gt;: &lt;span&gt;&#x27;ws://localhost:8080/&#x27;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先非常关键的是四个监听属性，用于定义函数：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;onopen&lt;/code&gt;：连接建立后的函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;onmessage&lt;/code&gt;：收到服务端推送消息的函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;onclose&lt;/code&gt;：连接关闭的函数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;onerror&lt;/code&gt;：连接异常的函数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中最常用的是 &lt;code&gt;onmessage&lt;/code&gt; 属性，赋值为一个函数来监听服务端消息：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ws.onmessage = &lt;span&gt;&lt;span&gt;mevt&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;消息：&#x27;&lt;/span&gt;, mevt.data)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一个关键属性是 &lt;code&gt;readyState&lt;/code&gt;，表示连接状态，值为一个数字。并且每个值都可以用&lt;code&gt;常量&lt;/code&gt;表示，对应关系和含义如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;0&lt;/code&gt;: 常量 &lt;code&gt;WebSocket.CONNECTING&lt;/code&gt;，表示正在连接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;1&lt;/code&gt;: 常量 &lt;code&gt;WebSocket.OPEN&lt;/code&gt;，表示已连接&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;2&lt;/code&gt;: 常量 &lt;code&gt;WebSocket.CLOSING&lt;/code&gt;，表示正在关闭&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;3&lt;/code&gt;: 常量 &lt;code&gt;WebSocket.CLOSED&lt;/code&gt;，表示已关闭&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然最重要的还有 &lt;code&gt;send&lt;/code&gt; 方法用于发送信息，向服务端发送数据：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ws.send(&lt;span&gt;&#x27;要发送的信息&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务端&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务端的 ws 对象表示当前发起连接的一个客户端，基本属性与浏览器大致相同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如上面客户端的四个监听属性，&lt;code&gt;readyState&lt;/code&gt; 属性，以及 &lt;code&gt;send&lt;/code&gt; 方法都是一致的。不过因为服务端是 Node.js 实现，因此会有更丰富的支持。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如下面两种监听事件的写法效果是一样的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Node.js 环境&lt;/span&gt;&lt;br/&gt;ws.onmessage = &lt;span&gt;&lt;span&gt;str&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;消息：&#x27;&lt;/span&gt;, str)&lt;br/&gt;}&lt;br/&gt;ws.on(&lt;span&gt;&#x27;message&#x27;&lt;/span&gt;, str =&amp;gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;消息：&#x27;&lt;/span&gt;, mevt.data)&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;详细的属性和介绍可以查阅官方文档&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;消息广播&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;WebSocket 服务器不会只有一个客户端连接，消息广播的意思就是把信息发给所有已连接的客户端，像一个大喇叭一样，所有人都听得到，经典场景就是热点推送。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么广播之前，就必须要解决一个问题，&lt;strong&gt;如何获取当前已连接（在线）的客户端&lt;/strong&gt;？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实 &lt;code&gt;ws&lt;/code&gt; 模块提供了快捷的获取方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; wss = &lt;span&gt;new&lt;/span&gt; WebSocketServer({ &lt;span&gt;port&lt;/span&gt;: &lt;span&gt;8080&lt;/span&gt; })&lt;br/&gt;&lt;span&gt;// 获取所有已连接客户端&lt;/span&gt;&lt;br/&gt;wss.clients&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方便吧。再看 &lt;code&gt;express-ws&lt;/code&gt; 怎么获取：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; wsServer = expressWebSocket(app)&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; wss = wsServer.getWss()&lt;br/&gt;&lt;span&gt;// 获取所有已连接客户端&lt;/span&gt;&lt;br/&gt;wss.clients&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;拿到 &lt;code&gt;wss.clients&lt;/code&gt; 后，我们看看它到底是什么样子。经过打印，发现它的数据结构比想象到还要简单，就是由所有在线客户端的 WebSocket 实例组成的一个 &lt;code&gt;Set&lt;/code&gt; 集合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，获取当前在线客户端的数量：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;wss.clients.size&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单粗暴的实现广播：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;wss.clients.forEach(&lt;span&gt;&lt;span&gt;client&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (client.readyState === &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;    client.send(&lt;span&gt;&#x27;广播数据&#x27;&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是非常简单，基础的实现方式。试想一下如果此刻在线客户有 10000 个，那么这个循环多半会卡死吧。因此才会有像 socket.io 这样的库，对基础功能做了大量优化和封装，提高并发性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的广播属于&lt;code&gt;全局广播&lt;/code&gt;，就是将消息发给所有人。然而还有另一种场景，比如一个 5 人的群聊小组聊天，这时的广播只是给这 5 人小团体发消息，因此这也叫 &lt;code&gt;局部广播&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;局部广播的实现要复杂一些，一般会揉合具体的业务场景。这就需要我们在客户端连接时，对客户端数据做持久化处理了。比如用 &lt;code&gt;Redis&lt;/code&gt; 存储在线客户端的状态和数据，这样检索分类更快，效率更高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;局部广播实现，那一对一私聊就更容易了。找到两个客户端对应的 WebSocket 实例互发消息就行。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;安全与认证&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面搭建好的 WebSocket 服务器，默认任何客户端都可以连接，这在生产环境肯定是不行的。我们要对 WebSocket 服务器做安全保障，主要是从两个方面入手：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Token 连接认证&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;wss 支持&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面说一说我的实现思路。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Token 连接认证&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 请求接口我们一般会做 JWT 认证，在请求头中带一个指定 Header，将一个 token 字符串传过去，后端会拿这个 token 做校验，校验失败则返回 401 错误阻止请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们上面说过，&lt;code&gt;WebSocket&lt;/code&gt; 建立连接的第一步是客户端发起一个 HTTP 的连接请求，那么我们在这个 HTTP 请求上做验证，如果验证失败，则中断 WebSocket 的连接创建，不就可以了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顺着这个思路，我们来改造一下服务端代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为要在 HTTP 层做校验，所以用 &lt;code&gt;http&lt;/code&gt; 模块创建服务器，关掉 WebSocket 服务的端口。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; server = http.createServer()&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; wss = &lt;span&gt;new&lt;/span&gt; WebSocketServer({ &lt;span&gt;noServer&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt; })&lt;br/&gt;&lt;br/&gt;server.listen(&lt;span&gt;8080&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当客户端通过 &lt;code&gt;ws://&lt;/code&gt; 连接服务端时，服务端会进行协议升级，也就是将 http 协议升级成 websocket 协议，此时会触发 &lt;code&gt;upgrade&lt;/code&gt; 事件：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;server.on(&lt;span&gt;&#x27;upgrade&#x27;&lt;/span&gt;, (request, socket) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;// 用 request 获取参数做验证&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 1. 验证不通过判断&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;&#x27;验证失败&#x27;&lt;/span&gt;) {&lt;br/&gt;    socket.write(&lt;span&gt;&#x27;HTTP/1.1 401 Unauthorized\r\n\r\n&#x27;&lt;/span&gt;)&lt;br/&gt;    socket.destroy()&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;// 2. 验证通过，继续建立连接&lt;/span&gt;&lt;br/&gt;  wss.handleUpgrade(request, socket, _, ws =&amp;gt; {&lt;br/&gt;    wss.emit(&lt;span&gt;&#x27;connection&#x27;&lt;/span&gt;, ws, request)&lt;br/&gt;  })&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 3. 监听连接&lt;/span&gt;&lt;br/&gt;wss.on(&lt;span&gt;&#x27;connection&#x27;&lt;/span&gt;, (ws, request) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;客户端已连接&#x27;&lt;/span&gt;)&lt;br/&gt;  ws.send(&lt;span&gt;&#x27;服务端信息&#x27;&lt;/span&gt;)&lt;br/&gt;})&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样服务端认证添加完毕，具体的认证方法结合客户端的传参方式来定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;WebSocket 客户端连接不支持自定义 Header，因此不能用 JWT 的方案，可用方案有两种：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Basic Auth&lt;/code&gt; 认证简单说就是账号+密码认证，而且账号密码是带在 URL 里的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我有账号是 &lt;strong&gt;ruims&lt;/strong&gt;，密码是 &lt;strong&gt;123456&lt;/strong&gt;，那么客户端连接是这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; ws = &lt;span&gt;new&lt;/span&gt; WebSocket(&lt;span&gt;&#x27;ws://ruims:123456@localhost:8080&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么服务端就会收到这样一个请求头：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;wss.on(&lt;span&gt;&#x27;connection&#x27;&lt;/span&gt;, (ws, req) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt;(req.headers[&lt;span&gt;&#x27;authorization&#x27;&lt;/span&gt;]) {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; auth = req.headers[&lt;span&gt;&#x27;authorization&#x27;&lt;/span&gt;]&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(auth)&lt;br/&gt;    &lt;span&gt;// 打印的值：Basic cnVpbXM6MTIzNDU2&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 &lt;strong&gt;cnVpbXM6MTIzNDU2&lt;/strong&gt; 就是 &lt;code&gt;ruims:123456&lt;/code&gt; 的 base64 编码，服务端可以获取到这个编码来做认证。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Quary&lt;/code&gt; 传参比较简单，就是普通的 URL 传参，可以带一个短一点的加密字符串过去，服务端获取到该字符串然后做认证：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; ws = &lt;span&gt;new&lt;/span&gt; WebSocket(&lt;span&gt;&#x27;ws://localhost:8080?token=cnVpbXM6MTIzNDU2&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务端获取参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;wss.on(&lt;span&gt;&#x27;connection&#x27;&lt;/span&gt;, (ws, req) =&amp;gt; {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(req.query.token)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;wss 支持&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;WebSocket 客户端使用 &lt;code&gt;ws://&lt;/code&gt; 协议连接，那 wss 是什么意思？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实非常简单，和 https 原理一摸一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;https&lt;/code&gt; 表示安全的 http 协议，组成是 &lt;strong&gt;HTTP + SSL&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;wss&lt;/code&gt; 则表示安全的 ws 协议，组成是 &lt;strong&gt;WS + SSL&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那为什么一定要用 wss 呢？除了安全性，还有一个关键原因是：如果你的 web 应用是 https 协议，你在当前应用中使用 WebSocket 就必须是 wss 协议，否则浏览器拒绝连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置 wss 直接在 https 配置中加一个 &lt;code&gt;location&lt;/code&gt; 即可，直接上 nginx 配置：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;location /websocket {&lt;br/&gt;  proxy_pass http://127.0.0.1:8080;&lt;br/&gt;  proxy_redirect off;&lt;br/&gt;  proxy_http_version 1.1;&lt;br/&gt;  proxy_set_header Upgrade $http_upgrade;&lt;br/&gt;  proxy_set_header Connection upgrade;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后客户端连接就变成了这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; ws = &lt;span&gt;new&lt;/span&gt; WebSocket(&lt;span&gt;&#x27;wss://[host]/websocket&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;BFF 应用&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BFF 或许你听说过，全称是 &lt;code&gt;Backend For Frontend&lt;/code&gt;，意思是为前端服务的后端，在实际应用架构中属于前端和后端的一个 &lt;code&gt;中间层&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个中间层一般是由 Node.js 实现，那么它有什么作用呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，现在后端的主流架构是微服务，微服务情况下 API 会划分的非常细，商品服务就是商品服务，通知服务就是通知服务。当你想在商品上架时给用户发一个通知，可能至少需要调两个接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的话对前端其实是不友好的，于是后来出现了 BFF 中间层，相当于一个后端请求的中间代理站，前端可以直接请求 BFF 的接口，然后 BFF 再向后端接口请求，将需要的数据组合起来，一次返回前端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那我们在上面讲的一大堆 WebSocket 的知识，在 BFF 层如何应用呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我想到的应用场景至少有 4 个：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;查看当前在线人数，在线用户信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;登录新设备，其他设备退出登录&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;检测网络连接/断开&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;站内消息，小圆点提示&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些功能以前是在后端实现的，并且会与其他业务功能耦合。现在有了 BFF，那么 WebSocket 完全可以在这一层实现，让后端可以专注核心数据逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此可见，掌握了 WebSocket 在 Node.js 中的实践应用，作为前端的我们可以破除内卷，在另一个领域继续发挥价值，岂不美哉？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;源码+答疑&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文所有的代码都是经过我亲自实践，为了便于小伙伴们查阅和试验，我建了一个 GitHub 仓库专门存放本文的完整源码，以及之后文章的完整源码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仓库地址在这里：&lt;span&gt;&lt;strong&gt;&lt;span&gt;https://github.com/ruidoc/blog-codes&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;欢迎大家查阅和试验。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;首发公众号&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果本文对你有启发，请左手一个&lt;strong&gt;赞&lt;/strong&gt;，右手一个&lt;strong&gt;在看&lt;/strong&gt;，祝你脱单不脱发，早日成为技术专家～&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如对文中细节有疑问，欢迎加微信咨询～ &lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODIwMDY2OQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/sz_mmbiz_png/3GPT1CHiaSVuxicynPxGHvs3EzVRI1wTnkehvUErL7vX7AlMltiasN85woTdynRZ8fdgj38SN4UHWXnsbn5Dje3eQ/0?wx_fmt=png&quot; data-nickname=&quot;前端巅峰&quot; data-alias=&quot;Java-Script-&quot; data-signature=&quot;专注于国内外前端前沿技术的应用与落地&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>