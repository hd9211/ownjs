<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>570576c0bf7854777c6a77574da6ff88</guid>
<title>资料 | 英语进阶指南</title>
<link>https://toutiao.io/k/4yqc5t5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f325e6d223643985b5499921cab9a604</guid>
<title>优质网站同好者周刊（第 5 期）</title>
<link>https://toutiao.io/k/ubsth9i</link>
<content:encoded>&lt;div&gt;&lt;html lang=&quot;zh-CN&quot;&gt;
&lt;head&gt;
  &lt;meta charset=&quot;UTF-8&quot;/&gt;
  

    &lt;title&gt;优质网站同好者周刊（第 5 期）- 倾城之链 | 晚晴幽草轩&lt;/title&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1,user-scalable=no&quot;/&gt;
    
    &lt;meta name=&quot;author&quot; content=&quot;晚晴幽草轩轩主&quot;/&gt;
    
    &lt;meta name=&quot;theme-color&quot; content=&quot;#fffffb&quot;/&gt;
    &lt;meta name=&quot;baidu-site-verification&quot; content=&quot;PKEtLPjO56&quot;/&gt;
    

    &lt;meta name=&quot;keywords&quot; content=&quot;倾城之链, 优质网站, 开放平台, 倾城&quot;/&gt;
    &lt;meta name=&quot;description&quot; content=&quot;倾城之链作为一个开放平台，旨在云集全球优秀网站，探索互联网中更广阔的世界。此周刊，将汇聚过去一周倾城所收录的内容，以飨同好；欢迎推荐或自荐（仅限有独立域名的网站，可以是二级域名）。您如果要了解收录要求，请参见关于倾城。&quot;/&gt;
&lt;meta property=&quot;og:type&quot; content=&quot;article&quot;/&gt;
&lt;meta property=&quot;og:title&quot; content=&quot;优质网站同好者周刊（第 5 期）- 倾城之链&quot;/&gt;
&lt;meta property=&quot;og:url&quot; content=&quot;https://www.jeffjade.com/2021/03/18/188-nicelinks-weekly-006/index.html&quot;/&gt;
&lt;meta property=&quot;og:site_name&quot; content=&quot;晚晴幽草轩&quot;/&gt;
&lt;meta property=&quot;og:description&quot; content=&quot;倾城之链作为一个开放平台，旨在云集全球优秀网站，探索互联网中更广阔的世界。此周刊，将汇聚过去一周倾城所收录的内容，以飨同好；欢迎推荐或自荐（仅限有独立域名的网站，可以是二级域名）。您如果要了解收录要求，请参见关于倾城。&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/forum.lovejade.cn.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/www.gitpod.io.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/defonic.com.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/rainbowhunt.com.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/mouto.org.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/coder.com.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://oss.nicelinks.site/embed.so.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://image.nicelinks.site/%E5%80%BE%E5%9F%8E%E4%B9%8B%E9%93%BE-%E5%BE%AE%E4%BF%A1-mini.jpeg&quot;/&gt;
&lt;meta property=&quot;og:image&quot; content=&quot;https://image.nicelinks.site/nicelinks-miniprogram-code.jpeg?imageView2/1/w/300/h/300/interlace/1/ignore-error/1&quot;/&gt;
&lt;meta property=&quot;og:updated_time&quot; content=&quot;2021-03-20T03:21:08.828Z&quot;/&gt;
&lt;meta name=&quot;twitter:card&quot; content=&quot;summary&quot;/&gt;
&lt;meta name=&quot;twitter:title&quot; content=&quot;优质网站同好者周刊（第 5 期）- 倾城之链&quot;/&gt;
&lt;meta name=&quot;twitter:description&quot; content=&quot;倾城之链作为一个开放平台，旨在云集全球优秀网站，探索互联网中更广阔的世界。此周刊，将汇聚过去一周倾城所收录的内容，以飨同好；欢迎推荐或自荐（仅限有独立域名的网站，可以是二级域名）。您如果要了解收录要求，请参见关于倾城。&quot;/&gt;
&lt;meta name=&quot;twitter:image&quot; content=&quot;https://oss.nicelinks.site/forum.lovejade.cn.png?x-oss-process=style/png2jpg&quot;/&gt;
&lt;meta name=&quot;twitter:creator&quot; content=&quot;@nicejadeyang&quot;/&gt;

    
    
    
    
    
    
    
    
    
    

    
    
    

    
    
    
    
    

    
    
    

    
    
    
    
    
    
&lt;/head&gt;&lt;/html&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>171742333c9d0f69e8dc4810f34d11a8</guid>
<title>写给开发人员的实用密码学：非对称加密算法</title>
<link>https://toutiao.io/k/ajk71ed</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面的文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI3NTQyMzEzNQ==&amp;amp;mid=2247486210&amp;amp;idx=1&amp;amp;sn=a63107bab37b9406f19a2ca7e5a0ba2e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;写给开发人员的实用密码学 - 对称加密算法&lt;/a&gt;》中，介绍了现代密码学中非常重要的加密解密算法。从工程学的角度，选取密钥足够长的加密算法（比如AES 256、AES 512），是无法破解的。但在对称加密算法中，存在明显的薄弱环节，那就是密钥的存储与分发。因为算法是公开的，那么决定加密系统是否安全的因素就是密钥。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然而在开放的互联网环境下，如何高效分发密钥成了一个难题。比如一个服务器，可能会服务千万级的用户，如果为每个用户分配不同的密钥，那密钥的维护是个大问题。密钥发放也是问题，如果是企业内部，还可以通过邮件发送密钥，但在开放的互联网上，这种方式行不通。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公开密钥算法（Public KeyCryptography），也称为非对称加密算法（Asymmetrical Cryptography），可以用于解决这一难题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顾名思义，非对称加密算法就是加密密钥和解密密钥不是同一个。算法的密钥是一对，分别是公钥（public key）和私钥（private key）。一般私钥由密钥对的生成方（比如服务器端）持有，避免泄露，而公钥任何人都可以持有，也不怕泄露。这里没有使用加密密钥和解密密钥，是因为公钥和私钥都可以用来加密，也可以用来解密。如果使用公钥加密，就要使用私钥解密，反之依然。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公开密钥算法不是一个算法而是一组算法，通常提供如下算法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;密钥对生成：生成随机对的私钥+对应的公钥。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加密/解密：通过公钥加密数据，并通过私钥解密数据（通常使用混合加密方案）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;数字签名（消息认证）：通过私钥对消息签名，并通过公钥验证签名。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;密钥交换算法：通过不安全的通道在两方之间安全地交换加密密钥。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果公开密钥算法用于加密解密运算，习惯上称为非对称加密算法。非对称加密算法的加密解密过程如下图所示。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2885572139303483&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibQ4mtgHYXv6I2wbKslbeib7VTCdtGvpyrr2EL4yJL8XZVvITsV9ibAoeNwHNoZp42qwiavWZYDrdqtKtiaZAaHicT1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;402&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前非对称加密算法还无法取代对称加密算法，相比对称加密算法来说，公开密钥算法尤其是RSA算法运算非常缓慢，一般情况下，需要加密的明文数据都非常大，如果使用公开密钥算法进行加密，运算性能会惨不忍睹。公开密钥算法在密码学中一般进行密钥协商或者数字签名，因为这两者运算的数据相对较小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前，最重要和最常用的公钥密码系统是 RSA 和 椭圆曲线密码算法（ECC）。推荐使用 ECC，因为它具有较小的密钥，较短的签名和更好的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;国密 SM2 算法就是一种 ECC 算法，所以下面着重讲一讲 ECC。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ECC 算法&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ECC是比离散对数类算法（比如RSA和DH算法）更复杂的算法，非常难于理解，本身也是很复杂的一个结构体，在理解起来的时候有一定的难度。不理解ECC理论知识没有关系，但需要了解以下这张图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.695&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibQ4mtgHYXv6I2wbKslbeib7VTCdtGvpyrJNra3zLFMuzsjTr3Mxo7JLicGoaCkj7h4HHfVibfKyuWtkFfMaVEjRlw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ECC椭圆曲线由很多点组成，这些点由特定的方程式组成的，比如方程式可以是y^2 = x^3 + ax + b，这些点连接起来就是一条曲线，但曲线并不是一个椭圆。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;椭圆曲线有个特点，任意两个点能够得到这条椭圆曲线上的另外一点，这个操作称为打点，经过多次（比如d次）打点后，能够生成一个最终点（F）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的图中，A点称为基点（G）或者生成器。A可以和自己打点从而生成B点，在实际应用的时候，一般有基点就可以了。经过多次打点，就得到了最终点G。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ECC密码学的关键点就在于就算知道具体方程式、基点（G）、最终点（F），也无法知晓一共打点了多少次（d）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ECC中，打点次数(d)就是私钥，这通常是一个随机数，公钥就是最终点（F)，包含(x，y)两个分量，通常组合成一个数字来传输和存储。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ECC由方程式（比如a、b这样的方程式参数）、基点（G）、质数（P）组成。理论上方程式和各种参数组合可以是任意的，但是在密码学中，为了安全，系统预先定义了一系列的曲线，称为命名曲线（name curve），比如secp256k1就是一个命名曲线。对于开发者而言，在使用ECC密码学的时候，就是选择具体的命名曲线。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;命名曲线&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ECC本质上就是一个数学公式，任何人基于公式都可以设计出椭圆曲线，在实现的时候一定要注意ECC离散对数问题（Elliptic-Curve Discrete-Logarithm Problem，简称ECDLP），如果实现不当，那么ECC公式就会存在安全风险。为了简化ECC的使用，可以选用设计规范的命名曲线，命名曲线中包含了ECC椭圆曲线的参数，比如基点、有限域等，对于大部分开发者来说，如果要使用ECC椭圆曲线，要做的就是选择一条安全且性能高的命名曲线。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的命名曲线有 secp192r1、secp256r1、secp384r1、secp512r1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用GmSSL命令行可以查看所实现的命名曲线。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ gmssl ecparam -list_curves&lt;br/&gt;  secp112r1 : SECG/WTLS curve over a 112 bit prime field&lt;br/&gt;  secp112r2 : SECG curve over a 112 bit prime field&lt;br/&gt;  secp128r1 : SECG curve over a 128 bit prime field&lt;br/&gt;  secp128r2 : SECG curve over a 128 bit prime field&lt;br/&gt;  secp160k1 : SECG curve over a 160 bit prime field&lt;br/&gt;  secp160r1 : SECG curve over a 160 bit prime field&lt;br/&gt;  secp160r2 : SECG/WTLS curve over a 160 bit prime field&lt;br/&gt;  secp192k1 : SECG curve over a 192 bit prime field&lt;br/&gt;  secp224k1 : SECG curve over a 224 bit prime field&lt;br/&gt;  secp224r1 : NIST/SECG curve over a 224 bit prime field&lt;br/&gt;  secp256k1 : SECG curve over a 256 bit prime field&lt;br/&gt;  secp384r1 : NIST/SECG curve over a 384 bit prime field&lt;br/&gt;  secp521r1 : NIST/SECG curve over a 521 bit prime field&lt;br/&gt;  prime192v1: NIST/X9.62/SECG curve over a 192 bit prime field&lt;br/&gt;  prime192v2: X9.62 curve over a 192 bit prime field&lt;br/&gt;  prime192v3: X9.62 curve over a 192 bit prime field&lt;br/&gt;  prime239v1: X9.62 curve over a 239 bit prime field&lt;br/&gt;  prime239v2: X9.62 curve over a 239 bit prime field&lt;br/&gt;  prime239v3: X9.62 curve over a 239 bit prime field&lt;br/&gt;  prime256v1: X9.62/SECG curve over a 256 bit prime field&lt;br/&gt;  sect113r1 : SECG curve over a 113 bit binary field&lt;br/&gt;  sect113r2 : SECG curve over a 113 bit binary field&lt;br/&gt;  sect131r1 : SECG/WTLS curve over a 131 bit binary field&lt;br/&gt;  sect131r2 : SECG curve over a 131 bit binary field&lt;br/&gt;  sect163k1 : NIST/SECG/WTLS curve over a 163 bit binary field&lt;br/&gt;  sect163r1 : SECG curve over a 163 bit binary field&lt;br/&gt;  sect163r2 : NIST/SECG curve over a 163 bit binary field&lt;br/&gt;  sect193r1 : SECG curve over a 193 bit binary field&lt;br/&gt;  sect193r2 : SECG curve over a 193 bit binary field&lt;br/&gt;  sect233k1 : NIST/SECG/WTLS curve over a 233 bit binary field&lt;br/&gt;  sect233r1 : NIST/SECG/WTLS curve over a 233 bit binary field&lt;br/&gt;  sect239k1 : SECG curve over a 239 bit binary field&lt;br/&gt;  sect283k1 : NIST/SECG curve over a 283 bit binary field&lt;br/&gt;  sect283r1 : NIST/SECG curve over a 283 bit binary field&lt;br/&gt;  sect409k1 : NIST/SECG curve over a 409 bit binary field&lt;br/&gt;  sect409r1 : NIST/SECG curve over a 409 bit binary field&lt;br/&gt;  sect571k1 : NIST/SECG curve over a 571 bit binary field&lt;br/&gt;  sect571r1 : NIST/SECG curve over a 571 bit binary field&lt;br/&gt;  c2pnb163v1: X9.62 curve over a 163 bit binary field&lt;br/&gt;  c2pnb163v2: X9.62 curve over a 163 bit binary field&lt;br/&gt;  c2pnb163v3: X9.62 curve over a 163 bit binary field&lt;br/&gt;  c2pnb176v1: X9.62 curve over a 176 bit binary field&lt;br/&gt;  c2tnb191v1: X9.62 curve over a 191 bit binary field&lt;br/&gt;  c2tnb191v2: X9.62 curve over a 191 bit binary field&lt;br/&gt;  c2tnb191v3: X9.62 curve over a 191 bit binary field&lt;br/&gt;  c2pnb208w1: X9.62 curve over a 208 bit binary field&lt;br/&gt;  c2tnb239v1: X9.62 curve over a 239 bit binary field&lt;br/&gt;  c2tnb239v2: X9.62 curve over a 239 bit binary field&lt;br/&gt;  c2tnb239v3: X9.62 curve over a 239 bit binary field&lt;br/&gt;  c2pnb272w1: X9.62 curve over a 272 bit binary field&lt;br/&gt;  c2pnb304w1: X9.62 curve over a 304 bit binary field&lt;br/&gt;  c2tnb359v1: X9.62 curve over a 359 bit binary field&lt;br/&gt;  c2pnb368w1: X9.62 curve over a 368 bit binary field&lt;br/&gt;  c2tnb431r1: X9.62 curve over a 431 bit binary field&lt;br/&gt;  wap-wsg-idm-ecid-wtls1: WTLS curve over a 113 bit binary field&lt;br/&gt;  wap-wsg-idm-ecid-wtls3: NIST/SECG/WTLS curve over a 163 bit binary field&lt;br/&gt;  wap-wsg-idm-ecid-wtls4: SECG curve over a 113 bit binary field&lt;br/&gt;  wap-wsg-idm-ecid-wtls5: X9.62 curve over a 163 bit binary field&lt;br/&gt;  wap-wsg-idm-ecid-wtls6: SECG/WTLS curve over a 112 bit prime field&lt;br/&gt;  wap-wsg-idm-ecid-wtls7: SECG/WTLS curve over a 160 bit prime field&lt;br/&gt;  wap-wsg-idm-ecid-wtls8: WTLS curve over a 112 bit prime field&lt;br/&gt;  wap-wsg-idm-ecid-wtls9: WTLS curve over a 160 bit prime field&lt;br/&gt;  wap-wsg-idm-ecid-wtls10: NIST/SECG/WTLS curve over a 233 bit binary field&lt;br/&gt;  wap-wsg-idm-ecid-wtls11: NIST/SECG/WTLS curve over a 233 bit binary field&lt;br/&gt;  wap-wsg-idm-ecid-wtls12: WTLS curve over a 224 bit prime field&lt;br/&gt;  Oakley-EC2N-3: &lt;br/&gt;        IPSec/IKE/Oakley curve &lt;span&gt;#3 over a 155 bit binary field.&lt;/span&gt;&lt;br/&gt;        Not suitable &lt;span&gt;for&lt;/span&gt; ECDSA.&lt;br/&gt;        Questionable extension field!&lt;br/&gt;  Oakley-EC2N-4: &lt;br/&gt;        IPSec/IKE/Oakley curve &lt;span&gt;#4 over a 185 bit binary field.&lt;/span&gt;&lt;br/&gt;        Not suitable &lt;span&gt;for&lt;/span&gt; ECDSA.&lt;br/&gt;        Questionable extension field!&lt;br/&gt;  brainpoolP160r1: RFC 5639 curve over a 160 bit prime field&lt;br/&gt;  brainpoolP160t1: RFC 5639 curve over a 160 bit prime field&lt;br/&gt;  brainpoolP192r1: RFC 5639 curve over a 192 bit prime field&lt;br/&gt;  brainpoolP192t1: RFC 5639 curve over a 192 bit prime field&lt;br/&gt;  brainpoolP224r1: RFC 5639 curve over a 224 bit prime field&lt;br/&gt;  brainpoolP224t1: RFC 5639 curve over a 224 bit prime field&lt;br/&gt;  brainpoolP256r1: RFC 5639 curve over a 256 bit prime field&lt;br/&gt;  brainpoolP256t1: RFC 5639 curve over a 256 bit prime field&lt;br/&gt;  brainpoolP320r1: RFC 5639 curve over a 320 bit prime field&lt;br/&gt;  brainpoolP320t1: RFC 5639 curve over a 320 bit prime field&lt;br/&gt;  brainpoolP384r1: RFC 5639 curve over a 384 bit prime field&lt;br/&gt;  brainpoolP384t1: RFC 5639 curve over a 384 bit prime field&lt;br/&gt;  brainpoolP512r1: RFC 5639 curve over a 512 bit prime field&lt;br/&gt;  brainpoolP512t1: RFC 5639 curve over a 512 bit prime field&lt;br/&gt;  sm2p256v1 : SM2 curve over a 256 bit prime field&lt;br/&gt;  wapip192v1: WAPI curve over a 192 bit prime field&lt;br/&gt;  sm9bn256v1: SM9 BN curve over a 256 bit prime field&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中 sm2p256v1、wapip192v1、sm9bn256v1 就是国密定义的命名曲线。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;国密SM2算法&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SM2算法就是一种ECC算法，准确来说，就是设计了一条ECC命名曲线。在《GMT 0003-2012》这份标准中，有SM2算法的设计背景知识，有兴趣的可以了解，对于开发者而言，最重要的是《GMT 0005-2012》标准中的曲线参数：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3490740740740741&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibQ4mtgHYXv6I2wbKslbeib7VTCdtGvpyrd5qNW1iaH3hL8KPKCliaveDlpXIA7AkZibF6Xpc8yvMibYPqK3KAKAVDVg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在的网络库，比如NSS、OpenSSL、libtomcrypt等，都有ECC算法的支持，要在网络库中加入SM2算法支持，只需加入命名曲线的参数即可。比如在GmSSL代码的 ec_curve.c 文件中就有 sm2p256v1 命名曲线的参数定义：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;&lt;span&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;br/&gt;    EC_CURVE_DATA h;&lt;br/&gt;    &lt;span&gt;unsigned&lt;/span&gt; &lt;span&gt;char&lt;/span&gt; data[&lt;span&gt;0&lt;/span&gt; + &lt;span&gt;32&lt;/span&gt; * &lt;span&gt;6&lt;/span&gt;];&lt;br/&gt;} _EC_SM2_PRIME_256V1 = {&lt;br/&gt;    {&lt;br/&gt;        NID_X9_62_prime_field, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    },&lt;br/&gt;    {&lt;br/&gt;        &lt;span&gt;/* no seed */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;/* p */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFE&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0x00&lt;/span&gt;, &lt;span&gt;0x00&lt;/span&gt;, &lt;span&gt;0x00&lt;/span&gt;, &lt;span&gt;0x00&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;/* a */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFE&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0x00&lt;/span&gt;, &lt;span&gt;0x00&lt;/span&gt;, &lt;span&gt;0x00&lt;/span&gt;, &lt;span&gt;0x00&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFC&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;/* b */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x28&lt;/span&gt;, &lt;span&gt;0xE9&lt;/span&gt;, &lt;span&gt;0xFA&lt;/span&gt;, &lt;span&gt;0x9E&lt;/span&gt;, &lt;span&gt;0x9D&lt;/span&gt;, &lt;span&gt;0x9F&lt;/span&gt;, &lt;span&gt;0x5E&lt;/span&gt;, &lt;span&gt;0x34&lt;/span&gt;, &lt;span&gt;0x4D&lt;/span&gt;, &lt;span&gt;0x5A&lt;/span&gt;, &lt;span&gt;0x9E&lt;/span&gt;, &lt;span&gt;0x4B&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;0xCF&lt;/span&gt;, &lt;span&gt;0x65&lt;/span&gt;, &lt;span&gt;0x09&lt;/span&gt;, &lt;span&gt;0xA7&lt;/span&gt;, &lt;span&gt;0xF3&lt;/span&gt;, &lt;span&gt;0x97&lt;/span&gt;, &lt;span&gt;0x89&lt;/span&gt;, &lt;span&gt;0xF5&lt;/span&gt;, &lt;span&gt;0x15&lt;/span&gt;, &lt;span&gt;0xAB&lt;/span&gt;, &lt;span&gt;0x8F&lt;/span&gt;, &lt;span&gt;0x92&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;0xDD&lt;/span&gt;, &lt;span&gt;0xBC&lt;/span&gt;, &lt;span&gt;0xBD&lt;/span&gt;, &lt;span&gt;0x41&lt;/span&gt;, &lt;span&gt;0x4D&lt;/span&gt;, &lt;span&gt;0x94&lt;/span&gt;, &lt;span&gt;0x0E&lt;/span&gt;, &lt;span&gt;0x93&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;/* x */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0x32&lt;/span&gt;, &lt;span&gt;0xC4&lt;/span&gt;, &lt;span&gt;0xAE&lt;/span&gt;, &lt;span&gt;0x2C&lt;/span&gt;, &lt;span&gt;0x1F&lt;/span&gt;, &lt;span&gt;0x19&lt;/span&gt;, &lt;span&gt;0x81&lt;/span&gt;, &lt;span&gt;0x19&lt;/span&gt;, &lt;span&gt;0x5F&lt;/span&gt;, &lt;span&gt;0x99&lt;/span&gt;, &lt;span&gt;0x04&lt;/span&gt;, &lt;span&gt;0x46&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;0x6A&lt;/span&gt;, &lt;span&gt;0x39&lt;/span&gt;, &lt;span&gt;0xC9&lt;/span&gt;, &lt;span&gt;0x94&lt;/span&gt;, &lt;span&gt;0x8F&lt;/span&gt;, &lt;span&gt;0xE3&lt;/span&gt;, &lt;span&gt;0x0B&lt;/span&gt;, &lt;span&gt;0xBF&lt;/span&gt;, &lt;span&gt;0xF2&lt;/span&gt;, &lt;span&gt;0x66&lt;/span&gt;, &lt;span&gt;0x0B&lt;/span&gt;, &lt;span&gt;0xE1&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;0x71&lt;/span&gt;, &lt;span&gt;0x5A&lt;/span&gt;, &lt;span&gt;0x45&lt;/span&gt;, &lt;span&gt;0x89&lt;/span&gt;, &lt;span&gt;0x33&lt;/span&gt;, &lt;span&gt;0x4C&lt;/span&gt;, &lt;span&gt;0x74&lt;/span&gt;, &lt;span&gt;0xC7&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;/* y */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0xBC&lt;/span&gt;, &lt;span&gt;0x37&lt;/span&gt;, &lt;span&gt;0x36&lt;/span&gt;, &lt;span&gt;0xA2&lt;/span&gt;, &lt;span&gt;0xF4&lt;/span&gt;, &lt;span&gt;0xF6&lt;/span&gt;, &lt;span&gt;0x77&lt;/span&gt;, &lt;span&gt;0x9C&lt;/span&gt;, &lt;span&gt;0x59&lt;/span&gt;, &lt;span&gt;0xBD&lt;/span&gt;, &lt;span&gt;0xCE&lt;/span&gt;, &lt;span&gt;0xE3&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;0x6B&lt;/span&gt;, &lt;span&gt;0x69&lt;/span&gt;, &lt;span&gt;0x21&lt;/span&gt;, &lt;span&gt;0x53&lt;/span&gt;, &lt;span&gt;0xD0&lt;/span&gt;, &lt;span&gt;0xA9&lt;/span&gt;, &lt;span&gt;0x87&lt;/span&gt;, &lt;span&gt;0x7C&lt;/span&gt;, &lt;span&gt;0xC6&lt;/span&gt;, &lt;span&gt;0x2A&lt;/span&gt;, &lt;span&gt;0x47&lt;/span&gt;, &lt;span&gt;0x40&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;0x02&lt;/span&gt;, &lt;span&gt;0xDF&lt;/span&gt;, &lt;span&gt;0x32&lt;/span&gt;, &lt;span&gt;0xE5&lt;/span&gt;, &lt;span&gt;0x21&lt;/span&gt;, &lt;span&gt;0x39&lt;/span&gt;, &lt;span&gt;0xF0&lt;/span&gt;, &lt;span&gt;0xA0&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;/* order */&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFE&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0xFF&lt;/span&gt;, &lt;span&gt;0x72&lt;/span&gt;, &lt;span&gt;0x03&lt;/span&gt;, &lt;span&gt;0xDF&lt;/span&gt;, &lt;span&gt;0x6B&lt;/span&gt;, &lt;span&gt;0x21&lt;/span&gt;, &lt;span&gt;0xC6&lt;/span&gt;, &lt;span&gt;0x05&lt;/span&gt;, &lt;span&gt;0x2B&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;0x53&lt;/span&gt;, &lt;span&gt;0xBB&lt;/span&gt;, &lt;span&gt;0xF4&lt;/span&gt;, &lt;span&gt;0x09&lt;/span&gt;, &lt;span&gt;0x39&lt;/span&gt;, &lt;span&gt;0xD5&lt;/span&gt;, &lt;span&gt;0x41&lt;/span&gt;, &lt;span&gt;0x23&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码中的order就是参数表中的 n。对于大部分ECC操作来说，不需要该值，但在计算签名的时候会对n取模。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也可以通过GmSSL查看命名曲线的参数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ gmssl ecparam -name sm2p256v1 -out sm2p256v1.pem&lt;br/&gt;$ gmssl ecparam -&lt;span&gt;in&lt;/span&gt; sm2p256v1.pem -text -param_enc explicit -noout&lt;br/&gt;Field Type: prime-field&lt;br/&gt;Prime:&lt;br/&gt;    00:ff:ff:ff:fe:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:&lt;br/&gt;    ff:ff:ff:ff:ff:ff:00:00:00:00:ff:ff:ff:ff:ff:&lt;br/&gt;    ff:ff:ff&lt;br/&gt;A:   &lt;br/&gt;    00:ff:ff:ff:fe:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:&lt;br/&gt;    ff:ff:ff:ff:ff:ff:00:00:00:00:ff:ff:ff:ff:ff:&lt;br/&gt;    ff:ff:&lt;span&gt;fc&lt;/span&gt;&lt;br/&gt;B:   &lt;br/&gt;    28:e9:fa:9e:9d:9f:5e:34:4d:5a:9e:4b:cf:65:09:&lt;br/&gt;    a7:f3:97:89:f5:15:ab:8f:92:dd:bc:bd:41:4d:94:&lt;br/&gt;    0e:93&lt;br/&gt;Generator (uncompressed):&lt;br/&gt;    04:32:c4:ae:2c:1f:19:81:19:5f:99:04:46:6a:39:&lt;br/&gt;    c9:94:8f:e3:0b:bf:f2:66:0b:e1:71:5a:45:89:33:&lt;br/&gt;    4c:74:c7:bc:37:36:a2:f4:f6:77:9c:59:bd:ce:e3:&lt;br/&gt;    6b:69:21:53:d0:a9:87:7c:c6:2a:47:40:02:df:32:&lt;br/&gt;    e5:21:39:f0:a0&lt;br/&gt;Order: &lt;br/&gt;    00:ff:ff:ff:fe:ff:ff:ff:ff:ff:ff:ff:ff:ff:ff:&lt;br/&gt;    ff:ff:72:03:df:6b:21:c6:05:2b:53:bb:f4:09:39:&lt;br/&gt;    d5:41:23&lt;br/&gt;Cofactor:  1 (0x1)&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小结&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文从非对称密码算法开始，逐步介绍到国密SM2算法。我们可以看到，SM2并不是一个全新设计的算法，而是借助现有的ECC理论，设计了一条命名曲线。这样，在已经实现了ECC算法的网络库上增加SM2算法的支持就非常简单，只需要将曲线参数添加即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一套完整的公开密码算法，更重要的作用是用于密钥交换和数字签名，在后面的文章将继续探讨这些话题，敬请关注！&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI3NTQyMzEzNQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/ibQ4mtgHYXv4tOEn4Uicn7b1ITAz13SSd95USUDHGciaIrrd3whtY0IwTvH5NXTpe0LMq5YerBI24lMw5plu7T2DA/0?wx_fmt=png&quot; data-nickname=&quot;云水木石&quot; data-alias=&quot;ourpoeticlife&quot; data-signature=&quot;生活不只是眼前的编程，还有远方的读书、跑步、旅行。谈谈人工智能，读读闲书，来场说走就走的旅行，就这样。&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibQ4mtgHYXv50C2zJtfH5icNbOicm63Mwia4EaZdIJtQDz9rJLxS6LBsVgWJXtbJIFBaAH2nzu7tBEic76fFUEphPjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b9cd0b8524a3c274f4411262ea21b7bc</guid>
<title>Java 线程的那些状态们</title>
<link>https://toutiao.io/k/fhks4c3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;346&quot; data-backw=&quot;574&quot; data-croporisrc=&quot;https://mp.weixin.qq.com/cgi-bin/photogalleryproxy?action=proxy&amp;amp;url=https%3A%2F%2Fpixabay.com%2Fget%2Fg8559b59c705f5d71e4ecad6cf0c3932fd38abfce9e734a0ebe3dd0ad2669927045b97d31e2e6df208473fdf2d78b2ea8ac19fd6c10232df2fba260841eb017d6_1280.jpg%3Fpermalink&amp;amp;supplier=4&amp;amp;from_public_pic=1&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;1280&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;773.7979094076654&quot; data-ratio=&quot;0.603125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jOD3PUUxTibMuUInUIJZDQv2ZvK6SPXg1WbibwXE3Sfa088bquwibm8fsy1SsGnz1VuD2icnKu9VIVpPQUmmNnEa0Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;p&gt;Java线程（或者说计算机线程），是有一些状态来表示当前线程运行信息的，可以通过jsatck命令来查看Java进程中线程函数栈信息，其中就包括了Java线程状态。&lt;/p&gt;&lt;p&gt;在分析Java线程状态之前，我们先来看下进程、线程、协程这些概念之间的区别：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;对于开发小伙伴来讲，了解Java线程状态，有利于加深对线程的理解，有助于解决线程死锁、线程阻塞等问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Java Thread类型的&lt;code&gt;State&lt;/code&gt;枚举就定义了如下6种线程状态，这些状态之间会进行切换直到线程终止为止，类似于状态机流转。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt; State {&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Thread state for a thread which has not yet started.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    NEW,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Thread state for a runnable thread.  A thread in the runnable&lt;br/&gt;     * state is executing in the Java virtual machine but it may&lt;br/&gt;     * be waiting for other resources from the operating system&lt;br/&gt;     * such as processor.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    RUNNABLE,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Thread state for a thread blocked waiting for a monitor lock.&lt;br/&gt;     * A thread in the blocked state is waiting for a monitor lock&lt;br/&gt;     * to enter a synchronized block/method or&lt;br/&gt;     * reenter a synchronized block/method after calling&lt;br/&gt;     * {&lt;span&gt;@link&lt;/span&gt; Object#wait() Object.wait}.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    BLOCKED,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Thread state for a waiting thread.&lt;br/&gt;     * A thread is in the waiting state due to calling one of the&lt;br/&gt;     * following methods:&lt;br/&gt;     * &amp;lt;ul&amp;gt;&lt;br/&gt;     *   &amp;lt;li&amp;gt;{&lt;span&gt;@link&lt;/span&gt; Object#wait() Object.wait} with no timeout&amp;lt;/li&amp;gt;&lt;br/&gt;     *   &amp;lt;li&amp;gt;{&lt;span&gt;@link&lt;/span&gt; #join() Thread.join} with no timeout&amp;lt;/li&amp;gt;&lt;br/&gt;     *   &amp;lt;li&amp;gt;{&lt;span&gt;@link&lt;/span&gt; LockSupport#park() LockSupport.park}&amp;lt;/li&amp;gt;&lt;br/&gt;     * &amp;lt;/ul&amp;gt;&lt;br/&gt;     *&lt;br/&gt;     * &amp;lt;p&amp;gt;A thread in the waiting state is waiting for another thread to&lt;br/&gt;     * perform a particular action.&lt;br/&gt;     *&lt;br/&gt;     * For example, a thread that has called &amp;lt;tt&amp;gt;Object.wait()&amp;lt;/tt&amp;gt;&lt;br/&gt;     * on an object is waiting for another thread to call&lt;br/&gt;     * &amp;lt;tt&amp;gt;Object.notify()&amp;lt;/tt&amp;gt; or &amp;lt;tt&amp;gt;Object.notifyAll()&amp;lt;/tt&amp;gt; on&lt;br/&gt;     * that object. A thread that has called &amp;lt;tt&amp;gt;Thread.join()&amp;lt;/tt&amp;gt;&lt;br/&gt;     * is waiting for a specified thread to terminate.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    WAITING,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Thread state for a waiting thread with a specified waiting time.&lt;br/&gt;     * A thread is in the timed waiting state due to calling one of&lt;br/&gt;     * the following methods with a specified positive waiting time:&lt;br/&gt;     * &amp;lt;ul&amp;gt;&lt;br/&gt;     *   &amp;lt;li&amp;gt;{&lt;span&gt;@link&lt;/span&gt; #sleep Thread.sleep}&amp;lt;/li&amp;gt;&lt;br/&gt;     *   &amp;lt;li&amp;gt;{&lt;span&gt;@link&lt;/span&gt; Object#wait(long) Object.wait} with timeout&amp;lt;/li&amp;gt;&lt;br/&gt;     *   &amp;lt;li&amp;gt;{&lt;span&gt;@link&lt;/span&gt; #join(long) Thread.join} with timeout&amp;lt;/li&amp;gt;&lt;br/&gt;     *   &amp;lt;li&amp;gt;{&lt;span&gt;@link&lt;/span&gt; LockSupport#parkNanos LockSupport.parkNanos}&amp;lt;/li&amp;gt;&lt;br/&gt;     *   &amp;lt;li&amp;gt;{&lt;span&gt;@link&lt;/span&gt; LockSupport#parkUntil LockSupport.parkUntil}&amp;lt;/li&amp;gt;&lt;br/&gt;     * &amp;lt;/ul&amp;gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    TIMED_WAITING,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * Thread state for a terminated thread.&lt;br/&gt;     * The thread has completed execution.&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    TERMINATED;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这些Java线程状态图如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jOD3PUUxTibMuUInUIJZDQv2ZvK6SPXg1FY3Zl18upPOj5RIDRYnHLpz5qvTmZfQh0Kr8VFZSia9dznJDo9a1AfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;注意，RUNNABLE状态时的线程不一定就是RUNNING的，有可能CPU还在执行其他线程而没有调度到该线程。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;我们知道了Java层面对于线程状态的几种定义，那么Java/JDK底层是基于什么机制来实现线程管理的呢&lt;/strong&gt;？下面咱们写个示例Demo进行分析：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@SuppressWarnings&lt;/span&gt;(&lt;span&gt;&quot;all&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MainDemo&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Object obj1 = &lt;span&gt;new&lt;/span&gt; Object();&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Lock lock = &lt;span&gt;new&lt;/span&gt; ReentrantLock();&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                LockSupport.park();&lt;br/&gt;            }&lt;br/&gt;        }, &lt;span&gt;&quot;t1&quot;&lt;/span&gt;).start();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                LockSupport.park(TimeUnit.DAYS.toNanos(&lt;span&gt;1&lt;/span&gt;));&lt;br/&gt;            }&lt;br/&gt;        }, &lt;span&gt;&quot;t2&quot;&lt;/span&gt;).start();&lt;br/&gt;&lt;br/&gt;        lock.lock();&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                lock.lock();&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;zzz222&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        }, &lt;span&gt;&quot;t3&quot;&lt;/span&gt;).start();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    Thread.sleep(&lt;span&gt;1000000000&lt;/span&gt;);&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;                    e.printStackTrace();&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;        }, &lt;span&gt;&quot;t4&quot;&lt;/span&gt;).start();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;synchronized&lt;/span&gt; (obj1) {&lt;br/&gt;            &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt; Runnable() {&lt;br/&gt;                &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;run&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;synchronized&lt;/span&gt; (obj1) {&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;zzz&quot;&lt;/span&gt;);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }, &lt;span&gt;&quot;t5&quot;&lt;/span&gt;).start();&lt;br/&gt;&lt;br/&gt;            Thread.sleep(&lt;span&gt;1000000000&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上述代码起了5个子线程，名字分别是t1、t2到t5，其中t1执行&lt;code&gt;LockSupport.park()&lt;/code&gt;阻塞，t2执行&lt;code&gt;LockSupport.park(long)&lt;/code&gt;阻塞，t3执行&lt;code&gt;lock.lock()&lt;/code&gt;阻塞，t4执行&lt;code&gt;Thread.sleep()&lt;/code&gt;阻塞，t5执行&lt;code&gt;synchronized(obj)&lt;/code&gt;阻塞。&lt;/p&gt;&lt;p&gt;通过&lt;code&gt;jstack&lt;/code&gt;命令可以查看Java线程栈，如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.175&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jOD3PUUxTibMuUInUIJZDQv2ZvK6SPXg1lJvM1INuyODHOBk9k3gicHX8WicLj2Ppr9O0NHrQ6FdSk0bpnKd7woibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;但是它不能看到JDK和系统层面的线程栈，此时可以通过&lt;code&gt;pstack命令&lt;/code&gt;来查看，如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.35234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jOD3PUUxTibMuUInUIJZDQv2ZvK6SPXg1hichxA9lDl1EQnTj74g9eoAOU8j63IVnPs4bpSR3hsBoRFnJibdAASbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;那么Java线程栈怎么和系统层线程栈关联起来呢&lt;/strong&gt;？这个时候可以通过Java线程栈中nid（十六进制）和系统层线程栈中LWP是否相等关联起来。比如t1线程的线程栈如下所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jOD3PUUxTibMuUInUIJZDQv2ZvK6SPXg1OSyibDoaNUDfM1uFmOngJQMGg9T3QpT1mZ7WzOiaDqlIFJH6sKssC4Vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;通过对t1-t5线程栈进行分析，这些线程都处于&lt;em&gt;TIMED_WAITING&lt;/em&gt;或者&lt;em&gt;WAITING&lt;/em&gt;状态，它们的JDK层面都是走到了方法&lt;code&gt;pthread_cond_wait&lt;/code&gt;或&lt;code&gt;pthread_cond_timedwait&lt;/code&gt;，而这些就是系统层pthread库中方法了，对于学过 Linux C 的同学肯定都不会陌生。感兴趣的同学可以按照上面的命令查看下所有线程的整个线程栈信息。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-style-type=&quot;2&quot; data-tools=&quot;新媒体排版&quot; data-id=&quot;8633&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt; 推荐阅读 &lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;figure&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a3a664b4f9f9929c72dc41fa6f7e0cac</guid>
<title>优雅停机之主动从 Nacos 下线实例</title>
<link>https://toutiao.io/k/5reyhwy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;问题场景&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.245260663507109&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/RMOHqs13Zw0MOd6WbMF6w3iaCJUCUHFzVEpOQ77SOs0AjpKUkibOiabLthZbnx17sgVPJ7QJW3WIk8zYeVS3dG76w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1688&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务提供方采用了 SpringCloud Alibaba 框架，将服务注册到 Nacos 上，部署采用的是 k8s + docker 容器部署。当服务升级发布时，新的 pod 被创建——Nacos 上服务实例加 1，旧的 pod 被关闭——Nacos 上服务实例减 1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nacos 通过心跳检测机制，将旧的 pod 实例下线。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在关闭旧的 pod 到下线 pod 之间，存在一定的时间差，导致服务消费方调用接口会发生报错的情况，对业务操作造成一定影响。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;向 Nacos 上注册服务实例流程&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Spring Cloud Nacos Discovery 遵循了 spring cloud common 标准，实现了 &lt;code&gt;AutoServiceRegistration&lt;/code&gt;、&lt;code&gt;ServiceRegistry&lt;/code&gt;、&lt;code&gt;Registration&lt;/code&gt; 这三个接口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于 2.0.0 版本，源码分析如下。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1、入口 NacosServiceRegistry.&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;AbstractAutoServiceRegistration&lt;/code&gt; 中执行 &lt;code&gt;serviceRegistry.register(registration)&lt;/code&gt;，注册实现在 &lt;code&gt;NacosServiceRegistry.register()&lt;/code&gt; 方法中，关键代码如下。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String serviceId = registration.getServiceId();&lt;br/&gt;String group = this.nacosDiscoveryProperties.getGroup();&lt;br/&gt;Instance instance = this.getNacosInstanceFromRegistration(registration);&lt;br/&gt;this.namingService.registerInstance(serviceId, group, instance);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、NacosNamingService&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;NacosNamingService&lt;/code&gt; 关键代码，主要逻辑是添加心跳检测和注册。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public void registerInstance(String serviceName, String groupName, Instance instance)  {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (instance.isEphemeral()) {&lt;br/&gt;            BeatInfo beatInfo = new BeatInfo();&lt;br/&gt;            beatInfo.setServiceName(NamingUtils.getGroupedName(serviceName, groupName));&lt;br/&gt;            beatInfo.setIp(instance.getIp());&lt;br/&gt;            beatInfo.setPort(instance.getPort());&lt;br/&gt;            beatInfo.setCluster(instance.getClusterName());&lt;br/&gt;            beatInfo.setWeight(instance.getWeight());&lt;br/&gt;            beatInfo.setMetadata(instance.getMetadata());&lt;br/&gt;            beatInfo.setScheduled(&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;            long instanceInterval = instance.getInstanceHeartBeatInterval();&lt;br/&gt;            beatInfo.setPeriod(instanceInterval == 0L ? DEFAULT_HEART_BEAT_INTERVAL : instanceInterval);&lt;br/&gt;            this.beatReactor.addBeatInfo(NamingUtils.getGroupedName(serviceName, groupName), beatInfo);&lt;br/&gt;        }&lt;br/&gt;        this.serverProxy.registerService(NamingUtils.getGroupedName(serviceName, groupName), groupName, instance);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3、NamingProxy&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;serverProxy.registerService()&lt;/code&gt; 中组装参数通过 HTTP 调用 API。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public void registerService(String serviceName, String groupName, Instance instance) throws NacosException {&lt;br/&gt;        LogUtils.NAMING_LOGGER.info(&lt;span&gt;&quot;[REGISTER-SERVICE] {} registering service {} with instance: {}&quot;&lt;/span&gt;, new Object[]{this.namespaceId, serviceName, instance});&lt;br/&gt;        Map&amp;lt;String, String&amp;gt; params = new HashMap(9);&lt;br/&gt;        params.put(&lt;span&gt;&quot;namespaceId&quot;&lt;/span&gt;, this.namespaceId);&lt;br/&gt;        params.put(&lt;span&gt;&quot;serviceName&quot;&lt;/span&gt;, serviceName);&lt;br/&gt;        params.put(&lt;span&gt;&quot;groupName&quot;&lt;/span&gt;, groupName);&lt;br/&gt;        params.put(&lt;span&gt;&quot;clusterName&quot;&lt;/span&gt;, instance.getClusterName());&lt;br/&gt;        params.put(&lt;span&gt;&quot;ip&quot;&lt;/span&gt;, instance.getIp());&lt;br/&gt;        params.put(&lt;span&gt;&quot;port&quot;&lt;/span&gt;, String.valueOf(instance.getPort()));&lt;br/&gt;        params.put(&lt;span&gt;&quot;weight&quot;&lt;/span&gt;, String.valueOf(instance.getWeight()));&lt;br/&gt;        params.put(&lt;span&gt;&quot;enable&quot;&lt;/span&gt;, String.valueOf(instance.isEnabled()));&lt;br/&gt;        params.put(&lt;span&gt;&quot;healthy&quot;&lt;/span&gt;, String.valueOf(instance.isHealthy()));&lt;br/&gt;        params.put(&lt;span&gt;&quot;ephemeral&quot;&lt;/span&gt;, String.valueOf(instance.isEphemeral()));&lt;br/&gt;        params.put(&lt;span&gt;&quot;metadata&quot;&lt;/span&gt;, JSON.toJSONString(instance.getMetadata()));&lt;br/&gt;        this.reqAPI(UtilAndComs.NACOS_URL_INSTANCE, params, (String)&lt;span&gt;&quot;POST&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从 Nacos 下线服务实例流程&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过心跳检测，Nacos 发现实例不存在后，自动下线掉此实例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;NacosNamingService&lt;/code&gt; 同时提供了主动下线的接口，代码如下。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public void deregisterInstance(String serviceName, String groupName, String ip, int port, String clusterName) throws NacosException {&lt;br/&gt;        Instance instance = new Instance();&lt;br/&gt;        instance.setIp(ip);&lt;br/&gt;        instance.setPort(port);&lt;br/&gt;        instance.setClusterName(clusterName);&lt;br/&gt;        this.deregisterInstance(serviceName, groupName, instance);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中处理逻辑是去除客户端心跳检测和下线。deregisterService 与 registerService 逻辑相仿，组装参数通过 HTTP 调用执行下线。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public void deregisterInstance(String serviceName, String groupName, Instance instance) throws NacosException {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (instance.isEphemeral()) {&lt;br/&gt;            this.beatReactor.removeBeatInfo(NamingUtils.getGroupedName(serviceName, groupName), instance.getIp(), instance.getPort());&lt;br/&gt;        }&lt;br/&gt;        this.serverProxy.deregisterService(NamingUtils.getGroupedName(serviceName, groupName), instance);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;容器优雅停机方式&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nacos 客户端提供了下线接口，就可以封装一个应用系统的接口来执行下线。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@GetMapping(value = &lt;span&gt;&quot;/api/nacos/deregister&quot;&lt;/span&gt;)&lt;br/&gt;    public String &lt;span&gt;&lt;span&gt;deregisterInstance&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;        String serviceName = nacosDiscoveryProperties.getService();&lt;br/&gt;        String groupName = nacosDiscoveryProperties.getGroup();&lt;br/&gt;        String clusterName = nacosDiscoveryProperties.getClusterName();&lt;br/&gt;        String ip = nacosDiscoveryProperties.getIp();&lt;br/&gt;        int port = nacosDiscoveryProperties.getPort();&lt;br/&gt;        log.info(&lt;span&gt;&quot;deregister from nacos, serviceName:{}, groupName:{}, clusterName:{}, ip:{}, port:{}&quot;&lt;/span&gt;, serviceName, groupName, clusterName, ip, port);&lt;br/&gt;        try {&lt;br/&gt;            nacosRegistration.getNacosNamingService().deregisterInstance(serviceName, groupName, ip, port, clusterName);&lt;br/&gt;        } catch (NacosException e) {&lt;br/&gt;            log.error(&lt;span&gt;&quot;deregister from nacos error&quot;&lt;/span&gt;, e);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;error&quot;&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;success&quot;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Pod 关闭前设置一个 preStop 钩子，在 preStop 脚本中执行主动从 Nacos 下线本机实例， sleep 25 秒后再执行 Pod 的销毁，从而实现优雅停机。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# 调用从nacos下线接口&lt;/span&gt;&lt;br/&gt;curl http://localhost:8081/api/nacos/deregister&lt;br/&gt;&lt;span&gt;# 延迟发送关闭信号到容器进程&lt;/span&gt;&lt;br/&gt;sleep 25&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>