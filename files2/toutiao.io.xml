<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>26ec005047116a0084b3beac8b638e2c</guid>
<title>闯过这 54 关，点亮你的 Git 技能树</title>
<link>https://toutiao.io/k/6kqnm2d</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;card-body markdown markdown-toc&quot;&gt;
        
        &lt;p&gt;&lt;img src=&quot;https://file.codingstyle.cn/photo/2021/36eaf186-6a61-427b-8972-04c65a57ad07.png!large&quot; title=&quot;&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;开篇&quot;&gt;开篇&lt;/h2&gt;
&lt;p&gt;如今，Git 大行其道，颇有一统天下之势。
如果你的技能树上 Git 和 Github 的图标还没有点亮的话，你都不好意思说你是程序员。
别说互联网企业，我接触到的许多传统企业都在从 SVN，Clear Case 等迁移到 Git 上，甚至大厂还会有一个团队去定制适合自己企业的 Git 服务器。&lt;/p&gt;

&lt;p&gt;很多人简历上写的「精通 Git 与 Github」，但如果你问他熟悉到什么程度的话，回答通常是「就是会用常用的 add，commit，push 操作」。&lt;/p&gt;

&lt;p&gt;但工作中我们会遇到一些更加复杂的场景：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;忽略某些文件&lt;/li&gt;
&lt;li&gt;创建，删除分支&lt;/li&gt;
&lt;li&gt;找到最后修改某行代码的人&lt;/li&gt;
&lt;li&gt;commit 后发现里边包含一个不应该提交的文件&lt;/li&gt;
&lt;li&gt;commit 后发现少提交了一些文件&lt;/li&gt;
&lt;li&gt;一个文件中的多次有改动，怎么做到只提交其中的一部分？&lt;/li&gt;
&lt;li&gt;怎样整理提交记录使其更加整洁？&lt;/li&gt;
&lt;li&gt;快速定位是哪一次提交引入了 bug&lt;/li&gt;
&lt;li&gt;...
作为一线程序员，我们要如何快速学习 Git 以发挥其最大威力呢？&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今天我就要向大家介绍一个工具，准确说应该是「游戏」，名字叫「githug」，它把平常可能遇到的一些场景都实例化，变成一个一个的关卡，一共有 55 个关卡：&lt;/p&gt;
&lt;pre class=&quot;highlight plaintext&quot;&gt;&lt;code&gt;#1: init
#2: config
#3: add
#4: commit
#5: clone
#6: clone_to_folder
#7: ignore
#8: include
#9: status
#10: number_of_files_committed
#11: rm
#12: rm_cached
#13: stash
#14: rename
#15: restructure
#16: log
#17: tag
#18: push_tags
#19: commit_amend
#20: commit_in_future
#21: reset
#22: reset_soft
#23: checkout_file
#24: remote
#25: remote_url
#26: pull
#27: remote_add
#28: push
#29: diff
#30: blame
#31: branch
#32: checkout
#33: checkout_tag
#34: checkout_tag_over_branch
#35: branch_at
#36: delete_branch
#37: push_branch
#38: merge
#39: fetch
#40: rebase
#41: repack
#42: cherry-pick
#43: grep
#44: rename_commit
#45: squash
#46: merge_squash
#47: reorder
#48: bisect
#49: stage_lines
#50: find_old_branch
#51: revert
#52: restore
#53: conflict
#54: submodule
#55: contribute
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;首先我们需要来安装这个游戏，「githug」是用 Ruby 编写的，可通过如下命令安装：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;gem install githug&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果遇到权限问题，请加上 sudo：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;sudo gem install githug&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;安装成功后，在 Terminal 里进入你常用的目录，输入 githug，会提示游戏目录不存在，是否要创建一个，输入 y 然后回车：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://file.codingstyle.cn/photo/2021/33bb1b0e-b9bc-4c91-9930-f89aa1432273.png!large&quot; title=&quot;&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;根据提示&lt;code&gt;cd git_hug&lt;/code&gt; 进入游戏目录，准备开始游戏。&lt;/p&gt;
&lt;h2 id=&quot;基本命令&quot;&gt;基本命令&lt;/h2&gt;
&lt;p&gt;在开始前我们还需要了解游戏的一些基本操作：&lt;/p&gt;

&lt;p&gt;play - 默认命令，检查是否过关
hint - 显示过关提示
reset - 重启本关，或者重启到指定的某关
levels - 显示关卡列表
来试一下，githug reset：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://file.codingstyle.cn/photo/2021/05f415e3-0be9-4e00-bca0-daf954e4c5f1.png!large&quot; title=&quot;&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;示例&lt;/h2&gt;
&lt;p&gt;我以第一关为例子给大家演示一下玩法。&lt;/p&gt;

&lt;p&gt;第一关的名称是：init，提示是：「一个新目录 git_hug 被创建了，请把它初始化为一个空仓库」。
假设现在我不知道该怎么过关，我可以查看过关提示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://file.codingstyle.cn/photo/2021/da0dc920-1714-4909-bbdd-85446d4c4c48.png!large&quot; title=&quot;&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;指示是：「你可以输入 git 命令来查看 git 命令列表」。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://file.codingstyle.cn/photo/2021/00b90da9-0f2e-429f-83c7-499d9dee0f5c.png!large&quot; title=&quot;&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;看最后一行，原来用 git init 就可以初始化一个空仓库，接着输入 githug 进行过关检测：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://file.codingstyle.cn/photo/2021/a2d14c4f-8586-4c20-b9cf-ec948a2eb427.png!large&quot; title=&quot;&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;太棒了！顺利进入第二关！&lt;/p&gt;

&lt;p&gt;怎么样？明白了吗？后面的 54 关就靠你自己了哦！&lt;/p&gt;
&lt;h2 id=&quot;友情提示&quot;&gt;友情提示&lt;/h2&gt;
&lt;p&gt;在闯关过程中，尽量使用 githug hint，git help subcommand 获取帮助，也可以根据下面的教程来系统学习：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://backlog.com/git-tutorial/cn/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot; title=&quot;&quot;&gt;猴子都能懂的 git 入门&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;为保大家都能顺利通关，学到所有的知识点，接下来我会写过关攻略，详细介绍每一关的玩法。&lt;/p&gt;

&lt;p&gt;并且我不会直接给答案，而是演示整个过关的过程。&lt;/p&gt;
        &lt;blockquote&gt;&lt;p&gt;&lt;a href=&quot;http://codingstyle.cn&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;「软件匠艺社区」&lt;/a&gt;旨在传播匠艺精神，通过分享好的「工作方式」，让帮助程序员更加快乐高效地编程！&lt;/p&gt;&lt;/blockquote&gt;
      &lt;/div&gt;
      &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1f8f0626936d4d1564dc16821f3e3a26</guid>
<title>Kubernetes 原生 CI/CD 构建框架 Argo 详解</title>
<link>https://toutiao.io/k/y0ieaw4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;K8sMeetup&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;什么是流水线？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在计算机中，&lt;strong&gt;流水线是把一个重复的过程分解为若干个子过程，使每个子过程与其他子过程并行进行的技术，也叫 Pipeline&lt;/strong&gt;。由于这种 s工作方式与工厂中的生产流水线十分相似， 因此也被称为流水线技术。从本质上讲，流水线技术是一种时间并行技术。&lt;/span&gt;&lt;span&gt;以“构建镜像”过程为例：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;327&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5658914728682171&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;645&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMM9eqKTwE2s4z6umicS2icRp5DUZK4glnxT5QMsbemEv5xvUz8U3GeymWEJUusTEWtOYBGcWu2hMT4w/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在每一次构建镜像中，我们都需要拉下代码仓库中的代码，进行代码编译，构建镜像，最后推往镜像仓库。在每一次代码更改过后，这一过程都是不变的。使用流水线工具可以极大的提升这一过程的效率，只需要进行简单的配置便可以轻松的完成重复性的工作。这样的过程也被称之为 CI。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;上图流程中使用的是 Jenkins。Jenkins 作为老牌流水线框架被大家所熟知。在云原生时代，Jenkins 推出了 Jenkins X 作为基于 Kubernetes 的新一代流水线，另外云原生时代还&lt;/span&gt;&lt;span&gt;诞生了两大流水线框架—— Argo 和 Tekton。本文就详细介绍了 Argo 的相关内容。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3ODAzMTMyNQ==&amp;amp;mid=2247488127&amp;amp;idx=1&amp;amp;sn=c00dd13b0baa973d3c0a2cb1d27ae7cd&amp;amp;chksm=cf18aacdf86f23db7bb47ef05878b83cbcdbd938e1db5db0f165ee2a62e04b85c6b54e50b2b0&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《Kubernetes 原生 CI/CD 构建框架 Tekton 详解！》&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《Kubernetes 原生 CI/CD 构建框架 Tekton 详解！》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;详细介绍了 Tekton 的相关内容。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;K8sMeetup&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Argo&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Argo Workflows 是一个开源的容器原生的工作流引擎，可在 Kubernetes 上编排并行作业。Argo Workflows 实现为 Kubernetes CRD。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;K8sMeetup&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Quick Start&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Argo 基于 Kubernetes，可以直接使用 kubectl 安装，安装的组件主要包括了一些 CRD 以及对应的 controller 和一个 server。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;64&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.11015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUgZV43ymX225cm9qFslKLghVRNjmWPOB90wpqHia0GXxTrezlFkYwHxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;注意，上述安装只会执行同 namespace 内的 Workflow，cluster install 详见文档。文档地址：&lt;/span&gt;&lt;span&gt;https://github.com/argoproj/argo/blob/master/docs/installation.md&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;K8sMeetup&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;三级定义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;要了解 Argo 定义的 CRD，先从其中的三级定义入手。概念上的从大到小分别为 WorkflowTemplate、Workflow、template，这些资源的命名有些相似，要注意分辨。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Template&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;从最简单的 template 说起，&lt;/span&gt;&lt;strong&gt;&lt;span&gt;一个 template 有多种类型，分别为 container、script、dag、ste&lt;/span&gt;&lt;span&gt;ps、resource 以及 suspend。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;对于 template，我们可以简单的将其理解为一个 Pod ——container/script/resource 类型的 template 都会去实际控制一个 Pod，而 dag/steps 类型的 template 则是由多个基础类型的 template （container/script/resource）组成的。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;container&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：最常见的模板类型，与 Kubernetes container spec 保持一致。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;script&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：该类型基于 Container，支持用户在 template 定义一段脚本，另有一个 Source 字段来表示脚本的运行环境。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;resource&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：该类型支持我们在 template 中对 kubernetes 的资源进行操作，有一个 action 字段可以指定操作类型，如 create, apply, delete 等，并且支持设定相关的成功与失败条件用于判断该 template 的成功与失败。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;suspend&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Suspend template 将在一段时间内或在手动恢复执行之前暂停执行。可以从 CLI （使用 argo resume）、API 或 UI 恢复执行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;steps&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：Steps Template 允许用户以一系列步骤定义任务。在 Steps 中，[--] 代表顺序执行，[-] 代表并行执行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;dag&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：DAG template 允许用户将任务定义为带依赖的有向无环图。在 DAG 中，通过 dependencies设置在特定任务开始之前必须完成的其他任务。没有任何依赖项的任务将立即运行。有关 DAG 的详细逻辑可见源码 &lt;/span&gt;&lt;span&gt;https://github.com/argoproj/argo/blob/master/workflow/controller/dag.go#L204&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Workflow&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在一个 Workflow 中，其 spec 中有一个名为 templates 的字段，在其中至少需要一个 template 作为其组成的任务。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;一个最简单的 hello world 例子如下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;359&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.6213921901528013&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqU6BDxlSO4y8M6fuiaAQO1p5qRag8WaibAsrAmnRDNud3khMaia5BHgatyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1178&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在这个例子中，该 Workflow 的 templates 字段中指定了一个类型为 container 的 template，使用了 whalesay 镜像。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下面是一个稍微复杂的 workflow：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.97421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUkJiatZ1kHYzMv6DH8dZCNJMVq2p9Pw08a1oYpDlHtnTqEEDOEE4iau6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;563&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;WorkflowTemplate&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;WorkflowTemplate &lt;/span&gt;相当于 Workflow 的模板库，和 Workflow 一样，也由 template 组成。用户在创建完 WorkflowTemplate 后，可以通过直接提交它们来执行 Workflow。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8388278388278388&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUV66EdLqfJOLGKTmoMs9xRRoJsibu2v8BrRUu6oV7jpvs054DD5lJZkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1092&quot; data-backw=&quot;578&quot; data-backh=&quot;485&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Workflow Overview&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7647058823529411&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUbr2aIupELvQqZ1qibplicqxspEvZnySj3yL1thgExtIKiaJrXWrhNLS3g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1020&quot; data-backw=&quot;578&quot; data-backh=&quot;442&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在了解了 Argo 的三级定义后，我们首先来深入一下 Argo 中最为关键的定义，Workflow。&lt;strong&gt;Workflow 是 Argo 中最重要的资源，有两个重要的功能：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于这些双重职责，Workflow 应该被视为一个 Active 的对象。它不仅是一个静态定义，也是上述定义的一个“实例”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Workflow Template 的定义与 Workflow 几乎一致，除了类型不同。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;正因为 Workflow 既可以是一个定义也可以是一个实例，所以才需要 WorkflowTemplate 作为 Workflow 的模板，WorkflowTemplate 在定义后可以通过提交（Submit）来创建一个 Workflow。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;而 Workflow 由一个 entrypoint 及一系列 template 组成，entrypoint 定义了这个 workflow 执行的入口，而 template 会实际去执行一个 Pod，其中，用户定义的内容会在 Pod 中以 Main Container 体现。此外，还有两个 Sidecar 来辅助运行。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;K8sMeetup&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Sidecar&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在 Argo 中，这些 Sidecar 的镜像都是 argoexec。Argo 通过这个 executor 来完成一些流程控制。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Init&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当用户的 template 中需要使用到 inputs 中的 artifact 或者是 script 类型时（script 类型需要注入脚本），Argo 都会为这个 pod 加上一个 Init Container —— 其镜像为 argoexec，命令是 argoexec init。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在这个 Init Container 中，主要工作就是加载 artifact：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9744680851063829&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqU34T931kQS27RW9W3IdZ6v9bwVT2qJuZwV3vO7t3MSvUcXoG17h22pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;940&quot; data-backw=&quot;578&quot; data-backh=&quot;563&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Wait&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;除了 Resource 类型外的 template，Argo 都会注入一个 Wait Container，用于等待 Main Container 的完成并结束所有 Sidecar。这个 Wait Container 的镜像同样为 argoexec，命令是 argoexec wait。（Resource 类型的不需要是因为 Resource 类型的 template 直接使用 argoexec 作为 Main Container 运行）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;868&quot; data-backw=&quot;578&quot; data-ratio=&quot;1.50234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUCyRCK9vSYDT7LlfESmcedeBgUN53BJAYKibEYcXl7kRff5vAsPKWGvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;K8sMeetup&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Inputs and Outputs&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在运行 Workflow 时，一个常见的场景是输出产物的传递。通常，一个 Step 的输出产物可以用作后续步骤的输入产物。&lt;strong&gt;在 Argo 中，产物可以通过 Artifact 或是 Parameter 传递。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Artifact&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;要使用 Argo 的 Artifact，首先必须配置和使用 Artifact 存储仓库。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;具体的配置方式可以通过修改存有 Artifact Repository 信息的默认 Config Map 或者在 Workflow 中显示指定，详见 配置文档，在此不做赘述。下表为 Argo 支持的仓库类型。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;325&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUebOU4jGnfpBcF4AZ7t4doKNOMoNPxWftPDkrCu36ekN0ZhRMBLcwhA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;一个简单的使用了 Artifact 的例子如下：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.190625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqULprIzymW8BibVkGeQV8OvgZoeqDbR9B7jYCcc6nRXX7kMOicUBibjvJ2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;688&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;默认情况下，Artifact 被打包为 tar 包和 gzip 包，我们也可以使用 archive 字段指定存档策略。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在上面的例子里，名为 whalesay 的 template 使用 cowsay 命令生成一个名为 /tmp/hello-world.txt 的文件，然后将该文件作为一个名为 hello-art 的 Artifact 输出。名为 print-message 的 template 接受一个名为 message 的输入 Artifact，在 /tmp/message 的路径上解包它，然后使用 cat 命令打印 /tmp/message 的内容。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在前面 Sidecar 介绍中提到过，&lt;strong&gt;Init Container 主要用于拉取 Artifact 产物&lt;/strong&gt;。这些 Sidecar 正是产物传递的关键。下面，我们通过介绍另一种产物传递的方式来体验 Argo 中传递产物的关键。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Scripts&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;先来看一个简单的例子：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9859375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUHMHZicAEOwGVclLwVia9aroJSkyeNYIbD9g1P4LibIEGClCQIgYr8vKKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;570&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在上面的例子中，有两个类型为 script 的 template，script 允许使用 source 规范脚本主体。这将创建一个包含脚本主体的临时文件，然后将临时文件的名称作为最后一个参数传递给 command（执行脚本主体的解释器），这样便可以方便的执行不同类型的脚本（bash、python、js etc）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Script template 会将脚本的标准输出分配给一个名为 result 的特殊输出参数从而被其他 template 调用。在这里，通过 {{steps.generate.outputs.result}} 即可获取到名为 generate 的 template 的脚本输出。&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;{{xxx}} 是 Argo 固定的变量替换格式：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;关于变量的格式详见文档，文档地址：&lt;/span&gt;&lt;span&gt;https://github.com/argoproj/argo/blob/master/docs/variables.md&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;关于变量替换的逻辑详见源码，源码地址：&lt;/span&gt;&lt;span&gt;https://github.com/argoproj/argo/blob/master/workflow/common/util.go#L305&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;那么，容器内部应该如何获取这个脚本输出呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们回到 Sidecar，在 Wait Container 中，有这样一段逻辑：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.8734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUxFATxLXYl77wzhvebRUTORnyxfcCksxsibKWEu2yUGs6HOkj2WJrGOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;505&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3484375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqU71Yv4U9n7L7wV9XianjnjYxK7dia7p2YUPgVaCJoK6D5A7IW9Uicm9eyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;201&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;再来看看这个 Wait Container 的 Volume Mount 情况：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUxIbWNUutHohzfXdEkdkzYkKPcFHKzWGx5r6KDFk6VeqAiaSviap5r6jQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;261&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;现在就十分明确了，&lt;strong&gt;Wait Container 通过挂载 docker.sock 以及 service account，获取到 Main Container 中的输出结果，并保存到 Workflow 中&lt;/strong&gt;。当然，因为 Workflow 中保存了大量的信息，当一个 Workflow 的 Step 过多时，整个 Workflow 的结构会过于庞大。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Parameter&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Parameter 提供了一种通用机制，可以将步骤的结果用作参数。&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;Parameter 的工作原理与脚本结果类似，除了输出参数的值会被设置为生成文件的内容，而不是 stdout 的内容。如：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUtaCwVj9Iwr0yG4fWOOVazfW3gIFj6ENblOhQj8D7fK3ElzU8U3hqmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;181&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Volume&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这并不是 Argo 处理产物传递的一种标准方式，但是通过共享存储，我们显然也能达到共通产物的结果。当然，如果使用 Volume，我们则无需借助 Inputs 和 Outputs。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在 Workflow 的 Spec 中，我们定义一个 Volume 模板：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUEJzRK8flqgicwiaz1TKCo1xk9dibrBicWPPMKW7VZZV3OQIm5ib9nH4wYJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;210&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;并在其他的 template 中 mount 该 volume：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqU1aLGMTFNoZbAkXgIpibKz9lJ2IjibybichfwTzV9Yuj2f19KnxFZo09vw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;155&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;K8sMeetup&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;其他流程控制功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;循环&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在编写 Workflow 时，能够循环迭代一组输入通常是非常有用的，如下例所示:&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUK7JKyraKlJe5iaVvhngK3SpiaLj2ftPgPsxURwdvfo3JSEj2TaEYYu4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;205&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在源码实现中，将会去判断 withItems，如果存在，则对其中的每个元素进行一次 step 的扩展。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.71640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUMAvK3nACFX6DLRamJwEkgoD9wPrg8LuutksAgx45qoII7tvAIxnlRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;414&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;条件判断&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过 when 关键字指定：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUNicSicUf9dPSCrm3hdVXibZSjkeqEe1I4VkPhMtrRiaNJ0Viaj119dgxbqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;243&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;错误重尝&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.28984375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUFmt15mlrujmtkdJ9v5C7POlEn6vYDdibnpR1RgannjeJiazICUY5wtCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;168&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;递归&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Template 可以递归地相互调用&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，这是一个非常实用的功能。例如在机器学习场景中：可以设定准确率必须满足一个值，否则就持续进行训练。在下面这个抛硬币例子中，我们可以持续抛硬币，直到出现正面才结束整个工作流。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.92734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUONpTNq9BFicY098ziaIO7aDWQLlVsoiavgNicCpia0MKZbb9icdPVznHiapbg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;536&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;以下是两次执行的结果，第一次执行直接抛到正面，结束流程；第二次重复三次后才抛到正面，结束流程。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.65703125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUPpDFCliaGUoRc5icLpiavZYCBdZLdA2nbMDMCMGFxCuIamto65ialdSkYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;380&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;退出处理&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;退出处理是一个指定在 workflow 结束时执行的 template，无论成功或失败。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.17734375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/1e9ia4YcKpMMsLQQtYoofT2Iw8QHicichqUjGfX9SBjbM9tNNV4BJKHaMpjXUAYGXEu1ibDQfPYickpCblFnUno6vMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-backw=&quot;578&quot; data-backh=&quot;103&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;K8sMeetup&lt;/strong&gt;&lt;strong/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;对比 Tekton&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;相较于 Tekton 而言，Argo 的流程控制功能更加丰富。拥有着循环、递归等功能，这对于一些机器学习的场景都是十分适用的。而 Argo 社区对自己的定位也是 MLOps、AIOps、Data/Batch Processing，这也正是 Kubeflow Pipeline 底层基于 Argo 的原因（尽管 KFP 也在做 Tekton 的 backend）。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;但是在权限控制方面，Argo 做的就不如 Tekton，我个人认为，Tekton 的结构定义更为清晰。二者各有优劣，可以根据自己的需求进行选择。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;参考文档&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Argo Roadmap：&lt;/span&gt;&lt;span&gt;https://github.com/argoproj/argo/blob/master/docs/roadmap.md&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Argo Examples：&lt;/span&gt;&lt;span&gt;https://argoproj.github.io/argo/examples/#welcome&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;em&gt;&lt;span&gt;Argo Source Code：&lt;/span&gt;&lt;span&gt;https://github.com/argoproj/argo&lt;/span&gt;&lt;/em&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bdb2a31538b8634e2476250ddf14efd3</guid>
<title>分布式唯一 ID 解决方案：雪花算法</title>
<link>https://toutiao.io/k/eyvwks8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;preview&quot;&gt;&lt;p&gt;&lt;code&gt;阅读大概需要3分钟&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;附源码&lt;/p&gt;

&lt;p&gt;[toc]&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210112221734297.png&quot; alt=&quot;封面图&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;前言&lt;/h2&gt;

&lt;p&gt;单体架构的服务的日子已经一去不复返了。&lt;/p&gt;

&lt;p&gt;当前系统业务和数据存储的复杂度都在提升，分布式系统是目前使用非常普遍的解决方案。&lt;/p&gt;

&lt;p&gt;全局唯一 ID 几乎是所有设计系统时都会遇到的，全局唯一 ID 在存储和检索中有至关重要的作用。&lt;/p&gt;

&lt;h2&gt;ID生成器&lt;/h2&gt;

&lt;p&gt;在应用程序中，经常需要全局唯一的ID作为数据库主键。如何生成全局唯一ID？&lt;/p&gt;

&lt;p&gt;首先，需要确定全局唯一ID是整型还是字符串？如果是字符串，那么现有的UUID就完全满足需求，不需要额外的工作。缺点是字符串作为ID占用空间大，索引效率比整型低。&lt;/p&gt;

&lt;p&gt;如果采用整型作为ID，那么首先排除掉32位int类型，因为范围太小，必须使用64位long型。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;采用整型作为ID时，如何生成自增、全局唯一且不重复的ID？&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;数据库自增&lt;/h3&gt;

&lt;p&gt;数据库自增 ID 是我们在数据量较小的系统中经常使用的，利用数据库的自增ID，从1开始，基本可以做到连续递增。Oracle可以用 &lt;code&gt;SEQUENCE&lt;/code&gt;，MySQL可以用主键的 &lt;code&gt;AUTO_INCREMENT&lt;/code&gt;，虽然不能保证全局唯一，但每个表唯一，也基本满足需求。&lt;/p&gt;

&lt;p&gt;数据库自增ID的缺点是数据在插入前，无法获得ID。数据在插入后，获取的ID虽然是唯一的，但一定要等到事务提交后，ID才算是有效的。有些双向引用的数据，不得不插入后再做一次更新，比较麻烦。&lt;/p&gt;

&lt;p&gt;在我们开发过程中，遇到一种 主主数据库同步（简单可以理解为，同样的sql再另一台数据库再执行一次）的场景，如果使用数据库自增 ID，就会出现主键不一致、或主键冲突问题。&lt;/p&gt;

&lt;h2&gt;分布式ID生成器&lt;/h2&gt;

&lt;h3&gt;方案一：UUID&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;分布式环境不推荐使用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;uuid 是我们比较先想到的方法，在 java.util;包中就有对应方法。这是一个具有rfc标准的uuid：&lt;a href=&quot;https://www.ietf.org/rfc/rfc4122.txt&quot;&gt;https://www.ietf.org/rfc/rfc4122.txt&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;uuid 有很好的性能（本地调用），没有网络消耗。&lt;/p&gt;

&lt;p&gt;但是，uuid 不易存储（生成了字符串、存储过长、很多场景不适用）；信息不安全（基于 MAC 地址生成、可能会造成泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。
）；无法保证递增（或趋势递增）；其他博主反馈，截取前20位做唯一 ID ，在大数量（大概只有220w）情况下会有重复问题。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;UUID.randomUUID().toString()&lt;/code&gt;&lt;/p&gt;

&lt;h3&gt;方案二：snowflake(雪花算法)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;这是目前使用较多分布式ID解决方案，推荐使用&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;背景 Twitter 云云就不介绍了，就是前段时间封了懂王账号的 Twitter。&lt;/p&gt;

&lt;h4&gt;算法介绍&lt;/h4&gt;

&lt;p&gt;SnowFlake算法生成id的结果是一个64bit大小的整数，它的结构如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190402101612645.png&quot; alt=&quot;snowflake-64bit&quot;/&gt;&lt;/p&gt;



&lt;p&gt;由于在 Java 中 64bit 的整数是 long 类型，所以在 Java 中 SnowFlake 算法生成的 id 就是 long 来存储的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;SnowFlake可以保证&lt;/strong&gt;：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;同一台服务器所有生成的id按时间趋势递增&lt;/li&gt;
&lt;li&gt;整个分布式系统内不会产生重复id（因为有datacenterId和workerId来做区分）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;存在的问题：
1. 机器ID（5位）和数据中心ID（5位）配置没有解决，分布式部署的时候会使用相同的配置，任然有ID重复的风险。
2. 使用的时候需要实例化对象，没有形成开箱即用的工具类。
3. 强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。（这点在正常情况下是不会发生的）&lt;/p&gt;

&lt;p&gt;针对上面问题，这里提供一种解决思路，workId 使用服务器 hostName 生成，dataCenterId 使用 IP 生成，这样可以最大限度防止 10 位机器码重复，但是由于两个 ID 都不能超过 32，只能取余数，还是难免产生重复，但是实际使用中，hostName 和 IP 的配置一般连续或相近，只要不是刚好相隔 32 位，就不会有问题，况且，hostName 和 IP 同时相隔 32 的情况更加是几乎不可能的事，平时做的分布式部署，一般也不会超过 10 台容器。&lt;/p&gt;

&lt;p&gt;生产上使用docker配置一般是一次编译，然后分布式部署到不同容器，不会有不同的配置。这种情况就对上面提到的出现了不确定情况，这个在评论中会再出一篇参考文章。&lt;/p&gt;

&lt;h4&gt;源码&lt;/h4&gt;

&lt;p&gt;Java 版雪花ID生成算法&lt;/p&gt;

&lt;pre lang=&quot;java&quot;&gt;&lt;code&gt;package com.my.blog.website.utils;

import org.apache.commons.lang3.RandomUtils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.SystemUtils;

import java.net.Inet4Address;
import java.net.UnknownHostException;

/**
 * Twitter_Snowflake&amp;lt;br&amp;gt;
 * SnowFlake的结构如下(每部分用-分开):&amp;lt;br&amp;gt;
 * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &amp;lt;br&amp;gt;
 * 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0&amp;lt;br&amp;gt;
 * 41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截)
 * 得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L &amp;lt;&amp;lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69&amp;lt;br&amp;gt;
 * 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId&amp;lt;br&amp;gt;
 * 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号&amp;lt;br&amp;gt;
 * 加起来刚好64位，为一个Long型。&amp;lt;br&amp;gt;
 * SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。
 */
public class SnowflakeIdWorker {

    // ==============================Fields===========================================
    /** 开始时间截 (2015-01-01) */
    private final long twepoch = 1489111610226L;

    /** 机器id所占的位数 */
    private final long workerIdBits = 5L;

    /** 数据标识id所占的位数 */
    private final long dataCenterIdBits = 5L;

    /** 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数) */
    private final long maxWorkerId = -1L ^ (-1L &amp;lt;&amp;lt; workerIdBits);

    /** 支持的最大数据标识id，结果是31 */
    private final long maxDataCenterId = -1L ^ (-1L &amp;lt;&amp;lt; dataCenterIdBits);

    /** 序列在id中占的位数 */
    private final long sequenceBits = 12L;

    /** 机器ID向左移12位 */
    private final long workerIdShift = sequenceBits;

    /** 数据标识id向左移17位(12+5) */
    private final long dataCenterIdShift = sequenceBits + workerIdBits;

    /** 时间截向左移22位(5+5+12) */
    private final long timestampLeftShift = sequenceBits + workerIdBits + dataCenterIdBits;

    /** 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095) */
    private final long sequenceMask = -1L ^ (-1L &amp;lt;&amp;lt; sequenceBits);

    /** 工作机器ID(0~31) */
    private long workerId;

    /** 数据中心ID(0~31) */
    private long dataCenterId;

    /** 毫秒内序列(0~4095) */
    private long sequence = 0L;

    /** 上次生成ID的时间截 */
    private long lastTimestamp = -1L;

    private static SnowflakeIdWorker idWorker;

    static {
        idWorker = new SnowflakeIdWorker(getWorkId(),getDataCenterId());
    }

    //==============================Constructors=====================================
    /**
     * 构造函数
     * @param workerId 工作ID (0~31)
     * @param dataCenterId 数据中心ID (0~31)
     */
    public SnowflakeIdWorker(long workerId, long dataCenterId) {
        if (workerId &amp;gt; maxWorkerId || workerId &amp;lt; 0) {
            throw new IllegalArgumentException(String.format(&quot;workerId can&#x27;t be greater than %d or less than 0&quot;, maxWorkerId));
        }
        if (dataCenterId &amp;gt; maxDataCenterId || dataCenterId &amp;lt; 0) {
            throw new IllegalArgumentException(String.format(&quot;dataCenterId can&#x27;t be greater than %d or less than 0&quot;, maxDataCenterId));
        }
        this.workerId = workerId;
        this.dataCenterId = dataCenterId;
    }

    // ==============================Methods==========================================
    /**
     * 获得下一个ID (该方法是线程安全的)
     * @return SnowflakeId
     */
    public synchronized long nextId() {
        long timestamp = timeGen();

        //如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常
        if (timestamp &amp;lt; lastTimestamp) {
            throw new RuntimeException(
                    String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp));
        }

        //如果是同一时间生成的，则进行毫秒内序列
        if (lastTimestamp == timestamp) {
            sequence = (sequence + 1) &amp;amp; sequenceMask;
            //毫秒内序列溢出
            if (sequence == 0) {
                //阻塞到下一个毫秒,获得新的时间戳
                timestamp = tilNextMillis(lastTimestamp);
            }
        }
        //时间戳改变，毫秒内序列重置
        else {
            sequence = 0L;
        }

        //上次生成ID的时间截
        lastTimestamp = timestamp;

        //移位并通过或运算拼到一起组成64位的ID
        return ((timestamp - twepoch) &amp;lt;&amp;lt; timestampLeftShift)
                | (dataCenterId &amp;lt;&amp;lt; dataCenterIdShift)
                | (workerId &amp;lt;&amp;lt; workerIdShift)
                | sequence;
    }

    /**
     * 阻塞到下一个毫秒，直到获得新的时间戳
     * @param lastTimestamp 上次生成ID的时间截
     * @return 当前时间戳
     */
    protected long tilNextMillis(long lastTimestamp) {
        long timestamp = timeGen();
        while (timestamp &amp;lt;= lastTimestamp) {
            timestamp = timeGen();
        }
        return timestamp;
    }

    /**
     * 返回以毫秒为单位的当前时间
     * @return 当前时间(毫秒)
     */
    protected long timeGen() {
        return System.currentTimeMillis();
    }

    private static Long getWorkId(){
        try {
            String hostAddress = Inet4Address.getLocalHost().getHostAddress();
            int[] ints = StringUtils.toCodePoints(hostAddress);
            int sums = 0;
            for(int b : ints){
                sums += b;
            }
            return (long)(sums % 32);
        } catch (UnknownHostException e) {
            // 如果获取失败，则使用随机数备用
            return RandomUtils.nextLong(0,31);
        }
    }

    private static Long getDataCenterId(){
        int[] ints = StringUtils.toCodePoints(SystemUtils.getHostName());
        int sums = 0;
        for (int i: ints) {
            sums += i;
        }
        return (long)(sums % 32);
    }


    /**
     * 静态工具类
     *
     * @return
     */
    public static synchronized Long generateId(){
        long id = idWorker.nextId();
        return id;
    }

    //==============================Test=============================================
    /** 测试 */
    public static void main(String[] args) {
        System.out.println(System.currentTimeMillis());
        long startTime = System.nanoTime();
        for (int i = 0; i &amp;lt; 50000; i++) {
            long id = SnowflakeIdWorker.generateId();
            System.out.println(id);
        }
        System.out.println((System.nanoTime()-startTime)/1000000+&quot;ms&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考原文：&lt;a href=&quot;https://blog.csdn.net/xiaopeng9275/article/details/72123709&quot;&gt;https://blog.csdn.net/xiaopeng9275/article/details/72123709&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;分享和在看是对我最大的鼓励。我是pub哥，我们下期见!&lt;/p&gt;
&lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fff592b3a61b7428a6f8560c679e9139</guid>
<title>超越身边 80% 的人，其实没有你想象的那么难</title>
<link>https://toutiao.io/k/ns5biqo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.33184855233853006&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgRgzIV2YTLYP1C9K6m6ZesXIGMic8cBk5es1ZicMDfULrExGEw49a51icWhlYkA1pXmib62xNNUDrMgXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;898&quot;/&gt;我是架构精进之路，点击上方“关注”，坚持每天为你分享技术干货，私信我回复“01”，送你一份程序员成长进阶大礼包。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;职场工作多年来，我观察到一些有点出乎意料的现象，例如：&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;1、很多年轻时头脑灵活、拼搏奋进的人，到了35+岁似乎也没有领先别人多少，甚至有不少人还落后了。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2、而年轻时能力一般、似乎安于现状的人，到了35+岁似乎也普遍在经理、总监的位置上，甚至还有人担任了更高的职位。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;有点奇怪，到底是什么造成了这种预期之外的情况呢？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这其中有人归因于机遇，有人归因于心态，有人归因于没有贵人相助...&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其实，接触的人多了就会发现一点：“&lt;/span&gt;&lt;span&gt;出类拔萃确实很难，但领先身边80%的人却相对简单&lt;/span&gt;&lt;span&gt;”。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;只要尝试做到以下四点（甚至其中的任一点），几乎都有可能成为领先他人的那前20%&lt;/span&gt;&lt;/section&gt;&lt;h1 spellcheck=&quot;false&quot;&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1 spellcheck=&quot;false&quot;&gt;&lt;span&gt;&lt;strong&gt;1、多一点耐心&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;在现在这个一切都讲究快节奏的社会里，有耐心的人实在太少了。&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;学习某个新技能刚没几天，就觉得见效太慢了也许就要选择放弃； &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;参加工作刚刚有半年一年没晋升加薪，就觉得受委屈了，闹着要离职；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;选择创业时在产品上没耐心打磨，成天想着怎么融一大笔钱、怎么用户裂变，幻想一夜暴富财富自由。 &lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;人根本不怕悟性差，就怕没耐性。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;“只要功夫深，铁杵磨成针。” 愿意花时间去琢磨，不管怎么样，都会有进步。但是，我见到很多人，非常喜欢说自己“悟性差”、是“凡人”，明明也是喝过几年墨水的人，其实不过是对自己没有耐心罢了，舍不得继续往里钻研。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，如果你能多一点耐心，比别人多坚持一会儿，很容易就能领先这些没有耐心的人。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;记得我刚刚毕业工作那会儿，也是一个极其没有耐心的人。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;记得大学刚毕业不久，我拿到了自己心仪的Offer，一开始，我对自己也的未来也是踌躇满志。但是日常工作毕竟是繁杂的，逐渐将最初的满腔热血逐渐打磨殆尽。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在公司呆了两年后，虽然拿了部门相对而言还不错的高绩效，工资也还不错，但我却依然觉得公司的平台不足以支撑我更快成长，自己会有更好的发展，因此选择跳槽了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;有人可能会反驳说 “频繁跳槽挺好的，工资都是靠跳出来的”，其实这其中的熟悉环境和浪费的时间精力，一点儿也不少。获得到的可能是部分涨薪，但损失的可能是更大的机遇和成长。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;经历过没耐心的苦果后，我就告诉自己一定要有耐心，坚持长期主义，在任何一家公司都至少要呆满三年。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;有个同事的话我至今印象深刻，“&lt;/span&gt;&lt;span&gt;再牛的技术成长，都不如傻瓜式的坚持&lt;/span&gt;&lt;span&gt;”。不推崇绝对信奉，但确实有一定道理。有时候你认为自己去了更好更有前途的公司平台，殊不知遇到的新挑战新问题也是非常难以解决的。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;有了这个转变，我之后的职业生涯收获了越来越来的长期主义回报。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如，带领团队做事，从一个人单打独斗到一群人为了集体利益去拼搏是完全不一样的。当你不仅为了自己的成长负责，还要为你团队中的每一个人成长负责，你就会感觉身上的担子完全不一样。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;把自己作为产品来打磨，来运营&lt;/span&gt;&lt;span&gt;，让自己多一点耐心，你会发现不经意间就领先很多身边的人了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img data-height=&quot;767&quot; data-ratio=&quot;0.7497556207233627&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z2bVaFK6CgTGGOckX5cbdydxbLHXhBa5iammy6OdOrlurjbHgLoYOCLWia7J5mm5Az9OuRV0lHvWzXV7Z30lnFxQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1023&quot; data-width=&quot;1023&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1 spellcheck=&quot;false&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h1&gt;&lt;h1 spellcheck=&quot;false&quot;&gt;&lt;strong&gt;&lt;span&gt;2、少一点贪心&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;前几天周末聚会，有位朋友跟我倾诉：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“我最近很焦虑，感觉前面有很多问题要解决，有很多东西要学，焦虑反过来又让我很拖延，感觉成长很慢。那&lt;/span&gt;&lt;span&gt;我应该怎么来设定我的合适的目标和成长计划？&lt;/span&gt;&lt;span&gt;” &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这个问题非常具有普遍性，可能80%以上的人都有。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其实，&lt;/span&gt;&lt;span&gt;这种焦虑的根本病因在于贪心&lt;/span&gt;&lt;span&gt;。总以为自己得到的太少，往往是因为我们想要的太多。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;管理学大师德鲁克在《卓有成效的管理者》中有一段讲得特别好： &lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;有些人一事无成，而实际上他们却做得很吃力&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;。原因有三：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1）他们低估了完成一件任务所需的时间。他们总以为万事顺利，却总不免有出乎意料的情况发生；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2）一般的管理者（往往也是不大有效的管理者）总喜欢赶工，而赶工的结果，总不免使进度更加落后；&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3）一般的管理者喜欢同时着手几件要事，结果对每一件事，他们都无法获得足够的最少整块时间。只要任何一件事情受阻，全部事情也都会跟着受阻了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;           ——引自德鲁克《卓有成效的管理者》&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;如果我们能减少自己的贪心，像德鲁克建议的这样，一段时间只聚焦一个目标、一个关键任务的话，那么我们成功完成这个目标或关键任务的概率将大大提高。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;有些同学可能会担心：目标或计划安排得太少，是不是会导致自己缺少成就感呢？ &lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;假如你减少了计划中的工作量，还是未能按时完成，那么你在计划里额外加再多任务项也没意义，反正你都不会去做完。更严重的是，当你排上这些事项，只会导致原本能做完的要事因为受到干扰而可能做不完，结果就是变得更焦虑了，最后可能什么都不愿做了（心里会想反正我也做不完）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;假如真的将任务量减少，你最终做的事也不会变少，因为你肯定有多余的时间空下来，那时再加更多的事就可以了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img data-height=&quot;681&quot; data-ratio=&quot;0.5675&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z2bVaFK6CgTGGOckX5cbdydxbLHXhBa5ia3aIgXIg4ibPmNRXMV09r6AaKKb57uy19gCPiavCfq5fdTCRpu0q344w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot; data-width=&quot;1200&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;木刻，描述一个贪婪的人会吃大量的食物&lt;/span&gt;&lt;/section&gt;&lt;h1 spellcheck=&quot;false&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h1&gt;&lt;h1 spellcheck=&quot;false&quot;&gt;&lt;span&gt;&lt;strong&gt;3、多一点行动&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;这个世界上，绝大部分人失败不是因为没有思考，而是因为犹豫不决，迟迟没有行动。美国总统艾森豪威尔说过：“任何语言都是苍白的，你唯一需要的就是执行力，一个行动胜过一打计划”。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你稍微用心观察下周边的朋友和同事，你会发现坐而论道、大谈理想的人很多，但是踏踏实实动手去做的人却很少。&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;子曰：“君子欲讷于言而敏于行。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;意思是：君子，说话是慢的，是迟钝的，看起来还比较木讷，但是行动很迅速。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;为什么要这样呢？&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因为说话是容易的，而去做事，是比较难的，难在开始的行动，也难在过程的坚持。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如 我计划锻炼身体，做减肥计划。&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;一但让你去干，你可能说自己条件不成熟，没有健身房；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当你有了健身房的时候，你又会找其他借口说，今天就不去了吧，明天再去。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;其实说话是相当容易的，执行起来就会有些难度。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;再比如，我们大家都知道早起早睡好，但总是有部分人，天天都在说：“明天我要早起早睡”，但是每天依旧玩游戏，依旧看电视剧，很晚入睡。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;人一旦养成喜欢说，说了又不执行的习惯，就很容易变得一事无成。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;这就是“纸上得来终觉浅，绝知此事要躬行”的最佳写照之一。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;工作中，总有同学问我：“怎么写好述职报告呢？如何写好文章，有没有什么写作方法论？”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我的最大建议就是：&lt;/span&gt;&lt;span&gt;不用管什么方法论，先去试着写写，写多了你的水平自然就提升了&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;因为写多了，你就不得不去琢磨内容如何布局，怎样思路别人才能更易懂、如何写才更言简意赅等等，这样写作水平自然也就高了。 但如果不去试，再厉害的方法论给你也没啥用。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，少一点空想，多一点行动，你想不领先80%的人都难，因为愿意动手去做的人实在是太少了。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img data-height=&quot;682&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z2bVaFK6CgTGGOckX5cbdydxbLHXhBa55ppENhIug2hicjC2TDEbUibZ3LtT9UTQAPo88RypzO8B9Nh13icZDDtvg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1023&quot; data-width=&quot;1023&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1 spellcheck=&quot;false&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h1&gt;&lt;h1 spellcheck=&quot;false&quot;&gt;&lt;span&gt;&lt;strong&gt;4、少一点娱乐&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;在现在这个全球消费主义占主流的时代里，人类社会和文化有了越来越强的娱乐化倾向。&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;《美丽新世界》的作者英国作家赫胥黎曾警告过：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“在一个科技发达的时代里，造成精神毁灭的敌人更可能是一个满面笑容的人，而不是那种一眼看上去就让人心生怀疑和仇恨的人。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;让你趋之如骛的手机游戏、刷了就放不下的短视频、无脑连续剧、低俗综艺节目正是这个“满面笑容的人”。&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;世界著名的媒体文化研究者尼尔·波兹曼在1985年出版的《娱乐至死》中，就因为电视文化的盛行提出过一个著名预言：&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;毁掉我们的不是我们憎恨的东西，恰恰是我们热爱的东西！&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;教育、体育、商业和任何其它公众话语的内容，都日渐以娱乐的方式出现，并成为一种文化精神，而人类无声无息地成为娱乐的附庸，毫无怨言，甚至心甘情愿，其结果是我们成了一个娱乐至死的物种。 &lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;拒绝X音、X手等精神鸦片，这些除了让你提高兴奋阈值没任何用。我们活在当下最好的时代，因为你拒绝这些 “奶头乐” 就能打败80%的同龄人。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当你减少一些无谓的娱乐，体验到了一种更积极的状态时，就很后悔之前荒废了很多时间在游戏、娱乐上面。因为享受到了戒除游戏带来的好处，我后来也从来不看低俗综艺节目、不追无脑连续剧，这帮我省下了大量的时间。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在此声明一下：&lt;/span&gt;&lt;span&gt;我不反对娱乐，在合理范围内娱乐，会给我们带来精神的享受和精力的恢复。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但现在的问题是，太多的人不是娱乐不足，而是沉溺在了“泛娱乐”之中。所有这些泛娱乐的东西，利用的都是人性中贪婪、懒惰、虚荣的一面，很容易就让你上瘾，你一旦上瘾绝对是百害而无一利的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，如果你能抵制住诱惑，减少一点娱乐的话，你会发现你比80%的人都多了不少可用于学习和思考的时间。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img data-height=&quot;800&quot; data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z2bVaFK6CgTGGOckX5cbdydxbLHXhBa5zwX7XPw1crkSTJcugSUHcz64viboa3xxF8288mMyrDkTtJEMzdyIs2Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot; data-width=&quot;1200&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;h1 spellcheck=&quot;false&quot;&gt;&lt;br/&gt;&lt;/h1&gt;&lt;h1 spellcheck=&quot;false&quot;&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;section&gt;&lt;span&gt;也许出类拔萃很难，但领先80%的人却相对简单，真的只要投入20%的努力就能做到。 &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;坚持做好这四点里只要你能做到其中一点，领先80%的人几乎就是顺其自然的事。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如果你还有所怀疑的话，那请你挑选其中一点认真去实践上三年，你敢么？&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;img data-height=&quot;729&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z2bVaFK6CgTGGOckX5cbdydxbLHXhBa5DrxibkAxQPjAqnAsVbxMVqpHalVFUiaRUNyB7t3aFgibuToPeJUtV0Uxw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-width=&quot;1200&quot; data-ratio=&quot;0.6074074074074074&quot; data-w=&quot;1080&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p data-pm-slice=&quot;1 1 []&quot;&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;作者&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;span&gt;架构精进之路，专注软件架构研究，技术学习与个人成长，关注并私信我回复“01”，送你一份程序员成长进阶大礼包。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;往期热文推荐：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;98311&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;395&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;395&quot; data-ratio=&quot;0.36484375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z2bVaFK6CgSxEpr7AzM5lGCicdEjfuE6jaiae9Rmj1CVCg85GJKaFKuico89ZlnhGicQiciciccOiaqVibE5cmKXwO1AOuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;87502&quot;&gt;&lt;p&gt;&lt;span&gt;「技术架构精进」专注架构研究，技术分享&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Thanks for reading!&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4335cb042b297e6947e496ee034dda2d</guid>
<title>醒醒！Python 已经支持中文变量名啦</title>
<link>https://toutiao.io/k/jhmz8w2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt; △点击上方&lt;/span&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;Python猫&lt;/span&gt;&lt;span&gt;”关注 ，回复“&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;”领取电子书&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTNHKpowicG5g0LPbFAh61tztUg1FRTQaWkTgO1EIUVicc8VnlfPBUQicJrhu9ITUfscd8ia9gTPfRMHjQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;作者：豌豆花下猫&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;来源：Python猫&lt;/span&gt;&lt;/section&gt;&lt;p&gt;最近，我在翻阅两本比较新的 Python 书籍时，发现它们都犯了一个严重的低级错误！&lt;/p&gt;&lt;p&gt;这两本书分别是《Python编程：从入门到实践》和《父与子的编程之旅》，它们都是畅销书，都在 2020 年 10 月出了新版本，都使用 Python3.7+ 版本的语法。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6752577319587629&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTNHKpowicG5g0LPbFAh61tzt5MvBnOn5F6KoYkY7icrzlribtojCHQeuxUic3dibSwZM3q8s4sDichqV5hg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1358&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;然而，在关于变量的命名规则部分，它们犯下了一样的错误，即还在使用 Python2 时代的那套说辞，误以为命名仅仅支持“字母、数字和下划线”的组合。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTNHKpowicG5g0LPbFAh61tztXia8akrae7KMlX5XRz13kcrQwPnmSclgicsBWhRWQP4ibz3F5GZFg5WAw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;4000&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;事实上，Python3.x 已经支持全面 Unicode 编码，比如支持使用中文作为变量名。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; 姓名 =&lt;span&gt;&quot;Python猫&quot;&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; print(&lt;span&gt;f&quot;我是&lt;span&gt;{姓名}&lt;/span&gt;，欢迎关注！&quot;&lt;/span&gt;)&lt;br/&gt;我是Python猫，欢迎关注！&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于我手头上没有其它样本，所以，我不确定有多少新版的书籍还在使用老的规则。但是，翻译类的书籍大概率都会有这样的问题，另外，有些不严谨的国内书籍，也可能因为借鉴了过时的材料而犯错。&lt;/p&gt;&lt;p&gt;如此一来，恐怕有些新接触 Python 的同学，就会形成错误的认识。虽然这可能不会造成严重的问题，但是它终归是一个应该避免而且很容易就能避免的问题。&lt;/p&gt;&lt;p&gt;因此，我觉得这个话题值得聊一聊。&lt;/p&gt;&lt;p&gt;在编程语言中有一个很常见的概念，即标识符（identifier），通常又会称之为名字（name），用于标识出变量、常量、函数、类、符号等实体的名字。&lt;/p&gt;&lt;section&gt;在定义标识符时，有一些必须要考虑的基本规则：&lt;/section&gt;&lt;p&gt;对于第一个问题，大多数的编程语言&lt;strong&gt;在早期版本&lt;/strong&gt;都遵循这条规则：&lt;strong&gt;标识符由字母、数字和下划线组成，并且不能以数字为开头。&lt;/strong&gt; 少数的编程语言有例外，还支持使用$、@、%等特殊符号（例如PHP、Ruby、Perl等等）。&lt;/p&gt;&lt;p&gt;Python 的早期版本，确切地说是 3.0 之前的版本，就遵循以上的命名规则。下面是官方文档中的描述：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;identifier ::=  (letter|&lt;span&gt;&quot;_&quot;&lt;/span&gt;) (letter | digit | &lt;span&gt;&quot;_&quot;&lt;/span&gt;)*&lt;br/&gt;letter     ::=  lowercase | uppercase&lt;br/&gt;lowercase  ::=  &lt;span&gt;&quot;a&quot;&lt;/span&gt;...&lt;span&gt;&quot;z&quot;&lt;/span&gt;&lt;br/&gt;uppercase  ::=  &lt;span&gt;&quot;A&quot;&lt;/span&gt;...&lt;span&gt;&quot;Z&quot;&lt;/span&gt;&lt;br/&gt;digit      ::=  &lt;span&gt;&quot;0&quot;&lt;/span&gt;...&lt;span&gt;&quot;9&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.32062391681109187&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTNHKpowicG5g0LPbFAh61tztn4Q3ZQE88ibFwv7p53atibfEuXPa56ax0cAfpmbZ95sT4tMiaVib3e2xYQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1154&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;出处：https://docs.python.org/2.7/reference/lexical_analysis.html#identifiers&lt;/span&gt;&lt;/section&gt;&lt;p&gt;但是，这条规则从 3.0 版本起，就被打破了。最新的官方文档已经变成了这样：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5247232472324723&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTNHKpowicG5g0LPbFAh61tzt1YRQkEiaJBgqoDVsgzZWJEyqB6FfqVdLwMBTeUJlGuykFuWian4xpCxQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1355&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;出处：https://docs.python.org/3/reference/lexical_analysis.html#identifiers&lt;/span&gt;&lt;/section&gt;&lt;p&gt;随着互联网的普及，各国语言进入了国际化的语境中，编程语言也与时俱进地增长了对国际化的诉求。&lt;/p&gt;&lt;p&gt;Unicode（译作统一码、万国码）编码标准在 1994 年发布，随后逐步被主流的编程语言所接纳。到目前为止，至少有 73 种编程语言支持 Unicode 变量名（数据依据：&lt;span&gt;https://rosettacode.org/wiki/Unicode_variable_names&lt;/span&gt;）。&lt;/p&gt;&lt;p&gt;2007 年，当 Python 正在设计划时代的 3.0 版本时，官方也考虑了对 Unicode 编码的支持，于是，诞生了重要的《&lt;span&gt;PEP 3131 -- Supporting Non-ASCII Identifiers&lt;/span&gt;》。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.41627689429373244&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/LLRiaS9YfFTNHKpowicG5g0LPbFAh61tztrmOV14755FmfrlWjAwuEEsXvIoMvD0ib3Vv3ia4JoZXzn7mjYWh7WXAg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1069&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;section&gt;&lt;span&gt;出处：https://www.python.org/dev/peps/pep-3131&lt;/span&gt;&lt;/section&gt;&lt;p&gt;事实上，除了我们最关心的中文，Unicode 字符集还包含非常非常多的内容。&lt;/p&gt;&lt;p&gt;在对变量命名时，下面这些用法都是可行的（谨慎使用，如若被打，本猫概不负责……）：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; ψ = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; Δ = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&amp;gt;&amp;gt;&amp;gt; ಠ_ಠ = &lt;span&gt;&quot;hello&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;综上所述，某些 Python 书籍中关于变量命名规则的内容已经过时了，不应该被其所误导！&lt;/p&gt;&lt;p&gt;Python 3 作为一门面向现代化/国际化的语言，对于 Unicode 编码有很好的支持。至于该不该在项目中使用中文给标识符命名，那就是另外的问题啦……&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.45454545454545453&quot; data-w=&quot;22&quot; title=&quot;音符&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz/cZV2hRpuAPiaJQXWGyC9wrUzIicibgXayrgibTYarT3A1yzttbtaO0JlV21wMqroGYT3QtPq2C7HMYsvicSB2p7dTBg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Python猫技术交流群开放啦！&lt;/span&gt;&lt;/strong&gt;群里既有国内一二线大厂在职员工，也有国内外高校在读学生，既有十多年码龄的编程老鸟，也有中小学刚刚入门的新人，学习氛围良好！想入群的同学，请在公号内回复『&lt;strong&gt;&lt;span&gt;交流群&lt;/span&gt;&lt;/strong&gt;』，获取猫哥的微信&lt;span&gt;（谢绝广告党，非诚勿扰！）&lt;/span&gt;~&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;近期热门文章推荐：&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247489077&amp;amp;idx=1&amp;amp;sn=9cb3032619c9a13182ba4213fc3a36e7&amp;amp;chksm=fa5851b0cd2fd8a60be889a1c476300f89a418a7fcee2b25fda152da2cbd57ae7d8f57eba8a1&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Python 协程的本质？原来也不过如此&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247486176&amp;amp;idx=1&amp;amp;sn=fbef147f64a13d61aafaef1f83d35c7d&amp;amp;chksm=fa584d65cd2fc473bc4849085317e48fe211f2f884be661b50c383e730dfb683bf0ff28220b9&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Python 函数为什么会默认返回 None？&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247485203&amp;amp;idx=2&amp;amp;sn=4aeb4441c789ab22ddbc5ee21b2add9a&amp;amp;chksm=fa584096cd2fc98086709dce70186e5a2dffa5e3873ae98712a8e0c5d49904ec5296f6803ccd&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;漫画：如何分析运行中的 Python 程序？&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUyOTk2MTcwNg==&amp;amp;mid=2247484001&amp;amp;idx=1&amp;amp;sn=f1d1b3cda82b2fa9d3f8e84df4c271ec&amp;amp;chksm=fa5845e4cd2fccf2f9622d78a608a3a9795d07a8b3bf3856de17cd649f2d89761eb84fe75e61&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Python之父重回决策层，未来如何发展？&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-copyright=&quot;0&quot; data-ratio=&quot;1.2336283185840708&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/LLRiaS9YfFTMJhESpVSgO3VPnQ9RrstXztuOsKekkV5W3jFZDGFsTqNwHaWkWzwNjYdEoc52ZpQQYE3Dz463gwQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;565&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;愿有所助，叩谢支持！&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>