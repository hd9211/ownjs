<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>37bb583e573a342b22348a3e9ded88b1</guid>
<title>Uber：大规模、半自动化 Go GC 调优</title>
<link>https://toutiao.io/k/de25y8u</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;大家好，我是程序员幽鬼。&lt;/p&gt;&lt;p&gt;Uber 是国外大规模使用 Go 的公司之一，在 GitHub 上，他们开源了不少 Go 相关项目。最出名的有以下几个：&lt;/p&gt;&lt;p&gt;其中 guide 是他们内部的 Go 编码规范，目前已经被翻译成了多国语言，其中包括简体中文版本：https://github.com/xxjwxc/uber_go_guide_cn。&lt;/p&gt;&lt;p&gt;Uber 更多内容开源项目可以访问他们的 GitHub 首页：https://github.com/uber-go。&lt;/p&gt;&lt;p&gt;此外，https://github.com/jaegertracing/jaeger 也是 Uber 开发的，之后捐赠给 CNCF，这是一个分布式追踪平台，用于监控基于微服务的分布式系统。&lt;/p&gt;&lt;p&gt;因此他们在 Go 上有很多经验。本文介绍 Uber 如何在 30 个关键任务服务中节省 7 万个内核。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;本文作者是 Cristian Velazquez，他是 Uber Maps Production Engineering 团队的 Sr Production Engineer II。他负责跨多个组织的多个效率计划，其中最相关的是 Java 和 Go 的垃圾收集调优。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、介绍&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;实现盈利的方式有开源和节流，对于 Uber 技术团队（其他公司技术团队其实也类似）来说，提升资源利用率，进而减少服务器数量，这是减少成本的一种方式。有些公司通过换语言实现，比如 Python 换为 Go 等。而对 Go 服务来说，可能最有效的工作是针对 GOGC 的优化。在本文中，我们将分享在高效、低风险、大规模、半自动化的 Go GC 调优机制方面的经验。&lt;/p&gt;&lt;p&gt;Uber 有数千个微服务，并由基于云原生和基于调度程序的基础设施提供支持，这些服务大部分是用 Go 编写的。我们的 Maps Production Engineering 团队之前在 Java 微服务 GC 调优方面有很多经验，也取得了很好的效果，现在这些经验在 Go GC 方面也发挥了重要的作用。&lt;/p&gt;&lt;p&gt;&lt;span&gt;2021 年初，我们探索了对 Go 服务进行 GC 调优的可能性。我们运行了几个 CPU 配置文件来评估当前的事务状态，我们发现 GC 是绝大多数关键任务服务的 CPU 最大消耗者。以下是一些 CPU 配置文件的表示，其中 GC（由 runtime.scanobject 方法标识）消耗了分配的计算资源的很大一部分。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;示例服务 #1：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;2.3513513513513513&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jdTRWcqrowQdfegP8Ms0NY2y7n7Uv0q59YiaaCibZXzJQETFS8Er8ibpdxr8rFSZZSBokI2ewB0iaTiaicqLDL5HAY9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;222&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;图 1：示例服务 #1 的 GC CPU 成本&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;示例服务 #2&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;2.3706896551724137&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jdTRWcqrowQdfegP8Ms0NY2y7n7Uv0q5HU03HWYibF9ouQt8VA72zTVdd0libb9Fes3bZNtGkaEa4KuTMvYv2vFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;232&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;图 2：示例服务 #2 的 GC CPU 成本&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;受到这一发现的启发，我们开始为相关服务调整 GC。令我们高兴的是，Go 的 GC 实现和调整的简单性使我们能够自动化大部分检测和调整机制。我们将在以下部分详细介绍我们的方法及其效果。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2、GOGC Tuner&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;除了触发事件，Go 运行时会定期调用并发垃圾收集器，其中触发事件是基于内存值的。因此， 更多内存对 Go 服务来说更有利，因为它减少了 GC 必须运行的时间。此外，我们意识到我们的主机 CPU 与内存的比例是 1:5（1 核：5 GB RAM），而大多数 Go 服务的配置比例是 1:1 ~ 1:2。因此，我们有信心可以利用更多内存来减少 GC 的 CPU 影响。这是一种与服务无关的机制，如果应用得当，会产生很大的影响。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;深入研究 Go 的垃圾收集超出了本文的范围，但以下是这项工作的相关部分：Go 中的垃圾收集是并发的，涉及分析所有对象以确定哪些对象仍然可以访问。我们将可到达对象称为“实时数据集”。Go 仅提供一个选项：GOGC， 以实时数据集的百分比表示，用于控制垃圾收集。GOGC 值充当数据集的乘数。&lt;strong&gt;GOGC&lt;/strong&gt; 的默认值为 100%，这意味着 Go 运行时将为新分配保留与实时数据集相同的内存量。例如：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;hard_target = live_dataset + live_dataset * (GOGC / 100).&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，pacer 负责预测触发 GC 的最佳时间，以避免命中硬目标（软目标）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.1111111111111112&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jdTRWcqrowQdfegP8Ms0NY2y7n7Uv0q5M1OVSdniaADXM9r9fSibvm67dKAB0Rwz493icjCkYdacxDMF2QeWicDOag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;450&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;图 3：具有默认配置的示例堆&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3、动态多样：一个值无法适应所有场景&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们发现固定的 GOGC 值的调整不适合 Uber 的服务。以下是可能的挑战：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;它不知道分配给容器的最大内存，并可能导致内存不足问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;我们的微服务有各种内存利用率组合。例如，分片系统可以有非常不同的实时数据集。我们在其中一项服务中遇到了这种情况，其中 p99 利用率为 1G 但 p1 为 100MB，因此 100MB 实例具有巨大的 GC 影响。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4、自动化案例&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GOGCTuner 是一个库，它简化了为服务所有者调整垃圾收集的过程，并在其之上添加了一个可靠层。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;GOGCTuner 根据容器的内存限制（或服务所有者的上限）动态计算正确的 GOGC 值，并使用 Go 的运行时 API 设置它。以下是 GOGCTuner 库功能的详细信息：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;简化配置，便于推理和确定性计算。对于初学者来说，&lt;span&gt;GOGC&lt;/span&gt;=100% 的确定性不足，因为它仍然依赖于实时数据集。另一方面，70% 的限制可确保服务始终使用 70% 的堆空间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;防止 OOM（内存不足）：该库从 cgroup 读取内存限制并使用 70% 的默认硬限制，根据我们的经验，这是一个安全值。&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;需要注意的是，这种保护是有限制的。Tuner 只能调整缓冲区分配，因此如果你的服务活动对象高于限制，则 Tuner 将设置默认下限为 1.25X 你的活动对象利用率。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;对于极端情况允许更高的 GOGC 值，例如：&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;正如我们上面提到的，手动 GOGC 不是确定性的。我们仍然依赖实时数据集的大小。如果 live_dataset 将我们的最后一个峰值翻倍了怎么办？GOGCTuner 将以更多 CPU 为代价强制执行相同的内存限制。相反，手动调整可能会导致 OOM。因此，服务所有者过去常常为这些类型的场景提供足够的缓冲。请参见下面的示例：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;正常流量（实时数据集为 150M）&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.55078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jdTRWcqrowQdfegP8Ms0NY2y7n7Uv0q5zWuz4BdYGfib2PLYP1pJzNxu0V5NIkT8Pzyia4kZc7ARKPlZU1x2GjOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;图 4：正常操作。左侧为默认配置，右侧为手动调整&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;流量增加了 2 倍（实时数据集为 300M）&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6880907372400756&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jdTRWcqrowQdfegP8Ms0NY2y7n7Uv0q5ORtcEZAicgRtVhB8Sv4yGbXHnGZicRhDiaON2yDuPSdicWKpBRWUR5xXDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1058&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;图 5：双倍负载。左侧为默认配置，右侧为手动调整&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;GOGCTuner 达到 70% 时流量增加了 2 倍（实时数据集为 300M）&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jdTRWcqrowQdfegP8Ms0NY2y7n7Uv0q55RnNjHQDqRyicfsbUcPHiccf8R8HjqJ0AYf2oYAwIBX6o3QDJic02wuRg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;图 6：将负载加倍，但使用调谐器。左边是默认配置，右边是GOGCTuner调优&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用 &lt;span&gt;MADV_FREE&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt; 内存策略的服务会导致错误的内存指标。例如，我们的可观察性指标显示 50% 的内存利用率（实际上它已经释放了 50% 中的 20%）。然后服务所有者只是使用这个“不准确”的指标来调整 GOGC。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5、可观察性&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们发现缺乏一些关键指标，这些指标可以让我们更深入地了解每个服务的垃圾收集。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;垃圾收集之间的间隔：了解我们是否仍然可以调整很有用。例如，Go 强制每 2 分钟进行一次垃圾收集。如果你的服务仍然具有较高的 GC 影响，但你已经看到此图的 120 秒，这意味着你不能再使用 GOGC 进行调优。在这种情况下，你需要优化分配。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.28984375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jdTRWcqrowQdfegP8Ms0NY2y7n7Uv0q5r5G2KGBGsqXMXogzia1ncZkUc0KrWONUyakSQ5tViciaoRFxNZxbQrebA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;图 7：GC 之间的间隔图表&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;GC CPU 影响：知道哪些服务受 GC 影响最大。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jdTRWcqrowQdfegP8Ms0NY2y7n7Uv0q5OIib2P5Vp0fWfwNhDeTM2AF2Lp4f5BVfLWicMoyPqGDhpWtSolGvBxaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;图 8：p99 GC CPU 成本图表&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;实时数据集（Live dataset）大小：帮助我们识别内存泄漏。服务所有者注意到的问题是他们看到内存利用率有所增加。为了向他们展示没有内存泄漏，我们添加了“实时使用”指标，该指标显示了稳定的利用率。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.2890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jdTRWcqrowQdfegP8Ms0NY2y7n7Uv0q5ctL375PnGe93h3rQ9QDkPDsNZ7muVpicLkicmwGZahicmoFYbn5Lsnj6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;图 9：估计的 p99 实时数据集图表&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.30859375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jdTRWcqrowQdfegP8Ms0NY2y7n7Uv0q5EGJ36v0TsicPdicNWcyWodiaS3MD5lLNp4l461EsxyjweEjtYxtP71coQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;图 10：调谐器分配给应用程序的 min、p50、p99 GOGC 值图表&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6、实现&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们最初的方法是每秒运行一次代码来监控堆指标，然后相应地调整 GOGC 值。这种方法的缺点是开销开始变得相当大，因为为了读取堆指标，Go 需要执行 STW（&lt;span&gt;ReadMemStats&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;），并且它有点不准确，因为我们每秒可以进行多次垃圾收集。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;幸运的是，我们找到一个不错的方法。Go 有终结器（&lt;span&gt;SetFinalizer&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;），它们是在对象将被垃圾收集时运行的函数。它们主要用于清理 C 代码或其他一些资源的内存。我们能够使用一个自引用终结器，它会在每次 GC 调用时自行重置。这使得我们能够减少 CPU 开销。例如：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.9921722113502935&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jdTRWcqrowQdfegP8Ms0NY2y7n7Uv0q55GltPW7aQAsVrTRZ89nicMbMA9d4Cv69oibwtYAKxafxv5l89qEotYtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1022&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;图 11：GC 触发事件的示例代码&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用 &lt;code&gt;runtime.SetFinalizer(f, finalizerHandler)&lt;/code&gt; 代替直接调用 &lt;code&gt;finalizerHandler&lt;/code&gt; 以允许处理程序在每次 GC 上运行；它基本上不会让引用消失，因为它不是保活的昂贵资源（它只是一个指针）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7、影响&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们的几十个服务中部署了 GOGCTuner 之后，我们深入研究了其中一些显著的、CPU 利用率提高到两位数的服务。仅这些服务就累计节省了大约 70K 个内核。以下是 2 个这样的示例：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3193359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jdTRWcqrowQdfegP8Ms0NY2y7n7Uv0q55ySJU8qWQmibB2Eaia4ZZRp8ZX7r95RBSZ4hJhrXJlcG9nlADowibDEFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;图 12：可观察性服务在数千个计算内核上运行，live_dataset 具有高标准偏差（最大值是最小值的 10 倍），显示 p99 CPU 利用率降低了约 65%&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3212890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jdTRWcqrowQdfegP8Ms0NY2y7n7Uv0q5lIEXQIXSB9ycbSGZVSIextshKbWtoKcuM0q67bV0iaEvtX83MiapIf0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;图 13：任务关键型 Uber 吃掉在数千个计算核心上运行的服务，显示 p99 CPU 利用率降低了约 30%&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此产生的 CPU 利用率降低在战术上改善了 p99 延迟（以及相关的 SLA、用户体验），并在战略上改善了容器成本（因为服务是根据其利用率进行扩展的）。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8、总结&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;垃圾收集（GC）是应用程序中最难以捉摸，同时也是被低估的性能影响因素之一。Go 强大的 GC 机制和简化的调优，加之我们大规模的 Go 服务以及强大的内部平台（如 Go、计算、可观察性），使我们能够产生如此大规模的影响。由于技术和能力的变化，同时问题空间本身的发展，我们希望继续改进我们调整 GC 的方式。&lt;/p&gt;&lt;p&gt;最后再次重申我们在开头提到的内容：没有一个适合所有场景的 GOGC 值。由于公有云和运行在其中的容器化工作负载的性能高度可变，我们认为 GC 性能在云原生设置中将保持可变。再加上我们使用的绝大多数 CNCF 可观测项目都是用 Go 编写的（如 Kubernetes、Prometheus、Jaeger 等），这意味着任何外部的大规模部署也可以从这种努力中受益。&lt;/p&gt;&lt;p&gt;比较可惜的是，目前没看到 Uber 开源了这个工具。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原文链接：https://eng.uber.com/how-we-saved-70k-cores-across-30-mission-critical-services/&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;MADV_FREE: &lt;span&gt;https://man7.org/linux/man-pages/man2/madvise.2.html&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;ReadMemStats: &lt;span&gt;https://golang.org/pkg/runtime/#ReadMemStats&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;SetFinalizer: &lt;span&gt;https://golang.org/pkg/runtime/#SetFinalizer&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0bd6afc79874dfdd90a0777c368e33b8</guid>
<title>不是主管，如何带人成事？——《横向领导力》读书笔记</title>
<link>https://toutiao.io/k/0h4y4iw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9d0fb0487ae486b4ed2e48e5891a1473</guid>
<title>「多图预警」详解Kafka中的数据采集和统计机制</title>
<link>https://toutiao.io/k/eeozwnr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在讲解 &lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg4ODY1NTcxNg==&amp;amp;mid=2247489315&amp;amp;idx=1&amp;amp;sn=b51a08c0d77a7718d9b5234963d6f451&amp;amp;chksm=cff68d28f881043e84d03c4cc6e4e11c4ee8712fb49fd3740ba6ba5468093193e2f22e9eeb67&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;Kafka的副本同步限流机制三部曲(源码篇)&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Kafka的副本同步限流机制三部曲(源码篇)&lt;/a&gt;&lt;span&gt; 第二篇(原理篇) 之前&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我想先讲解一下 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;Kafka中的数据采集和统计机制&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;span&gt;当你了解这个机制之后才会更容易理解限流机制&lt;/span&gt;&lt;strong&gt; &lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmWVxLDDVAXanWpBUwgJpibGt5zCApiaqI2xAzzPDVEgeWodhfpQwUNb3yd8xsyqwGEOahcWDGAziaRPsjYp8OTiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;20&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你会不会好奇,kafka监控中,那些数据都是怎么计算出来的 比如下图这些指标&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2971542025148908&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmWVxLDDVAXanWpBUwgJpibGt5zCApiaqIDxXZafiaIAGcjUGrtOtJKSjYvvXf1fQIQ4ZblDhAI4O3XLYbHPf0picA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1511&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;LogiKM监控图&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这些数据都是通过Jmx获取的kafka监控指标, 那么我们今天来探讨一下,这些指标都是怎么被计算出来的&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在开始分析之前,我们可以 自己思考一下&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;如果让你统计前一分钟内的流速,你会怎么统计才能够让数字更加精确呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我相信你脑海中肯定出现了一个词：&lt;/span&gt;&lt;span&gt;&lt;strong&gt;滑动窗口&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在kafka的数据采样和统计中,也是用了这个方法, 通过多个样本&lt;/span&gt;&lt;code&gt;&lt;span&gt;Sample&lt;/span&gt;&lt;/code&gt;&lt;span&gt;进行采样,并合并统计&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然这一个过程少不了&lt;strong&gt;滑动窗口&lt;/strong&gt;的影子&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;采集和统计类图&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们先看下整个Kafka的数据采集和统计机制的类图&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.29168309026409145&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmWVxLDDVAXanWpBUwgJpibGt5zCApiaqIPKGhuRAbsBfYNiaDYicTpP5rcwQUtPmrLzfEmx8z8Cz9LkYr0icqou2Qw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;5074&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;数据采集和统计全类图&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;看着整个类图好像很复杂,但是最核心的就是两个Interface接口&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;code&gt;Measurable:&lt;/code&gt;&lt;/strong&gt; 可测量的、可统计的 Interface。这个Interface 有一个方法, 专门用来计算需要被统计的值的&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;/**&lt;br/&gt;* 测量这个数量并将结果作为双精度返回&lt;br/&gt;* 参数：&lt;br/&gt;* config – 此指标的配置&lt;br/&gt;* now – 进行测量的 POSIX 时间（以毫秒为单位）&lt;br/&gt;* 返回：&lt;br/&gt;* 测量值&lt;br/&gt;*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;double&lt;/span&gt; &lt;span&gt;measure&lt;/span&gt;&lt;span&gt;(MetricConfig config, &lt;span&gt;long&lt;/span&gt; now)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;比如说返回 &lt;/span&gt;&lt;code&gt;&lt;span&gt;近一分钟的bytesIn&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;code&gt;Stat:&lt;/code&gt;&lt;/strong&gt; 记录数据, 上面的是统计,但是统计需要数据来支撑, 这个Interface就是用来做记录的,这个Interface有一个方法&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt; &lt;span&gt;/**&lt;br/&gt; * 记录给定的值&lt;br/&gt; * 参数：&lt;br/&gt; * config – 用于该指标的配置&lt;br/&gt; * value – 要记录的值&lt;br/&gt; * timeMs – 此值发生的 POSIX 时间（以毫秒为单位）&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;record&lt;/span&gt;&lt;span&gt;(MetricConfig config, &lt;span&gt;double&lt;/span&gt; value, &lt;span&gt;long&lt;/span&gt; timeMs)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt; &lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有了这两个接口,就基本上可以&lt;strong&gt;记录数据&lt;/strong&gt;和&lt;strong&gt;数据统计&lt;/strong&gt;了&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然这两个接口都有一个 &lt;strong&gt;&lt;code&gt;MetricConfig&lt;/code&gt;&lt;/strong&gt; 对象&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3989169675090253&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmWVxLDDVAXanWpBUwgJpibGt5zCApiaqIjEoTvE344Bib2UrTfDY396IAyEpI921iaNAdhcOOt1UI43Ieoqibov5aA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;MetricConfig&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这是一个统计配置类, 主要是定义&lt;strong&gt;采样的样本数&lt;/strong&gt;、&lt;strong&gt;单个样本的时间窗口大小&lt;/strong&gt;、&lt;strong&gt;单个样本的事件窗口大小&lt;/strong&gt;、&lt;strong&gt;限流机制&lt;/strong&gt;有了这样一个配置了,就可以自由定义时间窗口的大小,和采样的样本数之类的影响最终数据精度的变量。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里我需要对两个参数重点说明一下&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;单个样本的时间窗口大小:&lt;/strong&gt; 当前记录时间 - 当前样本的开始时间 &amp;gt;= 此值  则需要使用下一个样本。&lt;strong&gt;单个样本的事件窗口大小:&lt;/strong&gt; 当前样本窗口时间次数 &amp;gt;= 此值  则需要使用下一个样本&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在整个统计中,不一定是按照&lt;strong&gt;时间窗口&lt;/strong&gt;来统计的, 也可以按照&lt;strong&gt;事件窗口&lt;/strong&gt;来统计, 具体按照不同需求选择配置&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;好了,大家脑海里面已经有了最基本的概念了,我们接下来就以一个kafka内部经常使用的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SampledStat&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 记录和统计的抽象类来好好的深入分析理解一下。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;SampledStat 样本记录统计抽象类&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;这个记录统计抽象类,是按照采样的形式来计算的。里面使用了一个或者多个样本进行采样统计 &lt;/span&gt;&lt;code&gt;&lt;span&gt;List&amp;lt;Sample&amp;gt; samples&lt;/span&gt;&lt;/code&gt;&lt;span&gt;; 当前使用的样本: &lt;/span&gt;&lt;code&gt;&lt;span&gt;current&lt;/span&gt;&lt;/code&gt;&lt;span&gt;样本初始化的值: &lt;/span&gt;&lt;code&gt;&lt;span&gt;initialValue&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;code&gt;SampledStat :&lt;/code&gt;&lt;/strong&gt; 实现了&lt;/span&gt;&lt;code&gt;&lt;span&gt;MeasurableStat&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的抽象类,说明它又能采集记录数据,又能统计分析数据&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;当然它自身也定义了有两个抽象方法&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;  &lt;span&gt;/** 更新具体样本的数值 (单个样本)**/&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;&lt;span&gt;(Sample sample, MetricConfig config, &lt;span&gt;double&lt;/span&gt; value, &lt;span&gt;long&lt;/span&gt; timeMs)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;  &lt;span&gt;/**组合所有样本的数据 来统计出想要的数据 **/&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; &lt;span&gt;combine&lt;/span&gt;&lt;span&gt;(List&amp;lt;Sample&amp;gt; samples, MetricConfig config, &lt;span&gt;long&lt;/span&gt; now)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5743283582089552&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmWVxLDDVAXanWpBUwgJpibGt5zCApiaqIhzWpq6lNia8Jic0KPbrrrIERpVvib0GEsGhLuPUfAnNXRq2nzhJia0h8QQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1675&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;SampledStat图形化展示&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如上图所示, 是一个&lt;/span&gt;&lt;code&gt;&lt;span&gt;SampledStat&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的图形化展示, 其中定义了 若干个样本 Sample&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;记录数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;record&lt;/span&gt;&lt;span&gt;(MetricConfig config, &lt;span&gt;double&lt;/span&gt; value, &lt;span&gt;long&lt;/span&gt; timeMs)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Sample sample = current(timeMs);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (sample.isComplete(timeMs, config))&lt;br/&gt;            sample = advance(config, timeMs);&lt;br/&gt;        update(sample, config, value, timeMs);&lt;br/&gt;        sample.eventCount += &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取当前的&lt;strong&gt;Sample&lt;/strong&gt;号,如果没有则创建一个新的&lt;strong&gt;Sample&lt;/strong&gt;,  创建的时候设置 &lt;strong&gt;初始化值&lt;/strong&gt; 和 &lt;strong&gt;Sample起始时间(当前时间)&lt;/strong&gt; ,并保存到样品列表里面&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;判断这个&lt;strong&gt;Sample&lt;/strong&gt;是否完成(超过窗口期),判断的逻辑是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;当前时间 - 当前Sample的开始时间 &amp;gt;= 配置的时间窗口值 或者 事件总数 &amp;gt;= 配置的事件窗口值&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;  &lt;span&gt;/** 当前时间 - 当前Sample的开始时间 &amp;gt;= 配置的时间窗口值 或者  事件总数 &amp;gt;= 配置的事件窗口值 **/&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;isComplete&lt;/span&gt;&lt;span&gt;(&lt;span&gt;long&lt;/span&gt; timeMs, MetricConfig config)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; timeMs - lastWindowMs &amp;gt;= config.timeWindowMs() || eventCount &amp;gt;= config.eventWindow();&lt;br/&gt;        }&lt;br/&gt;        &lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果这个&lt;strong&gt;Sample&lt;/strong&gt;已经完成(超过窗口期), 则开始选择下一个窗口,如果下一个还没创建则创建新的,如果下一个已经存在,则重置这个&lt;strong&gt;Sample&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;拿到最终要使用的&lt;strong&gt;Sample&lt;/strong&gt;后, 将数据记录到这个&lt;strong&gt;Sample&lt;/strong&gt;中。具体怎么记录是让具体的实现类来实现的,因为想要最终统计的数据可以不一样,比如你只想记录&lt;strong&gt;Sample&lt;/strong&gt;中的最大值,那么更新的时候判断是不是比之前的值大则更新,如果你想统计平均值,那么这里就让单个&lt;strong&gt;Sample&lt;/strong&gt;中所有的值累加（最终会 除以 &lt;strong&gt;Sample&lt;/strong&gt;数量 求平均数的）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;记录事件次数+1。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7342549923195084&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmWVxLDDVAXanWpBUwgJpibGt5zCApiaqIrvwjJZBA6pBGbSnNyIBjLickSicOFmveOtq8yrDfOpGic38hXAR1p3HPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1302&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;记录数据的展示图&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;统计数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;    &lt;span&gt;/** 测量  统计 数据**/&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt; &lt;span&gt;measure&lt;/span&gt;&lt;span&gt;(MetricConfig config, &lt;span&gt;long&lt;/span&gt; now)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 重置过期样本&lt;/span&gt;&lt;br/&gt;        purgeObsoleteSamples(config, now);&lt;br/&gt;        &lt;span&gt;// 组合所有样本数据,并展示最终统计数据,具体实现类来实现该方法&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; combine(&lt;span&gt;this&lt;/span&gt;.samples, config, now);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;先重置 &lt;strong&gt;过期样本&lt;/strong&gt; , 过期样本的意思是：当前时间 - 每个样本的起始事件 &amp;gt; 样本数量 * 每个样本的窗口时间 ; 就是滑动窗口的概念,只统计这个滑动窗口的样本数据, 过期的样本数据会被重置(过期数据不采纳), 如下图所示&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7391834247410116&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmWVxLDDVAXanWpBUwgJpibGt5zCApiaqIIQnpvicsGEoXfOUkzbAfHC3wBeAOtT4KsNmv9icdR6qG4t8ib8kKicFDHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1641&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;滑动窗口重置过期数据&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;组合所有样本数据并进行不同维度的统计并返回数值, 因为不同场景想要得到的数据不同，所以这个只是一个抽象方法,需要实现类来实现这个计算逻辑,比如如果是计算平均值 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Avg&lt;/span&gt;&lt;/code&gt;&lt;span&gt;, 它的计算逻辑就是把所有的&lt;strong&gt;样本数据值累加&lt;/strong&gt;并除以&lt;strong&gt;累积的次数&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那我们再来看看不同的统计实现类&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;Avg 计算平均值&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;一个简单的&lt;/span&gt;&lt;code&gt;&lt;span&gt;SampledStat&lt;/span&gt;&lt;/code&gt;&lt;span&gt;实现类 它统计所有样本最终的平均值 每个样本都会累加每一次的记录值， 最后把所有样本数据叠加 / 总共记录的次数&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5128205128205128&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmWVxLDDVAXanWpBUwgJpibGt5zCApiaqIynmmL1SJb5U0O9vk3NHERDGVBSmic4tnhqoOCgFajO1BMVUmBF87trA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;780&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;在这里插入图片描述&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;Max 计算最大值&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;每个样本都保存这个样本的最大值, 然后最后再对比所有样本值的最大值&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5155844155844156&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmWVxLDDVAXanWpBUwgJpibGt5zCApiaqIb0k37jd2xumPZn3BtDZtHFyoXkzRQibk95u1fCH04eQrlOLrlSibzIGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;770&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;在这里插入图片描述&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;WindowedSum 所有样本窗口总和值&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;每个样本累积每一次的记录值, 统计的时候 把所有样本的累计值 再累积返回&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.42503259452411996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmWVxLDDVAXanWpBUwgJpibGt5zCApiaqIMlqkfQNAjSlqJGAKNFpDLItiak2g3PPpruvZjH1fNGtOC38fU2iaoZEg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;767&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;在这里插入图片描述&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Rate 样本记录统计求速率&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;Rate&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 也是实现了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;MeasurableStat&lt;/span&gt;&lt;/code&gt;&lt;span&gt;接口的,说明 它也有 记录&lt;/span&gt;&lt;code&gt;&lt;span&gt;record&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和 统计 &lt;/span&gt;&lt;code&gt;&lt;span&gt;measure&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的方法, 实际上这个类 是一个组合类 ，里面组合了 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SampledStat&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 和&lt;/span&gt;&lt;code&gt;&lt;span&gt;TimeUnit unit&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ,这不是很明显了么, SampledStat负责记录和统计, 得到的数据 跟时间&lt;/span&gt;&lt;code&gt;&lt;span&gt;TimeUnit&lt;/span&gt;&lt;/code&gt;&lt;span&gt;做一下处理就得出来速率了, 比如&lt;/span&gt;&lt;code&gt;&lt;span&gt;SampledStat&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的实现类&lt;/span&gt;&lt;code&gt;&lt;span&gt;AVG&lt;/span&gt;&lt;/code&gt;&lt;span&gt;可以算出来 被统计的 评价值, 但是如果我们再除以 一个时间维度, 是不是就可以得出 &lt;strong&gt;平均速率&lt;/strong&gt; 了&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;如何计算统计的有效时间呢&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个&lt;strong&gt;有效时间&lt;/strong&gt; 的计算会影响着最终&lt;strong&gt;速率&lt;/strong&gt;的结果&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;   &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; &lt;span&gt;windowSize&lt;/span&gt;&lt;span&gt;(MetricConfig config, &lt;span&gt;long&lt;/span&gt; now)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;// 将过期的样本给重置掉&lt;/span&gt;&lt;br/&gt;        stat.purgeObsoleteSamples(config, now);&lt;br/&gt;        &lt;span&gt;// 总共运行的时候 = 当前时间 - 最早的样本的开始时间&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;long&lt;/span&gt; totalElapsedTimeMs = now - stat.oldest(now).lastWindowMs;&lt;br/&gt;        &lt;span&gt;// 总时间/单个创建时间 = 多少个完整的窗口时间&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; numFullWindows = (&lt;span&gt;int&lt;/span&gt;) (totalElapsedTimeMs / config.timeWindowMs());&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; minFullWindows = config.samples() - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;// If the available windows are less than the minimum required, add the difference to the totalElapsedTime&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (numFullWindows &amp;lt; minFullWindows)&lt;br/&gt;            totalElapsedTimeMs += (minFullWindows - numFullWindows) * config.timeWindowMs();&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; totalElapsedTimeMs;&lt;br/&gt;    }&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这是Rate的有效时间的计算逻辑,当然&lt;/span&gt;&lt;code&gt;&lt;span&gt;Rate&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 还有一个子类是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;SampleRate&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.35199004975124376&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmWVxLDDVAXanWpBUwgJpibGt5zCApiaqIISfQmfx9c7IXN5c3woY2hdwrhlEMZFRoZFdkeP50iadqVrRlx9b38Ng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;804&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;SampleRate的窗口Size计算逻辑&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个子类,将 有效时间的计算逻辑改的更简单, 如果运行时间&amp;lt;一个样本窗口的时间 则他的运行时间就是单个样本的窗口时间, 否则就直接用这个运行的时间, 这个计算逻辑更简单 它跟&lt;/span&gt;&lt;code&gt;&lt;span&gt;Rate&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的区别就是, 不考虑采样的时间是否足够多,我们用图来简单描述一下&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;SampleRate&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9505376344086022&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmWVxLDDVAXanWpBUwgJpibGt5zCApiaqIq2f3bF8Uqian6xZDaKnGek8sqX3EDrpsQTKS2GCgHkOHrKibDFBX4ATg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;930&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;SampleRate 速率逻辑&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;Rate&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8142031379025598&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmWVxLDDVAXanWpBUwgJpibGt5zCApiaqIibph8DTOC76lwpB9Sme0VqibD3sYEa9rgpABt9THLeIHna6m5N7l0Iag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1211&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;Rate 速率逻辑&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Meter 包含速率和累积总指标的复合统计数据&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;这是一个&lt;/span&gt;&lt;code&gt;&lt;span&gt;CompoundStat&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的实现类, 说明它是一个复合统计, 可以统计很多指标在这里面 它包含速率指标和累积总指标的复合统计数据&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;底层实现的逻辑还是上面讲解过的&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;副本Fetch流量的速率统计 案例分析&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;我们知道 在分区副本重分配过程中,有一个限流机制,就是指定某个限流值,副本同步过程不能超过这个阈值。&lt;/span&gt;&lt;span&gt;做限流,那么肯定首先就需要统计 副本同步 的流速；&lt;/span&gt;&lt;span&gt;那么上面我们&lt;/span&gt;讲&lt;span&gt;了这么多,你应该很容易能够想到如果统计了吧？&lt;/span&gt;&lt;span&gt;流速  bytes/s , 统计一秒钟同步了多少流量, 那么我们可以把样本窗口设置为 &lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;1s&lt;/span&gt;&lt;/code&gt;&lt;span&gt;,然后多设置几个样本窗口求平均值。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来我们看看 Kafka是怎么统计的, 首先找到记录 Follower Fetch 副本流量的地方如下&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;ReplicaFetcherThread#processPartitionData&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;if&lt;/span&gt;(quota.isThrottled(topicPartition))&lt;br/&gt;  quota.record(records.sizeInBytes)&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7287390029325513&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmWVxLDDVAXanWpBUwgJpibGt5zCApiaqI7wHl46wLCJSBK0zFtPbia2M7g2K0GpkNPaTmEuTE7TDZyE6yvru03EA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;682&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;设置时间窗口配置&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里设置的&lt;/span&gt;&lt;code&gt;&lt;span&gt;timeWindowMs&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 单个样本窗口时间= 1 s&lt;/span&gt;&lt;code&gt;&lt;span&gt;numQuotaSamples&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 样本数 = 11 当然这些都是可以配置的&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5091277890466531&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kmWVxLDDVAXanWpBUwgJpibGt5zCApiaqICPzSJ49NZaNmJTN1GjX7oRaERicQBhDvtypDqs2nVC4D1asD5RjSHKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;986&quot;/&gt;&lt;figcaption&gt;&lt;span&gt;查看使用了哪个实现类&lt;/span&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们可以看到最终是使用了 &lt;strong&gt;&lt;code&gt;SampleRate&lt;/code&gt;&lt;/strong&gt; 来统计流量 !&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Gauge 瞬时读数的指标&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;上面我们起始是主要讲解了&lt;/span&gt;&lt;code&gt;&lt;span&gt;Measurable&lt;/span&gt;&lt;/code&gt;&lt;span&gt;接口, 它的父类是&lt;/span&gt;&lt;code&gt;&lt;span&gt;MetricValueProvider&amp;lt;Double&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ,它没有方法,只是定义,当还有一个子接口是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;Gauge&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ,它并不是上面那种采样的形式来统计数据, 它返回的是当前的值, &lt;span&gt;&lt;strong&gt;瞬时值&lt;/strong&gt;&lt;/span&gt;它提供的方法是 &lt;/span&gt;&lt;code&gt;&lt;span&gt;value()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ， &lt;/span&gt;&lt;code&gt;&lt;span&gt;Measurable&lt;/span&gt;&lt;/code&gt;&lt;span&gt;提供的是&lt;/span&gt;&lt;code&gt;&lt;span&gt;measure()&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个在kafka中使用场景很少,就不详细介绍了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;好了,这一篇我们主要讲解了一下 Kafka中的数据采集和统计机制&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么 接下来下一篇,我们来聊聊 Kafka的监控机制, 如何把这些采集&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;到的信息给保存起来并对外提供!!!&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>03f0f2569efb5c63dba2dd5fc3d18a96</guid>
<title>Python 远程连接服务器，用它就够了</title>
<link>https://toutiao.io/k/2fgxo80</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6666666666666666&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/atOH362Boyvxhic5qr1MyXN1TFKUQAy0OZA8rnOSIfHAJNhCpK0hV0ySMSwsbA3e6ydd47MaZb3zhyVXY9bk40Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;在使用 Python 写一些脚本的时候，在某些情况下，我们需要频繁登陆远程服务去执行一次命令，并返回一些结果。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;在 shell 环境中，我们是这样子做的。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; sshpass -p &lt;span&gt;${passwd}&lt;/span&gt; ssh -p &lt;span&gt;${port}&lt;/span&gt; -l &lt;span&gt;${user}&lt;/span&gt; -o StrictHostKeyChecking=no xx.xx.xx.xx &lt;span&gt;&quot;ls -l&quot;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后你会发现，你的输出有很多你并不需要，但是又不去不掉的一些信息（也许有方法，请留言交流），类似这样&lt;/p&gt;&lt;pre&gt;&lt;code&gt;host: xx.xx.xx.xx, port: xx&lt;br/&gt;Warning: Permanently added &#x27;[xx.xx.xx.xx]:xx&#x27; (RSA) to the list of known hosts.&lt;br/&gt;Login failure: [Errno 1] This server is not registered to rmp platform, please confirm whether cdn server.&lt;br/&gt;total 4&lt;br/&gt;-rw-r--r-- 1 root root 239 Mar 30  2018 admin-openrc&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于直接使用 shell 命令，来执行命令的，可以直接使用管道，或者将标准输出重定向到文件的方法取得执行命令返回的结果&lt;/p&gt;&lt;h2&gt;&lt;span&gt;# &lt;/span&gt;&lt;span&gt;1. 使用 subprocess&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;若是使用 Python 来做这件事，通常我们会第一时间，想到使用 os.popen，os.system，commands，subprocess 等一些命令执行库来间接获取 。&lt;/p&gt;&lt;p&gt;但是据我所知，这些库获取的 output 不仅只有标准输出，还包含标准错误（也就是上面那些多余的信息）&lt;/p&gt;&lt;p&gt;所以每次都要对 output 进行的数据清洗，然后整理格式化，才能得到我们想要的数据。&lt;/p&gt;&lt;p&gt;用 subprocess 举个例子，就像这样子&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; subprocess&lt;br/&gt;ssh_cmd = &lt;span&gt;&quot;sshpass -p ${passwd} ssh -p 22 -l root -o StrictHostKeyChecking=no xx.xx.xx.xx  &#x27;ls -l&#x27;&quot;&lt;/span&gt;&lt;br/&gt;status, output = subprocess.getstatusoutput(ssh_cmd)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 数据清理，格式化的就不展示了&lt;/span&gt;&lt;br/&gt;&amp;lt;code...&amp;gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过以上的文字 + 代码的展示 ，可以感觉到 ssh 登陆的几大痛点&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;痛点一&lt;/strong&gt;：需要额外安装 sshpass（如果不免密的话）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;痛点二&lt;/strong&gt;：干扰信息太多，数据清理、格式化相当麻烦&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;痛点三&lt;/strong&gt;：代码实现不够优雅（有点土），可读性太差&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;痛点四&lt;/strong&gt;：ssh 连接不能复用，一次连接仅能执行一次&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;痛点五&lt;/strong&gt;：代码无法全平台，仅能在 Linux 和 OSX 上使用&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;为了解决这几个问题，我搜索了全网关于 Python SSH 的文章，&lt;span&gt;还真的被我找到了两个库&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;# &lt;/span&gt;&lt;span&gt;2. 使用 sh.ssh&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;首先来介绍第一个，&lt;code&gt;sh.ssh&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;sh&lt;/code&gt; 是一个可以让你通过函数的调用来完成 Linxu/OSX 系统命令的一个库，非常好用，关于它有机会也写篇介绍。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; python3 -m pip install sh&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;今天只介绍它其中的一个函数：&lt;code&gt;ssh&lt;/code&gt;&lt;/p&gt;&lt;p&gt;通常两台机器互访，为了方便，可设置免密登陆，这样就不需要输入密码。&lt;/p&gt;&lt;p&gt;这段代码可以实现免密登陆，并执行我们的命令 &lt;code&gt;ls -l&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; sh &lt;span&gt;import&lt;/span&gt; ssh&lt;br/&gt;output=ssh(&lt;span&gt;&quot;root@xx.xx.xx.xx&quot;&lt;/span&gt;, &lt;span&gt;&quot;-p 22&quot;&lt;/span&gt;, &lt;span&gt;&quot;ls -l&quot;&lt;/span&gt;)&lt;br/&gt;print(output)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但有可能 ，我们并不想设置互信免密，为了使这段代码更通用，我假定我们没有设置免密，只能使用密码进行登陆。&lt;/p&gt;&lt;p&gt;问题就来了，要输入密码，必须得使用交互式的方法来输入呀，在 Python 中要如何实现呢？&lt;/p&gt;&lt;p&gt;原来 ssh 方法接收一个 &lt;code&gt;_out&lt;/code&gt; 参数，这个参数可以为一个字符串，表示文件路径，也可以是一个文件对象（或者类文件对象），还可以是一个回调函数，意思是当有标准输出时，就会调用将输出内容传给这个函数。&lt;/p&gt;&lt;p&gt;这就好办了呀。&lt;/p&gt;&lt;p&gt;我只要识别到有 &lt;code&gt;password:&lt;/code&gt; 字样，就往标准输入写入我的密码就好了呀。&lt;/p&gt;&lt;p&gt;完整代码如下：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; sys&lt;br/&gt;&lt;span&gt;from&lt;/span&gt; sh &lt;span&gt;import&lt;/span&gt; ssh&lt;br/&gt;&lt;br/&gt;aggregated = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;ssh_interact&lt;/span&gt;&lt;span&gt;(char, stdin)&lt;/span&gt;:&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;global&lt;/span&gt; aggregated&lt;br/&gt;    sys.stdout.write(char.encode())&lt;br/&gt;    sys.stdout.flush()&lt;br/&gt;    aggregated += char&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; aggregated.endswith(&lt;span&gt;&quot;password: &quot;&lt;/span&gt;):&lt;br/&gt;        stdin.put(&lt;span&gt;&quot;you_password\n&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;output=ssh(&lt;span&gt;&quot;root@xx.xx.xx.xx&quot;&lt;/span&gt;, &lt;span&gt;&quot;-p 22&quot;&lt;/span&gt;, &lt;span&gt;&quot;ls -l&quot;&lt;/span&gt;,_tty_in=&lt;span&gt;True&lt;/span&gt;, _out_bufsize=&lt;span&gt;0&lt;/span&gt;, _out=ssh_interact)&lt;br/&gt;print(output)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是官方文档（http://amoffat.github.io/sh/tutorials/interacting_with_processes.html?highlight=ssh）给的一些信息，写的一个demo。&lt;/p&gt;&lt;p&gt;尝试运行后，发现程序会一直在运行中，永远不会返回，不会退出，回调函数也永远不会进入。&lt;/p&gt;&lt;p&gt;通过调试查看源代码，仍然查不到问题所在，于是去 Github 上搜了下，原来在 2017 年就已经存在这个问题了，到现在 2020 年了还没有修复，看来使用 &lt;code&gt;sh.ssh&lt;/code&gt; 的人并不多，于是我又“追问”了下，期望能得到回复。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0226939970717424&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QB6G4ZoE187ibjO4ia2ib5XKbkicaVH0VArIGnVQclicxS0UyN4pBKJEJuQyDAKXoDwQFxfmZjGYLoZk0KtBpJ6Sa2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1366&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;以上这个问题，只有在需要输入密码才会出现，如果设置了机器互信是没有问题的。&lt;/p&gt;&lt;p&gt;为了感受 &lt;code&gt;sh.ssh&lt;/code&gt; 的使用效果，我设置了机器互信免密，然后使用如下这段代码。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;from&lt;/span&gt; sh &lt;span&gt;import&lt;/span&gt; ssh&lt;br/&gt;&lt;br/&gt;my_server=ssh.bake(&lt;span&gt;&quot;root@xx.xx.xx.xx&quot;&lt;/span&gt;, &lt;span&gt;&quot;-p 22&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 相当于执行登陆一次执行一次命令，执行完就退出登陆&lt;/span&gt;&lt;br/&gt;print(my_server.ls())&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 可在 sleep 期间，手动登陆服务器，使用 top ，查看当前有多少终端在连接&lt;/span&gt;&lt;br/&gt;time.sleep(&lt;span&gt;5&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 再次执行这条命令时，登陆终端数将 +1，执行完后，又将 -1&lt;/span&gt;&lt;br/&gt;print(my_server.ifconfig())&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;惊奇地发现使用 &lt;code&gt;bake&lt;/code&gt; 这种方式，&lt;code&gt;my_server.ls()&lt;/code&gt; 和 &lt;code&gt;my_server.ifconfig()&lt;/code&gt; 这种看似是通过同一个ssh连接，执行两次命令，可实际上，你可以在远程机器上，执行 top 命令看到已连接的终端的变化，会先 &lt;code&gt;+1&lt;/code&gt; 再 &lt;code&gt;-1&lt;/code&gt;，说明两次命令的执行是通过两次连接实现的。&lt;/p&gt;&lt;p&gt;如此看来，使用 &lt;code&gt;sh.ssh&lt;/code&gt; 可以解决痛点一（如果上述问题能得到解决）、痛点二、痛点三。&lt;/p&gt;&lt;p&gt;但是它仍然无法复用 ssh 连接，还是不太方便，不是我理想中的最佳方案。&lt;/p&gt;&lt;p&gt;最重要的一点是， &lt;code&gt;sh&lt;/code&gt; 这个模块，仅支持  Linxu/OSX ，在 Windows 你得使用它的兄弟库 - &lt;code&gt;pbs&lt;/code&gt; ，然后我又去  pypi 看了一眼 pbs，已经 “年久失修”，没人维护了。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.20748059280169373&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QB6G4ZoE187ibjO4ia2ib5XKbkicaVH0VArITtSOwp02y0YLKib5Pe9iaQeqMZL4nJz5yaSJwjCUZs945uDA47FYJqFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1417&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;至此，我离 “卒”，就差最后一根稻草了。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;# &lt;/span&gt;&lt;span&gt;3. 使用 paramiko&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;带着最后一丝希望，我尝试使用了 &lt;code&gt;paramiko&lt;/code&gt; 这个库，终于在 &lt;code&gt;paramiko&lt;/code&gt; 这里，找回了本应属于 Python 的那种优雅。&lt;/p&gt;&lt;p&gt;你可以通过如下命令去安装它&lt;/p&gt;&lt;pre&gt;&lt;code&gt;$ python3 -m pip install paramiko&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后接下来，就介绍几种常用的 ssh 登陆的方法&lt;/p&gt;&lt;h3&gt; &lt;span&gt;方法1：基于用户名和密码的 sshclient 方式登录&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;然后你可以参考如下这段代码，在 Linux/OSX 系统下进行远程连接&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; paramiko&lt;br/&gt;&lt;br/&gt;ssh = paramiko.SSHClient()&lt;br/&gt;&lt;span&gt;# 允许连接不在know_hosts文件中的主机&lt;/span&gt;&lt;br/&gt;ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 建立连接&lt;/span&gt;&lt;br/&gt;ssh.connect(&lt;span&gt;&quot;xx.xx.xx.xx&quot;&lt;/span&gt;, username=&lt;span&gt;&quot;root&quot;&lt;/span&gt;, port=&lt;span&gt;22&lt;/span&gt;, password=&lt;span&gt;&quot;you_password&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 使用这个连接执行命令&lt;/span&gt;&lt;br/&gt;ssh_stdin, ssh_stdout, ssh_stderr = ssh.exec_command(&lt;span&gt;&quot;ls -l&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 获取输出&lt;/span&gt;&lt;br/&gt;print(ssh_stdout.read())&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 关闭连接&lt;/span&gt;&lt;br/&gt;ssh.close()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt; &lt;span&gt;方法2：基于用户名和密码的 transport 方式登录&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;方法1 是传统的连接服务器、执行命令、关闭的一个操作，多个操作需要连接多次，无法复用连接[&lt;strong&gt;痛点四&lt;/strong&gt;]。&lt;/p&gt;&lt;p&gt;有时候需要登录上服务器执行多个操作，比如执行命令、上传/下载文件，方法1 则无法实现，那就可以使用 transport 的方法。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; paramiko&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 建立连接&lt;/span&gt;&lt;br/&gt;trans = paramiko.Transport((&lt;span&gt;&quot;xx.xx.xx.xx&quot;&lt;/span&gt;, &lt;span&gt;22&lt;/span&gt;))&lt;br/&gt;trans.connect(username=&lt;span&gt;&quot;root&quot;&lt;/span&gt;, password=&lt;span&gt;&quot;you_passwd&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 将sshclient的对象的transport指定为以上的trans&lt;/span&gt;&lt;br/&gt;ssh = paramiko.SSHClient()&lt;br/&gt;ssh._transport = trans&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 剩下的就和上面一样了&lt;/span&gt;&lt;br/&gt;ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())&lt;br/&gt;ssh_stdin, ssh_stdout, ssh_stderr = ssh.exec_command(&lt;span&gt;&quot;ls -l&quot;&lt;/span&gt;)&lt;br/&gt;print(ssh_stdout.read())&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 关闭连接&lt;/span&gt;&lt;br/&gt;trans.close()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt; &lt;span&gt;方法3：基于公钥密钥的 SSHClient 方式登录&lt;/span&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; paramiko&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 指定本地的RSA私钥文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 如果建立密钥对时设置的有密码，password为设定的密码，如无不用指定password参数&lt;/span&gt;&lt;br/&gt;pkey = paramiko.RSAKey.from_private_key_file(&lt;span&gt;&#x27;/home/you_username/.ssh/id_rsa&#x27;&lt;/span&gt;, password=&lt;span&gt;&#x27;12345&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 建立连接&lt;/span&gt;&lt;br/&gt;ssh = paramiko.SSHClient()&lt;br/&gt;ssh.connect(hostname=&lt;span&gt;&#x27;xx.xx.xx.xx&#x27;&lt;/span&gt;,&lt;br/&gt;            port=&lt;span&gt;22&lt;/span&gt;,&lt;br/&gt;            username=&lt;span&gt;&#x27;you_username&#x27;&lt;/span&gt;,&lt;br/&gt;            pkey=pkey)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 执行命令&lt;/span&gt;&lt;br/&gt;stdin, stdout, stderr = ssh.exec_command(&lt;span&gt;&#x27;ls -l&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 结果放到stdout中，如果有错误将放到stderr中&lt;/span&gt;&lt;br/&gt;print(stdout.read())&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 关闭连接&lt;/span&gt;&lt;br/&gt;ssh.close()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt; &lt;span&gt;方法4：基于密钥的 Transport 方式登录&lt;/span&gt;&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; paramiko&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 指定本地的RSA私钥文件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 如果建立密钥对时设置的有密码，password为设定的密码，如无不用指定password参数&lt;/span&gt;&lt;br/&gt;pkey = paramiko.RSAKey.from_private_key_file(&lt;span&gt;&#x27;/home/you_username/.ssh/id_rsa&#x27;&lt;/span&gt;, password=&lt;span&gt;&#x27;12345&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 建立连接&lt;/span&gt;&lt;br/&gt;trans = paramiko.Transport((&lt;span&gt;&#x27;xx.xx.xx.xx&#x27;&lt;/span&gt;, &lt;span&gt;22&lt;/span&gt;))&lt;br/&gt;trans.connect(username=&lt;span&gt;&#x27;you_username&#x27;&lt;/span&gt;, pkey=pkey)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 将sshclient的对象的transport指定为以上的trans&lt;/span&gt;&lt;br/&gt;ssh = paramiko.SSHClient()&lt;br/&gt;ssh._transport = trans&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 执行命令，和传统方法一样&lt;/span&gt;&lt;br/&gt;stdin, stdout, stderr = ssh.exec_command(&lt;span&gt;&#x27;df -hl&#x27;&lt;/span&gt;)&lt;br/&gt;print(stdout.read().decode())&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 关闭连接&lt;/span&gt;&lt;br/&gt;trans.close()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;以上四种方法，可以帮助你实现远程登陆服务器执行命令，如果需要复用连接：一次连接执行多次命令，可以使用 &lt;strong&gt;方法二&lt;/strong&gt; 和 &lt;strong&gt;方法四&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;用完后，记得关闭连接。&lt;/p&gt;&lt;h3&gt; &lt;span&gt;实现 sftp 文件传输&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;同时，paramiko 做为 ssh 的完美解决方案，它非常专业，利用它还可以实现 sftp 文件传输。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; paramiko&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 实例化一个trans对象# 实例化一个transport对象&lt;/span&gt;&lt;br/&gt;trans = paramiko.Transport((&lt;span&gt;&#x27;xx.xx.xx.xx&#x27;&lt;/span&gt;, &lt;span&gt;22&lt;/span&gt;))&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 建立连接&lt;/span&gt;&lt;br/&gt;trans.connect(username=&lt;span&gt;&#x27;you_username&#x27;&lt;/span&gt;, password=&lt;span&gt;&#x27;you_passwd&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 实例化一个 sftp对象,指定连接的通道&lt;/span&gt;&lt;br/&gt;sftp = paramiko.SFTPClient.from_transport(trans)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 发送文件&lt;/span&gt;&lt;br/&gt;sftp.put(localpath=&lt;span&gt;&#x27;/tmp/11.txt&#x27;&lt;/span&gt;, remotepath=&lt;span&gt;&#x27;/tmp/22.txt&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 下载文件&lt;/span&gt;&lt;br/&gt;sftp.get(remotepath=&lt;span&gt;&#x27;/tmp/22.txt&#x27;&lt;/span&gt;, localpath=&lt;span&gt;&#x27;/tmp/33.txt&#x27;&lt;/span&gt;)&lt;br/&gt;trans.close()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;到这里，Paramiko 已经完胜了，但是仍然有一个痛点我们没有提及，就是多平台，说的就是 Windows，这里就有一件好事，一件坏事了，。&lt;/p&gt;&lt;p&gt;好事就是：paramiko 支持 windows&lt;/p&gt;&lt;p&gt;坏事就是：你需要做很多复杂的准备，你可 google 解决，但是我建议你直接放弃，坑太深了。&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.14461738002594035&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/QB6G4ZoE187ibjO4ia2ib5XKbkicaVH0VArIglwtCU0Or77ia3VOl0j62Sn7bLlYDRU4HZYo3ZpME1l9Vcx0UyYsxNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1542&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h3&gt; &lt;span&gt;注意事项&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;使用 paramiko 的时候，有一点需要注意一下，这个也是我自己 &quot;踩坑&quot; 后才发现的，其实我觉得这个设计挺好的，如果你不需要等待它返回数据，可以直接实现异步效果，只不过对于不知道这个设计的人，确实是个容易掉坑的点&lt;/p&gt;&lt;p&gt;就是在执行 &lt;code&gt;ssh.exec_command(cmd)&lt;/code&gt; 时，这个命令并不是同步阻塞的。&lt;/p&gt;&lt;p&gt;比如下面这段代码，执行时，你会发现 脚本立马就结束退出了，并不会等待 5 s 后，再 执行 ssh.close()&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; paramiko&lt;br/&gt;&lt;br/&gt;trans = paramiko.Transport((&lt;span&gt;&quot;172.20.42.1&quot;&lt;/span&gt;, &lt;span&gt;57891&lt;/span&gt;))&lt;br/&gt;trans.connect(username=&lt;span&gt;&quot;root&quot;&lt;/span&gt;, password=&lt;span&gt;&quot;youpassword&quot;&lt;/span&gt;)&lt;br/&gt;ssh = paramiko.SSHClient()&lt;br/&gt;ssh._transport = trans&lt;br/&gt;stdin, stdout, stderr = ssh.exec_command(&lt;span&gt;&quot;sleep 5;echo ok&quot;&lt;/span&gt;)&lt;br/&gt;ssh.close()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是如果改成这样，加上一行 stdout.read()， paramiko 就知道，你需要这个执行的结果，就会在 read() 进行阻塞。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; paramiko&lt;br/&gt;&lt;br/&gt;trans = paramiko.Transport((&lt;span&gt;&quot;172.20.42.1&quot;&lt;/span&gt;, &lt;span&gt;57891&lt;/span&gt;))&lt;br/&gt;trans.connect(username=&lt;span&gt;&quot;root&quot;&lt;/span&gt;, password=&lt;span&gt;&quot;youpassword&quot;&lt;/span&gt;)&lt;br/&gt;ssh = paramiko.SSHClient()&lt;br/&gt;ssh._transport = trans&lt;br/&gt;stdin, stdout, stderr = ssh.exec_command(&lt;span&gt;&quot;sleep 5;echo ok&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 加上一行 read()&lt;/span&gt;&lt;br/&gt;print(stdout.read())&lt;br/&gt;ssh.close()&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;&lt;span&gt;# &lt;/span&gt;&lt;span&gt;4. 写在最后&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;经过了一番对比，和一些实例的展示，可以看出 Paramiko 是一个专业、让人省心的 ssh 利器，个人认为 Paramiko 模块是运维人员必学模块之一，如果你恰好需要在 Python 代码中实现 ssh 到远程服务器去获取一些信息，那么我把 Paramiko 推荐给你。&lt;/p&gt;&lt;p&gt;最后，希望这篇文章，能给你带来帮助。&lt;/p&gt;&lt;h2&gt;&lt;span&gt;# &lt;/span&gt;&lt;span&gt;5. 参考链接&lt;/span&gt;&lt;/h2&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://github.com/paramiko/paramiko&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;http://docs.paramiko.org&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;https://www.liujiangblog.com/blog/15/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;http://docs.paramiko.org/en/stable/&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.07625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/WLXa0NsmXuiap5yprf7DJXhpdhC0XIBAopbpFTUe1eSSuGbT5Kg63CPBicfpxwLAFIm2wPkicB5NWdSicbzziaibPXSA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU1OTI0NjI1NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/atOH362BoyuUe1icelWmbMyTCRwoFPScmosYQheSZ9wsmr61Bfr2rvNav9j9QpDnUulNpCotEiaAoLzSAm4jZTjA/0?wx_fmt=png&quot; data-nickname=&quot;AirPython&quot; data-alias=&quot;AirPython&quot; data-signature=&quot;专注于Python爬虫/自动化/Web原创技术干货！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>352f66ab55aa2c5cdd98a4bc0104ce00</guid>
<title>腾讯自主研发动画组件PAG开源</title>
<link>https://toutiao.io/k/91ue8oz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PAG (Portable Animated Graphics) 是一套完整的动画工作流。它提供从AE导出插件，到桌面预览工具，再到各端的跨平台渲染SDK，助力于将AE动画方便快捷的应用于各平台终端。PAG目前是公司AVGenerator OTeam开源协同小组的核心组件之一，广泛应用于公司内外40余款主流APP或业务，涵盖UI动画、视频编辑、特效模板、服务端特效渲染等多个场景，于2022年1月开源至GitHub。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PAG（Portable Animated Graphics）是腾讯自主研发的一套完整的动画工作流解决方案，助力于将 AE 动画方便快捷的应用于各平台终端。和 Lottie、SVGA 相比，支持的 AE 特性更多，支持的平台更广（增加了 mac OS、Windows 和 Linux），性能方面也做了深层次的优化，支持图层编辑，可以与视频编辑场景紧密结合。目前已经广泛应用于公司内外几十款 APP，包括国民级 APP 微信、QQ、腾讯视频、QQ 音乐、QQ 空间等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文将会对 PAG 与 Lottie、SVGA 的工作流程、实现方案、性能等进行对比，并且将会介绍 PAG 特有的一些能力，为一些想要了解或接入 PAG 的开发同学提供一些参考。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、 工作流程&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面将对 Lottie、SVGA、PAG 的工作流程进行对比。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;1.1 Lottie 的工作流程&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面是 Lottie 的实现流程图，设计师使用 AE 设计好动画， 通过 bodymovin 插件将 AE 工程文件导出为 json 文件，在客户端(使用 Lottie SDK)解析，最后通过各平台原生渲染方案进行渲染，其中在 Android 平台上通过 Canvas 进行绘制，在 iOS 上通过 CALayer 进行绘制，在 web 端支持 SVG、Canvas 和 HTML 绘制。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5087179487179487&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasqzncyaCRKiaNShIFMgEOVqZxOXiaaqzfJicV4fruJEiapyPL2S1Ou47kM0icclibhUnB4QhJVRPia0jrYA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;975&quot;/&gt;&lt;figcaption&gt;图1 Lottie工作流程图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;rLottie 与 lottie 工作流一致，在 SDK 上实现不一样，rLottie 没有使用平台特定实现，是统一 C++实现。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;1.2 SVGA 工作流程&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SVGA 流程如图 2 所示，大体流程与 Lottie 类似，使用 SVGAConverter 插件导出，文件是 PB 序列化以后 zip 压缩的格式，在具体实现上通过设置帧率来生成一个配置文件，使得每一帧一个配置，每一帧都是关键帧，从而在绘制的过程中不用解析高阶插值。SVGA 在 Lottie 方案基础上进行了优化和完善，但是不支持复杂的矢量形状图层和特效。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.37309292649098474&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasqzncyaCRKiaNShIFMgEOVq3vBOV87N5SJgic1NvOoS7gdw7W0nslm7qqf4Z2SGSo8oQyj9temsopQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1442&quot;/&gt;&lt;figcaption&gt;图2 SVGA工作流程图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;1.3 PAG 的工作流程&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PAG 的流程类似 Lottie，设计师使用 AE 设计好动画以后，通过 PAGExporter 插件读取 AE 工程文件，根据具体需求选择矢量导出、BMP 预合成、混合导出方式中的一种导出一个 PAG 二进制文件，客户端对该 PAG 二进制文件进行解码、渲染，各端共享一套 C++实现，平台端只做接口封装。(导出插件：PAGExporter;桌面预览工具：PAGViewer;客户端渲染 SDK：PAG SDK)&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.38114754098360654&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasqzncyaCRKiaNShIFMgEOVqPrgCfq0U3edbHzkicUxrHibfD8dbupmlN3byxVNAQKDceu339iboiaILYw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1464&quot;/&gt;&lt;figcaption&gt;图3 PAG工作流程图&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上 3 个库的工作流程大体相似，不同之处在于导出和渲染。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、 实现方案对比&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面对 Lottie、SVGA 和 PAG 的实现方案进行对比。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.1 诞生背景&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Lottie 最早从UI动&lt;/span&gt;&lt;span&gt;画场景出发解决矢量动画渲染的问题，从官方社区来看，我们能容易发现 Lottie 的矢量基因，社区作品大多是矢量图形类动画。&lt;/span&gt;&lt;span&gt;SVGA 是 YY 直播的开发工程师 2017 年发布的一套跨平台动画解决方案，诞生于直播场景，SVG&lt;/span&gt;&lt;span&gt;A 不支持复杂矢量图形动画，对位图动画的支持超过 Lottie，其最初的目标是为了改善和弥&lt;/span&gt;&lt;span&gt;补Lottie。&lt;/span&gt;&lt;span&gt;不可否认，两者都是业界优化的动画解决方案。&lt;/span&gt;&lt;span&gt;PAG诞生于2016年，最初的原因是为了解决更为复杂的视频编辑场景下动画渲染问题，同时又完美覆盖了UI动画和直播场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个有意思的共同点，以上三种方案的作者都有比较丰富的 Flash 相关背景，都在把Flash完善动画工作流的实现方式带到移动端，三者出发的场景不同，因此实现的方式也会存在一些差异。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.2 导出插件&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lottie 和 SVGA 都使用 AE Script SDK 来导出 AE 工程，但是 AE Script SDK 本身存在一定限制，不能访问 AE 文件中的所有属性，PAG 则使用 AE C++ SDK，能访问 AE 文件中所有属性和一些高级 API，能够实现对 AE 文件的完整导出。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;2.3 SDK 实现&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;渲染层面&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lottie 和 SVGA 渲染层面的实现依赖平台端接口，因此不同平台会存在支持的 AE 特性有所差异、渲染效果不一致等问题。PAG 渲染层面使用 C++实现，所有平台共享同一套实现，平台端只是封装接口调用，提供渲染环境，因此 PAG 所有平台支持特性一致，渲染效果一致。rLottie 跟 PAG 类似，底层共享一套 C++实现，素材支持 lottie 的 json 文件，矢量渲染性能还不错，但缺少各平台封装，支持的 AE 特性不全，也不支持文本、序列帧等。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;渲染缓存层面&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lottie 和 SVGA 依赖平台端的接口绘制，只能依赖平台侧接口的渲染缓存，PAG 内部有三级缓存机制，从素材结构到渲染结构都有缓存，实现了非常高性能的绘制效率。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;文件格式方面&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lottie 导出素材格式是 json 文本，可读性高，但是承载 AE 特性能力差，文件体积大，解码速度慢。SVGA 使用 ProtoBuffer 序列化，解码速度快，最终生成的文件直接使用 zip 压缩。PAG 采用二进制的编码方法，配套自研编解码器，动态比特位压缩，冗余信息极少，文件体积最小，解码速度最快，且支持图片和音频信息编码。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;平台端支持方面&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前 Lottie 仅支持 Android、iOS、web、mac OS，SVGA 支持 Android、iOS 和 web 端，PAG 可以支持到 Android、iOS、web、mac OS、windows、Linux，涵盖到所有平台。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、 动画文件及性能对比&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.1 矢量动画文件对比&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasqzncyaCRKiaNShIFMgEOVqUOj0Tng1bic5aRbvySAia9SicP2ibPaZJnmPibDYgjUfY6hDGMAWQMhsIag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;figcaption&gt;表1 动画文件对比&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上表所示，PAG 采用了动态比特位的压缩技术，动画文件可以做到足够小。相同的 AE 工程，PAG 导出的动画文件大小是 Lottie 动画文件的 51%，SVGA 动画文件的 22%。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;3.2 矢量动画渲染性能&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.39655172413793105&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasqzncyaCRKiaNShIFMgEOVqG0qPmVadTn4V3FDtutZIl0oEWRAsa9zcrEgZicuJXeiawPxJhS0TxcHA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1160&quot;/&gt;&lt;figcaption&gt;表2 矢量动画渲染性能对比&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如表所示，在矢量图形渲染方面，PAG 优化 Lottie 和 SVGA，内存占用方面会偏大一些。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4、 PAG 版本迭代与技术演进&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PAG 从第一行代码写下到现在已经经历了 5 年，期间经历了多个版本迭代：在 PAG 1.0 版本中，我们重点设计了高压缩率的文件格式，以及游戏引擎级别的跨平台的渲染架构。虽然还支持了带动画的文本编辑能力，但 1.0 版本跟 Lottie 一样仅覆盖了 AE 的纯矢量导出能力，很多复杂动画效果无法被完整还原。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是在 PAG 2.0 版本中，我们引入了 BMP 预合成的混合导出能力，同时解决了 AE 全特性的支持和可编辑性的问题。2.0 版本还引入了占位图替换的能力，为照片模板和视频模板的生产带来了工业化量产的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到 3.0 版本时，固定时间轴的模板已经越发没法满足需求，PAG 在编辑性上又进行了一步探索突破，开放了图层级别的原子编辑组合能力，支持了从原子特效组件动态构建模板，很好的支撑了游戏战报和一键出片等动态模板的需求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;截止到本月，PAG 4.0 版本的开发也接近收尾。这个版本耗时了近一年时间完成了在渲染架构上最大的一次升级，彻底脱离了谷歌的 Skia 2D 绘图库，PAG SDK 包体也直线下降了约 60%，并完成了包括 Web 平台在内的全平台覆盖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面详细介绍一下各个版本迭代过程中的重点技术演进细节：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.1 跨平台渲染架构&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PAG 方案最早就是诞生在视频编辑的场景下，要让动画能够在视频编辑场景下无缝整合使用，需要解决两个问题：支持离屏渲染绘制、子线程渲染。Lottie 的动画方案之所以无法应用在视频合成中，主要是因为依赖了平台相关的 UI 框架，开发成本较低，但也导致了它只能渲染到 UI 视图上，并且无法在子线程中使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;PAG 的整套动画方案就是基于 C++跨平台架构研发的，一直从最底层的动画插值器，还原到上层的时间轴和图层渲染树系统，虽然开发成本较高，但是所有端共享同一套代码，天然的能保障跨端渲染一致性。最重要的是能直接渲染到离屏纹理上，并完美支持子线程动画渲染。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5305105853051059&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavK7JjUiclNZCGovY0JzJTMzuJqAp9hLr2jScVDaUwwjLeCgic1WsDERBlQa5YU6bibqTWTfDia5LZYWw/640?wx_fmt=other&quot; data-type=&quot;other&quot; data-w=&quot;1606&quot;/&gt;&lt;/figure&gt;&lt;center data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;图4 PAG与视频渲染相结合&lt;/span&gt;&lt;/center&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在解决完整合视频渲染的问题后，还需要考虑怎么优化动画的性能。视频编辑的场景本身资源耗费比较高，每帧并行地存在多个视频解码以及各种特效处理，此时留给 PAG 的渲染时间就不太多。我们需要把 PAG 的渲染性能优化到极致，来满足视频编辑场景的实时预览需求。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;时间静态区间&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分析动画文件的特效，我们发现大部分的动画素材实际上并不是整个时间轴上都在变化，或多或少会存在一些画面静止的区间。而 PAG 在刷新时，如果遇到这些静态区间，会直接返回上一帧的动画内容，自动跳过任何重复的绘制。极限情况下，假设有一个一分钟的动画素材，但实际上全程都是静止的，它对 PAG 来说就相当于一张静态图片，整个刷新的过程中都是 0 开销。而在 Lottie 方案中，整个刷新过程都是全量的开销，因为它每帧都会清空屏幕重新刷新。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;三级缓存结构&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的解决思路是用空间来换时间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一个层面是文件缓存，主要解决 PAG 文件从文件解码到内存过程的耗时，同一个动画文件只需要解码一次，就可以放在多个动画实例中渲染，避免多个相同动画的重复解码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个层面是绘制缓存，解码后的文件有多个时间轴属性，我们将生成的绘制数据缓存到共享文件中，一个文件的任何一帧，只要绘制过一次，第二次绘制就可以得到加速。同时还利用了静态区间的特点来优化内存，将每个图层拆分成多个属性组，每个属性组计算出静态区间的列表后，只缓存每个静态区间第一帧数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三个层面是内容缓存，这个层级的加速效果是最明显的。通常情况下，图层的内容绘制是最耗时的，因为要经历栅格化等操作。但是内容一般不会随着时间轴变化，反而是轻量的矩阵参数会频繁的变化。根据这个原理，如果一个图层内容是静止的，我们会把他的内容缓存成一张纹理。这样整个时间轴上，只会经历一次栅格化的过程，后续每帧的绘制都可以复用第一帧的纹理，快速套用矩阵变换，接近零成本地渲染出动画效果。这里的内容缓存我们同样考虑了内存优化问题。例如一个动画文件预设的大小是 500x500，但是实际使用中，整体被缩放到了 50x50 的大小，那么内部创建的内容缓存，会对应的缩小相应的面积倍数。这样可以做到在保证清晰度的前提下，只缓存最小的面积。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.2 BMP 预合成&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在纯矢量的导出模式下，无论是那种实现方案，在众多的 AE 特性面前，都只支持将有限的 AE 特性导出渲染。因为在有桌面显卡的情况下，有部分 AE 特性都还需要跑进度条才能完成预览，在移动端根本没可能做到实时。另外还存在第三方 AE 插件的效果无法导出的问题。这在一定程度上限制了设计师的创造力。另一方面，由于相同的动画在 AE 中有很多实现方式，但性能却千差万别。于是我们思考如何解决众多 AE 特性支持的问题，通过分析 AE 提供的 SDK 的能力，我们发现 AE SDK 可以直接截图，可以导出任何效果，且包含第三方 AE 插件的效果，但缺点也很明显，图片无法进行编辑，如果通过截图的方式，文件会比较大。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5012562814070352&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavK7JjUiclNZCGovY0JzJTMz41Bj3kDliaXjNdmV8yv5LlhX9xYfnpeRfj2w235T5wLd35dhqWEjU8w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1592&quot;/&gt;&lt;/figure&gt;&lt;center data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;图5 BMP预合成导出实现&lt;/span&gt;&lt;/center&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;文件大问题解决&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对截图后文件比较大的问题（动画一般不低于 24 帧），我们首先想到了视频编码的极限帧间压缩能力，相对于原始的图片序列帧，可以压缩到百分之一点几的大小，另外视频格式还可以使用硬件解码，从而获得比较高的渲染性能。但这里遇到的一个问题是：动画一般都是透明的，而视频格式却不支持透明通道。于是我们视频编码的同时，扩展了透明通道，如上图所示，左边为 RGB 的视频内容，右边为 Alpha 通道的灰度图，最终渲染的时候再合并回 RGBA 的图片，从而实现对透明通道的支持。渲染的过程中，由于启用了硬件加速解码，可以直接得到一个 YUV 的纹理。我们在这里的优化点主要是不使用常见的 FFmpeg 来执行 YUV 到 RGB 转换，从而避免纹理在 CPU 和 GPU 之间来回拷贝，而是自定义了一个 Shader 脚本，利用硬件加速在一次绘制过程中，同时完成 YUV 转换和 Alpha 通道合并。这里平均就能够提高 10%的渲染性能。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可编辑性问题解决&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对 BMP 预合成无法编辑的特点，我们将 BMP 预合成支持的粒度由文件延伸到合成，支持矢量和 BMP 预合成混合导出，从而实现了支持所有的 AE 特性又能保持运行时的可编辑性。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.3 图层编辑能力&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在照片模板和视频模板不断地量产过程中，固定时间轴和尺寸的模板已经逐渐出现了在应用上的瓶颈。特别是当一键出片、王者战报等智能模板需求的出现，整个模板不是由固定的时间轴组成，而是可能由多个原子特效组件拼装而成，设计师即使投入非常高的人力，也无法针对每一种情况进行排列组合输出。这里对 PAG 的编辑能力也提出了进一步的挑战：就是要能对多个 PAG 文件，同时具有空间位置和时间轴的组合能力。由业务方去控制组合的规则。基于这个需求，我们引入了图层渲染树的编辑架构，不仅支持文本和占位图比编辑，还支持图层级别的编辑。一个文件就是一棵渲染树，支持图层级别的任意修改位置甚至增删图层，也可以把别的 PAG 文件添加到这棵渲染树中作为子树。能在空间维度上进行自由的排列摆放。而在时间轴的组合上，我们提供了 PAG 时间伸缩的能力，包含循环，变速，定格等多种自适应模式。每个图层又提供了起始时间的调整能力，能够自由设置在时间轴上的相对位置，能够灵活适配用户视频的时长。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7869481765834933&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavK7JjUiclNZCGovY0JzJTMzQfvicYWesVcoYddoBj3aUur6p0Pc2orzlZNX2xBvoAx1wVozH8RF4Rw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1042&quot;/&gt;&lt;/figure&gt;&lt;center data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;图6 PAG图层编辑&lt;/span&gt;&lt;/center&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过这些改造，新的接口不仅满足了智能模板的编辑性需求，也简化了原有业务调用的复杂度。例如原先业务上除了要构建外部的视频时间轴，还需要在渲染的过程中不断手动更新每个视频片段和 PAG 进度的对应关系。现在无论哪种使用场景，都可以简化为两个步骤：利用空间和时间的组合能力构建一个渲染树，然后播放或者导出即可。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;4.4 全新渲染引擎升级&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 PAG 的前 3 个大版本的迭代过程中，大部分的业务痛点问题都已经得到了很好的解决和覆盖。但是接入过程中始终一直还存在一个难以回避的痛点：SDK 包体能否进一步压缩？例如在某些头部的 App 对接过程中，甚至要求接入后包体 0 增量。对大部分应用来说，包体直接影响增长拉新的数据，因此包体优化确实是个刚需。在之前的版本里，我们的渲染架构由于依赖了谷歌的 Skia 2D 绘图库。我们也已经针对性做了非常多的定制和裁剪，但是 Skia 依然占据了 PAG SDK 75%左右的包体，无法在进一步进行裁剪。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在性能方面，3.0 版本上层的 PAG 渲染架构已经做了游戏引擎几乎所有能做的优化策略。但是由于 Skia 需要兼容历史遗留的 CPU 绘制模式，在 API 上暴露会比较保守，很多针对现代 GPU 绘制管线可以进一步优化性能的接口都没暴露出来。另外由于 Skia 是针对 UI 这种随机绘制设计的引擎，内部做了大量的缓存来确保随机渲染的性能。而对于动画这种可预测的渲染模式没有很好的优化，如果针对性优化可以有效降低平均的内存占用。整体上由于渲染对 Skia 的依赖，导致我们在性能上想要进一步突破也遇到了瓶颈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了彻底打破包体和性能的限制，我们花了将近一整年时间自研实现了一套轻量的纯 GPU 绘图引擎。在包体方面，我们最大化利用了平台端提供的所有可用能力，例如复杂矢量图形的栅格化， iOS 直接使用平台自带的 CoreGraphics，文本方面利用起 CoreText ，Android 端图片解码直接利用 Java 反射等。最终实现以 500K 左右的包体覆盖了 Skia 绝大部分功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在接口设计上，我们充分暴露了针对 GPU 渲染的优化能力给到调用层，例如提交纹理后统一不再重复缓存一份 CPU 图片，暴露传入纹理遮罩缓存的能力实现一次性上屏，并在移动端全面开启了 HardwareBuffer 接口的使用来加速纹理提交。在减小包体和内存占用的同时进一步提升了渲染性能的天花板。在接口易用性方面也自带线程安全的设计，所有 GPU 资源统一管理，外部任意线程释放引用都可以确保正确销毁，降低了使用 Skia 的 GPU 绘制模式时，容易出错并需要大量封装平台相关上下文代码的门槛。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.27564102564102566&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvavK7JjUiclNZCGovY0JzJTMzWpsUKfQvcyYGDlEajntr66sC6tNHDGm4CseJCpPH5dWbNak4FOoIAw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1248&quot;/&gt;&lt;/figure&gt;&lt;center data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;表3 PAG 4.0 包体优化数据&lt;/span&gt;&lt;/center&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外在 PAG 4.0 版本中，我们也提供了对 Web 平台的支持。之前迟迟未覆盖这最后一个平台，部分原因也是在等待新的渲染引擎升级完成后，可以减少 Web 端的包体加载压力。在 Web 端，Lottie 和 SVGA 使用 Web 的 HTML、CSS 和 Javascript 重新实现了一遍。而 PAG 依然保持了全平台共享一套 C++ 代码的架构。通过 WebAssembly 将全新的渲染引擎直接绑定到 WebGL 接口上进行渲染，仅在文本和栅格化等模块上对 Web 平台做了针对性的优化适配。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前这个新的绘图引擎仍然内置在 PAG 4.0 版本内，未来有可能会进一步抽离成独立的 2D 绘图库，应用到动画工作流以外更多的渲染场景中。目标实现成针对现代 GPU 渲染优化的，包体和性能达到最佳平衡的 2D 绘图引擎。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5、 结束语&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;除了本文描述的 PAG 技术能力，相对于 Lottie 和 SVGA，PAG 的辅助工具也非常完善，如果需要了解，大家可以访问 PAG 官网：&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://pag.io/&quot; textvalue=&quot;https://pag.io/&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;https://pag.io/&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果大家对改进 PAG 项目有任何的想法或建议，欢迎访问 Github 主页：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://github.com/Tencent/libpag&quot; textvalue=&quot;https://github.com/Tencent/libpag&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;https://github.com/Tencent/libpag&lt;/span&gt;&lt;/a&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;提交 issue 或 pull request，一起参与到开源项目建设中，帮助 PAG 动画方案做到更好。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;官方交流QQ 群: 893379574&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;4.045&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasqeyVq3SFb7MawCsAKX9Eg6TythGmOnJp10nibL8RO1D3JBRvDSe3A5GoLGykYGBmwzWPBE2GK1pw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAg5YjhtxVywAAAAstQy6ubaLX4KHWvLEZgBPE1KIwRD9cbvb8zNPgMItb4FJQnMOX_c5LQ1j2iCIs&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7Ym3K77SEULgkiaKAG07Zw5kBgHdI7c5eOkfJ4jScKbrMIZk502ypRXTMzoXYABcbiaIxnlbiaViavMw0AIzUsicBO2pgicAJd3boicicJeQ&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SZ&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=x5Y29zUxcibAPEdDrHsa2P1Q6SEu4yE0MldbsPdribvTlZYIZ50fXHXxkJH5q8ibYBUyIhfQlU3gbw&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;一款很棒的免费、体积小和多平台都可以使用的视频剪辑工具&quot; data-nonceid=&quot;14349975478346291574&quot; data-type=&quot;video&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>