<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>0c3954cece9861e72f99179c5006aacf</guid>
<title>接下来或许是一年中跳槽的最佳时间</title>
<link>https://toutiao.io/k/0y276l8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，很多人都认为一年中最佳的跳槽时间是三、四月份，也就是我们常说的“金三银四”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但我认为“金三银四”不一定是性价比最佳的时间。为什么这么说？听我从团队管理者、面试官的角度给大家解释一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三、四月份是跳槽的旺季，背后主要的原因就是年终奖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就拿我管理的技术团队来说吧，我们团队有 100 多人。每年三、四月份跳槽的人确实是最多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因也很简单，一般来说，上一年底最晚年初，每个人的绩效分数都出来了。其中绩效好的人，年终奖拿到手之后可以踏踏实实、美滋滋的走了。绩效不好的人，估计自己心里也有数，也不指望年终奖了，可能春节前后更早就开始找下家了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有一些人，春节回老家过了个年，在年味中内心也有点小波动，打算春节之后换一个离家近的城市工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总之，每年三、四月份，我最怕同事给我微信说&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;“四哥有空吗？我想单独和你聊聊”&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每次看到微信里同事头像一闪，我心里就默念“不是离职，不是离职”。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然我也知道“铁打的营盘，流水的兵”，但是面对同事离职，尤其是核心骨干离职，还是非常不舍的，肯定要诚心挽留。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老实说，挽留的成功率不高，所以留不住人的那种挫败感、无力感，可能会弄得我一天都心情不好，无心工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;烦死了！&lt;img data-ratio=&quot;0.9576059850374065&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KQPpbulMSDmceTicw4Cms19Cs9Sjmic60q775yYibF2LA1ibpPo6KiccQJBc5pjvzwbCAm4Mibj2R7On11w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;401&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有人跳槽，就有岗位空出来了，就需要招人来补缺。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然是要招的人多，但是那时候看机会找工作的人也多，HR 天天都能给我发不少简历，反正是不缺简历。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三、四月份是我看简历、面试最忙的时候。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一天面试四、五个人是常有的事儿。幸亏我是最后一轮的面试官，有些人到不了最后一轮，否则一天的时间都花在面试上了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候我们招人就是优中选优了，或者选性价比最好的那个人。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，我认为：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;金三银四跳槽的人多，招人的岗位多，但是候选人也多，面试求职的难度随之也变大，并不一定是性价比最好的时候。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另一个跳槽旺季“金九银十”，差不多也是这个道理（因为有一些公司有半年绩效）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面重点来了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要说性价比最好的时候，我觉得是&quot;金三银四&quot;、&quot;金九银十&quot;之后的一两个月。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是说我们团队，旺季的时候简历多、人选多，有时候我们自己就开始嘚瑟了，总想花同样的钱找个更 NB 的人。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是 NB 的人，别的公司也看上了，别的公司给的钱也多，NB 的人不缺 Offer，最后也没来我们这里。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在嘚瑟和犹豫不决中，旺季很快就过去了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候我们就着急了，得赶紧招人干活啊，老板定的任务得完成啊。所以越是往后越着急，一着急招人条件也放松了，薪资也好商量了，只求你赶紧来入职吧。谈好条件，我恨不得你下周就能来上班。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你看上面我们招人是不是有点像娶媳妇找老公，年轻的时候不着急，眼光贼高，年龄大了越往后越着急……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不只是我们团队，很多公司招人都是这么回事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，咱们再重点说说年末：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;年末的时候很多公司都会突击招人&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们部门，年初都会做 HC 预算。解释一下，HC = HeadCount 缩写，简单说就是人数、坑位数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如 HC 预算是 100 个程序员，快到年底了，我一看现在有 90 个程序员，离预算还差 10 个人。这时候，我会尽量再招 10 个人，把预算招满。不招满的话，明年预算会减少。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，临近年末的突击招人，也会比较着急，招聘条件自然也会放松。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上，我认为跳槽旺季之后的一两个月，尤其是临近年末的时候，或许是跳槽性价比最高的时间。对程序员来说，虽然年末岗位不一定很多，但是大部分程序员都在等年终奖，所以求职竞争没那么激烈，薪资也好商量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面这张图就可以看出来，10月、11月 Offer 给的年薪明显高于其他月份。虽然是 16 年的图，但是大差不差。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3709677419354839&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KQPpbulMSDmceTicw4Cms19Cc6JsHAjbltWLyZ3gZRHAyjib1OH2Z5LWIbicaK2bouSGZUoUVAjwcEJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;620&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结一下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;跳槽旺季，岗位多，和你竞争的人也多。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;旺季之后的一两个月，可能性价比高。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;尤其临近年末，因为预算，因为别人都在等年终奖，所以竞争者少，薪资或许有惊喜。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上我是从团队管理者、面试管的角度去说的。对程序员来说，我建议大家，如果计划年后跳槽的，现在可以开始准备了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一边背题、刷题，一边看看机会，换工作要提前看，找个满意的坑不容易，早下手，多看看多比较比较。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果真遇到合适的坑了，也果断点，别太纠结年终奖啥的，如果工资涨幅满意，早去几个月，年终奖就能赚回来了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，因为跳槽少了两个月的奖金，如果工资涨幅在 30% 以上，早去 6 个月就赚回来了，今年 10 月跳和明年 4 月跳，正好差 6 个月。这还只算了工资，还没算公积金。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且你在新公司的下一年，能待满一整年，能拿到足额的年终奖。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有最重要的一点，&lt;strong&gt;早就是优势&lt;/strong&gt;。同样的岗位，同样的工作，你比别人早去几个月，就能早熟悉早上手，将来的好处收益不是几个月工资能比的了的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你想想，是不是你身边有的同事，论能力、背景，你俩差不多，但是就是因为人家比你入职早，人家对业务更熟悉，和领导、同事关系更好，结果他就更受重视，发展的更好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就说这么多吧，今天文章字少。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;字越少，事越大。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章不适合点在看，防止被你领导看到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以点赞，点赞不会被别人知道，让我看看有多少人喜欢这篇文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果觉得有帮助，可以转发给你的朋友，让更多的人看到。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后推荐几篇和跳槽相关的旧文，一篇是讲简历、面试、谈薪酬技巧经验的，一篇是讲大公司、小公司区别的：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247484503&amp;amp;idx=1&amp;amp;sn=c7a006ddd9acb1cb104128c7d8601eab&amp;amp;chksm=fcd8c816cbaf4100d648d55111b3c360b14777a9e94c599ed6ad3e200045956df75db8e7164a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;最全干货：从写简历，到面试、谈薪酬的那些技巧和防坑指南&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247485653&amp;amp;idx=1&amp;amp;sn=51e729143b9bccc28f1527c934a47ca6&amp;amp;chksm=fcd8c494cbaf4d82fb5ef9fdd0e9b3558545700ea22b13c2ce036acfa5fa1e29c38b844cf1e0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;当年，我从小公司翻身进大公司之后……&lt;/a&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;你好，我是四猿外。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一家上市公司的技术总监，管理的技术团队一百余人。想了解我如何管理团队——&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU3MTg3NDYwNg==&amp;amp;mid=2247485282&amp;amp;idx=1&amp;amp;sn=f368ffae1845809ccf06859f988a88a8&amp;amp;chksm=fcd8cb23cbaf4235db644759c3d8099045d10fc952b950d429e4a5e07ed9a806fddf85c451d3&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;我，管理100多人团队的二三事&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我从一名非计算机专业的毕业生，转行到程序员，一路打拼，一路成长。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我会通过公众号，&lt;br/&gt;把自己的成长故事写成文章，&lt;br/&gt;把枯燥的技术文章写成故事。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我建了一个读者交流群，里面大部分是程序员，一起聊技术、工作、八卦。欢迎加我微信，拉你入群。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.9852216748768473&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/6nbNnibOq5KQibCDibpTo0kqofPehQvDDibibcb3bQUELdY3Knsl4r0RcgsV9l4icr3icmZQfaBXtSFNTxmdQlAZT1OQg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;609&quot;/&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>76023c705f4f6e2a95cc4f8dc060756a</guid>
<title>分布式服务下，消息中间件改造</title>
<link>https://toutiao.io/k/hseh6pt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p id=&quot;js_tags&quot; class=&quot;article-tag__list single-tag__wrp js_single&quot; data-len=&quot;1&quot; role=&quot;link&quot; aria-labelledby=&quot;js_article-tag-card__left&quot; aria-describedby=&quot;js_article-tag-card__right&quot;&gt;
                                            
                                                                                    &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__left&quot; class=&quot;article-tag-card__left&quot;&gt;
                                    &lt;span class=&quot;article-tag-card__title&quot;&gt;收录于话题&lt;/span&gt;
                                    &lt;span class=&quot;article-tag__item-wrp no-active js_tag&quot; data-url=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4Njg0MzYwNw==&amp;amp;action=getalbum&amp;amp;album_id=1327025063014596608#wechat_redirect&quot; data-tag_id=&quot;&quot; data-album_id=&quot;1327025063014596608&quot; data-tag_source=&quot;4&quot;&gt;
                                        &lt;span class=&quot;article-tag__item&quot;&gt;#分布式-数据源-中间件&lt;/span&gt;
                                    &lt;/span&gt;
                                &lt;/span&gt;
                                &lt;span aria-hidden=&quot;true&quot; id=&quot;js_article-tag-card__right&quot; class=&quot;article-tag-card__right&quot;&gt;34个&lt;span class=&quot;weui-hidden_abs&quot;&gt;内容&lt;/span&gt;&lt;/span&gt;
                                                                                        &lt;/p&gt;

                
                                
                
                

                
                                                                

                
                                


                
                
                
                
                                                
                                                                
                                
                                
                
                &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h1&gt;&lt;span&gt;一、背景简介&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;在系统开发初期，很容易出现这样一种情况：不同业务线上开发人员，因为技术栈和版本时间的影响，在选型的时候会优先使用自己熟悉的，例如MQ中间件常用的：Kafka、Rocket、Rabbit等，这样很容易忽略各个项目之间的组件差异问题；&lt;/p&gt;&lt;p&gt;在系统开发中后期，业务相对稳定之后，通常都会对资源占用较高的模块逐步重构，公共服务进行整合管理，从而使系统更具有整体性，在这个过程中，解决不同项目的中间件差异通常首当其冲，例如常见的缓存中心，MQ消息管理等；&lt;/p&gt;&lt;p&gt;这种情况一般来说很难避免，系统初期为了快速支撑业务，埋下很多坑点，一旦业务可以稳定发展，并且可持续性得到验证，就会开始适当考虑逐步进行模块重构，降低成本。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;二、重构思路&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;2.1 初期问题&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在某创业公司研发初期，业务线上存在五个项目并行开发的情况，当时对于MQ的使用状况如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5730337078651685&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDI1nPxvzGOiaxicUwtvExjhEb6qEJiaAmvFqDp1LYUsOvZuL45KENuA6oQ1IfLAttt2Siaz4ds9x3alQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;890&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Rocket：核心业务3个项目，版本有差异；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Kafka：数据权重偏高，1个项目采用；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Redis：基于Python连接，队列消息模式；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;刚开始因为用的不多，整体还在可控范围内，后续随着业务的持续迭代，项目间出现需要通信的情况，就开始混乱难以维护，然后就是被迫开始重构，统一消息组件。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2.2 二次选型&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;基于业务的综合考量，对现有几个项目进行MQ重新设计，形成的整体架构思路如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.42775665399239543&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDI1nPxvzGOiaxicUwtvExjhEVPjHJXRUGfZJoTicjWH7Cfia9HO0N9nozVD0UOzPOf4ibKqnAJ09d7L2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1052&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;MQ组件选择：采用RocketMQ；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;换掉Redis组件的队列模式；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将基于Python的系统改Java语言；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提供消息生产与消费两个服务；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MQ的功能由上述服务进行统一维护；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这里在核心业务线上没有改变组件选择，换掉kafka的一个原因是涉及大量结算业务，Redis队列模式弃用，基于Python的管理系统功能不多，这里只是顺手换掉，统一业务线的编程语言。这样设计之后，从整体思路上看就会合理很多。&lt;/p&gt;&lt;h1&gt;&lt;span&gt;三、改造过程&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;3.1 整体思路&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.44064748201438847&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvDI1nPxvzGOiaxicUwtvExjhEoSChbPL7SZzqBDbWnxicV2xicCbZ7D0tApnKvwfkDtFVrk7wVTrdKEfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1112&quot;/&gt;&lt;/p&gt;&lt;p&gt;涉及核心角色说明，从左向右依次：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;生产客户端：需要请求服务端通信的节点，调用生产服务端封装的消息发送接口即可；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;生产服务端：封装消息发送API，并维护路由管理，权限识别等，消息落地存储等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消息存储层：主要基于消息中间件进行存储，数据库层面用来处理特定情况下的二次调度；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费服务端：封装消息接收API，并根据路由标识，请求指定的消费端接口，完成通信；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;消费客户端：响应消费服务端的请求，封装消费时具体的业务逻辑；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在整体的技术难度上没有太多差别，但是引入两个服务【生产和消费】，用来管理MQ通信流程，适配特定的业务逻辑，引入数据库做一次落地存储，在异常流程的处理上更加灵活，这样整个消息模块具有很强的可扩展性。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3.2 细节描述&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;消息中间件的选择是比较多的，但是鉴于业务线上开发人员的熟悉程度，以及参考多方提供的测试对比报告，最终确定选用RocketMQ组件，同时RocketMQ相关特点：高性能、高可靠性，以及对分布式事务的支持，也是核心的考虑因素。&lt;/p&gt;&lt;p&gt;基于当前微服务的架构模式，把MQ功能本身集成在两个核心服务中，进行统一管理和迭代，以及组件的版本控制，对于所有生产的消息，进行全局路由控制，以及特定情况下的，通过应用服务层面功能设计，实现消息延时消费，以及失败消息的二次调度执行，和部分单条消息的手动触发。&lt;/p&gt;&lt;p&gt;对消息实体进行二次存储，主要还是适配部分特定的功能点，有些消息可以延时处理，例如当MQ队列出现堆积的时候，或者达到监控的预警线时，可以通过配置手段，干预一部分消息只存储入库，不推送MQ，等待服务相对空闲的时候再去发送。&lt;/p&gt;&lt;p&gt;消息中间件作为系统间解耦的稳定支撑，在服务层面管理时，需要具备清晰的设计路线，以及流程关键节点的监控和记录，确保整个链路的稳定和容错。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;同系列&lt;/strong&gt;：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4Njg0MzYwNw==&amp;amp;mid=2247484591&amp;amp;idx=1&amp;amp;sn=52f4a51cb9901a208e0d6d96c0f25a1e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;分布式概念&lt;/a&gt; | &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4Njg0MzYwNw==&amp;amp;mid=2247484811&amp;amp;idx=1&amp;amp;sn=4dfb7feaa0e660ece9a6d91fd9731f48&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;分布式事务&lt;/a&gt; | &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4Njg0MzYwNw==&amp;amp;mid=2247484633&amp;amp;idx=1&amp;amp;sn=ee8fcc2ce2a5b2adcd4dffe8bd0dd4cd&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Kafka集群&lt;/a&gt; | &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4Njg0MzYwNw==&amp;amp;mid=2247483755&amp;amp;idx=1&amp;amp;sn=9d78e7714ad4621fe5e643593069b186&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;RocketMQ组件&lt;/a&gt; | &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4Njg0MzYwNw==&amp;amp;mid=2247483886&amp;amp;idx=1&amp;amp;sn=2158323687acc7713d5d45c21c9558ee&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;Redis集群&lt;/a&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;四、源代码地址&lt;/span&gt;&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;GitEE·地址&lt;br/&gt;https://gitee.com/cicadasmile&lt;br/&gt;Wiki·地址&lt;br/&gt;https://gitee.com/cicadasmile/butte-java-note/wikis&lt;/code&gt;&lt;/pre&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU4Njg0MzYwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uUIibyNXbAvBCuF3zfJnqPKpUia4wfn1FUtTHpxxkR5HvbicPgOjibPicX0goMOkny1NdkLAJvBaqrYh3UdwMjiaDQMA/0?wx_fmt=png&quot; data-nickname=&quot;知了一笑&quot; data-alias=&quot;cicada_smile&quot; data-signature=&quot;积累是一个孤独且枯燥的过程&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1dbfecdeb5c7b92a240fce0977faaf59</guid>
<title>开源｜滴滴开源的，Java 版认证、鉴权、管理、任务调度通用功能组件</title>
<link>https://toutiao.io/k/yumis2g</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c6e2b0fcf83c2caf36a39cf00e36b1df</guid>
<title>并发编程：乱序执行的那些事儿</title>
<link>https://toutiao.io/k/qus2pec</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是乱序执行&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;乱序执行&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;，简单说就是程序里面的代码的执行顺序，有可能会被编译器、CPU 根据某种策略调整顺序（俗称，“打乱”）——虽然从单线程的角度看，乱序执行不影响执行结果。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么需要乱序执行&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要原因是 CPU 内部采用&lt;span&gt;流水线技术&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;。抽象且简化地看，一个 CPU 指令的执行过程可以分成 4 个阶段：取指、译码、执行、写回。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这 4 个阶段分别由 4 个独立物理执行单元来完成。这种情况下，如果指令之间没有依赖关系，后一条指令并不需要等到前一条指令完全执行完成再开始执行。而是前一条指令完成取指之后，后一条指令便可以开始执行取指操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比较理想的情况如下图所示：指令之间无依赖，可以使流水线的并行度最大化。&lt;img data-ratio=&quot;0.30192962542565266&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9637P74IBOHW1nlxA0eFXR2tDcdWManmEqLAKxwl4fibejHGTW1b2MvHCEe69xeToWWzgxGHicaNX44C15ntuiaXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;881&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;strong&gt;按序执行&lt;/strong&gt;的情况下，一旦遇到指令依赖的情况，流水线就会停滞。比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;指令 &lt;span&gt;1&lt;/span&gt;: Load R3 &amp;lt;- R1(&lt;span&gt;0&lt;/span&gt;)    # 从内存中加载数据到 R3 寄存器&lt;br/&gt;指令 &lt;span&gt;2&lt;/span&gt;: Add  R3 &amp;lt;- R3, R1   # 加法，依赖指令 &lt;span&gt;1&lt;/span&gt; 的执行结果&lt;br/&gt;指令 &lt;span&gt;3&lt;/span&gt;: Sub  R1 &amp;lt;- R6, R7   # 减法&lt;br/&gt;指令 &lt;span&gt;4&lt;/span&gt;: Add  R4 &amp;lt;- R6, R8   # 加法&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的伪代码中，指令 2 依赖指令 1 的执行结果。在指令 1 执行完成之前，指令 2 无法执行，这会让流水线的执行效率大大降低。&lt;img data-ratio=&quot;0.2252328535139712&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9637P74IBOHW1nlxA0eFXR2tDcdWManmFYqB5UHTIcPSF4VNx0rZvTzzs4TFjtwhbkShR7jA2qLpicDMy1uPBVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1181&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;观察到，指令 3 和指令 4 对其它指令没有依赖，可以考虑将这两条指令”乱序“到指令 2 之前。&lt;img data-ratio=&quot;0.2711518858307849&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9637P74IBOHW1nlxA0eFXR2tDcdWManm0CWWUOcjYxeadgb0T0MSh8rQH9xnmTiaSiahJa7jXQWH848gNODjECfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;981&quot;/&gt;这样，流水线执行单元就可以尽可能处于工作状态。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总的来说，通过乱序执行，合理调整指令的执行顺序，可以提高流水线的运行效率，让指令的执行能够尽可能地并行起来。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Compiler Fence&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在多线程的环境下，乱序执行的存在，很容易打破一些预期，造成一些意想不到的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;乱序执行有两种情况：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在编译期，编译器进行指令重排。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在运行期，CPU 进行指令乱序执行。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看一个编译器指令重排的例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;atomic&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 按序递增发号器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::atomic&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; timestamp_oracle{&lt;span&gt;0&lt;/span&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 当前处理的号码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; now_serving_ts{&lt;span&gt;0&lt;/span&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; shared_value;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;compute&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;memory_reorder&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;// 原子地获取一个号码&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; ts = timestamp_oracle.fetch_add(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 加锁：判断当前是否轮到这个号码，否则就循环等&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (now_serving_ts != ts);&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 临界区：开始处理请求&lt;/span&gt;&lt;br/&gt;    shared_value = compute();&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;// 编译器 memory barrier&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;asm&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt;(&lt;span&gt;&quot;&quot;&lt;/span&gt; : : : &lt;span&gt;&quot;memory&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 解锁：下一个要处理的号码&lt;/span&gt;&lt;br/&gt;    now_serving_ts = ts + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单解释一下这段代码：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个程序通过维护一个“发号器 timestamp_oracle”，来实现按顺序处理每个线程的请求。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个线程先从“发号器”取一个号，然后不停判断当前是否轮到自己执行，类似自旋锁的逻辑。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个线程执行完，将“号码”切换到下一个。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 O1 的编译优化选项下，编译出来的汇编指令没有被重排（通过左右两边的代码行背景色就可以看出来）。&lt;img data-ratio=&quot;0.44094955489614246&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9637P74IBOHW1nlxA0eFXR2tDcdWManmRfz8j3EibXK9eEYduBJwjZAUE4XsHRfClKq3XicBspAqYxyAYCtoEZXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1685&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 O2 的编译优化选项下，出现了指令被重排了，并且这里的指令重排打破了程序的预期，先切换了 now_serving_ts，再更新 shared_value，导致 shared_value 可能被并发修改。&lt;img data-ratio=&quot;0.47041420118343197&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9637P74IBOHW1nlxA0eFXR2tDcdWManmWRdaz3eFXaaTibibHoHibmk8kRmCmmhoMgRXicibTuggxX2rVd8mbB3R0qg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1690&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了阻止编译器重排这两句代码的指令，需要在它们之间插入一个 compiler fence。&lt;img data-ratio=&quot;0.5121517486662714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9637P74IBOHW1nlxA0eFXR2tDcdWManmPwYZd252Tg5xciawkmhmd7Y1fz5ibnzg7VzUjjdEpcSic6O26ZdxQ65vA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1687&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;asm&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt;(&lt;span&gt;&quot;&quot;&lt;/span&gt;: : :&lt;span&gt;&quot;memory&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是 GCC 扩展的 compiler fence 的写法。这条指令告诉编译器（&lt;span&gt;GCC 官方文档&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;）：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;防止这条 fence 指令上方的内存访问操作被移到下方，同时防止下方的内存访问操作移到上面，也就是防止了乱序。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;让编译器把所有缓存在寄存器中的内存变量 flush 到内存中，然后重新从内存中读取这些值。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于第 2 点，有时候我们只需要刷新部分变量。刷新所有寄存器并不一定完全符合我们的预期，并且会引入不必要的开销。GCC 支持指定变量的 compiler fence。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;write(x)&lt;br/&gt;asm volatile(&lt;span&gt;&quot;&quot;&lt;/span&gt;: &lt;span&gt;&quot;=m&quot;&lt;/span&gt;(y) : &lt;span&gt;&quot;m&quot;&lt;/span&gt;(x):)&lt;br/&gt;read(y)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;中间的内联汇编指令告诉编译器不要把 write(x) 和 read(y) 这两个操作乱序。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;CPU Fence&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来看一个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;int x = 0;&lt;br/&gt;int y = 0;&lt;br/&gt;&lt;br/&gt;int r0, r1;&lt;br/&gt;&lt;br/&gt;// CPU1&lt;br/&gt;void &lt;span&gt;&lt;span&gt;f1&lt;/span&gt;&lt;/span&gt;()&lt;br/&gt;{&lt;br/&gt;    x = 1;&lt;br/&gt;    asm volatile(&lt;span&gt;&quot;&quot;&lt;/span&gt;: : :&lt;span&gt;&quot;memory&quot;&lt;/span&gt;);&lt;br/&gt;    r0 = y; &lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// CPU2&lt;br/&gt;void &lt;span&gt;&lt;span&gt;f2&lt;/span&gt;&lt;/span&gt;()&lt;br/&gt;{&lt;br/&gt;    y = 1;&lt;br/&gt;    asm volatile(&lt;span&gt;&quot;&quot;&lt;/span&gt;: : :&lt;span&gt;&quot;memory&quot;&lt;/span&gt;);&lt;br/&gt;    r1 = x;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4311377245508982&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9637P74IBOHW1nlxA0eFXR2tDcdWManmxJPzKzetWxV5tEOmYQQTJ2y3AYQD12FR1MopLX0UfdrAibKhIb4M2rg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1002&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的例子中，由于 compiler fence 的存在，编译器不会对函数 f1 和函数 f2 内部的指令进行重排。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，如果 CPU 执行时也没有乱序，是不可能出现 &lt;code&gt;r0 == 0 &amp;amp;&amp;amp; r1 == 0&lt;/code&gt; 的情况的。不幸的是，由于 CPU 乱序执行的存在，这种情况是可能发生的。看下面这个例子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;#&lt;span&gt;include&lt;/span&gt; &lt;span&gt;&amp;lt;thread&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; x = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; y = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; r0 = &lt;span&gt;100&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; r1 = &lt;span&gt;100&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    x = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;asm&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt;(&lt;span&gt;&quot;&quot;&lt;/span&gt;: : :&lt;span&gt;&quot;memory&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    r0 = y;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    y = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;asm&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt;(&lt;span&gt;&quot;&quot;&lt;/span&gt;: : :&lt;span&gt;&quot;memory&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    r1 = x;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;init&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    x = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    y = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    r0 = &lt;span&gt;100&lt;/span&gt;;&lt;br/&gt;    r1 = &lt;span&gt;100&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;bool&lt;/span&gt; &lt;span&gt;check&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; r0 == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; r1 == &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::atomic&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt; wait1{&lt;span&gt;true&lt;/span&gt;};&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::atomic&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt; wait2{&lt;span&gt;true&lt;/span&gt;};&lt;br/&gt;&lt;span&gt;std&lt;/span&gt;::atomic&amp;lt;&lt;span&gt;bool&lt;/span&gt;&amp;gt; stop{&lt;span&gt;false&lt;/span&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;loop1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(!stop.load(&lt;span&gt;std&lt;/span&gt;::memory_order_relaxed)) {&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (wait1.load(&lt;span&gt;std&lt;/span&gt;::memory_order_relaxed));&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;asm&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt;(&lt;span&gt;&quot;&quot;&lt;/span&gt; ::: &lt;span&gt;&quot;memory&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;        f1();&lt;br/&gt;        &lt;span&gt;&lt;span&gt;asm&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt;(&lt;span&gt;&quot;&quot;&lt;/span&gt; ::: &lt;span&gt;&quot;memory&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        wait1.store(&lt;span&gt;true&lt;/span&gt;, &lt;span&gt;std&lt;/span&gt;::memory_order_relaxed);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;loop2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (!stop.load(&lt;span&gt;std&lt;/span&gt;::memory_order_relaxed)) {&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (wait2.load(&lt;span&gt;std&lt;/span&gt;::memory_order_relaxed));&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;asm&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt;(&lt;span&gt;&quot;&quot;&lt;/span&gt; ::: &lt;span&gt;&quot;memory&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;        f2();&lt;br/&gt;        &lt;span&gt;&lt;span&gt;asm&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt;(&lt;span&gt;&quot;&quot;&lt;/span&gt; ::: &lt;span&gt;&quot;memory&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;        wait2.store(&lt;span&gt;true&lt;/span&gt;, &lt;span&gt;std&lt;/span&gt;::memory_order_relaxed);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;int&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;std&lt;/span&gt;::thread &lt;span&gt;thread1&lt;/span&gt;&lt;span&gt;(loop1)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;std&lt;/span&gt;::thread &lt;span&gt;thread2&lt;/span&gt;&lt;span&gt;(loop2)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;long&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;) {&lt;br/&gt;        count++;&lt;br/&gt;        init();&lt;br/&gt;        &lt;span&gt;&lt;span&gt;asm&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt;(&lt;span&gt;&quot;&quot;&lt;/span&gt; ::: &lt;span&gt;&quot;memory&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;        wait1.store(&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;std&lt;/span&gt;::memory_order_relaxed);&lt;br/&gt;        wait2.store(&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;std&lt;/span&gt;::memory_order_relaxed);&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (!wait1.load(&lt;span&gt;std&lt;/span&gt;::memory_order_relaxed));&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (!wait2.load(&lt;span&gt;std&lt;/span&gt;::memory_order_relaxed));&lt;br/&gt;        &lt;span&gt;&lt;span&gt;asm&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt;(&lt;span&gt;&quot;&quot;&lt;/span&gt; ::: &lt;span&gt;&quot;memory&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (check()) {&lt;br/&gt;            &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;test count &quot;&lt;/span&gt; &amp;lt;&amp;lt; count &amp;lt;&amp;lt; &lt;span&gt;&quot;: r0 == &quot;&lt;/span&gt; &amp;lt;&amp;lt; r0 &amp;lt;&amp;lt; &lt;span&gt;&quot; &amp;amp;&amp;amp; r1 == &quot;&lt;/span&gt; &amp;lt;&amp;lt; r1 &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (count % &lt;span&gt;10000&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;test count &quot;&lt;/span&gt; &amp;lt;&amp;lt; count &amp;lt;&amp;lt; &lt;span&gt;&quot;: OK&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;std&lt;/span&gt;::&lt;span&gt;endl&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    stop.store(&lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;    wait1.store(&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;    wait2.store(&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;    thread1.join();&lt;br/&gt;    thread2.join();&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的程序可以很轻易就运行出 r0 == 0 &amp;amp;&amp;amp; r1 == 0 的结果，比如：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;test count &lt;span&gt;56&lt;/span&gt;: r0 == &lt;span&gt;0&lt;/span&gt; &amp;amp;&amp;amp; r1 == &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了防止 CPU 乱序执行，需要使用 CPU fence。我们可以将函数 f1 和 f2 中的 compiler fence 修改为 CPU fence：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    x = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;asm&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt;(&lt;span&gt;&quot;mfence&quot;&lt;/span&gt;: : :&lt;span&gt;&quot;memory&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    r0 = y;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;f2&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    y = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;asm&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt;&lt;span&gt;(&lt;span&gt;&quot;mfence&quot;&lt;/span&gt;: : :&lt;span&gt;&quot;memory&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;    r1 = x;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如此，便不会出现 &lt;code&gt;r0 == 0 &amp;amp;&amp;amp; r1 == 0&lt;/code&gt; 的情况了。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指令乱序执行主要由两种因素导致：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;编译期指令重排。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;运行期 CPU 乱序执行。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是编译期的指令重排还是 CPU 的乱序执行，主要都是为了让 CPU 内部的指令流水线可以“充满”，提高指令执行的并行度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面举的插入 fence 的例子都是使用了 GCC 的扩展语法，实际上 C++ 标准库已经提供了类似的封装：&lt;span&gt;std::atomic_thread_fence&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;，跨平台且可读性更好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一些无锁编程、追求极致性能的场景可能会需要手动在合适的地方插入合适 fence，这里涉及的细节太多，非常容易出错。原子变量操作根据不同的 memory order 会自动插入合适的 fence，建议优先考虑使用原子变量。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;乱序执行: &lt;em&gt;https://en.wikipedia.org/wiki/Out-of-order_execution&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;流水线技术: &lt;em&gt;https://en.wikipedia.org/wiki/Instruction_pipelining&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;GCC 官方文档: &lt;em&gt;https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html#Clobbers-and-Scratch-Registers&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;std::atomic_thread_fence: &lt;em&gt;https://en.cppreference.com/w/cpp/atomic/atomic_thread_fence&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a331fe91cfc6ec7bf0ca37730296c87d</guid>
<title>面试官：说下你对方法区演变过程和内部结构的理解</title>
<link>https://toutiao.io/k/rctfy0i</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前我们已经了解过“运行时数据区”的程序计数器、虚拟机栈、本地方法栈和堆空间，今天我们就来了解一下最后一个模块——方法区。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.42424242424242425&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNO0mrHPOTbFIkP3fI9IOhKKBDCsAdicb3BM5SiaPbpjVh7oQicicNKOPc5jFpEl7qOCc6zh9auKTXGog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;924&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;简介&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建对象时内存分配简图&lt;img data-ratio=&quot;0.35294117647058826&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNO0mrHPOTbFIkP3fI9IOhKuLqlgiaNgZMicSoaE3x714vMPNvFMjqiaZaibSJp1o2Hr9EQIWQd551cpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;561&quot;/&gt;&lt;img data-ratio=&quot;0.5610425240054869&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNO0mrHPOTbFIkP3fI9IOhKMwKhm9RjkMSJwMib5iaQqicx93pDeqibNHGp3iaNFod4rLPllF13ib2ckezw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;729&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《Java虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。所以，方法区可以看作是一块&lt;strong&gt;独立&lt;/strong&gt;于 Java 堆的内存空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法区与 Java 堆一样，是各个线程共享的内存区域。方法区在 JVM 启动时就会被创建，并且它的实际的物理内存空间是可以&lt;strong&gt;不连续&lt;/strong&gt;的，关闭 JVM 就会释放这个区域的内存。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;永久代、元空间&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《java虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit/IBM J9 中不存在永久代的概念。而对于 HotSpot 来说，在 jdk7 及以前，习惯上把方法区的实现称为&lt;strong&gt;永久代&lt;/strong&gt;，而从 jdk8 开始，使用&lt;strong&gt;元空间&lt;/strong&gt;取代了永久代。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;方法区是 Java 虚拟机规范中的概念，而永久代和元空间是 HotSpot 虚拟机对方法区的一种实现。通俗点讲：如果把方法区比作接口的话，那永久代和元空间可以比作实现该接口的实现类。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;直接内存&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;永久代、元空间并不只是名字变了，内部结构也进行了调整。永久代使用的是 JVM 的内存，而元空间使用的是本地的直接内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接内存并不是 JVM 运行时数据区的一部分，因此不会受到 Java 堆的限制。但是它会受到本机总内存大小以及处理器寻址空间的限制，所以如果这部分内存也被频繁的使用，依然会导致 OOM 错误的出现。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法区的大小&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法区的大小是可以进行设置的，可以选择固定大小也可以进行扩展。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;jdk7 及以前&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-XX:PermSize=N //方法区 (永久代) 初始分配空间，默认值为 20.75M&lt;br/&gt;-XX:MaxPermSize=N //方法区 (永久代) 最大可分配空间。32位机器默认是64M，64位机器默认是82M&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;jdk8及以后&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;默认值依赖于平台，windows下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-XX:MetaspaceSize=N //方法区 (元空间) 初始分配空间，如果未指定此标志，则元空间将根据运行时的应用程序需求动态地重新调整大小。&lt;br/&gt;-XX:MaxMetaspaceSize=N //方法区 (元空间) 最大可分配空间，默认值为 -1，即没有限制&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，比如：加载大量的第三方 jar 包、Tomcat 部署的工程过多、大量动态生成反射类等都会导致方法区溢出，抛出内存溢出错误。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;永久代：OutOfMemoryError:PermGen space&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;元空间：OutOfMemoryError:Metaspace&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;至于如何解决 OOM 异常，将在以后的文章中讲解！&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;jvisualvm&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过 JDK 自带的 &lt;strong&gt;jvisualvm&lt;/strong&gt; 工具来查看程序加载的类文件：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;例&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MethodAreaDemo1&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;start...&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            Thread.sleep(&lt;span&gt;1000000&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;end...&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行程序，可以看到一个简单的程序就需要加载这么多的类文件。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5154255319148936&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNO0mrHPOTbFIkP3fI9IOhKGjoTpgCcUAKuicRId78MPldw9u7kAicoQ9KRz7kVr0EGnfBvq2FA6MtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1880&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;高水位线&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一个64位的服务器端 JVM 来说，&lt;code&gt;XX：MetaspaceSize=21&lt;/code&gt; 就是初始的高水位线，一旦触及这个水位线，Full GC 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新的高水位线的值取决于 GC 后释放了多少元空间：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果释放的空间不足，那么在不超过 MaxMetaspaceSize 时，适当提高该值；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果释放空间过多，则适当降低该值。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如果初始化的高水位线设置过低，高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到 Full GC 多次调用。为了避免频繁地GC，建议将 &lt;code&gt;-XX ：MetaspaceSize&lt;/code&gt; 设置为一个相对较高的值。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;内部结构&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;《深入理解Java虚拟机》书中对方法区存储内容描述如下：它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。接下来我们就一起来看一下它的内部结构。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.16718266253869968&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNO0mrHPOTbFIkP3fI9IOhKzMleiaFRv2bjqBeSBxRaWG9c7ibUIO7CLTDzWgEMriaQFthFWhw5hvAAw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;969&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;类型信息&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对每个加载的类型（ 类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;这个类型的完整有效名称（全名=包名.类名）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这个类型直接父类的完整有效名（对于 interface 或是 java. lang.Object ，都没有父类）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这个类型的修饰符（ public ， abstract， final 的某个子集）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;这个类型直接接口的一个有序列表&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;域（Field）信息&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;JVM必须在方法区中保存类型的所有域（field，也称为属性）的相关信息以及域的声明顺序；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;域的相关信息包括：域名称、 域类型、域修饰符（public， private，protected， static， final， volatile， transient 的某个子集）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;方法（Method）信息&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM 必须保存所有方法的以下信息，同域信息一样包括声明顺序：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;方法名称&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方法的返回类型（或void）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方法参数的数量和类型（按顺序）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方法的修饰符（public， private， protected， static， final，synchronized， native ， abstract 的一个子集）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;方法的字节码（bytecodes）、操作数栈、局部变量表及大小（ abstract 和 native 方法除外）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异常表（ abstract 和 native 方法除外）每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;non-final 的类变量&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类变量被类的所有实例所共享，即使没有类实例你也可以访问它。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过例子来查看：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;MethodAreaDemo2&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        Order order = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        order.hello();&lt;br/&gt;        System.out.println(order.count);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Order&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; number = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;hello&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;hello!&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果为：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;hello!&lt;br/&gt;&lt;span&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以打开 IDEA 的 Terminal 窗口，在 MethodAreaDemo2.class 所在的路径下，输入 &lt;code&gt;javap -v -p MethodAreaDemo2.class&lt;/code&gt; 命令&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3969359331476323&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNO0mrHPOTbFIkP3fI9IOhKkHrIicXFB5ibT5ZAtsPTOkBQhbxh2sLAg3dScoD7fwXyylYnQeib618aw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;718&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过图片我们可以看出被声明为 final 的类变量的处理方法是不一样的，全局常量在编译的时候就被分配了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;运行时常量池&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到运行时常量池，我们先来了解一下什么是常量池表。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;常量池表&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述信息外，还包含一项信息那就是常量池表（Constant Pool Table），里边存储着&lt;strong&gt;数量值&lt;/strong&gt;、&lt;strong&gt;字符串值&lt;/strong&gt;、&lt;strong&gt;类引用&lt;/strong&gt;、&lt;strong&gt;字段引用&lt;/strong&gt;和&lt;strong&gt;方法引用&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5986238532110092&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNO0mrHPOTbFIkP3fI9IOhKbnibMl97oKg3Oib7wZygNpM8VOKDNeNDVq7dDGAGaOtLzBicK3oiaBonng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1308&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么字节码文件需要常量池？&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;java 源文件中的类、接口，编译后会产生一个字节码文件。而字节码文件需要数据支持，通常这种数据会很大，以至于不能直接存放到字节码中。换一种方式，可以将指向这些数据的&lt;strong&gt;符号引用&lt;/strong&gt;存到字节码文件的常量池中，这样字节码只需使用常量池就可以在运行时通过&lt;strong&gt;动态链接&lt;/strong&gt;找到相应的数据并使用。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;运行时常量池&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行时常量池（ &lt;code&gt;Runtime Constant Pool&lt;/code&gt;）是方法区的一部分，类加载器加载字节码文件时，将常量池表加载进方法区的运行时常量池。运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为&lt;strong&gt;真实&lt;/strong&gt;地址。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;运行时常量池，相对于 Class 文件常量池的另一重要特征是：具备动态性，比如 &lt;code&gt;String.intern()&lt;/code&gt;。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;演进细节&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对的是 &lt;strong&gt;Hotspot&lt;/strong&gt; 的虚拟机：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;jdk1.6 及之前：有&lt;strong&gt;永久代&lt;/strong&gt; ，静态变量存放在永久代上；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jdk1.7：有&lt;strong&gt;永久代&lt;/strong&gt;，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;jdk1.8及之后：无永久代，类型信息、字段、方法、常量保存在本地内存的&lt;strong&gt;元空间&lt;/strong&gt;，但字符串常量池、静态变量仍在堆中；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;演变示例图&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5350404312668463&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNO0mrHPOTbFIkP3fI9IOhKadYK1fdKFJwTGN0yUkBJQDdzgDouLlJBcYvh69ibGafy3pEeLh6jiaVA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;742&quot;/&gt;&lt;img data-ratio=&quot;0.5197183098591549&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNO0mrHPOTbFIkP3fI9IOhKzKCDtice7jMa3ra13n69gqdo7KZxVicqIJOr0v0n7gttFswznu8tHq0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;710&quot;/&gt;&lt;img data-ratio=&quot;0.43800904977375565&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpNO0mrHPOTbFIkP3fI9IOhKybrNQDch78E1IAWbqiaic6wKYZC1kF1bDO9D5nNibUvNoPeH92JcsNnMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1105&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么要将永久代替换为元空间呢?&lt;span/&gt;&lt;/h3&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;永久代使用的是 JVM 的内存，受 JVM 设置的内存大小限制；元空间使用的是本地直接内存，它的最大可分配空间是系统可用内存的空间。因为元空间里存放的是类的&lt;strong&gt;元数据&lt;/strong&gt;，所以随着内存空间的增大，能加载的类就更多了，相应的溢出的机率会大大减小。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 JDK8，合并 HotSpot 和 JRockit 的代码时，JRockit 从来没有一个叫永久代的东西，合并之后就没有必要额外的设置这么一个永久代的地方了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对永久代进行调优是很困难的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;StringTable 为什么要调整&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为永久代的回收效率很低，在 full gc 的时候才会触发。而 full GC 是老年代的空间不足、永久代不足时才会触发。这就导致了&lt;code&gt;StringTable&lt;/code&gt; 回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;垃圾回收&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。方法区的垃圾收集主要回收两部分内容：常量池中废奔的&lt;strong&gt;常量&lt;/strong&gt;和不再使用的&lt;strong&gt;类型&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法区内常量池中主要存放字面量和符号引用两大类常量：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;符号引用则属于编译原理方面的概念，包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;类型判定&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;该类所有的&lt;strong&gt;实例&lt;/strong&gt;都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;加载该类的&lt;strong&gt;类加载器&lt;/strong&gt;已经被回收，这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java 虛拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是今天的全部内容了，如果你有不同的意见或者更好的&lt;code&gt;idea&lt;/code&gt;，欢迎联系阿Q，添加阿Q可以加入&lt;strong&gt;技术交流群&lt;/strong&gt;参与讨论呦！&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI5MDg2NjEzNA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpMAn4Ha81WVBfsKnC9ficVemZff27LiaSoKX83JqwnNmrNhb4D4oAjW7wiaDwtkLTTCRs1A1hanfNu9g/0?wx_fmt=png&quot; data-nickname=&quot;阿Q说代码&quot; data-alias=&quot;AQ_Shuo&quot; data-signature=&quot;专注于后端技术栈分享：文章风格多变、配图通俗易懂、故事生动有趣&quot; data-from=&quot;1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>