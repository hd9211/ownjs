<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>2dcba8279be74b5ef5a14ac703e1b3c9</guid>
<title>如何快速实现一个聊天室？</title>
<link>https://toutiao.io/k/6xcz0t9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;如何快速实现一个聊天室？&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5384615384615384&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JJRW7FxQREz58QHz9k1ZDfgvLLIGqToR9cEK0XfhaNezuiaib8NlZjwqBEBaW8EK9QHVaNWibfiauic2LfJwnLAHQNQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;936&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;聊天室&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前些天做了一个网站：https://modubox.cn 其中有个群聊插件，许多人问如何实现的。这里简单说下，为了快速完成群聊功能，我选择从最简单的 WebSocket 开始。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;什么是WebSocket ？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然要使用它，就需要了解一下它吧。WebSocket其实也是一种基于TCP的网络协议，它与HTTP协议最大的不同是：是一种双向通信协议，在建立连接后，WebSocket服务器端和客户端都能主动向对方发送或接收数据，而HTTP协议只能客户端主动发起通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以WebSocket能够用于聊天，当然其他地方也能应用，如果做客服系统或推送消息都可以从这里开始。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;如何实现单聊/群聊？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;群聊：所有客户端的消息发送到服务器，服务端将消息发送给所有客户端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;单聊：WebSocket客户端之间是无法直接通信的，想要通信，必须由服务端转发。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.555&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/JJRW7FxQREz58QHz9k1ZDfgvLLIGqToRqr9iaZM2vdviaOWVibylkiaJhsdArOIO5r3D8WMSrSzicTW7bgCWpSB17sA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;群聊单聊&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;实现&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 引入WebSocket的支持&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们使用当前最流行的Spring Boot框架构建项目，然后引入Spring Boot 对 WebSocket 的支持：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-websocket&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 开启WebSocket&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@Configuration&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WebSocketConfig&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Bean&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; ServerEndpointExporter &lt;span&gt;serverEndpointExporter&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ServerEndpointExporter();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 服务端&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里主要有以下几点：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;声明服务端点路径&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;存储所有连接用户，等待匹配用户&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;连接 onOpen，消息OnMessage，关闭onClose，错误onError 方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;发送消息给特定连接者&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;@ServerEndpoint&lt;/span&gt;(value = &lt;span&gt;&quot;/websocket/random/&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ChatRandomServer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//所有连接&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ConcurrentHashMap&amp;lt;String, ChatRandomServer&amp;gt; webSocketSet = &lt;span&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;();&lt;br/&gt;    &lt;span&gt;//与某个客户端的连接会话，需要通过它来给客户端发送数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; Session session;&lt;br/&gt;    &lt;span&gt;//所有在配对的ID&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;String&amp;gt; webSocketLiveList = &lt;span&gt;new&lt;/span&gt; CopyOnWriteArrayList();&lt;br/&gt;    &lt;span&gt;//自己的id标识&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String id = &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;//连接对象的id标识&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String toUser = &lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 连接建立成功调用的方法&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@OnOpen&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onOpen&lt;/span&gt;&lt;span&gt;(Session session)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        session.setMaxIdleTimeout(&lt;span&gt;3600000&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.session = session;&lt;br/&gt;        &lt;span&gt;//获取用户ip&lt;/span&gt;&lt;br/&gt;        String ip = IpUtil.getRemoteAddress(session);&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.id = ip;&lt;br/&gt;        ChatRandomServer put = webSocketSet.put(&lt;span&gt;this&lt;/span&gt;.id, &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;//如果已经在队里，就不去找对象&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (put == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (pair()) {&lt;br/&gt;                    sendMessage(&lt;span&gt;&quot;匹配成功&quot;&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                sendMessage(&lt;span&gt;&quot;匹配失败&quot;&lt;/span&gt;);&lt;br/&gt;                webSocketSet.remove(&lt;span&gt;this&lt;/span&gt;.id); &lt;br/&gt;                session.close();&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;        log.info(&lt;span&gt;&quot;用户{}加入！当前在线人数为: {}&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.id, webSocketSet.size());&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 连接关闭调用的方法&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@OnClose&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onClose&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ChatRandomServer UserId = webSocketSet.get(toUser);&lt;br/&gt;        webSocketLiveList.remove(&lt;span&gt;this&lt;/span&gt;.id);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (UserId != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                sendToUser(session, &lt;span&gt;&quot;对方已离开&quot;&lt;/span&gt;, toUser);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        webSocketSet.remove(&lt;span&gt;this&lt;/span&gt;.id);&lt;br/&gt;        log.info(&lt;span&gt;&quot;{}连接关闭！当前在线人数:{}, 当前在匹配的人数:{}&quot;&lt;/span&gt; ,&lt;span&gt;this&lt;/span&gt;.id,webSocketSet.size(), webSocketLiveList.size());&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 收到客户端消息后调用的方法&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; message 客户端发送过来的消息&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;@OnMessage&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onMessage&lt;/span&gt;&lt;span&gt;(String message, Session session)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.info(&lt;span&gt;&quot;来自 {} 的消息: {}&quot;&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;.id, message);&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            ChatRandomServer.sendToUser(session, message, toUser, &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@OnError&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;onError&lt;/span&gt;&lt;span&gt;(Session session, Throwable error)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        log.error(&lt;span&gt;&quot;发生错误&quot;&lt;/span&gt;);&lt;br/&gt;        error.printStackTrace();&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            SendSelf(session,&lt;span&gt;&quot;服务器出现错误&quot;&lt;/span&gt;);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 发送消息给自己&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sendMessage&lt;/span&gt;&lt;span&gt;(String message)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        SendSelf(&lt;span&gt;this&lt;/span&gt;.session, message);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;SendSelf&lt;/span&gt;&lt;span&gt;(Session session, String message)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        session.getBasicRemote().sendText(message);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 发送信息给指定ID用户&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sendToUser&lt;/span&gt;&lt;span&gt;(Session session, String message, String sendUserId)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        ChatRandomServer UserId = webSocketSet.get(sendUserId);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (UserId != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            UserId.sendMessage(message);&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;            SendSelf(session, &lt;span&gt;&quot;发送失败&quot;&lt;/span&gt;);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 通知除了自己之外的所有人&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sendOnlineCount&lt;/span&gt;&lt;span&gt;(String message)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (String key : webSocketSet.keySet()) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (key.equals(id)) {&lt;br/&gt;                    &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;                }&lt;br/&gt;                webSocketSet.get(key).sendMessage(message);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 发送信息给所有人&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;sendToAll&lt;/span&gt;&lt;span&gt;(String message)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (String key : webSocketSet.keySet()) {&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                webSocketSet.get(key).sendMessage(message);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;pair&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//是否存在等待匹配的用户&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (webSocketLiveList.size() &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;//随机匹配一个&lt;/span&gt;&lt;br/&gt;            Random ra = &lt;span&gt;new&lt;/span&gt; Random();&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; nextInt = ra.nextInt(webSocketLiveList.size());&lt;br/&gt;            toUser = webSocketLiveList.get(nextInt);&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                ChatRandomServer UserId = webSocketSet.get(toUser);&lt;br/&gt;                UserId.setToUser(id);&lt;br/&gt;                sendToUser(session, &lt;span&gt;&quot;配对成功&quot;&lt;/span&gt;, toUser);&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (IOException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;            webSocketLiveList.remove(nextInt);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//没有匹配的，则将自己加入等待匹配队列&lt;/span&gt;&lt;br/&gt;        webSocketLiveList.add(id);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 前端支持&lt;span/&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt; start: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; (WebSocket) === &lt;span&gt;&quot;undefined&quot;&lt;/span&gt;) {&lt;br/&gt;          alert(&lt;span&gt;&quot;您的浏览器不支持socket&quot;&lt;/span&gt;)&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;          &lt;span&gt;// 实例化socket&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;this&lt;/span&gt;.socket = &lt;span&gt;new&lt;/span&gt; WebSocket(&lt;span&gt;`ws://localhost:8082/websocket/room`&lt;/span&gt;);&lt;br/&gt;          &lt;span&gt;// 监听socket连接&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;this&lt;/span&gt;.socket.onopen = &lt;span&gt;this&lt;/span&gt;.open&lt;br/&gt;          &lt;span&gt;// 监听socket错误信息&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;this&lt;/span&gt;.socket.onerror = &lt;span&gt;this&lt;/span&gt;.error&lt;br/&gt;          &lt;span&gt;// 监听socket消息&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;this&lt;/span&gt;.socket.onmessage = &lt;span&gt;this&lt;/span&gt;.getMessage&lt;br/&gt;          &lt;span&gt;this&lt;/span&gt;.socket.onclose = &lt;span&gt;this&lt;/span&gt;.close&lt;br/&gt;        }&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;open&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;error&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;getMessage&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;obj&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//接收信息后根据不同情况不同处理方式&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; data = &lt;span&gt;JSON&lt;/span&gt;.parse(obj.data);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (data.code === &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (data.code === &lt;span&gt;2&lt;/span&gt;) {&lt;br/&gt;        } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        }&lt;br/&gt;      },&lt;br/&gt;      &lt;span&gt;close&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span&gt;e&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;      },&lt;br/&gt;&lt;br/&gt;      &lt;span&gt;doSend&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (that.sendData === &lt;span&gt;&#x27;&#x27;&lt;/span&gt;) {&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.socket.send(that.sendData);&lt;br/&gt;        that.sendData = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;      },&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上代码不完整，如果需要看下完整代码，联系我。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;500&quot; data-backw=&quot;500&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;256&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;257&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/JJRW7FxQRExGEvHCSlBlBDLibfHJXldiaZ96rd67AIDF213cJzwICFLdUOFuib9cCibV1G8WVsG983iaRQZ1v1LRkUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bb068cb0972846af7fcf865202ce60ec</guid>
<title>深入探究 6 个 React 诡异现象</title>
<link>https://toutiao.io/k/ukuaetz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;前言&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们来一期不同寻常的React进阶文章，本文我们通过一些&lt;strong&gt;不同寻常的&lt;/strong&gt;现象，以探案的流程分析原因，找到结果，从而认识React，走进React的世界，揭开React的面纱，我深信，&lt;strong&gt;更深的理解，方可更好的使用。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我承认起这个名字可能有点标题党了，灵感来源于小时候央视有一个叫做《走进科学》的栏目，天天介绍各种超自然的灵异现象，搞的神乎其神，最后揭秘的时候原来是各种小儿科的问题，现在想想都觉得搞笑😂😂。但是我今天介绍的这些React &#x27;灵异&#x27;现象本质可不是小儿科，每一个现象后都透露出 &lt;strong&gt;React 运行机制&lt;/strong&gt;和&lt;strong&gt;设计原理&lt;/strong&gt;。（我们讲的react版本是&lt;code&gt;16.13.1&lt;/code&gt;）&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzm7OUwKfErKxVXuAcJSvLuibDCUSNWiaOefbnEDlWuQ7yKRoQ418WHKMiadIZBpoMlnCboVvRQqIkzQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好的，废话不多说，我的大侦探们，are you ready ? 让我们开启今天的揭秘之旅把。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;案件一：组件莫名其妙重复挂载&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;接到报案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前的一位同学遇到一个诡异情况，他希望在组件更新，&lt;code&gt;componentDidUpdate&lt;/code&gt;执行后做一些想要做的事，组件更新源来源于父组件传递 &lt;code&gt;props&lt;/code&gt; 的改变。但是父组件改变 &lt;code&gt;props&lt;/code&gt;发现视图渲染，但是&lt;code&gt;componentDidUpdate&lt;/code&gt;没有执行，更怪异的是&lt;code&gt;componentDidMount&lt;/code&gt;执行。代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// &lt;span&gt;TODO:&lt;/span&gt; 重复挂载&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Index&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;React&lt;/span&gt;.&lt;span&gt;Component&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;   componentDidMount(){&lt;br/&gt;     &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;组件初始化挂载&#x27;&lt;/span&gt;)&lt;br/&gt;   }&lt;br/&gt;   componentDidUpdate(){&lt;br/&gt;     &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;组件更新&#x27;&lt;/span&gt;)&lt;br/&gt;     &lt;span&gt;/* 想要做一些事情 */&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   render(){&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;《React进阶实践指南》  👍 { this.props.number } +   &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;效果如下&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3477801268498943&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/2KticQlBJtdzm7OUwKfErKxVXuAcJSvLutEAib8ibWgFFaNLiaDZ2iaZdaEWT4ag3vNbnZTibSibv9U9xlYdeBUSENTSQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1892&quot;/&gt;&lt;figcaption&gt;didupdate.gif&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;componentDidUpdate&lt;/code&gt;没有执行，&lt;code&gt;componentDidMount&lt;/code&gt;执行，说明组件根本&lt;strong&gt;没有走更新逻辑&lt;/strong&gt;，而是&lt;strong&gt;走了重复挂载&lt;/strong&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;逐一排查&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;子组件一头雾水，根本不找原因，我们只好从父组件入手。让我们看一下父组件如何写的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; BoxStyle = &lt;span&gt;(&lt;span&gt;{ children }&lt;/span&gt;)=&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&#x27;card&#x27;&lt;/span&gt; &amp;gt;&lt;/span&gt;{ children }&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Home&lt;/span&gt;(&lt;span/&gt;)&lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;const&lt;/span&gt; [ number , setNumber ] = useState(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;const&lt;/span&gt; NewIndex = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;BoxStyle&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;Index&lt;/span&gt; &lt;span&gt;number&lt;/span&gt;=&lt;span&gt;{number}&lt;/span&gt;  /&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;BoxStyle&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;NewIndex&lt;/span&gt;  /&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{&lt;/span&gt; ()=&amp;gt;&lt;/span&gt;setNumber(number+1) } &amp;gt;点赞&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从父组件中找到了一些端倪。在父组件中，首先通过&lt;code&gt;BoxStyle&lt;/code&gt;做为一个容器组件，添加样式，渲染我们的子组件&lt;code&gt;Index&lt;/code&gt;，但是每一次通过组合容器组件形成一个新的组件&lt;code&gt;NewIndex&lt;/code&gt;，真正挂载的是&lt;code&gt;NewIndex&lt;/code&gt;，真相大白。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;注意事项&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;造成这种情况的本质，是每一次 &lt;code&gt;render&lt;/code&gt; 过程中，都形成一个新组件，对于新组件，React 处理逻辑是直接卸载老组件，重新挂载新组件，所以我们开发的过程中，注意一个问题那就是：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对于函数组件，不要在其函数执行上下文中声明新组件并渲染，这样每次函数更新会促使组件重复挂载。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于类组件，不要在 &lt;code&gt;render&lt;/code&gt; 函数中，做如上同样的操作，否则也会使子组件重复挂载。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;案件二：事件源e.target离奇失踪&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;突发案件&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;化名（小明）在一个月黑风高的夜晚，突发奇想写一个受控组件。写的什么内容具体如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;EventDemo&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;React&lt;/span&gt;.&lt;span&gt;Component&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;constructor&lt;/span&gt;(props){&lt;br/&gt;    &lt;span&gt;super&lt;/span&gt;(props)&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.state={&lt;br/&gt;        &lt;span&gt;value&lt;/span&gt;:&lt;span&gt;&#x27;&#x27;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;  handerChange(e){&lt;br/&gt;    setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt;=&amp;gt;&lt;/span&gt;{&lt;br/&gt;       &lt;span&gt;this&lt;/span&gt;.setState({&lt;br/&gt;         &lt;span&gt;value&lt;/span&gt;:e.target.value&lt;br/&gt;       })&lt;br/&gt;    },&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;  }&lt;br/&gt;  render(){&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;input&lt;/span&gt; &lt;span&gt;placeholder&lt;/span&gt;=&lt;span&gt;&quot;请输入用户名？&quot;&lt;/span&gt; &lt;span&gt;onChange&lt;/span&gt;=&lt;span&gt;{&lt;/span&gt; &lt;span&gt;this.handerChange.bind&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;) }  /&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;input&lt;/code&gt;的值受到 &lt;code&gt;state&lt;/code&gt;中&lt;code&gt;value&lt;/code&gt;属性控制，小明想要通过&lt;code&gt;handerChange&lt;/code&gt;改变&lt;code&gt;value&lt;/code&gt;值，但是他期望在&lt;code&gt;setTimeout&lt;/code&gt;中完成更新。可以当他想要改变input值时候，意想不到的事情发生了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.504950495049505&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzm7OUwKfErKxVXuAcJSvLuB588Qqmibd0wgzkLfLEUfF2icsETNl73I1YMCCobbDjflAdf7XvAONiaQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;808&quot;/&gt;&lt;figcaption&gt;event.jpg&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;控制台报错如上所示。&lt;code&gt;Cannot read property &#x27;value&#x27; of null&lt;/code&gt; 也就是说明&lt;code&gt;e.target&lt;/code&gt;为&lt;code&gt;null&lt;/code&gt;。事件源 &lt;code&gt;target&lt;/code&gt;怎么说没就没呢？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;线索追踪&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接到这个案件之后，我们首先排查问题，那么我们先在&lt;code&gt;handerChange&lt;/code&gt;直接打印&lt;code&gt;e.target&lt;/code&gt;，如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.11838006230529595&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzm7OUwKfErKxVXuAcJSvLuzclYib5K51ribeUcibm1L4oVsicO9TfXgiagicbDGKO9Lau6EFypalOaaQPg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;642&quot;/&gt;&lt;figcaption&gt;event1.jpg&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看来首先排查不是 &lt;code&gt;handerChange&lt;/code&gt; 的原因，然后我们接着在&lt;code&gt;setTimeout&lt;/code&gt;中打印发现：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.07336956521739131&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzm7OUwKfErKxVXuAcJSvLuC0KkX0WUOs4bdFqvTmrvibvzoJNbbCG22OR6GDmhfMddaHxR6PNO1vA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;736&quot;/&gt;&lt;figcaption&gt;event2.jpg&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;果然是&lt;code&gt;setTimeout&lt;/code&gt;的原因，为什么&lt;code&gt;setTimeout&lt;/code&gt;中的事件源 e.target 就莫名的失踪了呢？首先，事件源肯定不是莫名的失踪了，肯定 React 底层对事件源做了一些额外的处理，首先我们知道React采用的是&lt;strong&gt;事件合成&lt;/strong&gt;机制，也就是绑定的 &lt;code&gt;onChange&lt;/code&gt;不是真实绑定的 &lt;code&gt;change&lt;/code&gt;事件，小明绑定的 &lt;code&gt;handerChange&lt;/code&gt;也不是真正的事件处理函数。那么也就是说React底层帮我们处理了事件源。这一切可能只有我们从 React 源码中找到线索。经过对源码的排查，我发现有一处线索十分可疑。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;react-dom/src/events/DOMLegacyEventPluginSystem.js&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;dispatchEventForLegacyPluginEventSystem&lt;/span&gt;(&lt;span&gt;topLevelType,eventSystemFlags,nativeEvent,targetInst&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; bookKeeping = getTopLevelCallbackBookKeeping(topLevelType,nativeEvent,targetInst,eventSystemFlags);&lt;br/&gt;    batchedEventUpdates(handleTopLevel, bookKeeping);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;dispatchEventForLegacyPluginEventSystem&lt;/code&gt;是&lt;code&gt;legacy&lt;/code&gt;模式下，所有事件都必定经过的主要函数，&lt;code&gt;batchedEventUpdates&lt;/code&gt;是处理批量更新的逻辑，里面会执行我们真正的事件处理函数，我们在事件原理篇章讲过 &lt;code&gt;nativeEvent&lt;/code&gt; 就是&lt;strong&gt;真正原生的事件对象 &lt;code&gt;event&lt;/code&gt;&lt;/strong&gt;。&lt;code&gt;targetInst&lt;/code&gt; 就是&lt;code&gt;e.target&lt;/code&gt;对应的&lt;code&gt;fiber&lt;/code&gt;对象。我们在&lt;code&gt;handerChange&lt;/code&gt;里面获取的事件源是React合成的事件源，那么了解事件源是什么时候，怎么样被合成的？这对于破案可能会有帮助。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事件原理篇我们将介绍React采用事件插件机制，比如我们的onClick事件对应的是 &lt;code&gt;SimpleEventPlugin&lt;/code&gt;，那么小明写&lt;code&gt;onChange&lt;/code&gt;也有专门 &lt;code&gt;ChangeEventPlugin&lt;/code&gt;事件插件，这些插件有一个至关重要的作用就是用来合成我们事件源对象e，所以我们来看一下&lt;code&gt;ChangeEventPlugin&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;react-dom/src/events/ChangeEventPlugin.js&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; ChangeEventPlugin ={&lt;br/&gt;   &lt;span&gt;eventTypes&lt;/span&gt;: eventTypes,&lt;br/&gt;   &lt;span&gt;extractEvents&lt;/span&gt;:&lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span/&gt;)&lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; event = SyntheticEvent.getPooled(&lt;br/&gt;            eventTypes.change,&lt;br/&gt;            inst, &lt;span&gt;// 组件实例&lt;/span&gt;&lt;br/&gt;            nativeEvent, &lt;span&gt;// 原生的事件源 e&lt;/span&gt;&lt;br/&gt;            target,      &lt;span&gt;// 原生的e.target&lt;/span&gt;&lt;br/&gt;     );&lt;br/&gt;     accumulateTwoPhaseListeners(event); &lt;span&gt;// 这个函数按照冒泡捕获逻辑处理真正的事件函数，也就是  handerChange 事件&lt;/span&gt;&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; event; &lt;span&gt;// &lt;/span&gt;&lt;br/&gt;   }   &lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看到合成事件的事件源&lt;code&gt;handerChange&lt;/code&gt;中的 e，就是&lt;code&gt;SyntheticEvent.getPooled&lt;/code&gt;创建出来的。那么这个是破案的关键所在。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;legacy-events/SyntheticEvent.js&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;SyntheticEvent.getPooled = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span/&gt;)&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; EventConstructor = &lt;span&gt;this&lt;/span&gt;; &lt;span&gt;//  SyntheticEvent&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (EventConstructor.eventPool.length) {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; instance = EventConstructor.eventPool.pop();&lt;br/&gt;    EventConstructor.call(instance,dispatchConfig,targetInst,nativeEvent,nativeInst,);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; instance;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; EventConstructor(dispatchConfig,targetInst,nativeEvent,nativeInst,);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;番外：在事件系统篇章，文章的事件池概念，讲的比较仓促，笼统，这篇这个部分将详细补充事件池&lt;span&gt;概念&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;code&gt;getPooled&lt;/code&gt;引出了事件池的真正的概念，它主要做了两件事：&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;判断事件池中有没有空余的事件源，如果有取出事件源复用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果没有，通过 &lt;code&gt;new SyntheticEvent&lt;/code&gt; 的方式创建一个新的事件源对象。那么 &lt;code&gt;SyntheticEvent&lt;/code&gt;就是创建事件源对象的构造函数，我们一起研究一下。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; EventInterface = {&lt;br/&gt;  &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;target&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;currentTarget&lt;/span&gt;: &lt;span&gt;&lt;span&gt;function&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;eventPhase&lt;/span&gt;: &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;  ...&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;SyntheticEvent&lt;/span&gt;(&lt;span&gt; dispatchConfig,targetInst,nativeEvent,nativeEventTarget&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.dispatchConfig = dispatchConfig; &lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;._targetInst = targetInst;    &lt;span&gt;// 组件对应fiber。&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.nativeEvent = nativeEvent;   &lt;span&gt;// 原生事件源。&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;._dispatchListeners = &lt;span&gt;null&lt;/span&gt;;   &lt;span&gt;// 存放所有的事件监听器函数。&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; propName &lt;span&gt;in&lt;/span&gt; Interface) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (propName === &lt;span&gt;&#x27;target&#x27;&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.target = nativeEventTarget; &lt;span&gt;// 我们真正打印的 target 是在这里&lt;/span&gt;&lt;br/&gt;      } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;[propName] = nativeEvent[propName];&lt;br/&gt;      }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;SyntheticEvent.prototype.preventDefault = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;)&lt;/span&gt;{ &lt;span&gt;/* .... */&lt;/span&gt; }     &lt;span&gt;/* 组件浏览器默认行为 */&lt;/span&gt;&lt;br/&gt;SyntheticEvent.prototype.stopPropagation = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{ &lt;span&gt;/* .... */&lt;/span&gt;  }  &lt;span&gt;/* 阻止事件冒泡 */&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;SyntheticEvent.prototype.destructor = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;)&lt;/span&gt;{ &lt;span&gt;/* 情况事件源对象*/&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;const&lt;/span&gt; propName &lt;span&gt;in&lt;/span&gt; Interface) {&lt;br/&gt;           &lt;span&gt;this&lt;/span&gt;[propName] = &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.dispatchConfig = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;._targetInst = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.nativeEvent = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; EVENT_POOL_SIZE = &lt;span&gt;10&lt;/span&gt;; &lt;span&gt;/* 最大事件池数量 */&lt;/span&gt;&lt;br/&gt;SyntheticEvent.eventPool = [] &lt;span&gt;/* 绑定事件池 */&lt;/span&gt;&lt;br/&gt;SyntheticEvent.release=&lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;)&lt;/span&gt;{ &lt;span&gt;/* 清空事件源对象，如果没有超过事件池上限，那么放回事件池 */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; EventConstructor = &lt;span&gt;this&lt;/span&gt;; &lt;br/&gt;    event.destructor();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (EventConstructor.eventPool.length &amp;lt; EVENT_POOL_SIZE) {&lt;br/&gt;       EventConstructor.eventPool.push(event);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我把这一段代码精炼之后，真相也就渐渐浮出水面了，我们先来看看 &lt;code&gt;SyntheticEvent&lt;/code&gt; 做了什么：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;首先赋予一些初始化的变量&lt;code&gt;nativeEvent&lt;/code&gt;等。然后按照 &lt;code&gt;EventInterface&lt;/code&gt; 规则把&lt;strong&gt;原生的事件源&lt;/strong&gt;上的属性，复制一份给&lt;strong&gt;React 事件源。然后一个重要的就是我们打印的e.target就是this.target，在事件源初始化的时候绑定了真正的&lt;code&gt;e.target-&amp;gt;nativeEventTarget&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;然后React事件源，绑定了自己的阻止默认行为&lt;code&gt;preventDefault&lt;/code&gt;，阻止冒泡&lt;code&gt;stopPropagation&lt;/code&gt;等方法。但是这里有一个重点方法就&lt;code&gt;destructor&lt;/code&gt;,&lt;strong&gt;这个函数置空了React自己的事件源对象。那么我们终于找到了答案，我们的事件源e.target消失大概率就是因为这个&lt;code&gt;destructor&lt;/code&gt;，&lt;code&gt;destructor&lt;/code&gt;在&lt;code&gt;release&lt;/code&gt;中被触发，然后将事件源放进事件池，等待下一次复用。&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在所有的矛头都指向了&lt;code&gt;release&lt;/code&gt;，那么&lt;code&gt;release&lt;/code&gt;是什么时候触发的呢？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;legacy-events/SyntheticEvent.js&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;executeDispatchesAndRelease&lt;/span&gt;(&lt;span/&gt;)&lt;/span&gt;{&lt;br/&gt;    event.constructor.release(event);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当 React 事件系统执行完所有的 &lt;code&gt;_dispatchListeners&lt;/code&gt;，就会触发这个方法 &lt;code&gt;executeDispatchesAndRelease&lt;/code&gt;释放当前的事件源。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;真相大白&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到小明遇到的这个问题，我们上面讲到，React最后会同步的置空事件源，然后放入事件池，因为&lt;code&gt;setTimeout&lt;/code&gt;是异步执行，执行时候事件源对象已经被重置并释放会事件池，所以我们打印 &lt;code&gt;e.target = null&lt;/code&gt;，到此为止，案件真相大白。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这个案件我们明白了 React 事件池的一些概念：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;React 事件系统有独特合成事件，也有自己的事件源，而且还有对一些特殊情况的处理逻辑，比如冒泡逻辑等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;React 为了防止每次事件都创建事件源对象，浪费性能，所以引入了&lt;strong&gt;事件池概念&lt;/strong&gt;，每一次用户事件都会从事件池中取出一个e，如果没有，就创建一个，然后赋值事件源，等到事件执行之后，重置事件源，放回事件池，借此做到复用。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;用一幅流程图表示：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5853080568720379&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzm7OUwKfErKxVXuAcJSvLurF9TtXG1M4yqDiaP61uxNVaMDEKIFYu47bRjNsxcR1JTNa7OQKZNfTg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1688&quot;/&gt;&lt;figcaption&gt;eventloop.jpg&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;案件三：真假React&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;案发现场&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是发生在笔者身上的事儿，之前在开发 React 项目时候，为了逻辑复用，我把一些封装好的自定义 Hooks 上传到公司私有的 package 管理平台上，在开发另外一个 React 项目的时候，把公司的包下载下来，在组件内部用起来。代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Index&lt;/span&gt;(&lt;span&gt;{classes, onSubmit, isUpgrade}&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;/* useFormQueryChange 是笔者写好的自定义hooks，并上传到私有库，主要是用于对表单控件的统一管理  */&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; {setFormItem, reset, formData} = useFormQueryChange()&lt;br/&gt;  React.useEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (isUpgrade)  reset()&lt;br/&gt;  }, [ isUpgrade ])&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;form&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;{classes.bootstrapRoot}&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;autoComplete&lt;/span&gt;=&lt;span&gt;&#x27;off&#x27;&lt;/span&gt;&lt;br/&gt;  &amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&#x27;btnbox&#x27;&lt;/span&gt; &amp;gt;&lt;/span&gt;&lt;br/&gt;       { /* 这里是业务逻辑，已经省略 */ }&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;form&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;useFormQueryChange&lt;/code&gt; 是笔者写好的自定义 &lt;code&gt;hooks&lt;/code&gt; ，并上传到私有库，主要是用于对表单控件的统一管理，没想到引入就直接爆红了。错误内容如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5975308641975309&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzm7OUwKfErKxVXuAcJSvLuJ5srj4sgKf3qXYaEtBuoj4YVCESChvpq3anTfvlDCgUXmvkRbb50iaw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;810&quot;/&gt;&lt;figcaption&gt;hooks.jpg&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;逐一排查&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们按照 React 报错的内容，逐一排查问题所在：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;第一个可能报错原因 &lt;code&gt;You might have mismatching versions of React and the renderer (such as React DOM)&lt;/code&gt;，意思是 &lt;code&gt;React&lt;/code&gt;和 &lt;code&gt;React Dom&lt;/code&gt;版本不一致，造成这种情况，但是我们项目中的 &lt;code&gt;React&lt;/code&gt; 和 &lt;code&gt;React Dom&lt;/code&gt; 都是 &lt;code&gt;v16.13.1&lt;/code&gt;，所以排除这个的嫌疑。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;第二个可能报错原因 &lt;code&gt;You might be breaking the Rules of Hooks&lt;/code&gt; 意思是你打破了Hooks 规则，这种情况也是不可能的，因为笔者代码里没有破坏&lt;code&gt;hoos&lt;/code&gt;规则的行为。所以也排除嫌疑。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;第三个可能报错原因&lt;code&gt;You might have more than one copy of React in the same app&lt;/code&gt; 意思是在同一个应用里面，可能有多个 React。目前来看所有的嫌疑都指向第三个，首先我们引用的自定义 hooks，会不会内部又存在一个React 呢？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照上面的提示我排查到自定义hooks对应的&lt;code&gt;node_modules&lt;/code&gt;中果然存在另外一个React，是这个&lt;code&gt;假React&lt;/code&gt;（我们姑且称之为假React）搞的鬼。我们在Hooks原理 文章中讲过，&lt;code&gt;React Hooks&lt;/code&gt;用&lt;code&gt;ReactCurrentDispatcher.current&lt;/code&gt; 在组件初始化，组件更新阶段赋予不同的hooks对象，更新完毕后赋予&lt;code&gt;ContextOnlyDispatcher&lt;/code&gt;，如果调用这个对象下面的hooks，就会报如上错误，那么说明了&lt;strong&gt;这个错误是因为我们这个项目，执行上下文引入的React是项目本身的React,但是自定义Hooks引用的是假React Hooks中的&lt;code&gt;ContextOnlyDispatcher&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我看到组件库中的&lt;code&gt;package.json&lt;/code&gt;中,&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&quot;dependencies&quot;&lt;/span&gt;: {&lt;br/&gt;  &lt;span&gt;&quot;react&quot;&lt;/span&gt;: &lt;span&gt;&quot;^16.13.1&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;react-dom&quot;&lt;/span&gt;: &lt;span&gt;&quot;^16.13.1&quot;&lt;/span&gt;&lt;br/&gt;},&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原来是React作为 &lt;code&gt;dependencies&lt;/code&gt;所以在下载自定义&lt;code&gt;Hooks&lt;/code&gt;的时候，把&lt;code&gt;React&lt;/code&gt;又下载了一遍。那么如何解决这个问题呢。对于封装React组件库，hooks库，不能用 &lt;code&gt;dependencies&lt;/code&gt;，因为它会以当前的&lt;code&gt;dependencies&lt;/code&gt;为依赖下载到自定义hooks库下面的&lt;code&gt;node_modules&lt;/code&gt;中。取而代之的应该用&lt;code&gt;peerDependencies&lt;/code&gt;，使用&lt;code&gt;peerDependencies&lt;/code&gt;，自定义&lt;code&gt;hooks&lt;/code&gt;再找相关依赖就会去我们的项目的&lt;code&gt;node_modules&lt;/code&gt;中找，就能根本上解决这个问题。所以我们这么改&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&quot;peerDependencies&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;react&quot;&lt;/span&gt;: &lt;span&gt;&quot;&amp;gt;=16.8&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;react-dom&quot;&lt;/span&gt;: &lt;span&gt;&quot;&amp;gt;=16.8&quot;&lt;/span&gt;,&lt;br/&gt;},&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就完美的解决了这个问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;拨开迷雾&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题让我们明白了如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;对于一些hooks库，组件库，本身的依赖，已经在项目中存在了，所以用&lt;code&gt;peerDependencies&lt;/code&gt;声明。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;在开发的过程中，很可能用到不同版本的同一依赖，比如说项目引入了 A 版本的依赖，组件库引入了 B 版本的依赖。那么这种情况如何处理呢。在 &lt;code&gt;package.json&lt;/code&gt; 文档中提供了一个resolutions配置项可以解决这个问题，在 &lt;code&gt;resolutions&lt;/code&gt; 中锁定同一的引入版本，这样就不会造成如上存在多个版本的项目依赖而引发的问题。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目&lt;code&gt;package.json&lt;/code&gt;这么写&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;resolutions&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;react&quot;&lt;/span&gt;: &lt;span&gt;&quot;16.13.1&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;react-dom&quot;&lt;/span&gt;: &lt;span&gt;&quot;16.13.1&quot;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样无论项目中的依赖，还是其他库中依赖，都会使用统一的版本，从根本上解决了多个版本的问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;案件四：PureComponet/memo功能失效问题&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;案情描述&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 React 开发的时候，但我们想要用 &lt;code&gt;PureComponent&lt;/code&gt; 做性能优化，调节组件渲染，但是写了一段代码之后，发现 &lt;code&gt;PureComponent&lt;/code&gt; 功能竟然失效了，具体代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Index&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;React&lt;/span&gt;.&lt;span&gt;PureComponent&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;   render(){&lt;br/&gt;     &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;组件渲染&#x27;&lt;/span&gt;)&lt;br/&gt;     &lt;span&gt;const&lt;/span&gt; { name , type } = &lt;span&gt;this&lt;/span&gt;.props&lt;br/&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;       hello , my name is { name }&lt;br/&gt;       let us learn { type }&lt;br/&gt;     &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Home&lt;/span&gt; (&lt;span/&gt;)&lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;const&lt;/span&gt; [ number , setNumber  ] = React.useState(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;const&lt;/span&gt; [ type , setType ] = React.useState(&lt;span&gt;&#x27;react&#x27;&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;const&lt;/span&gt; changeName = &lt;span&gt;(&lt;span&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;       setType(name)&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;&amp;lt;&lt;span&gt;span&lt;/span&gt;&amp;gt;&lt;/span&gt;{ number }&lt;span&gt;&amp;lt;/&lt;span&gt;span&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;br&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{&lt;/span&gt; ()=&amp;gt;&lt;/span&gt; setNumber(number + 1) } &amp;gt;change number&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;&amp;lt;&lt;span&gt;Index&lt;/span&gt; &lt;span&gt;type&lt;/span&gt;=&lt;span&gt;{type}&lt;/span&gt;  &lt;span&gt;changeType&lt;/span&gt;=&lt;span&gt;{&lt;/span&gt; &lt;span&gt;changeName&lt;/span&gt; } &lt;span&gt;name&lt;/span&gt;=&lt;span&gt;&quot;alien&quot;&lt;/span&gt;  /&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们本来期望：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对于 Index 组件，只有&lt;code&gt;props&lt;/code&gt;中 &lt;code&gt;name&lt;/code&gt;和&lt;code&gt;type&lt;/code&gt;改变，才促使组件渲染。但是实际情况却是这样：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击按钮效果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3838748495788207&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/2KticQlBJtdzm7OUwKfErKxVXuAcJSvLukRKEJGfNckibmyPwjw2IiacjztZrP6IVDtplD1jnKKAUR0u3TalsG5hQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1662&quot;/&gt;&lt;figcaption&gt;purecomponent.gif&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;水落石出&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么会出现这种情况呢？我们再排查一下&lt;code&gt;Index&lt;/code&gt;组件，发现 &lt;code&gt;Index&lt;/code&gt; 组件上有一个 &lt;code&gt;changeType&lt;/code&gt;，那么是不是这个的原因呢？我们来分析一下，首先状态更新是在父组件 &lt;code&gt;Home&lt;/code&gt;上，&lt;code&gt;Home&lt;/code&gt;组件更新每次会产生一个新的&lt;code&gt;changeName&lt;/code&gt;，所以&lt;code&gt;Index&lt;/code&gt;的&lt;code&gt;PureComponent&lt;/code&gt;每次会&lt;strong&gt;浅比较&lt;/strong&gt;，发现&lt;code&gt;props&lt;/code&gt;中的&lt;code&gt;changeName&lt;/code&gt;每次都不相等，所以就更新了，给我们直观的感觉是失效了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么如何解决这个问题，&lt;code&gt;React hooks&lt;/code&gt; 中提供了 &lt;code&gt;useCallback&lt;/code&gt;，可以对&lt;code&gt;props&lt;/code&gt;传入的回调函数进行缓存，我们来改一下&lt;code&gt;Home&lt;/code&gt;代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; changeName = React.useCallback(&lt;span&gt;(&lt;span&gt;name&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    setType(name)&lt;br/&gt;},[])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;效果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3838748495788207&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/2KticQlBJtdzm7OUwKfErKxVXuAcJSvLu06eA618znceOibrTvv59FSibgnOB95q0CumsmicESexL6anicy7NTIiczmg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1662&quot;/&gt;&lt;figcaption&gt;pureComponent1.gif&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就根本解决了问题，用 &lt;code&gt;useCallback&lt;/code&gt;对&lt;code&gt;changeName&lt;/code&gt;函数进行缓存，在每一次 &lt;code&gt;Home&lt;/code&gt; 组件执行，只要&lt;code&gt;useCallback&lt;/code&gt;中&lt;code&gt;deps&lt;/code&gt;没有变，&lt;code&gt;changeName&lt;/code&gt;内存空间还指向原来的函数，这样&lt;code&gt;PureComponent&lt;/code&gt;浅比较就会发现是相同&lt;code&gt;changeName&lt;/code&gt;，从而不渲染组件，至此案件已破。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;继续深入&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家用函数组件+类组件开发的时候，如果用到&lt;code&gt;React.memo React.PureComponent&lt;/code&gt;等api，要注意给这些组件绑定事件的方式，如果是函数组件，那么想要持续保持&lt;strong&gt;纯组件的渲染控制的特性&lt;/strong&gt;的话，那么请用 &lt;code&gt;useCallback&lt;/code&gt;,&lt;code&gt;useMemo&lt;/code&gt;等api处理，如果是类组件，请不要用箭头函数绑定事件，箭头函数同样会造成失效的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述中提到了一个浅比较&lt;code&gt;shallowEqual&lt;/code&gt;，接下来我们重点分析一下 &lt;code&gt;PureComponent&lt;/code&gt;是如何&lt;code&gt;shallowEqual&lt;/code&gt;，接下来我们在深入研究一下&lt;code&gt;shallowEqual&lt;/code&gt;的奥秘。那么就有从类租价的更新开始。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;react-reconciler/src/ReactFiberClassComponent.js&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;updateClassInstance&lt;/span&gt;(&lt;span/&gt;)&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; shouldUpdate =&lt;br/&gt;    checkHasForceUpdateAfterProcessing() ||&lt;br/&gt;    checkShouldComponentUpdate(&lt;br/&gt;      workInProgress,&lt;br/&gt;      ctor,&lt;br/&gt;      oldProps,&lt;br/&gt;      newProps,&lt;br/&gt;      oldState,&lt;br/&gt;      newState,&lt;br/&gt;      nextContext,&lt;br/&gt;    );&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; shouldUpdate&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我这里简化&lt;code&gt;updateClassInstance&lt;/code&gt;，只保留了涉及到&lt;code&gt;PureComponent&lt;/code&gt;的部分。&lt;code&gt;updateClassInstance&lt;/code&gt;这个函数主要是用来，执行生命周期，更新state，判断组件是否重新渲染，返回的 &lt;code&gt;shouldUpdate&lt;/code&gt;用来决定当前类组件是否渲染。&lt;code&gt;checkHasForceUpdateAfterProcessing&lt;/code&gt;检查更新来源是否来源与 forceUpdate ， 如果是&lt;code&gt;forceUpdate&lt;/code&gt;组件是一定会更新的，&lt;code&gt;checkShouldComponentUpdate&lt;/code&gt;检查组件是否渲染。我们接下来看一下这个函数的逻辑。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;checkShouldComponentUpdate&lt;/span&gt;(&lt;span/&gt;)&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;/* 这里会执行类组件的生命周期 shouldComponentUpdate */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; shouldUpdate = instance.shouldComponentUpdate(&lt;br/&gt;      newProps,&lt;br/&gt;      newState,&lt;br/&gt;      nextContext,&lt;br/&gt;    );&lt;br/&gt;    &lt;span&gt;/* 这里判断组件是否是 PureComponent 纯组件，如果是纯组件那么会调用 shallowEqual 浅比较  */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (ctor.prototype &amp;amp;&amp;amp; ctor.prototype.isPureReactComponent) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;        !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)&lt;br/&gt;        );&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;checkShouldComponentUpdate&lt;/code&gt;有两个至关重要的作用：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一个就是如果类组件有生命周期&lt;code&gt;shouldComponentUpdate&lt;/code&gt;，会执行生命周期&lt;code&gt;shouldComponentUpdate&lt;/code&gt;，判断组件是否渲染。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果发现是纯组件&lt;code&gt;PureComponent&lt;/code&gt;，会浅比较新老&lt;code&gt;props&lt;/code&gt;和&lt;code&gt;state&lt;/code&gt;是否相等，如果相等，则不更新组件。&lt;code&gt;isPureReactComponent&lt;/code&gt;就是我们使用&lt;code&gt;PureComponent&lt;/code&gt;的标识，证明是纯组件。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来就是重点&lt;code&gt;shallowEqual&lt;/code&gt;，以&lt;code&gt;props&lt;/code&gt;为例子，我们看一下。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;shared/shallowEqual&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;shallowEqual&lt;/span&gt;(&lt;span&gt;objA: mixed, objB: mixed&lt;/span&gt;): &lt;span&gt;boolean&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (is(objA, objB)) { &lt;span&gt;// is可以 理解成  objA === objB 那么返回相等&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (&lt;br/&gt;    &lt;span&gt;typeof&lt;/span&gt; objA !== &lt;span&gt;&#x27;object&#x27;&lt;/span&gt; ||&lt;br/&gt;    objA === &lt;span&gt;null&lt;/span&gt; ||&lt;br/&gt;    &lt;span&gt;typeof&lt;/span&gt; objB !== &lt;span&gt;&#x27;object&#x27;&lt;/span&gt; ||&lt;br/&gt;    objB === &lt;span&gt;null&lt;/span&gt;&lt;br/&gt;  ) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;  &lt;br/&gt;  } &lt;span&gt;// 如果新老props有一个不为对象，或者不存在，那么直接返回false&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; keysA = &lt;span&gt;Object&lt;/span&gt;.keys(objA); &lt;span&gt;// 老props / 老state key组成的数组&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; keysB = &lt;span&gt;Object&lt;/span&gt;.keys(objB); &lt;span&gt;// 新props / 新state key组成的数组&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (keysA.length !== keysB.length) { &lt;span&gt;// 说明props增加或者减少，那么直接返回不想等&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; keysA.length; i++) { &lt;span&gt;// 遍历老的props ,发现新的props没有，或者新老props不同等,那么返回不更新组件。&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (&lt;br/&gt;      !hasOwnProperty.call(objB, keysA[i]) ||&lt;br/&gt;      !is(objA[keysA[i]], objB[keysA[i]])&lt;br/&gt;    ) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;; &lt;span&gt;//默认返回相等&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;shallowEqual&lt;/code&gt;流程是这样的，&lt;code&gt;shallowEqual&lt;/code&gt; 返回 &lt;code&gt;true&lt;/code&gt; 则证明相等，那么不更新组件；如果返回&lt;code&gt;false&lt;/code&gt; 证明不想等，那么更新组件。&lt;code&gt;is&lt;/code&gt; 我们暂且可以理解成 ===&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;第一步，直接通过 === 判断是否相等，如果相等，那么返回&lt;code&gt;true&lt;/code&gt;。正常情况只要调用 &lt;code&gt;React.createElement&lt;/code&gt; 会重新创建&lt;code&gt;props&lt;/code&gt;，&lt;code&gt;props&lt;/code&gt;都是不相等的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第二步，如果新老&lt;code&gt;props&lt;/code&gt;有一个不为对象，或者不存在，那么直接返回&lt;code&gt;false&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第三步，判断新老&lt;code&gt;props&lt;/code&gt;，&lt;code&gt;key&lt;/code&gt;组成的数组数量等不想等，说明&lt;code&gt;props&lt;/code&gt;有增加或者减少，那么直接返回&lt;code&gt;false&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;第四步，遍历老的&lt;code&gt;props&lt;/code&gt; ,发现新的&lt;code&gt;props&lt;/code&gt;没有与之对应，或者新老&lt;code&gt;props&lt;/code&gt;不同等,那么返回&lt;code&gt;false&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;默认返回&lt;code&gt;true&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是&lt;code&gt;shallowEqual&lt;/code&gt;逻辑，代码还是非常简单的。感兴趣的同学可以看一看。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;案件五: useState更新相同的State,函数组件执行2次&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;接到报案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题实际很悬，大家可能平时没有注意到，引起我的注意的是掘金的一个掘友问我的一个问题，问题如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6960950764006791&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzm7OUwKfErKxVXuAcJSvLuOicuia9pLJvmFra68ticgVZyosT2ueYWydicm89muTdWX0kRwcvCbqBBPQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1178&quot;/&gt;首先非常感谢这位细心的掘友的报案，我在 React-hooks 原理 中讲到过，对于更新组件的方法函数组件 &lt;code&gt;useState&lt;/code&gt; 和类组件的&lt;code&gt;setState&lt;/code&gt;有一定区别，&lt;code&gt;useState&lt;/code&gt;源码中如果遇到两次相同的&lt;code&gt;state&lt;/code&gt;，会默认阻止组件再更新，但是类组件中&lt;code&gt;setState&lt;/code&gt;如果没有设置 &lt;code&gt;PureComponent&lt;/code&gt;，两次相同的&lt;code&gt;state&lt;/code&gt; 也会更新。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们回顾一下 &lt;code&gt;hooks&lt;/code&gt; 中是怎么样阻止组件更新的。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;react-reconciler/src/ReactFiberHooks.js -&amp;gt; dispatchAction&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (is(eagerState, currentState)) { &lt;br/&gt;     &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;scheduleUpdateOnFiber(fiber, expirationTime); &lt;span&gt;// 调度更新&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果判断上一次的&lt;code&gt;state&lt;/code&gt; -&amp;gt; &lt;code&gt;currentState&lt;/code&gt; ，和这一次的&lt;code&gt;state&lt;/code&gt; -&amp;gt; &lt;code&gt;eagerState&lt;/code&gt; 相等，那么将直接 &lt;code&gt;return&lt;/code&gt;阻止组件进行&lt;code&gt;scheduleUpdate&lt;/code&gt;调度更新。&lt;strong&gt;所以我们想如果两次 &lt;code&gt;useState&lt;/code&gt;触发同样的state，那么组件只能更新一次才对，但是事实真的是这样吗？。&lt;/strong&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;立案调查&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顺着这位掘友提供的线索，我们开始写 &lt;code&gt;demo&lt;/code&gt;进行验证。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; Index = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; [ number , setNumber  ] = useState(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;组件渲染&#x27;&lt;/span&gt;,number)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;page&quot;&lt;/span&gt; &amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;content&quot;&lt;/span&gt; &amp;gt;&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;&amp;lt;&lt;span&gt;span&lt;/span&gt;&amp;gt;&lt;/span&gt;{ number }&lt;span&gt;&amp;lt;/&lt;span&gt;span&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;br&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{&lt;/span&gt; () =&amp;gt;&lt;/span&gt; setNumber(1) } &amp;gt;将number设置成1&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;br&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{&lt;/span&gt; () =&amp;gt;&lt;/span&gt; setNumber(2) } &amp;gt;将number设置成2&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;br&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{&lt;/span&gt; () =&amp;gt;&lt;/span&gt; setNumber(3) } &amp;gt;将number设置成3&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Home&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;React&lt;/span&gt;.&lt;span&gt;Component&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;  render(){&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;span&gt;Index&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上demo，三个按钮，我们期望连续点击每一个按钮，组件都会仅此渲染一次，于是我们开始实验：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;效果：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3535714285714286&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/2KticQlBJtdzm7OUwKfErKxVXuAcJSvLuMgn6OYOibIADwG0iaeaC1riaianubllIvQGS7WxPj3gy9nr6K5V84s3eaA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1120&quot;/&gt;&lt;figcaption&gt;demo1.gif&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;果然，我们通过 &lt;code&gt;setNumber&lt;/code&gt; 改变 &lt;code&gt;number&lt;/code&gt;，每次连续点击按钮，组件都会更新2次，按照我们正常的理解，每次赋予 &lt;code&gt;number&lt;/code&gt; 相同的值，只会渲染一次才对，但是为什么执行了2次呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能刚开始会陷入困境，不知道怎么破案，但是我们在想 &lt;code&gt;hooks&lt;/code&gt;原理中讲过，每一个函数组件用对应的函数组件的 &lt;code&gt;fiber&lt;/code&gt; 对象去保存 &lt;code&gt;hooks&lt;/code&gt; 信息。所以我们只能从 &lt;code&gt;fiber&lt;/code&gt;找到线索。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;顺藤摸瓜&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么如何找到函数组件对应的fiber对象呢，这就顺着函数组件的父级 &lt;code&gt;Home&lt;/code&gt; 入手了，因为我们可以从类组件&lt;code&gt;Home&lt;/code&gt;中找到对应的fiber对象，然后根据 &lt;code&gt;child&lt;/code&gt; 指针找到函数组件 &lt;code&gt;Index&lt;/code&gt;对应的 &lt;code&gt;fiber&lt;/code&gt;。说干就干，我们将上述代码改造成如下的样子：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; Index = &lt;span&gt;(&lt;span&gt;{ consoleFiber }&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; [ number , setNumber  ] = useState(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;  useEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt;=&amp;gt;&lt;/span&gt;{  &lt;br/&gt;      &lt;span&gt;console&lt;/span&gt;.log(number)&lt;br/&gt;      consoleFiber() &lt;span&gt;// 每次fiber更新后，打印 fiber 检测 fiber变化&lt;/span&gt;&lt;br/&gt;  })&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;page&quot;&lt;/span&gt; &amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&quot;content&quot;&lt;/span&gt; &amp;gt;&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;&amp;lt;&lt;span&gt;span&lt;/span&gt;&amp;gt;&lt;/span&gt;{ number }&lt;span&gt;&amp;lt;/&lt;span&gt;span&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;br&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;       &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{&lt;/span&gt; () =&amp;gt;&lt;/span&gt; setNumber(1) } &amp;gt;将number设置成1&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;br&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Home&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;React&lt;/span&gt;.&lt;span&gt;Component&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;  consoleChildrenFiber(){&lt;br/&gt;     &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;this&lt;/span&gt;._reactInternalFiber.child) &lt;span&gt;/* 用来打印函数组件 Index 对应的fiber */&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  render(){&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;span&gt;Index&lt;/span&gt; &lt;span&gt;consoleFiber&lt;/span&gt;=&lt;span&gt;{&lt;/span&gt; &lt;span&gt;this.consoleChildrenFiber.bind&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;) }  /&amp;gt;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我们重点关心fiber上这几个属性，这对破案很有帮助&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Index fiber&lt;/code&gt;上的 &lt;code&gt;memoizedState&lt;/code&gt; 属性，&lt;code&gt;react hooks&lt;/code&gt; 原理文章中讲过，函数组件用 &lt;code&gt;memoizedState&lt;/code&gt; 保存所有的 &lt;code&gt;hooks&lt;/code&gt; 信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Index fiber&lt;/code&gt;上的 &lt;code&gt;alternate&lt;/code&gt; 属性&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Index fiber&lt;/code&gt;上的 &lt;code&gt;alternate&lt;/code&gt; 属性上的 &lt;code&gt;memoizedState&lt;/code&gt;属性。是不是很绕😂，马上会揭晓是什么。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Index&lt;/code&gt;组件上的 &lt;code&gt;useState&lt;/code&gt;中的&lt;code&gt;number&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们讲一下 &lt;code&gt;alternate&lt;/code&gt; 指针指的是什么？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到&lt;code&gt;alternate&lt;/code&gt; 就要从&lt;code&gt;fiber&lt;/code&gt;架构设计说起，每个&lt;code&gt;React&lt;/code&gt;元素节点，用两颗fiber树保存状态，一颗树保存当前状态，一个树保存上一次的状态，两棵 &lt;code&gt;fiber&lt;/code&gt; 树用 &lt;code&gt;alternate&lt;/code&gt; 相互指向。就是我们耳熟能详的&lt;strong&gt;双缓冲&lt;/strong&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;初始化打印&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;效果图：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.914438502673797&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzm7OUwKfErKxVXuAcJSvLuwCyPnfYnff1q0TYPVScKtUzj0D6Rgqu5zfRTb4OicSyR6GTIJPFnTPw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;748&quot;/&gt;&lt;figcaption&gt;fiber1.jpg&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;初始化完成第一次render后，我们看一下fiber树上的这几个状态&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次打印结果如下，&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;fiber&lt;/code&gt;上的 &lt;code&gt;memoizedState&lt;/code&gt; 中 &lt;strong&gt;&lt;code&gt;baseState = 0&lt;/code&gt;&lt;/strong&gt; 即是初始化 &lt;code&gt;useState&lt;/code&gt; 的值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;fiber&lt;/code&gt;上的 &lt;code&gt;alternate&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Index&lt;/code&gt;组件上的 &lt;code&gt;number&lt;/code&gt; 为 0。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始化流程：首先对于组件第一次初始化，会调和渲染形成一个fiber树（我们&lt;strong&gt;简称为树A&lt;/strong&gt;）。树A的&lt;code&gt;alternate&lt;/code&gt;属性为 &lt;code&gt;null&lt;/code&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第一次点击 setNumber(1)&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我们第一次点击发现组件渲染了，然后我们打印结果如下：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.6129807692307692&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzm7OUwKfErKxVXuAcJSvLuvqSVY78asGLUniaWskmNVLDal1xb13Js9Ixmm0DJjuLZ6ejj5agLbrw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;832&quot;/&gt;&lt;figcaption&gt;fiber2.jpg&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;树A上的 &lt;code&gt;memoizedState&lt;/code&gt; 中 **&lt;code&gt;baseState = 0&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;树A上的 &lt;code&gt;alternate&lt;/code&gt; 指向 另外一个&lt;code&gt;fiber&lt;/code&gt;(我们这里称之为树B)。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Index&lt;/code&gt;组件上的 &lt;code&gt;number&lt;/code&gt; 为 1。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们打印树B上的 &lt;code&gt;memoizedState&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.7283653846153846&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzm7OUwKfErKxVXuAcJSvLu7D17fdJqullwDv5FS634xdicVB020ogDkwHKKSicnuT4y1aws46keB3A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;832&quot;/&gt;&lt;figcaption&gt;fiber3.jpg&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果我们发现树B上 &lt;code&gt;memoizedState&lt;/code&gt;上的 &lt;code&gt;baseState = 1&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;得出结论：更新的状态都在树B上，而树A上的 baseState还是之前的0。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们大胆猜测一下更新流程：在第一次更新渲染的时候，由于树A中，不存在&lt;code&gt;alternate&lt;/code&gt;，所以直接复制一份树A作为 &lt;code&gt;workInProgress&lt;/code&gt;（我们这里称之为&lt;strong&gt;树B&lt;/strong&gt;）所有的更新都在当前树B中进行，所以 baseState 会被更新成 1,然后用当前的&lt;strong&gt;树B&lt;/strong&gt;进行渲染。结束后树A和树B通过&lt;code&gt;alternate&lt;/code&gt;相互指向。树B作为下一次操作的&lt;code&gt;current&lt;/code&gt;树。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第二次点击 setNumber(1)&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第二次打印，组件同样渲染了，然后我们打印fiber对象，效果如下：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.5049261083743843&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzm7OUwKfErKxVXuAcJSvLuwG4lSg2DXrKzFNOKvjy5MguekxjwU5kMzcepyFCzvvK8VndOic2jujw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;812&quot;/&gt;&lt;figcaption&gt;fiber4.jpg&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;fiber对象上的 &lt;code&gt;memoizedState&lt;/code&gt; 中 &lt;code&gt;baseState&lt;/code&gt;更新成了 1。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们打印一下 &lt;code&gt;alternate&lt;/code&gt; 中 &lt;code&gt;baseState&lt;/code&gt;也更新成了 1。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.484240687679083&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzm7OUwKfErKxVXuAcJSvLu2ysUaQPSGCGicVFfFFDxLUIxIZ8KMNTQ6fjk3GlUyUTDOL8YMePvLJg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;698&quot;/&gt;&lt;figcaption&gt;fiber5.jpg&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二次点击之后 ，树A和树B都更新到最新的 baseState = 1&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们分析一下流程：当我们第二次点击时候，是通过上一次树A中的 &lt;code&gt;baseState = 0&lt;/code&gt; 和 &lt;code&gt;setNumber(1)&lt;/code&gt; 传入的 1做的比较。所以发现 &lt;code&gt;eagerState !== currentState&lt;/code&gt; ，组件又更新了一次。接下来会以current树（树B）的 &lt;code&gt;alternate&lt;/code&gt;指向的树A作为新的&lt;code&gt;workInProgress&lt;/code&gt;进行更新，此时的树A上的 baseState 终于更新成了 1 ，这就解释了为什么上述两个 baseState 都等于 1。接下来组件渲染完成。树A作为了新的 current 树。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们第二次打印，打印出来的实际是交替后树B，树A和树B就这样交替着作为最新状态用于渲染的&lt;code&gt;workInProgress&lt;/code&gt;树和缓存上一次状态用于下一次渲染的&lt;code&gt;current&lt;/code&gt;树。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第三次点击（三者言其多也）&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么第三次点击组件没有渲染，就很好解释了，第三次点击上一次树B中的 &lt;code&gt;baseState = 1&lt;/code&gt; 和 &lt;code&gt;setNumber(1)&lt;/code&gt;相等，也就直接走了return逻辑。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;揭开谜底（我们学到了什么）&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;双缓冲树：React 用 &lt;code&gt;workInProgress&lt;/code&gt;树(内存中构建的树) 和 &lt;code&gt;current&lt;/code&gt;(渲染树) 来实现更新逻辑。我们console.log打印的fiber都是在内存中即将 &lt;code&gt;workInProgress&lt;/code&gt;的fiber树。双缓存一个在内存中构建，在下一次渲染的时候，直接用缓存树做为下一次渲染树，上一次的渲染树又作为缓存树，这样可以防止只用一颗树更新状态的丢失的情况，又加快了&lt;code&gt;dom&lt;/code&gt;节点的替换与更新。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;更新机制：在一次更新中，首先会获取current树的 &lt;code&gt;alternate&lt;/code&gt;作为当前的 &lt;code&gt;workInProgress&lt;/code&gt;，渲染完毕后，&lt;code&gt;workInProgress&lt;/code&gt; 树变为 &lt;code&gt;current&lt;/code&gt; 树。我们用如上的树A和树B和已经保存的baseState模型，来更形象的解释了更新机制 。hooks中的useState进行state对比，用的是缓存树上的state和当前最新的state。所有就解释了为什么更新相同的state，函数组件执行2次了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我们用一幅流程图来描述整个流程。&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.32773851590106007&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2KticQlBJtdzm7OUwKfErKxVXuAcJSvLuJhO33zlCfV6aBKDdJEamF8ctlWdOoQw4JrNaybcRPGkQCspGl1c5Zg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2264&quot;/&gt;&lt;figcaption&gt;FFB125E7-6A34-4F44-BB6E-A11D598D0A01.jpg&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此案已破，通过这个容易忽略的案件，我们学习了双缓冲和更新机制。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;案件六：useEffect修改DOM元素导致怪异闪现&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;鬼使神差&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小明（化名）在动态挂载组件的时候，遇到了灵异的Dom闪现现象，让我们先来看一下现象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;闪现现象：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4196078431372549&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/2KticQlBJtdzm7OUwKfErKxVXuAcJSvLunEeQFe5JjC6q0AfLSKFGKIpCbk0dW5OxUF45ncnwylDRyBTb0VhG4A/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1530&quot;/&gt;&lt;figcaption&gt;effect.gif&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Index&lt;/span&gt;(&lt;span&gt;{ offset }&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; card  = React.useRef(&lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;    React.useEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt;=&amp;gt;&lt;/span&gt;{&lt;br/&gt;       card.current.style.left = offset&lt;br/&gt;    },[])&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&#x27;box&#x27;&lt;/span&gt; &amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;className&lt;/span&gt;=&lt;span&gt;&#x27;card custom&#x27;&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;{card}&lt;/span&gt;   &amp;gt;&lt;/span&gt;《 React进阶实践指南 》&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;Home&lt;/span&gt;(&lt;span&gt;{ offset = &lt;span&gt;&#x27;300px&#x27;&lt;/span&gt; }&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;   &lt;span&gt;const&lt;/span&gt; [ isRender , setRender ] = React.useState(&lt;span&gt;false&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;       { isRender &amp;amp;&amp;amp; &lt;span&gt;&amp;lt;&lt;span&gt;Index&lt;/span&gt; &lt;span&gt;offset&lt;/span&gt;=&lt;span&gt;{offset}&lt;/span&gt;  /&amp;gt;&lt;/span&gt; }&lt;br/&gt;       &lt;span&gt;&amp;lt;&lt;span&gt;button&lt;/span&gt; &lt;span&gt;onClick&lt;/span&gt;=&lt;span&gt;{&lt;/span&gt; ()=&amp;gt;&lt;/span&gt;setRender(true) } &amp;gt; 挂载&lt;span&gt;&amp;lt;/&lt;span&gt;button&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;在父组件用 &lt;code&gt;isRender&lt;/code&gt; 动态加载 &lt;code&gt;Index&lt;/code&gt;，点击按钮控制 &lt;code&gt;Index&lt;/code&gt;渲染。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在 &lt;code&gt;Index&lt;/code&gt;的接受动态的偏移量&lt;code&gt;offset&lt;/code&gt;。并通过操纵用&lt;code&gt;useRef&lt;/code&gt;获取的原生&lt;code&gt;dom&lt;/code&gt;直接改变偏移量，使得划块滑动。但是出现了如上图的闪现现象，很不友好，那么为什么会造成这个问题呢？&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;深入了解&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初步判断产生这个闪现的问题应该是 &lt;code&gt;useEffect&lt;/code&gt;造成的，为什么这么说呢，因为类组件生命周期 &lt;code&gt;componentDidMount&lt;/code&gt;写同样的逻辑，然而并不会出现这种现象。那么为什么&lt;code&gt;useEffect&lt;/code&gt;会造成这种情况，我们只能顺藤摸瓜找到 &lt;code&gt;useEffect&lt;/code&gt; 的 &lt;code&gt;callback&lt;/code&gt;执行时机说起。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;useEffect&lt;/code&gt; &lt;code&gt;，useLayoutEffect&lt;/code&gt; , &lt;code&gt;componentDidMount&lt;/code&gt;执行时机都是在 &lt;code&gt;commit&lt;/code&gt;阶段执行。我们知道 React 有一个 &lt;code&gt;effectList&lt;/code&gt;存放不同&lt;code&gt;effect&lt;/code&gt;。因为 &lt;code&gt;React&lt;/code&gt; 对不同的 &lt;code&gt;effect&lt;/code&gt; 执行逻辑和时机不同。我们看一下&lt;code&gt;useEffect&lt;/code&gt;被定义的时候，定义成了什么样类型的 &lt;code&gt;effect&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;react-reconciler/src/ReactFiberHooks.js&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;mountEffect&lt;/span&gt;(&lt;span&gt;create, deps&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; mountEffectImpl(&lt;br/&gt;    UpdateEffect | PassiveEffect, &lt;span&gt;// PassiveEffect &lt;/span&gt;&lt;br/&gt;    HookPassive,&lt;br/&gt;    create,&lt;br/&gt;    deps,&lt;br/&gt;  );&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个函数的信息如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;useEffect&lt;/code&gt; 被赋予 &lt;code&gt;PassiveEffect&lt;/code&gt;类型的 &lt;code&gt;effect&lt;/code&gt; 。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;小明改原生dom位置的函数，就是 &lt;code&gt;create&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么 &lt;code&gt;create&lt;/code&gt;函数什么时候执行的，React又是怎么处理&lt;code&gt;PassiveEffect&lt;/code&gt;的呢，这是破案的关键。记下来我们看一 下React 怎么处理&lt;code&gt;PassiveEffect&lt;/code&gt;。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;react-reconciler/src/ReactFiberCommitWork.js&lt;/p&gt;&lt;/blockquote&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;commitBeforeMutationEffects&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;while&lt;/span&gt; (nextEffect !== &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; ((effectTag &amp;amp; Passive) !== NoEffect) {&lt;br/&gt;      &lt;span&gt;if&lt;/span&gt; (!rootDoesHavePassiveEffects) {&lt;br/&gt;        rootDoesHavePassiveEffects = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;/*  异步调度 - PassiveEffect */&lt;/span&gt;&lt;br/&gt;        scheduleCallback(NormalPriority, () =&amp;gt; {&lt;br/&gt;          flushPassiveEffects();&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        });&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;    nextEffect = nextEffect.nextEffect;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;commitBeforeMutationEffects&lt;/code&gt; 函数中，会异步调度 &lt;code&gt;flushPassiveEffects&lt;/code&gt;方法，&lt;code&gt;flushPassiveEffects&lt;/code&gt;方法中，对于React hooks 会执行 &lt;code&gt;commitPassiveHookEffects&lt;/code&gt;，然后会执行 &lt;code&gt;commitHookEffectListMount&lt;/code&gt; 。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;commitHookEffectListMount&lt;/span&gt;(&lt;span/&gt;)&lt;/span&gt;{&lt;br/&gt;     &lt;span&gt;if&lt;/span&gt; (lastEffect !== &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;          effect.destroy = create(); &lt;span&gt;/* 执行useEffect中饿 */&lt;/span&gt;&lt;br/&gt;     }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 &lt;code&gt;commitHookEffectListMount&lt;/code&gt;中，&lt;code&gt;create&lt;/code&gt;函数会被调用。我们给&lt;code&gt;dom&lt;/code&gt;元素加的位置就会生效。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了，异步调度做了些什么呢？React的异步调度，为了防止一些任务执行耽误了浏览器绘制，而造成卡帧现象，react 对于一些优先级不高的任务，采用异步调度来处理，也就是让浏览器才空闲的时间来执行这些异步任务，异步任务执行在不同平台，不同浏览器上实现方式不同，这里先姑且认为效果和&lt;code&gt;setTimeout&lt;/code&gt;一样。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;雨过天晴&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上述我们发现 &lt;code&gt;useEffect&lt;/code&gt; 的第一个参数 &lt;code&gt;create&lt;/code&gt;，采用的异步调用的方式，那么闪现就很好理解了，&lt;strong&gt;在点击按钮组件第一次渲染过程中，首先执行函数组件&lt;code&gt;render&lt;/code&gt;，然后&lt;code&gt;commit&lt;/code&gt;替换真实dom节点,然后浏览器绘制完毕。此时浏览器已经绘制了一次，然后浏览器有空余时间执行异步任务，所以执行了&lt;code&gt;create&lt;/code&gt;，修改了元素的位置信息，因为上一次元素已经绘制，此时又修改了一个位置，所以感到闪现的效果，此案已破。&lt;/strong&gt;，&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们怎么样解决闪现的现象呢，那就是 &lt;code&gt;React.useLayoutEffect&lt;/code&gt; ，&lt;code&gt;useLayoutEffect&lt;/code&gt;的 &lt;code&gt;create&lt;/code&gt;是同步执行的，所以浏览器绘制一次，直接更新了最新的位置。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  React.useLayoutEffect(&lt;span&gt;&lt;span&gt;()&lt;/span&gt;=&amp;gt;&lt;/span&gt;{&lt;br/&gt;      card.current.style.left = offset&lt;br/&gt;  },[])&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结  &lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;本节可我们学到了什么？&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文以破案的角度，从原理角度讲解了 &lt;code&gt;React&lt;/code&gt; 一些意想不到的现象，透过这些现象，我们学习了一些 React 内在的东西，我对如上案例总结，&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;案件一-对一些组件渲染和组件错误时机声明的理解&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;案件二-实际事件池概念的补充。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;案件三-是对一些组件库引入多个版本 &lt;code&gt;React&lt;/code&gt; 的思考和解决方案。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;案件四-要注意给 &lt;code&gt;memo&lt;/code&gt; / &lt;code&gt;PureComponent&lt;/code&gt; 绑定事件，以及如何处理 &lt;code&gt;PureComponent&lt;/code&gt; 逻辑，&lt;code&gt;shallowEqual&lt;/code&gt;的原理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;案件五-实际是对&lt;code&gt;fiber&lt;/code&gt;双缓存树的讲解。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;案件六-是对 &lt;code&gt;useEffect create&lt;/code&gt; 执行时机的讲解。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>febcd97027d114eeb4dfd3fd0edb9aee</guid>
<title>Go sync.Pool 浅析</title>
<link>https://toutiao.io/k/pwz9rfd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;hi, 大家好，我是 haohongfan。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Pool 应该是 Go 里面明星级别的数据结构，有很多优秀的文章都在介绍这个结构，本篇文章简单剖析下 sync.Pool。不过说实话 sync.Pool 并不是我们日常开发中使用频率很高的的并发原语。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽管用的频率很低，但是不可否认的是 sync.Pool 确实是 Go 的杀手锏，合理使用 sync.Pool 会让我们的程序性能飙升。本篇文章会从使用方式，源码剖析，运用场景等方面，让你对 sync.Pool 有一个清晰的认知。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用方式&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Pool 使用很简单，但是想用对却很麻烦，因为你有可能看到网上一堆错误的示例，各位同学在搜索 sync.Pool 的使用例子时，要特别注意。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Pool 是一个内存池。通常内存池是用来防止内存泄露的（例如C/C++)。sync.Pool 这个内存池却不是干这个的，带 GC 功能的语言都存在垃圾回收 STW 问题，需要回收的内存块越多，STW 持续时间就越长。如果能让 new 出来的变量，一直不被回收，得到重复利用，是不是就减轻了 GC 的压力。&lt;/p&gt;&lt;p&gt;正确的使用示例（下面的demo选自gin）&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;func (engine *Engine) ServeHTTP(w http.ResponseWriter, req *http.Request)&lt;/span&gt; {&lt;br/&gt;&lt;span&gt;    c := engine.pool.Get().(*Context)&lt;br/&gt;    c.writermem.reset(w)&lt;br/&gt;    c.Request = req&lt;br/&gt;    c.reset()&lt;br/&gt;&lt;br/&gt;    engine.handleHTTPRequest(c)&lt;br/&gt;&lt;br/&gt;    engine.pool.Put(c)&lt;br/&gt;&lt;/span&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一定要注意的是：是先 Get 获取内存空间，基于这个内存做相关的处理，然后再将这个内存还回（Put）到 sync.Pool。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Pool 结构&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9594813614262561&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/picLDrXZzlobSg2E3icVLJRibPFrYD9ib2Yw2tia1ibmh3uncc8BNUjUMwibcibPIB6aiadD6qNnicgp2XmdZxaaQ8Mo2a2w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1234&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;sync.Pool 全景图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;源码图解&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9374262101534829&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/picLDrXZzlobSg2E3icVLJRibPFrYD9ib2YwZlMxIYhfR6LJjfA46S2B3fScFvGZB5icpulDpPr8iaicSjibKIxwiaib4Dlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1694&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Pool.Get&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7169811320754716&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/picLDrXZzlobSg2E3icVLJRibPFrYD9ib2YwibarZj8RGvpqCv3Ayx5vuu2JssAyPUSXJQibNicpkVjS3tLkbqvbUiaWXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1696&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Pool.Put&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单点可以总结成下面的流程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3131768953068592&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/picLDrXZzlobSg2E3icVLJRibPFrYD9ib2Yw6BXv3BOjcfSBLysfCdtBO9r6K0MGgS7sHXVMdfur1TbfiauvsgZ4sibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2216&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Pool.Get 流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4831804281345566&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/picLDrXZzlobSg2E3icVLJRibPFrYD9ib2Ywz8NQU7nn3wZxBAibsJRwMQ1b4waLqOaBliaf7GtVqIn2nJPyrR9zvJpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1308&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Pool.Put流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23261117445838084&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/picLDrXZzlobSg2E3icVLJRibPFrYD9ib2YwNPHyvpGjSyKFiar4mibibU3XrOm3VZC8nW2lfpujnEnaNUuqQiaibec42uw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1754&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Pool GC 流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Sync.Pool 梳理&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Pool 的内容会清理？清理会造成数据丢失吗？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 会在每个 GC 周期内定期清理 sync.Pool 内的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要分几个方面来说这个问题。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;已经从 sync.Pool Get 的值，在 poolClean 时虽说将 pool.local 置成了nil，Get 到的值依然是有效的，是被 GC 标记为黑色的，不会被 GC回收，当 Put 后又重新加入到 sync.Pool 中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在第一个 GC 周期内 Put 到 sync.Pool 的数值，在第二个 GC 周期没有被 Get 使用，就会被放在 local.victim 中。如果在 第三个 GC 周期仍然没有被使用就会被 GC 回收。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;runtime.GOMAXPROCS 与 pool 之间的关系？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;s := p.localSize&lt;br/&gt;l := p.local&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;uintptr&lt;/span&gt;(pid) &amp;lt; s {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; indexLocal(l, pid), pid&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; p.local == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;    allPools = &lt;span&gt;append&lt;/span&gt;(allPools, p)&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// If GOMAXPROCS changes between GCs, we re-allocate the array and lose the old one.&lt;/span&gt;&lt;br/&gt;size := runtime.GOMAXPROCS(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;local := &lt;span&gt;make&lt;/span&gt;([]poolLocal, size)&lt;br/&gt;atomic.StorePointer(&amp;amp;p.local, unsafe.Pointer(&amp;amp;local[&lt;span&gt;0&lt;/span&gt;])) &lt;span&gt;// store-release&lt;/span&gt;&lt;br/&gt;runtime_StoreReluintptr(&amp;amp;p.localSize, &lt;span&gt;uintptr&lt;/span&gt;(size))     &lt;span&gt;// store-release&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;runtime.GOMAXPROCS(0) 是获取当前最大的 p 的数量。sync.Pool 的 poolLocal 数量受 p 的数量影响，会开辟 runtime.GOMAXPROCS(0) 个 poolLocal。某些场景下我们会使用 runtime.GOMAXPROCS（N) 来改变 p 的数量，会使 sync.Pool 的 pool.poolLocal 释放重新开辟新的空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么要开辟 runtime.GOMAXPROCS 个 local？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;pool.local 是个 poolLocal 结构，这个结构体是 private + shared链表组成，在多 goroutine 的 Get/Put 下是有数据竞争的，如果只有一个 local 就需要加锁来操作。每个 p 的 local 就能减少加锁造成的数据竞争问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;New() 的作用？假如没有 New 会出现什么情况？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的 pool.Get 流程图可以看出来，从 sync.Pool 获取一个内存会尝试从当前 private，shared，其他的 p 的 shared 获取或者 victim 获取，如果实在获取不到时，才会调用 New 函数来获取。也就是 New() 函数才是真正开辟内存空间的。New() 开辟出来的的内存空间使用完毕后，调用 pool.Put 函数放入到 sync.Pool 中被重复利用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 New 函数没有被初始化会怎样呢？很明显，sync.Pool 就废掉了，因为没有了初始化内存的地方了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;先 Put，再 Get 会出现什么情况？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「一定要注意，下面这个例子的用法是错误的」&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    pool:= sync.Pool{&lt;br/&gt;        New: &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;/span&gt;{} {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; item{}&lt;br/&gt;        },&lt;br/&gt;    }&lt;br/&gt;    pool.Put(item{value:&lt;span&gt;1&lt;/span&gt;})&lt;br/&gt;    data := pool.Get()&lt;br/&gt;    fmt.Println(data)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你直接跑这个例子，能得到你想像的结果，但是在某些情况下就不是这个结果了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Pool.Get 注释里面有这么一句话：“Callers should not assume any relation between values passed to Put and the values returned by Get.”，告诉我们不能把值 Pool.Put 到 sync.Pool 中，再使用 Pool.Get 取出来，因为 sync.Pool 不是 map 或者 slice，放入的值是有可能拿不到的，sync.Pool 的数据结构就不支持做这个事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面说使用 sync.Pool 容易被错误示例误导，就是上面这个写法。为什么 Put 的值 再 Get 会出现问题？&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;情况1：sync.Pool 的 poolCleanup 函数在系统 GC 时会被调用，Put 到 sync.Pool 的值，由于有可能一直得不到利用，被在某个 GC 周期内就有可能被释放掉了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;情况2：不同的 goroutine 绑定的 p 有可能是不一样的，当前 p 对应的 goroutine 放入到 sync.Pool 的值有可能被其他的 p 对应的 goroutine 取到，导致当前 goroutine 再也取不到这个值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;情况3：使用 runtime.GOMAXPROCS（N) 来改变 p 的数量，会使 sync.Pool 的 pool.poolLocal 释放重新开辟新的空间，导致 sync.Pool 被释放掉。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;情况4：还有很多情况&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;只 Get 不 Put 会内存泄露吗？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用其他的池，如连接池，如果取连接使用后不放回连接池，就会出现连接池泄露，&lt;strong&gt;「是不是 sync.Pool 也有这个问题呢？」&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的流程图，可以看出来 Pool.Get 的时候会尝试从当前 private，shared，其他的 p 的 shared 获取或者 victim 获取，如果实在获取不到时，才会调用 New 函数来获取，New 出来的内容本身还是受系统 GC 来控制的。所以如果我们提供的 New 实现不存在内存泄露的话，那么 sync.Pool 是不会内存泄露的。当 New 出来的变量如果不再被使用，就会被系统 GC 给回收掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不 Put 回 sync.Pool，会造成 Get 的时候每次都调用的 New 来从堆栈申请空间，达不到减轻 GC 压力。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用场景&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面说到 sync.Pool 业务开发中不是一个常用结构，我们业务开发中没必要假想某块代码会有强烈的性能问题，一上来就用 sync.Pool 硬怼。sync.Pool 主要是为了解决 Go GC 压力过大问题的，所以一般情况下，当线上高并发业务出现 GC 问题需要被优化时，才需要用 sync.Pool 出场。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;使用注意点&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;sync.Pool 同样不能被复制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;好的使用习惯，从 pool.Get 出来的值进行数据的清空（reset），防止垃圾数据污染。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;本文基于的 Go 源码版本：1.16.2&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;参考链接&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;深度解密 Go 语言之 sync.Pool https://www.cnblogs.com/qcrao-2018/p/12736031.html&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;请问sync.Pool有什么缺点？&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIyMTY3NDI3Ng==&amp;amp;mid=2247483691&amp;amp;idx=1&amp;amp;sn=92aa7a03d8229f64eee183ad118a3336&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;https://mp.weixin.qq.com/s/2ZC1BWTylIZMmuQ3HwrnUg&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Go 1.13中 sync.Pool 是如何优化的? https://colobu.com/2019/10/08/how-is-sync-Pool-improved-in-Go-1-13/&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Pool 的剖析到这里基本就写完了，想跟我交流的可以在评论区留言。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Pool 完整流程图获取链接：链接: https://pan.baidu.com/s/1T5e8qCzp8JcTgARZFjGQoQ  密码: ngea 其他模块流程图，请关注公众号回复1获取。学习资料分享，关注公众号回复指令：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;回复 0，获取 《Go 面经》&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;回复 1，获取 《Go 源码流程图》&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAwMDY4ODg5MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/picLDrXZzlob0NQenCHM7wrDdQicgdcYyDWDr78gNib4SBlxN6QnF644ytlDHx8EMq4DzbLWYqsajAXWQGDRZQ00g/0?wx_fmt=png&quot; data-nickname=&quot;HHFCodeRv&quot; data-alias=&quot;hhfcodearts&quot; data-signature=&quot;资深 Go 开发, Dubbogo commiter, 分享一些开发日常&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>47d99f5cdb5f673de709cd170253acf5</guid>
<title>早期阶段的 ToB SaaS 如何做 “数据收集”</title>
<link>https://toutiao.io/k/oweu0c5</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;前言&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;早期阶段的ToB SaaS，从数据规模来讲，相对较小，所以从研发成本、服务器成本上，一切从简，采用「简单」的数据收集方案，进行用户行为数据的收集工作，从而指导业务和产品。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大数据计算一般的流程如下：&lt;img data-backh=&quot;113&quot; data-backw=&quot;558&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;113&quot; data-ratio=&quot;0.20316301703163017&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Jq6sJhMhoXX5aPIH6NyExGowtPGibpzqPMAK7lGxjSodctufWHY6WQI45qfNBibGIlPavLwoXO7epHrfDObOziaiaQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;822&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中「数据收集」包含了「数据采集」「数据加工」「数据存储」三个步骤，通过这些步骤将用户的行为和环境信息转化为结构化数据，从而沉淀为数据资产，为产品设计、运营分析、业务决策提供重要的数据支持。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;事件模型&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记录用户行为，首先要考虑的就是如何结构化，即事件模型&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;WHO：用户ID、设备指纹、学校ID ......&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;WHEN：事件发生时间、时间上报时间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;WHERE：设备信息、网络环境、业务环境 ......&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;WHAT：事件标识、场景标识、事件参数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;270&quot; data-backw=&quot;558&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;270&quot; data-ratio=&quot;0.4830508474576271&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Jq6sJhMhoXX5aPIH6NyExGowtPGibpzqPLDAdCoCAwwj0hJH2djRyNy7t2bzEkOFT3OiatmG1ZytEibqAG9BEyzwg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;708&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;埋点SDK&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了简化业务同学开发埋点时的工作量，并对埋点日志进行一些必要的限制，需要统一的埋点SDK，目前需要2个端的SDK：微信小程序SDK、JS SDK&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;SDK包含的功能如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;用户标识管理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;设备信息、网络环境、业务环境自动收集&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;事件上报生命周期管理（上报机制）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;兼容性处理&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;......&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;数据存储&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日志经过「数据采集」「数据加工」「数据存储」这三个阶段，在每个阶段后，产生的数据，从类别、存储介质、保存时间上是有区别的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;222&quot; data-backw=&quot;558&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;222&quot; data-ratio=&quot;0.3978102189781022&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Jq6sJhMhoXX5aPIH6NyExGowtPGibpzqP0uCG6eyoZxUyGhZhypiblD8qfWNT9VwWETOxLqoiajB2aiaxQ0Tn8IaDw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;822&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;数据收集架构设计&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-backh=&quot;272&quot; data-backw=&quot;558&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;272&quot; data-ratio=&quot;0.48834853090172237&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Jq6sJhMhoXX5aPIH6NyExGowtPGibpzqPOlOoJwaBSCB2icE03SI4Xel4k2taM7fjNuu4LXYiaWtJYGbp8IAK2suA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;987&quot;/&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;各种端的SDK监控用户行为，通过Http请求上报给日志收集服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;日志收集服务，把原始数据写到硬盘，并进行归档操作&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过Filebeat + Logstash转发到Kafka内（主要是为了在高并发下，利用队列模式降低IO）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;日志ETL服务，针对原始数据进行分析和相关数据补全，存储到MySQL，形成中间层数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;日志分析服务，针对业务，进行数据分析，形成分析结果数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;WEB UI针对分析结果数据进行相应的报表展现&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;未来阶段&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;数据量&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于目前SaaS平台的数据量不大，数据的ETL、存储等等，采取了经济、简单方案，在后面数据量升级后，ETL可以采用Hive、Spark、Flink等等大数据解决方案，存储可以采用分布式大数据存储方案，HDFS等等。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;大数据测试&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当埋点较多、端类型比较多时，为了便于QA进行埋点测试，需要针对QA的测试方案，进行自动化大数据测试流程的设计和实现，保证埋点数据的准确。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ea3f268948959a63439b5f2007fb1dbb</guid>
<title>[推荐] 36 张图详解网络基础知识</title>
<link>https://toutiao.io/k/bjis3t4</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;figure&gt;&lt;figcaption&gt;前言&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;网络协议&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;我们用手机连接上网的时候，会用到许多网络协议。从手机连接 WiFi 开始，使用的是 &lt;strong&gt;802.11&lt;/strong&gt; （即 WLAN ）协议，通过 WLAN 接入网络；手机自动获取网络配置，使用的是 &lt;strong&gt;DHCP&lt;/strong&gt; 协议，获取配置后手机才能正常通信。这时手机已经连入&lt;strong&gt;局域网&lt;/strong&gt;，可以访问局域网内的设备和资源，但还不能使用互联网应用，例如：微信、抖音等。想要访问&lt;strong&gt;互联网&lt;/strong&gt;，还需要在手机的上联网络设备上实现相关协议，即在无线路由器上配置 &lt;strong&gt;NAT&lt;/strong&gt;、 &lt;strong&gt;PPPOE&lt;/strong&gt; 等功能，再通过运营商提供的互联网线路把局域网接入到互联网中，手机就可以上网玩微信、刷抖音了。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.26864244741873805&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhAibTZMiajUGdG2HCNXoBJPMz4eJ0vkpPLBr0AkBco5tRpQRyuQRiad7Wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1046&quot; title=&quot;网络协议示意图&quot;/&gt;&lt;figcaption&gt;网络协议示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;局域网&lt;/strong&gt; ：小范围内的私有网络，一个家庭内的网络、一个公司内的网络、一个校园内的网络都属于局域网。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;广域网&lt;/strong&gt;：把不同地域的局域网互相连接起来的网络。运营商搭建广域网实现跨区域的网络互连。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;互联网&lt;/strong&gt;：互联全世界的网络。互联网是一个开放、互联的网络，不属于任何个人和任何机构，接入互联网后可以和互联网的任何一台主机进行通信。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;简单来说，就是手机、无线路由器等设备通过多种&lt;strong&gt;网络协议&lt;/strong&gt;实现通信。网络协议就是为了通信各方能够互相交流而定义的标准或规则，设备只要遵循相同的网络协议就能够实现通信。那网络协议又是谁规定的呢？ISO 制定了一个国际标准 &lt;strong&gt;OSI&lt;/strong&gt; ， 其中的 &lt;strong&gt;OSI 参考模型&lt;/strong&gt;常被用于网络协议的制定。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;2.3259668508287294&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibh6uQJNdNmR86rKBMFTbTXWhE2TZgktqBJo5zPKad8UuWR7QRnRxQw4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;181&quot; title=&quot;OSI 参考模型图&quot;/&gt;&lt;figcaption&gt;OSI 参考模型图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;OSI 参考模型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;OSI 参考模型将网络协议提供的服务分成 &lt;strong&gt;7&lt;/strong&gt; 层，并定义每一层的&lt;strong&gt;服务&lt;/strong&gt;内容，实现每一层服务的是&lt;strong&gt;协议&lt;/strong&gt;，协议的具体内容是&lt;strong&gt;规则&lt;/strong&gt;。上下层之间通过&lt;strong&gt;接口&lt;/strong&gt;进行交互，同一层之间通过&lt;strong&gt;协议&lt;/strong&gt;进行交互。OSI 参考模型只对各层的服务做了粗略的界定，并没有对协议进行详细的定义，但是许多协议都对应了 7 个分层的某一层。所以要了解网络，首先要了解 OSI 参考模型。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.2626970227670753&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibh4CH4VEic76p0gs0OxOvdqHF2XhTvC47ic65TnEFnqHicFZeP10HjJoZpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;571&quot; title=&quot;OSI 参考模型分层功能&quot;/&gt;&lt;figcaption&gt;OSI 参考模型分层功能&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;应用层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;OSI参考模型的第 &lt;strong&gt;7&lt;/strong&gt; 层（最高层）。应用程序和网络之间的接口，直接向用户提供服务。应用层协议有电子邮件、远程登录等协议。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8047808764940239&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhBHM0ID4PHB6gmciaiajNh6NKpj18AvyA0UpiaqzAibMOCo4Oic14QbTiavkQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;502&quot; title=&quot;应用层示例图&quot;/&gt;&lt;figcaption&gt;应用层示例图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;表示层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;OSI参考模型的第 &lt;strong&gt;6&lt;/strong&gt; 层。负责数据格式的互相转换，如编码、数据格式转换和加密解密等。保证一个系统应用层发出的信息可被另一系统的应用层读出。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3237518910741301&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhbjeLdvrTPSibKXHcvPYNQ7vIxPm4xa6gXTT30UPibGOmsveBl0Ow9k1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;661&quot; title=&quot;表示层示例图&quot;/&gt;&lt;figcaption&gt;表示层示例图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;会话层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;OSI参考模型的第 &lt;strong&gt;5&lt;/strong&gt; 层。主要是管理和协调不同主机上各种进程之间的通信（对话），即负责建立、管理和终止应用程序之间的会话。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.1760797342192691&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhU62dNRZzibVgXiaUyJeWUNp9tQRQlKtIuGdCPhCaEUsIRtR8fAJv6ZicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;602&quot; title=&quot;会话层示例图&quot;/&gt;&lt;figcaption&gt;会话层示例图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;传输层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;OSI参考模型的第 &lt;strong&gt;4&lt;/strong&gt; 层。为上层协议提供通信主机间的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。只在通信主机上处理，不需要在路由器上处理。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2591362126245847&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhtPmon7ib0qicetLnGetZUBicwASfTuwDMrfhwulx8U1P3rwdicP8BAAmWQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;602&quot; title=&quot;传输层示例图&quot;/&gt;&lt;figcaption&gt;传输层示例图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;网络层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;OSI参考模型的第 &lt;strong&gt;3&lt;/strong&gt; 层。在网络上将数据传输到目的地址，主要负责寻址和路由选择。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3687707641196013&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhMpuqNicFkyCSoRZplxmDWYQdkWDOqKUFzZx7y7tcDuJCzAoib3FFljpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;602&quot; title=&quot;网络层示例图&quot;/&gt;&lt;figcaption&gt;网络层示例图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;数据链路层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;OSI参考模型的第 2 层。负责物理层面上两个互连主机间的通信传输，将由 0 、 1 组成的比特流划分成数据帧传输给对端，即数据帧的生成与接收。通信传输实际上是通过物理的传输介质实现的。数据链路层的作用就是在这些通过传输介质互连的设备之间进行数据处理。&lt;/p&gt;&lt;p&gt;网络层与数据链路层都是基于目标地址将数据发送给接收端的，但是网络层负责将整个数据发送给最终目标地址， 而数据链路层则只负责发送一个分段内的数据。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.18635607321131448&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibh0FPR0aiaAtEK7jwHpiaCe2BWYbiaKBs1HibaCQRYSMicW9CqhxMBfxhcDMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;601&quot; title=&quot;数据链路层示例图&quot;/&gt;&lt;figcaption&gt;数据链路层示例图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;物理层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;OSI参考模型的第 &lt;strong&gt;1&lt;/strong&gt; 层（最底层）。负责逻辑信号（比特流）与物理信号（电信号、光信号）之间的互相转换，通过传输介质为数据链路层提供物理连接。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.23688663282571912&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhReb6DfDyDYXURlSpp35nqeVm1sPv3L15Vk1DGaqvna08QsoVqRIEPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;591&quot; title=&quot;物理层示例图&quot;/&gt;&lt;figcaption&gt;物理层示例图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;&lt;span&gt;TCP/IP 参考模型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;p&gt;由于 OSI 参考模型把服务划得过于琐碎，先定义参考模型再定义协议，有点理想化。TCP/IP 模型则正好相反，通过已有的协议归纳总结出来的模型，成为业界的实际网络协议标准。&lt;/p&gt;&lt;p&gt;TCP/IP 是有由 IETF 建议、推进其标准化的一种协议，是 IP 、 TCP 、 HTTP 等协议的集合。TCP/IP 是为使用互联网而开发制定的协议族，所以互联网的协议就是 TCP/IP 。&lt;/p&gt;&lt;p&gt;先介绍下 TCP/IP 与 OSI 分层之间的对应关系，以及 TCP/IP 每层的主要协议。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.554006968641115&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhCdAvJnMQiaiahhib7JLKzJNfiafoTy8ia11vgseBQ5led0hicgic7iauq7w71w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;861&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;网络接入层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;TCP/IP 是以 OSI 参考模型的物理层和数据链路层的功能是透明的为前提制定的，并未对这两层进行定义，所以可以把物理层和数据链路层合并称为&lt;strong&gt;网络接入层&lt;/strong&gt;。网络接入层是对网络介质的管理，定义如何使用网络来传送数据。但是在通信过程中这两层起到的作用不一样，所以也有把物理层和数据链路层分别称为&lt;strong&gt;硬件&lt;/strong&gt;、&lt;strong&gt;网络接口层&lt;/strong&gt;。TCP/IP 分为四层或者五层都可以，只要能理解其中的原理即可。&lt;/p&gt;&lt;p&gt;设备之间通过物理的传输介质互连， 而互连的设备之间使用 &lt;strong&gt;MAC 地址&lt;/strong&gt;实现数据传输。采用 MAC 地址，目的是为了识别连接到同一个传输介质上的设备。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;网络层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;相当于 OSI 模型中的第 3 层网络层，使用 &lt;strong&gt;IP 协议&lt;/strong&gt;。IP 协议基于 &lt;strong&gt;IP 地址&lt;/strong&gt;转发分包数据，作用是将数据包从源地址发送到目的地址。&lt;/p&gt;&lt;p&gt;TCP/IP 分层中的网络层与传输层的功能通常由&lt;strong&gt;操作系统&lt;/strong&gt;提供。 路由器就是通过网络层实现&lt;strong&gt;转发数据包&lt;/strong&gt;的功能。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.31893687707641194&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhgmia5jI0BhocAEYoZp4Yy0fkguHEsFOAUcJRiaw0wjtfq6z3r17tXyxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;602&quot; title=&quot;网络层&quot;/&gt;&lt;figcaption&gt;网络层&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;网络传输中，每个节点会根据数据的地址信息，来判断该报文应该由哪个网卡发送出去。各个地址会参考一个发出接口列表， MAC 寻址中所参考的这张表叫做 &lt;strong&gt;MAC 地址转发表&lt;/strong&gt;，而 IP 寻址中所参考的叫做&lt;strong&gt;路由控制表&lt;/strong&gt;。MAC 地址转发表根据自学自动生成。路由控制表则根据路由协议自动生成。MAC 地址转发表中所记录的是实际的 MAC 地址本身，而路由表中记录的 IP 地址则是集中了之后的网络号（即网络号与子网掩码）。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;IP&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;IP 是跨越网络传送数据包，使用 IP 地址作为主机的标识，使整个互联网都能收到数据的协议。IP 协议独立于底层介质，实现从源到目的的数据转发。IP 协议不具有重发机制，属于非可靠性传输协议。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;ICMP&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;用于在 IP 主机、路由器之间传递控制消息，用来诊断网络的健康状况。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;ARP&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从数据包的 IP 地址中解析出 MAC 地址的一种协议。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;传输层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;相当于 OSI 模型中的第 4 层传输层，主要功能就是让应用程序之间互相通信，通过&lt;strong&gt;端口号&lt;/strong&gt;识别应用程序，使用的协议有面向连接的 &lt;strong&gt;TCP&lt;/strong&gt; 协议和面向无连接的 &lt;strong&gt;UDP&lt;/strong&gt; 协议。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;面向连接&lt;/strong&gt;是在发送数据之前， 在收发主机之间连接一条逻辑通信链路。好比平常打电话，输入完对方电话号码拨出之后，只有对方接通电话才能真正通话，通话结束后将电话机扣上就如同切断电源。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;面向无连接&lt;/strong&gt;不要求建立和断开连接。发送端可于任何时候自由发送数据。如同去寄信，不需要确认收件人信息是否真实存在，也不需要确认收件人是否能收到信件，只要有个寄件地址就可以寄信了。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3768472906403941&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibh1FDAMrFcLpUrjPv5QwO1NIxdTdsaSxMYQRVd6SGx37kmLAjwlN8uTg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;812&quot; title=&quot;传输层&quot;/&gt;&lt;figcaption&gt;传输层&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;应用层&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;相当于 OSI 模型中的第 5 - 7 层的集合，不仅要实现 OSI 模型应用层的功能，还要实现会话层和表示层的功能。HTTP 、 POP3 、 TELNET 、 SSH 、 FTP 、 SNMP都是应用层协议。&lt;/p&gt;&lt;p&gt;TCP/IP 应用的架构绝大多数属于&lt;strong&gt;客户端/服务端&lt;/strong&gt;模型。提供服务的程序叫服务端， 接受服务的程序叫客户端。客户端可以随时发送请求给服务端。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3768472906403941&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhyKGe6YR44yJCG4CDH00V7a4gPZtxy7gPVpKAFEOFBQCDPiaRJstBTwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;812&quot; title=&quot;应用层&quot;/&gt;&lt;figcaption&gt;应用层&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;HTTP&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;是 WWW 浏览器和服务器之间的应用层通信协议，所传输数据的主要格式是 HTML 。HTTP 定义高级命令或者方法供浏览器用来与Web服务器通信。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;POP3&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;简单邮件传输协议，邮件客户端和邮件服务器使用。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;TELNET 和 SSH&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;远程终端协议，用于远程管理网络设备。TELNET 是明文传输， SSH 是加密传输。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;SNMP&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;简单网络管理协议，用于网管软件进行网络设备的监控和管理。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;封装与解封装&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;通常，为协议提供的信息为包&lt;strong&gt;头部&lt;/strong&gt;，所要发送的内容为&lt;strong&gt;数据&lt;/strong&gt;。每个分层中，都会对所发送的数据附加一个头部，在这个头部中包含了该层必要的信息， 如发送的目标地址以及协议相关信息。在下一层的角度看，从上一分层收到的包全部都被认为是本层的数据。&lt;/p&gt;&lt;p&gt;数据发送前，按照参考模型从上到下，在数据经过每一层时，添加协议报文头部信息，这个过程叫&lt;strong&gt;封装&lt;/strong&gt;。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2861378799110452&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhXtASosjXf7a0LethmCGpQMX5nriaOPCWyIvHMYiaHPECaUpAmaLicnggg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1349&quot; title=&quot;封装&quot;/&gt;&lt;figcaption&gt;封装&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;数据接收后，按照参考模型从下到上，在数据经过每一层时，去掉协议头部信息，这个过程叫&lt;strong&gt;解封装&lt;/strong&gt;。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2861378799110452&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhkVS7NZXRM4IYDAYFPvM2rKT9sNLfcg7Q9PLGvibevEjL5raXNibUicLPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1349&quot; title=&quot;解封装&quot;/&gt;&lt;figcaption&gt;解封装&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;经过传输层协议封装后的数据称为&lt;strong&gt;段&lt;/strong&gt;，经过网络层协议封装后的数据称为&lt;strong&gt;包&lt;/strong&gt;，经过数据链路层协议封装后的数据称为&lt;strong&gt;帧&lt;/strong&gt;，物理层传输的数据为&lt;strong&gt;比特&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;TCP/IP 通信中使用 MAC 地址、 IP 地址、端口号等信息作为&lt;strong&gt;地址标识&lt;/strong&gt;。甚至在应用层中，可以将电子邮件地址作为网络通信的地址。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;实际数据传输举例&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;实际生活中，互联网是使用的 TCP/IP 协议进行网络连接的。我们以&lt;strong&gt;访问网站&lt;/strong&gt;为例，看看网络是如何进行通信的。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4305750350631136&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibh4ortuHsDtNOO0wck96WUJX55pIDLJPhZAcFtbKprtVawgklvThCkcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1426&quot; title=&quot;数据传输举例&quot;/&gt;&lt;figcaption&gt;数据传输举例&lt;/figcaption&gt;&lt;/figure&gt;&lt;h5&gt;&lt;span&gt;发送数据包&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;访问 HTTP 网站页面时，打开浏览器，输入网址，敲下回车键就开始进行 TCP/IP 通信了。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;应用程序处理&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7429305912596401&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhLwc6n2P5M6fwW9obU0DWdXeoich6EHxLtohob84qjj4LE0NBxCMBLOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;778&quot; title=&quot;应用层&quot;/&gt;&lt;figcaption&gt;应用层&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;首先，应用程序中会进行 HTML 格式&lt;strong&gt;编码&lt;/strong&gt;处理，相当于 OSI 的表示层功能。编码转化后，不一定会马上发送出去，相当于会话层的功能。在请求发送的那一刻，建立 TCP 连接，然后在 TCP 连接上发送数据。接下来就是将数据发送给下一层的 TCP 进行处理。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;TCP 模块处理&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7429305912596401&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhOTXiaE6HEHCITq3X6icFDsdwUAv9UTrUichKVibSEBUtzt1IseM7GKlQww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;778&quot; title=&quot;传输层&quot;/&gt;&lt;figcaption&gt;传输层&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;TCP 会将应用层发来的数据顺利的发送至目的地。实现可靠传输的功能，需要给数据封装 TCP 头部信息。TCP 头部信息包括源端口号和目的端口号（识别主机上应用）、序号（确认哪部分是数据）以及校验和（判断数据是否被损坏）。随后&lt;strong&gt;封装&lt;/strong&gt;了 TCP 头部信息的段再发送给 IP 。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;IP  模块处理&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7429305912596401&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhKsAaleKcoqDgOHVfmQrPNmG0JypanWX6L4T9fUT1GrxxtCA2GRu95w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;778&quot; title=&quot;网络层&quot;/&gt;&lt;figcaption&gt;网络层&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;IP 将 TCP 传过来的数据段当做自己的数据，并封装 IP 头部信息。IP 头部信息中包含目的 IP 地址和源 IP 地址，以及上层协议类型信息。&lt;/p&gt;&lt;p&gt;IP 包生成后，根据主机&lt;strong&gt;路由表&lt;/strong&gt;进行数据发送。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;网络接口处理&lt;/strong&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7419768934531451&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibh7fzBhQp6RyUz6tOPy9xomnB1jd4aThwQ5HS4N3hWn7jI3ic4TKXYYfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;779&quot; title=&quot;物理层&quot;/&gt;&lt;figcaption&gt;物理层&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;网络接口对传过来的 IP 包封装上以太网头部信息并进行发送处理。以太网头部信息包含目的 MAC 地址、源 MAC 地址，以及上层协议类型信息。然后将以太网数据&lt;strong&gt;帧&lt;/strong&gt;通过物理层传输给接收端。发送处理中的 FCS 由硬件计算， 添加到包的最后。设置 FCS 的目的是为了判断数据包是否由于噪声而被破坏。&lt;/p&gt;&lt;h5&gt;&lt;span&gt;接收数据包&lt;/span&gt;&lt;/h5&gt;&lt;p&gt;包的接收流程是发送流程的&lt;strong&gt;反向&lt;/strong&gt;过程。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;网络接口处理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;收到以太网包后，首先查看头部信息的目的 MAC 地址是否是发给自己的包。如果不是发送给自己的包就丢弃。如果是发送给自己的包，查看上层协议类型是 IP 包，以太网帧&lt;strong&gt;解封装&lt;/strong&gt;成 IP 包，传给 IP 模块进行处理。如果是无法识别的协议类型，则丢弃数据。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6457326892109501&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhZwvGQn8dLX5tvDwm5IevaicQJ93IkUnmMr2UFtEaBNxDRoPuib9dol6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;621&quot; title=&quot;网口处理流程&quot;/&gt;&lt;figcaption&gt;网口处理流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;IP  模块处理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;收到 IP 包后，进行类似处理。根据头部信息的目的 IP 地址判断是否是发送给自己包，如果是发送给自己的包，则查看上一层的协议类型。上一层协议是 TCP ，就把 IP 包解封装发送给 TCP 协议处理。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6457326892109501&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhQcwR7udwGoJ6pUWwGZ4nDcwMzkesJgpz6XC7l5R5FEsdqMrdpcf69Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;621&quot; title=&quot;IP模块处理流程&quot;/&gt;&lt;figcaption&gt;IP模块处理流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;假如有路由器，且接收端不是自己的地址，那么根据路由控制表转发数据。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3843594009983361&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhsBdTzwAicib1BGuUPk7DyKfWKeWIo1b5zdPibjkjZ55xWYg9iblkyfSjaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;601&quot; title=&quot;路由器处理流程&quot;/&gt;&lt;figcaption&gt;路由器处理流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;TCP 模块处理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;收到 TCP 段后，首先查看校验和，判断数据是否被破坏。然后检查是否按照序号接收数据。最后检查端口号，确定具体的应用程序。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.16542473919523099&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhUqvcpibJSeLPS8nqFxDAHwKibMlVvcRfKHhqnNSd7x8ZSHGQbZIiaH0vQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;671&quot; title=&quot;TCP模块处理流程&quot;/&gt;&lt;figcaption&gt;TCP模块处理流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;数据接收完毕后，发送一个 “ &lt;strong&gt;确认回执&lt;/strong&gt; ” 给发送端。如果这个回执信息未能达到发送端，那么发送端会认为接收端没有接收到数据而一直反复发送。&lt;/p&gt;&lt;p&gt;数据被完整接收后，会把 TCP 段解封装发送给由端口号识别的应用程序。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;应用程序处理&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;应用程序收到数据后，通过解析数据内容获知发送端请求的网页内容，然后按照 HTTP 协议进行后续数据交互。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;网络构成&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7861507128309573&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhn9MmOLTT0pav1aX6MZ4UzlR1K7wNlgjPemvau0UbHprOViaxketCqyg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;982&quot; title=&quot;网络构成要素&quot;/&gt;&lt;figcaption&gt;网络构成要素&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;搭建一套网络涉及各种线缆和网络设备。下面介绍一些常见的&lt;strong&gt;硬件设备&lt;/strong&gt;。硬件设备所说的层数是参照的 OSI 参考模型，而不是 TCP/IP 模型。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.446693657219973&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhypAKLNMIx5dndIiaIQokN7MbxEialnmh19eqSyQMv6n5x9xmy5r0CY1A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;741&quot; title=&quot;主要设备及作用表&quot;/&gt;&lt;figcaption&gt;主要设备及作用表&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;通信介质与数据链路&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;设备之间通过线缆进行连接。有线线缆有双绞线、光纤、串口线等。根据数据链路不同选择对应的线缆。传输介质还可以被分为电波、微波等不同类型的电磁波。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;传输速率&lt;/strong&gt;：单位为 &lt;code&gt;bps&lt;/code&gt; ，是指单位时间内传输的数据量有多少。又称作带宽，带宽越大网络传输能力就越强。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;吞吐量&lt;/strong&gt;：单位为 &lt;code&gt;bps&lt;/code&gt; ，主机之间实际的传输速率。吞吐量这个词不仅衡量带宽， 同时也衡量主机的 CPU 处理能力、 网络的拥堵程度、 报文中数据字段的占有份额等信息。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;网卡&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;任一主机连接网络时，必须要使用网卡。可以是有线网卡，用来连接有线网络，也可以是无线网卡连接 WiFi 网络。每块网卡都有一个唯一的 &lt;strong&gt;MAC 地址&lt;/strong&gt;，也叫做硬件地址或物理地址。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.14342629482071714&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhsKiajcpoicn0WnkaLnktxBeUb0wLJeqvzwWicElHX0MTomfIrFV2EaXGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;502&quot; title=&quot;网卡&quot;/&gt;&lt;figcaption&gt;网卡&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4&gt;&lt;span&gt;二层交换机&lt;/span&gt;&lt;/h4&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4560530679933665&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhGY3ImSAnriaBViaXTicFJmUrxOdGmZFnIFDtVpX5dYZkud9vXvgSaUAlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;603&quot; title=&quot;二层交换机&quot;/&gt;&lt;figcaption&gt;二层交换机&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;二层交换机位于 OSI 模型的第 2 层（数据链路层）。它能够识别数据链路层中的数据帧，并将帧转发给相连的另一个数据链路。&lt;/p&gt;&lt;p&gt;数据帧中有一个数据位叫做 &lt;strong&gt;FCS&lt;/strong&gt; ，用以校验数据是否正确送达目的地。二层交换机通过检查这个值，将损坏的数据丢弃。&lt;/p&gt;&lt;p&gt;二层交换机根据 MAC 地址&lt;strong&gt;自学机制&lt;/strong&gt;判断是否需要转发数据帧。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;路由器 / 三层交换机&lt;/span&gt;&lt;/h4&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2341897233201581&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhOsmuMplIHm41ne78tjlVT5Vk5rNuxacibkiazzZiazMBbySy4Wa6Hd4Xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1012&quot; title=&quot;路由器&quot;/&gt;&lt;figcaption&gt;路由器&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;路由器是在 OSI 模型的第 3 层（网络层）上连接两个网络、并对报文进行转发的设备。二层交换机是根据 MAC 地址进行处理，而路由器 / 三层交换机则是根据 &lt;strong&gt;IP 地址&lt;/strong&gt;进行处理的。因此 TCP/IP 中网络层的地址就成为了 IP 地址。&lt;/p&gt;&lt;p&gt;路由器可以连接不同的数据链路。比如连接两个以太网，或者连接一个以太网与一个无线网。家庭里面常见的无线路由器也是路由器的一种。&lt;/p&gt;&lt;h4&gt;&lt;span&gt;四至七层交换机&lt;/span&gt;&lt;/h4&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.36585365853658536&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibheJZpf1ccQlLUFiavVb4eT7L7lyeduEHgkKTcF5kic5ia77dzcJjR3jTibQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;902&quot; title=&quot;负载均衡设备&quot;/&gt;&lt;figcaption&gt;负载均衡设备&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;四至七层交换机负责处理 OSI 模型中从传输层至应用层的数据。以 TCP 等协议的传输层及其上面的应用层为基础，分析收发数据，并对其进行特定的处理。例如，视频网站的一台服务器不能满足访问需求，通过&lt;strong&gt;负载均衡设备&lt;/strong&gt;将访问分发到后台多个服务器上，就是四至七层交换机的一种。还有带宽控制、广域网加速器、防火墙等应用场景。&lt;/p&gt;&lt;h3&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h3&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4147398843930636&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibh5tkzzM4hGNboia7uWSOpSOvG85R9xwlZSwg4f7mSHL0L0FuOh0w3DzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1384&quot; title=&quot;总结&quot;/&gt;&lt;figcaption&gt;总结&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;应用层设备有电脑、手机、服务器等。应用层设备&lt;strong&gt;不转发数据&lt;/strong&gt;，它们是&lt;strong&gt;数据的源或目的&lt;/strong&gt;，拥有应用层以下的各层功能。发送数据时，从上而下的顺序，逐层对数据进行封装，再通过以太网将数据发送出去。接收数据时，从下而上的顺序，逐层对数据进行解封装，最终恢复成原始数据。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9534883720930233&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhmPxTe3pbnXCo721tiaJVibU5ltqM173MoeanBtszdUibwDxlBBLq7xibuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;602&quot; title=&quot;应用层处理流程&quot;/&gt;&lt;figcaption&gt;应用层处理流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;数据链路层设备有二层交换机、网桥等。二层网络设备&lt;strong&gt;只转发数据&lt;/strong&gt;，通过识别数据的 &lt;strong&gt;MAC 地址&lt;/strong&gt;进行转发。二层交换机接收数据后，对数据最外层封装的以太网头部信息进行查看，看到数据的目的 MAC 地址后，把数据帧从对应端口发送出去。交换机并不会对数据帧进行解封装，只要知道 MAC 地址信息就可以正确地将数据转发出去。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.3681592039800995&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibh25KFSbickc9wFSqMDO5auBdJRaK5DWCwzQRgvOv3YG0CkjKqebgNZCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;603&quot; title=&quot;数据链路层处理流程&quot;/&gt;&lt;figcaption&gt;数据链路层处理流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;网络层设备有路由器、三层交换机等。三层网络设备&lt;strong&gt;只转发数据&lt;/strong&gt;，通过识别数据的 &lt;strong&gt;IP 地址&lt;/strong&gt;进行转发。路由器接收数据后，首先查看最外层封装的以太网头部信息，当目的 MAC 地址是自己时，就会将以太网头部解封装，查看数据的 IP 地址。根据 IP 路由表做出转发决定时，路由器会把下一跳设备的 MAC 地址作为以太网头部的目的 MAC 地址，重新封装以太网头部并将数据转发出去。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5008291873963516&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhaiaoicM05qyZSlvlZfb2ibgdhyHibiaR3ZDLia13UibAzkJlLia1CzfbFhudicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;603&quot; title=&quot;网络层处理流程&quot;/&gt;&lt;figcaption&gt;网络层处理流程&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;转发数据的网络设备和应用层的数据，就像&lt;strong&gt;快递员&lt;/strong&gt;和&lt;strong&gt;包裹&lt;/strong&gt;一样。快递员根据目的地址运送包裹，不必了解包裹里的具体内容。&lt;/p&gt;&lt;p&gt;通过分层功能来区分网络设备已经不再适用，交换机集成三层路由功能就是三层交换机，无线AP集成路由器功能就是无线路由器。但是为了方便说明，通常是介绍单个设备的功能和原理。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.21212121212121213&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/NQOMbFoOWXdW6ezTsImVhB557bjdapibhmT3nzrMKm4ao3lvcr0do8j1VmDP3rC9ic757aboyF9GJ5qTNJpFnXow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;462&quot; title=&quot;无线路由器&quot;/&gt;&lt;figcaption&gt;无线路由器&lt;/figcaption&gt;&lt;/figure&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;图解TCP/IP - 竹下隆史&lt;/p&gt;&lt;p&gt;网络基础 - 田果&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>