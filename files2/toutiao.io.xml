<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>0a84402385f13817982978ace28e0e6b</guid>
<title>利用 Redsocks 解决透明代理的远程抓包问题</title>
<link>https://toutiao.io/k/xdc60me</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section class=&quot;toc-content post no-image&quot;&gt;
      &lt;h2 id=&quot;%E8%83%8C%E6%99%AF&quot;&gt;背景&lt;/h2&gt;&lt;p&gt;最近在做一些远程设备的抓包能力建设。具体来说是设备（基于 Docker 的 Redroid 云手机）在服务器上，抓包工具在本地（ Mitmproxy , Charles, Fiddler 等类似工具），希望通过某种方法将远程设备上的流量打到本地的抓包工具上，并且流量通过本地的 IP 出到公网。&lt;/p&gt;&lt;p&gt;这样做的目的主要有两个：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;可以做到抓包工具和待抓包设备的分离。既能利用上强大的第三方抓包工具，又无需本地部署待抓包的设备。毕竟如果在远程服务器上部署抓包工具，操作起来就不那么方便，甚至可能还需要自行开发管控界面；如果在本地部署待抓包设备，很可能会遇到例如芯片架构、操作系统、环境依赖、系统资源消耗等问题。&lt;/li&gt;&lt;li&gt;可以方便进行 IP 出口的调整。在调试一些不可言说的功能时，服务器上部署的设备很可能是走一些代理 IP 池，有时候这些 IP 池本身可能有点问题，导致远程设备被封。这时候如果我们能够将设备的流量导到本地的正常 IP 出公网，可能会更方便我们验证是 IP 问题还是其他的设备问题。&lt;/li&gt;&lt;/ol&gt;&lt;h2 id=&quot;%E8%AE%A1%E5%88%92&quot;&gt;计划&lt;/h2&gt;&lt;p&gt;为了打通远程设备本地抓包的这套链路，我们需要考虑如下技术点：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;远程设备需要能够安装本地抓包工具的证书。&lt;/li&gt;&lt;li&gt;远程设备的流量需要通过某种内网穿透能力打到本地的代理工具上。&lt;/li&gt;&lt;li&gt;远程设备的流量需要保证不遗漏地进行转发。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;由于我们的远程设备是有 root 权限的云手机，因此证书安装并不难。只要将本地的证书通过 openssl 命令转换成指定格式的证书文件，传到服务器上，在云手机启动时 bind 到 &lt;code&gt;/system/etc/security/cacerts/&lt;/code&gt;  目录下即可。&lt;/p&gt;&lt;p&gt;同理，由于远程设备是云手机，通过暴露 adb 的 tcpip 端口，我们可以用本地的 adb 客户端进行连接，再通过 adb reverse 就可以构建一个云手机访问本机代理端口的信道。&lt;/p&gt;&lt;p&gt;而要保证云手机的流量（这里特指 HTTP/HTTPS 流量）不遗漏的进行转发，我们就不能采用配置全局正向代理的方法（ &lt;code&gt;adb shell settings put global http_proxy xxxx&lt;/code&gt;  ），因为个别 app 可以配置强制 NO_PROXY 不走系统代理。一个简单的方法是通过云手机自带的 iptables 工具进行转发，将云手机中所有目的端口为 80/443 的流量转发到 adb reverse 命令转发过来的、映射到本地抓包工具的代理端口即可。&lt;/p&gt;&lt;p&gt;理想的架构图如下：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2022/05/---.excalidraw.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot; srcset=&quot;https://blog.mythsman.com/content/images/size/w600/2022/05/---.excalidraw.png 600w, https://blog.mythsman.com/content/images/size/w1000/2022/05/---.excalidraw.png 1000w, https://blog.mythsman.com/content/images/2022/05/---.excalidraw.png 1079w&quot; sizes=&quot;(min-width: 720px) 720px&quot;/&gt;&lt;/figure&gt;&lt;h2 id=&quot;%E9%97%AE%E9%A2%98&quot;&gt;问题&lt;/h2&gt;&lt;p&gt;架构图谁都会画，但是真正实操起来才发现有一堆坑。这套流程对 HTTP 请求的确是有用的，透明代理的工具无论是使用 Charles 还是 Mitmproxy 等中间人代理工具都能正常抓到包。但是对与 HTTPS 的流量则都出现了问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Charles 会报 &lt;code&gt;invalid first line in request&lt;/code&gt; 的错。&lt;/li&gt;&lt;li&gt;Mitmproxy 会报 &lt;code&gt;Could not resolve original destination&lt;/code&gt; 的错。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;当然，个别代理工具可能不支持解 HTTPS ，出现问题可以理解。但是各种代理工具都不能抓，那显然应当是流程上出了问题。经过实验我们发现，使用正向代理或非 HTTPS 的透明代理再加上端口转发都是能通的，唯一不能通的是 HTTPS 的透明代理模式。那么我们就需要先辨析一下这些模式的区别。&lt;/p&gt;&lt;h2 id=&quot;%E5%88%86%E6%9E%90&quot;&gt;分析&lt;/h2&gt;&lt;h3 id=&quot;%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86&quot;&gt;正向代理&lt;/h3&gt;&lt;p&gt;正向代理是由客户端主动发起，主动将流量打给一个代理服务器，由代理服务器代替请求的过程。下图主要展示正向代理过程中 IP 报文的变化：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2022/05/-------.excalidraw.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot; srcset=&quot;https://blog.mythsman.com/content/images/size/w600/2022/05/-------.excalidraw.png 600w, https://blog.mythsman.com/content/images/size/w1000/2022/05/-------.excalidraw.png 1000w, https://blog.mythsman.com/content/images/2022/05/-------.excalidraw.png 1265w&quot; sizes=&quot;(min-width: 720px) 720px&quot;/&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;Alice 代表发起请求的客户端&lt;/li&gt;&lt;li&gt;Flank 代表代理服务器（Forward Proxy）&lt;/li&gt;&lt;li&gt;Bob 代表客户端需要请求到的服务器&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86&quot;&gt;透明代理&lt;/h3&gt;&lt;p&gt;透明代理是客户端本身无感知的，由路由转发工具强行进行流量转发（Linux 下可以用 iptables ，Windows 下可以用 netsh ，Mac 下可以用 pfctl）。下图主要展示透明代理过程中 IP 报文的变化：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2022/05/------.excalidraw.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot; srcset=&quot;https://blog.mythsman.com/content/images/size/w600/2022/05/------.excalidraw.png 600w, https://blog.mythsman.com/content/images/size/w1000/2022/05/------.excalidraw.png 1000w, https://blog.mythsman.com/content/images/size/w1600/2022/05/------.excalidraw.png 1600w, https://blog.mythsman.com/content/images/2022/05/------.excalidraw.png 2266w&quot; sizes=&quot;(min-width: 720px) 720px&quot;/&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;Alice 代表发起请求的客户端&lt;/li&gt;&lt;li&gt;Ivan 代表转发流量的路由工具（Iptables之类的工具）&lt;/li&gt;&lt;li&gt;Tom 代表透明代理服务器（Transparent Proxy）&lt;/li&gt;&lt;li&gt;Bob 代表客户端需要请求到的服务器&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在透明代理模式下，路由工具会非常暴力地将客户端发来的包的目的地址直接改为透明代理服务器，这会导致当数据包到了透明代理服务器中时，代理服务器是无法直接获取客户端真正想要到达的服务器地址。而正向代理服务器则不同，客户端会明确告知代理服务器他想访问谁。&lt;/p&gt;&lt;p&gt;那么透明代理服务器要如何在报文中获得真实的目的地址呢？这时候就需要分情况讨论了。&lt;/p&gt;&lt;h4 id=&quot;http&quot;&gt;HTTP&lt;/h4&gt;&lt;p&gt;我们知道 HTTP 报文是纯明文，就像一个没有封口的信封。只要打开来看就会发现，HTTP 请求报文会在 Header 中带上一个 Host 头表明当前的信期望到达的地方。透明代理服务器可以非常方便地解析到这个信息，从而知道报文需要被发送到的目的地址（Bob）。&lt;/p&gt;&lt;h4 id=&quot;https&quot;&gt;HTTPS&lt;/h4&gt;&lt;p&gt;HTTPS 这里就比较尴尬了。我们知道 HTTPS 在第四层有一个 TLS 加密层，如果想和 HTTP 一样从 Header 中获取 Host 头的话，则需要先进行 TLS 解密；但是，如果想进行 TLS 解密，则必须和实际的服务器进行 TLS 握手；可是你都不知道实际的服务器在哪，如果握手呢？这竟然变成了一个鸡生蛋还是蛋生鸡的问题。&lt;/p&gt;&lt;p&gt;那么问题最终会怎么解决呢？目光还得回到路由工具。&lt;/p&gt;&lt;p&gt;既然报文是你路由工具传给透明代理的，那显然路由工具这边是记录了报文原先实际需要访问的目的地址的，我直接请求你不就好了么？在 Linux 下，我们有一个用户工具 conntrack 可以展示当前网络连接的链路追踪信息：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ sudo conntrack -L
tcp      6 60 TIME_WAIT src=192.168.32.1 dst=192.168.32.3 sport=40298 dport=8080 src=192.168.32.3 dst=192.168.32.1 sport=8080 dport=40298 [ASSURED] mark=0 use=1
tcp      6 56 TIME_WAIT src=192.168.32.1 dst=192.168.32.7 sport=54398 dport=2368 src=192.168.32.7 dst=192.168.32.1 sport=2368 dport=54398 [ASSURED] mark=0 use=1
tcp      6 60 TIME_WAIT src=192.168.32.5 dst=172.17.0.1 sport=52992 dport=5001 src=172.17.0.1 dst=192.168.32.5 sport=5001 dport=52992 [ASSURED] mark=0 use=1
tcp      6 79 TIME_WAIT src=10.0.0.4 dst=168.63.129.16 sport=39414 dport=80 src=168.63.129.16 dst=10.0.0.4 sport=80 dport=39414 [ASSURED] mark=0 use=1&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而透明代理程序则可以通过 getsockopt 等方法直接向内核查询 socket 的链路信息：&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-c&quot;&gt;static int getdestaddr(int fd, struct sockaddr_storage *destaddr)
{
    socklen_t socklen = sizeof(*destaddr);
    int error         = 0;

    error = getsockopt(fd, SOL_IPV6, IP6T_SO_ORIGINAL_DST, destaddr, &amp;amp;socklen);
    if (error) { // Didn&#x27;t find a proper way to detect IP version.
        error = getsockopt(fd, SOL_IP, SO_ORIGINAL_DST, destaddr, &amp;amp;socklen);
        if (error) {
            return -1;
        }
    }
    return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样一来，透明代理服务就能在 TLS 握手前就能拿到真实的目的 IP 了。&lt;/p&gt;&lt;p&gt;然而有了 IP 就够了么？并不是。路由工具中我们只能拿到目的 IP ，但是并没有域名！现代服务端的网关层基本都需要通过域名来进行转发。如何解决这个问题呢？这就引入了 SNI （&lt;strong&gt;Server Name Indication&lt;/strong&gt;）头。在 TLS 握手阶段，客户端会在握手报文里额外增加 SNI 信息（这个已经是TLS标准了，但是有些客户端可能没有加），这样服务端或者透明代理服务器就能获取到实际的域名了。&lt;/p&gt;&lt;p&gt;最后我们再来看下 Mitmproxy 文档中提供的透明代理的流程图：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2022/05/image-1.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/figure&gt;&lt;h2 id=&quot;%E8%A7%A3%E5%86%B3&quot;&gt;解决&lt;/h2&gt;&lt;p&gt;了解了代理服务器的工作细节，我们再来尝试回答下开头的问题。为什么把远端的 HTTPS 流量通过路由工具+端口映射转发到本地的透明代理服务器中会报错呢？&lt;/p&gt;&lt;p&gt;答案已经很明显了，那就是&lt;strong&gt;本地的透明代理工具无法查询到远端服务器中的路由链路信息，导致无法获取真实的目的地址&lt;/strong&gt;。（也就是为什么 mitmproxy 会报 &lt;code&gt;Could not resolve original destination&lt;/code&gt;的原因。&lt;/p&gt;&lt;p&gt;解决这个问题的思路也很清晰，&lt;strong&gt;既然希望走透明代理的流量无法跨主机，那我们就将透明代理服务部署在本机，然后转换成正向代理出去即可&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;具体操作中，由于 mitmproxy 默认不支持在透明代理模式下再配置一个上游正向代理，因此我们可以选择简单魔改一下代码，在透明代理模式下的出口处请求另一个正向代理。&lt;/p&gt;&lt;p&gt;如果懒得改代码，我找到了一个 &lt;a href=&quot;https://github.com/darkk/redsocks&quot;&gt;Redsocks&lt;/a&gt; 工具。这个工具可以直接作为透明代理服务器，并将流量转发给一个上游的正向代理。Ubuntu 下可以直接用 apt 安装，配置一下 /etc/redsocks.conf 就能直接使用。&lt;/p&gt;&lt;p&gt;如此，架构图修改成下图即可：&lt;/p&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2022/05/---2.excalidraw.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot; srcset=&quot;https://blog.mythsman.com/content/images/size/w600/2022/05/---2.excalidraw.png 600w, https://blog.mythsman.com/content/images/size/w1000/2022/05/---2.excalidraw.png 1000w, https://blog.mythsman.com/content/images/2022/05/---2.excalidraw.png 1237w&quot; sizes=&quot;(min-width: 720px) 720px&quot;/&gt;&lt;/figure&gt;&lt;h2 id=&quot;%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99&quot;&gt;参考资料&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://docs.mitmproxy.org/stable/concepts-howmitmproxyworks/#transparent-https&quot;&gt;Mitmproxy Docs - Transparent HTTPS&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://yemablog.com/posts/transparent-proxy&quot;&gt;如何使用透明代理抓 HTTPS&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://www.ichenfu.com/2019/04/09/istio-inbond-interception-and-linux-transparent-proxy/&quot;&gt;Istio的流量劫持和Linux下透明代理实现&lt;/a&gt;&lt;/p&gt;
    &lt;/section&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4f771bf62e553be1c95997fd8746bd7c</guid>
<title>JVM 类加载器与双亲委派模型</title>
<link>https://toutiao.io/k/f1pa9jb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1. 类加载器&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，虚拟机在加载类的过程中需要使用类加载器进行加载，而在 Java 中，类加载器有很多，那么当 JVM 想要加载一个 &lt;code&gt;.class&lt;/code&gt; 文件的时候，到底应该由哪个类加载器加载呢？这时候就需要双亲委派机制来告诉 JVM 使用哪个类加载器加载。在讲解什么是双亲委派机制之前，我们先看一下有哪些加载器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从 Java 虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器 Bootstrap ClassLoader，这个类加载器使用 C++ 语言实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由 Java 语言实现，独立于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。从 Java 开发人员的角度来看，类加载器还可以划分得更细致一些，分为用户级别和系统级别类加载器。用户级别的类加载器我们统一称为自定义类加载器，而系统级别的类加载器有：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;启动类加载器：Bootstrap ClassLoader&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;扩展类加载器：Extention ClassLoader&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;应用程序类加载器：Application ClassLoader&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 启动类加载器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动类加载器 Bootstrap ClassLoader 使用 C/C++ 语言实现，负责将存放在 &lt;code&gt;&amp;lt;JAVA_HOME&amp;gt;\lib&lt;/code&gt; 目录中的，或者被 &lt;code&gt;-Xbootclasspath&lt;/code&gt; 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用 null 代替即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过如下代码查看启动类加载器可以加载哪些路径的 jar：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String bootStrapPath = System.getProperty(&lt;span&gt;&quot;sun.boot.class.path&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(&lt;span&gt;&quot;启动类加载器加载的路径: &quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (String paths : bootStrapPath.split(&lt;span&gt;&quot;;&quot;&lt;/span&gt;)){&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (String path : paths.split(&lt;span&gt;&quot;:&quot;&lt;/span&gt;)) {&lt;br/&gt;        System.out.println(path);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 扩展类加载器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩展类加载器 Extension ClassLoader 由 Java 语言编写，并由 &lt;code&gt;sun.misc.Launcher$ExtClassLoader&lt;/code&gt; 实现，父类加载器为启动类加载器。负责加载 &lt;code&gt;&amp;lt;JAVA_HOME&amp;gt;\lib\ext&lt;/code&gt; 目录中的，或者被 &lt;code&gt;java.ext.dirs&lt;/code&gt; 系统变量所指定的路径中的所有类库。开发者可以直接使用扩展类加载器，如果用户创建的 JAR 放在扩展目录下，也会自动由扩展类加载器加载。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过如下代码查看扩展类加载器可以加载哪些路径的 jar：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String extClassLoaderPath = System.getProperty(&lt;span&gt;&quot;java.ext.dirs&quot;&lt;/span&gt;);&lt;br/&gt;System.out.println(&lt;span&gt;&quot;拓展类加载器加载的路径: &quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (String paths : extClassLoaderPath.split(&lt;span&gt;&quot;;&quot;&lt;/span&gt;)){&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (String path : paths.split(&lt;span&gt;&quot;:&quot;&lt;/span&gt;)) {&lt;br/&gt;        System.out.println(path);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.3 应用程序类加载器&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用程序类加载器 Application ClassLoader 由 Java 语言编写，并由 &lt;code&gt;sun.misc.Launcher$App-ClassLoader&lt;/code&gt; 实现，父类加载器为扩展类加载器。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径 ClassPath 或系统属性 &lt;code&gt;java.class.path&lt;/code&gt; 指定路径下的类库。开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过如下代码查看应用程序类加载器可以加载哪些路径的 jar：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;String appClassLoaderPath = System.getProperty(&lt;span&gt;&quot;java.class.path&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (String paths : appClassLoaderPath.split(&lt;span&gt;&quot;;&quot;&lt;/span&gt;)){&lt;br/&gt;    System.out.println(&lt;span&gt;&quot;应用程序类加载器加载的路径: &quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (String path : paths.split(&lt;span&gt;&quot;:&quot;&lt;/span&gt;)) {&lt;br/&gt;        System.out.println(path);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.4 自定义类加载器&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Java 的日常应用程序开发中，类的加载几乎是由上述 3 种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。那么什么场景下需要自定义类加载器呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发人员可以通过继承抽象类 java.lang.ClassLoader 类的方式，实现自己的类加载器，以满足一些特殊的需求。在 JDK 1.2 之前，在自定义类加载器时，总会去继承 ClassLoader 类并重写 loadClass() 方法，从而实现自定义的类加载类，但是在 JDK 1.2 之后已不再建议用户去覆盖 loadClass() 方法，而是建议把自定义的类加载逻辑写在 findclass() 方法中。下面我们来实现一个自定义类加载器并演示如何使用。第一步自定义一个实体类 Car.java：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 测试对象 Car&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Car&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Car&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;welcome you&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;this is a car&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二步自定义一个类加载器，我们定义的 CustomClassLoader 继承自 java.lang.ClassLoader，且只实现 findClass 方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 自定义加载器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CustomClassLoader&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;ClassLoader&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; String path;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;CustomClassLoader&lt;/span&gt;&lt;span&gt;(String path)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.path = path;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;protected&lt;/span&gt; Class&amp;lt;?&amp;gt; findClass(String name) &lt;span&gt;throws&lt;/span&gt; ClassNotFoundException {&lt;br/&gt;        System.out.println(&lt;span&gt;&quot;CustomClassLoader: &quot;&lt;/span&gt; + name);&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            String fileName = path + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + name.substring(name.lastIndexOf(&lt;span&gt;&quot;.&quot;&lt;/span&gt;) + &lt;span&gt;1&lt;/span&gt;) + &lt;span&gt;&quot;.class&quot;&lt;/span&gt;;&lt;br/&gt;            FileInputStream inputStream = &lt;span&gt;new&lt;/span&gt; FileInputStream(fileName);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (inputStream == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;super&lt;/span&gt;.findClass(name);&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;byte&lt;/span&gt;[] bytes = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[inputStream.available()];&lt;br/&gt;            inputStream.read(bytes);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; defineClass(name, bytes, &lt;span&gt;0&lt;/span&gt;, bytes.length);&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (IOException ex) {&lt;br/&gt;            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ClassNotFoundException(name, ex);&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三步演示自定义类加载器如何使用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CustomClassLoader myClassLoader = &lt;span&gt;new&lt;/span&gt; CustomClassLoader(&lt;span&gt;&quot;/opt/data&quot;&lt;/span&gt;);&lt;br/&gt;Class&amp;lt;?&amp;gt; myClass = myClassLoader.loadClass(&lt;span&gt;&quot;com.common.example.bean.Car&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// 创建对象实例&lt;/span&gt;&lt;br/&gt;Object o = myClass.newInstance();&lt;br/&gt;&lt;span&gt;// 调用方法&lt;/span&gt;&lt;br/&gt;Method print = myClass.getDeclaredMethod(&lt;span&gt;&quot;print&quot;&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;print.invoke(o, &lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// 输出类加载器&lt;/span&gt;&lt;br/&gt;System.out.println(&lt;span&gt;&quot;ClassLoader: &quot;&lt;/span&gt; + o.getClass().getClassLoader());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;直接运行上述代码，会输出如下结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;welcome you&lt;br/&gt;this is a car&lt;br/&gt;ClassLoader: sun.misc.Launcher&lt;span&gt;$AppClassLoader&lt;/span&gt;@49476842&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面看到输出结果并不符合我们的预期，Car 类使用的应用程序类加载器加载的，并不是我们自定义的类加载器。这个问题主要是因为 Idea 编译后会存放在 target/classes 目录下&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8093994778067886&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6LrrHRRxT1xEvMEVoibekmGq1x9s6vKCEflPfTTnKDaA7ZZO63BKmtD5TDrpEN9qdve8Eqiceuib7sejqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;383&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而这个目录正好是应用程序类加载的路径，可以使用ClassLoaderPathExample代码验证。为了解决这个问题，我们可以把 Car.class 手动移动到 /opt/data 目录下（删除 target/classes 目录下的 Car.class 文件，避免由应用程序类加载器加载）。再次运行输出如下结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;CustomClassLoader: com.common.example.bean.Car&lt;br/&gt;welcome you&lt;br/&gt;this is a car&lt;br/&gt;ClassLoader: com.common.example.jvm.classLoader.CustomClassLoader@4617c264&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样 Car 类就使用我们自定义的类加载器加载了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2. 什么是双亲委派模型&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述四种类加载器之间存在着一种层次关系，如下图所示：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.978494623655914&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/nKovjAe6LrrHRRxT1xEvMEVoibekmGq1xIKpFeYaVibn3NgVGTzJZBv7WCibs8XVlAib2w8LgOnKhsLiaIYmfoNx2jg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;186&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般认为上一层加载器是下一层加载器的父类加载器，除了启动类加载器 BootstrapClassLoader 之外，所有的加载器都是有父类加载器。我们可以先通过如下代码来看一下类加载器的层级结构：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 应用程序类加载器(系统类加载器)&lt;/span&gt;&lt;br/&gt;ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();&lt;br/&gt;System.out.println(systemClassLoader); &lt;span&gt;// sun.misc.Launcher$AppClassLoader@49476842&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 获取上层加载器:扩展类加载器&lt;/span&gt;&lt;br/&gt;ClassLoader extClassLoader = systemClassLoader.getParent();&lt;br/&gt;System.out.println(extClassLoader); &lt;span&gt;// sun.misc.Launcher$ExtClassLoader@5acf9800&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 获取上层加载器:启动类加载器&lt;/span&gt;&lt;br/&gt;ClassLoader bootstrapClassLoader = extClassLoader.getParent();&lt;br/&gt;System.out.println(bootstrapClassLoader); &lt;span&gt;// null&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上述代码中依次输出当前类的类加载器，父类加载器以及父类的父类加载器。可以看到当前类的加载器是应用程序类加载器，它的父类亲加载器是扩展类加载器，扩展类加载器的父类输出了一个 null，这个 null 会去调用启动类加载器。后续通过 ClassLoader 类的源码我们可以知道这一点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那到底什么是双亲委派模型呢？其实我们把上述类加载器之间的这种层次关系，我们称为类加载器的双亲委派模型（Parents Delegation Model）。双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承（Inheritance）的关系来实现，而是都使用组合（Composition）关系来复用父加载器的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;类加载器的双亲委派模型是在 JDK 1.2 期间被引入并被广泛应用于之后几乎所有的 Java 程序中。但它并不是一个强制性的约束模型，而是 Java 设计者推荐给开发者的一种类加载器实现方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们从概念上知道了什么是双亲委派模型，那它到底是如何工作的呢？双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都委派到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3. 为什么需要双亲委派模型&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上面我们提到的，因为类加载器之间有严格的层次关系，那么也就使得 Java 类也随之具备了一种带有优先级的层次关系。例如类 java.lang.Object，它存放在 rt.jar 之中，无论哪一个类加载器要加载这个类，但最终都委派给最顶层的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中将会出现多个不同的 Object 类，Java 类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面我们可以知道双亲委派模型的核心是保障类加载的唯一性和安全性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;唯一性：可以避免类的重复加载，当父类加载器已经加载过某一个类时，子加载器就不会再重新加载这个类。例如上述提及的 java.lang.Object 类，最终都委派给最顶层的启动类加载器进行加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;安全性：保证了 Java 的核心 API 不被篡改。因为启动类加载器 Bootstrap ClassLoader 在加载的时候，只会加载 JAVA_HOME 中的 jar 包里面的类，如 java.lang.Object，那么就可以避免加载自定义的有破坏能力的 java.lang.Object。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4. 双亲委派模型是怎么实现的&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型对于保证 Java 程序的稳定运作很重要，但它的实现却非常简单，实现双亲委派的代码都集中在 java.lang.ClassLoader 的 loadClass() 方法之中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;protected&lt;/span&gt; Class&amp;lt;?&amp;gt; loadClass(String name, &lt;span&gt;boolean&lt;/span&gt; resolve) &lt;span&gt;throws&lt;/span&gt; ClassNotFoundException {&lt;br/&gt;    &lt;span&gt;synchronized&lt;/span&gt; (getClassLoadingLock(name)) {&lt;br/&gt;        &lt;span&gt;// 首先检查类是否已经被加载过&lt;/span&gt;&lt;br/&gt;        Class&amp;lt;?&amp;gt; c = findLoadedClass(name);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (c == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;long&lt;/span&gt; t0 = System.nanoTime();&lt;br/&gt;            &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (parent != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                    &lt;span&gt;// 若没有加载过并且有父类加载器则调用父类加载器的 loadClass() 方法&lt;/span&gt;&lt;br/&gt;                    c = parent.loadClass(name, &lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;                } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                    &lt;span&gt;// 调用启动类加载器&lt;/span&gt;&lt;br/&gt;                    c = findBootstrapClassOrNull(name);&lt;br/&gt;                }&lt;br/&gt;            } &lt;span&gt;catch&lt;/span&gt; (ClassNotFoundException e) {&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (c == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;// 如果仍未找到，则调用 findClass 以查找该类。&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;long&lt;/span&gt; t1 = System.nanoTime();&lt;br/&gt;                c = findClass(name);&lt;br/&gt;                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);&lt;br/&gt;                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);&lt;br/&gt;                sun.misc.PerfCounter.getFindClasses().increment();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (resolve) {&lt;br/&gt;            resolveClass(c);&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; c;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先检查类是否已经被加载过，若没有加载过并且有父类加载器则调用父类加载器的 loadClass() 方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出 ClassNotFoundException 异常后，再调用自己的 findClass() 方法进行加载。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5. 如何破坏双亲委派模型&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型并不是一个强制性的约束模型，而是 Java 设计者推荐给开发者的类加载器实现方式。在 Java 的世界中大部分的类加载器都遵循这个模型，但也有例外，到目前为止，双亲委派模型主要出现过 3 较大规模的&#x27;被破坏&#x27;情况。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.1 JDK 1.2 历史原因&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型的第一次&#x27;被破坏&#x27;其实发生在双亲委派模型出现之前，即 JDK 1.2 发布之前。由于双亲委派模型在 JDK 1.2 之后才被引入，而类加载器和抽象类 java.lang.ClassLoader 则在 JDK 1.0 时代就已经存在，面对已经存在的用户自定义类加载器的实现代码，Java 设计者引入双亲委派模型时不得不做出一些妥协。为了向前兼容，JDK 1.2 之后的 java.lang.ClassLoader 添加了一个新的 protected 方法 findClass()，在此之前，用户去继承 java. lang.ClassLoader 的唯一目的就是为了重写 loadClass() 方法，因为虚拟机在进行类加载的时候会调用加载器的私有方法 loadClassInternal()，而这个方法的唯一逻辑就是去调用自己的 loadClass()。上一节我们已经看过 loadClass() 方法的代码，双亲委派的具体逻辑就实现在这个方法之中，JDK 1.2之 后已不提倡用户再去覆盖 loadClass() 方法，而应当把自己的类加载逻辑写到 findClass() 方法中，在 loadClass() 方法的逻辑里如果父类加载失败，则会调用自己的 findClass() 方法来完成加载，这样就可以保证新写出来的类加载器是符合双亲委派规则的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.2 SPI&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型的第二次&#x27;被破坏&#x27;是由这个模型自身的缺陷所导致的，双亲委派很好地解决了各个类加载器的基础类的统一问题（越基础的类由越上层的加载器进行加载），基础类之所以称为“基础”，是因为它们总是作为被用户代码调用的 API，但世事往往没有绝对的完美，如果基础类又要调用回用户的代码，那该怎么办？这并非是不可能的事情，一个典型的例子便是 JNDI 服务，JNDI 现在已经是 Java 的标准服务，它的代码由启动类加载器去加载（在 JDK 1.3 时放进去的 rt.jar 中），但 JNDI 的目的就是对资源进行集中管理和查找，它需要调用由独立厂商实现并部署在应用程序 ClassPath 下的 JNDI 接口提供者（SPI，Service Provider Interface）的代码，但启动类加载器不可能&#x27;认识&#x27;这些代码。为了解决这个问题，Java 设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过 java.lang.Thread 类的 setContextClassLoaser() 方法进行设置，如果创建线程时还未设置，将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。有了线程上下文类加载器，就可以做一些&#x27;舞弊&#x27;的事情了，JNDI 服务使用这个线程上下文类加载器去加载所需要的 SPI 代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则，但这也是无可奈何的事情。Java 中所有涉及 SPI 的加载动作基本上都采用这种方式，例如 JNDI、JDBC、JCE、JAXB和JBI等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.3 模块化&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双亲委派模型的第三次&#x27;被破坏&#x27;是由于用户对程序动态性的追求而导致的，这里所说的&#x27;动态性&#x27;指的是当前一些非常&#x27;热门&#x27;的名词：代码热替换（HotSwap）、模块热部署（Hot Deployment）等。Sun 公司所提出的JSR-294、JSR-277 规范在与 JCP 组织的模块化规范之争中落败给 JSR-291（即OSGi R4.2），虽然 Sun 不甘失去 Java 模块化的主导权，独立在发展 Jigsaw 项目，但目前 OSGi 已经成为了业界事实上的 Java 模块化标准，而 OSGi 实现模块化热部署的关键则是它自定义的类加载器机制的实现。每一个程序模块（OSGi 中称为 Bundle）都有一个自己的类加载器，当需要更换一个 Bundle 时，就把 Bundle 连同类加载器一起换掉以实现代码的热替换。在 OSGi 环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考：&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cf82ed9955b2bb6aa8f0515a7ccfca9e</guid>
<title>解密支付系统，来看如何构建理想的支付系统架构</title>
<link>https://toutiao.io/k/ohbhiwn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;markdown-body detail-content&quot;&gt;&amp;#13;
                &amp;#13;
                &lt;p&gt;&lt;strong&gt;【本文原创：苏博亚】&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;货币是人类发展史上一个极为重要的角色，它不仅是市场上物品交换的媒介，更是人类文明发展史上里程碑式的代表物。&lt;/p&gt;&amp;#13;
&lt;p&gt;几千年前人类在贸易市场上使用实物交换，可以想象一下我们的祖先进行市场贸易：一个人手上有羊奶，另一个人手上有牛肉，如果两个人都需要对方的物品，那么交换一下就可以了，这是最早的贸易。&lt;/p&gt;&amp;#13;
&lt;p&gt;但是随着人类文明的发展，这种实物交换已经无法满足人类的市场需求，比如拥有牛肉的人不喜欢羊奶，交易就无法进行。&lt;/p&gt;&amp;#13;
&lt;p&gt;这时候智慧的古人学会了使用媒介，大家所熟知的古时候的媒介是金、银、铜等。使用媒介给每种物品定价，所有的物品都可以通过媒介来购买和出售。&lt;/p&gt;&amp;#13;
&lt;p&gt;到了近代，金、银、铜的弊端也逐渐浮现出来，比如携带不便，大量金银放在身上会有安全隐患。在这种情况下，纸币应运而生，纸币的诞生解决了大部分金属货币的弊端，成本也非常低，并且携带方便。&lt;/p&gt;&amp;#13;
&lt;p&gt;随着科技的飞速发展，人类更加依赖电子产品，就出现了电子货币。货币发展经历的四大阶段如图1所示。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/2205651a5ec464e8d420&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图1&amp;#13;
&lt;/p&gt;&lt;p&gt;每一种货币的发展都经历了漫长的过程，每一种货币能够生存下来都经历了严格的考验。现在电子货币深入我们生活的方方面面，我们去商场购物，去餐厅吃饭，搭乘交通工具等，带一部手机就可以解决所有的支付问题。使用手机支付需要依靠互联网，&lt;strong&gt;通过互联网实现支付能力催生出了一大批支付机构。&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;h3 id=&quot;h3-1-&quot;&gt;&lt;a name=&quot;1 支付牌照的诞生&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;1 支付牌照的诞生&lt;/h3&gt;&lt;p&gt;支付机构诞生之初市场是非常混乱的，没有统一的管理，没有统一的规范，所有的支付机构可以直接对接银行，可以实现资金留存，这样操作存在极大的风险，比如支付机构“跑路”了会造成很多人的资金损失。&lt;/p&gt;&amp;#13;
&lt;p&gt;所有行业的发展都要经历从混乱到有序的过程，2005年6月中国人民银行（简称央行）出台《支付清算组织管理办法（征求意见稿）》，在一定程度上规范了支付行业。2010年6月《非金融机构支付服务管理办法》的出台使整个支付行业终于有据可依，行业发展得以规范化。2011年5月央行开始发行支付牌照，从事支付行业的人士都非常了解支付牌照（也称支付业务许可证）的重要性，&lt;strong&gt;有支付牌照的机构做三方支付业务才是合规的，不然就是所谓的无证机构，是央行严厉打击的对象。&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;目前全国有支付牌照的企业只有200多家，这200多家在央行是有备付金账户的，即客户资金是安全有保障的，且支付机构可以在此基础上为客户提供资金清算和管理的服务。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;是不是只有有支付牌照的企业才能做支付业务？&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;答案是否定的，没有牌照的也可以，但是没有央行的备付金账户，所以不能进行资金的清算和管理，只能做支付信息服务，我们称之为聚合支付。&lt;/p&gt;&amp;#13;
&lt;p&gt;这样做的目的是保护消费者的财产安全，使市场更加合规稳定。有支付牌照的支付机构的业务流程如图2所示。&lt;br/&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/220593f72f0ea4b2a05f&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图2&amp;#13;
&lt;/p&gt;&lt;p&gt;没有支付牌照的支付机构的业务流程如图3所示。&lt;br/&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/2205acb38d7f574456be&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图3&amp;#13;
&lt;/p&gt;&lt;p&gt;可以看出，有牌照和没有牌照的业务处理流程是不一样的，没有牌照的支付机构需要通过有牌照的支付机构实现资金的流转，并且有牌照的支付机构直接把钱结算给商户，资金不经过聚合支付机构。接下来出现的“支付机构”指的都是有支付牌照的三方支付机构。&lt;/p&gt;&amp;#13;
&lt;h3 id=&quot;h3-2-&quot;&gt;&lt;a name=&quot;2 支付业务架构&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;2 支付业务架构&lt;/h3&gt;&lt;p&gt;支付机构核心的两个职责&lt;strong&gt;一个是帮助商户把钱收上来，另一个是把收到的钱结算给商户。&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;这两个职责对应的两个过程分别是入金和出金，&lt;strong&gt;入金&lt;/strong&gt;是指能够支撑客户的支付能力，把钱从C端客户的账户入账到支付机构的账户，&lt;strong&gt;出金&lt;/strong&gt;是把收到的C端客户的钱结算给商户。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;通俗地讲，支付机构就是帮助商户管好钱。&lt;/strong&gt;支付的过程一定要做到高效且安全，C端客户在支付的过程中按照一般人的习惯不会等待超过7秒，7秒之内一定要支付完成，否则会给客户造成很不好的体验。&lt;/p&gt;&amp;#13;
&lt;p&gt;一笔支付要经过商户、支付机构、银联/网联，接着到达银行，然后银行再把结果返回，最终展示给用户，这个过程是非常漫长的。如果订单量比较少，几秒内完成这些工作完全没有问题，如果支付机构每天有上千万或者上亿的支付单量（比如支付宝、微信），保证支付的高效就非常难了。&lt;/p&gt;&amp;#13;
&lt;p&gt;支付的过程中有很多影响支付速度的因素，比如带宽、硬件设备等，这些因素对于开发人员来说应该考虑，但是并不能起到决定性的作用，开发人员能做的是使用最少的资源，实现最高的效率。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;如何设计一套高效且安全的支付体系呢？&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;首先业务架构要清晰，支付体系的业务架构如图4所示。&lt;br/&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/2205b7e568ae1c86e5db&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图4&amp;#13;
&lt;/p&gt;&lt;p&gt;我们常使用的支付方式除了微信、支付宝，还有快捷支付（即绑定银行卡支付）。&lt;/p&gt;&amp;#13;
&lt;p&gt;微信支付包含扫码支付、JSAPI支付、Native支付、APP支付、H5支付、小程序支付等。&lt;/p&gt;&amp;#13;
&lt;p&gt;支付宝支付包含手机网站支付、APP支付、电脑网站支付等。&lt;/p&gt;&amp;#13;
&lt;p&gt;聚合支付机构要具备这些支付能力就需要对接对应的接口。合规的支付机构之间不能相互对接，只能和银联/网联对接。如果要具有微信、支付宝支付能力，则需要通过银联/网联来对接微信和支付宝。&lt;/p&gt;&amp;#13;
&lt;h3 id=&quot;h3-3-&quot;&gt;&lt;a name=&quot;3 支付系统架构发展历程&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;3 支付系统架构发展历程&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;随着支付业务的发展，线上支付单量的增加，支付系统架构也经历了几次演进。&lt;/strong&gt;早先使用线上支付的人非常少，一个支付机构的日单量可能只有十几万甚至几万笔。这时候不需要太多的系统资源，也不需要太复杂的架构设计，一个系统基本“搞定”所有的事情，如图5所示。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/22050c017e1b808d9367&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图5&amp;#13;
&lt;/p&gt;&lt;p&gt;同一个系统里的业务分不同的模块来处理，支付系统不外乎API接入、交易逻辑处理、商户维护、账务记录等。如果订单量小，那么这个架构没有问题，但是随着支付业务复杂性增加，订单笔数增多，系统的弊端就逐渐暴露出来了。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;系统容灾能力弱：&lt;/strong&gt;所有的模块都在一个系统中，某一个模块出现问题，会影响其他的模块，比如退款本身是可以异步执行的，如果因为退款业务的原因把正常支付的资源使用完或者拖垮系统就得不偿失了。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;开发成本高，团队协作不灵活：&lt;/strong&gt;所有的开发者都用同一套代码，编码版本维护成本高，调优发布风险大。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;复杂业务扩展性差：&lt;/strong&gt;随着业务复杂性的增加，系统的业务扩展能力会受到架构的严重影响，无法灵活修改系统的业务模块。&lt;/p&gt;&amp;#13;
&lt;p&gt;基于这些问题，流量大的支付机构就开始思考设计扩展性更好的支付架构来支撑不断增长的业务量和业务复杂度，首先考虑的是如何把系统拆得可用性强一些，系统的模块中的账务管理、商户管理、渠道对接是非常重要并且独立的，可以拆分出来，拆分后的系统结构如图6所示。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/220547e81c85786be51e&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图6&amp;#13;
&lt;/p&gt;&lt;p&gt;这样拆分后系统扩展性相对来说就比较高了，但技术永远都是向前发展的，微服务思想大大提升了系统的可扩展性，接下来分析使用微服务设计支付系统架构的思路。&lt;/p&gt;&amp;#13;
&lt;h3 id=&quot;h3-4-&quot;&gt;&lt;a name=&quot;4 理想的支付系统架构&quot; class=&quot;reference-link&quot;/&gt;&lt;span class=&quot;header-link octicon octicon-link&quot;/&gt;4 理想的支付系统架构&lt;/h3&gt;&lt;p&gt;微服务的核心思想是把复杂的系统拆分为多个简单的子系统。明确了支付业务模型之后，需要把确定的支付产品转化为系统，以支撑我们的业务需求。支付体系架构经过多次演进，根据业务架构我们需要把系统拆解一下，每个小系统只负责一个业务模块。按照微服务的思想把支付系统拆分为多个小模块，如图7所示。&lt;br/&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/2205832c90222810e34a&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图7&amp;#13;
&lt;/p&gt;&lt;p&gt;每个模块都可以单独作为一个微服务的小系统，每个小系统负责不同的业务，某一个模块出现问题不会影响其他的业务模块。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;支付网关&lt;/strong&gt;是支付的入口，所有的交易都要经过支付网关再分发给各个系统，对支付机构起到门户的作用，给接入的商户提供统一的入口，方便商户的接入。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;商户中心&lt;/strong&gt;负责管理商户信息，商户想要使用支付平台，就要先提交入驻申请，把营业执照、法人信息、收款账户等上传到支付机构，支付机构存储并管理这些信息，在支付、结算的时候都需要用到这些信息。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;支付核心系统&lt;/strong&gt;（简称支付核心）负责处理业务逻辑，相当于一个系统的Service层，交易经过支付网关之后首先到达支付核心，支付核心根据交易报文的内容去“商户中心”收集信息，去请求“渠道”完成支付或者退款，去调用“账务”完成记账等。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;账务系统&lt;/strong&gt;负责管理商户的资金，商户入驻支付机构的时候，需要开通一个或多个管理资金的账户，商户使用支付渠道支付的每一笔资金都会在账户中体现，最终结算的时候也从账户中把资金结算给商户。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;清结算系统&lt;/strong&gt;负责把收到的资金结算给商户，结算的时候以支付、退款的明细为依据，把商户在支付机构的余额账户中的资金划转到商户的银行卡中。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;计费系统&lt;/strong&gt;负责收取渠道的手续费，一方面银联和网联要收取支付机构的手续费，另一方面支付机构会从中获利，是支付机构收入的主要来源。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;strong&gt;渠道系统&lt;/strong&gt;负责对接入金和出金的渠道，所有的支付机构不能和银行直接交互，需要通过银联/网联与银行交互。聚合支付机构可以对接三方支付机构。&lt;/p&gt;&amp;#13;
&lt;p&gt;一笔支付单在支付系统之间流转的过程如图8所示。&lt;br/&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/22056eb1ddf6ea674337&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;图8&amp;#13;
&lt;/p&gt;&lt;p&gt;所有的交易都要先经过支付网关，支付网关收到交易报文之后会进行验签、解密等相关的操作，校验完成之后转发报文到支付核心，支付核心会对业务字段进行验证、数据落库，然后请求渠道系统进行路由筛选，筛选出外部的交易渠道（使用银联还是网联），选定之后转发报文到银联或者网联，然后把支付结果返回到支付核心，支付核心把支付结果通过支付网关返回给商户。支付核心发送支付成功消息，清结算系统监听支付成功消息并把支付成功的记录落入数据库，等待发起结算。账务系统接收支付成功消息进行记账。支付的各个系统拆分之后，每个系统负责不同的职责，系统划分之后，就可以进行技术选型了。&lt;/p&gt;&amp;#13;
&lt;p&gt;本文节选自&lt;strong&gt;《支付架构实战》&lt;/strong&gt;一书，欢迎阅读本书继续了解技术选型等支付架构设计的内容。&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;img src=&quot;http://download.broadview.com.cn/Original/2205fada72242c9f2227&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;strong&gt;扫码了解本书详情&lt;/strong&gt;&lt;/p&gt;&amp;#13;
&lt;p&gt;&lt;img alt=&quot;&quot; src=&quot;http://download.broadview.com.cn/Original/2205c833275bc22454cb&quot;/&gt;&amp;#13;
&amp;#13;
            &lt;/p&gt;&lt;/div&gt;&amp;#13;
&amp;#13;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>926ccff739bdfa49382ccf10673bc743</guid>
<title>了解虚拟列表背后原理，轻松实现虚拟列表</title>
<link>https://toutiao.io/k/swzlkyj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;比如&lt;code&gt;umy-ui&lt;/code&gt;(ux-table)虚拟列表table组件，&lt;code&gt;vue-virtual-scroller&lt;/code&gt;以及&lt;code&gt;react-virtualized &lt;/code&gt;这些优秀的插件快速满足业务需要。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了理解插件背后的原理机制，我们实现一个自己简易版的虚拟列表，希望在实际业务项目中能带来一些思考和帮助。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正文开始...&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/h4&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.0970873786407767&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/njBmfXMicXibpcniaFhJ3vTjribkSkMu9jFxmIa8sYfuq3whdj7pljwic7FibucLWTNq8ibmoiay1pjKGMuLl4soNj3kicQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;103&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;虚拟列表是什么&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在大数据渲染中，选择一段可视区域显示对应数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先初步看一个图&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5363881401617251&quot; data-type=&quot;png&quot; data-w=&quot;2226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0jXCeiaibicNx4aU4a0Hm8CA4pUueuQo51exUIHhAUq5SFk19F29OQKbmCIp5LNXXaAQAo4mIAO6IOgJZfia9ev5LQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这张展示图中，我们可以看到我们展示的始终是&lt;code&gt;红色线虚线&lt;/code&gt;展示的部分，每一个元素固定高度，被一个&lt;code&gt;很大高度的元素&lt;/code&gt;包裹着，并且&lt;code&gt;最外层&lt;/code&gt;有一个固定的高度容器，并且设置可以滚动。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;新建一个&lt;code&gt;index.html&lt;/code&gt;对应结构如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;vitual-list-wrap&quot;&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;listWrap&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;content&quot;&lt;/span&gt; &lt;span&gt;:style&lt;/span&gt;=&lt;span&gt;&quot;contentStyle&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;item&quot;&lt;/span&gt; &lt;span&gt;v-for&lt;/span&gt;=&lt;span&gt;&quot;(item, index) in list&quot;&lt;/span&gt;&lt;br/&gt;         &lt;span&gt;:key&lt;/span&gt;=&lt;span&gt;&quot;index&quot;&lt;/span&gt; &lt;span&gt;:style&lt;/span&gt;=&lt;span&gt;&quot;item.style&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        {{item.content}}&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对应的&lt;code&gt;css&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;*{&lt;br/&gt;  &lt;span&gt;padding&lt;/span&gt;:&lt;span&gt;0px&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;margin&lt;/span&gt;: &lt;span&gt;0px&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;#app&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;width&lt;/span&gt;:&lt;span&gt;300px&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;border&lt;/span&gt;: &lt;span&gt;1px&lt;/span&gt; solid &lt;span&gt;#e5e5e5&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;/*外部容器给一个固定的可视高度，并且设置可以滚动*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;.vitual-list-wrap&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;position&lt;/span&gt;: relative;&lt;br/&gt;  &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;800px&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;overflow-y&lt;/span&gt;: auto;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;/*真实容器的区域*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;.content&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;position&lt;/span&gt;: relative;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;/*固定高度的每个元素*/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;.item&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;60px&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;padding&lt;/span&gt;: &lt;span&gt;10px&lt;/span&gt; &lt;span&gt;5px&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;border-bottom&lt;/span&gt;: &lt;span&gt;1px&lt;/span&gt; solid &lt;span&gt;#111&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;position&lt;/span&gt;: absolute;&lt;br/&gt;  &lt;span&gt;left&lt;/span&gt;:&lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;right&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;line-height&lt;/span&gt;: &lt;span&gt;60px&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从对应页面结构与&lt;code&gt;css&lt;/code&gt;中我们的思路大致是这样&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;确定外层固定的高度，并且设置纵向滚动条&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;真实容器设置相对定位，并且根据显示总数动态设置一个装载容器的高度&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个元素设置绝对定位，且是固定高度&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了对应设置的结构，因为我们每个元素是绝对定位的，所以我们现在的思路就是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、确定可视区域&lt;code&gt;item&lt;/code&gt;显示的条数&lt;code&gt;limit&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、向上滑动的当前位置&lt;code&gt;起始位&lt;/code&gt;与&lt;code&gt;最后位置&lt;/code&gt;，确定显示元素范围&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、确定每个元素的&lt;code&gt;top&lt;/code&gt;，当向上滑动时，确定当前的位置与最后元素的位置索引，根据当前位置与最后元素位置，渲染&lt;code&gt;可视区域&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体逻辑代码如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;app&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;h3&lt;/span&gt;&amp;gt;&lt;/span&gt;虚拟列表&lt;span&gt;&amp;lt;/&lt;span&gt;h3&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;vitual-list-wrap&quot;&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;list-wrap&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;content&quot;&lt;/span&gt; &lt;span&gt;:style&lt;/span&gt;=&lt;span&gt;&quot;contentStyle&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;item&quot;&lt;/span&gt; &lt;span&gt;v-for&lt;/span&gt;=&lt;span&gt;&quot;(item, index) in list&quot;&lt;/span&gt; &lt;br/&gt;                  &lt;span&gt;:key&lt;/span&gt;=&lt;span&gt;&quot;index&quot;&lt;/span&gt; &lt;span&gt;:style&lt;/span&gt;=&lt;span&gt;&quot;item.style&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;                    {{item.content}}&lt;br/&gt;                &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;!--引入vue3组件库--&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt; &lt;span&gt;src&lt;/span&gt;=&lt;span&gt;&quot;https://cdn.bootcdn.net/ajax/libs/vue/3.2.33/vue.global.min.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;&lt;span&gt;script&lt;/span&gt; &lt;span&gt;src&lt;/span&gt;=&lt;span&gt;&quot;./index.js&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们具体看下&lt;code&gt;index.js&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;// index.js&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; { createApp, reactive, toRefs, computed, onMounted, ref } = Vue;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; vm = createApp({&lt;br/&gt;  setup() {&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; listWrap = ref(&lt;span&gt;null&lt;/span&gt;);&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; viewData = reactive({&lt;br/&gt;        &lt;span&gt;list&lt;/span&gt;: [],&lt;br/&gt;        &lt;span&gt;total&lt;/span&gt;: &lt;span&gt;1000&lt;/span&gt;, &lt;span&gt;// 数据总条数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;600&lt;/span&gt;, &lt;span&gt;// 可视区域的高度&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;rowHeight&lt;/span&gt;: &lt;span&gt;60&lt;/span&gt;, &lt;span&gt;// 每条item的高度&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;startIndex&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;// 初始位置&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;endIndex&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;// 结束位置&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;timer&lt;/span&gt;: &lt;span&gt;false&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;bufferSize&lt;/span&gt;: &lt;span&gt;5&lt;/span&gt; &lt;span&gt;// 做一个缓冲&lt;/span&gt;&lt;br/&gt;        &lt;br/&gt;      });&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; contentStyle = computed(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;          &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;`&lt;span&gt;${viewData.total * viewData.rowHeight}&lt;/span&gt;px`&lt;/span&gt;,&lt;br/&gt;          &lt;span&gt;position&lt;/span&gt;: &lt;span&gt;&#x27;relative&#x27;&lt;/span&gt;,&lt;br/&gt;        }&lt;br/&gt;      });&lt;br/&gt;      &lt;span&gt;// todo 设置数据&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; renderData = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        viewData.list = [];&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; {rowHeight, height, startIndex, total, bufferSize} = viewData;&lt;br/&gt;        &lt;span&gt;// 当前可视区域的row条数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; limit = &lt;span&gt;Math&lt;/span&gt;.ceil(height/rowHeight);&lt;br/&gt;        &lt;span&gt;console&lt;/span&gt;.log(limit, &lt;span&gt;&#x27;=limit&#x27;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// 可视区域的最后一个位置&lt;/span&gt;&lt;br/&gt;        viewData.endIndex = &lt;span&gt;Math&lt;/span&gt;.min(startIndex + limit + bufferSize, total &lt;span&gt;-1&lt;/span&gt;);&lt;br/&gt;          &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i=startIndex; i&amp;lt;viewData.endIndex; i++) {&lt;br/&gt;            viewData.list.push({&lt;br/&gt;            &lt;span&gt;content&lt;/span&gt;: i,&lt;br/&gt;            &lt;span&gt;style&lt;/span&gt;: {&lt;br/&gt;              &lt;span&gt;top&lt;/span&gt;: &lt;span&gt;`&lt;span&gt;${i * rowHeight}&lt;/span&gt;px`&lt;/span&gt;&lt;br/&gt;            }&lt;br/&gt;          })&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;// todo 监听滚动，设置statIndex与endIndex&lt;/span&gt;&lt;br/&gt;      &lt;span&gt;const&lt;/span&gt; handleScroll = &lt;span&gt;(&lt;span&gt;callback&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// console.log(listWrap.value)&lt;/span&gt;&lt;br/&gt;        listWrap.value &amp;amp;&amp;amp; listWrap.value.addEventListener(&lt;span&gt;&#x27;scroll&#x27;&lt;/span&gt;, (e) =&amp;gt; {&lt;br/&gt;          &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.timer) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;          }&lt;br/&gt;          &lt;span&gt;const&lt;/span&gt; { rowHeight, startIndex, bufferSize } = viewData;&lt;br/&gt;          &lt;span&gt;const&lt;/span&gt; { scrollTop } = e.target;&lt;br/&gt;          &lt;span&gt;// 计算当前滚动的位置，获取当前开始的起始位置&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;const&lt;/span&gt; currentIndex = &lt;span&gt;Math&lt;/span&gt;.floor(scrollTop / rowHeight); &lt;br/&gt;          viewData.timer = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;          &lt;span&gt;// console.log(startIndex, currentIndex);&lt;/span&gt;&lt;br/&gt;          &lt;span&gt;// 做一个简单的节流处理&lt;/span&gt;&lt;br/&gt;          setTimeout(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;            viewData.timer = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;               &lt;span&gt;// 如果滑动的位置不是当前位置&lt;/span&gt;&lt;br/&gt;               &lt;span&gt;if&lt;/span&gt; (currentIndex !== startIndex) {&lt;br/&gt;                viewData.startIndex = &lt;span&gt;Math&lt;/span&gt;.max(currentIndex - bufferSize, &lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;                callback();&lt;br/&gt;               }&lt;br/&gt;            }, &lt;span&gt;500&lt;/span&gt;)&lt;br/&gt;        })&lt;br/&gt;      }&lt;br/&gt;      onMounted(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;        renderData();&lt;br/&gt;        handleScroll(renderData);&lt;br/&gt;      })&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;        ...toRefs(viewData),&lt;br/&gt;        contentStyle,&lt;br/&gt;        renderData,&lt;br/&gt;        listWrap&lt;br/&gt;      }&lt;br/&gt;  },&lt;br/&gt;})&lt;br/&gt;vm.mount(&lt;span&gt;&#x27;#app&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看下页面，已经ok了，每次上滑都只会固定高度加载对应的数据&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.45582047685834504&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/0jXCeiaibicNx4aU4a0Hm8CA4pUueuQo51eDyJ78MatXdPHDicsMr451AdtUTu2Qz8zdB2xnhdaTSIubFod2BcS1eA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2852&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意我们在&lt;code&gt;css&lt;/code&gt;中有一段这样的代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;#app&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;width&lt;/span&gt;:&lt;span&gt;300px&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;border&lt;/span&gt;: &lt;span&gt;1px&lt;/span&gt; solid &lt;span&gt;#e5e5e5&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;...&lt;br/&gt;&lt;span&gt;[data-v-app]&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;opacity&lt;/span&gt;: &lt;span&gt;1&lt;/span&gt; &lt;span&gt;!important&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样处理主要是为了插值表达式在未渲染的时候，让用户看不到未渲染前的模版内容。如果不先隐藏，那么会打开页面的时候会有插值表达式，&lt;code&gt;vue&lt;/code&gt;中提供了一个&lt;code&gt;v-cloak&lt;/code&gt;,但是貌似这里不管用，在&lt;code&gt;vue2&lt;/code&gt;中是可以的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇是非常简易的虚拟列表实现，了解虚拟列表背后的实现思想，更多可以参考&lt;span&gt;vue-virtual-scroller&lt;/span&gt;&lt;sup&gt;[1]&lt;/sup&gt;与&lt;span&gt;react-virtualized&lt;/span&gt;&lt;sup&gt;[2]&lt;/sup&gt;源码的实现，具体应用示例可以查看之前写的一篇偏应用的文章&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzk0ODMxODIzNw==&amp;amp;mid=2247486014&amp;amp;idx=1&amp;amp;sn=4fb22eb3cc18b08d5d7ec8ffeed63587&amp;amp;chksm=c368334cf41fba5ab89d61af3ae16d7753c3ebb61aa6a7720fb6e78a29c080a7e8841da8db02&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;测试脚本把页面搞崩了 &lt;/a&gt;。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;了解虚拟列表到底是什么，在大数据渲染中，选择一段可视区域显示对应数据&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;实现虚拟列表的背后原理，最外层给定一个固定的高度，然后设置纵向&lt;code&gt;Y轴&lt;/code&gt;滚动，然后每个元素的父级设置相对定位，设置真实展示数据的高度，根据&lt;code&gt;item&lt;/code&gt;固定高度(&lt;code&gt;rowHeight&lt;/code&gt;)，根据可视区域和&lt;code&gt;rowHeight&lt;/code&gt;计算可显示的&lt;code&gt;limit&lt;/code&gt;数目。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当滚动条上滑时，计算出滚动的距离&lt;code&gt;scrollTop&lt;/code&gt;，通过&lt;code&gt;currentIndex = Math.floor(scrollTop/rowHeight)&lt;/code&gt;计算出当前起始索引&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;根据&lt;code&gt;endIndex = Math.min(currentIndex+limit, total-1)&lt;/code&gt;计算出最后可显示的索引&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;最后根据&lt;code&gt;startIndex&lt;/code&gt;与结束位置&lt;code&gt;endIndex&lt;/code&gt;，根据&lt;code&gt;startIndex&lt;/code&gt;与&lt;code&gt;endIndex&lt;/code&gt;渲染可视区域&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;本文示例代码&lt;span&gt;code example&lt;/span&gt;&lt;sup&gt;[3]&lt;/sup&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;本文参考相关文章&lt;span&gt;如何实现一个高度自适应的虚拟列表&lt;/span&gt;&lt;sup&gt;[4]&lt;/sup&gt;,这是&lt;code&gt;react&lt;/code&gt;版本的&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考资料&lt;/span&gt;&lt;/h3&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;p&gt;vue-virtual-scroller: &lt;em&gt;https://github.com/Akryum/vue-virtual-scroller&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[2]&lt;/span&gt;&lt;p&gt;react-virtualized: &lt;em&gt;https://github.com/bvaughn/react-virtualized&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[3]&lt;/span&gt;&lt;p&gt;code example: &lt;em&gt;https://github.com/maicFir/lessonNote/tree/master/javascript/08-%E8%99%9A%E6%8B%9F%E5%88%97%E8%A1%A8&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;[4]&lt;/span&gt;&lt;p&gt;如何实现一个高度自适应的虚拟列表: &lt;em&gt;https://juejin.cn/post/6948011958075392036&lt;/em&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6db41b03b351c110b4d8ec2a2a199fdb</guid>
<title>数据标准在网易的实践</title>
<link>https://toutiao.io/k/qtjrexd</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;span&gt;在生活中，标准与我们息息相关，吃的食品需要满足国家标准才能食用，汽车排放达标才能够上路行驶，电脑接口得满足统一的标准才能够与外设对接等等。而在数据的世界，数据标准也同等重要。我们期望将数据标准真正应用到实践中去，帮助客户解决资产化不足、数据质量难以提升、数据开发效率低等问题，于是网易开始了数据标准的建设。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;本文将基于我们对数据标准的理解，阐述标准的建立并依据标准的建立内容和流程来设计的标准管理产品的介绍以及标准在数据治理过程中的具体实践，希望与大家碰撞出新的认识。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;1&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p hm_fix=&quot;360:461&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;数据标准的是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在实际的工作生产中，我们一般会参照国家标准、地方标准、行业标准等来进行具体的活动，来确保我们生成过程符合监管要求、便于上下游协同等，于是我们会见到如下的标准指导文件：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.4267676767676767&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQoFwCUFCkAQJoKV0pf6r6peibn8LFGu0p7hWAC99iaFjrf3u7ZQb9vv0PQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;396&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;同样，数据标准也会以文件的形式存在，在除了国标、行标定义的标准外，企业内部为了便于各部门采取同样的数据建设规范，通常会使用文件来定义数据标准，以供各部门达成统一的共识。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;虽然文件是标准的一种体现形式，但文件是非结构化的，在实际应用中，我们只有理解、提取文件里的内容，将标准应用于产品设计及流程活动当中去，标准才能起到真正的规范约束作用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据信通院发布的《数据标准管理实践白皮书》定义：数据标准（Data Standards）是指保障数据的内外部使用和交换的一致性和准确性的规范性约束。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;毫无疑问，这是正确的。但我们还需要将标准践行，以建设数据中台为例，我们知道数据中台强调的是资源整合，在数据层面就是整合多源异构系统中分散在各个孤岛的数据，形成统一的数据服务能力，这是一项艰巨的任务， 很难通过互相约定以及默认信任相关方来保障数据的价值发掘，形成真正的数据资产。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是，基于此点将数据标准进行扩充，一是对管理范围的扩充，从狭义的数据标准（指对基础数据本身的规范性约束，如数据格式、类型、值域等）扩充到整个数据中台层面的标准（包含治理各阶段的规范性约束）；二是对管理手段的扩充，数据标准不再是指一系列的数据标准化文档，而是一套由规范要求、流程制度、技术工具共同组成的体系，通过这套体系完成标准的规划、制定、发布、执行、检查、维护等行为，来完成数据的标准化以及标准的沉淀。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;2&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p hm_fix=&quot;360:461&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;数据标准的价值&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在说价值之前，我们先聊聊让我们头疼的问题。人人都在谈论数据标准，但数据标准真的被应用起来了么，我们拿着一堆标准文件，期望企业内部宣贯大家要按照这个标准来，但执行的结果如何？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据集成多源异构数据时，数仓开发人员真的能快速理解这些数据的实际业务含义么？如果理解成本很高，开发人员可能就会出现认识偏差。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;终于数据集成进来了，可以开始进行数仓建设了，如何保证每一层的数据都是符合质量要求的，靠开发的个人素质么？比如我们一般在dwd层做数据标准化，那么不同主题域的由不同的负责人进行开发，怎么保证标准化的结果似乎满足规范的？dws的数据可信度还能保证么？还能被叫做公共模型层么？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再后，数仓开发完成后需要对外开放，我们其实开发的不光是其数据，还需要开发它的元数据信息，帮助数据使用方快速的找到需要的数据，如果只是把数据堆在一起，只有研发人员自己知道这个数据是什么、在哪、怎么使用，那是不能够被称为数据资产的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还有很多问题，这里只列举了些典型。当然这些问题，是可以解决的，解决的方式就是数据标准。解决的的过程可能需要的时间比较长，因为标准从管理到落地执行推进并不是一件容易的事，需要从思想上进行转变，但我们总要正确的做事。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面列举了一些价值，但在实际的应用过程能够发现更多的可能性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;价值一：建立统一的数据视图&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;建立通用的元模型规范，支持用户自定义扩展，对多源异构数据表进行信息抽象提取，形成统一的元数据层。所有的数据开发完成后发布到数据标准维护的统一的数据目录，通过不同维度的数据目录进行多维筛选，满足各类用户的检索需要，达到资产的可管、可用、可查的目标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;价值二：建立统一的数据认知&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先利用标准完成对多源异构数据的标准化描述，虽然数据在不同系统中的称呼千奇百怪，但只要进入我们的平台都将赋予统一的名姓，使得管理方、开发方、使用方建立统一认知。对于仓外表将数据标准与表字段进行关联，旨在统一含义以及告知未来数据处理的方向；对于仓内表，模型设计之初就需要引用标准，我们知道将数据项进行组合即可得到模型，数据元即为标准数据项池，模型设计时仅需从池子里选取需要的字段进行组合即可组装成想要的模型。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;价值三：建立质量稽核体系&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现有的质量稽核一般是由用户根据业务需求手动设置，不同人员的认知偏差将导致数据质量难以控制。数据标准通过数据元的表示类属性，根据其格式、类型等要求自动生成质量稽核规则，当某张表的字段绑定了数据元时，即可根据数据元的质量信息要求自动生成稽核任务，且保证了源头定义的一致性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;价值四：面向未来的数据治理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们知道，工具的终极目的都是为了降本提效。效率提升是要靠流程规范的，流程足够规范，在某种程度上可实现流程自动流转。因此，未来的数据治理趋势应当侧重于流程自动化以及阶段智能化，而这两点都需要数据标准的支撑。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;阶段智能化期望在流程各阶段提供智能识别能力，比如字段的真实含义（挂载数据标准）、资源所属分类、字段枚举值等，减少人工参与。从短期来看，用户从处理者变为审核者，从长期来看，用户干预的行为反哺识别模型，增加识别准确性，可降低人力成本；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;流程自动化依赖阶段智能化以及人工干预的结果，将各阶段进行串联，上下游尽可能完美对接，当上游阶段达到下游准入条件时，可自动触发流程运作，当然该过程也需要统一上下游语言（即数据标准），在实际实践中，可通过试运行进行验证。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;标准的价值还有很多，限于篇幅不过多赘述，大家可以不断发现标准的应用场景。说完标准的价值了，那么我们该如何建立数据标准呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;3&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p hm_fix=&quot;360:461&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;如何建立数据标准？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在早期的业务发展过程中，企业为了解决当下的业务问题，各业务条线已建设自己个性化的业务系统，在建设的过程中为了保证内部通信，或多或少都已存在局部的数据标准。因此，建设统一的数据标准很大程度上是对局部标准进行收口，一般来说，可收集现行的国家标准或行业标准，将现有标准与国标或行标进行对标，此过程一是可以满足监管需要，二是可大大节省标准制定的人力；另一方面则是考虑所在行业的特点并结合企业的实际需要，逐步构建标准进行推行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体可参考数据标准的建立的6个步骤，分别是：数据标准规划、数据标准制定、数据标准发布、数据标准执行、数据标准检查、数据标准维护。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.1 数据标准规划&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;标准的规划首先需对企业业务和数据进行调研和分析，结合实际的数据标准需求，明确数据标准的范围。再根据实际情况的不同，逐步推进。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.1.1 收集现行标准&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可从业务流程出发，圈定参与业务流程的业务实体，通用的业务实体如人，可收集对应现行的国家标准，如对于公民身份证号码应当遵循强制性标准GB 11643 ,对于性别的代码应当参考推荐性标准GB/T 2261.1的规定，行政区划应当参考GB/T 2260的规定等。具备行业属性的业务实体如商业银行担保物，可参考JR/T 0170.1以及JR/T 0170.2的规定等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.1.2 从局部标准到全局标准 &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于企业各业务条线（部门）已建立的局部标准且不适用于引用现行标准或不存在于现行标准的需要进行收集，对同一业务含义但不同标准描述的项进行评审，在企业内部达成一致，得到最终统一的数据标准。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此过程可包含基础类数据标准统一、参照类标准统一、指标类数据标准统一。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.1.3 发现更多数据标准&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;发现更多标准主要应用于以下情况，一是局部标准不明确也无现行标准适用时，二是企业各业务条线垂直系统较多，数据体量较大，缺乏足够的人力及技术手段，但从总体战略的角度期望制定标准时。应对这种情况可依赖数据标准管理平台（第3节将详细介绍）进行标准的识别及拾取。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;标准的识别及拾取一般存在两种方式：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一种有明确制定某项标准的需求，则通过定义数据元概念（第2.2节详细介绍 ），确定该项数据标准描述的对象类及特性，再通过关键词扫描及智能识别技术，扫描存量数据，识别与该数据元概念一致的数据项集合，对该集合进行探查获取字段类型分布、长度范围、值域分布等，从而构建数据元的表示描述，形成完整的数据标准。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二种是暂无明确制定某项标准的需求，去探索是否需要对某些数据项制定标准。系统对存量数据进行扫描，遍历所选择的数据源类型中的所有字段名，提取达到重复阈值的字段名，对其制定数据标准。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.2 数据标准制定&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.2.1 元数据标准&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;元数据标准主要规范了平台对于各类元数据及资产的表示方式和组织方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.2.1.1 元模型的制定&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据中台是企业数字化转型的基础和中枢系统，将企业全域海量、多源、异构的数据整合资产化，但多源异构数据差异化明显，如何保证数据管理者、使用者、开发者对数据具备统一的认知是亟待解决的问题。良好元模型设计，主旨在于屏蔽底层多源异构系统的复杂度，用统一的语言来描述来自不同应用系统、存储在不同种类数据库的各类数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们知道元数据是描述数据的数据，而元模型则是关于模型的数据描述，根据OMG（对象管理组织）提出的四层元模型结构，可以清晰的表达出四层的关系：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.8512396694214877&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQoY4fPBWtNeODdmCJEUAFiciazw0oibqz1ZibLjBnTBqEPpeTJmk4SUiaNgyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;847&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看出，元数据是个相对的概念，元模型即为元数据的元数据，为了更方便大家理解，这里提供一个实例解释：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7044609665427509&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQoj4LFltQREQBiaMhunuIljFQSibcgIj9TROD3CnMTXD2CF4wmgQjWmGBw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1076&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;元模型不仅限于表元模型、字段元模型，还包含指标元模型、标签元模型等，虽然所描述的元数据种类不同，但管理方法上都是一致的，在实践的过程中，可全部纳入数据标准进行管理，也可在对应的子系统中各自维护。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.2.1.2 命名及编码规则制定&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;命名规则主要用于规范表名、字段名、任务名称、指标名称、标签名称等，指定某个名称应当使用哪些命名要素组成以及以何种排列顺序组成。编码规则主要用户资产编码、数据元内部标识符、标签编码、指标编码等，指定某个编码应当使用何种编码方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此需要指定命名及编码要素范围，一是选取平台已存在的枚举值，如数据分层、主题域或其他已存在的分类枚举；二是用户可自定义常量、自定义枚举值；三是平台提供的可变位序列。通过上述的命名要素，进行排序组合，形成命名及编码规则。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以数据元为例子：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一种编码方式可以为“指定标识（常量）+7位自增序列”，可以编码为DE0000001;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二种编码方式可以按照所在分类进行统一编码，类似于“一级分类编码+二级分类编码+三位自增序列”，比如公民身份号码数据元归属分了为”人员类（01）/信息标识类（001）“，那么可以编码为01001001，其他以此类推。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.2.1.3 数据目录规范制定&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据目录提供灵活的数据组织方式，比如数仓开发人员使用数据分层、主题域来组织数据，对于数据管理者，可能更关注于资产盘点，希望能够按照来源系统、管理部门以及安全分类等多种方案进行管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们在制定数据目录时，需要分析用户的需求场景，在不同场景下为用户提供更合适的数据视角，便于用户取数用数。一般来说，会先提供数据来源分类、数仓设计分类、数据安全分类，分类的描述信息至少要包含分类名称、英文名称、内部编码，以便于在平台其他模块的应用。且分类方案支持用户在后期的管理过程中进行自定义扩充。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.2.2 基础数据标准&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.2.2.1 词根的制定&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;词根是为了标准的命名更加规范统一，最终将被应用到字段命名或其他资产的命名上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;企业可根据自身积累，对词根进行收集，形成自己的词根库，在制定数据元及字典时，可根据输入的中文名称自动根据词根翻译英文名称。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一个完整的词根信息包含英文简称、英文全称、中文全称三个部分，其中文全称支持多个，保证用户在使用词根翻译时相同含义字段能够获取相同的英文简称。另外，为了便于统一管理，需对词根的编码及词根来源进行指定。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.2.2.2 数据元的制定&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据元是基础类数据标准的具象化体现，也是数据标准管理的核心。根据数据标准规划，制定数据元第一种方式是对现行标准进行结构化提取，使用平台进行管理，第二种则是根据自身需要建立企业自己的专业数据元。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;完整的数据元应当由三部分组成，对象类、特性及表示，如下图所示，只有当对象类及其特性绑定了表示时，才能由数据元概念转变为真正的数据元。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对象类：现实世界中的想法、抽象概念或事物的集合，有清楚的边界和含义，并且特性和其行为遵循同样的规则而能够加以标识;，如：车、人、订单等；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;特性：对象类的所有个体所共有的某种性质，如颜色、性别、年龄、价格等；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;表示：值域、数据类型的组合，必要时也包括度量单位或字符集，如：格式、值域、长度等；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其中，值域可通过名称或码值直接给出、也可通过参考资料给出、也可通过绑定数据字典给出。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.6873536299765808&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQoicEhJOr6eI4GFKnRbP4bhHA4PiarrFH8y6pcTJ4Ksu5Bib8y1rujRNe0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;854&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此完整的数据元名称应当为：“对象类词+特性词+表示词”，如人性别代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在理解了数据元的含义后，如何去制定数据元呢？我们可参考GB/T 18391标准的第1~6部分，有兴趣的朋友可以去了解下，这里结合我们的理解给出数据元的结构化描述。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在制定数据元时，我们通常会从6个方面描述数据元的基本属性：标识类属性、定义类属性、关系类属性、表示类属性、管理类属性、附加类属性，如下表，这是一个综合的较为通用的数据元描述模板，在应用过程中需要根据企业实际需要，进行删减补全。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.326086956521739&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQorHwic1CVLd7hvicSZh7Gmt2DCXB6ey9eulEw5sWmKVxUSomOYia0iaUndQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;598&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.2.2.3 数据字典的制定&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据字典是参照类数据标准的具象体现，一般分为原始字典及标准字典，原始字典指源系统或生产系统中某个原始项数据内容的枚举集合，标准数据字典一般用于作为数据元值域而存在，在数据处理过程中需要完成原始字典到标准字典的映射，完成字典标准化工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据字典核心是其码值列表，码值列表至少要包含两项信息：代码、代码描述，必要时可增加说明字段进行补充。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5053908355795148&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQoj1QiaMceQHeicRMInc0fGCauOz21QRjZzelSje2mdib7qfjTMDkgibSh8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;742&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;获得码表的方式：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.2.2.4 数据项分类规范制定&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据项分类与数据目录类似，也是为了满足在不同场景下，对不同对象的分类需求。数据项分类即是对字段级进行分类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在制定数据目录时，需要分析用户的需求场景，在不同场景下为用户提供不同的分类方案。如从管理角度，可以按照描述对象、来源文件进行划分；从数据安全角度可以按照敏感级别、安全级别进行划分等，且分类方案支持用户在后期的管理过程中进行自定义扩充。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在实际应用的过程时，会将具体的分类值关联数据元，再由数据元关联字段，做到快速分类的目的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.2.3 技术标准制定&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.2.3.1 数据类型映射关系&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要记录不同数据源间数据类型的映射关系，便于在数据传输、分发等场景下快速建表，提升数据传输任务的配置效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.2.3.2 异构数据开发模板制定&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要管理不同数据源的DDL语句模板，包含新增、删除、更新等，协助数据开发人员选择对应数据库节点时快速根据模板生成语句。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.3 数据标准发布&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般数据标准建议遵循草案、试用、标准、废止的生命周期流转，但可根据实际情况进行简化。对于数据元、数据字典尽可能遵循此生命周期管理，对于词根、数据分类、元模型等可简化流程，可采取草案、上线、下线的生命周期管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据标准发布是在标准制定完成进入开发完成态后，可提交发布审核，审核通过后将应用于整个系统，若后续需要进行修订，则需修订完成后重新发布最新版本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，发布前需查看版本变化以及影响范围，评估影响后再进行发布生效，并通知相关方进行调整。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.4 数据标准执行&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据标准执行主要分两块，第一块是正在进行数据治理的各个阶段进行应用，第二块是新建系统和历史存在的业务系统的应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据治理过程的应用主要在（涉及数据标准与各个模块的对接，将在第4节详细介绍）：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;元数据：需要从业务属性、技术属性、管理属性三个方面对元数据进行描述，需要定义具体的描述项&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据资产：需要对各类资产进行盘点，需要定义资产编码及命名规范、定义分类依据、上线标准&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据质量：需要建立稽核规则，需要构建质量检测体系&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据安全：需要对数据进行分级分类，需要定义数据项分类依据、敏感信息的识别依据&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;模型设计：需要定义数据模型、数据指标、维度度量等数据的标准&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据传输：需要对接不同种数据源、来源系统，需要制定不同系统、数据源间的交换依据&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据开发：需要定义数据处理依据，字段及字典映射逻辑、各类数据源SQL模板&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;新建的业务系统&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;正在运行的系统&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.5 数据标准检查&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据标准执行后，需要进行落标检查，确认标准执行的情况以及效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可参考相关指标，从标准侧进行标准的引用统计、标准化率统计，从质量侧统计表及字段质量评分，多角度去判断指标执行情况及应用效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3.6 数据标准维护&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;维护数据标准&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;沉淀数据标准&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;4&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p hm_fix=&quot;360:461&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;数据标准产品介绍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在了解了如何建立数据标准后，我们可以着手开始干了。但工欲善其事必先利其器，一个合适的数据标准管理工具可以帮助我们更方便、更高效的制定和管理数据标准。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此我们基于数据标准管理流程、管理内容的分析，并充分考虑不同行业对标准管理需求的不一致性，对数据标准管理产品进行功能设计，本章将详细介绍产品的各个模块。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.1 产品总体架构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.64453125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQo2NUru4ic94qNDNC8mrfkqpqCO9MXEVMokG38UanSOYEGLE9QLGR9Abg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;4.2 产品功能模块&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.2.1 数据标准统计首页&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要包含标准资产统计、标准化情况统计、标准流程统计，全方位评估标准建设及使用情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7931747673216132&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQodAyn7XfibEpOxjhXcGHRT48u5km4tJR5758vNSfJFFOkSibKICsoq1nA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;967&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.2.2 数据标准文件管理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此模块用于管理当前平台参照的各类标准文件，并与已结构化的标准建立联系，保证标准来源的可信。另外，针对已经做过结构化标准提取的文件，将作为平台预置的标准模板，供用户使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQoGL4ka2Lzt6zPNSffa1QczRaZiaIDAcIria5Nmek4MhADJOqofOXI8G5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.2.2.1 数据元管理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据元管理是标准管理核心内容，支持表单及批量导入的方式录入数据元，按照标准生命周期草案、试用、标准、废止对数据元进行管理，支持数据元的批量导出，满足不同场景下查看数据元的需求。定义时也将数据元与稽核规则进行绑定，为质量检测提供依据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，支持数据元不同版本之间的比对，获取版本差异，评估标准变更存在的风险。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.353125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQouBqH0iaj2bCYIlUkgDxdGQGID4eWpXvXLywo0iblgiayFXcDMuRboDfPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQo9jG9hC94jfL19oDMhzdow5z3IuwFWice4vgoqRej4kolIVDINRmBW6A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.2.2.2 数据字典管理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据字典管理内容包含原始字典及标准字典，可以认为原始字典是原始数据项的值域分布， 标准字典是标准数据项的值域分布。原始字典可主动录入，也可通过数据探查的值域分布进行生成；标准字典满足与数据元同样的生命周期管理，也支持批量导入导出操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在后续的实现中，将完成从平台已有数据库中存在的字典表进行拾取，同时维护原始字典与标准字典之间的关系，方便用户在进行数据处理时快速进行字典对标。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.509375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQoxdzXu4h15WhbMjNbeUMkmXicjV2BibibI1FOINFX9wVrdUxTic9Ww1RHXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.2.2.3 词根管理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;词根管理旨在定义英文名称、英文简称、中文名称间的映射关系，为标准的命名提供规范的输入。用户在定义数据元、数据字典或模型字段时，将对输入的中文名称进行拆词，依据词根生成英文名称。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了已支持的词根表单录入外，后续将支持词根的批量导入，帮助用户快速导入已制定好的词根列表。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.51015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQoibwwqTZYXSDgbGNTJiaW3XudPh6zicgdwr4rLlA785lIxgGP4WYuicPVzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.2.2.4 数据项分类管理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据项分类管理提供了三个层级目录类型，第一种管理的是分类目录，用户对分类方案进行归类；第二种管理的是分类方案，它是基于某种数据项分类依据（如描述对象）提供的一种分类方式；第三种是分类值，它归属于分类方案，在这一层将与真正的数据元进行挂载。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此数据项分类支持分类的基本信息管理，也支持对数据元批量进行关联以及解除关联。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.51015625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQoiawud265ia19iaPSr3Eibn61YBQmLVs6HFR6d13ia0q3x2icLtvEjibMTsWyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.2.3 元数据标准管理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.2.3.1 命名及编码规则管理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;命名规则及编码管理要能够将平台中已有的可作为命名要素的枚举值进行收集管理，支持用户添加自定义元素，用户可通过点击或拖拽的方式将元素进行组合形成命名规则及编码规则。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.40130963517305895&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQoLHv6q46a9XvYbibLWzqStfDA6xicUro4EDRW2pFhDEoDaiajrj8mSpjnw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1069&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.2.3.2 数据目录管理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据目录管理与数据项分类管理类似，但分类的对象不同，此处分类主要是对平台各类资产的编目，提供多种视角、多种方案对表、指标、标签等进行分类管理，应用于统一的资产目录进行展示，让资产可理解、可识别、易查找。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.56171875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQoRg5FeSAACh6nd6of7Sv2MnhLbCIyQ2Dn4f3aialVZvnyS6pqMVSeFGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.2.4 技术标准管理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.2.4.1 数据类型映射关系管理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要管理不同数据源间数据类型的映射关系，如下表示例，随着数据源种类的增加，此模块支持多数据源类型交叉映射。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.3347826086956522&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQonTepdX73EaMJf0NvL8EIB964lDmSBFLOQZ9dkjZo1ZGTncn7Oep1lQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;460&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.2.4.2 DDL模板管理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要管理不同数据源的DDL语句模板，包含新增、删除、更新等，在模型设计时或离线开发时进行引用，根据选中的信息，替换模板中的参数。以mysql建表为例：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;sql&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;CREATE TABLE IF NOT EXISTS ${table_name}(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   ${filed_list}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   PRIMARY KEY ( ${pk_filed_name} )&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)ENGINE=InnoDB DEFAULT CHARSET=utf8;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.2.5 标准流程管理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.2.5.1 标准发现&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据标准制定流程，平台提供数据库拾取能力，对标准进行识别，根据识别结果来得出结论 ，即完整的数据元定义。下面是根据数据元概念进行识别的页面参考。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.7978835978835979&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQou8FrqeuOvsaribdk6jl7UJibTCNhhlFJTCI7PtJ5ggkSVB8zWsUZS9zw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.2.5.2 审核管理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;审核管理主要是对标准生命周期流转的申请以及标准的发布申请进行操作，审核人员可根据实际情况评估，选择通过或拒绝。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.45078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQof23HWibRu8layE4SsTxITjcJXdOdpIMiczfchaiaiagXXTuMW0iaoUviaE9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQoesl5aLYj5jgWK4C0hOQ3Sydaq86j23Nb19B1znD3UAfrWplAJQBZZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.2.5.3 标准发布&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;标准发布采取整包发布的方式，若将同一批次的数据元列表发布一个大版本，保证平台的标准参考基线。需要支持查看当前更新的内容，提交发布申请，比对版本差异，支持查看发布历史等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.45078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQoLYZzyMh5nfs9j9Uv6Q5Jzz6hx9GxicSUCNf02yE6cdWSKT17QyibC8kg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.2.6 标准配置&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;标准配置主要是对数据元及数据字典的元模型进行配置管理，我们提供了较为全面的数据标准结构化表示方法，但根据不同行业对标准描述的需要，可能并不需要这么多描述项，因此提供数据标准的元模型配置，用户可根据实际情况进行启用、停用或新增标准的描述项。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.2.6.1 数据元模板配置&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.53515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQoK46xAUnRSysG5P5ZoRMJobv4KbVO1EQPJFqEktoz7pRMRgj525ib6ibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.2.6.2 数据字典模板配置&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.53359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQodhe0K0eJ8qLRrq2ibHGq9gDVrJpEybNWQF83TI0TIJcaAxuB4puZBCg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;5&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p hm_fix=&quot;360:461&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;数据标准和数据中台的结合实践&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在具体实施过程中，我们期望按照“需求-设计-开发-交付”流程进行建设。在需求设计阶段，应对数据现状进行摸排，确定治理范围以及标准的制定范围。从而在后续的设计中能够规范指标及模型设计，从源头上开始控制元数据及数据的质量，指导开发过程的具体实施。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据标准在治理流程中的位置以及跟各模块产生的交互。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.38515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQo6QBmXAGXYh7YBXretf4R757d46PWdoT1dqqgVxVow2AkHrvxVf6CXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.1 数据传输&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据传输承担着将多源异构数据集成到大数据平台以及将平台数据分发到其他库的能力，当目标库无对应表时，需要根据来源表进行建表，但不同数据源间的类型差异，需要人工进行匹配，随着数据源种类的不断增加，靠人的经验进行匹配处理已非常困难。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;标准维护的是不同数据源间类型的映射关系，在建立传输任务时，可根据映射关系快速生成目标表结构，达到快速建表、一键建表的能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5977984758679086&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQoQU20ofESMCSic93O8icmKogk5vPWZ30X8VFiatRQjxAPekaJr8E3xAsvA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1181&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.2 元数据&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;元模型的配置在我们的实践中主要包含对元模型分组管理、系统内置项管理、用户自定义项管理，目前已支持对表、字段、指标、标签的元模型设计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.2.1 表元模型设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5.2.1.1 分组管理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.534375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQobiaXDdVeBLnBpYTlQsc5GiaFyc8VIjUk7O5VKvhz4sgcicSvX1pG2n7Mw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5.2.1.2 系统内置项管理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQoOCwKAHMn0gTCOAK3Kf7ibRtSXb2jBibmKtoaqJmOiczRmvwEcG95axuyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5.2.1.3 自定义项管理&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.534375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQoddWZA97JskhmIiaEZibhJcaUyPicJtbAbtzI14Ln6y3zsEeBSokUQ0pmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5.2.2 字段元模型设计&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.53203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQoKuN71iaLIdLIEj7BmHwhojg5B4ksus4G7Xqq5a56Tutia4RSNqX57K1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.2.2 指标元模型设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.534375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQoaUIS9OnAxkAXFRdVQXEzGppM4OJK0WoMtOcxUWIDr4CHibsGgCXCzfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.2.3 标签元模型设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.534375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQoE1r2xm9z6Bjlq59KUuub6KFrwvJtx8ln6nI9L6wZMRI8mofN5rXUTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.3 模型设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.3.1 分层规划&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了系统内置的分层外，用户可添加自定义分层&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;1.163141993957704&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQoXb6NnAwrVxvAdZxgKTbfoEjRia0m5BzSSMmJTYue9c52icYuegWCS1ibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;331&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于分层下的表，需要配置表名设计规范，将选取命名要素按照一定顺序排列，得到命名规则&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.050514499532273154&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQoAicwhzsA394lqSxzWgSGoGcxuswYBSFgKibng45yZWOibGHOJliak57kpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1069&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.3.2 分类规划&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;利用数据目录管理进行分类规划，在资源目录、资产侧按照场景对数据资源进行编目，满足各类用户查数用数需求。如：主题域划分、来源系统划分、安全分类等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.3.3 表结构及数据项标准设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;设计表结构时，一方面根据填写的中文描述，自动推荐对应的数据元（若标准存在），另一方面可直接选择数据元，平台将根据选择的数据元自动回填字段名、字段类型、字段描述以及关联的标准数据字典，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5960629921259842&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQoEnlUDIcYoMxiavlVp5MNElmcb6sdJKtE0SItwbwuyNgs2Mic3veRAl3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1270&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体应用一般放在模型设计中心添加字段时进行关联：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.19765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQoRSsICaNOHoZdeqicUeZXZwYqUVecZ4eKAFENfZIiaPI2NDkqcIhhhZxg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.4 数据开发&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SQL编辑时根据选择的输入输出表，通过表字段关联的数据元信息，将相同含义的字段自动进行映射，快速生成SQL，用户只需对生成的SQL进行确认即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在后续的规划中，标准将助力可视化ETL以及自动化ETL，协助用户进行字段映射，根据数据元关联的稽核规则、脱敏规则等，自动获取对应的处理函数，即可生成开发脚本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.5 数据质量&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据标准是数据质量稽核规则的主要参考依据，通过将数据质量稽核规则与数据标准关联，一方面可以实现字段级的数据质量校验，另一方面也可以直接构建较为通用的数据质量稽核规则体系，确保规则的全面性和可用性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.38515625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQoEq8ibLLRtQGXqz1banJkRX9CrUiczQfW9dST5OthbMLUYtCmPJla06MA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.17421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQovZ7ChNWk4Q3lWIDOE3VTGsnM6ne1Gpo2l04iaEibRG7RYSOFSyXAicOmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;5.6 数据安全&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据标准可包含业务敏感数据对象和属性，从而实现对数据安全管理相关规则的定义。通过数据元关联，快速生成字段级加密或脱敏规则。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.38203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOUglYNiaj7ZSDL3L9ZkK8cQoggb1rEViaGb8hxdsDjeAGXeymoudW87tOF2uP9Qe9GibRvia1Uc0EWm4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;86134&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-original-title=&quot;&quot; title=&quot;&quot;&gt;6&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section data-width=&quot;20%&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;p hm_fix=&quot;360:461&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-brushtype=&quot;text&quot;&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据标准的建设及管理任重而道远，后续将逐步扩展标准的应用场景，满足各行业客户的需求。随着管理内容的不断丰富，管理流程的不断完善，标准将作为数据中台的基石，为各模块、各流程阶段提供规范性指导及监督。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;101582&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;作者简介&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p hm_fix=&quot;322:369&quot;&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzIwNTUxNTI1Ng==&amp;amp;mid=2247487968&amp;amp;idx=1&amp;amp;sn=bad151ae6714e6821e934b15fc1a0816&amp;amp;chksm=972ee177a0596861c07fc1eddb9eb6e7073d6b65081824c84ef25d86b9afadaf2628a5ebc715&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;破浪人丨找数据如何更准更快？这个95年小哥哥有奇招~&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;破浪人丨找数据如何更准更快？这个95年小哥哥有奇招~&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzIwNTUxNTI1Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/sYBGQlzfEOV4Bfic2e5zqTMCl0XxmMuVq1XpDOBrbXicVB4KmrEXglsWcnMREoQXfX24sscdvQIR74ic3SiciaLoMFA/0?wx_fmt=png&quot; data-nickname=&quot;网易有数&quot; data-alias=&quot;Youdata_Netease&quot; data-signature=&quot;网易有数是网易数帆旗下大数据技术与服务品牌，以“数据价值”为导向，聚焦于企业 “看数”、“管数”、“用数”等业务场景，提供全链路大数据技术及产品服务，致力于盘活企业数据生产力，加速实现数字化转型。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;__bg_gif rich_pages wxw-img&quot; data-fileid=&quot;100003451&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/sYBGQlzfEOXECeWKgyIia3c7bom7Ir4rh4qI4XdxuRW4lyHudFyglytmLrOM4yYOWs3XNqqj0XlXTEw8icZ2Eb1Q/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot; hm_fix=&quot;317:401&quot;&gt;分享，点赞，在看，安排一下？&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>