<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>30f404611444e1bd442941270c7e7ad4</guid>
<title>细说 Kafka Partition 分区</title>
<link>https://toutiao.io/k/kw76t1v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Partition（分区）是 Kafka 的核心角色，对于 Kafka 的存储结构、消息的生产消费方式都至关重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;掌握好 Partition 就可以更快的理解 Kafka。本文会讲解 Partition 的概念、结构，以及行为方式。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、Events, Streams, Topics&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在深入 Partition 之前，我们先看几个更高层次的概念，以及它们与 Partition 的联系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Event&lt;/strong&gt;（事件）代表过去发生的一个事实。简单理解就是一条消息、一条记录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Event 是不可变的，但是很活跃，经常从一个地方流向另一个地方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;Stream&lt;/strong&gt; 事件流表示运动中的相关事件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一个事件流进入 Kafka 之后，它就成为了一个 &lt;strong&gt;Topic&lt;/strong&gt; 主题。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5565789473684211&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl92jPCtqDryrqzialkGL0P3CuxEUsNFkfODicHd54NTribBconiaEHedNFYBVd4zH41TFVlhxpyp5ZgRTA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1520&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，Topic 就是具体的事件流，也可以理解为一个 Topic 就是一个静止的 Stream。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Topic 把相关的 Event 组织在一起，并且保存。一个 Topic 就像数据库中的一张表。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、Partition 分区&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4814305364511692&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl92jPCtqDryrqzialkGL0P3CuhM5SuLc7OIfwibKZ1CIIc5hf6lNByI6lgFkYLRnNHiaqunVINUmktJhg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1454&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 中 Topic 被分成多个 Partition 分区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Topic 是一个&lt;strong&gt;逻辑概念&lt;/strong&gt;，Partition 是最小的&lt;strong&gt;存储单元&lt;/strong&gt;，掌握着一个 Topic 的部分数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个 Partition 都是一个单独的 log 文件，每条记录都以追加的形式写入。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5294117647058824&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl92jPCtqDryrqzialkGL0P3Cu1nia1GNiaMxDFbJmWVOAicdgALMxvf2L4JoAzt7BiaMaqAib2ftz6FAJk3A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;561&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;Record（记录） 和 Message（消息）是一个概念。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、Offsets（偏移量）和消息的顺序&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Partition 中的每条记录都会被分配一个唯一的序号，称为 &lt;strong&gt;Offset&lt;/strong&gt;（偏移量）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Offset 是一个递增的、不可变的数字，由 Kafka 自动维护。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当一条记录写入 Partition 的时候，它就被追加到 log 文件的末尾，并被分配一个序号，作为 Offset。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8452722063037249&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl92jPCtqDryrqzialkGL0P3CuPicicAqYFcJ4zYxowD5wxFhvQPq7qQOSJibleW4Qq9e9kpyUIQdp6KQBA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;698&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图，这个 Topic 有 3 个 Partition 分区，向 Topic 发送消息的时候，实际上是被写入某一个 Partition，并赋予 Offset。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息的顺序性需要注意，一个 Topic 如果有多个 Partition 的话，那么从 Topic 这个层面来看，消息是无序的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但单独看 Partition 的话，Partition 内部消息是有序的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，一个 Partition 内部消息有序，一个 Topic 跨 Partition 是无序的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果强制要求 Topic 整体有序，就只能让 Topic 只有一个 Partition。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;四、Partition 为 Kafka 提供了扩展能力&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5442622950819672&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl92jPCtqDryrqzialkGL0P3Cu31iaibt3FokPlyTSVMfNBprydoVjTf5JM326tCLr9YTiatSbm2ibNrN2lw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1220&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个 Kafka 集群由多个 Broker（就是 Server） 构成，每个 Broker 中含有集群的部分数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 把 Topic 的多个 Partition 分布在多个 Broker 中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样会有多种好处：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果把 Topic 的所有 Partition 都放在一个 Broker 上，那么这个 Topic 的可扩展性就大大降低了，会受限于这个 Broker 的 IO 能力。把 Partition 分散开之后，Topic 就可以水平扩展 。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个 Topic 可以被多个 Consumer 并行消费。如果 Topic 的所有 Partition 都在一个 Broker，那么支持的 Consumer 数量就有限，而分散之后，可以支持更多的 Consumer。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个 Consumer 可以有多个实例，Partition 分布在多个 Broker 的话，Consumer 的多个实例就可以连接不同的 Broker，大大提升了消息处理能力。可以让一个 Consumer 实例负责一个 Partition，这样消息处理既清晰又高效。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;五、Partition 为 Kafka 提供了数据冗余&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 为一个 Partition 生成多个副本，并且把它们分散在不同的 Broker。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个 Broker 故障了，Consumer 可以在其他 Broker 上找到 Partition 的副本，继续获取消息。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;六、写入 Partition&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个 Topic 有多个 Partition，那么，向一个 Topic 中发送消息的时候，具体是写入哪个 Partition 呢？有3种写入方式。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1. 使用 Partition Key 写入特定 Partition&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2647058823529412&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl92jPCtqDryrqzialkGL0P3CuTpL6glziazJjdMN8x57924ys74DC4mGKwCw9icMibszDAoM2eSgqt7DkQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;782&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Producer 发送消息的时候，可以指定一个 Partition Key，这样就可以写入特定 Partition 了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Partition Key 可以使用任意值，例如设备ID、User ID。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Partition Key 会传递给一个 Hash 函数，由计算结果决定写入哪个 Partition。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，有相同 Partition Key 的消息，会被放到相同的 Partition。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如使用 User ID 作为 Partition Key，那么此 ID 的消息就都在同一个 Partition，这样可以保证此类消息的有序性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式需要注意 Partition &lt;strong&gt;热点问题&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如使用 User ID 作为 Partition Key，如果某一个 User 产生的消息特别多，是一个头部活跃用户，那么此用户的消息都进入同一个 Partition 就会产生热点问题，导致某个 Partition 极其繁忙。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. 由 kafka 决定&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果没有使用 Partition Key，Kafka 就会使用轮询的方式来决定写入哪个 Partition。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样，消息会均衡的写入各个 Partition。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但这样无法确保消息的有序性。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3. 自定义规则&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 支持自定义规则，一个 Producer 可以使用自己的分区指定规则。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;七、读取 Partition&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 不像普通消息队列具有发布/订阅功能，Kafka 不会向 Consumer 推送消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Consumer 必须自己从 Topic 的 Partition 拉取消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个 Consumer 连接到一个 Broker 的 Partition，从中依次读取消息。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8515769944341373&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl92jPCtqDryrqzialkGL0P3CuyGmAw7o61GPUGN3F8L1jHt8wq9w3K9IjHjs56SgiaibcdbocuKcPIJwg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;539&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息的 Offset 就是 Consumer 的游标，根据 Offset 来记录消息的消费情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读完一条消息之后，Consumer 会推进到 Partition 中的下一个 Offset，继续读取消息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Offset 的推进和记录都是 Consumer 的责任，Kafka 是不管的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5316455696202531&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl92jPCtqDryrqzialkGL0P3Cu3HhC9CNGOcbeBzGxAIvwgVGBFicH6DrWATTnqrj6EeibPGRpYhwRLseA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;474&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kafka 中有一个 Consumer Group（消费组）的概念，多个 Consumer 组团去消费一个 Topic。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同组的 Consumer 有相同的 Group ID。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Consumer Group 机制会保障一条消息只被组内唯一一个 Consumer 消费，不会重复消费。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消费组这种方式可以让多个 Partition 并行消费，大大提高了消息的消费能力，最大并行度为 Topic 的 Partition 数量。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8160291438979964&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/wv3K6j4ibl92jPCtqDryrqzialkGL0P3CuSs4kQ7WQRb6icicnUuu7ibNebewGbzxs7GlRqxA7iciaPSOCfhYXcJjQwkg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;549&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如一个 Topic 有 3 个 Partition，你有 4 个 Consumer 负责这个 Topic，也只会有 Consumer 工作，另一个作为后补队员，当某个 Consumer 故障了，它再补上去，是一种很好的容错机制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考资料&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://medium.com/event-driven-utopia/understanding-kafka-topic-partitions-ae40f80552e8&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fb130e187ce769ac05a78fa4c9a8cc3d</guid>
<title>还不会使用分布式锁？从零开始基于 etcd 实现分布式锁</title>
<link>https://toutiao.io/k/5xw6p4n</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么需要分布式锁？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在单进程的系统中，当存在多个线程可以同时改变某个变量时，就需要对变量或代码块做同步，使其在修改这种变量时能够线性执行消除并发修改变量。而同步本质上通过锁来实现。为了实现多个线程在一个时刻同一个代码块只能有一个线程可执行，那么需要在某个地方做个标记，这个标记必须每个线程都能看到，当标记不存在时可以设置该标记，其余后续线程发现已经有标记了则等待拥有标记的线程结束同步代码块取消标记后再去尝试设置标记。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在分布式环境下，数据一致性问题一直是难点。相比于单进程，分布式环境的情况更加复杂。分布式与单机环境最大的不同在于其不是多线程而是多进程。多线程由于可以共享堆内存，因此可以简单的采取内存作为标记存储位置。而进程之间甚至可能都不在同一台物理机上，因此需要将标记存储在一个所有进程都能看到的地方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的是秒杀场景，订单服务部署了多个服务实例。如秒杀商品有 4 个，第一个用户购买 3 个，第二个用户购买 2 个，理想状态下第一个用户能购买成功，第二个用户提示购买失败，反之亦可。而实际可能出现的情况是，两个用户都得到库存为 4，第一个用户买到了 3 个，更新库存之前，第二个用户下了 2 个商品的订单，更新库存为 2，导致业务逻辑出错。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的场景中，商品的库存是共享变量，面对高并发情形，需要保证对资源的访问互斥。在单机环境中，比如 Java 语言中其实提供了很多并发处理相关的 API，但是这些 API 在分布式场景中就无能为力了，由于分布式系统具备多线程和多进程的特点，且分布在不同机器中，synchronized 和 lock 关键字将失去原有锁的效果，。仅依赖这些语言自身提供的 API 并不能实现分布式锁的功能，因此需要我们想想其它方法实现分布式锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的锁方案如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;基于数据库实现分布式锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基于 Zookeeper 实现分布式锁&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基于缓存实现分布式锁，如 redis、etcd 等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面我们简单介绍下这几种锁的实现，并重点介绍 etcd 实现锁的方法。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基于数据库的锁&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于数据库的锁实现也有两种方式，一是基于数据库表，另一种是基于数据库的排他锁。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;基于数据库表的增删&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于数据库表增删是最简单的方式，首先创建一张锁的表主要包含下列字段：方法名，时间戳等字段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体使用的方法为：当需要锁住某个方法时，往该表中插入一条相关的记录。需要注意的是，方法名有唯一性约束。如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，可以执行方法体内容。执行完毕，需要删除该记录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于上述方案可以进行优化，如应用主从数据库，数据之间双向同步。一旦主库挂掉，将应用服务快速切换到从库上。除此之外还可以记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给该线程，实现可重入锁。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;基于数据库排他锁&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还可以通过数据库的排他锁来实现分布式锁。基于 Mysql 的 InnoDB 引擎，可以使用以下方法来实现加锁操作：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;lock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;    connection.setAutoCommit(&lt;span&gt;false&lt;/span&gt;)&lt;br/&gt;    &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt;(count &amp;lt; &lt;span&gt;4&lt;/span&gt;){&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt;{&lt;br/&gt;            select * from lock where lock_name=xxx &lt;span&gt;for&lt;/span&gt; update;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt;(结果不为空){&lt;br/&gt;                &lt;span&gt;//代表获取到锁&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;        }&lt;span&gt;catch&lt;/span&gt;(Exception e){&lt;br/&gt;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//为空或者抛异常的话都表示没有获取到锁&lt;/span&gt;&lt;br/&gt;        sleep(&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;        count++;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; LockException();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在查询语句后面增加 &lt;code&gt;for update&lt;/code&gt;，数据库会在查询过程中给数据库表增加排他锁。当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。其他没有获取到锁的就会阻塞在上述 select 语句上，可能的结果有 2 种，在超时之前获取到了锁，在超时之前仍未获取到锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;获得排它锁的线程即可获得分布式锁，当获取到锁之后，可以执行业务逻辑，执行完业务之后释放锁。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;基于数据库锁的总结&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面两种方式都是依赖数据库的一张表，一种是通过表中的记录的存在情况确定当前是否有锁存在，另外一种是通过数据库的排他锁来实现分布式锁。优点是直接借助现有的关系型数据库，简单且容易理解；缺点是操作数据库需要一定的开销，性能问题以及 SQL 执行超时的异常需要考虑。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基于 Zookeeper&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于 Zookeeper 的临时节点和顺序特性可以实现分布式锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;申请对某个方法加锁时，在 Zookeeper 上与该方法对应的指定节点的目录下，生成一个唯一的临时有序节点。当需要获取锁时，只需要判断有序节点中该节点是否为序号最小的一个。业务逻辑执行完成释放锁，只需将这个临时节点删除即可。这种方式也可以避免由于服务宕机导致的锁无法释放，而产生的死锁问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Netflix 开源了一套 Zookeeper 客户端框架 curator，你可以自行去看一下具体使用方法。Curator 提供的 InterProcessMutex 是分布式锁的一种实现。acquire 方法获取锁，release 方法释放锁。另外，锁释放、阻塞锁、可重入锁等问题都可以有效解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于阻塞锁的实现，客户端可以通过在 Zookeeper 中创建顺序节点，并且在节点上绑定监听器 Watch。一旦节点发生变化，Zookeeper 会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是就获取到锁，便可以执行业务逻辑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Zookeeper 实现的分布式锁也存在一些缺陷。在性能上可能不如基于缓存实现的分布式锁。因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，Zookeeper 中创建和删除节点只能通过 Leader 节点来执行，然后将数据同步到集群中的其他节点。分布式环境中难免存在网络抖动，导致客户端和 Zookeeper 集群之间的 session 连接中断，此时 Zookeeper 服务端以为客户端挂了，就会删除临时节点。其他客户端就可以获取到分布式锁了，导致了同时获取锁的不一致问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;基于缓存实现分布式锁&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相对于基于数据库实现分布式锁的方案来说，基于缓存来实现在性能方面会表现的更好一点，存取速度快很多。而且很多缓存是可以集群部署的，可以解决单点问题。基于缓存的锁有好几种，如memcached、redis、本文下面主要讲解基于 etcd 实现分布式锁。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;通过 etcd txn 实现分布式锁&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 etcd 实现分布式锁，同样需要满足一致性、互斥性和可靠性等要求。etcd 中的事务 txn、lease 租约以及 watch 监听特性，能够使得基于 etcd 实现上述要求的分布式锁。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;思路分析&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 etcd 的事务特性可以帮助我们实现一致性和互斥性。etcd 的事务特性，使用的 &lt;code&gt;IF-Then-Else&lt;/code&gt; 语句，IF 语言判断 etcd 服务端是否存在指定的 key，即该 key 创建版本号 create_revision 是否为 0 来检查 key 是否已存在，因为该 key 已存在的话，它的 create_revision 版本号就不是 0。满足 IF 条件的情况下则使用 then 执行 put 操作，否则 else 语句返回抢锁失败的结果。当然，除了使用 key 是否创建成功作为 IF 的判断依据，还可以创建前缀相同的 key，比较这些 key 的 revision 来判断分布式锁应该属于哪个请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端请求在获取到分布式锁之后，如果发生异常，需要及时将锁给释放掉。因此需要租约，当我们申请分布式锁的时候需要指定租约时间。超过 lease 租期时间将会自动释放锁，保证了业务的可用性。是不是这样就够了呢？在执行业务逻辑时，如果客户端发起的是一个耗时的操作，操作未完成的请情况下，租约时间过期，导致其他请求获取到分布式锁，造成不一致。这种情况下则需要续租，即刷新租约，使得客户端能够和 etcd 服务端保持心跳。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;具体实现&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们基于如上分析的思路，绘制出实现 etcd 分布式锁的流程图，如下所示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.219560878243513&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Pd1oo3TBKyekFvVH8qWMm0mvbjnzkAI0Eiah5S2kAWOiayiaU43dfdwZlibichRuxd1Zp47xBSxTVKicawzMvkc8iaZIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;501&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于 Go 语言实现的 etcd 分布式锁，测试代码如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;TestLock&lt;/span&gt;&lt;span&gt;(t *testing.T)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// 客户端配置&lt;/span&gt;&lt;br/&gt; config = clientv3.Config{&lt;br/&gt;  Endpoints:   []&lt;span&gt;string&lt;/span&gt;{&lt;span&gt;&quot;localhost:2379&quot;&lt;/span&gt;},&lt;br/&gt;  DialTimeout: &lt;span&gt;5&lt;/span&gt; * time.Second,&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 建立连接&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; client, err = clientv3.New(config); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  fmt.Println(err)&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 1. 上锁并创建租约&lt;/span&gt;&lt;br/&gt; lease = clientv3.NewLease(client)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; leaseGrantResp, err = lease.Grant(context.TODO(), &lt;span&gt;5&lt;/span&gt;); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;panic&lt;/span&gt;(err)&lt;br/&gt; }&lt;br/&gt; leaseId = leaseGrantResp.ID&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 2 自动续约&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// 创建一个可取消的租约，主要是为了退出的时候能够释放&lt;/span&gt;&lt;br/&gt; ctx, cancelFunc = context.WithCancel(context.TODO())&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 3. 释放租约&lt;/span&gt;&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; cancelFunc()&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; lease.Revoke(context.TODO(), leaseId)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; keepRespChan, err = lease.KeepAlive(ctx, leaseId); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;panic&lt;/span&gt;(err)&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 续约应答&lt;/span&gt;&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;select&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; keepResp = &amp;lt;-keepRespChan:&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; keepRespChan == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;     fmt.Println(&lt;span&gt;&quot;租约已经失效了&quot;&lt;/span&gt;)&lt;br/&gt;     &lt;span&gt;goto&lt;/span&gt; END&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; { &lt;span&gt;// 每秒会续租一次, 所以就会受到一次应答&lt;/span&gt;&lt;br/&gt;     fmt.Println(&lt;span&gt;&quot;收到自动续租应答:&quot;&lt;/span&gt;, keepResp.ID)&lt;br/&gt;    }&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; END:&lt;br/&gt; }()&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 1.3 在租约时间内去抢锁（etcd 里面的锁就是一个 key）&lt;/span&gt;&lt;br/&gt; kv = clientv3.NewKV(client)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 创建事务&lt;/span&gt;&lt;br/&gt; txn = kv.Txn(context.TODO())&lt;br/&gt;&lt;br/&gt; &lt;span&gt;//if 不存在 key，then 设置它，else 抢锁失败&lt;/span&gt;&lt;br/&gt; txn.If(clientv3.Compare(clientv3.CreateRevision(&lt;span&gt;&quot;lock&quot;&lt;/span&gt;), &lt;span&gt;&quot;=&quot;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)).&lt;br/&gt;  Then(clientv3.OpPut(&lt;span&gt;&quot;lock&quot;&lt;/span&gt;, &lt;span&gt;&quot;g&quot;&lt;/span&gt;, clientv3.WithLease(leaseId))).&lt;br/&gt;  Else(clientv3.OpGet(&lt;span&gt;&quot;lock&quot;&lt;/span&gt;))&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 提交事务&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; txnResp, err = txn.Commit(); err != &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;panic&lt;/span&gt;(err)&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; !txnResp.Succeeded {&lt;br/&gt;  fmt.Println(&lt;span&gt;&quot;锁被占用:&quot;&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;(txnResp.Responses[&lt;span&gt;0&lt;/span&gt;].GetResponseRange().Kvs[&lt;span&gt;0&lt;/span&gt;].Value))&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 抢到锁后执行业务逻辑，没有抢到退出&lt;/span&gt;&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;处理任务&quot;&lt;/span&gt;)&lt;br/&gt; time.Sleep(&lt;span&gt;5&lt;/span&gt; * time.Second)&lt;br/&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;预期的执行结果如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;=== RUN   TestLock&lt;br/&gt;处理任务&lt;br/&gt;收到自动续租应答: 7587848943239472601&lt;br/&gt;收到自动续租应答: 7587848943239472601&lt;br/&gt;收到自动续租应答: 7587848943239472601&lt;br/&gt;--- PASS: TestLock (5.10s)&lt;br/&gt;PASS&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总得来说，如上关于 etcd 分布式锁的实现过程分为四个步骤：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;客户端初始化与建立连接；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建租约，自动续租；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;创建事务，获取锁；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;执行业务逻辑，最后释放锁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建租约的时候，需要创建一个可取消的租约，主要是为了退出的时候能够释放。释放锁对应的步骤，在上面的 defer 语句中。当 defer 租约关掉的时候，分布式锁对应的 key 就会被释放掉了。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要介绍了基于 etcd 实现分布式锁的案例。首先介绍了分布式锁产生的背景以及必要性，分布式架构不同于单体架构，涉及到多服务之间多个实例的调用，跨进程的情况下使用编程语言自带的并发原语没有办法实现数据的一致性，因此分布式锁出现，用来解决分布式环境中的资源互斥操作。接着介绍了基于数据库实现分布式锁的两种方式：数据表增删和数据库的排它锁。基于 Zookeeper 的临时节点和顺序特性也可以实现分布式锁，这两种方式或多或少存在性能和稳定性方面的缺陷。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着本文重点介绍了基于 etcd 实现分布式锁的方案，根据 etcd 的特点，利用事务 txn、lease 租约以及 watch 监测实现分布式锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我们上面的案例中，抢锁失败，客户端就直接返回了。那么当该锁被释放之后，或者持有锁的客户端出现了故障退出了，其他锁如何快速获取锁呢？所以上述代码可以基于 watch 监测特性进行改进，各位同学可以自行试试。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;订阅最新文章，欢迎关注我的公众号&lt;/h4&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzU1OTIzOTE0Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/Pd1oo3TBKyduNg189ju8TeFTgRTRzTzyttRZQoibyib4spdfR0zB5qXh4Mgvj28iblR16kic2LZVR4lqRUCOBKxZeA/0?wx_fmt=png&quot; data-nickname=&quot;aoho求索&quot; data-alias=&quot;aohoBlog&quot; data-signature=&quot;aoho 求索是一个分享服务端开发技术的公众号，主要涉及 Java、Golang 等语言，介绍微服务架构和高并发相关的实践。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>edc876d5c4e99d9084512ad70932bacb</guid>
<title>民族工业软件之殇</title>
<link>https://toutiao.io/k/cip5d5f</link>
<content:encoded>&lt;div&gt;&lt;body id=&quot;readabilityBody&quot;/&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>965a5088eeb56fd96ebfad2e3dab088e</guid>
<title>全方位深度解读 Elasticsearch 分页查询</title>
<link>https://toutiao.io/k/22smd1p</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、关于 Elasticsearch 分页查询，这几个问题经常被问到&lt;/span&gt;&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;问题1：想请问下，一次性获取索引上的某个字段的所有值（100 万左右），除了把 max_result_window 调大 ，还有没有啥方法？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;问题2：关于 es 的分页，每次拿 20 条展示在前台，然后点击下一页，在查询后面的20条数据，应该要怎么写？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;问题3：From+size、Scroll、search_after 的本质区别和应用场景分别是什么？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、 Elasticsearch 支持的三种分页查询方式&lt;/span&gt;&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;From + Size 查询&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Search After 查询&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;Scroll 查询&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下面我就三种方式的联系与区别、优缺点、适用场景等展开进行解读。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1 From + size 分页查询&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1.1 From + size 分页查询定义与实战案例&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如下基础查询：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;GET kibana_sample_data_flights/_search&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;默认返回前10个匹配的匹配项。其中：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;from：未指定，默认值是 0，注意不是1，代表当前页返回数据的起始值。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;size：未指定，默认值是 10，代表当前页返回数据的条数。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如下指定条件查询和排序：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;GET kibana_sample_data_flights/_search&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;from&quot;&lt;/span&gt;: 0,&lt;br/&gt;  &lt;span&gt;&quot;size&quot;&lt;/span&gt;:20,&lt;br/&gt;  &lt;span&gt;&quot;query&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;match&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;DestWeather&quot;&lt;/span&gt;: &lt;span&gt;&quot;Sunny&quot;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;sort&quot;&lt;/span&gt;: [&lt;br/&gt;    {&lt;br/&gt;      &lt;span&gt;&quot;FlightTimeHour&quot;&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;&quot;order&quot;&lt;/span&gt;: &lt;span&gt;&quot;desc&quot;&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;  ]&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;共返回 20 条数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其中：from + size 两个参数定义了结果页面显示数据的内容。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1.2 From + size 查询优缺点及适用场景&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;From + size 查询优点&lt;/span&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;From + size 查询缺点&lt;/span&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;受制于 max_result_window 设置，不能无限制翻页。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;存在深度翻页问题，越往后翻页越慢。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;From + size 查询适用场景&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第一：非常适合小型数据集或者大数据集返回 Top N（N &amp;lt;= 10000）结果集的业务场景。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第二：类似主流 PC 搜索引擎（谷歌、bing、百度、360、sogou等）支持随机跳转分页的业务场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.08310991957104558&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9Y3yWkiaGtXn81CNLDGmNp7eekAIh9du3iaqWJwZ7rJfSiccpFDSyKqDwX9ysgAHk4wANlVeccHTx4qg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;746&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1.3 深度翻页不推荐使用 From + size&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Elasticsearch 会限制最大分页数，避免大数据量的召回导致性能低下。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Elasticsearch 的 max_result_window 默认值是：10000。也就意味着：如果每页有 10 条数据，会最大翻页至 1000 页。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实际主流搜索引擎都翻不了那么多页，举例：百度搜索“上海”，翻到第 76 页，就无法再往下翻页了，提示信息如下截图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.35153129161118507&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9Y3yWkiaGtXn81CNLDGmNp7epOQSZH5W8ibmn5xlt4pC3UTsVfic9jKRKzsnt0H8VsQteG7mVTjAob1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;751&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如下的分页查询&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;GET kibana_sample_data_flights/_search&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;from&quot;&lt;/span&gt;: 0,&lt;br/&gt;  &lt;span&gt;&quot;size&quot;&lt;/span&gt;:10001&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;GET kibana_sample_data_flights/_search&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;from&quot;&lt;/span&gt;: 10001,&lt;br/&gt;  &lt;span&gt;&quot;size&quot;&lt;/span&gt;:10&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;报错如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;{&lt;br/&gt;  &lt;span&gt;&quot;error&quot;&lt;/span&gt; : {&lt;br/&gt;    &lt;span&gt;&quot;root_cause&quot;&lt;/span&gt; : [&lt;br/&gt;      {&lt;br/&gt;        &lt;span&gt;&quot;type&quot;&lt;/span&gt; : &lt;span&gt;&quot;illegal_argument_exception&quot;&lt;/span&gt;,&lt;br/&gt;        &lt;span&gt;&quot;reason&quot;&lt;/span&gt; : &lt;span&gt;&quot;Result window is too large, from + size must be less than or equal to: [10000] but was [10001]. See the scroll api for a more efficient way to request large data sets. This limit can be set by changing the [index.max_result_window] index level setting.&quot;&lt;/span&gt;&lt;br/&gt;      }&lt;br/&gt;    ],&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么原因？超过了最大窗口的限制，index.max_result_window 默认值为10000。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;报错信息还同时给出了两个解决方案：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;方案一：大数据集召回数据使用：scroll api。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;后面会详细讲解。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;方案二：调大 index.max_result_window 默认值。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;PUT kibana_sample_data_flights/_settings&lt;br/&gt;{&lt;br/&gt;    &lt;span&gt;&quot;index.max_result_window&quot;&lt;/span&gt;:50000&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;官方建议&lt;/strong&gt;：避免过度使用 from 和 size 来分页或一次请求太多结果。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不推荐使用 from + size 做深度分页查询的核心原因：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;搜索请求通常跨越多个分片，每个分片必须将其请求的命中内容以及任何先前页面的命中内容加载到内存中。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;对于翻页较深的页面或大量结果，这些操作会显著增加内存和 CPU 使用率，从而导致性能下降或节点故障。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;什么意思呢？&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;GET kibana_sample_data_flights/_search&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;from&quot;&lt;/span&gt;: 10001,&lt;br/&gt;  &lt;span&gt;&quot;size&quot;&lt;/span&gt;: 10&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;共 10 条数据加载到内存吗？不是的！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;共：10011 条数据加载到内存，然后经过后台处理后返回了最后 10 条我们想要的数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那也就意味着，越往后翻页（也就是深度翻页）需要加载的数据量越大，势必会越耗费 CPU + 内存资源，响应也会越慢！&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2 search_after 查询&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2.1 search_after 查询定义与实战案例&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;search_after 查询&lt;strong&gt;本质&lt;/strong&gt;：使用前一页中的一组排序值来检索匹配的下一页。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前置条件：使用 search_after 要求后续的多个请求返回与第一次查询相同的排序结果序列。也就是说，即便在后续翻页的过程中，可能会有新数据写入等操作，但这些操作不会对原有结果集构成影响。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如何实现呢？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;可以创建一个时间点 Point In Time（PIT）保障搜索过程中保留特定事件点的索引状态。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Point In Time（PIT）是 Elasticsearch 7.10 版本之后才有的新特性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;PIT的&lt;strong&gt;本质&lt;/strong&gt;：存储索引数据状态的轻量级视图。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如下示例能很好的解读 PIT 视图的内涵。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# 创建 PIT&lt;/span&gt;&lt;br/&gt;POST kibana_sample_data_logs/_pit?keep_alive=1m&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 获取数据量 14074&lt;/span&gt;&lt;br/&gt;POST kibana_sample_data_logs/_count&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 新增一条数据&lt;/span&gt;&lt;br/&gt;POST kibana_sample_data_logs/_doc/14075&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;test&quot;&lt;/span&gt;:&lt;span&gt;&quot;just testing&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 数据总量为 14075&lt;/span&gt;&lt;br/&gt;POST kibana_sample_data_logs/_count&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 查询PIT，数据依然是14074，说明走的是之前时间点的视图的统计。&lt;/span&gt;&lt;br/&gt;POST /_search&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;track_total_hits&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;, &lt;br/&gt;  &lt;span&gt;&quot;query&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;match_all&quot;&lt;/span&gt;: {}&lt;br/&gt;  }, &lt;br/&gt;   &lt;span&gt;&quot;pit&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;id&quot;&lt;/span&gt;: &lt;span&gt;&quot;48myAwEXa2liYW5hX3NhbXBsZV9kYXRhX2xvZ3MWM2hGWXpxLXFSSGlfSmZIaXJWN0dxUQAWdG1TOWFMTF9UdTZHdVZDYmhoWUljZwAAAAAAAAEN3RZGOFJCMGVrZVNndTk3U1I0SG81V3R3AAEWM2hGWXpxLXFSSGlfSmZIaXJWN0dxUQAA&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有了 PIT，search_after 的后续查询都是基于 PIT 视图进行，能有效保障数据的一致性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;search_after 分页查询可以简单概括为如下几个步骤。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;步骤 1：创建 PIT 视图，这是前置条件不能省。&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# Step 1: 创建 PIT&lt;/span&gt;&lt;br/&gt;POST kibana_sample_data_logs/_pit?keep_alive=5m&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;返回结果如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;{&lt;br/&gt;  &lt;span&gt;&quot;id&quot;&lt;/span&gt; : &lt;span&gt;&quot;48myAwEXa2liYW5hX3NhbXBsZV9kYXRhX2xvZ3MWM2hGWXpxLXFSSGlfSmZIaXJWN0dxUQAWdG1TOWFMTF9UdTZHdVZDYmhoWUljZwAAAAAAAAEg5RZGOFJCMGVrZVNndTk3U1I0SG81V3R3AAEWM2hGWXpxLXFSSGlfSmZIaXJWN0dxUQAA&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;keep_alive=5m，类似scroll的参数，代表视图保留时间是 5 分钟，超过 5 分钟执行会报错如下：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;  &lt;span&gt;&quot;type&quot;&lt;/span&gt; : &lt;span&gt;&quot;search_context_missing_exception&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;reason&quot;&lt;/span&gt; : &lt;span&gt;&quot;No search context found for id [91600]&quot;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;步骤 2：创建基础查询语句，这里要设置翻页的条件。&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# Step 2: 创建基础查询&lt;/span&gt;&lt;br/&gt;GET /_search&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;size&quot;&lt;/span&gt;:10,&lt;br/&gt;  &lt;span&gt;&quot;query&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;match&quot;&lt;/span&gt; : {&lt;br/&gt;      &lt;span&gt;&quot;host&quot;&lt;/span&gt; : &lt;span&gt;&quot;elastic&quot;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;pit&quot;&lt;/span&gt;: {&lt;br/&gt;     &lt;span&gt;&quot;id&quot;&lt;/span&gt;:  &lt;span&gt;&quot;48myAwEXa2liYW5hX3NhbXBsZV9kYXRhX2xvZ3MWM2hGWXpxLXFSSGlfSmZIaXJWN0dxUQAWdG1TOWFMTF9UdTZHdVZDYmhoWUljZwAAAAAAAAEg5RZGOFJCMGVrZVNndTk3U1I0SG81V3R3AAEWM2hGWXpxLXFSSGlfSmZIaXJWN0dxUQAA&quot;&lt;/span&gt;, &lt;br/&gt;     &lt;span&gt;&quot;keep_alive&quot;&lt;/span&gt;: &lt;span&gt;&quot;1m&quot;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;sort&quot;&lt;/span&gt;: [ &lt;br/&gt;    {&lt;span&gt;&quot;response.keyword&quot;&lt;/span&gt;: &lt;span&gt;&quot;asc&quot;&lt;/span&gt;}&lt;br/&gt;  ]&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;设置了PIT，检索时候就不需要再指定索引。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;id 是基于步骤1 返回的 id 值。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;排序 sort 指的是：按照哪个关键字排序。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在每个返回文档的最后，会有两个结果值，如下所示：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt; &lt;span&gt;&quot;sort&quot;&lt;/span&gt; : [&lt;br/&gt;          &lt;span&gt;&quot;200&quot;&lt;/span&gt;,&lt;br/&gt;          4&lt;br/&gt;        ]&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;其中，“200”就是我们指定的排序方式：基于 {&quot;response.keyword&quot;: &quot;asc&quot;} 升序排列。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;而 4 代表什么含义呢？&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;4 代表——隐含的排序值，是基于_shard_doc 的升序排序方式。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;官方文档把这种隐含的字段叫做：tiebreaker （决胜字段），tiebreaker 等价于_shard_doc。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;tiebreaker &lt;strong&gt;本质&lt;/strong&gt;含义：每个文档的唯一值，确保分页不会丢失或者分页结果数据出现重复（相同页重复或跨页重复）。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;步骤3：实现后续翻页。&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;# step 3 : 开始翻页&lt;/span&gt;&lt;br/&gt;GET /_search&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;size&quot;&lt;/span&gt;: 10,&lt;br/&gt;  &lt;span&gt;&quot;query&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;match&quot;&lt;/span&gt; : {&lt;br/&gt;      &lt;span&gt;&quot;host&quot;&lt;/span&gt; : &lt;span&gt;&quot;elastic&quot;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;pit&quot;&lt;/span&gt;: {&lt;br/&gt;     &lt;span&gt;&quot;id&quot;&lt;/span&gt;:  &lt;span&gt;&quot;48myAwEXa2liYW5hX3NhbXBsZV9kYXRhX2xvZ3MWM2hGWXpxLXFSSGlfSmZIaXJWN0dxUQAWdG1TOWFMTF9UdTZHdVZDYmhoWUljZwAAAAAAAAEg5RZGOFJCMGVrZVNndTk3U1I0SG81V3R3AAEWM2hGWXpxLXFSSGlfSmZIaXJWN0dxUQAA&quot;&lt;/span&gt;, &lt;br/&gt;     &lt;span&gt;&quot;keep_alive&quot;&lt;/span&gt;: &lt;span&gt;&quot;1m&quot;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;&quot;sort&quot;&lt;/span&gt;: [&lt;br/&gt;    {&lt;span&gt;&quot;response.keyword&quot;&lt;/span&gt;: &lt;span&gt;&quot;asc&quot;&lt;/span&gt;}&lt;br/&gt;  ],&lt;br/&gt;  &lt;span&gt;&quot;search_after&quot;&lt;/span&gt;: [                                &lt;br/&gt;    &lt;span&gt;&quot;200&quot;&lt;/span&gt;,&lt;br/&gt;    4&lt;br/&gt;  ]&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;后续翻页都需要借助 search_after 指定前一页的最后一个文档的 sort 字段值。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如下代码所示：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;  &lt;span&gt;&quot;search_after&quot;&lt;/span&gt;: [                                &lt;br/&gt;    &lt;span&gt;&quot;200&quot;&lt;/span&gt;,&lt;br/&gt;    4&lt;br/&gt;  ]&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;显然，search_after 查询仅支持向后翻页。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2.2 search_after 查询优缺点及适用场景&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;search_after 优点&lt;/span&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;不严格受制于 max_result_window，可以无限制往后翻页。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ps：不严格含义：单次请求值不能超过 max_result_window；但总翻页结果集可以超过。&lt;/span&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;search_after 缺点&lt;/span&gt;&lt;/h5&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;search_after 适用场景&lt;/span&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;类似：今日头条分页搜索  https://m.toutiao.com/search&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;不支持随机翻页，更适合手机端应用的场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.17078189300411523&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9Y3yWkiaGtXn81CNLDGmNp7ex2T4JiaEcPeEFUls9PTfLBDElldicfax2wLwUw2JpFYa29GCdkVMqrqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;972&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.3 Scroll 遍历查询&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.3.1 Scroll 遍历查询定义与实战案例&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;相比于 From + size 和 search_after 返回一页数据，Scroll API 可用于从单个搜索请求中检索大量结果（甚至所有结果），其方式与传统数据库中游标（cursor）类似。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果把  From + size 和 search_after 两种请求看做近实时的请求处理方式，那么 scroll 滚动遍历查询显然是非实时的。数据量大的时候，响应时间可能会比较长。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;scroll 核心执行步骤如下：&lt;/span&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;步骤 1：指定检索语句同时设置 scroll 上下文保留时间。&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实际上，scroll 已默认包含了 search_after 的PIT 的视图或快照功能。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从 Scroll 请求返回的结果反映了发出初始搜索请求时索引的状态，类似在那一个时刻做了快照。随后对文档的更改（写入、更新或删除）只会影响以后的搜索请求。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;POST kibana_sample_data_logs/_search?scroll=3m&lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;size&quot;&lt;/span&gt;: 100,&lt;br/&gt;  &lt;span&gt;&quot;query&quot;&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;&quot;match&quot;&lt;/span&gt;: {&lt;br/&gt;      &lt;span&gt;&quot;host&quot;&lt;/span&gt;: &lt;span&gt;&quot;elastic&quot;&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;步骤 2：向后翻页继续获取数据，直到没有要返回的结果为止。&lt;/span&gt;&lt;/h4&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;POST _search/scroll                                   &lt;br/&gt;{&lt;br/&gt;  &lt;span&gt;&quot;scroll&quot;&lt;/span&gt; : &lt;span&gt;&quot;3m&quot;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;&quot;scroll_id&quot;&lt;/span&gt;:&lt;span&gt;&quot;FGluY2x1ZGVfY29udGV4dF91dWlkDXF1ZXJ5QW5kRmV0Y2gBFkY4UkIwZWtlU2d1OTdTUjRIbzVXdHcAAAAAAAGmkBZ0bVM5YUxMX1R1Nkd1VkNiaGhZSWNn&quot;&lt;/span&gt; &lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;scroll_id 值是步骤 1 返回的结果值。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.3.2 Scroll 遍历查询优缺点及适用场景&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;    scroll 查询优点&lt;/span&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ps：单次遍历的 size 值也不能超过 max_result_window 大小。&lt;/span&gt;&lt;/h4&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;    scroll 查询缺点&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;scroll 查询适用场景&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;全量或数据量很大时遍历结果数据，而非分页查询。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;官方文档强调：不再建议使用scroll API进行深度分页。如果要分页检索超过 Top 10,000+ 结果时，推荐使用：PIT + search_after。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、小结&lt;/span&gt;&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;From+ size：需要随机跳转不同分页（类似主流搜索引擎）、Top 10000 条数据之内分页显示场景。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;search_after：仅需要向后翻页的场景及超过Top 10000 数据需要分页场景。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Scroll：需要遍历全量数据场景 。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;max_result_window：调大治标不治本，不建议调过大。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;PIT：本质是视图。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.509375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9Y3yWkiaGtXn81CNLDGmNp7ede1rgZ3ibavod54Cd99Qia94mNfhNo5ia3ULQOIicMpHZq2uY1C8J9BFmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4644506001846722&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mjl8GCpsL9Y3yWkiaGtXn81CNLDGmNp7eDDicDz1KoqQPBVVBJm7l73XCymlXIRXFqFbuQ7MLeqDh1fWOY96N9gw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1083&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本文说法有不严谨的地方，以&lt;span&gt;官方文档&lt;/span&gt;为准。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;欢迎大家就自己的分页实践进行留言讨论。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. https://coralogix.com/log-analytics-blog/how-to-optimize-your-elasticsearch-queries-using-pagination&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. https://www.javatpoint.com/elasticsearch-pagination&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. https://www.elastic.co/guide/en/elasticsearch/reference/7.12/paginate-search-results.html&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;span&gt;推荐：&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>40124cfdbd09e24b3747634fb619237a</guid>
<title>某小公司：MySQL 连环问</title>
<link>https://toutiao.io/k/qqqjn8a</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是yes。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL 面试题开始要更新啦！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请接招。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;你们公司数据库有备份的吧？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我：有的，因为单点故障的情况不可避免，所以我们公司有主从。面试官：那你知道主备、主从、主主有什么区别？&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;主备就是：主机和备机。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;备机是不干活的，也就是不对外提供服务，只是默默地在同步主机的数据，然后等着某一天主机挂了之后，它取而代之！&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6075949367088608&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nHqiaU6RXYZsDEUPBibhWibT4muz0OYpdBjGG6IZgoEJ7NcZaB2p83XeVM4rgxd6XWvXW8lFbjcLyFLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;553&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;至于切换的话主要有两种方式：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;人工切换，得知主机挂了之后手动把备机切成主机，缺点就是慢。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;利用 keepalived 或者自己写个脚本来作监控，然后自动切换。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;主从就是主机和从机。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从机和备机的区别在于，它是对外提供服务的，一般而言主从就是读写分离，写请求指派到主机，读请求指派到从机。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5583941605839416&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nHqiaU6RXYZsDEUPBibhWibT4mGJPT0AsjnNKSXic0RQibjSuZ2h7XXARxiadlN8dNsL0M3mWrxcsFV4WPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;548&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;主主就是两个都是主机&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.52&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nHqiaU6RXYZsDEUPBibhWibT4mUVTxWDkIjic6ccDOZPiapgPK8YyAK2CpaYZia6mfrgkLVB4ApNz6PaAKw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;575&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一般情况下都不会有主主的架构&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当同时有两个写请求达到分别打到两个主库同一张表的时候，则会同时创建一条记录，这条记录的 ID 是一样的，这样数据同步之后其中有一条就会被覆盖了，这会出问题的。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;为什么要读写分离啊？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读写分离就是读操作和写操作从以前的一台服务器上剥离开来，将主库压力分担一些到从库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本质上是因为访问量太大，主库的压力过大，单机数据库无法支撑并发读写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后一般而言读的次数远高于写，因此将读操作分发到从库上，这就是常见的读写分离。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读写分离还有个操作就是&lt;span&gt;主库不建查询的索引，从库建查询的索引&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为索引是需要维护的，比如你插入一条数据，不仅要在聚簇索引上面插入，对应的二级索引也得插入，修改也是一样的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以将读操作分到从库了之后，可以在主库把查询要用的索引删了，减少写操作对主库的影响。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;你们读写分离是用中间件的还是代码封装的？&lt;/span&gt;&lt;/h1&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;代码封装。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;讲白了就是代码层面抽出一个中间层，由中间层来实现读写分离和数据库连接。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是搞了个代理类，对外暴露正常的读写接口，里面封装了逻辑，将读操作指向从库的数据源，写操作指向主库的数据源。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;优点：简单，并且可以根据业务定制化变化，随心所欲。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;缺点：如果数据库宕机了，发生主从切换了之后，就得修改配置重启。如果系统是多语言的话，需要为每个语言都实现一个中间层代码，重复开发。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;中间件&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般而言是独立部署的系统，客户端与这个中间件的交互是通过 SQL 协议的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.25705794947994054&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nHqiaU6RXYZsDEUPBibhWibT4mMuJqh3cshMzmmaEmvt9rYupxtrK66svdF2LCV7e3APJd8haqVxNv2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;673&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在客户端看来连接的就是一个数据库，通过 SQL 协议交互也可以屏蔽多语言的差异。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缺点就是整体架构多了一个系统需要维护，并且可能成为性能瓶颈，毕竟交互都需要经过它中转。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的开源数据库中间件有：官方的MySQL-Proxy、360的Atlas、Mycat 等。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;MySQL 主从同步机制你知道吗？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主从同步主要依赖的就是 binlog，MySQL 默认是&lt;span&gt;异步复制&lt;/span&gt;，具体流程如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主库：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;接受到提交事务请求&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;更新数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将数据写到binlog中&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;给客户端响应&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;推送binlog到从库中&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从库：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;由 I/O 线程将同步过来的 binlog 写入到 relay log 中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;由 SQL 线程从 relay log 重放事件，更新数据&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;给主库返回响应。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.39331366764995085&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nHqiaU6RXYZsDEUPBibhWibT4m7xCIWlFeMgFC4qGrdQpuJgLN9RITxLhdvOJmR4bHlRhAI4YmXVm48w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1017&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用一句话概括一下：主库提交事务会写binlog，会由一个 dump 线程推送给从库，从库接受之后会有一个I/O线程将其写到 relay log 中，慢慢消化，由 SQL 线程来重放更新数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;异步复制&lt;/span&gt;有数据丢失风险，例如数据还未同步到从库，主库就给客户端响应，然后主库挂了，此时从库晋升为主库的话数据是缺失的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以有&lt;span&gt;同步复制&lt;/span&gt;，主库需要将 binlog 复制到所有从库，等所有从库响应了之后才会给客户端响应，这样的话性能很差，一般不会选择同步复制。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;MySQL 5.7 之后搞了个&lt;span&gt;半同步复制&lt;/span&gt;，有个参数可以选择“成功同步几个从库就返回响应。”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如一共有 3 个从库，我参数配置 1，那么只要有一个从库响应说复制成功了，主库就直接返回响应给客户端，不会等待其他两个从库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的话性能就比较好，并且数据可靠性也增强了，只有当那个从库和主库同时都挂了，才会缺失数据。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;主从同步延迟怎么处理啊？&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图的流程就可以得知，&lt;span&gt;延迟是必然存在的&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;延迟过大的话就有可能出现一个用户刚注册，然后登陆报该用户不存在的....&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为数据是写到主库中的，查询走从库有可能还未来同步完毕，导致查不到这个用户。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就非常不友好了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见解决方式有以下几种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;二次查询。如果从库查不到数据，则再去主库查一遍，由 API 封装即可，算是一个兜底策略，比较简单。不过等于读的压力又转移到主库身上了，如果有不法分子估计搞一下必定查不到的查询，这就难受了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;强制将写之后立马读的操作转移到主库上。这种属于代码写死了，比如一些写入之后立马查询的操作，就绑定在一起，写死都走主库。不推荐，太僵硬了。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;关键业务读写都走主库，非关键还是读写分离。比如上面我举例的用户注册这种，可以读写主库，这样就不会有登陆报该用户不存在的问题，这种访问量频次应该也不会很多，所以看业务适当调整此类接口。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;暂时就更新到这儿了~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本来MySQL面试题挺早之前就要开始写的，后来构思着就感觉索引那块有点想法，所以就先写故事去了~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是这两篇：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;故事是连贯的，还没完结，面试题也同步更新，排的满满当当~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对了，如果有遇到关于 MySQL 刁钻的面试题，可以联系我，也可以直接留言，我会收录并尽力解答 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的个人微信：yes_oba。&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkxNTE3NjQ3MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEf5LN3Y4UErfNUkiaMseJPkdXA4xPD6Uicl8EqAJAEKVIKalU19xS41TO3aPmHK5bqbzGTwu3z92Kg/0?wx_fmt=png&quot; data-nickname=&quot;yes的练级攻略&quot; data-alias=&quot;yes_java&quot; data-signature=&quot;用接地气的话来分享一些后端技术或写一些想写的。&quot;/&gt;&lt;/section&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我是yes，从一点点到亿点点，我们下篇见~&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>