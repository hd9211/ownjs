<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>425113ce32ae56021f0689e7b2b1f433</guid>
<title>Spring Boot 引起的 “堆外内存泄漏”</title>
<link>https://toutiao.io/k/o802afr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;src-views-article-detail-main-module__content--2qOBd markdown-body&quot;&gt;&lt;h1&gt;背景&lt;/h1&gt;
&lt;p&gt;组内一个项目最近一直报swap区域使用过高异常，笔者被叫去帮忙查看原因。发现配置的4G堆内内存，但是实际使用的物理内存高达7G，确实有点不正常，JVM参数配置是：&lt;/p&gt;
&lt;pre class=&quot;hljs&quot;&gt;&lt;code class=&quot;hljs-code-wrap&quot;&gt;-XX:MetaspaceSize=&lt;span class=&quot;hljs-number&quot;&gt;256&lt;/span&gt;M -XX:MaxMetaspaceSize=&lt;span class=&quot;hljs-number&quot;&gt;256&lt;/span&gt;M -XX:+AlwaysPreTouch -XX:ReservedCodeCacheSize=&lt;span class=&quot;hljs-number&quot;&gt;128&lt;/span&gt;m -XX:InitialCodeCacheSize=&lt;span class=&quot;hljs-number&quot;&gt;128&lt;/span&gt;m, -Xss512k -Xmx4g -Xms4g,-XX:+UseG1GC -XX:G1HeapRegionSize=&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;M
&lt;/code&gt;&lt;button class=&quot;pre-button&quot;&gt;复制&lt;/button&gt;&lt;/pre&gt;
&lt;p&gt;但是使用的虚拟内存和物理内存使用情况如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386034&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h1&gt;排查过程&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;步骤一：先使用java层面的工具定位是不是堆内内存、code区域或者使用unsafe.allocateMemory和DirectByteBuffer申请的堆外内存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;笔者在项目中添加“-XX:NativeMemoryTracking=summary ”JVM参数重启项目，查看查到的内存分布如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386059&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现这个命令显示的committed的远内存小于物理内存。因为之前就对NativeMemoryTracking有所了解和测试，知道NativeMemoryTracking可以追踪到堆内内存、code区域、通过unsafe.allocateMemory和DirectByteBuffer申请的内存，但是追踪不到其他native code（c代码）申请的堆外内存。这一步也可以使用arthas去查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386084&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了防止误判，笔者适应了pmap查看内存分布，发现大量的64M的地址，而这些地址空间不在NativeMemoryTracking所给出的地址空间里面。基本上就断定就是这些64M的内存导致的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386087&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤二：使用系统层面的工具定位堆外内存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为基本上确定是native code引起之后，java层面的工具基本上就失效了，只能使用系统层面的工具去查找问题。首先使用了gperftools去查看，截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386113&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图可以看出，使用malloc申请的的内存最高到3G之后就释放了，之后始终维持在700M-800M。第一反应就是难道native code 中没有使用malloc申请，直接使用mmap/brk申请的？（gperftools原理就使用动态链接的方式替换了操作系统默认的内存分配器（glibc））&lt;/p&gt;
&lt;p&gt;直接使用strace对mmap/brk进行追踪发现，并没有申请内存，此时陷入了比较迷茫的状态。于是想着能不能看看内存里面是啥东西，就用gdb去dump这些64M的内存下来看看，内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386121&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从内容上来看像解压后的jar信息。读取jar信息应该是在项目启动的时候，那么在项目启动之后使用strace作用就不是很大了，于是在项目启动的时候就使用strace，发现确实申请了很多64M内存空间，截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386153&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用该mmap申请的地址空间在pmap对应如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386182&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据strace显示的线程Id，去jstack一下java进程，找到线程栈如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386188&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里基本上就可以看出问题来了，这里使用了Reflections进行扫包，底层使用了spring boot loader去加载了jar。因为需要解压jar肯定需要Inflater类，这个需要用到堆外内存，然后使用btrace去追踪这个方法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386197&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在代码中找到扫包的地方，发现没有配置扫包路径，默认的是扫描所有jar，修改为扫描特定的jar路径。上线测试，内存正常，问题修复。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤三：为什么堆外内存没有释放掉呢&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;到步骤二的时候，问题已经解决了，但是有几个疑问：&lt;/p&gt;
&lt;p&gt;为什么堆外内存没有释放&lt;/p&gt;
&lt;p&gt;为什么内存大小都是64M，jar大小不可能这么大，而且都是一样大&lt;/p&gt;
&lt;p&gt;为什么gperftools最终显示使用的的内存大小是700M左右，解压包真的没有使用malloc申请内存吗？&lt;/p&gt;
&lt;p&gt;直接看了一下spring boot loader那一块源码，发现spring对jdk的JarFile的进行了包装。他使用Inflater却没有手动去释放，依赖于Inflater中的finalize机制，在gc的时候释放。于是怀疑gc的时候没有调用finalize。带着这样的怀疑，我把Inflater进行包装在spring loader里面替换成我包装的Inflater，在finalize进行打点监控，发现finalize在young gc 的时候确实被调用了啊。去看了一下Inflater对应的C代码，初始化的使用了malloc 申请内存，调用end的时候调用了free去释放内存了。于是怀疑free的时候没有真正释放内存。然后想着把spring boot包装JarFile 替换成jdk 自带的 JarFile，发现替换之后内存问题解决。&lt;/p&gt;
&lt;p&gt;然后再返过来看gperftools的内存分布情况。发现使用spring loader的时候，内存使用一直在增加，突然某个点内存使用下降了好多。这个点应该就是gc引起的，内存应该释放了。但是操作系统层面没有看到内存变化，怀疑没有释放到操作系统，被内存分配器持有了。&lt;/p&gt;
&lt;p&gt;发现和不使用gperftools内存地址分布差别很明显，2.5G地址使用smaps发现他是属于native stack。物理内存地址分布如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386217&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到此基本上可以确定是内存分配器在捣鬼，搜索了一下glibc 64M，发现从glibc 从2.11 开始对每个线程引入内存池（64位机器大小就是64M内存），原文如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386228&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;按照文中所说去修改MALLOC_ARENA_MAX环境变量，发现没什么效果，去查看tcmalloc（gperftools使用的内存分配器）也使用了内存池方式。&lt;/p&gt;
&lt;p&gt;因为glibc 内存分配器代码太多，懒得去看，为了验证就自己简单写个内存分配器。使用动态链接替换掉glibc 的内存分配器，代码如下（因为都是从main中分配内存，没有考虑线程安全，realloc，calloc代码类似没截图了）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过在自定义分配器当中埋点可以发现其实程序启动之后程序实际申请的堆外内存其实始终在700M-800M之前，tcmalloc 也有相关埋点也是在700M-800M左右。但是从操作系统角度来看进程占用的内存差别很大（这里只是监控堆外内存）。&lt;/p&gt;
&lt;p&gt;笔者做了一下测试，使用不同分配器进行不同程度的扫包，占用的内存如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386259&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为什么自定义的malloc 申请800M，最终占用的物理内存在1.7G呢？&lt;/p&gt;
&lt;p&gt;因为自定义内存采用的是mmap分配内存，mmap分配内存的单位是page，也就是page的整数倍，笔者使用的系统pagesize=4k，也就说如果用户申请了1一个字节，也会分配一个page，存在着巨大的空间浪费，可以通过埋点查看系统申请了多少页。埋点发现最终在536k左右吧。那实际上向系统申请的内存 = 512k * 4k = 2G，为什么这个数据由大于1.7G内，因为操作系统采取的是延迟加载的方式，也就是说通过mmap向系统申请内存的时候系统仅仅返回地址并没有分配真实的物理地址，只有在使用的时候系统产生一个缺页中断然后在加载这个page到内存当中，这也是使用pmap看到的物理和虚拟内存的区别。&lt;/p&gt;
&lt;h1&gt;总结&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://a.perfma.net/img/386284&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整个内存分配的流程如上图。在扫描包的时候，spring loader不会主动去释放堆外内存，导致在扫描过程中，堆外内存占用量一直持续飙升。当发生gc 的时候会依赖于finalize机制一并去释放了堆外内存。但是glibc为了性能考虑，并没有真正把内存归返到操作系统，而是留下来当做内存池了，导致应用层以为发生了“内存泄漏”。&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>35b847572daa0a8491692d02ce6fff69</guid>
<title>[推荐] 面试题：MySQL 一棵 B+ 树能存多少条数据？</title>
<link>https://toutiao.io/k/85kvlje</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;大家好，我是Tom哥~&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;span&gt;今日寄语：充满活力的新人，能让身边的人都重回初心，真是不可思议。&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;my&lt;/span&gt;&lt;span&gt;sql 的InnoDB存储引擎 一棵B+树可以存放多少行数据?&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.41114982578397213&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfxA7iaBRvMqhOtRNlUOketzpVLicRx4bhoYFC2IyEJGQichDkNPaf1ubltvu1LibkZTwU9dP5pyVJejA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;574&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;（答案在文章中！！）&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;要搞清楚这个问题，首先要从InnoDB索引数据结构、数据组织方式说起。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们都知道计算机有五大组成部分：控制器，运算器，存储器，输入设备，输出设备。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;其中很重要的，也跟今天这个题目有关系的是存储器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们知道万事万物都有自己的单元体系，若干个小单体组成一个个大的个体。就像拼乐高一样，可以自由组合。所以说，如果能熟悉最小单元，就意味着我们抓住了事物的本事，再复杂的问题也会迎刃而解。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;存储单元&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;br/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;存储器范围比较大，但是数据具体怎么存储，有自己的最小存储单元。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、数据持久化存储磁盘里，磁盘的最小单元是扇区，&lt;/span&gt;&lt;code&gt;&lt;span&gt;一个扇区的大小是 512个字节&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、文件系统的最小单元是块，&lt;/span&gt;&lt;code&gt;&lt;span&gt;一个块的大小是 4K&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、InnoDB存储引擎，有自己的最小单元，称之为页，&lt;/span&gt;&lt;code&gt;&lt;span&gt;一个页的大小是16K&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;扇区、块、页这三者的存储关系？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4234375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfxA7iaBRvMqhOtRNlUOketzlYj9YicSEnH5fHR3M2vhZXRAx5ziaicicGYF8ticfyhddjfoMDSsia5F2kzA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;InnoDB引擎&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果mysql部署在本地，通过命令行方式连接mysql，默认的端口 &lt;/span&gt;&lt;code&gt;&lt;span&gt;3306&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ，然后输入密码即可进入&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;mysql -u root -p&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;查看InnoDB的页大小&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;show variables like &lt;span&gt;&#x27;innodb_page_size&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3391304347826087&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfxA7iaBRvMqhOtRNlUOketzEFG2ibmpdO3d6tPLUeKoXj30aAaJKib31DbJrsucRC8RGAffyxIcNO6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;mysql数据库中，table表中的记录都是存储在页中，那么一页可以存多少行数据？假如一行数据的大小约为1K字节，那么按 &lt;/span&gt;&lt;code&gt;&lt;span&gt;16K / 1K = 16&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，可以计算出一页大约能存放16条数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;mysql 的最小存储单元叫做“页”，这么多的页是如何构建一个庞大的数据组织，我们又如何知道数据存储在哪一个页中？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果逐条遍历，性能肯定很差。为了提升查找速度，我们引入了&lt;/span&gt;&lt;code&gt;&lt;span&gt;B+树&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，先来看下&lt;/span&gt;&lt;code&gt;&lt;span&gt;B+树&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的存储结构&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7431972789115646&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfxA7iaBRvMqhOtRNlUOketzQoknttTWIrdxibtddSIiaXkNRwaa7nbLNhzAZic8jOx7ExBGFkDT5hZQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1176&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;页除了可以存放&lt;/span&gt;&lt;code&gt;&lt;span&gt;数据&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（叶子节点），还可以存放&lt;/span&gt;&lt;code&gt;&lt;span&gt;健值和指针&lt;/span&gt;&lt;/code&gt;&lt;span&gt;（非叶子节点），当然他们是有序的。这样的数据组织形式，我们称为索引组织表。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;如：上图中 page number=3的页，该页存放键值和指向数据页的指针，这样的页由N个键值+指针组成&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;B+ 树是如何检索记录？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;首先找到根页，你怎么知道一张表的根页在哪呢？&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;其实每张表的根页位置在表空间文件中是固定的，即page number=3的页&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;找到根页后通过二分查找法，定位到id=5的数据应该在指针P5指向的页中&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;然后再去page number=5的页中查找，同样通过二分查询法即可找到id=5的记录&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;如何计算B+树的高度？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在&lt;/span&gt;&lt;code&gt;&lt;span&gt;InnoDB&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的表空间文件中，约定&lt;/span&gt;&lt;code&gt;&lt;span&gt;page number = 3&lt;/span&gt;&lt;/code&gt;&lt;span&gt;表示主键索引的根页&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;SELECT&lt;br/&gt;b.name, a.name, index_id, &lt;span&gt;type&lt;/span&gt;, a.space, a.PAGE_NO&lt;br/&gt;FROM&lt;br/&gt;information_schema.INNODB_SYS_INDEXES a,&lt;br/&gt;information_schema.INNODB_SYS_TABLES b&lt;br/&gt;WHERE&lt;br/&gt;a.table_id = b.table_id AND a.space &amp;lt;&amp;gt; 0&lt;br/&gt;and b.name like &lt;span&gt;&#x27;%sp_job_log&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4416326530612245&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfxA7iaBRvMqhOtRNlUOketzDYSy4C3FBQGVAicTia8eWaE0ibSbmR1nR0fQrxvPzpH314j8wwD7BQzJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1225&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;从图中可以看出，每个表的主键索引的根页的page number都是3，而其他的二级索引page number为4&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在根页偏移量为&lt;/span&gt;&lt;code&gt;&lt;span&gt;64&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的地方存放了该B+树的&lt;/span&gt;&lt;code&gt;&lt;span&gt;page level&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。主键索引B+树的根页在整个表空间文件中的第3个页开始，所以算出它在文件中的偏移量：&lt;/span&gt;&lt;code&gt;&lt;span&gt;16384*3 + 64 = 49152 + 64 =49216&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，前2个字节中。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，找到MySql数据库物理文件存放位置：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;show global variables like &lt;span&gt;&quot;%datadir%&quot;&lt;/span&gt; ;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.23905723905723905&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfxA7iaBRvMqhOtRNlUOketznDFboCv74nXKOaM99gicGfGPWOX4iaV47GdCokFqSrlUv32h8z5mS6wA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;594&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;hexdump工具，查看表空间文件指定偏移量上的数据：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;hexdump -s 49216 -n 10  sp_job_log.ibd&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.09765625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfxA7iaBRvMqhOtRNlUOketzuZepNfX9ZfrDShVg5coaEoKmmZEe5jAxad1Te2Q5y8v5IcI09mzzpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;page_level 值是 1，那么 B+树高度为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;page level + 1 = 2&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;特别说明：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;查询数据库时，不论读一行，还是读多行，都是将这些行所在的整页数据加载，然后在内存中匹配过滤出最终结果。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;表的检索速度跟树的深度有直接关系，毕竟一次页加载就是一次IO，而磁盘IO又是比较费时间。&lt;/span&gt;&lt;code&gt;&lt;span&gt;对于一张千万级条数B+树高度为3的表与几十万级B+树高度也为3的表，其实查询效率相差不大。&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;一棵树可以存放多少行数据？&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;假设B+树的深度为2&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这棵B+树的存储总记录数 = &lt;/span&gt;&lt;code&gt;&lt;span&gt;根节点指针数 * 单个叶子节点记录条数&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;那么指针数如何计算？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设主键ID为&lt;/span&gt;&lt;code&gt;&lt;span&gt;bigint&lt;/span&gt;&lt;/code&gt;&lt;span&gt;类型，长度为&lt;/span&gt;&lt;code&gt;&lt;span&gt;8字节&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，而指针大小在InnoDB源码中设置为&lt;/span&gt;&lt;code&gt;&lt;span&gt;6字节&lt;/span&gt;&lt;/code&gt;&lt;span&gt;，这样一共&lt;/span&gt;&lt;code&gt;&lt;span&gt;14字节&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;那么一个页中能存放多少这样的组合，就代表有多少指针，即 &lt;/span&gt;&lt;code&gt;&lt;span&gt;16384 / 14 = 1170&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。那么可以算出一棵高度为2 的B+树，能存放 &lt;/span&gt;&lt;code&gt;&lt;span&gt;1170 * 16 = 18720&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 条这样的数据记录。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;同理：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;高度为3的B+树可以存放的行数 =  &lt;/span&gt;&lt;code&gt;&lt;span&gt;1170 * 1170 * 16 = 21902400&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;千万级的数据存储只需要约3层B+树，查询数据时，每加载一页（page）代表一次IO。所以说，根据主键id索引查询约3次IO便可以找到目标结果。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;对于一些复杂的查询，可能需要走二级索引，那么通过二级索引查找记录最多需要花费多少次IO呢？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.66640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfxA7iaBRvMqhOtRNlUOketz38TgsCyJTkFxDq7psbdsdsbYqoL9le40CKiaeaiaObAliaFWnOaGs48aA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，从二级索引B+树中，根据&lt;/span&gt;&lt;code&gt;&lt;span&gt;name&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 找到对应的主键id&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.69296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfxA7iaBRvMqhOtRNlUOketzk8Vt860QGV3uwh5GjeEgfwmRcYFpADH8hZNwV2ic5eTutzYPGhVEttQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然后，再根据主键id 从 聚簇索引查找到对应的记录。如上图所示，二级索引有3层，聚簇索引有3层，那么最多花费的IO次数是：3+3 = 6&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;聚簇索引默认是主键，如果表中没有定义主键，InnoDB 会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引。&lt;/span&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;这也是为什么InnoDB表必须有主键，并且推荐使用整型的自增主键！！！&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;举例说明：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、若使用&lt;/span&gt;&lt;code&gt;&lt;span&gt;&quot;where id = 14&quot;&lt;/span&gt;&lt;/code&gt;&lt;span&gt;这样的条件查找记录，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、若对Name列进行条件搜索，则需要两个步骤：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键值。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;第二步使用主键值在主索引B+树中再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。（重点在于通过其他键需要建立辅助索引）&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;实战演示&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;实际项目中，每个表的结构设计都不一样，占用的存储空间大小也各不相等。如何计算不同的B+树深度下，一个表可以存储的记录条数？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们以业务日志表 &lt;/span&gt;&lt;code&gt;&lt;span&gt;sp_job_log&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 为例，讲解详细的计算过程：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1、查看表的状态信息&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;show table status like &lt;span&gt;&#x27;sp_job_log&#x27;&lt;/span&gt;\G&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.54140625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfxA7iaBRvMqhOtRNlUOketzPSO6icytqwXDU2rF2yy2CJKyc3V4462NyPbvuVroIicBhoz7Bk5TILDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;图中看到&lt;/span&gt;&lt;code&gt;&lt;span&gt;sp_job_log&lt;/span&gt;&lt;/code&gt;&lt;span&gt;表的行平均大小为&lt;/span&gt;&lt;code&gt;&lt;span&gt;153&lt;/span&gt;&lt;/code&gt;&lt;span&gt;个字节&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2、查看表结构&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;desc sp_job_log;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2KTof9YshwfxA7iaBRvMqhOtRNlUOketzlKOpFialibXWIiaZOIY26AZjhr2lTWicGTfOxAdq7xeZTzCZS0ib5ZQgVicQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3、计算B+树的行数&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;单个叶子节点（页）中的记录数 = 16K / 153 = 105&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;非叶子节点能存放多少指针， 16384 / 14 = 1170&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果树的高度为3，可以存放的记录行数 =  1170 * 1170 * 105 = 143,734,500&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;最后加餐&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;普通索引和唯一索引在查询效率上有什么不同？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;唯一索引就是在普通索引上增加了约束性，也就是关键字唯一，找到了关键字就停止检索。而普通索引，可能会存在用户记录中的关键字相同的情况，根据页结构的原理，当我们读取一条记录的时候，不是单独将这条记录从磁盘中读出去，而是将这个记录所在的页全部加载到内存中进行读取。InnoDB 存储引擎的页大小为 16KB，在一个页中可能存储着上千个记录，因此在普通索引的字段上进行查找也就是在内存中多几次&lt;/span&gt;&lt;code&gt;&lt;span&gt;判断下一条记录&lt;/span&gt;&lt;/code&gt;&lt;span&gt;的操作，对于 CPU 来说，这些操作所消耗的时间是可以忽略不计的。所以对一个索引字段进行检索，采用普通索引还是唯一索引在检索效率上基本上没有差别。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;关于我：前阿里架构师，出过专利，竞赛拿过奖，CSDN博客专家，负责过电商交易、社区生鲜、营销、金融等业务，多年团队管理经验，爱思考，喜欢结交朋友&lt;/span&gt;&lt;/section&gt;&lt;h1 accuse=&quot;qTitle&quot;&gt;&lt;span&gt;&lt;span&gt;「长按2秒」↓↓&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;↓ 二维码，拉你进群，一线大厂技术交流&lt;/span&gt;&lt;/span&gt;&lt;/h1&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2021660649819494&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3Ohm6WHibeXLL4AVYEUeBKzcTZJd7mrk9XicnYiccg6n8YjsA4ibpRk6hkog7Qqx6cJNIF1rhicl992vID1IFUKWYuw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247484947&amp;amp;idx=1&amp;amp;sn=5a70f88fba83b435b8144bf1ddd3cc9f&amp;amp;chksm=ceb9fab8f9ce73ae97afc43f87314dd3bb61c966b9a40c12801cddc454dcf2845bbb605694e3&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;亿级系统的Redis缓存如何设计？？？&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247484957&amp;amp;idx=1&amp;amp;sn=e50e0808cb6503ca7214bdd6fee4f134&amp;amp;chksm=ceb9fab6f9ce73a0c0725e381673fc7dc50c0594fb995b5f985b263143b34371e5e2936d7be0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;【高并发、高性能、高可用】系统设计经验&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247484929&amp;amp;idx=1&amp;amp;sn=d8cb3306dea9f1b92fd30d59da3f536a&amp;amp;chksm=ceb9faaaf9ce73bca59b46021a450fdc84aa0f85d6b49ff0e5578cc3abaa1433447f7dffc5e4&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;人人都是架构师？？？谈何容易！！&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg2NzYyNjQzNg==&amp;amp;mid=2247484921&amp;amp;idx=1&amp;amp;sn=b429efe7e622759fc8f3bb24c2979a90&amp;amp;chksm=ceb9f952f9ce7044b001528ce8ae0ec89ed63727764081c21a8400e9f8f685345ec9cb0a54d7&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;【万级并发】电商库存扣减如何设计？不超卖！&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e673c59e9f42b2dcaac6f769562148d6</guid>
<title>[推荐] 惊！这个 Go 开源项目号称「不改一行代码做秒杀」</title>
<link>https://toutiao.io/k/qnyxbs9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-tools=&quot;135编辑器&quot; data-id=&quot;23&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;阅读本文大概需要 2 分钟。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是 polarisxu。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到耗子叔发推文推荐了一个新开源的网关：Easegress。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.43005181347150256&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UzjmETLXwBaZWKKF0aSaChclOHu7laFedvaxa0eueVuPxwnhF2HdGLz3ZIrMTaEwy6DJ5TfbyHNMhhYgArxW5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1158&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打开看了下，这是一个 Go 语言实现的开源项目。它有如下亮点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;高可用。内置 Raft 共识和领导者选举，提供 99.99％ 的可用性。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;流量编排。将各种过滤器动态地编排到流量管道。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高性能。轻量级和基础特性提升性能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可观察性。以可读方式定期存放许多有意义的统计数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可扩展性。使用高级编程语言开发自己的过滤器或控制器很容易。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一体化。简单的接口使其易于与其他系统集成，例如 Kubernetes Ingress，Easemesh Sidecar，Workflow 等。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;给一张架构图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4578125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UzjmETLXwBaZWKKF0aSaChclOHu7laFelnG5ouQsoNo4HAlGd7I5LXFaMlz93Kr5NEfywFoXLgdY4jibAxEevEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的功能特性，耗子叔给了一张图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;3.8641509433962264&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/UzjmETLXwBaZWKKF0aSaChclOHu7laFecibnIyqiak6pfS1LYmYvaicg33tbR7Tcz4fkzGmia2LfYfAicRAiakiawibemQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1060&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看起来很强大，而且他们公司的产品宣传是：&lt;strong&gt;不改一行代码做秒杀&lt;/strong&gt;。有机会可以深入学习研究下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然是国人开源项目，不过文档是全英文的，没有中文版。很显然是要走向国际的。&lt;strong&gt;阅读原文&lt;/strong&gt;可以直达项目首页：https://github.com/megaease/easegress。&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;往期推荐&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/UzjmETLXwBYuP3ncUTaemHXQYjOZDS40VoicqII73Hu9RncJv06g0kJhnrVicSmUfJRg5Wf9qcDHj7zf5vTjns5A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我是 polarisxu，北大硕士毕业，曾在 360 等知名互联网公司工作，10多年技术研发与架构经验！2012 年接触 Go 语言并创建了 Go 语言中文网！著有《&lt;/span&gt;&lt;span&gt;Go语言编程之旅&lt;/span&gt;&lt;span&gt;》、开源图书《&lt;/span&gt;&lt;span&gt;Go语言标准库&lt;/span&gt;&lt;span&gt;》等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;坚持输出技术（包括 Go、Rust 等技术）、职场心得和创业感悟！欢迎关注「polarisxu」一起成长！也欢迎加我微信好友交流：&lt;/span&gt;&lt;span&gt;gopherstudio&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>73917c38e91915d25a8474cc1de38754</guid>
<title>[推荐] Spring Boot 在 K8s 下实现优雅停机</title>
<link>https://toutiao.io/k/6tcdyp9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/FBPFm28kpSwRuCcX7myzfYhVevLQPOdFPR0NOQuAHoLCm46CvYb25ic3ibzupbbl7ib6YMqqjyXVTm4YzXWAY4bpg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在K8s中，当我们实现滚动升级之前，务必要实现应用级别的优雅停机。否则滚动升级时，还是会影响到业务。本文介绍SpringBoot应用实现优雅停机。此次教程基于SpringBoot 2.5.0。&lt;/p&gt;&lt;h3&gt;1. 加入必要依赖&lt;/h3&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;xml&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-actuator&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;2. 配置SpringBoot应用&lt;/h3&gt;&lt;p&gt;默认情况下，SpringBoot是直接关机的，所以，需要将优雅停机配置打开。在applicatoin.yaml中配置：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;yaml&quot;&gt;&lt;code&gt;&lt;span&gt;spring:&lt;/span&gt;&lt;br/&gt;  application:&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: demo&lt;br/&gt;  &lt;span&gt;# 停机过程超时时长设置了20s，超过20s，直接停机&lt;/span&gt;&lt;br/&gt;  lifecycle:&lt;br/&gt;    &lt;span&gt;timeout-per-shutdown-phase&lt;/span&gt;: 20s&lt;br/&gt;&lt;br/&gt;&lt;span&gt;server:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;port&lt;/span&gt;: 8080&lt;br/&gt;  &lt;span&gt;#  默认为IMMEDIATE，表示立即关机；GRACEFUL表示优雅关机&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;shutdown&lt;/span&gt;: graceful&lt;br/&gt;&lt;br/&gt;&lt;span&gt;management:&lt;/span&gt;&lt;br/&gt;  server:&lt;br/&gt;    &lt;span&gt;address&lt;/span&gt;: 127&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;port&lt;/span&gt;: 50000&lt;br/&gt;  &lt;span&gt;# 开启shutdown endpoint&lt;/span&gt;&lt;br/&gt;  endpoint:&lt;br/&gt;    &lt;span&gt;shutdown&lt;/span&gt;:&lt;br/&gt;      enabled: &lt;span&gt;true&lt;/span&gt;&lt;br/&gt;  endpoints:&lt;br/&gt;    web:&lt;br/&gt;      &lt;span&gt;base&lt;/span&gt;-path: /&lt;span&gt;private&lt;/span&gt;-url&lt;br/&gt;      exposure:&lt;br/&gt;        &lt;span&gt;# 暴露shutdown endpoint&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;include&lt;/span&gt;: health,shutdown&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;这时我们只需要在发送停机请求告诉应用，即可优雅停机。发送指令为：&lt;code&gt;curl -XPOST 127.0.0.1:50000/private-url/shutdown&lt;/code&gt;。&lt;/p&gt;&lt;h3&gt;3. 集成到Pod中&lt;/h3&gt;&lt;p&gt;生产环境中当然不会直接使用Pod部署应用，而是使用Deployment部署应用。以下只是样例：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;yaml&quot;&gt;&lt;code&gt;&lt;span&gt;apiVersion&lt;/span&gt;: v1 &lt;br/&gt;&lt;span&gt;kind&lt;/span&gt;: Pod &lt;br/&gt;&lt;span&gt;metadata:&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;name&lt;/span&gt;: demopod&lt;br/&gt;&lt;span&gt;spec:&lt;/span&gt;&lt;br/&gt;  containers:&lt;br/&gt;  &lt;span&gt;-&lt;/span&gt; &lt;span&gt;image&lt;/span&gt;: &lt;span&gt;springboot-demo&lt;/span&gt;&lt;span&gt;:v1.10&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: demo-container&lt;br/&gt;    ports:&lt;br/&gt;    - containerPort: 8080&lt;br/&gt;    lifecycle:&lt;br/&gt;      preStop:&lt;br/&gt;        &lt;span&gt;exec&lt;/span&gt;:&lt;br/&gt;          &lt;span&gt;command&lt;/span&gt;: [&lt;span&gt;&quot;curl&quot;&lt;/span&gt;, &lt;span&gt;&quot;-XPOST&quot;&lt;/span&gt;, &lt;span&gt;&quot;127.0.0.1:50000/private-url/shutdown&quot;&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;注意：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;前提是你的应用镜像中必须包含&lt;code&gt;curl&lt;/code&gt;命令。&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;50000是应用管理端口，不能暴露给公网。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;4. 实验效果&lt;/h3&gt;&lt;p&gt;在命令行里执行：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;% curl -X POST &lt;span&gt;127.0&lt;/span&gt;&lt;span&gt;.0&lt;/span&gt;&lt;span&gt;.1&lt;/span&gt;:&lt;span&gt;50000&lt;/span&gt;/&lt;span&gt;private&lt;/span&gt;-url/shutdown&lt;br/&gt;{&lt;span&gt;&quot;message&quot;&lt;/span&gt;:&lt;span&gt;&quot;Shutting down, bye...&quot;&lt;/span&gt;}%&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;应用日志：&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;... &lt;span&gt;o&lt;/span&gt;&lt;span&gt;.s&lt;/span&gt;&lt;span&gt;.b&lt;/span&gt;&lt;span&gt;.w&lt;/span&gt;&lt;span&gt;.e&lt;/span&gt;&lt;span&gt;.tomcat&lt;/span&gt;&lt;span&gt;.GracefulShutdown&lt;/span&gt;  : &lt;span&gt;Commencing&lt;/span&gt; &lt;span&gt;graceful&lt;/span&gt; &lt;span&gt;shutdown&lt;/span&gt;. &lt;span&gt;Waiting&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;active&lt;/span&gt; &lt;span&gt;requests&lt;/span&gt; &lt;span&gt;to&lt;/span&gt; &lt;span&gt;complete&lt;/span&gt;&lt;br/&gt;... &lt;span&gt;o&lt;/span&gt;&lt;span&gt;.s&lt;/span&gt;&lt;span&gt;.b&lt;/span&gt;&lt;span&gt;.w&lt;/span&gt;&lt;span&gt;.e&lt;/span&gt;&lt;span&gt;.tomcat&lt;/span&gt;&lt;span&gt;.GracefulShutdown&lt;/span&gt;  : &lt;span&gt;Gracefsul&lt;/span&gt; &lt;span&gt;shutdown&lt;/span&gt; &lt;span&gt;complete&lt;/span&gt;&lt;br/&gt;... &lt;span&gt;o&lt;/span&gt;&lt;span&gt;.s&lt;/span&gt;&lt;span&gt;.b&lt;/span&gt;&lt;span&gt;.w&lt;/span&gt;&lt;span&gt;.e&lt;/span&gt;&lt;span&gt;.tomcat&lt;/span&gt;&lt;span&gt;.GracefulShutdown&lt;/span&gt;  : &lt;span&gt;Commencing&lt;/span&gt; &lt;span&gt;graceful&lt;/span&gt; &lt;span&gt;shutdown&lt;/span&gt;. &lt;span&gt;Waiting&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;active&lt;/span&gt; &lt;span&gt;requests&lt;/span&gt; &lt;span&gt;to&lt;/span&gt; &lt;span&gt;complete&lt;/span&gt;&lt;br/&gt;... &lt;span&gt;o&lt;/span&gt;&lt;span&gt;.s&lt;/span&gt;&lt;span&gt;.b&lt;/span&gt;&lt;span&gt;.w&lt;/span&gt;&lt;span&gt;.e&lt;/span&gt;&lt;span&gt;.tomcat&lt;/span&gt;&lt;span&gt;.GracefulShutdown&lt;/span&gt;  : &lt;span&gt;Graceful&lt;/span&gt; &lt;span&gt;shutdown&lt;/span&gt; &lt;span&gt;complete&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;最后，关注本公众号，后台发消息：springboot优雅停机，即可拿到源码。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;首图来自：https://pixabay.com/photos/woman-model-flowers-chrysanthemums-6059236/&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>2a830bfd8fbc9fd0106c7cecdab832ea</guid>
<title>[推荐] Linux 调度系统全景指南（终结篇）</title>
<link>https://toutiao.io/k/ow2rhiz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/8bD08cI97gtcM69EHcDBDvhOXDNpIo7Y4xY8XpEIoib8GeEYnmNlibjdSwqBvHSuu38TgiaFflVhv9byn3DbRmCbA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;pre&gt;&lt;p&gt;&lt;img data-cropselx1=&quot;0&quot; data-cropselx2=&quot;558&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;237&quot; data-ratio=&quot;0.42560553633217996&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/IsrmVA0RIYNibUD5Mz7pTdHok3G6UJVASP3dgDELEY2ficdvYic6om48TcTbErFJiaUmJZibFh4LR9D59ZJ1zKB6Nvg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;289&quot;/&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;| 导语&lt;/span&gt;&lt;span&gt;本文主要是讲Linux的调度系统, 本篇是终结篇，主要讲当前多核系统调度策略和调度优化，调度可以说是操作系统的灵魂，为了让CPU资源利用最大化，Linux设计了一套非常精细的调度系统，对大多数场景都进行了很多优化，系统扩展性强，我们可以根据业务模型和业务场景的特点，有针对性的去进行性能优化。欢迎大家相互交流学习！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;                              目录&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.019455252918287938&quot; data-type=&quot;png&quot; data-w=&quot;514&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/VRxORJYZ4KNh7dvTFCCiaPDepEZG8R7W4sdpA5TzJ5727A9NmeX4HUN0ZG4atXvoxs3OYPu0AicXibgrLIvZic1Q5g/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;476&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;954&quot; data-ratio=&quot;2.1588310038119443&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1ECE0stpb2H78NckHW8qHmy7s3iaINWibkqFLm4wNAkbIeB0jhPyJFt40YC75PUjGibInuVRFQFeLcGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;787&quot;/&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot; mpa-is-content=&quot;t&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;                                 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;多核调度&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.05177993527508091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/C4BflpndvHSxhmF7rr5YNyEb0fEvxc2t2Jrew5jznCicz5fljTns2alIrjYELaHAxlX8YRLaxib1s8g7Iic4BvQXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;618&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在单核系统中，调度器只需要考虑任务执行先后顺序的问题，在多核系统中，除了任务先后问题，调度器还需要考虑CPU分配问题。也就是说，在多核系统中，调度器还需要决定任务在哪个CPU上运行，需要尽量做到公平和整体性能最大化。一般来说，调度器可以被划分为以下几类：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;（1）全局类（Global）&lt;/strong&gt;：即一个调度器就可以管理系统中的所有CPU，任务可以在CPU之间自由迁移。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;（2）集群类（Clustered）&lt;/strong&gt;：系统中的CPU被分成互不相交的几个cluster，调度器负责调度任务到cluster内的CPU上去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;（3）分区类（Partitioned ）&lt;/strong&gt;：每个调度器只管自己的那个CPU，系统有多少个CPU就有多少个调度器实体。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;（4）任意类（Arbitrary ）&lt;/strong&gt;：每一个任务都可以运行在任何一个CPU集合上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;内核调度系统针对CPU架构演进：单CPU-&amp;gt;SMP-&amp;gt;NUMA-&amp;gt;复杂混合架构， 做了针对性的优化设计；&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;SMP&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;       &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.64296875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1EXysvEy7ib5BJK0vLZHc1KWic1ITAM3gmNOJ4VdibiaP32wzTxVB4WbIvDQ6TM7oWkr0KbolicbNmhzXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;SMP （Symmetric Multiprocessing），&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;对称多处理器. 顾名思义, 在SMP中所有的处理器都是对等的, 它们通过总线连接共享同一块物理内存，这也就导致了系统中所有资源(CPU、内存、I/O等)都是共享的，其架构简单，但是拓展性能比较差。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;多处理器系统上，内核必须考虑几个额外的问题，以确保良好的调度效率。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; CPU负荷必须尽可能公平地在所有的处理器上共享。如果一个处理器负责3个并发的应用程序，而另一个只能处理空闲进程，那是没有意义的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;进程与系统中某些处理器的亲合性（affinity）必须是可设置的。例如在4个CPU系统中，可以将计算密集型应用程序绑定到前3个CPU，而剩余的（交互式）进程则在第4个CPU上运行。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;内核必须能够将进程从一个CPU迁移到另一个。但该选项必须谨慎使用，因为它会严重危害性能。在小型SMP系统上CPU高速缓存是最大的问题。对于真正大型系统， CPU与迁移进程此前使用的物理内存距离可能有若干米，因此对该进程内存的访问代价高昂。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;进程对特定CPU的亲合性 ，定义在task_struct的 cpus_allowed 成 员 中 。Linux 提供了sched_setaffinity系统调用，可修改进程与CPU的现有分配关系&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在SMP系统上，每个调度器类的调度方法必须增加两个额外的函数：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;load_balance：&lt;/strong&gt;允许从最忙的就绪队列分配多个进程到当前CPU，但移动的负荷不能比max_load_move更多，每当内核认为有必要重新均衡时，核心调度器代码都会调用这些函数；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;move_one_task：&lt;/strong&gt;move_one_task则使用了iter_move_one_task，从最忙碌的就绪队列移出一个进程，迁移到当前CPU的就绪队列；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在SMP系统上，周期性调度器函数scheduler_tick按上文所述完成所有系统都需要的任务之后，会调用trigger_load_balance函数，&lt;/span&gt;&lt;span&gt;这会引发&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SCHEDULE_SOFTIRQ软中断softIRQ，该中断确保会在适当的时机执行run_rebalance_domains。该函数最终对当前CPU调用rebalance_domains，实现负载均衡。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.33541341653666146&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;641&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1EXysvEy7ib5BJK0vLZHc1KWsWKHUxxlJdKmaAoSxQIZXYhyA8saEb1NXMDtzZyRuYrv2WWqmUq0EA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;NUMA&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;        &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5659777424483307&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1EXysvEy7ib5BJK0vLZHc1KWfL49wZ547572dANRGDqcWibicoTicEKiaWlqbZKGEhOkpibfXqlGSMEHicnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;629&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;非统一内存访问架构&lt;/strong&gt;（英语：&lt;strong&gt;Non-uniform memory access&lt;/strong&gt;，简称NUMA）是一种为多处理器的电脑设计的内存架构，内存访问时间取决于内存相对于处理器的位置。在NUMA下，处理器访问它自己的本地内存的速度比非本地内存（内存位于另一个处理器，或者是处理器之间共享的内存）快一些；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;非统一内存访问架构的特点是：被共享的内存物理上是分布式的，所有这些内存的集合就是全局地址空间。所以处理器访问这些内存的时间是不一样的，显然访问本地内存的速度要比访问全局共享内存或远程访问外地内存要快些。另外，NUMA中内存可能是分层的：本地内存，群内共享内存，全局共享内存；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在NUMA中还有三个节点的概念：&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;       本地节点：对于某个节点中的所有CPU，此节点称为本地节点。&lt;br/&gt;        邻居节点：与本地节点相邻的节点称为邻居节点。&lt;br/&gt;        远端节点：非本地节点或邻居节点的节点，称为远端节点。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;&lt;span&gt;&lt;strong&gt;调度域（Scheduling Domain）&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;Scheduling Domains 是现代硬件技术尤其是多 CPU 多核技术发展的产物。现在，一个复杂的高端系统由上到下可以这样构成：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;它是一个 NUMA 架构的系统，系统中的每个 Node 访问系统中不同区域的内存有不同的速度。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;同时它又是一个 SMP 系统。由多个物理 CPU(Physical Package) 构成。这些物理 CPU 共享系统中所有的内存。但都有自己独立的 Cache 。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每个物理 CPU 又由多个核 (Core) 构成，即 Multi-core 技术或者叫 Chip-level Multi processor(CMP) 。这些核都被集成在一块 die 里面。一般有自己独立的 L1 Cache，但可能共享 L2 Cache 。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每个核中又通过 SMT 之类的技术实现多个硬件线程，或者叫 Virtual CPU( 比如 Intel 的 Hyper-threading 技术 ) 。这些硬件线程，逻辑上看是就是一个 CPU 。它们之间几乎所有的东西都共享。包括 L1 Cache，甚至是逻辑运算单元 (ALU) 以及 Power 。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;在上述系统中，最小的执行单元是逻辑 CPU，进程的调度执行也是相对于逻辑 CPU 的。因此，后文皆简称逻辑 CPU 为 CPU，是物理 CPU 时会特别说明。在这样复杂的系统，调度器要解决的一个首要问题就是如何发挥这么多 CPU 的性能，使得负载均衡。不存某些 CPU 一直很忙，进程在排队等待运行，而某些 CPU 却是处于空闲状态。但是在这些 CPU 之间进行 Load Balance 是有代价的，比如对处于两个不同物理 CPU 的进程之间进行负载平衡的话，将会使得 Cache 失效。造成效率的下降。而且过多的 Load Balance 会大量占用 CPU 资源，为了解决上述的这些问题，内核开发人员 Nick Piggin 等人在 Linux 2.6 中引入基于 Scheduling Domains 的解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;            &lt;/span&gt;&lt;img data-ratio=&quot;0.5260960334029228&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/ibFicPkVFMc1EXysvEy7ib5BJK0vLZHc1KWNrmwBGyGysWFRiboAdOGTLYbeEW1UVibscibuOPH4vA8wgLFpJl1ejjicA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;479&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;每个 Scheduling Domain 其实就是具有相同属性的一组 cpu 的集合。并且跟据 Hyper-threading, Multi-core, SMP, NUMA architectures 这样的系统结构划分成不同的级别。不同级之间通过指针链接在一起，从而形成一种的树状的关系;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;负载平衡就是针对 Scheduling domain 的。从叶节点往上遍历。直到所有的 domain 中的负载都是平衡的。当然对不同的 domain 会有不同的策略识别是否负载不平衡，以及不同的调度策略。通过这样的方式，从而很好的发挥众多 cpu 的效率;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;基于 Scheduling Domains 的调度器引入了一组新的数据结构。下面先讲一下两个主要的数据结构:&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;struct sched_domain: 代表一个 Scheduling Domain，也就是一个 CPU 集合，这个集合里所有的 CPU 都具有相同的属性和调度策略。Load Balance 是针对每个 domain 里的 CPU 进行的。这里要注意 Scheduling Domains 是分级的。像上节所讲的复杂系统就分为 Allnuma_domain,Numa_domain, Phy_domain, Core_domain, Smt_domain(Cpu_domain) 五个等级。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;struct sched_group: 每个 Scheduling domain 都有一个或多个 CPU group，每个 group 都被 domain 当做一个单独的单元来对待。Load Balance 就是在这些 CPU group 之间的 CPU 进行的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;                             &lt;/p&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;                                调度优化&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.05177993527508091&quot; data-type=&quot;png&quot; data-w=&quot;618&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/C4BflpndvHSxhmF7rr5YNyEb0fEvxc2t2Jrew5jznCicz5fljTns2alIrjYELaHAxlX8YRLaxib1s8g7Iic4BvQXA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;    &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当前主流服务器都是多核，多处理器，多NUMA等多CPU架构系统，很多程序都同时跑着服务器里面，怎么最大化利用当前CPU资源， 让整体运行效率更高呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;调度优化的本质 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; CPU资源和任务之间最优匹配&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6797312430011199&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;893&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1EXysvEy7ib5BJK0vLZHc1KW8FmdWpxRGeSHKbaulqH8qg6e3ZNMicxxccIDyWn2b2XWwOcoujJoMoA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里讨论CPU调度优化一些比较常见的优化点，即包括怎么提升CPU性能，怎么提升单个程序性能，也包括怎么提升整个系统的性能，后面计划会详细讨论关于性能优化等内容，本篇探讨了一些优化点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;性能瓶颈&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在进行任何性能优化前，有个很重要的前提原则是要找到性能瓶颈点，然后才能针对性优化，这要求我们学会用性能分析工具：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1HzZqicU39AUTbNqTzZFic1vHialAr1UPBopdx77IDYe852SZwAtqtGaI1yVaKfKCq0iaPFyg2mTuGoNQ/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;perf &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;perf sta&lt;/span&gt;&lt;span&gt;t 采集程序运行事件，用于分析指定程序的性能概况：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5372714486638537&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;711&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1HzZqicU39AUTbNqTzZFic1vH5tO25kvVfRBjOyJAGnJgCuaTwVC3kCichyER6Twkd3EDMqhVrNWdTJA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;task-clock：目标任务真真占用处理器的时间，单位是毫秒，我们称之为任务执行时间，后面是任务的处理器占用率（执行时间和持续时间的比值）。持续时间值从任务提交到任务结束的总时间（总时间在stat结束之后会打印出来）。CPU 利用率，该值高，说明程序的多数时间花费在 CPU 计算上而非 IO。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;context-switches：上下文切换次数，前半部分是切换次数，后面是平均每秒发生次数（M是10的6次方）。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;cpu-migrations：处理器迁移，linux为了位置各个处理器的负载均衡，会在特定的条件下将某个任务从一个处理器迁往另外一个处理器，此时便是发生了一次处理器迁移。即被调度器从一个 CPU 转移到另外一个 CPU 上运行。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;page-fault：缺页异常，linux内存管理子系统采用了分页机制，&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;当应用程序请求的页面尚未建立、请求的页面不在内存中或者请求的页面虽在在内存中，&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;但是尚未建立物理地址和虚拟地址的映射关系是，会触发一次缺页异常。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;cycles：任务消耗的处理器周期数；处理器时钟，一条机器指令可能需要多个 cycles；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;instructions：任务执行期间产生的处理器指令数，IPC（instructions perf cycle）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;IPC（Instructions/Cycles ）是评价处理器与应用程序性能的重要指标。（很多指令需要多个处理周期才能执行完毕），&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;IPC越大越好，说明程序充分利用了处理器的特征。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;branches：程序在执行期间遇到的分支指令数。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;branch-misses：预测错误的分支指令数&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;cache-misses：cache时效的次数&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;cache-references：cache的命中次数&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;perf top &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;对系统性能进行实时分析：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6012558869701727&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;637&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1HzZqicU39AUTbNqTzZFic1vHibheJg8MEr2YLib5EpL0SCHXDZm4vO7rDHXUPwExibGHcdvDXwfSRt8sw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;可以观察到当前函数CPU使用占比；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以查看当前系统最耗时的内核函数或某个用户进程&lt;/span&gt;；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;可以查看到当前耗时的指令；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;CPU 火焰图&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.449955713020372&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1129&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1HzZqicU39AUTbNqTzZFic1vHUfIxOfu9eXQFaz9j6icX8UM2gjWthqydia8TfMuVcm8xbIUkJAVLvicHw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持多种工具源，可以从包含堆栈跟踪的任何配置文件数据生成火焰图，包括从以下配置文件工具生成：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Linux: perf, eBPF, SystemTap, and ktap&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Solaris, illumos, FreeBSD: DTrace&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Mac OS X: DTrace and Instruments&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Windows: Xperf.exe&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以查看哪些代码路径很热（CPU占有率高）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以显示堆栈路径上CPU消耗，找到耗时的最多的函数；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1&gt;&lt;strong&gt;&lt;span&gt;gperf 性能检测&lt;/span&gt;&lt;/strong&gt;&lt;/h1&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.58671875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1HzZqicU39AUTbNqTzZFic1vHmjfsxwbfM1yTKlybWFkfgfk0MGfKzZAFIfPZIKSXmrVcia7It9LarTA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1622596241525&quot; data-category_id_list=&quot;48|32|26|49|1|27|28|45|46|55|39|8|3|47|35|41|5|31|6|7|24|37|22|11|50|54|53|52|42|29|43|16|17|51|36&quot; data-id=&quot;1622596241525&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;性能优化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;局部性原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;局部性有两种，即时间局部性和空间局部性。时间局部性是指当一个数据被访问后，它很有可能会在不久的将来被再次访问，比如循环代码中的数据或指令本身。而空间局部性指的是，当程序访问地址为&lt;/span&gt;&lt;em&gt;x&lt;/em&gt;&lt;span&gt;的数据时，很有可能会紧接着访问&lt;/span&gt;&lt;em&gt;x&lt;/em&gt;&lt;span&gt;周围的数据，比如遍历数组或指令的顺序执行。由于这两种局部性存在于大多数的程序中，硬件系统可以很好地预测哪些数据可以放入缓存，从而运行得很好。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6921875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1GnwrlY72QGSFTn9WTVl525XWx2yhXYicZEQ49WmoA4oxiak3SI7xnKuwalzJ1Om9Rk2jQFNt1rnZjg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缓存访问在设计多处理器调度时遇到的最后一个问题，是所谓的缓存亲和度（cache affinity）。这个概念很简单：一个进程在某个CPU上运行时，会在该CPU的缓存中维护许多状态。下次该进程在相同CPU上运行时，由于缓存中的数据而执行得更快。相反，在不同的CPU上执行，会由于需要重新加载数据而很慢（好在硬件保证的缓存一致性可以保证正确执行）。因此多处理器调度应该考虑到这种缓存亲和性，并尽可能将进程保持在同一个CPU上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;NUMA优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4621212121212121&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1EBUR11xGfGu9jEjRmAnib1JaAFnzJ205KamGH3vjlMFNDTt2RStbPEf3hqL0FSGiabcHuLfGhn0VibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;660&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比起访问remote memory，local memory 访问不仅延迟低(100ns)，而且也减少了对公共总线（interconnect)的竞争。因此合理地放置数据(比如直接调用NUMA api) ，  软件调优化基本上还是围绕在尽量访问本地内存这一思路上。如果本地内存已用完，那么尽量访问本CPU下相临节点的内存，避免访问跨CPU访问最远端的内存，可以提高20-30%性能，具体数据和当前应用相关。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;CPU资源优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CPU独占：独占CPU资源，减少调度影响，提高系统性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CPU绑定：减少CPU上下文切换，提高系统性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;中断亲和 : 中断负载均衡，减轻其他CPU负担，提高系统性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;进程亲和：减少CPU上下文切换，提高系统性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;中断隔离：减少中断对CPU调度影响，提高系统性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;内存优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;时钟优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;优先级优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;调度算法优化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; linux 系统一些主线调度算法演进：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;strong&gt;O(n)调度算法&lt;/strong&gt; -&lt;span&gt;2.4时代&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8944365192582026&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1GnwrlY72QGSFTn9WTVl525LNcndbSbe5HW7fmSVBEibxIKvN7E8C4gszFgUezv3B7ckaibrYXfM8Mw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;701&quot;/&gt;&lt;/p&gt;&lt;h3 name=&quot;O(n)%E8%B0%83%E5%BA%A6%E5%99%A8%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98&quot;&gt;O(n)调度器&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;调度器采用基于优先级的设计；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;pick next算法非常简单：对runqueue中所有进程的优先级进行依次进行比较，选择最高优先级的进程作为下一个被调度的进程；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每次进程切换时, 内核扫描可运行进程的链表, 计算优先级,然后选择”最佳”进程来运行；&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 name=&quot;O(n)%E8%B0%83%E5%BA%A6%E5%99%A8%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98&quot;&gt;O(n)调度器面临的问题&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;时间复杂度问题，时间复杂度是O(n),当系统中的进程很少的时候性能还可以，但是当系统中的进程逐渐增多，选择下一个进程的时间则是逐渐增大。而且当系统中无可运行的进程时，重新初始化进程的时间片也是相当耗时，在系统中进程很多的情况系下。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;SMP扩展问题。当需要picknext下一个进程时，需要对整个runqueue队列进行加锁的操作，spin_lock_irq(&amp;amp;runqueue_lock);当系统中进程数目比较多的时候，则在临界区的时间就比较长，导致其余的CPU自旋比较浪费&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;实时进程的运行效率问题，因为实时进程和普通进程在一个列表中，每次查实时进程时，都需要全部扫描整个列表，导致实时进程不是很“实时”&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;CPU资源浪费问题：因为系统中只有一个runqueue,则当运行队列中的进程少于CPU的个数时，其余的CPU则几乎是idle状态，浪费资源&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;cache缓存问题：当系统中的进程逐渐减少时，原先在CPU1上运行的进程，不得不在CPU2上运行，导致在CPU2上运行时，cacheline则几乎是空白的，影响效率。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;总之O(n)调度器有很多问题，不过有问题肯定要解决的。所以在Linux2.6引入了O(1)的调度器。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;strong&gt;O(1)调度算法 -&lt;span&gt;2.6&lt;/span&gt;时代&lt;br/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.0813953488372092&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1GnwrlY72QGSFTn9WTVl5255ibRtYdctHMibWwMtKYt9hA8aqRrx4Z8BXylJS0ribY5CBbsJ7R2MHOmw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;              &lt;/p&gt;&lt;h3 name=&quot;O(n)%E8%B0%83%E5%BA%A6%E5%99%A8%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98&quot;&gt;O(1)调度器：&lt;/h3&gt;&lt;h3 name=&quot;O(n)%E8%B0%83%E5%BA%A6%E5%99%A8%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98&quot;&gt;O(1)调度器面临的问题&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;CFS调度算法&lt;/strong&gt; -如今主流&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CFS 背后的主要想法是维护为任务提供处理器时间方面的平衡（公平性）。这意味着应给进程分配相当数量的处理器。分给某个任务的时间失去平衡时（意味着一个或多个任务相对于其他任务而言未被给予相当数量的时间），应给失去平衡的任务分配时间，让其执行&lt;/span&gt;；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CFS 在叫做vruntime-&lt;/span&gt;&lt;em&gt;虚拟运行时&lt;/em&gt;&lt;span&gt; 的地方维持提供给某个任务的时间量。任务的虚拟运行时越小， 意味着任务被允许访问服务器的时间越短 — 其对处理器的需求越高&lt;/span&gt;；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CFS 不直接使用优先级而是将其用作允许任务执行的时间的衰减系数。低优先级任务具有更高的衰减系数，而高优先级任务具有较低的衰减系数。这意味着与高优先级任务相比，低优先级任务允许任务执行的时间消耗得更快。这是一个绝妙的解决方案，可以避免维护按优先级调度的运行队列&lt;/span&gt;；&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CFS 维护了一个以时间为顺序的红黑树&lt;/span&gt;，&lt;span&gt;任务存储在以时间为顺序的红黑树中&lt;/span&gt;，&lt;span&gt;对处理器需求最多的任务 （最低虚拟运行时）存储在树的左侧，处理器需求最少的任务（最高虚拟运行时）存储在树的右侧&lt;/span&gt;，pick_next算法选择vruntime最小进程运行，即&lt;span&gt;选取红黑树最左端的节点调度为下一个以便保持公平性&lt;/span&gt;；&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6383442265795207&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;459&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1GnwrlY72QGSFTn9WTVl525rM4Qm9ia1QFEDYz3USuJWLM0nGj0X9xnTIsrxOeHk55O5aANkvz1BZA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; BFS &amp;amp; MuqSS-面向桌面或移动设备调度器&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;BFS的原理十分简单，其实质正是使用了O(1)调度器中的位图的概念，所有进程被安排到103个queue中，各个进程不是按照优先级而是按照优先级区间被排列到各自所在的区间，每一个区间拥有一个queue：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6302325581395349&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;430&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1GnwrlY72QGSFTn9WTVl525ut8C5NfHBqPtdwPGsBTsxjicP0ibmcKJs8v4sgSGibQw7uGNRYn6nhp5Q/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;BFS 是一个适用于桌面或移动设备的调度器，设计地比较简洁，用于改善桌面应用的交互性，减小响应时间，提升用户体验。它采用了全局单任务队列设计，不再让每个 CPU 都有独立的运行队列。虽然使用单个全局队列，需要引入队列锁来保证并发安全性，但是对于桌面系统而言，处理器通常都比较少，锁的开销基本可以忽略。BFS 每次会在任务链表中选择具有最小 virtual deadline 的任务运行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.54765625&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1GnwrlY72QGSFTn9WTVl525u1RAFF76RA7L1qDypGanm7GNfkIicslmguOXRD2hYaiaib4YMSlJK8CEQ/640?wx_fmt=png&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;MuqSS 是作者后来基于 BFS 改进的一款调度器，同样是用于桌面环境任务调度。它主要解决了 BFS 的两个问题：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;并行优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;并行&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：多个任务在同一时刻一起发生;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;并发&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：多个任务在同一时刻只能有一个发生，CPU快速切换-操作系统分时复用，给人的感觉还是同时在跑，本质还是串行执行；&lt;/span&gt;&lt;span&gt;并发的关键是你有处理多个任务的能力，不一定要同时；&lt;/span&gt;&lt;span&gt;并行的关键是你有同时处理多个任务的能力，必须在多核系统上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;在多核系统中需要并行编程提高CPU运行效率&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一般采用多线程来实现并行计算来缩短计算时间，提高多核系统整体性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通常是一个线程绑定一个核，可以实现多线程程序CPU利用率最大化；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;尽量使用线程 local 数据，减少共享数据访问；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;尽量使用线程栈内存（local变量），减少指针引用，数据结构内存对齐（利用编译指令），减少cache miss；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;了解参考一些经典成熟并行编程模型对你设计多线程并行程序大有裨益：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.2884927066450567&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1234&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1HzZqicU39AUTbNqTzZFic1vHokKoVzAkIVgTUPsO17moymfCLjwOz0a7SiafX2miceo9VsKECetnzkHg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;       https://zh.wikipedia.org/wiki/%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;锁和无锁设计优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如何正确有效的保护共享数据是编写并行程序必须面临的一个难题，通常的手段就是同步。同步可分为阻塞型同步（Blocking Synchronization）和非阻塞型同步（ Non-blocking Synchronization），多&lt;/span&gt;&lt;span&gt;线程里面难免需要访问&quot;共享内存&quot;，如果不加锁很容易导致结果异常&lt;/span&gt;&lt;span&gt;，程序首先要保证正确，即使影响性能低也需要加锁来防止错误，此时该怎么提高&lt;/span&gt;&lt;span&gt;CPU执行性能呢？ 一个比较重要的优化工作是锁需要精心设计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;阻塞锁&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;阻塞锁通过改变了线程的运行状态。让线程进入阻塞状态进行等待，当获得相应的信号（唤醒，时间） 时，才可以进入线程的准备就绪状态，准备就绪状态的线程，通过竞争，进入运行状态；&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;mutex 主要用于线程间互斥访问资源场景；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;semaphore 主要用于多个线程同步场景；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;读写锁针主要用于读多写少场景；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;非阻塞锁&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;非阻塞锁不会改变线程状态，使用时不会产生调度，通过CPU忙等待或者基于&lt;span&gt;CAS（Compare - And - Swap）原子&lt;/span&gt;操作指令实现非阻塞访问资源；&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;自旋锁底层通过控制原子变量的值，让其他CPU忙等待，cache亲和性高和控制好锁粒度，可以提高多线程访问资源效率，主要用于加锁时间极短且无阻塞点场景；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;RCU锁(Read-Copy Update)--非常重要一种无锁设计，对于被RCU保护的共享数据结构，读者不需要获得任何锁就可以访问它（因此不会导致锁竞争，不会导致锁竞争，内存延迟以及流水线停滞，读效率极高），但写者在访问它时首先拷贝一个副本，然后对副本进行修改，最后使用一个回调（callback）机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据。这个时机就是所有引用该数据的CPU都退出对共享数据的操作，RCU实际上是一种改进的读写锁，更能提高读多写少场景的系统性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;原子操作可以保证指令以原子的方式执行（锁总线或者锁CPU缓存）——执行过程不被打断,主要用于全局统计、引用计数，无锁设计等场景；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CAS操作（Compare And Set或是 Compare And Swap），现在几乎所有的CPU指令都支持CAS的原子操作，X86下对应的是 CMPXCHG 汇编指令。有了这个原子操作，我们就可以用其来实现各种无锁（lock free）的数据结构，主要用于各种追求极限高性能场景，比如内存数据库，内存消息队列，DPDK的内存池mempool，java 的&lt;span&gt;Disruptor等&lt;/span&gt;；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;真正无锁-没有资源冲突，每个线程只使用local数据，最高级别的无锁设计，适合分而治之算法场景；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;IO优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;零拷贝:  减少驱动到协议栈之间内存拷贝，减少用户空间到内核空间内存拷贝，提升IO性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;网卡硬件升级：10G-&amp;gt;25G-&amp;gt;40G-&amp;gt;100G-&amp;gt;200G-&amp;gt;400G-&amp;gt;...；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;kernelbypass：绕过内核协议栈（路径长，多核性能差），提高IO吞吐量；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;   DPDK： &lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Intel DPDK全称Intel Data Plane Development Kit，是intel提供的数据平面开发工具集，为Intel architecture（IA）处理器架构下用户空间高效的数据包处理提供库函数和驱动的支持，它不同于Linux系统以通用性设计为目的，而是专注于网络应用中数据包的高性能处理，适合高性能网关(IO需求大）场景；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.62734375&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1HzZqicU39AUTbNqTzZFic1vHRLOnstsz8urg7oueVQFTYHfoDiavczo2noB7Qn5GicdrlX0dIePGH4ZA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;PMD用户态驱动，使用无中断方式直接操作网卡的接收和发送队列；&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;采用&lt;/span&gt;&lt;span&gt;HugePage&lt;/span&gt;&lt;span&gt;减少TLB Miss；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DPDK采用向量SIMD指令优化性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;CPU亲缘性和独占；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;内存对齐：根据不同存储硬件的配置来优化程序，确保对象位于不同channel和rank的起始地址，这样能保证对象并并行加载，性能也能够得到极大的提升；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Cache对齐，提高cache访问效率：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;NUMA亲和，提高numa内存访问性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;减少进程上下文切换：保证活跃进程数目不超过CPU个数；减少堵塞函数的调用，尽量采样无锁数据结构；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;利用空间局部性，采用预取Prefetch，在数据被用到之前就将其调入缓存，增加缓存命中率；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;充分挖掘网卡的潜能：借助现代网卡支持的分流（RSS, FDIR）和卸载（TSO，chksum）等特性；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;   XDP:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.546875&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1HzZqicU39AUTbNqTzZFic1vHunA467uj6iazVYiaCVGn4qc78LPNfDia9zib9hgOWa5SMN0DSWJ2hrkibEA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt; XDP（eXpress Data Path）为Linux内核提供了高性能、可编程的网络数据路径。由于网络包在还未进入网络协议栈之前就处理，它给Linux网络带来了巨大的性能提升（性能比DPDK还要高）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;在网络协议栈前处理&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;无锁设计&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;批量I/O操作&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;轮询式&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;直接队列访问&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;DDIO（网卡直接IO），支持硬件offload加速&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;支持eBPF，高效开发，安全可靠，性能好&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;和内核耦合紧密，适合基于内核网络组件平滑演进高性能方案，比如DDOS防护，网络采&lt;/span&gt;&lt;span&gt;样，高性能防火墙；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;  P4 &lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.44144144144144143&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;555&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1HzZqicU39AUTbNqTzZFic1vHsiabaJzDxGEuuU8IU9icSsCKOXia4tDmyRibmvxU0or1lojkPRo0ibkcCLA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;p4 为一种高级可编程协议无关处理语言，结合可编程交换机芯片，编程能力强，&lt;/span&gt;&lt;span&gt;可以实现业务offload 到硬件，转发面 p4lang 定制开发，控制面可通过 Apache Thrift、gRPC 接口远程管理，生态繁荣包括P4 Runtime、Stratum；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;性能高&lt;/span&gt;&lt;span&gt;，&lt;strong&gt;1.8T ~ 6.5T&lt;/strong&gt; 线速转发，&lt;/span&gt;&lt;span&gt;&lt;span&gt;更低时延&lt;/span&gt;；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;每Tbps设备成本大幅降低；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;主要应用场景是大流量的边界网关，大流量无状态网关，大流量状态网关（当前P4交换机对内存容量支持有限，对配置量有一定的限制）；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;时空互换&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Per CPU&lt;/p&gt;&lt;p&gt;Per-CPU是基于空间换时间的方法, 让每个CPU都有自己的私有数据段(放在L1中),并将一些变量私有化到 每个CPU的私有数据段中. 单个CPU在访问自己的私有数据段时, 不需要考虑其他CPU之间的竞争问题,也不存在同步的问题.  注意只有在该变量在各个CPU上逻辑独立时才可使用。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;指&lt;/span&gt;&lt;span/&gt;&lt;span&gt;令并行&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;通过展开循环降低循环开销，提高指令并行执&lt;/span&gt;&lt;span&gt;行效率；&lt;/span&gt;&lt;/section&gt;&lt;h1&gt;&lt;span&gt;采用SIMD扩展指令集来优化指令执行效率；&lt;/span&gt;&lt;/h1&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;分支预测&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9574014909478168&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;939&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibFicPkVFMc1HzZqicU39AUTbNqTzZFic1vHQFyN2p3moJXGiaEDoiaicFODxaLmicRPFYKkwa2xP3ykeEVYRQFTGV3P2g/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;分支预测采用空间换时间方式，直接预测分支条件，把分支指令填入流水线，如果预测失败，再回滚清空流水线，重新选择分支，通过采用有效的预测算法，可以极大提高CPU流水线的执行效率，我们需要合理利用这个特性，减少分支判断，在代码中采用编&lt;/span&gt;&lt;span&gt;译指令优化提供分支预测准确性，比如在linux内核中，提分支预测的信息提供给编译器&lt;/span&gt;&lt;span&gt;: &lt;/span&gt;&lt;span/&gt;&lt;span&gt;l&lt;/span&gt;&lt;span&gt;ikely(x)  表示x的值为真的可能性更大；&lt;/span&gt;&lt;span&gt;u&lt;/span&gt;&lt;span/&gt;&lt;span&gt;nlik&lt;/span&gt;&lt;span&gt;ely(x)   表示x的值为假的可能性更大；&lt;/span&gt;&lt;span&gt;这样编译器对代码进行优化，以减少指令跳转带来的性能下&lt;/span&gt;&lt;span&gt;降。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;BIOS优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;BIOS（基本输入/输出系统）是主板上的一个小内存，其数据定义了系统的配置。某些数据被写入死存储器（ROM），因此无法更改。另一方面，某些配置可以从BIOS配置中访问，我们在启动PC时通过按键激活该配置。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;超线程优化（&lt;span&gt;Hyper-Threading&lt;/span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;超线程，是一种用于提升CPU计算并行度的处理器技术，用一个物理核模拟两个逻辑核。这两个逻辑核拥有自己的中断、状态，但是共用物理核的计算资源（寄存器）。超线程技术旨在提高CPU计算资源的使用率，从而提高计算并行度。但是超线程也&lt;/span&gt;&lt;span&gt;有副作用，会产生访问cache的竞争，会导致更多的cache不命中(cache-miss)，增加线程间的通信负载。加大内存的通信带宽，I/O总线的压力，所以对于一些高性能程序，一般是需要关闭超线程的；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;电源模式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果服务器想获得最大的吞吐量或最低的延迟，修改电源模式为最大性能，可以提高服务器的性能；&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;h4&gt;&lt;span&gt;Lockstep模式&lt;/span&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;锁步模式对内存进行了更高的校验，提升了系统的可靠性，但是降低了内存访问的带宽和延时，对于实时性要求高，吞吐量大的业务场景不适用，对于这些场景从系统，软件和方案层面都有完善的保护机制，所以建议关闭;&lt;/span&gt;&lt;/h4&gt;&lt;/li&gt;&lt;li&gt;&lt;h4&gt;&lt;span&gt;Turbo Mode&lt;/span&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;Turbo boost就是Intel的睿频加速技术，通常所说的自动超频技术，主要用于提升处理器的频率，最大程度发挥处理器性能;&lt;/span&gt;&lt;br/&gt;&lt;/h4&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;批量合并&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;预处理&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;预处理策略就是提前做好一些准备工作，这样可以提高后续处理性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;比如网站页面资源的提前加载，可以显著地提升页面下载性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;比如CPU 预取指令，提前将所需要的数据和指令取出来，可以提高流水线效率和缓存效率；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;惰性求值&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;惰性处理策略就是尽量将操作（比如计算），推迟到必需执行的时刻，这样很可能避免多余的操作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Linux COW（Copy On Write，写时复制）机制，比如fork 调用只有真正用到资源时候才拷贝；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;中断后半部分优化，把可延迟函数放到延后处理，从而提高中断处理整体效率；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;缺页中断处理，不需要进程把所有内存页载入内存，只有需要的时候再加载，这样可以减少大量无效内存操作，提高整体性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;架&lt;/span&gt;&lt;span&gt;构优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;系统资源优化：物理机器-&amp;gt;集群-&amp;gt;虚拟化-&amp;gt;云计算-&amp;gt;容器-&amp;gt;k8s编排器；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;应用架构优化： 单体应用-&amp;gt;基于组件-&amp;gt;面向服务-&amp;gt;微服务；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;软件工程优化： 瀑布模型-&amp;gt;敏捷开发-&amp;gt;DevOps-&amp;gt;智能化工程，主要是提高研发效能，建设产品的性能测试CI/CD自动化流水线，每个优化点都可以及时查看到性能指标变化和对比，从小作坊到标准化，工业化，智能化发展；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;算法优化&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;代码优化&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;循环优化：适当展开循环，可以让指令并行执行，提供搞性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;条件判断：减少条件判断语句，可以减少分支预测失败概率，提升CPU流水线效率，从而提升性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;表达式优化： 优化布尔逻辑可以减少不必要计算；使++i而不使用i++可以减少中间临时变量；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;采用位运算：如果没有越界风险，使用位运算符合计算机计算模型，效率更高；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;内存&amp;amp;cache对齐：数据结构最好是cache 对齐的整数倍，把高频使用的属性，放到最前面，这样可以提高cache命中效率，减少Cache miss；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;指针优化：尽量减少指针使用，指针跳转会导致Cache miss；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;向量化：合适使用SIMD高级指令可以优化代码；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;插入其他语言：插入汇编，优化高频函数；采用CPython优化python代码；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;递归优化：尽量把递归修&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;改为循环，减少递归调用代价；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;编译优化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;编译器优化：O0 --&amp;gt;&amp;gt; O1 --&amp;gt;&amp;gt; O2 --&amp;gt;&amp;gt; O3，来额外的性能提升；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;编译器API：使用内联函数，使用内存对齐API，使用cache对齐API等 ，可以更好让编译器优化代码，减少调用指令，提高性能；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;JIt编译器优化：使用Jit技术，可以把中间代码生成本地指令，提升代码执行效率；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;优化无止境，上面每一个优化点，都可以更详细展开讲，更多是需要我们深入理解计算机原理，才能找到得更多优化点，让我们向顶级程序员迈进；&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>