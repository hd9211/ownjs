<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>98ee5bbf770316434e25a88816084598</guid>
<title>面试：为了进阿里，必须掌握 HashMap 源码原理和面试题（图解版一）</title>
<link>https://toutiao.io/k/vl7rvfr</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;h1 cid=&quot;n0&quot; mdtype=&quot;heading&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;欢迎关注公众号【&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;Ccww技术博客&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;】，原创技术文章第一时间推出&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/h1&gt;&lt;hr/&gt;&lt;h3 cid=&quot;n2&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p cid=&quot;n3&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;集合在基础面试中是必备可缺的一部分，其中重要的HashMap更是少不了，那面试官会面试中提问那些问题呢，这些在JDK1.7和1.8有什么区别？？&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n4&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n6&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;HashMap的底层原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n8&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;HashMap的hash哈希函数的设计原理，以及HashMap下标获取方式？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n10&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;HashMap扩容机制，hashMap中什么时候需要进行扩容，扩容resize()又是如何实现的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n12&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;hashMap中put是如何实现的 ，JDK1.7和1.8有什么区别？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n14&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;hashMap中get是如何实现的&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n16&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;其他涉及问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n17&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n19&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;HashMap具备的特性&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n21&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;为什么Hash的底层数据长度总为2的N次方？如果输入值不是2的幂比如10会怎么样？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n23&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;加载因子为什么是 0.75？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n25&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;哈希表如何解决Hash冲突&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n27&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;当有哈希冲突时，HashMap 是如何查找并确认元素的？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n29&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;HashMap 是线程安全的吗，为什么不是线程安全的？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;hr/&gt;&lt;h3 cid=&quot;n32&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;1. HashMap的底层原理&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p cid=&quot;n33&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;JDK1.7使用的是数组+ 单链表的数据结构。JDK1.8之后，使用的是数组+链表+红黑树的数据结构&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n34&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;HashMap数据结构图（jdk1.8）&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n35&quot; mdtype=&quot;paragraph&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.573943661971831&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDriatqsuMHWsaacfH3j6lpw9YmAsnANIrHEz6efzy1BvJDibR7ib8pRaPC6Ik4Qdhiae8Ym3UKJknoLOYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;568&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; TREEIFY_THRESHOLD = &lt;span class=&quot;code-snippet__number&quot;&gt;8&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; UNTREEIFY_THRESHOLD = &lt;span class=&quot;code-snippet__number&quot;&gt;6&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; MIN_TREEIFY_CAPACITY = &lt;span class=&quot;code-snippet__number&quot;&gt;64&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p cid=&quot;n37&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;从HashMap常量中可以看出，当链表的深度达到8的时候，也就是默认阈值TREEIFY_THRESHOLD=8，就会自动扩容把链表转成红黑树的数据结构来把时间复杂度从O(n)变成O(logN)提高了效率，而且当进行resize操作时，若桶中数量少于6则从树转成链表。&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n38&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;那为什么数据结构需要从JDK1.7换成JDK1.8的数组+链表+红黑树？&lt;/span&gt;&lt;/h4&gt;&lt;p cid=&quot;n39&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;在JDK1.7中，当相同的hash值时，HashMap不断地产生碰撞，那么相同key位置的链表就会不断增长，当查询HashMap的相应key值的Vaule值时，就会去循环遍历这个超级大的链表，查询性能非常低下。&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n40&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;但在JDK1.8当链表超过8个节点数时，将会让红黑树来替代链表，查询性能得到了很好的提升，从原来的是O(n)到O(logn)。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h3 cid=&quot;n42&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;2. HashMap的hash哈希函数的设计原理，以及HashMap下标获取 hash &amp;amp;（n - 1）？&lt;/span&gt;&lt;br/&gt;&lt;/h3&gt;&lt;h4 cid=&quot;n43&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;hash哈希函数的设计原理&lt;/span&gt;&lt;/h4&gt;&lt;pre spellcheck=&quot;false&quot; lang=&quot;java&quot; cid=&quot;n44&quot; mdtype=&quot;fences&quot;&gt;&lt;span&gt;&lt;span role=&quot;presentation&quot;&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;hash&lt;/span&gt;(&lt;span&gt;Object&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;) {&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;int&lt;/span&gt; &lt;span&gt;h&lt;/span&gt;;&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;    &lt;span&gt;return&lt;/span&gt; (&lt;span&gt;key&lt;/span&gt; &lt;span&gt;==&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;?&lt;/span&gt; &lt;span&gt;0&lt;/span&gt; : (&lt;span&gt;h&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;.&lt;span&gt;hashCode&lt;/span&gt;()) &lt;span&gt;^&lt;/span&gt; (&lt;span&gt;h&lt;/span&gt; &lt;span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;);&lt;/span&gt;&lt;br/&gt;&lt;span role=&quot;presentation&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.32936507936507936&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDriatqsuMHWsaacfH3j6lpw9YDRqM9pcmhradXMYnxd3AwDG1nKSzxeoaoZ6KEE8frPKic89rp9PhhyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;756&quot;/&gt;&lt;/p&gt;&lt;h4 cid=&quot;n51&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;HashMap下标获取h % n = h &amp;amp;（n - 1）&lt;/span&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5994729907773386&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDriatqsuMHWsaacfH3j6lpw9YS3QHaO147Jxib8Z1r3iaZv1q9C4KE8jOqQnMia8q82GeSo0moQGiafz7eA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;759&quot;/&gt;&lt;/h4&gt;&lt;p cid=&quot;n58&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;设计原因：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;&quot; cid=&quot;n59&quot; mdtype=&quot;list&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n61&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;一定要尽可能降低hash碰撞，越分散越好；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n63&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;算法一定要尽可能高效，因为这是高频操作, 因此采用位运算；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p cid=&quot;n64&quot; mdtype=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h3 cid=&quot;n65&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;3. HashMap扩容机制resize（）&lt;/span&gt;&lt;/h3&gt;&lt;p cid=&quot;n66&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;strong&gt;HashMap扩容步骤分成两步：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4 cid=&quot;n73&quot; mdtype=&quot;heading&quot;&gt;&lt;span&gt;获取新值：新的容量值newCap ，新的扩容阀界值newThr获取&lt;/span&gt;&lt;/h4&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Node&amp;lt;K,V&amp;gt;[] oldTab = table;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; oldCap = (oldTab == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) ? &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; : oldTab.length;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; oldThr = threshold;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt; newCap, newThr = &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;threshold = newThr;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Node&amp;lt;K,V&amp;gt;[] newTab = (Node&amp;lt;K,V&amp;gt;[])&lt;span class=&quot;code-snippet__keyword&quot;&gt;new&lt;/span&gt; Node[newCap];&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; table = newTab;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;kotlin&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (oldCap &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (oldCap &amp;gt;= MAXIMUM_CAPACITY) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            threshold = Integer.MAX_VALUE;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;             &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; oldTab;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; ((newCap = oldCap &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;) &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                   oldCap &amp;gt;= DEFAULT_INITIAL_CAPACITY)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           newThr = oldThr &amp;lt;&amp;lt; &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n74&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot; cid=&quot;n81&quot; mdtype=&quot;list&quot; data-mark=&quot;-&quot;&gt;&lt;li&gt;&lt;p cid=&quot;n83&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;如果此时oldCap&amp;gt;=MAXIMUM_CAPACITY(1 &amp;lt;&amp;lt; 30)，表示已经到了最大容量，这时还要往map中put数据，则阈值设置为整数的最大值 Integer.MAX_VALUE，直接返回这个oldTab的内存地址&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p cid=&quot;n85&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;如果扩容之后的新容量小于最大容量 ，且老的数组容量大于等于默认初始化容量（16），那么新数组的扩容阀值设置为老阀值的2倍（左移1位相当于乘以2，newCap = oldCap &amp;lt;&amp;lt; 1），阈值也double（newThr= oldThr &amp;lt;&amp;lt; 1）;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (oldThr &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;newCap = oldThr;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;....&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (newThr == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt; ft = (&lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt;)newCap * loadFactor;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     newThr = (newCap &amp;lt; MAXIMUM_CAPACITY &amp;amp;&amp;amp; ft &amp;lt; (&lt;span class=&quot;code-snippet__keyword&quot;&gt;float&lt;/span&gt;)MAXIMUM_CAPACITY ?&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;)ft : Integer.MAX_VALUE);  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           newCap = DEFAULT_INITIAL_CAPACITY;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           newThr = (&lt;span class=&quot;code-snippet__keyword&quot;&gt;int&lt;/span&gt;)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p cid=&quot;n93&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p cid=&quot;n93&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;数据迁移&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n96&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;如果oldTab老数组不为空，说明是扩容操作，那么涉及到元素的转移操，遍历老数组，如果当前位置元素不为空，那么需要转移该元素到新数组。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (e.next == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;)  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;newTab[e.hash &amp;amp; (newCap - &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;)] = e;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;   &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (e &lt;span class=&quot;code-snippet__keyword&quot;&gt;instanceof&lt;/span&gt; TreeNode)  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          ((TreeNode&amp;lt;K,V&amp;gt;)e).split(&lt;span class=&quot;code-snippet__keyword&quot;&gt;this&lt;/span&gt;, newTab, j, oldCap);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Node&amp;lt;K,V&amp;gt; loHead = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;, loTail = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Node&amp;lt;K,V&amp;gt; hiHead = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;, hiTail = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Node&amp;lt;K,V&amp;gt; next;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;do&lt;/span&gt; {  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    next = e.next;                &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; ((e.hash &amp;amp; oldCap) == &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;) {  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (loTail == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                 loHead = e;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              loTail.next = e;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;          loTail = e;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt; {  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;              &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (hiTail == &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                      hiHead = e;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                   hiTail.next = e;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                hiTail = e;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;} &lt;span class=&quot;code-snippet__keyword&quot;&gt;while&lt;/span&gt; ((e = next) != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (loTail != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      loTail.next = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      newTab[j] = loHead;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; (hiTail != &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;) {  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       hiTail.next = &lt;span class=&quot;code-snippet__literal&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       newTab[j + oldCap] = hiHead;                  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/ul&gt;&lt;p cid=&quot;n744&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span&gt;JDK1.8对&lt;/span&gt;&lt;code&gt;resize()&lt;/code&gt;&lt;span&gt;扩容方法进行了优化，&lt;/span&gt;&lt;strong&gt;经过rehash之后，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n744&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;是不是有点不明白呢？那我们来用图来解析一下：&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n746&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;结合&lt;code&gt;e.hash &amp;amp; oldCapn&lt;/code&gt;取值判断是在高位还是在低位，即如图（a）表示扩容前的key1和key2两种key确定索引位置的示例，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.27328431372549017&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDriatqsuMHWsaacfH3j6lpw9YBHLgyPRCRaOWZZFFF2y2Jh19A0r6BnwazHiaEAmP4sAdAcoslj6so5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1632&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图（b）表示扩容后key1和key2两种key确定索引，元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.18984962406015038&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDriatqsuMHWsaacfH3j6lpw9Yms5OpiboDtic3ZScNgicBBx8sgerWlElOnZQLN4p31QcQD2KVP0iahQFVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1064&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“&lt;/span&gt;&lt;code&gt;&lt;span&gt;原索引+oldCap&lt;/span&gt;&lt;/code&gt;&lt;span&gt;”，可以看看下图为16扩充为32的resize示意图：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5757097791798107&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDriatqsuMHWsaacfH3j6lpw9YYvu72ssibnLME4icwlRWbWF5bVRQnXia85OleqdibVTBdPsYAzOxldBaqw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1268&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在JDK1.7中rehash扩容的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同的链表元素会倒置，但是在JDK1.8进行了优化，从上图可以看出，JDK1.8链表元素不会倒置。&lt;/span&gt;&lt;span&gt;因此不会出现链表死循环的问题。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于篇幅过长，将分成两篇来介绍，接下来内容看&lt;/span&gt;&lt;span&gt;《面试：为了进阿里，必须掌握HashMap源码原理和面试题（图解版二）》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n158&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;各位看官还可以吗？喜欢的话，动动手指点个再看💗呗！！谢谢支持！&lt;span md-inline=&quot;linebreak&quot;&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p cid=&quot;n158&quot; mdtype=&quot;paragraph&quot;&gt;&lt;span&gt;欢迎扫码关注，原创技术文章第一时间推出&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.36857142857142855&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;350&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/EvicK4z5ZDrgfBz2Ve78FylxcGWmXaueSuqPguurBCWEkeY1ibeLl1wlxUyibdesc4YeuiaJJjSt6HTiab2iaHyXyyicA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ca7b1683b01879920d7a83d2ca230803</guid>
<title>[译] 仅用 18 行 JavaScript 构建一个倒数计时器</title>
<link>https://toutiao.io/k/qijww23</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3724053724053724&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0ANAsyE4nMbsnrRoddRZl3UltwVTlHofjZZWC4VtyKS2BtDaLdB1cXKyZOpLj4GvWpaSntOJvYWwgw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1638&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;来源：https://www.sitepoint.com，作者：Nilson Jacques&lt;/span&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;第100期了，回馈粉丝，文末参与送书活动！&lt;/span&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有时候，你会需要构建一个JavaScript倒计时时钟。你可能会有一个活动、一个销售、一个促销或一个游戏。你可以用原生的JavaScript构建一个时钟，而不是去找一个插件。尽管有很多很棒的时钟插件，但是使用原生JavaScript可以带来以下好处：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;你的代码将是轻量级的，因为它将具有零依赖性。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;你的网站将表现得更好。你不需要加载外部脚本和样式表。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;你将拥有更多的控制权。你将会建立一个完全按照你的意愿来表现的时钟。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;所以，废话不多说，下面是如何在短短的18行JavaScript中制作自己的倒计时钟。&lt;/span&gt;&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;目录：&lt;/strong&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1.基本时钟：倒数到特定的日期或时间&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2.设置有效的结束日期&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3.计算剩余时间&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4.将时间转换为可用格式&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;5.将时钟数据输出为可重复使用的对象&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;6.在页面上显示时钟，并在时钟为零时停止时钟&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;7.准备展示你的时钟&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;7.1 消除初始延迟&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;7.2 避免不断重建时钟&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;7.3 添加前导0&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;8.更进一步&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;8.1 自动调节时钟&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;8.2 从用户到达起将计时器设置为10分钟&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;8.3 跨页面保持时钟进度&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;9.有关客户端时间的重要警告&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;10.总结&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;11.代码&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1.基本时钟：倒数到特定的日期或时间&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以下是创建基本时钟所需步骤的简要概述：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;设置有效的结束日期。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;计算剩余时间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将时间转换为可用格式。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将时钟数据输出为可重复使用的对象。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在页面上显示时钟，并在时钟为零时停止时钟。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.设置有效的结束日期&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，你需要设置一个有效的结束日期。这应该是JavaScript的 Date.parse() 方法可以理解的任何格式的字符串。例如：&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ISO 8601格式：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; deadline = &lt;span&gt;&#x27;2015-12-31&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;简短格式：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; deadline = &lt;span&gt;&#x27;31/12/2015&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;或者，长格式：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; deadline = &lt;span&gt;&#x27;December 31 2015&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这些格式中的每一种都允许你指定一个准确的时间和一个时区（或者在ISO日期的情况下指定一个与UTC的偏移）。例如：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; deadline = &lt;span&gt;&#x27;December 31 2015 23:59:59 GMT+0200&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3.计算剩余时间&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下一步是计算剩余时间。我们需要编写一个函数，该函数需要一个表示给定结束时间的字符串（如上所述）。然后，我们计算该时间与当前时间之间的时差。看起来像这样：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getTimeRemaining&lt;/span&gt;(&lt;span&gt;endtime&lt;/span&gt;)&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; total = &lt;span&gt;Date&lt;/span&gt;.parse(endtime) - &lt;span&gt;Date&lt;/span&gt;.parse(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;());&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; seconds = &lt;span&gt;Math&lt;/span&gt;.floor( (total/&lt;span&gt;1000&lt;/span&gt;) % &lt;span&gt;60&lt;/span&gt; );&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; minutes = &lt;span&gt;Math&lt;/span&gt;.floor( (total/&lt;span&gt;1000&lt;/span&gt;/&lt;span&gt;60&lt;/span&gt;) % &lt;span&gt;60&lt;/span&gt; );&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; hours = &lt;span&gt;Math&lt;/span&gt;.floor( (total/(&lt;span&gt;1000&lt;/span&gt;*&lt;span&gt;60&lt;/span&gt;*&lt;span&gt;60&lt;/span&gt;)) % &lt;span&gt;24&lt;/span&gt; );&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; days = &lt;span&gt;Math&lt;/span&gt;.floor( total/(&lt;span&gt;1000&lt;/span&gt;*&lt;span&gt;60&lt;/span&gt;*&lt;span&gt;60&lt;/span&gt;*&lt;span&gt;24&lt;/span&gt;) );&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;    total,&lt;br/&gt;    days,&lt;br/&gt;    hours,&lt;br/&gt;    minutes,&lt;br/&gt;    seconds&lt;br/&gt;  };&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;首先，我们要创建一个变量 &lt;/span&gt;&lt;code&gt;&lt;span&gt;total&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 以保留到截止日期为止的剩余时间。&lt;/span&gt;&lt;code&gt;&lt;span&gt;Date.parse()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数将时间字符串转换为毫秒值，这样我们就可以将两次相减，得到中间的时间量。&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; total = &lt;span&gt;Date&lt;/span&gt;.parse(endtime) - &lt;span&gt;Date&lt;/span&gt;.parse(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;4.将时间转换为可用格式&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在我们要将毫秒转换为天，小时，分钟和秒。让我们以秒为例：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; seconds = &lt;span&gt;Math&lt;/span&gt;.floor( (t/&lt;span&gt;1000&lt;/span&gt;) % &lt;span&gt;60&lt;/span&gt; );&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;让我们分解一下这里发生的事情。&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将毫秒除以1000可转换为秒：&lt;/span&gt;&lt;code&gt;&lt;span&gt;(t/1000)&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将总秒数除以60，然后取余数。你不需要所有的秒，只需要计算分钟数后剩下的那些：&lt;/span&gt;&lt;code&gt;&lt;span&gt;(t/1000) % 60&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;四舍五入到最接近的整数。这是因为你需要完整的秒数，而不是几分之一秒：&lt;/span&gt;&lt;code&gt;&lt;span&gt;Math.floor((t/1000)％60)&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;重复此逻辑，将毫秒转换为分钟，小时和天。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1600180410767&quot; data-category_id_list=&quot;1|11|16|17|22|24|26|27|28|29|3|31|32|35|36|37|39|41|42|43|45|46|47|48|49|5|50|51|52|53|54|55|6|7|8&quot; data-id=&quot;1600180410767&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;5.将时钟数据输出为可重复使用的对象&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在准备好几天，几小时，几分钟和几秒钟之后，我们现在可以将数据作为可重复使用的对象返回：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;return&lt;/span&gt; {&lt;br/&gt;  total,&lt;br/&gt;  days,&lt;br/&gt;  hours,&lt;br/&gt;  minutes,&lt;br/&gt;  seconds&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这个对象允许你调用你的函数，并获得任何计算值。这是如何获取剩余分钟数的示例：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;getTimeRemaining(deadline).minutes&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;方便吧？&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;6.在页面上显示时钟，并在时钟为零时停止时钟&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在我们有了一个可以吐出剩余天数、小时、分钟和秒数的函数，我们就可以建立我们的时钟了。首先，我们将创建以下HTML元素来保存时钟：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;clockdiv&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;然后，我们将编写一个函数，在新的div中输出时钟数据：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;initializeClock&lt;/span&gt;(&lt;span&gt;id, endtime&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; clock = &lt;span&gt;document&lt;/span&gt;.getElementById(id);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; timeinterval = setInterval(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; t = getTimeRemaining(endtime);&lt;br/&gt;    clock.innerHTML = &lt;span&gt;&#x27;days: &#x27;&lt;/span&gt; + t.days + &lt;span&gt;&#x27;&amp;lt;br&amp;gt;&#x27;&lt;/span&gt; +&lt;br/&gt;                      &lt;span&gt;&#x27;hours: &#x27;&lt;/span&gt;+ t.hours + &lt;span&gt;&#x27;&amp;lt;br&amp;gt;&#x27;&lt;/span&gt; +&lt;br/&gt;                      &lt;span&gt;&#x27;minutes: &#x27;&lt;/span&gt; + t.minutes + &lt;span&gt;&#x27;&amp;lt;br&amp;gt;&#x27;&lt;/span&gt; +&lt;br/&gt;                      &lt;span&gt;&#x27;seconds: &#x27;&lt;/span&gt; + t.seconds;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (t.total &amp;lt;= &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      clearInterval(timeinterval);&lt;br/&gt;    }&lt;br/&gt;  },&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;该函数有两个参数，这两个参数是包含时钟的元素的id，以及倒计时的结束时间。在函数内部，我们将声明一个 &lt;/span&gt;&lt;code&gt;&lt;span&gt;clock&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 变量，并使用它来保存对时钟容器div的引用。这意味着我们不必一直查询DOM。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来，我们将使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;setInterval&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 每秒执行一个匿名函数。此功能将执行以下操作：&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;计算剩余时间。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;将剩余时间输出到我们的div。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果剩余时间为零停止计时。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此时，剩下的唯一步骤是像这样运行时钟：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;initializeClock(&lt;span&gt;&#x27;clockdiv&#x27;&lt;/span&gt;, deadline);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;恭喜你！现在，你仅用18行JavaScript就拥有了一个基本时钟。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7.准备展示你的时钟&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在设置时钟样式之前，我们需要进行一些改进。&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;消除初始延迟，使你的时钟立即显示。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;让时钟脚本更有效率，这样它就不会连续重建整个时钟。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;根据需要添加前导零。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7.1 消除初始延迟&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在时钟中，我们使用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;setInterval&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 每秒更新一次显示。多数情况下，这很好，除非在开始时会有一秒钟的延迟。要消除此延迟，我们必须在间隔开始之前更新一次时钟。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;让我们将传递给 &lt;/span&gt;&lt;code&gt;&lt;span&gt;setInterval&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的匿名函数移到其自己的单独函数中，我们可以将此函数命名为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;updateClock&lt;/span&gt;&lt;/code&gt;&lt;span&gt;。在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;setInterval&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 外调用一次 &lt;/span&gt;&lt;code&gt;&lt;span&gt;updateClock&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数，然后在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;setInterval&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 内再次调用。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在你的JavaScript中，替换这个&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; timeinterval = setInterval(&lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; { ... },&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;新代码&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;updateClock&lt;/span&gt;()&lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; t = getTimeRemaining(endtime);&lt;br/&gt;  clock.innerHTML = &lt;span&gt;&#x27;days: &#x27;&lt;/span&gt; + t.days + &lt;span&gt;&#x27;&amp;lt;br&amp;gt;&#x27;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&#x27;hours: &#x27;&lt;/span&gt;+ t.hours + &lt;span&gt;&#x27;&amp;lt;br&amp;gt;&#x27;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&#x27;minutes: &#x27;&lt;/span&gt; + t.minutes + &lt;span&gt;&#x27;&amp;lt;br&amp;gt;&#x27;&lt;/span&gt; +&lt;br/&gt;                    &lt;span&gt;&#x27;seconds: &#x27;&lt;/span&gt; + t.seconds;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (t.total &amp;lt;= &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;    clearInterval(timeinterval);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;updateClock(); &lt;span&gt;// 首先运行一函数能以避免延迟&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; timeinterval = setInterval(updateClock,&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7.2 避免不断重建时钟&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们需要使时钟脚本更高效，我们只想更新时钟中的数字，而不是每秒重建整个时钟。实现此目的的一种方法是将每个数字放在 &lt;/span&gt;&lt;code&gt;&lt;span&gt;span&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 标签内，并仅更新这些 &lt;/span&gt;&lt;code&gt;&lt;span&gt;span&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的内容。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这是HTML：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt; &lt;span&gt;id&lt;/span&gt;=&lt;span&gt;&quot;clockdiv&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    Days: &lt;span&gt;&amp;lt;&lt;span&gt;span&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;days&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;span&lt;/span&gt;&amp;gt;&amp;lt;&lt;span&gt;br&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    Hours: &lt;span&gt;&amp;lt;&lt;span&gt;span&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;hours&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;span&lt;/span&gt;&amp;gt;&amp;lt;&lt;span&gt;br&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    Minutes: &lt;span&gt;&amp;lt;&lt;span&gt;span&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;minutes&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;span&lt;/span&gt;&amp;gt;&amp;lt;&lt;span&gt;br&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    Seconds: &lt;span&gt;&amp;lt;&lt;span&gt;span&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;seconds&quot;&lt;/span&gt;&amp;gt;&amp;lt;/&lt;span&gt;span&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在让我们参考这些元素。在定义 &lt;/span&gt;&lt;code&gt;&lt;span&gt;clock&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 变量的位置之后添加以下代码&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; daysSpan = clock.querySelector(&lt;span&gt;&#x27;.days&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; hoursSpan = clock.querySelector(&lt;span&gt;&#x27;.hours&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; minutesSpan = clock.querySelector(&lt;span&gt;&#x27;.minutes&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; secondsSpan = clock.querySelector(&lt;span&gt;&#x27;.seconds&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来，我们需要修改 &lt;/span&gt;&lt;code&gt;&lt;span&gt;updateClock&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数，使其只更新数字。新的代码是这样的：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;updateClock&lt;/span&gt;()&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; t = getTimeRemaining(endtime);&lt;br/&gt;&lt;br/&gt;    daysSpan.innerHTML = t.days;&lt;br/&gt;    hoursSpan.innerHTML = t.hours;&lt;br/&gt;    minutesSpan.innerHTML = t.minutes;&lt;br/&gt;    secondsSpan.innerHTML = t.seconds;&lt;br/&gt;&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;7.3 添加前导0&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在时钟不再每秒都在重建，我们还有另一件事要做：添加前导零。例如，不是让时钟显示7秒，而是显示07秒。一种简单的方法是在一个数的开头加上一串“0”，然后切掉最后两个数字。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;例如，要在“seconds”值上添加前导零，你可以更改以下设置：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;secondsSpan.innerHTML = t.seconds;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;secondsSpan.innerHTML = (&lt;span&gt;&#x27;0&#x27;&lt;/span&gt; + t.seconds).slice(&lt;span&gt;-2&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;如果你愿意，你也可以在分钟和小时的前面加零。如果你已经走到这一步，恭喜你！你的时钟现在已经可以显示了。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;mpcpc js_editor_cpcad=&quot;&quot; class=&quot;js_cpc_area cpc_iframe&quot; src=&quot;/cgi-bin/readtemplate?t=tmpl/cpc_tmpl#1600180422775&quot; data-category_id_list=&quot;1|11|16|17|22|24|26|27|28|29|3|31|32|35|36|37|39|41|42|43|45|46|47|48|49|5|50|51|52|53|54|55|6|7|8&quot; data-id=&quot;1600180422775&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8.更进一步&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;以下示例演示了如何为某些用例扩展时钟。它们都是基于上面的基本例子。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8.1 自动调节时钟&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;假设我们想让时钟在特定的日子出现，而不是在其他的日子。例如，我们可能有一系列事件即将发生，而不希望每次都手动更新时钟。以下是如何提前安排事情的方法。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通过在CSS中将其 &lt;/span&gt;&lt;code&gt;&lt;span&gt;display&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 属性设置为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;none&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 来隐藏时钟，然后将以下内容添加到 &lt;/span&gt;&lt;code&gt;&lt;span&gt;initializeClock&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数中（以 &lt;/span&gt;&lt;code&gt;&lt;span&gt;var clock&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 开头的行之后）。这将导致只有在调用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;initializeClock&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数后才会显示时钟：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;clock.style.display = &lt;span&gt;&#x27;block&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;接下来，我们可以指定显示时钟的日期。这将替换截止日期变量（ &lt;/span&gt;&lt;code&gt;&lt;span&gt;deadline&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ）：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; schedule = [&lt;br/&gt;    [&lt;span&gt;&#x27;Jul 25 2015&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Sept 20 2015&#x27;&lt;/span&gt;],&lt;br/&gt;    [&lt;span&gt;&#x27;Sept 21 2015&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Jul 25 2016&#x27;&lt;/span&gt;],&lt;br/&gt;    [&lt;span&gt;&#x27;Jul 25 2016&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;Jul 25 2030&#x27;&lt;/span&gt;]&lt;br/&gt;];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Schedule&lt;/code&gt;&lt;span&gt;数组中的每个元素代表一个开始日期和一个结束日期。如上所述，它可以包含时间和时区，但我在这里使用了普通的日期，以保持代码的可读性。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后，当用户加载页面时，我们需要检查是否在指定的时间范围内。此代码应替换先前对 &lt;/span&gt;&lt;code&gt;&lt;span&gt;initializeClock&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数的调用：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 遍历schedule中的每个元素&lt;/span&gt;&lt;br/&gt;schedule.forEach(&lt;span&gt;(&lt;span&gt;[startDate, endDate]&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 以毫秒为单位放置日期以便于比较&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; startMs = &lt;span&gt;Date&lt;/span&gt;.parse(startDate);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; endMs = &lt;span&gt;Date&lt;/span&gt;.parse(endDate);&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; currentMs = &lt;span&gt;Date&lt;/span&gt;.parse(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;());&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 如果当前日期在开始日期和结束日期之间，则显示时钟&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (endMs &amp;gt; currentMs &amp;amp;&amp;amp; currentMs &amp;gt;= startMs ) {&lt;br/&gt;    initializeClock(&lt;span&gt;&#x27;clockdiv&#x27;&lt;/span&gt;, endDate);&lt;br/&gt;  }&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在，你可以提前安排你的时钟，而不必手动更新它。如果你愿意，你可以缩短代码。为了便于阅读，我把我的代码写得很啰嗦。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8.2 从用户到达起将计时器设置为10分钟&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;用户到达或开始特定任务后，有必要在给定的时间内设置倒计时。我们将在此处将计时器设置为10分钟，但是你可以使用任意时间。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们需要做的就是用以下命令替换 &lt;/span&gt;&lt;code&gt;&lt;span&gt;deadline&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 变量：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; timeInMinutes = &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; currentTime = &lt;span&gt;Date&lt;/span&gt;.parse(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;());&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; deadline = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;(currentTime + timeInMinutes*&lt;span&gt;60&lt;/span&gt;*&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这段代码以当前时间为基准，增加10分钟。这些值将转换为毫秒，因此可以将它们加在一起并变成新的截止日期。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;现在我们有一个时钟，从用户到达时开始倒计时十分钟，你可以自由发挥，尝试不同的时间长度。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;8.3 跨页面保持时钟进度&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;有时，除了当前页面外，还需要保留时钟状态。如果我们想在整个网站上设置10分钟的计时器，则我们不希望在用户转到其他页面时重置该计时器。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一个解决方案是将时钟的结束时间保存在一个cookie中。这样一来，导航到一个新的页面就不会把结束时间重置到十分钟以后。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这是逻辑：&lt;/span&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果Cookie中记录了截止日期，使用该截止日期。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果不存在Cookie，请设置一个新的截止日期并将其存储在Cookie中。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;要实现这一点，请使用以下命令替换 &lt;/span&gt;&lt;code&gt;&lt;span&gt;deadline&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 变量：&lt;/span&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; deadline;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 如果有一个名为myClock的cookie，则使用该值作为截止日期&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;document&lt;/span&gt;.cookie &amp;amp;&amp;amp; &lt;span&gt;document&lt;/span&gt;.cookie.match(&lt;span&gt;&#x27;myClock&#x27;&lt;/span&gt;)){&lt;br/&gt;  &lt;span&gt;// 从Cookie获取截止日期值&lt;/span&gt;&lt;br/&gt;  deadline = &lt;span&gt;document&lt;/span&gt;.cookie.match(&lt;span&gt;/(^|;)myClock=([^;]+)/&lt;/span&gt;)[&lt;span&gt;2&lt;/span&gt;];&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// 否则，请设置从现在开始10分钟的截止日期，&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;// 将其保存在具有该名称的cookie中&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 创建从现在开始10分钟的截止日期&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; timeInMinutes = &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; currentTime = &lt;span&gt;Date&lt;/span&gt;.parse(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;());&lt;br/&gt;  deadline = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Date&lt;/span&gt;(currentTime + timeInMinutes*&lt;span&gt;60&lt;/span&gt;*&lt;span&gt;1000&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;// 将截止日期存储在cookie中以供将来引用&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;document&lt;/span&gt;.cookie = &lt;span&gt;&#x27;myClock=&#x27;&lt;/span&gt; + deadline + &lt;span&gt;&#x27;; path=/; domain=.yourdomain.com&#x27;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;需要注意的是，你需要将 &lt;/span&gt;&lt;code&gt;&lt;span&gt;.yourdomain.com&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 改为你的实际域名。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;9.有关客户端时间的重要警告&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;JavaScript日期和时间是从用户的计算机上获取的，这意味着用户可以通过更改计算机上的时间来影响JavaScript时钟。在大多数情况下，这并不重要，但在一些超级敏感的情况下，就需要从服务器上获取时间。可以使用一些Node.js或Ajax来完成，这两者都超出了本教程的范围。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;从服务器获取时间后，我们可以使用本教程中的相同技术来使用它。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;10.总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在完成本文中的示例之后，你现在知道了如何使用几行简单的JavaScript代码创建自己的倒计时计时器！我们已经了解了如何制作一个基本的倒计时时钟并有效地显示它。我们还介绍了添加一些有用的附加功能，包括日程安排、绝对时间与相对时间，以及在页面和网站访问之间用cookie保存状态。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;下一步是什么？&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;试着添加一些创意风格，或者新的功能（比如暂停和恢复按钮）。之后，如果你想出了任何很酷的时钟例子，你想分享，让我们在评论区见。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;11.代码&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;本示例代码和演示地址：https://coding.zhangbing.site/view.html?url=./list/down-click.html&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5199374511336982&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0ANAsyE4nMbsnrRoddRZl3Ulz4YSjStP8ld5zicpEzrVUTPZFM8TsUrv018LNU7mnIAGrBmVomqtj9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2558&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;section&gt;&lt;mpcps frameborder=&quot;0&quot; class=&quot;js_editor_cps&quot; data-datakey=&quot;1600178414761_0.7220740555156842&quot; data-uid=&quot;1600178414759&quot; data-type=&quot;1&quot; data-product=&quot;&quot; data-templateid=&quot;list&quot; data-pid=&quot;29120617&quot; data-packid=&quot;&quot; data-smartnum=&quot;&quot; data-categoryid=&quot;3&quot; data-appid=&quot;wx831660fe3ded4389&quot; data-report=&quot;s0%3D0%26s1%3D0%26s2%3D0%26s3%3DJavaScript%25E9%25AB%2598%25E7%25BA%25A7%25E7%25A8%258B%25E5%25BA%258F%25E8%25AE%25BE%25E8%25AE%25A1%26s4%3D0%26s5%3D10%26s6%3Did_1600179496139_855052%26s7%3D%26s8%3D%26s9%3D%26s10%3D%26pid%3Dwx831660fe3ded4389_29120617%26uuid%3D3240205452442390687%26title%3DJavaScript%25E9%25AB%2598%25E7%25BA%25A7%25E7%25A8%258B%25E5%25BA%258F%25E8%25AE%25BE%25E8%25AE%25A1%2B%25E7%25AC%25AC4%25E7%2589%2588%26sid%3D3%26cid%3D3%26ratio%3D17.00%2525%26price%3D96.80%26&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;mpcps frameborder=&quot;0&quot; class=&quot;js_editor_cps&quot; data-datakey=&quot;1600178414762_0.4332142757043733&quot; data-uid=&quot;1600178414760&quot; data-type=&quot;1&quot; data-product=&quot;&quot; data-templateid=&quot;list&quot; data-pid=&quot;12883028&quot; data-packid=&quot;&quot; data-smartnum=&quot;&quot; data-categoryid=&quot;3&quot; data-appid=&quot;wxbdbc4659744ed70d&quot; data-report=&quot;s0%3D0%26s1%3D0%26s2%3D0%26s3%3DJavaScript%25E8%25AF%25AD%25E8%25A8%2580%25E7%25B2%25BE%25E9%25AB%2593%26s4%3D0%26s5%3D10%26s6%3Did_1600179516463_23250%26s7%3D%26s8%3D%26s9%3D%26s10%3D%26pid%3Dwxbdbc4659744ed70d_12883028%26uuid%3D32402054522077153266%26title%3DJavaScript%25E8%25AF%25AD%25E8%25A8%2580%25E7%25B2%25BE%25E9%25AB%2593%25E4%25B8%258E%25E7%25BC%2596%25E7%25A8%258B%25E5%25AE%259E%25E8%25B7%25B5%25EF%25BC%2588%25E7%25AC%25AC3%25E7%2589%2588%25EF%25BC%2589(%25E5%258D%259A%25E6%2596%2587%25E8%25A7%2586%25E7%2582%25B9%25E5%2587%25BA%25E5%2593%2581)%26sid%3D1%26cid%3D3%26ratio%3D18.00%2525%26price%3D136.80%26&quot;/&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;福利时间&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，我又来给大家送福利了，这么好的书不送几本给大家怎么行呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;福利送给「阅读、点赞、在看、评论」我的文章的读者们，你们的支持也是我持续输出最大的动力，&lt;span&gt;感恩&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本次抽奖有三个参与方式&lt;span&gt;「留言、在看&lt;span&gt;、现金&lt;/span&gt;红包抽奖」&lt;/span&gt;，当然都参与中奖概率更高哈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;为了避免中奖后失联，提前加我微信哈。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/WYoaOn5t0ANpQDTG8tzUI7XTrYCicQaUYCZvxu69zuIYjJ5YB2icua8zRG0MPL9IFU09iboV7XOKwTicrr3ghkYeZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>53b6c73b207428153551725bfa2a60be</guid>
<title>多图，一文了解 8 种常见的数据结构</title>
<link>https://toutiao.io/k/d392rnj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;p&gt;前几天和丙弟交流，他说我们写作的人都是在不停地燃烧自己，所以需要不停地补充燃料。对于他的观点，我不能再苟同了——所以我开始狂补计算机方面的基础知识，这其中就包括我相对薄弱的数据结构。&lt;/p&gt;&lt;p&gt;百度百科对数据结构的定义是：相互之间存在一种或多种特定关系的数据元素的集合。定义很抽象，需要大声地朗读几遍，才有点感觉。怎么让这种感觉来得更强烈，更亲切一些呢？我来列举一下常见的 8 种数据结构，数组、链表、栈、队列、树、堆、图、哈希表。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.47619047619047616&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaB93GW1ZTzqzXpD9CCprJZGt0iauuLJzMUkicfMhOARZhIGnyFCibjGJ1yg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1218&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这 8 种数据结构有什么区别呢？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;①、数组&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;按照索引查询元素的速度很快；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;按照索引遍历数组也很方便。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;p&gt;&lt;strong&gt;②、链表&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;《算法（第 4 版）》一书中是这样定义链表的：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;链表是一种递归的数据结构，它或者为空（null），或者是指向一个结点（node）的引用，该节点还有一个元素和一个指向另一条链表的引用。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Java 的 LinkedList 类可以很形象地通过代码的形式来表示一个链表的结构：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;LinkedList&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;transient&lt;/span&gt; Node&amp;lt;E&amp;gt; first;&lt;br/&gt;    &lt;span&gt;transient&lt;/span&gt; Node&amp;lt;E&amp;gt; last;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&amp;lt;&lt;span&gt;E&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;        E item;&lt;br/&gt;        Node&amp;lt;E&amp;gt; next;&lt;br/&gt;        Node&amp;lt;E&amp;gt; prev;&lt;br/&gt;&lt;br/&gt;        Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.item = element;&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.next = next;&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.prev = prev;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这是一种双向链表，当前元素 item 既有 prev 又有 next，不过 first 的 prev 为 null，last 的 next 为 null。如果是单向链表的话，就只有 next，没有 prev。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.4&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBVCicPIQYibicdxouzxnVM4uVFXzGuDKFE66zDiav3Zu1rmw2HGPl0CiafGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;670&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;单向链表的缺点是只能从头到尾依次遍历，而双向链表可进可退，既能找到下一个，也能找到上一个——每个节点上都需要多分配一个存储空间。&lt;/p&gt;&lt;p&gt;链表中的数据按照“链式”的结构存储，因此可以达到内存上非连续的效果，数组必须是一块连续的内存。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5788888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBkmpbvsf8IUTrTgwbNdeXjW4iba1tJPSmZR4jZsL5THQhMZZewibDmIibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;由于不必按照顺序的方式存储，链表在插入、删除的时候可以达到 O(1) 的时间复杂度（只需要重新指向引用即可，不需要像数组那样移动其他元素）。除此之外，链表还克服了数组必须预先知道数据大小的缺点，从而可以实现灵活的内存动态管理。&lt;/p&gt;&lt;p&gt;优点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不需要初始化容量；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以添加任意元素；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;插入和删除的时候只需要更新引用。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;缺点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;含有大量的引用，占用的内存空间大；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;查找元素需要遍历整个链表，耗时。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;③、栈&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;栈就好像水桶一样，底部是密封的，顶部是开口，水可以进可以出。用过水桶的小伙伴应该明白这样一个道理：先进去的水在桶的底部，后进去的水在桶的顶部；后进去的水先被倒出来，先进去的水后被倒出来。&lt;/p&gt;&lt;p&gt;同理，栈按照“后进先出”、“先进后出”的原则来存储数据，先插入的数据被压入栈底，后插入的数据在栈顶，读出数据的时候，从栈顶开始依次读出。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9454545454545454&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBbpJ3J7DZLmox5PicUyzBM5hnVC2W37CEKIwKbibvKZeaLlQbP3efwV4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;220&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;④、队列&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;队列就好像一段水管一样，两端都是开口的，水从一端进去，然后从另外一端出来。先进去的水先出来，后进去的水后出来。&lt;/p&gt;&lt;p&gt;和水管有些不同的是，队列会对两端进行定义，一端叫队头，另外一端就叫队尾。队头只允许删除操作（出队），队尾只允许插入操作（入队）。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.531700288184438&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBuqsHCTFJJS1QEbMQlWGYNibF1U0s2VBVQE9arW7rpjSmxHZhvgGEicOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;694&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;注意，栈是先进后出，队列是先进先出——两者虽然都是线性表，但原则是不同的，结构不一样嘛。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;⑤、树&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;树是一种典型的非线性结构，它是由 n（n&amp;gt;0）个有限节点组成的一个具有层次关系的集合。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9416666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBNG5VquqaTNkXHazARMOOHWI3hXmeKc8Pqibk63EFSHKCAh1XD7ccIVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;之所以叫“树”，是因为这种数据结构看起来就像是一个倒挂的树，只不过根在上，叶在下。树形数据结构有以下这些特点：&lt;/p&gt;&lt;p&gt;下图展示了树的一些术语：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8258064516129032&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaB5fBXNTAjhGAkGPK1GSEtuWia41G9tutOp4sNS5qByTy6QFxYzfLibgzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;根节点是第 0 层，它的子节点是第 1 层，子节点的子节点为第 2 层，以此类推。&lt;/p&gt;&lt;p&gt;树的种类有很多种，常见的有：&lt;/p&gt;&lt;p&gt;假如有三个节点，一个是父节点，两个是同级的子节点，那么就有三种情况：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.2653225806451613&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBlzDo0iadbvynC8D3O2VQwCJib581GmjqibPlhM09Mz9sHKwvfTmZbwOqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;假如有三个节点，一个是父节点，两个是不同级的子节点，那么就有六种情况：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.45483870967741935&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBvHIqQT4AgkchWGGIc86w157X4iaORtNbK1ia8WZ9qD0yGdLY8ibMjlC0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;三个节点组成的无序树，合起来就是九种情况。&lt;/p&gt;&lt;p&gt;完全二叉树：对于一颗二叉树，假设其深度为 d（d &amp;gt; 1）。除了第 d 层，其它各层的节点数目均已达最大值，且第 d 层所有节点从左向右连续地紧密排列，这样的二叉树被称为完全二叉树。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.716931216931217&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBibF1D0NMh3ELjuOuvN9kjlibkEJbIhyjcubicaia6ajugIOaS8kMyFG9uw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;756&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;拿上图来说，d 为 3，除了第 3 层，第 1 层、第 2 层 都达到了最大值（2 个子节点），并且第 3 层的所有节点从左向右联系地紧密排列（H、I、J、K、L），符合完全二叉树的要求。&lt;/p&gt;&lt;p&gt;满二叉树：一颗每一层的节点数都达到了最大值的二叉树。有两种表现形式，第一种，像下图这样（每一层都是满的），满足每一层的节点数都达到了最大值 2。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.6475409836065574&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBe3ctGhq7WqiapWQpNJNHAibn74hPPK6zUG8a359gb3RQ92PiaDDdcG4lA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;第二种，像下图这样（每一层虽然不满），但每一层的节点数仍然达到了最大值 2。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.7481060606060606&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaB92VnLZdZEFYRW2f73UnhVuZAtTVzQRk0lhxhibgz1BnxWOhPuAOQ2Ew/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1056&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;二叉查找树：英文名叫 Binary Search Tree，即 BST，需要满足以下条件：&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5298387096774193&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaByCLXibBBJdRBBiclOiaeLMxySmPxECdFOO43DpicHl0OGZIicmYC3LYel3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;基于二叉查找树的特点，它相比较于其他数据结构的优势就在于查找、插入的时间复杂度较低，为 O(logn)。假如我们要从上图中查找 5 个元素，先从根节点 7 开始找，5 必定在 7 的左侧，找到 4，那 5 必定在 4 的右侧，找到 6，那 5 必定在 6 的左侧，找到了。&lt;/p&gt;&lt;p&gt;理想情况下，通过 BST 查找节点，所需要检查的节点数可以减半。&lt;/p&gt;&lt;p&gt;平衡二叉树：当且仅当任何节点的两棵子树的高度差不大于 1 的二叉树。由前苏联的数学家 Adelse-Velskil 和 Landis 在 1962 年提出的高度平衡的二叉树，根据科学家的英文名也称为 AVL 树。&lt;/p&gt;&lt;p&gt;平衡二叉树本质上也是一颗二叉查找树，不过为了限制左右子树的高度差，避免出现倾斜树等偏向于线性结构演化的情况，所以对二叉搜索树中每个节点的左右子树作了限制，左右子树的高度差称之为平衡因子，树中每个节点的平衡因子绝对值不大于 1。&lt;/p&gt;&lt;p&gt;平衡二叉树的难点在于，当删除或者增加节点的情况下，如何通过左旋或者右旋的方式来保持左右平衡。&lt;/p&gt;&lt;p&gt;Java 中最常见的平衡二叉树就是红黑树，节点是红色或者黑色，通过颜色的约束来维持着二叉树的平衡：&lt;/p&gt;&lt;p&gt;1）每个节点都只能是红色或者黑色&lt;/p&gt;&lt;p&gt;2）根节点是黑色&lt;/p&gt;&lt;p&gt;3）每个叶节点（NIL 节点，空节点）是黑色的。&lt;/p&gt;&lt;p&gt;4）如果一个节点是红色的，则它两个子节点都是黑色的。也就是说在一条路径上不能出现相邻的两个红色节点。&lt;/p&gt;&lt;p&gt;5）从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5724815724815725&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBrmu2nPLWWjKOtn3TkgjDFBordKkDFBakyLRuQG6lrTFZdhUTEWhlgA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;814&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5630252100840336&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBLHPViaSrBvypPqwsDJs7sFjUE2V1dL9RDBo0F9FJevfA8P2CtO8xLaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1190&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;⑥、堆&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;堆可以被看做是一棵树的数组对象，具有以下特点：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;堆中某个节点的值总是不大于或不小于其父节点的值；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;堆总是一棵完全二叉树。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.42096774193548386&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBxz4ddlo5D4aLLkhoGj7hScRQR8Ipv0ototruVb7VVfJxd6pbQcXQzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;⑦、图&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;图是一种复杂的非线性结构，由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G（V，E），其中，G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5199501246882793&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaB5uNbXoX3qxZS5j4lakLGo6fcia44HylHMw57socSNs7lf0ul4oNnPiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;802&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;上图共有 V0，V1，V2，V3 这 4 个顶点，4 个顶点之间共有 5 条边。&lt;/p&gt;&lt;p&gt;在线性结构中，数据元素之间满足唯一的线性关系，每个数据元素（除第一个和最后一个外）均有唯一的“前驱”和“后继”；&lt;/p&gt;&lt;p&gt;在树形结构中，数据元素之间有着明显的层次关系，并且每个数据元素只与上一层中的一个元素（父节点）及下一层的多个元素（子节点）相关；&lt;/p&gt;&lt;p&gt;而在图形结构中，节点之间的关系是任意的，图中任意两个数据元素之间都有可能相关。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;⑧、哈希表&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;哈希表（Hash Table），也叫散列表，是一种可以通过关键码值（key-value）直接访问的数据结构，它最大的特点就是可以快速实现查找、插入和删除。&lt;/p&gt;&lt;p&gt;数组的最大特点就是查找容易，插入和删除困难；而链表正好相反，查找困难，而插入和删除容易。哈希表很完美地结合了两者的优点， Java 的 HashMap 在此基础上还加入了树的优点。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.756701030927835&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z40lCFUAHpmHbN9n1rRLn3KVAzRUXIiaBcJg9UngrA7Yh40PkVSOCIkcabXgUqCrxNTaWg9F7Vgn8v4WcsfBGKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;970&quot; title=&quot;&quot;/&gt;&lt;/figure&gt;&lt;p&gt;哈希函数在哈希表中起着⾮常关键的作⽤，它可以把任意长度的输入变换成固定长度的输出，该输出就是哈希值。哈希函数使得一个数据序列的访问过程变得更加迅速有效，通过哈希函数，数据元素能够被很快的进行定位。&lt;/p&gt;&lt;p&gt;若关键字为 k，则其值存放在 &lt;code&gt;hash(k)&lt;/code&gt; 的存储位置上。由此，不需要遍历就可以直接取得 k 对应的值。&lt;/p&gt;&lt;p&gt;对于任意两个不同的数据块，其哈希值相同的可能性极小，也就是说，对于一个给定的数据块，找到和它哈希值相同的数据块极为困难。再者，对于一个数据块，哪怕只改动它的一个比特位，其哈希值的改动也会非常的大——这正是 Hash 存在的价值！&lt;/p&gt;&lt;p&gt;尽管可能性极小，但仍然会发生，如果哈希冲突了，Java 的 HashMap 会在数组的同一个位置上增加链表，如果链表的长度大于 8，将会转化成红黑树进行处理——这就是所谓的拉链法（数组+链表）。&lt;/p&gt;&lt;p&gt;说句实在话，照这个进度恶补下去，我感觉要秃的节奏，不过，如果能够变得更强，值了——对，值了。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>39e33fa4c2481a1ead767bef42db5ea9</guid>
<title>谈谈我所认识的分布式锁</title>
<link>https://toutiao.io/k/oqnmp3h</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;/p&gt;&lt;h2 mpa-is-content=&quot;t&quot;&gt;&lt;span&gt;随着计算机技术和工程架构的发展，微服务变得越来越热。如今，绝大多数服务都处于分布式环境中，其中，数据一致性是我们一直关注的重点。分布式锁到底是什么？经过了哪些发展演进？工程上有哪些实现方案？各种方案的利弊权衡又有哪些？希望这篇文章能够对你有一些帮助。&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;▍&lt;strong&gt;阅读&lt;/strong&gt;&lt;strong&gt;索引&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;0. 名词定义&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;1. 问题引入&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;2. 分布式环境的特点 &lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;3. 锁&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;4. 分布式锁&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;5. 分布式锁实现方案&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;5.1. 朴素Redis实现方案、&lt;/span&gt;&lt;span&gt;朴素Redis方案小结&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;5.2. ZooKeeper实现方案、&lt;/span&gt;&lt;span&gt;ZooKeeper方案小结&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;5.3&lt;span&gt;. &lt;/span&gt;Redisson实现方案、&lt;/span&gt;&lt;span&gt;Redisson方案小结&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;6. 总结&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;7. 结束语&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;8. Reference&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-copyright=&quot;0&quot; data-ratio=&quot;0.02847130968024529&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jE5bOw22iaBsseSfyAldiaR4R3UMuxvTLoibspKdM7d2ePE6INj7RnywH5xnvFmLC2pXxUSBUVejaAhKcme5CPyXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2283&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;▍&lt;/span&gt;&lt;strong&gt;&lt;span&gt;0. 名词定义&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分布式锁：顾名思义，是指在分布式环境下的锁，重点在锁。所以我们先从锁开始讲起。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;span&gt;▍&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1. 问题引入&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;举个例子：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;某服务记录数据X，当前值为100。A请求需要将X增加200；同时，B请求需要将X减100。在理想的情况下，A先读取到X=100，然后X增加200，最后写入X=300。B请求接着读取到X=300，减少100，最后写入X=200。然而在真实情况下，如果不做任何处理，则可能会出现：A和B同时读取到X=100；A写入之前B读取到X；B比A先写入等等情况。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面这个例子相信大家都非常熟悉。出现不符合预期的结果本质上是对临界资源没有做好互斥操作。互斥性问题通俗来讲，就是对共享资源的抢占问题。对于共享资源争抢的正确性，锁是最常用的方式，其他的如CAS（compare and swap）等，这里不展开。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;2. 分布式环境的特点&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们的绝大部分服务都处于分布式环境中。那么，分布式系统有哪些特点呢？大致如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;* 可扩展性：可通过横向水平扩展提高系统的性能和吞吐量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;* 高可靠性：高容错，即使系统中一台或几台故障，系统仍可提供服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;* 高并发性：各机器并行独立处理和计算。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;* 廉价高效：多台小型机而非单台高性能机。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;▍&lt;/span&gt;&lt;strong&gt;&lt;span&gt;3.锁&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们先来看下非分布式情况下的锁方案（多线程和多进程的情况），然后再演进到分布式锁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;▍&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;多线程下的锁机制：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;各种语言有不同的实现方式，比较成熟。比如，go语言中的sync.RWMutex（读写锁）、sync.Mutex（互斥锁）；JAVA中的ReentrantLock、synchronized；在php中没有找到原生的支持锁的方式，只能通过外部来间接实现，比如文件锁，借助外部存储的锁等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;多进程下的锁机制：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于临界资源的访问已经超出了单个进程的控制范围。在多进程的情况下，主要是利用操作系统层面的进程间通信原理来解决临界资源的抢占问题。比较常见的一种方法便是使用信号量（Semaphores）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;▍对信号量的操作，主要是P操作（wait）和V操作（signal）：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;* P操作 ( wait ) ：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;先检查信号量的大小，若值大于零，则将信号量减1，同时进程获得共享资源的访问权限，继续执行；若小于或者等于零，则该进程被阻塞后，进入等待队列。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;* V操作 ( signal ) ：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该操作将信号量的值加1，如果有进程阻塞着等待该信号量，那么其中一个进程将被唤醒。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;CTO3&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可看出，多进程锁方案跟多线程的锁方案实现思路大同小异。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们将互斥的级别拉高，分布式环境下不同节点不同进程或线程之间的互斥，就是分布式锁的挑战之一。后面再细讲。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，在传统的基于数据库的架构中，对于数据的抢占问题也可以通过数据库事务（ACID）来保证。在分布式环境中，出于对性能以及一致性敏感度的要求，使得分布式锁成为了一种比较常见而高效的解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;从上面对于多线程和多进程锁的概括，可以总结出锁的抽象条件：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）“需要有存储锁的空间，并且锁的空间是可以访问到的”：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于多线程就是内存（进程中不同的线程都可以读写），多进程中通过共享内存的方式，也是提供一块地方，供不同进程读写。主要目的是保证不同的进线程改动对于其他进线程可见，进而满足互斥性需求。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;UkB5&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）“锁需要被唯一标识”：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不同的共享资源，必然需要用不同的锁进行保护，因此相应的锁必须有唯一的标识。在多线程环境中，锁可以是一个对象，那么对这个对象的引用便是这个唯一标识。多进程下，比如有名信号量，便是用硬盘中的文件名作为唯一标识。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;ognS&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）“锁要有至少两种状态”：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有锁，没锁。存在，不存在等等。很好理解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;满足上述三个条件就可以实现基础的分布式锁了。但是随着技术的演进，&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;strong&gt;相应地，&lt;span&gt;对锁也提出了更高级的条件：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）可重入：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;外层函数获得锁之后，内层函数还可以获得锁。原因是随着软件复杂性增加，方法嵌套获取锁已经很难避免。但是从代码层面很难分析出这个问题，因此我们要使用可重入锁。导致锁需要支持可重入的场景。对于可重入的思考，每种语言有自己的哲学和取舍，&lt;span&gt;如go就舍弃了支持重入：Recursive locking in Go [ &lt;/span&gt;&lt;/span&gt;https://stackoverflow.com/questions/14670979/recursive-locking-in-go&lt;span&gt; &lt;span&gt;]以后go又会不会认为“可重入真香”呢？哈哈，我们拭目以待。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;NaC5&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）避免产生惊群效应（Herd Effect）：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;惊群效应指，在有多个请求等待获取锁的时候，一旦占有锁的线程释放之后，所有等待方都同时被唤醒，尝试抢占锁。但是绝大多数的抢占都是不必要的。这种情况在多线程和多进程中开销同样很大。要尽量避免这种情况出现。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;PCZG&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）公平锁和非公平锁：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;公平锁：优先把锁给等待时间最长的一方；非公平锁：不保证等待线程拿锁的顺序。公平锁的实现成本较高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）阻塞锁和自旋锁：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;主要是效率的考虑。自旋锁适用于临界区操作耗时短的场景；阻塞锁适用于临界区操作耗时长的场景。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;X7fS&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;5）锁超时：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;防止释放锁失败，出现死锁的情况。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;42fr&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;6）高效，高可用：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;加锁和解锁需要高效，同时也需要保证高可用防止分布式锁失效，可以增加降级。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还有很多其他更高要求的条件，不一一列举了。有兴趣的小伙伴可以看看编程史上锁的演进过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;4. 分布式锁&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▍使用分布式锁的必要性&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）服务要求：部署的服务本身就处于分布式环境中&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）效率：使用分布式锁可以避免不同节点重复相同的工作，这些工作会浪费资源。比如用户付了钱之后有可能不同节点会发出多封短信&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3）正确性：跟2）类似。如果两个节点在同一条数据上面操作，比如多个节点机器对同一个订单操作不同的流程有可能会导致该笔订单最后状态出现错误，造成损失&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;包括但不限于这些必要性，在强烈地呼唤我们今天的主角---“分布式锁”闪亮登场。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;nBwx&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;▍&lt;/span&gt;&lt;strong&gt;&lt;span&gt;5. 分布式锁实现方案&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有了非分布式锁的实现思路，和分布式环境的挑战，我们来看看分布式锁的实现策略。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分布式锁本质上还是要实现一个简单的目标---占一个“坑”，当别的节点机器也要来占时，发现已经有人占了，就只好放弃或者稍后再试。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▍大体分为4种&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）使用数据库实现&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）使用朴素Redis等缓存系统实现&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3）使用ZooKeeper等分布式协调系统实现&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4）使用Redisson来实现（本质上基于Redis）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为利用mysql实现分布式锁的性能低以及改造大，我们这里重点讲一下下面3种实现分布式锁的方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;▍&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;5.1 朴素Redis实现方案&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们循序渐进，对比几种实现方式，找出优雅的方式：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;方案1：setnx+delete&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;setnx lock_key lock_value&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;//&lt;/span&gt; &lt;span&gt;do&lt;/span&gt; sth&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt; lock_key&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;缺点：一旦服务挂掉，锁无法被删除释放，会导致死锁。硬伤，pass！2&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;方案2：setnx + setex&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;setnx lock_key lock_value&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;setex lock_key N lock_value  &lt;span&gt;// N s超时&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;// do sth&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt; lock_key&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;在方案1的基础上设置了超时时间。但是还是会出现跟1一样的问题。如果setnx之后、setex之前服务挂掉，一样会陷入死锁。本质原因是，setnx/setex分为了两个步骤，非原子操作。硬伤，pass！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;方案3：set ex nx&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;SET lock_key lock_value EX N NX &lt;span&gt;//N s超时&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;// do sth&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;delete&lt;/span&gt; lock_key&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;将加锁、设置超时两个步骤合并为一个原子操作，从而解决方案1、2的问题。（Redis原生命令支持，Redis version需要&amp;gt;=2.6.12，滴滴生产环境Redis version一般为3.2，所以日常能够使用）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;优点：此方案目前大多数sdk、Redis部署方案都支持，实现简单&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;缺点：会存在锁被错误的释放，被错误的抢占的情况。如下图： &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.5439739413680782&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jE5bOw22iaBvxHozhM8S9If1R4gBm2g4Yc20ibVicHzz1JXITFmVnRhrSyU7JX9bSzpPfJoibUg31XIIVTvic8yibf4A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1228&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这块有2个问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）GC期间，client1超时时间已到，导致将client2错误地放进来&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）client1执行完逻辑后会显式调用del，将所有的锁都释放了（正确的情况应该只释放自己的锁，错误地释放了client2的锁）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;方案4：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在3的基础上，对于问题1，将client的超时时间设置长一些，保证只能通过显式del来释放锁，而超时时间只是作为一种最终兜底的方案。针对问题2，增加对 value 的检查，只解除自己加的锁，为保证原子性，只能需要通过lua脚本实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;lua脚本：&lt;/span&gt;https://redis.io/commands/eval&lt;/p&gt;&lt;p line=&quot;pxbd&quot;&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; redis.&lt;span&gt;call&lt;/span&gt;(&lt;span&gt;&quot;get&quot;&lt;/span&gt;,KEYS[&lt;span&gt;1&lt;/span&gt;]) == ARGV[&lt;span&gt;1&lt;/span&gt;] &lt;span&gt;then&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt; redis.&lt;span&gt;call&lt;/span&gt;(&lt;span&gt;&quot;del&quot;&lt;/span&gt;,KEYS[&lt;span&gt;1&lt;/span&gt;])&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果超时时间设置长，只能通过显式的del来释放锁，就不会出现问题2（错误释放掉其他client的锁）。跟滴滴KV store的王斌同学讨论过，目前没有找到方案4优于方案3（只要超时时间设置的长一些）的场景。所以，在我的认知中，方案4跟方案3的优势一样，但是方案3的实现成本明显要低很多。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;朴素Redis方案小结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方案3用的最多，实现成本小，对于大部分场景，将超时时间设置的长一些，极少出现问题。同时本方案对不同语言的友好度极高。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;CEKs&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;▍&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;5.2 ZooKeeper实现方案&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们先简要介绍一些ZooKeeper（以下简称ZK）：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ZooKeeper是一种“分布式协调服务”。所谓分布式协调服务，可以在分布式系统中共享配置，协调锁资源，提供命名服务等。为读多写少的场景所设计，ZK中的节点（以下简称ZNode）非常适合用于存储少量的状态和配置信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;对ZK常见的操作：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;create：创建节点&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;delete：删除节点&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;exists：判断一个节点的数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;setdata：设置一个节点的数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;getchildren：获取节点下的所有子节点&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这其中，exists，getData，getChildren属于读操作。Zookeeper客户端在请求读操作的时候，可以选择是否设置Watch（监听机制）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;什么是Watch？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;pUaL&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Watch机制是zk中非常有用的功能。我们可以理解成是注册在特定Znode上的触发器。当这个Znode发生改变，也就是调用了create，delete，setData方法的时候，将会触发Znode上注册的对应事件，请求Watch的客户端会接收到异步通知。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们在实现分布式锁的时候，正是通过Watch机制，来通知正在等待的session相关锁释放的信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;什么是ZNode？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ZNode就是ZK中的节点。ZooKeeper节点是有生命周期的，这取决于节点的类型。在 ZooKeeper 中，节点类型可以分为临时节点（EPHEMERAL），时序节点（SEQUENTIAL ），持久节点（PERSISTENT ）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;临时节点（EPHEMERAL）：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;节点的生命周期跟session绑定，session创建的节点，一旦该session失效，该节点就会被删除。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;临时顺序节点（EPHEMERAL_SEQUENTIAL）：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在临时节点的基础上增加了顺序。每个父结点会为自己的第一级子节点维护一份时序。在创建子节点的时候，会自动加上数字后缀，越后创建的节点，顺序越大，后缀越大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;持久节点（PERSISTENT ）：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;节点创建之后就一直存在，不会因为session失效而消失。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;持久顺序节点（PERSISTENT_SEQUENTIAL）：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;与临时顺序节点同理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;ZNode中的数据结构：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;data（znode存储的数据信息），acl（记录znode的访问权限，即哪些人或哪些ip可以访问本节点），stat（包含znode的各种元数据，比如事务id，版本号，时间戳，大小等等），child（当前节点的子节点引用）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;利用ZK实现分布式锁，主要得益于ZK保证了数据的强一致性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下面说说通过zk简单实现一个保持独占的锁（利用临时节点的特性）：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们可以将ZK上的ZNode看成一把锁（类似于Redis方案中的key）。多个session都去创建同一个distribute_lock节点，只会有一个创建成功的session。相当于只有该session获取到锁，其他session没有获取到锁。在该成功获锁的session失效前，锁将会一直阻塞住。session失效时，节点会自动被删除，锁被解除。（类似于Redis方案中的expire）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上述实现方案跟Redis方案3的实现效果一样。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;但是，这样的锁有没有改进的地方？当然！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）我们可能会有可重入的需求，因此希望能有可重入的锁机制。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）有些场景下，在争抢锁的时候，我们既不想一次争抢不到就pass，也不想一直阻塞住直到获取到锁。一个朴素的需求是，我们希望有超时时间来控制是否去上锁。更进一步，我们不想主动的去查到底是否能够加锁，我们希望能够有事件机制来通知是否能够上锁。（这里，你是不是想到了ZK的Watch机制呢？）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;要满足这样的需求就需要控制时序。利用顺序临时节点和Watch机制的特性，来实现：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们事先创建/distribute_lock节点，多个session在它下面创建临时有序节点。由于zk的特性，/distribute_lock该节点会维护一份sequence，来保证子节点创建的时序性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;具体实现如下：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1）客户端调用create()方法在/distribute_lock节点下创建EPHEMERAL_SEQUENTIAL节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2）客户端调用getChildren(“/distribute_lock”)方法来获取所有已经创建的子节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3）客户端获取到所有子节点path之后，如果发现自己在步骤1中创建的节点序号最小，那么就认为这个客户端获得了锁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4）如果在步骤3中发现自己并非所有子节点中最小的，说明自己还没有获取到锁。此时客户端需要找到比自己小的那个节点，然后对其调用exist()方法，同时注册事件监听。需要注意是，只在比自己小一号的节点上注册Watch事件。如果在比自己都小的节点上注册Watch事件，将会出现惊群效应，要避免。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5）之后当这个被关注的节点被移除了，客户端会收到相应的通知。这个时候客户端需要再次调用getChildren(“/distribute_lock”)方法来获取所有已经创建的子节点，确保自己确实是最小的节点了，然后进入步骤3）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Curator框架封装了对ZK的api操作。以Java为例来进行演示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;引入依赖： &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.curator&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;3&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;curator-recipes&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;4&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.11.1&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p line=&quot;LuWY&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用的时候需要注意Curator框架和ZK的版本兼容问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;以排他锁为例，看看怎么使用：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;pre&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt; 1&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TestLock&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span&gt; 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 3&lt;/span&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; void main(String[] args) throws &lt;span&gt;Exception&lt;/span&gt; {&lt;br/&gt;&lt;span&gt; 4&lt;/span&gt;        &lt;span&gt;//创建zookeeper的客户端&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 5&lt;/span&gt;        RetryPolicy retryPolicy = &lt;span&gt;new&lt;/span&gt; ExponentialBackoffRetry(&lt;span&gt;1000&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;);&lt;br/&gt;&lt;span&gt; 6&lt;/span&gt;        CuratorFramework client = CuratorFrameworkFactory.newClient(“ip:port&lt;span&gt;&quot;, retryPolicy);&lt;br/&gt;&lt;span&gt; 7&lt;/span&gt;        client.start();&lt;br/&gt;&lt;span&gt; 8&lt;/span&gt;&lt;br/&gt;&lt;span&gt; 9&lt;/span&gt;        //创建分布式锁, 锁空间的根节点路径为/sunnyzengqi/curator/lock&lt;br/&gt;&lt;span&gt;10&lt;/span&gt;        InterProcessMutex mutex = new InterProcessMutex(client, &quot;&lt;/span&gt;/sunnyzengqi/curator/lock&lt;span&gt;&quot;);&lt;br/&gt;&lt;span&gt;11&lt;/span&gt;        mutex.acquire();&lt;br/&gt;&lt;span&gt;12&lt;/span&gt;        //获得了锁, 进行业务流程&lt;br/&gt;&lt;span&gt;13&lt;/span&gt;        System.out.println(&quot;&lt;/span&gt;Enter mutex&lt;span&gt;&quot;);&lt;br/&gt;&lt;span&gt;14&lt;/span&gt;        Thread.sleep(10000);&lt;br/&gt;&lt;span&gt;15&lt;/span&gt;        //完成业务流程, 释放锁&lt;br/&gt;&lt;span&gt;16&lt;/span&gt;        mutex.release();&lt;br/&gt;&lt;span&gt;17&lt;/span&gt;        //关闭客户端&lt;br/&gt;&lt;span&gt;18&lt;/span&gt;        client.close();&lt;br/&gt;&lt;span&gt;19&lt;/span&gt;    }&lt;br/&gt;&lt;span&gt;20&lt;/span&gt;}&lt;br/&gt;&lt;span&gt;21&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt; &lt;span&gt;△左滑浏览全貌&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面代码在业务执行的过程中，在ZK的/sunnyzengqi/curator/lock路径下，会创建一个临时节点来占位。相同的代码，在两个机器节点上运行，可以看到该路径下创建了两个临时节点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;302&quot; data-backw=&quot;556&quot; data-before-oversubscription-url=&quot;https://mmbiz.qpic.cn/mmbiz_png/jE5bOw22iaBvxHozhM8S9If1R4gBm2g4Yv6vCkkWjSf9H4991kwCskFAo0c9hDIMIXs3ZXANjasunlntGdpIaKw/0?wx_fmt=png&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.5439739413680782&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jE5bOw22iaBvxHozhM8S9If1R4gBm2g4YXSxlU1gM8nvc602DwgrxGID2CpkG7ltT8MT93JibGa272Q5hB61vdJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1228&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;146&quot; data-backw=&quot;501&quot; data-before-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/jE5bOw22iaBvxHozhM8S9If1R4gBm2g4YHs0fNHJJV7wdG6I9OvZxe54n7gK01Ilm0Eng1lra99y88UvgR8Jxow/0?wx_fmt=jpeg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/jE5bOw22iaBvxHozhM8S9If1R4gBm2g4Yts9zjpAN4TuHYu6D803envEX7nqODODFQT5vSPcNVTceXiaFAPpPWNw/0?wx_fmt=png&quot; data-cropx1=&quot;61.84172661870504&quot; data-cropx2=&quot;1168.36690647482&quot; data-cropy1=&quot;172.27338129496403&quot; data-cropy2=&quot;494.7338129496403&quot; data-ratio=&quot;0.2917795844625113&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jE5bOw22iaBvxHozhM8S9If1R4gBm2g4YHs0fNHJJV7wdG6I9OvZxe54n7gK01Ilm0Eng1lra99y88UvgR8Jxow/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1107&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;145&quot; data-backw=&quot;502&quot; data-before-oversubscription-url=&quot;http://mmbiz.qpic.cn/mmbiz_jpg/jE5bOw22iaBvxHozhM8S9If1R4gBm2g4YO2XW7A4xoooeCtMPjQib3QcrlFJolia6bPBuPVRhADHl9yFNuVa9VG4g/0?wx_fmt=jpeg&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/jE5bOw22iaBvxHozhM8S9If1R4gBm2g4YaYIc6diaVV5Ys5ficmCoFOXUl6Qcz8pIUHKibAadm71ew6hibqrq6HfUicw/0?wx_fmt=png&quot; data-cropx1=&quot;59.63309352517986&quot; data-cropx2=&quot;1168.36690647482&quot; data-cropy1=&quot;174.4820143884892&quot; data-cropy2=&quot;494.7338129496403&quot; data-ratio=&quot;0.2894499549143372&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/jE5bOw22iaBvxHozhM8S9If1R4gBm2g4YO2XW7A4xoooeCtMPjQib3QcrlFJolia6bPBuPVRhADHl9yFNuVa9VG4g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1109&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;运行命令echo wchc | nc localhost 2181查看watch信息：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.5439739413680782&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jE5bOw22iaBvxHozhM8S9If1R4gBm2g4YGEqB7hzZciaJrqwBOnRmjZG2x7eHfYeZEbH3ME1zicOM4ep86uicBbYfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1228&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可以看到lock1节点的session在监听节点lock0的变动。此时是lock0获取到锁。等到lock0执行完，session会失效，触发Watch机制，通知lock1的session说锁已经被释放了。这时，lock1可以来抢占锁，进而执行自己的操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了简单的排它锁的实现，还可以利用ZK的特性来实现更高级的锁（比如信号量，读写锁，联锁）等，这里面有很多的玩法。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;FjLD&quot;&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;ZooKeeper方案小结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;能够实现很多具有更高条件的锁机制，并且由于ZK优越的session和watch机制，适用于复杂的场景。因为有久经检验的Curator框架，集成了很多基于ZK的分布式锁的api，对于Java语言非常友好。对于其他语言，虽然也有一些开源项目封装了它的api，但是稳定性和效率需要自己去实际检验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;▍&lt;/span&gt;5.3 Redisson实现方案&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;我们先简要介绍一下Redisson：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p line=&quot;LzDo&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Redisson是Java语言编写的基于Redis的client端。功能也非常强大，功能包括：分布式对象，分布式集合，分布式锁和同步器，分布式服务等。被大家熟知的场景还是在分布式锁的场景。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;BtxK&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了解决加锁线程在没有解锁之前崩溃进而出现死锁的问题，不同于朴素Redis中通过设置超时时间来处理。Redisson采用了新的处理方式：Redisson内部提供了一个监控锁的看门狗，它的作用是在Redisson实例被关闭前，不断的延长锁的有效期。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;跟Zookeeper类似，Redisson也提供了这几种分布式锁：可重入锁，公平锁，联锁，红锁，读写锁等。具体怎么用这里不展开，感兴趣的朋友可以自己去实验。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;XnaC&quot;&gt;&lt;/p&gt;&lt;h2/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Redisson方案小结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;跟ZK一样，都能够实现很多具有更高条件的锁机制，适用于复杂的场景。但对语言非常挑剔，目前只能支持Java语言。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;▍&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;6. 总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上一节，我们讨论了三种实现的方案：朴素Redis实现方案，ZooKeeper实现方案，Redisson实现方案。由于第1种与第3种都是基于Redis，所以主要是ZK和基于Redis两种。我们不禁想问，在实现分布式锁上，基于ZK与基于Redis的方案，有什么不同呢？&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;91oY&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1）锁的时长设置上：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;得益于ZK的session机制，客户端可以持有锁任意长的时间，这可以确保它做完所有需要的资源访问操作之后再释放锁。避免了基于Redis的锁对于有效时间到底设置多长的两难问题。实际上，基于ZooKeeper的锁是依靠Session（心跳）来维持锁的持有状态的，而Redis不支持Sesion。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;优势：ZK&amp;gt;Redisson&amp;gt;朴素Redis。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;7GVc&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2）监听机制上：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;得益于ZK的watch机制，在获取锁失败之后可以等待锁重新释放的事件。这让客户端对锁的使用更加灵活。避免了Redis方案主要去轮询的方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;优势：ZK&amp;gt;Redisson=朴素Redis。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;RJg6&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3）使用便利性上：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于生产环境都有稳定的Redis和ZooKeeper集群，有专业的同学维护，这两者差别不大。在语言局限性上，朴素Redis从不挑食。ZK和Redisson都偏向于Java语言。在开发难度上，Redis最简单，几乎不用写什么代码；ZK和Redisson次之，依赖于使用的语言是否有集成的api以及集成稳定性等。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;NVzY&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;优势：朴素Redis&amp;gt;ZK&amp;gt;Redisson。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;do7K&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4）支持锁形式的多样性上：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面有提及，ZK和Redisson都支持了各种花样的分布锁。朴素Redis就比较捉急了，在实现更高要求的锁方面，如果自己造轮子，往往费时费力，力不从心。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;优势：ZK=Redisson&amp;gt;Redis。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h1/&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;▍&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;7. 结束语&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;分布式锁在日常Coding中已经很常用。但是分布式锁这方面的知识依然非常深奥。2016年，Martin Kleppmann与Antirez两位分布式领域非常有造诣的前辈还针对“Redlock算法”在分布式锁上面的应用炒得沸沸扬扬。&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;mBRW&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后借助这场历史闹剧中Martin的话来结束我们今天的分享。与诸君共勉！将学习当成一生的主题！&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;qV6I&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;对我来说最重要的一点在于：我并不在乎在这场辩论中谁对谁错 —— 我只关心从其他人的工作中学到的东西，以便我们能够避免重蹈覆辙，并让未来更加美好。前人已经为我们创造出了许多伟大的成果：站在巨人的肩膀上，我们得以构建更棒的软件。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;……&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;对于任何想法，务必要详加检验，通过论证以及检查它们是否经得住别人的详细审查。那是学习过程的一部分。但目标应该是为了获得知识，而不应该是为了说服别人相信你自己是对的。有时候，那只不过意味着停下来，好好地想一想。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;p line=&quot;XMQD&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于时间仓促，自己水平有限，文中必定存在诸多疏漏与理解不当的地方。非常希望得到各位指正，畅谈技术。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;▍&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;Reference&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p line=&quot;VJCB&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;0.Apache ZooKeeper&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1.Redisson&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2.Redis&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3.Redis分布式锁进化史&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4.分布式系统互斥性与幂等性问题的分析与解决&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5.浅谈可重入性及其他&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;6.Distributed locks with Redis&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;7.How to do distributed locking&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;8.Is Redlock safe?&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;9.Note on fencing and distributed locks&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-copyright=&quot;0&quot; data-ratio=&quot;0.02847130968024529&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jE5bOw22iaBsseSfyAldiaR4R3UMuxvTLoibspKdM7d2ePE6INj7RnywH5xnvFmLC2pXxUSBUVejaAhKcme5CPyXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2283&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-copyright=&quot;0&quot; data-ratio=&quot;0.16146393972012918&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jE5bOw22iaBsz4OAZe6Wr6wibWOdFRduRXen6uibicDHQkgg0Cjd5ySeG2jOwMarWbDK7icApR3PNmdicPQlUdrowpnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;929&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.25876288659793817&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/jE5bOw22iaBvxHozhM8S9If1R4gBm2g4YbgVicCqZ04Mtiar5dpLZ1IcdokLfHRoOb32UhuibM8wWib1AJy2mBcoU2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3880&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;曾  奇&lt;/strong&gt;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;滴滴 | 业务平台技术&lt;br/&gt;研发工程师&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;北京科技大学本硕，2018年应届入职滴滴。热爱技术，更热爱用技术去解决实际问题。对分布式系统，大型网站架构有一定的了解。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>60f1c571a071dece68020c2dce89b28e</guid>
<title>老生常谈 Spring Aop 日志收集与处理做的工具包</title>
<link>https://toutiao.io/k/b79camp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body cnblogs-markdown&quot;&gt;
    &lt;h4 id=&quot;aoplog是基于spring-aop-和threadlocal实现的一个专门对请求方法内容日志的拦截与处理的日志工具包。&quot;&gt;AopLog是基于Spring Aop 和ThreadLocal实现的一个专门对请求方法内容日志的拦截与处理的日志工具包。&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img.shields.io/static/v1?label=release&amp;amp;message=2.1&amp;amp;color=green&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img.shields.io/static/v1?label=jar&amp;amp;message=16k&amp;amp;color=green&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img.shields.io/badge/License-Apache%202.0-blue.svg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img.shields.io/badge/JDK-1.8+-red.svg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;场景 :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用Spring Aop拦截参数日志目前大部分做法都基本上大同小异,不想日后每个项目工程都写一份这样的Aop拦截处理日志的代码,甚至代码侵入。&lt;/li&gt;
&lt;li&gt;我想知道一些相对重要的请求方法的请求参数,响应参数,请求头,以及内部耗时,方法是成功还是失败等等信息。发生错误时我也不知道执行到哪一步发生了异常，是不是某个参数导致出的逻辑问题。&lt;/li&gt;
&lt;li&gt;普通的log.info或warn信息没有所属请求的上下关系,并不方便查看和分析。&lt;/li&gt;
&lt;li&gt;正式环境中,我并不想打印太多无意义的info日志(有些只是为了排查问题打印的日志,程序正常运行时其实毫无意义)，只希望在发生异常时记录日志或者只希望每次请求只记录一条关键的请求信息。&lt;/li&gt;
&lt;li&gt;日志的收集,我希望将这些请求的日志记录下来，记录的实现方式我自己决定，比如正常的日志打印，常见的日志写入数据库，日志写入到文件，日志入队列等等。&lt;/li&gt;
&lt;li&gt;整个日志的记录完全不干扰正常请求方法的流程,日志的收集处理异步化,完全不影响正常请求方法的性能与响应。&lt;/li&gt;
&lt;li&gt;只需要通过&lt;code&gt;@AopLog&lt;/code&gt;注解决定是否记录。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;快速开始&quot;&gt;快速开始&lt;/h3&gt;
&lt;h4 id=&quot;项目通过maven的pomxml引入&quot;&gt;项目通过maven的pom.xml引入&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-xml&quot;&gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.github.ealenxie&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;aop-log&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.1&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;或者通过gradle引入&quot;&gt;或者通过gradle引入&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&quot;language-gradle&quot;&gt;compile group: &#x27;com.github.ealenxie&#x27;, name: &#x27;aop-log&#x27;, version: &#x27;2.1&#x27;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;aoplog注解使用，进行日志记录&quot;&gt;@AopLog注解使用，进行日志记录&lt;/h4&gt;
&lt;p&gt;直接在类(作用类的所有方法)或类方法(作用于方法)上加上注解@AopLog,进行日志记录&lt;/p&gt;
&lt;p&gt;例如 :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;import com.github.AopLog;
import name.ealen.infra.base.resp.RespBody;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @author EalenXie create on 2020/6/22 14:28
 */
@AopLog(type = &quot;测试&quot;,stackTraceOnErr = true)
@RestController
public class AppController {

    @GetMapping(&quot;/app/sayHello&quot;)
    public RespBody&amp;lt;String&amp;gt; sayHello() {
        return RespBody.ok(&quot;hello EalenXie&quot;);
    }

}

&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;自定义全局的日志收集器实现收集-logcollector&quot;&gt;自定义全局的日志收集器实现收集 LogCollector&lt;/h4&gt;
&lt;p&gt;例如只是简单打印,或写入到库等等。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.github.LogData;
import com.github.collector.LogCollector;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

/**
 * @author EalenXie create on 2020/9/15 13:46
 * 此为样例参考
 * 配置一个简单的日志收集器 这里只是做了一个log.info打印一下，可以在这里写入到数据库中或者写入
 */
@Slf4j
@Component
public class AopLogCollector implements LogCollector {
    private ObjectMapper objectMapper = new ObjectMapper();
    @Override
    public void collect(LogData logData) {
        try {
            log.info(objectMapper.writeValueAsString(logData));
        } catch (JsonProcessingException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置@Component的全局日志收集器只能配置一个。&lt;/p&gt;
&lt;p&gt;接口调用 &lt;code&gt;/say/hello&lt;/code&gt; 测试即可看看到控制台打印出结果 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2020-09-16 16:01:04.782  INFO 2012 --- [AsyncExecutor-2] name.ealen.infra.advice.AopLogCollector  : {&quot;appName&quot;:&quot;app-template&quot;,&quot;host&quot;:&quot;127.0.0.1&quot;,&quot;port&quot;:8080,&quot;clientIp&quot;:&quot;192.168.110.1&quot;,&quot;reqUrl&quot;:&quot;http://localhost:8080/app/sayHello&quot;,&quot;httpMethod&quot;:&quot;GET&quot;,&quot;headers&quot;:{&quot;User-Agent&quot;:&quot;Apache-HttpClient/4.5.10 (Java/11.0.5)&quot;},&quot;type&quot;:&quot;测试&quot;,&quot;content&quot;:&quot;&quot;,&quot;method&quot;:&quot;name.ealen.api.facade.AppController#sayHello&quot;,&quot;args&quot;:null,&quot;respBody&quot;:{&quot;code&quot;:&quot;200&quot;,&quot;desc&quot;:&quot;OK&quot;,&quot;message&quot;:&quot;请求成功&quot;,&quot;dateTime&quot;:&quot;2020-09-16 16:01:04&quot;,&quot;body&quot;:&quot;hello EalenXie&quot;},&quot;logDate&quot;:1600243264780,&quot;costTime&quot;:1,&quot;threadName&quot;:&quot;http-nio-8080-exec-3&quot;,&quot;threadId&quot;:33,&quot;success&quot;:true}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;记录的日志对象logdata属性说明&quot;&gt;记录的日志对象LogData属性说明&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;LogData 记录的内容&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;字段&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;注释&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;appName&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;应用名称&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;host&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;主机&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;port&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;端口号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;clientIp&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;请求客户端的Ip&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reqUrl&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;请求地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;headers&lt;/td&gt;
&lt;td&gt;Object&lt;/td&gt;
&lt;td&gt;请求头部信息(可选择记录) 默认记录user-agent,content-type&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;type&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;操作类型,默认值undefined&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;content&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;方法步骤内容,默认是空,可使用LogData.step进行内容步骤记录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;method&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;请求的本地java方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;args&lt;/td&gt;
&lt;td&gt;Object&lt;/td&gt;
&lt;td&gt;方法请求参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;respBody&lt;/td&gt;
&lt;td&gt;Object&lt;/td&gt;
&lt;td&gt;方法响应参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;costTime&lt;/td&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;整个方法耗时&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;logDate&lt;/td&gt;
&lt;td&gt;Date&lt;/td&gt;
&lt;td&gt;Log产生时间,LogData对象初始化的时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;threadName&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;线程名称&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;threadId&lt;/td&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;线程Id&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;success&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;执行状态,成功(true)/异常(false)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;aoplog-注解选项说明&quot;&gt;AopLog 注解选项说明&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;默认&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;logOnErr&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;仅当发生异常时才记录收集&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;type&lt;/td&gt;
&lt;td&gt;String&lt;/td&gt;
&lt;td&gt;操作类型&lt;/td&gt;
&lt;td&gt;默认值&quot;undefined&quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;headers&lt;/td&gt;
&lt;td&gt;String[]&lt;/td&gt;
&lt;td&gt;记录的header信息 ,选择要记录哪些header信息&lt;/td&gt;
&lt;td&gt;默认&quot;User-Agent&quot;,&quot;content-type&quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;args&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;是否记录请求参数&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;respBody&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;是否记录响应参数&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;stackTraceOnErr&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;当目标方法发生异常时,是否追加异常堆栈信息到LogData的content中&lt;/td&gt;
&lt;td&gt;false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;asyncMode&lt;/td&gt;
&lt;td&gt;boolean&lt;/td&gt;
&lt;td&gt;异步方式收集&lt;/td&gt;
&lt;td&gt;true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;collector&lt;/td&gt;
&lt;td&gt;Class&amp;lt;? extends LogCollector&amp;gt;&lt;/td&gt;
&lt;td&gt;指定日志收集器&lt;/td&gt;
&lt;td&gt;默认不调整收集器,使用全局的日志收集器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&quot;logdata的step方法。&quot;&gt;LogData的step方法。&lt;/h4&gt;
&lt;p&gt;记录步骤。(如果某些重要步骤希望被记录下来)&lt;br/&gt;
例如 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import com.github.AopLog;
import com.github.LogData;
import name.ealen.infra.base.resp.RespBody;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;


/**
 * @author EalenXie create on 2020/6/22 14:28
 */
@AopLog(type = &quot;测试&quot;,stackTraceOnErr = true)
@RestController
public class AppController {


    @GetMapping(&quot;/app/sayHello&quot;)
    public RespBody&amp;lt;String&amp;gt; sayHello() {
        LogData.step(&quot;1. 第一步执行完成&quot;);
        //......
        LogData.step(&quot;2. 第二步执行完成&quot;);
        //.....
        LogData.step(&quot;3. service的方法执行完成&quot;);
        //.....
        return RespBody.ok(&quot;hello EalenXie&quot;);
    }

}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意: 此方法如果不在被@AopLog注解的方法的整体调用链路中使用，则当前线程中的ThreadLocal中的LogData不会释放，需要手动调用LogData.removeCurrent();&lt;/p&gt;
&lt;p&gt;此时再次接口调用 &lt;code&gt;/say/hello&lt;/code&gt; 测试即可看看到控制台打印出结果，重点观察content字段 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;2020-09-16 17:26:20.285  INFO 3284 --- [AsyncExecutor-2] name.ealen.infra.advice.AopLogCollector  : {&quot;appName&quot;:&quot;app-template&quot;,&quot;host&quot;:&quot;127.0.0.1&quot;,&quot;port&quot;:8080,&quot;clientIp&quot;:&quot;192.168.110.1&quot;,&quot;reqUrl&quot;:&quot;http://localhost:8080/app/sayHello&quot;,&quot;httpMethod&quot;:&quot;GET&quot;,&quot;headers&quot;:{&quot;User-Agent&quot;:&quot;Apache-HttpClient/4.5.10 (Java/11.0.5)&quot;},&quot;type&quot;:&quot;测试&quot;,&quot;content&quot;:&quot;1. 第一步执行完成\n2. 第二步执行完成\n3. service的方法执行完成\n&quot;,&quot;method&quot;:&quot;name.ealen.api.facade.AppController#sayHello&quot;,&quot;args&quot;:null,&quot;respBody&quot;:{&quot;code&quot;:&quot;200&quot;,&quot;desc&quot;:&quot;OK&quot;,&quot;message&quot;:&quot;请求成功&quot;,&quot;dateTime&quot;:&quot;2020-09-16 17:26:20&quot;,&quot;body&quot;:&quot;hello EalenXie&quot;},&quot;logDate&quot;:1600248380283,&quot;costTime&quot;:1,&quot;threadName&quot;:&quot;http-nio-8080-exec-2&quot;,&quot;threadId&quot;:32,&quot;success&quot;:true}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&quot;关于&quot;&gt;关于&lt;/h4&gt;
&lt;p&gt;开源Github地址 : &lt;a href=&quot;https://github.com/EalenXie/aop-log&quot;&gt;https://github.com/EalenXie/aop-log&lt;br/&gt;
&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;感谢各位提出意见和支持。&lt;/p&gt;
&lt;p&gt;我的博客即将同步至腾讯云+社区，邀请大家一同入驻：&lt;a href=&quot;https://cloud.tencent.com/developer/support-plan?invite_code=2xarst7a9zsw8&quot;&gt;https://cloud.tencent.com/developer/support-plan?invite_code=2xarst7a9zsw8&lt;/a&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>