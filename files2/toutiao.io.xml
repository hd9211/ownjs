<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>078c622dcd1a25c5de0fe52487109072</guid>
<title>技术方案设计的方法</title>
<link>https://toutiao.io/k/jc76sul</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;前段时间接手了一个还处于方案设计阶段的工作，我重新做了设计。觉得新方案比旧方案业务清晰明朗、解决了旧方案的缺陷。我就很高兴，跟同事聊这个事情。同事就问我是怎么想到这些的呢。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我说了一些细节的，但是没有把核心本质讲出来。我觉得这是个很难回答的问题。因为一个方案怎么更合适，主要因素包含业务理解、个人经验、思维逻辑。这3个要素一般都是靠经年累月的积累才获得的。从这些中提取出别人可以学习和使用的方法确实不是一会儿就能想出来的事情。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;市面上可以看到的关于技术方案设计的经典的书都没有仔细的去讲这个问题。比如《人月神话》讲的是项目大了怎么办、《架构即未来》讲的是架构扩展性的问题。那对于最普通的CURD(创建更新读取删除)系统究竟怎么去设计。都是做CURD的，架构师和普通开发区别在哪里。本文就来探讨一下这个问题。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;CURD系统怎么做出技术含量&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我前几年在面试别人的时候，遇到过一些面试者，已经带领别人做过项目了。可能人家的管理能力是不错的。项目管理是个博大精深的学问，可能一个项目在不同的阶段，更上层会找不同的管理者来做。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;比如初创团队，会找些善于创业、擅长打造敏捷团队的管理者。这样的管理者可能会比较善于鼓舞团队士气。而到了一定阶段，项目业务量起来之后，不再求快，而是求稳。这时候管理者可能会换人，新的管理者做事并不那么快，但是做决策的路很正。路很正怎么理解，打个比方说：别人提了需求，前一个领导人很好，人家来需求他就接。这个领导不是，他会分析利弊和领域、业务是否合适放在这里。再比如更一层领导提了一个需求，要求什么什么时间做完。这个领导会去分析上层领导更本质的需求，宁可延期，要做稳做好。而项目稳定之后，继续稳定下去已经没有什么业绩了。这时候可能会再换领导，这个领导会带来一些原来积累的规划、方法。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;总之，这个面试者可能有这些能力，但是我们要招聘一个技术人员，先考察硬实力，所以很自然的先请他介绍之前的项目做了什么和怎么做的。他自己也很没底气的说就是CURD嘛。给人感觉就是没有想法，在工作过程中思考的少。&lt;br/&gt;&lt;/p&gt;&lt;p&gt;拿一个后台管理系统来说，要对重要数据进行添加修改删除，一般需要审核、审计，敏感数据脱敏，甚至需要数据灰度。将这整套流程串联起来，需要一个工作流系统，可能会用到工作流引擎。目前有些数据脱敏已经用上了NLP(自然语言处理)技术。这里面每一步都涉及知识点。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;数据模型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;有限状态机设计&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;刚才提到后台管理系统里用到审核、审计、灰度。这三个可以与业务流程分离，做成三个工具组件。审核有审核状态：审核中、审核成功，审核失败。灰度也有待灰度、灰度中、灰度成功、灰度失败四种状态。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;假如有一条数据，目前它的状态可以分成数据状态：有效数据和无效数据。另外还有审核状态和灰度状态。这时候数据模型(可以简单理解成数据库的数据表设计)应该设计成三个状态用三个数据字段表示呢，还是用一个数据字段来表示这三种状态呢。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这要看情况，一般来说，如果三种状态之前是相互独立的，比如：审核中是否可以待灰度，也可能是灰度中？对于一个工作流系统来说，一般要先审核通过才会进行灰度流程。就是说各个状态是互斥的。所以设计成三个字段，程序的判断逻辑会很复杂，因为有些组合是不成立的。这时候更合理的一个设计是用一个状态字段表示，通过状态机流转来控制。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;设计方案中可以通过类似下面的流转图来体现：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.70917225950783&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8l6wfnRA330O2MsEGAdjo4UXbicbGAk4J6D65icIQOBXJHgzEu9uhZLpcia7DfTnApRXk5qLS2YvWQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;894&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;实际方案设计过程中我改造了一下，状态正常从左到右流转，将终态用不同的形状(这里用椭圆)来表示。这样表示秩序感强些，更好理解。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4270531400966184&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8l6wfnRA330O2MsEGAdjo4CT9KTLDLRCsUYWDb9vHQDW5BhUdnbzQFOpfxcKD33ncHb7KlC14L3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1035&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;数据表设计&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在数据表设计时，要至少考虑数据类型、是否默认、是否为空和索引设计。比如对于钱什么的，需要用decimal(10,2)，具体精确到多少位，要根据业务理解来定。对于加密字符什么的，加密如果是md5的，可以用char，而不用varchar来提高效率。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这里面就好像《红楼梦》里的台词一样，每条都很有学问。所以面试时的场景题也经常爱让进行一个数据表设计。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3135646687697161&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8l6wfnRA330O2MsEGAdjo4d6qxbIx3879enMZOOw4MR9HkqIz1geR7iaPxib0txhKKr0qe10WSMW4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1585&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;流程设计&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我比较建议在一个设计方案开始时先把设计流程图先给出来，便于对方案有个整体认知。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;流程图也很有学问，【亿图】软件上把流程图分成了下面的子类。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.23336006415396954&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8l6wfnRA330O2MsEGAdjo41opFVQ2AJ6KMmQb4o7ic9OehJjEI5jM7e97SAYAXxZPK5nJTzzdMIIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1247&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我个人最常用的是泳道图和BPMN。BPMN可以简单理解为业务流程图和泳道图差别不大。就是在普通流程图基础上增加一个分类，这个分类可以是阶段、也可以是执行者这些。就是给流程图多增加一个维度的信息，理解起来更清晰。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7156511350059738&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8l6wfnRA330O2MsEGAdjo4iagBDgFFPI4dhnUWbtLACSc9Kibofoict49HzaKVv6t97M5m5hnibNc61Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;837&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在设计方案里还必须要有里程碑和未来规划。有句废话叫只怕有心人。在工作中，往往工作出色的并不是最聪明的，也不是花时间最长的。而是真正用心做的人。特别是设计方案，建议多用前人和大家总结的设计模板。模板最能代表一种设计思路。自己想到的、设计模板想到的都要考虑清楚，把方案做细。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;遇到具体的问题，要做业界调研。之前听过一个实习生做的方案，他说业界调研的时候并没有查到特别相关的方案资料。当时我的领导就说了一句特别值得思考的话：如果没有查到，肯定是你的检索关键词不对。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我后来反复斟酌这句话，发现能想到的检索关键词才是真正体现自己对业务理解的。同时，业界调研的时候不仅要对业务相关做调研，需求可以分解，具体到每个步骤也需要调研。调研过程是个极好的学习机会。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;下功夫和不下功夫的区别，想想《红楼梦》，之所以这么多红学者。人家红楼梦的作者设计每句话都是剧透，人物说出的话，都会被啪啪打脸。里面的每道菜谱都是值得专业厨师来研究的。这都是心用到了。优秀架构师也是这样炼成的。之所以说这个废话，因为我就被diss过方案做的不够细，我也看过别人的方案不够细的。时常回想被diss不够细的那句话，觉得真的是金玉良言。心怀感激。&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b58c7ce8139ec9b8af0ccf5c01db3415</guid>
<title>设计模式大冒险第一关：观察者模式</title>
<link>https://toutiao.io/k/l6bta2w</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近把之前学习过的这些设计模式又再次温习了一下，觉得还是有很多收获的。确实有了&lt;strong&gt;温故知新&lt;/strong&gt;的感觉，所以准备在每个设计模式复习完之后都能够写一篇关于这个设计模式的文章，这样会让自己能够加深对这个设计模式的理解；也能够跟大家一起来探讨一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们来一起学习一下&lt;strong&gt;观察者模式&lt;/strong&gt;，刚开始我们不需要知道观察者模式的定义是什么，这些我们到后面再去了解。我想先带着大家从生活中的一个小事例开始。&lt;strong&gt;从生活中熟悉的事情入手，会让我们更快速的理解这个模式的用途&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;生活中的小例子&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信大家都关注过一些公众号，&lt;strong&gt;那么对于一个公众号来说，如果有新的文章发布的话；那么所有关注这个公众号的用户都会收到更新的通知，如果一个用户没有关注或者关注后又取消了关注，那么这个用户就不会收到该公众号更新的通知&lt;/strong&gt;。相信这个场景大家都很熟悉吧。那么如果我们把这个过程抽象出来，用代码来实现的话，你会怎么处理呢？不妨现在停下来思考一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的描述，我们知道这是一个&lt;strong&gt;一对多的关系&lt;/strong&gt;。也就是一个公众号对应着许多关注这个公众号的用户。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6748878923766816&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fj9xyC53hPX4W4Sf8cgG3UjicjvVS9QFjWmKMcBqDjHAWDEJe28zaZeiaQibYbUNaM7CIqXOnWwM6SOXFIFrmicIoQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;446&quot;/&gt;&lt;figcaption&gt;关注公众号&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么对于这个公众号来说，&lt;strong&gt;它的内部需要有一个列表记录着关注这个公众号的用户&lt;/strong&gt;，一旦公众号有了新的内容。那么对于公众号来说，&lt;strong&gt;它会遍历这个列表。然后给列表中的每一个用户发送一个内容跟新的通知&lt;/strong&gt;。我们可以通过代码来表示这个过程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 用户&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; user = {&lt;br/&gt; update() {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;公众号更新了新的内容&#x27;&lt;/span&gt;);&lt;br/&gt; },&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 公众号&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; officialAccount = {&lt;br/&gt;    &lt;span&gt;// 关注当前公众号的用户列表&lt;/span&gt;&lt;br/&gt; followList: [user],&lt;br/&gt;    &lt;span&gt;// 公众号更新时候调用的通知函数&lt;/span&gt;&lt;br/&gt; notify() {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; len = &lt;span&gt;this&lt;/span&gt;.followList.length;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (len &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;      &lt;span&gt;// 通知已关注该公众号的每个用户，有内容更新&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; user &lt;span&gt;of&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.followList) {&lt;br/&gt;    user.update();&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; },&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 公众号有新内容更新&lt;/span&gt;&lt;br/&gt;officialAccount.notify();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行的结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;公众号更新了新的内容&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码能够简单的表示，当公众号的内容发生了更新的时候，去通知关注该公众号的用户的过程。但是这个实现是很简陋的，还缺少一些内容。我们接下来把这些缺少的过程补充完整。&lt;strong&gt;对于公众号来说，还需要可以添加新的关注的用户，移除不再关注的用户，获取关注公众号的用户总数等&lt;/strong&gt;。我们来实现一下上面的过程：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 公众号&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; officialAccount = {&lt;br/&gt; &lt;span&gt;// 关注当前公众号的用户列表&lt;/span&gt;&lt;br/&gt; followList: [],&lt;br/&gt; &lt;span&gt;// 公众号更新时候调用的通知函数&lt;/span&gt;&lt;br/&gt; notify() {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; len = &lt;span&gt;this&lt;/span&gt;.followList.length;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (len &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;   &lt;span&gt;// 通知已关注该公众号的每个用户，有内容更新&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; user &lt;span&gt;of&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.followList) {&lt;br/&gt;    user.update();&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; },&lt;br/&gt; &lt;span&gt;// 添加新的关注的用户&lt;/span&gt;&lt;br/&gt; add(user) {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.followList.push(user);&lt;br/&gt; },&lt;br/&gt; &lt;span&gt;// 移除不再关注的用户&lt;/span&gt;&lt;br/&gt; remove(user) {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; idx = &lt;span&gt;this&lt;/span&gt;.followList.indexOf(user);&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (idx !== &lt;span&gt;-1&lt;/span&gt;) {&lt;br/&gt;   &lt;span&gt;this&lt;/span&gt;.followList.splice(idx, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt; },&lt;br/&gt; &lt;span&gt;// 计算关注公众号的总的用户数&lt;/span&gt;&lt;br/&gt; count() {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.followList.length;&lt;br/&gt; },&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 新建用户的类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;constructor&lt;/span&gt;(name) {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.name = name;&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 接收公众号内容更新的通知&lt;/span&gt;&lt;br/&gt; update() {&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`&lt;span&gt;${&lt;span&gt;this&lt;/span&gt;.name}&lt;/span&gt;接收到了公众号的内容更新`&lt;/span&gt;);&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 创建两个新的用户&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; zhangSan = &lt;span&gt;new&lt;/span&gt; User(&lt;span&gt;&#x27;张三&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; liSi = &lt;span&gt;new&lt;/span&gt; User(&lt;span&gt;&#x27;李四&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 公众号添加关注的用户&lt;/span&gt;&lt;br/&gt;officialAccount.add(zhangSan);&lt;br/&gt;officialAccount.add(liSi);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 公众号有新内容更新&lt;/span&gt;&lt;br/&gt;officialAccount.notify();&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`当前关注公众号的用户数量是：&lt;span&gt;${officialAccount.count()}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 张三不再关注公众号&lt;/span&gt;&lt;br/&gt;officialAccount.remove(zhangSan);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 公众号有新内容更新&lt;/span&gt;&lt;br/&gt;officialAccount.notify();&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`当前关注公众号的用户数量是：&lt;span&gt;${officialAccount.count()}&lt;/span&gt;`&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输出的结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;张三接收到了公众号的内容更新&lt;br/&gt;李四接收到了公众号的内容更新&lt;br/&gt;当前关注公众号的用户数量是：2&lt;br/&gt;李四接收到了公众号的内容更新&lt;br/&gt;当前关注公众号的用户数量是：1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的代码完善了关注和取消关注的过程，并且可以获取当前公众号的关注人数。我们还实现了一个用户类，能够让我们快速创建需要添加到公众号关注列表的用户。当然你也可以把公众号的实现通过一个类来完成，这里就不再展示实现的过程了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面这个简单的例子，你是不是有所感悟，有了一些新的收获？&lt;strong&gt;我们上面实现的其实就是一个简单的观察者模式&lt;/strong&gt;。接下来我们来聊一聊观察者模式的定义，以及一些在实际开发中的用途。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;观察者模式的定义&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;所谓的观察者模式指的是一种一对多的关系，我们把其中的&lt;code&gt;一&lt;/code&gt;叫做&lt;code&gt;Subject&lt;/code&gt;（类比上文中的公众号），把其中的&lt;code&gt;多&lt;/code&gt;叫做&lt;code&gt;Observer&lt;/code&gt;（类比上文中关注公众号的用户），也就是观察者。因为多个&lt;code&gt;Observer&lt;/code&gt;的变动依赖&lt;code&gt;Subject&lt;/code&gt;的状态更新，所以&lt;code&gt;Subject&lt;/code&gt;在内部维护了一个&lt;code&gt;Observer&lt;/code&gt;的列表，一旦&lt;code&gt;Subject&lt;/code&gt;的状态有更新，就会遍历这个列表，通知列表中每一个&lt;code&gt;Observer&lt;/code&gt;进行相应的更新。因为有了这个列表，&lt;code&gt;Subject&lt;/code&gt;就可以对这个列表进行增删改查的操作。也就实现了&lt;code&gt;Observer&lt;/code&gt;对&lt;code&gt;Subject&lt;/code&gt;依赖的更新和解绑&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看一下观察者模式的&lt;code&gt;UML&lt;/code&gt;图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4131944444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/fj9xyC53hPX4W4Sf8cgG3UjicjvVS9QFj3ESHeV5wricu9IRuq9REDiatN085rnxbSLrOicics7gL34lPMsaGSCDptQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2880&quot;/&gt;&lt;figcaption&gt;观察者模式UML模式&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图我们这可以看到，对于&lt;code&gt;Subject&lt;/code&gt;来说，它自身需要维护一个&lt;code&gt;observerCollection&lt;/code&gt;，这个列表里面就是&lt;code&gt;Observer&lt;/code&gt;的实例。然后在&lt;code&gt;Subject&lt;/code&gt;内部实现了增加观察者，移除观察者，和通知观察者的方法。其中通知观察者的方式就是遍历&lt;code&gt;observerCollection&lt;/code&gt;列表，依次调用列表中每一个&lt;code&gt;observer&lt;/code&gt;的&lt;code&gt;update&lt;/code&gt;方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里为止，你现在已经对这个设计模式有了一些了解。那我们学习这个设计模式有什么作用呢？&lt;strong&gt;首先如果我们在开发中遇到这种类似上面的一对多的关系，并且&lt;code&gt;多&lt;/code&gt;的状态更新依赖&lt;code&gt;一&lt;/code&gt;的状态；那么我们就可以使用这种设计模式去解决这种问题。而且我们也可以使用这种模式解耦我们的代码，让我们的代码更好拓展与维护&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然一些同学会觉得自己在平时的开发中好像没怎么使用过这种设计模式，那是因为我们平时在开发中一般都会使用一些框架，比如&lt;code&gt;Vue&lt;/code&gt;或者&lt;code&gt;React&lt;/code&gt;等，&lt;strong&gt;这个设计模式已经被这些框架在内部实现好了。我们可以直接使用，所以我们对这个设计模式的感知会少一些&lt;/strong&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;实战：实现一个简单的TODO小应用&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之前我开发的一个组队打卡小程序&lt;a class=&quot;weapp_text_link js_weapp_entry&quot; data-miniprogram-appid=&quot;wx1fffeba49d074af6&quot; data-miniprogram-path=&quot;pages/main-thread/index/index&quot; data-miniprogram-nickname=&quot;主线程&quot; href=&quot;&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-servicetype=&quot;&quot;&gt;主线程&lt;/a&gt;，其中首页待办的一些功能就使用了&lt;strong&gt;观察者模式&lt;/strong&gt;，今天我们利用观察者模式实现一个粗糙的版本&lt;span&gt;，&lt;/span&gt;&lt;strong&gt;就是能够让用户添加自己的待办，并且需要显示已添加的待办事项的数量&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解了需求之后，我们需要确定那些是&lt;code&gt;一&lt;/code&gt;，哪些是&lt;code&gt;多&lt;/code&gt;。当然我们知道整个TODO的&lt;code&gt;状态&lt;/code&gt;就是我们所说的&lt;code&gt;一&lt;/code&gt;，那么对于&lt;code&gt;待办列表的展示&lt;/code&gt;以及&lt;code&gt;待办列表的计数&lt;/code&gt;就是我们所说的&lt;code&gt;多&lt;/code&gt;。理清了思路之后，实现这个小应用就变得很简单了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;可以点击👉这里提前体验一下这个简单的小应用&lt;/strong&gt;。&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.142156862745098&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/fj9xyC53hPX4W4Sf8cgG3UjicjvVS9QFjMSHZIjAibEo2CiblxsXk3bf3dv3pA9XlCqfWgkgzTYGnyboHyic4HoI5A/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;816&quot;/&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;TODO小应用&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们需要先实现观察者模式中的&lt;code&gt;Subject&lt;/code&gt;和&lt;code&gt;Observer&lt;/code&gt;类，代码如下所示。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Subject&lt;/code&gt;类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Subject&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Subject&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;constructor&lt;/span&gt;() {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.observerCollection = [];&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 添加观察者&lt;/span&gt;&lt;br/&gt; registerObserver(observer) {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.observerCollection.push(observer);&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 移除观察者&lt;/span&gt;&lt;br/&gt; unregisterObserver(observer) {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; observerIndex = &lt;span&gt;this&lt;/span&gt;.observerCollection.indexOf(observer);&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.observerCollection.splice(observerIndex, &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 通知观察者&lt;/span&gt;&lt;br/&gt; notifyObservers(subject) {&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; collection = &lt;span&gt;this&lt;/span&gt;.observerCollection;&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; len = collection.length;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (len &amp;gt; &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; observer &lt;span&gt;of&lt;/span&gt; collection) {&lt;br/&gt;    observer.update(subject);&lt;br/&gt;   }&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Observer&lt;/code&gt;类：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 观察者&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Observer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; update() {}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么接下来的代码就是关于上面待办的具体实现了，代码中也添加了相应的注释，我们来看一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;待办应用的逻辑部分：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// 表单的状态&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Todo&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Subject&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;constructor&lt;/span&gt;() {&lt;br/&gt;  &lt;span&gt;super&lt;/span&gt;();&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.items = [];&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 添加todo&lt;/span&gt;&lt;br/&gt; addItem(item) {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.items.push(item);&lt;br/&gt;  &lt;span&gt;super&lt;/span&gt;.notifyObservers(&lt;span&gt;this&lt;/span&gt;);&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 列表渲染&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ListRender&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Observer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;constructor&lt;/span&gt;(el) {&lt;br/&gt;  &lt;span&gt;super&lt;/span&gt;();&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.el = &lt;span&gt;document&lt;/span&gt;.getElementById(el);&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 更新列表&lt;/span&gt;&lt;br/&gt; update(todo) {&lt;br/&gt;  &lt;span&gt;super&lt;/span&gt;.update();&lt;br/&gt;  &lt;span&gt;const&lt;/span&gt; items = todo.items;&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.el.innerHTML = items.map(&lt;span&gt;&lt;span&gt;text&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;`&amp;lt;li&amp;gt;&lt;span&gt;${text}&lt;/span&gt;&amp;lt;/li&amp;gt;`&lt;/span&gt;).join(&lt;span&gt;&#x27;&#x27;&lt;/span&gt;);&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 列表计数观察者&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CountObserver&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Observer&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;constructor&lt;/span&gt;(el) {&lt;br/&gt;  &lt;span&gt;super&lt;/span&gt;();&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.el = &lt;span&gt;document&lt;/span&gt;.getElementById(el);&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 更新计数&lt;/span&gt;&lt;br/&gt; update(todo) {&lt;br/&gt;  &lt;span&gt;this&lt;/span&gt;.el.innerText = &lt;span&gt;`&lt;span&gt;${todo.items.length}&lt;/span&gt;`&lt;/span&gt;;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 列表观察者&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; listObserver = &lt;span&gt;new&lt;/span&gt; ListRender(&lt;span&gt;&#x27;item-list&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// 计数观察者&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; countObserver = &lt;span&gt;new&lt;/span&gt; CountObserver(&lt;span&gt;&#x27;item-count&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; todo = &lt;span&gt;new&lt;/span&gt; Todo();&lt;br/&gt;&lt;span&gt;// 添加列表观察者&lt;/span&gt;&lt;br/&gt;todo.registerObserver(listObserver);&lt;br/&gt;&lt;span&gt;// 添加计数观察者&lt;/span&gt;&lt;br/&gt;todo.registerObserver(countObserver);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 获取todo按钮&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; addBtn = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;add-btn&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// 获取输入框的内容&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; inputEle = &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;new-item&#x27;&lt;/span&gt;);&lt;br/&gt;addBtn.onclick = &lt;span&gt;&lt;span&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;const&lt;/span&gt; item = inputEle.value;&lt;br/&gt; &lt;span&gt;// 判断添加的内容是否为空&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; (item) {&lt;br/&gt;  todo.addItem(item);&lt;br/&gt;  inputEle.value = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt; }&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的代码我们可以清楚地知道这个应用的每一个部分，被观察的&lt;code&gt;Subject&lt;/code&gt;就是我们的&lt;code&gt;todo&lt;/code&gt;对象，它的状态就是待办列表。它维护的观察者列表分别是展示待办列表的&lt;code&gt;listObserver&lt;/code&gt;和展示待办数量的&lt;code&gt;countObserver&lt;/code&gt;。一旦&lt;code&gt;todo&lt;/code&gt;的列表新增加了一项待办，那么就会通知这两个观察者去做相应的内容更新。这样代码的逻辑就很直观明了。如果以后在状态变更的时候还要添加新的功能，我们只需要再次添加一个相应的&lt;code&gt;observer&lt;/code&gt;就可以了，维护起来也很方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然上面的代码只实现了很基础的功能，&lt;strong&gt;还没有包含待办的完成和删除，以及对于未完成和已完成的待办的分类展示。而且列表的渲染每次都是重新渲染的，没有复用的逻辑&lt;/strong&gt;。因为我们本章的内容是跟大家一起来探讨一下观察者模式，所以上面的代码比较简陋，也只是为了说明观察者模式的用法。相信优秀的你能够在这个基础上，把这些功能都完善好，快去试试吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;其实我们学习这些设计模式，都是为了让代码的逻辑更加清晰明了，能够复用一些代码的逻辑，减少重复的工作，提升开发的效率。让整个应用更加容易维护和拓展。当然不能为了使用而使用，在使用之前，需要对当前的问题做一个全面的了解。到底需不需要使用某个设计模式是一个需要考虑清楚的问题。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好啦，关于观察者模式到这里就结束啦，大家如果有什么意见和建议可以在文章下面下面留言，我们一起探讨一下。也可以在这里提出来，我们更好地进行讨论。也欢迎大家关注我的公众号&lt;strong&gt;关山不难越&lt;/strong&gt;，随时随地获取文章的更新。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家如果有兴趣的话，可以看一下我之前的作品&lt;a class=&quot;weapp_text_link js_weapp_entry&quot; data-miniprogram-appid=&quot;wx1fffeba49d074af6&quot; data-miniprogram-path=&quot;pages/main-thread/index/index&quot; data-miniprogram-nickname=&quot;主线程&quot; href=&quot;&quot; data-miniprogram-type=&quot;text&quot; data-miniprogram-servicetype=&quot;&quot;&gt;主线程&lt;/a&gt;，如果这个小程序能够对你有一些帮助的话就更好了~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考链接：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;The Observer Pattern&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;How to Use the Observable Pattern in JavaScript&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文章封面图来源：unDraw&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1efa1aef55157d09a044561945f9cae9</guid>
<title>工具 | 一个轻量级业务中台开发框架</title>
<link>https://toutiao.io/k/6qs3yvv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>ea0c7e9327b158461c312aac885c1796</guid>
<title>业务压力一大就宕机？一文带你搞懂限流熔断</title>
<link>https://toutiao.io/k/wodn2gj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“在分布式应用中，最常见的问题是什么呢？”&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“一个分布式应用部署上去后，还要关注什么？”&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5603715170278638&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/KVl0giak5ib4jDrh1vIHLPh0nz30kZpJxyouM609fywaIrD4ZVNmuYhkdu1E85WzDr912Xy5CVtUa1j6uIEJ5pvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;646&quot;/&gt;&lt;figcaption&gt;图来自网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“这服务的远程调用依赖似乎有点多...”&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前言&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 《微服务的战争：级联故障和雪崩》中有提到，在一个分布式应用中，最常见，最有危险性之一的点就是级联故障所造成的雪崩，而其对应的解决方案为&lt;strong&gt;根据特定的规则/规律进行流量控制和熔断降级&lt;/strong&gt;，避免请求发生堆积，保护自身应用，也防止服务提供方进一步过载。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5654596100278552&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4jDrh1vIHLPh0nz30kZpJxy8FZvPC8ErPOCVKMoQmyKIHLVXNy7o8oiam8Q8fOqYImPFsWibMTVlwug/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1436&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来讲就是，要控制访问量的流量，要防各类调用的强/弱依赖，才能保护好应用程序的底线。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;诉求，期望&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;诉求：作为一个业务，肯定是希望自家的应用程序，能够全年无休，最低限度也要有个 4 个 9，一出突发性大流量，在资源贫乏的窗口期，就马上能够自动恢复。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;期望：万丈高楼平地起，我们需要对应用程序进行流量控制、熔断降级。确保在特定的规则下，系统能够进行容错，只处理自己力所能及的请求。若有更一步诉求，再自动扩缩容，提高系统资源上限。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;解决方案&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要如何解决这个问题，或者说是达到这个目的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;咱们可以关注到问题的核心点是 “系统没有任何的保护的情况下”，因此方向上就是让系统，让应用程序有流量控制的保护。一般含以下几个方面：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;来自端控制：在业务/流量网关处内置流量控制、熔断降级的外部插件，起到端控制的效果。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;来自集群/节点控制：在统一框架中内建流量控制、熔断降级的处理逻辑，起到集群/节点控制的效果。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;来自 Mesh 控制：通过 ServiceMesh 来实现流量控制、熔断降级。侵入性小，能带来多种控制模式，但有利有弊。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上的多种方式均可与内部的治理平台打通，且流量控制、熔断降级是不止面试应用程序的，就看资源埋点上如何设计、注入。常见有如下几种角度：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;资源的调用关系：例如远程调用，像是面向 HTTP、SQL、Redis、RPC 等调用均，另外针对文件句柄控制也可以。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;运行指标：例如 QPS、线程池、系统负载等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;流量控制&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在资源不变的情况下，系统所能提供的处理能力是有限的。而系统所面对的请求所到来的时间和量级往往是随机且不可控的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此就会存在可能出现突发性流量，而&lt;span&gt;系统&lt;/span&gt;在没有任何的保护的情况下，很有可能会在数分钟内就无法提供正常服务。常见的前导现象是先出现调用延迟，接着持续出现饱和度上升，最终假死。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5761024182076814&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4jDrh1vIHLPh0nz30kZpJxyQGNiakYvM4EREX9XXwL975RdfDhFXNsicHdC24t5V5N9JjWwRibKXbxlQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1406&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;流量控制一般常见的有两种方式，分别是：基于 QPS、基于并发隔离。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基于 QPS&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最常用的流量控制场景，就是基于 QPS 来做流控，在一定的时间窗口内按照特定的规则达到所设定的阈值则进行调控：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5609418282548476&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4jDrh1vIHLPh0nz30kZpJxydibYnEXXYL8gk5VCNaAjwISdtrpkjicjsMsptTPiaicTjopA5Nt44GXfCg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1444&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;案例&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本文中借助 sentinel-golang 来实现案例所需的诉求，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;import (&lt;br/&gt; ...&lt;br/&gt; sentinel &lt;span&gt;&quot;github.com/alibaba/sentinel-golang/api&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/alibaba/sentinel-golang/core/base&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/alibaba/sentinel-golang/core/flow&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/alibaba/sentinel-golang/util&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;func &lt;span&gt;&lt;span&gt;main&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; _ = sentinel.InitDefault()&lt;br/&gt; _, _ = flow.LoadRules([]*flow.Rule{&lt;br/&gt;  {&lt;br/&gt;   Resource:               &lt;span&gt;&quot;控制吃煎鱼的速度&quot;&lt;/span&gt;,&lt;br/&gt;   Threshold:              60,&lt;br/&gt;   ControlBehavior:        flow.Reject,&lt;br/&gt;  },&lt;br/&gt; })&lt;br/&gt;&lt;br/&gt; ...&lt;br/&gt; e, b := sentinel.Entry(&lt;span&gt;&quot;控制吃煎鱼的速度&quot;&lt;/span&gt;, sentinel.WithTrafficType(base.Inbound))&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; b != nil {&lt;br/&gt;     // Blocked&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;     // Passed&lt;br/&gt;     e.Exit()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总的来讲，上述规则结果就是 1s 内允许通过 60 个请求，超出的请求的处理策略为直接拒绝（Reject）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们初始化了 Sentinel 并定义资源（Resource）为 “控制吃煎鱼的速度”。其 Threshold 配置为 3，也就是 QPS 的阈值为 3，统计窗口未设置默认值为 1s，ControlBehavior 控制的行为为直接拒绝。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而在满足阈值条件后，常见的处理策略还有匀速排队（Throttling），匀速排队方式会严格控制请求通过的间隔时间，也就是让请求以均匀的速度通过。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基于并发隔离&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于资源访问的并发协程数来控制对资源的访问数量，主要是控制对资源访问的最大协程数，避免因为资源的异常导致协程耗尽。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7390510948905109&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4jDrh1vIHLPh0nz30kZpJxycaRhTQdwmTnxzHDGJpVa2ia6bHGrVAJ0CDXT35ZkgJTbKjr6NnblFAg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1096&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这类情况，Go 语言在设计上常常可以使用协程池来进行控制，但设计总是赶不上计划的，且不同场景情况可能不同，因此作为一个日常功能也是非常有存在的必要性。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;熔断降级&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式应用中，随着不断地业务拆分，远程调用逐渐变得越来越多。且在微服务盛兴的情况下，一个小业务拆出七八个服务的也常有。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时就会出现一个经典的问题，那就是客户端的一个普通调用，很有可能就要经过好几个服务，而一个服务又有可能远程调用外部 HTTP、SQL、Redis、RPC 等，调用链会特别的长。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若其中一个调用流程出现了问题，且没有进行调控，就会出现级联故障，最终导致系统雪崩：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3888888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4jDrh1vIHLPh0nz30kZpJxyyibbgQIRj7KFwToKPtbzh1vHWGrEDAcAOL4HDOiaupiaTb87f1GPxoibYw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1692&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;服务 D 所依赖的外部接口出现了故障，而他并没有做任何的控制，因此扩散到了所有调用到他的服务，自然也就包含服务 B，因此最终出现系统雪崩。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种最经典的是出现在默认 Go http client 调用没有设置 Timeout，从而只要出现一次故障，就足矣让记住这类 “坑”，毕竟崩的 ”慢“，错误日志还多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（via: 《微服务的战争：级联故障和雪崩》）&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;目的和措施&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决上述问题所带来的灾难，在分布式应用中常需要对服务依赖进行熔断降级。在存在问题时，暂时切断内部调用，避免局部不稳定因素导致整个分布式系统的雪崩。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而熔断降级作为保护服务自身的手段，通常是在客户端进行规则配置和熔断识别：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5306451612903226&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4jDrh1vIHLPh0nz30kZpJxygvao4KANcCYAy7Oj8lEpgPHqDnibHLKHETTLT4j8CsprfazE3xMOsZw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常见的有三种熔断降级措施：慢调用比例策略、错误比例策略、错误计数策略。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;慢调用比例&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在所设定的时间窗口内，慢调用的比例大于所设置的阈值，则对接下来访问的请求进行自动熔断。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;错误比例&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在所设定的时间窗口内，调用的访问错误比例大于所设置的阈值，则对接下来访问的请求进行自动熔断。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;错误计数&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在所设定的时间窗口内，调用的访问错误次数大于所设置的阈值，则对接下来访问的请求进行自动熔断。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;实践案例&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道流量控制、熔断降级的基本概念和功能后，在现实环境中应该如何结合项目进行使用呢。最常见的场景是可针对业务服务的 HTTP 路由进行流量控制，以 HTTP 路由作为资源埋点，这样子就可以实现接口级的调控了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5177419354838709&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4jDrh1vIHLPh0nz30kZpJxyGAPAugvVBN1br9KuBc4gjD1TxXn35oWj2KF4HxUnKq6CJXUwU54ibWA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还可以增强其功能特性，针对参数也进行多重匹配。常会有这种限流诉求：针对 &lt;code&gt;HTTP GET /eddycjy/info&lt;/code&gt; 且 language 为 go 的情况下进行限流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外还可以针对 HTTP 调用封装统一方法，进行默认的熔断注入，实现多重保障。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而结合系统负载、服务 QPS 等，可以对限流熔断的规则数据源进行实时调控，再结合 Watch 机制，就能够比较平滑的实现自适应限流熔断的接入。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在分布式应用中，限流熔断是非常重要的一环，越早开始做越有益处。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但需要注意的是，不同公司的业务模型多多少少有些不一样，所针对的匹配维度多少有些不同，因此需要提前进行业务调研。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在做业务的限流熔断时，注意把度量指标的打点做上，这样子后续就能够结合 Prometheus+Grafana+Alertmanager 做一系列的趋势图，熔断告警，自动扩缩容等相关工作了，会是一个很好的助力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分享 Go 语言、微服务架构和奇怪的系统设计&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>51a9b1213178c05af9c68a121b551523</guid>
<title>恕我直言，微服务挺好，但不适合你</title>
<link>https://toutiao.io/k/2ltmzw0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天这篇文章我们继续说架构师大刘的故事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;故事纯属虚构，别对号入座哈。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大刘日子最近还不错，经常午睡醒来，就继续拿着手机看小说摸鱼。大刘对当前所在的这家公司比较满意。大部分系统已经成熟稳定，用户量也中规中矩。虽然有些项目技术陈旧，但好处是没啥幺蛾子技术问题冒出来等着解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只是有时候大刘心里会打鼓，公司盈利在下降，巅峰不在，也不知道这家公司能撑多久。除了偶然会冒出些对工作稳定的担忧以外，大部分时候，大刘心情都是愉快的。直到他被领导叫到办公室分派新任务的那一刻……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大刘的领导 CTO 老李，这些日子心情不是很好。他在的这家公司原本是个以传统业务为主的公司。为了跟上互联网时代，大老板拍脑袋成立了个技术部门搞互联网。虽说公司已经号称触网了，但是公司盈利基本还是靠传统业务，技术部门只是打辅助的。没有业务主动权，没有盈利点，部门员工的工资却都不低，老李的地位就可见一般了，经常受些冷言冷语的夹板气。再加上，最近公司的效益也有所下降，眼见技术部门面临着裁员的危险。老李危机意识被极大的刺激到了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老李是个技术出身，但是离开一线编码已经快十年了，每天的工作其实就是管理加玩概念。这几年微服务的概念非常火爆，老李一直想着能搞点这种热门东西，然后再拿着这些做出来的新概念技术，给那个不懂技术的大老板展示下自己的两把刷子，同时也能打响在业界的名声，对自己的职业发展也大有好处。趁着构思部门前途这时当，老李认为这也是搞微服务的好时机，同时也想到了有微服务经验的大刘。于是，大刘就被召唤进了办公室……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过了几个小时的讨论，大刘面带无奈的接下了这个任务。这个任务是这样的：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;把公司里几套运行多年的核心系统改造成微服务。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些个老系统当初是按照几万用户量的目标去设计开发的，虽然现在跑着没问题，但是眼光要看长远，产品和技术们将搞一套更高级的东西，目标是这套系统会被几百万人使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;OK，微服务使用的前提出现了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大刘来这家公司之前，在某电商大厂干了多年，对微服务在电商系统中的应用这块有实践、有经验。对微服务这块，大刘是吃过猪肉、也见过猪跑，还被猪咬过……嗯，对，还被咬过不止一口两口。所以，对改造微服务这个任务，大刘是硬着头皮接下来的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大刘虽然无奈，但是看在工资的份上活还得干。不过槽还是要吐的，于是下班后大刘用了几小时码出了下面这堆心里话。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正文开始（以下是大刘的第一人称）：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;— 0 —&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近，经常有同事和我聊微服务，也屡屡期望对公司已有项目进行改造，希望能把所有项目改造成微服务方式。我对此经常很无语，也屡屡对这些人进行劝阻。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我认为，劝我改造微服务的人之中，有一些人纯粹的对技术痴迷太深。更甚些，我甚至可以说这些人中的某些人就是纯粹的自私自利。搞微服务难道不是为了蹭热点，为自己的简历增色，为下一步跳槽涨薪做准备？何尝想过微服务为公司带来的各种坏处和因此而来的成本提升？另外有些人，则纯粹是被外面铺天盖地的微服务概念给打晕了头，被各种微服务成功故事洗了脑。这些人，把微服务当成了万能药，纯粹就是脑袋犯了糊涂，陷入了唯技术论。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了说明微服务不是万能药，这里我们就先要说明下微服务的概念。同时呢，我们也需要诠释清楚微服务的优缺点，看看什么时候用微服务，什么时候不用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么是微服务？对于微服务的定义，网上众说纷纭，并没有一个权威的定义。但是在这些纷繁复杂，云山雾罩的各种微服务洗脑文和说明文之后，总是有一个统一的基本面在：即微服务是一种利用分治法的思想，去把一整套非常复杂的业务逻辑给切分成多个简单的业务问题，并采用模块化方法去实现组合的一种架构方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么说是不是还很抽象呢？好，咱们再更深入的解释下，并顺便把微服务的优缺点也全部一并说清楚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;— 1 —&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，微服务是采用分治法思想，需要对业务逻辑做分解。做完分解后，还需要多个对应的实现模块去实现分解后的业务问题。这些模块的开发和维护，是都需要成本的。如果我们要搞微服务，考虑过开发维护成本吗？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4905982905982906&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KT24fhlWcmtKzEuuFW5AwoQqS357Eyu75ctSJhzMXF0cvlw3rPp1iaphIekghaAFGcDib9Wn29nH4rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;585&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这图表明了，从项目一开始，微服务的代码开发和维护每行平均成本就不少，随着项目规模和系统复杂度的上升，代码的开发和维护平均成本才会缓慢下降并逐渐收敛到某一个值左右恒定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而单体项目正好相反，一开始，单体项目的每行代码平均成本是比较低的，随着项目规模和系统复杂度的上升，代码开发和维护成本会慢慢上涨，后续可能复杂度和开发成本会越来越高，一直冲上天际。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候，就不得不迫使人们去找到一种比较合适的方法，能把开发和维护成本降低到项目团队可以承受的程度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是引入微服务的意义所在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，所有的项目会一直发展下去吗？所有的项目会永远运行并扩展吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有很多的架构师或者技术人员，在一开始做架构和系统设计的时候，不考虑实际情况，在公司给出一项很紧迫的任务之后，不去考虑实现时间和开发成本，上来就搞高大上，起手就是微服务，这现实吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们这些技术人员看过许多鼓吹微服务的技术书籍，也看到过很多微服务的“成功学”，但是他们的前提是什么？他们对微服务的说法统统是建立在一个只有技术存在的完美世界里，把现实世界他们认为的一切杂音都摒除在外，这合适吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在做架构师之前，第一个考虑的应该是投入和产出。固然，我们从技术角度考虑，一定会要考虑可扩展性，可维护性之类的技术指标。但是，我们也需要根据当前项目的重要程度，盈利前景，还有可用服务器资源等，作出自己的平衡来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;— 2 —&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二，微服务的另一个优势是弹性化。什么意思呢？就是我们在业务逻辑改变时，那些对应业务逻辑改变的功能的增删改，开发和部署成本很低，可以像弹簧一样，自由的缩减和增加。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且，微服务里最佳实践是每个分出的模块应该都有自己的数据库，和别的微服务并不共享任何数据库。所以微服务本身认为，每个微服务模块的数据库都可以不一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们开发一个电商网站，如果搞成微服务，大概如下:&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48390151515151514&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KT24fhlWcmtKzEuuFW5AwoQHichrLA4LiakxjQ0Jm1PLObxsy4aia5PEU2Rib1n3pOicYkib1ObPeCdvwiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1056&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们的业务逻辑做了一些调整，比如，我们想要增加一个积分功能，那么，我们只需要再增加一个叫做积分的微服务即可。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.40796555435952636&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/6nbNnibOq5KT24fhlWcmtKzEuuFW5AwoQx1sP47r7vAqNe1YQsOiaNiawPC0aoUpPjoLZCNznD8TAgMSL9eE6o8eg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;929&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就是微服务的便利之处。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，我们承认吧，并不是我们所做的每个系统都足够大，都大到需要分解成更多更小的服务。那些不是太复杂的系统，它们凭什么需要弹性化？凭什么需要切分业务，从而搞出一大堆的项目出来呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，微服务的弹性化带来的问题就是，我们需要管理因为弹性化所切分的许多小项目，需要搞出一套易用的自动化管理系统，需要把公司的底层基础设置打造好，请问，这些成本，你准备付出了吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个现实的世界里，并不是一切围绕着技术打转的。固然，技术欠债会让我们这些技术从业者感到分外的困扰和难受。可是，假如我们超前超度的使用了我们可能并不需要的超前概念和超前架构，同样会使我们感到痛苦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们控制住了自己的技术欲望，我们是不是从自身也控制了一部分技术欠债呢？这是一个架构师应该要思考的地方，也是我们不应该滥用微服务的原因之一。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;— 3 —&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第三，微服务起手就是分布式。分布式我承认有各种各样的优点，但是，分布式引发的各种问题和因此需要引入的各种技术解决方案本身也有自身的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，分布式事务。在引入微服务前，我们作为架构师，一定要思考后续是不是可能出现跨服务的事务。兄弟，分布式事务大家都知道有多困难的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按照微服务的标准，服务之间的通讯应该尽量采用简单的 RESTFUL 协议。那么，根据这种规范，如果我们采用了微服务方式架构，我们的每个项目都应该搞成 REST 服务。REST 服务本身就是无状态的，现在，如果业务里出现了严重依赖状态的跨服务事务，想想吧，你会面临什么：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分布式锁方案你是不是要考虑下？分布式互锁后，出现了死锁，你的追踪策略是什么？如果出现了竞争资源，导致服务状态不一致了，你怎么去快速恢复？数据腐蚀你有办法吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;什么？你告诉我我说市面上有很多成熟的分布式事务解决方案？别自欺欺人了，咱们都是搞技术的，请问，你说的是两阶段提交（2PC）吗？好吧，大家都知道 2PC 那可怜兮兮的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好吧，那三阶段提交（3PC）呢？它的不一致问题曾经让我们彻夜难眠。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;搞 TCC 或者 SAGA 呢？对不起，因为最终一致性所添加的业务紧耦合的各种消息和通知，会直接犹如 24 小时的梦魇，可能会是压垮你的最后一根稻草。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;微服务的提倡者老马丁自己也说，微服务引入了最终一致性问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于原来单体项目很简单的事务问题，在微服务中，是一个令人皱眉的困难问题。所有微服务的开发者，在开发微服务代码之前，都需要考虑怎么能探测到数据不一致的问题。否则，一定会万分后悔。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，分布式事务会不会一定会出现在微服务中呢？从目前来看，几乎无法避免。为了搞定这些问题，微服务实现往往还需要伴随着实现一整套构建在无状态服务之上的调用链。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于这些额外的开发成本，我们有必要吗？是所有项目都需要的吗？不是吧。这就是我们架构师需要考虑的问题，也是我们需要谨慎和妥协的地方。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;— 4 —&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第四，微服务互相之间是通过网络通信配合起来来对外提供服务的。这就会带来一个依赖性问题，即微服务非常依赖底层网络的健康。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果网络通信之间出了问题，整体对外的服务质量就会降低到极其让人难以接受的程度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并且，网络通信天然就一定会带来延迟。本来单体项目我们好好的，大家都是在内部互相通信，延迟基本可以忽略不计。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，大家分开了，互相得远距离打招呼，延迟动不动就来个几十毫秒几百毫秒延迟。这些延迟，我们也需要考虑在内，必须经过严格的测试才可以。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，网络通信出现问题后的各种容错方案，也必须考虑完善。以上说的这些，也都是一个合格的架构师必须在微服务引入之前，所要进行的综合的考量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;— 5 —&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他：微服务的引入还有各种各样的问题，包括:&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;额外引入的复杂性&lt;br/&gt;微服务在上面我也说过了，会带来各种各样的成本的提升，也会引入各种各样的技术问题。这些最终就会导致整体系统复杂性进一步的提高。当复杂性提高的时候，为了保证系统的稳定，就需要整体技术团队的靠谱，就需要技术人员的靠谱，就需要整体技术设施搭建的靠谱。在引入微服务之前，各位兄台麻烦扪心自问下，这些贵公司有吗？有这些团队、这些设施、这些资源吗？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;分布式本身带来的成本&lt;br/&gt;分布式本身就需要一整套完整的技术体系和设施去支撑整体分布式的建设。比如，以前单体项目只需要一个项目，直接人工上线就好了。现在呢，可能会出现几十个上百个项目，这些项目如果全靠人工去做，会彻底让团队人员疯掉。所以，就需要把整体发布，部署自动化起来。这里还仅仅是发布部署所需要的，还没有谈维护问题，用《征服》刘华强里的一句话说:”你有这个实力吗？”&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;维护和监控微服务所需要的 DevOps 团队&lt;br/&gt;微服务本身需要维护和监控，以确保运行的稳定和可靠。在微服务的最佳实践里，是非常推荐搞 DevOps 的。我暂且不说 DevOps 需要的对人员水平的高要求，我就说 DevOps 本身所需要的工作态度和责任心问题，自己家的运维团队搭建是个什么鸟样子，运维成天忙死了再干嘛，谁还不清楚吗？整体运维的平均水准加上开发水平的要求，这个团队搭建下来要花多少钱？公司舍得这些投入吗？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;微服务本身所需要的经验&lt;br/&gt;微服务本身是很复杂的，从设计划分模块开始，就需要架构师必须对架构设计和微服务本身对应的 DDD 领域驱动设计非常有经验，能够恰到好处的划分出对应的模块。否则，一旦设计完毕，不巧把一些紧耦合的服务给硬是解耦成了不同的服务，那么，这个后果对整个技术团队甚至对整个项目团队都是灾难性的。同时，对于微服务的开发、维护、运行、保障以及运维，都需要技术团队成员要有很丰富的从业经验能迅速发现，定位，解决可能随时出现的问题才可以。如果技术问题不能及时解决，那整体系统的体验就可想而知了。但是，现在的经济环境，现在的公司技术人员构成，确定能有这些很丰富经验的人员来搞微服务吗？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;链路测试的方法&lt;br/&gt;我们上面提到过，为了快速追踪定位死锁或者共享资源的问题，微服务需要靠谱的调用链实现。那么，这就引出的新的问题：我们如何搞全链路测试？我们是不是还得搞一套合适的全链路测试工具才可以？这全链路测试工具开发又需要花多长时间，需要投入多少人力？测试人员的水平是不是也需要得到一定的保证？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;微服务日志的爆炸&lt;br/&gt;微服务本身有多个节点，这些节点为了自己的安全运行和维护，需要很多自己独有的日志。这些日志随着微服务的增多，也越来越多，你如何存？如何查？如何删？这些是不是都要考虑在内？&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上说的这些问题并不是否认微服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我只是砸给那些劝我没事儿就搞微服务的人。对于这些什么都不考虑，上来就说微服务的人，我认为都是非蠢既坏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管不顾现状，没事儿把微服务挂嘴边动辄怎么怎么样的人，我劝你悠着点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;最后&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写完之后，大刘感觉长出了一口胸中的闷气，过完嘴瘾，心里也痛快了。现在大刘最担心的是，这些文字千万别被领导看到……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;最最后&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大刘的故事讲完了，我再啰嗦一下。微服务肯定是先进的，但是都已经 2020 年了，不用我再和大家介绍微服务的优点了，那也太俗了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;希望大家看完能明白，并不是什么新科技，热概念都适合自己的团队、自己的项目的。做一个合格的架构师、技术负责人，首先应该遵循的是 KISS 和 YAGNI 原则。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请各位技术人员永远保持理智，我们要做的是选择正确适用的技术而不是选择自己最喜爱的技术。请不要做那种把简单的事情往复杂里做的技术疯子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;END&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>