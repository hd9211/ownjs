<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>5af9470e475126f74ddaf66978914100</guid>
<title>懂了！国际算法体系对称算法 DES 原理</title>
<link>https://toutiao.io/k/hgpzrix</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;strong&gt;&lt;span&gt;概念&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;加密领域主要有国际算法和国密算法两种体系。&lt;span&gt;国密算法是国家密码局认定的国产密码算法。&lt;/span&gt;&lt;span&gt;国际算法是由美国安全局发布的算法。&lt;/span&gt;&lt;span&gt;由于国密算法安全性高等一系列原因。&lt;/span&gt;&lt;span&gt;国内的银行和支付机构都推荐使用国密算法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5541958041958042&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9ra6mqN4XtugtZnGMuN4ShsaIlnABcCibRQJz0wKj0NQfnap2KoF4ncpQjxK7qwnWQDoIMWLx40Ag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;572&quot;/&gt;&lt;/p&gt;&lt;p&gt;从上图可知，对称加密算法在算法体系里占了半壁江山。因为国际和国密算法的过程差异并不大。只是应用的数学公式和秘钥位数不同。DES在里面算是基础，所以今天主要介绍一下DES的原理。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;原理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;密码&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;咱们从加密的原理说起。举个最简单的加密：&lt;/p&gt;&lt;p&gt;我有一段明文：520&lt;/p&gt;&lt;p&gt;我的秘钥是：221&lt;/p&gt;&lt;p&gt;我的加密算法是：加法&lt;/p&gt;&lt;p&gt;加密后的密文就是：741&lt;/p&gt;&lt;p&gt;如果这个密文被截获了，接受者看到的信息是：741(气死你)，和原来明文520是完全不同的，不能知道信息原有的意思。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从这个简单的例子可知：加密是包含：明文、秘钥、加密算法和密文四个要素的。加密算法可公开可不公开，常见的算法有：位移、循环位移、异或、置换、数学函数。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;凯撒密码&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;加密技术从古罗马凯撒时候就在用：凯撒密码&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9269746646795827&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8cAoPktdo4nJQEicvibMicVicHYYCWibNKvKqRYUibHvhvRmOEz96p1fPvf9aia21RTSedE80kO6jnaV9BA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;671&quot;/&gt;&lt;/p&gt;&lt;p&gt;凯撒密码是古罗马时期凯撒大帝和他的将军们通信时使用的加密方式：&lt;/p&gt;&lt;p&gt;明文：由26个字母组成&lt;/p&gt;&lt;p&gt;秘钥：1到25之间的任意数字&lt;/p&gt;&lt;p&gt;加密算法：循环位移&lt;/p&gt;&lt;p&gt;密文：举例明文为eat 秘钥为2，对照上面图片的凯撒密码盘可以得到密文是gcv。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;咱们来动手写个凯撒密码(代码已经上传github:&lt;br/&gt;（https://github.com/xiexiaojing/yuna)：&lt;/p&gt;&lt;pre&gt;&lt;span&gt;@Test&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public void &lt;/span&gt;&lt;span&gt;caesarCipher&lt;/span&gt;() {&lt;br/&gt;    String text = &lt;span&gt;&quot;love was growing in eyes&quot;&lt;/span&gt;&lt;span&gt;;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;明文&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;int &lt;/span&gt;key = &lt;span&gt;3&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;秘钥&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;String cipher = encryptCaesarCipher(text&lt;span&gt;, &lt;/span&gt;key)&lt;span&gt;; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;密文&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(cipher)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;凯撒密码加密算法&lt;br/&gt;&lt;/span&gt;&lt;span&gt;private &lt;/span&gt;String &lt;span&gt;encryptCaesarCipher&lt;/span&gt;(String text&lt;span&gt;, int &lt;/span&gt;key) {&lt;br/&gt;    &lt;span&gt;char&lt;/span&gt;[] chars = text.toCharArray()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    for&lt;/span&gt;(&lt;span&gt;int &lt;/span&gt;i=&lt;span&gt;0&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i&amp;lt;chars.&lt;span&gt;length&lt;/span&gt;&lt;span&gt;; &lt;/span&gt;i++) {&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt;(chars[i] != &lt;span&gt;&#x27; &#x27;&lt;/span&gt;) {&lt;br/&gt;            chars[i] = (&lt;span&gt;char&lt;/span&gt;)(chars[i]+key)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果超过了&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;&lt;span&gt;个字母，则减去&lt;/span&gt;&lt;span&gt;26&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(chars[i]&amp;gt;&lt;span&gt;122&lt;/span&gt;) {&lt;br/&gt;            chars[i] = (&lt;span&gt;char&lt;/span&gt;)(chars[i]-&lt;span&gt;26&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;}&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return new &lt;/span&gt;String(chars)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;/pre&gt;&lt;p&gt;运行得到密文：oryh zdv jurzlqj lq hbhv&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;凯撒密码连小朋友都能破解。一旦被人知道用的凯撒密码，算法是已知的。要破解秘钥拿个明文和密文试试就知道了。就是平时说的暴力破解法可以很容易破解。对于这种全是英文字符的也可以使用频率分析法。频率分析法可以理解为基于大数据的方法，因为26个字母中，e的使用频率高。如果比如一篇文章，单词足够多的话，出现频率最高的字母xxx就是e。xxx的char值e的char值就是秘钥了。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7333333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8cAoPktdo4nJQEicvibMicVicHCm6Jjbc6S5wxetM5bSZAAoWkru6NliagRxQ7sghhouibLfP1WuqD7ib5Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;540&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;DES&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;概述&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;DES全称为Data Encryption Standard，即数据加密标准，是一种分组加密算法。&lt;span&gt;其分组长度为64bit，密钥长度为64bit，其中8bit为校验位，所以实际长度为56bit。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;先介绍一下校验位。举个例子，咱们的身份证号码都是18位。这18位包含：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.16144018583042974&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8cAoPktdo4nJQEicvibMicVicHqNj0ib42YhVQrGt5KaW6meQRicicsRj9RyIvpE7WcZQaYJO7GRAj3agXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;861&quot;/&gt;&lt;/p&gt;&lt;p&gt;其中最后一位就是校验位，原理是利用将前面部分利用某种算法计算得到一个数。如果校验位与算法得到的不一致，则数据是有问题的。所以身份证本身是有不通过查库就可以简单验证有效性功能的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;回到DES算法。DES算法的秘钥必须是64位，参与加密计算的是56位。这是原始秘钥。这个原始秘钥会用一个函数转换成16个64位秘钥。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;加密过程&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;DES的加密过程：&lt;/p&gt;&lt;p&gt;明文64位-&amp;gt;初始IP置换-&amp;gt;16轮加密变换-&amp;gt;逆初始IP置换-&amp;gt;密文&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;DES算法的这个过程又被称为Feistel网络。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.412&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRliccia32comB5k8icMWfCISBrQA0gO1KncFiciahA9dHNSiawicufLSCsfT61XcQiamfficSFWfnqtokicPiauwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;500&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;简单解释下：&lt;/p&gt;&lt;p&gt;明文我们自己想写多长写多长。但是加密的时候每次以64bit作为一个分组。最后将密文拼接起来。&lt;/p&gt;&lt;p&gt;然后执行一个IP置换(初始置换)操作。IP置换就是按位置换。举例来说64bit就是64个0和1。把第40个位置上的数换成第50个位置上的数就是置换了。&lt;/p&gt;&lt;p&gt;置换好的64个bit会分成两个32bit。然后用相同的加密算法每次传不同的转换后秘钥做16轮。&lt;/p&gt;&lt;p&gt;然后将两组32bit拼接起来再进行一次IP置换(终结置换)变成密文&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;分组组合&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;刚才介绍的加密过程是把明文的一块怎么加密成密文。DES密码块与密码块连接方式遵循对称加密的方式。&lt;/p&gt;&lt;p&gt;对称加密有两种方式，一种是分组加密，一种是序列加密。&lt;/p&gt;&lt;p&gt;分组加密，也叫块加密(block cyphers)，一次加密明文中的一个块。是将明文按一定的位长分组，明文组经过加密运算得到密文组，密文组经过解密运算（加密运算的逆运算），还原成明文组。&lt;/p&gt;&lt;p&gt;序列加密，也叫流加密(stream cyphers)，一次加密明文中的一个位。是指利用少量的密钥通过某种复杂的运算（密码算法）产生大量的伪随机位流，用于对明文位流的加密。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;分组加密算法中，&lt;span&gt;分组密码的设计基本遵循混淆原则和扩散原则。&lt;/span&gt;有ECB,CBC,CFB,OFB这4种算法模式。DES有ECB和CBC两种实现。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;ECB模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;ECB模式就是每组明文分别加密后拼接起来。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5087040618955513&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9ra6mqN4XtugtZnGMuN4ShiaBI8hoT3bQpUErNxkg3gwGV3iaf2KS58gHJmtzCYo4C9j6pOoemQCJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1034&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;CBC模式&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;CBC即密码分组链接（Cipher-block chaining）的简称。在CBC模式中，每个明文块先与前一个密文块进行异或后，再进行加密。在这种方法中，每个密文块都依赖于它前面的所有明文块。同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量。在DES中，初始化向量就是秘钥。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.41486359360301034&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9ra6mqN4XtugtZnGMuN4ShIsUB09GwMRFvKicToFeMKZLqDsPskLPt67wuA4IJBuBTNTF44iaSmTAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1063&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;程序实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们用程序来实现一下DES加密算法&lt;/p&gt;&lt;pre&gt;&lt;span&gt;@Test&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public void &lt;/span&gt;&lt;span&gt;desCiper&lt;/span&gt;() &lt;span&gt;throws &lt;/span&gt;Exception{&lt;br/&gt;    String key = &lt;span&gt;&quot;12345678&quot;&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;String text = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我知道我是任性很任性，伤透了你的心&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;明文&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;String cipher = encryptDesCipher(text&lt;span&gt;, &lt;/span&gt;key)&lt;span&gt;; &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;密文&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(cipher)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;text = decryptDesCipher(cipher&lt;span&gt;, &lt;/span&gt;key)&lt;span&gt;;  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;明文&lt;br/&gt;&lt;/span&gt;&lt;span&gt;         &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(text)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//DES&lt;/span&gt;&lt;span&gt;加密算法&lt;br/&gt;&lt;/span&gt;&lt;span&gt;private &lt;/span&gt;String &lt;span&gt;encryptDesCipher&lt;/span&gt;(String text&lt;span&gt;, &lt;/span&gt;String origKey) &lt;span&gt;throws &lt;/span&gt;Exception{&lt;br/&gt;    Key key = &lt;span&gt;new &lt;/span&gt;SecretKeySpec(origKey.getBytes()&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;DES&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;Cipher cipher = Cipher.&lt;span&gt;getInstance&lt;/span&gt;(&lt;span&gt;&quot;DES&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;cipher.init(Cipher.&lt;span&gt;ENCRYPT_MODE&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;key)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    return &lt;/span&gt;Base64.&lt;span&gt;encode&lt;/span&gt;(cipher.doFinal(text.getBytes()))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//DES&lt;/span&gt;&lt;span&gt;加密算法&lt;br/&gt;&lt;/span&gt;&lt;span&gt;private &lt;/span&gt;String &lt;span&gt;decryptDesCipher&lt;/span&gt;(String text&lt;span&gt;, &lt;/span&gt;String origKey) &lt;span&gt;throws &lt;/span&gt;Exception{&lt;br/&gt;    Key key = &lt;span&gt;new &lt;/span&gt;SecretKeySpec(origKey.getBytes()&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;DES&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;Cipher cipher = Cipher.&lt;span&gt;getInstance&lt;/span&gt;(&lt;span&gt;&quot;DES&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;cipher.init(Cipher.&lt;span&gt;DECRYPT_MODE&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;key)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    return new &lt;/span&gt;String(cipher.doFinal(Base64.&lt;span&gt;decode&lt;/span&gt;(text)))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;运行结果：&lt;/p&gt;&lt;p&gt;xo6mmVe8j1/d60cAAiFz1HAXxihi2FH5d0zMWILvEYISWR52lguy2TbMZQ4vuulCdO8WvxMRuXE=&lt;/p&gt;&lt;p&gt;我知道我是任性很任性，伤透了你的心&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;3DES&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;3DES即3重加密算法，是对每个数据块应用三次DES算法。这是为了应对计算机计算能力增强，DES变的容易破解而产生的。&lt;/p&gt;&lt;p&gt;主要方法就是DES秘钥64位，3DES秘钥64*3=192位，分成个三个秘钥，进行2轮DES加密，1轮DES解密。最终得到结果。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0022075055187638&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRliccia32comB5k8icMWfCISBrQQr8XXLvY6d0XHDQnou1dq2Tdiau3iciaaZBggxoaRz0dl19MJbA3Jx0kQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;453&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;AES&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;AES全称是高级加密标准(Advanced Encryption Standard)。是用来替代DES/3DES的。主要过程如下，这里不过多介绍。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.718944099378882&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9ra6mqN4XtugtZnGMuN4Shl7lk4ibjfMCYgGicJmc3bklod8y3uoSSD0D5ibPBzsW02b7L71MVWMBbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;644&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;应用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;我们来回顾下https的SSL握手过程：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7711267605633803&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl9ra6mqN4XtugtZnGMuN4ShBpw65zZspytxXRcKuEvYKG1stFXzQs46jCic8CMTVZiao4ZKItrByC4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;852&quot;/&gt;&lt;/p&gt;&lt;p&gt;SSL握手的最后，双方会用非对称秘钥协商出一个对称秘钥。用对称秘钥来加密传输的数据。之所以这样做是因为非对称加密安全性高但是效率低，对称秘钥正好相反。对称秘钥可以被暴力破解，破解需要时间。如果破解出来时就过期了，再通信就用另外的秘钥就能保证信息安全。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们来模拟一下已经协商好的秘钥之后http客户端与服务器端的通信。(代码已经上传github:（https://github.com/xiexiaojing/yuna)：&lt;/p&gt;&lt;pre&gt;&lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;/pre&gt;&lt;pre&gt;&lt;span&gt;public void &lt;/span&gt;&lt;span&gt;client&lt;/span&gt;() &lt;span&gt;throws &lt;/span&gt;Exception {&lt;br/&gt;    &lt;span&gt;int &lt;/span&gt;i = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    while &lt;/span&gt;(i &amp;lt;= &lt;span&gt;2&lt;/span&gt;) {&lt;br/&gt;        Socket socket = &lt;span&gt;new &lt;/span&gt;Socket(&lt;span&gt;&quot;127.0.0.1&quot;&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;520&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;向服务器端第一次发送字符串&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;OutputStream netOut = socket.getOutputStream()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;InputStream io = socket.getInputStream()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;String msg = i == &lt;span&gt;1 &lt;/span&gt;? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;客户端：我知道我是任性太任性，伤透了你的心。我是追梦的人，追一生的缘分。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;br/&gt;        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;客户端：我愿意嫁给你，你却不能答应我。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(msg)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;netOut.write(encryptDesCipher(msg.getBytes()&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;12345678&quot;&lt;/span&gt;))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;netOut.flush()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        byte&lt;/span&gt;[] bytes = &lt;span&gt;new byte&lt;/span&gt;[i==&lt;span&gt;1&lt;/span&gt;?&lt;span&gt;104&lt;/span&gt;:&lt;span&gt;64&lt;/span&gt;]&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;io.read(bytes)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;String response = &lt;span&gt;new &lt;/span&gt;String(decryptDesCipher(bytes&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;12345678&quot;&lt;/span&gt;))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(response)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;netOut.close()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;io.close()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;socket.close()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;i++&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;@Test&lt;br/&gt;&lt;/span&gt;&lt;span&gt;public void &lt;/span&gt;&lt;span&gt;server&lt;/span&gt;() &lt;span&gt;throws &lt;/span&gt;Exception {&lt;br/&gt;    ServerSocket serverSocket = &lt;span&gt;new &lt;/span&gt;ServerSocket(&lt;span&gt;520&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    int &lt;/span&gt;i = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    while &lt;/span&gt;(i &amp;lt;= &lt;span&gt;2&lt;/span&gt;) {&lt;br/&gt;        String msg = i == &lt;span&gt;1 &lt;/span&gt;? &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;服务端：我知道你是任性太任性，伤透了我的心。同是追梦的人，难舍难分。&lt;/span&gt;&lt;span&gt;&quot; &lt;/span&gt;:&lt;br/&gt;                &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;服务端：你愿意嫁给我，我却不能向你承诺。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;Socket socket = serverSocket.accept()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;InputStream io = socket.getInputStream()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        byte&lt;/span&gt;[] bytes = &lt;span&gt;new byte&lt;/span&gt;[i==&lt;span&gt;1&lt;/span&gt;?&lt;span&gt;112&lt;/span&gt;:&lt;span&gt;64&lt;/span&gt;]&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;io.read(bytes)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;new &lt;/span&gt;String(decryptDesCipher(bytes&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;12345678&quot;&lt;/span&gt;)))&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;OutputStream os = socket.getOutputStream()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;System.&lt;span&gt;out&lt;/span&gt;.println(msg)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        byte&lt;/span&gt;[] outBytes = encryptDesCipher(msg.getBytes()&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;12345678&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;os.write(outBytes)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;os.flush()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;os.close()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;io.close()&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;        &lt;/span&gt;i++&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;}&lt;br/&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/pre&gt;&lt;pre&gt;&lt;span&gt;//DES&lt;/span&gt;&lt;span&gt;加密算法&lt;br/&gt;&lt;/span&gt;&lt;span&gt;private byte&lt;/span&gt;[] &lt;span&gt;encryptDesCipher&lt;/span&gt;(&lt;span&gt;byte&lt;/span&gt;[] text&lt;span&gt;, &lt;/span&gt;String origKey) &lt;span&gt;throws &lt;/span&gt;Exception {&lt;br/&gt;    Key key = &lt;span&gt;new &lt;/span&gt;SecretKeySpec(origKey.getBytes()&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;DES&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;Cipher cipher = Cipher.&lt;span&gt;getInstance&lt;/span&gt;(&lt;span&gt;&quot;DES&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;cipher.init(Cipher.&lt;span&gt;ENCRYPT_MODE&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;key)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    return &lt;/span&gt;cipher.doFinal(text)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//DES&lt;/span&gt;&lt;span&gt;加密算法&lt;br/&gt;&lt;/span&gt;&lt;span&gt;private byte&lt;/span&gt;[] &lt;span&gt;decryptDesCipher&lt;/span&gt;(&lt;span&gt;byte&lt;/span&gt;[] text&lt;span&gt;, &lt;/span&gt;String origKey) &lt;span&gt;throws &lt;/span&gt;Exception {&lt;br/&gt;    Key key = &lt;span&gt;new &lt;/span&gt;SecretKeySpec(origKey.getBytes()&lt;span&gt;, &lt;/span&gt;&lt;span&gt;&quot;DES&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;Cipher cipher = Cipher.&lt;span&gt;getInstance&lt;/span&gt;(&lt;span&gt;&quot;DES&quot;&lt;/span&gt;)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    &lt;/span&gt;cipher.init(Cipher.&lt;span&gt;DECRYPT_MODE&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;key)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;    return &lt;/span&gt;cipher.doFinal(text)&lt;span&gt;;&lt;br/&gt;&lt;/span&gt;}&lt;br/&gt;&lt;/pre&gt;&lt;p&gt;运行结果&lt;/p&gt;&lt;p&gt;客户端：我知道我是任性太任性，伤透了你的心。我是追梦的人，追一生的缘分。&lt;/p&gt;&lt;p&gt;服务端：我知道你是任性太任性，伤透了我的心。同是追梦的人，难舍难分。&lt;/p&gt;&lt;p&gt;客户端：我愿意嫁给你，你却不能答应我。&lt;/p&gt;&lt;p&gt;服务端：你愿意嫁给我，我却不能向你承诺。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这个程序实现了简单的客户端和服务器端的DES加密方式通信。稍加改造可以实现一个信息加密的聊天小程序。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;本文使用概念、原理、应用的传统型逻辑架构来对DES做系统梳理。里面涉及到的一些基本知识限于篇幅省略了一些。&lt;/p&gt;&lt;p&gt;比如Base64编码。它是加密时常用的编码方式，我们平时所看到的密钥都是base64后的结果。可以简单理解为对2的6次方进行64进制运算，可防止乱码丢失字节。&lt;/p&gt;&lt;p&gt;再比如填充字节这部分也没有介绍，有兴趣可以自己查阅下。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;加解密很多人工作中或多或少都有涉及。我个人认为只要涉及的地方至少要了解到原理和架构层面，才能避免遇到问题时【拿着锤子找钉子】找不到真正问题的窘境。而只有动手实践才能避免当时了解了，过后又忘了需要再看一遍而产生重复工作的问题。&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>61681e417fb3e17bb41eea27acc2ea9e</guid>
<title>揭秘 Apache Pulsar 如何挑战 Kafka</title>
<link>https://toutiao.io/k/ao9ceoz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;开源流数据公司 &lt;/span&gt;&lt;span&gt;StreamNative&lt;/span&gt;&lt;span&gt; 近期&lt;/span&gt;&lt;span&gt;宣布完成数百万美元 Pre-A 轮融资&lt;/span&gt;&lt;span&gt;，日前&lt;/span&gt;&lt;span&gt;正式加入 CNCF&lt;/span&gt;&lt;span&gt;。其创始团队成员是 Apache Pulsar、Apache BookKeeper 项目的原生核心开发者，StreamNative 也被称为开源消息系统基础设施 Pulsar 背后的公司。（本文中 Pulsar、BookKeeper 分别指代&lt;/span&gt;&lt;span&gt; Apache Pulsar&lt;/span&gt;&lt;span&gt;、&lt;/span&gt;&lt;span&gt;Apache BookKeeper&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;StreamNative 是一家基于 Pulsar 的商业公司，提供云原生的实时消息和流数据处理技术。Pulsar 是 Yahoo 内部在 2012 年为构建统一消息平台而构建的，采用分层分片的系统架构。上层 Pulsar Broker 提供无状态的服务层；底层 BookKeeper 提供高性能、低延迟和强一致性的 IO 服务。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在今年 6 月的 Pulsar Summit 中，Splunk 和 Yahoo 做了测试和分析：Pulsar 帮助 Splunk 将成本降低了 1.5 - 2 倍，延迟降低了 5 - 50 倍，运营成本降低 2 - 3 倍；&lt;span&gt;在 Yahoo 的部署中，Pulsar 支持同等规模的业务量，还在保证更高数据服务质量的情况下，消耗只有 Apache Kafka 的一半的实际硬件资源成本。&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过，在目前开源的分布式消息系统中，Kafka 依旧有很高的知名度和使用率，也同样是 Apache 基金会的顶级项目。Pulsar 在技术和生态上有什么地方上优于 Kafka？未来是否有更大的发展空间？Pulsar 和 StreamNative 是如何共生的？StreamNative 因何获得投资，这对其他开源项目公司有什么启发？对此，我们采访了 StreamNative 联合创始人兼 CTO 翟佳。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;翟佳，StreamNative 联合创始人兼 CTO。在创办 StreamNative 之前，在 EMC 从事分布式、文件系统、流存储相关的设计和开发，目前是 Apache BookKeeper 和 Apache Pulsar 两个项目的 PMC 成员。&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;开源消息系统基础设施 Pulsar&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;Pulsar 诞生于 2012 年，最初的目的是为在 Yahoo 内部，取代其他消息系统，构建统一逻辑大集群的消息平台。当时的其他消息系统（包括 Kafka），都不能满足 Yahoo 的需求，比如大集群多租户、稳定可靠的 IO 服务质量、百万级 Topic、跨地域复制等，因此 Pulsar 应运而生。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“当时在 Yahoo 内部叫 CMS（Cloud Message Service），从名字可以看出 Pulsar 诞生时就坚定了云的方向”，翟佳介绍，2015 年，Pulsar 完成了在 Yahoo 内部的部署和替换，大规模部署在 Yahoo 内部， 服务于 Yahoo mail、 Yahoo Finance、 Yahoo Sports/ Flickr 及广告平台等大规模的场景。2017 年 6 月 Pulsar 被捐赠给 Apache 基金会，2018 年 9 月毕业成为 ASF 顶级项目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在，Pulsar 被  StreamNative 看做是一个兼属“流数据+云原生”领域的项目。那么 Pulsar 作为一个以“云”为方向的消息基础设施，其“流数据”和“云原生”特性都是如何实现的呢？这里翟佳介绍了一些 Pulsar 的技术特性：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Pulsar 作为消息的基础设施，必然会和存储、和计算层有深入的交互。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在存储方面，Pulsar 利用 Apache BookKeeper 的优势，积极扩展和挖掘 Pulsar 架构的优势。基于 Pulsar 对 Topic 的分片存储，我们可以很自然地将老的分片从 BookKeeper 迁移到的二级存储中。通过层级存储，可以支持无限量的流数据。此外我们正在二级存储中支持列存模式的支持，这样可以更高效的支撑批处理的请求，真正实现批流融合的存储需求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6574074074074074&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRK9SQEH3MBDRrIEWYWOeq271Wz9N4f1X7azlibheN8SKYYxMjeLNYHHHaF6RetaYyp1aQAKMlbpyzEw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于计算层，Pulsar 的思路是更多地拥抱其他开源项目。我们在 Pulsar 中提供了结构化（Schema）的支持，保证 Pulsar 中的数据可以按照数据结构被其他系统理解。比如 StreamNative 开源的 pulsar-spark、&lt;/span&gt;&lt;span&gt;pulsar-flink 连接器&lt;/span&gt;&lt;span&gt;等，都是为了更好的和其他大数据引擎整合的例子。Pulsar SQL 也是直接整合 Presto 来支持 Pulsar 中的数据查询。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;函数式轻量化计算（Pulsar Functions），是 Pulsar 结合 Serverless 的理念在消息领域的一个创新。函数的编写很简单，运行时，每个消息触发一次函数的计算。这种轻量级的计算，为用户提供了 Spark、Flink 之外一个很好的补充，可以方便用户处理很多常见的简单计算场景，比如数据的清洗、路由、Enhancement 等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Pulsar 借助在存储层的优势，通过和更多的大数据生态整合，为用户提供一整套基于事件流的数据处理平台。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;在消息领域&lt;/span&gt;，&lt;span&gt;Pulsar 是第一个将存储计算分离云原生架构落地的开源项目。&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;除了存储计算的分层架构，Pulsar 系统中的节点对等、大集群管理带来的资源池化、高可用特性带来的系统弹性等和云原生的理念十分契合。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;流数据按照有没有明确的起止位置，可以分为有界流和无界流。流入消息平台中每个 Topic 的数据，很自然地可以作为事件流的一种数据表现。Pulsar 的 Pub/Sub 接口，可以让计算平台更方便地把 Topic 当作流数据来处理。同时 Pulsar 底层的存储层 BookKeeper，又将一个 Topic 分为了多个有界的分片，和 HDFS 中的数据块对应，直接访问 BookKeeper 中的分片，更加方便批数据的处理引擎。结合 Pulsar，可以更便捷地完成在数据处理中的批流统一。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.44565217391304346&quot; data-type=&quot;png&quot; data-w=&quot;828&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dkwuWwLoRK9SQEH3MBDRrIEWYWOeq271ia13x1ibqKuV6Qdy06eh1ZcjOnws35dL4VbWiaXERHIiaY3wtQfF2mWXPw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在批流统一的实践中，Flink/Spark 等计算引擎都有了很好的抽象，但是在数据的存储层没有太多的工作，StreamNative 认为 Pulsar 的架构很匹配批流融合的存储需求，这是 Pulsar 在数据处理领域的一个优势。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;StreamNative 正在 Pulsar 的二级存储中支持列存格式，让访问 Pulsar 的批处理引擎更加高效。&lt;/span&gt;这样 Pulsar 提供了统一的数据存储层，用户只用关心上层的数据处理，而不用关心底层的数据存储细节。&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Pulsar 使用 BookKeeper 作为存储中心&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;Pulsar 使用 BookKeeper 作为存储中心。BookKeeper 提供的 API 抽象度很高，简单来说就是一个提供无限个 Write-Ahead-Log（WAL）的分布式存储系统。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从 BookKeeper 毕业成为 Apache 顶级项目，已经有 5 年多的时间，期间一直有 Yahoo、Twitter、Salesforce、EMC 等公司的深度使用和积极贡献，BookKeeper 相对来说已经比较稳定和成熟。StreamNative 主要通过 Pulsar 的社区增长来带动 BookKeeper 的社区增长。 &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据 Pulsar 的功能需求，相应地增加 BookKeeper 的功能。StreamNative 组织的线上线下活动中，也常邀请 BookKeeper 的相关用户参与分享和交流。从 GitHub 上 BookKeeper 项目 Star 数的增长趋势，也可以很明显的看到两个社区的相互带动。&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Pulsar 和 Kafka 对比&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;开发者最关心的问题可能还是 Pulsar 好用在哪？翟佳从三个方面对比 Pulsar 与 Kafka，以说明 Pulsar 的特点和优势：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第一，从应用场景来说，Pulsar 对用户来说提供了统一的消息模型，一方面可以满足各种 MQ，例如 RabbitMQ、ActiveMQ 等线上交易系统的需求；一方面可以满足和 Kafka 类似的高吞吐的需求的场景。这决定了 Pulsar 在生态上，有比 Kafka 更多的使用场景和需求。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第二，架构上，Pulsar 有存储计算分离的云原生架构的优势。由于在 Broker 层不存储任何数据，这种架构为用户带来了更高的可用性、更灵活的扩容和管理、避免数据的 reblance 和 catch-up。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;BookKeeper 作为 Pulsar 的存储层，它诞生时就是为元数据的一致性服务的，可以在保证高带宽、低延迟的情况下，为用户提供更好的一致性保障；相比 Kafka 依赖文件系统来保证一致性，BookKeeper 有原生的一致性协议，数据实时刷盘，读写硬件隔离，这些都为 Pulsar 带来了更高可靠性和数据服务质量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;第三，在社区上，Kafka 作为当时流数据的唯一选择有一定的先发优势。Pulsar 凭借架构和功能方面的优势，在过去两年的关注度和使用量不断快速增加，国内外的 Pulsar 用户和贡献者数量也在快速增加。在前两周，全球项目贡献者人数已突破 300 位。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前公司对消息平台的需求升级集中在降低成本、便捷操作两个方面。Pulsar 以下的特性正是符合消息平台发展的趋势：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;云原生，降低系统的人工运维和管理的成本；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;大集群，统一管控系统资源；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;统一平台，便捷数据的共享和管理。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;翟佳总结，Pulsar 的优势在于其&lt;span&gt;独特设计和分层分片的系统架构&lt;/span&gt;。借助 Pulsar 的架构和功能，用户可以部署统一的集群，通过池化的资源和多租户，来满足整个组织内部的各种消息场景的需求，减少小集群、多集群的复杂管理，提高资源利用率，方便集群内部数据的共享。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Pulsar 借助 BookKeeper 也为用户提供了更好的数据服务质量， 在保证高带宽、低延迟的同时，提供了更高的一致性和持久化。从运维和资源弹性角度看，Pulsar 集群的扩缩容更加迅速便捷；节点的替换和更新不会影响业务的可靠性和可用性。从线上部署成本来说，对比 Kafka，Pulsar 也有相当大的优势。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;基于 Pulsar 的 StreamNative&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在了解了 Pulsar 的基础之上，才能更好理解 StreamNative。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;StreamNative 在开发与运维 Pulsar 的同时，主要提供基于 Pulsar 的云端托管与运维、技术支持服务。需要注意的是，Pulsar 是 Apache 基金会下的顶级开源项目，其所有权属于中立的基金会，这也是 StreamNative 可以为 Pulsar 做社区运营的信任基础。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;StreamNative 成立于 2019 年，公司开发人员都是 Apache Pulsar 早期的一批贡献者，很多成员也是 Apache Pulsar 的 PMC 成员或 Committer，其联合创始人兼 CEO 郭斯杰 是 Apache Pulsar 原型设计和主要开发者。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;翟佳介绍，StreamNative 聚焦的两个主要方向是 Pulsar 社区和云，这也是投资人极为看好的方向。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;产品方面，&lt;span&gt;StreamNative 的产品是 StreamNative Cloud，为企业在云上提供全托管式的 “Apache Pulsar 即服务”，翟佳介绍，“&lt;/span&gt;熟悉 Pulsar 的工程师会对 Pulsar 的存储计算分离和分层分片的弹性系统架构，印象比较深刻，这也是StreamNative 常说 Pulsar 拥有云原生架构的一个原因。”StreamNative 的服务适合对 Pulsar 集群运行质量、管控和维护有更高需求的客户。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;StreamNative 团队目前的主要工作内容还包括完善 Pulsar 社区。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对 Pulsar 社区的构建主要是集中在产品及与用户的互动，贡献和改进 Pulsar 的功能、丰富 Pulsar 的周边生态、帮助 Pulsar 的版本发布和维护、沟通社区用户并帮忙解决上线 Pulsar 中遇到的障碍、组织参加相关 Pulsar 的 meetup 等推广宣传活动等。这些工作主要是完善 Pulsar 的文档、降低 Pulsar 的入门门槛，丰富 Pulsar 和其他系统的集成和交互，做好用户起步的基础工作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;“长期来看，更重要的是丰富社区的用户场景、吸引更多的用户参与社区，构建一个活跃的、可以长期持续发展的社区”&lt;/span&gt;，翟佳透露，除了 Pulsar 自身的优势，社区和客户的认可也是促成 Pre-A 轮融资成功的原因之一。目前 Pulsar 已经在一线的互联网场景中得到了广泛的应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外，StreamNative 也在完善 StreamNative 基于 K8S 的云平台。目前已经在 Google Cloud 上发布了云平台预览版 StreamNative Cloud，预计在年底发布国内的预览版。&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;开源项目与商业公司&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;在这次访谈中，翟佳大部分时间都在介绍 Pulsar。他认为，&lt;span&gt;开源项目与商业公司是相互成就的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;成功的开源项目背后，都有一家商业化公司来为社区和用户持续提供核心支持：社区用户被开源产品的架构和功能所吸引，参与社区；公司在服务社区的过程中，不断获得反馈和创新，完善开源产品在各种生产环境的综合表现；公司再利用成熟的项目和积淀来服务有需要的社区客户——这样形成一个良性循环。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由 Pulsar 核心团队带领的 StreamNative 公司和 Pulsar 社区也是这样一种关系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;谈到&lt;span&gt;创业商机&lt;/span&gt;，作为技术人的翟佳表示自己一直抱着“技术改变世界”的梦想，“StreamNative 创始团队成员亲身见证经历了 3000+ Pulsar 存储集群规模的搭建和运维，见证和经历了 Pulsar 和 BookKeeper 在 Yahoo、Twitter 线上的长期磨砺和迭代，明确感受到 Pulsar 在架构和功能方面的优势，以及与云原生方向的匹配和一致性。同时，我们看到开发者对 Pulsar 的架构和产品的认可，也感受到用户在使用时遇到的痛点。”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此外近两年开源商业化的模式不断成熟，在 Spark、ES、MongoDB、TiDB 等开源项目背后，都有商业公司在崛起，StreamNative 认为 Pulsar 和 StreamNative 有同样的机会。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不过，StreamNative 花费了如此多的时间与精力在 Pulsar 与其社区生态上，是否会造成 Pulsar 与商业公司绑定，削弱项目的开源协作属性呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对此翟佳认为，&lt;span&gt;这种绑定，是对开源协作的促进，而非削弱。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Pulsar 的核心是全部开源的，StreamNative 公司和社区用户用的是同样的一份代码。StreamNative 投入社区会带来社区的信任和发展；社区的反馈会带来 Pulsar 的成熟和创新迭代；最终会有更多的用户相信 Pulsar 和 StreamNative。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;其次，金融、证券、零售、IoT 等领域都有客户在拥抱和使用 Pulsar。StreamNative 在支持这些客户的同时，Pulsar 也通过不同的场景变得更加成熟。通过对客户的服务，StreamNative 可以了解相关垂直领域的需求，进而不断接触和满足更多相同领域的客户。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Pulsar 和 Kafka 很类似，都是 Apache 软件基金会的项目，Linkedin 在捐赠 Kafka 之后，成为了 Kafka 的用户，Yahoo 现在也是 Pulsar 的用户。 在 Linkedin 和 Yahoo 的角度，维护开源项目（Kafka/Pulsar）在原公司的使用，满足原公司线上的业务需求是最重要的，除此之外开源能让项目更加成熟和健壮，对原公司有不少好处。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;综上， Pulsar 项目本身往云原生方向发展，看好此方向的 StreamNative 投入绝对的精力和时间在 Pulsar 上，一方面帮助拓展 Pulsar 的生态，反刍自身的商业资源，另一方面握住 Pulsar 和 BookKeeper 的技术优势，以区别其他的 Pulsar 服务商。这些或许就是投资人现在看好 StreamNative 的原因，未来也可能会是更多开发者和用户选择 StreamNative 的理由。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzM0MjcyMQ==&amp;amp;mid=2650095312&amp;amp;idx=1&amp;amp;sn=6dc4571475e963b86625070ef1b25828&amp;amp;chksm=bedae5be89ad6ca8d1403569c04c542ae8c0c6895e7738f12f89d598d6e06842b64a7bf04915&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;尤雨溪：全职做开源年薪百万，非科班程序员也能成功&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzM0MjcyMQ==&amp;amp;mid=2650095283&amp;amp;idx=1&amp;amp;sn=a42eb68ddfb55c262a5a7ebe0e6681c4&amp;amp;chksm=bedae5dd89ad6ccb38acd98d3d9f3d3cee5c314b4f27164cfcd29c33f18f782c7589b8bdbf33&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Vue 3发布&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzM0MjcyMQ==&amp;amp;mid=2650095280&amp;amp;idx=1&amp;amp;sn=c9db17ec6e2297c045b81921661036db&amp;amp;chksm=bedae5de89ad6cc8a46f71a267e5223d02dbdbe33f1f499af32c0ae5f6c936b11ef4c1eec562&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;TypeScript之父：JS不是竞争对手&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzM0MjcyMQ==&amp;amp;mid=2650095283&amp;amp;idx=2&amp;amp;sn=702e7bb79973d66d37b91e516ec52366&amp;amp;chksm=bedae5dd89ad6ccbd730f57884afb5f9ce17ffc59bf0371698ed9babe653dd450a85d19142bc&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;领导层缺失，Ubuntu创始人反思&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5NzM0MjcyMQ==&amp;amp;mid=2650095291&amp;amp;idx=1&amp;amp;sn=7f8ecba66a02f1996345eff941001bd8&amp;amp;chksm=bedae5d589ad6cc3b134691af153e2ba7c331e9629507f814d9a08ca966055727e2be50b2a94&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;几天后，GitHub的“master”将更改为“main”&lt;/a&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>830e5428aa221b4cdac745d4b02244d3</guid>
<title>23 张图，带你入门推荐系统</title>
<link>https://toutiao.io/k/ivzzn8a</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;300&quot; data-backw=&quot;540&quot; data-ratio=&quot;0.5555555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/gicSKPDibrreqCenMeiboc7xEhABibW4JO6F4ZTFB0BVibr6gNXG1NesJLUDia4ysYL7ic3Xy5YbZOzKUgA9wIGMaMicXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;540&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;做广告业务1年多时间了，但是平时的工作主要和&lt;/span&gt;&lt;span&gt;广告工程&lt;/span&gt;&lt;span&gt;有关，核心的广告算法由 AI 部门支持，对我们而言可以说是「黑盒般」的存在，只需要对训练好的模型进行调用即可。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;近期，我打算系统性地学习下广告中的搜索和推荐算法，当然更多是从工程的视角去弄清楚：算法的基本原理、以及面对线上海量数据时算法是如何解决性能问题的？整个过程，我会将有价值的技术点输出成系列文章。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;这篇文章属于推荐系统的入门篇，本文暂不考虑线上环境的海量数据，目的是&lt;span&gt;先&lt;/span&gt;了解清楚推荐系统的基本构成，我会通过图解推荐算法以及程序demo的形式展开，内容包括：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;426&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.7374658158614403&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AaabKZjib2kY0PLtjXquTGjdx8aEibK1eYdGamlqlLH9mdweROicxU2y1EtVHY74VkzKBteXnlSAylbsMO1w3X7xQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1097&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;01 走进推荐系统的世界&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;“啤酒与尿布” 的故事相信很多人都听过，年轻爸爸去超市购买尿布时，经常会买点啤酒犒劳自己。因此，沃尔玛将这两种商品进行了捆绑销售，最终获得了更好的销量。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4950980246067047&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AaabKZjib2ka0NNY82HVVsuaiaQTjNFzGo5YmVQVicdjicJibsdeZjI2t6zErbBNDs3eyRGe1ibnRAdQbktyiamXOIxWg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;408&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;“啤酒与尿布”的故事&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;这个故事背后的理论依据就是 “推荐算法”，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;因为尿布和啤酒经常出现在同一个购物车中，那么向购买尿布的年轻爸爸推荐啤酒确实有一定道理。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 推荐系统到底解决的是什么问题？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;推荐系统从20世纪90年代就被提出来了，但是真正进入大众视野以及在各大互联网公司中流行起来，还是最近几年的事情。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随着移动互联网的发展，越来越多的信息开始在互联网上传播，&lt;/span&gt;&lt;span&gt;产生了严重的信息过载。因此，&lt;/span&gt;&lt;span&gt;如何从众多信息中找到用户感兴趣的信息，这个便是推荐系统的价值。&lt;/span&gt;&lt;span&gt;精准推荐解决了用户痛点，提升了用户体验&lt;/span&gt;&lt;span&gt;，最终便能留住用户。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐系统&lt;/span&gt;&lt;span&gt;本质上就是一个信息过滤系统，通常分为：召回、排序、重排序这3个环节，每个环节逐层过滤，最终从海量的物料库中筛选出几十个用户可能感兴趣的物品推荐给用户。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;184&quot; data-backw=&quot;579&quot; data-ratio=&quot;0.3188888888888889&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AaabKZjib2kY0PLtjXquTGjdx8aEibK1eYvs5QRIQ5eWUEccMPIf764IV2XhjnR9uSlvnav1PKDlZowDZbUiaqX7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐系统的分阶段过滤流程&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;2. 推荐系统的应用场景&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;p&gt;&lt;span&gt;哪里有海量信息，哪里就有推荐系统，我们每天最常用的APP都涉及到推荐功能：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;资讯类：今日头条、腾讯新闻等&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;电商类：淘宝、京东、拼多多、亚马逊等&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;娱乐类：抖音、快手、爱奇艺等&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;生活服务类：美团、大众点评、携程等&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;社交类：微信、陌陌、脉脉等&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;362&quot; data-backw=&quot;570&quot; data-ratio=&quot;0.6350257542310522&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AaabKZjib2kY0PLtjXquTGjdx8aEibK1eYypbUE3C3XzoX2X0jcANicNm8yUJmaA5mdDA1YCsx6iaEkQYfxibNsdJ0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1359&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;头条、京东、网易云音乐中的&lt;/span&gt;&lt;span&gt;推荐功能&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;推荐系统的应用场景通常分为以下两类：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;3. 搜索、推荐、广告三者的异同&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;p&gt;&lt;span&gt;搜索和推荐是AI算法最常见的两个应用场景，在技术上有相通的地方。这里提到广告，主要考虑很多没做过广告业务的同学不清楚为什么广告和搜索、推荐会有关系，所以做下解释。&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;02 推荐系统的整体架构&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;499&quot; data-backw=&quot;578&quot; data-ratio=&quot;0.8629441624365483&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AaabKZjib2kY0PLtjXquTGjdx8aEibK1eYCN2ibNSffF2mxY9ly2KqicuLHvZ4CgkD9vyxaXZEwgIm1HUGPa2Yl6Nw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;788&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐系统的整体架构&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;上面是推荐系统的整体架构图，自下而上分成了多层，各层的主要作用如下：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;数据源：&lt;/strong&gt;&lt;/span&gt;推荐算法所依赖的各种数据源，包括物品数据、用户数据、行为日志、其他可利用的业务数据、甚至公司外部的数据。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;计算平台：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;负责对底层的各种异构数据进行清洗、加工，离线计算和实时计算。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;数据存储层：&lt;/strong&gt;&lt;span&gt;存储&lt;/span&gt;&lt;span&gt;计算平台处理后的数据，根据需要可落地到不同的存储系统中，比如Redis中可以存储用户特征和用户画像数据，ES中可以用来索引物品数据，Faiss中可以存储用户或者物品的embedding向量等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;召回层：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;包括各种推荐策略或者算法，比如经典的协同过滤，基于内容的召回，基于向量的召回，用于托底的热门推荐等。为了应对线上高并发的流量，召回结果通常会预计算好，建立好倒排索引后存入缓存中。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;融合过滤层：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;触发多路召回，由于召回层的每个召回源都会返回一个候选集，因此这一层需要进行融合和过滤。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;排序层：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;利用机器学习或者深度学习模型，以及更丰富的特征进行重排序，筛选出更小、更精准的推荐集合返回给上层业务。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;span&gt;从数据存储层到召回层、再到融合过滤层和排序层，&lt;span&gt;候选集逐层减少，但是精准性要求越来越高，因此也带来了&lt;/span&gt;计算复杂度的逐层增加，这个便是推荐系统的最大挑战。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;其实对于推荐引擎来说，最核心的部分主要是两块：特征和算法。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6674786845310596&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AaabKZjib2kY0PLtjXquTGjdx8aEibK1eYr7BBPyTsick5FRMPqwDQY4Q87No2wKctngqd42Zoqe96XxeBc7JQ3XA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;821&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;推荐引擎的核心功能和技术方案&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;特征计算由于数据量大，通常采用大数据的离线和实时处理技术，像Spark、Flink等，然后将计算结果保存在Redis或者其他存储系统中（比如HBase、MongoDB或者ES），供召回和排序模块使用。&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;召回算法的作用是：从海量数据中快速获取一批候选数据，要求是快和尽可能的准。这一层通常有丰富的策略和算法，用来确保多样性，为了更好的推荐效果，某些算法也会做成近实时的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;排序算法的作用是：对多路召回的候选集进行精细化排序。它会利用物品、用户以及它们之间的交叉特征，然后通过复杂的机器学习或者深度学习模型进行打分排序，这一层的特点是计算复杂但是结果更精准。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;03 图解经典的协同过滤算法&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;了解了推荐系统的整体架构和技术方案后，下面带大家深入一下算法细节。这里选择图解的是推荐系统中的明星算法：协同过滤（Collaborative Filtering，CF）。&lt;/span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;对于工程同学来说，可能觉得 AI 算法晦涩难懂，门槛太高，确实很多深度学习算法的确是这样，但是协同过滤却是一个简单同时效果很好的算法，只要你有初中数学的基础就能看懂。&lt;/span&gt;&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 协同过滤是什么？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;协同过滤算法的核心就是&lt;span&gt;「&lt;/span&gt;找相似&lt;span&gt;」&lt;/span&gt;，它基于用户的历史行为（浏览、收藏、评论等），去发现用户对物品的喜好，并对喜好进行度量和打分，最终筛选出推荐集合。它又包括两个分支：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;基于用户的协同过滤：&lt;/strong&gt;&lt;span&gt;User-CF，核心是找相似的人。&lt;span&gt;比如下图中，&lt;/span&gt;用户 A 和用户 C 都购买过物品 a 和物品 b，那么可以认为 A 和 C 是相似的，因为他们共同喜欢的物品多。这样，就可以将用户 A 购买过的物品 d 推荐给用户 C&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;290&quot; data-backw=&quot;573&quot; data-ratio=&quot;0.5052264808362369&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AaabKZjib2kbpJZgkCoibicdHCpTlW7I1XWTmibBc6icSUVxSDa7UkdVj2ezxiaIY8voCWAiaBp0sibPBhGs1S77yvF7Ag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;574&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;基于用户的协同过滤&lt;/span&gt;&lt;span&gt;示例&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;333&quot; data-backw=&quot;573&quot; data-ratio=&quot;0.5801393728222997&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AaabKZjib2kbpJZgkCoibicdHCpTlW7I1XWLnLsxEgvt2FGoAHsycIJ8XsF0IyibBiaRTJt9lfzcEYibB0zvOJxIj7WQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;574&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基于物品的协同过滤&lt;/span&gt;&lt;span&gt;示例&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;2. 如何找相似？&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;p&gt;&lt;span&gt;前面讲到，协同过滤的核心就是找相似，User-CF是找用户之间的相似，Item-CF是找物品之间的相似，那到底如何衡量两个用户或者物品之间的相似性呢？&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们都知道，对于坐标中的两个点，如果它们之间的夹角越小，这两个点越相似，这就是初中学过的余弦距离，它的计算公式如下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;112&quot; data-backw=&quot;570&quot; data-ratio=&quot;0.19747235387045814&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AaabKZjib2kbpJZgkCoibicdHCpTlW7I1XWUSKy4lpWlabhFxgINbQaO3Z2hODpRtOcjt5Su7g3pJZ2EEvKmn56DQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;633&quot;/&gt;&lt;/p&gt;&lt;p&gt;举个例子，A坐标是（0，3，1），B坐标是（4，3，0），那么这两个点的余弦距离是0.569，余弦距离越接近1，表示它们越相似。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;273&quot; data-backw=&quot;570&quot; data-ratio=&quot;0.4784172661870504&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AaabKZjib2ka0NNY82HVVsuaiaQTjNFzGowEyKebNjCDFnXicsBKCQejiaPEBWl615HXUPniajI5ftlwhSmos8g2jcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;834&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;除了余弦距离，衡量相似性的方法还有很多种，比如：欧式距离、皮尔逊相关系数、Jaccard 相似系数等等，这里不做展开，只是计算公式上的差异而已。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;3. Item-CF的算法流程&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;p&gt;&lt;span&gt;清楚了相似性的定义后，下面以Item-CF为例，详细说下这个算法到底是如何选出推荐物品的？&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;第一步：整理物品的共现矩阵&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;假设有 A、B、C、D、E 5个用户，其中用户 A 喜欢物品 a、b、c，用户 B 喜欢物品 a、b等等。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;309&quot; data-backw=&quot;570&quot; data-ratio=&quot;0.5414438502673797&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AaabKZjib2ka0NNY82HVVsuaiaQTjNFzGoXVTn4UvtChOyLp9lRFE5ZEwbSPBMFGwwA24F3quluc19zXvbxibJqDw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;748&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;所谓共现，即：两个物品被同一个用户喜欢了。比如物品 a 和 b，由于他们同时被用户 A、B、C 喜欢，所以 a 和 b 的共现次数是3，采用这种统计方法就可以快速构建出共现矩阵。&lt;/span&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;第二步：计算物品的相似度矩阵&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;对于 Item-CF 算法来说，一般不采用前面提到的余弦距离来衡量物品的相似度，而是采用下面的公式&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.19085173501577288&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AaabKZjib2ka0NNY82HVVsuaiaQTjNFzGo2PYOv8Pq3e4ia7A7qALkN3ArmxeqPicz8jbscIhuKc5JmqJ0C2ZEMdMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;634&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;其中，N(u) 表示喜欢物品 u 的用户数，N(v) 表示喜欢物品 v 的用户数，两者的交集表示同时喜欢物品 u 和物品 v 的用户数。很显然，如果两个物品同时被很多人喜欢，那么这两个物品越相似。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;基于第1步计算出来的共现矩阵以及每个物品的喜欢人数，便可以构造出物品的相似度矩阵：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6618531889290012&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AaabKZjib2ka0NNY82HVVsuaiaQTjNFzGoiaqDVj8uCRjzFxq6FVxyC7ne8JaBetmat69J4icTzhw4GLNYqpxIhMQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;831&quot; data-backw=&quot;570&quot; data-backh=&quot;377&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;strong&gt;&lt;span&gt;第三步：推荐物品&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;最后一步，便可以基于相似度矩阵推荐物品了，公式如下：&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.18250950570342206&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AaabKZjib2ka0NNY82HVVsuaiaQTjNFzGoAkib6icNUGrgnEqeGMic1IcBPJQ7a9vPp0cuibawDR6ibm7XUcoh9If98Fg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1052&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;其中，P&lt;/span&gt;&lt;span&gt;uj &lt;/span&gt;&lt;span&gt;表示用户 u 对物品 j 的感兴趣程度，值越大，越值得被推荐。N(u) 表示用户 u 感兴趣的物品集合，S(j,N) 表示和物品 j 最相似的前 N 个物品，W&lt;/span&gt;&lt;span&gt;ij &lt;/span&gt;&lt;span&gt;表示物品 i 和物品 j 的相似度，R&lt;/span&gt;&lt;span&gt;ui &lt;/span&gt;&lt;span&gt;表示用户 u 对物品 i 的兴趣度。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;上面的公式有点抽象，直接看例子更容易理解，假设我要给用户 E 推荐物品，前面我们已经知道用户 E 喜欢物品 b 和物品 c，喜欢程度假设分别为 0.6 和 0.4。那么，利用上面的公式计算出来的推荐结果如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;377&quot; data-backw=&quot;570&quot; data-ratio=&quot;0.661144578313253&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AaabKZjib2ka0NNY82HVVsuaiaQTjNFzGo0kWejTY1TVx8Uf78EjTfqDUoEeIZfNq89BjU2kDs823or8omic2zECQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;664&quot;/&gt;&lt;/p&gt;&lt;section&gt;因为物品 b 和物品 c 已经被用户 E 喜欢过了，所以不再重复推荐。最终对比用户 E 对物品 a 和物品 d 的&lt;span&gt;感兴&lt;/span&gt;&lt;span&gt;趣程度&lt;/span&gt;，因为 0.682 &amp;gt; 0.3，因此选择推荐物品 a。&lt;/section&gt;&lt;p&gt;&lt;span&gt;04 从0到1搭建一个推荐系统&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;有了上面的理论基础后，我们就可以用 Python 快速实现出一个推荐系统。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 选择数据集&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;这里采用的是推荐领域非常经典的 MovieLens 数据集，它是一个关于电影评分的数据集，官网上提供了多个不同大小的版本，下面以 ml-1m 数据集（大约100万条用户评分记录）为例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;下载解压后，文件夹中包含：ratings.dat、movies.dat、users.dat 3个文件，共6040个用户，3900部电影，1000209条评分记录。各个文件的格式都是一样的，每行表示一条记录，字段之间&lt;/span&gt;&lt;span&gt;采用 :: 进行分割。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;以ratings.dat为例，每一行包括4个属性：&lt;/span&gt;&lt;span&gt;UserID, MovieID, Rating, Timestamp。&lt;/span&gt;&lt;span&gt;通过脚本可以统计出不同评分的人数分布：&lt;/span&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.75&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AaabKZjib2ka0NNY82HVVsuaiaQTjNFzGoJicVv4k4819mnoNicrdrMMGm483Mbsic5E2jRPicT4fE3mWIpL5AMXJciaw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;408&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;2. 读取原始数据&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;程序主要使用数据集中的 ratings.dat 这个文件，通过解析该文件，抽取出 user_id、movie_id、rating 3个字段，最终构造出算法依赖的数据，并保存在变量 dataset 中，它的格式为：dict[user_id][movie_id] = rate&lt;/span&gt;&lt;span/&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4166666567325592&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AaabKZjib2ka0NNY82HVVsuaiaQTjNFzGokfY7uHLQtDQkFGiaKLcODp2VvUjicUc2PaWr3hrCwKFnqd6Gk42g6zQg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;408&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;3. 构造物品的相似度矩阵&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;基于第 2 步的 dataset，可以进一步统计出每部电影的评分次数以及电影的共生矩阵，然后再生成相似度矩阵。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;429&quot; data-backw=&quot;553&quot; data-ratio=&quot;0.775&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AaabKZjib2ka0NNY82HVVsuaiaQTjNFzGocy30xfCohvSJVQewx7icvd2ukljfxqcjF6ib15S8hKPxwXePRZJ1iaudQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;4. 基于相似度矩阵推荐物品&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;最后，可以基于相似度矩阵进行推荐了，输入一个用户id，先针对该用户评分过的电影，依次选出 top 10 最相似的电影，然后加权求和后计算出每个候选电影的最终评分，最后再选择得分前 5 的电影进行推荐&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;270&quot; data-backw=&quot;546&quot; data-ratio=&quot;0.4953125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AaabKZjib2ka0NNY82HVVsuaiaQTjNFzGoND3mzquzScP4h9RJTYhQtFjqXF2LXvRzuiaUF9C0ZKJnrkYJz5W7gfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;5. 调用推荐系统&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;下面选择 &lt;span&gt;UserId=1 这个用户&lt;/span&gt;，看下程序的执行结果。由于推荐程序输出的是 movieId 列表，为了更直观的了解推荐结果，这里转换成电影的标题进行输出。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-backh=&quot;256&quot; data-backw=&quot;538&quot; data-ratio=&quot;0.47421875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AaabKZjib2ka0NNY82HVVsuaiaQTjNFzGoXZibHQzExp9TDnuloLsHrSxNIkRYSesicBPUdJ0TXUibkIMxfsnyoZ9CA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;最终推荐的前5个电影为：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;273&quot; data-backw=&quot;538&quot; data-ratio=&quot;0.509142053445851&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AaabKZjib2ka0NNY82HVVsuaiaQTjNFzGoTBVwYtWGqP2j5Ogbn6rACa5tMScqibyQzTAgjHbrDIJ3iaib3WfDr8sjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;711&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;05 线上推荐系统的挑战&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过上面的介绍，大家对推荐系统的基本构成应该有了一个初步认识，但是真正运用到线上真实环境时，还会遇到很多算法和工程上的挑战，绝对不是几十行 Python 代码可以搞定的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、上面的示例使用了标准化的数据集，而线上环境的数据是非标准化的，因此涉及到海量数据的收集、清洗和加工，最终构造出模型可使用的数据集。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、复杂且繁琐的特征工程，都说算法模型的上限由数据和特征决定。对于线上环境，需要从业务角度选择出可用的特征，然后对数据进行清洗、标准化、归一化、离散化，并通过实验效果进一步验证特征的有效性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、算法复杂度如何降低？比如上面介绍的Item-CF算法，时间和空间复杂度都是O(N×N)，而线上环境的数据都是千万甚至上亿级别的，如果不做算法优化，可能几天都跑不出数据，或者内存中根本放不下如此大的矩阵数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、实时性如何满足？因为用户的兴趣随着他们最新的行为在实时变化的，如果模型只是基于历史数据进行推荐，可能结果不够精准。因此，如何满足实时性要求，以及对于新加入的物品或者用户该如何推荐，都是要解决的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5、算法效果和性能的权衡。从算法角度追求多样性和准确性，从工程角度追求性能，这两者之间必须找到一个平衡点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;6、推荐系统的稳定性和效果追踪。需要有一套完善的数据监控和应用监控体系，同时有 ABTest 平台进行灰度实验，进行效果对比。&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;写在最后&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这篇文章是推荐系统的入门篇，目的是让大家对推荐系统先有一个整体的认识，后续我会再连载出一些文章，详细地介绍面对具体业务和线上海量数据时，推荐系统应该如何设计？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;欢迎关注我的公号，如果有疑问可以留言交流。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&amp;lt;END&amp;gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;大家在看：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MTM4NDAwMw==&amp;amp;mid=2247485125&amp;amp;idx=1&amp;amp;sn=7cfc053f2fb055588d4313545404cbe2&amp;amp;chksm=fc78d9e9cb0f50ffd639215d4039b3f606734ea5c620457d7de87b10567e783ee9031da04357&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;干货，广告系统架构解密！&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;干货，广告系统架构解密！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MTM4NDAwMw==&amp;amp;mid=2247484105&amp;amp;idx=1&amp;amp;sn=de4c763482aa65383dab59b221800cb5&amp;amp;chksm=fc78dde5cb0f54f39e1f278249d236ff2400330be573405435dba458404a5f771715319d694c&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;工程师如何从技术转型做管理？&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;高并发，你真的理解透彻了吗？&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MTM4NDAwMw==&amp;amp;mid=2247483901&amp;amp;idx=1&amp;amp;sn=c9ae824a1b7d0a8d07f08af8921cd7fc&amp;amp;chksm=fc78ded1cb0f57c7f01cb918e8d9382f9ccafe3a366d14405040b05d3986ff8dfbe6712430a1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;工程师如何从技术转型做管理？&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;工程师如何从技术转型做管理？&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2MTM4NDAwMw==&amp;amp;mid=2247483900&amp;amp;idx=1&amp;amp;sn=0544715b3f49600f7a5dc816e99dfd69&amp;amp;chksm=fc78ded0cb0f57c690aa73de40ca7805fa7e50b0f53d9ef68c4220458600c4a5eaf51c15b118&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;聊聊直播平台背后的技术架构&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot; hasload=&quot;1&quot;&gt;聊聊直播平台背后的技术架构&lt;/a&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;IT人的职场进阶 &lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;前亚马逊工程师，现58转转技术总监，持续分享个人的成长经历，希望为你的职场发展带来些新思路，欢迎扫码关注我！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-backh=&quot;53&quot; data-backw=&quot;53&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;271&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;271&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AaabKZjib2kZxxgevbSVSmRuyaiaMzkVjclyc9Vc7CicwsSnbrHMfqIkNkvvt6iajgGscibkAT2aicCtSuf6OEoMk1og/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p/&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;分享或在看是最大的鼓励&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fd145b4b5b6fd93fe65ac1de182298ac</guid>
<title>技术人员发展四阶段</title>
<link>https://toutiao.io/k/lfucbgj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cdc8863f3f3457a6194dfa8efcd6851c</guid>
<title>Dubbo 日志链路追踪 TraceId 选型</title>
<link>https://toutiao.io/k/b0y1ksy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6666666666666666&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Hic4icvNgYCicZvwodbNQryOoDKF56ncD3xibWXERbb6xlrL2GlLyKiagVTeg16G7ppkOhxqIAPiaN3oshebbCkDpKhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;figcaption&gt;链路追踪ID&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、目的&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发排查系统问题用得最多的手段就是查看系统日志，但是在分布式环境下使用日志定位问题还是比较麻烦，需要借助 &lt;code&gt;全链路追踪ID&lt;/code&gt;  把上下文串联起来，本文主要分享基于 &lt;code&gt;Spring Boot&lt;/code&gt; + &lt;code&gt;Dubbo&lt;/code&gt; 框架下 &lt;code&gt;日志链路追踪ID&lt;/code&gt; 的实现方案选型思路。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前大多数分布式追踪系统的思想模型都来自 Google&#x27;s Dapper 论文&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6796296296296296&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Hic4icvNgYCicZvwodbNQryOoDKF56ncD3xlpM9C8K7W9MAbG8LotAWicSxqo6P3uD3KFsJEyiaNlkG3uzdFqQxmODw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;figcaption&gt;Dapper&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;全链路追踪的核心思想：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为每条请求都单独分配一个唯一的 &lt;code&gt;traceId&lt;/code&gt; 用来标识一条请求链路，该 &lt;code&gt;traceId&lt;/code&gt; 会贯穿整个请求处理过程的所有服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每个服务/线程都拥有自己的 &lt;code&gt;spanId&lt;/code&gt; 标识，代表请求的其中一段处理步骤&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一个请求包含一个 &lt;code&gt;traceId&lt;/code&gt; 和一个或多个 &lt;code&gt;spanId&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;「日志全链路追踪」&lt;/strong&gt; 就是在每条系统日志里都添加显示 &lt;code&gt;traceId&lt;/code&gt; 和 &lt;code&gt;spanId&lt;/code&gt; 信息&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.37424547283702214&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Hic4icvNgYCicZvwodbNQryOoDKF56ncD3xUwlpGH25lmKD7s1seERvjGiaX6doZXJpOy6ZQXcwXTtV8XiaiaCfZRSCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1988&quot;/&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、方案选型&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1. 方案一(apm-toolkit)&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是 &lt;code&gt;SkyWalking&lt;/code&gt; 的一个日志插件，通过这个插件可以在日志中输出&lt;code&gt;traceId&lt;/code&gt;&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.1. 使用方式&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「配置依赖」&lt;/strong&gt;，在 pom 文件中添加以下内容&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.skywalking&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;apm-toolkit-logback-1.x&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;8.1.0&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「配置日志模板」&lt;/strong&gt;，修改 &lt;code&gt;logback-spring.xml&lt;/code&gt; 文件中 &lt;code&gt;Appender&lt;/code&gt; 元素的 &lt;code&gt;encoder&lt;/code&gt; 为以下内容&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;encoder&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;ch.qos.logback.core.encoder.LayoutWrappingEncoder&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;layout&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;org.apache.skywalking.apm.toolkit.log.logback.v1.x.TraceIdPatternLogbackLayout&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%tid] [%thread] %-5level %logger{35} - %msg%n&lt;span&gt;&amp;lt;/&lt;span&gt;pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;layout&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;encoder&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;「ps:」&lt;/strong&gt; pattern 中的内容按需修改，其中的 %tid 就是相当于 traceId，默认 TID:N/A，当有请求调用时会生成并显示 traceId&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1.2. 总结&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;「优点」&lt;/strong&gt;：无需编码，业务无入侵，可与 &lt;code&gt;SkyWalking&lt;/code&gt; 的图形化界面中使用该ID快速定位各种接口的调用关系&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;「缺点」&lt;/strong&gt;：强耦合 &lt;code&gt;SkyWalking&lt;/code&gt; 才能生效&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;必须添加sk的 &lt;code&gt;javaagent&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;必&lt;span&gt;须&lt;/span&gt;部署 &lt;code&gt;SkyWalking&lt;/code&gt; 服务端&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2. 方案二(sleuth)&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Sleuth&lt;/code&gt; 是 &lt;code&gt;Spring Cloud&lt;/code&gt; 的组件之一，它为 &lt;code&gt;Spring Cloud&lt;/code&gt; 实现了一种分布式追踪解决方案，兼容Zipkin，HTrace与其他日志追踪系统&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.1. 使用方式&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「配置父依赖」&lt;/strong&gt;，在 pom 文件中添加以下内容管理版本号&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependencyManagement&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;dependencies&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-cloud-sleuth&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;2.2.4.RELEASE&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;type&lt;/span&gt;&amp;gt;&lt;/span&gt;pom&lt;span&gt;&amp;lt;/&lt;span&gt;type&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;import&lt;span&gt;&amp;lt;/&lt;span&gt;scope&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependencyManagement&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「配置依赖」&lt;/strong&gt;，在 pom 文件中添加以下内容&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-sleuth&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「适配dubbo」&lt;/strong&gt;，要让 &lt;code&gt;sleuth&lt;/code&gt; 支持 &lt;code&gt;dubbo&lt;/code&gt; 框架，需要增加以下两个步骤：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先添加 dubbo 的插件依赖&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;io.zipkin.brave&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;brave-instrumentation-dubbo-rpc&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;5.12.6&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;配置 dubbo 过滤器&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;dubbo:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  provider:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    filter:&lt;/span&gt; &lt;span&gt;tracing&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  consumer:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;    filter:&lt;/span&gt; &lt;span&gt;tracing&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「配置日志模板」&lt;/strong&gt;，修改 &lt;code&gt;logback-spring.xml&lt;/code&gt; 文件中 &lt;code&gt;Appender&lt;/code&gt; 元素的 &lt;code&gt;encoder&lt;/code&gt; 为以下内容&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;encoder&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%X{X-B3-TraceId},%X{X-B3-SpanId}] [%thread] %-5level %logger{35} - %msg%n&lt;span&gt;&amp;lt;/&lt;span&gt;pattern&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;charset&lt;/span&gt;&amp;gt;&lt;/span&gt;utf-8&lt;span&gt;&amp;lt;/&lt;span&gt;charset&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;encoder&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;「ps:」&lt;/strong&gt; pattern 中的内容按需修改，其中的 %X{X-B3-TraceId} 为 traceId，%X{X-B3-SpanId} 为 spanId&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2.2. 总结&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;「优点」&lt;/strong&gt;：业务无入侵，有丰富的插件进行扩展包括定时任务、MQ等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;「缺点」&lt;/strong&gt;：&lt;code&gt;brave-instrumentation-dubbo-rpc&lt;/code&gt; 不支持 &lt;code&gt;dubbo 2.7.x&lt;/code&gt; 需要自行开发插件。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3. 方案三(自研)&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3.1. 无入侵增加 traceId&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 &lt;code&gt;Logback&lt;/code&gt; 的 &lt;code&gt;MDC&lt;/code&gt; 机制，在日志模板中加入 &lt;code&gt;traceId&lt;/code&gt; 标识，取值方式为 &lt;code&gt;%X{traceId}&lt;/code&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;系统入口（api网关）创建 &lt;code&gt;traceId&lt;/code&gt; 的值&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 &lt;code&gt;MDC&lt;/code&gt; 保存 &lt;code&gt;traceId&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修改 &lt;code&gt;logback&lt;/code&gt; 配置文件模板格式添加标识 &lt;code&gt;%X{traceId}&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;MDC（Mapped Diagnostic Context，映射调试上下文）是 log4j 和 logback 提供的一种方便在多线程条件下记录日志的功能。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3.2. 跨线程传递&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决 &lt;code&gt;traceId&lt;/code&gt; 跨线程丢失问题&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6342281879194631&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Hic4icvNgYCicZvwodbNQryOoDKF56ncD3xTqibShsN3wuo4kDQtTzjWo1h5YgficGzDw0Wn4X6PRfoUInIvWfJE5og/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1192&quot;/&gt;&lt;figcaption&gt;file&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于 &lt;code&gt;MDC&lt;/code&gt; 内部使用的是 &lt;code&gt;ThreadLocal&lt;/code&gt; 所以只有本线程才有效，子线程和下游的服务 &lt;code&gt;MDC&lt;/code&gt; 里的值会丢失；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要解决 &lt;code&gt;Spring&lt;/code&gt; 的各种线程池与异步方法的父子线程间传递。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「解决思路」&lt;/strong&gt;：重写一个 &lt;code&gt;MDCAdapter&lt;/code&gt; 使用阿里的 &lt;code&gt;TransmittableThreadLocal&lt;/code&gt; 替换原来的 &lt;code&gt;ThreadLocal&lt;/code&gt; 对象，解决各种线程池（&lt;code&gt;ExecutorService&lt;/code&gt; / &lt;code&gt;ForkJoinPool&lt;/code&gt; / &lt;code&gt;TimerTask&lt;/code&gt;）父子进程传值问题。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;需要使用 &lt;code&gt;TtlRunnable&lt;/code&gt; 和 &lt;code&gt;TtlCallable&lt;/code&gt; 来修饰传入线程池的 &lt;code&gt;Runnable&lt;/code&gt; 和 &lt;code&gt;Callable&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3.3. 跨进程传递&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;解决 &lt;code&gt;traceId&lt;/code&gt; 跨进程丢失问题&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「dubbo服务」&lt;/strong&gt; 使用 &lt;code&gt;org.apache.dubbo.rpc.Filter&lt;/code&gt; 创建一个过滤器进行 &lt;code&gt;traceId&lt;/code&gt; 传递&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;服务消费者：负责传递链路追踪 ID&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;服务提供者：负责接收 ID 并保存到 &lt;code&gt;MDC&lt;/code&gt; 中&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3.4. 总结&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;「优点」&lt;/strong&gt;：业务无入侵，最小依赖，扩展灵活，适配性强。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;「缺点」&lt;/strong&gt;：需要自行实现，有大量的开发工作量。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt; &lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、方案总结&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方案&lt;/th&gt;&lt;th&gt;开发工作量&lt;/th&gt;&lt;th&gt;可维护性&lt;/th&gt;&lt;th&gt;入侵性&lt;/th&gt;&lt;th&gt;性能&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;apm-toolkit&lt;/td&gt;&lt;td&gt;无&lt;/td&gt;&lt;td&gt;低&lt;/td&gt;&lt;td&gt;业务无入侵&lt;/td&gt;&lt;td&gt;中&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;sleuth&lt;/td&gt;&lt;td&gt;中&lt;/td&gt;&lt;td&gt;中&lt;/td&gt;&lt;td&gt;业务无入侵&lt;/td&gt;&lt;td&gt;中&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;自研&lt;/td&gt;&lt;td&gt;高&lt;/td&gt;&lt;td&gt;高&lt;/td&gt;&lt;td&gt;业务无入侵&lt;/td&gt;&lt;td&gt;高&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>