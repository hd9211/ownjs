<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>dc05c13cb0614d6cdcae7b43cb9c5e2c</guid>
<title>文末送福利｜十一长假干嘛呢？快来吧！</title>
<link>https://toutiao.io/k/8pbs9cx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;34&quot; data-cropselx2=&quot;356&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;425&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ6h6x4EnYInRLic6PibFNWw4zSv28rAxcJu9dumVJF03PwHGOWxOzeJKIsydVa7UJuTo4jOjrct9NZw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>d001abde810a843deefdbcb50171e434</guid>
<title>t-io 的生态结构，可以大致看到 t-io 的性能</title>
<link>https://toutiao.io/k/m1bcnml</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;blockquote&gt;
&lt;p&gt;tio-utils是笔者在项目开发中积累的部分工具类
里面有少部分代码是在开源许可范围内摘自第三方开源项目代码的，还有部分代码是其它开源作者提供的，譬如hutool的作者路神就提供了许多类，这么做，仅仅是因为广大用户强力要求tio减少第三方依赖
当然笔者更愿意使第三方工具类，譬如hutool
在tio-utils中目前t-io用得最多的Cache
首先这个Cache是个门面——把市面上的各路Cache统一成了ICache，操作方法统一了
其次它内置了一级cache，两级cache，并且性能极好、操作省心、稳定性也在大量项目中得到了考验
其实就是想挑战J2cache，不过tio-utils也把J2cache门面化了&lt;/p&gt;
&lt;/blockquote&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>922be80cfadaca882f5ffb005c2f570b</guid>
<title>一篇讲透自研的前端错误监控</title>
<link>https://toutiao.io/k/j137z5n</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;138771404668583936&quot; data-gallerysupplier=&quot;5&quot; data-ratio=&quot;0.55078125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/aDoYvepE5x0D8raJJQbVFOicG2HYYXNhUjrdsSfem4qK6ytGaJiakvMmryVKKMyXpeibeOZAHlgCUqRibGQhMcJfBQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot;/&gt;&lt;span&gt;一、背景&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;痛点&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;某⼀天产品：xxx⼴告主反馈我们的⻚⾯注册不了！⼜⼀天运营：这个活动在xxx媒体上挂掉了！&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在我司线上运行的是近亿级别的广告页面，这样线上如果裸奔，出现了什么问题不知道，后置在业务端发现，被业务方询问，这种场景很尴尬。&lt;/p&gt;&lt;h2&gt;选择&lt;/h2&gt;&lt;p&gt;公司存在四个事业部，而每个事业部不下于3个项目，这里至少12个项目，这里作为伏笔，业务线多。&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们是选择自己做呢，还是选第三方的呢。我们比较一&lt;/span&gt;下&lt;span&gt;几款常见第三方。&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Fundebug：付费版 159元/月起，数据存在第三方，而数据自我保存需要 30 万/年。还是很贵的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;FrontJS，FrontJS 高级版 899/月，专业版是 2999/月。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Sentry，80 美金/月。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以Sentry为计费，对这12个项目计算一下。12个项目一年将近10万。而大致估算过需要2人1.5月即90人日，能完成MVP版本，按每人1.5万工资/月计算，总共花费4.5万，而且是一劳永逸的。&lt;/p&gt;&lt;p&gt;因此从成本角度我们会选择自研，但除了成本外，还有其他原因。例如我们会基于这套系统做一些自定义功能，与公司权限用户系统打通，再针对用户进行Todo管理，对用户进行错误排行等。&lt;/p&gt;&lt;p&gt;还有基于业务数据的安全，我们希望自我搭建一个系统。&lt;/p&gt;&lt;p&gt;所以从成本、安全、扩展性角度，我们选择了自己研发。&lt;/p&gt;&lt;h1&gt;二、产品设计&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;我们要什么样的一个产品呢，根据第一性原理，解决关键问题“怎么定位问题”。通过5W1H法我们来分析，我们想要知道些什么信息呢？&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;错误信息&lt;/h2&gt;&lt;p&gt;其实错误监控说简单就一句话可以描述，搜集页面错误，进行上报，然后对症分析。&lt;/p&gt;&lt;p&gt;按照5W1H法则进行分析这句话，可以发现有几项需要我们关注。&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;What，发⽣了什么错误：逻辑错误、数据错误、⽹络错误、语法错误等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;When，出现的时间段，如时间戳。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Who，影响了多少用户，包括报错事件数、IP、设备信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Where，出现的页面是哪些，包括页面、广告位（我司）、媒体（我司）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Why，错误的原因是为什么，包括错误堆栈、⾏列、SourceMap。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;How，怎么定位解决问题，我们还需要收集系统等信息。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2&gt;架构层次&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;首先我们需要梳理下，我们需要一些哪些功能。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;那我们怎么得到上面的信息进行最终错误的定位呢。&lt;/p&gt;&lt;p&gt;首先我们肯定需要对错误进行搜集，然后用户设备页面端的错误我们怎么才能感知到呢，这就需要进行上报。那么第一层就展现出来了，我们需要一个搜集上报端。&lt;/p&gt;&lt;p&gt;那怎么才能进行上报呢，和后端协作那么久，肯定知道的吧🙃 ，你需要一个接口。那就需要一个服务器来进行对于上报的错误进行采集，对于错误进行筛选聚合。那么第二层也知道了啊，我们需要一个采集聚合端。&lt;/p&gt;&lt;p&gt;我们搜集到了我们足够的物料信息了，那接下来要怎么用起来呢，我们需要把它们按照我们的规则进行整理。如果每次又是通过写类SQL进行整理查询效率会很低，因此我们需要一个可视化的平台进行展示。因此有了第三层，可视化分析端。&lt;/p&gt;&lt;p&gt;感觉好像做完啦，想必大家都这么想，一个错误监控平台做完了，🙅 。如果是这样你会发现一个现象，每次上线和上线后一段时间，开发同学都一直盯着屏幕看，这是在干嘛，人形眼动观察者模式吗。因此我们需要通过代码去解决，自然而然，第四层，监控告警端应运而生。&lt;/p&gt;&lt;p&gt;所以请大声说出来我们需要什么🙈 ，搜集上报端，采集聚合端，可视分析端，监控告警端。&lt;/p&gt;&lt;h1&gt;三、系统设计&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;如函数一样，定义好每个环节的输入和输出，且核心需要处理的功能。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;下面我们看看上述所说的四个端怎么去实现呢。&lt;/p&gt;&lt;h2&gt;搜集上报端（SDK）&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;这个环节主要输入是所有错误，输出是捕获上报错误。核心是处理不同类型错误的搜集工作。其他是一些非核心但必要的工作。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;错误类型&lt;/h3&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;先看看我们需要处理哪些错误类型。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;常见JS执行错误&lt;/strong&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;SyntaxError&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;解析时发生语法错误&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;// 控制台运行&lt;br/&gt;const xx, &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;window.onerror捕获不到SyntxError，一般SyntaxError在构建阶段，甚至本地开发阶段就会被发现。&lt;/p&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;TypeError&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;值不是所期待的类型&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;// 控制台运行&lt;br/&gt;const person = void 0&lt;br/&gt;person.name &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ReferenceError&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;引用未声明的变量&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;// 控制台运行&lt;br/&gt;nodefined &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;4&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;RangeError&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;当一个值不在其所允许的范围或者集合中&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;(&lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;fn&lt;/span&gt;&lt;/span&gt; ( ) { fn() })() &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;网络错误&lt;/strong&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ResourceError&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;资源加载错误&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;new Image().src = &lt;span&gt;&#x27;/remote/image/notdeinfed.png&#x27;&lt;/span&gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;HttpError&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;Http请求错误&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;// 控制台运行&lt;br/&gt;fetch(&lt;span&gt;&#x27;/remote/notdefined&#x27;&lt;/span&gt;, {}) &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;搜集错误&lt;/h3&gt;&lt;p&gt;所有起因来源于错误，那我们如何进行错误捕获。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;try/catch&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;能捕获常规运行时错误，语法错误和异步错误不行&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;// 常规运行时错误，可以捕获 ✅&lt;br/&gt;try {&lt;br/&gt;  console.log(notdefined);&lt;br/&gt;} catch(e) {&lt;br/&gt;  console.log(&lt;span&gt;&#x27;捕获到异常：&#x27;&lt;/span&gt;, e);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 语法错误，不能捕获 ❌&lt;br/&gt;try {&lt;br/&gt;  const notdefined,&lt;br/&gt;} catch(e) {&lt;br/&gt;  console.log(&lt;span&gt;&#x27;捕获到异常：&#x27;&lt;/span&gt;, e);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 异步错误，不能捕获 ❌&lt;br/&gt;try {&lt;br/&gt;  setTimeout(() =&amp;gt; {&lt;br/&gt;    console.log(notdefined);&lt;br/&gt;  }, 0)&lt;br/&gt;} catch(e) {&lt;br/&gt;  console.log(&lt;span&gt;&#x27;捕获到异常：&#x27;&lt;/span&gt;,e);&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;try/catch有它细致处理的优势，但缺点也比较明显。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;window.onerror&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;pure js错误收集，window.onerror，当 JS 运行时错误发生时，window 会触发一个 ErrorEvent 接口的 error 事件。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;/**&lt;br/&gt;* @param {String} message    错误信息&lt;br/&gt;* @param {String} &lt;span&gt;source&lt;/span&gt;    出错文件&lt;br/&gt;* @param {Number} lineno    行号&lt;br/&gt;* @param {Number} colno    列号&lt;br/&gt;* @param {Object} error  Error对象&lt;br/&gt;*/&lt;br/&gt;&lt;br/&gt;window.onerror = &lt;span&gt;function&lt;/span&gt;(message, &lt;span&gt;source&lt;/span&gt;, lineno, colno, error) {&lt;br/&gt;   console.log(&lt;span&gt;&#x27;捕获到异常：&#x27;&lt;/span&gt;, {message, &lt;span&gt;source&lt;/span&gt;, lineno, colno, error});&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;先验证下几个错误是否可以捕获。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 常规运行时错误，可以捕获 ✅&lt;br/&gt;&lt;br/&gt;window.onerror = &lt;span&gt;function&lt;/span&gt;(message, &lt;span&gt;source&lt;/span&gt;, lineno, colno, error) {&lt;br/&gt;  console.log(&lt;span&gt;&#x27;捕获到异常：&#x27;&lt;/span&gt;,{message, &lt;span&gt;source&lt;/span&gt;, lineno, colno, error});&lt;br/&gt;}&lt;br/&gt;console.log(notdefined);&lt;br/&gt;&lt;br/&gt;// 语法错误，不能捕获 ❌&lt;br/&gt;window.onerror = &lt;span&gt;function&lt;/span&gt;(message, &lt;span&gt;source&lt;/span&gt;, lineno, colno, error) {&lt;br/&gt;  console.log(&lt;span&gt;&#x27;捕获到异常：&#x27;&lt;/span&gt;,{message, &lt;span&gt;source&lt;/span&gt;, lineno, colno, error});&lt;br/&gt;}&lt;br/&gt;const notdefined,&lt;br/&gt;      &lt;br/&gt;// 异步错误，可以捕获 ✅&lt;br/&gt;window.onerror = &lt;span&gt;function&lt;/span&gt;(message, &lt;span&gt;source&lt;/span&gt;, lineno, colno, error) {&lt;br/&gt;  console.log(&lt;span&gt;&#x27;捕获到异常：&#x27;&lt;/span&gt;,{message, &lt;span&gt;source&lt;/span&gt;, lineno, colno, error});&lt;br/&gt;}&lt;br/&gt;setTimeout(() =&amp;gt; {&lt;br/&gt;  console.log(notdefined);&lt;br/&gt;}, 0)&lt;br/&gt;&lt;br/&gt;// 资源错误，不能捕获 ❌&lt;br/&gt;&amp;lt;script&amp;gt;&lt;br/&gt;  window.onerror = &lt;span&gt;function&lt;/span&gt;(message, &lt;span&gt;source&lt;/span&gt;, lineno, colno, error) {&lt;br/&gt;  console.log(&lt;span&gt;&#x27;捕获到异常：&#x27;&lt;/span&gt;,{message, &lt;span&gt;source&lt;/span&gt;, lineno, colno, error});&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;img src=&lt;span&gt;&quot;https://yun.tuia.cn/image/kkk.png&quot;&lt;/span&gt;&amp;gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;window.onerror 不能捕获资源错误怎么办？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;window.addEventListener&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;当一项资源（如图片或脚本）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，这些 error 事件不会向上冒泡到 window，但能被捕获。而window.onerror不能监测捕获。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;// 图片、script、css加载错误，都能被捕获 ✅&lt;br/&gt;&amp;lt;script&amp;gt; window.addEventListener(&lt;span&gt;&#x27;error&#x27;&lt;/span&gt;, (error) =&amp;gt; {&lt;br/&gt;   console.log(&lt;span&gt;&#x27;捕获到异常：&#x27;&lt;/span&gt;, error);&lt;br/&gt; }, &lt;span&gt;true&lt;/span&gt;) &amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;img src=&lt;span&gt;&quot;https://yun.tuia.cn/image/kkk.png&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;&amp;lt;script src=&lt;span&gt;&quot;https://yun.tuia.cn/foundnull.js&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;link href=&lt;span&gt;&quot;https://yun.tuia.cn/foundnull.css&quot;&lt;/span&gt; rel=&lt;span&gt;&quot;stylesheet&quot;&lt;/span&gt;/&amp;gt;&lt;br/&gt;  &lt;br/&gt;// new Image错误，不能捕获 ❌&lt;br/&gt;&amp;lt;script&amp;gt; window.addEventListener(&lt;span&gt;&#x27;error&#x27;&lt;/span&gt;, (error) =&amp;gt; {&lt;br/&gt;    console.log(&lt;span&gt;&#x27;捕获到异常：&#x27;&lt;/span&gt;, error);&lt;br/&gt;  }, &lt;span&gt;true&lt;/span&gt;) &amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;script&amp;gt; new Image().src = &lt;span&gt;&#x27;https://yun.tuia.cn/image/lll.png&#x27;&lt;/span&gt; &amp;lt;/script&amp;gt;&lt;br/&gt;&lt;br/&gt;// fetch错误，不能捕获 ❌&lt;br/&gt;&amp;lt;script&amp;gt; window.addEventListener(&lt;span&gt;&#x27;error&#x27;&lt;/span&gt;, (error) =&amp;gt; {&lt;br/&gt;    console.log(&lt;span&gt;&#x27;捕获到异常：&#x27;&lt;/span&gt;, error);&lt;br/&gt;  }, &lt;span&gt;true&lt;/span&gt;) &amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;script&amp;gt; fetch(&lt;span&gt;&#x27;https://tuia.cn/test&#x27;&lt;/span&gt;) &amp;lt;/script&amp;gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;new Image运用的比较少，可以单独自己处理自己的错误。&lt;/p&gt;&lt;p&gt;但通用的fetch怎么办呢，fetch返回Promise，但Promise的错误不能被捕获，怎么办呢？&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Promise错误&lt;/strong&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;普通Promise错误&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;try/catch不能捕获Promise中的错误&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;// try/catch 不能处理 JSON.parse 的错误，因为它在 Promise 中&lt;br/&gt;try {&lt;br/&gt;  new Promise((resolve,reject) =&amp;gt; { &lt;br/&gt;    JSON.parse(&lt;span&gt;&#x27;&#x27;&lt;/span&gt;)&lt;br/&gt;    resolve();&lt;br/&gt;  })&lt;br/&gt;} catch(err) {&lt;br/&gt;  console.error(&lt;span&gt;&#x27;in try catch&#x27;&lt;/span&gt;, err)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 需要使用catch方法&lt;br/&gt;new Promise((resolve,reject) =&amp;gt; { &lt;br/&gt;  JSON.parse(&lt;span&gt;&#x27;&#x27;&lt;/span&gt;)&lt;br/&gt;  resolve();&lt;br/&gt;}).catch(err =&amp;gt; {&lt;br/&gt;  console.log(&lt;span&gt;&#x27;in catch fn&#x27;&lt;/span&gt;, err)&lt;br/&gt;}) &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;async错误&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;try/catch不能捕获async包裹的错误&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;const getJSON = async () =&amp;gt; {&lt;br/&gt;  throw new Error(&lt;span&gt;&#x27;inner error&#x27;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 通过try/catch处理&lt;br/&gt;const makeRequest = async () =&amp;gt; {&lt;br/&gt;    try {&lt;br/&gt;        // 捕获不到&lt;br/&gt;        JSON.parse(getJSON());&lt;br/&gt;    } catch (err) {&lt;br/&gt;        console.log(&lt;span&gt;&#x27;outer&#x27;&lt;/span&gt;, err);&lt;br/&gt;    }&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;try {&lt;br/&gt;    // try/catch不到&lt;br/&gt;    makeRequest()&lt;br/&gt;} catch(err) {&lt;br/&gt;    console.error(&lt;span&gt;&#x27;in try catch&#x27;&lt;/span&gt;, err)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;try {&lt;br/&gt;    // 需要await，才能捕获到&lt;br/&gt;    await makeRequest()&lt;br/&gt;} catch(err) {&lt;br/&gt;    console.error(&lt;span&gt;&#x27;in try catch&#x27;&lt;/span&gt;, err)&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;import chunk错误&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;blockquote&gt;&lt;p&gt;import其实返回的也是一个promise，因此使用如下两种方式捕获错误&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;// Promise catch方法&lt;br/&gt;import(/* webpackChunkName: &lt;span&gt;&quot;incentive&quot;&lt;/span&gt; */&lt;span&gt;&#x27;./index&#x27;&lt;/span&gt;).&lt;span&gt;then&lt;/span&gt;(module =&amp;gt; {&lt;br/&gt;    module.default()&lt;br/&gt;}).catch((err) =&amp;gt; {&lt;br/&gt;    console.error(&lt;span&gt;&#x27;in catch fn&#x27;&lt;/span&gt;, err)&lt;br/&gt;})&lt;br/&gt;&lt;br/&gt;// await 方法，try catch&lt;br/&gt;try {&lt;br/&gt;    const module = await import(/* webpackChunkName: &lt;span&gt;&quot;incentive&quot;&lt;/span&gt; */&lt;span&gt;&#x27;./index&#x27;&lt;/span&gt;);&lt;br/&gt;    module.default()&lt;br/&gt;} catch(err) {&lt;br/&gt;    console.error(&lt;span&gt;&#x27;in try catch&#x27;&lt;/span&gt;, err)&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;小结：全局捕获Promise中的错误&lt;/p&gt;&lt;p&gt;以上三种其实归结为Promise类型错误，可以通过unhandledrejection捕获&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 全局统一处理Promise&lt;br/&gt;window.addEventListener(&lt;span&gt;&quot;unhandledrejection&quot;&lt;/span&gt;, &lt;span&gt;function&lt;/span&gt;(e){&lt;br/&gt;  console.log(&lt;span&gt;&#x27;捕获到异常：&#x27;&lt;/span&gt;, e);&lt;br/&gt;});&lt;br/&gt;fetch(&lt;span&gt;&#x27;https://tuia.cn/test&#x27;&lt;/span&gt;) &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了防止有漏掉的 Promise 异常，可通过unhandledrejection用来全局监听Uncaught Promise Error。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Vue错误&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;由于Vue会捕获所有Vue单文件组件或者Vue.extend继承的代码，所以在Vue里面出现的错误，并不会直接被window.onerror捕获，而是会抛给Vue.config.errorHandler。&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;/**&lt;br/&gt; * 全局捕获Vue错误，直接扔出给onerror处理&lt;br/&gt; */&lt;br/&gt;Vue.config.errorHandler = &lt;span&gt;function&lt;/span&gt; (err) {&lt;br/&gt;  setTimeout(() =&amp;gt; {&lt;br/&gt;    throw err&lt;br/&gt;  })&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;React错误&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;react 通过componentDidCatch，声明一个错误边界的组件&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;class ErrorBoundary extends React.Component {&lt;br/&gt;  constructor(props) {&lt;br/&gt;    super(props);&lt;br/&gt;    this.state = { hasError: &lt;span&gt;false&lt;/span&gt; };&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  static getDerivedStateFromError(error) {&lt;br/&gt;    // 更新 state 使下一次渲染能够显示降级后的 UI&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; { hasError: &lt;span&gt;true&lt;/span&gt; };&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  componentDidCatch(error, errorInfo) {&lt;br/&gt;    // 你同样可以将错误日志上报给服务器&lt;br/&gt;    logErrorToMyService(error, errorInfo);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;&lt;span&gt;render&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (this.state.hasError) {&lt;br/&gt;      // 你可以自定义降级后的 UI 并渲染&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; &amp;lt;h1&amp;gt;Something went wrong.&amp;lt;/h1&amp;gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; this.props.children; &lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;class App extends React.Component {&lt;br/&gt;   &lt;br/&gt;  &lt;span&gt;&lt;span&gt;render&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;    &amp;lt;ErrorBoundary&amp;gt;&lt;br/&gt;      &amp;lt;MyWidget /&amp;gt;&lt;br/&gt;    &amp;lt;/ErrorBoundary&amp;gt;  &lt;br/&gt;    )&lt;br/&gt;  }&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但error boundaries并不会捕捉以下错误：React事件处理，异步代码，error boundaries自己抛出的错误。&lt;/p&gt;&lt;h3&gt;跨域问题&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;一般情况，如果出现 Script error 这样的错误，基本上可以确定是出现了跨域问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;如果当前投放页面和云端JS所在不同域名，如果云端JS出现错误，window.onerror会出现Script Error。通过以下两种方法能给予解决。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;后端配置Access-Control-Allow-Origin、前端script加crossorigin。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;script src=&lt;span&gt;&quot;http://yun.tuia.cn/test.js&quot;&lt;/span&gt; crossorigin&amp;gt;&amp;lt;/script&amp;gt;&lt;br/&gt;&lt;br/&gt;const script = document.createElement(&lt;span&gt;&#x27;script&#x27;&lt;/span&gt;);&lt;br/&gt;script.crossOrigin = &lt;span&gt;&#x27;anonymous&#x27;&lt;/span&gt;;&lt;br/&gt;script.src = &lt;span&gt;&#x27;http://yun.tuia.cn/test.js&#x27;&lt;/span&gt;;&lt;br/&gt;document.body.appendChild(script); &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果不能修改服务端的请求头，可以考虑通过使用 try/catch 绕过，将错误抛出。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;!doctype html&amp;gt;&lt;br/&gt;&amp;lt;html&amp;gt;&lt;br/&gt;&amp;lt;head&amp;gt;&lt;br/&gt;  &amp;lt;title&amp;gt;Test page &lt;span&gt;in&lt;/span&gt; http://test.com&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;&amp;lt;body&amp;gt;&lt;br/&gt;  &amp;lt;script src=&lt;span&gt;&quot;https://yun.dui88.com/tuia/cdn/remote/testerror.js&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;br/&gt;  &amp;lt;script&amp;gt; window.onerror = &lt;span&gt;function&lt;/span&gt; (message, url, line, column, error) {&lt;br/&gt;    console.log(message, url, line, column, error);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  try {&lt;br/&gt;    foo(); // 调用testerror.js中定义的foo方法&lt;br/&gt;  } catch (e) {&lt;br/&gt;    throw e;&lt;br/&gt;  } &amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&amp;lt;/html&amp;gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会发现如果不加try catch，console.log就会打印script error。加上try catch就能捕获到。&lt;/p&gt;&lt;p&gt;我们捋一下场景，一般调用远端js，有下列三种常见情况。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;调用远端JS的方法出错&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;远端JS内部的事件出问题&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;要么在setTimeout等回调内出错&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;调用方法场景&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;可以通过封装一个函数，能装饰原方法，使得其能被try/catch。&lt;/p&gt;&lt;pre&gt;&lt;code&gt; &amp;lt;!doctype html&amp;gt;&lt;br/&gt;&amp;lt;html&amp;gt;&lt;br/&gt;&amp;lt;head&amp;gt;&lt;br/&gt;  &amp;lt;title&amp;gt;Test page &lt;span&gt;in&lt;/span&gt; http://test.com&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;&amp;lt;body&amp;gt;&lt;br/&gt;  &amp;lt;script src=&lt;span&gt;&quot;https://yun.dui88.com/tuia/cdn/remote/testerror.js&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;br/&gt;  &amp;lt;script&amp;gt; window.onerror = &lt;span&gt;function&lt;/span&gt; (message, url, line, column, error) {&lt;br/&gt;    console.log(message, url, line, column, error);&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;function&lt;/span&gt; wrapErrors(fn) {&lt;br/&gt;    // don&lt;span&gt;&#x27;t wrap function more than once&lt;br/&gt;    if (!fn.__wrapped__) {&lt;br/&gt;      fn.__wrapped__ = function () {&lt;br/&gt;        try {&lt;br/&gt;          return fn.apply(this, arguments);&lt;br/&gt;        } catch (e) {&lt;br/&gt;          throw e; // re-throw the error&lt;br/&gt;        }&lt;br/&gt;      };&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    return fn.__wrapped__;&lt;br/&gt;  }&lt;br/&gt;&lt;br/&gt;  wrapErrors(foo)() &amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&amp;lt;/html&amp;gt; &lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;大家可以尝试去掉wrapErrors感受下。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;事件场景&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;可以劫持原生方法。&lt;/p&gt;&lt;pre&gt;&lt;code&gt; &amp;lt;!doctype html&amp;gt;&lt;br/&gt;&amp;lt;html&amp;gt;&lt;br/&gt;&amp;lt;head&amp;gt;&lt;br/&gt;  &amp;lt;title&amp;gt;Test page &lt;span&gt;in&lt;/span&gt; http://test.com&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;&amp;lt;body&amp;gt;&lt;br/&gt;  &amp;lt;script&amp;gt; const originAddEventListener = EventTarget.prototype.addEventListener;&lt;br/&gt;    EventTarget.prototype.addEventListener = &lt;span&gt;function&lt;/span&gt; (&lt;span&gt;type&lt;/span&gt;, listener, options) {&lt;br/&gt;      const wrappedListener = &lt;span&gt;function&lt;/span&gt; (...args) {&lt;br/&gt;        try {&lt;br/&gt;          &lt;span&gt;return&lt;/span&gt; listener.apply(this, args);&lt;br/&gt;        }&lt;br/&gt;        catch (err) {&lt;br/&gt;          throw err;&lt;br/&gt;        }&lt;br/&gt;      }&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; originAddEventListener.call(this, &lt;span&gt;type&lt;/span&gt;, wrappedListener, options);&lt;br/&gt;    } &amp;lt;/script&amp;gt;&lt;br/&gt;  &amp;lt;div style=&lt;span&gt;&quot;height: 9999px;&quot;&lt;/span&gt;&amp;gt;http://test.com&amp;lt;/div&amp;gt;&lt;br/&gt;  &amp;lt;script src=&lt;span&gt;&quot;https://yun.dui88.com/tuia/cdn/remote/error_scroll.js&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;&lt;br/&gt;  &amp;lt;script&amp;gt; window.onerror = &lt;span&gt;function&lt;/span&gt; (message, url, line, column, error) {&lt;br/&gt;    console.log(message, url, line, column, error);&lt;br/&gt;  } &amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&amp;lt;/html&amp;gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;大家可以尝试去掉封装EventTarget.prototype.addEventListener的那段代码，感受下。&lt;/p&gt;&lt;h3&gt;上报接口&lt;/h3&gt;&lt;p&gt;为什么不能直接用GET/POST/HEAD请求接口进行上报？&lt;/p&gt;&lt;p&gt;这个比较容易想到原因。一般而言，打点域名都不是当前域名，所以所有的接口请求都会构成跨域。&lt;/p&gt;&lt;p&gt;为什么不能用请求其他的文件资源（js/css/ttf）的方式进行上报？&lt;/p&gt;&lt;p&gt;创建资源节点后只有将对象注入到浏览器DOM树后，浏览器才会实际发送资源请求。而且载入js/css资源还会阻塞页面渲染，影响用户体验。&lt;/p&gt;&lt;p&gt;构造图片打点不仅不用插入DOM，只要在js中new出Image对象就能发起请求，而且还没有阻塞问题，在没有js的浏览器环境中也能通过img标签正常打点。&lt;/p&gt;&lt;p&gt;使用new Image进行接口上报。最后一个问题，同样都是图片，上报时选用了1x1的透明GIF，而不是其他的PNG/JEPG/BMP文件。&lt;/p&gt;&lt;p&gt;首先，1x1像素是最小的合法图片。而且，因为是通过图片打点，所以图片最好是透明的，这样一来不会影响页面本身展示效果，二者表示图片透明只要使用一个二进制位标记图片是透明色即可，不用存储色彩空间数据，可以节约体积。因为需要透明色，所以可以直接排除JEPG。&lt;/p&gt;&lt;p&gt;同样的响应，GIF可以比BMP节约41%的流量，比PNG节约35%的流量。GIF才是最佳选择。&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;可以进行跨域&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不会携带cookie&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不需要等待服务器返回数据&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;使用1\*1的gif&lt;/span&gt;&lt;span&gt;[1]&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;非阻塞加载&lt;/h3&gt;&lt;p&gt;尽量避免SDK的js资源加载影响。&lt;/p&gt;&lt;p&gt;通过先把window.onerror的错误记录进行缓存，然后异步进行SDK的加载，再在SDK里面处理错误上报。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;br/&gt;&amp;lt;html lang=&lt;span&gt;&quot;en&quot;&lt;/span&gt;&amp;gt;&lt;br/&gt;&amp;lt;head&amp;gt;&lt;br/&gt;    &amp;lt;script&amp;gt; (&lt;span&gt;function&lt;/span&gt;(w) {&lt;br/&gt;            w._error_storage_ = [];&lt;br/&gt;            &lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;errorhandler&lt;/span&gt;&lt;/span&gt;(){&lt;br/&gt;                // 用于记录当前的错误 &lt;br/&gt;                w._error_storage_&amp;amp;&amp;amp;w._error_storage_.push([].slice.call(arguments));&lt;br/&gt;            } &lt;br/&gt;            w.addEventListener &amp;amp;&amp;amp; w.addEventListener(&lt;span&gt;&quot;error&quot;&lt;/span&gt;, errorhandler, &lt;span&gt;true&lt;/span&gt;);&lt;br/&gt;            var &lt;span&gt;times&lt;/span&gt; = 3,&lt;br/&gt;            appendScript = &lt;span&gt;function&lt;/span&gt; &lt;span&gt;&lt;span&gt;appendScript&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;                var sc = document.createElement(&lt;span&gt;&quot;script&quot;&lt;/span&gt;);&lt;br/&gt;                sc.async = !0,&lt;br/&gt;                sc.src = &lt;span&gt;&#x27;./build/skyeye.js&#x27;&lt;/span&gt;,  // 取决于你存放的位置&lt;br/&gt;                sc.crossOrigin = &lt;span&gt;&quot;anonymous&quot;&lt;/span&gt;,&lt;br/&gt;                sc.onerror = &lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt;                    &lt;span&gt;times&lt;/span&gt;--,&lt;br/&gt;                    &lt;span&gt;times&lt;/span&gt; &amp;gt; 0 &amp;amp;&amp;amp; setTimeout(appendScript, 1500)&lt;br/&gt;                },&lt;br/&gt;                document.head &amp;amp;&amp;amp; document.head.appendChild(sc);&lt;br/&gt;            };&lt;br/&gt;            setTimeout(appendScript, 1500);&lt;br/&gt;        })(window); &amp;lt;/script&amp;gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;&amp;lt;body&amp;gt;&lt;br/&gt;    &amp;lt;h1&amp;gt;这是一个测试页面(new)&amp;lt;/h1&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&amp;lt;/html&amp;gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;采集聚合端（日志服务器）&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;这个环节，输入是接口接收到的错误记录，输出是有效的数据入库。核心功能需要对数据进行清洗，顺带解决了过多的服务压力。另一个核心功能是对数据进行入库。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;总体流程可以看为错误标识 -&amp;gt; 错误过滤 -&amp;gt; 错误接收 -&amp;gt; 错误存储。&lt;/p&gt;&lt;h3&gt;错误标识（SDK配合）&lt;/h3&gt;&lt;p&gt;聚合之前，我们需要有不同维度标识错误的能力，可以理解为定位单个错误条目，单个错误事件的能力。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;单个错误条目&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;通过date和随机值生成一条对应的错误条目id。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;const errorKey = `&lt;span&gt;${+new Date()}&lt;/span&gt;@&lt;span&gt;${randomString(8)}&lt;/span&gt;`&lt;br/&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; randomString(len) {  &lt;br/&gt;    len = len || 32;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; chars = &lt;span&gt;&#x27;ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678&#x27;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; maxPos = chars.length;&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; &lt;span&gt;pwd&lt;/span&gt; = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;  &lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = 0; i &amp;lt; len; i++) {    &lt;br/&gt;        &lt;span&gt;pwd&lt;/span&gt; += chars.charAt(Math.floor(Math.random() * maxPos));  &lt;br/&gt;    }  &lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;pwd&lt;/span&gt;;&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;单个错误事件&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;首先需要有定位同个错误事件（不同用户，发生相同错误类型、错误信息）的能力。&lt;/p&gt;&lt;p&gt;通过message、colno与lineno进行相加计算阿斯克码值，可以生成错误的errorKey。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;const eventKey = compressString(String(e.message), String(e.colno) + String(e.lineno))&lt;br/&gt;&lt;br/&gt;&lt;span&gt;function&lt;/span&gt; compressString(str, key) {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; chars = &lt;span&gt;&#x27;ABCDEFGHJKMNPQRSTWXYZ&#x27;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!str || !key) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&#x27;null&#x27;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; n = 0,&lt;br/&gt;        m = 0;&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = 0; i &amp;lt; str.length; i++) {&lt;br/&gt;        n += str[i].charCodeAt();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; j = 0; j &amp;lt; key.length; j++) {&lt;br/&gt;        m += key[j].charCodeAt();&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; num = n + &lt;span&gt;&#x27;&#x27;&lt;/span&gt; + key[key.length - 1].charCodeAt() + m + str[str.length - 1].charCodeAt();&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(num) {&lt;br/&gt;        num = num + chars[num[num.length - 1]];&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; num;&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如下图，一个错误事件（事件列表），下属每条即为实际的错误条目。&lt;img data-ratio=&quot;0.5581146223888591&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ictoaEf142mgUEMgeQAjewG2psnYt8uD6PcvpGSicOWZEs02DRT85KuMcOMXg02jvVD2vh9oiccKK2Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1867&quot;/&gt;&lt;/p&gt;&lt;h3&gt;错误过滤（SDK配合）&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;域名过滤&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;过滤本页面script error，可能被webview插入其他js。 &lt;/p&gt;&lt;p&gt;我们只关心自己的远端JS问题，因此做了根据本公司域名进行过滤。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 伪代码&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(!e.filename || !e.filename.match(/^(http|https):\/\/yun./)) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;重复上报&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;怎么避免重复的数据上报？根据errorKey来进行缓存，重复的错误避免上报的次数超过阈值。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 伪代码&lt;br/&gt;&lt;br/&gt;const localStorage = window.localStorage;&lt;br/&gt;const TIMES = 6; // 缓存条数&lt;br/&gt;&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; setItem(key, repeat) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(!key) {&lt;br/&gt;        key = &lt;span&gt;&#x27;unknow&#x27;&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;  &lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (has(key)) {&lt;br/&gt;        const value = getItem(key);&lt;br/&gt;        &lt;br/&gt;       // 核心代码，超过条数，跳出&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (value &amp;gt;= repeat) {&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        storeStorage[key] = {&lt;br/&gt;            value: value + 1,&lt;br/&gt;            time: Date.now()&lt;br/&gt;        }&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        storeStorage[key] = {&lt;br/&gt;            value: 1,&lt;br/&gt;            time: Date.now()&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;h3&gt;错误接收&lt;/h3&gt;&lt;p&gt;在处理接收接口的时候，注意流量的控制，这也是后端开发需要投入最多精力的地方，处理高并发的流量。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;错误记录&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;接收端使用Koa，简单的实现了接收及打印到磁盘。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 伪代码&lt;br/&gt;&lt;br/&gt;module.exports = async ctx =&amp;gt; {&lt;br/&gt;  const { query } = ctx.request;&lt;br/&gt;  &lt;br/&gt;  // 对于字段进行简单check &lt;br/&gt;  check([ &lt;span&gt;&#x27;mobile&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;network&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;ip&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;system&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;ua&#x27;&lt;/span&gt;, ......], query);&lt;br/&gt;&lt;br/&gt;  ctx.type = &lt;span&gt;&#x27;application/json&#x27;&lt;/span&gt;;&lt;br/&gt;  ctx.body = { code: &lt;span&gt;&#x27;1&#x27;&lt;/span&gt;, msg: &lt;span&gt;&#x27;数据上报成功&#x27;&lt;/span&gt; };&lt;br/&gt;&lt;br/&gt;  // 进行日志记录到磁盘的代码，根据自己的日志库选择&lt;br/&gt;}; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;削峰机制&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;比如每秒设置2000的阈值，然后根据请求量减少上限，定时重置上限。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 伪代码&lt;br/&gt;&lt;br/&gt;// 1000ms&lt;br/&gt;const TICK = 1000;&lt;br/&gt;// 1秒上限为2000&lt;br/&gt;const MAX_LIMIT = 2000;&lt;br/&gt;// 每台服务器请求上限值&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; maxLimit = MAX_LIMIT;&lt;br/&gt;&lt;br/&gt;/**&lt;br/&gt; * 启动重置函数&lt;br/&gt; */&lt;br/&gt;const task = () =&amp;gt; {&lt;br/&gt;  setTimeout(() =&amp;gt; {&lt;br/&gt;    maxLimit = MAX_LIMIT;&lt;br/&gt;    task();&lt;br/&gt;  }, TICK);&lt;br/&gt;};&lt;br/&gt;task();&lt;br/&gt;&lt;br/&gt;const check = () =&amp;gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (maxLimit &amp;lt;= 0) {&lt;br/&gt;    throw new Error(&lt;span&gt;&#x27;超过上报次数&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;  maxLimit--;&lt;br/&gt;  // 执行业务代码。。。&lt;br/&gt;}; &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;采样处理&lt;/strong&gt; &lt;/p&gt;&lt;p&gt;超过阈值，还可以进行采样收集。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 只采集 20%&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(Math.random() &amp;lt; 0.2) {&lt;br/&gt;  collect(data)      // 记录错误信息&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;错误存储&lt;/h3&gt;&lt;p&gt;对于打印在了磁盘的日志，我们怎么样才能对于其进行聚合呢，这里得考虑使用存储方案。&lt;/p&gt;&lt;p&gt;一般选择了存储方案后，设置好配置，存储方案就可以通过磁盘定时周期性的获取数据。因此我们需要选择一款存储方案。&lt;/p&gt;&lt;p&gt;对于存储方案，我们对比了日常常见方案，阿里云日志服务 - Log Service（SLS）、ELK（Elastic、Logstash、Kibana）、Hadoop/Hive（将数据存储在 Hadoop，利用 Hive 进行查询） 类方案的对比。&lt;/p&gt;&lt;p&gt;从以下方面进行了对比，最终选择了Log Service，主要考虑为无需搭建，成本低，查询功能满足。&lt;/p&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;功能项&lt;/th&gt;&lt;th&gt;ELK 类系统&lt;/th&gt;&lt;th&gt;Hadoop + Hive&lt;/th&gt;&lt;th&gt;日志服务&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;日志延时&lt;/td&gt;&lt;td&gt;1~60 秒&lt;/td&gt;&lt;td&gt;几分钟~数小时&lt;/td&gt;&lt;td&gt;实时&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;查询延时&lt;/td&gt;&lt;td&gt;小于 1 秒&lt;/td&gt;&lt;td&gt;分钟级&lt;/td&gt;&lt;td&gt;小于 1 秒&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;查询能力&lt;/td&gt;&lt;td&gt;好&lt;/td&gt;&lt;td&gt;好&lt;/td&gt;&lt;td&gt;好&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;扩展性&lt;/td&gt;&lt;td&gt;提前预备机器&lt;/td&gt;&lt;td&gt;提前预备机器&lt;/td&gt;&lt;td&gt;秒级 10 倍扩容&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;成本&lt;/td&gt;&lt;td&gt;较高&lt;/td&gt;&lt;td&gt;较低&lt;/td&gt;&lt;td&gt;很低&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;p&gt;日志延时：日志产生后，多久可查询。查询延时：单位时间扫描数据量。查询能力：关键词查询、条件组合查询、模糊查询、数值比较、上下文查询。扩展性：快速应对百倍流量上涨。成本：每 GB 费用。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;具体API使用，可查看&lt;span&gt;日志服务&lt;/span&gt;&lt;span&gt;[2]&lt;/span&gt;。&lt;/p&gt;&lt;h2&gt;可视分析端（可视化平台）&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;这个环节，输入是接口接收到的错误记录，输出是有效的数据入库。核心功能需要对数据进行清洗，顺带解决了过多的服务压力。另一个核心功能是对数据进行入库。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;主功能&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;这部分主要是产品功能的合理设计，做到小而美，具体的怎么聚合，参考阿里云SLS就可以。&lt;/p&gt;&lt;/blockquote&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首页图表，可选1天、4小时、1小时等等，聚合错误数，根据1天切分24份来聚合。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;首页列表，聚合选中时间内的数据，展示错误文件、错误key、事件数、错误类型、时间、错误信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;错误详情，事件列表、基本信息、设备信息、设备占比图表（见上面事件列表的图）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.563731170336037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ictoaEf142mgUEMgeQAjewGspIzwO4Yt0ekS7Dm6yNnibnzzZqesEN9KianBjofjPvzicAUVwPKj33Sg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1726&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;排行榜&lt;/h3&gt;&lt;p&gt;刚开始做了待处理错误列表、我的错误列表、已解决列表，错误与人没有绑定关系，过于依赖人为主动，需要每个人主动到平台上处理，效果不佳。&lt;/p&gt;&lt;p&gt;后面通过错误作者排行榜，通过钉钉日报来提醒对应人员处理。紧急错误，通过实时告警来责任到人，后面告警会说。&lt;/p&gt;&lt;p&gt;具体原理：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;webpack打包通过git命令把作者和作者邮箱、时间打包在头部。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在可视化服务中，去请求对应的报错url匹配到对应作者，返回给展示端。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.5437710437710438&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ictoaEf142mgUEMgeQAjewGKSUT8vR4ZicjoAAZpIibWN1U2dsvlMsg2w56OqicyOiauv34r3EESf274Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1782&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3&gt;SourceMap&lt;/h3&gt;&lt;p&gt;利用webpack的hidden-source-map构建。与 source-map 相比少了末尾的注释，但 output 目录下的 index.js.map 没有少。线上环境避免source-map泄露。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;webpackJsonp([1],[&lt;br/&gt;  &lt;span&gt;function&lt;/span&gt;(e,t,i){...},&lt;br/&gt;  &lt;span&gt;function&lt;/span&gt;(e,t,i){...},&lt;br/&gt;  &lt;span&gt;function&lt;/span&gt;(e,t,i){...},&lt;br/&gt;  &lt;span&gt;function&lt;/span&gt;(e,t,i){...},&lt;br/&gt;  ...&lt;br/&gt;])&lt;br/&gt;// 这里没有生成&lt;span&gt;source&lt;/span&gt;-map的链接地址 &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根据报错文件的url，根据团队内部约定好的目录和规则，定位之前打包上传的sourceMap地址。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;const sourcemapUrl = (&lt;span&gt;&#x27;xxxfolder/&#x27;&lt;/span&gt; + url + &lt;span&gt;&#x27;xxxHash&#x27;&lt;/span&gt; +&lt;span&gt;&#x27;.map&#x27;&lt;/span&gt;) &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;获取上报的line、column、source，利用第三方库sourceMap进行定位。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;const sourceMap = require(&lt;span&gt;&#x27;source-map&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;// 根据行数获取源文件行数&lt;br/&gt;const getPosition = async(map, rolno, colno) =&amp;gt; {&lt;br/&gt;  const consumer = await new sourceMap.SourceMapConsumer(map)&lt;br/&gt;&lt;br/&gt;  const position = consumer.originalPositionFor({&lt;br/&gt;    line: rolno,&lt;br/&gt;    column: colno&lt;br/&gt;  })&lt;br/&gt;&lt;br/&gt;  position.content = consumer.sourceContentFor(position.source)&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; position&lt;br/&gt;} &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.7139588100686499&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ictoaEf142mgUEMgeQAjewGtV0zpl7qJ1gr84NzzSlfiazASx3ialltRd9v3cVAHrq26GZgQwWQ5P9g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;874&quot;/&gt;感兴趣SourceMap原理的，可以继续深入，&lt;span&gt;SourceMap 与前端异常监控&lt;/span&gt;&lt;span&gt;[3]&lt;/span&gt;。&lt;/p&gt;&lt;h2&gt;错误报警&lt;/h2&gt;&lt;h3&gt;报警设置&lt;/h3&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;每条业务线设置自己的阈值、错误时间跨度，报警轮询间隔&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过钉钉hook报警到对应的群&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过日报形式报出错误作者排行榜&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8761904761904762&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ictoaEf142mgUEMgeQAjewGWY7fJVmdwk2YicIO4ZbK4xzpicSbuywLeSacianoYbQCSbALjRxa1V0dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1680&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;h1&gt;四、扩展&lt;/h1&gt;&lt;h2&gt;行为搜集&lt;/h2&gt;&lt;p&gt;通过搜集用户的操作，可以明显发现错误为什么产生。&lt;img data-ratio=&quot;0.43997485857950974&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ictoaEf142mgUEMgeQAjewGakav3qsnpfbh12mBwdk2WT71VYjXQoe8TvkDLkekV0pkN1lFlUTJMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3182&quot;/&gt;&lt;/p&gt;&lt;h3&gt;分类&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;UI行为：点击、滚动、聚焦/失焦、长按&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;浏览器行为：请求、前进/后退、跳转、新开页面、关闭&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;控制台行为：log、warn、error&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;搜集方式&lt;/h3&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;点击行为&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;使用addEventListener监听全局上的click事件，将事件和DOM元素名字收集。与错误信息一起上报。&lt;/p&gt;&lt;ol start=&quot;2&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;发送请求&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;监听XMLHttpRequest的onreadystatechange回调函数&lt;/p&gt;&lt;ol start=&quot;3&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;页面跳转&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;监听window.onpopstate，页面进行跳转时会触发。&lt;/p&gt;&lt;ol start=&quot;4&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;控制台行为&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;重写console对象的info等方法。&lt;/p&gt;&lt;p&gt;有兴趣可以参考&lt;span&gt;行为监控&lt;/span&gt;&lt;span&gt;[4]&lt;/span&gt;。&lt;/p&gt;&lt;h2&gt;遇到的问题&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;由于涉及到一些隐私，下述会做脱敏处理。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3&gt;空日志问题&lt;/h3&gt;&lt;p&gt;上线灰度运行后，我们发现SLS日志存在一些空日志😢 ，🦢，这是发生了啥？&lt;/p&gt;&lt;p&gt;首先我们回忆下这个链路上有哪些环节可能存在问题。&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.1370757180156658&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ictoaEf142mgUEMgeQAjewGrXMjXjXFrKCib0ibGFb2ibyss2A6icFVnrAOHianEmuovYt2flBC9WNpFvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;766&quot;/&gt;&lt;figcaption&gt;image.png&lt;/figcaption&gt;&lt;/figure&gt;&lt;p&gt;排查链路，SLS采集环节之前有磁盘日志收集，服务端接收，SDK上报，那我们依次排查。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3598183881952327&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/dFTfMt0114ictoaEf142mgUEMgeQAjewGfQSuT12cJ8GdBiaPqGq7WgGeCMjZR3UHkd6pPBmAyVNibTDFpoxqjWgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1762&quot;/&gt;往前一步，发现磁盘日志就已经存在空日志，那剩下就得看一下接收端、SDK端。&lt;/p&gt;&lt;p&gt;开始利用控制变量法，先在SDK端进行空判断，防止空日志上报。结果：发现无效😅。&lt;/p&gt;&lt;p&gt;再继续对Node接收端处理，对接收到的数据进行判空，如果为空不进行日志打印，结果：依然无效😳。&lt;/p&gt;&lt;p&gt;所以开始定位是不是日志打印本身出了什么问题？研究了下日志第三方日志库的API，进行了各种尝试，发现依旧没用，我脸黑了🌚。&lt;/p&gt;&lt;p&gt;什么情况，“遇事不决”看源码。排查下日志库源码存在什么问题。对于源码的主调用流程走了一遍，并没有发现什么问题，一头雾水🙃。&lt;/p&gt;&lt;p&gt;整个代码逻辑很正常，这让我们开始怀疑难道是数据的问题，于是开始缩减上报的字段，最终定义为了一个字段。发现上线后没有问题了😢。&lt;/p&gt;&lt;p&gt;难道是有些字段存储的数据过长导致的？但从代码逻辑、流程日志中并没有反应这个错误的可能性。&lt;/p&gt;&lt;p&gt;因此我们利用二分法，二分地增加字段，最终定位到了某个字段。如果存在某个字段上报就会出现问题。这很出乎人的意料。&lt;/p&gt;&lt;p&gt;我们再想了下链路，除了日志库，其他代码基本都是我们自己的逻辑，所以对日志库进行了排查，怀疑其对某个字段做了什么处理。&lt;/p&gt;&lt;p&gt;于是通过搜索，定位到了日志库在仆从模式（可以了解下Node的主从模式）下会使用某个字段来表意，导致和我们上报的字段冲突，因此丢失了🤪。&lt;/p&gt;&lt;h3&gt;日志丢失问题&lt;/h3&gt;&lt;p&gt;解决了上个问题，开心了，一股成就感涌上心头。但马上就被当头一棒，我发现我高兴的太早了🤮。&lt;/p&gt;&lt;p&gt;团队的某同学在本地测试的时候，由于玩的很开心，一直去刷新页面去上报当前页面的错误。但他发现本地上报的条数和实际日志服务里的条数对不上，日志服务里的少了很多。&lt;/p&gt;&lt;p&gt;由于之前自身刚毕业时候做过2年多后端开发，对于IO操作丢失数据还是有点敏感。直觉上就感觉可能是多进程方向的问题。怀疑是多进程导致的文件死锁问题。&lt;/p&gt;&lt;p&gt;那我们去掉多线程，通过单线程，我们去重复原先复现问题的步骤。发现没有遗漏🤭。&lt;/p&gt;&lt;p&gt;我们发现能进行配置Cluster（主从模式）的地方有两处，日志库和部署工具。&lt;/p&gt;&lt;p&gt;观察日志库默认使用的主从进程模式，而部署工具没有主从模式的概念，势必会导致写入IO的死锁问题，导致日志丢失。于是在想社区有没有可以有解决此问题的第三方支持。&lt;/p&gt;&lt;p&gt;然后通过谷歌搜索，很快就找到了对应的第三方库，它能提供主人进程和仆从进程之间的消息沟通。原理是主人进程负责所有消息写入log，而仆从进程通过消息传递给主人进程。&lt;/p&gt;&lt;h1&gt;五、推荐阅读及引用&lt;/h1&gt;&lt;p&gt;处理异常&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;如何优雅处理前端异常？&lt;/span&gt;&lt;span&gt;[5]&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;source-map&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;SourceMap 与前端异常监控&lt;/span&gt;&lt;span&gt;[6]&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;React错误&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;React，优雅的捕获异常&lt;/span&gt;&lt;span&gt;[7]&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;Script Error&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;Capture and report JavaScript errors with window.onerror | Product Blog • Sentry&lt;/span&gt;&lt;span&gt;[8]&lt;/span&gt; &lt;span&gt;What the heck is &quot;Script error&quot;? | Product Blog • Sentry&lt;/span&gt;&lt;span&gt;[9]&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;整体&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;前端搞监控|Allan - 如何实现一套多端错误监控平台&lt;/span&gt;&lt;span&gt;[10]&lt;/span&gt; &lt;span&gt;一步一步搭建前端监控系统：JS错误监控篇&lt;/span&gt;&lt;span&gt;[11]&lt;/span&gt; &lt;span&gt;撸一个前端监控系统&lt;/span&gt;&lt;span&gt;[12]&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;Mzg2NDAzMjE5NQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/aDoYvepE5x2LRUFlGccgWM7pibyfHFibKOp7r5ecialTR0hwcUdfXhYAPibUbYJ0VibnZS27BolMNukPspZx3ibUDiblg/0?wx_fmt=png&quot; data-nickname=&quot;code秘密花园&quot; data-alias=&quot;code_mmhy&quot; data-signature=&quot;一个优质的前端号，基础、框架、算法、项目、面试...   总有你想要的。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f960461812c19bf64c1b44d91dee5728</guid>
<title>如何实现敏捷赋能？</title>
<link>https://toutiao.io/k/m4bmhfx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content&quot; itemprop=&quot;articleBody&quot;&gt;&amp;#13;
&lt;p&gt;企业的敏捷转型，由于涉及转变企业全体成员的工作习惯，提升敏捷实践能力，所以本质上属于教育和赋能。&lt;/p&gt;
&lt;p&gt;而很多企业在做敏捷赋能时，虽然怀着完美的初衷，却好心办坏事。就如同下面三个完美搞砸敏捷赋能的案例所表现的那样。&lt;/p&gt;
&lt;h4&gt;完美搞砸案例一，用培训推广最佳实践，但学员用不上。&lt;/h4&gt;
&lt;p&gt;某企业为一线开发团队安排了10门敏捷技术实践培训和编程操练课程，涉及重构、自动化测试、持续集成和整洁架构。这些可都是业界所推崇的最佳实践。但在练完根据《重构》第2版第一章所改编的代码重构编程操练后，一位听课学员对讲师说，”这些重构手法固然很好，但在实际工作中，开发人员一般不会为了消除代码腐臭，而做这些重构。你所讲的通过决策树来设计测试用例，开发人员也都知道，但他们一般也不会使用。“或许有些开发人员还没有意识到重构和自动化测试的重要性，此时给他们讲这些，这就好比给一个口渴的人一个馒头，解决不了他的问题。&lt;/p&gt;
&lt;h4&gt;完美搞砸案例二，集中性地推广某实践，但很快倒胃口。&lt;/h4&gt;
&lt;p&gt;某企业领导认为自动化测试很重要，于是相关部门安排了为期一年的自动化测试集中推广。推广活动包括一线开发人员观看相关视频课程，编写并发布了组织级自动化测试实践指南，每月组织一次自动化测试收益分享，设计了推广活动的宣传口号“新八零”（指新增代码测试覆盖率要向80%看齐），利用企业内部研发效能工具平台统计自动化测试覆盖率，并设置了组织级自动化测试达标评判指标和进度。这样做了几个月后，发现有人开始抱怨推广活动给他们带来了额外的工作量，在内部论坛里大量吐槽评判指标不合理，参加每月自动化测试收益分享的人数越来越少。这就好比每天吃妈妈做的红烧肉，连续吃一年，吃到后来感觉就是在受罪。&lt;/p&gt;
&lt;h4&gt;完美搞砸案例三，靠成熟度评级来推动，但过后删测试。&lt;/h4&gt;
&lt;p&gt;某企业领导认为一线开发团队实践敏捷技术实践缺乏动力，于是想借助第三方的DevOps能力成熟度评估来促进敏捷实践的落地。为了在达标中获得好成绩，某团队在达标考核前2周，抽调8人加班加点，在原先500个自动化测试的基础上，又增加了2000个自动化测试。但在达标考核的前夜，将这2500个测试运行在流水线上后，发现即使运行了2个多小时，这些测试还没跑完。最后只好将这2000个测试从流水线上移除。而当该企业通过了达标后，为了加快流水线的运行速度，开发人员开始在流水线上移除更多的自动化测试。&lt;/p&gt;
&lt;p&gt;上述三个案例，都属于不顾一线开发团队具体情况，“拍脑袋”式推广的做法。&lt;/p&gt;
&lt;p&gt;“拍脑袋”式推广的不祥之兆在于缺乏用户思维。即在敏捷转型的组织内，规模化推广业界敏捷最佳实践时，缺乏为一线开发人员创造价值的心态，不针对他们的具体痛点，不因人、因地、因时制宜，不做频繁小批的迭代复盘和调整，只是一味地推广未经在本组织内验证过的业界最佳实践，从而完美搞砸敏捷赋能。&lt;/p&gt;
&lt;p&gt;“拍脑袋”式推广的后果，就是浪费严重。因为赋能内容在工作中“用不上”，内部教练与团队成员对敏捷赋能缺乏兴趣，而仅仅应付差使，等风头过后就恢复原样，造成赋能投入的大量浪费。&lt;/p&gt;
&lt;p&gt;那么该如何救场被完美搞砸的敏捷赋能呢？要持经达变地为一线开发人员创造价值。经书一般不会随意修改，持经就是说要坚持良好的敏捷实践原则。而一旦面临一线开发团队具体的痛点时，要在“持经”的基础上随机应变，根据团队具体情况灵调整，从而做到“达变”。&lt;/p&gt;
&lt;p&gt;要想在敏捷赋能时做到“持经达变”，可以参考三个原则：用户思维原则、赋能假说原则和分享警示原则。&lt;/p&gt;
&lt;h3&gt;用户思维原则&lt;/h3&gt;
&lt;h4&gt;用户思维要运用&lt;/h4&gt;
&lt;p&gt;要针对一线开发人员的痛点创建若干实践社区，作为用户思维的基础，并将其中的一线开发人员视作敏捷赋能的用户。&lt;/p&gt;
&lt;p&gt;要运用电梯演讲、用户画像、用户目标等技术，明确敏捷赋能要解决的用户问题。&lt;/p&gt;
&lt;h4&gt;赋能让人听进去&lt;/h4&gt;
&lt;p&gt;想要敏捷赋能产生成效，离不开一线开发人员。要让他们改变工作习惯，需要抱着为他们分忧的心态来进行赋能。与他们沟通时，要站在他们的立场，使用他们能听进去的方式来讲话。比如，将“要为关键业务逻辑编写自动化测试”，改为“本来项目进度就很紧张了，但bug所造成的返工，会导致加班，伤害身体。而为容易出错的业务逻辑添加开卡、验卡和自动化测试等环节，会有效减少返工。”&lt;/p&gt;
&lt;h4&gt;全部角色做赋能&lt;/h4&gt;
&lt;p&gt;软件产品的价值会流经业务、开发、测试、运维等人员之手。而每个角色的研发效能和质量内建，都会决定端到端的交货时长和产品质量，所以需要对价值流经的所有角色进行敏捷赋能。&lt;/p&gt;
&lt;h4&gt;实现端到端限流&lt;/h4&gt;
&lt;p&gt;当双十一激增的用户访问量，逼近电商网站的最大负荷（已经使用了容量伸缩机制）时，要想让网站能继续提供服务，唯一的方法就是对用户请求限流，能继续处理的请求接着处理，超出处理能力的请求就一一谢绝，这样才不至于压垮电商网站。对于软件开发团队也同理，当技术债或祖传代码中所积累的毒素，快要达到开发效能崩溃的临界值时，就需要从业务上游开始，进行端到端全链路的限流，减少甚至停止开发新需求，给开发团队留出清除代码毒素的带宽。&lt;/p&gt;
&lt;h3&gt;赋能假说原则&lt;/h3&gt;
&lt;h4&gt;心态接受复杂性&lt;/h4&gt;
&lt;p&gt;Ross Ashby在1958年所提出的“&lt;a href=&quot;http://pespmc1.vub.ac.be/REQVAR.html&quot;&gt;必要多样性法则&lt;/a&gt;”指出，“对于能够完全控制系统B的系统A，必须至少与系统B一样复杂。”要想用软件实现日益复杂的业务，相关的软件开发过程，必然是一个包含大量组件及其关联关系的复杂系统，无法将其简化为简单系统。所以，要从心态上接受软件开发过程是复杂系统的事实，接受其“事与愿违”和“难以预测”的特点。&lt;/p&gt;
&lt;h4&gt;赋能计划即假说&lt;/h4&gt;
&lt;p&gt;既然软件开发过程“事与愿违”和“难以预测”，那么对其中的人员进行赋能前所制定的赋能计划，就属于假说。比如，“一线开发人员通过为业务主流程编写单元测试，并将其作为回归测试运行在流水线上，以减少返工”。这个假说既可能完全成立，也可能部分成立，也有可能完全不成立，依这个一线开发团队具体情况而定。&lt;/p&gt;
&lt;h4&gt;假说验证靠实验&lt;/h4&gt;
&lt;p&gt;验证敏捷赋能假说是否成立的唯一手段，就是做实验。由于实验可能失败，所以要在规划实验时，将实验的范围限制在可控的范围内。&lt;/p&gt;
&lt;h4&gt;失误难免可回退&lt;/h4&gt;
&lt;p&gt;由于软件开发过程是一个“事与愿违”和“难以预测”的复杂系统，所以个人的大脑无法对整个复杂系统完整建模，当对这个过程进行敏捷赋能时，出现失误在所难免。为此应该为赋能过程设计“失误可回退”的机制，一旦发现赋能假说不成立，就可快速回退到之前的状态。&lt;/p&gt;
&lt;h4&gt;指标举措要权变&lt;/h4&gt;
&lt;p&gt;每个开发小组的开发过程，会根据其所开发的软件产品的生命周期的阶段的不同而不同。比如，一个正处于开发阶段的产品，后端有5位开发人员协作开发，那么每天做半小时集体代码评审就有意义。但对于正处于维护阶段的软件产品，维护人员只有一人，此时就无法实现集体代码评审。所以敏捷赋能的指标和举措，都要根据开发小组的具体情况，作出权变，不可一刀切。&lt;/p&gt;
&lt;h4&gt;小步迭代常改进&lt;/h4&gt;
&lt;p&gt;因为敏捷赋能是个复杂系统，赋能计划即假说，所以敏捷赋能规划，不可一下就做一年的计划，而应该用小步迭代的方式，不断根据反馈进行改进。&lt;/p&gt;
&lt;h4&gt;优选返工与瓶颈&lt;/h4&gt;
&lt;p&gt;当在进行敏捷赋能迭代时，由于在迭代周期内只能小批量地做实验，所以确定赋能优先级十分关键，因为这决定了本次迭代要做哪些赋能。根据约束理论，优先赋能的环节，应该是价值流的最大瓶颈。而在做基于遗留系统的软件开发维护工作时，返工的危害会大于瓶颈。因为返工不仅会耽误时间，还会让价值流再次穿过瓶颈，让本以缓慢的软件开发过程雪上加霜。所以，敏捷赋能的迭代待办项，要优选返工最多的环节进行赋能，其次是对瓶颈进行赋能。&lt;/p&gt;
&lt;h4&gt;质量内建可观测&lt;/h4&gt;
&lt;p&gt;要想确定存在返工与瓶颈问题的环节，需要确定指标，以观测质量内建的过程。&lt;/p&gt;
&lt;h4&gt;指标仅为自提升&lt;/h4&gt;
&lt;p&gt;由于人员会根据指标做出一些急功近利的调整，从而花费最小的代价来达成指标，所以指标一旦用于控制和绩效考核，就会变得不再可靠。要想让指标发挥作用，不能将其与绩效考核直接挂钩，也不可做跨团队的横向对比，而仅用于开发小组自身的改进。&lt;/p&gt;
&lt;h3&gt;分享警示原则&lt;/h3&gt;
&lt;h4&gt;痛点拉动做培训&lt;/h4&gt;
&lt;p&gt;培训分两种。一种是相对抽象的理念普及，另一种是更加落地的实际操练。要想让这两类培训获得更好的成效，需要先基于用户思维，了解听众实际工作中的痛点，再针对痛点来定制培训内容。&lt;/p&gt;
&lt;h4&gt;频繁分享警示牌&lt;/h4&gt;
&lt;p&gt;要想应对复杂系统的不确定性，除了接受复杂性，做到失误可回退之外，还要做到树立警示牌，将前人所踩的坑进行分析和沉淀，并分享给后人，让后人不再重蹈覆辙。&lt;/p&gt;
&lt;p&gt;“拍脑袋”式的敏捷赋能，虽然初衷良好，但会好心办坏事。既解决不了一线开发团队的痛点，也会因形式主义造成大量浪费。要想扭转这一局面，需要本着用户思维原则、赋能假说原则和分享警示原则，持经达变地为一线开发团队创造价值。&lt;/p&gt;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4edd105da48af8b04a08aaa517c1664d</guid>
<title>数据中台架构解析及未来展望</title>
<link>https://toutiao.io/k/q6nbcxg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>