<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3d118c2e31438a47014e34138dfd3c44</guid>
<title>精通那么多技术，你为何还是受不到重用？| 码农周刊第 324 期</title>
<link>https://toutiao.io/k/3ininot</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;精通那么多技术，你为何还是受不到重用？| 码农周刊第 324 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第324期（2020-11-11）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3240&quot; target=&quot;_blank&quot;&gt;双十一，买它买它买它！&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3240&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_324.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;基于 Kubernetes 的云原生批量计算平台&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;对以 Transformer 为基础的序列特征提取器 (Encoder) 和自回归的序列解码器 (Decoder) 做了深度优化&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;技术雷达是 ThoughtWorks 每半年发布一次的技术趋势报告&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;这是德勤第 11 年发布技术趋势年度报告&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;个人经历&lt;/p&gt;
        
        &lt;p&gt;你知道吗？&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验总结&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;欢迎探讨&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;图文并茂&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;欢迎探讨&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;适合入门&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        
        &lt;p&gt;深入探讨&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;基于 Swift 推出的函数响应框架&lt;/p&gt;
        
        &lt;p&gt;使用 JavaScript 来自动化 iOS&lt;/p&gt;
        
        &lt;p&gt;系列文章&lt;/p&gt;
        
        &lt;p&gt;实践总结&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;细致讲解&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;简明介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;试试吧&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;7年工作经验，技术总监&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 451915 即可&lt;/p&gt;
        
        &lt;p&gt;坚持原创，持续分享技术，包括但不限于：分布式、微服务架构，spring cloud、Dubbo微服务框架，Java核心技术，Redis缓存、Kafka消息队列中间件等。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 450130 即可&lt;/p&gt;
        
        &lt;p&gt;一个工作10年的程序猿，分享技术干货及内心的声音。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 413084 即可&lt;/p&gt;
        
        &lt;p&gt;详解数据结构与算法&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 142771 即可&lt;/p&gt;
        
        &lt;p&gt;Web前端、服务端、小程序、App、学习资料、工具、资讯&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 125297 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=324&amp;amp;aid=20115&amp;amp;url=http%3A%2F%2Fproduct.dangdang.com%2F29132383.html&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/book_324.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;一个技术总监的忠告&lt;/p&gt;
        
        &lt;p&gt;写作不易&lt;/p&gt;
        
        &lt;p&gt;同理心&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1908bde196859946ffbfc4e846c47233</guid>
<title>[推荐] 为什么 Go 占用那么多的虚拟内存？</title>
<link>https://toutiao.io/k/0zyeufv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前段时间，某同学说某服务的容器因为超出内存限制，不断地重启，问我们是不是有内存泄露，赶紧排查，然后解决掉，省的出问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们大为震惊，赶紧查看监控+报警系统和性能分析，发现应用指标压根就不高，不像有泄露的样子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题到底是出在哪里了呢，我们进入某个容器里查看了 &lt;code&gt;top&lt;/code&gt; 的系统指标：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;PID       VSZ    RSS   ... COMMAND&lt;br/&gt;67459     2007m  136m  ... ./eddycjy-server&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看上去也没什么大开销的东西，就一个 Go 进程？就这？&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/KVl0giak5ib4htibhubl5wtrrJqdexvxTbXrZYlg4HFnHt2cfNvp73aUaBHuM3ic0ficGHOTGuWEGb4CHC67kWJ2JVQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再定眼一看，某同学就说 VSZ 那么高，而某云上的容器内存指标居然恰好和 VSZ 的值相接近，因此就怀疑是不是 VSZ 所导致的，觉得存在一定的关联关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个猜测的结果到底是否正确呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基础知识&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇文章将&lt;strong&gt;主要围绕 Go 进程的 VSZ 来进行剖析&lt;/strong&gt;，看看到底它为什么那么 &quot;高&quot;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一节为前置的补充知识，大家可按顺序阅读。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是 VSZ&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VSZ 是该进程所能使用的虚拟内存总大小，它包括进程可以访问的所有内存，其中包括了被换出的内存（Swap）、已分配但未使用的内存以及来自共享库的内存。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;为什么要虚拟内存&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前面我们有了解到 VSZ 其实就是该进程的虚拟内存总大小，那&lt;strong&gt;如果我们想了解 VSZ 的话，那我们得先了解 “为什么要虚拟内存？”&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本质上来讲，在一个系统中的进程是与其他进程共享 CPU 和主存资源的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此在现代的操作系统中，多进程的使用非常的常见，如果太多的进程需要太多的内存，在没有虚拟内存的情况下，物理内存很可能会不够用，就会导致其中有些任务无法运行，更甚至会出现一些很奇怪的现象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如 “某一个进程不小心写了另一个进程使用的内存”，就会造成内存破坏，因此虚拟内存是非常重要的一个媒介。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;虚拟内存包含了什么&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虚拟内存，又分为：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每一个进程的虚拟内存都是独立的， 内部结构如下图所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7496902106567535&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4htibhubl5wtrrJqdexvxTbXPV2vnCH3W9YyUKcjhsn7vSTWhh3TF6CQU2ianKmRq5fQbvdibYLzUTkA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1614&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在内核虚拟内存中，包含了内核中的代码和数据结构。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内核虚拟内存中的某些区域会被映射到所有进程共享的物理页面中去，因此你会看到 ”内核虚拟内存“ 中实际上是包含了 ”物理内存“ 的，它们两者存在映射关系。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而从应用场景上来讲，每个进程也会去共享内核的代码和全局数据结构，因此就会被映射到所有进程的物理页面中去。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7496902106567535&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4htibhubl5wtrrJqdexvxTbXNH1leIy1liaqzHmMH75W1GcibLpUUH8FwZhTFYEl2IaG1eRMyPkFlEUg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1614&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;虚拟内存的重要能力&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更有效地管理内存并且减少出错，现代系统提供了一种对主存的抽象概念，也就是今天的主角，叫做虚拟内存（VM）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虚拟内存是硬件异常、硬件地址翻译、主存、磁盘文件和内核软件交互的地方，它为每个进程提供了一个大的、一致的和私有的地址空间，虚拟内存提供了三个重要的能力：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，通过这种方式，它高效地使用了主存。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;它为每个进程提供了一致的地址空间，从而简化了内存管理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;它保护了每个进程的地址空间不被其他进程破坏。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小结&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面发散的可能比较多，简单来讲，对于本文我们重点关注这些知识点，如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;虚拟内存它是有各式各样内存交互的地方，它包含的不仅仅是 &quot;自己&quot;，&lt;strong&gt;而在本文中，我们只需要关注 VSZ，也就是进程虚拟内存，它包含了你的代码、数据、堆、栈段和共享库&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;虚拟内存作为内存保护的工具，能够保证进程之间的内存空间独立，不受其他进程的影响，因此每一个进程的 VSZ 大小都不一样，互不影响。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;虚拟内存的存在，系统给各进程分配的内存之和是可以大于实际可用的物理内存的，因此你也会发现你进程的物理内存总是比虚拟内存低的多的多。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;排查问题&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在了解了基础知识后，我们正式开始排查问题，第一步我们先编写一个测试程序，看看没有什么业务逻辑的 Go 程序，它初始的 VSZ 是怎么样的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;测试&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; r := gin.Default()&lt;br/&gt; r.GET(&lt;span&gt;&quot;/ping&quot;&lt;/span&gt;, &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(c *gin.Context)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  c.JSON(&lt;span&gt;200&lt;/span&gt;, gin.H{&lt;br/&gt;   &lt;span&gt;&quot;message&quot;&lt;/span&gt;: &lt;span&gt;&quot;pong&quot;&lt;/span&gt;,&lt;br/&gt;  })&lt;br/&gt; })&lt;br/&gt; r.Run(&lt;span&gt;&quot;:8001&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看进程情况：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;$&lt;/span&gt;&lt;span&gt; ps aux 67459&lt;/span&gt;&lt;br/&gt;USER      PID  %CPU %MEM      VSZ    RSS   ...&lt;br/&gt;eddycjy 67459   0.0  0.0  4297048    960   ...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从结果上来看，VSZ 为 4297048K，也就是 4G 左右，咋一眼看过去还是挺吓人的，明明没有什么业务逻辑，但是为什么那么高呢，真是令人感到好奇。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;确认有没有泄露&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在未知的情况下，我们可以首先看下 &lt;code&gt;runtime.MemStats&lt;/code&gt; 和 &lt;code&gt;pprof&lt;/code&gt;，确定应用到底有没有泄露。不过我们这块是演示程序，什么业务逻辑都没有，因此可以确定和应用没有直接关系。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;# runtime.MemStats&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Alloc = 1298568&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# TotalAlloc = 1298568&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Sys = 71893240&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Lookups = 0&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Mallocs = 10013&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Frees = 834&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# HeapAlloc = 1298568&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# HeapSys = 66551808&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# HeapIdle = 64012288&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# HeapInuse = 2539520&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# HeapReleased = 64012288&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# HeapObjects = 9179&lt;/span&gt;&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Go FAQ&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着我第一反应是去翻了 Go FAQ（因为看到过，有印象），其问题为 &quot;Why does my Go process use so much virtual memory?&quot;，回答如下：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;The Go memory allocator reserves a large region of virtual memory as an arena for allocations. This virtual memory is local to the specific Go process; the reservation does not deprive other processes of memory.&lt;/p&gt;&lt;p&gt;To find the amount of actual memory allocated to a Go process, use the Unix top command and consult the RES (Linux) or RSIZE (macOS) columns.&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个 FAQ 是在 2012 年 10 月 提交 的，这么多年了也没有更进一步的说明，再翻了 issues 和 forum，一些关闭掉的 issue 都指向了 FAQ，这显然无法满足我的求知欲，因此我继续往下探索，看看里面到底都摆了些什么。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;查看内存映射&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，我们有提到进程虚拟内存，主要包含了你的代码、数据、堆、栈段和共享库，那初步怀疑是不是进程做了什么内存映射，导致了大量的内存空间被保留呢，为了确定这一点，我们通过如下命令去排查：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ vmmap --wide 67459&lt;br/&gt;...&lt;br/&gt;==== Non-writable regions for process 67459&lt;br/&gt;REGION TYPE                      START - END             [ VSIZE  RSDNT  DIRTY   SWAP] PRT/MAX SHRMOD PURGE    REGION DETAIL&lt;br/&gt;__TEXT                 00000001065ff000-000000010667b000 [  496K   492K     0K     0K] r-x/rwx SM=COW          /bin/zsh&lt;br/&gt;__LINKEDIT             0000000106687000-0000000106699000 [   72K    44K     0K     0K] r--/rwx SM=COW          /bin/zsh&lt;br/&gt;MALLOC metadata        000000010669b000-000000010669c000 [    4K     4K     4K     0K] r--/rwx SM=COW          DefaultMallocZone_0x10669b000 zone structure&lt;br/&gt;...&lt;br/&gt;__TEXT                 00007fff76c31000-00007fff76c5f000 [  184K   168K     0K     0K] r-x/r-x SM=COW          /usr/lib/system/libxpc.dylib&lt;br/&gt;__LINKEDIT             00007fffe7232000-00007ffff32cb000 [192.6M  17.4M     0K     0K] r--/r-- SM=COW          dyld shared cache combined __LINKEDIT&lt;br/&gt;...        &lt;br/&gt;&lt;br/&gt;==== Writable regions for process 67459&lt;br/&gt;REGION TYPE                      START - END             [ VSIZE  RSDNT  DIRTY   SWAP] PRT/MAX SHRMOD PURGE    REGION DETAIL&lt;br/&gt;__DATA                 000000010667b000-0000000106682000 [   28K    28K    28K     0K] rw-/rwx SM=COW          /bin/zsh&lt;br/&gt;...   &lt;br/&gt;__DATA                 0000000106716000-000000010671e000 [   32K    28K    28K     4K] rw-/rwx SM=COW          /usr/lib/zsh/5.3/zsh/zle.so&lt;br/&gt;__DATA                 000000010671e000-000000010671f000 [    4K     4K     4K     0K] rw-/rwx SM=COW          /usr/lib/zsh/5.3/zsh/zle.so&lt;br/&gt;__DATA                 0000000106745000-0000000106747000 [    8K     8K     8K     0K] rw-/rwx SM=COW          /usr/lib/zsh/5.3/zsh/complete.so&lt;br/&gt;__DATA                 000000010675a000-000000010675b000 [    4K     4K     4K     0K] rw-&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这块主要是利用 macOS 的 &lt;code&gt;vmmap&lt;/code&gt; 命令去查看内存映射情况，这样就可以知道这个进程的内存映射情况，从输出分析来看，&lt;strong&gt;这些关联共享库占用的空间并不大，导致 VSZ 过高的根本原因不在共享库和二进制文件上，但是并没有发现大量保留内存空间的行为，这是一个问题点&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注：若是 Linux 系统，可使用 &lt;code&gt;cat /proc/PID/maps&lt;/code&gt; 或 &lt;code&gt;cat /proc/PID/smaps&lt;/code&gt; 查看。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;查看系统调用&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然在内存映射中，我们没有明确的看到保留内存空间的行为，那我们接下来看看该进程的系统调用，确定一下它是否存在内存操作的行为，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;$ sudo dtruss -a ./awesomeProject&lt;br/&gt;...&lt;br/&gt; 4374/0x206a2:     15620       6      3 mprotect(0x1BC4000, 0x1000, 0x0)   = 0 0&lt;br/&gt;...&lt;br/&gt; 4374/0x206a2:     15781       9      4 sysctl([CTL_HW, 3, 0, 0, 0, 0] (2), 0x7FFEEFBFFA64, 0x7FFEEFBFFA68, 0x0, 0x0)   = 0 0&lt;br/&gt; 4374/0x206a2:     15783       3      1 sysctl([CTL_HW, 7, 0, 0, 0, 0] (2), 0x7FFEEFBFFA64, 0x7FFEEFBFFA68, 0x0, 0x0)   = 0 0&lt;br/&gt; 4374/0x206a2:     15899       7      2 mmap(0x0, 0x40000, 0x3, 0x1002, 0xFFFFFFFFFFFFFFFF, 0x0)   = 0x4000000 0&lt;br/&gt; 4374/0x206a2:     15930       3      1 mmap(0xC000000000, 0x4000000, 0x0, 0x1002, 0xFFFFFFFFFFFFFFFF, 0x0)   = 0xC000000000 0&lt;br/&gt; 4374/0x206a2:     15934       4      2 mmap(0xC000000000, 0x4000000, 0x3, 0x1012, 0xFFFFFFFFFFFFFFFF, 0x0)   = 0xC000000000 0&lt;br/&gt; 4374/0x206a2:     15936       2      0 mmap(0x0, 0x2000000, 0x3, 0x1002, 0xFFFFFFFFFFFFFFFF, 0x0)   = 0x59B7000 0&lt;br/&gt; 4374/0x206a2:     15942       2      0 mmap(0x0, 0x210800, 0x3, 0x1002, 0xFFFFFFFFFFFFFFFF, 0x0)   = 0x4040000 0&lt;br/&gt; 4374/0x206a2:     15947       2      0 mmap(0x0, 0x10000, 0x3, 0x1002, 0xFFFFFFFFFFFFFFFF, 0x0)   = 0x1BD0000 0&lt;br/&gt; 4374/0x206a2:     15993       3      0 madvise(0xC000000000, 0x2000, 0x8)   = 0 0&lt;br/&gt; 4374/0x206a2:     16004       2      0 mmap(0x0, 0x10000, 0x3, 0x1002, 0xFFFFFFFFFFFFFFFF, 0x0)   = 0x1BE0000 0&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这小节中，我们通过 macOS 的 &lt;code&gt;dtruss&lt;/code&gt; 命令监听并查看了运行这个程序所进行的所有系统调用，发现了与内存管理有一定关系的方法如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;mmap：创建一个新的虚拟内存区域，但这里需要注意，&lt;strong&gt;就是当系统调用 mmap 时，它只是从虚拟内存中申请了一段空间出来，并不会去分配和映射真实的物理内存，而当你访问这段空间的时候，才会在当前时间真正的去分配物理内存&lt;/strong&gt;。那么对应到我们实际应用的进程中，那就是 VSZ 的增长后，而该内存空间又未正式使用的话，物理内存是不会有增长的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;madvise：提供有关使用内存的建议，例如：MADV_NORMAL、MADV_RANDOM、MADV_SEQUENTIAL、MADV_WILLNEED、MADV_DONTNEED 等等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;mprotect：设置内存区域的保护情况，例如：PROT_NONE、PROT_READ、PROT_WRITE、PROT_EXEC、PROT_SEM、PROT_SAO、PROT_GROWSUP、PROT_GROWSDOWN 等等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sysctl：在内核运行时动态地修改内核的运行参数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在此比较可疑的是 &lt;code&gt;mmap&lt;/code&gt; 方法，它在 &lt;code&gt;dtruss&lt;/code&gt; 的最终统计中一共调用了 10 余次，我们可以相信它在 Go Runtime 的时候进行了大量的虚拟内存申请。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再接着往下看，看看到底是在什么阶段进行了虚拟内存空间的申请。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注：若是 Linux 系统，可使用 &lt;code&gt;strace&lt;/code&gt; 命令。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;查看 Go Runtime&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;启动流程&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上述的分析，我们可以知道在 Go 程序启动的时候 VSZ 就已经不低了，并且确定不是共享库等的原因，且程序在启动时系统调用确实存在 &lt;code&gt;mmap&lt;/code&gt; 等方法的调用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们可以充分怀疑 Go 在初始化阶段就保留了该内存空间。那我们第一步要做的就是查看一下 Go 的引导启动流程，看看是在哪里申请的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;引导过程如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;graph TD&lt;br/&gt;A(rt0_darwin_amd64.s:8&amp;lt;br/&amp;gt;_rt0_amd64_darwin) --&amp;gt;|JMP| B(asm_amd64.s:15&amp;lt;br/&amp;gt;_rt0_amd64)&lt;br/&gt;B --&amp;gt; |JMP|C(asm_amd64.s:87&amp;lt;br/&amp;gt;runtime-rt0_go)&lt;br/&gt;C --&amp;gt; D(runtime1.go:60&amp;lt;br/&amp;gt;runtime-args)&lt;br/&gt;D --&amp;gt; E(os_darwin.go:50&amp;lt;br/&amp;gt;runtime-osinit)&lt;br/&gt;E --&amp;gt; F(proc.go:472&amp;lt;br/&amp;gt;runtime-schedinit)&lt;br/&gt;F --&amp;gt; G(proc.go:3236&amp;lt;br/&amp;gt;runtime-newproc)&lt;br/&gt;G --&amp;gt; H(proc.go:1170&amp;lt;br/&amp;gt;runtime-mstart)&lt;br/&gt;H --&amp;gt; I(在新创建的 p 和 m 上运行 runtime-main)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;runtime-osinit：获取 CPU 核心数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;runtime-schedinit：初始化程序运行环境（包括栈、内存分配器、垃圾回收、P等）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;runtime-newproc：创建一个新的 G 和 绑定 runtime.main。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;runtime-mstart：启动线程 M。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注：来自@曹大的 《Go 程序的启动流程》和@全成的 《Go 程序是怎样跑起来的》，推荐大家阅读。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;初始化运行环境&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显然，我们要研究的是 runtime 里的 &lt;code&gt;schedinit&lt;/code&gt; 方法，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func &lt;span&gt;&lt;span&gt;schedinit&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; ...&lt;br/&gt; stackinit()&lt;br/&gt; mallocinit()&lt;br/&gt; mcommoninit(_g_.m)&lt;br/&gt; cpuinit()       // must run before alginit&lt;br/&gt; alginit()       // maps must not be used before this call&lt;br/&gt; modulesinit()   // provides activeModules&lt;br/&gt; typelinksinit() // uses maps, activeModules&lt;br/&gt; itabsinit()     // uses activeModules&lt;br/&gt;&lt;br/&gt; msigsave(_g_.m)&lt;br/&gt; initSigmask = _g_.m.sigmask&lt;br/&gt;&lt;br/&gt; goargs()&lt;br/&gt; goenvs()&lt;br/&gt; parsedebugvars()&lt;br/&gt; gcinit()&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从用途来看，非常明显， &lt;code&gt;mallocinit&lt;/code&gt; 方法会进行内存分配器的初始化，我们继续往下看。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;初始化内存分配器&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;mallocinit&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们正式的分析一下 &lt;code&gt;mallocinit&lt;/code&gt; 方法，在引导流程中， &lt;code&gt;mallocinit&lt;/code&gt; 主要承担 Go 程序的内存分配器的初始化动作，而今天主要是针对虚拟内存地址这块进行拆解，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func &lt;span&gt;&lt;span&gt;mallocinit&lt;/span&gt;&lt;/span&gt;() {&lt;br/&gt; ...&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; sys.PtrSize == 8 {&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; i := 0x7f; i &amp;gt;= 0; i-- {&lt;br/&gt;   var p uintptr&lt;br/&gt;   switch {&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; GOARCH == &lt;span&gt;&quot;arm64&quot;&lt;/span&gt; &amp;amp;&amp;amp; GOOS == &lt;span&gt;&quot;darwin&quot;&lt;/span&gt;:&lt;br/&gt;    p = uintptr(i)&amp;lt;&amp;lt;40 | uintptrMask&amp;amp;(0x0013&amp;lt;&amp;lt;28)&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; GOARCH == &lt;span&gt;&quot;arm64&quot;&lt;/span&gt;:&lt;br/&gt;    p = uintptr(i)&amp;lt;&amp;lt;40 | uintptrMask&amp;amp;(0x0040&amp;lt;&amp;lt;32)&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; GOOS == &lt;span&gt;&quot;aix&quot;&lt;/span&gt;:&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; i == 0 {&lt;br/&gt;     &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;    p = uintptr(i)&amp;lt;&amp;lt;40 | uintptrMask&amp;amp;(0xa0&amp;lt;&amp;lt;52)&lt;br/&gt;   &lt;span&gt;case&lt;/span&gt; raceenabled:&lt;br/&gt;    ...&lt;br/&gt;   default:&lt;br/&gt;    p = uintptr(i)&amp;lt;&amp;lt;40 | uintptrMask&amp;amp;(0x00c0&amp;lt;&amp;lt;32)&lt;br/&gt;   }&lt;br/&gt;   hint := (*arenaHint)(mheap_.arenaHintAlloc.alloc())&lt;br/&gt;   hint.addr = p&lt;br/&gt;   hint.next, mheap_.arenaHints = mheap_.arenaHints, hint&lt;br/&gt;  }&lt;br/&gt; } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;      ...&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;判断当前是 64 位还是 32 位的系统。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;从 0x7fc000000000~0x1c000000000 开始设置保留地址。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;判断当前 &lt;code&gt;GOARCH&lt;/code&gt;、&lt;code&gt;GOOS&lt;/code&gt; 或是否开启了竞态检查，根据不同的情况申请不同大小的连续内存地址，而这里的 &lt;code&gt;p&lt;/code&gt; 是即将要要申请的连续内存地址的开始地址。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;保存刚刚计算的 arena 的信息到 &lt;code&gt;arenaHint&lt;/code&gt; 中。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能会有小伙伴问，为什么要判断是 32 位还是 64 位的系统，这是因为不同位数的虚拟内存的寻址范围是不同的，因此要进行区分，否则会出现高位的虚拟内存映射问题。而在申请保留空间时，我们会经常提到 &lt;code&gt;arenaHint&lt;/code&gt; 结构体，它是 &lt;code&gt;arenaHints&lt;/code&gt;链表里的一个节点，结构如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; arenaHint struct {&lt;br/&gt; addr uintptr&lt;br/&gt; down bool&lt;br/&gt; next *arenaHint&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;addr：&lt;code&gt;arena&lt;/code&gt; 的起始地址&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;down：是否最后一个 &lt;code&gt;arena&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;next：下一个 &lt;code&gt;arenaHint&lt;/code&gt; 的指针地址&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么这里疯狂提到的 &lt;code&gt;arena&lt;/code&gt; 又是什么东西呢，这其实是 Go 的内存管理中的概念，Go Runtime 会把申请的虚拟内存分为三个大块，如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5018587360594795&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4htibhubl5wtrrJqdexvxTbXdphQOjjGxD6m2JyDrpwMvZwRRGbouDkoZtgDc6siaR3ee3bS7eYcQNQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1614&quot;/&gt;&lt;figcaption&gt;image&lt;/figcaption&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;spans：记录 arena 区域页号和 mspan 的映射关系。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;bitmap：标识 arena 的使用情况，在功能上来讲，会用于标识 arena 的哪些空间地址已经保存了对象。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;arean：arean 其实就是 Go 的堆区，是由 mheap 进行管理的，它的 MaxMem 是 512GB-1。而在功能上来讲，Go 会在初始化的时候申请一段连续的虚拟内存空间地址到 arean 保留下来，在真正需要申请堆上的空间时再从 arean 中取出来处理，这时候就会转变为物理内存了。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里的话，你需要理解 arean 区域在 Go 内存里的作用就可以了。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;mmap&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们刚刚通过上述的分析，已经知道 &lt;code&gt;mallocinit&lt;/code&gt; 的用途了，但是你可能还是会有疑惑，就是我们之前所看到的 &lt;code&gt;mmap&lt;/code&gt; 系统调用，和它又有什么关系呢，怎么就关联到一起了，接下来我们先一起来看看更下层的代码，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func sysAlloc(n uintptr, sysStat *uint64) unsafe.Pointer {&lt;br/&gt; p, err := mmap(nil, n, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_PRIVATE, -1, 0)&lt;br/&gt; ...&lt;br/&gt; mSysStatInc(sysStat, n)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; p&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func sysReserve(v unsafe.Pointer, n uintptr) unsafe.Pointer {&lt;br/&gt; p, err := mmap(v, n, _PROT_NONE, _MAP_ANON|_MAP_PRIVATE, -1, 0)&lt;br/&gt; ...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;func sysMap(v unsafe.Pointer, n uintptr, sysStat *uint64) {&lt;br/&gt; ...&lt;br/&gt; munmap(v, n)&lt;br/&gt; p, err := mmap(v, n, _PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_FIXED|_MAP_PRIVATE, -1, 0)&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go Runtime 中存在着一系列的系统级内存调用方法，本文涉及的主要如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;sysAlloc：从 OS 系统上申请清零后的内存空间，调用参数是 &lt;code&gt;_PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_PRIVATE&lt;/code&gt;，得到的结果需进行内存对齐。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sysReserve：从 OS 系统中保留内存的地址空间，这时候还没有分配物理内存，调用参数是 &lt;code&gt;_PROT_NONE, _MAP_ANON|_MAP_PRIVATE&lt;/code&gt;，得到的结果需进行内存对齐。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sysMap：通知 OS 系统我们要使用已经保留了的内存空间，调用参数是 &lt;code&gt;_PROT_READ|_PROT_WRITE, _MAP_ANON|_MAP_FIXED|_MAP_PRIVATE&lt;/code&gt;。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看上去好像很有道理的样子，但是 &lt;code&gt;mallocinit&lt;/code&gt; 方法在初始化时，到底是在哪里涉及了 &lt;code&gt;mmap&lt;/code&gt; 方法呢，表面看不出来，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;for&lt;/span&gt; i := 0x7f; i &amp;gt;= 0; i-- {&lt;br/&gt; ...&lt;br/&gt; hint := (*arenaHint)(mheap_.arenaHintAlloc.alloc())&lt;br/&gt; hint.addr = p&lt;br/&gt; hint.next, mheap_.arenaHints = mheap_.arenaHints, hint&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实际上在调用 &lt;code&gt;mheap_.arenaHintAlloc.alloc()&lt;/code&gt; 时，调用的是 &lt;code&gt;mheap&lt;/code&gt;  下的 &lt;code&gt;sysAlloc&lt;/code&gt; 方法，而 &lt;code&gt;sysAlloc&lt;/code&gt; 又会与 &lt;code&gt;mmap&lt;/code&gt; 方法产生调用关系，并且这个方法与常规的 &lt;code&gt;sysAlloc&lt;/code&gt; 还不大一样，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;var mheap_ mheap&lt;br/&gt;...&lt;br/&gt;func (h *mheap) sysAlloc(n uintptr) (v unsafe.Pointer, size uintptr) {&lt;br/&gt; ...&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; h.arenaHints != nil {&lt;br/&gt;  hint := h.arenaHints&lt;br/&gt;  p := hint.addr&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; hint.down {&lt;br/&gt;   p -= n&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; p+n &amp;lt; p {&lt;br/&gt;   v = nil&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; arenaIndex(p+n-1) &amp;gt;= 1&amp;lt;&amp;lt;arenaBits {&lt;br/&gt;   v = nil&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;   v = sysReserve(unsafe.Pointer(p), n)&lt;br/&gt;  }&lt;br/&gt;  ...&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以惊喜的发现 &lt;code&gt;mheap.sysAlloc&lt;/code&gt; 里其实有调用 &lt;code&gt;sysReserve&lt;/code&gt; 方法，而 &lt;code&gt;sysReserve&lt;/code&gt; 方法又正正是从 OS 系统中保留内存的地址空间的特定方法，是不是很惊喜，一切似乎都串起来了。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小结&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在本节中，我们先写了一个测试程序，然后根据非常规的排查思路进行了一步步的跟踪怀疑，整体流程如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;通过 &lt;code&gt;top&lt;/code&gt; 或 &lt;code&gt;ps&lt;/code&gt; 等命令，查看进程运行情况，分析基础指标。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 &lt;code&gt;pprof&lt;/code&gt; 或 &lt;code&gt;runtime.MemStats&lt;/code&gt; 等工具链查看应用运行情况，分析应用层面是否有泄露或者哪儿高。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 &lt;code&gt;vmmap&lt;/code&gt; 命令，查看进程的内存映射情况，分析是不是进程虚拟空间内的某个区域比较高，例如：共享库等。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过 &lt;code&gt;dtruss&lt;/code&gt; 命令，查看程序的系统调用情况，分析可能出现的一些特殊行为，例如：在分析中我们发现  &lt;code&gt;mmap&lt;/code&gt; 方法调用的比例是比较高的，那我们有充分的理由怀疑 Go 在启动时就进行了大量的内存空间保留。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过上述的分析，确定可能是在哪个环节申请了那么多的内存空间后，再到 Go Runtime 中去做进一步的源码分析，因为源码面前，了无秘密，没必要靠猜。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从结论上而言，VSZ（进程虚拟内存大小）与共享库等没有太大的关系，主要与 Go Runtime 存在直接关联，也就是在前图中表示的运行时堆（malloc）。转换到 Go Runtime 里，就是在 &lt;code&gt;mallocinit&lt;/code&gt;  这个内存分配器的初始化阶段里进行了一定量的虚拟空间的保留。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而保留虚拟内存空间时，受什么影响，又是一个哲学问题。从源码上来看，主要如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;受不同的 OS 系统架构（GOARCH/GOOS）和位数（32/64 位）的影响。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;受内存对齐的影响，计算回来的内存空间大小是需要经过对齐才会进行保留。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过一步步地分析，讲解了 Go 会在哪里，又会受什么因素，去调用了什么方法保留了那么多的虚拟内存空间，但是我们肯定会忧心进程虚拟内存（VSZ）高，会不会存在问题呢，我分析如下：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;VSZ 并不意味着你真正使用了那些物理内存，因此是不需要担心的。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;VSZ 并不会给 GC 带来压力，GC 管理的是进程实际使用的物理内存，而 VSZ 在你实际使用它之前，它并没有过多的代价。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;VSZ 基本都是不可访问的内存映射，也就是它并没有内存的访问权限（不允许读、写和执行）。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;思考&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这里舒一口气，因为 Go VSZ 的高，并不会对我们产生什么非常实质性的问题，但是又仔细一想，为什么 Go 要申请那么多的虚拟内存呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总体考虑如下：&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Go 的设计是考虑到 &lt;code&gt;arena&lt;/code&gt; 和  &lt;code&gt;bitmap&lt;/code&gt; 的后续使用，先提早保留了整个内存地址空间。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;Go Runtime 和应用的逐步使用，肯定也会开始实际的申请和使用内存，这时候 &lt;code&gt;arena&lt;/code&gt; 和 &lt;code&gt;bitmap&lt;/code&gt; 的内存分配器就只需要将事先申请好的内存地址空间保留更改为实际可用的物理内存就好了，这样子可以极大的提高效能。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;High virtual memory allocation by golang&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;GO MEMORY MANAGEMENT&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;GoBigVirtualSize&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;GoProgramMemoryUse&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;曹大的 Go 程序的启动流程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;全成大佬的 Go 程序是怎样跑起来的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;欧神的 go-under-the-hood&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6f8d185fd5a0627344cdc836c03f3721</guid>
<title>[推荐] 爱了！一个现代化的 Git CLI 客户端，一堆命令不用记了</title>
<link>https://toutiao.io/k/s3pgs9r</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;span&gt;关注公众号 “&lt;/span&gt;&lt;span&gt;&lt;span&gt;转角遇到GitHub&lt;/span&gt;&lt;/span&gt;&lt;span&gt;” ，每天推荐给你优秀开源项目&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是欧盆索思（opensource），每天为你带来优秀的开源项目！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看一张动图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.290625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/lkYNiaZsfpqbfTtJ24frNJpobbiczdSTj9oD67Zl7o7Jk1yKia0KoosN5fe77camiatzBGX10WR5lR4IMErePVoWtQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天推荐的这个工具是：bit，它是构建在 git 之上的实验性现代化 git CLI，可提供令人满意的默认值和其他优点。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;命令和 flag 建议，以帮助你浏览 git 为您提供的众多选项；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;bit add、bit checkout 能自动完成分支名和文件名；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;自动获取（fetch）和分支快速转发（fast-forwarding），减少合并冲突的可能性；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;建议与 git 别名一起使用；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一些新命令，如 bit sync 等，能极大地简化了工作流程；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;来自 git-extras 的命令，例如 bit release &amp;amp; bit info；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;与 git 完全兼容，允许您在需要时回退到 git。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;项目地址：https://github.com/chriswalz/bit，Star 数：2.7k+。这是一个 Go 项目。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;安装&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1）最简单的安装方式&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ curl -sf https://gobinaries.com/chriswalz/bit | sh; curl -sf https://gobinaries.com/chriswalz/bit/bitcomplete | sh &amp;amp;&amp;amp; &lt;span&gt;echo&lt;/span&gt; y | COMP_INSTALL=1 bitcomplete&lt;br/&gt;$ bit&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2）也可以直接从这里下载&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://github.com/chriswalz/bit/releases&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3）如果安装了 Go，则可以从源码编译&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;确保使用了 go module。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ go get github.com/chriswalz/bit&lt;br/&gt;$ bit&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，bit 依赖 git。所以你本地需要安装 git。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前支持如下平台：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;iTerm2 (macOS)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Terminal.app (macOS)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Command Prompt (Windows)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;WSL/Windows Subsystem for Linux (Windows)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;gnome-terminal (Ubuntu)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;bit 特有的命令&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、bit save [commit message]&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建一个新的提交。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、bit sync&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同步对 origin 分支的更改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大部分时候，bit sync 相当于 &lt;code&gt;bit commit -m &quot;I can still use git commands&quot;&lt;/code&gt;, &lt;code&gt;bit pull -r origin master&lt;/code&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;bit 常见工作流&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过例子演示 bit 常见工作流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、切换分支&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ bit&lt;br/&gt;&amp;gt; bit switch example-branch&lt;br/&gt;? Branch does not exist. Do you want to create it? Yes&lt;br/&gt;Switched to a new branch &lt;span&gt;&#x27;example-branch&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、做一些改动&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ bit add *&lt;br/&gt;$ bit save &lt;span&gt;&quot;add important feature&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、做其他改动&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ bit save&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、push 改变到 origin&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ bit sync&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5、一段时间后，可以再同步别人的修改&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ bit sync&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般都直接输入 bit，然后回车。接着输入会自动提示，如开始的动图。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;文末&lt;strong&gt;「阅读原文」&lt;/strong&gt;可直达项目首页。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;今天的项目大家觉得怎么样吗？如果你喜欢，请在文章底部留言、点赞或关注转发，你的支持就是我持续更新的最大动力！&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;转角遇到GitHub - 送给爱开源的你&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;258&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;258&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/lkYNiaZsfpqYm0bG0MRgJIZRoicricTQsNEEbzuja1veleica9PFicSiayqmibQZzSRZBNufMjJIq2tKXpb4VK0DjbibZQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;344&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Git · GitHub · GitLab · Gitee&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5e7b69cce47f8726b8aecdf05d5de70f</guid>
<title>[推荐] 消息队列和任务队列有什么区别？</title>
<link>https://toutiao.io/k/cfr4egg</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;昨天发了一篇文章是关于&lt;code&gt;machinery&lt;/code&gt;的入门教程，有一位读者在留言中问我 这个和kafka有什么区别？一时我也有点懵，这两个的概念很近，到底有什么不同呢？根据我自己的理解，简单分析了一下，有不足之处欢迎指出。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;消息队列&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息队列这个概念其实在我之前的文章：&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIzMDU0MTA3Nw==&amp;amp;mid=2247483933&amp;amp;idx=1&amp;amp;sn=45c609694ef8cd34c98f5bd74903c754&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;手把手教姐姐写消息队列&lt;/a&gt;，自己动手用go写一个简易版的消息队列，有兴趣的小伙伴们可以看一下这篇文章。回归正题，我们再来介绍一下什么是消息队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息队列，一般我们会简称它为MQ(Message Queue)。他是由两个单词组成，我们应该对队列(Queue)很熟悉吧。队列是一种先进先出的数据结构。再配合上消息，消息队列可以简单理解为：把要传输的数据放在队列中。使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ。这里我们就不具体讲解消息队列实现细节，这不是本文的主题，只知道概念就可以了。了解了什么是消息队列，我们一起来看看他在什么场景使用。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.2676470588235293&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/k5430ljpYPPdxicxQeIHia5x6mJbpxRVngrRpYBaYeNFibHYMRQJousyymjcMwdDdwbeOsZr2bRBqR7rGckXZGUFg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;340&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;场景&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息队列中间件是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题。这里举一个消息队列的使用场景：日志处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;日志处理是指将消息队列用在日志处理中，比如Kafka的应用，解决大量日志传输的问题。架构简化如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.42524271844660194&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/k5430ljpYPPdxicxQeIHia5x6mJbpxRVngPn0KBGKuB2fptLtTjDdenhO9KMiaq5jbHqm7iaDnFTUSGAVQu1JCJGXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1030&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;日志采集客户端，负责日志数据采集，定时写入&lt;code&gt;Kfaka&lt;/code&gt;队列。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;Kfaka&lt;/code&gt;消息队列，负责日志数据的接收，存储和转发。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;日志处理应用，订阅并消费kafka队列中日志数据。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;任务队列&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然消息队列称为MQ，那么任务队列我们就可以叫其TQ(Task Message)。任务队列可以简单理解为：把要执行的任务放在队列中。使用较多的任务队列有&lt;code&gt;machiney&lt;/code&gt;、&lt;code&gt;Celery&lt;/code&gt;、&lt;code&gt;goWorker&lt;/code&gt;、&lt;code&gt;YTask&lt;/code&gt;。每一个任务队列都有自己的特点，这里就不细讲了。我写了一篇&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIzMDU0MTA3Nw==&amp;amp;mid=2247484084&amp;amp;idx=1&amp;amp;sn=6177ef00ffe5c0acd428b90540a8d6d3&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;&lt;code&gt;machinery&lt;/code&gt;入门教程&lt;/a&gt;，并且翻译了&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIzMDU0MTA3Nw==&amp;amp;mid=2247484084&amp;amp;idx=2&amp;amp;sn=8671d9ab75a42e8a83d03d390bf7e3f7&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;一篇&lt;code&gt;machinery&lt;/code&gt;中文文档&lt;/a&gt;，有需要的公众号自取。具体任务队列的细节就不讲了。这不是本文的主题，下面我们看一看任务队列的使用场景。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;场景&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;任务队列是用来执行一个耗时任务。大家可能都使用过马爸爸的花呗，每当我们还款时，就会增加自己的芝麻信用分。这就可以用到任务队列来计算用户的积分和等级了。架构简化如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.42524271844660194&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/k5430ljpYPPdxicxQeIHia5x6mJbpxRVngawZHGjHBBkyoPyqzVcO59Wia9YtaHwpftu0Rngt7GJEFgrIPDNdibgUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1030&quot;/&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;用户还款，当用户还款成功时，发送一个计算用户积分计算的任务到任务队列。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;任务队列，可以是&lt;code&gt;mq&lt;/code&gt;，也可是&lt;code&gt;redis&lt;/code&gt;，用来存储任务。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;任务执行者，任务的执行者，监听任务队列，当任务队列中有任务时，便会执行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;区别&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;消息队列和任务队列，我觉得最大的不同就是理念的不同：任务队列传递的是&quot;任务&quot;，消息队列传递的是&quot;消息&quot;。任务队列可以说是消息队列的二次开发。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.4497716894977169&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/k5430ljpYPPdxicxQeIHia5x6mJbpxRVngg47VJ7qPoibPAJ8tsEw2y39X2KNkmbq9PCWAhPJu0yYWxVbJuKI62Tg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;876&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面两个场景例子，我们可以总结一下两者区别：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;消息队列更侧重于消息的吞吐、处理，具有有处理海量信息的能力。另外利用消息队列的生产者和消费者的概念，也可以实现任务队列的功能，但是还需要进行额外的开发处理。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;任务队列则提供了执行任务所需的功能，比如任务的重试，结果的返回，任务状态记录等。虽然也有并发的处理能力，但一般不适用于高吞吐量快速消费的场景。其实任务队列和远程函数调用很像，不过和rpc调用不同，他的调用不是网络请求的方式，而是通过利用消息队列传递任务信息。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;综上所述，个人认为任务队列就是消息队列在异步场景下的深度二次开发，根据实际项目开发根据实际场景做相应选择即可。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;后言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上全是个人理解，有什么不对的，欢迎指出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好啦，这一篇文章到这就结束了，我们下期见～～。希望对你们有用。可添加我的golang交流群，我们一起学习交流。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;结尾给大家发一个小福利吧，最近我在看[微服务架构设计模式]这一本书，讲的很好，自己也收集了一本PDF，有需要的小伙可以到自行下载。获取方式：关注公众号：[Golang梦工厂]，后台回复：[微服务]，即可获取。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我翻译了一份GIN中文文档，会定期进行维护，有需要的小伙伴后台回复[gin]即可下载。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;自己翻译了一份&lt;code&gt;machinery&lt;/code&gt;官方中文文档，会定期维护，有需要的小伙伴后台回复[machinery]即可下载。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我是asong，一名普普通通的程序猿，让gi我一起慢慢变强吧。我自己建了一个&lt;code&gt;golang&lt;/code&gt;交流群，有需要的小伙伴加我&lt;code&gt;vx&lt;/code&gt;,我拉你入群。欢迎各位的关注，我们下期见~~~&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/k5430ljpYPPdxicxQeIHia5x6mJbpxRVngE5pd6l3ksDM088Zo9PWZ8FVWbQnNQbKPtkr2wia42nuSKtW8GojrwdA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;推荐往期文章：&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;mp-qa class=&quot;js_uneditable custom_select_card qa_iframe&quot; data-pluginname=&quot;insertquestion&quot; data-id=&quot;1589461370889109505&quot; data-bizuin=&quot;MzIzMDU0MTA3Nw==&quot; data-title=&quot;你们有什么理解，欢迎讨论～～～&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>42e632bf561d1ae352a0e3f4e6f1f96a</guid>
<title>[推荐] 面试官：你说说互斥锁、自旋锁、读写锁、悲观锁、乐观锁的应用场景</title>
<link>https://toutiao.io/k/vhisgi9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;（给&lt;/span&gt;&lt;span&gt;数据分析与开发&lt;/span&gt;&lt;span&gt;加星标，提升数据技能&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt; 转自：小林Coding&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;生活中用到的锁，用途都比较简单粗暴，上锁基本是为了防止外人进来、电动车被偷等等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但生活中也不是没有 BUG 的，比如加锁的电动车在「广西 - 窃·格瓦拉」面前，锁就是形同虚设，只要他愿意，他就可以轻轻松松地把你电动车给「顺走」，不然打工怎么会是他这辈子不可能的事情呢？牛逼之人，必有牛逼之处。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.94&quot; data-type=&quot;jpeg&quot; data-w=&quot;350&quot; title=&quot;&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/J0g14CUwaZflJahXjfiaG4OvTA9DA2Uibznd2ictPmdiaM9Nic6dqJ1kXd2FMiaYRWL9h8n8RZ6vuttsAAI77TerIqiaA/640?wx_fmt=jpeg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;那在编程世界里，「锁」更是五花八门，多种多样，每种锁的加锁开销以及应用场景也可能会不同。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如何用好锁，也是程序员的基本素养之一了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;高并发的场景下，如果选对了合适的锁，则会大大提高系统的性能，否则性能会降低。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，知道各种锁的开销，以及应用场景是很有必要的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接下来，就谈一谈常见的这几种锁：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.8525345622119815&quot; data-type=&quot;png&quot; data-w=&quot;868&quot; title=&quot;&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZflJahXjfiaG4OvTA9DA2UibzWMw2wvbFNhIHe3XrOZB6C8NZ3LFK5tF4twWs9UCEYR4kUEjUN00Qbg/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;hr/&gt;&lt;h2&gt;&lt;span&gt;正文&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;span&gt;多线程访问共享资源的时候，避免不了资源竞争而导致数据错乱的问题，所以我们通常为了解决这一问题，都会在访问共享资源之前加锁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最常用的就是互斥锁，当然还有很多种不同的锁，比如自旋锁、读写锁、乐观锁等，不同种类的锁自然适用于不同的场景。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果选择了错误的锁，那么在一些高并发的场景下，可能会降低系统的性能，这样用户体验就会非常差了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，为了选择合适的锁，我们不仅需要清楚知道加锁的成本开销有多大，还需要分析业务场景中访问的共享资源的方式，再来还要考虑并发访问共享资源时的冲突概率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对症下药，才能减少锁对高并发性能的影响。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那接下来，针对不同的应用场景，谈一谈「&lt;strong&gt;互斥锁、自旋锁、读写锁、乐观锁、悲观锁&lt;/strong&gt;」的选择和使用。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;span&gt;互斥锁与自旋锁：谁更轻松自如？&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;最底层的两种就是会「互斥锁和自旋锁」，有很多高级的锁都是基于它们实现的，你可以认为它们是各种锁的地基，所以我们必须清楚它俩之间的区别和应用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当已经有一个线程加锁后，其他线程加锁则就会失败，互斥锁和自旋锁对于加锁失败后的处理方式是不一样的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，&lt;strong&gt;既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被阻塞&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;对于互斥锁加锁失败而阻塞的现象，是由操作系统内核实现的&lt;/strong&gt;。当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行。如下图：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;1.178147268408551&quot; data-type=&quot;png&quot; data-w=&quot;842&quot; title=&quot;&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZflJahXjfiaG4OvTA9DA2UibzKwEMKCNn2DoRsgWyvZsfzPARRpvfdc3ywicDNAmVrIFE6icduenBnxgw/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;所以，互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们切换线程，虽然简化了使用锁的难度，但是存在一定的性能开销成本。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那这个开销成本是什么呢？会有&lt;strong&gt;两次线程上下文切换的成本&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;线程的上下文切换的是什么？当两个线程是属于同一个进程，&lt;strong&gt;因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上下切换的耗时有大佬统计过，大概在几十纳秒到几微秒之间，如果你锁住的代码执行时间比较短，那可能上下文切换的时间都比你锁住的代码执行时间还要长。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，&lt;strong&gt;如果你能确定被锁住的代码执行时间很短，就不应该用互斥锁，而应该选用自旋锁，否则使用互斥锁。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自旋锁是通过 CPU 提供的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;CAS&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 函数（&lt;em&gt;Compare And Swap&lt;/em&gt;），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换，所以相比互斥锁来说，会快一些，开销也小一些。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一般加锁的过程，包含两个步骤：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;CAS 函数就把这两个步骤合并成一条硬件级指令，形成&lt;strong&gt;原子指令&lt;/strong&gt;，这样就保证了这两个步骤是不可分割的，要么一次性执行完两个步骤，要么两个步骤都不执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会「忙等待」，直到它拿到锁。这里的「忙等待」可以用 &lt;/span&gt;&lt;code&gt;&lt;span&gt;while&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 循环等待实现，不过最好是使用 CPU 提供的 &lt;/span&gt;&lt;code&gt;&lt;span&gt;PAUSE&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 指令来实现「忙等待」，因为可以减少循环等待时的耗电量。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自旋锁是最比较简单的一种锁，一直自旋，利用 CPU 周期，直到锁可用。&lt;strong&gt;需要注意，在单核 CPU 上，需要抢占式的调度器（即不断通过时钟中断一个线程，运行其他线程）。否则，自旋锁在单 CPU 上无法使用，因为一个自旋的线程永远不会放弃 CPU。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自旋锁开销少，在多核系统下一般不会主动产生线程切换，适合异步、协程等在用户态切换请求的编程方式，但如果被锁住的代码执行时间过长，自旋的线程会长时间占用 CPU 资源，所以自旋的时间和被锁住的代码执行的时间是成「正比」的关系，我们需要清楚的知道这一点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自旋锁与互斥锁使用层面比较相似，但实现层面上完全不同：&lt;strong&gt;当加锁失败时，互斥锁用「线程切换」来应对，自旋锁则用「忙等待」来应对&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;它俩是锁的最基本处理方式，更高级的锁都会选择其中一个来实现，比如读写锁既可以选择互斥锁实现，也可以基于自旋锁实现。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;&lt;span&gt;读写锁：读和写还有优先级区分？&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;读写锁从字面意思我们也可以知道，它由「读锁」和「写锁」两部分构成，如果只读取共享资源用「读锁」加锁，如果要修改共享资源则用「写锁」加锁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以，&lt;strong&gt;读写锁适用于能明确区分读操作和写操作的场景&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;读写锁的工作原理是：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以说，写锁是独占锁，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁，而读锁是共享锁，因为读锁可以被多个线程同时持有。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;知道了读写锁的工作原理后，我们可以发现，&lt;strong&gt;读写锁在读多写少的场景，能发挥出优势&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，根据实现的不同，读写锁可以分为「读优先锁」和「写优先锁」。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;读优先锁期望的是，读锁能被更多的线程持有，以便提高读线程的并发性，它的工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 仍然可以成功获取读锁，最后直到读线程 A 和 C 释放读锁后，写线程 B 才可以成功获取读锁。如下图：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.9092592592592592&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZflJahXjfiaG4OvTA9DA2UibzGiaX1mvYx5jzfQaYsG9hYbicIzos7M9SkKz0wWMoxBk9RwyguyWwtricA/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;而写优先锁是优先服务写线程，其工作方式是：当读线程 A 先持有了读锁，写线程 B 在获取写锁的时候，会被阻塞，并且在阻塞过程中，后续来的读线程 C 获取读锁时会失败，于是读线程 C 将被阻塞在获取读锁的操作，这样只要读线程 A 释放读锁后，写线程 B 就可以成功获取读锁。如下图：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.975&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/J0g14CUwaZflJahXjfiaG4OvTA9DA2UibzskMiariaXsTzJYibmXK6vGf9fWOlJI6oSaB0ibBIp40Gia5V0VsWclRvttw/640?wx_fmt=png&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;读优先锁对于读线程并发性更好，但也不是没有问题。我们试想一下，如果一直有读线程获取读锁，那么写线程将永远获取不到写锁，这就造成了写线程「饥饿」的现象。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;写优先锁可以保证写线程不会饿死，但是如果一直有写线程获取写锁，读线程也会被「饿死」。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;既然不管优先读锁还是写锁，对方可能会出现饿死问题，那么我们就不偏袒任何一方，搞个「公平读写锁」。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;公平读写锁比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;&lt;span&gt;乐观锁与悲观锁：做事的心态有何不同？&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;前面提到的互斥锁、自旋锁、读写锁，都是属于悲观锁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;悲观锁做事比较悲观，它认为&lt;strong&gt;多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那相反的，如果多线程同时修改共享资源的概率比较低，就可以采用乐观锁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;乐观锁做事比较乐观，它假定冲突的概率很低，它的工作方式是：&lt;strong&gt;先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;放弃后如何重试，这跟业务场景息息相关，虽然重试的成本很高，但是冲突的概率足够低的话，还是可以接受的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;可见，乐观锁的心态是，不管三七二十一，先改了资源再说。另外，你会发现&lt;strong&gt;乐观锁全程并没有加锁，所以它也叫无锁编程&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里举一个场景例子：在线文档。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们都知道在线文档可以同时多人编辑的，如果使用了悲观锁，那么只要有一个用户正在编辑文档，此时其他用户就无法打开相同的文档了，这用户体验当然不好了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那实现多人同时编辑，实际上是用了乐观锁，它允许多个用户打开同一个文档进行编辑，编辑完提交之后才验证修改的内容是否有冲突。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;怎么样才算发生冲突？这里举个例子，比如用户 A 先在浏览器编辑文档，之后用户 B 在浏览器也打开了相同的文档进行编辑，但是用户 B 比用户 A 提交改动，这一过程用户 A 是不知道的，当 A 提交修改完的内容时，那么 A 和 B 之间并行修改的地方就会发生冲突。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;服务端要怎么验证是否冲突了呢？通常方案如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;实际上，我们常见的 SVN 和 Git 也是用了乐观锁的思想，先让用户编辑代码，然后提交的时候，通过版本号来判断是否产生了冲突，发生了冲突的地方，需要我们自己修改后，再重新提交。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以&lt;strong&gt;只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;开发过程中，最常见的就是互斥锁的了，互斥锁加锁失败时，会用「线程切换」来应对，当加锁失败的线程再次加锁成功后的这一过程，会有两次线程上下文切换的成本，性能损耗比较大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果我们明确知道被锁住的代码的执行时间很短，那我们应该选择开销比较小的自旋锁，因为自旋锁加锁失败时，并不会主动产生线程切换，而是一直忙等待，直到获取到锁，那么如果被锁住的代码执行时间很短，那这个忙等待的时间相对应也很短。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果能区分读操作和写操作的场景，那读写锁就更合适了，它允许多个读线程可以同时持有读锁，提高了读的并发性。根据偏袒读方还是写方，可以分为读优先锁和写优先锁，读优先锁并发性很强，但是写线程会被饿死，而写优先锁会优先服务写线程，读线程也可能会被饿死，那为了避免饥饿的问题，于是就有了公平读写锁，它是用队列把请求锁的线程排队，并保证先入先出的原则来对线程加锁，这样便保证了某种线程不会被饿死，通用性也更好点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;互斥锁和自旋锁都是最基本的锁，读写锁可以根据场景来选择这两种锁其中的一个进行实现。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;另外，互斥锁、自旋锁、读写锁都属于悲观锁，悲观锁认为并发访问共享资源时，冲突概率可能非常高，所以在访问共享资源前，都需要先加锁。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相反的，如果并发访问共享资源时，冲突概率非常低的话，就可以使用乐观锁，它的工作方式是，在访问共享资源时，不用先加锁，修改完共享资源后，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是，一旦冲突概率上升，就不适合使用乐观锁了，因为它解决冲突的重试成本非常高。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;不管使用的哪种锁，我们的加锁的代码范围应该尽可能的小，也就是加锁的粒度要小，这样执行速度会比较快。再来，使用上了合适的锁，就会快上加快了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;- EOF -&lt;/span&gt;&lt;/p&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_030&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section&gt;&lt;span&gt;推荐阅读&lt;/span&gt;  &lt;span&gt;点击标题可跳转&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;1、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5ODM5MDU3MA==&amp;amp;mid=2650867608&amp;amp;idx=1&amp;amp;sn=31304a1e4fdf1723a769967cfbbec729&amp;amp;chksm=8b67e0ddbc1069cb14cce449afb8982d2c4c0536f7baabf64b7a54c629e8d684a3b6646d4a1a&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;一次由 Redis 分布式锁造成的重大事故&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5ODM5MDU3MA==&amp;amp;mid=2650865251&amp;amp;idx=1&amp;amp;sn=29cd4dffb55976653d21b60229ae0214&amp;amp;chksm=8b661926bc119030627cbff9a84c12eeed72310808e07181cb06a8765c3d03b46c6d2af7c791&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;通俗讲解分布式锁，看完不懂算作者输&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA5ODM5MDU3MA==&amp;amp;mid=2650865371&amp;amp;idx=1&amp;amp;sn=99e6e48b44cfef32445b00360223649b&amp;amp;chksm=8b66199ebc1190885b93da29f8d294951377dfa0a5e7d9219fedddb3d50503d7770567533d4e&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;聊一聊数据库中的锁&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;看完本文有收获？请转发分享给更多人&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;关注「数据分析与开发」加星标，提升数据技能&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-copyright=&quot;0&quot; data-ratio=&quot;0.9166666666666666&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;600&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/DmibiaFiaAI4B3YpcZYPicgc9JTMiaACNXE5A9FePsKgBic7LNlibx2fwVycTN4Wq47TzYXTNnP2PCKCVAGibNmzDnD0zg/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;点赞和在看就是最大的支持❤️&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>