<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>c3c4d22202da4ac599ec3133e120fb5e</guid>
<title>简单的 Postman，还能玩出花？</title>
<link>https://toutiao.io/k/94q54nm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Postman是一款我们在工作中使用频率非常高的API调试工具，估计很多童鞋在使用它时也比较粗暴，填好接口地址、参数，直接send就完事了，估计大家要说了，这么简单的东西还能玩出什么花来。今天就和大家安利几个非常实用、但是可能一直被忽视的功能，用完之后，简直不要太香！&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;环境变量&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们通过一个例子来看一下环境变量的用法，在一个项目的生命周期中，可能会有开发环境、测试环境、预上线环境、线上环境等众多的不同环境，这时候就可以通过环境变量来管理接口的地址以及端口。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;点击左侧的&lt;code&gt;Environments&lt;/code&gt;，系统中默认已经存在了一个&lt;code&gt;Globals&lt;/code&gt;的全局环境，在这里可以存放一些通用的公共变量的值。先在这里写入&lt;code&gt;host&lt;/code&gt;和&lt;code&gt;port&lt;/code&gt;信息：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.40132827324478176&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDodsJRLuibttrK5fB6XMSKfUw479Xg87jJglIggpp20ZxL4xb1gOkyx9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1054&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在需要使用变量时，可以在访问接口时使用双大括号包裹变量，以&lt;code&gt;{{variable}}&lt;/code&gt;的方式进行引用：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.42005420054200543&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDo318tNtAia9ZcnqQib54InyvJ2nNbmau6TpXfDrsge77ggUKK7YIia9iaMw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;738&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了默认的全局环境外，也可以自己创建新的环境来存放变量。在下面的例子中，创建了&lt;code&gt;local&lt;/code&gt;和&lt;code&gt;test&lt;/code&gt;两个环境，这样我们可以直接在两个环境间进行切换激活，简化了开发中测试接口的过程，不再需要频繁的改动接口的地址。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2954063604240283&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoEx2iao3B5ElM2Z5c0vrJh0YiaVy4dJSHm3KuHicuJLdSdtkB0HIicKicrpA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1415&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果激活的环境和全局环境中有名称重复的变量，那么当前激活的环境中的变量具有更高的优先级，它会直接覆盖&lt;code&gt;globals&lt;/code&gt;环境中变量的值：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7780104712041885&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDobKWDzqgMPDkmw2SlZJx2gzhzib0ibTQBJpT6aYyB85FibJNsIO2mJcgGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;955&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面，我们将环境变量分为了两类，普通环境变量和全局变量。总的来说，全局变量具有更高的使用范围，即使切换到自己创建的环境，全局变量仍然可用。但是我们自己创建的环境之间是相互隔离的，如果切换到一个环境，那么其他环境中的变量将不再可用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像上面这样手动写入变量的值，在某些时候可能不太方便满足一些需求，因此postman提供了一种方法，允许使用脚本来改变环境变量的值。我们来看一下发送请求中的&lt;code&gt;Pre-request Script&lt;/code&gt;和&lt;code&gt;Tests&lt;/code&gt;模块，它们是在请求发送前或完成后执行的脚本，具体的使用在后面具体介绍，现在我们只需要知道能在这里执行js代码就可以了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3506311360448808&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoSB7LpO5Bf4NiaLlWXibw1NN3d1C5xLoTmOavj4Omzzw6FSsHPmLzugiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;713&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面，在&lt;code&gt;Pre-request Script&lt;/code&gt;中加入两行js代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;pm.globals.set(&lt;span&gt;&quot;key1&quot;&lt;/span&gt;,&lt;span&gt;&quot;value1&quot;&lt;/span&gt;);&lt;br/&gt;pm.environment.set(&lt;span&gt;&quot;key2&quot;&lt;/span&gt;,&lt;span&gt;&quot;value2&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行完成请求后再次查看环境变量，全局环境和当前环境中都写入了新的值：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.536547433903577&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoVj7vo3FYicdiag0LcFCf7RvDdqSJFick8M1SyECxI6ttoQTqia4icxODRAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1286&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，也可以使用脚本删除变量：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;pm.globals.unset(&lt;span&gt;&quot;key1&quot;&lt;/span&gt;);&lt;br/&gt;pm.environment.unset(&lt;span&gt;&quot;key2&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了上面的两类变量外，postman中的&lt;code&gt;Collection&lt;/code&gt;也可以存储变量。&lt;code&gt;Collection&lt;/code&gt;可以理解为一个集合，通常在使用中我们会将一个应用系统中的接口放在一个集合中，集合中的变量拥有更小的使用范围，仅在当前集合内可用：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24489795918367346&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoiaXrOPxm1xLScqvLzamUkicuKtakBXlibGa71acA3he1470IkmP27q5MQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1470&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样，也可以在脚本中对它进行操作：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;pm.collectionVariables.set(&lt;span&gt;&quot;key3&quot;&lt;/span&gt;,&lt;span&gt;&quot;value3&quot;&lt;/span&gt;);&lt;br/&gt;pm.collectionVariables.unset(&lt;span&gt;&quot;key3&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在有了环境变量的基础后，再回头看一下上面提到的&lt;code&gt;Pre-request Script&lt;/code&gt;和&lt;code&gt;Tests&lt;/code&gt;，它们是两个比较类似的功能，用处也非常广泛。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;Pre-request Script&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;运行js脚本&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Pre-request Script&lt;/code&gt;可以翻译为预请求脚本，是在请求发送前被执行的代码逻辑，可以在这里执行一些&lt;code&gt;js&lt;/code&gt;代码。通过下面的简单例子进行一下演示，先准备一个后台接口，将前端传递过来的时间戳转换为时间并打印：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;@GetMapping&lt;/span&gt;(&lt;span&gt;&quot;test1&quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;time&lt;/span&gt;&lt;span&gt;(@RequestParam(&lt;span&gt;&quot;time&quot;&lt;/span&gt;)&lt;/span&gt; String time)&lt;/span&gt;{&lt;br/&gt;     Date date = &lt;span&gt;new&lt;/span&gt; Date(Long.parseLong(time));&lt;br/&gt;     System.out.println(date);&lt;br/&gt; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;Pre-request Script&lt;/code&gt;中利用js代码获取当前时间，并放到集合变量中，在请求中传给后端：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34386391251518833&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoCTmuX5U6kUeISPmGiazibLlqgM5GJCmVDFGThV1zXMYxiczOwVPuuNOqA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;823&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发送请求，控制台打印了前端接口的调用时间：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Tue Aug 01 14:14:29 CST 2021&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;发送get请求&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Pre-request Script&lt;/code&gt;的另一大用途就是，在请求当前接口前，通过执行脚本来先请求一下其他接口。在postman中，已经内置了&lt;code&gt;sendRequest&lt;/code&gt;方法来发送&lt;code&gt;get&lt;/code&gt;方法请求。我们在这里调用一个本地接口，并将信息打印到&lt;code&gt;console&lt;/code&gt;控制台（可以通过 &lt;code&gt;Show Postman Console&lt;/code&gt;开启）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.28221343873517785&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoPPlnfEJVfIyncLq416jWNQxW31ZbwNelrHgzekXLzbOZFVvR8AibqVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1265&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过控制台的打印顺序，也可以看到，是在先执行了&lt;code&gt;Pre-request&lt;/code&gt;中的请求后，才去执行的真正目标接口的请求。直接像上面这样调用&lt;code&gt;sendRequest&lt;/code&gt;时，默认发送的&lt;code&gt;get&lt;/code&gt;的请求，如果需要使用&lt;code&gt;post&lt;/code&gt;请求、配置请求&lt;code&gt;header&lt;/code&gt;或使用&lt;code&gt;json&lt;/code&gt;传参的话，可以使用下面单独封装请求的方式。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;发送post请求&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这里，我们通过一个例子来演示&lt;code&gt;Pre-request Script&lt;/code&gt;在具体的工作中能够怎样应用。有一个很普遍的场景，通常在调试需要权限认证的接口时，需要提前通过一个接口获取token，然后再访问目标接口时携带这个token。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时就可以在&lt;code&gt;Pre-request Script&lt;/code&gt;中先调用获取token的接口，再将token设置到集合的环境变量中，在之后的接口调用中引用它。在这里先准备了一个应用了&lt;code&gt;Shiro+JWT&lt;/code&gt;的项目，其中通过登录接口获取token，之后的其他接口都需要带上这个token用于认证 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在&lt;code&gt;sendRequest&lt;/code&gt;发送&lt;code&gt;get&lt;/code&gt;请求的基础上，进行一些修改。首先定义一个变量，在其中使用&lt;code&gt;url&lt;/code&gt;指定请求地址，&lt;code&gt;method&lt;/code&gt;指定请求方法，&lt;code&gt;body&lt;/code&gt;携带参数，最后使用&lt;code&gt;sendRequest&lt;/code&gt;进行请求的发送。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.47566182749786506&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoTXTCct1PunhU6UnNhX7Tib9ibveTeo2n7PELXoaGmadl4mEUr2uGhvow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1171&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在获取完成token后，通过下面的代码将获取的token放入了&lt;code&gt;Collection&lt;/code&gt;的变量中：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;pm.collectionVariables.set(&lt;span&gt;&quot;TOKEN&quot;&lt;/span&gt;,response.json().data.token);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看&lt;code&gt;Collection&lt;/code&gt;中的变量，已经保存了刚才获取的token：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3617407071622847&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoexhRpgNGBpFZeQOow3bpYBDuGcG95QafSQ6QcDqBq0xtrH0ayxayug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1103&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在需要认证的接口&lt;code&gt;header&lt;/code&gt;中，引用这个token，就可以正常的调用接口了：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6576271186440678&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoXshQwMc6IXgGKOhMZKtDialHgQs2qXM0FWucohbhppsRjTb7rsnG7RQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;590&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的例子中，我们使用的是&lt;code&gt;urlencoded&lt;/code&gt;的表单传参方式，如果接口定义是使用json方式传参，可以写成下面的格式：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;body: {&lt;br/&gt;  &lt;span&gt;mode&lt;/span&gt;: &lt;span&gt;&#x27;raw&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;raw&lt;/span&gt;: &lt;span&gt;JSON&lt;/span&gt;.stringify({ &lt;span&gt;key&lt;/span&gt;: &lt;span&gt;&#x27;value&#x27;&lt;/span&gt; })&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果需要传递&lt;code&gt;header&lt;/code&gt;请求头信息，也可以在自定义的请求中添加：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; loginRequest = {&lt;br/&gt;  &lt;span&gt;url&lt;/span&gt;: &lt;span&gt;&#x27;...&#x27;&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;header&lt;/span&gt;: [&lt;br/&gt;      &lt;span&gt;&#x27;Key1 : Value1&#x27;&lt;/span&gt;,&lt;br/&gt;      &lt;span&gt;&#x27;Key2 : Value2&#x27;&lt;/span&gt;&lt;br/&gt;  ],&lt;br/&gt;  ...&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体的使用中需要添加什么字段非常的灵活，可以由我们自行进行配置。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;Tests&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和&lt;code&gt;Pre-request Script&lt;/code&gt;相对，&lt;code&gt;Tests&lt;/code&gt;是在请求完成后执行的操作。这里我们回顾一下上面&lt;code&gt;Pre-request Script&lt;/code&gt;中发送&lt;code&gt;post&lt;/code&gt;请求的例子，其实可以通过&lt;code&gt;Tests&lt;/code&gt;来进行改进。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为在上面的例子中，获取到的token是&lt;code&gt;JWT&lt;/code&gt;生成的，具有一定有效时间，在一段时间内是都可以复用的。因此我们可以先手动调用一次&lt;code&gt;login&lt;/code&gt;接口获取token，完成后在&lt;code&gt;Tests&lt;/code&gt;中使用脚本将获取的token放入&lt;code&gt;Collection&lt;/code&gt;的变量中，就不需要在每次调用接口前都调用&lt;code&gt;login&lt;/code&gt;接口重复获取token了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用&lt;code&gt;login&lt;/code&gt;接口并存入缓存的过程：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.41159695817490494&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDovdAGuyMXdaqxK4JgSEz86S5OSI5ic231mZeaNicjfH8daREoVvSicASaA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1052&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后在调用其他需要携带这个token的接口时，使用&lt;code&gt;{{TOKEN}}&lt;/code&gt;的方式，就会自动填充刚才保存的&lt;code&gt;TOKEN&lt;/code&gt;值。这样在获取到新的token后，每个接口中的token都会自动更新，就不需要再手动复制到每个接口了，极大的减少了工作量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在postman中，在&lt;code&gt;Collection&lt;/code&gt;中可以创建&lt;code&gt;Folder&lt;/code&gt;文件夹，并且集合和文件夹上也可以添加&lt;code&gt;Pre-request Script&lt;/code&gt;和&lt;code&gt;Tests&lt;/code&gt;脚本。我们来看一下位于&lt;code&gt;Folder&lt;/code&gt;中的请求，在执行&lt;code&gt;Pre-request Script&lt;/code&gt;和&lt;code&gt;Tests&lt;/code&gt;时顺序是怎样的，在每个环节中加入对应的打印语句，最后输出的结果是这样的：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6504424778761062&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoHqWmkM8wACqLhrypMkcicCu85o12JZ4Jzo6eZFfVaS6VOoibRW7qvCPg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;452&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说，在发送请求前，postman会先执行所有&lt;code&gt;Pre-request Script&lt;/code&gt;，并且顺序是集合最先、文件夹次之、最后是请求中的，在执行完成真正的请求后执行所有的&lt;code&gt;Tests&lt;/code&gt;，顺序同上。这也就要求我们在使用&lt;code&gt;Pre-request Script&lt;/code&gt;及&lt;code&gt;Tests&lt;/code&gt;功能前，首先要求我们对接口的调用顺序、数据的流向有一个明确的了解，这样才能保证不会出现取不到值或更新错误的情况。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9358638743455497&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/zpom4BeZSicZPYw9B7oJxw4W1eNUXuWDoiat3YsiacTibBr4CHXFxAicaTWw9f72U4AGch8wbj1seRRRG1nEJAznwiaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;764&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>3ca34d4329b4a3246ca681130982e124</guid>
<title>一款前端性能监控系统</title>
<link>https://toutiao.io/k/r0ghwnu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;大家好，我是周刊菌。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzA4Njk2NDAzMA==&amp;amp;mid=2660215615&amp;amp;idx=2&amp;amp;sn=844e0251c92fa230434af84b6e49d5d9&amp;amp;chksm=84bba96eb3cc2078f8bf59ced9b7909530f69cb94e8c5405f7d05fb731e4711b7362bdf7b6c0&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;加入「码农周刊VIP会员」，一起牛起来！&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;以下内容选自「码农周刊 VIP 会员」圈子，每日更新，精彩不断&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;1014&quot; data-ratio=&quot;1.512&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/t8lpVibticjQ5akDVbyFRcrK98pUqmWkBP3UyVjfABXJ8IMtbjJpPheS8YXJia8nUP5WhOtib1dEUaBD4lOfZjs1Pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;码农周刊是什么？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;码农周刊是一份专为广大程序员、编程爱好者们打造的 IT 技术周刊。每周发送。&lt;br/&gt;2013 年 9 月 12 日创刊至今，已发送 300 多期，订阅用户超 20 万。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;专业、简单、有用&lt;/span&gt;&lt;span&gt;，是我们一直坚持的办刊宗旨。一路走来，我们见证了不少订阅用户从编程新手进阶成了高级程序员、架构师、CTO……&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;2020 年 4 月，为了给用户提供更优质的服务，我们推出了「&lt;/span&gt;&lt;span&gt;码农周刊VIP会员&lt;/span&gt;&lt;span&gt;」服务。&lt;br/&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;你与 BAT 技术大牛，只差一份「码农周刊VIP会员」的距离！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;VIP会员特权&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1. 52 期码农周刊VIP会员&lt;span&gt;专属邮件周报&lt;/span&gt;，让你及时掌握技术动向；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 只限VIP会员加入的&lt;span&gt;交流圈子&lt;/span&gt;，让你与技术大牛切磋学习；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3. VIP会员独享的&lt;span&gt;工作机会&lt;/span&gt;，为你介绍好公司的好机会；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4. 更多会员特权，持续更新……&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;如何加入「码农周刊VIP会员」？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1. 微信扫描下方二维码，加入码农周刊VIP会员知识星球。&lt;/span&gt;&lt;strong&gt;&lt;span&gt;促销期间，一年仅需 108 元！平均一天花费不到 3 毛！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;34&quot; data-cropselx2=&quot;356&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;425&quot; data-ratio=&quot;1.0857487922705313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/t8lpVibticjQ6h6x4EnYInRLic6PibFNWw4zSv28rAxcJu9dumVJF03PwHGOWxOzeJKIsydVa7UJuTo4jOjrct9NZw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;828&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2. 加入码农周刊VIP会员知识星球后，客服会联系您，请留意知识星球内的私信。&lt;br/&gt;3. 客服向您发送码农周刊VIP会员欢迎邮件，开启您的码农周刊VIP会员之旅。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;心动不如心动，赶快订阅吧！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>916053b271e070695eab859b991c0397</guid>
<title>图文并茂地聊聊 ReentrantReadWriteLock 的位运算</title>
<link>https://toutiao.io/k/f6e7ggq</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是阿星，欢迎来到&lt;code&gt;Java&lt;/code&gt;并发编程系列第六篇&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt;基础，今天我们来聊一聊读写状态的设计。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我相信不少读者，在看&lt;code&gt;JDK&lt;/code&gt;源码时，会看到位运算代码，可能有些人和阿星一样是转行的，缺乏计算机相关的基础知识，看的是一头雾水。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8eiaVYPG5ibrG1rTbMIbo8cvZgvOVo7Mplmql2JKelLZRger3EBKbkQH7Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;导致有些人直接被劝退，也有些人选择理解字面上的意思，细节跳过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是一颗疑惑的种子在我们心中埋了下来「&lt;strong&gt;为什么使用位运算就能达到这样的效果？&lt;/strong&gt;」。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;恰好&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt;读写状态的设计用到了位运算，我们以此来展开今天的话题。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;一段位运算代码&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来到&lt;code&gt;ReentrantReadWriteLock.Sync&lt;/code&gt;内部类，发现了这段代码（&lt;strong&gt;后面以&lt;code&gt;RRW&lt;/code&gt;简称&lt;/strong&gt;）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;        &lt;br/&gt;&lt;span&gt;//偏移位数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SHARED_SHIFT = &lt;span&gt;16&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//读锁计数基本单位&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SHARED_UNIT = (&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; SHARED_SHIFT);&lt;br/&gt;&lt;span&gt;//读锁、写锁可重入最大数量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MAX_COUNT = (&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; SHARED_SHIFT) - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//获取低16位的条件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; EXCLUSIVE_MASK = (&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; SHARED_SHIFT) - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//获取读锁重入数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;sharedCount&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; c)&lt;/span&gt;    &lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; c &amp;gt;&amp;gt;&amp;gt; SHARED_SHIFT; }&lt;br/&gt;&lt;span&gt;//获取写锁重入数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;exclusiveCount&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; c)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; c &amp;amp; EXCLUSIVE_MASK; }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的这些位运算代码是用来干嘛的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为&lt;code&gt;RRW&lt;/code&gt;的中的&lt;code&gt;int&lt;/code&gt;整型变量&lt;code&gt;state&lt;/code&gt;要同时维护读锁、写锁两种状态，所以&lt;code&gt;RRW&lt;/code&gt;的是通过&lt;strong&gt;高低位切割&lt;/strong&gt;来实现。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46440677966101696&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8eByfbUsNUPuqUVKPSK2LlAhriaOvfHNoiccHQSf2832aoLmdfk1pK2wibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;885&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;int&lt;/code&gt;占&lt;code&gt;4&lt;/code&gt;个字节，一个字节&lt;code&gt;8&lt;/code&gt;位，总共&lt;code&gt;32&lt;/code&gt;位，切割一下，高&lt;code&gt;16&lt;/code&gt;位表示读，低&lt;code&gt;16&lt;/code&gt;位表示写。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样做的好处就是节约资源，就像现实中老板把你一个人当两个人用是一样的道理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;讲到这里，大家也明白了，上面的位运算代码就是完成&lt;strong&gt;高低位切割&lt;/strong&gt;的。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;读锁位运算&lt;/span&gt;&lt;/h1&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//偏移位数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SHARED_SHIFT = &lt;span&gt;16&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//读锁计数基本单位&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SHARED_UNIT = (&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; SHARED_SHIFT);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读锁使用高&lt;code&gt;16&lt;/code&gt;位，每次获取读锁成功&lt;code&gt;+1&lt;/code&gt;，所以读锁计数基本单位是&lt;code&gt;1&lt;/code&gt;的高&lt;code&gt;16&lt;/code&gt;位，即&lt;code&gt;1&lt;/code&gt;左移&lt;code&gt;16&lt;/code&gt;位（&lt;code&gt;1 &amp;lt;&amp;lt; 16&lt;/code&gt;）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4066147859922179&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8ediaLfax9fyJ1ahIlfqH4RPMaufp0SAUmebu57mJTiccqdJFsuPGicCic2A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1028&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;1&lt;/code&gt;左移&lt;code&gt;16&lt;/code&gt;位等于&lt;code&gt;65536&lt;/code&gt;，每次获取读锁成功都&lt;code&gt;+65536&lt;/code&gt;，这时有读者跳出来问，不是&lt;code&gt;+1&lt;/code&gt;嘛，怎么变成&lt;code&gt;+65536&lt;/code&gt;了，这不对啊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;别急别急，看看下面这段代码&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//偏移位数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SHARED_SHIFT = &lt;span&gt;16&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//获取读锁重入数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;sharedCount&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; c)&lt;/span&gt;    &lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; c &amp;gt;&amp;gt;&amp;gt; SHARED_SHIFT; }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面&lt;code&gt;sharedCount&lt;/code&gt;函数通过位运算是做无符号右移&lt;code&gt;16&lt;/code&gt;位获取读锁的重入数，为什么可以获取到呢？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.39068825910931176&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8ecYmzt2RQcCmQKKaLUqVA6c3dZQfClKTG31ibubjMDsUO4BfBfslcy1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;988&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;阿星原地向前走&lt;code&gt;16&lt;/code&gt;步，再后退&lt;code&gt;16&lt;/code&gt;步，又回到原点，&lt;code&gt;1&lt;/code&gt;左移&lt;code&gt;16&lt;/code&gt;位等于&lt;code&gt;65536&lt;/code&gt;，&lt;code&gt;65536&lt;/code&gt;右移&lt;code&gt;16&lt;/code&gt;位等于&lt;code&gt;1&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们获取到了&lt;code&gt;3&lt;/code&gt;次读锁，就是&lt;code&gt;65536 * 3 = 196608&lt;/code&gt;，转换下公式就是&lt;code&gt;3&lt;/code&gt;左移&lt;code&gt;16&lt;/code&gt;位等于&lt;code&gt;196608&lt;/code&gt;，&lt;code&gt;196608&lt;/code&gt;右移&lt;code&gt;16&lt;/code&gt;位等于&lt;code&gt;3&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然我们每次获取到读锁都会&lt;code&gt;+65536&lt;/code&gt;，但是获取读锁时会做右移&lt;code&gt;16&lt;/code&gt;位，所以效果和&lt;code&gt;+1&lt;/code&gt;是一样。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;写锁位运算&lt;/span&gt;&lt;/h1&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//偏移位数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SHARED_SHIFT = &lt;span&gt;16&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//获取低16位的条件&lt;/span&gt;&lt;br/&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; EXCLUSIVE_MASK = (&lt;span&gt;1&lt;/span&gt; &amp;lt;&amp;lt; SHARED_SHIFT) - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//获取写锁重入数&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;exclusiveCount&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; c)&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;return&lt;/span&gt; c &amp;amp; EXCLUSIVE_MASK; }&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;剩下的写锁就非常简单，获取低&lt;code&gt;16&lt;/code&gt;位不用左右移动，只要把高&lt;code&gt;16&lt;/code&gt;位全部补&lt;code&gt;0&lt;/code&gt;即可。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4642507345739471&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8eHDSSt5icianAaoF3dzUpDjACTuuIruTYbhA1sAWmFuTZeso1icrcwSLMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1021&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;反推一下，因为不需要左右移动，其实就和正常的数字一样，只不过因为高&lt;code&gt;16&lt;/code&gt;位补&lt;code&gt;0&lt;/code&gt;，导致数值范围在&lt;code&gt;0~65535&lt;/code&gt;，也就是说写锁获取成功直接&lt;code&gt;+1&lt;/code&gt;就好了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.20534458509142053&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8eGBSTacYSkOY494ItEZKiaPDxMYl0oJAKP3kBzx1kqnG6fVckGIkTKSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;711&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们目光转到&lt;code&gt;EXCLUSIVE_MASK&lt;/code&gt;变量，&lt;code&gt;1&lt;/code&gt;右移&lt;code&gt;16&lt;/code&gt;位后&lt;code&gt;-1&lt;/code&gt;，得到&lt;code&gt;65535&lt;/code&gt;，&lt;code&gt;65535&lt;/code&gt;的二进制就是&lt;code&gt;111111111111111&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在来看&lt;code&gt;exclusiveCount&lt;/code&gt;函数，该函数内做了位运算&lt;code&gt;&amp;amp;&lt;/code&gt;，&lt;code&gt;&amp;amp;&lt;/code&gt;又称&quot;&lt;strong&gt;与&lt;/strong&gt;&quot;运算。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&quot;&lt;strong&gt;与&lt;/strong&gt;&quot;运算是两个二进制，每位数运算，运算规则如下&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果相对应位都是1，则结果为1，否则为0&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能有些读者大大还是不太明白，下面放张图&lt;code&gt;16&lt;/code&gt;位二进制&quot;&lt;strong&gt;与&lt;/strong&gt;&quot;运算图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5050377833753149&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8eicHWoDaric4ibhw2Ol0mAiauYWM5QkoiaCqjiaDdpsf3lcGPBxX6sRj9QZTw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;794&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们发现&quot;&lt;strong&gt;与&lt;/strong&gt;&quot;运算时，只要有一方为&lt;code&gt;0&lt;/code&gt;，那结果一定是&lt;code&gt;0&lt;/code&gt;，所以为了切割低&lt;code&gt;16&lt;/code&gt;位，可以使用&lt;code&gt;&amp;amp;&lt;/code&gt;来完成。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1882716049382716&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8exKFmYyCcbXXG4jPe6UpWX2fkA0eH2SrgXoh1ZXOrYoYWY6EC1axHbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1296&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图可以看出，&lt;code&gt;EXCLUSIVE_MASK&lt;/code&gt;高&lt;code&gt;16&lt;/code&gt;位都是&lt;code&gt;0&lt;/code&gt;，低&lt;code&gt;16&lt;/code&gt;位都是&lt;code&gt;1&lt;/code&gt;，和它&lt;code&gt;&amp;amp;&lt;/code&gt;的变量，高&lt;code&gt;16&lt;/code&gt;位全部会变成&lt;code&gt;0&lt;/code&gt;，低&lt;code&gt;16&lt;/code&gt;位全部保留下来，最终达到获取低&lt;code&gt;16&lt;/code&gt;位效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;c &amp;amp; EXCLUSIVE_MASK&lt;/code&gt;，假设&lt;code&gt;c&lt;/code&gt;是&lt;code&gt;1&lt;/code&gt;，&lt;code&gt;&amp;amp;&lt;/code&gt;的过程如下图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.22013034033309195&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8eteqiaKxxy2zr01yGytQgLDCEuVLycXuhXDArSRRIYiaKZGLFAlMCBdPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1381&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样看可能没太大感觉，我们把数值调大点，假设&lt;code&gt;c&lt;/code&gt;是&lt;code&gt;65536&lt;/code&gt;和&lt;code&gt;65537&lt;/code&gt;，&lt;code&gt;&amp;amp;&lt;/code&gt;的过程如下图&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5193409742120344&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8edY58tHo1EuwDibv897K10H6nGQygDcIaNTDZG49agI0WyZc9Zko3evQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1396&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在有感觉了吧，&lt;code&gt;c&lt;/code&gt;的高&lt;code&gt;16&lt;/code&gt;位都会变成&lt;code&gt;0&lt;/code&gt;，低&lt;code&gt;16&lt;/code&gt;位会原样保留，最终达到获取低&lt;code&gt;16&lt;/code&gt;位效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;EXCLUSIVE_MASK&lt;/code&gt;范围在&lt;code&gt;0~65535&lt;/code&gt;，所以&lt;code&gt;c&lt;/code&gt;的范围也不会超过&lt;code&gt;0~65535&lt;/code&gt;，因为超过了也会通过&lt;code&gt;&amp;amp; EXCLUSIVE_MASK&lt;/code&gt;回到&lt;code&gt;0~65535&lt;/code&gt;。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;提个问题&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;「&lt;strong&gt;阿星&lt;/strong&gt;」：&lt;code&gt;int&lt;/code&gt;如何实现序列化与反序列化？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;「&lt;strong&gt;萌新&lt;/strong&gt;」：好家伙，我直接用&lt;code&gt;Integer&lt;/code&gt;就好了，父类&lt;code&gt;Number&lt;/code&gt;实现了序列化接口&lt;code&gt;Serializable&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;「&lt;strong&gt;阿星&lt;/strong&gt;」：不使用&lt;code&gt;Serializable&lt;/code&gt;，自己手写一个呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;「&lt;strong&gt;萌新&lt;/strong&gt;」：啊，这。。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了让大家更好的消化之前的内容，阿星手把手带大家实现&lt;code&gt;int&lt;/code&gt;与字节的互转。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23111510791366907&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8eTdukxib9lRLnJsN57T1ibFiciaWSpYic42uBN5YaCaictzCBV3EylibVPXibkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1112&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;int&lt;/code&gt;占&lt;code&gt;4&lt;/code&gt;个字节，一个字节&lt;code&gt;8&lt;/code&gt;位，总共&lt;code&gt;32&lt;/code&gt;位。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;int转byte数组&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思路很简单，我们只需要从右往左按&lt;code&gt;8&lt;/code&gt;位一个一个截取，再存储到&lt;code&gt;byte&lt;/code&gt;数组里面，代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] intToBytes(&lt;span&gt;int&lt;/span&gt; n) {&lt;br/&gt;        &lt;span&gt;//长度4字节的数组&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;byte&lt;/span&gt;[] buf = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;4&lt;/span&gt;];&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; buf.length; i++) {&lt;br/&gt;            &lt;span&gt;//循环右移动8位，存储到数组中&lt;/span&gt;&lt;br/&gt;            buf[i] = (&lt;span&gt;byte&lt;/span&gt;) (n &amp;gt;&amp;gt; (&lt;span&gt;8&lt;/span&gt; * i));&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; buf;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过程图如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.860381861575179&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8e2OEmVniaP7mSI4AuLoDgzPnJX2H0mtvD6cmam4Orib1hAWiaQ0NYcSRRA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;838&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;byte数组转int&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们从&lt;code&gt;int&lt;/code&gt;转换成了&lt;code&gt;byte[]&lt;/code&gt;，现在要从&lt;code&gt;byte[]&lt;/code&gt;转换成&lt;code&gt;int&lt;/code&gt;，代码如下&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;bytesToInt&lt;/span&gt;&lt;span&gt;(&lt;span&gt;byte&lt;/span&gt;[] buf)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; buf[&lt;span&gt;0&lt;/span&gt;] &amp;amp; &lt;span&gt;0xff&lt;/span&gt;&lt;br/&gt;            | ((buf[&lt;span&gt;1&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span&gt;8&lt;/span&gt;) &amp;amp; &lt;span&gt;0xff00&lt;/span&gt;)&lt;br/&gt;            | ((buf[&lt;span&gt;2&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span&gt;16&lt;/span&gt;) &amp;amp; &lt;span&gt;0xff0000&lt;/span&gt;)&lt;br/&gt;            | ((buf[&lt;span&gt;3&lt;/span&gt;] &amp;lt;&amp;lt; &lt;span&gt;24&lt;/span&gt;) &amp;amp; &lt;span&gt;0xff000000&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码中涉及到了&quot;&lt;strong&gt;左移、与、或&lt;/strong&gt;&quot;位运算，&lt;strong&gt;左移&lt;/strong&gt;和&lt;strong&gt;与&lt;/strong&gt;我们前面都说了，还有一个&lt;strong&gt;或&lt;/strong&gt;，&lt;strong&gt;或&lt;/strong&gt;和&lt;strong&gt;与&lt;/strong&gt;一样，只是运算规则不同，&lt;strong&gt;或&lt;/strong&gt;的运算规则如下&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果相对应位都是 0，则结果为 0，否则为 1&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;0xff&lt;/code&gt;的二进制是&lt;code&gt;11111111&lt;/code&gt;，&lt;code&gt;0xff&lt;/code&gt;后面每追加&lt;code&gt;2&lt;/code&gt;个&lt;code&gt;0&lt;/code&gt;，效果等于左移&lt;code&gt;8&lt;/code&gt;位，依次类推，所以我们最终是利用&lt;code&gt;&amp;lt;&amp;lt;、|、&amp;amp;、0xff&lt;/code&gt;来还原。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;过程图如下&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.7016460905349795&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8e35VWYdEYCTBYzZnrbCF1ErfdfGmTujA8IMZcfthd3MV1EjsEevKgiaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1458&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;ReentrantReadWriteLock&lt;/code&gt;中读写状态公用一个状态，巧妙的利用高低位来节约资源，在整个实现过程中，使用了位运算来做高低位切割。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;历史好文推荐&lt;/span&gt;&lt;/h1&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;关于我&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里是阿星，一个热爱技术的Java程序猿，公众号  &lt;strong&gt;「程序猿阿星」&lt;/strong&gt; 里将会定期分享操作系统、计算机网络、Java、分布式、数据库等精品原创文章，2021，与您在 Be Better 的路上共同成长！。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5763888888888888&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/23OQmC1ia8nykwymiaCmxWDDibG9upZoV8e5Qfw5lAfCiawAwhp3M07Jr9WqnOZRtX9KYM0l3ibmxcWSjt6mK73N96w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;288&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非常感谢各位小哥哥小姐姐们能看到这里，原创不易，文章有帮助可以关注、点个赞、分享与评论，都是支持（莫要白嫖）！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;愿你我都能奔赴在各自想去的路上，我们下篇文章见&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>bab406b67996e6ef32053a7cd9a2af74</guid>
<title>聊聊如何根据环境动态指定 feign 调用服务名</title>
<link>https://toutiao.io/k/7yze5jo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;1.1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/O1vpibItUIJV1iblpZ8SUcHFUVqA2RcyrlYdjDVTuhRbbmLrtRsibYenrldcSte4cBicRabicxARsjickFo4g59MyICQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;40&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;点击上方&lt;span data-mid=&quot;&quot;&gt;蓝字&lt;/span&gt;关注我们&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;br/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;01&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;前段时间和朋友聊天，他说他部门老大给他提了一个需求，这个需求的背景是这样，他们开发环境和测试环境共用一套eureka，服务提供方的serviceId加环境后缀作为区分，比如用户服务其开发环境serviceId为user_dev,测试环境为user_test。每次服务提供方发布的时候，会根据环境变量，自动变更serviceId。&lt;/p&gt;&lt;p&gt;消费方feign调用时，直接通过&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;@&lt;span&gt;FeignClient&lt;/span&gt;(&lt;span&gt;name&lt;/span&gt; = &lt;span&gt;&quot;user_dev&quot;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;来进行调用，因为他们是直接把feignClient的name直接写死在代码里，导致他们每次发版到测试环境时，要手动改name，比如把user_dev改成user_test，这种改法在服务比较少的情况下，还可以接受，一旦服务一多，就容易改漏，导致本来该调用测试环境的服务提供方，结果跑去调用开发环境的提供方。&lt;/p&gt;&lt;p&gt;他们的老大给他提的需求是，消费端调用需要&lt;strong&gt;自动&lt;/strong&gt;根据环境调用到相应环境的服务提供方。&lt;/p&gt;&lt;p&gt;下面就介绍朋友通过百度搜索出来的几种方案，以及后面我帮朋友实现的另一种方案&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;02&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;方案&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.03428571428571429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Zo04aoPGhhftaGG0yuEeaxw97HRiaFa8WJW7libBkFeicrPny8KnvKmeezoNnqicGdpWHkOm3eGAIXwGohqRuZ6S6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;方案一：通过feign拦截器+url改造&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.03428571428571429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/py7L4cx8wYvBYkElUsqDz94g2u3uiaKibfK2IkLjMkEBKezINP2n0PyX4GwcXC1vl0K8KWnITP6HhjIuhyUBIXbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;&gt;01&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;在API的URI上做一下特殊标记&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@FeignClient&lt;/span&gt;(name = &lt;span&gt;&quot;feign-provider&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;public interface FooFeignClient {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(value = &lt;span&gt;&quot;//feign-provider-$env/foo/{username}&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    String foo(&lt;span&gt;@PathVariable&lt;/span&gt;(&lt;span&gt;&quot;username&quot;&lt;/span&gt;) String username);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;这边指定的URI有两点需要注意的地方&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;&gt;02&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;在RequestInterceptor中查找到特殊的变量标记并替换&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;@Configuration&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;InterceptorConfig&lt;/span&gt; {&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    @Autowired&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; Environment environment;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    @&lt;span&gt;Bean&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;public&lt;/span&gt; RequestInterceptor &lt;span&gt;cloudContextInterceptor&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RequestInterceptor() {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            @Override&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; apply(RequestTemplate &lt;span&gt;template&lt;/span&gt;) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                String url = &lt;span&gt;template&lt;/span&gt;.url();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;if&lt;/span&gt; (url.contains(&lt;span&gt;&quot;$env&quot;&lt;/span&gt;)) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    url = url.replace(&lt;span&gt;&quot;$env&quot;&lt;/span&gt;, route(&lt;span&gt;template&lt;/span&gt;));&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    System.out.println(url);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    &lt;span&gt;template&lt;/span&gt;.uri(url);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;if&lt;/span&gt; (url.startsWith(&lt;span&gt;&quot;//&quot;&lt;/span&gt;)) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    url = &lt;span&gt;&quot;http:&quot;&lt;/span&gt; + url;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    &lt;span&gt;template&lt;/span&gt;.target(url);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    &lt;span&gt;template&lt;/span&gt;.uri(&lt;span&gt;&quot;&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;&lt;span&gt;private&lt;/span&gt; CharSequence &lt;span&gt;route&lt;/span&gt;&lt;span&gt;(RequestTemplate &lt;span&gt;template&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;// TODO 你的路由算法在这里&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;return&lt;/span&gt; environment.getProperty(&lt;span&gt;&quot;feign.env&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        };&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;这种方案是可以实现，但是朋友没有采纳，因为朋友的项目已经是上线的项目，通过改造url，成本比较大。就放弃了&lt;/p&gt;&lt;p&gt;该方案由博主&lt;strong&gt;无级程序员&lt;/strong&gt;提供，下方链接是他实现该方案的链接&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;/&gt;&lt;span data-mid=&quot;&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;https://blog.csdn.net/weixin_45357522/article/details/104020061&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;/&gt;&lt;span data-mid=&quot;&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.03428571428571429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Zo04aoPGhhftaGG0yuEeaxw97HRiaFa8WJW7libBkFeicrPny8KnvKmeezoNnqicGdpWHkOm3eGAIXwGohqRuZ6S6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;方案二:重写RouteTargeter&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.03428571428571429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/py7L4cx8wYvBYkElUsqDz94g2u3uiaKibfK2IkLjMkEBKezINP2n0PyX4GwcXC1vl0K8KWnITP6HhjIuhyUBIXbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;&gt;01&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;API的URL中定义一个特殊的变量标记，形如下&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@FeignClient&lt;/span&gt;(name = &lt;span&gt;&quot;feign-provider-env&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;public interface FooFeignClient {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@GetMapping&lt;/span&gt;(value = &lt;span&gt;&quot;/foo/{username}&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    String foo(&lt;span&gt;@PathVariable&lt;/span&gt;(&lt;span&gt;&quot;username&quot;&lt;/span&gt;) String username);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;&gt;02&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;以HardCodedTarget为基础，实现Targeter&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RouteTargeter&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Targeter&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; Environment environment;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;RouteTargeter&lt;/span&gt;&lt;span&gt;(Environment environment)&lt;/span&gt;&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;       &lt;span&gt;this&lt;/span&gt;.environment = environment;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    } &lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;/**&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   * 服务名以本字符串结尾的，会被置换为实现定位到环境&lt;br mpa-from-tpl=&quot;t&quot;/&gt;   */&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String CLUSTER_ID_SUFFIX = &lt;span&gt;&quot;env&quot;&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span&gt;T &lt;span&gt;target&lt;/span&gt;&lt;span&gt;(FeignClientFactoryBean factory, Builder feign, FeignContext context,&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      HardCodedTarget&amp;lt;T&amp;gt; target)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;return&lt;/span&gt; feign.target(&lt;span&gt;new&lt;/span&gt; RouteTarget&amp;lt;&amp;gt;(target));&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;RouteTarget&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Target&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    Logger log = LoggerFactory.getLogger(getClass());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; Target&amp;lt;T&amp;gt; realTarget;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;RouteTarget&lt;/span&gt;&lt;span&gt;(Target&amp;lt;T&amp;gt; realTarget)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;super&lt;/span&gt;();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;this&lt;/span&gt;.realTarget = realTarget;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Class&amp;lt;T&amp;gt; &lt;span&gt;type&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;return&lt;/span&gt; realTarget.type();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;name&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;return&lt;/span&gt; realTarget.name();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; String &lt;span&gt;url&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      String url = realTarget.url();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;if&lt;/span&gt; (url.endsWith(CLUSTER_ID_SUFFIX)) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        url = url.replace(CLUSTER_ID_SUFFIX, locateCusterId());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        log.debug(&lt;span&gt;&quot;url changed from {} to {}&quot;&lt;/span&gt;, realTarget.url(), url);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;return&lt;/span&gt; url;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;/**&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     * &lt;span&gt;@return&lt;/span&gt; 定位到的实际单元号&lt;br mpa-from-tpl=&quot;t&quot;/&gt;     */&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; String &lt;span&gt;locateCusterId&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;// TODO 你的路由算法在这里&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;return&lt;/span&gt; environment.getProperty(&lt;span&gt;&quot;feign.env&quot;&lt;/span&gt;);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Request &lt;span&gt;apply&lt;/span&gt;&lt;span&gt;(RequestTemplate input)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;if&lt;/span&gt; (input.url().indexOf(&lt;span&gt;&quot;http&quot;&lt;/span&gt;) != &lt;span&gt;0&lt;/span&gt;) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        input.target(url());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;return&lt;/span&gt; input.request();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;&gt;03&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;使用自定义的Targeter实现代替缺省的实现&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Bean&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;&lt;span&gt;public&lt;/span&gt; RouteTargeter &lt;span&gt;getRouteTargeter&lt;/span&gt;&lt;span&gt;(Environment environment)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RouteTargeter(environment);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该方案适用于spring-cloud-starter-openfeign为3.0版本以上，3.0版本以下得额外加&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;repositories&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;repository&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;id&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-milestones&lt;span&gt;&amp;lt;/&lt;span&gt;id&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;Spring Milestones&lt;span&gt;&amp;lt;/&lt;span&gt;name&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;      &lt;span&gt;&amp;lt;&lt;span&gt;url&lt;/span&gt;&amp;gt;&lt;/span&gt;https://repo.spring.io/milestone&lt;span&gt;&amp;lt;/&lt;span&gt;url&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&amp;lt;/&lt;span&gt;repository&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;  &lt;span&gt;&amp;lt;/&lt;span&gt;repositories&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;Targeter 这个接口在3.0之前的包是属于package范围，因此没法直接继承。朋友的springcloud版本相对比较低，后面基于系统稳定性的考虑，就没有贸然升级springcloud版本。因此这个方案朋友也没采纳&lt;/p&gt;&lt;p&gt;该方案仍然由博主&lt;strong&gt;无级程序员&lt;/strong&gt;提供，下方链接是他实现该方案的链接&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;/&gt;&lt;span data-mid=&quot;&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;https://blog.csdn.net/weixin_45357522/article/details/106745468&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;/&gt;&lt;span data-mid=&quot;&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.03428571428571429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Zo04aoPGhhftaGG0yuEeaxw97HRiaFa8WJW7libBkFeicrPny8KnvKmeezoNnqicGdpWHkOm3eGAIXwGohqRuZ6S6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;方案三：使用FeignClientBuilder&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.03428571428571429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/py7L4cx8wYvBYkElUsqDz94g2u3uiaKibfK2IkLjMkEBKezINP2n0PyX4GwcXC1vl0K8KWnITP6HhjIuhyUBIXbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这个类的作用如下&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;/**&lt;br mpa-from-tpl=&quot;t&quot;/&gt; * A builder for creating Feign clients without using the {&lt;span&gt;@link&lt;/span&gt; FeignClient} annotation.&lt;br mpa-from-tpl=&quot;t&quot;/&gt; * &amp;lt;p&amp;gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt; * This builder builds the Feign client exactly like it would be created by using the&lt;br mpa-from-tpl=&quot;t&quot;/&gt; * {&lt;span&gt;@link&lt;/span&gt; FeignClient} annotation.&lt;br mpa-from-tpl=&quot;t&quot;/&gt; *&lt;br mpa-from-tpl=&quot;t&quot;/&gt; * &lt;span&gt;@author&lt;/span&gt; Sven Döring&lt;br mpa-from-tpl=&quot;t&quot;/&gt; */&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;他的功效是和@FeignClient是一样的，因此就可以通过手动编码的方式&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;&gt;01&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;编写一个feignClient工厂类&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DynamicFeignClientFactory&lt;/span&gt;&amp;lt;&lt;span&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; FeignClientBuilder feignClientBuilder;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;DynamicFeignClientFactory&lt;/span&gt;&lt;span&gt;(ApplicationContext appContext)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;this&lt;/span&gt;.feignClientBuilder = &lt;span&gt;new&lt;/span&gt; FeignClientBuilder(appContext);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; T &lt;span&gt;getFeignClient&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; Class&amp;lt;T&amp;gt; type, String serviceId)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.feignClientBuilder.forType(type, serviceId).build();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;&gt;02&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;编写API实现类&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Component&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BarFeignClient {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; DynamicFeignClientFactory&amp;lt;BarService&amp;gt; dynamicFeignClientFactory;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Value&lt;/span&gt;(&lt;span&gt;&quot;${feign.env}&quot;&lt;/span&gt;)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; env;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; bar(&lt;span&gt;@PathVariable&lt;/span&gt;(&lt;span&gt;&quot;username&quot;&lt;/span&gt;) &lt;span&gt;String&lt;/span&gt; username){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        BarService barService = dynamicFeignClientFactory.getFeignClient(BarService.class,getBarServiceName());&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; barService.bar(username);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;String&lt;/span&gt; getBarServiceName(){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;feign-other-provider-&quot;&lt;/span&gt; + env;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;本来朋友打算使用这种方案了，最后没采纳，原因后面会讲。&lt;/p&gt;&lt;p&gt;该方案由博主&lt;strong&gt;lotern&lt;/strong&gt;提供，下方链接为他实现该方案的链接&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;/&gt;&lt;span data-mid=&quot;&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;https://my.oschina.net/kaster/blog/4694238&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;/&gt;&lt;span data-mid=&quot;&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.03428571428571429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Zo04aoPGhhftaGG0yuEeaxw97HRiaFa8WJW7libBkFeicrPny8KnvKmeezoNnqicGdpWHkOm3eGAIXwGohqRuZ6S6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;方案四：feignClient注入到spring之前，修改FeignClientFactoryBean&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.03428571428571429&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/py7L4cx8wYvBYkElUsqDz94g2u3uiaKibfK2IkLjMkEBKezINP2n0PyX4GwcXC1vl0K8KWnITP6HhjIuhyUBIXbA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;700&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;实现核心逻辑&lt;/strong&gt;：在feignClient注入到spring容器之前，变更name&lt;/p&gt;&lt;p&gt;如果有看过spring-cloud-starter-openfeign的源码的朋友，应该就会知道openfeign通过FeignClientFactoryBean中的getObject()生成具体的客户端。因此我们在getObject托管给spring之前，把name换掉&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;&gt;01&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;在API定义一个特殊变量来占位&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@FeignClient&lt;/span&gt;(name = &lt;span&gt;&quot;feign-provider-env&quot;&lt;/span&gt;,path = EchoService.INTERFACE_NAME)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;EchoFeignClient&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;EchoService&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;&lt;span&gt; env为特殊变量占位符&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;&gt;02&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;通过spring后置器处理FeignClientFactoryBean的name&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;FeignClientsServiceNameAppendBeanPostProcessor&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;BeanPostProcessor&lt;/span&gt;, &lt;span&gt;ApplicationContextAware&lt;/span&gt; , &lt;span&gt;EnvironmentAware&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; ApplicationContext applicationContext;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; Environment environment;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;private&lt;/span&gt; AtomicInteger atomicInteger = &lt;span&gt;new&lt;/span&gt; AtomicInteger();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@SneakyThrows&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Object &lt;span&gt;postProcessAfterInitialization&lt;/span&gt;&lt;span&gt;(Object bean, String beanName)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;if&lt;/span&gt;(atomicInteger.getAndIncrement() == &lt;span&gt;0&lt;/span&gt;){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            String beanNameOfFeignClientFactoryBean = &lt;span&gt;&quot;org.springframework.cloud.openfeign.FeignClientFactoryBean&quot;&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            Class beanNameClz = Class.forName(beanNameOfFeignClientFactoryBean);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            applicationContext.getBeansOfType(beanNameClz).forEach((feignBeanName,beanOfFeignClientFactoryBean)-&amp;gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    setField(beanNameClz,&lt;span&gt;&quot;name&quot;&lt;/span&gt;,beanOfFeignClientFactoryBean);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    setField(beanNameClz,&lt;span&gt;&quot;url&quot;&lt;/span&gt;,beanOfFeignClientFactoryBean);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                    e.printStackTrace();&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                System.out.println(feignBeanName + &lt;span&gt;&quot;--&amp;gt;&quot;&lt;/span&gt; + beanOfFeignClientFactoryBean);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            });&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setField&lt;/span&gt;&lt;span&gt;(Class clazz, String fieldName, Object obj)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception&lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        Field field = ReflectionUtils.findField(clazz, fieldName);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;if&lt;/span&gt;(Objects.nonNull(field)){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            ReflectionUtils.makeAccessible(field);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            Object value = field.get(obj);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            &lt;span&gt;if&lt;/span&gt;(Objects.nonNull(value)){&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                value = value.toString().replace(&lt;span&gt;&quot;env&quot;&lt;/span&gt;,environment.getProperty(&lt;span&gt;&quot;feign.env&quot;&lt;/span&gt;));&lt;br mpa-from-tpl=&quot;t&quot;/&gt;                ReflectionUtils.setField(field, obj, value);&lt;br mpa-from-tpl=&quot;t&quot;/&gt;            }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setEnvironment&lt;/span&gt;&lt;span&gt;(Environment environment)&lt;/span&gt; &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;this&lt;/span&gt;.environment = environment;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setApplicationContext&lt;/span&gt;&lt;span&gt;(ApplicationContext applicationContext)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; BeansException &lt;/span&gt;{&lt;br mpa-from-tpl=&quot;t&quot;/&gt;        &lt;span&gt;this&lt;/span&gt;.applicationContext = applicationContext;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;    }&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 这边不能直接用FeignClientFactoryBean.class，因为FeignClientFactoryBean这个类的权限修饰符是default。因此得用反射。&lt;/p&gt;&lt;p&gt;其次只要是在bean注入到spring IOC之前提供的扩展点，都可以进行FeignClientFactoryBean的name替换，不一定得用BeanPostProcessor&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;&gt;03&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;使用import注入&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-preserve=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;pre&gt;&lt;code&gt;&lt;span&gt;@Retention&lt;/span&gt;(RetentionPolicy.RUNTIME)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Target&lt;/span&gt;(ElementType.TYPE)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Documented&lt;/span&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;span&gt;@Import&lt;/span&gt;(FeignClientsServiceNameAppendEnvConfig.class)&lt;br mpa-from-tpl=&quot;t&quot;/&gt;public &lt;span&gt;@interface&lt;/span&gt; EnableAppendEnv2FeignServiceName {&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;}&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;span data-mid=&quot;&quot;&gt;04&lt;/span&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;在启动类上加上@EnableAppendEnv2FeignServiceName&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;03&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;后面朋友采用了第四种方案，主要这种方案相对其他三种方案改动比较小。&lt;/p&gt;&lt;p&gt;第四种方案朋友有个不解的地方，为啥要用import，直接在spring.factories配置自动装配，这样就不用在启动类上@EnableAppendEnv2FeignServiceName&lt;br/&gt;不然启动类上一堆@Enable看着恶心，哈哈。&lt;/p&gt;&lt;p&gt;我给的答案是开了一个显眼的@Enable，是为了让你更快知道我是怎么实现，他的回答是那还不如你直接告诉我怎么实现就好。我竟然无言以对。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;04&lt;/p&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;&lt;span&gt;demo链接&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p data-mid=&quot;&quot;&gt;https://github.com/lyb-geek/springboot-learning/tree/master/springboot-feign-servicename-route&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-mid=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img data-ratio=&quot;0.025936599423631124&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ibqicBWEiaFhaUkEs3YhX1fKvaBcTc3V7YooNTGXoXQEGE8V3BGstZA0g9OpLlWicaefuM0zBUvxG3mPIlLdP7vnYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;694&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>796d9392b2ae1d4250f31d460e843428</guid>
<title>Android 性能优化：从卡顿和 ANR 来彻底理解内存泄露原理和优化</title>
<link>https://toutiao.io/k/dje4uo8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;JAVA程序，因为有垃圾回收机制，应该没有内存泄露。我们已经知道了，如果某个对象，从根节点可到达，也就是存在从根节点到该对象的引用链，那么该对象是不会被 GC 回收的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果说这个对象已经不会再被使用到了，是无用的，我们依然持有他的引用的话，就会造成内存泄漏，例如 一个长期在后台运行的线程持有 Activity 的引用，这个时 候 Activity 执行了 onDestroy 方法，那么这个 Activity 就是从根节点可到达并且无用的对象， 这个 Activity 对象就是泄漏的对象，给这个对象分配的内存将无法被回收。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;如果我们的java运行很久,而这种内存泄露不断的发生，最后就没内存可用了。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当然java的，内存泄漏和C/C++是不一样的。如果java程序完全结束后，它所有的对象就都不可达了，系统就可以对他们进行垃圾回收，它的内存泄露仅仅限于它本身，而不会影响整个系统的。C/C++的内存泄露就比较糟糕了，它的内存泄露是系统级，即使该C/C++程序退出，它的泄露的内存也无法被系统回收，永远不可用了，除非重启机器。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;我们这篇文章就开始对Android内存泄露进行总结；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一、Android内存泄露介绍&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、什么是内存泄露？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;内存泄漏（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;内存泄漏缺陷具有隐蔽性、积累性的特征，比其他内存非法访问错误更难检测。因为内存泄漏的产生原因是内存块未被释放，属于遗漏型缺陷而不是过错型缺陷。此外，内存泄漏通常不会直接产生可观察的错误症状，而是逐渐积累，降低系统整体性能，极端的情况下可能使系统崩溃；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Android的一个应用程序的内存泄露对别的应用程序影响不大。为了能够使得Android应用程序安全且快速的运行，Android的每个应用程序都会使用一个专有的Dalvik虚拟机实例来运行，它是由Zygote服务进程孵化出来的，也就是说每个应用程序都是在属于自己的进程中运行的。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Android为不同类型的进程分配了不同的内存使用上限，如果程序在运行过程中出现了内存泄漏的而造成应用进程使用的内存超过了这个上限，则会被系统视为内存泄漏，从而被kill掉，这使得仅仅自己的进程被kill掉，而不会影响其他进程（如果是system_process等系统进程出问题的话，则会引起系统重启）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、内存泄露的危害&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;用户对单次的内存泄漏并没有什么感知，但是当泄漏积累到内存都被消耗完，就会导致卡顿，甚至崩溃；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;gc回收频繁 造成应用卡顿ANR：&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;当内存不足的时候,gc会主动回收没用的内存.但是,内存回收也是需要时间的.&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;内存回收和gc回收垃圾资源之间高频率交替的执行.就会产生内存抖动.&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;很多数据就会污染内存堆，马上就会有许多GCs启动，由于这一额外的内存压力，也会产生突然增加的运算造成卡顿现象，&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;任何线程的任何操作都会需要暂停，等待GC操作完成之后，其他操作才能够继续运行,所以垃圾回收运行的次数越少，对性能的影响就越少；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、内存泄漏的原因&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;①内存空间使用完毕后没有被回收，就会导致内存泄漏。虽然Java有垃圾回收机制，但是Java中任然存在很多造成内存泄漏的代码逻辑，垃圾回收器会回收掉大部分的内存空间，&lt;/span&gt;&lt;span&gt;但是有一些内存空间还保持着引用，但是在逻辑上已经不会再用到的对象，这时候垃圾回收器就很无能为力，不能回收它们，比如：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;span&gt;②Android（Java）平台的内存泄漏是指没用的对象资源与GC Roots之间保持可达路径，导致系统无法进行回收；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6013363028953229&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kyDL16ViavhFpiafRZPpfGqjDkYQ2VCRjHERrPNDHicPnxUE1bRYYxhXjYtPPKmP4G4jxqZTGNhFzMej1ae3fhUFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;898&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6347826086956522&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kyDL16ViavhFpiafRZPpfGqjDkYQ2VCRjHemMMOXfuCV5rdibtvdwlpLahicOw0bSLtwZhkgaasGQGAQRVofkPibZ1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;920&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;③那么从栈中弹出的对象将不会被当作垃圾回收，即使程序不再使用栈中的这些队象，他们也不会回收，因为栈中仍然保存这对象的引用，俗称过期引用，这个内存泄露很隐蔽；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二、检测内存泄露检测工具 &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;①Memory Monitor&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.6206415620641562&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/kyDL16ViavhFpiafRZPpfGqjDkYQ2VCRjHkWlmsFsFcouu0Xiak74tVmaNapDoE6n9prqQO4YdP6tW2Vug70YPTGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;717&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;位于 Android Monitor 中，该工具可以：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;方便的显示内存使用和 GC 情况&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;快速定位卡顿是否和 GC 有关&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;快速定位 Crash 是否和内存占用过高有关&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;快速定位潜在的内存泄露问题（内存占用一直在增长）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;但是不能准确的定位问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;②Allocation Tracker&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该工具用途：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以定位代码中分配的对象类型、大小、时间、线程、堆栈等信息&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;可以定位内存抖动问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;配合 Heap Viewer 定位内存泄露问题（可以找出来泄露的对象是在哪创建的等等）&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;使用方法：在 Memory Monitor 中有个 Start Allocation Tracking 按钮即可开始跟踪 在点击停止跟踪后会显示统计结果。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;③Heap Viewer&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;该工具用于：&lt;/span&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;/&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;④LeakCanary&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;dependencies {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  debugImplementation &#x27;com.squareup.leakcanary:leakcanary-android:1.6.3&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  releaseImplementation &#x27;com.squareup.leakcanary:leakcanary-android-no-op:1.6.3&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  // Optional, if you use support library fragments:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  debugImplementation &#x27;com.squareup.leakcanary:leakcanary-support-fragment:1.6.3&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;直接在Application中使用，然后运行APP就会自动检测，检测到会在另一个APP上通知，显示详情&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class ExampleApplication extends Application {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  @Override public void onCreate() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    super.onCreate();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    if (LeakCanary.isInAnalyzerProcess(this)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      // This process is dedicated to LeakCanary for heap analysis.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      // You should not init your app in this process.&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;      return;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    LeakCanary.install(this);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    // Normal app init code...&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;三、常见的内存泄露场景详解&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.单例导致内存泄露&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;单例模式在Android开发中会经常用到，但是如果使用不当就会导致内存泄露。因为单例的静态特性使得它的生命周期同应用的生命周期一样长，如果一个对象已经没有用处了，但是单例还持有它的引用，那么在整个应用程序的生命周期它都不能正常被回收，从而导致内存泄露。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class AppSettings {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    private static volatile AppSettings singleton;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    private Context mContext;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    private AppSettings(Context context) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        this.mContext = context;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public static AppSettings getInstance(Context context) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        if (singleton == null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            synchronized (AppSettings.class) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (singleton == null) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    singleton = new AppSettings(context);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        return singleton;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;像上面代码中这样的单例，如果我们在调用getInstance(Context context)方法的时候传入的context参数是Activity、Service等上下文，就会导致内存泄露。以Activity为例，当我们启动一个Activity，并调用getInstance(Context context)方法去获取AppSettings的单例，传入Activity.this作为context，这样AppSettings类的单例sInstance就持有了Activity的引用，当我们退出Activity时，该Activity就没有用了，但是因为sIntance作为静态单例（在应用程序的整个生命周期中存在）会继续持有这个Activity的引用，导致这个Activity对象无法被回收释放，这就造成了内存泄露。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了避免这样单例导致内存泄露，我们可以将context参数改为全局的上下文：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;private AppSettings(Context context) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        this.mContext = context.getApplicationContext();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;2.静态变量导致内存泄漏&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;静态变量存储在方法区，它的生命周期从类加载开始，到整个进程结束。一旦静态变量初始化后，它所持有的引用只有等到进程结束才会释放。比如下面这样的情况，在Activity中为了避免重复的创建info，将sInfo作为静态变量：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class MainActivity2 extends AppCompatActivity {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    public static Info sInfo;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    protected void onCreate(Bundle savedInstanceState) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        super.onCreate(savedInstanceState);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        sInfo = new Info(this);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    class Info {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        private Context mContext;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        public Info(Context context) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            this.mContext = context;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Info作为Activity的静态成员，并且持有Activity的引用，但是sInfo作为静态变量，生命周期肯定比Activity长。所以当Activity退出后，sInfo仍然引用了Activity，Activity不能被回收，这就导致了内存泄露。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在Android开发中，静态持有很多时候都有可能因为其使用的生命周期不一致而导致内存泄露，所以我们在新建静态持有的变量的时候需要多考虑一下各个成员之间的引用关系，并且尽量少地使用静态持有的变量，以避免发生内存泄露。当然，我们也可以在适当的时候讲静态量重置为null，使其不再持有引用，这样也可以避免内存泄露。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3.非静态内部类导致内存泄露&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;非静态内部类（包括匿名内部类）默认就会持有外部类的引用，当非静态内部类对象的生命周期比外部类对象的生命周期长时，就会导致内存泄露。非静态内部类导致的内存泄露在Android开发中有一种典型的场景就是使用Handler，很多开发者在使用Handler是这样写的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class MainActivity2 extends AppCompatActivity {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    protected void onCreate(Bundle savedInstanceState) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        super.onCreate(savedInstanceState);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        start();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    private void start() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        Message message = Message.obtain();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        message.what = 1;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mHandler.sendMessage(message);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    private Handler mHandler = new Handler() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        public void handleMessage(Message msg) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            super.handleMessage(msg);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            if (msg.what == 1) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                //doNothing&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    };&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也许有人会说，mHandler并未作为静态变量持有Activity引用，生命周期可能不会比Activity长，应该不一定会导致内存泄露呢，显然不是这样的！熟悉Handler消息机制的都知道，mHandler会作为成员变量保存在发送的消息msg中，即msg持有mHandler的引用，而mHandler是Activity的非静态内部类实例，即mHandler持有Activity的引用，那么我们就可以理解为msg间接持有Activity的引用。msg被发送后先放到消息队列MessageQueue中，然后等待Looper的轮询处理（MessageQueue和Looper都是与线程相关联的，MessageQueue是Looper引用的成员变量，而Looper是保存在ThreadLocal中的）。那么当Activity退出后，msg可能仍然存在于消息对列MessageQueue中未处理或者正在处理，那么这样就会导致Activity无法被回收，以致发生Activity的内存泄露。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通常在Android开发中如果要使用内部类，但又要规避内存泄露，一般都会采用静态内部类+弱引用的方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;MyHandler mHandler;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public static class MyHandler extends Handler {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        private WeakReference&amp;lt;Activity&amp;gt; mActivityWeakReference;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        public MyHandler(Activity activity) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mActivityWeakReference = new WeakReference&amp;lt;&amp;gt;(activity);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        public void handleMessage(Message msg) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            super.handleMessage(msg);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;mHandler通过弱引用的方式持有Activity，当GC执行垃圾回收时，遇到Activity就会回收并释放所占据的内存单元。这样就不会发生内存泄露了。上面的做法确实避免了Activity导致的内存泄露，发送的msg不再已经没有持有Activity的引用了，但是msg还是有可能存在消息队列MessageQueue中，所以更好的是在Activity销毁时就将mHandler的回调和发送的消息给移除掉。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    protected void onDestroy() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        super.onDestroy();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        mHandler.removeCallbacksAndMessages(null);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;非静态内部类造成内存泄露还有一种情况就是使用Thread或者AsyncTask。要避免内存泄露的话还是需要像上面Handler一样使用静态内部类+弱应用的方式（代码就不列了，参考上面Hanlder的正确写法）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4.未取消注册或回调导致内存泄露&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如我们在Activity中注册广播，如果在Activity销毁后不取消注册，那么这个刚播会一直存在系统中，同上面所说的非静态内部类一样持有Activity引用，导致内存泄露。因此注册广播后在Activity销毁后一定要取消注册。在注册观察则模式的时候，如果不及时取消也会造成内存泄露。比如使用Retrofit+RxJava注册网络请求的观察者回调，同样作为匿名内部类持有外部引用，所以需要记得在不用或者销毁的时候取消注册。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;5.Timer和TimerTask导致内存泄露&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Timer和TimerTask在Android中通常会被用来做一些计时或循环任务，比如实现无限轮播的ViewPager：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;java&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;private void stopTimer(){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        if(mTimer!=null){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mTimer.cancel();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mTimer.purge();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mTimer = null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        if(mTimerTask!=null){&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mTimerTask.cancel();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            mTimerTask = null;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    @Override&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    protected void onDestroy() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        super.onDestroy();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        stopTimer();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当我们Activity销毁的时，有可能Timer还在继续等待执行TimerTask，它持有Activity的引用不能被回收，因此当我们Activity销毁的时候要立即cancel掉Timer和TimerTask，以避免发生内存泄漏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;6.集合中的对象未清理造成内存泄露&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个比较好理解，如果一个对象放入到ArrayList、HashMap等集合中，这个集合就会持有该对象的引用。当我们不再需要这个对象时，也并没有将它从集合中移除，这样只要集合还在使用（而此对象已经无用了），这个对象就造成了内存泄露。并且如果集合被静态引用的话，集合里面那些没有用的对象更会造成内存泄露了。所以在使用集合时要及时将不用的对象从集合remove，或者clear集合，以避免内存泄漏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;7.资源未关闭或释放导致内存泄露&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在使用IO、File流或者Sqlite、Cursor等资源时要及时关闭。这些资源在进行读写操作时通常都使用了缓冲，如果不及时关闭，这些缓冲对象就会一直被占用而得不到释放，以致发生内存泄露。因此我们在不需要使用它们的时候就及时关闭，以便缓冲能及时得到释放，从而避免内存泄露。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;8.属性动画造成内存泄露&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;动画同样是一个耗时任务，比如在Activity中启动了属性动画（ObjectAnimator），但是在销毁的时候，没有调用cancle方法，虽然我们看不到动画了，但是这个动画依然会不断地播放下去，动画引用所在的控件，所在的控件引用Activity，这就造成Activity无法正常释放。因此同样要在Activity销毁的时候cancel掉属性动画，避免发生内存泄漏。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;9.WebView造成内存泄露&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关于WebView的内存泄露，因为WebView在加载网页后会长期占用内存而不能被释放，因此我们在Activity销毁后要调用它的destory()方法来销毁它以释放内存。另外在查阅WebView内存泄露相关资料时看到这种情况：Webview下面的Callback持有Activity引用，造成Webview内存无法释放，即使是调用了Webview.destory()等方法都无法解决问题（Android5.1之后）。最终的解决方案是：在销毁WebView之前需要先将WebView从父容器中移除，然后再销毁WebView。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section data-role=&quot;list&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;对于生命周期比Activity长的对象（单例），要避免直接引用Activity的context，可以考虑使用ApplicationContext，静态变量不使用时及时置空；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Handler持有的引用最好使用弱引用，在Activity被释放的时候要记得清空Message，取消Handler对象的Runnable；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;非静态内部类、非静态匿名内部类会自动持有外部类的引用，为避免内存泄露，可以考虑把内部类声明为静态的；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;广播接收器、EventBus等的使用过程中，注册/反注册应该成对使用，但凡有注册的都应该有反注册；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不再使用的资源对象Cursor、File、Bitmap等要记住正确关闭；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;集合里面的东西有加入就应该对应有相应的删除。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;属性动画及时取消，注意webview内存泄漏问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>