<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b224fc1a7aed33b92399627e1629adac</guid>
<title>Hadoop 学习与面试 8000 字，收藏这一篇就够了</title>
<link>https://toutiao.io/k/xagkm7n</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section&gt;&lt;span&gt;现在在脑海过一遍以下问题，是否能够回忆清楚（后附解析参考）&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt; 1.&lt;/strong&gt; HDFS读流程和写流程？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt; 2.&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; NameNode和Secondary NameNode工作机制？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt; 3.&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; HA NameNode如何工作？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;strong&gt;4. &lt;/strong&gt;DataNode工作机制？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;strong&gt;5.&lt;/strong&gt; DataNode数据损坏怎么办？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;strong&gt;6.&lt;/strong&gt; 压缩方式怎么选择？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt; 7.&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; MapReduce工作流程？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt; 8.&lt;/strong&gt; Yarn工作机制（作业提交全过程）是什么？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;strong&gt;9.&lt;/strong&gt; Yarn调度器了解多少？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;10.&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; HDFS小文件怎么处理？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;11.&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; Shuffle及优化？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;12.&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; Hadoop解决数据倾斜方法？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;13.&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; Hadoop的参数优化？&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;14.&lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 异构存储（冷热数据分离）你了解吗？&lt;/span&gt;&lt;/section&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;以下总结仅供参考&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;HDFS读流程和写流程&lt;/span&gt;&lt;/h2&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;HDFS写数据流程&lt;span/&gt;&lt;/h6&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.4530612244897959&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dRXPfxlVQkvDmENXeqxDJGibEybWuPialfwLdB0BDWSHWSjoJ4CAvUFVKxttH4MKc86scITeLFe7sag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;735&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）客户端通过Distributed FileSystem模块向NameNode请求上传文件，NameNode检查目标文件是否已存在，父目录是否存在。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）NameNode返回是否可以上传。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）客户端请求第一个 Block上传到哪几个DataNode服务器上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）NameNode返回3个DataNode节点，分别为dn1、dn2、dn3。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（5）客户端通过FSDataOutputStream模块请求dn1上传数据，dn1收到请求会继续调用dn2，然后dn2调用dn3，将这个通信管道建立完成。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（6）dn1、dn2、dn3逐级应答客户端。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（7）客户端开始往dn1上传第一个Block（先从磁盘读取数据放到一个本地内存缓存），以Packet为单位，dn1收到一个Packet就会传给dn2，dn2传给dn3；dn1每传一个packet会放入一个应答队列等待应答。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（8）当一个Block传输完成之后，客户端再次请求NameNode上传第二个Block的服务器。（重复执行3-7步）。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;HDFS读数据流程&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.47919655667144906&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dRXPfxlVQkvDmENXeqxDJGibYAar4tw8MEE0xfQ0pYsibwfJjYwXESAhcmXicEZrjXtfnOBQ6CIWk5OQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;697&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）客户端通过Distributed FileSystem向NameNode请求下载文件，NameNode通过查询元数据，找到文件块所在的DataNode地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）挑选一台DataNode（就近原则，然后随机）服务器，请求读取数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）DataNode开始传输数据给客户端（从磁盘里面读取数据输入流，以Packet为单位来做校验）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）客户端以Packet为单位接收，先在本地缓存，然后写入目标文件。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;NameNode和Secondary NameNode工作机制&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先认识NameNode的结构&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.23563218390804597&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dRXPfxlVQkvDmENXeqxDJGibVpO6PbAIPsIMbf528DoP4NmgD9NMI6UCvSg1hKcViapcjM6THOM2LhQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;348&quot;/&gt;&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Fsimage&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Fsimage文件是HDFS文件系统元数据的一个永久性检查点，其中包含HDFS文件系统的所有目录和文件inode的序列化信息。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Edits文件&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;存放HDFS文件系统的所有更新操作的逻辑，文件系统客户端执行的所有写操作首先会记录大Edits文件中。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Seen_txid&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文件保存是一个数字，就是最后一个edits_的数字。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思考：NameNode中的元数据是存储在哪里的？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们做个假设，如果存储在NameNode节点的磁盘中，因为经常需要进行随机访问，还有响应客户请求，必然是效率过低。因此，元数据需要存放在内存中。但如果只存在内存中，一旦断电，元数据丢失，整个集群就无法工作了。因此产生在磁盘中备份元数据的FsImage。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样又会带来新的问题，当在内存中的元数据更新时，如果同时更新FsImage，就会导致效率过低，但如果不更新，就会发生一致性问题，一旦NameNode节点断电，就会产生数据丢失。因此，引入Edits文件(只进行追加操作，效率很高)。每当元数据有更新或者添加元数据时，修改内存中的元数据并追加到Edits中。这样，一旦NameNode节点断电，可以通过FsImage和Edits的合并，合成元数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，如果长时间添加数据到Edits中，会导致该文件数据过大，效率降低，而且一旦断电，恢复元数据需要的时间过长。因此，需要定期进行FsImage和Edits的合并，如果这个操作由NameNode节点完成，又会效率过低。因此，引入一个新的节点SecondaryNamenode，专门用于FsImage和Edits的合并。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以NameNode的工作机制是这样的：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5372714486638537&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dRXPfxlVQkvDmENXeqxDJGib3g1gPfN4dgibobC6HUcFTHcuVwUiaSgyBBxPic3vdyL4wiav1IyBOibTfKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;711&quot;/&gt;&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第一阶段：NameNode启动&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）第一次启动NameNode格式化后，创建Fsimage和Edits文件。如果不是第一次启动，直接加载编辑日志和镜像文件到内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）客户端对元数据进行增删改的请求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）NameNode记录操作日志，更新滚动日志。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）NameNode在内存中对元数据进行增删改。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;第二阶段：Secondary NameNode工作&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）Secondary NameNode询问NameNode是否需要CheckPoint。直接带回NameNode是否检查结果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）Secondary NameNode请求执行CheckPoint。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）NameNode滚动正在写的Edits日志。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）将滚动前的编辑日志和镜像文件拷贝到Secondary NameNode。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（5）Secondary NameNode加载编辑日志和镜像文件到内存，并合并。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（6）生成新的镜像文件fsimage.chkpoint。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（7）拷贝fsimage.chkpoint到NameNode。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（8）NameNode将fsimage.chkpoint重新命名成fsimage。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;HA NameNode如何工作（原理挺多，这里简单介绍）&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在一个典型的HA集群中，每个NameNode是一台独立的服务器。在任一时刻，只有一个NameNode处于active状态，另一个处于standby状态。其中，active状态的NameNode负责所有的客户端操作，standby状态的NameNode处于从属地位，维护着数据状态，随时准备切换。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;两个NameNode为了数据同步，会通过一组称作JournalNodes的独立进程进行相互通信。当active状态的NameNode的命名空间有任何修改时，会告知大部分的JournalNodes进程。standby状态的NameNode有能力读取JNs中的变更信息，并且一直监控edit log的变化，把变化应用于自己的命名空间。standby可以确保在集群出错时，命名空间状态已经完全同步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了确保快速切换，standby状态的NameNode有必要知道集群中所有数据块的位置。为了做到这点，所有的datanodes必须配置两个NameNode的地址，发送数据块位置信息和心跳给他们两个。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于HA集群而言，确保同一时刻只有一个NameNode处于active状态是至关重要的。否则，两个NameNode的数据状态就会产生分歧，可能丢失数据，或者产生错误的结果。为了保证这点，JNs必须确保同一时刻只有一个NameNode可以向自己写数据。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8963815789473685&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dRXPfxlVQkvDmENXeqxDJGibG9UjFoSb4MtxT63ZxZiaTAl8zJf04rNeRgjNibJUSXIV96qMvNplxRLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;608&quot;/&gt;&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ZKFC&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ZKFC即ZKFailoverController，作为独立进程存在，负责控制NameNode的主备切换，ZKFC会监测NameNode的健康状况，当发现Active NameNode出现异常时会通过Zookeeper集群进行一次主备选举，完成Active和Standby状态的切换。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;HealthMonitor&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;定时调用NameNode的HAServiceProtocol RPC接口(monitorHealth和getServiceStatus)，监控NameNode的健康状态并向ZKFC反馈。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ActiveStandbyElector&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接收ZKFC的选举请求，通过Zookeeper自动完成主备选举，选举完成后回调ZKFC的主备切换方法对NameNode进行Active和Standby状态的切换。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;JouranlNode集群&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;共享存储系统，负责存储HDFS的元数据，Active NameNode(写入)和Standby NameNode(读取)通过共享存储系统实现元数据同步，在主备切换过程中，新的Active NameNode必须确保元数据同步完成才能对外提供服务。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;DataNode工作机制&lt;/span&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.46016483516483514&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dRXPfxlVQkvDmENXeqxDJGibK8DSMYUbicVT3icYlAj76DQdHDtunUdCE17QDicJmw4FIwAN7I6ApcowQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;728&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）一个数据块在DataNode上以文件形式存储在磁盘上，包括两个文件，一个是数据本身，一个是元数据包括数据块的长度，块数据的校验和，以及时间戳。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）DataNode启动后向NameNode注册，通过后，周期性（1小时）的向NameNode上报所有的块信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）心跳是每3秒一次，心跳返回结果带有NameNode给该DataNode的命令如复制块数据到另一台机器，或删除某个数据块。如果超过10分钟没有收到某个DataNode的心跳，则认为该节点不可用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）集群运行中可以安全加入和退出一些机器。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;DataNode数据损坏&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）当DataNode读取Block的时候，它会计算CheckSum。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）如果计算后的CheckSum，与Block创建时值不一样，说明Block已经损坏。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）Client读取其他DataNode上的Block。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）DataNode在其文件创建后周期验证CheckSum。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;压缩&lt;/span&gt;&lt;/h2&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;gzip压缩&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「应用场景」&lt;/strong&gt;&lt;/span&gt;：当每个文件压缩之后在130M以内的（1个块大小内），都可以考虑用gzip压缩格式。譬如说一天或者一个小时的日志压缩成一个gzip文件，运行mapreduce程序的时候通过多个gzip文件达到并发。hive程序，streaming程序，和java写的mapreduce程序完全和文本处理一样，压缩之后原来的程序不需要做任何修改。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「优点」&lt;/strong&gt;&lt;/span&gt;：压缩率比较高，而且压缩/解压速度也比较快；hadoop本身支持，在应用中处理gzip格式的文件就和直接处理文本一样；有hadoop native库；大部分linux系统都自带gzip命令，使用方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「缺点」&lt;/strong&gt;&lt;/span&gt;：不支持split。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;snappy压缩&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「应用场景」&lt;/strong&gt;&lt;/span&gt;：当mapreduce作业的map输出的数据比较大的时候，作为map到reduce的中间数据的压缩格式；或者作为一个mapreduce作业的输出和另外一个mapreduce作业的输入。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「优点」&lt;/strong&gt;&lt;/span&gt;：高速压缩速度和合理的压缩率；支持hadoop native库。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「缺点」&lt;/strong&gt;&lt;/span&gt;：不支持split；压缩率比gzip要低；hadoop本身不支持，需要安装；linux系统下没有对应的命令。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;lzo压缩&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「应用场景」&lt;/strong&gt;&lt;/span&gt;：一个很大的文本文件，压缩之后还大于200M以上的可以考虑，而且单个文件越大，lzo优点越越明显。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「优点」&lt;/strong&gt;&lt;/span&gt;：压缩/解压速度也比较快，合理的压缩率；支持split，是hadoop中最流行的压缩格式；支持hadoop native库；可以在linux系统下安装lzop命令，使用方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「缺点」&lt;/strong&gt;&lt;/span&gt;：压缩率比gzip要低一些；hadoop本身不支持，需要安装；在应用中对lzo格式的文件需要做一些特殊处理（为了支持split需要建索引，还需要指定inputformat为lzo格式）。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;bzip2压缩&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「应用场景」&lt;/strong&gt;&lt;/span&gt;：适合对速度要求不高，但需要较高的压缩率的时候，可以作为mapreduce作业的输出格式；或者输出之后的数据比较大，处理之后的数据需要压缩存档减少磁盘空间并且以后数据用得比较少的情况；或者对单个很大的文本文件想压缩减少存储空间，同时又需要支持split，而且兼容之前的应用程序（即应用程序不需要修改）的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「优点」&lt;/strong&gt;&lt;/span&gt;：支持split；具有很高的压缩率，比gzip压缩率都高；hadoop本身支持，但不支持native；在linux系统下自带bzip2命令，使用方便。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;「缺点」&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;：压缩/解压速度慢&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;MapReduce工作流程&lt;/span&gt;&lt;/h2&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;MapTask工作流&lt;span/&gt;&lt;/h6&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.49643705463182897&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dRXPfxlVQkvDmENXeqxDJGib1ttian1GtlwKT0cXD5CvSaSRapKaUcovnzGWQs2iblThicbBicIAo9JB1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;842&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）Read阶段：MapTask通过用户编写的RecordReader，从输入InputSplit中解析出一个个key/value。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）Map阶段：该节点主要是将解析出的key/value交给用户编写map()函数处理，并产生一系列新的key/value。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）Collect收集阶段：在用户编写map()函数中，当数据处理完成后，一般会调用OutputCollector.collect()输出结果。在该函数内部，它会将生成的key/value分区（调用Partitioner），并写入一个环形内存缓冲区中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）Spill阶段：即“溢写”，当环形缓冲区满后，MapReduce会将数据写到本地磁盘上，生成一个临时文件。需要注意的是，将数据写入本地磁盘之前，先要对数据进行一次本地排序，并在必要时对数据进行合并、压缩等操作。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;pre data-source-line=&quot;170&quot;&gt;&lt;section&gt;&lt;code&gt;&lt;span&gt;溢写阶段详情：&lt;br/&gt;步骤1：利用快速排序算法对缓存区内的数据进行排序，排序方式是，先按照分区编号Partition进行排序，然后按照&lt;span&gt;key&lt;/span&gt;进行排序。这样，经过排序后，数据以分区为单位聚集在一起，且同一分区内所有数据按照&lt;span&gt;key&lt;/span&gt;有序。&lt;br/&gt;步骤2：按照分区编号由小到大依次将每个分区中的数据写入任务工作目录下的临时文件&lt;span&gt;output&lt;/span&gt;/spillN.&lt;span&gt;out&lt;/span&gt;（N表示当前溢写次数）中。如果用户设置了Combiner，则写入文件之前，对每个分区中的数据进行一次聚集操作。&lt;br/&gt;步骤3：将分区数据的元信息写到内存索引数据结构SpillRecord中，其中每个分区的元信息包括在临时文件中的偏移量、压缩前数据大小和压缩后数据大小。如果当前内存索引大小超过1MB，则将内存索引写到文件&lt;span&gt;output&lt;/span&gt;/spillN.&lt;span&gt;out&lt;/span&gt;.&lt;span&gt;index&lt;/span&gt;中。&lt;/span&gt;&lt;/code&gt;&lt;/section&gt;&lt;/pre&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（5）Combine阶段：当所有数据处理完成后，MapTask对所有临时文件进行一次合并，以确保最终只会生成一个数据文件。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ReduceTask工作流&lt;span/&gt;&lt;/h6&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4604651162790698&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dRXPfxlVQkvDmENXeqxDJGibyyt7Aibat0X8mR6rkx86FZaF63fp4LjWpvHYagIxC5m7zgggZsBA1og/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;860&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）Copy阶段：ReduceTask从各个MapTask上远程拷贝一片数据，并针对某一片数据，如果其大小超过一定阈值，则写到磁盘上，否则直接放到内存中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）Merge阶段：在远程拷贝数据的同时，ReduceTask启动了两个后台线程对内存和磁盘上的文件进行合并，以防止内存使用过多或磁盘上文件过多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）Sort阶段：按照MapReduce语义，用户编写reduce()函数输入数据是按key进行聚集的一组数据。为了将key相同的数据聚在一起，Hadoop采用了基于排序的策略。由于各个MapTask已经实现对自己的处理结果进行了局部排序，因此，ReduceTask只需对所有数据进行一次归并排序即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）Reduce阶段：reduce()函数将计算结果写到HDFS上。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Yarn工作流（作业提交全过程）&lt;/span&gt;&lt;/h2&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.49759615384615385&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dRXPfxlVQkvDmENXeqxDJGibbx370qcxuMOVUNaLNCLehDz3wZeraTKI5G2c8ar8ZnNGj8LqwJtsug/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;832&quot;/&gt;&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;1.作业提交&lt;span/&gt;&lt;br/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）Client调用job.waitForCompletion方法，向整个集群提交MapReduce作业。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）Client向RM申请一个作业id。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）RM给Client返回该job资源的提交路径和作业id。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）Client提交jar包、切片信息和配置文件到指定的资源提交路径。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（5）Client提交完资源后，向RM申请运行MrAppMaster。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.作业初始化&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（6）当RM收到Client的请求后，将该job添加到容量调度器中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（7）某一个空闲的NM领取到该Job。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（8）该NM创建Container，并产生MRAppmaster。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（9）下载Client提交的资源到本地。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.任务分配&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（10）MrAppMaster向RM申请运行多个MapTask任务资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（11）RM将运行MapTask任务分配给另外两个NodeManager，另两个NodeManager分别领取任务并创建容器。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.任务运行&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（12）MR向两个接收到任务的NodeManager发送程序启动脚本，这两个NodeManager分别启动MapTask，MapTask对数据分区排序。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（13）MrAppMaster等待所有MapTask运行完毕后，向RM申请容器，运行ReduceTask。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（14）ReduceTask向MapTask获取相应分区的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（15）程序运行完毕后，MR会向RM申请注销自己。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.进度和状态更新&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;YARN中的任务将其进度和状态(包括counter)返回给应用管理器, 客户端每秒(通过mapreduce.client.progressmonitor.pollinterval设置)向应用管理器请求进度更新, 展示给用户。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;6.作业完成&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了向应用管理器请求作业进度外, 客户端每5秒都会通过调用waitForCompletion()来检查作业是否完成。时间间隔可以通过mapreduce.client.completion.pollinterval来设置。作业完成之后, 应用管理器和Container会清理工作状态。作业的信息会被作业历史服务器存储以备之后用户核查。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Yarn调度器&lt;/span&gt;&lt;/h2&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;先进先出调度器（FIFO）&lt;span/&gt;&lt;/h6&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.48091603053435117&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dRXPfxlVQkvDmENXeqxDJGibtMxzETJ4iahFmBb0x2BmrXEIKGkmiaSrjURHibVSJqGIdaBha9AuAq62w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;786&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;把应用按提交的顺序排成一个队列，这是一个先进先出队列，在进行资源分配的时候，先给队列中最头上的应用进行分配资源，待最头上的应用需求满足后再给下一个分配。&lt;/span&gt;&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;容量调度器（Capacity Scheduler）&lt;span/&gt;&lt;/h6&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.30453879941434847&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dRXPfxlVQkvDmENXeqxDJGibqZ8QwjpgXT0z7CR8IPtGHOic3qoxqicIoyAxLxM8s1w1gExX9kUg9azQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;683&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以队列为单位划分资源，每个队列可设定一定比例的资源最低保证和使用上限，同时，每个用户也可设定一定的资源使用上限以防止资源滥用。而当一个队列的资源有剩余时，可暂时将剩余资源共享给其他队列。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;特点 &lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）可为每个队列设置资源最低保证和资源使用上限，而所有提交到该队列的应用程序共享这些资源&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）：如果一个队列中的资源有剩余，可以暂时共享给那些需要资源的队列，而一旦该队列有新的应用程序提交，则其他队列释放的资源会归还给该队列&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）支持多用户共享集群和多应用程序同时运行。为防止单个应用程序、用户或队列独占集群中的资源，可为之增加多重约束（比如单个应用程序同时运行的任务数等）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）每个队列有严格的ACL列表规定它的访问用户，每个用户可指定哪些用户允许查看自己应用程序的运行状态或者控制应用程序（比如杀死应用程序）。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;公平调度器（Fair Scheduler）&lt;span/&gt;&lt;/h6&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.2926470588235294&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2gY1hzDz7dRXPfxlVQkvDmENXeqxDJGibMiaO0msLiaZfyJy1f0OGLY3nNRmpl8uhmg1mmC3nzDTVhOBibo4YTic5wA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;680&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公平调度器可以为所有的应用“平均公平”分配资源，当然，这种“公平”是可以配置的，称为权重，可以在分配文件中为每一个队列设置分配资源的权重，如果没有设置，默认是1（由于默认权重相同，因此，在不做配置的情况下，作业（队列）之间的资源占比相同）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;具有以下特点：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）允许资源共享,即当一个APP运行时,如果其它队列没有任务执行,则可以使用其它队列(不属于该APP的队列),当其它队列有APP需要资源时再将占用的队列释放出来.所有的APP都从资源队列中分配资源。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）当队列中有任务,该队列将至少获得最小资源.当队列资源使用不完时,可以给其它队列使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）当队列不能满足最小资源时,可以从其它队列抢占。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;HDFS小文件处理&lt;/span&gt;&lt;/h2&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;HDFS小文件弊端&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HDFS上每个文件都要在NameNode上建立一个索引，这个索引的大小约为150byte，这样当小文件比较多的时候，就会产生很多的索引文件，一方面会大量占用NameNode的内存空间，另一方面就是索引文件过大使得索引速度变慢。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;HDFS小文件解决方案&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1） Hadoop Archive
Hadoop Archive或者HAR，是一个高效地将小文件放入HDFS块中的文件存档工具，它能够将多个小文件打包成一个HAR文件，这样在减少namenode内存使用的同时，仍然允许对文件进行透明的访问。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2） Sequence file
sequence file由一系列的二进制key/value组成，如果为key小文件名，value为文件内容，则可以将大批小文件合并成一个大文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）CombineFileInputFormat
用于将多个文件合并出成单独的Split，另外，它会考虑数据的存储位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（4）开启JVM重用
原理：一个Map运行在一个JVM上，开启重用的话，该Map在JVM上运行完毕后，JVM继续运行其他Map。（mapreduce.job.jvm.numtasks）
，对于大量小文件Job，可以减少45%运行时间&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Shuffle及优化&lt;/span&gt;&lt;/h2&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Shuffle过程&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Map方法之后，Reduce方法之前的数据处理过程称之为Shuffle&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考上面：&lt;strong&gt;MapReduce工作流程&lt;/strong&gt;&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Map阶段优化&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）增大环形缓冲区大小。由100m扩大到200m
（2）增大环形缓冲区溢写的比例。由80%扩大到90%
（3）减少对溢写文件的merge次数。（10个文件，一次20个merge）
（4）不影响实际业务的前提下，采用Combiner提前合并，减少 I/O。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Reduce阶段优化&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）合理设置Map和Reduce数：两个都不能设置太少，也不能设置太多。太少，会导致Task等待，延长处理时间；太多，会导致 Map、Reduce任务间竞争资源，造成处理超时等错误。（2）设置Map、Reduce共存：调整slowstart.completedmaps参数，使Map运行到一定程度后，Reduce也开始运行，减少Reduce的等待时间。（3）规避使用Reduce，因为Reduce在用于连接数据集的时候将会产生大量的网络消耗。（4）增加每个Reduce去Map中拿数据的并行数
（5）集群性能可以的前提下，增大Reduce端存储数据内存的大小。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;IO传输&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采用数据压缩的方式，减少网络IO的的时间。安装Snappy和LZOP压缩编码器。压缩：（1）map输入端主要考虑数据量大小和切片，支持切片的有Bzip2、LZO。注意：LZO要想支持切片必须创建索引；（2）map输出端主要考虑速度，速度快的snappy、LZO；（3）reduce输出端主要看具体需求，例如作为下一个mr输入需要考虑切片，永久保存考虑压缩率比较大的gzip。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;其他Shuffle优化参考下文：参数优化&lt;span/&gt;&lt;/h6&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Hadoop解决数据倾斜方法&lt;/span&gt;&lt;/h2&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;可以参考hive，spark，flink数据倾斜&lt;span/&gt;&lt;/h6&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;提前在map进行combine，减少传输的数据量&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Mapper加上combiner相当于提前进行reduce，即把一个Mapper中的相同key进行了聚合，减少shuffle过程中传输的数据量，以及Reducer端的计算量。如果导致数据倾斜的key大量分布在不同的mapper的时候，这种方法就不是很有效了。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;导致数据倾斜的key 大量分布在不同的mapper&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）局部聚合加全局聚合。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次在map阶段对那些导致了数据倾斜的key 加上1到n的随机前缀，这样本来相同的key
也会被分到多个Reducer中进行局部聚合，数量就会大大降低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二次mapreduce，去掉key的随机前缀，进行全局聚合。思想：二次mr，第一次将key随机散列到不同reducer进行处理达到负载均衡目的。第二次再根据去掉key的随机前缀，按原key进行reduce处理。这个方法进行两次mapreduce，性能稍差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2） 增加Reducer，提升并行度:JobConf.setNumReduceTasks(int)&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（3）实现自定义分区:根据数据分布情况，自定义散列函数，将key均匀分配到不同Reducer&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Hadoop的参数优化&lt;/span&gt;&lt;/h2&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;资源相关参数&lt;span/&gt;&lt;/h6&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;配置参数&lt;/th&gt;&lt;th&gt;参数说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;mapreduce.map.memory.mb&lt;/td&gt;&lt;td&gt;一个MapTask可使用的资源上限（单位:MB），默认为1024。如果MapTask实际使用的资源量超过该值，则会被强制杀死。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mapreduce.reduce.memory.mb&lt;/td&gt;&lt;td&gt;一个ReduceTask可使用的资源上限（单位:MB），默认为1024。如果ReduceTask实际使用的资源量超过该值，则会被强制杀死。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mapreduce.map.cpu.vcores&lt;/td&gt;&lt;td&gt;每个MapTask可使用的最多cpu core数目，默认值: 1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mapreduce.reduce.shuffle.parallelcopies&lt;/td&gt;&lt;td&gt;每个ReduceTask可使用的最多cpu core数目，默认值: 1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mapreduce.reduce.shuffle.merge.percent&lt;/td&gt;&lt;td&gt;每个Reduce去Map中取数据的并行数。默认值是5&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mapreduce.reduce.shuffle.input.buffer.percent&lt;/td&gt;&lt;td&gt;Buffer中的数据达到多少比例开始写入磁盘。默认值0.66&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mapreduce.reduce.input.buffer.percent&lt;/td&gt;&lt;td&gt;Buffer大小占Reduce可用内存的比例。默认值0.7 指定多少比例的内存用来存放Buffer中的数据，默认值是0.0&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;YARN&lt;span/&gt;&lt;/h6&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;配置参数&lt;/th&gt;&lt;th&gt;参数说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;yarn.scheduler.minimum-allocation-mb&lt;/td&gt;&lt;td&gt;给应用程序Container分配的最小内存，默认值：1024&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;yarn.scheduler.maximum-allocation-mb&lt;/td&gt;&lt;td&gt;给应用程序Container分配的最大内存，默认值：8192&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;yarn.scheduler.minimum-allocation-vcores&lt;/td&gt;&lt;td&gt;每个Container申请的最小CPU核数，默认值：1&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;yarn.scheduler.maximum-allocation-vcores&lt;/td&gt;&lt;td&gt;每个Container申请的最大CPU核数，默认值：32&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;yarn.nodemanager.resource.memory-mb&lt;/td&gt;&lt;td&gt;给Containers分配的最大物理内存，默认值：8192&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Shuffle&lt;span/&gt;&lt;/h6&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;配置参数&lt;/th&gt;&lt;th&gt;参数说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;mapreduce.task.io.sort.mb&lt;/td&gt;&lt;td&gt;Shuffle的环形缓冲区大小，默认100m&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mapreduce.map.sort.spill.percent&lt;/td&gt;&lt;td&gt;环形缓冲区溢出的阈值，默认80%&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;容错相关参数&lt;span/&gt;&lt;/h6&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;配置参数&lt;/th&gt;&lt;th&gt;参数说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;mapreduce.map.maxattempts&lt;/td&gt;&lt;td&gt;每个Map Task最大重试次数，一旦重试参数超过该值，则认为Map Task运行失败，默认值：4。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mapreduce.reduce.maxattempts&lt;/td&gt;&lt;td&gt;每个Reduce Task最大重试次数，一旦重试参数超过该值，则认为Map Task运行失败，默认值：4。&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;mapreduce.task.timeout&lt;/td&gt;&lt;td&gt;Task超时时间，经常需要设置的一个参数，该参数表达的意思为：如果一个Task在一定时间内没有任何进入，即不会读取新的数据，也没有输出数据，则认为该Task处于Block状态，可能是卡住了，也许永远会卡住，为了防止因为用户程序永远Block住不退出，则强制设置了一个该超时时间（单位毫秒），默认是600000。如果你的程序对每条输入数据的处理时间过长（比如会访问数据库，通过网络拉取数据等），建议将该参数调大。&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>0ca07aea47926e0a360f75be319c127a</guid>
<title>有备无患（GitHub 热点速览 v.21.38）</title>
<link>https://toutiao.io/k/c2uwe7a</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.66640625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNMmZlibFPGes79kgyPUciaMc6mUNPeicclKJ4qwnQldQibicBY66IY0aeglOH7ic1iapfObHKFCwHeMsvwXQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：HelloGitHub-小鱼干&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库最重要的一个功能是容灾备份，备份不只是对数据库重要，对日常工作生活的我们一样重要，比如花了一个工作日写的代码没有备份（虽然可能只有 1 行…）总归是一个让人不爽的事情，Restic 是一个备份系统，可以帮备份自托管或线上服务，支持只备份变更部分内容。Atmosphere 可能对于一些 Switch 高玩并不陌生，它也能让你备份 Switch 相册以及游戏资料内容…&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以下内容摘录自微博@HelloGitHub 的 GitHub Trending 及 Hacker News 热帖（简称 HN 热帖），选项标准：&lt;code&gt;新发布&lt;/code&gt; | &lt;code&gt;实用&lt;/code&gt; | &lt;code&gt;有趣&lt;/code&gt;，根据项目 release 时间分类，发布时间不超过 14 day 的项目会标注 &lt;code&gt;New&lt;/code&gt;，无该标志则说明项目 release 超过半月。由于本文篇幅有限，还有部分项目未能在本文展示，望周知 🌝&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8807947019867549&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMmZlibFPGes79kgyPUciaMc6ERp4pjIU8Vyo4r6M4EG2WmicPyXQQcvIfYIWeWJLV7ELnApgeSqxibAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;906&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;1. 本周特推&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.1 Switch 固件：Atmosphere&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：450+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Atmosphere 是一个非常知名的 Switch 破解系统，你可以用它来破解 Switch，然后备份相册里的内容，或者其他游戏资料。网上也有很多相关操作 Atmosphere 来破解 Switch 后进行例如安装 Android 系统之类的“骚操作”。如果你想玩点不一样的 Switch，也许可以试试 Atmosphere。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/Atmosphere-NX/Atmosphere&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMmZlibFPGes79kgyPUciaMc6nX43xoFwKl9xzEo3ZGArwX23MmbWhW2nbs7ISibaEFs3ia27ExxQic9oQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.20495495495495494&quot; data-w=&quot;888&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.2 图解 React 源码：react-illustration-series&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：800+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;react-illustration-series 是一个配大量图片来讲解 React 源码的项目，希望用图解的方式讲清楚 React 的背后原理。目前分为了 v16.13.1 和 v17.0.1 两个版本。下图为包结构配图。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/7kms/react-illustration-series&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7203703703703703&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMmZlibFPGes79kgyPUciaMc6CbEfZnnw3xhKwKfjNU53qdroyqiakoeugknJRXgo7OY39dgNpfSkaaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;2. GitHub Trending 周榜&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.1 Python 小技巧：python-mini-projects&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：2,050+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Python-Mini-Projects 收录了大量能提升你 Python 技能的小项目，从最简单的 Hello World，到 json 和 csv 的转换，到捕获视频帧等等 100+ 小项目。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/Python-World/python-mini-projects&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMmZlibFPGes79kgyPUciaMc6PHkozeOw8U2lJGTRWda7OJuAlicQ6jSCzxTzGSuA8p41wnvAFOysibCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.35051546391752575&quot; data-w=&quot;970&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.2 开源日历：calendso&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：1,300+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;calendso 是一款开源的日历组件，你可以基于它管理你的日常事项，例如备忘、会议事项，可基于自己的个人爱好来定制日历 UI。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/calendso/calendso&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMmZlibFPGes79kgyPUciaMc6q8nroHrnKEYHyhDNaOXnJy8Tqt2DomaH9Pzn7P3PqvhrWiciaiaHa4Hkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.3 AI 量化：Qlib&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：600+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Qlib 是一个面向人工智能的量化平台，旨在实现人工智能技术在量化的潜能。有了 Qlib 可以轻松尝试想法，以创建更好的量化策略。&lt;strong&gt;即便有 AI 帮忙，量化也需谨慎&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/microsoft/qlib&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMmZlibFPGes79kgyPUciaMc6RD7G2BvL6MnW52yWE9oXysGfDPcEkTZkk6UyTcI3P2w7bTvdgAbhKQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.38636363636363635&quot; data-w=&quot;352&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.4 备份工具：restic&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：200+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Restic 是一个备份系统，用来备份文件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;支持 Linux、BSD、Mac 和 Windows 系统&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;支持多种存储类型，自托管的或者是线上服务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;易用，不需要复杂的安装过程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;高效，只备份文件中变更过的部分&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;安全加密&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;校验系统&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;免费&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/restic/restic&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.42757417102966844&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMmZlibFPGes79kgyPUciaMc6VoiaqoF31auPEJzSrg9jicxtLjcpvuGnBlfaUy8v3cicpahTu4EUc8j7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1146&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.5 单点登录：authelia&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;本周 star 增长数：1,700+&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Authelia 是一个开源的身份验证和授权工具，通过 Web 为应用程序提供双因素身份验证和单点登录（SSO）。它可搭配 Nginx、Traefik 或 HAProxy 等反向代理，让它们知道是否应该允许或重定向请求到 Authelia 进行身份验证。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;GitHub 地址→https://github.com/authelia/authelia&lt;/p&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNMmZlibFPGes79kgyPUciaMc6d7ck9FBOibrBnQd2gkmne5UoIt4kqic61WesVZHZKZicqX3TXpx5eC3icQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-ratio=&quot;0.46131805157593125&quot; data-w=&quot;698&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;3. 往期回顾&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回顾之前，先来回复下 Elysium 的评论既然你已经提到了 OpenPose 这个项目这里不做赘述了，引用下 HelloGitHub vol.037 期卤蛋的项目介绍:&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;OpenPose 基于卷积神经网络和监督学习的开源库，可以实现人的面部、躯干和四肢甚至手指的跟踪。适用于多人，且标记准确，同时具有较好的鲁棒性&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;和他类似的项目，这里推荐一个 HyperPose，和 OpenPose 类似也是一个用来检测动态人体姿势的库。不过不清楚你具体想要了解的是哪块东西，推荐的项目有不错的文档，通过阅读文档来学习下实现也是一个不错的方式。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;HyperPose GitHub 地址：https://github.com/tensorlayer/hyperpose&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5633333333333334&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xBgIbW1vdNMmZlibFPGes79kgyPUciaMc6ZsUDuiaehKM0BalV2BmQHruiaTfAFzW8ajgeQ5tbHPvfdyvfe2pxC1kQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;往期回顾：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上为 2021 年第 38 个工作周的 GitHub Trending 🎉如果你 Pick 其他好玩、实用的 GitHub 项目，记得来 HelloGitHub issue 区和我们分享下哟 🌝&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，记得你在本文留言区留下你想看的主题 Repo（限公众号），例如：AI 换头。👀 和之前的送书活动类似，留言点赞 Top5 的小伙伴(&lt;span&gt;棒&lt;/span&gt;），小鱼干会努力去找 Repo 的^^&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub001 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~&lt;/p&gt;&lt;/blockquote&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA5MzYyNzQ0MQ==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOqkqThUJBICyFBlvLvTyOCgBpibwWotSxGExfnOYFfPiaL9yn3GMUOCEVYN2RNslGCdQwgZy6ticdyA/0?wx_fmt=png&quot; data-nickname=&quot;HelloGitHub&quot; data-alias=&quot;GitHub520&quot; data-signature=&quot;分享 GitHub 上有趣、入门级的开源项目。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;👆 关注「HelloGitHub」第一时间收到更新&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;👆&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>604f5474b0a5f8d96fe63f0db6ebd045</guid>
<title>16 张图解锁 Spring 的整体脉络</title>
<link>https://toutiao.io/k/bynegiy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天来梳理下 &lt;strong&gt;Spring&lt;/strong&gt; 的整体脉络啦，为后面的文章做个铺垫~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面几篇文章应该会讲讲这些内容啦 😆&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Spring  AOP 插件 🐖  （🕊了好久都忘了 😅）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;分享下  &lt;strong&gt;4ye&lt;/strong&gt; 在项目中利用  &lt;strong&gt;AOP + MybatisPlus&lt;/strong&gt;   对项目进行重构，优化系统中特殊的日志模块的故事&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring &lt;strong&gt;属性注入&lt;/strong&gt; , &lt;strong&gt;循环依赖&lt;/strong&gt;，&lt;strong&gt;事务&lt;/strong&gt; 等这几个比较重要的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring  源码中的要点  &lt;strong&gt;AbstractApplicationContext&lt;/strong&gt;  中的 &lt;strong&gt;refresh&lt;/strong&gt; 方法里的 12 个方法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Spring 中的设计模式  等等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;目前就想到这么多啦🐷&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;话说咱们一直都在用这个 Spring  ，你们对它的感受是啥呀？还是说说不出来 哈哈&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4ye 的感觉也是零零散散的，而且印象中一直都在用 Springboot ，不用再配置一堆东西呀，管理依赖啥的，方便太多了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以借此机会简单梳理下其中的一些脉络，这样去看源码就有条理多啦，更能知道一些扩展点的使用等😝&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;目录&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文会先大概介绍下这些知识点 👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6292372881355932&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYRAzh9fXT7e7ep8M5yAtf18ibz4LM6uaGicwxvXNXTT3w9ZSgNU2ic20iaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;944&quot;/&gt;&lt;figcaption&gt;image-20210904200622280&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;印象中的 Spring&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;脑海中有这么一条公式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;👉  IOC  = 工厂模式 + XML + 反射&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;👉 而 DI ,  AOP ， &lt;strong&gt;事务&lt;/strong&gt; 等也都在  XML  中很直观的表现出来&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然我们现在大部分用这个注解来代替，但是原理还是基本一样的🐖&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注解使用起来很方便，但是学习的话，还是建议先通过这个 XML ，毕竟结构性的文档，有层次感，可以留下更深的印象~ 😄&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小小Spring&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把 Spring 浓缩一下，就有了这么一点小东西🐖&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6832116788321168&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYJaPwb8Q4qfnumnrqKuMEhtibm3Z2BuomvIuVBgsbjVMzsj6wISZSgBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;685&quot;/&gt;&lt;figcaption&gt;image-20210831215104931&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;想了下，我们用 Spring ，其中最主要的一点，就是用它来帮我们管理，创建这个 Bean 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么先从源头看起  —— Bean 从哪来 (＠_＠;)&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Bean 解析流程&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.49678012879484823&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYaQvLdLoiazvicj4nswAZQv3Z13yLnQo0h3576OYntY2juqicJWrwbwggQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1087&quot;/&gt;&lt;figcaption&gt;image-20210901220458461&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图所示，就是通过 &lt;strong&gt;解析器&lt;/strong&gt;，对我们的 XML 文件或者注解进行解析，最后将这些信息封装在  BeanDefinition 类中，并通过 BeanDefinitionRegistry 接口将这些信息 &lt;strong&gt;注册&lt;/strong&gt; 起来，放在 beanDefinitionMap 变量中, key : beanName , value ：BeanDefinition &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单看看  BeanDefinition 中的属性叭&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;BeanDefinition&lt;span/&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;beanClass  :  bean 的类型 ，实例化时用的 🐖&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;scope  :  作用范围有 singleton，prototype&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;isLazy   :  &lt;strong&gt;懒加载&lt;/strong&gt; ，true  的话 会在 getBean 时生成，而且 scope 的 prototype 无效，false 在 Spring 启动过程中直接生成&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;initMethodName  :  初始化方法，当然是初始化时调用🐖&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;primary  :  主要的，有多个 Bean 时使用它&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;dependsOn  :   依赖的Bean，必须等依赖Bean 创建好才可以创建&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;PS: @Component ，@Bean ,&lt;bean&gt;都会被解析成 BeanDefinition&lt;/bean&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;反射&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有了原料后呢，&lt;span&gt;咱&lt;/span&gt;们再来看看这个 &lt;strong&gt;工厂&lt;/strong&gt; BeanFactory&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先简单想一想这个工厂要怎么创建这个 Bean 呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，肯定就是这个 &lt;strong&gt;反射&lt;/strong&gt; 啦 😄&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，结合我们从原料中获取的重要属性之一的 beanClass ，我们可以画出这么一张图 👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.44776119402985076&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYnoKibDt7iaoUBBYYLZDmiaUuVp0qNbLC9iaqNpO5Rk8E0ErObSePlPnQUQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;670&quot;/&gt;&lt;figcaption&gt;image-20210901221544464&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么我们再来看看这个 BeanFactory 叭 😄&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;BeanFactory&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来看看 作为IOC 容器的&lt;strong&gt;根接口&lt;/strong&gt; 的 BeanFactory  提供了什么方法吧👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9006849315068494&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYFS4iafIWZH0GvxNiaVUCfmR0Ce9kDcSB2sibXUu4Ug9km7pRxnRA4RhBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;584&quot;/&gt;&lt;figcaption&gt;image-20210904162844126&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要是这个 getBean 方法，以及 &lt;strong&gt;别名获取&lt;/strong&gt;，&lt;strong&gt;类型获取&lt;/strong&gt; 方法和其他一些判断方法如 ：&lt;strong&gt;单例&lt;/strong&gt;，&lt;strong&gt;多例&lt;/strong&gt;，&lt;strong&gt;类型匹配&lt;/strong&gt;，&lt;strong&gt;包含bean&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来简单看看它的子接口都有哪些叭~😄&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里分享个小技巧叭🐖&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看源码的时候，一般就直接看这个&lt;strong&gt;默认&lt;/strong&gt;接口 如这里的 DefaultListableBeanFactory&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.488013698630137&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYgdSZWQ2TcpeDVImcK6jrrI0PiapV1Gy2AjJ0eh5mRzz9u2tBXC6Kozw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1168&quot;/&gt;&lt;figcaption&gt;image-20210904161436139&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本上看个类名就知道大概作用了，那么先对号入座下👇&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ListableBeanFactory&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;👉 遍历 bean&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;HierarchicalBeanFactory&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;👉  提供 父子关系，可以获取上一级的 BeanFactory&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ConfigurableBeanFactory&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;👉  实现了 SingletonBeanRegistry ，主要是 单例Bean的注册，生成&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;AutowireCapableBeanFactory&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;👉  和自动装配有关的&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;AbstractBeanFactory&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;👉  单例缓存，以及 FactoryBean 相关的&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ConfigurableListableBeanFactory&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;👉  预实例化单例Bean，分析，修改 BeanDefinition&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;AbstractAutowireCapableBeanFactory&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;👉 创建 Bean ，属性注入，实例化，调用初始化方法 等等&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;DefaultListableBeanFactory&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;👉 支持单例Bean ，Bean别名 ，父子BeanFactory，Bean 类型转化 ，Bean 后置处理，FactoryBean，自动装配等&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是不是非常丰富 😄&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;FactoryBean&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FactoryBean  ，它本身就是个 Bean，算是小工厂 ，归 BeanFactory 这个大工厂管理的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3247863247863248&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYdicclg8dIQDH1qozmmDEPPg9EjiayyuJoGfco6eyoKiaAtibYxLmcvJBHA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;585&quot;/&gt;&lt;figcaption&gt;image-20210904174616712&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到它就只有三个方法&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;getObject() 获取对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;isSingleton() 单例对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;getObjectType()  返回的是 Bean 对象的类型&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比大工厂 BeanFactory 少了特别多东西，没有严格的 Bean 生命周期流程&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 👉 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MjUzODc5Mw==&amp;amp;mid=2247488639&amp;amp;idx=1&amp;amp;sn=e772f1c8ba3110b4311df9ce39837966&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《三分钟快速了解Spring中的工厂模式》&lt;/a&gt; 一文中有介绍到 😄&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;FacotryBean 对象本身也是一个Bean，是一个小工厂，可以生产另外的 Bean&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BeanFactory 是 Spring 容器的根接口，是大工厂，生产各种各样的Bean&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;beanName  就是正常对象&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“&amp;amp;”+beanName   ， 获取的是实现了该接口的 FacotryBean 工厂对象&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大致如下 👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3133874239350913&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYP30NxrKoDOyLibRPheGib5vznatgWyfJY7Z4RqBWWUNMUKQFDlickrf7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;986&quot;/&gt;&lt;figcaption&gt;image-20210904180204105&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ApplicationContext&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再来看看这个 ApplicationContext&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2833904109589041&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYypLS6YT6DXTW5ibwicrvV6VmFCmsZBVtzpl6gIZvdfGBPG5gTzWibzmBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1168&quot;/&gt;&lt;figcaption&gt;image-20210904161808341&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到它扩展了很多功能，除了 BeanFactory ，它还可以&lt;strong&gt;创建 , 获取 Bean&lt;/strong&gt;，以及处理&lt;strong&gt;国际化&lt;/strong&gt;，&lt;strong&gt;事件&lt;/strong&gt;，&lt;strong&gt;获取资源&lt;/strong&gt;等&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;EnvironmentCapable  获取 环境变量 的功能，可以获取到 &lt;strong&gt;操作系统变量&lt;/strong&gt; 和 &lt;strong&gt;JVM 环境变量&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ListableBeanFactory 获取所有 BeanNames，判断某个 BeanName 是否存在 BeanDefinition 对象，统计 BeanDefinition 对象，获取某个类型对应的所有 beanNames 等功能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;HierarchicalBeanFactory  获取父 BeanFactory ，判断某个 name 是否存在 bean 对象的功能&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;MessageSource  &lt;strong&gt;国际化功能&lt;/strong&gt;，获取某个国际化资源&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ApplicationEventPublisher &lt;strong&gt;事件发布功能&lt;/strong&gt;（重点）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ResourcePatternResolver &lt;strong&gt;加载，获取资源的功能&lt;/strong&gt;，这里的资源可能是文件，图片 等某个URL资源都可以&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有这三个重要的类👇,就不一一介绍先啦😄&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ClassPathXmlApplicationContext&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AnnotationConfigApplicationContext&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;FileSystemXmlApplicationContext&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;赶紧来看看这个核心叭！&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;IOC 容器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，这时候出场的肯定是 IOC 啦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道 IOC 是 &lt;strong&gt;控制反转&lt;/strong&gt;  ，但是别忘了 &lt;strong&gt;容器&lt;/strong&gt; 这个词，比如 **容器的根接口 **BeanFactory  ，&lt;strong&gt;容器的实现&lt;/strong&gt; 👇&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ClassPathXmlApplicationContext&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;AnnotationConfigApplicationContext&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;FileSystemXmlApplicationContext&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时我们要注意这里无处不在的 &lt;strong&gt;后置处理器&lt;/strong&gt;  xxxPostProcessor 🐷&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个是 Spring 中扩展性强的原因了！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以在各个过程中合理应用这些 PostProcessor 来扩展，或者修改 Bean 定义信息等等&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6658986175115207&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYg6Y9Fxiae2KkD8NmzAuBpdz8Yh1rZ9rocHMjVQj91bnbC0oiam7VMaQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;868&quot;/&gt;&lt;figcaption&gt;image-20210901222805351&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到在这个容器中，完成了 Bean 的初始化，而这个过程还有很多细节 ，请往下看看👇&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DI 到时写 &lt;strong&gt;属性填充&lt;/strong&gt; 时再介绍🐷&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;BeanFactory 后置处理器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作为 IOC 容器根接口的 BeanFactory ，有着非常高的扩展性，比如最开始获取原料 BeanDefinition  时，就出现了两个针对 BeanFactory  工厂的后置处理器 👇&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BeanDefinitionRegistryPostProcessor&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;通过该接口，我们可以自己掌控我们的 &lt;strong&gt;原料&lt;/strong&gt;，通过 BeanDefinitionRegistry  接口去 &lt;strong&gt;新增&lt;/strong&gt;，&lt;strong&gt;删除&lt;/strong&gt;，&lt;strong&gt;获取&lt;/strong&gt;我们这个 BeanDefinition&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;BeanFactoryPostProcessor&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;通过该接口，可以在 &lt;strong&gt;实例化对象前&lt;/strong&gt;，对  BeanDefinition 进行修改 ，&lt;strong&gt;冻结&lt;/strong&gt; ，&lt;strong&gt;预实例化单例Bean&lt;/strong&gt; 等&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过上面层层阻碍后，我们最终会来到目标方法 getBean ，将原料投入生产，最终获取一个个 Bean 对象出来&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么随之而来的就是这个 Bean 的生命周期啦 😄&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Bean 生命周期&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Bean 的创建和管理有&lt;strong&gt;标准化的流程&lt;/strong&gt;！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里在我们的工厂 BeanFactory 中写得很清楚 👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4824175824175824&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYfPibFKooIQG2PEdib1xYveWicQCicFwZDoMGyNKrHajBVtlq94DwocnFOQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;910&quot;/&gt;&lt;figcaption&gt;image-20210902072224002&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总共 &lt;strong&gt;14&lt;/strong&gt; 个步骤，是不是一下子就清晰多了😄&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9222560975609756&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYFI0Fnpur6bqA4mOw29kiaV75OLMYYt6wUo40fKASNic6NcZkxRZhLa1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;656&quot;/&gt;&lt;figcaption&gt;image-20210902073122559&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在看这部分的源码时，要多注意两个英文单词 😝&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;实例化&lt;/strong&gt; 👉 &lt;strong&gt;Instantiation&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;初始化&lt;/strong&gt; 👉 &lt;strong&gt;Initialization&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ps: 别看快搞错了 哈哈😝&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仔细阅读上面这14个步骤，会发现前面 &lt;strong&gt;8&lt;/strong&gt; 个都是 Aware 接口，而他们的作用也很简单，就是获取 xxAware 这个单词的前缀 xx 😄&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们在上文 👉 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MjUzODc5Mw==&amp;amp;mid=2247488730&amp;amp;idx=1&amp;amp;sn=ec8d1155ef4a400a791cf89ef8aa633c&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《三分钟快速上手Spring事件机制》&lt;/a&gt; 中提到的事件发布器 ApplicationEventPublisher ，只要你实现了 ApplicationEventPublisherAware 接口，就可以&lt;strong&gt;获取&lt;/strong&gt; 事件发布器 ApplicationEventPublisher  ！&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Bean 后置处理器&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实例化 和 初始化流程中，把这个Bean 的后置处理器 BeanPostProcessor 安排上，就得到下图啦 👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9026946107784432&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYQYlpLYjcJYrSYDu1uGegt8KXWiaSibYm5icxguPUK4RXjRFcibz6iaq8FLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;668&quot;/&gt;&lt;figcaption&gt;image-20210902082034253&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里留意下 &lt;strong&gt;实例化&lt;/strong&gt; 有扩展点  InstantiationAwareBeanPostProcessor ， &lt;strong&gt;初始化&lt;/strong&gt; 扩展点 BeanPostProcessor 就非常多啦，我们主要来关注下这个 AOP&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;AOP&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么 AOP 是在哪个步骤代理对象的呢？👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5630885122410546&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYLkJSplLjNHavws9BfGqrEuWribcU59sm2icG5ichsSaSs8GXT8mwUkOcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1062&quot;/&gt;&lt;figcaption&gt;image-20210903080503505&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以在 AbstractAutoProxyCreator 类中看到 👇&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.40595238095238095&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYrbsibTib7CiaOHQBysMOzzozIy1AnvpVUJQvsnbTXJa86R3crk6SLtO1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;840&quot;/&gt;&lt;figcaption&gt;image-20210903080803199&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他具体信息在下文的 &lt;strong&gt;AOP插件&lt;/strong&gt; 一文中再讲一下😄&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于代理的知识点可以看看这里&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;👉  &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MjUzODc5Mw==&amp;amp;mid=2247487968&amp;amp;idx=1&amp;amp;sn=c2dbbdc444461b3568712119c170242e&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《Java代理模式和字节码的探索》&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;👉  &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg2MjUzODc5Mw==&amp;amp;mid=2247488415&amp;amp;idx=1&amp;amp;sn=2ac254a9862f49a7bb1d3b94cba27b86&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;《Cglib动态代理探索(ASM，Spring)》&lt;/a&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文就先介绍到这里啦🐖&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要介绍了 Spring 里面的这些脉络，方便小伙伴们对它有个整体的印象先~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再介绍其中的一些扩展点，比如从源材料的 BeanFactoryPostprocessor ，到产物 Bean 的 BeanPostprocessor 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实例化，初始化的顺序，Bean的生命周期，以及 BeanFactory 及子类扩展的功能，再到 ApplicationContext 的功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还有这个核心机制：&lt;strong&gt;工厂+XML+反射&lt;/strong&gt;，以及引出下文要说的 AOP &lt;strong&gt;发生的地方&lt;/strong&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.43116883116883115&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zIjiaGEEKdYFtYp2o13U0340FTvUeUNicYuqBRQM6e9uz1wrwZE5h4UepOHEeOD8yrGMObGx28H83AbcglnLKcsw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1155&quot;/&gt;&lt;figcaption&gt;image-20210904203613899&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本期的思维导图会和后面的章节汇总一起再分享哦😋&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;ps&lt;/strong&gt;：最近忙起来啦，更文速度会慢一些哦~ ，喜欢的话可以 &lt;strong&gt;星标&lt;/strong&gt; 哦，这样可以第一时间收到更文消息🐷&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我是4ye 咱们下期应该……很快再见！！&lt;/strong&gt; 😆&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;喜欢的话还可以关注下公众号 &lt;strong&gt;Java4ye&lt;/strong&gt; 支持下 &lt;strong&gt;4ye&lt;/strong&gt; 呀😝&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>27ae7164fa30f5cc799cb32d2dd4058c</guid>
<title>开源浪潮下程序员的职业规划和成长</title>
<link>https://toutiao.io/k/jqs1x8f</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-hnrfcf&quot; options=&quot;[object Object]&quot;&gt;&lt;p&gt;无论从年初开源社发布的《2020 中国开源年度报告》还是整体的大环境，不难看到中国的开源正在崛起，越来越多的来自中国的开源项目和开发者们正在走入大家的视野。在开源浪潮的大趋势下，程序员又该如何规划自己的职业以及个人成长呢？不如听听正在全职做开源的工程师张晋涛怎么说。&lt;/p&gt;&lt;p&gt;大家好，今天我分享的主题是《开源浪潮下程序员的职业规划和成长》。今天在这里聊两个项目，一个是 Apache APISIX，APISIX 是 Apache 基金会旗下的顶级开源项目。第二个项目是 ingress-nginx，它是 Kubernetes 整个生态圈里头，除去 Kubernetes 自身以外使用频率最高的软件之一了。搞过 Kubernetes 的同学应该基本上都用过这个项目。&lt;/p&gt;&lt;p&gt;今天我分享的内容主要从四个方面来聊：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;开源的文化&lt;/li&gt;&lt;li&gt;如何参与开源&lt;/li&gt;&lt;li&gt;关于我的故事&lt;/li&gt;&lt;li&gt;职业规划相关的内容&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;了解开源文化&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;自由软件运动&lt;/b&gt;&lt;/p&gt;&lt;p&gt;提到开源文化，首先需要了解自由软件运动。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3e949cb619c4c8505966274a08fdd96d_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;670&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-3e949cb619c4c8505966274a08fdd96d_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;670&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-3e949cb619c4c8505966274a08fdd96d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-3e949cb619c4c8505966274a08fdd96d_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;图右是被称为自由软件之父的斯托曼，他在 1983 年提出了 GNU 计划。1984 年，斯托曼提出了 Copyleft 的概念，Copyleft 跟我们平时用到的版权 Copyright 是相对应的，它放弃了 Copyright 类似对版权的严格限制。&lt;/p&gt;&lt;p&gt;1985 年，斯托曼成立了自由软件基金会，目的是为了能够让自由软件更好地发展。在当时，很多软件都是专有软件或者商用软件，任何人使用这些软件都是需要付费的。斯托曼认为随着计算机的发展，如果商用软件、付费软件掌握在极少数公司的情况下，那么我们将会逐步失去自由。因为很多商业软件或者专用软件都是由商业公司，或者是极少数的人掌握着，如果你依赖这些软件，都必须依赖于其他人，你的命脉就掌握在了他们手中，就不可能获得自由。&lt;/p&gt;&lt;p&gt;1989 年，出现了第一个 GNU 的通用协议，叫做 GPL。&lt;/p&gt;&lt;p&gt;接下来，我们来看下在自由软件运动之后发生了什么事情。想必大家都接触过 Linux 操作系统。Linux 操作系统的创始人是林纳斯·托瓦兹，他在 1991 年首次发布了 Linux 操作系统，并且选择了将它的源代码直接发布到网络上，供其他人去使用和分享。&lt;/p&gt;&lt;p&gt;在这个时候，斯托曼找到了林纳斯。GNU 自由软件基金会的主要目标是希望能够创建出所有人都可以使用的基础软件，包括操作系统。直到 1991 年 Linux 操作系统发布的时候，GNU 自由软件基金会已经完成了所有基础类的自由软件开发，但是它没完成最核心的操作系统的开发。所以，斯托曼找上了林纳斯。结果我们都知道，Linux 操作系统的完整名字是 GNU/Linux。&lt;/p&gt;&lt;p&gt;&lt;b&gt;开源协作与文化&lt;/b&gt;&lt;/p&gt;&lt;p&gt;聊完自由软件运动、Linux 操作系统，来看下我们现在所接触到的开源协作和开源文化。&lt;/p&gt;&lt;p&gt;&lt;b&gt;开放&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在开源协作中，基本的理念就是开放。但很多人可能对此有误解，认为开放源代码就等于开放，其实不然。源代码的开放和真正的开放并不一样。举个简单的例子：MongoDB。&lt;/p&gt;&lt;p&gt;MongoDB 是一个文档类型的数据库。近几年，MongoDB 修改了一次协议 SSPL，称之为服务端公共许可证，协议更改之后有什么变化呢？它的协议规定任何一个云厂商，如果在云服务上使用了 MongoDB，就必须把在 MongoDB 之上所做的更改，包括管控端的源代码都开源出来。&lt;/p&gt;&lt;p&gt;大家想一下这个事情可能吗？&lt;/p&gt;&lt;p&gt;其实不可能，任何一个云厂商，它对所有基础软件，或者所有开源软件的变更，都是它的核心，是它的命脉。所以说，MongoDB 这一次修改其实是带有针对性的，它针对的是这些云厂商。在开源软件的基本协定之下，这其实属于不开放的协议。&lt;/p&gt;&lt;p&gt;再有就是前段时间，Elasticsearch 也宣布其使用 SSPL，这导致 AWS 基于之前 Apache 协议的代码直接 fork 了一个版本，并称之为 OpenSearch 。这也是对这种不开放的行为的一种应对方式。&lt;/p&gt;&lt;p&gt;&lt;b&gt;协同&lt;/b&gt;&lt;/p&gt;&lt;p&gt;开源文化当中提到另外一点，就是协作。Linux 操作系统为什么能够获得成功？因为 1991 年的时候林纳斯发布了第一个 Linux 的版本，把源代码直接公开到了互联网上，其他人可以直接下载源代码，并且对这些源代码进行修改。&lt;/p&gt;&lt;p&gt;在 1991 年，林纳斯发布完 Linux 第一个可供下载和使用的版本时，其实自由软件基金会旗下还有其他人也在写给 GNU 使用的内核，只是没有 Linux 的完成度高。&lt;/p&gt;&lt;p&gt;为什么它没有发展起来呢？因为它是由固定的几个人在做这个事情，且仅有那么几个人，只有它真正对外公开发布了一个版本，外界才会了解到。这里就不得不提到一种思想，那就是大教堂与集市。这是一个什么概念呢？&lt;/p&gt;&lt;p&gt;可以这样理解，传统的软件开发过程像大家在修建一个大教堂一样，只有极少数的精英工匠参与其中。而开源软件提倡的开放和协同，主要指将软件当成一个大集市，每个人都是自由的，大家都可以互相协作，每个人贡献自己的一份力量。有专门一本书，来阐述这些理念，就叫做《大教堂与集市》，感兴趣可以看看。&lt;/p&gt;&lt;p&gt;&lt;b&gt;开源软件&lt;/b&gt;&lt;/p&gt;&lt;p&gt;聊完开源理念，我们最后来说说开源软件。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-67b0d49c80312016c3021bd8c063e26b_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;627&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-67b0d49c80312016c3021bd8c063e26b_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;627&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-67b0d49c80312016c3021bd8c063e26b_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-67b0d49c80312016c3021bd8c063e26b_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;开源软件的前提是开放源代码，这是必不可少的。另外，其实每个开源软件都是有开源许可证的，刚才我们聊 MongoDB 的时候也提到了，它的许可证是不被认可的。&lt;b&gt;开源软件核心价值观就是不歧视、中立、开放。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;目前国内开源生态整体向好，有很多进入开源软件基金会的项目，无论是进入 Apache 软件基金会，还是 CNCF，亦或 Linux 的基金会。其中有很多的项目例如 ApacheAPISIX 就是 Apache 基金会旗下的顶级开源项目，通过 Apache-2.0 License 进行分发，这是一种非常开放且友好的协议。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;如何参与开源&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;很多人对于参与开源有一些误解。有些人认为，我在使用一个开源软件，并且在它的 GitHub 上面提交了 issue，提交了 pull request 之类的，认为就是在参与开源项目了。还有一些人认为，我写了一个软件或者程序，我把它放在 GitHub 上面，代码是公开的，认为自己在做开源了。其实不然（尽管我们也认可为开源项目所做的贡献）。&lt;/p&gt;&lt;p&gt;&lt;b&gt;做开源的前提是基于你对开源文化的认同。&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-a25a43d07010fda57fdaf255b0412935_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;607&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-a25a43d07010fda57fdaf255b0412935_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;607&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-a25a43d07010fda57fdaf255b0412935_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a25a43d07010fda57fdaf255b0412935_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;开源文化的最主要是平等、中立、开放、一致、文档优先。一致是什么意思呢？意味着你的软件在这个环境和在另外一个环境当中产生的结果是一样的。&lt;/p&gt;&lt;p&gt;那么如何选择一个开源项目呢？&lt;/p&gt;&lt;p&gt;从我个人角度来讲，&lt;b&gt;首先一定是兴趣使然的。&lt;/b&gt;我不会选择一个自己并不太感兴趣的项目去参与。因为这样子是不可持续的。也有很多人问过我，参与开源你能收获什么？为什么你愿意花费那么多的时间和精力在这个事情上面？在参与开源项目的前期，或者很长的一段时间，其实没有任何收获，尤其是物质上的收获一点都没有。所以这也是我为什么提了一定是要自己感兴趣的。&lt;/p&gt;&lt;p&gt;&lt;b&gt;其次，持续投入非常重要。&lt;/b&gt;在一个开源项目中，如果你只是想起来了参与一下，而不是持续地投入，也不会有较高的价值产生。&lt;/p&gt;&lt;p&gt;&lt;b&gt;最后，应该选择一个比较活跃的社区。&lt;/b&gt;如果项目的社区已经非常的不活跃，你参与到这个项目当中就很难。比如你提交 issue，提交 pull request，很少有人会给你对应的回复。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-621165ea526ca7cc5f601bf0a8ee067a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1164&quot; data-rawheight=&quot;710&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-621165ea526ca7cc5f601bf0a8ee067a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1164&quot; data-rawheight=&quot;710&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-621165ea526ca7cc5f601bf0a8ee067a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-621165ea526ca7cc5f601bf0a8ee067a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这里我选取了三个项目做对比，ApacheAPISIX、Kong 和 tyk。目前可以看到活跃度最高的是 Apache APISIX，每天都有很多的开发者会参与到 Apache APISIX 的社区中，帮助别人解答问题，或者为 Apache APISIX 提交 PR 等，大家彼此都会在这么活跃的社区中成长和收获。&lt;/p&gt;&lt;p&gt;&lt;b&gt;开源协作的中立也是一种很重要的价值观。&lt;/b&gt;无论你是提交代码，或者回复别人的 issue，这些我认为是其次的。最重要的是应该基于平等、尊重、中立的心态去参与到项目当中。&lt;/p&gt;&lt;p&gt;我现在主要参与的是 Apache APISIX 当中的一个子项目 APISIX ingress，还有一个是 Kubernetes ingress-nginx。这两个项目都是 Kubernetes controller 的项目，做的事情是类似的，但是参与开源项目过程中，我始终保持着中立的态度，而不会因为我在支流科技就大力发展 APISIX ingress 项目，限制 ingress-nginx 项目的发展，这是不存在的。所以心态很重要，只有保持中立的心态才能持续地参与到开源项目当中。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;聊聊我的故事&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;&lt;b&gt;我的职业路径&lt;/b&gt;&lt;/p&gt;&lt;p&gt;接下来聊一下我发展的过程和职业规划上的选择。&lt;/p&gt;&lt;p&gt;我的第一份工作 title 是 Web 开发工程师，主要是在做后端开发，也会兼顾一部分的前端开发工作，以及运维及 DBA 的任务。第二份工作是在做运维开发，会涉及一部分的运维工作，主业也还是在做开发。再后来就是做容器化的开发，现在我是支流科技的技术专家，做的事情主要是做开源基础软件。这些年前端、后端、运维、数据库、中间件，基础软件，容器化技术基本都有涉及到，这是我的职业整体路线。&lt;/p&gt;&lt;p&gt;很多人问过我这样的问题，特别是在跟 HR 沟通的时候。他们会问我，你为什么从 Web 开发做了运维开发，这是第一个时间点。第二个时间点，为什么从运维开发，到做基础软件以及全职做开源的事情。&lt;/p&gt;&lt;p&gt;我做 Web 开发，大概是七八年前，那个时候像服务器通常是 32G 或者 64G 的内存。但是现在，我的笔记本已经是 32G 的内存了，可以想象当时硬件资源是比较紧张的。在实际做后端开发中，当业务量上来的时候，我们会去做很多性能优化相关的工作。&lt;/p&gt;&lt;p&gt;那个时候，我们会花很多的时间去做优化，现在遇到性能的问题可能很简单，加一台机器扩容一下就搞定了。但在那个时候大家的第一想法就是做性能优化，怎么样可以充分地压榨资源，这是我们当时做的事情。在这个过程当中，偏底层的事情我做得更多些。&lt;/p&gt;&lt;p&gt;在 2014 年，我开始接触 Docker。2013 年Docker 首次开源，我在国内算是比较早一批接触到 Docker 的。我很喜欢这些底层的技术，包括容器化的技术。在职业选择的时候，我就从 Web 开发转向了运维开发。做运维开发的时候，前期是做运维平台化的开发，运维平台化、运维自动化、包括 GitOps 和ChatOps 等等。&lt;/p&gt;&lt;p&gt;随着 Kubernetes 在容器化编排技术争夺战中成为了王者。很多公司开始做容器化改造，我们也选择了 Kubernetes 做自己的容器平台。这个时候，由于我在容器化技术这方面，积淀相对比较多一些，自然也就承担了相关的工作内容。&lt;/p&gt;&lt;p&gt;再后来工作的选择，因为我想要更多的自由，也想更倾向于自己的兴趣，而在公司做项目的话，确实不够自由，所以我现在的工作是全职做开源，我可以在任何一个我喜欢工作的时间，或者想要工作的时间去工作。&lt;/p&gt;&lt;p&gt;&lt;b&gt;有一些人评价我说，我是把我的兴趣做成了我的工作。&lt;/b&gt;其实是的，即使没有这份工作，我也会持续地去做开源。工作时间做开源，闲暇的时间也在做开源，这个本身来讲也没有什么界限。这是我目前的现状，自由、全职做开源的工程师。&lt;/p&gt;&lt;p&gt;&lt;b&gt;职业规划&lt;/b&gt;&lt;/p&gt;&lt;p&gt;接下来，我们来看一下职业规划。大家可能对于我到底是什么样的情况并不关心，更应该想知道在开源的场景里如何做职业规划。&lt;/p&gt;&lt;p&gt;我现在一方面是做开源相关的工作，再有一方面，也在做自媒体。&lt;b&gt;我认为做职业规划最重要的一点是基于自己的兴趣。&lt;/b&gt;一天一共就 24 小时，除去睡觉的时间，剩下的几个小时如果做的是自己不感兴趣的工作，一直处于不开心的状态，那真是太惨了。所以一定要选择自己喜欢的、感兴趣的工作，这是第一点。&lt;/p&gt;&lt;p&gt;&lt;b&gt;第二点就是核心竞争力。&lt;/b&gt;既然是程序员，无论是前端、后端、运维，还是其他开发，自身的技术实力才是核心竞争力。现在有个词很流行，那就是“内卷”，为什么内卷会让人产生焦虑感呢？焦虑到底是怎么来的？&lt;/p&gt;&lt;p&gt;我是这么理解的，焦虑就是别人在学，我不学，我可能会很焦虑；别人会，我不会，我也会焦虑；别人知道，我不知道，那更焦虑；还有就是别人在聊这些，我听的一脸懵逼，这些都是焦虑的产生原因。&lt;/p&gt;&lt;p&gt;那如何应对这个问题呢？那就是提升你的核心竞争力。首先选一个自己最感兴趣的方向，提升自己的技术深度，这样才能持续地提升自己的核心竞争力。技术深度就跟海面上的冰山差不多，海面上你可以看到的只有那么一小点，但在海面之下还有很多很多。&lt;/p&gt;&lt;p&gt;技术的深度是无限的，当你把技术深度提升到一定程度之后，你会发现好像我不知道的东西越来越多，这是一个技术人常常会有的感觉。如果你很长时间没有这种感觉了，认为好像所有的东西我都知道，所有面临的问题我都能解决。这个情况我认为，你可能需要去参与一些开源项目，或者出去跟别人交流一下，或者换一份工作，开阔一下自己的眼界。&lt;b&gt;当你的技术深度到了一定程度，例如能 cover 住面临的绝大多数问题时，我建议你在这个时候尽量提升一下自己的技术广度。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;b&gt;第三点我要说的是价值。&lt;/b&gt;价值这个概念非常宽泛，在做工作中最直观体现价值的，那就是薪资。当然，薪资只是一方面，另一方面在于你能够收获到什么。&lt;/p&gt;&lt;p&gt;我们回到刚才第一点，也就是工作开不开心的事情。如果说你的工作薪资是令人满意的，同时你又能收获一些开心，那就赚到了。因为公司本来给你提供的，是一种雇佣关系，他给到你的本质上来讲只有你的薪资。而你做这份工作的同时，收获了一些乐趣，其实也就是赚到了。&lt;b&gt;收获开心，这是我要提到价值当中的第一点。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;此外，在工作的过程当中，你肯定不是一个人在独自战斗，&lt;b&gt;你也会收获到一些伙伴，这是第二点。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;第三点，在这份工作当中，你还实现自己价值的提升。这些价值可以理解为心理学当中或者社会学当中提到的认可，&lt;b&gt;当你获得别人或者社会的一些认可。&lt;/b&gt;这也是价值的一部分。&lt;/p&gt;&lt;p&gt;&lt;b&gt;程序员的副业&lt;/b&gt;&lt;/p&gt;&lt;p&gt;最后我们来聊聊程序员的副业，这个事情也许大家会比较感兴趣一些。在谈到副业的时候，你要先评估一下自己能做什么，量力而行在任何情况下都是比较正确的。承认自己在某些方面不擅长，或者某些方面不太懂这个事情其实没有什么的，如果强行做不擅长的事情，可能得到的结果并不太好。&lt;/p&gt;&lt;p&gt;我来聊一下我自己个人做的一些东西。我之前写了一个专栏，叫 《Kubernetes 上手实践》。后来又写了一个专栏，叫做 《Docker 核心知识必会》。我自己在这方面相对来说积累比较多一点，这里就不多说了，说多了就变成广告了（笑），不过你可以关注下我的公众号：MoeLove ，我会跟你分享一些有价值的技术和内容。&lt;/p&gt;&lt;p&gt;很多人可能会问我能做什么？我认为其实还是有很多的事情可以做，具体肯定看个人的选择。做副业能为自己带来最直观的，大家可能认为是金钱收益。但实际上如果你把耗费的时间精力折算一下，可能会发现这个事情收益很少。陪陪家人、跟爱人约个会，出去玩一趟，可能能收获的更多。现在整体来说就是两种选择，一是用时间换钱，另一种是用钱换时间。很多事情如果年轻的时候错过了还是会很遗憾的。所以还是要建议大家根据自己的情况衡量一下。&lt;/p&gt;&lt;p&gt;以上是今天的全部分享内容，来简单总结下：第一部分聊了平等、中立、自由的开源文化；接着谈了如何参与开源，心态一定要摆正，同时要基于自己个人的兴趣；最后聊到一些个人成长，还是建议大家应根据自己的实际情况，合理地规划一下自己的的职业生涯，谢谢大家。&lt;/p&gt;&lt;p&gt;&lt;b&gt;视频与PPT请戳：&lt;/b&gt;&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/opentalk/463.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic3.zhimg.com/v2-5fff19c93245b8d497f7205401414536_180x120.jpg&quot; data-image-width=&quot;960&quot; data-image-height=&quot;540&quot; data-text=&quot;开源浪潮下程序员的职业规划和成长&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>37993524ffb71d4c56b61d65adb85fbd</guid>
<title>为什么要分布式 id ？分布式 id 生成方案有哪些？</title>
<link>https://toutiao.io/k/0kuz75c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-hnrfcf&quot; options=&quot;[object Object]&quot;&gt;&lt;blockquote&gt;本文已经收录进 Github 110k+ 点赞的 Java 知识点总结类开源项目 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gitee.com/SnailClimb/JavaGuide&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JavaGuide&lt;/a&gt; ，【Java学习+面试指南】 一份涵盖大部分Java程序员所需要掌握的核心知识。&lt;/blockquote&gt;&lt;p&gt;分享一道朋友去京东面试真实遇到的面试题：“为什么要分布式ID？你项目中是怎么做的？”。&lt;/p&gt;&lt;p&gt;这篇文章我会说说自己的看法，详细介绍一下分布式ID相关的内容包括分布式 ID 的基本要求以及分布式 ID 常见的解决方案。&lt;/p&gt;&lt;p&gt;这篇文章全程都是大白话的形式，希望能够为你带来帮助！&lt;/p&gt;&lt;p&gt;&lt;b&gt;原创不易，若有帮助，点赞/分享就是对我最大的鼓励！&lt;/b&gt;&lt;/p&gt;&lt;p&gt;&lt;i&gt;个人能力有限。如果文章有任何需要补充/完善/修改的地方，欢迎在评论区指出，共同进步！&lt;/i&gt;&lt;/p&gt;&lt;h2&gt;&lt;b&gt;分布式 ID&lt;/b&gt;&lt;/h2&gt;&lt;h3&gt;&lt;b&gt;何为 ID？&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;日常开发中，我们需要对系统中的各种数据使用 ID 唯一表示，比如用户 ID 对应且仅对应一个人，商品 ID 对应且仅对应一件商品，订单 ID 对应且仅对应一个订单。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-0e10300de1c6fc6f7ac9e256f2c66d1e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;433&quot; data-rawheight=&quot;325&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-0e10300de1c6fc6f7ac9e256f2c66d1e_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;433&quot; data-rawheight=&quot;325&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-0e10300de1c6fc6f7ac9e256f2c66d1e_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-0e10300de1c6fc6f7ac9e256f2c66d1e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们现实生活中也有各种 ID，比如身份证 ID 对应且仅对应一个人、地址 ID 对应且仅对应&lt;/p&gt;&lt;p&gt;简单来说，&lt;b&gt;ID 就是数据的唯一标识&lt;/b&gt;。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;何为分布式 ID？&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;分布式 ID 是分布式系统下的 ID。分布式 ID 不存在与现实生活中，属于计算机系统中的一个概念。&lt;/p&gt;&lt;p&gt;我简单举一个分库分表的例子。&lt;/p&gt;&lt;p&gt;我司的一个项目，使用的是单机 MySQL 。但是，没想到的是，项目上线一个月之后，随着使用人数越来越多，整个系统的数据量将越来越大。&lt;/p&gt;&lt;p&gt;单机 MySQL 已经没办法支撑了，需要进行分库分表（推荐 Sharding-JDBC）。&lt;/p&gt;&lt;p&gt;在分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。&lt;b&gt;我们如何为不同的数据节点生成全局唯一主键呢？&lt;/b&gt;&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-6d694779c7d47e3573939f21993318df_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;342&quot; data-rawheight=&quot;431&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;342&quot; data-rawheight=&quot;431&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-6d694779c7d47e3573939f21993318df_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;这个时候就需要生成&lt;b&gt;分布式 ID&lt;/b&gt;了。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;分布式 ID 需要满足哪些要求?&lt;/b&gt;&lt;/h3&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-bd2e3078390035dd00323a4cbbf67c93_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;421&quot; data-rawheight=&quot;411&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-bd2e3078390035dd00323a4cbbf67c93_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;421&quot; data-rawheight=&quot;411&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-bd2e3078390035dd00323a4cbbf67c93_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-bd2e3078390035dd00323a4cbbf67c93_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;分布式 ID 作为分布式系统中必不可少的一环，很多地方都要用到分布式 ID。&lt;/p&gt;&lt;p&gt;一个最基本的分布式 ID 需要满足下面这些要求：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;全局唯一&lt;/b&gt; ：ID 的全局唯一性肯定是首先要满足的！&lt;/li&gt;&lt;li&gt;&lt;b&gt;高性能&lt;/b&gt; ： 分布式 ID 的生成速度要快，对本地资源消耗要小。&lt;/li&gt;&lt;li&gt;&lt;b&gt;高可用&lt;/b&gt; ：生成分布式 ID 的服务要保证可用性无限接近于 100%。&lt;/li&gt;&lt;li&gt;&lt;b&gt;方便易用&lt;/b&gt; ：拿来即用，使用方便，快速接入！&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;除了这些之外，一个比较好的分布式 ID 还应保证：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;安全&lt;/b&gt; ：ID 中不包含敏感信息。&lt;/li&gt;&lt;li&gt;&lt;b&gt;有序递增&lt;/b&gt; ：如果要把 ID 存放在数据库的话，ID 的有序性可以提升数据库写入速度。并且，很多时候 ，我们还很有可能会直接通过 ID 来进行排序。&lt;/li&gt;&lt;li&gt;&lt;b&gt;有具体的业务含义&lt;/b&gt; ：生成的 ID 如果能有具体的业务含义，可以让定位问题以及开发更透明化（通过 ID 就能确定是哪个业务）。&lt;/li&gt;&lt;li&gt;&lt;b&gt;独立部署&lt;/b&gt; ：也就是分布式系统单独有一个发号器服务，专门用来生成分布式 ID。这样就生成 ID 的服务可以和业务相关的服务解耦。不过，这样同样带来了网络调用消耗增加的问题。总的来说，如果需要用到分布式 ID 的场景比较多的话，独立部署的发号器服务还是很有必要的。&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;&lt;b&gt;分布式 ID 常见解决方案&lt;/b&gt;&lt;/h2&gt;&lt;h3&gt;&lt;b&gt;数据库&lt;/b&gt;&lt;/h3&gt;&lt;h3&gt;&lt;b&gt;数据库主键自增&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;这种方式就比较简单直白了，就是通过关系型数据库的自增主键产生来唯一的 ID。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-b39917f16d51b05341473914f4407d34_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;231&quot; data-rawheight=&quot;231&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;231&quot; data-rawheight=&quot;231&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-b39917f16d51b05341473914f4407d34_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;以 MySQL 举例，我们通过下面的方式即可。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.创建一个数据库表。&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;CREATE TABLE `sequence_id` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT,
  `stub` char(10) NOT NULL DEFAULT &#x27;&#x27;,
  PRIMARY KEY (`id`),
  UNIQUE KEY `stub` (`stub`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;stub&lt;/code&gt; 字段无意义，只是为了占位，便于我们插入或者修改数据。并且，给 &lt;code&gt;stub&lt;/code&gt; 字段创建了唯一索引，保证其唯一性。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.通过 &lt;code&gt;replace into&lt;/code&gt; 来插入数据。&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;BEGIN;
REPLACE INTO sequence_id (stub) VALUES (&#x27;stub&#x27;);
SELECT LAST_INSERT_ID();
COMMIT;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;插入数据这里，我们没有使用 &lt;code&gt;insert into&lt;/code&gt; 而是使用 &lt;code&gt;replace into&lt;/code&gt; 来插入数据，具体步骤是这样的：&lt;/p&gt;&lt;p&gt;1)第一步： 尝试把数据插入到表中。&lt;/p&gt;&lt;p&gt;2)第二步： 如果主键或唯一索引字段出现重复数据错误而插入失败时，先从表中删除含有重复关键字值的冲突行，然后再次尝试把数据插入到表中。&lt;/p&gt;&lt;p&gt;这种方式的优缺点也比较明显：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;优点&lt;/b&gt; ：实现起来比较简单、ID 有序递增、存储消耗空间小&lt;/li&gt;&lt;li&gt;&lt;b&gt;缺点&lt;/b&gt; ： 支持的并发量不大、存在数据库单点问题（可以使用数据库集群解决，不过增加了复杂度）、ID 没有具体业务含义、安全问题（比如根据订单 ID 的递增规律就能推算出每天的订单量，商业机密啊！ ）、每次获取 ID 都要访问一次数据库（增加了对数据库的压力，获取速度也慢）&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;数据库号段模式&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;数据库主键自增这种模式，每次获取 ID 都要访问一次数据库，ID 需求比较大的时候，肯定是不行的。&lt;/p&gt;&lt;p&gt;如果我们可以批量获取，然后存在在内存里面，需要用到的时候，直接从内存里面拿就舒服了！这也就是我们说的 &lt;b&gt;基于数据库的号段模式来生成分布式 ID。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;数据库的号段模式也是目前比较主流的一种分布式 ID 生成方式。像滴滴开源的&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/didi/tinyid/wiki/tinyid%25E5%258E%259F%25E7%2590%2586%25E4%25BB%258B%25E7%25BB%258D&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Tinyid&lt;/a&gt; 就是基于这种方式来做的。不过，TinyId 使用了双号段缓存、增加多 db 支持等方式来进一步优化。&lt;/p&gt;&lt;p&gt;以 MySQL 举例，我们通过下面的方式即可。&lt;/p&gt;&lt;p&gt;&lt;b&gt;1.创建一个数据库表。&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;CREATE TABLE `sequence_id_generator` (
  `id` int(10) NOT NULL,
  `current_max_id` bigint(20) NOT NULL COMMENT &#x27;当前最大id&#x27;,
  `step` int(10) NOT NULL COMMENT &#x27;号段的长度&#x27;,
  `version` int(20) NOT NULL COMMENT &#x27;版本号&#x27;,
  `biz_type`    int(20) NOT NULL COMMENT &#x27;业务类型&#x27;,
   PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;current_max_id&lt;/code&gt; 字段和&lt;code&gt;step&lt;/code&gt;字段主要用于获取批量 ID，获取的批量 id 为： &lt;code&gt;current_max_id ~ current_max_id+step&lt;/code&gt;。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-91181f7a85dae4e0997fec9be7ed9f42_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;382&quot; data-rawheight=&quot;249&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;382&quot; data-rawheight=&quot;249&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-91181f7a85dae4e0997fec9be7ed9f42_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;code&gt;version&lt;/code&gt; 字段主要用于解决并发问题（乐观锁）,&lt;code&gt;biz_type&lt;/code&gt; 主要用于表示业余类型。&lt;/p&gt;&lt;p&gt;&lt;b&gt;2.先插入一行数据。&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;INSERT INTO `sequence_id_generator` (`id`, `current_max_id`, `step`, `version`, `biz_type`)
VALUES
 (1, 0, 100, 0, 101);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;3.通过 SELECT 获取指定业务下的批量唯一 ID&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;SELECT `current_max_id`, `step`,`version` FROM `sequence_id_generator` where `biz_type` = 101
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;id current_max_id step version biz_type
1 0 100 1 101
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;4.不够用的话，更新之后重新 SELECT 即可。&lt;/b&gt;&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;UPDATE sequence_id_generator SET current_max_id = 0+100, version=version+1 WHERE version = 0  AND `biz_type` = 101
SELECT `current_max_id`, `step`,`version` FROM `sequence_id_generator` where `biz_type` = 101
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;id current_max_id step version biz_type
1 100 100 1 101
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;相比于数据库主键自增的方式，&lt;b&gt;数据库的号段模式对于数据库的访问次数更少，数据库压力更小。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;另外，为了避免单点问题，你可以从使用主从模式来提高可用性。&lt;/p&gt;&lt;p&gt;&lt;b&gt;数据库号段模式的优缺点:&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;优点&lt;/b&gt; ：ID 有序递增、存储消耗空间小&lt;/li&gt;&lt;li&gt;&lt;b&gt;缺点&lt;/b&gt; ：存在数据库单点问题（可以使用数据库集群解决，不过增加了复杂度）、ID 没有具体业务含义、安全问题（比如根据订单 ID 的递增规律就能推算出每天的订单量，商业机密啊！ ）&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;NoSQL&lt;/b&gt;&lt;/h3&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-c677463c12eb6e677330561f83422d41_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;231&quot; data-rawheight=&quot;231&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;231&quot; data-rawheight=&quot;231&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-c677463c12eb6e677330561f83422d41_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;一般情况下，NoSQL 方案使用 Redis 多一些。我们通过 Redis 的 &lt;code&gt;incr&lt;/code&gt; 命令即可实现对 id 原子顺序递增。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;127.0.0.1:6379&amp;gt; set sequence_id_biz_type 1
OK
127.0.0.1:6379&amp;gt; incr sequence_id_biz_type
(integer) 2
127.0.0.1:6379&amp;gt; get sequence_id_biz_type
&quot;2&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了提高可用性和并发，我们可以使用 Redis Cluser。Redis Cluser 是 Redis 官方提供的 Redis 集群解决方案（3.0+版本）。&lt;/p&gt;&lt;p&gt;除了 Redis Cluser 之外，你也可以使用开源的 Redis 集群方案&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/CodisLabs/codis&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Codis&lt;/a&gt; （大规模集群比如上百个节点的时候比较推荐）。&lt;/p&gt;&lt;p&gt;除了高可用和并发之外，我们知道 Redis 基于内存，我们需要持久化数据，避免重启机器或者机器故障后数据丢失。Redis 支持两种不同的持久化方式：&lt;b&gt;快照（snapshotting，RDB）&lt;/b&gt;、&lt;b&gt;只追加文件（append-only file, AOF）&lt;/b&gt;。 并且，Redis 4.0 开始支持 &lt;b&gt;RDB 和 AOF 的混合持久化&lt;/b&gt;（默认关闭，可以通过配置项 &lt;code&gt;aof-use-rdb-preamble&lt;/code&gt; 开启）。&lt;/p&gt;&lt;p&gt;关于 Redis 持久化，我这里就不过多介绍。不了解这部分内容的小伙伴，可以看看 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//snailclimb.gitee.io/javaguide/%23/docs/database/Redis/redis-all&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JavaGuide 对于 Redis 知识点的总结&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;b&gt;Redis 方案的优缺点：&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;优点&lt;/b&gt; ： 性能不错并且生成的 ID 是有序递增的&lt;/li&gt;&lt;li&gt;&lt;b&gt;缺点&lt;/b&gt; ： 和数据库主键自增方案的缺点类似&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;除了 Redis 之外，MongoDB ObjectId 经常也会被拿来当做分布式 ID 的解决方案。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-12fea698bf8b4b67ff7bf015bf99fba8_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;793&quot; data-rawheight=&quot;185&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-12fea698bf8b4b67ff7bf015bf99fba8_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;793&quot; data-rawheight=&quot;185&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-12fea698bf8b4b67ff7bf015bf99fba8_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-12fea698bf8b4b67ff7bf015bf99fba8_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;MongoDB ObjectId 一共需要 12 个字节存储：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;0~3：时间戳&lt;/li&gt;&lt;li&gt;3~6： 代表机器 ID&lt;/li&gt;&lt;li&gt;7~8：机器进程 ID&lt;/li&gt;&lt;li&gt;9~11 ：自增值&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;MongoDB 方案的优缺点：&lt;/b&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;优点&lt;/b&gt; ： 性能不错并且生成的 ID 是有序递增的&lt;/li&gt;&lt;li&gt;&lt;b&gt;缺点&lt;/b&gt; ： 需要解决重复 ID 问题（当机器时间不对的情况下，可能导致会产生重复 ID） 、有安全性问题（ID 生成有规律性）&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;算法&lt;/b&gt;&lt;/h3&gt;&lt;h3&gt;&lt;b&gt;UUID&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;UUID 是 Universally Unique Identifier（通用唯一标识符） 的缩写。UUID 包含 32 个 16 进制数字（8-4-4-4-12）。&lt;/p&gt;&lt;p&gt;JDK 就提供了现成的生成 UUID 的方法，一行代码就行了。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;//输出示例：cb4a9ede-fa5e-4585-b9bb-d60bce986eaa
UUID.randomUUID()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//tools.ietf.org/html/rfc4122&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;RFC 4122&lt;/a&gt; 中关于 UUID 的示例是这样的：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-d7a9b85346b01ad81aa8cab1f84d937f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1400&quot; data-rawheight=&quot;340&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-d7a9b85346b01ad81aa8cab1f84d937f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1400&quot; data-rawheight=&quot;340&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-d7a9b85346b01ad81aa8cab1f84d937f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-d7a9b85346b01ad81aa8cab1f84d937f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我们这里重点关注一下这个 Version(版本)，不同的版本对应的 UUID 的生成规则是不同的。&lt;/p&gt;&lt;p&gt;5 种不同的 Version(版本)值分别对应的含义（参考&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E9%2580%259A%25E7%2594%25A8%25E5%2594%25AF%25E4%25B8%2580%25E8%25AF%2586%25E5%2588%25AB%25E7%25A0%2581&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;维基百科对于 UUID 的介绍&lt;/a&gt;）：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;版本 1&lt;/b&gt; : UUID 是根据时间和节点 ID（通常是 MAC 地址）生成；&lt;/li&gt;&lt;li&gt;&lt;b&gt;版本 2&lt;/b&gt; : UUID 是根据标识符（通常是组或用户 ID）、时间和节点 ID 生成；&lt;/li&gt;&lt;li&gt;&lt;b&gt;版本 3、版本 5&lt;/b&gt; : 版本 5 - 确定性 UUID 通过散列（hashing）名字空间（namespace）标识符和名称生成；&lt;/li&gt;&lt;li&gt;&lt;b&gt;版本 4&lt;/b&gt; : UUID 使用&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E9%259A%258F%25E6%259C%25BA%25E6%2580%25A7&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;随机性&lt;/a&gt;或&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/%25E4%25BC%25AA%25E9%259A%258F%25E6%259C%25BA%25E6%2580%25A7&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;伪随机性&lt;/a&gt;生成。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;下面是 Version 1 版本下生成的 UUID 的示例：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-ecfce8d231fbf729b33a911b764eeaab_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1400&quot; data-rawheight=&quot;250&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-ecfce8d231fbf729b33a911b764eeaab_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1400&quot; data-rawheight=&quot;250&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-ecfce8d231fbf729b33a911b764eeaab_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-ecfce8d231fbf729b33a911b764eeaab_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;JDK 中通过 &lt;code&gt;UUID&lt;/code&gt; 的 &lt;code&gt;randomUUID()&lt;/code&gt; 方法生成的 UUID 的版本默认为 4。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;UUID uuid = UUID.randomUUID();
int version = uuid.version();// 4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外，Variant(变体)也有 4 种不同的值，这种值分别对应不同的含义。这里就不介绍了，貌似平时也不怎么需要关注。&lt;/p&gt;&lt;p&gt;需要用到的时候，去看看维基百科对于 UUID 的 Variant(变体) 相关的介绍即可。&lt;/p&gt;&lt;p&gt;从上面的介绍中可以看出，UUID 可以保证唯一性，因为其生成规则包括 MAC 地址、时间戳、名字空间（Namespace）、随机或伪随机数、时序等元素，计算机基于这些规则生成的 UUID 是肯定不会重复的。&lt;/p&gt;&lt;p&gt;虽然，UUID 可以做到全局唯一性，但是，我们一般很少会使用它。&lt;/p&gt;&lt;p&gt;比如使用 UUID 作为 MySQL 数据库主键的时候就非常不合适：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;数据库主键要尽量越短越好，而 UUID 的消耗的存储空间比较大（32 个字符串，128 位）。&lt;/li&gt;&lt;li&gt;UUID 是无顺序的，InnoDB 引擎下，数据库主键的无序性会严重影响数据库性能。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;最后，我们再简单分析一下 &lt;b&gt;UUID 的优缺点&lt;/b&gt; （面试的时候可能会被问到的哦！） :&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;优点&lt;/b&gt; ：生成速度比较快、简单易用&lt;/li&gt;&lt;li&gt;&lt;b&gt;缺点&lt;/b&gt; ： 存储消耗空间大（32 个字符串，128 位） 、 不安全（基于 MAC 地址生成 UUID 的算法会造成 MAC 地址泄露)、无序（非自增）、没有具体业务含义、需要解决重复 ID 问题（当机器时间不对的情况下，可能导致会产生重复 ID）&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;Snowflake(雪花算法)&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;Snowflake 是 Twitter 开源的分布式 ID 生成算法。Snowflake 由 64 bit 的二进制数字组成，这 64bit 的二进制被分成了几部分，每一部分存储的数据都有特定的含义：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;第 0 位&lt;/b&gt;： 符号位（标识正负），始终为 0，没有用，不用管。&lt;/li&gt;&lt;li&gt;&lt;b&gt;第 1~41 位&lt;/b&gt; ：一共 41 位，用来表示时间戳，单位是毫秒，可以支撑 2 ^41 毫秒（约 69 年）&lt;/li&gt;&lt;li&gt;&lt;b&gt;第 42~52 位&lt;/b&gt; ：一共 10 位，一般来说，前 5 位表示机房 ID，后 5 位表示机器 ID（实际项目中可以根据实际情况调整）。这样就可以区分不同集群/机房的节点。&lt;/li&gt;&lt;li&gt;&lt;b&gt;第 53~64 位&lt;/b&gt; ：一共 12 位，用来表示序列号。 序列号为自增值，代表单台机器每毫秒能够产生的最大 ID 数(2^12 = 4096),也就是说单台机器每毫秒最多可以生成 4096 个 唯一 ID。&lt;/li&gt;&lt;/ul&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-95f9ed7f7c7cf4022e8a4d957a2cb18f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1234&quot; data-rawheight=&quot;578&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/v2-95f9ed7f7c7cf4022e8a4d957a2cb18f_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1234&quot; data-rawheight=&quot;578&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic4.zhimg.com/v2-95f9ed7f7c7cf4022e8a4d957a2cb18f_r.jpg&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-95f9ed7f7c7cf4022e8a4d957a2cb18f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;如果你想要使用 Snowflake 算法的话，一般不需要你自己再造轮子。有很多基于 Snowflake 算法的开源实现比如美团 的 Leaf、百度的 UidGenerator，并且这些开源实现对原有的 Snowflake 算法进行了优化。&lt;/p&gt;&lt;p&gt;另外，在实际项目中，我们一般也会对 Snowflake 算法进行改造，最常见的就是在 Snowflake 算法生成的 ID 中加入业务类型信息。&lt;/p&gt;&lt;p&gt;我们再来看看 Snowflake 算法的优缺点 ：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;优点&lt;/b&gt; ：生成速度比较快、生成的 ID 有序递增、比较灵活（可以对 Snowflake 算法进行简单的改造比如加入业务 ID）&lt;/li&gt;&lt;li&gt;&lt;b&gt;缺点&lt;/b&gt; ： 需要解决重复 ID 问题（依赖时间，当机器时间不对的情况下，可能导致会产生重复 ID）。&lt;/li&gt;&lt;/ul&gt;&lt;h3&gt;&lt;b&gt;开源框架&lt;/b&gt;&lt;/h3&gt;&lt;h3&gt;&lt;b&gt;UidGenerator(百度)&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/baidu/uid-generator&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;UidGenerator&lt;/a&gt; 是百度开源的一款基于 Snowflake(雪花算法)的唯一 ID 生成器。&lt;/p&gt;&lt;p&gt;不过，UidGenerator 对 Snowflake(雪花算法)进行了改进，生成的唯一 ID 组成如下。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-a745e8818c2f431b824179b91b475e98_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;880&quot; data-rawheight=&quot;128&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-a745e8818c2f431b824179b91b475e98_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;880&quot; data-rawheight=&quot;128&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-a745e8818c2f431b824179b91b475e98_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-a745e8818c2f431b824179b91b475e98_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;可以看出，和原始 Snowflake(雪花算法)生成的唯一 ID 的组成不太一样。并且，上面这些参数我们都可以自定义。&lt;/p&gt;&lt;p&gt;UidGenerator 官方文档中的介绍如下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-cb055f09c6e29532276746bfe4d979b2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2284&quot; data-rawheight=&quot;1638&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-cb055f09c6e29532276746bfe4d979b2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2284&quot; data-rawheight=&quot;1638&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-cb055f09c6e29532276746bfe4d979b2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-cb055f09c6e29532276746bfe4d979b2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;自 18 年后，UidGenerator 就基本没有再维护了，我这里也不过多介绍。想要进一步了解的朋友，可以看看 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/baidu/uid-generator/blob/master/README.zh_cn.md&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;UidGenerator 的官方介绍&lt;/a&gt;。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Leaf(美团)&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Meituan-Dianping/Leaf&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Leaf&lt;/a&gt;&lt;/b&gt; 是美团开源的一个分布式 ID 解决方案 。这个项目的名字 Leaf（树叶） 起源于德国哲学家、数学家莱布尼茨的一句话： “There are no two identical leaves in the world”（世界上没有两片相同的树叶） 。这名字起得真心挺不错的，有点文艺青年那味了！&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-ce8a66e6777087c073c450b8cbb03eb9_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1704&quot; data-rawheight=&quot;821&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-ce8a66e6777087c073c450b8cbb03eb9_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1704&quot; data-rawheight=&quot;821&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-ce8a66e6777087c073c450b8cbb03eb9_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-ce8a66e6777087c073c450b8cbb03eb9_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Leaf 提供了 &lt;b&gt;号段模式&lt;/b&gt; 和 &lt;b&gt;Snowflake(雪花算法)&lt;/b&gt; 这两种模式来生成分布式 ID。并且，它支持双号段，还解决了雪花 ID 系统时钟回拨问题。不过，时钟问题的解决需要弱依赖于 Zookeeper 。&lt;/p&gt;&lt;p&gt;Leaf 的诞生主要是为了解决美团各个业务线生成分布式 ID 的方法多种多样以及不可靠的问题。&lt;/p&gt;&lt;p&gt;Leaf 对原有的号段模式进行改进，比如它这里增加了双号段避免获取 DB 在获取号段的时候阻塞请求获取 ID 的线程。简单来说，就是我一个号段还没用完之前，我自己就主动提前去获取下一个号段（图片来自于美团官方文章：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//tech.meituan.com/2017/04/21/mt-leaf.html&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Leaf——美团点评分布式 ID 生成系统》&lt;/a&gt;）。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-ba69a2a3c52898643b9c20f75ae84a14_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;779&quot; data-rawheight=&quot;383&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-ba69a2a3c52898643b9c20f75ae84a14_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;779&quot; data-rawheight=&quot;383&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-ba69a2a3c52898643b9c20f75ae84a14_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-ba69a2a3c52898643b9c20f75ae84a14_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;根据项目 README 介绍，在 4C8G VM 基础上，通过公司 RPC 方式调用，QPS 压测结果近 5w/s，TP999 1ms。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;Tinyid(滴滴)&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/didi/tinyid&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Tinyid&lt;/a&gt; 是滴滴开源的一款基于数据库号段模式的唯一 ID 生成器。&lt;/p&gt;&lt;p&gt;数据库号段模式的原理我们在上面已经介绍过了。&lt;b&gt;Tinyid 有哪些亮点呢？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;为了搞清楚这个问题，我们先来看看基于数据库号段模式的简单架构方案。（图片来自于 Tinyid 的官方 wiki:&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/didi/tinyid/wiki/tinyid%25E5%258E%259F%25E7%2590%2586%25E4%25BB%258B%25E7%25BB%258D&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Tinyid 原理介绍》&lt;/a&gt;）&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-5f4c15710e52a6965d820e3394d99ba0_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1066&quot; data-rawheight=&quot;698&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-5f4c15710e52a6965d820e3394d99ba0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1066&quot; data-rawheight=&quot;698&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-5f4c15710e52a6965d820e3394d99ba0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-5f4c15710e52a6965d820e3394d99ba0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;在这种架构模式下，我们通过 HTTP 请求向发号器服务申请唯一 ID。负载均衡 router 会把我们的请求送往其中的一台 tinyid-server。&lt;/p&gt;&lt;p&gt;这种方案有什么问题呢？在我看来（Tinyid 官方 wiki 也有介绍到），主要由下面这 2 个问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;获取新号段的情况下，程序获取唯一 ID 的速度比较慢。&lt;/li&gt;&lt;li&gt;需要保证 DB 高可用，这个是比较麻烦且耗费资源的。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;除此之外，HTTP 调用也存在网络开销。&lt;/p&gt;&lt;p&gt;Tinyid 的原理比较简单，其架构如下图所示：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-8dd9384bce3ad98dc764971d2c7db6a1_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1016&quot; data-rawheight=&quot;836&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-8dd9384bce3ad98dc764971d2c7db6a1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1016&quot; data-rawheight=&quot;836&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-8dd9384bce3ad98dc764971d2c7db6a1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-8dd9384bce3ad98dc764971d2c7db6a1_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;相比于基于数据库号段模式的简单架构方案，Tinyid 方案主要做了下面这些优化：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;b&gt;双号段缓存&lt;/b&gt; ：为了避免在获取新号段的情况下，程序获取唯一 ID 的速度比较慢。 Tinyid 中的号段在用到一定程度的时候，就会去异步加载下一个号段，保证内存中始终有可用号段。&lt;/li&gt;&lt;li&gt;&lt;b&gt;增加多 db 支持&lt;/b&gt; ：支持多个 DB，并且，每个 DB 都能生成唯一 ID，提高了可用性。&lt;/li&gt;&lt;li&gt;&lt;b&gt;增加 tinyid-client&lt;/b&gt; ：纯本地操作，无 HTTP 请求消耗，性能和可用性都有很大提升。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;Tinyid 的优缺点这里就不分析了，结合数据库号段模式的优缺点和 Tinyid 的原理就能知道。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;分布式 ID 生成方案总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;这篇文章中，我基本上已经把最常见的分布式 ID 生成方案都总结了一波。&lt;/p&gt;&lt;p&gt;除了上面介绍的方式之外，像 ZooKeeper 这类中间件也可以帮助我们生成唯一 ID。&lt;b&gt;没有银弹，一定要结合实际项目来选择最适合自己的方案。&lt;/b&gt;&lt;/p&gt;&lt;h2&gt;相关推荐&lt;/h2&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://zhuanlan.zhihu.com/p/379041500&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic1.zhimg.com/v2-269077f0b6627adec1e6b87b0c983b3c_120x160.jpg&quot; data-image-width=&quot;720&quot; data-image-height=&quot;1349&quot; data-text=&quot;JavaGuide：Github 标星 100k！2021 最新Java 学习线路图是怎样的？284 赞同 · 26 评论文章&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;p&gt;最后，再给想要学习 Java 的小伙伴推荐一个非常不错的 Java 教程类开源项目：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Snailclimb/JavaGuide&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;JavaGuide&lt;/a&gt; 。我在大三开始准备秋招面试的时候，创建了 JavaGuide 这个项目。目前这个项目已经有 100k+的 star，相关阅读：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzg2OTA0Njk0OA%3D%3D%26mid%3D2247501206%26idx%3D1%26sn%3Db04d30f26380602a2b9029ba91169e64%26chksm%3Dcea18a5df9d6034be43554ced33a8da4aad9a0037cc955093885bffb85e96d05ea8491b06a75%26token%3D301155466%26lang%3Dzh_CN%23rd&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《1049 天，100K!简单复盘！》&lt;/a&gt; 。 这个项目上面有常见知识点比如 Spring、SpringBoot 和 MyBatis 的面试题总结。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-d8b247cd84cb323f79d37cd102456d50_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1265&quot; data-rawheight=&quot;769&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-d8b247cd84cb323f79d37cd102456d50_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1265&quot; data-rawheight=&quot;769&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-d8b247cd84cb323f79d37cd102456d50_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-d8b247cd84cb323f79d37cd102456d50_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;另外，这个项目还推出了一个PDF版本：&lt;a href=&quot;https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMzg2OTA0Njk0OA%3D%3D%26mid%3D2247486324%26idx%3D1%26sn%3De8b690ddaedabc486bd399310105aad3%26chksm%3Dcea244bff9d5cda9a627fa65235be09e7b089e92cf49c0eb0ceb35b39bbed86c1fab0125f5af%26token%3D1351080357%26lang%3Dzh_CN%26scene%3D21%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;完结撒花！JavaGuide面试突击版来啦！&lt;/a&gt;！ 再推荐一下 准备Java后端面试必备参考资料：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//www.yuque.com/docs/share/f37fc804-bfe6-4b0d-b373-9c462188fec7&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;《Java 面试进阶指北 打造个人的技术竞争力》&lt;/a&gt;！&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-40a75c5431266cb9be626237da4a4f15_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1188&quot; data-rawheight=&quot;581&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-40a75c5431266cb9be626237da4a4f15_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1188&quot; data-rawheight=&quot;581&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-40a75c5431266cb9be626237da4a4f15_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-40a75c5431266cb9be626237da4a4f15_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;我是 Guide哥，一个工作两年有余，接触编程已经6年有余的程序员。大三开源&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Snailclimb/JavaGuide&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;SnailClimb/JavaGuide&lt;/a&gt; （如果无法访问Github，可以访问国内的码云：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//gitee.com/SnailClimb/JavaGuide&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;SnailClimb/JavaGuide&lt;/a&gt;），目前已经 100k+ Star，我的 Github：&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/Snailclimb&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;Snailclimb - Overview&lt;/a&gt; 。&lt;/p&gt;&lt;p&gt;未来几年，希望持续完善 JavaGuide，争取能够帮助更多学习 Java 的小伙伴！共勉！凎！&lt;/p&gt;&lt;p&gt;想要了解更多关于我的信息，&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/mp/appmsgalbum%3F__biz%3DMzg2OTA0Njk0OA%3D%3D%26action%3Dgetalbum%26album_id%3D2019767912546336773%23wechat_redirect&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;点击即可了解我的个人经历&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;原创不易，欢迎点赞分享，欢迎关注 &lt;a href=&quot;https://www.zhihu.com/people/ee0f19babdc46c21672264080ad7a641&quot; class=&quot;internal&quot;&gt;@JavaGuide&lt;/a&gt;,我会持续分享原创干货~&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>