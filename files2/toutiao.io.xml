<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>86b11757c52ad7b81d1010cff93c9d8e</guid>
<title>从前，有一个简单的通道系统叫尤娜……</title>
<link>https://toutiao.io/k/6kbx2kv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;从前，有个女生宿舍，住着小A、小B、尤娜和我4个人。有天，小A不小心把小B的床板坐塌了。小B非常生气，当场和小A翻脸。不论人缘最好的尤娜怎么中间调解都不管用。一直到毕业，小A和小B再没有说过一句话。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;后来，小A、小B和尤娜都成了公司老板，只有我一事无成。小A公司需要使用小B公司的系统，小A还记着当年的事情，没敢直接找小B，就找尤娜商量。尤娜就找到小B诉说原委。有生意小B自然是愿意做的，但是想到关系这么僵了，还是放不下身段。尤娜叹了口气：“这样吧，我们公司做一个系统，你俩都来接我吧。”&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是，尤娜成立了一个以自己名字命名的项目，看着我实在找不到工作，就让我自学编程，给她做开发。于是尤娜初版就这样上线了。架构是这样的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.9917355371900827&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRl8PicnOiboOzX9wmHLtjoBu8O4UllEHOxhgBUtB9ftia0m7RUtzrsdAJ7vb8XOObAt5UEpxHmaTvVPUw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;121&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我还只是个菜鸟，所以我的做法只是把B的http接口包装了一下，其他什么也没有做。上线之后，我发现A的调用请求一天有几个时间调用量特别大，小B公司的老师说：“扛不住了，不要把流量直接透传过来呀！”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我通过自己的学习调查，发现可以使用消息中间件做个缓冲。当A请求过来，我先把请求放到消息队列里，然后再自己消费后转发请求给B。因为消费是匀速的，就起到了削峰填谷的作用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是这样，我怎么把返回结果再返回给A呢？聪明如我怎么会想不到办法，我把B返回的结果记录到数据库中。当A的请求发送到消息中间件后就循环去数据库里取结果，取到就返回这个结果给A。完美！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;于是我跟尤娜商量了这个想法，尤娜是我的好姐妹，我的想法她马上表示支持，让我放手去做，资源呀什么都不是问题。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我按照网上找到的&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485934&amp;amp;idx=1&amp;amp;sn=71bc51653cef4a1b3c86e663fb2a3c62&amp;amp;chksm=fafde340cd8a6a5646411696514f350cc1cb00dbac89d6989115f3eeaf1b05d9bb4167b6011e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《项目中怎样做技术选型》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《项目中怎样做技术选型》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;的文章，结合目前的特点，优缺点比较之后，消息中间件使用kafka，数据库使用mysql。经过自己的努力，尤娜第二版上线啦。架构是这样的：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.667590027700831&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRl8PicnOiboOzX9wmHLtjoBu8O78brobwPdG89sTsMSjTxLEfBGWUCs8qOe7aAWFowADTJvBeibql3Yxw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;361&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;kafka集群的内部架构，我是参考&lt;/span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzUzNjAxODg4MQ==&amp;amp;mid=2247485702&amp;amp;idx=1&amp;amp;sn=79563d2f2d6a3e38d19459286ac26a6f&amp;amp;chksm=fafde3a8cd8a6abeec857f877d8c1353f2d959871c1634bf138103a7117abd9d5598d4b7ab84&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;《Kafka生产端实际项目中的使用分析》&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;《Kafka生产端实际项目中的使用分析》&lt;/span&gt;&lt;/a&gt;&lt;span&gt;这篇文章，使用zookeeper做分布式协调。上线不久后，意想不到的事情发生了：kafka broker集群挂了。不管三七二十一先重启再说。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;重启之后，尤娜消费端没有恢复，每隔3ms报一个warn日志：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Auto offset commit failed for group XXX:&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; Commit cannot be completed since the group has already rebalanced and assigned the partitions to another member.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; This means that the time between subsequent calls to poll() was longer than the configured max.poll.interval.ms,&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; which typically implies that the poll loop is spending too much time message processing.&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我根据auto offset commit failed（自动提交offset失败了）这个信息在网上搜索了一下。通过之前的学习我知道：kafka的数据更新消费都是通过在zookeeper中标记一个偏移量（offset）来记录每个分区的消费位置，所以一旦offset更新失败，会出现重复消费数据的问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终我分总结出：kafka消费者在处理消息时，在指定时间内（session.time.out）没有处理完。kafka消费要在消息处理完之后，自己提交当前的offset给kafka集群。而这时候已经超时断开连接了，导致自动提交offset失败。因此就会像日志中所说的发生rebalanced（重平衡即重新分配partition给客户端），而之前提交的offset已经失败了，所以重新分配的客户端又会消费之前的数据，接着consumer重新消费，又出现了消费超时，无限循环下去。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;出现这个原因是因为我客户端使用时就是使用了spring-kafka，只用了一个@KafkaListener，没有修改任何默认配置。而默认enable.auto.commit设置成true，可以改为false，不采用自动提交方式。所谓不自动提交实际上是消费端收到消息不先处理而是先提交offset再处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这种解决方案，万一提交了offset之后消费失败了不会再次处理。这样次数多了向A不好交代呀。还是先不改了。我决定先修改session.time.out时间设置长一些，重启解决问题。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前服务已经恢复了正常，作为菜鸟新人解决了问题觉得好激动。但是实际上细想还有好多问题没有弄明白，比如：kafka broker集群为什么挂了？太晚了，先睡觉再说。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;突然想起那时候在宿舍我们四个一起读《飘》的情景，特别喜欢里面那句名言：无论如何，明天又是新的一天！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e3a295836f129cb17a1a145f44a79893</guid>
<title>Go 高性能编程技法</title>
<link>https://toutiao.io/k/405ts7m</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：dablelv，腾讯 IEGggG 后台开发工程师&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;代码的稳健、可读和高效是我们每一个 coder 的共同追求。本文将结合 Go 语言特性，为书写效率更高的代码，从常用数据结构、内存管理和并发，三个方面给出相关建议。话不多说，让我们一起学习 Go 高性能编程的技法吧。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;常用数据结构&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.反射虽好，切莫贪杯&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标准库 reflect 为 Go 语言提供了运行时动态获取对象的类型和值以及动态创建对象的能力。反射可以帮助抽象和简化代码，提高开发效率。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言标准库以及很多开源软件中都使用了 Go 语言的反射能力，例如用于序列化和反序列化的 json、ORM 框架 gorm、xorm 等。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1 优先使用 strconv 而不是 fmt&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基本数据类型与字符串之间的转换，优先使用 strconv 而不是 fmt，因为前者性能更佳。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Bad&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt; s := fmt.Sprint(rand.Int())&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;BenchmarkFmtSprint&lt;span&gt;-4&lt;/span&gt;    &lt;span&gt;143&lt;/span&gt; ns/op    &lt;span&gt;2&lt;/span&gt; allocs/op&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Good&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt; s := strconv.Itoa(rand.Int())&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;BenchmarkStrconv&lt;span&gt;-4&lt;/span&gt;    &lt;span&gt;64.2&lt;/span&gt; ns/op    &lt;span&gt;1&lt;/span&gt; allocs/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么性能上会有两倍多的差距，因为 fmt 实现上利用反射来达到范型的效果，在运行时进行类型的动态判断，所以带来了一定的性能损耗。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2 少量的重复不比反射差&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时，我们需要一些工具函数。比如从 uint64 切片过滤掉指定的元素。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用反射，我们可以实现一个类型泛化支持扩展的切片过滤函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// DeleteSliceElms 从切片中过滤指定元素。注意：不修改原切片。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;DeleteSliceElms&lt;/span&gt;&lt;span&gt;(i &lt;span&gt;interface&lt;/span&gt;{}, elms ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;/span&gt;{} {&lt;br/&gt; &lt;span&gt;// 构建 map set。&lt;/span&gt;&lt;br/&gt; m := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;interface&lt;/span&gt;{}]&lt;span&gt;struct&lt;/span&gt;{}, &lt;span&gt;len&lt;/span&gt;(elms))&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, v := &lt;span&gt;range&lt;/span&gt; elms {&lt;br/&gt;  m[v] = &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 创建新切片，过滤掉指定元素。&lt;/span&gt;&lt;br/&gt; v := reflect.ValueOf(i)&lt;br/&gt; t := reflect.MakeSlice(reflect.TypeOf(i), &lt;span&gt;0&lt;/span&gt;, v.Len())&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; v.Len(); i++ {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; _, ok := m[v.Index(i).Interface()]; !ok {&lt;br/&gt;   t = reflect.Append(t, v.Index(i))&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; t.Interface()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，我们可能只需要操作一个类型的切片，利用反射实现的类型泛化扩展的能力压根没用上。退一步说，如果我们真地需要对 uint64 以外类型的切片进行过滤，拷贝一次代码又何妨呢？可以肯定的是，绝大部份场景，根本不会对所有类型的切片进行过滤，那么反射带来好处我们并没有充分享受，但却要为其带来的性能成本买单。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// DeleteU64liceElms 从 []uint64 过滤指定元素。注意：不修改原切片。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;DeleteU64liceElms&lt;/span&gt;&lt;span&gt;(i []&lt;span&gt;uint64&lt;/span&gt;, elms ...&lt;span&gt;uint64&lt;/span&gt;)&lt;/span&gt; []&lt;span&gt;uint64&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// 构建 map set。&lt;/span&gt;&lt;br/&gt; m := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;uint64&lt;/span&gt;]&lt;span&gt;struct&lt;/span&gt;{}, &lt;span&gt;len&lt;/span&gt;(elms))&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, v := &lt;span&gt;range&lt;/span&gt; elms {&lt;br/&gt;  m[v] = &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;// 创建新切片，过滤掉指定元素。&lt;/span&gt;&lt;br/&gt; t := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;uint64&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;len&lt;/span&gt;(i))&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; _, v := &lt;span&gt;range&lt;/span&gt; i {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; _, ok := m[v]; !ok {&lt;br/&gt;   t = &lt;span&gt;append&lt;/span&gt;(t, v)&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; t&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面看一下二者的性能对比。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkDeleteSliceElms&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; slice := []&lt;span&gt;uint64&lt;/span&gt;{&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;}&lt;br/&gt; elms := []&lt;span&gt;interface&lt;/span&gt;{}{&lt;span&gt;uint64&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;), &lt;span&gt;uint64&lt;/span&gt;(&lt;span&gt;3&lt;/span&gt;), &lt;span&gt;uint64&lt;/span&gt;(&lt;span&gt;5&lt;/span&gt;), &lt;span&gt;uint64&lt;/span&gt;(&lt;span&gt;7&lt;/span&gt;), &lt;span&gt;uint64&lt;/span&gt;(&lt;span&gt;9&lt;/span&gt;)}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = DeleteSliceElms(slice, elms...)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkDeleteU64liceElms&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; slice := []&lt;span&gt;uint64&lt;/span&gt;{&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;4&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;8&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;}&lt;br/&gt; elms := []&lt;span&gt;uint64&lt;/span&gt;{&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = DeleteU64liceElms(slice, elms...)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上面的基准测试。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; test -bench=. -benchmem main/reflect &lt;br/&gt;goos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/reflect&lt;br/&gt;cpu: Intel(R) Core(TM) i7&lt;span&gt;-9750&lt;/span&gt;H CPU @ &lt;span&gt;2.60&lt;/span&gt;GHz&lt;br/&gt;BenchmarkDeleteSliceElms&lt;span&gt;-12&lt;/span&gt;              &lt;span&gt;1226868&lt;/span&gt;               &lt;span&gt;978.2&lt;/span&gt; ns/op           &lt;span&gt;296&lt;/span&gt; B/op         &lt;span&gt;16&lt;/span&gt; allocs/op&lt;br/&gt;BenchmarkDeleteU64liceElms&lt;span&gt;-12&lt;/span&gt;            &lt;span&gt;8249469&lt;/span&gt;               &lt;span&gt;145.3&lt;/span&gt; ns/op            &lt;span&gt;80&lt;/span&gt; B/op          &lt;span&gt;1&lt;/span&gt; allocs/op&lt;br/&gt;PASS&lt;br/&gt;ok      main/reflect    &lt;span&gt;3.809&lt;/span&gt;s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，反射涉及了额外的类型判断和大量的内存分配，导致其对性能的影响非常明显。随着切片元素的递增，每一次判断元素是否在 map 中，因为 map 的 key 是不确定的类型，会发生变量逃逸，触发堆内存的分配。所以，可预见的是当元素数量增加时，性能差异会越来大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当使用反射时，请问一下自己，我真地需要它吗？&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3 慎用 binary.Read 和 binary.Write&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;binary.Read 和 binary.Write 使用反射并且很慢。如果有需要用到这两个函数的地方，我们应该手动实现这两个函数的相关功能，而不是直接去使用它们。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;encoding/binary 包实现了数字和字节序列之间的简单转换以及 varints 的编码和解码。varints 是一种使用可变字节表示整数的方法。其中数值本身越小，其所占用的字节数越少。Protocol Buffers 对整数采用的便是这种编码方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中数字与字节序列的转换可以用如下三个函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Read 从结构化二进制数据 r 读取到 data。data 必须是指向固定大小值的指针或固定大小值的切片。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Read&lt;/span&gt;&lt;span&gt;(r io.Reader, order ByteOrder, data &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Write 将 data 的二进制表示形式写入 w。data 必须是固定大小的值或固定大小值的切片，或指向此类数据的指针。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Write&lt;/span&gt;&lt;span&gt;(w io.Writer, order ByteOrder, data &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Size 返回 Wirte 函数将 v 写入到 w 中的字节数。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Size&lt;/span&gt;&lt;span&gt;(v &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面以我们熟知的 C 标准库函数 ntohl() 函数为例，看看 Go 利用 binary 包如何实现。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Ntohl 将网络字节序的 uint32 转为主机字节序。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Ntohl&lt;/span&gt;&lt;span&gt;(bys []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;uint32&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; r := bytes.NewReader(bys)&lt;br/&gt; err = binary.Read(buf, binary.BigEndian, &amp;amp;num)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 如将 IP 127.0.0.1 网络字节序解析到 uint32&lt;/span&gt;&lt;br/&gt;fmt.Println(Ntohl([]&lt;span&gt;byte&lt;/span&gt;{&lt;span&gt;0x7f&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0x1&lt;/span&gt;})) &lt;span&gt;// 2130706433 &amp;lt;nil&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们针对 uint32 类型手动实现一个 ntohl() 呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NtohlNotUseBinary&lt;/span&gt;&lt;span&gt;(bys []&lt;span&gt;byte&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;uint32&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &lt;span&gt;uint32&lt;/span&gt;(bys[&lt;span&gt;3&lt;/span&gt;]) | &lt;span&gt;uint32&lt;/span&gt;(bys[&lt;span&gt;2&lt;/span&gt;])&amp;lt;&amp;lt;&lt;span&gt;8&lt;/span&gt; | &lt;span&gt;uint32&lt;/span&gt;(bys[&lt;span&gt;1&lt;/span&gt;])&amp;lt;&amp;lt;&lt;span&gt;16&lt;/span&gt; | &lt;span&gt;uint32&lt;/span&gt;(bys[&lt;span&gt;0&lt;/span&gt;])&amp;lt;&amp;lt;&lt;span&gt;24&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 如将 IP 127.0.0.1 网络字节序解析到 uint32&lt;/span&gt;&lt;br/&gt;fmt.Println(NtohlNotUseBinary([]&lt;span&gt;byte&lt;/span&gt;{&lt;span&gt;0x7f&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0x1&lt;/span&gt;})) &lt;span&gt;// 2130706433&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该函数也是参考了 encoding/binary 包针对大端字节序将字节序列转为 uint32 类型时的实现。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面看下剥去反射前后二者的性能差异。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkNtohl&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _, _ = Ntohl([]&lt;span&gt;byte&lt;/span&gt;{&lt;span&gt;0x7f&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0x1&lt;/span&gt;})&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkNtohlNotUseBinary&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = NtohlNotUseBinary([]&lt;span&gt;byte&lt;/span&gt;{&lt;span&gt;0x7f&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0x1&lt;/span&gt;})&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上面的基准测试，结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go &lt;span&gt;test&lt;/span&gt; -bench=BenchmarkNtohl.* -benchmem main/reflect&lt;br/&gt;goos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/reflect&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz&lt;br/&gt;BenchmarkNtohl-12                       13026195                81.96 ns/op           60 B/op          4 allocs/op&lt;br/&gt;BenchmarkNtohlNotUseBinary-12           1000000000               0.2511 ns/op          0 B/op          0 allocs/op&lt;br/&gt;PASS&lt;br/&gt;ok      main/reflect    1.841s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可见使用反射实现的 encoding/binary 包的性能相较于针对具体类型实现的版本，性能差异非常大。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.避免重复的字符串到字节切片的转换&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要反复从固定字符串创建字节 slice，因为重复的切片初始化会带来性能损耗。相反，请执行一次转换并捕获结果。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Bad&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt; w.Write([]&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;Hello world&quot;&lt;/span&gt;))&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;BenchmarkBad&lt;span&gt;-4&lt;/span&gt;   &lt;span&gt;50000000&lt;/span&gt;   &lt;span&gt;22.2&lt;/span&gt; ns/op&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Good&lt;/span&gt;&lt;br/&gt;data := []&lt;span&gt;byte&lt;/span&gt;(&lt;span&gt;&quot;Hello world&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt; w.Write(data)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;BenchmarkGood&lt;span&gt;-4&lt;/span&gt;  &lt;span&gt;500000000&lt;/span&gt;   &lt;span&gt;3.25&lt;/span&gt; ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.指定容器容量&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尽可能指定容器容量，以便为容器预先分配内存。这将在后续添加元素时减少通过复制来调整容器大小。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 指定 map 容量提示&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在尽可能的情况下，在使用 make() 初始化的时候提供容量信息。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[T1]T2, hint)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;向 make() 提供容量提示会在初始化时尝试调整 map 的大小，这将减少在将元素添加到 map 时为 map 重新分配内存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，与 slice 不同。map capacity 提示并不保证完全的抢占式分配，而是用于估计所需的 hashmap bucket 的数量。因此，在将元素添加到 map 时，甚至在指定 map 容量时，仍可能发生分配。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Bad&lt;/span&gt;&lt;br/&gt;m := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]os.FileInfo)&lt;br/&gt;&lt;br/&gt;files, _ := ioutil.ReadDir(&lt;span&gt;&quot;./files&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; _, f := &lt;span&gt;range&lt;/span&gt; files {&lt;br/&gt;    m[f.Name()] = f&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// m 是在没有大小提示的情况下创建的； 在运行时可能会有更多分配。&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Good&lt;/span&gt;&lt;br/&gt;files, _ := ioutil.ReadDir(&lt;span&gt;&quot;./files&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;m := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]os.FileInfo, &lt;span&gt;len&lt;/span&gt;(files))&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; _, f := &lt;span&gt;range&lt;/span&gt; files {&lt;br/&gt;    m[f.Name()] = f&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;// m 是有大小提示创建的；在运行时可能会有更少的分配。&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 指定切片容量&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在尽可能的情况下，在使用 make() 初始化切片时提供容量信息，特别是在追加切片时。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;make&lt;/span&gt;([]T, length, capacity)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与 map 不同，slice capacity 不是一个提示：编译器将为提供给 make() 的 slice 的容量分配足够的内存，这意味着后续的 append() 操作将导致零分配（直到 slice 的长度与容量匹配，在此之后，任何 append 都可能调整大小以容纳其他元素）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; size = &lt;span&gt;1000000&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Bad&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;0&lt;/span&gt;; n &amp;lt; b.N; n++ {&lt;br/&gt; data := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; k := &lt;span&gt;0&lt;/span&gt;; k &amp;lt; size; k++ {&lt;br/&gt;     data = &lt;span&gt;append&lt;/span&gt;(data, k)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;BenchmarkBad&lt;span&gt;-4&lt;/span&gt;    &lt;span&gt;219&lt;/span&gt;    &lt;span&gt;5202179&lt;/span&gt; ns/op&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Good&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;0&lt;/span&gt;; n &amp;lt; b.N; n++ {&lt;br/&gt; data := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, size)&lt;br/&gt;   &lt;span&gt;for&lt;/span&gt; k := &lt;span&gt;0&lt;/span&gt;; k &amp;lt; size; k++ {&lt;br/&gt;     data = &lt;span&gt;append&lt;/span&gt;(data, k)&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;BenchmarkGood&lt;span&gt;-4&lt;/span&gt;   &lt;span&gt;706&lt;/span&gt;    &lt;span&gt;1528934&lt;/span&gt; ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行基准测试：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=^BenchmarkJoinStr -benchmem &lt;br/&gt;BenchmarkJoinStrWithOperator-8    66930670    17.81 ns/op    0 B/op    0 allocs/op&lt;br/&gt;BenchmarkJoinStrWithSprintf-8      7032921    166.0 ns/op    64 B/op   4 allocs/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.字符串拼接方式的选择&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1 行内拼接字符串推荐使用运算符+&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;行内拼接字符串为了书写方便快捷，最常用的两个方法是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;行内字符串的拼接，主要追求的是代码的简洁可读。&lt;code&gt;fmt.Sprintf()&lt;/code&gt; 能够接收不同类型的入参，通过格式化输出完成字符串的拼接，使用非常方便。但因其底层实现使用了反射，性能上会有所损耗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运算符 + 只能简单地完成字符串之间的拼接，非字符串类型的变量需要单独做类型转换。行内拼接字符串不会产生内存分配，也不涉及类型地动态转换，所以性能上优于&lt;code&gt;fmt.Sprintf()&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;从性能出发，兼顾易用可读，如果待拼接的变量不涉及类型转换且数量较少（&amp;lt;=5），行内拼接字符串推荐使用运算符 +，反之使用 &lt;code&gt;fmt.Sprintf()&lt;/code&gt;。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面看下二者的性能对比。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Good&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkJoinStrWithOperator&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s1, s2, s3 := &lt;span&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span&gt;&quot;bar&quot;&lt;/span&gt;, &lt;span&gt;&quot;baz&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = s1 + s2 + s3&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Bad&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkJoinStrWithSprintf&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s1, s2, s3 := &lt;span&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span&gt;&quot;bar&quot;&lt;/span&gt;, &lt;span&gt;&quot;baz&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = fmt.Sprintf(&lt;span&gt;&quot;%s%s%s&quot;&lt;/span&gt;, s1, s2, s3)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行基准测试结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=^BenchmarkJoinStr -benchmem .&lt;br/&gt;BenchmarkJoinStrWithOperator-8    70638928    17.53 ns/op     0 B/op    0 allocs/op&lt;br/&gt;BenchmarkJoinStrWithSprintf-8      7520017    157.2 ns/op    64 B/op    4 allocs/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2 非行内拼接字符串推荐使用 strings.Builder&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;字符串拼接还有其他的方式，比如&lt;code&gt;strings.Join()&lt;/code&gt;、&lt;code&gt;strings.Builder&lt;/code&gt;、&lt;code&gt;bytes.Buffer&lt;/code&gt;和&lt;code&gt;byte[]&lt;/code&gt;，这几种不适合行内使用。当待拼接字符串数量较多时可考虑使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看下其性能测试的对比。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkJoinStrWithStringsJoin&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s1, s2, s3 := &lt;span&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span&gt;&quot;bar&quot;&lt;/span&gt;, &lt;span&gt;&quot;baz&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = strings.Join([]&lt;span&gt;string&lt;/span&gt;{s1, s2, s3}, &lt;span&gt;&quot;&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkJoinStrWithStringsBuilder&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s1, s2, s3 := &lt;span&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span&gt;&quot;bar&quot;&lt;/span&gt;, &lt;span&gt;&quot;baz&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; builder strings.Builder&lt;br/&gt;  _, _ = builder.WriteString(s1)&lt;br/&gt;  _, _ = builder.WriteString(s2)&lt;br/&gt;  _, _ = builder.WriteString(s3)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkJoinStrWithBytesBuffer&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s1, s2, s3 := &lt;span&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span&gt;&quot;bar&quot;&lt;/span&gt;, &lt;span&gt;&quot;baz&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; buffer bytes.Buffer&lt;br/&gt;  _, _ = buffer.WriteString(s1)&lt;br/&gt;  _, _ = buffer.WriteString(s2)&lt;br/&gt;  _, _ = buffer.WriteString(s3)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkJoinStrWithByteSlice&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s1, s2, s3 := &lt;span&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span&gt;&quot;bar&quot;&lt;/span&gt;, &lt;span&gt;&quot;baz&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; bys []&lt;span&gt;byte&lt;/span&gt;&lt;br/&gt;  bys= &lt;span&gt;append&lt;/span&gt;(bys, s1...)&lt;br/&gt;  bys= &lt;span&gt;append&lt;/span&gt;(bys, s2...)&lt;br/&gt;  _ = &lt;span&gt;append&lt;/span&gt;(bys, s3...)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkJoinStrWithByteSlicePreAlloc&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s1, s2, s3 := &lt;span&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span&gt;&quot;bar&quot;&lt;/span&gt;, &lt;span&gt;&quot;baz&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  bys:= &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;)&lt;br/&gt;  bys= &lt;span&gt;append&lt;/span&gt;(bys, s1...)&lt;br/&gt;  bys= &lt;span&gt;append&lt;/span&gt;(bys, s2...)&lt;br/&gt;  _ = &lt;span&gt;append&lt;/span&gt;(bys, s3...)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基准测试结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=^BenchmarkJoinStr .&lt;br/&gt;goos: windows&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/perf&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9700 CPU @ 3.00GHz&lt;br/&gt;BenchmarkJoinStrWithStringsJoin-8               31543916                36.39 ns/op&lt;br/&gt;BenchmarkJoinStrWithStringsBuilder-8            30079785                40.60 ns/op&lt;br/&gt;BenchmarkJoinStrWithBytesBuffer-8               31663521                39.58 ns/op&lt;br/&gt;BenchmarkJoinStrWithByteSlice-8                 30748495                37.34 ns/op&lt;br/&gt;BenchmarkJoinStrWithByteSlicePreAlloc-8         665341896               1.813 ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从结果可以看出，&lt;code&gt;strings.Join()&lt;/code&gt;、&lt;code&gt;strings.Builder&lt;/code&gt;、&lt;code&gt;bytes.Buffer&lt;/code&gt;和&lt;code&gt;byte[]&lt;/code&gt; 的性能相近。如果结果字符串的长度是可预知的，使用 &lt;code&gt;byte[]&lt;/code&gt; 且预先分配容量的拼接方式性能最佳。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以如果对性能要求非常严格，或待拼接的字符串数量足够多时，建议使用  &lt;code&gt;byte[]&lt;/code&gt; 预先分配容量这种方式。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;综合易用性和性能，一般推荐使用&lt;code&gt;strings.Builder&lt;/code&gt;来拼接字符串。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;string.Builder&lt;/code&gt;也提供了预分配内存的方式 Grow：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkJoinStrWithStringsBuilderPreAlloc&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s1, s2, s3 := &lt;span&gt;&quot;foo&quot;&lt;/span&gt;, &lt;span&gt;&quot;bar&quot;&lt;/span&gt;, &lt;span&gt;&quot;baz&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; builder strings.Builder&lt;br/&gt;  builder.Grow(&lt;span&gt;9&lt;/span&gt;)&lt;br/&gt;  _, _ = builder.WriteString(s1)&lt;br/&gt;  _, _ = builder.WriteString(s2)&lt;br/&gt;  _, _ = builder.WriteString(s3)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用了 Grow 优化后的版本的性能测试结果如下。可以看出相较于不预先分配空间的方式，性能提升了很多。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;BenchmarkJoinStrWithStringsBuilderPreAlloc-8    60079003                20.95 ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.遍历 []struct{} 使用下标而不是 range&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 中遍历切片或数组有两种方式，一种是通过下标，一种是 range。二者在功能上没有区别，但是在性能上会有区别吗？&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.1 []int&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先看一下遍历基本类型切片时二者的性能差别，以 []int 为例。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// genRandomIntSlice 生成指定长度的随机 []int 切片&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;genRandomIntSlice&lt;/span&gt;&lt;span&gt;(n &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; []&lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; rand.Seed(time.Now().UnixNano())&lt;br/&gt; nums := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, n)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++ {&lt;br/&gt;  nums = &lt;span&gt;append&lt;/span&gt;(nums, rand.Int())&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; nums&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkIndexIntSlice&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; nums := genRandomIntSlice(&lt;span&gt;1024&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; tmp &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; k := &lt;span&gt;0&lt;/span&gt;; k &amp;lt; &lt;span&gt;len&lt;/span&gt;(nums); k++ {&lt;br/&gt;   tmp = nums[k]&lt;br/&gt;  }&lt;br/&gt;  _ = tmp&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkRangeIntSlice&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; nums := genRandomIntSlice(&lt;span&gt;1024&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; tmp &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; _, num := &lt;span&gt;range&lt;/span&gt; nums {&lt;br/&gt;   tmp = num&lt;br/&gt;  }&lt;br/&gt;  _ = tmp&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行测试结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=IntSlice$ .&lt;br/&gt;goos: windows&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/perf&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9700 CPU @ 3.00GHz&lt;br/&gt;BenchmarkIndexIntSlice-8         5043324               236.2 ns/op&lt;br/&gt;BenchmarkRangeIntSlice-8         5076255               239.1 ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;genRandomIntSlice()&lt;/code&gt; 函数用于生成指定长度元素类型为 int 的切片。从最终的结果可以看到，遍历 []int 类型的切片，下标与 range 遍历性能几乎没有区别。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.2 []struct{}&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么对于稍微复杂一点的 []struct 类型呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Item &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; id  &lt;span&gt;int&lt;/span&gt;&lt;br/&gt; val [&lt;span&gt;1024&lt;/span&gt;]&lt;span&gt;byte&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkIndexStructSlice&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; items [&lt;span&gt;1024&lt;/span&gt;]Item&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; tmp &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; j := &lt;span&gt;0&lt;/span&gt;; j &amp;lt; &lt;span&gt;len&lt;/span&gt;(items); j++ {&lt;br/&gt;   tmp = items[j].id&lt;br/&gt;  }&lt;br/&gt;  _ = tmp&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkRangeIndexStructSlice&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; items [&lt;span&gt;1024&lt;/span&gt;]Item&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; tmp &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; k := &lt;span&gt;range&lt;/span&gt; items {&lt;br/&gt;   tmp = items[k].id&lt;br/&gt;  }&lt;br/&gt;  _ = tmp&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkRangeStructSlice&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; items [&lt;span&gt;1024&lt;/span&gt;]Item&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; tmp &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; _, item := &lt;span&gt;range&lt;/span&gt; items {&lt;br/&gt;   tmp = item.id&lt;br/&gt;  }&lt;br/&gt;  _ = tmp&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行测试结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=StructSlice$ .&lt;br/&gt;goos: windows&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/perf&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9700 CPU @ 3.00GHz&lt;br/&gt;BenchmarkIndexStructSlice-8              5079468               234.9 ns/op&lt;br/&gt;BenchmarkRangeIndexStructSlice-8         5087448               236.2 ns/op&lt;br/&gt;BenchmarkRangeStructSlice-8                38716               32265 ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出，两种通过 index 遍历 []struct 性能没有差别，但是 range 遍历 []struct 中元素时，性能非常差。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;range 只遍历 []struct 下标时，性能比 range 遍历  []struct 值好很多。从这里我们应该能够知道二者性能差别之大的原因。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Item 是一个结构体类型 ，Item 由两个字段构成，一个类型是 int，一个是类型是 [1024]byte，如果每次遍历 []Item，都会进行一次值拷贝，所以带来了性能损耗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，因为 range 时获取的是值拷贝的副本，所以对副本的修改，是不会影响到原切片。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.3 []*struct&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那如果切片中是指向结构体的指针，而不是结构体呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// genItems 生成指定长度 []*Item 切片&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;genItems&lt;/span&gt;&lt;span&gt;(n &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt; []*&lt;span&gt;Item&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; items := &lt;span&gt;make&lt;/span&gt;([]*Item, &lt;span&gt;0&lt;/span&gt;, n)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; i++ {&lt;br/&gt;  items = &lt;span&gt;append&lt;/span&gt;(items, &amp;amp;Item{id: i})&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; items&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkIndexPointer&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; items := genItems(&lt;span&gt;1024&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; tmp &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; k := &lt;span&gt;0&lt;/span&gt;; k &amp;lt; &lt;span&gt;len&lt;/span&gt;(items); k++ {&lt;br/&gt;   tmp = items[k].id&lt;br/&gt;  }&lt;br/&gt;  _ = tmp&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkRangePointer&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; items := genItems(&lt;span&gt;1024&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; tmp &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; _, item := &lt;span&gt;range&lt;/span&gt; items {&lt;br/&gt;   tmp = item.id&lt;br/&gt;  }&lt;br/&gt;  _ = tmp&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行性能测试结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=Pointer$ main/perf&lt;br/&gt;goos: windows&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/perf&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9700 CPU @ 3.00GHz&lt;br/&gt;BenchmarkIndexPointer-8           773634              1521 ns/op&lt;br/&gt;BenchmarkRangePointer-8           752077              1514 ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;切片元素从结构体 Item 替换为指针 *Item 后，for 和 range 的性能几乎是一样的。而且使用指针还有另一个好处，可以直接修改指针对应的结构体的值。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.4 小结&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;range 在迭代过程中返回的是元素的拷贝，index 则不存在拷贝。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 range 迭代的元素较小，那么 index 和 range 的性能几乎一样，如基本类型的切片 []int。但如果迭代的元素较大，如一个包含很多属性的 struct 结构体，那么 index 的性能将显著地高于 range，有时候甚至会有上千倍的性能差异。对于这种场景，建议使用 index。如果使用 range，建议只迭代下标，通过下标访问元素，这种使用方式和 index 就没有区别了。如果想使用 range 同时迭代下标和值，则需要将切片/数组的元素改为指针，才能不影响性能。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;内存管理&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.使用空结构体节省内存&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1 不占内存空间&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 中，我们可以使用 unsafe.Sizeof 计算出一个数据类型实例需要占用的字节数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;unsafe&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; fmt.Println(unsafe.Sizeof(&lt;span&gt;struct&lt;/span&gt;{}{}))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上面的例子将会输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;go&lt;/span&gt; run main.&lt;span&gt;go&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，Go 中空结构体 struct{} 是不占用内存空间，不像 C/C++ 中空结构体仍占用 1 字节。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2 用法&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为空结构体不占据内存空间，因此被广泛作为各种场景下的占位符使用。一是节省资源，二是空结构体本身就具备很强的语义，即这里不需要任何值，仅作为占位符，达到的代码即注释的效果。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2.1 实现集合（Set）&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言标准库没有提供 Set 的实现，通常使用 map 来代替。事实上，对于集合来说，只需要 map 的键，而不需要值。即使是将值设置为 bool 类型，也会多占据 1 个字节，那假设 map 中有一百万条数据，就会浪费 1MB 的空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此呢，将 map 作为集合（Set）使用时，可以将值类型定义为空结构体，仅作为占位符使用即可。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Set &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;string&lt;/span&gt;]&lt;span&gt;struct&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(s Set)&lt;/span&gt; &lt;span&gt;Has&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; _, ok := s[key]&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; ok&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(s Set)&lt;/span&gt; &lt;span&gt;Add&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s[key] = &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(s Set)&lt;/span&gt; &lt;span&gt;Delete&lt;/span&gt;&lt;span&gt;(key &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;delete&lt;/span&gt;(s, key)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s := &lt;span&gt;make&lt;/span&gt;(Set)&lt;br/&gt; s.Add(&lt;span&gt;&quot;foo&quot;&lt;/span&gt;)&lt;br/&gt; s.Add(&lt;span&gt;&quot;bar&quot;&lt;/span&gt;)&lt;br/&gt; fmt.Println(s.Has(&lt;span&gt;&quot;foo&quot;&lt;/span&gt;))&lt;br/&gt; fmt.Println(s.Has(&lt;span&gt;&quot;bar&quot;&lt;/span&gt;))&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果想使用 Set 的完整功能，如初始化（通过切片构建一个 Set）、Add、Del、Clear、Contains 等操作，可以使用开源库 &lt;a href=&quot;https://github.com/deckarep/golang-set&quot; data-linktype=&quot;2&quot;&gt;golang-set&lt;/a&gt;。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2.2 不发送数据的信道&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;worker&lt;/span&gt;&lt;span&gt;(ch &lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &amp;lt;-ch&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;do something&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{})&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; worker(ch)&lt;br/&gt; ch &amp;lt;- &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt; &lt;span&gt;close&lt;/span&gt;(ch)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候使用 channel 不需要发送任何的数据，只用来通知子协程（goroutine）执行任务，或只用来控制协程的并发。这种情况下，使用空结构体作为占位符就非常合适了。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2.3 仅包含方法的结构体&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Door &lt;span&gt;struct&lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(d Door)&lt;/span&gt; &lt;span&gt;Open&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;Open the door&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(d Door)&lt;/span&gt; &lt;span&gt;Close&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; fmt.Println(&lt;span&gt;&quot;Close the door&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在部分场景下，结构体只包含方法，不包含任何的字段。例如上面例子中的 Door，在这种情况下，Door 事实上可以用任何的数据结构替代。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Door &lt;span&gt;int&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Door &lt;span&gt;bool&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论是 int 还是 bool 都会浪费额外的内存，因此呢，这种情况下，声明为空结构体最合适。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2. struct 布局要考虑内存对齐&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 为什么需要内存对齐&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU 访问内存时，并不是逐个字节访问，而是以字长（word size）为单位访问。比如 32 位的 CPU ，字长为 4 字节，那么 CPU 访问内存的单位也是 4 字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么设计的目的，是减少 CPU 访问内存的次数，加大 CPU 访问内存的吞吐量。比如同样读取 8 个字节的数据，一次读取 4 个字节那么只需要读取 2 次。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CPU 始终以字长访问内存，如果不进行内存对齐，很可能增加 CPU 访问内存的次数，例如：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.6060606060606061&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasXic8UMQ0Bbvu6iaXLy4Q8sF3gkkRyxjMxonRLkWx29jDvibWPibibkoglDhHxPorbalQiaTJNDYRfFKGw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;990&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;变量 a、b 各占据 3 字节的空间，内存对齐后，a、b 占据 4 字节空间，CPU 读取 b 变量的值只需要进行一次内存访问。如果不进行内存对齐，CPU 读取 b 变量的值需要进行 2 次内存访问。第一次访问得到 b 变量的第 1 个字节，第二次访问得到 b 变量的后两个字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这个例子中也可以看到，内存对齐对实现变量的原子性操作也是有好处的，每次内存访问是原子的，如果变量的大小不超过字长，那么内存对齐后，对该变量的访问就是原子的，这个特性在并发场景下至关重要。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简言之：合理的内存对齐可以提高内存读写的性能，并且便于实现变量操作的原子性。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 Go 内存对齐规则&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译器一般为了减少 CPU 访存指令周期，提高内存的访问效率，会对变量进行内存对齐。Go 作为一门追求高性能的后台编程语言，当然也不例外。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go Language Specification 中 &lt;a href=&quot;https://go.dev/ref/spec#Size_and_alignment_guarantees&quot; data-linktype=&quot;2&quot;&gt;Size and alignment guarantees&lt;/a&gt; 描述了内存对齐的规则。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;1.For a variable x of any type: unsafe.Alignof(x) is at least 1.
2.For a variable x of struct type: unsafe.Alignof(x) is the largest of all the values unsafe.Alignof(x.f) for each field f of x, but at least 1.
3.For a variable x of array type: unsafe.Alignof(x) is the same as the alignment of a variable of the array&#x27;s element type.&lt;/p&gt;&lt;/blockquote&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;对于任意类型的变量 x ，unsafe.Alignof(x) 至少为 1。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于结构体类型的变量 x，计算 x 每一个字段 f 的 unsafe.Alignof(x.f)，unsafe.Alignof(x) 等于其中的最大值。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;对于数组类型的变量 x，unsafe.Alignof(x) 等于构成数组的元素类型的对齐系数。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中函数 &lt;code&gt;unsafe.Alignof&lt;/code&gt; 用于获取变量的对齐系数。对齐系数决定了字段的偏移和变量的大小，两者必须是对齐系数的整数倍。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3 合理的 struct 布局&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为内存对齐的存在，合理的 struct 布局可以减少内存占用，提高程序性能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; demo1 &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; a &lt;span&gt;int8&lt;/span&gt;&lt;br/&gt; b &lt;span&gt;int16&lt;/span&gt;&lt;br/&gt; c &lt;span&gt;int32&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; demo2 &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; a &lt;span&gt;int8&lt;/span&gt;&lt;br/&gt; c &lt;span&gt;int32&lt;/span&gt;&lt;br/&gt; b &lt;span&gt;int16&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; fmt.Println(unsafe.Sizeof(demo1{})) &lt;span&gt;// 8&lt;/span&gt;&lt;br/&gt; fmt.Println(unsafe.Sizeof(demo2{})) &lt;span&gt;// 12&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，同样的字段，因字段排列顺序不同，最终会导致不一样的结构体大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个字段按照自身的对齐系数来确定在内存中的偏移量，一个字段因偏移而浪费的大小也不同。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来逐个分析，首先是 demo1：a 是第一个字段，默认是已经对齐的，从第 0 个位置开始占据 1 字节。b 是第二个字段，对齐系数为 2，因此，必须空出 1 个字节，偏移量才是 2 的倍数，从第 2 个位置开始占据 2 字节。c 是第三个字段，对齐倍数为 4，此时，内存已经是对齐的，从第 4 个位置开始占据 4 字节即可。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此 demo1 的内存占用为 8 字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于 demo2：a 是第一个字段，默认是已经对齐的，从第 0 个位置开始占据 1 字节。c 是第二个字段，对齐倍数为 4，因此，必须空出 3 个字节，偏移量才是 4 的倍数，从第 4 个位置开始占据 4 字节。b 是第三个字段，对齐倍数为 2，从第 8 个位置开始占据 2 字节。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;demo2 的对齐系数由 c 的对齐系数决定，也是 4，因此，demo2 的内存占用为 12 字节。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.36891385767790263&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasXic8UMQ0Bbvu6iaXLy4Q8sFf2TJrMgXLEuDYFxgsuQ7cIph3SKr8DCwljibicSS85OZiaItevkL7rxnQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1068&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;因此，在对内存特别敏感的结构体的设计上，我们可以通过调整字段的顺序，将字段宽度从小到大由上到下排列，来减少内存的占用。&lt;/strong&gt;&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4 空结构与空数组对内存对齐的影响&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;空结构与空数组在 Go 中比较特殊。没有任何字段的空 struct{} 和没有任何元素的 array 占据的内存空间大小为 0。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为这一点，空 struct{} 或空 array 作为其他 struct 的字段时，一般不需要内存对齐。但是有一种情况除外：即当 struct{} 或空 array 作为结构体最后一个字段时，需要内存对齐。因为如果有指针指向该字段，返回的地址将在结构体之外，如果此指针一直存活不释放对应的内存，就会有内存泄露的问题（该内存不因结构体释放而释放）。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; demo3 &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; a &lt;span&gt;struct&lt;/span&gt;{}&lt;br/&gt; b &lt;span&gt;int32&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; demo4 &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; b &lt;span&gt;int32&lt;/span&gt;&lt;br/&gt; a &lt;span&gt;struct&lt;/span&gt;{}&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; fmt.Println(unsafe.Sizeof(demo3{})) &lt;span&gt;// 4&lt;/span&gt;&lt;br/&gt; fmt.Println(unsafe.Sizeof(demo4{})) &lt;span&gt;// 8&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，demo3{} 的大小为 4 字节，与字段 b 占据空间一致，而 demo4{} 的大小为 8 字节，即额外填充了 4 字节的空间。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.减少逃逸，将变量限制在栈上&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;变量逃逸一般发生在如下几种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;变量较大&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;变量大小不确定&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;变量类型不确定&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回指针&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回引用&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;闭包&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;知道变量逃逸的原因后，我们可以有意识的控制变量不发生逃逸，将其控制在栈上，减少堆变量的分配，降低 GC 成本，提高程序性能。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 小的拷贝好过引用&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小的拷贝好过引用，什么意思呢，就是尽量使用栈变量而不是堆变量。下面举一个反常识的例子，来证明小的拷贝比在堆上创建引用变量要好。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们都知道 Go 里面的 Array 以 pass-by-value 方式传递后，再加上其长度不可扩展，考虑到性能我们一般很少使用它。实际上，凡事无绝对。有时使用数组进行拷贝传递，比使用切片要好。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// copy/copy.go&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; capacity = &lt;span&gt;1024&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;arrayFibonacci&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; [&lt;span&gt;capacity&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; d [capacity]&lt;span&gt;int&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;len&lt;/span&gt;(d); i++ {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; i &amp;lt;= &lt;span&gt;1&lt;/span&gt; {&lt;br/&gt;   d[i] = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  d[i] = d[i&lt;span&gt;-1&lt;/span&gt;] + d[i&lt;span&gt;-2&lt;/span&gt;]&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; d&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;sliceFibonacci&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; []&lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; d := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, capacity)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;len&lt;/span&gt;(d); i++ {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; i &amp;lt;= &lt;span&gt;1&lt;/span&gt; {&lt;br/&gt;   d[i] = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  d[i] = d[i&lt;span&gt;-1&lt;/span&gt;] + d[i&lt;span&gt;-2&lt;/span&gt;]&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; d&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面看一下性能对比。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkArray&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = arrayFibonacci()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkSlice&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = sliceFibonacci()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上面的基准测试，将得到如下结果。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=. -benchmem -gcflags=&quot;-l&quot; main/copy&lt;br/&gt;goos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/copy&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz&lt;br/&gt;BenchmarkArray-12         692400              1708 ns/op               0 B/op          0 allocs/op&lt;br/&gt;BenchmarkSlice-12         464974              2242 ns/op            8192 B/op          1 allocs/op&lt;br/&gt;PASS&lt;br/&gt;ok      main/copy       3.908s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从测试结果可以看出，对数组的拷贝性能却比使用切片要好。为什么会这样呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sliceFibonacci() 函数中分配的局部变量切片因为要返回到函数外部，所以发生了逃逸，需要在堆上申请内存空间。从测试也过也可以看出，arrayFibonacci() 函数没有内存分配，完全在栈上完成数组的创建。这里说明了对于一些短小的对象，栈上复制的成本远小于在堆上分配和回收操作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意，运行上面基准测试时，传递了禁止内联的编译选项 &quot;-l&quot;，如果发生内联，那么将不会出现变量的逃逸，就不存在堆上分配内存与回收的操作了，二者将看不出性能差异。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;编译时可以借助选项 -gcflags=-m 查看编译器对上面两个函数的优化决策。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go build  -gcflags=-m copy/copy.go&lt;br/&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; &lt;span&gt;command&lt;/span&gt;-line-arguments&lt;/span&gt;&lt;br/&gt;copy/copy.go:5:6: can inline arrayFibonacci&lt;br/&gt;copy/copy.go:17:6: can inline sliceFibonacci&lt;br/&gt;copy/copy.go:18:11: make([]int, capacity) escapes to heap&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，arrayFibonacci() 和 sliceFibonacci() 函数均可内联。sliceFibonacci() 函数中定义的局部变量切片逃逸到了堆。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么多大的变量才算是小变量呢？对 Go 编译器而言，超过一定大小的局部变量将逃逸到堆上，不同的 Go 版本的大小限制可能不一样。一般是 &amp;lt;64KB，局部变量将不会逃逸到堆上。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 返回值 VS 返回指针&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值传递会拷贝整个对象，而指针传递只会拷贝地址，指向的对象是同一个。返回指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加垃圾回收(GC)的负担。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择返回指针。对于只读的占用内存较小的结构体，直接返回值能够获得更好的性能。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3 返回值使用确定的类型&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果变量类型不确定，那么将会逃逸到堆上。所以，函数返回值如果能确定的类型，就不要使用 interface{}。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是以上面斐波那契数列函数为例，看下返回值为确定类型和 interface{} 的性能差别。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; capacity = &lt;span&gt;1024&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;arrayFibonacci&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; [&lt;span&gt;capacity&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; d [capacity]&lt;span&gt;int&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;len&lt;/span&gt;(d); i++ {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; i &amp;lt;= &lt;span&gt;1&lt;/span&gt; {&lt;br/&gt;   d[i] = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  d[i] = d[i&lt;span&gt;-1&lt;/span&gt;] + d[i&lt;span&gt;-2&lt;/span&gt;]&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; d&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;arrayFibonacciIfc&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;/span&gt;{} {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; d [capacity]&lt;span&gt;int&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;len&lt;/span&gt;(d); i++ {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; i &amp;lt;= &lt;span&gt;1&lt;/span&gt; {&lt;br/&gt;   d[i] = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;continue&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  d[i] = d[i&lt;span&gt;-1&lt;/span&gt;] + d[i&lt;span&gt;-2&lt;/span&gt;]&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; d&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkArray&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = arrayFibonacci()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkIfc&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = arrayFibonacciIfc()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行上面的基准测试结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=. -benchmem main/copy&lt;br/&gt;goos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/copy&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz&lt;br/&gt;BenchmarkArray-12         832418              1427 ns/op               0 B/op          0 allocs/op&lt;br/&gt;BenchmarkIfc-12           380626              2861 ns/op            8192 B/op          1 allocs/op&lt;br/&gt;PASS&lt;br/&gt;ok      main/copy       3.742s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可见，函数返回值使用 interface{} 返回时，编译器无法确定返回值的具体类型，导致返回值逃逸到堆上。当发生了堆上内存的申请与回收时，性能会差一点。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.sync.Pool 复用对象&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1 简介&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Pool 是 sync 包下的一个组件，可以作为保存临时取还对象的一个“池子”。个人觉得它的名字有一定的误导性，因为 Pool 里装的对象可以被无通知地被回收，可能 sync.Cache 是一个更合适的名字。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Pool 是可伸缩的，同时也是并发安全的，其容量仅受限于内存的大小。存放在池中的对象如果不活跃了会被自动清理。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2 作用&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于很多需要重复分配、回收内存的地方，sync.Pool 是一个很好的选择。频繁地分配、回收内存会给 GC 带来一定的负担，严重的时候会引起 CPU 的毛刺，而 sync.Pool 可以将暂时不用的对象缓存起来，待下次需要的时候直接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力，提升系统的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一句话总结：用来保存和复用临时对象，减少内存分配，降低 GC 压力。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.3 如何使用&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Pool 的使用方式非常简单，只需要实现 New 函数即可。对象池中没有对象时，将会调用 New 函数创建。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设我们有一个“学生”结构体，并复用改结构体对象。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Student &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Name   &lt;span&gt;string&lt;/span&gt;&lt;br/&gt; Age    &lt;span&gt;int32&lt;/span&gt;&lt;br/&gt; Remark [&lt;span&gt;1024&lt;/span&gt;]&lt;span&gt;byte&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; studentPool = sync.Pool{&lt;br/&gt;    New: &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;/span&gt;{} { &lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;(Student) &lt;br/&gt;    },&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后调用 Pool 的 Get() 和 Put() 方法来获取和放回池子中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;stu := studentPool.Get().(*Student)&lt;br/&gt;json.Unmarshal(buf, stu)&lt;br/&gt;studentPool.Put(stu)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;Get() 用于从对象池中获取对象，因为返回值是 interface{}，因此需要类型转换。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Put() 则是在对象使用完毕后，放回到对象池。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4 性能差异&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以 bytes.Buffer 字节缓冲器为例，利用 sync.Pool 复用 bytes.Buffer 对象，避免重复创建与回收内存，来看看对性能的提升效果。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; bufferPool = sync.Pool{&lt;br/&gt; New: &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;/span&gt;{} {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &amp;amp;bytes.Buffer{}&lt;br/&gt; },&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; data = &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;byte&lt;/span&gt;, &lt;span&gt;10000&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkBufferWithPool&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;0&lt;/span&gt;; n &amp;lt; b.N; n++ {&lt;br/&gt;  buf := bufferPool.Get().(*bytes.Buffer)&lt;br/&gt;  buf.Write(data)&lt;br/&gt;  buf.Reset()&lt;br/&gt;  bufferPool.Put(buf)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkBuffer&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;0&lt;/span&gt;; n &amp;lt; b.N; n++ {&lt;br/&gt;  &lt;span&gt;var&lt;/span&gt; buf bytes.Buffer&lt;br/&gt;  buf.Write(data)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=. -benchmem main/pool&lt;br/&gt;goos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/pool&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz&lt;br/&gt;BenchmarkBufferWithPool-12      11987966                97.12 ns/op            0 B/op          0 allocs/op&lt;br/&gt;BenchmarkBuffer-12               1246887              1020 ns/op           10240 B/op          1 allocs/op&lt;br/&gt;PASS&lt;br/&gt;ok      main/pool       3.510s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子创建了一个 bytes.Buffer 对象池，每次只执行 Write 操作，及做一次数据拷贝，耗时几乎可以忽略。而内存分配和回收的耗时占比较多，因此对程序整体的性能影响更大。从测试结果也可以看出，使用了 Pool 复用对象，每次操作不再有内存分配。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.5 在标准库中的应用&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 标准库也大量使用了 sync.Pool，例如 fmt 和 encoding/json。以 fmt 包为例，我们看下其是如何使用 sync.Pool 的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以看一下最常用的标准格式化输出函数 Printf() 函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Printf formats according to a format specifier and writes to standard output.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// It returns the number of bytes written and any write error encountered.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Printf&lt;/span&gt;&lt;span&gt;(format &lt;span&gt;string&lt;/span&gt;, a ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;(n &lt;span&gt;int&lt;/span&gt;, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; Fprintf(os.Stdout, format, a...)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续看 Fprintf() 的定义。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Fprintf formats according to a format specifier and writes to w.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// It returns the number of bytes written and any write error encountered.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;Fprintf&lt;/span&gt;&lt;span&gt;(w io.Writer, format &lt;span&gt;string&lt;/span&gt;, a ...&lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt; &lt;span&gt;(n &lt;span&gt;int&lt;/span&gt;, err error)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; p := newPrinter()&lt;br/&gt; p.doPrintf(format, a)&lt;br/&gt; n, err = w.Write(p.buf)&lt;br/&gt; p.free()&lt;br/&gt; &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Fprintf() 函数的参数是一个 io.Writer，Printf() 传的是 os.Stdout，相当于直接输出到标准输出。这里的 newPrinter 用的就是 sync.Pool。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// go version go1.17 darwin/amd64&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// pp is used to store a printer&#x27;s state and is reused with sync.Pool to avoid allocations.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; pp &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt;    buf buffer&lt;br/&gt;    ...&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; ppFree = sync.Pool{&lt;br/&gt; New: &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;/span&gt;{} { &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;(pp) },&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// newPrinter allocates a new pp struct or grabs a cached one.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;newPrinter&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; *&lt;span&gt;pp&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; p := ppFree.Get().(*pp)&lt;br/&gt; p.panicking = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; p.erroring = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; p.wrapErrs = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt; p.fmt.init(&amp;amp;p.buf)&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; p&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// free saves used pp structs in ppFree; avoids an allocation per invocation.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(p *pp)&lt;/span&gt; &lt;span&gt;free&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// Proper usage of a sync.Pool requires each entry to have approximately&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// the same memory cost. To obtain this property when the stored type&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// contains a variably-sized buffer, we add a hard limit on the maximum buffer&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// to place back in the pool.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// See https://golang.org/issue/23199&lt;/span&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;cap&lt;/span&gt;(p.buf) &amp;gt; &lt;span&gt;64&lt;/span&gt;&amp;lt;&amp;lt;&lt;span&gt;10&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;&lt;br/&gt; p.buf = p.buf[:&lt;span&gt;0&lt;/span&gt;]&lt;br/&gt; p.arg = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; p.value = reflect.Value{}&lt;br/&gt; p.wrappedErr = &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt; ppFree.Put(p)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;fmt.Printf() 的调用是非常频繁的，利用 sync.Pool 复用 pp 对象能够极大地提升性能，减少内存占用，同时降低 GC 压力。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;并发编程&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.关于锁&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1 无锁化&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加锁是为了避免在并发环境下，同时访问共享资源产生的安全问题。那么，在并发环境下，是否必须加锁？答案是否定的。并非所有的并发都需要加锁。适当地降低锁的粒度，甚至采用无锁化的设计，更能提升并发能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无锁化主要有两种实现，无锁数据结构和串行无锁。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1.1 无锁数据结构&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用硬件支持的原子操作可以实现无锁的数据结构，原子操作可以在 lock-free 的情况下保证并发安全，并且它的性能也能做到随 CPU 个数的增多而线性扩展。很多语言都提供 CAS 原子操作（如 Go 中的 atomic 包和 C++11 中的 atomic 库），可以用于实现无锁数据结构，如无锁链表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以一个简单的线程安全单向链表的插入操作来看下无锁编程和普通加锁的区别。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; list&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;sync&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;sync/atomic&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&quot;golang.org/x/sync/errgroup&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Node 链表节点&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Node &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Value &lt;span&gt;interface&lt;/span&gt;{}&lt;br/&gt; Next  *Node&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 有锁单向链表的简单实现&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// WithLockList 有锁单向链表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; WithLockList &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Head *Node&lt;br/&gt; mu   sync.Mutex&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Push 将元素插入到链表的首部&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(l *WithLockList)&lt;/span&gt; &lt;span&gt;Push&lt;/span&gt;&lt;span&gt;(v &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; l.mu.Lock()&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; l.mu.Unlock()&lt;br/&gt; n := &amp;amp;Node{&lt;br/&gt;  Value: v,&lt;br/&gt;  Next:  l.Head,&lt;br/&gt; }&lt;br/&gt; l.Head = n&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// String 有锁链表的字符串形式输出&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(l WithLockList)&lt;/span&gt; &lt;span&gt;String&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s := &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt; cur := l.Head&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; cur == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; s != &lt;span&gt;&quot;&quot;&lt;/span&gt; {&lt;br/&gt;   s += &lt;span&gt;&quot;,&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  s += fmt.Sprintf(&lt;span&gt;&quot;%v&quot;&lt;/span&gt;, cur.Value)&lt;br/&gt;  cur = cur.Next&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; s&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// 无锁单向链表的简单实现&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// LockFreeList 无锁单向链表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; LockFreeList &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; Head atomic.Value&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Push 有锁&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(l *LockFreeList)&lt;/span&gt; &lt;span&gt;Push&lt;/span&gt;&lt;span&gt;(v &lt;span&gt;interface&lt;/span&gt;{})&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  head := l.Head.Load()&lt;br/&gt;  headNode, _ := head.(*Node)&lt;br/&gt;  n := &amp;amp;Node{&lt;br/&gt;   Value: v,&lt;br/&gt;   Next:  headNode,&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; l.Head.CompareAndSwap(head, n) {&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// String 有锁链表的字符串形式输出&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(l LockFreeList)&lt;/span&gt; &lt;span&gt;String&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; s := &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt; cur := l.Head.Load().(*Node)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; cur == &lt;span&gt;nil&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;break&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; s != &lt;span&gt;&quot;&quot;&lt;/span&gt; {&lt;br/&gt;   s += &lt;span&gt;&quot;,&quot;&lt;/span&gt;&lt;br/&gt;  }&lt;br/&gt;  s += fmt.Sprintf(&lt;span&gt;&quot;%v&quot;&lt;/span&gt;, cur.Value)&lt;br/&gt;  cur = cur.Next&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; s&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的实现有几点需要注意一下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（1）无锁单向链表实现时在插入时需要进行 CAS 操作，即调用&lt;code&gt;CompareAndSwap()&lt;/code&gt;方法进行插入，如果插入失败则进行 for 循环多次尝试，直至成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（2）为了方便打印链表内容，实现一个&lt;code&gt;String()&lt;/code&gt;方法遍历链表，且使用值作为接收者，避免打印对象指针时无法生效。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;ol start=&quot;5&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;If an operand implements method String() string, that method will be invoked to convert the object to a string, which will then be formatted as required by the verb (if any).&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们分别对两种链表做一个并发写入的操作验证一下其功能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;br/&gt; &lt;span&gt;&quot;main/list&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ConcurWriteWithLockList 并发写入有锁链表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ConcurWriteWithLockList&lt;/span&gt;&lt;span&gt;(l *WithLockList)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; g errgroup.Group&lt;br/&gt; &lt;span&gt;// 10 个协程并发写入链表&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt;  i := i&lt;br/&gt;  g.Go(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   l.Push(i)&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt; _ = g.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ConcurWriteLockFreeList 并发写入无锁链表&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ConcurWriteLockFreeList&lt;/span&gt;&lt;span&gt;(l *LockFreeList)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; g errgroup.Group&lt;br/&gt; &lt;span&gt;// 10 个协程并发写入链表&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt;  i := i&lt;br/&gt;  g.Go(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   l.Push(i)&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt; _ = g.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// 并发写入与遍历打印有锁链表&lt;/span&gt;&lt;br/&gt; l1 := &amp;amp;list.WithLockList{}&lt;br/&gt; list.ConcurWriteWithLockList(l1)&lt;br/&gt; fmt.Println(l1)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// 并发写入与遍历打印无锁链表&lt;/span&gt;&lt;br/&gt; l2 := &amp;amp;list.LockFreeList{}&lt;br/&gt; list.ConcurWriteLockFreeList(l2)&lt;br/&gt; fmt.Println(l2)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意，多次运行上面的&lt;code&gt;main()&lt;/code&gt;函数的结果可能会不相同，因为并发是无序的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;8,7,6,9,5,4,3,1,2,0&lt;br/&gt;9,8,7,6,5,4,3,2,0,1&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面再看一下链表 Push 操作的基准测试，对比一下有锁与无锁的性能差异。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkWriteWithLockList&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; l := &amp;amp;WithLockList{}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;0&lt;/span&gt;; n &amp;lt; b.N; n++ {&lt;br/&gt;  l.Push(n)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;BenchmarkWriteWithLockList&lt;span&gt;-8&lt;/span&gt;    &lt;span&gt;14234166&lt;/span&gt;                &lt;span&gt;83.58&lt;/span&gt; ns/op&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkWriteLockFreeList&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; l := &amp;amp;LockFreeList{}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;0&lt;/span&gt;; n &amp;lt; b.N; n++ {&lt;br/&gt;  l.Push(n)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;BenchmarkWriteLockFreeList&lt;span&gt;-8&lt;/span&gt;    &lt;span&gt;15219405&lt;/span&gt;                &lt;span&gt;73.15&lt;/span&gt; ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看出无锁版本比有锁版本性能高一些。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.1.2 串行无锁&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;串行无锁是一种思想，就是避免对共享资源的并发访问，改为每个并发操作访问自己独占的资源，达到串行访问资源的效果，来避免使用锁。不同的场景有不同的实现方式。比如网络 I/O 场景下将&lt;strong&gt;单 Reactor 多线程模型&lt;/strong&gt;改为&lt;strong&gt;主从 Reactor 多线程模型&lt;/strong&gt;，避免对同一个消息队列锁读取。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我介绍的是后台微服务开发经常遇到的一种情况。我们经常需要并发拉取多方面的信息，汇聚到一个变量上。那么此时就存在对同一个变量互斥写入的情况。比如批量并发拉取用户信息写入到一个 map。此时我们可以将每个协程拉取的结果写入到一个临时对象，这样便将并发地协程与同一个变量解绑，然后再将其汇聚到一起，这样便可以不用使用锁。即独立处理，然后合并。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.19331742243436753&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasXic8UMQ0Bbvu6iaXLy4Q8sFJCE3nO5BibRwkgEf3biaawPGIsxcJ6qQib7aSFQdIlmaRrYHz1Zs5D9WA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1676&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了模拟上面的情况，简单地写个示例程序，对比下性能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;sync&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&quot;golang.org/x/sync/errgroup&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ConcurWriteMapWithLock 有锁并发写入 map&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ConcurWriteMapWithLock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; m := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; mu sync.Mutex&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; g errgroup.Group&lt;br/&gt; &lt;span&gt;// 10 个协程并发写入 map&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt;  i := i&lt;br/&gt;  g.Go(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   mu.Lock()&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; mu.Unlock()&lt;br/&gt;   m[i] = i * i&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt; _ = g.Wait()&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; m&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ConcurWriteMapLockFree 无锁并发写入 map&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ConcurWriteMapLockFree&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; m := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;int&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;// 每个协程独占一 value&lt;/span&gt;&lt;br/&gt; values := &lt;span&gt;make&lt;/span&gt;([]&lt;span&gt;int&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;// 10 个协程并发写入 map&lt;/span&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; g errgroup.Group&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt;  i := i&lt;br/&gt;  g.Go(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   values[i] = i * i&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt; _ = g.Wait()&lt;br/&gt; &lt;span&gt;// 汇聚结果到 map&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i, v := &lt;span&gt;range&lt;/span&gt; values {&lt;br/&gt;  m[i] = v&lt;br/&gt; }&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; m&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看下二者的性能差异：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkConcurWriteMapWithLock&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;0&lt;/span&gt;; n &amp;lt; b.N; n++ {&lt;br/&gt;  _ = ConcurWriteMapWithLock()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;BenchmarkConcurWriteMapWithLock&lt;span&gt;-8&lt;/span&gt;         &lt;span&gt;218673&lt;/span&gt;              &lt;span&gt;5089&lt;/span&gt; ns/op&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkConcurWriteMapLockFree&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; n := &lt;span&gt;0&lt;/span&gt;; n &amp;lt; b.N; n++ {&lt;br/&gt;  _ = ConcurWriteMapLockFree()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;BenchmarkConcurWriteMapLockFree&lt;span&gt;-8&lt;/span&gt;         &lt;span&gt;316635&lt;/span&gt;              &lt;span&gt;4048&lt;/span&gt; ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.2 减少锁竞争&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果加锁无法避免，则可以采用分片的形式，减少对资源加锁的次数，这样也可以提高整体的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如 Golang 优秀的本地缓存组件  &lt;a href=&quot;https://github.com/allegro/bigcache&quot; data-linktype=&quot;2&quot;&gt;bigcache&lt;/a&gt; 、&lt;a href=&quot;https://github.com/patrickmn/go-cache&quot; data-linktype=&quot;2&quot;&gt;go-cache&lt;/a&gt;、&lt;a href=&quot;https://github.com/coocood/freecache&quot; data-linktype=&quot;2&quot;&gt;freecache&lt;/a&gt; 都实现了分片功能，每个分片一把锁，采用分片存储的方式减少加锁的次数从而提高整体性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以一个简单的示例，通过对&lt;code&gt;map[uint64]struct{}&lt;/code&gt;分片前后并发写入的对比，来看下减少锁竞争带来的性能提升。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; (&lt;br/&gt; num = &lt;span&gt;1000000&lt;/span&gt;&lt;br/&gt; m0  = &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;struct&lt;/span&gt;{}, num)&lt;br/&gt; mu0 = sync.RWMutex{}&lt;br/&gt; m1  = &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;struct&lt;/span&gt;{}, num)&lt;br/&gt; mu1 = sync.RWMutex{}&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ConWriteMapNoShard 不分片写入一个 map。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ConWriteMapNoShard&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; g := errgroup.Group{}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; num; i++ {&lt;br/&gt;  g.Go(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   mu0.Lock()&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; mu0.Unlock()&lt;br/&gt;   m0[i] = &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt; _ = g.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// ConWriteMapTwoShard 分片写入两个 map。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ConWriteMapTwoShard&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; g := errgroup.Group{}&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; num; i++ {&lt;br/&gt;  g.Go(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;error&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; i&amp;amp;&lt;span&gt;1&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;    mu0.Lock()&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; mu0.Unlock()&lt;br/&gt;    m0[i] = &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   mu1.Lock()&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; mu1.Unlock()&lt;br/&gt;   m1[i] = &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; &lt;span&gt;nil&lt;/span&gt;&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt; _ = g.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看下二者的性能差异：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkConWriteMapNoShard&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  ConWriteMapNoShard()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;BenchmarkConWriteMapNoShard&lt;span&gt;-12&lt;/span&gt;                 &lt;span&gt;3&lt;/span&gt;         &lt;span&gt;472063245&lt;/span&gt; ns/op&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkConWriteMapTwoShard&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  ConWriteMapTwoShard()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;BenchmarkConWriteMapTwoShard&lt;span&gt;-12&lt;/span&gt;                &lt;span&gt;4&lt;/span&gt;         &lt;span&gt;310588155&lt;/span&gt; ns/op&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，通过对分共享资源的分片处理，减少了锁竞争，能明显地提高程序的并发性能。可以预见的是，随着分片粒度地变小，性能差距会越来越大。当然，分片粒度不是越小越好。因为每一个分片都要配一把锁，那么会带来很多额外的不必要的开销。可以选择一个不太大的值，在性能和花销上寻找一个平衡。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3 优先使用共享锁而非互斥锁&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果并发无法做到无锁化，优先使用共享锁而非互斥锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓互斥锁，指锁只能被一个 Goroutine 获得。共享锁指可以同时被多个 Goroutine 获得的锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 标准库 sync 提供了两种锁，互斥锁（sync.Mutex）和读写锁（sync.RWMutex），读写锁便是共享锁的一种具体实现。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3.1 sync.Mutex&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;互斥锁的作用是保证共享资源同一时刻只能被一个 Goroutine 占用，一个 Goroutine 占用了，其他的 Goroutine 则阻塞等待。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3859223300970874&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasXic8UMQ0Bbvu6iaXLy4Q8sFuDDfnQxBm08cRBpsiacfibcOFSnm1wWmtkBp9zFNeaq0WMdl55LehQCQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;824&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Mutex 提供了两个导出方法用来使用锁。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Lock()   &lt;span&gt;// 加锁&lt;/span&gt;&lt;br/&gt;Unlock()   &lt;span&gt;// 释放锁&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以通过在访问共享资源前前用 Lock 方法对资源进行上锁，在访问共享资源后调用 Unlock 方法来释放锁，也可以用 defer 语句来保证互斥锁一定会被解锁。在一个 Go 协程调用 Lock 方法获得锁后，其他请求锁的协程都会阻塞在 Lock 方法，直到锁被释放。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3.2 sync.RWMutex&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读写锁是一种共享锁，也称之为多读单写锁 (multiple readers, single writer lock)。在使用锁时，对获取锁的目的操作做了区分，一种是读操作，一种是写操作。因为同一时刻允许多个 Gorouine 获取读锁，所以是一种共享锁。但写锁是互斥的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般来说，有如下几种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;读锁之间不互斥，没有写锁的情况下，读锁是无阻塞的，多个协程可以同时获得读锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写锁之间是互斥的，存在写锁，其他写锁阻塞。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;写锁与读锁是互斥的，如果存在读锁，写锁阻塞，如果存在写锁，读锁阻塞。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.20430107526881722&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvasXic8UMQ0Bbvu6iaXLy4Q8sFVsSVEskUxvXv93ibFYdsQUHpHLE2zY5zsMZE93VeYn3eK15R9sSpZWA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1674&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.RWMutex 提供了五个导出方法用来使用锁。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Lock()    &lt;span&gt;// 加写锁&lt;/span&gt;&lt;br/&gt;Unlock()   &lt;span&gt;// 释放写锁&lt;/span&gt;&lt;br/&gt;RLock()    &lt;span&gt;// 加读锁&lt;/span&gt;&lt;br/&gt;RUnlock()   &lt;span&gt;// 释放读锁&lt;/span&gt;&lt;br/&gt;RLocker() Locker &lt;span&gt;// 返回读锁，使用 Lock() 和 Unlock() 进行 RLock() 和 RUnlock()&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读写锁的存在是为了解决读多写少时的性能问题，读场景较多时，读写锁可有效地减少锁阻塞的时间。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.3.3 性能对比&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大部分业务场景是读多写少，所以使用读写锁可有效提高对共享数据的访问效率。最坏的情况，只有写请求，那么读写锁顶多退化成互斥锁。所以优先使用读写锁而非互斥锁，可以提高程序的并发性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们测试三种情景下，互斥锁和读写锁的性能差异。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;读多写少(读占 80%)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;读写一致(各占 50%)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;读少写多(读占 20%)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先根据互斥锁和读写锁分别实现对共享 map 的并发读写。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// OpMapWithMutex 使用互斥锁读写 map。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// rpct 为读操作占比。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;OpMapWithMutex&lt;/span&gt;&lt;span&gt;(rpct &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; m := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;struct&lt;/span&gt;{})&lt;br/&gt; mu := sync.Mutex{}&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; wg sync.WaitGroup&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++ {&lt;br/&gt;  i := i&lt;br/&gt;  wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;   mu.Lock()&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; mu.Unlock()&lt;br/&gt;   &lt;span&gt;// 写操作。&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; i &amp;gt;= rpct {&lt;br/&gt;    m[i] = &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt;    time.Sleep(time.Microsecond)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;// 读操作。&lt;/span&gt;&lt;br/&gt;   _ = m[i]&lt;br/&gt;   time.Sleep(time.Microsecond)&lt;br/&gt;  }()&lt;br/&gt; }&lt;br/&gt; wg.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// OpMapWithRWMutex 使用读写锁读写 map。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// rpct 为读操作占比。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;OpMapWithRWMutex&lt;/span&gt;&lt;span&gt;(rpct &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; m := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;map&lt;/span&gt;[&lt;span&gt;int&lt;/span&gt;]&lt;span&gt;struct&lt;/span&gt;{})&lt;br/&gt; mu := sync.RWMutex{}&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; wg sync.WaitGroup&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++ {&lt;br/&gt;  i := i&lt;br/&gt;  wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;   &lt;span&gt;// 写操作。&lt;/span&gt;&lt;br/&gt;   &lt;span&gt;if&lt;/span&gt; i &amp;gt;= rpct {&lt;br/&gt;    mu.Lock()&lt;br/&gt;    &lt;span&gt;defer&lt;/span&gt; mu.Unlock()&lt;br/&gt;    m[i] = &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt;    time.Sleep(time.Microsecond)&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt;&lt;br/&gt;   }&lt;br/&gt;   &lt;span&gt;// 读操作。&lt;/span&gt;&lt;br/&gt;   mu.RLock()&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; mu.RUnlock()&lt;br/&gt;   _ = m[i]&lt;br/&gt;   time.Sleep(time.Microsecond)&lt;br/&gt;  }()&lt;br/&gt; }&lt;br/&gt; wg.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;入参 rpct 用来调节读操作的占比，来模拟读写占比不同的场景。rpct 设为 80 表示读多写少(读占 80%)，rpct 设为 50 表示读写一致(各占 50%)，rpct 设为 20 表示读少写多(读占 20%)。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkMutexReadMore&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  OpMapWithMutex(&lt;span&gt;80&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkRWMutexReadMore&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  OpMapWithRWMutex(&lt;span&gt;80&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkMutexRWEqual&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  OpMapWithMutex(&lt;span&gt;50&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkRWMutexRWEqual&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  OpMapWithRWMutex(&lt;span&gt;50&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkMutexWriteMore&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  OpMapWithMutex(&lt;span&gt;20&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkRWMutexWriteMore&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  OpMapWithRWMutex(&lt;span&gt;20&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行当前包下的所有基准测试，结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;dablelv@DABLELV-MB0 mutex % go test -bench=.&lt;br/&gt;goos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/mutex&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz&lt;br/&gt;BenchmarkMutexReadMore-12                   2462            485917 ns/op&lt;br/&gt;BenchmarkRWMutexReadMore-12                 8074            145690 ns/op&lt;br/&gt;BenchmarkMutexRWEqual-12                    2406            498673 ns/op&lt;br/&gt;BenchmarkRWMutexRWEqual-12                  4124            303693 ns/op&lt;br/&gt;BenchmarkMutexWriteMore-12                  1906            532350 ns/op&lt;br/&gt;BenchmarkRWMutexWriteMore-12                2462            432386 ns/op&lt;br/&gt;PASS&lt;br/&gt;ok      main/mutex      9.532s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可见读多写少的场景，使用读写锁并发性能会更优。可以预见的是如果写占比更低，那么读写锁带的并发效果会更优。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里需要注意的是，因为每次读写 map 的操作耗时很短，所以每次睡眠一微秒（百万分之一秒）来增加耗时，不然对共享资源的访问耗时，小于锁处理的本身耗时，那么使用读写锁带来的性能优化效果将变得不那么明显，甚至会降低性能。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.限制协程数量&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1 协程数过多的问题&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.1 程序崩溃&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 程（goroutine）是由 Go 运行时管理的轻量级线程。通过它我们可以轻松实现并发编程。但是当我们无限开辟协程时，将会遇到致命的问题。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; wg sync.WaitGroup&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; math.MaxInt32; i++ {&lt;br/&gt;  wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(i &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;   fmt.Println(i)&lt;br/&gt;   time.Sleep(time.Second)&lt;br/&gt;  }(i)&lt;br/&gt; }&lt;br/&gt; wg.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个例子实现了 math.MaxInt32 个协程的并发，&lt;code&gt;2^31 - 1&lt;/code&gt; 约为 20 亿个，每个协程内部几乎没有做什么事情。正常的情况下呢，这个程序会乱序输出 0 ~ 2^31-1 个数字。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;程序会像预期的那样顺利的运行吗？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go run main.go&lt;br/&gt;...&lt;br/&gt;108668&lt;br/&gt;1142025&lt;br/&gt;panic: too many concurrent operations on a single file or socket (max 1048575)&lt;br/&gt;&lt;br/&gt;goroutine 1158408 [running]:&lt;br/&gt;internal/poll.(*fdMutex).rwlock(0xc0000ae060, 0x0)&lt;br/&gt;        /usr/local/go/src/internal/poll/fd_mutex.go:147 +0x11b&lt;br/&gt;internal/poll.(*FD).writeLock(...)&lt;br/&gt;        /usr/local/go/src/internal/poll/fd_mutex.go:239&lt;br/&gt;internal/poll.(*FD).Write(0xc0000ae060, {0xc12cadf690, 0x8, 0x8})&lt;br/&gt;        /usr/local/go/src/internal/poll/fd_unix.go:262 +0x72&lt;br/&gt;os.(*File).write(...)&lt;br/&gt;        /usr/local/go/src/os/file_posix.go:49&lt;br/&gt;os.(*File).Write(0xc0000ac008, {0xc12cadf690, 0x1, 0xc12ea62f50})&lt;br/&gt;        /usr/local/go/src/os/file.go:176 +0x65&lt;br/&gt;fmt.Fprintln({0x10c00e0, 0xc0000ac008}, {0xc12ea62f90, 0x1, 0x1})&lt;br/&gt;        /usr/local/go/src/fmt/print.go:265 +0x75&lt;br/&gt;fmt.Println(...)&lt;br/&gt;        /usr/local/go/src/fmt/print.go:274&lt;br/&gt;main.main.func1(0x0)&lt;br/&gt;        /Users/dablelv/work/code/test/main.go:16 +0x8f&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行的结果是程序直接崩溃了，关键的报错信息是：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;panic: too many concurrent operations on a single file or socket (max 1048575)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对单个 file/socket 的并发操作个数超过了系统上限，这个报错是 fmt.Printf 函数引起的，fmt.Printf 将格式化后的字符串打印到屏幕，即标准输出。在 Linux 系统中，标准输出也可以视为文件，内核（Kernel）利用文件描述符（File Descriptor）来访问文件，标准输出的文件描述符为 1，错误输出文件描述符为 2，标准输入的文件描述符为 0。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简而言之，系统的资源被耗尽了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那如果我们将 fmt.Printf 这行代码去掉呢？那程序很可能会因为内存不足而崩溃。这一点更好理解，每个协程至少需要消耗 2KB 的空间，那么假设计算机的内存是 4GB，那么至多允许 4GB/2KB = 1M 个协程同时存在。那如果协程中还存在着其他需要分配内存的操作，那么允许并发执行的协程将会数量级地减少。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.1.2 协程的代价&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面的例子过于极端，一般情况下程序也不会无限开辟协程，旨在说明协程数量是有限制的，不能无限开辟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们开辟很多协程，但不会导致程序崩溃，可以吗？如果真要这么做的话，我们应该清楚地知道，协程虽然轻量，但仍有开销。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 的开销主要是三个方面：创建（占用内存）、调度（增加调度器负担）和删除（增加 GC 压力）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;空间上，一个 Go 程占用约 2K 的内存，在源码 src/runtime/runtime2.go里面，我们可以找到 Go 程的结构定义type g struct。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;时间上，协程调度也会有 CPU 开销。我们可以利用runntime.Gosched()让当前协程主动让出 CPU 去执行另外一个协程，下面看一下协程之间切换的耗时。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; NUM = &lt;span&gt;10000&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;cal&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; NUM; i++ {&lt;br/&gt;  runtime.Gosched()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// 只设置一个 Processor&lt;/span&gt;&lt;br/&gt; runtime.GOMAXPROCS(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt; start := time.Now().UnixNano()&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; cal()&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; NUM; i++ {&lt;br/&gt;  runtime.Gosched()&lt;br/&gt; }&lt;br/&gt; end := time.Now().UnixNano()&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;total %vns per %vns&quot;&lt;/span&gt;, end-start, (end-start)/NUM)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;total 997200ns per 99ns&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可见一次协程的切换，耗时大概在 100ns，相对于线程的微秒级耗时切换，性能表现非常优秀，但是仍有开销。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;GC 开销
创建 Go 程到运行结束，占用的内存资源是需要由 GC 来回收，如果无休止地创建大量 Go 程后，势必会造成对 GC 的压力。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;runtime&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;runtime/debug&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;sync&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;createLargeNumGoroutine&lt;/span&gt;&lt;span&gt;(num &lt;span&gt;int&lt;/span&gt;, wg *sync.WaitGroup)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; wg.Add(num)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; num; i++ {&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;  }()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// 只设置一个 Processor 保证 Go 程串行执行&lt;/span&gt;&lt;br/&gt; runtime.GOMAXPROCS(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;// 关闭GC改为手动执行&lt;/span&gt;&lt;br/&gt; debug.SetGCPercent(&lt;span&gt;-1&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; wg sync.WaitGroup&lt;br/&gt; createLargeNumGoroutine(&lt;span&gt;1000&lt;/span&gt;, &amp;amp;wg)&lt;br/&gt; wg.Wait()&lt;br/&gt; t := time.Now()&lt;br/&gt; runtime.GC() &lt;span&gt;// 手动GC&lt;/span&gt;&lt;br/&gt; cost := time.Since(t)&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;GC cost %v when goroutine num is %v\n&quot;&lt;/span&gt;, cost, &lt;span&gt;1000&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; createLargeNumGoroutine(&lt;span&gt;10000&lt;/span&gt;, &amp;amp;wg)&lt;br/&gt; wg.Wait()&lt;br/&gt; t = time.Now()&lt;br/&gt; runtime.GC() &lt;span&gt;// 手动GC&lt;/span&gt;&lt;br/&gt; cost = time.Since(t)&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;GC cost %v when goroutine num is %v\n&quot;&lt;/span&gt;, cost, &lt;span&gt;10000&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt; createLargeNumGoroutine(&lt;span&gt;100000&lt;/span&gt;, &amp;amp;wg)&lt;br/&gt; wg.Wait()&lt;br/&gt; t = time.Now()&lt;br/&gt; runtime.GC() &lt;span&gt;// 手动GC&lt;/span&gt;&lt;br/&gt; cost = time.Since(t)&lt;br/&gt; fmt.Printf(&lt;span&gt;&quot;GC cost %v when goroutine num is %v\n&quot;&lt;/span&gt;, cost, &lt;span&gt;100000&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;GC cost 0s when goroutine num is 1000&lt;br/&gt;GC cost 2.0027ms when goroutine num is 10000&lt;br/&gt;GC cost 30.9523ms when goroutine num is 100000&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当创建的 Go 程数量越多，GC 耗时越大。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的分析目的是为了尽可能地量化 Goroutine 的开销。虽然官方宣称用 Golang 写并发程序的时候随便起个成千上万的 Goroutine 毫无压力，但当我们起十万、百万甚至千万个 Goroutine 呢？Goroutine 轻量的开销将被放大。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.2 限制协程数量&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;系统地资源是有限，协程是有代价的，为了保护程序，提高性能，我们应主动限制并发的协程数量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以利用信道 channel 的缓冲区大小来实现。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;var&lt;/span&gt; wg sync.WaitGroup&lt;br/&gt; ch := &lt;span&gt;make&lt;/span&gt;(&lt;span&gt;chan&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;{}, &lt;span&gt;3&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt;  ch &amp;lt;- &lt;span&gt;struct&lt;/span&gt;{}{}&lt;br/&gt;  wg.Add(&lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  &lt;span&gt;go&lt;/span&gt; &lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;(i &lt;span&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   &lt;span&gt;defer&lt;/span&gt; wg.Done()&lt;br/&gt;   log.Println(i)&lt;br/&gt;   time.Sleep(time.Second)&lt;br/&gt;   &amp;lt;-ch&lt;br/&gt;  }(i)&lt;br/&gt; }&lt;br/&gt; wg.Wait()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上例中创建了缓冲区大小为 3 的 channel，在没有被接收的情况下，至多发送 3 个消息则被阻塞。开启协程前，调用&lt;code&gt;ch &amp;lt;- struct{}{}&lt;/code&gt;，若缓存区满，则阻塞。协程任务结束，调用 &amp;lt;-ch 释放缓冲区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.WaitGroup 并不是必须的，例如 Http 服务，每个请求天然是并发的，此时使用 channel 控制并发处理的任务数量，就不需要 sync.WaitGroup。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;2022/03/06 20:37:02 0&lt;br/&gt;2022/03/06 20:37:02 2&lt;br/&gt;2022/03/06 20:37:02 1&lt;br/&gt;2022/03/06 20:37:03 3&lt;br/&gt;2022/03/06 20:37:03 4&lt;br/&gt;2022/03/06 20:37:03 5&lt;br/&gt;2022/03/06 20:37:04 6&lt;br/&gt;2022/03/06 20:37:04 7&lt;br/&gt;2022/03/06 20:37:04 8&lt;br/&gt;2022/03/06 20:37:05 9&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从日志中可以很容易看到，每秒钟只并发执行了 3 个任务，达到了协程并发控制的目的。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.3 协程池化&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面的例子只是简单地限制了协程开辟的数量。在此基础之上，基于对象复用的思想，我们可以重复利用已开辟的协程，避免协程的重复创建销毁，达到池化的效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;协程池化，我们可以自己写一个协程池，但不推荐这么做。因为已经有成熟的开源库可供使用，无需再重复造轮子。目前有很多第三方库实现了协程池，可以很方便地用来控制协程的并发数量，比较受欢迎的有：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面以 panjf2000/ants 为例，简单介绍其使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ants 是一个简单易用的高性能 Goroutine 池，实现了对大规模 Goroutine 的调度管理和复用，允许使用者在开发并发程序的时候限制 Goroutine 数量，复用协程，达到更高效执行任务的效果。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; (&lt;br/&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;&quot;time&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;&quot;github.com/panjf2000/ants&quot;&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// Use the common pool&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10&lt;/span&gt;; i++ {&lt;br/&gt;  i := i&lt;br/&gt;  ants.Submit(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;   fmt.Println(i)&lt;br/&gt;  })&lt;br/&gt; }&lt;br/&gt; time.Sleep(time.Second)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 ants，我们简单地使用其默认的协程池，直接将任务提交并发执行。默认协程池的缺省容量 math.MaxInt32。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果自定义协程池容量大小，可以调用 NewPool 方法来实例化具有给定容量的池，如下所示：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Set 10000 the size of goroutine pool&lt;/span&gt;&lt;br/&gt;p, _ := ants.NewPool(&lt;span&gt;10000&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.4 小结&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Golang 为并发而生。Goroutine 是由 Go 运行时管理的轻量级线程，通过它我们可以轻松实现并发编程。Go 虽然轻量，但天下没有免费的午餐，无休止地开辟大量 Go 程势必会带来性能影响，甚至程序崩溃。所以，我们应尽可能的控制协程数量，如果有需要，请复用它。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.使用 sync.Once 避免重复执行&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.1 简介&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Once 是 Go 标准库提供的使函数只执行一次的实现，常应用于单例模式，例如初始化配置、保持数据库连接等。作用与 init 函数类似，但有区别。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;init 函数是当所在的 package 首次被加载时执行，若迟迟未被使用，则既浪费了内存，又延长了程序加载时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;sync.Once 可以在代码的任意位置初始化和调用，因此可以延迟到使用时再执行，并发场景下是线程安全的。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在多数情况下，sync.Once 被用于控制变量的初始化，这个变量的读写满足如下三个条件：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;当且仅当第一次访问某个变量时，进行初始化（写）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;变量初始化过程中，所有读都被阻塞，直到初始化完成；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;变量仅初始化一次，初始化完成后驻留在内存里。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2 原理&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Once 用来保证函数只执行一次。要达到这个效果，需要做到两点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;计数器，统计函数执行次数；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;线程安全，保障在多 Go 程的情况下，函数仍然只执行一次，比如锁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2.1 源码&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面看一下 sync.Once 结构，其有两个变量。使用 done 统计函数执行次数，使用锁 m 实现线程安全。果不其然，和上面的猜想一致。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Once is an object that will perform exactly one action.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// A Once must not be copied after first use.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Once &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// done indicates whether the action has been performed.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// It is first in the struct because it is used in the hot path.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// The hot path is inlined at every call site.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// Placing done first allows more compact instructions on some architectures (amd64/386),&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// and fewer instructions (to calculate offset) on other architectures.&lt;/span&gt;&lt;br/&gt; done &lt;span&gt;uint32&lt;/span&gt;&lt;br/&gt; m    Mutex&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Once 仅提供了一个导出方法 Do()，参数 f 是只会被执行一次的函数，一般为对象初始化函数。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// go version go1.17 darwin/amd64&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Do calls the function f if and only if Do is being called for the&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// first time for this instance of Once. In other words, given&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//  var once Once&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// if once.Do(f) is called multiple times, only the first call will invoke f,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// even if f has a different value in each invocation. A new instance of&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Once is required for each function to execute.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Do is intended for initialization that must be run exactly once. Since f&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// is niladic, it may be necessary to use a function literal to capture the&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// arguments to a function to be invoked by Do:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//  config.once.Do(func() { config.init(filename) })&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Because no call to Do returns until the one call to f returns, if f causes&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Do to be called, it will deadlock.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// If f panics, Do considers it to have returned; future calls of Do return&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// without calling f.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(o *Once)&lt;/span&gt; &lt;span&gt;Do&lt;/span&gt;&lt;span&gt;(f &lt;span&gt;func&lt;/span&gt;()&lt;/span&gt;)&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;// Note: Here is an incorrect implementation of Do:&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// if atomic.CompareAndSwapUint32(&amp;amp;o.done, 0, 1) {&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//  f()&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// }&lt;/span&gt;&lt;br/&gt; &lt;span&gt;//&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// Do guarantees that when it returns, f has finished.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// This implementation would not implement that guarantee:&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// given two simultaneous calls, the winner of the cas would&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// call f, and the second would return immediately, without&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// waiting for the first&#x27;s call to f to complete.&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// This is why the slow path falls back to a mutex, and why&lt;/span&gt;&lt;br/&gt; &lt;span&gt;// the atomic.StoreUint32 must be delayed until after f returns.&lt;/span&gt;&lt;br/&gt;&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; atomic.LoadUint32(&amp;amp;o.done) == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;// Outlined slow-path to allow inlining of the fast-path.&lt;/span&gt;&lt;br/&gt;  o.doSlow(f)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(o *Once)&lt;/span&gt; &lt;span&gt;doSlow&lt;/span&gt;&lt;span&gt;(f &lt;span&gt;func&lt;/span&gt;()&lt;/span&gt;)&lt;/span&gt; {&lt;br/&gt; o.m.Lock()&lt;br/&gt; &lt;span&gt;defer&lt;/span&gt; o.m.Unlock()&lt;br/&gt; &lt;span&gt;if&lt;/span&gt; o.done == &lt;span&gt;0&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;defer&lt;/span&gt; atomic.StoreUint32(&amp;amp;o.done, &lt;span&gt;1&lt;/span&gt;)&lt;br/&gt;  f()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;抛去大段的注释，可以看到 sync.Once 实现非常简洁。Do() 函数中，通过对成员变量 done 的判断，来决定是否执行传入的任务函数。执行任务函数前，通过锁保证任务函数的执行和 done 的修改是一个互斥操作。在执行任务函数前，对 done 做一个二次判断，来保证任务函数只会被执行一次，done 只会被修改一次。&lt;/p&gt;&lt;h6 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.2.2  done 为什么是第一个字段&lt;/span&gt;&lt;span/&gt;&lt;/h6&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从字段 done 前有一段注释，说明了done 为什么是第一个字段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;done 在热路径中，done 放在第一个字段，能够减少 CPU 指令，也就是说，这样做能够提升性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;热路径（hot path）是程序非常频繁执行的一系列指令，sync.Once 绝大部分场景都会访问 o.done，在热路径上是比较好理解的。如果 hot path 编译后的机器码指令更少，更直接，必然是能够提升性能的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么放在第一个字段就能够减少指令呢？因为结构体第一个字段的地址和结构体的指针是相同的，如果是第一个字段，直接对结构体的指针解引用即可。如果是其他的字段，除了结构体指针外，还需要计算与第一个值的偏移（calculate offset）。在机器码中，偏移量是随指令传递的附加值，CPU 需要做一次偏移值与指针的加法运算，才能获取要访问的值的地址。因为，访问第一个字段的机器代码更紧凑，速度更快。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;参考 &lt;a href=&quot;https://stackoverflow.com/questions/59174176/what-does-hot-path-mean-in-the-context-of-sync-once&quot; data-linktype=&quot;2&quot;&gt;What does “hot path” mean in the context of sync.Once? - StackOverflow&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.3 性能差异&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以一个简单示例，来说明使用 sync.Once 保证函数只会被执行一次和多次执行，二者的性能差异。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;考虑一个简单的场景，函数 ReadConfig 需要读取环境变量，并转换为对应的配置。环境变量在程序执行前已经确定，执行过程中不会发生改变。ReadConfig 可能会被多个协程并发调用，为了提升性能（减少执行时间和内存占用），使用 sync.Once 是一个比较好的方式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;type&lt;/span&gt; Config &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; GoRoot &lt;span&gt;string&lt;/span&gt;&lt;br/&gt; GoPath &lt;span&gt;string&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; (&lt;br/&gt; once   sync.Once&lt;br/&gt; config *Config&lt;br/&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ReadConfigWithOnce&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; *&lt;span&gt;Config&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; once.Do(&lt;span&gt;&lt;span&gt;func&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt;  config = &amp;amp;Config{&lt;br/&gt;   GoRoot: os.Getenv(&lt;span&gt;&quot;GOROOT&quot;&lt;/span&gt;),&lt;br/&gt;   GoPath: os.Getenv(&lt;span&gt;&quot;GOPATH&quot;&lt;/span&gt;),&lt;br/&gt;  }&lt;br/&gt; })&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; config&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;ReadConfig&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; *&lt;span&gt;Config&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &amp;amp;Config{&lt;br/&gt;  GoRoot: os.Getenv(&lt;span&gt;&quot;GOROOT&quot;&lt;/span&gt;),&lt;br/&gt;  GoPath: os.Getenv(&lt;span&gt;&quot;GOPATH&quot;&lt;/span&gt;),&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看下二者的性能差异。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkReadConfigWithOnce&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = ReadConfigWithOnce()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;BenchmarkReadConfig&lt;/span&gt;&lt;span&gt;(b *testing.B)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; b.N; i++ {&lt;br/&gt;  _ = ReadConfig()&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行测试结果如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go test -bench=. main/once&lt;br/&gt;goos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: main/once&lt;br/&gt;cpu: Intel(R) Core(TM) i7-9750H CPU @ 2.60GHz&lt;br/&gt;BenchmarkReadConfigWithOnce-12          670438965                1.732 ns/op&lt;br/&gt;BenchmarkReadConfig-12                  13339154                87.46 ns/op&lt;br/&gt;PASS&lt;br/&gt;ok      main/once       3.006s&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Once 中保证了 Config 初始化函数仅执行了一次，避免了多次重复初始化，在并发环境下很有用。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.使用 sync.Cond 通知协程&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.1 简介&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Cond 是基于互斥锁/读写锁实现的条件变量，用来协调想要访问共享资源的那些 Goroutine，当共享资源的状态发生变化的时候，sync.Cond 可以用来通知等待条件发生而阻塞的 Goroutine。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Cond 基于互斥锁/读写锁，它和互斥锁的区别是什么呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;互斥锁 sync.Mutex 通常用来保护共享的临界资源，条件变量 sync.Cond 用来协调想要访问共享资源的 Goroutine。当共享资源的状态发生变化时，sync.Cond 可以用来通知被阻塞的 Goroutine。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.2 使用场景&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Cond 经常用在多个 Goroutine 等待，一个 Goroutine 通知（事件发生）的场景。如果是一个通知，一个等待，使用互斥锁或 channel 就能搞定了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们想象一个非常简单的场景：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一个协程在异步地接收数据，剩下的多个协程必须等待这个协程接收完数据，才能读取到正确的数据。在这种情况下，如果单纯使用 chan 或互斥锁，那么只能有一个协程可以等待，并读取到数据，没办法通知其他的协程也读取数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个时候，就需要有个全局的变量来标志第一个协程数据是否接受完毕，剩下的协程，反复检查该变量的值，直到满足要求。或者创建多个 channel，每个协程阻塞在一个 channel 上，由接收数据的协程在数据接收完毕后，逐个通知。总之，需要额外的复杂度来完成这件事。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 语言在标准库 sync 中内置一个 sync.Cond 用来解决这类问题。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.3 原理&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Cond 内部维护了一个等待队列，队列中存放的是所有在等待这个 sync.Cond 的 Go 程，即保存了一个通知列表。sync.Cond 可以用来唤醒一个或所有因等待条件变量而阻塞的 Go 程，以此来实现多个 Go 程间的同步。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Cond 的定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Cond implements a condition variable, a rendezvous point&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// for goroutines waiting for or announcing the occurrence&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// of an event.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Each Cond has an associated Locker L (often a *Mutex or *RWMutex),&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// which must be held when changing the condition and&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// when calling the Wait method.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// A Cond must not be copied after first use.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;type&lt;/span&gt; Cond &lt;span&gt;struct&lt;/span&gt; {&lt;br/&gt; noCopy noCopy&lt;br/&gt;&lt;br/&gt; &lt;span&gt;// L is held while observing or changing the condition&lt;/span&gt;&lt;br/&gt; L Locker&lt;br/&gt;&lt;br/&gt; notify  notifyList&lt;br/&gt; checker copyChecker&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个 Cond 实例都会关联一个锁 L（互斥锁 *Mutex，或读写锁 *RWMutex），当修改条件或者调用 Wait 方法时，必须加锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Cond 的四个成员函数定义如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// NewCond returns a new Cond with Locker l.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;NewCond&lt;/span&gt;&lt;span&gt;(l Locker)&lt;/span&gt; *&lt;span&gt;Cond&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; &amp;amp;Cond{L: l}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NewCond 创建 Cond 实例时，需要关联一个锁。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Wait atomically unlocks c.L and suspends execution&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// of the calling goroutine. After later resuming execution,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Wait locks c.L before returning. Unlike in other systems,&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Wait cannot return unless awoken by Broadcast or Signal.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Because c.L is not locked when Wait first resumes, the caller&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// typically cannot assume that the condition is true when&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// Wait returns. Instead, the caller should Wait in a loop:&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//    c.L.Lock()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//    for !condition() {&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//        c.Wait()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//    }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//    ... make use of condition ...&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//    c.L.Unlock()&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Cond)&lt;/span&gt; &lt;span&gt;Wait&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; c.checker.check()&lt;br/&gt; t := runtime_notifyListAdd(&amp;amp;c.notify)&lt;br/&gt; c.L.Unlock()&lt;br/&gt; runtime_notifyListWait(&amp;amp;c.notify, t)&lt;br/&gt; c.L.Lock()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Wait 用于阻塞调用者，等待通知。调用 Wait 会自动释放锁 c.L，并挂起调用者所在的 goroutine。如果其他协程调用了 Signal 或 Broadcast 唤醒了该协程，那么 Wait 方法在结束阻塞时，会重新给 c.L 加锁，并且继续执行 Wait 后面的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对条件的检查，使用了 for !condition() 而非 if，是因为当前协程被唤醒时，条件不一定符合要求，需要再次 Wait 等待下次被唤醒。为了保险起，使用 for 能够确保条件符合要求后，再执行后续的代码。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// Signal wakes one goroutine waiting on c, if there is any.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// It is allowed but not required for the caller to hold c.L&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// during the call.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Cond)&lt;/span&gt; &lt;span&gt;Signal&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; c.checker.check()&lt;br/&gt; runtime_notifyListNotifyOne(&amp;amp;c.notify)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Broadcast wakes all goroutines waiting on c.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;//&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// It is allowed but not required for the caller to hold c.L&lt;/span&gt;&lt;br/&gt;&lt;span&gt;// during the call.&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;(c *Cond)&lt;/span&gt; &lt;span&gt;Broadcast&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; c.checker.check()&lt;br/&gt; runtime_notifyListNotifyAll(&amp;amp;c.notify)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Signal 只唤醒任意 1 个等待条件变量 c 的 goroutine，无需锁保护。Broadcast 唤醒所有等待条件变量 c 的 goroutine，无需锁保护。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.4 使用示例&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们实现一个简单的例子，三个协程调用 Wait() 等待，另一个协程调用 Broadcast() 唤醒所有等待的协程。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; done = &lt;span&gt;false&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;read&lt;/span&gt;&lt;span&gt;(name &lt;span&gt;string&lt;/span&gt;, c *sync.Cond)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; c.L.Lock()&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; !done {&lt;br/&gt;  c.Wait()&lt;br/&gt; }&lt;br/&gt; log.Println(name, &lt;span&gt;&quot;starts reading&quot;&lt;/span&gt;)&lt;br/&gt; c.L.Unlock()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;write&lt;/span&gt;&lt;span&gt;(name &lt;span&gt;string&lt;/span&gt;, c *sync.Cond)&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; log.Println(name, &lt;span&gt;&quot;starts writing&quot;&lt;/span&gt;)&lt;br/&gt; time.Sleep(time.Second)&lt;br/&gt; done = &lt;span&gt;true&lt;/span&gt;&lt;br/&gt; log.Println(name, &lt;span&gt;&quot;wakes all&quot;&lt;/span&gt;)&lt;br/&gt; c.Broadcast()&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; cond := sync.NewCond(&amp;amp;sync.Mutex{})&lt;br/&gt;&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; read(&lt;span&gt;&quot;reader1&quot;&lt;/span&gt;, cond)&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; read(&lt;span&gt;&quot;reader2&quot;&lt;/span&gt;, cond)&lt;br/&gt; &lt;span&gt;go&lt;/span&gt; read(&lt;span&gt;&quot;reader3&quot;&lt;/span&gt;, cond)&lt;br/&gt; write(&lt;span&gt;&quot;writer&quot;&lt;/span&gt;, cond)&lt;br/&gt;&lt;br/&gt; time.Sleep(time.Second * &lt;span&gt;3&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;section&gt;done 即多个 Goroutine 阻塞等待的条件。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;read() 调用 Wait() 等待通知，直到 done 为 true。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;write() 接收数据，接收完成后，将 done 置为 true，调用 Broadcast() 通知所有等待的协程。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;write() 中的暂停了 1s，一方面是模拟耗时，另一方面是确保前面的 3 个 read 协程都执行到 Wait()，处于等待状态。main 函数最后暂停了 3s，确保所有操作执行完毕。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行输出：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;go run main.go&lt;br/&gt;2022/03/07 17:20:09 writer starts writing&lt;br/&gt;2022/03/07 17:20:10 writer wakes all&lt;br/&gt;2022/03/07 17:20:10 reader3 starts reading&lt;br/&gt;2022/03/07 17:20:10 reader1 starts reading&lt;br/&gt;2022/03/07 17:20:10 reader2 starts reading&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多关于 sync.Cond 的讨论可参考 &lt;a href=&quot;https://stackoverflow.com/questions/36857167/how-to-correctly-use-sync-cond&quot; data-linktype=&quot;2&quot;&gt;How to correctly use sync.Cond? - StackOverflow&lt;/a&gt;。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.5 注意事项&lt;/span&gt;&lt;span/&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sync.Cond 不能被复制的原因，并不是因为其内部嵌套了 Locker。因为 NewCond 时传入的 Mutex/RWMutex 指针，对于 Mutex 指针复制是没有问题的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要原因是 sync.Cond 内部是维护着一个 Goroutine 通知队列 notifyList。如果这个队列被复制的话，那么就在并发场景下导致不同 Goroutine 之间操作的 notifyList.wait、notifyList.notify 并不是同一个，这会导致出现有些 Goroutine 会一直阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从等待队列中按照顺序唤醒，先进入等待队列，先被唤醒。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;调用 Wait() 函数前，需要先获得条件变量的成员锁，原因是需要互斥地变更条件变量的等待队列。在 Wait() 返回前，会重新上锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考文献&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;最近好文：&lt;/strong&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649768568&amp;amp;idx=1&amp;amp;sn=68dc084a79407a41762f8705b28e1257&amp;amp;chksm=beccd10389bb5815ae094ed7423a32f421fd143d724cbf0330efaeaf0382e683e575e6350f30&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;在鹅厂工作1到11年的程序媛&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;在鹅厂工作1到11年的程序媛&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649769049&amp;amp;idx=1&amp;amp;sn=b8ac0e6409b073758fa0bbcde1acd952&amp;amp;chksm=beccd72289bb5e34bacb76669650d8ebb70563fb35b381f452f20c62b86968f2efbeb98d8337&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;技术她力量，鹅厂女博士的寻“豹”之旅&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;技术她力量，鹅厂女博士的寻“豹”之旅&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MjM5ODYwMjI2MA==&amp;amp;mid=2649769274&amp;amp;idx=1&amp;amp;sn=a46fc1574ecbf5cfddd1f40af9cb1b4f&amp;amp;chksm=beccd64189bb5f57f80799fd2ea51c7669942254a2223dea55fe7d2bfa5762410a784dec8e2f&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;微信全文搜索技术优化&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; imgdata=&quot;null&quot; data-itemshowtype=&quot;11&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;微信全文搜索技术优化&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAgDAS3gDsiAAAAAstQy6ubaLX4KHWvLEZgBPE8KIMcXtxZL38zNPgMIvt27oRctxLQngBmm2RSmIU&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=rjD5jyTuFrIpZ2ibE8T7YmwgiahniaXswqz4S6B63dgPBSkQM1Pibkk08bsnRVMG0MKAZ26U5ESqSNFtReXFxmYaalxffR57exzXKicibmO91qDTVFBh9zBPSEAA&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=&amp;amp;scene=0&amp;amp;token=AxricY7RBHdWOPjH6MHTJcta8qxWU2YJYIzYZjHP3n6pJIp2mTCHqh9rqZQPUvWCEgUCyBuJ4114&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xESOBAfIZ8xQ9ApXt4uTe8po/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;我的程序媛同事们，节日快乐~&amp;#10;&amp;#10;#不被定义的她 #程序媛 #女性 &amp;#10;&quot; data-nonceid=&quot;6143725764114518706&quot; data-type=&quot;video&quot;/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5ODYwMjI2MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvasvpPfMrktl2xvC9A325p8Qa9dFeEzxZmZ2O1XuFGsVXyQhG9Dia8J8nTXVtzNcHozr0umH3R4iboXg/0?wx_fmt=png&quot; data-nickname=&quot;腾讯技术工程&quot; data-alias=&quot;Tencent_TEG&quot; data-signature=&quot;腾讯技术官方号。腾讯技术创新、前沿领域发布解读平台。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>72ad1c4305e8bf52ede66411007da708</guid>
<title>详解阿里2022裁员；支持符合条件的地区开展数字人民币试点；微信、抖音、淘宝、微博等头部 App 上线算法关闭键｜开发者头条</title>
<link>https://toutiao.io/k/7d5jfrx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>00d462fa572d2c532afb574bbdcf1b5b</guid>
<title>我又来啦，带大家用python每天白嫖天翼云盘呀~</title>
<link>https://toutiao.io/k/dld0ygh</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;span&gt;这里简单介绍一下实现原理吧。既然要签到和抽奖，当然需要先模拟登录一波天翼网盘啦，这里我们主要还是借助公众号之前开源的模拟登录包&lt;/span&gt;&lt;span&gt;DecryptLogin&lt;/span&gt;&lt;span&gt;，具体而言，代码实现如下：&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; DecryptLogin &lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; login&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;lg = login.Login()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;self.infos_return, self.session = lg.cloud189(username, password, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;mobile&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;不了解这个包的可以参见公众号之前的文章：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NDI1MjkwNA==&amp;amp;mid=2247487571&amp;amp;idx=1&amp;amp;sn=84d335fc97c6ad20891b64208c5d0df6&amp;amp;chksm=fc4c89d4cb3b00c203e64c09875e9f8889d605efe0ffc0610f81c097b127360aaae9c4a52d4e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;模拟登录神器DecryptLogin v0.2.0发布啦，喜欢爬虫的小伙伴有福啦~&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;模拟登录神器DecryptLogin v0.2.0发布啦，喜欢爬虫的小伙伴有福啦~&lt;/a&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;成功模拟登录天翼网盘之后，剩下的事情就简单很多啦，就是实现一下签到和抽奖功能。其中，简单抓包可以发现，签到需要请求的API链接为：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;# 构造url&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;params&lt;/span&gt; = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;rand&#x27;&lt;/span&gt;: str(time.time() * &lt;span class=&quot;code-snippet__number&quot;&gt;1000&lt;/span&gt;),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;clientType&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;TELEANDROID&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;version&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;8.9.0&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;model&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;Mi MIX3&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;url = f&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;https://api.cloud.189.cn/mkt/userSign.action?{parse.urlencode(params)}&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;构造一下请求：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;date = self.cst2gmt(int(float(params[&#x27;rand&#x27;])))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;infos = json.dumps(xmltodict.parse(self.infos_return[&#x27;merge_info&#x27;]))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;infos = json.loads(infos)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;sign = f&#x27;SessionKey={infos[&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;userSession&quot;&lt;/span&gt;][&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;sessionKey&quot;&lt;/span&gt;]}&amp;amp;Operate=GET&amp;amp;RequestURI=/mkt/userSign.action&amp;amp;Date={date}&#x27;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;headers = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &#x27;sessionkey&#x27;: infos[&#x27;userSession&#x27;][&#x27;sessionKey&#x27;],&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &#x27;date&#x27;: date,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &#x27;signature&#x27;: self.getsignhex(sign, infos[&#x27;userSession&#x27;][&#x27;sessionSecret&#x27;]),&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &#x27;user-agent&#x27;: &#x27;Ecloud/8.9.0 (Mi MIX3; ; uc) Android/10&#x27;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &#x27;host&#x27;: parse.urlparse(url).hostname&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;response = self.session.get(url, headers=headers)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;response_json = json.dumps(xmltodict.parse(response.text))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;response_json = json.loads(response_json)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;然后判断一下请求有没有成功并打印对应的信息就可以啦：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;python&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; response_json.get(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;userSignResult&#x27;&lt;/span&gt;, {}).get(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;result&#x27;&lt;/span&gt;) == &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    print(&lt;span class=&quot;code-snippet__string&quot;&gt;f&quot;[INFO]: 签到成功, &lt;span class=&quot;code-snippet__subst&quot;&gt;{response_json[&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;userSignResult&#x27;&lt;/span&gt;][&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;resultTip&#x27;&lt;/span&gt;]}&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    print(&lt;span class=&quot;code-snippet__string&quot;&gt;f&quot;[INFO]: 签到失败, 错误码为&lt;span class=&quot;code-snippet__subst&quot;&gt;{response_json[&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;userSignResult&#x27;&lt;/span&gt;][&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;result&#x27;&lt;/span&gt;]}&lt;/span&gt;, &lt;span class=&quot;code-snippet__subst&quot;&gt;{response_json[&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;userSignResult&#x27;&lt;/span&gt;][&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;resultTip&#x27;&lt;/span&gt;]}&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;自动抽奖也差不多，实现的代码如下：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;python&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;&#x27;&#x27;自动抽奖&#x27;&#x27;&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;draw&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    print(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;[INFO]: 开始自动抽奖...&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    url = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;https://m.cloud.189.cn/zhuanti/2016/sign/index.jsp?albumBackupOpened=0&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    infos = json.dumps(xmltodict.parse(self.infos_return[&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;merge_info&#x27;&lt;/span&gt;]))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    infos = json.loads(infos)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    params = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;sessionKey&#x27;&lt;/span&gt;: infos[&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;userSession&#x27;&lt;/span&gt;][&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;sessionKey&#x27;&lt;/span&gt;],&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;sessionKeyFm&#x27;&lt;/span&gt;: infos[&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;userSession&#x27;&lt;/span&gt;][&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;familySessionKey&#x27;&lt;/span&gt;],&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;appName&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;com.cn21.ecloud&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;redirectUrl&#x27;&lt;/span&gt;: url,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    merge_url = &lt;span class=&quot;code-snippet__string&quot;&gt;f&#x27;https://m.cloud.189.cn/ssoLoginMerge.action?&lt;span class=&quot;code-snippet__subst&quot;&gt;{parse.urlencode(params)}&lt;/span&gt;&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    headers = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;user-agent&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;Mozilla/5.0 (Linux; Android 10; Mi MIX3 Build/QKQ1.190828.002; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/87.0.4280.66 Mobile Safari/537.36 clientCtaSdkVersion/v3.8.1 deviceSystemVersion/10 deviceSystemType/Android clientPackageName/com.cn21.ecloud clientPackageNameSign/1c71af12beaa24e4d4c9189f3c9ad576&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;x-requested-with&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;com.cn21.ecloud&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;host&#x27;&lt;/span&gt;: parse.urlparse(merge_url).hostname&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    response = self.session.get(merge_url, headers=headers)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    headers = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;user-agent&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;Mozilla/5.0 (Linux; Android 10; Mi MIX3 Build/QKQ1.190828.002; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/87.0.4280.66 Mobile Safari/537.36 clientCtaSdkVersion/v3.8.1 deviceSystemVersion/10 deviceSystemType/Android clientPackageName/com.cn21.ecloud clientPackageNameSign/1c71af12beaa24e4d4c9189f3c9ad576&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;x-requested-with&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;XMLHttpRequest&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;referer&#x27;&lt;/span&gt;: url,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    params = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;activityId&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;ACT_SIGNIN&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;taskId&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;TASK_SIGNIN&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;noCache&#x27;&lt;/span&gt;: str(random.random())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    url = &lt;span class=&quot;code-snippet__string&quot;&gt;f&#x27;https://m.cloud.189.cn/v2/drawPrizeMarketDetails.action?&lt;span class=&quot;code-snippet__subst&quot;&gt;{parse.urlencode(params)}&lt;/span&gt;&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    headers[&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;host&#x27;&lt;/span&gt;] = parse.urlparse(url).hostname&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    response = self.session.get(url, headers=headers)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    response_json = response.json()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;prizeName&#x27;&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; response_json:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        print(&lt;span class=&quot;code-snippet__string&quot;&gt;f&#x27;[INFO]: 签到抽奖成功，奖品名称为&lt;span class=&quot;code-snippet__subst&quot;&gt;{response_json[&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;prizeName&quot;&lt;/span&gt;]}&lt;/span&gt;&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        print(&lt;span class=&quot;code-snippet__string&quot;&gt;f&#x27;[INFO]: 签到抽奖失败, 错误码为&lt;span class=&quot;code-snippet__subst&quot;&gt;{response_json[&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;errorCode&quot;&lt;/span&gt;]}&lt;/span&gt;&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    url = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;https://m.cloud.189.cn/zhuanti/2016/sign/act.jsp?act=10&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    headers[&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;host&#x27;&lt;/span&gt;] = parse.urlparse(url).hostname&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    response = self.session.get(url, headers=headers)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    params = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;activityId&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;ACT_SIGNIN&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;taskId&#x27;&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;TASK_SIGNIN_PHOTOS&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;noCache&#x27;&lt;/span&gt;: str(random.random())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    url = &lt;span class=&quot;code-snippet__string&quot;&gt;f&#x27;https://m.cloud.189.cn/v2/drawPrizeMarketDetails.action?&lt;span class=&quot;code-snippet__subst&quot;&gt;{parse.urlencode(params)}&lt;/span&gt;&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    headers[&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;referer&#x27;&lt;/span&gt;] = &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;https://m.cloud.189.cn/zhuanti/2016/sign/index.jsp?albumBackupOpened=1&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    headers[&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;host&#x27;&lt;/span&gt;] = parse.urlparse(url).hostname&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    response = self.session.get(url, headers=headers)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    response_json = response.json()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;prizeName&#x27;&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; response_json:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        print(&lt;span class=&quot;code-snippet__string&quot;&gt;f&#x27;[INFO]: 相册抽奖成功，奖品名称为&lt;span class=&quot;code-snippet__subst&quot;&gt;{response_json[&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;prizeName&quot;&lt;/span&gt;]}&lt;/span&gt;&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        print(&lt;span class=&quot;code-snippet__string&quot;&gt;f&#x27;[INFO]: 相册抽奖失败, 错误码为&lt;span class=&quot;code-snippet__subst&quot;&gt;{response_json[&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;errorCode&quot;&lt;/span&gt;]}&lt;/span&gt;&#x27;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;ok，大功告成啦，完整源代码详见相关文件。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;写完代码之后，其实可以按照之前的教程白嫖Github的计算资源来每天定时打卡，这里就不再赘述了，放个链接吧：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzU2NDI1MjkwNA==&amp;amp;mid=2247487251&amp;amp;idx=1&amp;amp;sn=a58009573eb957d9624a5cb7bd048063&amp;amp;chksm=fc4c9694cb3b1f82467b2eaee7eb77508f9ec744b26db4b314e51a8c9bd19e512fe458fe3be1&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;带大家一起来白嫖一波Github的免费计算资源呀~&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;带大家一起来白嫖一波Github的免费计算资源呀~&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f2714a6e862ac70abccad2990f481e92</guid>
<title>成为更好的开发者！行动起来！</title>
<link>https://toutiao.io/k/0qqtsd1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;profile_inner&quot;&gt;
                              &lt;strong class=&quot;profile_nickname&quot;&gt;开发者头条&lt;/strong&gt;
                              &lt;img class=&quot;profile_avatar&quot; id=&quot;js_profile_qrcode_img&quot; src=&quot;&quot; alt=&quot;&quot;/&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;Weixin ID&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;kaifazhetoutiao&lt;/span&gt;
                              &lt;/p&gt;

                              &lt;p class=&quot;profile_meta&quot;&gt;
                              &lt;label class=&quot;profile_meta_label&quot;&gt;About Feature&lt;/label&gt;
                              &lt;span class=&quot;profile_meta_value&quot;&gt;程序员分享平台 | 官方应用下载地址：http://toutiao.io/download&lt;/span&gt;
                              &lt;/p&gt;
                              
                          &lt;/div&gt;
                          &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>