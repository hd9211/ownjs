<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>41d356b19740a0dfcd82632bd28efceb</guid>
<title>[推荐] Redis 教程：Redis 知识体系详解</title>
<link>https://toutiao.io/k/av396i0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;theme-default-content content__default&quot;&gt;&lt;h1 id=&quot;♥redis教程---redis知识体系详解♥&quot;&gt;&lt;a href=&quot;#♥redis教程---redis知识体系详解♥&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; ♥Redis教程 - Redis知识体系详解♥&lt;/h1&gt; &lt;blockquote&gt;&lt;p&gt;本系列主要对Redis知识体系进行详解。@pdai&lt;/p&gt;&lt;/blockquote&gt;  &lt;h2 id=&quot;知识体系&quot;&gt;&lt;a href=&quot;#知识体系&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; 知识体系&lt;/h2&gt; &lt;p&gt;&lt;em&gt;知识体系&lt;/em&gt;&lt;/p&gt; &lt;p&gt;&lt;img alt=&quot;&quot; data-src=&quot;/_images/db/redis/db-redis-overview.png&quot; loading=&quot;lazy&quot; class=&quot;lazy&quot;/&gt;&lt;/p&gt; &lt;p&gt;&lt;em&gt;相关文章&lt;/em&gt;&lt;/p&gt; &lt;blockquote&gt;&lt;p&gt;首先，我们通过学习Redis的概念基础，了解它适用的场景。&lt;/p&gt;&lt;/blockquote&gt; &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-introduce.html&quot;&gt;Redis入门 - Redis概念和基础&lt;/a&gt; &lt;ul&gt;&lt;li&gt;Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt; &lt;blockquote&gt;&lt;p&gt;其次，这些适用场景都是基于Redis支持的数据类型的，所以我们需要学习它支持的数据类型；同时在redis优化中还需要对底层数据结构了解，所以也需要了解一些底层数据结构的设计和实现。&lt;/p&gt;&lt;/blockquote&gt; &lt;p&gt;&lt;img alt=&quot;&quot; data-src=&quot;/_images/db/redis/db-redis-object-2-2.png&quot; loading=&quot;lazy&quot; class=&quot;lazy&quot;/&gt;&lt;/p&gt;  &lt;blockquote&gt;&lt;p&gt;再者，需要学习Redis支持的核心功能，包括持久化，消息，事务，高可用；高可用方面包括，主从，哨兵等；高可拓展方面，比如 分片机制等。&lt;/p&gt;&lt;/blockquote&gt; &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-rdb-aof.html&quot;&gt;Redis进阶 - 持久化：RDB和AOF机制详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;为了防止数据丢失以及服务重启时能够恢复数据，Redis支持数据的持久化，主要分为两种方式，分别是RDB和AOF; 当然实际场景下还会使用这两种的混合模式。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-pub-sub.html&quot;&gt;Redis进阶 - 消息传递：发布订阅模式详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-event.html&quot;&gt;Redis进阶 - 事件：Redis事件机制详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;Redis 采用事件驱动机制来处理大量的网络IO。它并没有使用 libevent 或者 libev 这样的成熟开源方案，而是自己实现一个非常简洁的事件驱动库 ae_event。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-trans.html&quot;&gt;Redis进阶 - 事务：Redis事务详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-copy.html&quot;&gt;Redis进阶 - 高可用：主从复制详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;我们知道要避免单点故障，即保证高可用，便需要冗余（副本）方式提供集群服务。而Redis 提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式。本文主要阐述Redis的主从复制。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-sentinel.html&quot;&gt;Redis进阶 - 高可用：哨兵机制（Redis Sentinel）详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;在上文主从复制的基础上，如果注节点出现故障该怎么办呢？ 在 Redis 主从集群中，哨兵机制是实现主从库自动切换的关键机制，它有效地解决了主从复制模式下故障转移的问题。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/md/db/nosql-redis/db-redis-x-cluster.html&quot;&gt;Redis进阶 - 高可拓展：分片技术（Redis Cluster）详解&lt;/a&gt; &lt;ul&gt;&lt;li&gt;前面两篇文章，主从复制和哨兵机制保障了高可用，就读写分离而言虽然slave节点来扩展主从的读并发能力，但是写能力和存储能力是无法进行扩展的，就只能是master节点能够承载的上限。如果面对海量数据那么必然需要构建master（主节点分片)之间的集群，同时必然需要吸收高可用（主从复制和哨兵机制）能力，即每个master分片节点还需要有slave节点，这是分布式系统中典型的纵向扩展（集群的分片技术）的体现；所以在Redis 3.0版本中对应的设计就是Redis Cluster。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt; &lt;blockquote&gt;&lt;p&gt;最后，就是具体的实践以及实践中遇到的问题和解决方法了：在不同版本中有不同特性，所以还需要了解版本；以及性能优化，大厂实践等。&lt;/p&gt;&lt;/blockquote&gt;  &lt;h2 id=&quot;学习资料&quot;&gt;&lt;a href=&quot;#学习资料&quot; class=&quot;header-anchor&quot;&gt;¶&lt;/a&gt; 学习资料&lt;/h2&gt; &lt;ul&gt;&lt;li&gt;&lt;p&gt;Redis官网:http://redis.io/&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;Redis官方文档:http://redis.io/documentation&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;Redis教程:http://www.w3cschool.cn/redis/redis-intro.html&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;Redis下载:http://redis.io/download&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;redis英文文档 https://redis.io/topics/data-types&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;redis中文文档 http://www.redis.cn/documentation.html&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;《redis设计与实现 3.0版本》 http://redisbook.com/index.html&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;redis菜鸟教程 https://www.runoob.com/redis/redis-tutorial.html&lt;/p&gt;&lt;/li&gt; &lt;li&gt;&lt;p&gt;redis源码解读 3.2.8版本 https://blog.csdn.net/men_wen/article/details/75668345&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt; &lt;p&gt;除此之外，我还推荐你看下 极客时间 《Redis核心技术与实战》（作者：蒋德钧）的相关内容，它是我看到的为数不多的含有实战经验比较多的专栏，部分文章中图片也来源于这个系列。&lt;/p&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1c0499b61f2bd4240156fbb7919d2ffe</guid>
<title>[推荐] 带你深入理解 Java 内存模型理论</title>
<link>https://toutiao.io/k/0ic2o68</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3529480&quot; data-style-type=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3356876&quot; data-style-type=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.18170426065162906&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;798&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qMicvibdvl7p0KEd3bHYcm99nBiclZbia548oyvliaq8PrrmrcyuT3QS3urMcfaXDPEumnHP9KYcMV3Fad5Pepzic81Q/640?wx_fmt=jpeg&quot;/&gt;&lt;img data-ratio=&quot;0.23416666666666666&quot; data-type=&quot;gif&quot; data-w=&quot;1200&quot; class=&quot;__bg_gif&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/qMicvibdvl7p0shmw7MKGyutc63KZyibndlEzXkYJiaS1fUicrkRRKdOhPHMOic2dB36fnECUbaN0h6EJNcYU0HuY49g/640?wx_fmt=gif&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tools=&quot;新媒体排版&quot; data-id=&quot;3335002&quot; data-style-type=&quot;&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;本文字数：&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;5036 &lt;/strong&gt;&lt;/span&gt;字&lt;/p&gt;&lt;p&gt;预计阅读时间：&lt;span&gt;&lt;strong mpa-from-tpl=&quot;t&quot;&gt;30&lt;/strong&gt;&lt;/span&gt;分钟&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Java并发是一个很大的主题，包含很多方面的知识。&lt;/span&gt;&lt;span&gt;本文从内存模型的角度分析，从概念理论上尽量精确理解Java内存模型，及其对并发的影响。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;h3&gt;文章目录&lt;/h3&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;一. 引入&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;二. 内存模型的理解&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;1. 什么叫内存模型&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;2. 顺序一致性模型&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;3. happens-before 模型&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;4. Java内存模型 及 “因果关系”（Causality）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;三. 提炼理念&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;1. 技术层次观念与思想方法的互通&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;2. executed 和 exhibit 的区别，及双向视图&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;一. 引入&lt;/h2&gt;&lt;h3&gt;1. 并发的概念&lt;/h3&gt;&lt;p&gt;&lt;span&gt;并发听起来是一个计算机术语，但计算机技术毕竟才发展百年，起初理念一定是来源于生活的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如在打饭窗口排队打饭，顾客排队的时候是空闲的，而打饭阿姨是忙碌的。没有并发的情况下，一个阿姨对应所有顾客，效率很慢。如果增加窗口同时进行，会成倍提高效率。当然，严格来讲这个情景可以叫“并行”，当每个菜盆在同一时间只有一个勺子可以打饭的时候才叫做“并发”。其中便包含了并发与并行的区别。由此可见，并发最原始的动力就是：充分利用长板，补齐短板，把空闲的东西利用起来，提高效率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;特别的，在计算机技术领域。从冯·诺依曼提出计算机的五大组成部分开始，后来进一步抽象到主要由CPU、内存和I/O组成运转的体系，一直存在的问题就是速度差异巨大且一直存在，表现为 CPU 的速度 &amp;gt; 内存的速度 &amp;gt; I/O 设备的速度。为了充分开发利用计算机的潜能，体系结构、操作系统、编译程序等都做出了改变，比如CPU多核、流水线技术、进程线程概念、数据库中的事务处理等，足见这是一个普适的理念。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有得必有失。在成倍提高效率的同时，并发也引入了新的问题。主要包括：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;缓存导致的可见性问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;切换执行导致的原子性问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;重排序导致的有序性问题&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;这三个问题在很多文章中都有介绍，在此就不多赘述。为了解决这些问题，就引出了本文重点内存模型的概念。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;二. 内存模型的理解&lt;/h2&gt;&lt;h3&gt;1. 什么叫内存模型&lt;/h3&gt;&lt;section&gt;&lt;span&gt;还是先要明晰概念。内存模型是什么，用途是什么。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们已经知道，没有并发的程序执行起来效率是极慢的。于是在计算机技术的硬件软件各个层次对程序执行进行了大量的优化，比如缓存、并发、重排序等，但是这样会出现类似上一节中提到的安全性问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;“究其原因在于“共享内存”的方式，即线程之间通过读写内存中的公共状态来隐式进行通信。但是如果没有一个执行顺序的规则，这些公共状态就会被以随机或者无法预知的顺序规则进行修改，程序执行结果也就无法保证。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;内存模型就是应用于此的一种规则，一种标准，用来保证程序的最终执行结果是符合代码期望逻辑的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;引用 JSR-133 中，笔者觉得最经典的一句话：&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;“These semantics do not describe how a multithreaded program &lt;/span&gt;&lt;span&gt;&lt;strong&gt;should be executed&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;. Rather, they describe the behaviors that multithreaded programs are &lt;strong&gt;allowed to exhibit&lt;/strong&gt;.”&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;顺便来提一下JSR-133是什么。JCP（Java Community Process Program）是管理 java 技术的官方组织，JCP制定的技术规范称为JSR（Java Specification Requests），可以翻译为Java规范提案。在 JDK5.0 中，加入了JSR-133的内容，JSR-133的全称是《Java Memory Model and Thread Specification》。这个提案更正了 volatile 和 final 语义的问题，也明确定义了Java内存模型的概念和规范，是直到现在Java并发编程的准则。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;原文中，should be executed，意思是应该如何执行，是实现层面的东西。而 be allowed to exhibit，意思是允许如何展示。由此可见，内存模型并不管底层是如何具体执行的，只是向上层形成了一个“视图”。在接下来的学习中可以慢慢体会这句原文。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;2. 顺序一致性模型&lt;/h3&gt;&lt;section&gt;&lt;span&gt;要理解Java内存模型，首先要理解顺序一致性模型：&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span&gt;在顺序一致性模型里，所有动作以全序（程序顺序）的顺序发生，与程序顺序一致；而且，每个对变量 v 的读操作 r 都将看到写操作 w 写入 v 的值，只要符合：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;执行顺序上 w 在 r 之前&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;执行顺序上不存在这样一个 w’ ，w 在 w’ 之前且 w’ 在 r 之前。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;span&gt;以上是顺序一致性模型的定义，但是比较枯燥难懂。形象化地类比一下就像这张图：&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;img data-ratio=&quot;0.2859259259259259&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0eibqKmf1FgaH3M64V7YBVPibDby2W85gUARhzIUrLBuko5YVhzZUhEUCIA3uNqx8I2BC13eazZreg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1350&quot;/&gt;&lt;section&gt;&lt;span&gt;在顺序一致性模型里，所有动作都存在一个全序关系，与程序顺序一致，每辆车都是有编号的，想让他第几个过去必须按照编号排队；每一个动作都是原子的，不存在一辆车分成两半通过的情况，中间也不能插队；每个动作执行后立即对所有线程可见，一个通过之后立马有个大喇叭向后面所有车喊：“XXX已经过去了”。而且拒绝了一切的优化，不管车的大小胖瘦，都不可以并排通过。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;术语表述就是：保证了有序性、原子性和可见性，且拒绝一切优化。由此可见，顺序一致性模型好像回到了最原始的阶段，所以只能是一种理想模型。因为如果实际采用的话，L1  L2 Cache、流水线技术等都将变为非法（硬件工程师几十年的努力就拜拜了）。现实中的处理器和语言都是在顺序一致性模型的基础上，为了执行效率优化，做了不同程度的实现变通。&lt;/span&gt;&lt;/section&gt;&lt;h3&gt;3. happens-before 模型&lt;/h3&gt;&lt;p&gt;&lt;span&gt;happens-before 是我们提及JMM最常讨论的一个词，happens-before 规则在JSR-133中是通过 synchronized-with 边缘来辅助定义的。许多资料上将其总结为6条规则，实际上JSR-133中有更多。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先来说 Synchronizes-With 边缘的规则定义。关于“边缘”这个词，英文原文中就是用的“Synchronizes-With Edges”来表述的，我意会的意思就像如果没有这个边缘，语句的执行是在一个平面上的，是可以来回换且不影响的，但是一旦出现这个边缘，就上了一个台阶，和前一个平面是不能互通的。或者理解成“border”这个词，有点界限的意思。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果存在以下七种情况，就认为存在Synchronizes-With 边缘。而只要存在Synchronizes-With 边缘，就存在happens-before关系。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;“monitor锁定规则”：某个monitor上的解锁动作 synchronizes-with 所有后续在其上的锁定动作；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;“volatile变量规则”：对volatile变量v的写操作 synchronizes-with 所有后续任意线程对v的读操作；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;“线程启动规则”：用于启动一个线程的动作 synchronizes-with 该新启动线程中的第一个动作；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;“线程终止规则”：线程T1的最后一个动作 synchronizes-with 线程T2中任一用于探测T1是否终止的动作；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;“线程中断规则”：如果线程T1中断了线程T2，T1的中断操作 synchronizes-with 任意时刻任何其它线程（包括 T2）用于确定 T2 是否被中断的操作；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;“默认值规则”：为每个变量写默认值（0，false或null）的动作 synchronizes-with 该线程中的第一个动作；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;“对象终结规则”：调用对象的终结方法时，会隐式的读取该对象的引用。从一个对象的构造器末尾到该引用的读取之间存在一个 synchronizes-with 边缘；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;在Synchronizes-With 边缘的基础上，还加入了两条，程序顺序规则和传递性规则，这两条是最基本的。&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;ol start=&quot;8&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;“程序顺序规则”：如果 x 和 y 是 同一个线程中的动作，且在程序顺序上 x 在 y 之前，那么有 x happens-before y；&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;“传递性规则”：happens-before 是传递闭包的。换而言之，如果 x happens-before y，且 y happens-before z，那么可以得到 x happens-before z。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;这9条共同定义了happens-before规则，满足这些的就可以说满足happens-before规则，具有了happens-before关系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果一个动作 happens-before 另一个动作，则第一个对第二个可见，且第一个排在第二个之前。这在JSR-133中是一种非正式语义（Informal Semantics），是易于理解的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;happens-before已经是一种很强的保证了，所以我们经常说，一个操作是happens-before另一个操作的，就说明是可见的、顺序的、原子的。但是很多网上的理解都说happens-before就是Java内存模型的规则，这个当然是错误的。happens-before也是一种模型而已，它离真正的Java内存模型还差那么一点点。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;4. Java内存模型 及 “因果关系”（Causality）&lt;/h3&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;span&gt;终于到了主角。Java内存模型在JSR-133中有详细的定义，截取如下图：&lt;/span&gt;&lt;br/&gt;&lt;img data-ratio=&quot;0.8121178432462479&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0eibqKmf1FgaH3M64V7YBVPMqibSibQjPpLolH9Tf0GM24u7utjwoZy8P19KGYUBfyvp95uyzCWQkhw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1799&quot;/&gt;&lt;section&gt;&lt;br/&gt;&lt;span&gt;其中用了很多符号和公式以及集合知识来表示线程的行为和行为之间的关系，但是太过复杂。确实只有这样他才能称之为一个规范、一个标准，是严密的经得起推敲验证的，有兴趣的读者可以自行研究。当然了，JSR-133也知道大多数人看不懂，给了一些解释，我们已经有了刚才两个模型的知识铺垫，可以迂回地去理解Java内存模型。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Java内存模型和happens-before模型的那“一点点”差距，在于“因果关系”（Causality）。这是大部分博客都没有提过的，也比较绕。原文说的是，“Happens-Before is too Weak”。“因果关系”的表述是：一个写操作不能发生在一个其依赖的读操作之前，因为它涉及写操作是否会触发自身发生的问题。&lt;br/&gt;JSR-133原文目录如下图：&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;img data-ratio=&quot;0.20935672514619882&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0eibqKmf1FgaH3M64V7YBVP36y3T3FPulDtbu7hVVWbLx7at1gLg8ToRib1k1QwdACqJHmnbGqECEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1710&quot;/&gt;&lt;p&gt;&lt;span&gt;举一个JSR -133给出的官方示例，如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5842894969108562&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0eibqKmf1FgaH3M64V7YBVPibN96ubGqbcQibI0JtMOS2qAN6cUrch9TiaVibEbPuhzVdStCPteoKlfVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2266&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;按照我们通常的理解，r1 == r2 == 0 是唯一合法结果。但是&lt;strong&gt;在 happens-before 内存模型下&lt;/strong&gt;，存在执行结果是 r1 == r2 == 1 的可能性，其原理如下图：&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3722627737226277&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0eibqKmf1FgaH3M64V7YBVPhn2Olcv94ptI3rUXicfUt2rHOMew4lfFZpbHOAic6737e0oOWfm6nTGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1644&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;happens-before 内存模型下，这里在执行 r1 = x 的时候，已经看到了 x = 1 的执行结果。我们会感到奇怪，赋值在 if 里，为什么会已经看到了x = 1的写操作结果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为程序这样表现没有违反 synchronizes-with 或 happens-before 边缘，是完全符合happens-before模型规定的，允许每个读操作看到其它线程写的值。读者可能会对上一节第8条程序顺序规则产生疑问，但是上述执行顺序确实已经遵守了单线程中的程序顺序规则。&lt;strong&gt;因为 r1 = x 并没有看到 y = 1 的执行结果，r2 = y 也没有看到 x = 1 的执行结果，这才是单线程的程序顺序规则。&lt;/strong&gt;这个问题笔者当时也纠结了一周，直到读了很多遍原文才明白。r1 = x 读操作 和 x = 1 写操作是两个线程的事情，按照happens-before模型单线程的程序顺序规则是不相互制约的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;顺便一提，这里是解释“标准”或者说“规范”的一个绝佳的例子。还记得那句话吗， should be executed 和 are allowed to exhibit。happens-before 包括JMM都只是一种规范理论，而不去管能不能实现或者怎么样实现（真实情况可能由于多级缓存可能由于重排序也可能先执行再决定是否回滚等，这些都是实现层面的事情）。在此处，由于遵守了 happens-before 规则的约定，所以此顺序的任意读操作可以看到任意写操作的结果，也就看到了x = 1的写操作结果。总的来说，要从一个内存模型而不是内存模型实现的角度去理解它。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;说回JMM，这种执行顺序是 happens-before 允许的，但JMM不允许，也就是上述的因果关系。所以，happens-before 模型可以理解为JMM的真子集，它们的差别就是因果关系（Causality）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因果关系正式的表述是：&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;因果关系解决 什么时候一个顺序靠前的读操作 被允许看到 顺序靠后的写操作的执行结果（在 happens-before 基础上）：&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;具体到我们的代码，什么样的操作算是因果关系呢。其实我们的程序也就三种过程结构，顺序结构、选择结构、循环结构。在其中用到判断因果关系的地方，比如 if else, switch case等，用语义去理解就可以。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如如果感到幸福你就拍拍手，拍手的前提是感到幸福，这就是因果关系，是符合我们正常认知的，不用在写代码的时候刻意在意。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;综上，对JMM的理解总结如下图：&lt;/span&gt;&lt;br/&gt;&lt;img data-ratio=&quot;0.6016771488469602&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0eibqKmf1FgaH3M64V7YBVPVVibLxFnD8TCbas2oTqVVfFexqY6YNUHh6JyzU18wTBBVJ53MGQuSqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;954&quot;/&gt;&lt;br/&gt;&lt;span&gt;我们终于可以比较全面地来理解Java内存模型了。Java内存模型是什么？上图是笔者总结JSR-133之后认为的干货。首先Java内存模型是一种共享内存方式的内存模型，它比起顺序一致性模型这种理想化模型要宽松很多，从编译到底层执行部分各个层次都做了不同程度的优化。和它最贴近的是happens-before内存模型，两者只相差一个因果关系的约束。在因果关系的前提下，只要它满足happens-before，就是JMM允许的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在我们的编程中，尤其要注意上一节所说的 happens-before 的第 1- 7 条规则。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;了解JMM之后，我引用一个网上流传类似的图，看一下JMM在各种内存模型中处于什么样的位置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5470514429109159&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0eibqKmf1FgaH3M64V7YBVPZ88SgIpyMvPmfjd29fp9cqGmibc9gXbF2fJr2QEeFjicrzFDB0kjSVAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;3188&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有两个可以说互斥的指标在约束着内存模型们。一般来说，易编程性越好，就是要注意的并发的坑越少，这个内存模型的执行性能就会越差。最极端的例子是顺序一致性模型，完全不用考虑这个变量会不会同时被两个线程操作之类的问题。当然我们不可能用这样的理想模型，因为我们对于执行性能是有很大要求的。菱形的是语言级别的内存模型，JMM相比C的内存模型会更严格一些，执行性能也会差一些。虽然语言级别的内存模型已经做了一些优化，但是处理器级别的内存模型还是会秒杀他们，对于用户不能感知的优化会更多。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;三. 提炼理念&lt;/h2&gt;&lt;h3&gt;1. 技术层次观念与思想方法的互通&lt;/h3&gt;&lt;p&gt;&lt;span&gt;类似并发这样的思想在计算机技术的每一个层次都会用到。比如在CPU层为了并发用到了多级缓存，会产生不一致的问题，MESI协议在这一层解决了这个问题，给了CPU使用者一个统一的视图。但是在上层，如操作系统、汇编语言、高级语言等层次也会用到缓存等提高效率，这时候MESI不能解决这些层次的问题，需要该层次对应的解决办法，如高级语言层次的Java内存模型。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;2. executed 和 exhibit 的区别，及双向视图&lt;/h3&gt;&lt;p&gt;&lt;span&gt;内存模型对于开发者强调的概念是如何&lt;strong&gt;表现&lt;/strong&gt;，就像一个黑盒展现给人们的输入输出视图。JMM协调了底层硬件和上层开发者之间相反的需求，形象表示如下图：&lt;/span&gt;&lt;br/&gt;&lt;img data-ratio=&quot;0.33560864618885095&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p0eibqKmf1FgaH3M64V7YBVPT3Etzicz78WkIjKYcPpKM6Q8o67xOQBDia4eInibx2ApHghdJib9lyYic9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1758&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;JMM做出了双向承诺：&lt;/span&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从Java开发者的视角，希望内存模型易于理解、易于编程，所以希望基于一个强内存模型来编写代码。JMM向开发者提供保证，只要程序是正确同步的（满足A happens-before B 和因果关系），那么A的操作结果一定对B可见，且A的执行顺序排在B之前。虽然这么说是骗我们的，但是我们心甘情愿被骗了。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;从编译器和处理器的视角，希望内存模型对其优化的束缚越小越好，这样就可以尽可能提高性能，所以希望实现一个弱内存模型。JMM遵循一个基本原则：只要不改变程序的执行结果（单线程程序和&lt;strong&gt;正确同步的&lt;/strong&gt;多线程程序），编译器和处理器可以随意优化。这里的“正确同步”就是指如volatile、synchronized等规定的具体规则，不多赘述。&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;本文主要从内存模型理论的角度，分析了内存模型的概念和侧重点，运用逼近的方法理解Java内存模型，尤其深入了“因果关系”的概念，帮助大家了解 happens-before 模型和JMM的区别。同时浅析了JMM中涉及的技术理念。具体实践方面有更多的问题需要学习探究，如volatile、synchronized底层原理与应用方法、并发相关JUC类库等，可以继续深入研究。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;br mpa-from-tpl=&quot;t&quot;/&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot; mpa-from-tpl=&quot;t&quot;&gt;&lt;img class=&quot;rich_pages __bg_gif&quot; data-ratio=&quot;0.2777777777777778&quot; data-s=&quot;300,640&quot; data-type=&quot;gif&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/qMicvibdvl7p15cy8dCBsQ3qGTK2dseYLWrVLkN9aFvGpjpnjDGxz1LCUaNpQvHGPvkzokhibu8B66J5uOhiaHFslg/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;a class=&quot;weapp_image_link js_weapp_entry&quot; data-miniprogram-appid=&quot;wx17eb4d48e11ce306&quot; data-miniprogram-path=&quot;interbar/pages/topic?id=179189&amp;amp;type=2&quot; data-miniprogram-nickname=&quot;小互动助手&quot; href=&quot;&quot; data-miniprogram-type=&quot;image&quot; data-miniprogram-servicetype=&quot;&quot;&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.64&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qMicvibdvl7p3iaGw410lUuf12ZXwtXKiaMyATYBpLfibvBvpmicsegZnX7JUe5T3eEzrOkbHibicd3em145Y5soC9Z0Lg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.41875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qMicvibdvl7p3emlMBeH8cjIR9M42WeicHrLqtvW5kllgTtwrO1eCibhhfYn20Lkiagb0xibNBk6JibBaNiazVDicQicDK4w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8f464e7790c69c48a2d489e52a9472ca</guid>
<title>[推荐] 下一代微服务 Service Mesh 原理及实践</title>
<link>https://toutiao.io/k/hxrinvv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;微服务架构痛点&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;业务关注服务之间通信&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;会导致业务迭代速度变慢&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;微服务架构1.0&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.643&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmiajLDjc9MPXicibQiaAOrKpKhktXkwo2z5AvyvtbGM2G3zPx7EM1rAZHIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;网关层1个、业务逻辑层多个、数据访问层多个、DB/Cache多个，注册中心、配置中心&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;微服务2.0架构-服务网格&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3867735470941884&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm04yhHth8b2E02ib2USEvHaksgazdibxTMQGWicTTrqD0cJOpTt1nDl4JA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1996&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基础设施升级困难&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;影响基础设施团队的交付能力和交付速度&lt;br/&gt;因为应用程序通过jar包方式引入通信组件&lt;br/&gt;通信组件升级需要应用程序配合jar包版本升级&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.35850956696878145&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmuVcXnTB12CTiaZVfCDZD4XLTEMxuT7JD9dsQsD6yJdN6kH40neXsRpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1986&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;多编程语言之间&#x27;通信&#x27;问题&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;业务每种语言一套基础设施 成本大&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5065065065065065&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm0nkAfvnwft5wCfvspwQt3ia7UKuvn1duiatSHBlazZEfeb7yV48BwNjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1998&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;微服务架构演进&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6202404809619239&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm82tn8Emsn1QQJ8Gd8oVkUOgNrjGbk5Qo8eibwrgticTdSEsUjF7XP53A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1996&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务网格定义&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1494949494949495&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmdp8dbUuibwWlMgXtcKZMYHfjoGxouD6aP5llbqrpE6d5Ph50Vo4MOrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1980&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务网格架构&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3587939698492462&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm7ldtRY15MtRTHt4CFvCK0B7hlXA1NwmU6rsPIDRLmw4y7AxXl6av9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1990&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;带来的问题-链路会变长&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;性能里面的RT 平均响应延迟会变高&lt;br/&gt;但本机之间即应用程序放到本机的sidecar损耗不会超过1毫秒&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;开源框架&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;最早版本linkerd&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5393145161290323&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmhqnkic7NVOkx4vic78f0T6Bb5sQCA0OdszPgw7ohciaEuHbPrjke1Q6bg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1984&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;应用程序和sidecar之间通讯用tcp或http1.1以上都可以；两者需要保持长连接&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;istio&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5272177419354839&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmV5BVAcx02mtLnoX8k72PeIgfZ2fy57ybnMcrh18FCtchUETXwkNPqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1984&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;控制中心&lt;br/&gt;1、控制proxy之间通讯&lt;br/&gt;2、负载均衡&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;数据收集服务：&lt;br/&gt;&lt;br/&gt;proxy之间通讯完之后 要上报一些mertics信息 （耗时、请求次数）&lt;br/&gt;全部同步上报&lt;br/&gt;集中式 不靠谱&lt;br/&gt;它的性能影响proxy本身的性能&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;做鉴权安全相关的&lt;br/&gt;proxy之间权限鉴权比如TLS、SSL&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;sofa mesh&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;蚂蚁金服开源&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;架构&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5371485943775101&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmjb27vgyKDnVKosFmXPicLTPtNPaV3PeVibd8PCFnj6VRrdQOlTQhib0uw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1992&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、将istio中的proxy重写&lt;br/&gt;isotio proxy是用c++写的&lt;br/&gt;sofa用go重写&lt;br/&gt;2、istio数据收集节点是集中式的 sofa是分布式的即每个proxy中都有一个mixer&lt;br/&gt;3、目前还没有公司大规模在用 社区不活跃 建议使用istio&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;新浪weibo mesh&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5542046605876393&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm2AcJ10hv8sSMFHW5pnNv802fibw4icNZfxAkIlpdK3h0lh5IxypAqxGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1974&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务网格做什么&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5557809330628803&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmfqEgE9Iyuic9SDnQGfJF5lU2C32bibIZTfuB65QWzXxFAicbSdPL9xbmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1972&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;如何选型&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0440456769983686&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmoCLMeFcSWr3p7LHdyDm1sZbb56h6HF5y3u4oLH6RZeIrfVwCLWbmGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1226&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、业务升级代价太高 要让业务的升级成本降低到0 要兼容所有rpc用法 所以自研&lt;br/&gt;2、期望的是业务方只需要将rpc jar包换成这个rpc mesh jar包就行了&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;自研思路&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6939655172413793&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmbQfriaJyu4Rc3C2ibSQicXoEww4Ple3YtpZ12M5c4MIQtQDc3akNFH2mA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1856&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、要兼容传统(物理机、虚拟机)和云&lt;br/&gt;2、控制中心包括服务管理平台和数据收集中心&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;架构设计&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.624750499001996&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm6YibfraG2mpo9wpNsAs4fQVaxH903whNVe2ssxQUYIAbkiaamplfmqBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2004&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、数据收集中心：&lt;br/&gt;a、Metric:收集耗时、响应情况&lt;br/&gt;b、Trace:分布式请求跟踪系统APM&lt;br/&gt;c、Alarm：报警功能&lt;br/&gt;2、Protocol&lt;br/&gt;a、RPC:兼容老的RPC协议&lt;br/&gt;b、mesh包括通讯协议(http1.1和2.0)和数据协议(protobuff)&lt;br/&gt;&lt;br/&gt;（注：http1.0不支持 因为是短连接;http1.1和http2.0支持keep alive长连接;tpc是长连接;连接还在 server短可以直接推送消息给client）&lt;br/&gt;&lt;br/&gt;2、sidecar之间的健康检查没有通过注册中心而是本身&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总体流程&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5563380281690141&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmrSJdXxcYt152vciaR2Ob4vQiagxHDFXu7AK2qTtD6qbiadr6oXczw4Y3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1988&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;用户发起一个熔断服务B的指令&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6687179487179488&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm2TJRQWtdicfY7JJaRtb3QRUad370WicLSQK8RDpLUWLb53ialyPKNqRQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1950&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、服务管理平台、控制中心、数据收集中心都是现成的服务（之前文章介绍过）那么自研Service Mesh只需要实现proxy就可以了&lt;br/&gt;2、之前Service和Proxy是一个进程&lt;br/&gt;现在需要修改成2个独立的进程即可&lt;br/&gt;3、将二者放到同一个pod中&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;如果sidecar挂了对整体是否有影响?&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;没有影响。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4915514592933948&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmha1K9PrBecoN7mhbfYdUAa1bledkmlrEMYdwwf9lWovsiaYndOL5I9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1302&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sidecar挂掉 pod如何处理？&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;如果sidecar挂掉了 就会被监控到 直接把当前pod杀死就行了 k8s会自动重启一个pod&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;2个应用程序放在同一个物理机上架构怎样？&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5741758241758241&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmVVtyS2E1ZDIlJRdTiceHsjug11thSR3uOZQtjtbuzwg9uPqM5wn3ldw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;728&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;漂移&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、日志漂移&lt;br/&gt;&lt;br/&gt;服务器1上有服务1生成日志1&lt;br/&gt;如果服务器1上面的服务1挂了&lt;br/&gt;在服务器2上启动服务2生成日志2 &lt;br/&gt;如果日志1和日志2有强依赖关系 &lt;br/&gt;那么必须得在服务器1上启动服务1继续在日志1的基础上生成日志&lt;br/&gt;&lt;br/&gt;2、重试漂移&lt;br/&gt;pod如果挂了 再次重启 那么ip就会改变&lt;br/&gt;重试漂移到云上任何节点都没有关系&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;完整流程图&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;这个完整的流程图涵盖了&lt;br/&gt;DNS、CDN、Nginx、FastDFS（或Ceph）、&lt;br/&gt;LVS、ServiceMash、数据收集中心、&lt;br/&gt;注册中心、控制中心、网关、业务逻辑层、&lt;br/&gt;数据访问层、存储层等数据交互过程&lt;br/&gt;&lt;br/&gt;价值不菲 想要的话 &lt;br/&gt;可以添加我微信15900411193&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;调用链路&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3782696177062374&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmgLOSWZMwhkiaN5VeySCQn6QUbjIibuHr4MOWQGibSzNlhfuqibGBpyUHCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1988&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、做协议解析的目的是兼容老的协议&lt;br/&gt;客户端发出请求后 在客户端service和服务方service要做协议解析&lt;br/&gt;如果都是mesh协议 是不需要协议解析的、协议封装也不需要&lt;br/&gt;2、客户端一定要做序列化、反序列化 这和通讯没啥关系 就是一个数据包&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;调用方时序图&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.1094017094017095&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmo2ZqydDFr5mLALib7TFtOxoFyrW4put3x8MzSwP5TpsW6bgLplp3umw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1170&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务方时序图&lt;br/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.4110671936758894&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmA6dmticzO1uAO4jXEy5NC7T1wPfmuNmr99yWrOibPd2ic5iaXDKwB1E8xQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1012&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;缓存管理 多个Map:&lt;br/&gt;服务方提供哪些函数调用 通过扫描jar包 反射机制 获取服务提供的类名和方法名&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;协议设计&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;数据协议&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、Protocol Buffer&lt;br/&gt;2、分割符、版本号、Mesh消息构成&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.19497487437185929&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmk1YhLJzQ3xd5E9GbDmX1anKKgIqD6tuiaNG4EQIV52TrWIHF4yXApEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1990&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、一次传输协议中有版本号 &lt;br/&gt;比如 版本号1表示rpc协议 &lt;br/&gt;版本号2表示mesh协议&lt;br/&gt;通过版本号可以区分兼容老协议还是新协议&lt;br/&gt;2、多个数据包之间通过头和尾分割符分开&lt;br/&gt;3、分割符占5个字节&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Mesh通讯协议&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、TCP长连接&lt;br/&gt;2、Http1.1或2.0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;混合云部署&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、调用方&lt;br/&gt;a、SideCar+Service(Mesh)&lt;br/&gt;b、Service(RPC)&lt;br/&gt;2、服务方&lt;br/&gt;a、SideCar+Service(Mesh)&lt;br/&gt;b、Service(RPC)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;访问流程&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3229689067201605&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm20ht2oGM3KHs0CDYics7JXYjRJrPIEYplfbpOYS7zhQ9tgAIXzD1kFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1994&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、在服务启动的时候 mesh服务或普通的RPC服务都会去注册中心注册 此时就知道了该节点的服务类型&lt;br/&gt;2、调用方下拉服务信息 也就知道了提供方服务类型 然后选择不同的协议去调用&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小细节&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、熔断放在mesh里面做 不需要业务方参与&lt;br/&gt;2、下游重试次数是一样的 是服务粒度 非接口粒度&lt;br/&gt;3、proxy(mesh)之间做健康检测 是分布式的 一旦发现自己的上游或下游出现了问题 就更新本地的路由表&lt;br/&gt;4、负载均衡算法:Random、RR、Hash(主要用一致性&lt;span&gt;hash&lt;/span&gt;来做)&lt;br/&gt;（RR：(循环负载)&lt;br/&gt;第一次请求路由到第一个节点，&lt;br/&gt;第二次请求路由到第二个节点，&lt;br/&gt;第三次请求路由到第三个节点，&lt;br/&gt;第四次请求路由到第一个节点&lt;br/&gt;....）&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;架构未来&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;2平台1中心1趋势&lt;br/&gt;&lt;br/&gt;service mesh平台与业务解耦&lt;br/&gt;容器云弹性平台&lt;br/&gt;服务治理平台(控制中心、注册中心、数据收集中心)&lt;br/&gt;人工智能(AI)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务管理平台的调用关系-数据收集存储方法&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务方-调用方角度&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4020100502512563&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmnp3gibme5rHX7cQxzrJojyic7S72CvWH0Vr24WpDC8RGicKCuQYm2ogaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1990&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;服务方:1分钟500万条记录&lt;br/&gt;调用方:50万&lt;br/&gt;共550万&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;存储方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;方案1&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5426278836509528&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm0a7lakm422lTyImtA59Vo4GP3nsFjib63vAQQq6uuheS5AhqicIbW6rQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1994&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;方案二&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;重复数据提取出来作为元数据&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.46598984771573604&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm1ficWMZOiaX1GReepHV0qKPibWuE9zpYfhicnJ1a3EhXurnibZ7iaG6jRwWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1970&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;方案三&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;实际调用流量仅为方案1的1/10&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.295959595959596&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmMekAzNGwEOiarZTiakpzeibcXlV36Cen0DhAcna6ictLUKddPVBeE4iaVfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1980&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;、&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>c7848135d6361ed5f737b8f82b2fc593</guid>
<title>[推荐] [译] 新老手必备的 34 种 JavaScript 简写优化技术</title>
<link>https://toutiao.io/k/jdslwhk</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;原文：https://javascript.plainenglish.io/34-javascript-optimization-techniques-to-know-in-2021-d561afdf73c3&lt;br/&gt;作者：Atit&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开发者的生活总是在学习新的东西，跟上变化不应该比现在更难，我的动机是介绍所有JavaScript的最佳实践，比如简写功能，作为一个前端开发者，我们必须知道，让我们的生活在2021年变得更轻松。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可能做了很长时间的JavaScript开发，但有时你可能没有更新最新的特性，这些特性可以解决你的问题，而不需要做或编写一些额外的代码。这些技术可以帮助您编写干净和优化的JavaScript代码。此外，这些主题可以帮助你为2021年的JavaScript面试做准备。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.如果有多个条件&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以在数组中存储多个值，并且可以使用数组 &lt;code&gt;include&lt;/code&gt; 方法。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (x === &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt; || x === &lt;span&gt;&#x27;def&#x27;&lt;/span&gt; || x === &lt;span&gt;&#x27;ghi&#x27;&lt;/span&gt; || x ===&lt;span&gt;&#x27;jkl&#x27;&lt;/span&gt;) {&lt;br/&gt;  &lt;span&gt;//logic&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; ([&lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;def&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;ghi&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;jkl&#x27;&lt;/span&gt;].includes(x)) {&lt;br/&gt;  &lt;span&gt;//logic&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.如果为真…否则简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这对于我们有 &lt;code&gt;if-else&lt;/code&gt; 条件，里面不包含更大的逻辑时，是一个较大的捷径。我们可以简单的使用三元运算符来实现这个简写。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test: boolean;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (x &amp;gt; &lt;span&gt;100&lt;/span&gt;) {&lt;br/&gt;  test = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  test = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test = (x &amp;gt; &lt;span&gt;10&lt;/span&gt;) ? &lt;span&gt;true&lt;/span&gt; : &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;//or we can use directly&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test = x &amp;gt; &lt;span&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(test);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们有嵌套条件时，我们可以采用这种方式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; x = &lt;span&gt;300&lt;/span&gt;,&lt;br/&gt;test2 = (x &amp;gt; &lt;span&gt;100&lt;/span&gt;) ? &lt;span&gt;&#x27;greater 100&#x27;&lt;/span&gt; : (x &amp;lt; &lt;span&gt;50&lt;/span&gt;) ? &lt;span&gt;&#x27;less 50&#x27;&lt;/span&gt; : &lt;span&gt;&#x27;between 50 and 100&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(test2); &lt;span&gt;// &quot;greater than 100&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.声明变量&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们要声明两个具有共同值或共同类型的变量时，可以使用此简写形式。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test1;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test2 = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test1, test2 = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.Null, Undefined，空检查&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们创建新的变量时，有时我们想检查我们引用的变量的值是否为空或undefined。JavaScript确实有一个非常好的简写工具来实现这些功能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (test1 !== &lt;span&gt;null&lt;/span&gt; || test1 !== &lt;span&gt;undefined&lt;/span&gt; || test1 !== &lt;span&gt;&#x27;&#x27;&lt;/span&gt;) {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; test2 = test1;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test2 = test1 || &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.null值检查和分配默认值&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; test1 = &lt;span&gt;null&lt;/span&gt;,&lt;br/&gt;    test2 = test1 || &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;null check&quot;&lt;/span&gt;, test2); &lt;span&gt;// output will be &quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.undefined值检查和分配默认值&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; test1 = &lt;span&gt;undefined&lt;/span&gt;,&lt;br/&gt;    test2 = test1 || &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&quot;undefined check&quot;&lt;/span&gt;, test2); &lt;span&gt;// output will be &quot;&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;正常值检查&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; test1 = &lt;span&gt;&#x27;test&#x27;&lt;/span&gt;,&lt;br/&gt;    test2 = test1 || &lt;span&gt;&#x27;&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(test2); &lt;span&gt;// output: &#x27;test&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.将值分配给多个变量&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们处理多个变量并希望将不同的值分配给不同的变量时，此简写技术非常有用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test1, test2, test3;&lt;br/&gt;test1 = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;test2 = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;test3 = &lt;span&gt;3&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; [test1, test2, test3] = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;8.赋值运算符简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在编程中处理很多算术运算符，这是将运算符分配给JavaScript变量的有用技术之一。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;test1 = test1 + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;test2 = test2 - &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;test3 = test3 * &lt;span&gt;20&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;test1++;&lt;br/&gt;test2--;&lt;br/&gt;test3 *= &lt;span&gt;20&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;9.如果存在简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是我们大家都在使用的常用简写之一，但仍然值得一提。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (test1 === &lt;span&gt;true&lt;/span&gt;) or &lt;span&gt;if&lt;/span&gt; (test1 !== &lt;span&gt;&quot;&quot;&lt;/span&gt;) or &lt;span&gt;if&lt;/span&gt; (test1 !== &lt;span&gt;null&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand //it will check empty string,null and undefined too&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (test1)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：如果test1有任何值，它将在if循环后进入逻辑，该运算符主要用于 &lt;code&gt;null&lt;/code&gt; 或 &lt;code&gt;undefined&lt;/code&gt; 的检查。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;10.多个条件的AND（&amp;amp;&amp;amp;）运算符&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果仅在变量为 &lt;code&gt;true&lt;/code&gt; 的情况下才调用函数，则可以使用 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 运算符。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (test1) {&lt;br/&gt; callMethod(); &lt;br/&gt;} &lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;test1 &amp;amp;&amp;amp; callMethod();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;11.foreach循环简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是迭代的常用简写技术之一。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; testData.length; i++)&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; testData) or  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i &lt;span&gt;of&lt;/span&gt; testData)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每个变量的数组&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;testData&lt;/span&gt;(&lt;span&gt;element, index, array&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;test[&#x27;&lt;/span&gt; + index + &lt;span&gt;&#x27;] = &#x27;&lt;/span&gt; + element);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;[&lt;span&gt;11&lt;/span&gt;, &lt;span&gt;24&lt;/span&gt;, &lt;span&gt;32&lt;/span&gt;].forEach(testData);&lt;br/&gt;&lt;span&gt;// logs: test[0] = 11, test[1] = 24, test[2] = 32&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;12.return中比较&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们也可以在return语句中使用比较。它将避免我们的5行代码，并将它们减少到1行。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;checkReturn&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (!(test === &lt;span&gt;undefined&lt;/span&gt;)) {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; test;&lt;br/&gt;  } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; callMe(&lt;span&gt;&#x27;test&#x27;&lt;/span&gt;);&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; data = checkReturn();&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(data); &lt;span&gt;//output test&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;callMe&lt;/span&gt;(&lt;span&gt;val&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(val);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;checkReturn&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; test || callMe(&lt;span&gt;&#x27;test&#x27;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;13.箭头函数&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;a, b&lt;/span&gt;) &lt;/span&gt;{ &lt;br/&gt;   &lt;span&gt;return&lt;/span&gt; a + b; &lt;br/&gt;} &lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; add = &lt;span&gt;(&lt;span&gt;a, b&lt;/span&gt;) =&amp;gt;&lt;/span&gt; a + b;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更多示例。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;callMe&lt;/span&gt;(&lt;span&gt;name&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;Hello&#x27;&lt;/span&gt;, name);&lt;br/&gt;}&lt;br/&gt;callMe = &lt;span&gt;&lt;span&gt;name&lt;/span&gt; =&amp;gt;&lt;/span&gt; &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;Hello&#x27;&lt;/span&gt;, name);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;14.短函数调用&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以使用三元运算符来实现这些功能。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;test1&#x27;&lt;/span&gt;);&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;test2&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;test2&#x27;&lt;/span&gt;);&lt;br/&gt;};&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; test3 = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (test3 == &lt;span&gt;1&lt;/span&gt;) {&lt;br/&gt;  test1();&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  test2();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;(test3 === &lt;span&gt;1&lt;/span&gt;? test1:test2)();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;15. Switch简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以将条件保存在键值对象中，并可以根据条件使用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;switch&lt;/span&gt; (data) {&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;:&lt;br/&gt;    test1();&lt;br/&gt;  &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;:&lt;br/&gt;    test2();&lt;br/&gt;  &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  &lt;span&gt;case&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;:&lt;br/&gt;    test();&lt;br/&gt;  &lt;span&gt;break&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;// And so on...&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; data = {&lt;br/&gt;  &lt;span&gt;1&lt;/span&gt;: test1,&lt;br/&gt;  &lt;span&gt;2&lt;/span&gt;: test2,&lt;br/&gt;  &lt;span&gt;3&lt;/span&gt;: test&lt;br/&gt;};&lt;br/&gt;&lt;br/&gt;data[something] &amp;amp;&amp;amp; data[something]();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;16.隐式返回简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用箭头函数，我们可以直接返回值，而不必编写return语句。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;calculate&lt;/span&gt;(&lt;span&gt;diameter&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;Math&lt;/span&gt;.PI * diameter&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;calculate = &lt;span&gt;&lt;span&gt;diameter&lt;/span&gt; =&amp;gt;&lt;/span&gt; (&lt;br/&gt;  &lt;span&gt;Math&lt;/span&gt;.PI * diameter;&lt;br/&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;17.小数基数指数&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;10000&lt;/span&gt;; i++) { ... }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;1e4&lt;/span&gt;; i++) {&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;18.默认参数值&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt;(&lt;span&gt;test1, test2&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (test1 === &lt;span&gt;undefined&lt;/span&gt;)&lt;br/&gt;    test1 = &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;if&lt;/span&gt; (test2 === &lt;span&gt;undefined&lt;/span&gt;)&lt;br/&gt;    test2 = &lt;span&gt;2&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; test1 + test2;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;add = &lt;span&gt;(&lt;span&gt;test1 = &lt;span&gt;1&lt;/span&gt;, test2 = &lt;span&gt;2&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; (test1 + test2);&lt;br/&gt;add() &lt;span&gt;//output: 3&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;19.扩展运算符简写&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// joining arrays using concat&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; data = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test = [&lt;span&gt;4&lt;/span&gt; ,&lt;span&gt;5&lt;/span&gt; , &lt;span&gt;6&lt;/span&gt;].concat(data);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// joining arrays&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; data = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test = [&lt;span&gt;4&lt;/span&gt; ,&lt;span&gt;5&lt;/span&gt; , &lt;span&gt;6&lt;/span&gt;, ...data];&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(test); &lt;span&gt;// [ 4, 5, 6, 1, 2, 3]&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于克隆，我们也可以使用扩展运算符。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// cloning arrays&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test1 = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test2 = test1.slice()&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// cloning arrays&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test1 = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;];&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test2 = [...test1];&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;20.模板文字&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果您厌倦了在单个字符串中使用 &lt;code&gt;+&lt;/code&gt; 来连接多个变量，那么这种简写可以消除您的头痛。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; welcome = &lt;span&gt;&#x27;Hi &#x27;&lt;/span&gt; + test1 + &lt;span&gt;&#x27; &#x27;&lt;/span&gt; + test2 + &lt;span&gt;&#x27;.&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; welcome = &lt;span&gt;`Hi &lt;span&gt;${test1}&lt;/span&gt; &lt;span&gt;${test2}&lt;/span&gt;`&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;21.多行字符串简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们在代码中处理多行字符串时，可以使用以下功能：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; data = &lt;span&gt;&#x27;abc abc abc abc abc abc\n\t&#x27;&lt;/span&gt;&lt;br/&gt;    + &lt;span&gt;&#x27;test test,test test test test\n\t&#x27;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; data = &lt;span&gt;`abc abc abc abc abc abc&lt;br/&gt;         test test,test test test test`&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;22.对象属性分配&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; test1 = &lt;span&gt;&#x27;a&#x27;&lt;/span&gt;; &lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test2 = &lt;span&gt;&#x27;b&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; obj = {&lt;span&gt;test1&lt;/span&gt;: test1, &lt;span&gt;test2&lt;/span&gt;: test2}; &lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; obj = {test1, test2};&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;23.将字符串转换成数字&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test1 = &lt;span&gt;parseInt&lt;/span&gt;(&lt;span&gt;&#x27;123&#x27;&lt;/span&gt;); &lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test2 = &lt;span&gt;parseFloat&lt;/span&gt;(&lt;span&gt;&#x27;12.3&#x27;&lt;/span&gt;); &lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test1 = +&lt;span&gt;&#x27;123&#x27;&lt;/span&gt;; &lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test2 = +&lt;span&gt;&#x27;12.3&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;24.用解构简写&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test1 = &lt;span&gt;this&lt;/span&gt;.data.test1;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test2 = &lt;span&gt;this&lt;/span&gt;.data.test2;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; test2 = &lt;span&gt;this&lt;/span&gt;.data.test3;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; { test1, test2, test3 } = &lt;span&gt;this&lt;/span&gt;.data;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;25.用Array.find简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们确实有一个对象数组并且我们想要根据对象属性查找特定对象时，find方法确实很有用。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; data = [&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;test1&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;test2&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;cde&#x27;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  {&lt;br/&gt;    &lt;span&gt;type&lt;/span&gt;: &lt;span&gt;&#x27;test1&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;name&lt;/span&gt;: &lt;span&gt;&#x27;fgh&#x27;&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;]&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;findtest1&lt;/span&gt;(&lt;span&gt;name&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; data.length; ++i) {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (data[i].type === &lt;span&gt;&#x27;test1&#x27;&lt;/span&gt; &amp;amp;&amp;amp; data[i].name === name) {&lt;br/&gt;      &lt;span&gt;return&lt;/span&gt; data[i];&lt;br/&gt;    }&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand&lt;/span&gt;&lt;br/&gt;filteredData = data.find(&lt;span&gt;&lt;span&gt;data&lt;/span&gt; =&amp;gt;&lt;/span&gt; data.type === &lt;span&gt;&#x27;test1&#x27;&lt;/span&gt; &amp;amp;&amp;amp; data.name === &lt;span&gt;&#x27;fgh&#x27;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(filteredData); &lt;span&gt;// { type: &#x27;test1&#x27;, name: &#x27;fgh&#x27; }&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;26.查找条件简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们有代码来检查类型，根据类型需要调用不同的方法，我们可以选择使用多个else ifs或者switch，但是如果我们有比这更好的简写方法呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (type === &lt;span&gt;&#x27;test1&#x27;&lt;/span&gt;) {&lt;br/&gt;  test1();&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (type === &lt;span&gt;&#x27;test2&#x27;&lt;/span&gt;) {&lt;br/&gt;  test2();&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (type === &lt;span&gt;&#x27;test3&#x27;&lt;/span&gt;) {&lt;br/&gt;  test3();&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (type === &lt;span&gt;&#x27;test4&#x27;&lt;/span&gt;) {&lt;br/&gt;  test4();&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;  &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;&#x27;Invalid value &#x27;&lt;/span&gt; + type);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; types = {&lt;br/&gt;  &lt;span&gt;test1&lt;/span&gt;: test1,&lt;br/&gt;  &lt;span&gt;test2&lt;/span&gt;: test2,&lt;br/&gt;  &lt;span&gt;test3&lt;/span&gt;: test3,&lt;br/&gt;  &lt;span&gt;test4&lt;/span&gt;: test4&lt;br/&gt;};&lt;br/&gt; &lt;br/&gt;&lt;span&gt;var&lt;/span&gt; func = types[type];&lt;br/&gt;(!func) &amp;amp;&amp;amp; &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Error&lt;/span&gt;(&lt;span&gt;&#x27;Invalid value &#x27;&lt;/span&gt; + type); func();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;27.按位索引简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们遍历数组以查找特定值时，我们确实使用 &lt;code&gt;indexOf()&lt;/code&gt; 方法，如果找到更好的方法该怎么办？让我们看看这个例子。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(arr.indexOf(item) &amp;gt; &lt;span&gt;-1&lt;/span&gt;) { &lt;span&gt;// item found &lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(arr.indexOf(item) === &lt;span&gt;-1&lt;/span&gt;) { &lt;span&gt;// item not found&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(~arr.indexOf(item)) { &lt;span&gt;// item found&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(!~arr.indexOf(item)) { &lt;span&gt;// item not found&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;按位（&lt;code&gt;〜&lt;/code&gt;）运算符将返回除-1以外的任何值的真实值。否定它就像做 &lt;code&gt;~~&lt;/code&gt; 一样简单。另外，我们也可以使用 &lt;code&gt;include()&lt;/code&gt; 函数：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;if&lt;/span&gt; (arr.includes(item)) { &lt;br/&gt;&lt;span&gt;// true if the item found&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;28.Object.entries()&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此函数有助于将对象转换为对象数组。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; data = { &lt;span&gt;test1&lt;/span&gt;: &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;, &lt;span&gt;test2&lt;/span&gt;: &lt;span&gt;&#x27;cde&#x27;&lt;/span&gt;, &lt;span&gt;test3&lt;/span&gt;: &lt;span&gt;&#x27;efg&#x27;&lt;/span&gt; };&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; arr = &lt;span&gt;Object&lt;/span&gt;.entries(data);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(arr);&lt;br/&gt;&lt;span&gt;/** Output:&lt;br/&gt;[ [ &#x27;test1&#x27;, &#x27;abc&#x27; ],&lt;br/&gt;  [ &#x27;test2&#x27;, &#x27;cde&#x27; ],&lt;br/&gt;  [ &#x27;test3&#x27;, &#x27;efg&#x27; ]&lt;br/&gt;]&lt;br/&gt;**/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;29.Object.values()&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是ES8中引入的一项新功能，该功能执行与 &lt;code&gt;Object.entries()&lt;/code&gt; 类似的功能，但没有关键部分：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; data = { &lt;span&gt;test1&lt;/span&gt;: &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;, &lt;span&gt;test2&lt;/span&gt;: &lt;span&gt;&#x27;cde&#x27;&lt;/span&gt; };&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; arr = &lt;span&gt;Object&lt;/span&gt;.values(data);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(arr);&lt;br/&gt;&lt;span&gt;/** Output:&lt;br/&gt;[ &#x27;abc&#x27;, &#x27;cde&#x27;]&lt;br/&gt;**/&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;30.双按位简写&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;双重NOT按位运算符方法仅适用于32位整数）&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;// Longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Math&lt;/span&gt;.floor(&lt;span&gt;1.9&lt;/span&gt;) === &lt;span&gt;1&lt;/span&gt; &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Shorthand&lt;/span&gt;&lt;br/&gt;~~&lt;span&gt;1.9&lt;/span&gt; === &lt;span&gt;1&lt;/span&gt; &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;31.重复一个字符串多次&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要一次又一次地重复相同的字符，我们可以使用for循环并将它们添加到同一循环中，但是如果我们有一个简写方法呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;let&lt;/span&gt; test = &lt;span&gt;&#x27;&#x27;&lt;/span&gt;; &lt;br/&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;let&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;5&lt;/span&gt;; i ++) { &lt;br/&gt;  test += &lt;span&gt;&#x27;test &#x27;&lt;/span&gt;; &lt;br/&gt;} &lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(str); &lt;span&gt;// test test test test test &lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand &lt;/span&gt;&lt;br/&gt;&lt;span&gt;&#x27;test &#x27;&lt;/span&gt;.repeat(&lt;span&gt;5&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;32.在数组中查找最大值和最小值&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; arr = [&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;3&lt;/span&gt;]; &lt;br/&gt;&lt;span&gt;Math&lt;/span&gt;.max(…arr); &lt;span&gt;// 3&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Math&lt;/span&gt;.min(…arr); &lt;span&gt;// 1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;33.从字符串中获取字符&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;let&lt;/span&gt; str = &lt;span&gt;&#x27;abc&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Longhand &lt;/span&gt;&lt;br/&gt;str.charAt(&lt;span&gt;2&lt;/span&gt;); &lt;span&gt;// c&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//Shorthand &lt;/span&gt;&lt;br/&gt;Note: If we know the index &lt;span&gt;of&lt;/span&gt; the array then we can directly use index insted &lt;span&gt;of&lt;/span&gt; character.If we are not sure about index it can &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;undefined&lt;/span&gt;&lt;br/&gt;str[&lt;span&gt;2&lt;/span&gt;]; &lt;span&gt;// c&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;34.数学指数幂函数的简写&lt;/span&gt;&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//longhand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Math&lt;/span&gt;.pow(&lt;span&gt;2&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;); &lt;span&gt;// 8&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//shorthand&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2&lt;/span&gt;**&lt;span&gt;3&lt;/span&gt; &lt;span&gt;// 8&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b8a2cc82d285efa9a8ae8959b3a9cb2b</guid>
<title>[推荐] Redis 不是一直号称单线程效率也很高吗，为什么又采用多线程了？</title>
<link>https://toutiao.io/k/vsxwjpf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article class=&quot;article-content&quot;&gt;
&lt;p&gt;Redis是目前广为人知的一个内存数据库，在各个场景中都有着非常丰富的应用，前段时间Redis推出了6.0的版本，在新版本中采用了多线程模型。&lt;/p&gt;
&lt;p&gt;因为我们公司使用的内存数据库是自研的，按理说我对Redis的关注其实并不算多，但是因为Redis用的比较广泛，所以我需要了解一下这样方便我进行面试。&lt;/p&gt;
&lt;p&gt;总不能候选人用过Redis，但是我非要问人家阿里的Tair是怎么回事吧。&lt;/p&gt;
&lt;p&gt;所以，在Redis 6.0 推出之后，我想去了解下为什么采用多线程，现在采用的多线程和以前版本有什么区别？为什么这么晚才使用多线程？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Redis不是已经采用了多路复用技术吗？不是号称很高的性能了吗？为啥还要采用多线程模型呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本文就来分析下这些问题以及背后的思考。&lt;/p&gt;
&lt;h3&gt;Redis为什么最开始被设计成单线程的？&lt;/h3&gt;
&lt;p&gt;Redis作为一个成熟的分布式缓存框架，它由很多个模块组成，如网络请求模块、索引模块、存储模块、高可用集群支撑模块、数据操作模块等。&lt;/p&gt;
&lt;p&gt;很多人说Redis是单线程的，就认为Redis中所有模块的操作都是单线程的，其实这是不对的。&lt;/p&gt;
&lt;p&gt;我们所说的Redis单线程，指的是”其网络IO和键值对读写是由一个线程完成的”，也就是说，&lt;strong&gt;Redis中只有网络请求模块和数据操作模块是单线程的。而其他的如持久化存储模块、集群支撑模块等是多线程的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以说，Redis中并不是没有多线程模型的，早在Redis 4.0的时候就已经针对部分命令做了多线程化。&lt;/p&gt;
&lt;p&gt;那么，为什么网络操作模块和数据存储模块最初并没有使用多线程呢？&lt;/p&gt;
&lt;p&gt;这个问题的答案比较简单！因为：”没必要！”&lt;/p&gt;
&lt;p&gt;为什么没必要呢？我们先来说一下，什么情况下要使用多线程？&lt;/p&gt;
&lt;h4&gt;多线程适用场景&lt;/h4&gt;
&lt;p&gt;一个计算机程序在执行的过程中，主要需要进行两种操作分别是读写操作和计算操作。&lt;/p&gt;
&lt;p&gt;其中读写操作主要是涉及到的就是I/O操作，其中包括网络I/O和磁盘I/O。计算操作主要涉及到CPU。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而多线程的目的，就是通过并发的方式来提升I/O的利用率和CPU的利用率。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么，Redis需不需要通过多线程的方式来提升提升I/O的利用率和CPU的利用率呢？&lt;/p&gt;
&lt;p&gt;首先，我们可以肯定的说，Redis不需要提升CPU利用率，因为&lt;strong&gt;Redis的操作基本都是基于内存的，CPU资源根本就不是Redis的性能瓶颈。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，通过多线程技术来提升Redis的CPU利用率这一点是完全没必要的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么，使用多线程技术来提升Redis的I/O利用率呢？是不是有必要呢？&lt;/p&gt;
&lt;p&gt;Redis确实是一个I/O操作密集的框架，他的数据操作过程中，会有大量的网络I/O和磁盘I/O的发生。要想提升Redis的性能，是一定要提升Redis的I/O利用率的，这一点毋庸置疑。&lt;/p&gt;
&lt;p&gt;但是，&lt;strong&gt;提升I/O利用率，并不是只有采用多线程技术这一条路可以走！&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;多线程的弊端&lt;/h4&gt;
&lt;p&gt;我们在很多文章中介绍过一些Java中的多线程技术，如内存模型、锁、CAS等，这些都是Java中提供的一些在多线程情况下保证线程安全的技术。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;线程安全：是编程中的术语，指某个函数、函数库在并发环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;和Java类似，所有支持多线程的编程语言或者框架，都不得不面对的一个问题，那就是如何解决多线程编程模式带来的共享资源的并发控制问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虽然，采用多线程可以帮助我们提升CPU和I/O的利用率，但是多线程带来的并发问题也给这些语言和框架带来了更多的复杂性。而且，多线程模型中，多个线程的互相切换也会带来一定的性能开销。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，在提升I/O利用率这个方面上，Redis并没有采用多线程技术，而是选择了&lt;strong&gt;多路复用 I/O&lt;/strong&gt;技术。&lt;/p&gt;
&lt;h4&gt;小结&lt;/h4&gt;
&lt;p&gt;Redis并没有在网络请求模块和数据操作模块中使用多线程模型，主要是基于以下四个原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1、Redis 操作基于内存，绝大多数操作的性能瓶颈不在 CPU&lt;/li&gt;
&lt;li&gt;2、使用单线程模型，可维护性更高，开发，调试和维护的成本更低&lt;/li&gt;
&lt;li&gt;3、单线程模型，避免了线程间切换带来的性能开销&lt;/li&gt;
&lt;li&gt;4、在单线程中使用多路复用 I/O技术也能提升Redis的I/O利用率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;还是要记住：Redis并不是完全单线程的，只是有关键的网络IO和键值对读写是由一个线程完成的。&lt;/p&gt;
&lt;h3&gt;Redis的多路复用&lt;/h3&gt;
&lt;p&gt;多路复用这个词，相信很多人都不陌生。我之前的很多文章中也够提到过这个词。&lt;/p&gt;
&lt;p&gt;其中在介绍Linux IO模型的时候我们提到过它、在介绍HTTP/2的原理的时候，我们也提到过他。&lt;/p&gt;
&lt;p&gt;那么，Redis的多路复用技术和我们之前介绍的又有什么区别呢？&lt;/p&gt;
&lt;p&gt;这里先讲讲&lt;strong&gt;Linux多路复用技术，就是多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hollischuang.com/wp-content/uploads/2021/03/16157036192280.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;多看一遍上面这张图和上面那句话，后面可能还会用得到。&lt;/p&gt;
&lt;p&gt;也就是说，通过一个线程来处理多个IO流。&lt;/p&gt;
&lt;p&gt;IO多路复用在Linux下包括了三种，select、poll、epoll，抽象来看，他们功能是类似的，但具体细节各有不同。&lt;/p&gt;
&lt;p&gt;其实，Redis的IO多路复用程序的所有功能都是通过包装操作系统的IO多路复用函数库来实现的。每个IO多路复用函数库在Redis源码中都有对应的一个单独的文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hollischuang.com/wp-content/uploads/2021/03/16157004365080.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;在Redis 中，每当一个套接字准备好执行连接应答、写入、读取、关闭等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hollischuang.com/wp-content/uploads/2021/03/16157003905528.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。&lt;/p&gt;
&lt;p&gt;所以，Redis选择使用多路复用IO技术来提升I/O利用率。&lt;/p&gt;
&lt;p&gt;而之所以Redis能够有这么高的性能，不仅仅和采用多路复用技术和单线程有关，此外还有以下几个原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2、数据结构简单，对数据操作也简单，如哈希表、跳表都有很高的性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;4、使用多路I/O复用模型&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;为什么Redis 6.0 引入多线程&lt;/h3&gt;
&lt;p&gt;2020年5月份，Redis正式推出了6.0版本，这个版本中有很多重要的新特性，其中多线程特性引起了广泛关注。&lt;/p&gt;
&lt;p&gt;但是，需要提醒大家的是，&lt;strong&gt;Redis 6.0中的多线程，也只是针对处理网络请求过程采用了多线程，而数据的读写命令，仍然是单线程处理的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是，不知道会不会有人有这样的疑问：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Redis不是号称单线程也有很高的性能么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不是说多路复用技术已经大大的提升了IO利用率了么，为啥还需要多线程？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主要是因为我们对Redis有着更高的要求。&lt;/p&gt;
&lt;p&gt;根据测算，Redis 将所有数据放在内存中，内存的响应时长大约为 100 纳秒，对于小数据包，Redis 服务器可以处理 80,000 到 100,000 QPS，这么高的对于 80% 的公司来说，单线程的 Redis 已经足够使用了。&lt;/p&gt;
&lt;p&gt;但随着越来越复杂的业务场景，有些公司动不动就上亿的交易量，因此需要更大的 QPS。&lt;/p&gt;
&lt;p&gt;为了提升QPS，很多公司的做法是部署Redis集群，并且尽可能提升Redis机器数。但是这种做法的资源消耗是巨大的。&lt;/p&gt;
&lt;p&gt;而经过分析，限制Redis的性能的主要瓶颈出现在网络IO的处理上，虽然之前采用了多路复用技术。但是我们前面也提到过，&lt;strong&gt;多路复用的IO模型本质上仍然是同步阻塞型IO模型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面是多路复用IO中select函数的处理过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hollischuang.com/wp-content/uploads/2021/03/16157047007332.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;从上图我们可以看到，&lt;strong&gt;在多路复用的IO模型中，在处理网络请求时，调用 select （其他函数同理）的过程是阻塞的，也就是说这个过程会阻塞线程，如果并发量很高，此处可能会成为瓶颈。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然现在很多服务器都是多个CPU核的，但是对于Redis来说，因为使用了单线程，在一次数据操作的过程中，有大量的CPU时间片是耗费在了网络IO的同步处理上的，并没有充分的发挥出多核的优势。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果能采用多线程，使得网络处理的请求并发进行，就可以大大的提升性能。多线程除了可以减少由于网络 I/O 等待造成的影响，还可以充分利用 CPU 的多核优势。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以，Redis 6.0采用多个IO线程来处理网络请求，网络请求的解析可以由其他线程完成，然后把解析后的请求交由主线程进行实际的内存读写。提升网络请求处理的并行度，进而提升整体性能。&lt;/p&gt;
&lt;p&gt;但是，Redis 的多 IO 线程只是用来处理网络请求的，对于读写命令，Redis 仍然使用单线程来处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么，在引入多线程之后，如何解决并发带来的线程安全问题呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这就是为什么我们前面多次提到的”Redis 6.0的多线程只用来处理网络请求，而数据的读写还是单线程”的原因。&lt;/p&gt;
&lt;p&gt;Redis 6.0 只有在网络请求的接收和解析，以及请求后的数据通过网络返回给时，使用了多线程。而数据读写操作还是由单线程来完成的，所以，这样就不会出现并发问题了。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/Zzbj/p/13531622.html https://xie.infoq.cn/article/b3816e9fe3ac77684b4f29348 https://jishuin.proginn.com/p/763bfbd2a1c2 《极客时间：Redis核心技术与实战》&lt;/p&gt;
&lt;center&gt;&lt;b&gt;(全文完)&lt;/b&gt;&lt;/center&gt;&lt;hr/&gt;&lt;center&gt;&lt;b&gt;扫描二维码，关注作者微信公众号&lt;/b&gt;&lt;/center&gt;&lt;img src=&quot;http://www.hollischuang.com/wp-content/uploads/2019/04/二维码.png&quot;/&gt;
&lt;/article&gt;
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>