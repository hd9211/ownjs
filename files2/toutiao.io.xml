<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>f2714a6e862ac70abccad2990f481e92</guid>
<title>成为更好的开发者！行动起来！</title>
<link>https://toutiao.io/k/bcodelm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;weui-dialog&quot;&gt;
      &lt;p class=&quot;weui-dialog__hd&quot;&gt;&lt;strong class=&quot;weui-dialog__title&quot;&gt;&quot;Top Stories&quot; is disabled&lt;/strong&gt;&lt;/p&gt;
      &lt;p class=&quot;weui-dialog__bd&quot;&gt;
        Enable &quot;Top Stories&quot; in &quot;Settings&quot; &amp;gt; &quot;General&quot; &amp;gt; &quot;Manage Discover&quot;      &lt;/p&gt;
      
    &lt;/div&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>403860aa2c5964ea49088ab33d7db829</guid>
<title>快手抓包问题分析</title>
<link>https://toutiao.io/k/ef3rtq9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section class=&quot;toc-content post tag-spider tag-linux no-image&quot;&gt;
      &lt;h2 id=&quot;%E8%83%8C%E6%99%AF&quot;&gt;背景&lt;/h2&gt;&lt;p&gt;不知从什么版本后，对快手进行简单抓包似乎“不可行”了。表现就是使用常规的 HTTP 正向代理抓包工具（&lt;a href=&quot;https://www.charlesproxy.com/&quot;&gt;charles&lt;/a&gt;、&lt;a href=&quot;https://mitmproxy.org/&quot;&gt;mitmproxy&lt;/a&gt;、&lt;a href=&quot;https://www.telerik.com/fiddler&quot;&gt;fiddler&lt;/a&gt; 之类）并且把自签名证书种到系统证书里后，数据依然能刷出来，也能抓到一些零星的报文，但是关键出数据的那些接口报文都没有。&lt;/p&gt;&lt;p&gt;一般来说，常规方法无法抓安卓应用的 https 包，通常有以下几种可能：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;证书信任问题。在 Android 7 以上，应用会默认不信任用户证书，只信任系统证书，如果配置不得当则是抓不到包的。&lt;/li&gt;&lt;li&gt;应用配置了 SSL pinning，强制只信任自己的证书。这样一来由于客户端不信任我们种的证书，因此也无法抓包。&lt;/li&gt;&lt;li&gt;应用使用了纯 TCP 传输私有协议（通常也会套上一层 TLS）。由于甚至都不是 HTTP 协议，当然就抓不到包了。&lt;/li&gt;&lt;li&gt;应用使用 WebSocket 长链接，将不同的接口封装在这个长链接里。在 WebSocket 里承载的协议一般是用某种自定义方式来模拟 http 请求，因此也难以抓包。&lt;/li&gt;&lt;li&gt;应用使用了基于 UDP 的 http3.0协议等。大部分代理工具目前还不支持 quic 等协议，所以这样一般是抓不到包的。&lt;/li&gt;&lt;li&gt;应用配置了 Proxy.NO_PROXY ，强制不走系统代理。这样http流量就绕过我们配置的代理，自然抓不到包。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;当前的现象是数据能刷出来，那就说明并不是证书信任相关的问题。接下来就需要验证它究竟是使用了什么样的传输方式，对症下药。&lt;/p&gt;&lt;p&gt;最稳妥的验证方式当然是白盒测试看源码，不过快手反编译的代码看起来也费劲，于是考虑直接当成黑盒来测试看看。以下验证方式均以 &lt;strong&gt; 快手 8.2.31.17191&lt;/strong&gt; 版本为例。&lt;/p&gt;&lt;h2 id=&quot;%E5%88%86%E6%9E%90&quot;&gt;分析&lt;/h2&gt;&lt;h3 id=&quot;%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2&quot;&gt;环境部署&lt;/h3&gt;&lt;h4 id=&quot;%E5%87%86%E5%A4%87%E8%87%AA%E7%AD%BE%E5%90%8Dca%E8%AF%81%E4%B9%A6&quot;&gt;准备自签名CA证书&lt;/h4&gt;&lt;p&gt;需要在 Linux 主机上使用 openssl 工具生成一波证书。当然，这一步可以忽略，直接使用mitmproxy生成的证书。只是手动配置一下能够加深一下对 openssl 的理解。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# 生成RSA私钥 cert.key 
openssl genrsa -out cert.key 2048

# 生成有效期为15年的X509证书 cert.crt（DN信息随便填填似乎都行，但是不能全空）
openssl req -new -x509 -key cert.key -out -days 5480 cert.crt

# 私钥和证书放一起，构成PEM格式的 cert.pem
cat cert.key cert.crt &amp;gt; cert.pem

# 将之前生成的pem证书作为mitmproxy使用的根证书
cp cert.pem ~/.mitmproxy/mitmproxy-ca.pem

# 以普通正向代理模式启动在8000端口，并配合curl简单验证证书可用性
mitmproxy -p 8000 

# 能正常访问没有SSL相关报错，就说明之前生成的自签名证书是OK的
curl -x localhost:8000 --cacert ~/.mitmproxy/mitmproxy-ca.pem https://www.baidu.com

# 从证书文件中计算出用于放置在安卓中的文件hash名，假设结果为 a5176621 
openssl x509 -subject_hash_old -in cert.crt -noout

# 将cert.crt复制出一个上述hash结果的新文件
cp cert.crt a5176621.0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;值得注意的是，不要尝试使用 &lt;code&gt;mitmproxy --certs&lt;/code&gt; 来配置证书，这种方式只能配置 leaf 证书，而不能配置根 CA 证书。因此还是老老实实的把根证书放在默认路径下。&lt;/p&gt;&lt;h4 id=&quot;%E5%87%86%E5%A4%87%E8%AE%BE%E5%A4%87&quot;&gt;准备设备&lt;/h4&gt;&lt;p&gt;为了方便测试，我在 arm 服务器上使用 &lt;a href=&quot;https://github.com/remote-android/redroid-doc&quot;&gt;redroid&lt;/a&gt; 准备了一台安卓虚拟机。&lt;/p&gt;&lt;pre&gt;&lt;code&gt;docker run -itd --rm --memory-swappiness=0 \
--privileged --name redroid \
--mount type=bind,source=/home/myths/exp/a5176621.0,target=/system/etc/security/cacerts/a5176621.0 \
-p 5555:5555 \
redroid/redroid:11.0.0-arm64 \
redroid.width=720 \
redroid.height=1280 \
redroid.fps=15 \
redroid.gpu.mode=guest&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中 /home/myths/exp/a5176621.0 替换成实际文件所在路径。&lt;/p&gt;&lt;p&gt;然后在arm主机上用 adb 连接安卓的 tcpip 端口，下载并安装快手 8.2.31.17191 版本。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# 在arm服务器上用adb连接安卓虚拟机
adb connect localhost:5555

# 安装快手
adb install kuaishou.apk&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了方便远程操作，需要在本地机器上连接 arm 服务器上的安卓虚拟机，并用scrcpy操作。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# 在本地主机上连接远程arm服务器上的安卓虚拟机
adb connect &amp;lt;ip for arm server&amp;gt;:5555

# 启动scrcpy
scrcpy&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;到这一步骤时，可以检测安卓中的网络应该都已经是通的了。&lt;/p&gt;&lt;h3 id=&quot;%E5%A4%8D%E7%8E%B0%E6%8A%93%E5%8C%85%E9%97%AE%E9%A2%98&quot;&gt;复现抓包问题&lt;/h3&gt;&lt;p&gt;先尝试使用传统正向代理的方式进行抓包。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# 在arm服务器上用正向代理启动mitmproxy
mitmproxy -p 8000

# 对安卓设置正向代理，其中 172.17.0.1 为安卓下访问arm主机的ip
adb shell settings put global http_proxy 172.17.0.1:8000&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;设置完成后，观察手机的网络状况，现象如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;使用浏览器访问普通网站，返回均正常，mitmproxy也能抓到包。&lt;/li&gt;&lt;li&gt;刷快手推荐页，返回也正常，但是mitmproxy只能抓到一些静态资源，无法抓到接口。&lt;/li&gt;&lt;/ol&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2022/02/Xnip2022-02-20_15-30-21.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot; srcset=&quot;https://blog.mythsman.com/content/images/size/w600/2022/02/Xnip2022-02-20_15-30-21.png 600w, https://blog.mythsman.com/content/images/size/w1000/2022/02/Xnip2022-02-20_15-30-21.png 1000w, https://blog.mythsman.com/content/images/2022/02/Xnip2022-02-20_15-30-21.png 1024w&quot; sizes=&quot;(min-width: 720px) 720px&quot;/&gt;&lt;/figure&gt;&lt;h3 id=&quot;ban%E6%8E%89%E4%B8%8D%E8%B5%B0%E4%BB%A3%E7%90%86%E7%9A%84%E6%89%80%E6%9C%89%E6%B5%81%E9%87%8F&quot;&gt;Ban掉不走代理的所有流量&lt;/h3&gt;&lt;p&gt;有数据但是抓不到包，怀疑应当是有些流量漏掉了，于是尝试把这些流量Ban掉看看效果。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# 首先需要打开内核的 ip_forward 功能
echo 1 &amp;gt; /proc/sys/net/ipv4/ip_forward

# 依然在arm服务器上用正向代理启动mitmproxy
mitmproxy -p 8000

# 继续在手机上配置http代理，其中172.17.0.1为安卓下访问arm主机的ip
adb shell settings put global http_proxy 172.17.0.1:8000

# 在 arm 服务器上配置iptables，将来源于安卓虚拟机但目的地不是arm服务器的流量重定向到一个无用端口。
# 其中 172.17.0.12 位安卓虚拟机的ip，1234为一个无用端口。
sudo iptables -t nat -I PREROUTING -p tcp -s 172.17.0.12 ! -d 172.17.0.1 -j REDIRECT --to-ports 1234
# 如果上述操作报了 Couldn&#x27;t load match `owner&#x27;:No such file or directory 的错，那么需要在 arm 服务器上启动下相关模块。
sudo modprobe ipt_owner

# 记得测试完成后，将上面这个记录干掉
iptables -t nat -D PREROUTING 1&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;设置完成后，观察手机的网络状况，现象如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;使用浏览器访问普通网站，返回均正常，mitmproxy也能抓到包。&lt;/li&gt;&lt;li&gt;刷快手推荐页，显示“无网络连接“。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;说明这里的确是有流量漏了，没有走正向代理，但是依然出了外网。&lt;/p&gt;&lt;h3 id=&quot;ban%E6%8E%89%E4%B8%8D%E8%B5%B0%E4%BB%A3%E7%90%86%E7%9A%8444380%E6%B5%81%E9%87%8F&quot;&gt;Ban掉不走代理的443/80流量&lt;/h3&gt;&lt;p&gt;那么这些流量到底是私有的四层TCP流量、还是没走正向代理的80/443流量呢？因此尝试把非80/443的流量放开试试。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# 依然在arm服务器上用正向代理启动mitmproxy
mitmproxy -p 8000

# 继续在手机上配置http代理
adb shell settings put global http_proxy 172.17.0.1:8000

# 在 arm 服务器上配置iptables，将来源于安卓虚拟机但目的端口不是80/443的流量重定向到一个无用端口。
# 其中 172.17.0.12 位安卓虚拟机的ip，1234为一个无用端口。
sudo iptables -t nat -I PREROUTING -p tcp -s 172.17.0.12  --dport 80 -j REDIRECT --to-ports 1234
sudo iptables -t nat -I PREROUTING -p tcp -s 172.17.0.12  --dport 443 -j REDIRECT --to-ports 1234

# 记得测试完成后，将上面这两条记录干掉
iptables -t nat -D PREROUTING 1
iptables -t nat -D PREROUTING 1&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;设置完成后，观察手机的网络状况，现象如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;使用浏览器访问普通网站，返回均正常，mitmproxy也能抓到包。&lt;/li&gt;&lt;li&gt;刷快手推荐页，依然显示“无网络连接“。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;这就说明，控制快手推荐页的流量并不是所谓私有流量，而就是走的80/443端口，只是没有走正向代理。&lt;/p&gt;&lt;h3 id=&quot;%E6%94%B9%E7%94%A8%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F&quot;&gt;改用透明代理模式&lt;/h3&gt;&lt;p&gt;既然七层的代理配置会被忽略，那就尝试使用四层的透明代理，将流量强制转到透明代理服务器上即可。&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# 在arm服务器上以透明代理模式启动mitmproxy
mitmproxy -p 8000 -m transparent

# 将手机上的http代理移除
adb shell settings put global http_proxy :0

# 在arm服务器上配置将来源于安卓虚拟机的的80/443流量直接路由到mitmproxy
# 其中 172.17.0.12 位安卓虚拟机的ip
sudo iptables -t nat -I PREROUTING -p tcp  -s 172.17.0.12 --dport 80 -j REDIRECT --to-ports 8000
sudo iptables -t nat -I PREROUTING -p tcp  -s 172.17.0.12 --dport 443 -j REDIRECT --to-ports 8000

# 记得测试完成后，将上面这两个记录干掉
iptables -t nat -D PREROUTING 1
iptables -t nat -D PREROUTING 1&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;设置完成后，观察手机的网络状况，现象如下：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;使用浏览器访问普通网站，返回均正常，mitmproxy也能抓到包。&lt;/li&gt;&lt;li&gt;刷快手推荐页，能成功刷出，并且mitmproxy也抓到了包。&lt;/li&gt;&lt;/ol&gt;&lt;figure class=&quot;kg-card kg-image-card&quot;&gt;&lt;img src=&quot;https://blog.mythsman.com/content/images/2022/02/K20220220-174206.png&quot; class=&quot;kg-image&quot; alt=&quot;&quot; loading=&quot;lazy&quot; srcset=&quot;https://blog.mythsman.com/content/images/size/w600/2022/02/K20220220-174206.png 600w, https://blog.mythsman.com/content/images/2022/02/K20220220-174206.png 720w&quot; sizes=&quot;(min-width: 720px) 720px&quot;/&gt;&lt;/figure&gt;&lt;h2 id=&quot;%E6%80%BB%E7%BB%93&quot;&gt;总结&lt;/h2&gt;&lt;p&gt;目前看来，快手并非像很多网上传的那样，大多数接口都走了 kquic 协议导致无法抓包。其实很多接口只是做了一个禁止走系统代理的设置，简单使用透明代理模式进行抓包即可轻松绕过。当然，不排除有些关键接口也做了SSL pinning、走私有协议之类的。。。&lt;/p&gt;&lt;h2 id=&quot;%E5%8F%82%E8%80%83&quot;&gt;参考&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://docs.mitmproxy.org/stable/concepts-certificates/&quot;&gt;https://docs.mitmproxy.org/stable/concepts-certificates/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/56830858&quot;&gt;https://stackoverflow.com/questions/56830858&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;https://square.github.io/okhttp/4.x/okhttp/okhttp3/-ok-http-client/-builder/proxy/&quot;&gt;https://square.github.io/okhttp/4.x/okhttp/okhttp3/-ok-http-client/-builder/proxy/&lt;/a&gt;&lt;/p&gt;
    &lt;/section&gt;
  &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a224987e80d8478f78f3364aff518a2a</guid>
<title>TikTok或将与甲骨文达成数据存储协议；董明珠建议对996开展公益诉讼；苹果举办春季新品发布会｜开发者头条</title>
<link>https://toutiao.io/k/fxpbkrf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;321&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/AjN1jquNavic1fOib9UibTAaeyqeBO36abkLDWcNJ5QDQnHI7sueAAuXFsaYzBy2N2IGSL31ic9nNekm5HjRZ1TeWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;640&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;来源&lt;/strong&gt;：网络整理&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;头条菌微信号：&lt;/span&gt;&lt;span&gt;toutiaoio007&lt;/span&gt;&lt;span&gt; ，欢迎加我，交个朋友！&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;数字人民币试点“10+1”有望扩围 全面铺开尚存阻力&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数字人民币试点将在“10+1”格局下迎来进一步扩围。日前，有媒体报道，全国第三批数字人民币试点地区即将亮相，天津市、杭州市、福州市等地区有望入选。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;多位业内人士分析称，通过此前在“10+1”地区的试点，数字人民币应用场景、技术架构均已得到市场认可，监管部门、商业银行以及相关服务商在此过程中也积累了丰富的经验，当前数字人民币进一步扩大试点的条件已经成熟。尽管如此，数字人民币全面铺开尚存阻力，还需在持续提高用户使用体验、测试完善底层技术、保护数据安全、制定相关法律法规和配套政策等方面努力。（证券日报）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;拜登下令研究加密货币风险，探索美国中央银行数字货币&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当地时间周三，美国总统拜登将签署一项行政命令，要求美国政府机构仔细研究加密货币激增可能带来的风险，并考虑创建「数字美元」的可能性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;白宫在一份信息简报中表示，拜登政府的目标是充分利用数字资产的「潜在优势」，同时消除这个超过 3 万亿美元的市场给约 4000 万美国投资者甚至是整个经济带来的风险。据彭博社，美国政府一名高级官员表示，各机构将有 60 至 180 天的时间来完成他们的研究报告，之后政府计划迅速采取行动，执行优秀的提议。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;据华尔街日报，美国一名高级政府官员表示：「这不再是一个小众问题，我们需要拥有正确的工具来减小消费者、投资者甚至整个金融体系的风险，这一点非常重要。」&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此前一位官员分析，一个关键目标是改善当前美国支付系统的低效率，并促进金融包容性。由于费用高昂，约 5% 的美国穷人目前还没有银行账户。（中财网）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;腾讯、网易和米哈游位列全球手游发行商收入榜前五&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3 月 8 日，Sensor Tower 公布了 2022 年 2 月中国手游发行商在全球 App Store 和 Google Play 的收入排名。其中，腾讯游戏、网易游戏和米哈游继续占据全球手游发行商收入榜 TOP 5 的 3 个席位。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此次一共有 36 个中国厂商入围全球手游发行商收入榜 TOP 100，还包括心动网络、创酷互动、竞技世界、哔哩哔哩、露珠科技和紫龙游戏等。它们合计吸金近 20 亿美元，占全球 TOP 100 手游发行商收入近 37.9%。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而在 2022 年 2 月中国 App Store 手游收入排行榜中，腾讯、米哈游、网易旗下的游戏也位列前四。其中，第一名是腾讯旗下的王者荣耀，第二名是腾讯旗下的和平精英，第三名是米哈游旗下的原神，第四名是网易旗下的梦幻西游。（Sensor Tower）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;微信正在测试半屏小程序&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;近日，微信小程序官方开发文档上线了一个新功能，从基础库 2.20.1 开始，将支持「半屏小程序」，目前还处于内测阶段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据文档定义，该功能为「当小程序需要打开另一个小程序让用户进行快捷操作时，可将要打开的小程序通过半屏的形态快速拉起。」&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前，当用户通过微信小程序打开另一个微信小程序时，将会以全新界面打开的方式进行跳转。而在内测的功能中，当开发者进行配置后，就可以从下方拉起，以卡片的形式展现。（IT 之家）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;抖音电商运营团队调整薪资：降低每月基本工资，15薪改18薪&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从字节跳动旗下抖音电商内部人员获悉，近期抖音电商开启了新一轮薪资改革，覆盖旗下大部分运营团队：原有的15薪改为18薪，降低每个月的基本工资，而年终奖比例有所提升，从原有的3个月绩效改为6个月绩效。此次改革主要针对的是运营岗位，产品研发等其他岗位并未涉及。（澎湃）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;京东：应届博士生年薪最高达 200 万元，近 50% 应届生获得晋升&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3 月 7 日消息，京东数据显示，京东物流一线员工中超过 80% 来自农村地区。一线员工中在本省就业的人数占比超过 60%。京东物流 2021 中报数据显示， 半年间为一线员工的薪酬福利开支达到 172 亿元；全员缴纳五险一金等；2022 年“我在京东过大年”投入超 4 亿元，对春节坚守一线的员工加大福利补贴。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;据了解，应届生方面，京东称四年间为应届毕业生提供近 6 万个就业机会，累计开放岗位 358 个，且呈逐年递增趋势。2021 年晋升数据显示，近 50% 应届生获得晋升，25% 应届生年内连续两次晋升。技术人才投入方面，应届博士生年薪最高可达 200 万元。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;从京东物流公布的数据来看，2019 至 2021 年，应届生中硕士及以上学历占比近半。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2021 年，京东物流招聘超过 500 名双一流大学应届生，作为专业人才培养；超过 4000 名“双非应届生”，作为基层管理者储备人才。（IT之家）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;董明珠建议对996开展公益诉讼&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“有些岗位由于特殊原因，在八小时工作制上适当延长，是可以理解的。但如果企业置员工的身体和心理健康于不顾，实行“996”工作制，这是绝对不可行的。”全国人大代表、格力电器董事长兼总裁董明珠建议检察机关对“996”工作制进行监督，为相关劳动者开展公益诉讼工作。检察机关应充分发挥职能，最大限度保护劳动者合法权益。（检察日报）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;俄罗斯曾经最大资源网站 RuTracker.org 近日解封&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;据俄罗斯媒体报道，俄罗斯曾经最大的盗版资源站 RuTracker.org 已经于近日解锁，该网站曾在 2015 年被俄罗斯通信监管机构 Roskomnadzor 永封。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此前，不少游戏厂商、音乐和电影流媒体也终止了俄区服务。于是，俄罗斯当局取消了对盗版网站 RuTracker.org 的封锁，用户可以在其中下载破解的 Windows、Microsoft Office、AutoCAD 等版本，还有好莱坞电影、电视节目。（IT 之家）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;苹果举办春季新品发布会，Mac Studio 最低售价 12600 元起&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3 月 9 日凌晨 2 点，苹果春季新品发布会正式举行。与之前的曝光内容接近，苹果发布了 iPhone SE3、iPad Air 5、M1 Ultra 芯片、新款 Mac 等产品。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最先登场的产品是 iPhone 13 系列苍岭绿配色，本周五开启预购。随后，搭载 A15 仿生芯片的 iPhone SE3 登场。这款产品保留了苹果的 Home 键，库克表示果粉们对 SE 系列一直青睐有加。iPhone SE3 拥有三种配色，正面采用 4.7 英寸玻璃，起售价为 429 美元。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;随后，库克为用户带来了 iPad Air5。它搭载了全新 M1 芯片，相比同价位 Windows 平板更轻，性能更强。此外它有前置 1200 万像素超广角摄像头，支持 5G 连接。iPad Air5 支持 5 种配色，64GB、256GB 两种规格，起售价 599 美元。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;接着发布会宣布了 M1 芯片家族的新成员 M1 Ultra。它采用 UltraFusion 架构将两颗 M1 Max 连接在一起，20 颗 CPU+64 核 GPU 的配置使得其性能相比 M1 芯片高 8 倍。这颗芯片包含 1140 亿晶体管，支持 800GB/s 内存带宽，32 核心神经引擎每秒可执行 22 亿次神经元网络计算。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后是桌面电脑系列。其中，Mac Studio 桌面台式机采用类似 Mac Pro/mini 的外观，其 M1 Ultra 版本相比顶配 MacBook Pro 性能仍提升 80%。而显示器 Studio Display 拥有 27 英寸大屏，支持 5K Retina 显示，600nits 亮度。Mac Studio 的 M1 Max/Ultra 版本售价为 1999、3999 美元，Studio Display 售价 1599 美元。（中关村在线）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;TikTok 或将与甲骨文达成数据存储协议&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3 月 11 日讯，据报道，消息人士透露，TikTok 即将与甲骨文达成协议，在后者服务器上存储美国用户的数据。 据悉，甲骨文将把 TikTok 的所有美国用户数据存储在甲骨文的数据服务器上。根据协议，将成立一个由数百人组成的美国数据管理团队，作为美国用户信息的「看门人」。这两家公司正在讨论一种结构，在这种结构下，美国数据管理团队将不受 TikTok 的控制或监督。（智通财经）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Intel 中国董事长称国内没有竞争对手，依然是行业老大&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;近日，Intel 中国董事长王锐接受凤凰《封面》采访时表示，目前来看中国本土还没有竞争对手，Intel 综合实力依然是行业老大。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;被问及中国本土公司的发展是否已经对 Intel 构成了实质性的威胁，王锐表示，现在还没有，但是她相信中国会出现扎扎实实做好设计的公司的，也非常希望中国本土公司有这样的竞争力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;「我觉得在未来的三到五年，应该可以看到中国本土企业（对我们构成竞争威胁）的这个势头。」王锐表示，Intel 的综合能力绝对是老大，从单一领域看，比如显卡、CPU 芯片，我们的确暂时落后于一些公司，比如制程工艺落后于台积电，但她相信以 Intel 这么多年的底蕴，完全有追回来的把握。（TechWeb）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;光刻机大厂 ASML 重金招人：硕士年薪 36 万元&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3 月 5 日消息，据报道，ASML 公司将从 3 月 5 日开始今年的校招，目标是招聘 1000 名半导体行业的人才，其中 90% 的人才是工程相关，10% 人才是后勤支援的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前半导体人才抢人大战激烈，ASML 开出的薪资也很诱人，根据 ASML 公司 HR 高管公布的数据，新招的硕士毕业生加入 ASML 之后，工资及加班津贴等算进来之后，最高可达 160 万新台币，约合 36 万人民币。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;ASML 强调，从去年 7 月份以来，ASML 员工的涨薪幅度已经达到了 15-19%，同时福利也不少，年假从 10 天起跳，还提供弹性工作制，每周有一天在家办公，可以兼顾家庭与工作。（中关村在线）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;谷歌、微软、苹果、Mozilla 浏览器「四巨头」将首度合作，解决网页适配老大难问题&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;据外媒报道，苹果、Google、微软和 Mozilla，以及软件顾问公司 Bocoup 和 Igalia 已经同意共同合作，致力于改善网络浏览器的互操作性和用户体验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些公司制定了一项名为「Interop 2022」的新标准，主要针对市面上主流的四大浏览器：Safari、Chrome、Edge 和 Firefox，改善 15 个网络平台规范中的表现，以及目前正在调查的三个未完全指定的功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;简单来说，通过该标准，Web 开发人员不必考虑多个浏览器之间的兼容差异，只要标准互通，页面实现的效果是一致的。（快科技）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;迈克尔·乔丹推出 NFT 项目「6 Rings」&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;传奇球星迈克尔·乔丹在新平台 HEIR 上推出 NFT 项目「6 Rings」，以其生涯在芝加哥公牛获得的六座总冠军为灵感，每个持有者都被视为创始粉丝，未来将提供对独家内容或其他项目的访问权限。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;项目原计划推出 10010 个 NFT，不过因反响低于预期，改为 5005 个，每个售价 2.3 SOL。（Hypebeast）&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;加入「码农周刊VIP会员」，成为更好的开发者！&lt;/strong&gt;&lt;strong&gt;&lt;br/&gt;↓↓↓&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/AjN1jquNavicibroqCN98y5SNT9NbfA3oHYQiaicFScHFfppgek7ZGicJiaHK45qc2zoccBibfEzIvzTsI4AB2xO2IaOw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>52ec155b5da45dd5d9a7040b9cd517b6</guid>
<title>一文彻底了解Low Code</title>
<link>https://toutiao.io/k/beqdqw9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;blockquote&gt;&lt;p&gt;“The future of coding is no coding at all.” —— Chris Wanstrath (Former CEO of GitHub)&lt;/p&gt;&lt;/blockquote&gt;&lt;h1&gt;第一部分：基本概念&lt;/h1&gt;&lt;h2&gt;no-code、low-code 和 pro-code&lt;/h2&gt;&lt;blockquote&gt;&lt;p&gt;基本概念：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Pro Code：纯代码&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Low Code：低代码&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;No Code：无代码&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;LCAP：Low-Code Application Platform，低代码应用平台&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;LCDP：Low-Code Development Platform，低代码开发平台&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;HPAPaaS：High-Productivity Application Platform as a Service，高生产力PaaS平台&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在低代码概念引入之前，我们先看看纯代码（Pro Code）。&lt;/p&gt;&lt;p&gt;在日常的开发过程中，绝大多数的编程都是手写全部的代码，也就是大家常说的“&lt;strong&gt;纯代码&lt;/strong&gt;”（&lt;strong&gt;Pro Code&lt;/strong&gt;），要实现某一个功能，需要写全部的代码。有没有一种方法可以避免如 &lt;strong&gt;程序员门槛高、文档链路长、研发效率不够高&lt;/strong&gt; 等问题呢？&lt;/p&gt;&lt;p&gt;于是，可视化编程开始发光发热。可视化编程，就是可视化程序设计，通过少写代码，或者不写代码通过拖拽的方式生成。&lt;strong&gt;可视化编程的特点就是所见即所得、一站式研发、技术收敛，而且专业门槛低，对程序员小白相对友好。&lt;/strong&gt;&lt;strong/&gt;&lt;/p&gt;&lt;p&gt;关于可视化编程，主要分为两类，一是无代码，另外一个是低代码。&lt;/p&gt;&lt;h2&gt;Low Code 与 No Code的关系区分&lt;/h2&gt;&lt;p&gt;网上一搜索“低代码”相关的定义特别多，维基百科定义：低代码开发平台（LCAP）本身也是一种软件，它为开发者提供了&lt;strong&gt;一个创建应用软件的开发环境&lt;/strong&gt;；与传统编写代码的 IDE 不同，低代码开发平台提供&lt;strong&gt;更简单易用的可视化 IDE&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;在2019年的Gartner的Low-Code报告「&lt;span&gt;《Magic Quadrant for Enterprise Low-Code Application Platforms》&lt;/span&gt;」中，低代码平台被称为企业级低代码应用平台（Enterprise Low-Code Application Platform，Enterprise LCAP），是支持快速应用开发，使用陈述性、高级的编程抽象（如基于模型驱动和元数据编程语言）实现一站式应用部署、执行和管理的应用平台，不同于传统的应用平台，它支持用户界面、业务逻辑和数据服务的开发，并以牺牲跨平台的可移植性、应用开放性为代价来提高生产效率。&lt;/p&gt;&lt;p&gt;简单来讲，低代码（Low Code）就是&lt;strong&gt;一种可视化搭建系统&lt;/strong&gt;，从字面意思来讲，一是可视化，二是少写代码。无代码（No Code）同样从字面上来理解，一是可视化，二是不写代码。&lt;/p&gt;&lt;p&gt;No Code 和 Low Code 这两种的区别是，No Code 的是完全不需要写代码，而 Low Code 是需要写部分代码，整体通过拖拽的方式生成。&lt;/p&gt;&lt;p&gt;既然Low Code、No Code 这么方便，我是不是直接用它就好了，还写什么代码？&lt;/p&gt;&lt;p&gt;其实，不是这样的。虽然 Pro Code 有前文提到的缺点，但是它也有 Low Code、No Code 暂时无法取代的优点。Pro Code 的优势在于表达更精准、在封装的基础上更好的实现提效、更好的满足平台间的兼容性、更快的版本迭代；另外一方面，可视化搭建的场景只能覆盖解决一部分的对代码能力要求不是那么高的业务研发场景，有一些能力是配置不出来的，并不能完全取代Pro Code。总之，Pro Code、Low Code、No Code 之间不是替代消灭关系，⽽是互补加强关系。&lt;/p&gt;&lt;p&gt;同样的在Gartner的报告中，也对Low-Code和No-Code的关系进行了相对准确的解读：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;Gartner has covered low-code development for mobile apps used in the workplace under rapid mobile app development (RMAD) tools (see “Market Guide for Rapid Mobile App Development Tools”). We have also observed that no-code development tools are being marketed toward lines of business as a way for them to own their data applications. The idea is to “democratize” application development by enabling and facilitating citizen development (see “Citizen Development Success Depends on an Equal Partnership Between Business and IT Leaders”).However, the no-code tools targeted at minimally skilled citizen developers often end up requiring trained IT staff for certain use cases. Therefore, we consider no-code tooling as a subset of the larger low-code tool market, especially as enterprise-class low-code platforms increasingly strive to address both citizen and professional developers.&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;根据Gartner报告的定义，实际上No-Code的理念与Low-Code并不冲突。两者的关系可以认为是从属关系，即：No-Code（零代码）从属于Low-Code（低代码）的范畴，如果进行解释，可以认为：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;“所谓的”零代码产品，并未脱离低代码产品族群，而是低代码领域的子集；&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;低代码产品的前端UI构建方案中，重要的实现方式，就是通过零代码的理念或组件来完成UI的构建。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;发展历史&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5597826086956522&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qnAibK5Aia2dUMpqVfB4P2NS0picbKwS6kUCp78XzKZPTfyNwwzO0tTvsuN5PH5cFuRDyza7Rf8BNfCbghEm2ibXEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;920&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;LCAP的特性&lt;/h2&gt;&lt;p&gt;&lt;span&gt;回到Gartner的报告，其中提到了一份低代码领域的分支报告——&lt;/span&gt;&lt;span&gt;《Low-Code Development Technologies Evaluation Guide》&lt;/span&gt;&lt;span&gt;，这其中有一段对于Low-Code平台的横向对比标准的描述，也就是不同的供应商的产品，其在Low-Code能力方面，可以横向比对哪些因素。实际上，关于低代码平台的特性，也可以借由这些因素窥探一二。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8655913978494624&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qnAibK5Aia2dUMpqVfB4P2NS0picbKwS6kUHqicl2dFzKtKMJ6AjXDiatL1Se7ElXj9JLtibypfCwAyglLkMEMYAVKIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1860&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;如上图可见，Gartner列示了9个不同的比较因素，并在之后进行了归纳，说明了目前主流的Low-Code产品具备的能力，分为两个部分：1）通用技术能力：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;以&lt;strong&gt;模型/元数据&lt;/strong&gt;为驱动的UI实现方式，最好是通过零代码的方案实现&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;能够在线进行基本的数据结构（底层为数据库）的数据结构定义&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;支持以SOAP、REST或其他类型的API的方式实现对外部接口的调用&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;支持以API的方式，对外提供平台自身的数据/服务&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;支持模型、可视化的代码或业务流程的开发实现&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;高性能和低时延&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2）作为企业级平台的进阶能力：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;高扩展性，例如：用户数、交易量、数据量等&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;高可用性与灾难恢复「容灾」、自动扩缩容&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;应用访问、API、数据存储的安全性&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;部署SLA或支持运行时部署（PaaS类产品）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们可以借由此进行约定，符合上述的大部分能力要求的，可认为是Low-Code（低代码）平台。而在企业级应用解决方案中，会发现有不少传统IT人熟知的产品也是符合上述能力要求的，例如：BPM平台、iPaaS平台、国内的某些OA产品等。因此，在具体应用时，需根据组织自身的情况进行合理的选择。&lt;/p&gt;&lt;p&gt;简而言之，低代码（Low-Code）是指&lt;strong&gt;通过图形用户界面和配置，来代替传统的手工编码计算机程序来创建应用程序软件的平台。低码平台能够实现业务应用的快速交付，降低业务应用的开发成本。&lt;/strong&gt;&lt;/p&gt;&lt;h2&gt;HpaPaaS（高生产力应用PaaS）又是个啥&lt;/h2&gt;&lt;p&gt;上图可以看到，“Low-Code”一词是拜Forrester所赐。作为同样是国际知名调研机构（a.k.a 造词小能手）的Gartner，显然不会轻易在这场可能决定低代码领域江湖地位的新概念作词大赛中认输，于是也于2017年发明了“HpaPaaS”（High-productivity application Platform as a Service）这个听上去更高大上的缩写词。&lt;/p&gt;&lt;p&gt;&lt;span&gt;按照Gartner的定义，HpaPaaS是一种支持声明式、模型驱动设计和一键部署的平台，提供了云上的快速应用开发（RAD）、部署和运行特性；这显然与低代码的定义如出一辙。但事实证明，名字起得太专业并不见得是好事，“HpaPaas”最终还是败给了起源更早、更接地气也更顺口的“Low-Code”：从2019年开始，Gartner在其相关调研报告中也开始全面采用“Low-Code”一词（如LCAP），亲手为“HpaPaaS”打上了 @deprecated 印记。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.2861111111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qnAibK5Aia2dUMpqVfB4P2NS0picbKwS6kURTcf1PiagPSmyb4Dm0AQxfMxgLBcOPiapGJKico1ib0kn3EQNLiamj1liaAQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;图源：https://blog.kintone.com/business-with-heart/difference-saas-iaas-paas-apaas-hpapaas 一个图表来总结下三者的区别：&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;方式&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;No Code&lt;/td&gt;&lt;td&gt;基于模型和标准化的模板，通过可视化建模、搭建等轻量级配置完成应用开发，主要针对标准化场景，不需要写代码&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;上手快&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;交付快&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;犯错少&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;标准化&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;体验一致性 | 定制性差，非标准化场景实现比较困难，依赖具体的aPaaS平台，移植性差 | | Low Code | 在No Code的基础上，需要辅助写少量业务逻辑代码，比如：关联数据字段、绑定自定义动作等，也会通过WebIDE去编辑更多源码，但理念上是通过基础设施提供尽量多的功能，让开发者对底层实现无感，以减少写代码 | 相比Node Code拥有更大的定制性，开发者可以控制更多一点 | 依赖具体的aPaaS平台，开发者效率很大程度上受限于平台易用性 | | Pro Code | 使用WebIDE和DesktopIDE以源代码的方式开发应用，不完全依赖具体的平台，开发者需要关注更多底层实现，比如：调用远程服务等 |&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;专业程度高&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;灵活性更大&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;移植性强 | 容易形成人力瓶颈，其他角色想帮忙也使不上劲 |&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;直观感受&lt;/h2&gt;&lt;p&gt;据研究机构 Forrester 估计，低代码开发平台有着极其广阔的市场，可细分为数据库、请求处理、移动端、流程和通用低代码平台&lt;/p&gt;&lt;h3&gt;奥哲·氚云&lt;/h3&gt;&lt;p&gt;&lt;span&gt;面向数字化管理员的开发工具&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5282167042889391&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qnAibK5Aia2dUMpqVfB4P2NS0picbKwS6kUiavficyaskDVic0fRCYUFwkVFtXVedw8fNJ8XmZ7iaOSqmqib3KoFicw6luQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1772&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;宜搭&lt;/h3&gt;&lt;p&gt;&lt;span&gt;低代码的企业应用搭建SAAS平台-阿里巴巴旗下产品&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5684292379471229&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qnAibK5Aia2dUMpqVfB4P2NS0picbKwS6kUJthMkkbnX7fxWdPVib6KXm1ibJcKfmDiaEHAj4ibUZDLgxep1ibRWeNAwKA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1286&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5430769230769231&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qnAibK5Aia2dUMpqVfB4P2NS0picbKwS6kUXESSdibY2Ow4DkchfK2jn79giczz4W1Wia2OSy8KV9lB8PrJp2mJHibusQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1300&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;h3&gt;其他&lt;/h3&gt;&lt;p&gt;&lt;span&gt;实际上，low-code 平台的发展不局限于前端领域，移动 Native 客户端、服务端也有众多 low-code 探索。 &lt;/span&gt;&lt;span&gt;Xcode SwiftUI&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qnAibK5Aia2dUMpqVfB4P2NS0picbKwS6kUywZhqBH6LXfUBDoLFfTN3hqJwavuJ9dTfiaNtChIcvs3s2m1xz9bzibQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;920&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;VS Server Explorer&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4618249534450652&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qnAibK5Aia2dUMpqVfB4P2NS0picbKwS6kUKic8JwGfRy5j3AsiaGH9DeHBsHy1pUH0FXakKvXWCW46dibkXlgrK5AQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1611&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;以及&lt;/span&gt;&lt;span&gt;阿里云逻辑编排&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.3766937669376693&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qnAibK5Aia2dUMpqVfB4P2NS0picbKwS6kU2n3tw329RT9yoicZHbVTSk0DpaQqhBOJic6IicVAb7wXP4fSyp5Xfbe9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;738&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;h1&gt;第二部分：为什么需要/不需要低代码&lt;/h1&gt;&lt;blockquote&gt;&lt;p&gt;话题比较大，部分内容参考自：&lt;span&gt;什么是低代码（Low-Code）？&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2&gt;1、为什么「市场」需要低代码？&lt;/h2&gt;&lt;p&gt;一些基本调研数据：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;IDC预测，未来5年需开发5亿个新应用，这比过去40年开发的所有应用都多。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Gartner预测，到2021年应用开发需求的市场增⻓将至少超过企业IT交付能力的5倍。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;据2019年统计，全球IT技术开发者一共有2400万，其中中国的开发者数量是760万，远满足不了市场所需。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;有实际数据表明：企业创建应用程序的需求非常庞大，约86%的组织，难以找到所需的开发人员。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这个大爷大妈都满嘴“互联网+”和“数字化转型”的时代，企业越来越需要通过应用（App）来改善企业内部的信息流转、强化与客户之间的触点连接。然而，诞生还不太久的IT信息时代，也正面临着与我国社会主义初级阶段类似的供需关系矛盾：落后的软件开发生产力跟不上人民日益增长的业务需求。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4842592592592593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qnAibK5Aia2dUMpqVfB4P2NS0picbKwS6kUO0rW8chjJsapm6I2dmdHqBbolFIbRn1AmULbY1t1zq7EUexVXU4DdA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;Gartner预测，到2021年应用开发需求的市场增长将至少超过企业IT交付能力的5倍。面对如此巨大的IT缺口，如果没有一种革命性的“新生产力”体系，很难想象仅凭现有传统技术体系的发展延续就能彻底解决问题。而低代码技术正是带着这样的使命而降临，期望通过以下几个方面彻底革新应用开发生产力，拯救差一点就要迈入水深火热的IT世界：&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;提效降本 &amp;amp; 质量保障&lt;/h3&gt;&lt;p&gt;虽然软件行业一直在高速发展，新的语言、框架和工具层出不穷，但作为从业者我们不得不承认：软件开发仍处于手工作坊阶段，效率低、人力成本高、质量不可控：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;项目延期交付已成为行业常态，而瓶颈几乎总是开发人员（对机器能解决的问题都不是问题）；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;优秀的开发人才永远是稀缺资源，还贼贵；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;软件质量缺陷始终无法收敛，线上故障频发资损不断。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.32685185185185184&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qnAibK5Aia2dUMpqVfB4P2NS0picbKwS6kUzEJssiaSof8FiaP95Ugzs5sTlzZg7lY3ibdh7J9cibUSzBBmzYGiceCksPA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;而低代码正在将应用软件开发过程工业化：每个低代码开发平台都是一个技术密集型的应用工厂，所有项目相关人员都在同一条产线内紧密协作。开发主力不再是熟知for循环一百种写法的技术Geek，而是一群心怀想法业务sense十足的应用Maker。借助应用工厂中各种成熟的基础设施、现成的标准零件、自动化的装配流水线，开发者只需要专注于最核心的业务价值即可。即便是碰到非标需求，也可以随时自己动手，用最灵活的手工定制（代码）方式来解决各种边角问题。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;扩大应用开发劳动力&lt;/h3&gt;&lt;p&gt;&lt;span&gt;通过让大部分开发工作可以仅通过简单的拖拽与配置完成，低代码（包括零代码）显著降低了使用者门槛，让企业能够充分利用前面所提到的平民开发者资源。部分纯零代码需求场景下，低代码还能让业务人员实现自助式（self-service）应用交付，既解决了传统IT交付模式下的任务堆积（backlog）问题，避免稀缺的专业开发资源被大量简单、重复性的应用开发需求所侵占，也能让业务人员真正按自己的想法去实现应用，摆脱交由他人开发时不可避免的桎梏。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.31574074074074077&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qnAibK5Aia2dUMpqVfB4P2NS0picbKwS6kUPiaoEia2dsq2QXZGru1YIiaCudEvib5OdqCAeXojV7bzcJ9ibfRcn0YTPsg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;至此，应用开发能力不再是少数专业开发者的专利和特权，且今后所需要的技能门槛与拥有成本也会越来越低，真正实现所谓的“技术民主化”（democratization of technology）。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;加强开发过程的沟通协作&lt;/h3&gt;&lt;p&gt;&lt;span&gt;多方调查结果显示，软件项目失败的最主要原因之一就是缺乏沟通（poor communication）。传统开发模式下，业务、产品、设计、开发、测试与运维人员各司其职，且各有一套领域内的工具和语言，长久以来很容易形成一个个“竖井”（silos），让跨职能的沟通变得困难而低效。这也是为什么当前热门的敏捷开发和DevOps都在强调沟通（前者是协同Biz与Dev，而后者是协同Dev和Ops），而经典的DDD领域驱动设计也主张通过“统一语言”来减少业务与技术人员之间的沟通不一致。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3638888888888889&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qnAibK5Aia2dUMpqVfB4P2NS0picbKwS6kUerxG0ySJibWHmwLSD3veUTOjgR2ePj4x5Hl3dbsvLJTM1zCcLlWl9Jg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;有了低代码后，这一状况将得到根本改善：上述各角色都可以在同一个低代码开发平台上紧密协作（甚至可以是同一个人），这种全新的协作模式不仅打破了职能竖井，还能通过统一的可视化语言和单一的应用表示（页面/数据/逻辑），轻松对齐项目各方对应用形态和项目进度的理解，实现更终极的敏捷开发模式，以及在传统DevOps基础之上更进一步的BizDevOps。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;统一开发平台下的聚合效应&lt;/h3&gt;&lt;p&gt;低代码尝试将所有与应用开发相关活动都收敛到同一个平台（one platform）上后，将会产生更多方面的聚合效应与规模收益：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;人员聚合：除了上一点所提到的各职能角色紧密协作以外，人员聚合到统一的低代码开发平台进行作业后，还能促进整个项目流程的标准化、规范化和统一化。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;应用聚合：一方面，新应用的架构设计、资产复用、相互调用变得更容易；另一方面，各应用的数据都天然互通，同时平台外数据也能通过集成能力进行打通，彻底消除企业的数据孤岛问题。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;生态聚合：当低代码开发平台聚合了足够多的开发者和应用后，将形成一个巨大的、连接一切、有无限想象力的生态体系，彻底放飞低代码的价值。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;2、为什么「专业开发者」也需要低代码？&lt;/h2&gt;&lt;p&gt;&lt;span&gt;虽然零代码确实是设计给非专业开发者用的，但其所能支撑的业务场景确实有限，无法真正革新传统开发模式，替代那些仍需专业开发者参与的复杂业务场景。而狭义上的低代码却有潜力做到这一点，因为它天生就是为专业开发者而量身定制的。Gartner最近的一项调研报告显示，“66%的低代码开发平台用户都是企业IT部门的专业开发者”。这充分说明了，专业开发者比平民开发者更需要低代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;屏幕前一批穿格子衬衫的同学要发问了：“低代码都不怎么写代码了，怎么能算是为我们程序员服务呢？”。虽然程序员讨厌重复自己，但重要的事情还是得多说一遍：开发 ≠ 写代码。1万年前蹲在洞穴里的原始人，在用小石子画远古图腾；100年前坐在书桌前的徐志摩，在用钢笔给林徽因写情书；而今天趴在屏幕前的很多人，相信都已经开始用上手写板或iPad涂涂写写了。千百年来，人类使用的工具一直在演进，但所从事活动的本质并没有多大改变。无论是用小石子还是小鼠标，写作绘画的本质都是创造与表达，最终作品的好坏并不取决于当时你手中拿着什么；同样地，应用开发的本质是想法和逻辑，最终价值的高低也不取决你实现时是用的纯代码还是低代码。&lt;/p&gt;&lt;p&gt;而相比纯代码而言，低代码极有可能成为更好的下一代生产力工具：&lt;/p&gt;&lt;h3&gt;减少不必要的工作量&lt;/h3&gt;&lt;p&gt;可视化拖拽与参数配置的极简开发模式，结合模型驱动的代码自动生成机制，可以消灭绝大部分繁琐和重复的boilerplate代码；一站式的部署和运维管理平台，无需自己搭建CI/CD流水线、申请环境资源、配置监控报警；一次搭建同时生成、构建和发布多端应用，免去人工同步维护多个功能重复的端应用；开箱即用的组件库、模板库、主题库、连接器等，让最大化软件复用成为可能。总而言之，低代码能够让专业开发者更专注于创新性、有价值、有区分度的工作，而不是把宝贵开发时间都耗费在上面那些不必要的非业务核心工作上。&lt;/p&gt;&lt;h3&gt;强大的平台能力支撑&lt;/h3&gt;&lt;p&gt;虽然上面列的技术支撑性工作并不直接产生业务价值，但却会直接影响业务的性能、成本、稳定性、安全性、可持续发展能力等。有远见的企业，绝不允许牺牲这些重要指标，来换取短暂的业务加速。低代码开发平台深知这一点，因此在简化和屏蔽底层技术细节的同时，也会尽可能把自己所cover的部分做到最好（至少能和纯代码开发方式一样好），包括但不限于：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;现代化的技术架构和实现：现代化的低代码开发平台，在支撑用户应用时所选择的技术架构与实现方案，也会是现代化且符合业界最佳实践的，例如，前端基于主流的HTML5/CSS3标准和React框架，后端基于成熟的Java语言、SpringBoot框架和MySQL数据库，部署环境基于云原生的Docker镜像、CI/CD流水线、K8s集群和Service Mesh技术。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;零成本的技术升级和维护：低代码的高维抽象开发方式，让应用的核心业务逻辑与底层技术细节彻底解耦。开发者在大部分情况下都不需要关心底层技术选型，同时也无需亲自跟进这些技术的版本升级与漏洞修复，免费享受与时俱进的技术红利和应用安全性提升。即便遇到某些底层技术或工具需要进行彻底更换（比如不再维护的开源项目），开发者也完全不必感知；技术迁移再费劲再难搞，平台自己努力就行，对开发者来说只要服务一直在线，岁月就依然静好；事后可能还会惊喜地发现，应用访问突然就变得更快了，仿佛冥冥中自有天助，感激上苍和低代码。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;一体化生态能力复用&lt;/h3&gt;&lt;p&gt;&lt;span&gt;复用（Reuse）是提升软件开发效率和工程质量的最有效途径。传统的代码开发模式下，开发者可以通过提取公共类/函数、引用共享库、调用外部API服务、沉淀代码片段和模板等方式实现复用。在低代码的世界里，平台也可以提供对应的多层次多粒度复用手段，比如页面组件库、逻辑函数库、应用模板库等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;但更重要的是，低代码平台还可以充分发挥其一体化的生态优势，提供强大易用的可复用能力（资产）的发现、集成与共享体系：以页面组件为例，你可以直接用系统组件，也可以在平台自带的组件市场上搜索和引用更合适的组件，还可以自己用代码开发一个自定义组件并发布到市场中。平台的生态体系越大，积累的可复用能力就越多，应用的开发成本也会越低。&lt;/p&gt;&lt;p&gt;相比而言，虽然传统代码世界整体生态更庞大和深厚，但由于各类技术不互通、缺乏统一平台与市场、代码集成成本高等原因，一直以来都没有形成有类似规模潜力的生态能力复用体系，导致重复造轮子和低水平重复建设的现象司空见惯，还美名为“新基建”。&lt;/p&gt;&lt;p&gt;说到这里，另一批裹着冲锋衣头顶锃亮的同学也忍不住了：“万一低代码真的发展起来了，是不是就不需要那么多程序员了啊？上有老下有小的，同是码农身，相煎何太急！”。低代码虽然是一场应用开发生产力革命，但并不会革掉程序员的饭碗。它去掉的只是难懂的编程语法、繁琐的技术细节和一切可自动化的重复性工作，并没有也无法去掉应用开发最核心的东西：严谨的业务逻辑、巧妙的算法设计、良好的工程风格等。对于真正的程序员，即使剥去他一层又一层的编程语言和工具熟练度技能外壳，最终剩下的仍然是一个有价值的硬核开发者。&lt;/p&gt;&lt;p&gt;当然，如果你坚持要用纯粹的写代码方式来改变世界，也不至于失业。要么，你可以选择那些低代码暂时不太适用的领域，比如底层系统驱动、3D游戏引擎、火箭发射程序；或者，你也可以选择去写低代码中那一部分不可或缺的自定义代码扩展，为平民开发者提供高质量的积木。最后，你也完全可以选择为低代码平台本身的底层代码添砖加瓦。&lt;/p&gt;&lt;h2&gt;3、&lt;strong&gt;前端为什么需要 low-code？&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;近几年 low-code 理念在前端领域逐渐流行起来，主要有这些原因：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;被资源化的前端开发者：工作量大，但技术要求大多不高，生产效率成为了必须要解决的问题&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;开放的前端技术体系：low-code 类代码生成工具很容易与前端技术体系结合起来&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;趋于成熟的前端工程化体系：成熟稳定的前提下，才会转而追求变革式的生产效率突破&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;被资源化的前端开发者&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;面对大量低技术含量的需求，前端开发者就变成了极易替代的资源（就像低值易耗资产一样），前端人力进而成为产品需求迭代的瓶颈。此时，最好的解决办法是通过工具化、自动化的方式提高生产效率，突破前端资源瓶颈，自然就有了 low-code 方向的探索和实践，诸如 jQuery 时代的&lt;/span&gt;&lt;span&gt;表单生成器&lt;/span&gt;&lt;span&gt;、移动时代的 H5 页面制作工具&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;开放的前端技术体系&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;与移动 Native 客户端、服务端等技术相比，前端技术体系最为开放（甚至所有源码都是公开的），体现在：&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;第三方模块引入成本极低：无论布局容器、样式主题、逻辑模块、甚至整站，一行标签直接引进来就能用，甚至能够随时动态引入&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;拥有基于 Web 标准的开放生态：整个前端生态都建立在统一的标准层之上，任何一点创新都很容易累积起来，也总能站在巨人的肩膀上进一步创新&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;因此，low-code 平台得以站在巨人肩上前行，在组件库、构建工具、甚至可视化设计、代码自动生成的基础上进一步探索。另一方面，前端 low-code 产物都能应用到现有的任何前端应用程序中，无论生成的是 React/Vue 组件、jQuery 表单，还是&lt;span&gt;SPA（Single Page App）&lt;/span&gt;、MPA（Multiple Page App）&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;趋于成熟的前端工程化体系&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;既不在十几年前，也不在更远的将来，而是现在，为什么？最重要的一点，low-code 平台的发展是在前端工程化体系趋于成熟的背景之下，毕竟只有温饱问题都解决得差不多了，才能转而追求更高的生产效率。&lt;/p&gt;&lt;p&gt;从技术演进的角度来看，前端 low-code 探索与前端工程化的发展历程息息相关：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;前端工程化历经了这样几个阶段：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;CLI 工具：脚手架、构建工具、调试服务等等&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;GUI 客户端：GUI 化的 CLI 工具，除交互方式外区别不大&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;定制化端 IDE：基于 IDE 扩展脚手架、构建、调试、发布、监控等工程链路能力&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;云 IDE：基于 Web IDE 扩展一系列工程链路能力，进入云研发时代&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;（摘自&lt;span&gt;定制化 IDE 的核心价值&lt;/span&gt;）&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在 CLI/GUI 工具时代，编码层面的效率提升主要体现在通过脚手架自动生成模板代码，减少了样板代码的编写，让开发者码得更少；在接下来的端/云 IDE 时代，API 提示、自动补全、代码片段（Snippets）等实用功能也通通集成进来了，让开发者码得飞快；IDE 时代之后，编码层面的效率提升已经达到极致，更进一步的生产效率提升需要变革式的突破。于是，迎来了 low-code 时代，让非专业开发者也能“码”得又好又快。&lt;/p&gt;&lt;p&gt;从前端工程化的角度来看，low-code 是工程效率提升的重要方向（也是必经之路），不难发现其中的 low-code 演进痕迹：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;模型驱动设计：从直接操作 DOM 到数据驱动视图，提升代码可预测性&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;代码自动生成：从模板到代码片段到搭建，不断减少人工代码量&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;可视化编程：从组件拼装到拖拽生成，减少低效的重复工作&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;low-code 模式下新的可能性&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;可视化研发模式：复杂度转移到工具中，专业性要求降低&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;low-code 与智能化结合：素材/组件智能批量生成、结合端智能、个性化推荐等技术，让用户根本停不下来&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;low-code 打入专业开发工具：在面向专业开发者的 IDE 中提供部分可视化辅助工具，如支付宝小程序 IDE&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;前后端一体的 low-code 方案：在端云一体化开发的基础上更进一步，自动生成、部署相应的BFF/SFF代码&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;像云计算产品将专业的运维工作转移到了云供应商一样，low-code 模式将专业的组件开发工作、甚至 BFF 接口开发工作都转移到了可视化研发工具侧，把专业的前端技术以普惠的方式赋能给了更多的非专业开发者，同时可视化辅助工具与专业 IDE 相结合，也让专业的开发者更加高效。&lt;/p&gt;&lt;p&gt;另一方面，前端生产力和生产效率提上来、专业性要求降下去之后，之前受限于开发成本而无法实现的事情都可以开始探索了，比如面向海量细分用户群体的个性化 UI（所谓千人千面）、自媒体时代的个人建站（再小的个体也可以有自己的平台）、高时效性的百变运营（而不只是发条push消息）。&lt;/p&gt;&lt;h2&gt;4、低代码平台的难题和局限性&lt;/h2&gt;&lt;p&gt;技术没有银弹。Low-Code平台虽然有偌大的市场空间、极好的发展前景、诸多的平台优势，但依旧脱离不了其自身形态所带来的应用难题及适用场景的局限性。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;业务适配&lt;/strong&gt;：低代码平台在面向模型设计时模型和业务匹配度往往决定其上限。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;平台的易用性和业务灵活性难以调和：&lt;/strong&gt;过于简单的设计虽然方便使用遇到复杂场景时又会束手无策，而过于灵活的设计看起来功能强大又难免会让业务专家难上手。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;各种低代码平台很难形成统一的标准去开发和运营&lt;/strong&gt;，导致用户接入不同低代平台都需要学习成本。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;通用性受限&lt;/strong&gt;：对于&lt;strong&gt;复杂度极高的业务场景&lt;/strong&gt;低代码平台实现起来有些力不从心。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;5、为什么「我不」需要低代码&lt;/h2&gt;&lt;p&gt;&lt;span&gt;即使所有人都认同上述“为什么要用低代码”的理由，但仍不时会有试水者跳出来，给大家细数“为什么我不需要低代码”。实践出真知没错，而且大部分质疑背后也都有一定道理；但在我看来，更多的可能是主观或无意识的偏见。这里我列了一些对低代码的常见质疑和我个人的看法，期望能帮助大家看到一个更全面和客观的低代码。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;质疑1：低代码平台不好用&lt;/h3&gt;&lt;blockquote&gt;“试用过一些所谓的低代码开发平台，&lt;strong&gt;要么能力很弱&lt;/strong&gt;，&lt;strong&gt;要么体验太差&lt;/strong&gt;，只能开发点玩具应用。”&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;很多人调研过国内外多款低代码产品的深度体验用户，得到的观点是：&lt;strong&gt;不能以偏概全&lt;/strong&gt;。低代码市场在国内正处于爆发初期，所以许多与低代码只沾一点边的产品也都在蹭热点；但它们并不能代表低代码目前的业界水平和发展方向。市面上真正成熟的企业级低代码开发平台，完全有能力以高效的开发方式满足大部分复杂场景的功能需求，以及企业级应用所需要的安全、性能、可伸缩等非功能需求，这一点在国外市场已得到充分验证（不然也不会这么被寄予厚望）。&lt;/p&gt;&lt;p&gt;当然，国内市场尚处于鱼龙混杂的混战阶段，遇到真龙的概率很低，但碰上金鱼鲤鱼甚至木头假鱼都在所难免。相信随着时间推移，真正有实力和口碑的产品都能脱颖而出，为大家展现低代码该有的样子。&lt;/p&gt;&lt;h3&gt;质疑2：低代码开发不可控&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;黑盒：“平台上的各种可视化组件、逻辑动作和部署环境都是黑盒，如果内部出问题无法排查和解决。”&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;作为同样不搞清楚底层原理不舒服斯基的程序员，我更愿意相信：问题只是暂时的。虽然这确实是目前使用低代码平台时绕不开的一个痛点，但并不属于低代码技术本身的固有缺陷。计算机领域有一句至理名言：任何问题都可以通过增加一个间接的中间层来解决。低代码的思路亦是如此：与当年的操作系统和现在的云平台一样，都是想通过建立一个黑盒化的中间层抽象来降低开发者的工作量与心智负担。&lt;/p&gt;&lt;p&gt;当然，所有额外增加的中间层都不是完全免费的，低代码也不例外。作为一个尚未成熟稳定的新的中间层，低代码必然会出现各种让使用者束手无措的问题，就跟当年的操作系统内核bug、如今的云主机&lt;span&gt;磁盘I/O hang&lt;/span&gt;一样。但历史规律也告诉我们，所有伟大的技术最终都会走向成熟；只要低代码领域一直健康发展，问题总会越来越少，最终降到一个绝大部分人感知不到的范围内。过去萦绕在Windows用户心中挥之不去的“蓝屏”问题，对如今的新用户来说早已不知为何物；今天低代码开发者所遇到的种种“蓝瘦”问题，未来也终将成为被遗忘的历史（谁还没段黑历史呢）。&lt;/p&gt;&lt;h3&gt;质疑3：低代码应用难维护&lt;/h3&gt;&lt;blockquote&gt;&lt;p&gt;“应用一旦复杂起来，各种复杂逻辑流穿插着自定义代码，看不懂也改不动，还不如全用代码呢。”&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;用低代码开发，也是要讲基本法的。一般来说，无论是使用低代码开发还是纯代码开发，造成应用可维护性低的根本原因往往不在于开发工具，而是开发者自身没有去遵循一些软件开发的普适原则，比如工程规范性、命名可读性、DRY/KISS/SOLID原则等。&lt;/p&gt;&lt;p&gt;好的低代码平台绝不会阻碍开发者去改善应用的可维护性；恰恰相反，还会尽可能提供引导和帮助。以Mendix为例，除了支持基本的模型分析与重构（e.g. 无用模型、对象重命名、子逻辑流提取）以外，甚至还提供了基于ISO/IEC 25010标准的应用质量监控（AQM）能力。另一方面，让应用变得难以维护的一个客观原因也是应用本身过于复杂，而低代码作为高度抽象和自动化的开发模式，在降低应用复杂度方面是专业的。&lt;/p&gt;&lt;p&gt;综合来看，低代码虽然不是能解决一切问题的银弹，但更不是会带来更多问题的炸弹：在提高应用可维护性方面的上限，一定比传统开发模式更高；但决定应用可维护性下限的，依然还是开发者自己。&lt;/p&gt;&lt;h1&gt;第三部分：行业发展现状&lt;/h1&gt;&lt;p&gt;对于一个行业而言，判断它当前的表现是否够好，或者未来是否有潜力做到更好，可以从以下这三个方面进行衡量：市场规模（蛋糕够不够大）、适用场景（是否可落地）、竞品状况（有没有被验证过）。&lt;/p&gt;&lt;h2&gt;市场规模&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Forrester在2015年曾预测过，低代码的市场将从2015年的17亿美元增长至2020年的150亿美元。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Marketsandmarkets在今年四月份的分析报告中预测，低代码的市场将从2020年的130亿美元（估算值，可以看出来与Forrester当年的预测是接近的）增长到2025年的450亿美元（年复合增长率：28.1%）。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;PS Inteligence在2018年的分析报告中预测，全球的低代码开发平台市场中，亚太地区将在今后五年（2019-2024年）中保持最高的增长速度。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.46111111111111114&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qnAibK5Aia2dUMpqVfB4P2NS0picbKwS6kUPwffl8O1iaXR6UMiaicRiba6SVlzFGsjicjGMrgYKbNQfRUbzCzM9PHQzrA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;总结一下就是两点：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;低代码的市场规模足够大，且一直都在高速增长。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;作为亚太地区的经济大国与IT强国，中国的低代码市场将会迎来一个爆发期，未来几年内的增速都会超过全球平均水平。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;适用场景&lt;/h2&gt;&lt;p&gt;&lt;span&gt;理论上来说，低代码是完全对标传统纯代码的通用开发模式，应该有能力支撑所有可能的业务场景。但理论也只是理论，低代码一统江湖的梦想尚未照进现实，也不可能完全取代现实。前文中提到过，低代码与纯代码方式是互补关系，未来也将长期共存，各自在其所适合的业务场景中发光发热。同时还需要指出的是，当前阶段的低代码技术、产品和市场都尚未完全成熟，因此部分本来可能很适合用低代码来开发的场景，目前也只能先用纯代码来替代。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Gartner在2019年的低代码调研报告中，曾经绘制过一张用来阐述低代码适用场景的“应用金字塔”：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.40185185185185185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/qnAibK5Aia2dUMpqVfB4P2NS0picbKwS6kUAa0txvtKyXmKxWRac5eeVMQWeTEwcAjoicjIQQ6aE3ibxWiatsgwuRzag/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;应用级别划分&lt;/strong&gt;：从下往上，分别为工作组级（Workgroup Class）、部门级（Departmental Class）、企业级（Enterprise Class）、可扩展需求极强的企业级（Extreme-Scale Enterprise Class）。容易看出来，它主要的划分维度就是应用所面向的用户基数（基数越大，可扩展需求也越高），如：营销活动⻚面搭建、中后台系统⻚面搭建、小程序/跨端App的搭建&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;任务关键性&lt;/strong&gt;：从下往上，各级别应用的任务关键性（Mission Criticality）逐级递增。例如一个只在工作组内使用的后台管理应用，一般都不会涉及到影响整个企业的关键任务。脱离企业这个视角来看，整个软件产业中也有很多通用的任务关键型应用，比如：实时操作系统、航空调度系统、银行对账系统。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;实现复杂度&lt;/strong&gt;：从下往上，各级别应用的复杂度（Complexity）也逐级递增。例如最上层的企业级应用，除了功能覆盖面大导致业务复杂以外，往往还需要满足更多苛刻的非功能需求，包括但不限于：用户体验、性能、可靠性、安全性、可伸缩性、可维护性、兼容性。其他一些复杂软件的案例包括：3D游戏界面（交互复杂）极其底层的游戏引擎（逻辑复杂）、超大型CRM系统（一方面是实现很复杂，另一方面，这种成熟软件的标准化程度较高，大部分情况下可以直接用现成的SaaS软件）、少儿编程/学生编程。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;应用需求量&lt;/strong&gt;：从上往下，各级别应用的需求体量（Volume）逐级递增，呈现一个金字塔形状。这个特征可以用万能的2/8原则来理解：20%的“全民”应用，由于需求的通用性和普适性，可以覆盖至少80%的用户群体（例如企业大部分人都要用的考勤系统）；而剩下那80%的“小众”应用，由于需求的定制化和特殊性（例如未上市公司的期权系统...），就只能覆盖各自小圈子里那20%的用户了。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;与低代码的契合关系&lt;/strong&gt;：从上往下，各级别应用与低代码越来越契合（Relevant）。也就是说：&lt;strong&gt;越简单的应用，越契合低代码；越不太关键的任务，也越契合低代码&lt;/strong&gt;。同时，由于契合低代码的应用更偏金字塔底层，而这些应用的需求量都更大，所以可以得出如下判断：低代码能够适用于大部分业务场景（而且这个比例会一直上升，逐步往金字塔的更上层应用逼近），例如：B2E类应用（表单、审批流、ERP系统）、B2B类应用（企业商城、工业控制台）、B2C类应用（企业展示、营销页、店铺装修）。&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;竞品情况&lt;/h2&gt;&lt;p&gt;&lt;span&gt;下面是全球范围内做的比较靠前的几个竞品：&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Microsoft PowerApps：&lt;strong&gt;微软全家桶服务集成的非常好&lt;/strong&gt;，比如 Excel，全站写代码的地方都统一为 Excel 相似的概念 Formula/Fx，另外 PowerBI/PowerFlow 十分强大，定位 hpaPaaS (low-code)；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Google AppMaker：谷歌产，&lt;strong&gt;谷歌全家桶服务集成的非常好&lt;/strong&gt;，谷歌工程师文化在 SCRIPTS 体现得比较极致，无论是后端、前端都使用开发生态的 JS 语法，代码提示十分友好，定位 hpaPaaS (low-code)；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Salesforce SaaS：平台领头羊，集 IaaS、PaaS、SaaS 与一体的云平台，目前市值 1255 亿美元；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Sap：集 IaaS、PaaS、SaaS 与一体的云平台，相比 salesforce，使用的技术要新一些，体验上要好一些，目前市值 1577 亿美元；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;OutSystems：提供桌面 IDE，最近提供的 OutSystems AI 能够辅助模型设计，定位 hpaPaaS (low-code)，作为后起之秀，表现不俗，已获得多轮融资，在 2018 年估值 10+ 亿美元，俨然成为下一个独角兽。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;应用研发能力对比如下：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.9289617486338798&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qnAibK5Aia2dUMpqVfB4P2NS0picbKwS6kUiafDYn8xZEHNjicqEkT0vppaSPBdMia0mfj6wgtLAQw3jNicN7eGseODFw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;几点产品体验感受：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Google 和 Microsoft 老牌玩家玩 hpaPaaS 这一套相当得心应手，体验相当讲究，把自家的服务包括三方常用服务整合的非常好。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;OutSystems 类似微软，提供多种流式编排，很多时候不需要写代码，同时也整合了非常多数据服务，比如 Swagger 的 OpenAPI。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;Salesforce 和 SAP 类似，从单一的应用程序，到一套应用程序，到一个快速应用开发平台，企业协作工具，再到一个应用程序容器和数据库提供，提供了一套完整的生态链，以 SaaS、PaaS、IaaS 的分层方式对外输出。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;几点参考：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;高效整合才能降低成本，这是所有玩家的心智，不容质疑。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;视角要放大，要能够覆盖 90% 场景，必须要构建一套完整的生态链，从 no-code 到 low-code 再到 pro-code 都要有对应的解决方案，且要做到互相之间能够打通，这是 Salesforce 和 SAP 给到的经验，目前 AppMaker 和 PowerApps 主要针对表单、表格垂直领域，还不能够玩大，单一领域视角解决的问题有限。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;可视化的流式编排针对特定场景提效明显，应对稍微复杂一点的场景，一点也不好玩，比如 AppMaker 就粗暴一点，直接使用 SCRIPTS，书写表达式更舒服，不知道使用 OutSystems 的用户是什么感受。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;国内的几个经典案例：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;span&gt;国内低代码平台&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;类型&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;strong&gt;代表产品&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;业务复用型：根据产品形态常见的有：应用开发平台、智能表格、SaaS聚合。&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;应用开发平台&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;strong&gt;宜搭、简道云、明道云等&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.12371134020618557&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qnAibK5Aia2dUMpqVfB4P2NS0picbKwS6kUia9ZONd8IzczlkibrQM09yOA4KQTpNsz4b6YKdQ38uIqbVuXprJkFZpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1552&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;/td&gt;&lt;td&gt;宜搭：目标是为中小企业降低企业应用搭建成本。作为钉钉生态产品提供大量行业标准的应用模板，例如：CRM、财务管理、日常信息收集等，业务人员可以直接发布到自己的钉钉工作台快速投产；由于这些应用模板本事是基于丰富的标准化前端组件，业务人员经过简单文档学习，通过宜搭提供的可视化拖拉拽工具可以完成一定程度的业务定制。宜搭也试图突破边界，提供更深度的应用定制能力，虽然提供了JS编辑面板等代码编辑工具，但受限于原本产品定位，显得十分鸡肋。&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;智能表格&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;strong&gt;维格表、Treelab、轻流等&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.08975834292289989&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qnAibK5Aia2dUMpqVfB4P2NS0picbKwS6kUt7wlsN0ia2mrIRVGtkGGDAJxAyImVB9BdJaFAMsMBXxTgRMNt4g2WSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1738&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;/td&gt;&lt;td&gt;维格表：定位与主要产品目标与上面一条赛道基本相同，主要针对内部协作、项目管理信息收集一类的基础企业管理场景。而在产品形态上略有不同，这类智能表格型产品，延续了Excel经典的功能及交互逻辑，只要你用过Office里的Excel，这类产品上手就没有什么门槛。我个人是非常喜欢这条赛道的，定位极其精准。你可能想象不到中国有多少小微企业是依托一个Excel文件管理公司日常运营的，智能表格产品提供了无缝衔接的操作体验以及本地Excel所无法比拟的多人协作、高可用能力，很受小微团队欢迎。由于技术门槛相对较低，是很多小型创业团队的首选方向，但同样带来的是这个赛道竞争激烈，运营和渠道能力反而成为这个赛道的必考题。&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;SaaS聚合&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;strong&gt;Odoo、OpenERP&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.17375886524822695&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qnAibK5Aia2dUMpqVfB4P2NS0picbKwS6kUHL5L4jcviaoBvkYDlhwiciap6gl21kTb2wmtjbElAaHX66eibgOAWjzWVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1128&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;/td&gt;&lt;td&gt;Odoo：CRM、ERP领域的SaaS起家，在海外市场风靡一时。Odoo瞄准的是应用级的开箱即用，依托于多年的SaaS交付和生态社区发展，Odoo积累了一大批围绕企业管理场景的SaaS应用。在应用市场中，用户可以选择所需的管理软件，如财务、库存、人事、设备管理、园区巡检等，直接添加到自己的工作台。相比于购买不同厂家saas产品，企业获得了统一的工作台、数据接口、底层协议，无论是自己依照odoo开源框架还是增加其他应用都有很好的拓展性&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;开发工具型：顾名思义，主要针对的用户是IT开发人员，这类低代码产品的主要目标就是作为一个编码开发工具，提升IT人员开发效率。不同于业务复用型产品瞄准通用化需求，开发工具型产品对垂直领域的深度要求更高，顺应现在技术发展，也就分为了前端提效、后端提效，但都围绕一个核心，帮助开发人员减少重复、通用代码的编码工作，让开发人员更专注于业务逻辑代码的开发。&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;开发工具型的产品形成就相对更丰富一些：在线IDE、DSL开发框架、组件代码库。&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;IDE+DevOps&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;strong&gt;Mendix、AppCube、iVX&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.14201183431952663&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qnAibK5Aia2dUMpqVfB4P2NS0picbKwS6kUhoG9jslXF6YOQxmgGhmhfZ6O0icl9Aj1WEtSWdPGqicIicJPsP4f251zQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1690&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;/td&gt;&lt;td&gt;iVX：iVX官方给出的定义是“0代码开发语言”，目标用户是开发人员。iVX提供了一套完整的DevOps解决方案：通过iVX的在线IDE可以完成前端页面的可视化构建，iVX提供了常用的前端组件如按钮、图片、输入框等；也可以完成后端应用逻辑的编排，通过将逻辑代码模块化，定义了循环、动作、条件、回调等事件模块，通过可视化“拼装”+配置的方式完成传统意义上的逻辑代码编码；iVX直接打包了底层的IaaS资源，用户可以按需直接部署上线。通过iVX相对封闭的一套技术体系，用户可以通过可视化方式完成前端、后端代码编码、上线部署的完成软件生命周期。由于产品整体自成体系，学习成本非常高，就像iVX官方讲的那样，他们目标是培养一个新的工作岗位——iVX工程师。&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;DSL开发框架&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;strong&gt;Uni-app、双链AI软件云引擎等&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;figure&gt;&lt;img data-ratio=&quot;0.1414267834793492&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qnAibK5Aia2dUMpqVfB4P2NS0picbKwS6kUohAVhL7Zg5BOjzwNbDhVY6FT31Yg2AJQK6VsfyLKSl0eXLYptzcobA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1598&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;/td&gt;&lt;td&gt;Uni-app: 是DCloud一个基于Vue封装的前端开发框架，可以达到一次编码，多端适配。用户只需要编写一套预定的标记语言，框架即可生成可以适配各个用户端的前端代码，是一个典型的DSL产品。这类产品的优势是交付效率非常高，如果你熟悉了这套标记语言，可以以较高的效率交付一套相对标准或模板化的成熟应用代码，对交付型团队，这里的提效就意味着利润的增加。但同时，交付型团队普遍人员流动性高，这又与DSL需要学习成本的特性相矛盾。因此，很多DSL产品源自于团队自身提效，最终也止步于此。&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;组件代码库&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;strong&gt;BrickNext、Vant、ICE等&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.15748031496062992&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qnAibK5Aia2dUMpqVfB4P2NS0picbKwS6kUvjeVibhFPWSRBSlh8OSOco9sYK8qsSGhmic7ZTGibStkk3nAyNn2zcZfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1016&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;/td&gt;&lt;td&gt;BrickNext：优维科技旗下低代码开发工具，提供超过300个前端组件库，只需要配置yaml文件即可完成前端搭建。不同于element这类的开源前端组件，BrickNext基于前端原生开发方式，可以提供原子级的自定义能力，同时相较于element的通用型前端组件，BrickNext同时提供优维多年交付积累下来的业务前端组件。支持原子级修改是该产品的最大优势，但同时也是最大的问题，目前前端行业普遍采用Vue或React开发框架+element或其他前端组件的方式进行开发，基于原生的开发方式越来越少。&lt;/td&gt;&lt;td&gt;&lt;br/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;国内在大力投入Low Code的企业：&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0081845238095237&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qnAibK5Aia2dUMpqVfB4P2NS0picbKwS6kU0QLiaqXp73PmqCc1VlXzoXSykI5DNNkdW8qVRRWYXq315aBJ58n3jVQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1344&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;跟云☁️的结合&lt;/h2&gt;&lt;p&gt;我们都知道，云计算主要分为三大类服务：**软件即服务 (SaaS)、平台即服务 (PaaS) 和基础架构即服务 (IaaS)**。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;软件即服务 (SaaS)：是一种通过互联网交付应用的模式。客户能够通过 Web 浏览器访问 SaaS 应用，这意味着，客户无需购买、安装、维护和更新硬件或软件。SaaS 提供商负责确保一切顺利进行，而且客户通常能够使用最新版本的应用。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;平台即服务 (PaaS) ：能够提供云平台和各种工具，&lt;strong&gt;帮助开发人员构建和部署云应用&lt;/strong&gt;。用户可以通过 Web 浏览器访问 PaaS，所以企业无需购买和维护基础硬件和软件。借助 PaaS，开发人员还能采用租用的方式挑选所需的功能。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;采用基础架构即服务 (IaaS)，企业可以通过按使用付费的方式，“租用”服务器、网络、存储器和操作系统等计算资源。IaaS 提供商负责托管基础架构和处理系统维护及备份等任务，这样，客户就无需购买硬件或雇佣内部专家对其进行管理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在 PaaS 层有专门用来支持应用在云上开发、部署、运行的平台，称之为 aPaaS (Application platform as a service)，在 aPaaS 基础上，提供 no-code &amp;amp; low-code 方式开发应用的平台称之为 hpaPaaS (High-productivity aPaaS)，提供快速应用研发能力，比如业务编排、逻辑编排、模型驱动、页面编排等。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5601092896174863&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qnAibK5Aia2dUMpqVfB4P2NS0picbKwS6kU8IDv82BfFrV8q2SAyAK6JaRl7icKRs10g04N5ByoETKQ1dxIDchl4iaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;732&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;以腾讯的云开发CloudBase为例，是一个很好地结合云的能力的典型case。其打造的理念是：「&lt;/span&gt;&lt;strong&gt;云开发低码平台&lt;/strong&gt;&lt;span&gt;」，是&lt;/span&gt;&lt;strong&gt;由云开发团队打造的拖拽式低代码开发平台&lt;/strong&gt;&lt;span&gt;，整合了腾讯云海量云服务和微信端生态能力，助力政务、工业、教育、金融等垂直行业直通上云。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;云开发低码 LowCode通过「后端服务 &lt;span&gt;Serverless&lt;/span&gt; 化，免鉴权调用微信开放能力」等方式，&lt;strong&gt;为企业和开发者提供低开发门槛、快速构建多端应用的服务&lt;/strong&gt;，帮助企业在前后台营销场景和移动办公应用等方向构建业务应用；同时，云开发低码平台&lt;strong&gt;开放自定义组件和第三方数据源接入&lt;/strong&gt;，企业和开发者可以无缝对接集成旧有系统数据接口，无需改造，快速上云。&lt;/p&gt;&lt;p&gt;&lt;span&gt;具体来讲，云开发低码 LowCode &lt;/span&gt;&lt;strong&gt;将繁琐的底层架构和基础设施抽象化为图形界面&lt;/strong&gt;&lt;span&gt;，通过行业化模板、拖放式组件和可视化配置快速构建多端应用（小程序、H5应用、Web 应用等）。与传统手工编码模式相比，一方面免去了重复性的编码工作，另一方面进一步降低应用开发门槛，让企业和开发者快速开发出满足需求的应用。&lt;/span&gt;&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5148148148148148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/qnAibK5Aia2dUMpqVfB4P2NS0picbKwS6kUsRIddFxSnFicJrRIMmCofFicvKcbuBgc89Om3r7Lfw7ES3XliagMp9NOA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot; title=&quot;null&quot;/&gt;&lt;/figure&gt;&lt;p&gt;&lt;span&gt;有几个好处： &lt;/span&gt;&lt;strong&gt;1、降低开发门槛&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;开箱即用：&lt;/strong&gt;提供开箱即用的组件、模板和工具，多纬度支持持续性开发；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;多端发布&lt;/strong&gt;：拖拽一份页面可快速发布多端应用，支持小程序、H5、PC（支持“PC端”预计2月上线）等应用，多端数据自动同步。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;2、云原生支持&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;构建上云：&lt;/strong&gt;低码应用的构建过程和 Coding 深度集成，云端持续构建；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;strong&gt;部署上云：&lt;/strong&gt;低码应用的部署过程和 CloudBase Framework 深度集成，一键部署上云。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;3、数据源服务&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;数据源和云上资源（云数据库、云函数）深度集成，可无缝对接用户现有的后台系统数据，并基于数据快速生成业务表单/业务列表/组件；&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;天然集成云开发内容管理（CMS），方便应用的运营使用。&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;第四部分：Low Code结合智能化的新探索&lt;/h1&gt;&lt;p&gt;&lt;span&gt;在实际落地可视化搭建产品的过程中，逐步的也暴露出了非常多的问题：比如在使用层面上，&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;物料的缺失会导致一个页面可能难以搭建出来，针对于需要精准还原设计稿的场景只能通过原子化组件来一点点的搭建，效率就极为低下&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;可视化搭建画板的搭建效率、易用性等问题，这可能是可视化搭建落地过程中遇到的最痛的问题&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;复杂的可视化搭建画板的上手成本问题，不止是画板本身，也包括周边的各种配置等等&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在研发层面，基于前端组件的物料开发可能是整个活动生产过程中遇到的成本最高的一个问题。于是，基于「智能化搭建」探索的方式，尝试来一次性的解决上面遇到的所有问题。&lt;/p&gt;&lt;p&gt;可以看出：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;上传设计稿并基于平台的能力生成对应的页面结构后，运营or研发都可以在页面上对要进行成组or组件化的部分进行圈选，给到研发同学之后，研发就拿到了该组件的「语义化」的UI结构代码及样式代码，只需要添加逻辑代码「后续也会尝试自动生成，至少部分的自动生成」即可快速完成组件的研发生产；而且整个过程都可以是在线完成的，平台也会提供对应的在线WebIDE + 在线调试「支持Lynx」的能力，组件开发好后运营同学就可以把rd开发的组件拿到页面里进行替换了&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;基于设计稿可以自动的生成页面，而且期间会对页面的结构进行切割，基于图片分类算法模型自动的对既有的组件进行推荐，运营可以选择既有的组件进行替换，以及后续可以基于画板进行一些样式的微调及玩法等的配置，整个过程简单高效，成本极低&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;因为代码都是自动化生成的，而且生成的是贴近于研发的语义化代码，我们会直接提供对应搭建活动的在线预览地址，运营同学测试没问题后就可以直接发布上线了，无需关心周边的其他配置，而且搭建生成的是工程级别的应用，线上运行效率无折损&lt;/span&gt;&lt;/p&gt;&lt;h1&gt;参考&lt;/h1&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;一文看懂低代码的现状、打法、机会和挑战&lt;/span&gt;该文中有详细的case调研、解析&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;万字长文讲透低代码-InfoQ&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;深入看透低代码:阿里、腾讯等巨头火拼的下个风口-钛媒体官方网站&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;2021年 中国低代码行业短报告&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;钛媒体独家对话张建锋:钉钉的低代码革命-钛媒体官方网站&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;低代码平台浅析:钉钉宜搭 | 人人都是产品经理&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;钉钉用户超4亿，张建峰希望，未来三年长出1000万钉应用&lt;/span&gt;过去3年，阿里巴巴集团已通过宜搭构建了&lt;strong&gt;12700&lt;/strong&gt;个应用，其中绝大部分是由HR、财务等不具备开发经验的岗位员工搭建，这些应用通过钉钉集成后，形成了支撑阿里巴巴十几万人的工作平台。&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;什么是低代码（Low-Code）？&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;阿里云2.0来了 张建锋：让不懂代码的人也能用云的能力&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;终于来了！云开发低码 LowCode 平台正式开启公测&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;探索低代码的未来&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;2021年中国低代码行业报告&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4NzU0MDIzOQ==&amp;amp;mid=2247493253&amp;amp;idx=4&amp;amp;sn=40475f54f570d009df7555cef7eab048&amp;amp;scene=21#wechat_redirect&quot; title=&quot;2B领域下低代码的探索之路&quot; data-linktype=&quot;2&quot;&gt;2B领域下低代码的探索之路&lt;/a&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;&lt;span&gt;Low-code: Panacea or Revisited Hype?&lt;/span&gt;「Low-Code：灵丹妙药还是重温炒作？」&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>12ad7953af18eabad555b03b71a2bbfc</guid>
<title>Decorator 装饰器</title>
<link>https://toutiao.io/k/4m72ib3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;第 27 期前端食堂技术周刊视频版&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;https://www.bilibili.com/video/BV17q4y1i7zz&lt;/p&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为公众号推荐机制变更，如果不想错过食堂的文章，可以将食堂设置为星标，这样就会出现在你的公众号置顶列表里。设置星标方式：先进入公众号后台(点击本文标题下方蓝色的字“前端食堂”)，再点击右上角三个点，就可以看到设置星标啦。&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;给前端食堂标星标，吃好每一顿饭！&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;前言&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家在前端开发过程中有遇到过 &lt;code&gt;@ + 方法名&lt;/code&gt; 这种写法吗？当我第一次看到的时候，直接懵了，这是什么东东……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;遇到困难解决困难，在我的一番查找后，我知道了，原来这东西叫&lt;strong&gt;装饰器&lt;/strong&gt;，英文名叫 &lt;strong&gt;&lt;code&gt;Decorator&lt;/code&gt;&lt;/strong&gt; ，那它到底是干什么的呢？接下来就让我跟大家说道说道～&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;什么是装饰器&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;装饰者模式&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;装饰者模式就是能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责。打个比方，一个人在天气冷的时候要穿棉衣，天气热的时候穿短袖，可无论穿什么，本质上他还是一个人，只不过身上穿了不同的衣服。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以简单来说， &lt;code&gt;Decorator&lt;/code&gt; 就是一种动态地往一个类中添加新的行为的设计模式， 它可以在类运行时， 扩展一个类的功能， 并且去修改类本身的属性和方法， 使其可以在不同类之间更灵活的共用一些属性和方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;@&lt;/code&gt; 是针对这种设计模式的一个语法糖，不过目前还处于第 2 阶段提案中，使用它之前需要使用 Babel 模块编译成 ES5 或 ES6。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;怎么使用装饰器&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;三方库使用&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Babel 版本 ≥ 7.x&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果项目的 Babel 版本大于等于 7.x，那么可以使用 &lt;code&gt;@babel/plugin-proposal-decorators&lt;/code&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;安装&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;npm install --save-dev @babel/plugin-proposal-decorators&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;配置 .babelrc&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;  &lt;span&gt;&quot;plugins&quot;&lt;/span&gt;: [&lt;br/&gt;    [&lt;span&gt;&quot;@babel/plugin-proposal-decorators&quot;&lt;/span&gt;, { &lt;span&gt;&quot;legacy&quot;&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt; }],&lt;br/&gt;  ]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Babel 版本 ≤ 6.x&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果小于等于 6.x，则可以使用 &lt;code&gt;babel-plugin-transform-decorators-legacy&lt;/code&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;安装&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;npm install --save-dev @babel/plugin-proposal-decorators&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;配置 .babelrc&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;    &lt;span&gt;&quot;plugins&quot;&lt;/span&gt;: [&lt;span&gt;&quot;transform-decorators-legacy&quot;&lt;/span&gt;]&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;使用方法&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;装饰器的写法是 &lt;code&gt;@ + 返回装饰器函数的表达式&lt;/code&gt;，所以其使用方法如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@classDecorator&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TargetClass&lt;/span&gt; &lt;/span&gt;{ &lt;span&gt;// 类&lt;/span&gt;&lt;br/&gt;  @fieldDecorator&lt;br/&gt;  targetField = &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;// 类实例属性&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  @funDecorator&lt;br/&gt;  targetFun() { } &lt;span&gt;// 类方法&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;  @accessorDecorator&lt;br/&gt;  &lt;span&gt;get&lt;/span&gt; targetGetFun() { } &lt;span&gt;// 类访问器&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个对象使用多个装饰器，那么执行顺序是什么呢？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;decorator1&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;decorator1&#x27;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;decFn1&lt;/span&gt;(&lt;span&gt;targetClass&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;decFn1&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; targetClass;&lt;br/&gt;  };&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;decorator2&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;decorator2&#x27;&lt;/span&gt;);&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;decFn2&lt;/span&gt;(&lt;span&gt;targetClass&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;decFn2&#x27;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; targetClass;&lt;br/&gt;  };&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行顺序：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.17362817362817362&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vzEib9IRhZD67mAibPqbDoOluV2KjSNQLOnZHexjtLEIhYzNHXHzt0u67n1K6LQR7273eOvFiaiaS0XzRJYh36lr9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1221&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打印结果：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5759493670886076&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vzEib9IRhZD67mAibPqbDoOluV2KjSNQLOibv2ozatwI8p3EwAg9Efe0QRiaU6I66AHpg4vKMeHKEB7GsGhbVLpSdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;316&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据以上，我们可知，装饰器的执行顺序为由外向内进入，由内向外执行。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;使用范围&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据使用方法，我们可以看出装饰器可以应用于以下几种类型：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;类（class）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类实例属性（公共、私有和静态）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类方法（公共、私有和静态）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;类访问器（公共、私有和静态）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;函数的装饰&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们看完装饰器的使用方法和使用范围时，我们发现，装饰器不能修饰函数，那原因到底是什么呢？原因就是函数有&lt;strong&gt;函数提升&lt;/strong&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; num = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  num ++;&lt;br/&gt;}&lt;br/&gt;@add&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;fn&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这个例子中，我们想要在执行后让 num 等于 1，但其实结果并不是这样，因为函数提升，实际上代码是这样执行的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;add&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;  num ++;&lt;br/&gt;}&lt;br/&gt;@add&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;fn&lt;/span&gt;(&lt;span/&gt;) &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;var&lt;/span&gt; num;&lt;br/&gt;num = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一定要装饰函数的话，可以采用高阶函数的形式，这篇文章主要讲装饰器，有关高阶函数就不在此赘述了，不了解的小伙伴们可自行查阅资料哈～&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;装饰器原理&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据装饰器的使用范围，可以把它分为两大类：类的装饰与类方法的装饰，下面就让我为大家逐个分享一下。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;类的装饰&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;传参&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们先根据一个小例子看一下装饰器接收参数的情况：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;decorator&lt;/span&gt;(&lt;span&gt;...args&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  args.forEach(&lt;span&gt;(&lt;span&gt;arg, index&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`参数&lt;span&gt;${index}&lt;/span&gt;`&lt;/span&gt;, arg);&lt;br/&gt;  });&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;@decorator&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TargetClass&lt;/span&gt; &lt;/span&gt;{ }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;targetClass:&#x27;&lt;/span&gt;, TargetClass);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打印结果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.1287037037037037&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vzEib9IRhZD67mAibPqbDoOluV2KjSNQLOJLW8o08WoR1NmAcxRpFD1pYN6XiaiaxUB0FQeaslPzNJ2vPZjgOzAuPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到结果，我们发现装饰器只接收一个参数，就是被装饰的类定义本身。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;返回值&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们继续通过一个小例子来看返回值的情况：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;returnStr&lt;/span&gt;(&lt;span&gt;targetClass&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&#x27;hello world~&#x27;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;returnClass&lt;/span&gt;(&lt;span&gt;targetClass&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; targetClass;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;@returnStr&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ClassA&lt;/span&gt; &lt;/span&gt;{ }&lt;br/&gt;&lt;br/&gt;@returnClass&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;ClassB&lt;/span&gt; &lt;/span&gt;{ }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;ClassA:&#x27;&lt;/span&gt;, ClassA);&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;ClassB:&#x27;&lt;/span&gt;, ClassB);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.09314359637774904&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vzEib9IRhZD67mAibPqbDoOluV2KjSNQLO2YXsHFqAXGX0g9lZdVuOHWOyYNiaQA90dQyXf6AzJcliagBrQGeIN7BQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1546&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据结果，我们发现装饰器返回什么输出的就是什么。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;结论&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过以上的两个例子，我们可以得出以下这个结论：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;@decorator&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TargetClass&lt;/span&gt; &lt;/span&gt;{ }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 等同于&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TargetClass&lt;/span&gt; &lt;/span&gt;{ }&lt;br/&gt;TargetClass = decorator(TargetClass) || TargetClass;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以说，装饰器的第一个参数就是要装饰的类，它的功能就是对类进行处理。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;类装饰器的使用&lt;span/&gt;&lt;/h4&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;添加属性&lt;/p&gt;&lt;p&gt;因为装饰器接收的参数就是类定义本身，所以我们可以给类添加属性：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;addAttribute&lt;/span&gt;(&lt;span&gt;targetClass&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  targetClass.isUseDecorator = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;@addAttribute&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TargetClass&lt;/span&gt; &lt;/span&gt;{ }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(TargetClass.isUseDecorator); &lt;span&gt;// true&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这个例子中，我们定义了 &lt;code&gt;addAttribute&lt;/code&gt; 的装饰器，用于对 &lt;code&gt;TargetClass&lt;/code&gt; 添加 &lt;code&gt;isUseDecorator&lt;/code&gt; 标记，这个用法就跟 Java 中的注解比较相似，仅仅是对目标类型打上一些标记。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;返回装饰器函数的表达式&lt;/p&gt;&lt;p&gt;上面有说装饰器的写法是 &lt;code&gt;@ + 返回装饰器函数的表达式&lt;/code&gt;，也就是说，&lt;code&gt;@&lt;/code&gt; 后边可以不是一个方法名，还可以是&lt;strong&gt;能返回装饰器函数的表达式&lt;/strong&gt;：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;addAttribute&lt;/span&gt;(&lt;span&gt;content&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;decFn&lt;/span&gt;(&lt;span&gt;targetClass&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;    targetClass.content = content;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; targetClass;&lt;br/&gt;  };&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;@addAttribute(&lt;span&gt;&#x27;这是内容～～～&#x27;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TargetClass&lt;/span&gt; &lt;/span&gt;{ }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(TargetClass.content); &lt;span&gt;// 这是内容～～～&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们看到 &lt;code&gt;TargetClass&lt;/code&gt; 通过 &lt;code&gt;addAttribute&lt;/code&gt; 的装饰，添加了 &lt;code&gt;content&lt;/code&gt; 这个属性，并且可以向 &lt;code&gt;addAttribute&lt;/code&gt; 传参来给 &lt;code&gt;content&lt;/code&gt; 属性赋值，这种使用方法使装饰器变得更加灵活。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;添加原型方法&lt;/p&gt;&lt;p&gt;在前面的例子中我们添加的都是类的静态属性，但是既然装饰器接收的参数就是类定义本身，那么它也可以通过访问类的 &lt;code&gt;prototype&lt;/code&gt; 属性来添加或修改原型方法：&lt;/p&gt;&lt;pre&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;decorator&lt;/span&gt;(&lt;span&gt;targetClass&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  targetClass.prototype.decFun = &lt;span&gt;&lt;span&gt;function&lt;/span&gt; (&lt;span/&gt;) &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;这里是装饰器 decorator 添加的原型方法 decFun~&#x27;&lt;/span&gt;);&lt;br/&gt;  };&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;@decorator&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TargetClass&lt;/span&gt; &lt;/span&gt;{ }&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; targetClass = &lt;span&gt;new&lt;/span&gt; TargetClass();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(targetClass);&lt;br/&gt;targetClass.decFun();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果如下：&lt;/p&gt;&lt;figure&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.29745042492917845&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vzEib9IRhZD67mAibPqbDoOluV2KjSNQLOrJSibL4wGpOOwMVxAT41n7sUyWMvJcYxvodzYILMksRlib5fISoSibnxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;706&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是类装饰器的使用，由此我们可以得出，装饰器还可以对类型进行静态标记和方法扩展，还挺有用的对吧～那么看到这里，小伙伴们是不是发现了在实际项目中就有类装饰器的使用，比如 react-redux 的 connect 就是一个类装饰器、Antd 中的 Form.create 也是一个类装饰器。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// connect&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;App&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;React&lt;/span&gt;.&lt;span&gt;Component&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; connect(mapStateToProps, mapDispatchToProps)(App);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 等同于&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;@connect(mapStateToProps, mapDispatchToProps)&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;App&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;React&lt;/span&gt;.&lt;span&gt;Component&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// Form.create&lt;/span&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; WrappedApp = Form.create()(App);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 等同于&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;@Form.create()&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;App&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;React&lt;/span&gt;.&lt;span&gt;Component&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;类方法的装饰&lt;span/&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;传参&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们把类实例属性、类方法、类访问器都归到这一类中的原因其实是因为它们三个就是作为某个对象的属性(实例属性、原型方法、实例访问器属性)，也就是说它们接收的参数是类似的：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;decorator&lt;/span&gt;(&lt;span&gt;...args&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  args.forEach(&lt;span&gt;(&lt;span&gt;arg, index&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;`参数&lt;span&gt;${index}&lt;/span&gt;`&lt;/span&gt;, arg);&lt;br/&gt;  });&lt;br/&gt;  &lt;span&gt;console&lt;/span&gt;.log(&lt;span&gt;&#x27;****************&#x27;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;TargetClass&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  @decorator&lt;br/&gt;  field = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;  @decorator&lt;br/&gt;  fn() { }&lt;br/&gt;&lt;br/&gt;  @decorator&lt;br/&gt;  &lt;span&gt;get&lt;/span&gt; getFn() { }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; targetOne = &lt;span&gt;new&lt;/span&gt; TargetClass();&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(targetOne.field, &lt;span&gt;Object&lt;/span&gt;.getOwnPropertyDescriptor(targetOne, &lt;span&gt;&#x27;field&#x27;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;结果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4629032258064516&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vzEib9IRhZD67mAibPqbDoOluV2KjSNQLOmXBGsAc0RXExmnISqibL6tMrEWIicCRVUXCqlUuVTiaR0gAowvDYDI37g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1240&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据结果我们发现，类方法装饰器接收了三个参数：类定义对象、实例属性/方法/实例访问器属性名、属性操作符。眼熟吧，没错，它与 &lt;code&gt;Object.defineProperty()&lt;/code&gt; 接收的参数很像。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Object.defineProperty(obj, props, descriptor)&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Object.defineProperty()&lt;/code&gt; 的作用就是直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。该方法一共接收三个参数：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;要定义属性的对象&lt;/strong&gt;（obj）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;要定义或修改的属性名或 &lt;code&gt;Symbol&lt;/code&gt;&lt;/strong&gt; （props）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;要定义或修改的属性描述符&lt;/strong&gt;（descriptor）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而对象里目前存在的&lt;strong&gt;属性描述符&lt;/strong&gt;有两种主要形式：&lt;em&gt;数据描述符&lt;/em&gt;和&lt;em&gt;存取描述符&lt;/em&gt;。&lt;em&gt;数据描述符&lt;/em&gt;是一个具有值的属性，该值可以是可写的，也可以是不可写的；&lt;em&gt;存取描述符&lt;/em&gt;是由 getter 函数和 setter 函数所描述的属性。一个描述符只能是这两者其中之一，不能同时是两者。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它们共享以下可选键值：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;configurable&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;属性是否可以被删除和重新定义特性，默认值为 &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;enumerable&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;是否会出现在对象的枚举属性中，默认值为 &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据描述符特有键值：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;value&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;该属性对应的值，默认值为 &lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;writable&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;是否可以被更改，默认值为 &lt;code&gt;false&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;存取操作符特有键值：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;get&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;属性的 &lt;code&gt;getter&lt;/code&gt; 函数，如果没有 &lt;code&gt;getter&lt;/code&gt;，则为 &lt;code&gt;undefined&lt;/code&gt;；默认为 &lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;set&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;属性的 &lt;code&gt;setter&lt;/code&gt; 函数，如果没有 &lt;code&gt;setter&lt;/code&gt;，则为 &lt;code&gt;undefined&lt;/code&gt;；默认为 &lt;code&gt;undefined&lt;/code&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;讲完 &lt;code&gt;Object.defineProperty()&lt;/code&gt;，接下来就让我们看看该怎么使用它吧～&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;类方法装饰器的使用&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让我们通过一个例子来了解一下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;(&lt;span&gt;target, name, descriptor&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  descriptor.writable = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; descriptor;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Person&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  @readonly&lt;br/&gt;  name = &lt;span&gt;&#x27;zhangsan&#x27;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; person = &lt;span&gt;new&lt;/span&gt; Person();&lt;br/&gt;&lt;span&gt;console&lt;/span&gt;.log(person.name, &lt;span&gt;Object&lt;/span&gt;.getOwnPropertyDescriptor(person, &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;打印结果如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.03834355828220859&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vzEib9IRhZD67mAibPqbDoOluV2KjSNQLOIF9v7evNtRnpib6RHN71cibBsheC94l1bpJ5IxS7IGSsTCSfXf9rJVkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1304&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面代码说明，装饰器会修改属性的描述对象，然后被修改的描述对象再用来定义属性。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;结论&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此我们可以得出结论：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;changeName&lt;/span&gt;(&lt;span&gt;target, name, descriptor&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  descriptor.value = &lt;span&gt;&#x27;lisi&#x27;&lt;/span&gt;;&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; descriptor;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Person&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  @changeName&lt;br/&gt;  name = &lt;span&gt;&#x27;zhangsan&#x27;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; person = &lt;span&gt;new&lt;/span&gt; Person();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 等同于&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Person&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  name = &lt;span&gt;&#x27;zhangsan&#x27;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; person = &lt;span&gt;new&lt;/span&gt; Person();&lt;br/&gt;&lt;span&gt;Object&lt;/span&gt;.defineProperty(person, &lt;span&gt;&#x27;name&#x27;&lt;/span&gt;, {&lt;br/&gt;  &lt;span&gt;value&lt;/span&gt;: &lt;span&gt;&#x27;lisi&#x27;&lt;/span&gt;,&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;装饰器的应用&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在项目中，可能会遇到这样一种情况，好几个组件的数据都是调用同一个后端接口获得，只是传参不同，有些小伙伴们在写代码的时候可能就是每个组件都去手动调用一次后端接口（以 React 项目为例）：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;...&lt;br/&gt;export &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;CompOne&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Component&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;  getData = &lt;span&gt;async&lt;/span&gt; () =&amp;gt; { &lt;span&gt;// 调用后端接口&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; data = &lt;span&gt;await&lt;/span&gt; request(&lt;span&gt;&#x27;/xxx&#x27;&lt;/span&gt;, {&lt;br/&gt;      &lt;span&gt;params&lt;/span&gt;: {&lt;br/&gt;        &lt;span&gt;id&lt;/span&gt;: &lt;span&gt;&#x27;123&#x27;&lt;/span&gt;, &lt;span&gt;// 不同组件传参不同&lt;/span&gt;&lt;br/&gt;      },&lt;br/&gt;    });&lt;br/&gt;    &lt;span&gt;this&lt;/span&gt;.setState({ data });&lt;br/&gt;  }&lt;br/&gt;  render() {&lt;br/&gt;    ...&lt;br/&gt;    return (&lt;br/&gt;      &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        ...&lt;br/&gt;        我是组件一: {data}&lt;br/&gt;        ...&lt;br/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    )&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;遇到这种情况，我们就可以用装饰器解决呀～&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 装饰器&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;function&lt;/span&gt; &lt;span&gt;getData&lt;/span&gt;(&lt;span&gt;params&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;  &lt;span&gt;return&lt;/span&gt; &lt;span&gt;(&lt;span&gt;Comp&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;WrapperComponent&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Component&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;      ...&lt;br/&gt;      getData = &lt;span&gt;async&lt;/span&gt; () =&amp;gt; {&lt;br/&gt;        &lt;span&gt;const&lt;/span&gt; data = &lt;span&gt;await&lt;/span&gt; request(&lt;span&gt;&#x27;/xxx&#x27;&lt;/span&gt;, {&lt;br/&gt;          params,&lt;br/&gt;        });&lt;br/&gt;        &lt;span&gt;this&lt;/span&gt;.setState({ data });&lt;br/&gt;      }&lt;br/&gt;      render() {&lt;br/&gt;        ...&lt;br/&gt;        return (&lt;br/&gt;          &lt;span&gt;&amp;lt;&lt;span&gt;Comp&lt;/span&gt; &lt;span&gt;data&lt;/span&gt;=&lt;span&gt;{data}&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;        )&lt;br/&gt;      }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Comp;&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;// 组件&lt;/span&gt;&lt;br/&gt;...&lt;br/&gt;@getData({&lt;br/&gt;  &lt;span&gt;id&lt;/span&gt;: &lt;span&gt;&#x27;123&#x27;&lt;/span&gt;&lt;br/&gt;})&lt;br/&gt;&lt;span&gt;export&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;index&lt;/span&gt; &lt;span&gt;extends&lt;/span&gt; &lt;span&gt;Component&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;  ...&lt;br/&gt;  render() {&lt;br/&gt;    ...&lt;br/&gt;    const data = &lt;span&gt;this&lt;/span&gt;.props.data; &lt;span&gt;// 直接从 this.props 中获取想要的数据&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; (&lt;br/&gt;      &lt;span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;        ...&lt;br/&gt;        我是组件一: {data}&lt;br/&gt;        ...&lt;br/&gt;      &lt;span&gt;&amp;lt;/&lt;span&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;    )&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好啦，今天的分享就要到此结束了哦，希望通过这篇文章大家能够对装饰器有一定的了解，如有不同意见，欢迎在评论区评论呦～就让暴风雨来得更猛烈些吧！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考链接&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;装饰器（https://www.bookstack.cn/read/es6-3rd/docs-decorator.md）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ES7 提案: Decorators 装饰器（https://blog.csdn.net/weixin_44691608/article/details/117180409）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Object.defineProperty()（https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;babel-plugin-transform-decorators-legacy（https://www.npmjs.com/package/babel-plugin-transform-decorators-legacy）&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>