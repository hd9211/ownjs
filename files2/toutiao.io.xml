<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>4cd7d91bb18bf98c4dba14740a2cc106</guid>
<title>认识 MySQL 和 Redis 的数据一致性问题</title>
<link>https://toutiao.io/k/w79d4wj</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502257907&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：sinxu，腾讯 CSIG 后台开发工程师&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;1. 什么是数据的一致性&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“数据一致”一般指的是：缓存中有数据，缓存的数据值 = 数据库中的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但根据缓存中是有数据为依据，则”一致“可以包含两种情况：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;缓存中有数据，缓存的数据值 = 数据库中的值（需均为最新值，本文将“旧值的一致”归类为“不一致状态”）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;缓存中本没有数据，数据库中的值 = 最新值（有请求查询数据库时，会将数据写入缓存，则变为上面的“一致”状态）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;”数据不一致“：缓存的数据值 ≠ 数据库中的值；缓存或者数据库中存在旧值，导致其他线程读到旧数据&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2. 数据不一致情况及应对策略&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据是否接收写请求，可以把缓存分成读写缓存和只读缓存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只读缓存：只在缓存进行数据查找，即使用 “更新数据库+删除缓存” 策略；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读写缓存：需要在缓存中对数据进行增删改查，即使用 “更新数据库+更新缓存”策略。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.1 针对只读缓存（更新数据库+删除缓存）&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只读缓存：新增数据时，直接写入数据库；更新（修改/删除）数据时，先删除缓存。后续，访问这些增删改的数据时，会发生缓存缺失，进而查询数据库，更新缓存。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;新增数据时&lt;/strong&gt; ，写入数据库；访问数据时，缓存缺失，查数据库，更新缓存（始终是处于”数据一致“的状态，不会发生数据不一致性问题)&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502281707&quot; data-ratio=&quot;0.4581560283687943&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas78Lu5Owe8MKrobnYROVa4Q4CMeKuVZ9lxdH5boGdn199E3LkgCtyE5erib61ibtibiaLSUJkcLJtgnQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1410&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;更新（修改/删除）数据时&lt;/strong&gt; ，会有个时序问题：更新数据库与删除缓存的顺序（这个过程会发生数据不一致性问题）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502281704&quot; data-ratio=&quot;0.4624113475177305&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas78Lu5Owe8MKrobnYROVa4kdiaCD8VvpnfkUicpx6JrTXgZG2W7SKfvBt8zN6u2qWhpsrW4B1ibKBNA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1410&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在更新数据的过程中，可能会有如下问题：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;无并发请求下，其中一个操作失败的情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;并发请求下，其他线程可能会读到旧值&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此，要想达到数据一致性，需要保证两点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;无并发请求下，保证 A 和 B 步骤都能成功执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;并发请求下，在 A 和 B 步骤的间隔中，避免或消除其他线程的影响&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，我们针对有/无并发场景，进行分析并使用不同的策略。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;A. 无并发情况&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无并发请求下，在更新数据库和删除缓存值的过程中，因为操作被拆分成两步，那么就很有可能存在“步骤 1 成功，步骤 2 失败” 的情况发生（由于单线程中步骤 1 和步骤 2 是串行执行的，不太可能会发生 “步骤 2 成功，步骤 1 失败” 的情况）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;(1) 先删除缓存，再更新数据库&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502281706&quot; data-ratio=&quot;0.5196078431372549&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas78Lu5Owe8MKrobnYROVa4GXJHnh0HUPiaVLR9cZXfxf8mYjCKGs794CCswvibOOT8mhQ6phKKRxmQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1428&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;(2) 先更新数据库，再删除缓存&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502281705&quot; data-ratio=&quot;0.5289139633286318&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas78Lu5Owe8MKrobnYROVa4lh5OXwbl9PEFCQd5vrrGGdqhZcYEovpW8E7jKKrTgg7bfJfO64MCVg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1418&quot;/&gt;&lt;/figure&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502281703&quot; data-ratio=&quot;0.24721878862793573&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas78Lu5Owe8MKrobnYROVa4mL4PibMeZXHic5ZK75CdjdOmyRslWicFGBpPLdCT960QQWZLCeAibJPpJA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1618&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解决策略：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;a.消息队列+异步重试&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;无论使用哪一种执行时序，可以在执行步骤 1 时，将步骤 2 的请求写入消息队列，当步骤 2 失败时，就可以使用重试策略，对失败操作进行 “补偿”。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502281708&quot; data-ratio=&quot;0.8011869436201781&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas78Lu5Owe8MKrobnYROVa4QLwkeAo8Ako8OuO5RBAAe2Dc3VBBA1icW2njfgwBCibPiaEU865gib0NBw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1348&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;具体步骤如下：&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;把要删除缓存值或者是要更新数据库值操作生成消息，暂存到消息队列中（例如使用 Kafka 消息队列）；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当删除缓存值或者是更新数据库值操作成功时，把这些消息从消息队列中去除（丢弃），以免重复操作；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当删除缓存值或者是更新数据库值操作失败时，执行失败策略，重试服务从消息队列中重新读取（消费）这些消息，然后再次进行删除或更新；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;删除或者更新失败时，需要再次进行重试，重试超过的一定次数，向业务层发送报错信息。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;b.订阅 Binlog 变更日志&lt;/strong&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;创建更新缓存服务，接收数据变更的 MQ 消息，然后消费消息，更新/删除 Redis 中的缓存数据；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用 Binlog 实时更新/删除 Redis 缓存。利用 Canal，即将负责更新缓存的服务伪装成一个 MySQL 的从节点，从 MySQL 接收 Binlog，解析 Binlog 之后，得到实时的数据变更信息，然后根据变更信息去更新/删除 Redis 缓存；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;MQ+Canal 策略，将 Canal Server 接收到的 Binlog 数据直接投递到 MQ 进行解耦，使用 MQ 异步消费 Binlog 日志，以此进行数据同步；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管用 MQ/Canal 或者 MQ+Canal 的策略来异步更新缓存，对整个更新服务的数据可靠性和实时性要求都比较高，如果产生数据丢失或者更新延时情况，会造成 MySQL 和 Redis 中的数据不一致。因此，使用这种策略时，需要考虑出现不同步问题时的降级或补偿方案。&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;B. 高并发情况&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用以上策略后，可以保证在单线程/无并发场景下的数据一致性。但是，在高并发场景下，由于数据库层面的读写并发，会引发的数据库与缓存数据不一致的问题（本质是后发生的读请求先返回了）&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;(1) 先删除缓存，再更新数据库&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设线程 A 删除缓存值后，由于网络延迟等原因导致未及更新数据库，而此时，线程 B 开始读取数据时会发现缓存缺失，进而去查询数据库。而当线程 B 从数据库读取完数据、更新了缓存后，线程 A 才开始更新数据库，此时，会导致缓存中的数据是旧值，而数据库中的是最新值，产生“数据不一致”。其本质就是，本应后发生的“B 线程-读请求” 先于 “A 线程-写请求” 执行并返回了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502281709&quot; data-ratio=&quot;0.33908754623921084&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas78Lu5Owe8MKrobnYROVa45GW0u9QE39Uiagc0dTem03ooN2pMHFiamzOlXTe0GgyMeSlxzdJ2ibtYA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1622&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502281710&quot; data-ratio=&quot;0.3706896551724138&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas78Lu5Owe8MKrobnYROVa4HVbvqnfj05lWxxXPMiabYVfsvwNbhOocEroHJibHYfC2pZCFapkrdy9Q/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1624&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解决策略：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;a.设置缓存过期时间 + 延时双删&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过设置缓存过期时间，若发生上述淘汰缓存失败的情况，则在缓存过期后，读请求仍然可以从 DB 中读取最新数据并更新缓存，可减小数据不一致的影响范围。虽然在一定时间范围内数据有差异，但可以保证数据的最终一致性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，还可以通过延时双删进行保障：在线程 A 更新完数据库值以后，让它先 sleep 一小段时间，确保线程 B 能够先从数据库读取数据，再把缺失的数据写入缓存，然后，线程 A 再进行删除。后续，其它线程读取数据时，发现缓存缺失，会从数据库中读取最新值。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;redis.delKey(X)&lt;br/&gt;db.update(X)&lt;br/&gt;Thread.sleep(N)&lt;br/&gt;redis.delKey(X)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;sleep 时间：在业务程序运行的时候，统计下线程读数据和写缓存的操作时间，以此为基础来进行估算：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502281711&quot; data-ratio=&quot;0.32305795314426633&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas78Lu5Owe8MKrobnYROVa4ib4k3cT95icRascicOJhGoCSMk0UfeL9kiaES3joicYVoWfoSaBI497e2Cg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1622&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注意&lt;/strong&gt;：如果难以接受 sleep 这种写法，可以使用延时队列进行替代。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先删除缓存值再更新数据库，有可能导致请求因缓存缺失而访问数据库，给数据库带来压力，也就是缓存穿透的问题。针对缓存穿透问题，可以用缓存空结果、布隆过滤器进行解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;(2) 先更新数据库，再删除缓存&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果线程 A 更新了数据库中的值，但还没来得及删除缓存值，线程 B 就开始读取数据了，那么此时，线程 B 查询缓存时，发现缓存命中，就会直接从缓存中读取旧值。其本质也是，本应后发生的“B 线程-读请求” 先于 “A 线程-删除缓存” 执行并返回了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502281712&quot; data-ratio=&quot;0.29280397022332505&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas78Lu5Owe8MKrobnYROVa4xjC5YhxZDgjHSJQF5fyl03vibHTLuRzQrwWTTS46txy6cApZSj1hHCw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1612&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;或者，在”先更新数据库，再删除缓存”方案下，“读写分离 + 主从库延迟”也会导致不一致：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502281717&quot; data-ratio=&quot;0.5130111524163569&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas78Lu5Owe8MKrobnYROVa4yPMicFtkaENG6s1UiaVoDXxXqRU77deJ776hfsnrib6OIE1FPR6Ia7TMQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1614&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;a.延迟消息&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;b.订阅 binlog，异步删除&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过数据库的 binlog 来异步淘汰 key，利用工具(canal)将 binlog 日志采集发送到 MQ 中，然后通过 ACK 机制确认处理删除缓存。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;c.删除消息写入数据库&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过比对数据库中的数据，进行删除确认
先更新数据库再删除缓存，有可能导致请求因缓存缺失而访问数据库，给数据库带来压力，也就是缓存穿透的问题。针对缓存穿透问题，可以用缓存空结果、布隆过滤器进行解决。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;d.加锁&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;更新数据时，加写锁；查询数据时，加读锁
保证两步操作的“原子性”，使得操作可以串行执行。“原子性”的本质是什么？不可分割只是外在表现，其本质是多个资源间有一致性的要求，操作的中间状态对外不可见。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502281715&quot; data-ratio=&quot;0.42926356589147285&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas78Lu5Owe8MKrobnYROVa4qo2wlxdG9qjybHDvoqfd8EPf4ZxrvHMPlmKIQtSMLQicfuTSDfFXdTg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;2064&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;建议：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优先使用“先更新数据库再删除缓存”的执行时序，原因主要有两个：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;先删除缓存值再更新数据库，有可能导致请求因缓存缺失而访问数据库，给数据库带来压力；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;业务应用中读取数据库和写缓存的时间有时不好估算，进而导致延迟双删中的 sleep 时间不好设置。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.2 针对读写缓存（更新数据库+更新缓存）&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读写缓存：增删改在缓存中进行，并采取相应的回写策略，同步数据到数据库中&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;同步直写：使用事务，保证缓存和数据更新的原子性，并进行失败重试（如果 Redis 本身出现故障，会降低服务的性能和可用性）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异步回写：写缓存时不同步写数据库，等到数据从缓存中淘汰时，再写回数据库（没写回数据库前，缓存发生故障，会造成数据丢失）
该策略在秒杀场中有见到过，业务层直接对缓存中的秒杀商品库存信息进行操作，一段时间后再回写数据库。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一致性：同步直写 &amp;gt; 异步回写
因此，对于读写缓存，要保持数据强一致性的主要思路是：利用同步直写
同步直写也存在两个操作的时序问题：更新数据库和更新缓存&lt;/p&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;A. 无并发情况&lt;/span&gt;&lt;/h5&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502281714&quot; data-ratio=&quot;0.24444444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas78Lu5Owe8MKrobnYROVa4ibFLnCYibGP5cGPUEVYbU8KaElKGKLIZp472zprofC9tGfE5icsXKSSlA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1620&quot;/&gt;&lt;/figure&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;B. 高并发情况&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有四种场景会造成数据不一致：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502281713&quot; data-ratio=&quot;1.010185185185185&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas78Lu5Owe8MKrobnYROVa4sic3u4RpyopslNuoHJog8dNjfSw5IllRh1icPWa7el9y9UeZJzBzIzKg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对场景 1 和 2 的解决方案是：保存请求对缓存的读取记录，延时消息比较，发现不一致后，做业务补偿
针对场景 3 和 4 的解决方案是：对于写请求，需要配合分布式锁使用。写请求进来时，针对同一个资源的修改操作，先加分布式锁，保证同一时间只有一个线程去更新数据库和缓存；没有拿到锁的线程把操作放入到队列中，延时处理。用这种方式保证多个线程操作同一资源的顺序性，以此保证一致性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502281716&quot; data-ratio=&quot;0.3776824034334764&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas78Lu5Owe8MKrobnYROVa403BuzrjFuhp0iaoYwnNY7VGLLkXrWIdh7CTHTgDZHBf1ym4g4jNazJA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1398&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中，分布式锁的实现可以使用以下策略：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502281718&quot; data-ratio=&quot;0.30816831683168316&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas78Lu5Owe8MKrobnYROVa4B0e7MeibIiapm9C3av9xSAg3sQwsOahm5mAB0XFsSb2NPsw48O3lVHow/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1616&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.3 强一致性策略&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上述策略只能保证数据的最终一致性。要想做到强一致，最常见的方案是 2PC、3PC、Paxos、Raft 这类一致性协议，但它们的性能往往比较差，而且这些方案也比较复杂，还要考虑各种容错问题。如果业务层要求必须读取数据的强一致性，可以采取以下策略：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（1）暂存并发读请求&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在更新数据库时，先在 Redis 缓存客户端暂存并发读请求，等数据库更新完、缓存值删除后，再读取数据，从而保证数据一致性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（2）串行化&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读写请求入队列，工作线程从队列中取任务来依次执行&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;修改服务 Service 连接池，id 取模选取服务连接，能够保证同一个数据的读写都落在同一个后端服务上&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;修改数据库 DB 连接池，id 取模选取 DB 连接，能够保证同一个数据的读写在数据库层面是串行的&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;（3）使用 Redis 分布式读写锁&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将淘汰缓存与更新库表放入同一把写锁中，与其它读请求互斥，防止其间产生旧数据。读写互斥、写写互斥、读读共享，可满足读多写少的场景数据一致，也保证了并发性。并根据逻辑平均运行时间、响应超时时间来确定过期时间。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;public void &lt;span&gt;write&lt;/span&gt;() {&lt;br/&gt;    Lock writeLock = redis.getWriteLock(lockKey);&lt;br/&gt;    writeLock.lock();&lt;br/&gt;    try {&lt;br/&gt;        redis.delete(key);&lt;br/&gt;        db.update(record);&lt;br/&gt;    } finally {&lt;br/&gt;        writeLock.unlock();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public void &lt;span&gt;read&lt;/span&gt;() {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (caching) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;    // no cache&lt;br/&gt;    Lock readLock = redis.getReadLock(lockKey);&lt;br/&gt;    readLock.lock();&lt;br/&gt;    try {&lt;br/&gt;        record = db.get();&lt;br/&gt;    } finally {&lt;br/&gt;        readLock.unlock();&lt;br/&gt;    }&lt;br/&gt;    redis.set(key, record);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;2.4 小结&lt;/span&gt;&lt;/h4&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502281719&quot; data-ratio=&quot;0.5018587360594795&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas78Lu5Owe8MKrobnYROVa4JEX6eVZpqcwveIicoiapQfoMdndiaNplFOEpicKMQJfFNVPZVNIJdsBzzw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1614&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对读写缓存时：同步直写，更新数据库+更新缓存：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502281720&quot; data-ratio=&quot;0.7443142660234321&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas78Lu5Owe8MKrobnYROVa4MMibYib0VzuRoJPoqL9OWdnXEtWsh6WEzO58wDkx2Ww6HaZbIm37cq0g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1451&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;针对只读缓存时：更新数据库+删除缓存：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502281722&quot; data-ratio=&quot;0.588380716934487&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas78Lu5Owe8MKrobnYROVa4DyBXp3BZhGLP41VfibRwJLicEOzSWDoPZEp4dt0fDyXd2eUiaIWVkNqfg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1618&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;较为通用的一致性策略拟定：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在并发场景下，使用 “更新数据库 + 更新缓存” 需要用分布式锁保证缓存和数据一致性，且可能存在”缓存资源浪费“和”机器性能浪费“的情况；一般推荐使用 “更新数据库 + 删除缓存” 的方案。如果根据需要，热点数据较多，可以使用 “更新数据库 + 更新缓存” 策略。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 “更新数据库 + 删除缓存” 的方案中，推荐使用推荐用 “先更新数据库，再删除缓存” 策略，因为先删除缓存可能会导致大量请求落到数据库，而且延迟双删的时间很难评估。在 “先更新数据库，再删除缓存” 策略中，可以使用“消息队列+重试机制” 的方案保证缓存的删除。并通过 “订阅 binlog” 进行缓存比对，加上一层保障。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，需要通过初始化缓存预热、多数据源触发、延迟消息比对等策略进行辅助和补偿。【多种数据更新触发源：定时任务扫描，业务系统 MQ、binlog 变更 MQ，相互之间作为互补来保证数据不会漏更新】&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;3. 数据一致性中需要注意的其他问题有哪些？&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;(1) k-v 大小的合理设置&lt;/strong&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;strong&gt;Redis key 大小设计：&lt;/strong&gt;由于网络的一次传输 MTU 最大为 1500 字节，所以为了保证高效的性能，建议单个 k-v 大小不超过 1KB，一次网络传输就能完成，避免多次网络交互；k-v 是越小性能越好&lt;strong&gt;Redis 热 key：&lt;/strong&gt;（1） 当业务遇到单个读热 key，通过增加副本来提高读能力或是用 hashtag 把 key 存多份在多个分片中；（2）当业务遇到单个写热 key，需业务拆分这个 key 的功能，属于设计不合理- 当业务遇到热分片，即多个热 key 在同一个分片上导致单分片 cpu 高，可通过 hashtag 方式打散——[引自腾讯云技术分享]&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;(2 )避免其他问题导致缓存服务器崩溃，进而简直导致数据一致性策略失效&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存穿透、缓存击穿、缓存雪崩、机器故障等问题：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-fileid=&quot;502281721&quot; data-ratio=&quot;0.6444444444444445&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvas78Lu5Owe8MKrobnYROVa4RxibPxc16qx8OZHCDBBVj7YzxCUUwMRw49NK8iacicHdiaK7pSQvrNkPjQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1620&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;(3)方案选定的思路&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;确定缓存类型（读写/只读）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;确定一致性级别&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;确定同步/异步方式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;选定缓存流程&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;补充细节&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h3&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;https://xie.infoq.cn/article/1322475e05c11bd2aacd8bc73&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;https://www.infoq.cn/article/Hh4IOuIiJHWB4X46vxeO&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;https://time.geekbang.org/column/article/217593&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;https://xie.infoq.cn/article/ab2599366009928a17fe498fb&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://mp.weixin.qq.com/s?spm=a2c6h.12873639.0.0.2020fe8dDvjfTJ&amp;amp;__biz=MjM5ODYxMDA5OQ==&amp;amp;mid=404202261&amp;amp;idx=1&amp;amp;sn=1b8254ba5013952923bdc21e0579108e&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;缓存与数据库一致性保证&quot; linktype=&quot;text&quot; imgurl=&quot;&quot; tab=&quot;outerlink&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;缓存与数据库一致性保证&lt;/span&gt;&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;https://time.geekbang.org/column/article/295812&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;https://blog.csdn.net/chengh1993/article/details/112685774&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;https://juejin.cn/post/6850418120201666568&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a8b2548630110a411223e2068bab34d8</guid>
<title>用 Java 轻松完成一个分布式事务 TCC，保姆级教程</title>
<link>https://toutiao.io/k/jaxfhme</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;什么是TCC，TCC是Try、Confirm、Cancel三个词语的缩写，最早是由 Pat Helland 于 2007 年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。&lt;/p&gt;&lt;h2&gt;TCC组成&lt;/h2&gt;&lt;p&gt;TCC分为3个阶段&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;Try 阶段：尝试执行，完成所有业务检查（一致性）, 预留必须业务资源（准隔离性）&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Confirm 阶段：如果所有分支的Try都成功了，则走到Confirm阶段。Confirm真正执行业务，不作任何业务检查，只使用 Try 阶段预留的业务资源&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Cancel 阶段：如果所有分支的Try有一个失败了，则走到Cancel阶段。Cancel释放 Try 阶段预留的业务资源。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;TCC分布式事务里，有3个角色，与经典的XA分布式事务一样：&lt;/p&gt;&lt;p&gt;如果我们要进行一个类似于银行跨行转账的业务，转出（TransOut）和转入（TransIn）分别在不同的微服务里，一个成功完成的TCC事务典型的时序图如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.169179229480737&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9m9OfQX94VvJvhjNGBvp23oCHMicZHFfWZ9zwPQIlhiabFoTcTE9W4pPePuiahLmkCyDctJceps7ic68qWBgeV3hbQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1194&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;h2&gt;TCC实践&lt;/h2&gt;&lt;p&gt;下面我们进行一个TCC事务的具体开发&lt;/p&gt;&lt;p&gt;我们的例子使用的分布式事务框架为dtm，它对分布式事务的支持非常优雅。下面来详细讲解TCC的组成&lt;/p&gt;&lt;p&gt;下面我们来编写具体的Try/Confirm/Cancel的处理函数&lt;/p&gt;&lt;pre&gt;&lt;span&gt;@RequestMapping(&quot;TransOutTry&quot;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, String&amp;gt; &lt;span&gt;TransOutTry&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; {&lt;br/&gt;        logger.info(&lt;span&gt;&quot;TransOutTry&quot;&lt;/span&gt;);&lt;br/&gt;        Map&amp;lt;String, String&amp;gt; result = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;HashMap&lt;/span&gt;&amp;lt;&amp;gt;();&lt;br/&gt;        result.put(&lt;span&gt;&quot;dtm_result&quot;&lt;/span&gt;, &lt;span&gt;&quot;SUCCESS&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@RequestMapping(&quot;TransOutConfirm&quot;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, String&amp;gt; &lt;span&gt;TransOutConfirm&lt;/span&gt;&lt;span&gt;(HttpServerResponse response)&lt;/span&gt; {&lt;br/&gt;        logger.info(&lt;span&gt;&quot;TransOutConfirm&quot;&lt;/span&gt;);&lt;br/&gt;        Map&amp;lt;String, String&amp;gt; result = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;HashMap&lt;/span&gt;&amp;lt;&amp;gt;();&lt;br/&gt;        result.put(&lt;span&gt;&quot;dtm_result&quot;&lt;/span&gt;, &lt;span&gt;&quot;SUCCESS&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@RequestMapping(&quot;TransOutCancel&quot;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, String&amp;gt; &lt;span&gt;TransOutCancel&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; {&lt;br/&gt;        logger.info(&lt;span&gt;&quot;TransOutCancel&quot;&lt;/span&gt;);&lt;br/&gt;        Map&amp;lt;String, String&amp;gt; result = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;HashMap&lt;/span&gt;&amp;lt;&amp;gt;();&lt;br/&gt;        result.put(&lt;span&gt;&quot;dtm_result&quot;&lt;/span&gt;, &lt;span&gt;&quot;SUCCESS&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@RequestMapping(&quot;TransInTry&quot;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, String&amp;gt; &lt;span&gt;TransInTry&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; {&lt;br/&gt;        logger.info(&lt;span&gt;&quot;TransInTry&quot;&lt;/span&gt;);&lt;br/&gt;        Map&amp;lt;String, String&amp;gt; result = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;HashMap&lt;/span&gt;&amp;lt;&amp;gt;();&lt;br/&gt;        result.put(&lt;span&gt;&quot;dtm_result&quot;&lt;/span&gt;, &lt;span&gt;&quot;SUCCESS&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@RequestMapping(&quot;TransInConfirm&quot;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, String&amp;gt; &lt;span&gt;TransInConfirm&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; {&lt;br/&gt;        logger.info(&lt;span&gt;&quot;TransInConfirm&quot;&lt;/span&gt;);&lt;br/&gt;        Map&amp;lt;String, String&amp;gt; result = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;HashMap&lt;/span&gt;&amp;lt;&amp;gt;();&lt;br/&gt;        result.put(&lt;span&gt;&quot;dtm_result&quot;&lt;/span&gt;, &lt;span&gt;&quot;SUCCESS&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@RequestMapping(&quot;TransInCancel&quot;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, String&amp;gt; &lt;span&gt;TransInCancel&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; {&lt;br/&gt;        logger.info(&lt;span&gt;&quot;TransInCancel&quot;&lt;/span&gt;);&lt;br/&gt;        Map&amp;lt;String, String&amp;gt; result = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;HashMap&lt;/span&gt;&amp;lt;&amp;gt;();&lt;br/&gt;        result.put(&lt;span&gt;&quot;dtm_result&quot;&lt;/span&gt;, &lt;span&gt;&quot;SUCCESS&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;/pre&gt;&lt;p&gt;到此各个子事务的处理函数已经OK了，然后是开启TCC事务，进行分支调用&lt;/p&gt;&lt;pre&gt;       &lt;span&gt;@RequestMapping(&quot;fireTcc&quot;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; String &lt;span&gt;fireTcc&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; {&lt;br/&gt;        Function&amp;lt;Tcc, Boolean&amp;gt; function = TccController::tccTrans;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; tcc.tccGlobalTransaction(function);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Boolean &lt;span&gt;tccTrans&lt;/span&gt;&lt;span&gt;(Tcc tcc)&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;a&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; tcc.callBranch(&lt;span&gt;&quot;&quot;&lt;/span&gt;, svc + &lt;span&gt;&quot;/TransOutTry&quot;&lt;/span&gt;, svc + &lt;span&gt;&quot;/TransOutConfirm&quot;&lt;/span&gt;, svc + &lt;span&gt;&quot;/TransOutCancel&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;b&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; tcc.callBranch(&lt;span&gt;&quot;&quot;&lt;/span&gt;, svc + &lt;span&gt;&quot;/TransInTry&quot;&lt;/span&gt;, svc + &lt;span&gt;&quot;/TransInConfirm&quot;&lt;/span&gt;, svc + &lt;span&gt;&quot;/TransInCancel&quot;&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; a &amp;amp;&amp;amp; b;&lt;br/&gt;        } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    }&lt;/pre&gt;&lt;p&gt;至此，一个完整的TCC分布式事务编写完成。&lt;/p&gt;&lt;p&gt;如果您想要完整运行一个成功的示例，那么参考这个例子yedf/dtmcli-java-sample，将它运行起来非常简单&lt;/p&gt;&lt;pre&gt;&lt;span&gt;# 部署启动dtm&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 需要docker版本18以上&lt;/span&gt;&lt;br/&gt;git &lt;span&gt;clone&lt;/span&gt; https://github.com/yedf/dtm&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; dtm&lt;br/&gt;docker-compose up&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 另起一个命令行&lt;/span&gt;&lt;br/&gt;git &lt;span&gt;clone&lt;/span&gt; https://github.com/yedf/dtmcli-java-sample.git&lt;br/&gt;&lt;span&gt;cd&lt;/span&gt; dtmcli-java-sample&lt;br/&gt;&lt;span&gt;# 编译运行例子 main/src/main/java/com/github/viticis/dtmclijavaexamples/DtmcliJavaSampleApplication&lt;/span&gt;&lt;/pre&gt;&lt;h2&gt;TCC的回滚&lt;/h2&gt;&lt;p&gt;假如银行将金额准备转入用户2时，发现用户2的账户异常，返回失败，会怎么样？我们可以让TransIn返回失败来模拟这种情况&lt;/p&gt;&lt;pre&gt;    &lt;span&gt;@RequestMapping(&quot;TransInTry&quot;)&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, String&amp;gt; &lt;span&gt;TransInTry&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; {&lt;br/&gt;        logger.info(&lt;span&gt;&quot;TransInTry&quot;&lt;/span&gt;);&lt;br/&gt;        Map&amp;lt;String, String&amp;gt; result = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;HashMap&lt;/span&gt;&amp;lt;&amp;gt;();&lt;br/&gt;        result.put(&lt;span&gt;&quot;dtm_result&quot;&lt;/span&gt;, &lt;span&gt;&quot;FAILURE&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; result;&lt;br/&gt;    }&lt;/pre&gt;&lt;p&gt;我们给出事务失败交互的时序图&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.219430485762144&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/9m9OfQX94VvJvhjNGBvp23oCHMicZHFfWSnf5utwia7X1VIzY6HVnDTAVnqHHiahTnT6pvYXicx3nickq8rIy61Sj7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1194&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;这个跟成功的TCC差别就在于，当某个子事务返回失败后，后续就回滚全局事务，调用各个子事务的Cancel操作，保证全局事务全部回滚。&lt;/p&gt;&lt;p&gt;在TCC事务模式上，有不少的读者会问，如果Confirm/Cancel失败会怎么样？这是一个好问题，代表您正在深入思考TCC事务模式。第一种情况是临时失败，例如网络故障、应用或数据库宕机，这类错误进行重试，最后会返回成功；另一种情况为业务失败，按照TCC的协议，第一阶段锁定资源，保证足够的资源能够让Confirm/Cancel执行，也就是说，程序逻辑上，Confirm/Cancel是不允许返回业务失败的，如果出现业务失败，那么是bug，需要开发人员手动修复bug。&lt;/p&gt;&lt;h2&gt;小结&lt;/h2&gt;&lt;p&gt;在这篇文章里，我们介绍了TCC的理论知识，也通过一个例子，完整给出了编写一个TCC事务的过程，涵盖了正常成功完成，以及成功回滚的情况。相信读者通过这边文章，对TCC已经有了深入的理解。&lt;/p&gt;&lt;p&gt;关于分布式事务更多更全面的知识，请参考《分布式事务最经典的七种解决方案》&lt;/p&gt;&lt;p&gt;文中使用的例子节选自yedf/dtm，它支持多种事务模式：TCC、SAGA、XA、事务消息 跨语言支持，已支持 golang、python、Java、PHP、nodejs等语言的客户端，参考各语言SDK。提供子事务屏障功能，优雅解决幂等、悬挂、空补偿等问题。&lt;/p&gt;&lt;p&gt;阅读完此篇干货，欢迎大家访问https://github.com/yedf/dtm项目，给颗星星支持！&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5388a67fe0b102581a30ce954b5d9f6b</guid>
<title>拥抱毒瘤 DDD</title>
<link>https://toutiao.io/k/g8y08bl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;174&quot; data-backw=&quot;365&quot; data-fileid=&quot;503034946&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4767123287671233&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/cvQbJDZsKLp6wejHtKTRbqqQyt0wMk9K1wNtuwRqQTJAPOJ1KiaqSeSRbIJRTicVicKpDKRndBodY2DBNN20tvWwA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;365&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原创：小姐姐味道（微信公众号ID：xjjdog），欢迎分享，转载请保留出处。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;牛B的人物，早已经厌倦了中英文混杂，他们更进一步，使用中英文缩写，对普通人进行降维打击。更厉害的，造就新的名词，并科普出去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有几项技术，我从心底里鄙视和厌恶，但每次在技术方案中，都默默的把它们加进去，而且给足了它们分量。因为它们对于方案的成功与否，起着重要的概念性指导作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它们就是中台、低代码，以及DDD。这三个不同领域中的技术，肩负着同样的责任，那就是往死里忽悠。这三个词，很伟大，它们有一个共同点，都是很容易说服非技术但能决策的人员，然后向下铺开，非常具有营销型，是职业经理人和CTO的最爱。也是咨询类公司的最爱。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些玩意儿，有的可以忽悠大公司，有的可以忽悠小公司，反正谁也别想逃掉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但毒瘤如果能够为我们带来利益，当然也要拥抱。不要那么死板嘛。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当妖风袭来，比起关上窗子，我们要拥抱它，要投其所好！为什么有的人工资高，有的人升的快！有的人成为了大师！要从根本上想想原因。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;概念能够升华体系&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你知道么？越是职位高的人，越容易喜欢虚无缥缈的东西。拿古代的皇帝来说，有很多期望与神仙相会的，就被方士骗的死去活来。即使到最后知道被骗了，也只能偷偷的把消息封锁起来。最近看《资治通鉴》，就发现了很多这样的案例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一来，是他们真的有这种需求；二来，是怕这些事被曝光了丢脸，只能咬牙坚持下去。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;地球上没有新鲜事，放到软件行业也一样。当我们把一件东西给神化，赋予它某些超自然的能力，它就能在方士的路上越走越平坦。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何神化？抓痛点、谈愿景、搞方法论，一般就能够销售成功。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，销售成功只是第一步，我们还要避免失败，避免被秋后算账。所以，我们需要把决策者的积极性调动起来，让他认识到自己的不足，羞于承认自己的弱点，我们就算落稳脚步了。只要决策者上了船，他就会想方设法美化它，争取更多的资源，让更多的人上船。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么互联网黑话生命力强劲，就是因为它能忽悠，能够升华你的思想，而不是空洞洞的代码。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我这里举个例子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一家公司，由于研发的人数有限，但是活儿很多，分散在多个系统之间。研发部门研究出来的结论是：要聚焦，集中力量到核心系统上。怎么办？不能在PPT上干巴巴的写上&lt;code&gt;聚焦&lt;/code&gt;两个字吧，那显得多LOW。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思来想去，突然灵机一动。要不，我们造点名词吧。按照级别，分它个CVP系统、IVP系统、EVP系统。这样，一下子逼格就上升了不少。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看不懂这些名词？看不懂就对了，因为这是我造的，要的就是看不懂这种效果。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看看下面这张图，我们甚至可以赋予它属性，把系统归类到这三类之中。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;503041360&quot; data-ratio=&quot;0.55546875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLqIuLwLlkn3olSAovUz70ib0jPNXenXyYZohia1BibycXyjcxsreyeia7GZ0jDvuwt13No0rt86jOHb3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重要的是，业务系统的聚焦，摇身一变，成为了CVP的重点建设。哈哈，比起一句话就完事的决策，我们这下可以聊很久了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;“教你怎么说话十分钟，等于什么都没说”。这是一种非常重要的能力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，我们就来看一下，这些技术到底是什么？为什么是毒瘤？为什么要拥抱它们。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;D不D的D的，有啥区别么&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所谓领域驱动，就是根据需求设计系统，这句话本来就是废话。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有Demo代码没？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有Demo代码没？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有Demo代码没？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有Demo代码没？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有的文章下面，都充满了这样的发问。如果说DDD层只是战略上有用，那它就不应该进入程序员视野，它应该是需求分析师的玩具。DDD应该学学TOGAF、COBIT、CGEIT之类的培训，把眼光放在战略布局上，不要老是想着革程序员的命，搞什么战术。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你要是专心搞搞业务培训证书，你赚你的钱我做我的架构设计，咱们井水不犯河水。但你要把触角伸到我的领域，就会招来像我这样的喷子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DDD正确的打开方式，就是拥抱它的战略阶段，完全扔掉它的战术阶段。这样做，你会活的很舒坦。原谅我使用“限界上下文”这样的名词来解释一下：你只要把我的服务边界划分清楚了，你管我后面是怎么实现呢，设计模式和架构模式，我的工具箱多的很，并不缺CQRS、事件溯源这样的名词。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DDD的概念最早来源于2004年，这么多年没火，没有标准落地，不是没有原因的。最近几年，有些人发现了技术名词的贫瘠，重新捡起了它，希望它能继续为KPI效力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我曾痴迷DDD，被它的美好愿景折磨的兴奋无比。买了网课，买了书籍，到最后发现它在浪费我的时间。我恨它。恕我直言，一个难度高，落地难的技术方案，根本没有资格让人分割精力去了解它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不好意思，没有路转粉。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，搞DDD的，都是些卷中卷公司，它不像微服务技术一样，能够找到大量落地的方案。实际上，你几乎找不到任何有价值的参考示例，更别说这些示例之间还相互打脸。它就像是圣经一样，给你说什么是对的，但怎么做，全靠你悟。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么你干不了DDD，你的团队干不了DDD？DDD给出了三个主要原因。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;对团队的要求较高。画外音，你做不好是你的团队不行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;只有复杂的业务使用DDD才能见效。那什么是复杂呢？并没有定论。话外音，你觉得不好用，那是你的业务不够复杂&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;虽然你用不了DDD，但其中的思想，还是值得借鉴和思考的。画外音，我是万金油，不会让你白学&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没有人会承认自己的团队不行，没有团队会承认自己的业务简单，没人能忍受自己的投入就真的肉包子打狗了。DDD通过几个让你不能打脸的理由，瞬间将你绑在了一起。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2020年，花了整整三个月时间，有幸拜读了《实现领域驱动设计》这本书，对其深厚的文字运用水平惊叹拜服。以后，即使一个简单的CRUD项目，我也知道文档应该怎么写了，这本书就是非常好的案例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你搜一下DDD的文章，不论什么文章，都有一个特点，那就是不能好好的说人话。所有的应用代码，都是一堆无法说服人的垃圾代码。因为开发者和正常的写法一比较，发现自己在找罪受，那为什么要用它呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就拿吹的很牛b的六边形架构来说吧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;六边形架构，因为长得像蜂窝，看起来就很靠近绿色的自然界，很高大上。说实话，我到现在都没弄明白六边形架构，八边形架构（没这种东西），三角形架构（没这种东西）之间，到底有何区别，这群名词狂魔为啥选择了6这个数字。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;您就直说，复杂的业务逻辑，不应该过多的关注技术等基础设施、但要预留接口就行了，非要整的这么玄乎，一条条蚯蚓一样的线从那腐烂的六边形上辐射出来。觉得很美么？或许老板真这么觉得，因为它像彩虹一样的名词轮，确实能唬住一群蹉B。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要说ServiceMesh的数据平面和控制平面分割，是靠DDD指导的哦，虽然它概念上靠的上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下图是google搜索&lt;code&gt;Hexagonal Architecture&lt;/code&gt;出现的一张图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-fileid=&quot;503041361&quot; data-ratio=&quot;0.68359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLqIuLwLlkn3olSAovUz70ib0v42yeOjgAGxKNFLu1UmfWQhFPtt5sp0ALqUIKSWGtqqzCNJrJApcUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;figcaption&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哎吆，六边形呢？这图怎么整了个10边形？那还是六边形架构么？您忽悠小孩子呢？当我不识数？什么，你又把它叫做洋葱头架构，它们不是一个东西？这样的误解在DDD中比比皆是，我也不想解释，因为它们都是短话长说。这说明了它是一门全面的忽悠方法论，是靠堆概念和黑话起家的，宣传者也不合格。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整个DDD这一套概念，价值观就有问题。或者说作者的本意或许是好的，面向的是复杂业务。结果让这群宣传者和培训一捣鼓，就成了解决问题的必要手段。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是不好意思，您连起码的顺畅交流都没整好，没资格教别人做架构。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;尴尬局面&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;让人觉得尴尬的是，真正需要DDD的人，并不认同它；不需要DDD的人，被强迫认同它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;DDD最大的价值是梳理业务性需求，将不同的业务领域划分出来，并形成领域之间的接口交互。说个实话，我见过很多咨询公司的大佬，他们对这种想要通吃的方法论嗤之以鼻，更倾向于使用TOGAF之类老牌的业务梳理方法。但条条道路通罗马，最终的领域划分还是能够达成一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些梳理的过程，大部分是业务专家，以及系统架构师的范畴。他们的工作成果，将作为输入输出到技术团队实现。他们需要DDD，但他们并不用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相比较而言，DDD的战术阶段，毫无价值而言。比如，把数据汇总到宽表或者大数据中心，形成数据“中台”提供交易域、管理域、查询域的分离，我并不需要知道什么CQRS的概念，也能工作的很好。至于实体充血不充血，我本来就是微服务了，业务粒度本来就很小了，要怎么写是我的自由，改造也是我自己的成本，我并不需要按照你那一套来。谈业务和技术的沟通？不好意思，不能沟通而去做业务的团队，我还没见过。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工程师被决策层强迫使用DDD战术书写业务，结果代码更乱，更改更加频繁。但是DDD说，不好意思，不是我的错，是你团队不行。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;道理是这个道理，但在现实中，还是有人吹嘘、甚至使用这个东西去改造代码。《微服务架构模式》这本书，甚至有事件溯源和CQRS两个章节，去专门讲解DDD的一些落地的内容。这叫做大师毒害了大师，当然也叫做相互扶持。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;恕我直言，如果你信了这些鬼话，大概率会把项目带入死亡。尽信书不如无书，架构是一种权衡，并没有通吃的指导思路。你可以参考，可以思考，但就是不能照搬，因为每个公司的技术前提都不一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;话虽如此，但当一些概念被吹嘘起来的时候，你不去拥抱它，反而会产生问题。软件行业有两个难题，一个是怎么把复杂的事情简单的汇报，另外一个就是把简单的东西搞复杂。对于前者，主要是描述你构想的可行性。而对于后者，主要的目的就是让人觉得很高大上，很主流，越晦涩越好。前者脚踏实地，后者口吐莲花。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而后者的功效，显然要比前一种有效得多。让人听上去感觉很牛x，但是听不懂，可以获得掌声，也可以体验高高在上的感觉。没人会承认自己的智商不在线，你需要激起这些人的活力。只要有人认同，就可以产生利益。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些概念，有些人，并不是神，但利益共同体，需要他成为神。这玩意也有信徒，你信么？但软件设计的工具，难道不是合适就用，不合适就扔么？为什么会成为信徒？仅仅是因为上船了而已。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;朋友们，在一定程度上，DDD这些概念，与比特币之类的概念，并没有什么区别。这就是信仰的魔力，这就是大师的力量啊！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;End&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有像我这样诚实的人，才会偶尔喷一喷。然后转身，把DDD写在了自己的方案上。是的，我可以写上，也可以讨论，也可以思维碰撞，但我永远不会轻易用它。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有在发广告的时候，我才会把它吹成自己的亲爹。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;作者简介：小姐姐味道 (xjjdog)，一个不允许程序员走弯路的公众号。聚焦基础架构和Linux。十年架构，日百亿流量，与你探讨高并发世界，给你不一样的味道。我的个人微信xjjdog0，欢迎添加好友，进一步交流。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4a2e0c65a1cacc773b4ca9ae0685e9cb</guid>
<title>指针那么容易出错，为什么 Go 还保留？</title>
<link>https://toutiao.io/k/funpq25</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4255555555555556&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/oiccOczwQpFicv3D2tDvmia6ZJfhia7rzhKNXzv4W1OYtPmWw326vCFnhgBQ4C35mkqpekb79TPbGfBPMiatLbCJZxg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;900&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想知道为什么 Go 的运行效率会那么快？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么你的程序老是报 invalid memory address or nil pointer dereference？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那了解&lt;strong&gt;指针&lt;/strong&gt;是一定少不了的！&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是指针？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先干一张百度百科是怎么解释指针的图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5774647887323944&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpFicv3D2tDvmia6ZJfhia7rzhKNxicibDGoAuXssDHPVwOXeib6MWU2jvuoFQx9l79TD15J68vak7tEsHvng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;852&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看完后感觉如何？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我记得我第一次听说指针是在接触 C++ 的时候，那简直是噩梦，太抽象了！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以这篇文章我尽量写得通俗易懂点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很庆幸的是，在后来发展起来的语言，比如 Java 基本就已经看不见他的身影了，因为指针太难了，非常反人类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到正题，&lt;strong&gt;什么是指针？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;计算机最重要的两个硬件就是 CPU 和内存吧，CPU 负责计算，内存负责临时存储数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们在写代码时，定义的变量在程序运行时，这些变量都被放在了内存里面，那内存是怎么存数据呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可以粗暴的理解他就是一个记事本，如下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6432748538011696&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpFicv3D2tDvmia6ZJfhia7rzhKNVx847jUFXBKapY1sqicy0kdyzAILZQsvwP3tavsOJulNILbibMjA5LuA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;513&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;浅绿色的部分就可以理解是内存，里面各种颜色的块就是里面存的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然实际情况不可能这么规则，不同长度的数据，分配的块大小和长度都不一样。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查过字典的同学都能明白，当我们要查某个字的时候，会去目录里面看这个字在第几页，这个第几页就可以理解是这个字在这个字典里面的地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存也是这样，我们在内存里面存放的任何数据都有一个地址，便于 CPU 去取数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;存放这个地址的变量就是指针！&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Go语言里面的指针&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Go 里面并没完全抛弃指针，因为在很多时候有指针的存在，在效率上会高很多。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是个人感觉 Go 对指针的处理非常恰到好处，先来看一段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;package&lt;/span&gt; main&lt;br/&gt;&lt;br/&gt;&lt;span&gt;import&lt;/span&gt; &lt;span&gt;&quot;fmt&quot;&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; a := &lt;span&gt;&quot;hello&quot;&lt;/span&gt;&lt;br/&gt; fmt.Println(a) &lt;span&gt;//[1]&lt;/span&gt;&lt;br/&gt; fmt.Println(&amp;amp;a) &lt;span&gt;//[2]&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后这是输出的结果：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;hello&lt;br/&gt;0xc000010230&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记了 [1] 的那行，是打印这个变量的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;标记了 [2] 的那行，是打印这个变量的指针地址。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;指针有什么用？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;可以直接修改指向数据的值！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有时候我需要在一个方法里面修改传进来的变量值，比如下面这段代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; a := &lt;span&gt;&quot;hello&quot;&lt;/span&gt;&lt;br/&gt; fmt.Println(a)&lt;br/&gt; update(a)&lt;br/&gt; fmt.Println(a) &lt;span&gt;//[1]&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;&lt;span&gt;(in &lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; in = &lt;span&gt;&quot;word&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码执行后的结果应该是这样的，直接输出两行 hello：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;hello&lt;br/&gt;hello&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如我现在想在 update 这个方法里面修改 a 这个变量的值，我想在当 [1] 的那段代码执行时，打印 word ，该怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时就可以使用指针来处理，直接把 a 变量的地址传给方法，然后方法里面直接针对这个地址进行操作。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt; {&lt;br/&gt; a := &lt;span&gt;&quot;hello&quot;&lt;/span&gt;&lt;br/&gt; fmt.Println(a)&lt;br/&gt; update(&amp;amp;a)&lt;br/&gt; fmt.Println(a)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;func&lt;/span&gt; &lt;span&gt;update&lt;/span&gt;&lt;span&gt;(in *&lt;span&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;  {&lt;br/&gt; *in = &lt;span&gt;&quot;word&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里面关键点就是 *：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;放在类型前面就是申明这是一个指针类型，放在变量前面就是通过这个指针取他值。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;而在变量前面放 &amp;amp; 这个字符，就是取这个变量的指针。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到目前为止，Go 指针的核心知识点就这么多，剩下的都是围绕这些在开展。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;空指针的坑&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来看下这个代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;var&lt;/span&gt; b *&lt;span&gt;int&lt;/span&gt;&lt;br/&gt;*b = &lt;span&gt;12&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果运行会怎么样？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;他会报错！&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;panic: runtime error: invalid memory address or nil pointer dereference&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们要操作指针变量时，他必须是一个有指向的地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段代码里面，变量 b 他声明了，但是内存里面并未分配内存地址给他，所以你此时去操作就会报空指针！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以怎么处理呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;初始化时就要求分配地址就好了，比如这样：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;var b *int = new(int)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是我们一般不这么写，会结合 Go 的类型自动推断来处理，如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;b := &lt;span&gt;new&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt;)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么情况下使用指针？&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Go 语言里面对指针是非常克制的，比如他不允许直接指针计算等。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;那为什么还要考虑保留指针？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不用指针，在传值的时候，就只能采用拷贝的方式，所以在复杂或者大的数据传递时会比较消耗性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是在使用时有几点需要注意的：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1、不要对 channel 这类引用类型使用指针&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2、对int、bool这样小的数据没必要使用指针&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3、如果需要并发安全，则尽可能的不要使用指针&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4、指针最好不要嵌套，也就是一个指针指向另一个指针&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你还有关于 Go 里面&lt;span&gt;指针的疑惑，欢迎给我留言，一起讨论！&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;如果你觉得有用欢迎，&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;收藏，点赞，在看，关注，转发&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzAxMDM4OTE4Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/oiccOczwQpFibibo18fyFiayicVL4FZV4ic7vibkR4NkVichWgwlZ3uURnJTGBrHNFpGafadfoQic1XOPPtgawW3kQuvNNA/0?wx_fmt=png&quot; data-nickname=&quot;GoLang全栈&quot; data-alias=&quot;GolangStackDev&quot; data-signature=&quot;在这里我会与你分享Go语言相关的技术，比如Docker、K8S等，还有读书笔记，期待你的关注。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>44a4dcf8a038d92222be4b87fe413853</guid>
<title>7.8k Star！一个强大的 JS 代码混淆工具</title>
<link>https://toutiao.io/k/ry3wt9q</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-hnrfcf&quot; options=&quot;[object Object]&quot;&gt;&lt;p&gt;【导语】：一个开源的代码混淆器，能将 JS 代码混淆成可读性低的代码。&lt;/p&gt;
&lt;h3&gt;简介&lt;/h3&gt;
&lt;p&gt;JavaScript Obfuscator 是一款功能强大的免费 JavaScript 混淆器，包含多种功能，能将代码混淆成可读性低的代码，看上去是难以阅读的代码，其实具备和之前代码一样的功能，从而起到保护代码的作用。&lt;/p&gt;
&lt;p&gt;原代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;function hi() {
  console.log(&quot;Hello World!&quot;);
}
hi();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;混淆后代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;function _0x5737(){var _0x3de046=[&#x27;13797910djQtgr&#x27;,&#x27;202NzEpzv&#x27;,&#x27;2273TLhUKk&#x27;,&#x27;6976590XeTkcs&#x27;,&#x27;4633335tPFIvf&#x27;,&#x27;460SzVdaa&#x27;,&#x27;1260225mbbZER&#x27;,&#x27;49056QtXjli&#x27;,&#x27;1736NJoeHX&#x27;,&#x27;42116DYgHBM&#x27;];_0x5737=function(){return _0x3de046;};return _0x5737();}function _0x5e71(_0x1e04fb,_0x168fdd){var _0x57378a=_0x5737();return _0x5e71=function(_0x5e7194,_0x30106f){_0x5e7194=_0x5e7194-0xb6;var _0x3c5c20=_0x57378a[_0x5e7194];return _0x3c5c20;},_0x5e71(_0x1e04fb,_0x168fdd);}(function(_0x41d572,_0x45db5e){var _0x306ede=_0x5e71,_0x408f15=_0x41d572();while(!![]){try{var _0x4c3c37=-parseInt(_0x306ede(0xbb))/0x1*(parseInt(_0x306ede(0xba))/0x2)+-parseInt(_0x306ede(0xbd))/0x3+parseInt(_0x306ede(0xb8))/0x4*(parseInt(_0x306ede(0xbe))/0x5)+-parseInt(_0x306ede(0xbc))/0x6+-parseInt(_0x306ede(0xb6))/0x7*(-parseInt(_0x306ede(0xb7))/0x8)+-parseInt(_0x306ede(0xbf))/0x9+parseInt(_0x306ede(0xb9))/0xa;if(_0x4c3c37===_0x45db5e)break;else _0x408f15[&#x27;push&#x27;](_0x408f15[&#x27;shift&#x27;]());}catch(_0x8596b2){_0x408f15[&#x27;push&#x27;](_0x408f15[&#x27;shift&#x27;]());}}}(_0x5737,0xc1743));function hi(){console[&#x27;log&#x27;](&#x27;Hello\x20World!&#x27;);}hi();&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;主要特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;变量重命名&lt;/li&gt;
&lt;li&gt;字符串提取和加密&lt;/li&gt;
&lt;li&gt;随机添加无用代码进行混淆&lt;/li&gt;
&lt;li&gt;控制流扁平化&lt;/li&gt;
&lt;li&gt;各种代码转换 ...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;支持的插件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Webpack 插件: webpack-obfuscator&lt;/li&gt;
&lt;li&gt;Webpack loader: obfuscator-loader&lt;/li&gt;
&lt;li&gt;Gulp: gulp-javascript-obfuscator&lt;/li&gt;
&lt;li&gt;Grunt: grunt-contrib-obfuscator&lt;/li&gt;
&lt;li&gt;Rollup: rollup-plugin-javascript-obfuscator&lt;/li&gt;
&lt;li&gt;Weex: weex-devtool&lt;/li&gt;
&lt;li&gt;Malta: malta-js-obfuscator&lt;/li&gt;
&lt;li&gt;Netlify 插件: netlify-plugin-js-obfuscator&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;项目地址是：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/javascript-obfuscator/javascript-obfuscator&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/javascript-o&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;bfuscator/javascript-obfuscator&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;安装使用&lt;/h3&gt;
&lt;h4&gt;使用 Yarn 或 Npm 安装&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// yarn 安装
$ yarn add --dev javascript-obfuscator
// npm 安装
$ npm install --save-dev javascript-obfuscator&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4&gt;CDN 引入&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/javascript-obfuscator/dist/index.browser.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;用法&lt;/h3&gt;
&lt;h4&gt;简单示例&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;var JavaScriptObfuscator = require(&#x27;javascript-obfuscator&#x27;);

var obfuscationResult = JavaScriptObfuscator.obfuscate(
    `
        (function(){
            var variable1 = &#x27;5&#x27; - 3;
            var variable2 = &#x27;5&#x27; + 3;
            var variable3 = &#x27;5&#x27; + - &#x27;2&#x27;;
            var variable4 = [&#x27;10&#x27;,&#x27;10&#x27;,&#x27;10&#x27;,&#x27;10&#x27;,&#x27;10&#x27;].map(parseInt);
            var variable5 = &#x27;foo &#x27; + 1 + 1;
            console.log(variable1);
            console.log(variable2);
            console.log(variable3);
            console.log(variable4);
            console.log(variable5);
        })();
    `,
    {
        compact: false,
        controlFlowFlattening: true,
        controlFlowFlatteningThreshold: 1,
        numbersToExpressions: true,
        simplify: true,
        stringArrayShuffle: true,
        splitStrings: true,
        stringArrayThreshold: 1
    }
);

console.log(obfuscationResult.getObfuscatedCode());&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;var _0x9947 = [
    &#x27;map&#x27;,
    &#x27;log&#x27;,
    &#x27;foo\x20&#x27;,
    &#x27;bvmqO&#x27;,
    &#x27;133039ViRMWR&#x27;,
    &#x27;xPfLC&#x27;,
    &#x27;ytpdx&#x27;,
    &#x27;1243717qSZCyh&#x27;,
    &#x27;2|7|4|6|9|&#x27;,
    &#x27;1ErtbCr&#x27;,
    &#x27;1608314VKvthn&#x27;,
    &#x27;1ZRaFKN&#x27;,
    &#x27;XBoAA&#x27;,
    &#x27;423266kQOYHV&#x27;,
    &#x27;3|0|5|8|1&#x27;,
    &#x27;235064xPNdKe&#x27;,
    &#x27;13RUDZfG&#x27;,
    &#x27;157gNPQGm&#x27;,
    &#x27;1639212MvnHZL&#x27;,
    &#x27;rDjOa&#x27;,
    &#x27;iBHph&#x27;,
    &#x27;9926iRHoRl&#x27;,
    &#x27;split&#x27;
];
function _0x33e4(_0x1809b5, _0x37ef6e) {
    return _0x33e4 = function (_0x338a69, _0x39ad79) {
        _0x338a69 = _0x338a69 - (0x1939 + -0xf * 0x1f3 + 0x1 * 0x469);
        var _0x2b223a = _0x9947[_0x338a69];
        return _0x2b223a;
    }, _0x33e4(_0x1809b5, _0x37ef6e);
}
(function (_0x431d87, _0x156c7f) {
    var _0x10cf6e = _0x33e4;
    while (!![]) {
        try {
            var _0x330ad1 = -parseInt(_0x10cf6e(0x6c)) * -parseInt(_0x10cf6e(0x6d)) + -parseInt(_0x10cf6e(0x74)) * -parseInt(_0x10cf6e(0x78)) + parseInt(_0x10cf6e(0x6a)) + -parseInt(_0x10cf6e(0x70)) + parseInt(_0x10cf6e(0x6e)) * -parseInt(_0x10cf6e(0x75)) + parseInt(_0x10cf6e(0x72)) + -parseInt(_0x10cf6e(0x67)) * parseInt(_0x10cf6e(0x73));
            if (_0x330ad1 === _0x156c7f)
                break;
            else
                _0x431d87[&#x27;push&#x27;](_0x431d87[&#x27;shift&#x27;]());
        } catch (_0x9f878) {
            _0x431d87[&#x27;push&#x27;](_0x431d87[&#x27;shift&#x27;]());
        }
    }
}(_0x9947, -0xb6270 + 0x4dfd2 * 0x2 + 0x75460 * 0x2), function () {
    var _0x1f346d = _0x33e4, _0x860db8 = {
            &#x27;ytpdx&#x27;: _0x1f346d(0x6b) + _0x1f346d(0x71),
            &#x27;bvmqO&#x27;: function (_0x560787, _0x519b9e) {
                return _0x560787 - _0x519b9e;
            },
            &#x27;rDjOa&#x27;: function (_0x4501fe, _0x2b07a3) {
                return _0x4501fe + _0x2b07a3;
            },
            &#x27;xPfLC&#x27;: function (_0x5f3c9b, _0x434936) {
                return _0x5f3c9b + _0x434936;
            },
            &#x27;XBoAA&#x27;: function (_0x535b8a, _0x42eef4) {
                return _0x535b8a + _0x42eef4;
            },
            &#x27;iBHph&#x27;: _0x1f346d(0x65)
        }, _0x346c55 = _0x860db8[_0x1f346d(0x69)][_0x1f346d(0x79)](&#x27;|&#x27;), _0x3bf817 = 0x4bb * 0x1 + 0x801 + -0xcbc;
    while (!![]) {
        switch (_0x346c55[_0x3bf817++]) {
        case &#x27;0&#x27;:
            console[_0x1f346d(0x7b)](_0x4c96d8);
            continue;
        case &#x27;1&#x27;:
            console[_0x1f346d(0x7b)](_0x101028);
            continue;
        case &#x27;2&#x27;:
            var _0x65977d = _0x860db8[_0x1f346d(0x66)](&#x27;5&#x27;, -0x586 + -0x2195 + -0x6 * -0x685);
            continue;
        case &#x27;3&#x27;:
            console[_0x1f346d(0x7b)](_0x65977d);
            continue;
        case &#x27;4&#x27;:
            var _0x56d39b = _0x860db8[_0x1f346d(0x76)](&#x27;5&#x27;, -&#x27;2&#x27;);
            continue;
        case &#x27;5&#x27;:
            console[_0x1f346d(0x7b)](_0x56d39b);
            continue;
        case &#x27;6&#x27;:
            var _0x544285 = [
                &#x27;10&#x27;,
                &#x27;10&#x27;,
                &#x27;10&#x27;,
                &#x27;10&#x27;,
                &#x27;10&#x27;
            ][_0x1f346d(0x7a)](parseInt);
            continue;
        case &#x27;7&#x27;:
            var _0x4c96d8 = _0x860db8[_0x1f346d(0x68)](&#x27;5&#x27;, 0x622 * -0x6 + 0x4a * 0x3 + 0x1 * 0x23f1);
            continue;
        case &#x27;8&#x27;:
            console[_0x1f346d(0x7b)](_0x544285);
            continue;
        case &#x27;9&#x27;:
            var _0x101028 = _0x860db8[_0x1f346d(0x6f)](_0x860db8[_0x1f346d(0x6f)](_0x860db8[_0x1f346d(0x77)], 0x6fb * 0x5 + 0x1ebf * 0x1 + -0x41a5), 0x209 * 0xa + 0x1314 + -0x276d);
            continue;
        }
        break;
    }
}());&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4&gt;obfuscate(sourceCode, options) 方法&lt;/h4&gt;
&lt;p&gt;该方法返回的对象 ObfuscationResult 包含以下公共方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;getObfuscatedCode()- 返回混淆后的代码字符串（对 ObfuscationResult 对象调用 toString() 方法也将返回混淆代码）；&lt;/li&gt;
&lt;li&gt;getSourceMap()- 如果 sourceMapMode 选项设置为 inline，则返回原代码或空字符串；&lt;/li&gt;
&lt;li&gt;getIdentifierNamesCache()- 如果 identifierNamesCache 选项为启用，则返回带有标识符名称的缓存对象，否则返回 null。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;该方法包含两个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;sourceCode(string, default:null) – 字符串原代码；&lt;/li&gt;
&lt;li&gt;options(Object, default:null) – 可选的设置选项 options 对象，具体有：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;{
    compact: true,
    controlFlowFlattening: false,
    controlFlowFlatteningThreshold: 0.75,
    deadCodeInjection: false,
    deadCodeInjectionThreshold: 0.4,
    debugProtection: false,
    debugProtectionInterval: false,
    disableConsoleOutput: false,
    domainLock: [],
    domainLockRedirectUrl: &#x27;about:blank&#x27;,
    forceTransformStrings: [],
    identifierNamesCache: null,
    identifierNamesGenerator: &#x27;hexadecimal&#x27;,
    identifiersDictionary: [],
    identifiersPrefix: &#x27;&#x27;,
    ignoreRequireImports: false,
    inputFileName: &#x27;&#x27;,
    log: false,
    numbersToExpressions: false,
    optionsPreset: &#x27;default&#x27;,
    renameGlobals: false,
    renameProperties: false,
    renamePropertiesMode: &#x27;safe&#x27;,
    reservedNames: [],
    reservedStrings: [],
    seed: 0,
    selfDefending: false,
    simplify: true,
    sourceMap: false,
    sourceMapBaseUrl: &#x27;&#x27;,
    sourceMapFileName: &#x27;&#x27;,
    sourceMapMode: &#x27;separate&#x27;,
    sourceMapSourcesMode: &#x27;sources-content&#x27;,
    splitStrings: false,
    splitStringsChunkLength: 10,
    stringArray: true,
    stringArrayIndexesType: [
        &#x27;hexadecimal-number&#x27;
    ],
    stringArrayEncoding: [],
    stringArrayIndexShift: true,
    stringArrayRotate: true,
    stringArrayShuffle: true,
    stringArrayWrappersCount: 1,
    stringArrayWrappersChainedCalls: true,
    stringArrayWrappersParametersMaxCount: 2,
    stringArrayWrappersType: &#x27;variable&#x27;,
    stringArrayThreshold: 0.75,
    target: &#x27;browser&#x27;,
    transformObjectKeys: false,
    unicodeEscapeSequence: false
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4&gt;obfuscateMultiple(sourceCodesObject, options) 方法&lt;/h4&gt;
&lt;p&gt;sourceCodesObject 是字典键值对象，其中键是源代码的标识符，值是原代码：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;{
    foo: &#x27;var foo = 1;&#x27;,
    bar: &#x27;var bar = 2;&#x27;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该方法也返回一个字典键值对象，其键是原代码的标识符，值是 ObfuscationResult对象。&lt;/p&gt;
&lt;h3&gt;命令行使用&lt;/h3&gt;
&lt;h4&gt;混淆单个文件&lt;/h4&gt;
&lt;p&gt;带有 .js 扩展名的单个文件的混淆：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;javascript-obfuscator input_file_name.js [options]
javascript-obfuscator input_file_name.js --output output_file_name.js [options]
javascript-obfuscator input_file_name.js --output output_folder_name [options]
javascript-obfuscator input_folder_name --output output_folder_name [options]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果没有使用 --output 指定输出路径，则混淆后的结果文件将存放到输入文件的目录中：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 这会创建一个新文件 samples/sample-obfuscated.js
javascript-obfuscator samples/sample.js --compact true --self-defending false

// 这会创建一个新文件 output/output.js
javascript-obfuscator samples/sample.js --output output/output.js --compact true --self-defending false&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4&gt;递归混淆目录下的文件&lt;/h4&gt;
&lt;p&gt;混淆输入目录下的所有 .js 文件。如果目录中包含已经带有 -obfuscated 后缀的混淆文件，则忽略这些文件。&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;// 输出结果到 ./dist 同级目录下带有 obfuscated 后缀的目录中
javascript-obfuscator ./dist [options]

// 输出结果到 ./dist/obfuscated 目录中
javascript-obfuscator ./dist --output ./dist/obfuscated [options]
// creates a folder structure with obfuscated files under `./dist/obfuscated` path&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;开源前哨&lt;/code&gt; 日常分享热门、有趣和实用的开源项目。参与维护 10万+ Star 的开源技术资源库，包括：Python、Java、C/C++、Go、JS、CSS、Node.js、PHP、.NET 等。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>