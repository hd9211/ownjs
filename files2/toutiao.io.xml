<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>1b27e0723c1e085a277f0ba20fb7cf24</guid>
<title>深度长文：从 bio 到 nio 到 aio，再到响应式编程</title>
<link>https://toutiao.io/k/8eqeeh0</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;174&quot; data-backw=&quot;365&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.4767123287671233&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/cvQbJDZsKLp6wejHtKTRbqqQyt0wMk9K1wNtuwRqQTJAPOJ1KiaqSeSRbIJRTicVicKpDKRndBodY2DBNN20tvWwA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;365&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;原创：小姐姐味道（微信公众号ID：xjjdog），欢迎分享，转载请保留出处。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要问计算机系统里，有哪些概念比较折腾人，nio绝对能算上一个。配合着多是异的网络编程，nio加上多线程一般能够完成双杀。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Linux有5种常见的IO模型。其中，阻塞IO就是bio，IO复用就是nio，异步IO就是aio，我们本篇文章就聚焦于此。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;阻塞式IO （bio）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;非阻塞式IO&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;IO复用 （nio）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;信号驱动式IO&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;异步IO（aio）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在网络编程中，Reactor模型是必须要了解的。现在，大多数与IO相关的组件，都会使用Reactor模型，比如Tomcat、Redis、Nginx等，可见Reactor应用的广泛性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Reactor是NIO的基础。为什么NIO的性能就能够比传统的阻塞IO性能高呢？我们首先来看一下传统阻塞式IO的一些特点。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;1.阻塞IO模型&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.40298507462686567&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLogDicUMe8OSdYKicHZ75ic7ic6Mst1dW6iaPqNickNnRyVIOUfVHIrricibfGkjBqFvGosdX2gQs4iaibFqDfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;804&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如上图，是典型的BIO模型，每当有一个连接到来，经过协调器的处理，就开启一个对应的线程进行接管。如果连接有1000条，那就需要1000个线程。线程资源是非常昂贵的，除了占用大量的内存，还会占用非常多的CPU调度时间，所以BIO在连接非常多的情况下，效率会变得非常低。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面的代码是使用&lt;code&gt;ServerSocket&lt;/code&gt;实现的一个简单socket服务器，监听在8888端口。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;BIO&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; stop = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; connectionNum = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; port = &lt;span&gt;8888&lt;/span&gt;;&lt;br/&gt;        ExecutorService service = Executors.newCachedThreadPool();&lt;br/&gt;        ServerSocket serverSocket = &lt;span&gt;new&lt;/span&gt; ServerSocket(port);&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (!stop) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;10&lt;/span&gt; == connectionNum) {&lt;br/&gt;                stop = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            Socket socket = serverSocket.accept();&lt;br/&gt;            service.execute(() -&amp;gt; {&lt;br/&gt;                &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                    Scanner scanner = &lt;span&gt;new&lt;/span&gt; Scanner(socket.getInputStream());&lt;br/&gt;                    PrintStream printStream = &lt;span&gt;new&lt;/span&gt; PrintStream(socket.getOutputStream());&lt;br/&gt;                    &lt;span&gt;while&lt;/span&gt; (!stop) {&lt;br/&gt;                        String s = scanner.next().trim();&lt;br/&gt;                        printStream.println(&lt;span&gt;&quot;PONG:&quot;&lt;/span&gt; + s);&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;catch&lt;/span&gt; (Exception ex) {&lt;br/&gt;                    ex.printStackTrace();&lt;br/&gt;                }&lt;br/&gt;            });&lt;br/&gt;            connectionNum++;&lt;br/&gt;        }&lt;br/&gt;        service.shutdown();&lt;br/&gt;        serverSocket.close();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动之后，使用&lt;code&gt;nc&lt;/code&gt;命令进行连接测试，结果如下。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ nc -v localhost 8888&lt;br/&gt;Connection to localhost port 8888 [tcp/ddi-tcp-1] succeeded!&lt;br/&gt;hello&lt;br/&gt;PONG:hello&lt;br/&gt;nice&lt;br/&gt;PONG:nice&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，BIO的读写操作是阻塞的，线程的整个生命周期和连接的生命周期是一样的，而且不能够被复用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就单个&lt;code&gt;阻塞IO&lt;/code&gt;来说，它的效率并不比&lt;code&gt;NIO&lt;/code&gt;慢。但是当服务的连接增多，考虑到整个服务器的资源调度和资源利用率等因素，&lt;code&gt;NIO&lt;/code&gt;就有了显著的效果，NIO非常适合高并发场景。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;2.非阻塞IO模型&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，在处理IO动作时，有大部分时间是在等待。比如，socket连接要花费很长时间进行连接操作，在完成连接的这段时间内，它并没有占用额外的系统资源，但它只能阻塞等待在线程中。这种情况下，系统资源并不能被合理的利用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java的NIO，在Linux上底层是使用epoll实现的。epoll是一个高性能的多路复用I/O工具，改进了select和poll等工具的一些功能。在网络编程中，对epoll概念的一些理解，几乎是面试中必问的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;epoll的数据结构是直接在内核上进行支持的。通过epoll_create和epoll_ctl等函数的操作，可以构造描述符（fd）相关的事件组合（event）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有两个比较重要的概念：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;fd&lt;/code&gt; 每条连接、每个文件，都对应着一个描述符，比如端口号。内核在定位到这些连接的时候，就是通过fd进行寻址的&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;event&lt;/code&gt; 当fd对应的资源，有状态或者数据变动，就会更新&lt;code&gt;epoll_item&lt;/code&gt;结构。在没有事件变更的时候，epoll就阻塞等待，也不会占用系统资源；一旦有新的事件到来，epoll就会被激活，将事件通知到应用方&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于epoll还会有一个面试题：相对于select，epoll有哪些改进？这里直接给出答案：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;epoll不再需要像select一样对fd集合进行轮询，也不需要在调用时将fd集合在用户态和内核态进行交换&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;应用程序获得就绪fd的事件复杂度，epoll时O(1)，select是O(n)&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;select最大支持约1024个fd，epoll支持65535个&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;select使用轮询模式检测就绪事件，epoll采用通知方式，更加高效&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还是以Java中的NIO代码为例，来看一下NIO的具体概念。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;NIO&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; stop = &lt;span&gt;false&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; connectionNum = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; port = &lt;span&gt;8888&lt;/span&gt;;&lt;br/&gt;        ExecutorService service = Executors.newCachedThreadPool();&lt;br/&gt;        ServerSocketChannel ssc = ServerSocketChannel.open();&lt;br/&gt;        ssc.configureBlocking(&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;        ssc.socket().bind(&lt;span&gt;new&lt;/span&gt; InetSocketAddress(&lt;span&gt;&quot;localhost&quot;&lt;/span&gt;, port));&lt;br/&gt;        Selector selector = Selector.open();&lt;br/&gt;        ssc.register(selector, ssc.validOps());&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (!stop) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;10&lt;/span&gt; == connectionNum) {&lt;br/&gt;                stop = &lt;span&gt;true&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; num = selector.select();&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (num == &lt;span&gt;0&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            Iterator&amp;lt;SelectionKey&amp;gt; events = selector.selectedKeys().iterator();&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (events.hasNext()) {&lt;br/&gt;                SelectionKey event = events.next();&lt;br/&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (event.isAcceptable()) {&lt;br/&gt;                    SocketChannel sc = ssc.accept();&lt;br/&gt;                    sc.configureBlocking(&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;                    sc.register(selector, SelectionKey.OP_READ);&lt;br/&gt;                    connectionNum++;&lt;br/&gt;                } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (event.isReadable()) {&lt;br/&gt;                    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;                        SocketChannel sc = (SocketChannel) event.channel();&lt;br/&gt;                        ByteBuffer buf = ByteBuffer.allocate(&lt;span&gt;1024&lt;/span&gt;);&lt;br/&gt;                        &lt;span&gt;int&lt;/span&gt; size = sc.read(buf);&lt;br/&gt;                        &lt;span&gt;if&lt;/span&gt;(-&lt;span&gt;1&lt;/span&gt;==size){&lt;br/&gt;                            sc.close();&lt;br/&gt;                        }&lt;br/&gt;                        String result = &lt;span&gt;new&lt;/span&gt; String(buf.array()).trim();&lt;br/&gt;                        ByteBuffer wrap = ByteBuffer.wrap((&lt;span&gt;&quot;PONG:&quot;&lt;/span&gt; + result).getBytes());&lt;br/&gt;                        sc.write(wrap);&lt;br/&gt;                    } &lt;span&gt;catch&lt;/span&gt; (Exception ex) {&lt;br/&gt;                        ex.printStackTrace();&lt;br/&gt;                    }&lt;br/&gt;                } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (event.isWritable()) {&lt;br/&gt;                    SocketChannel sc = (SocketChannel) event.channel();&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                events.remove();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        service.shutdown();&lt;br/&gt;        ssc.close();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这段代码比较长，是使用NIO实现的和BIO相同的功能。从它的API设计上，我们就能够看到epoll的一些影子。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先，我们创建了一个服务端ssc，并开启一个新的事件选择器，监听它的&lt;code&gt;OP_ACCEPT&lt;/code&gt;事件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;ServerSocketChannel ssc = ServerSocketChannel.open();&lt;br/&gt;Selector selector = Selector.open();&lt;br/&gt;ssc.register(selector, ssc.validOps());&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;共有4种事件类型。分别是新连接事件（OP_ACCEPT）、连接就绪事件（OP_CONNECT）、读就绪事件（OP_READ）、写就绪事件（OP_WRITE）。任何网络和文件操作，都可以抽象成这四个事件。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.332955832389581&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLogDicUMe8OSdYKicHZ75ic7ic6FE5zlBibZAKmYEhUI07mx1ZXXUibkXRvuvlIfXVDVzoAbXlp3aWO4PTQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;883&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，在while循环里，使用select函数，阻塞在主线程里。所谓阻塞，就是操作系统不再分配CPU事件片到当前线程中，所以select函数是几乎不占用任何系统资源的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;int&lt;/span&gt; num = selector.select();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一旦有新的事件到达，比如有新的连接到来，主线程就能够被调度到，程序就能够向下执行。这时候，就能够根据订阅的事件通知，持续获取订阅的事件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于注册到selector的连接和事件可能会有多个，所以这些事件也会有多个。我们使用安全的迭代器循环进行处理，在处理完毕之后，将它删除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果事件不删除的话，或者漏掉了某个事件的处理，会怎么样呢？后果还是比较严重的，由于事件总是存在，我们的程序会陷入无休无止的循环之中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Iterator&amp;lt;SelectionKey&amp;gt; events = selector.selectedKeys().iterator();&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (events.hasNext()) {&lt;br/&gt;        SelectionKey event = events.next();&lt;br/&gt;        ...&lt;br/&gt;        events.remove();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有新的连接到达时，我们订阅了更多的事件。对于我们的数据读取来说，对应的事件就是OP_READ。和BIO编程面向流的方式不同，NIO操作的对象是抽象的概念Channel，通过缓冲区进行数据交换。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;SocketChannel sc = ssc.accept();&lt;br/&gt;sc.configureBlocking(&lt;span&gt;false&lt;/span&gt;);&lt;br/&gt;sc.register(selector, SelectionKey.OP_READ);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;值得注意的是：服务端和客户端的实现方式，可以是不同的。比如，服务端是NIO，客户端可以是BIO，它们并没有什么强制要求。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外一个面试时候经常问到的事件就是&lt;code&gt;OP_WRITE&lt;/code&gt;。我们上面提到过，这个事件是表示写就绪的，当底层的缓冲区有空闲，这个事件就会一直发生，浪费占用CPU资源。所以，我们一般是不注册&lt;code&gt;OP_WRITE&lt;/code&gt;的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里还有一个细节，在读取数据的时候，并没有像BIO的方式一样使用循环来获取数据。如下面的代码，我们创建了一个1024字节的缓冲区，用于数据的读取。如果连接中的数据，大于1024字节怎么办？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;SocketChannel sc = (SocketChannel) event.channel();&lt;br/&gt;ByteBuffer buf = ByteBuffer.allocate(&lt;span&gt;1024&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; size = sc.read(buf);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这涉及到两种事件的通知机制。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;水平触发&lt;/strong&gt; (level-triggered) 称作LT模式。只要缓冲区有数据，事件就会一直发生&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;边缘触发&lt;/strong&gt; (edge-triggered) 称作ET模式。缓冲区有数据，仅会触发一次。事件想要再次触发，必须先将fd中的数据读完才行&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，Java的NIO采用的就是水平触发的方式。LT模式频繁环唤醒线程，效率相比较ET模式低，所以Netty使用JNI的方式，实现了ET模式，效率上更高一些。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.Reactor模式&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解了BIO和NIO的一些使用方式，Reactor模式就呼之欲出了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;NIO是基于事件机制的，有一个叫做Selector的选择器，阻塞获取关注的事件列表。获取到事件列表后，可以通过分发器，进行真正的数据操作。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5426997245179064&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLogDicUMe8OSdYKicHZ75ic7ic6PicK9MgzlPgUYWY1rib53UXQopLXVP2dq3NvEs2TCiahTaEyAtMhgHwyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;726&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图是&lt;code&gt;Doug Lea&lt;/code&gt;在讲解NIO时候的一张图，指明了最简单的Reactor模型的基本元素。你可以对比这上面的NIO代码分析一下，里面有四个主要元素：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Acceptor&lt;/strong&gt; 处理client的连接，并绑定具体的事件处理器&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Event&lt;/strong&gt; 具体发生的事件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Handler&lt;/strong&gt;  执行具体事件的处理者。比如处理读写事件&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Reactor&lt;/strong&gt; 将具体的事件分配给Handler&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以对上面的模型进行近一步细化，下面这张图同样是&lt;code&gt;Doug Lea&lt;/code&gt;的ppt中的。它把Reactor部分分为mainReactor和subReactor两部分。mainReactor负责监听处理新的连接，然后将后续的事件处理交给subReactor，subReactor对事件处理的方式，也由阻塞模式变成了多线程处理，引入了任务队列的模式。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.653954802259887&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLogDicUMe8OSdYKicHZ75ic7ic6AnuaS6YNEic86IWI0FEPWZnY4qWC6Nw9Cmib5oTc6A89hy5nDEr8tq8g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;708&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;熟悉Netty的同学可以看到，这个模型就是Netty设计的基础。在Netty中，Boss线程对应着对连接的处理和分派，相当于mainReactor；Work线程 对应着subReactor，使用多线程负责读写事件的分发和处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种模式将每个组件的职责分的更细，耦合度也更低，能有效的解决&lt;code&gt;C10k&lt;/code&gt;问题。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;4.AIO&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于NIO的概念，误解还是比较多的。面试官可能会问你：为什么我在使用NIO的时候，使用Channel进行读写，socket的操作依然是阻塞的？NIO主要体现在哪里？&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;//这行代码是阻塞的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;int&lt;/span&gt; size = sc.read(buf);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案就是，NIO只负责对发生在fd描述符上的事件进行通知。事件的获取和通知部分是非阻塞的，但收到通知之后的操作，却是阻塞的。即使使用多线程去处理这些事件，它依然是阻塞的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AIO更近一步，将这些对事件的操作也变成非阻塞的。下面是一段典型的AIO代码，它通过注册&lt;code&gt;CompletionHandler&lt;/code&gt; 回调函数进行事件处理。这里的事件是隐藏的，比如read函数，它不仅仅代表Channel可读了，而且会把数据自动的读取到ByteBuffer中。等完成了读取，就会通过回调函数通知你，进行后续的操作。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;AIO&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;main&lt;/span&gt;&lt;span&gt;(String[] args)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; port = &lt;span&gt;8888&lt;/span&gt;;&lt;br/&gt;        AsynchronousServerSocketChannel ssc = AsynchronousServerSocketChannel.open();&lt;br/&gt;        ssc.bind(&lt;span&gt;new&lt;/span&gt; InetSocketAddress(&lt;span&gt;&quot;localhost&quot;&lt;/span&gt;, port));&lt;br/&gt;        ssc.accept(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; CompletionHandler&amp;lt;AsynchronousSocketChannel, Object&amp;gt;() {&lt;br/&gt;            &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;job&lt;/span&gt;&lt;span&gt;(&lt;span&gt;final&lt;/span&gt; AsynchronousSocketChannel sc)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                ByteBuffer buffer = ByteBuffer.allocate(&lt;span&gt;1024&lt;/span&gt;);&lt;br/&gt;                sc.read(buffer, buffer, &lt;span&gt;new&lt;/span&gt; CompletionHandler&amp;lt;Integer, ByteBuffer&amp;gt;() {&lt;br/&gt;                    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;completed&lt;/span&gt;&lt;span&gt;(Integer result, ByteBuffer attachment)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                        String str = &lt;span&gt;new&lt;/span&gt; String(attachment.array()).trim();&lt;br/&gt;                        ByteBuffer wrap = ByteBuffer.wrap((&lt;span&gt;&quot;PONG:&quot;&lt;/span&gt; + str).getBytes());&lt;br/&gt;                        sc.write(wrap, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; CompletionHandler&amp;lt;Integer, Object&amp;gt;() {&lt;br/&gt;                            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;completed&lt;/span&gt;&lt;span&gt;(Integer result, Object attachment)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                                job(sc);&lt;br/&gt;                            }&lt;br/&gt;                            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;failed&lt;/span&gt;&lt;span&gt;(Throwable exc, Object attachment)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                                System.out.println(&lt;span&gt;&quot;error&quot;&lt;/span&gt;);&lt;br/&gt;                            }&lt;br/&gt;                        });&lt;br/&gt;                    }&lt;br/&gt;                    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;failed&lt;/span&gt;&lt;span&gt;(Throwable exc, ByteBuffer attachment)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                        System.out.println(&lt;span&gt;&quot;error&quot;&lt;/span&gt;);&lt;br/&gt;                    }&lt;br/&gt;                });&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;completed&lt;/span&gt;&lt;span&gt;(AsynchronousSocketChannel sc, Object attachment)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                ssc.accept(&lt;span&gt;null&lt;/span&gt;, &lt;span&gt;this&lt;/span&gt;);&lt;br/&gt;                job(sc);&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;failed&lt;/span&gt;&lt;span&gt;(Throwable exc, Object attachment)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;                exc.printStackTrace();&lt;br/&gt;                System.out.println(&lt;span&gt;&quot;error&quot;&lt;/span&gt;);&lt;br/&gt;            }&lt;br/&gt;        });&lt;br/&gt;        Thread.sleep(Integer.MAX_VALUE);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AIO是Java1.7加入的，理论上性能是会提升的，但它现在发展的不太好。那部分对数据进行自动读取的操作，总得有地方实现，不在框架里，就得在内核里。Netty的NIO模型加上多线程处理，在这方面已经做的很好，编程模式也非常简单。所以，市面上对AIO的实践并不多，在采用技术选型的时候，一定要谨慎。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;5.响应式编程&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可能听说过Spring5的webflux，webflux是可以替代spring mvc的一套解决方案，可以编写响应式的应用，两者之间的关系可以看下图。它的底层使用的是netty，所以操作是异步非阻塞的。类似的组件还有vert.x、akka、rxjava等。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5575&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLogDicUMe8OSdYKicHZ75ic7ic6mVpyyzwfVT9tgU0YFblyL5Riciaq2LGugx67BvTO0EOYX9UFjGjeRzaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;webflux是运行在project reactor之上的一个封装，其根本特性是由后者提供的。至于再底层的非阻塞模型，就是由Netty保证的了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;非阻塞的特性我们可以理解，响应式又是什么概念呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段话很晦涩，在编程方面，它表达的意思是：&lt;strong&gt;把生产者消费者模式，使用简单的API表示出来，并自动处理背压（backpressure）问题。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;背压，指的是生产者与消费者之间的流量控制。通过将操作全面异步化，来减少无效的等待和资源消耗。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java的lambda表达式可以承担&lt;strong&gt;简单&lt;/strong&gt;这个职责，Java9更是引入了响应式流（Reactive Stream），方便了我们的操作。比如，下面是&lt;code&gt;Spring Cloud GateWay&lt;/code&gt;的&lt;code&gt;Fluent API&lt;/code&gt;写法，响应式编程的API都是类似的。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; RouteLocator &lt;span&gt;customerRouteLocator&lt;/span&gt;&lt;span&gt;(RouteLocatorBuilder builder)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; builder.routes()&lt;br/&gt;                .route(r -&amp;gt; r.path(&lt;span&gt;&quot;/market/**&quot;&lt;/span&gt;)&lt;br/&gt;                        .filters(f -&amp;gt; f.filter(&lt;span&gt;new&lt;/span&gt; RequestTimeFilter())&lt;br/&gt;                                .addResponseHeader(&lt;span&gt;&quot;X-Response-Default-Foo&quot;&lt;/span&gt;, &lt;span&gt;&quot;Default-Bar&quot;&lt;/span&gt;))&lt;br/&gt;                        .uri(&lt;span&gt;&quot;http://localhost:8080/market/list&quot;&lt;/span&gt;)&lt;br/&gt;                        .order(&lt;span&gt;0&lt;/span&gt;)&lt;br/&gt;                        .id(&lt;span&gt;&quot;customer_filter_router&quot;&lt;/span&gt;)&lt;br/&gt;                )&lt;br/&gt;                .build();&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从传统的开发模式过渡到reactor的开发模式，是有一定成本的，不过它确实能够提高我们应用程序的性能。具体用不用，就要看在编程难度和性能之间的取舍了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的描述，我们了解到，BIO的线程模型是一个连接对应一个线程的，非常的浪费资源；NIO通过对关键事件的监听，通过主动通知的方式完成非阻塞操作，但它对事件本身的处理依然是非阻塞的；AIO完全是异步非阻塞的，但现实中使用很少。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用Netty的多Acceptor模式和多线程模式，我们能够方便的完成类似AIO这样的操作。Netty的事件触发机制使用了高效的ET模式，使得支持的连接更多，性能更高。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用Netty，能够构建响应式编程的基础，加上类似lambda表达式这样的书写风格，能够完成类似WebFlux这样的响应式框架。响应式编程是一个趋势，现在有越来越多的框架和底层的数据库支持响应式编程，我们的应用响应也会更加迅速。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;作者简介：&lt;strong&gt;小姐姐味道&lt;/strong&gt;  (xjjdog)，一个不允许程序员走弯路的公众号。聚焦基础架构和Linux。十年架构，日百亿流量，与你探讨高并发世界，给你不一样的味道。我的个人微信xjjdog0，欢迎添加好友，进一步交流。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6fd5b01f5edc82f559cb9f80ced0a01d</guid>
<title>Rust 速查表</title>
<link>https://toutiao.io/k/7v3m3tv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;article v-if=&quot;pjaxHtml === &#x27;&#x27;&quot; class=&quot;article-body&quot;&gt;
            
            &lt;h1 class=&quot;article-body-title&quot; data-identifier=&quot; 2021-08-08&quot;&gt;Rust-CheatSheet&lt;/h1&gt;







&lt;h2 id=&quot;1-data-structure&quot;&gt;1. Data Structure&lt;/h2&gt;

&lt;h3 id=&quot;通过关键字定义的数据类型和内存位置&quot;&gt;通过关键字定义的数据类型和内存位置&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;struct S {}&lt;/code&gt; 定义一个名称为S的结构体
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;struct S { x: T }&lt;/code&gt; 定义结构体字段 x 类型为 T&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;struct S(T)&lt;/code&gt; 定义tuple结构体 &lt;code class=&quot;highlighter-rouge&quot;&gt;.0&lt;/code&gt; 元素类型为 T&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;struct S&lt;/code&gt; 定义一个 Zero sized 的单元结构体.不占用空间,编译器优化&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;enum E {}&lt;/code&gt; 定义结构体
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;enum E { A, B(), C{} }&lt;/code&gt; 定义 &lt;code class=&quot;highlighter-rouge&quot;&gt;enum&lt;/code&gt;, 可以是单元 &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;, 元组 &lt;code class=&quot;highlighter-rouge&quot;&gt;B()&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;struct-like&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;C{}&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;enum E { A = 1}&lt;/code&gt; 判别值 A - 1&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;union U {}&lt;/code&gt; 不安全的类似 C 的 Union, 用于 FFI 兼容性&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;static X:T = T()&lt;/code&gt; 全局变量 static 生命周期, 单内存地址&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;const X:T = T()&lt;/code&gt; 定义常量, 使用的时候拷贝到临时内存&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let x:T&lt;/code&gt; 分配 T stack 数据 绑定到 x, 赋值一次, 不可变&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let mut x:T&lt;/code&gt; 和 let 类似,是可变的,借用可变
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;x = y&lt;/code&gt; 如果 y 是不能被Copy, 移动(move) y 到 x, y将失效. 否则复制y&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;绑定变量存在于同步代码的stack中. 在 async {} 中,它们成为 async 状态机的一部分,可能驻留在heap.
从技术上讲,可变和不可变是用词不当. 不可变绑定或共享引用可能仍包含 Cell, 从而提供内部可变性.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;创建和访问数据结构和更多的符号类型&quot;&gt;创建和访问数据结构,和更多的符号类型&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S { x: y }&lt;/code&gt; 创建 &lt;code class=&quot;highlighter-rouge&quot;&gt;struct S {}&lt;/code&gt; 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;enum E::S {}&lt;/code&gt; 的x字段设置y值&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S { x }&lt;/code&gt; 设置变量 x 到 struct x字段&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S { ..s }&lt;/code&gt; 使用 s 的全部同字段填充&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S { 0: x}&lt;/code&gt; tuple struct &lt;code class=&quot;highlighter-rouge&quot;&gt;.0&lt;/code&gt; 设置 x&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S(x)&lt;/code&gt; 创建 struct S(T) 或者 使用 enum E::S() x 赋值给 元组结构体 &lt;code class=&quot;highlighter-rouge&quot;&gt;.0&lt;/code&gt; 元素&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S&lt;/code&gt; S 单元 struct, enum E::S 创建 S&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;E::C { x:y }&lt;/code&gt; 创建 enum 成员是 struct&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;()&lt;/code&gt; 空 tuple&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(x)&lt;/code&gt; 括号表达式&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(x,)&lt;/code&gt; 单元素 tuple&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(S,)&lt;/code&gt; 单元素类型 tuple&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[S]&lt;/code&gt; Slice 不知道长度的Type Array&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[S;n]&lt;/code&gt; 元素类型为 S, 长度为 n Array&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[x;n]&lt;/code&gt; Array 实例 n 个 x的拷贝&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[x,y]&lt;/code&gt; Array 实例 x,y 元素&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;x[0]&lt;/code&gt; 集合索引 x.usize. Implementable with Index, IndexMut&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;x[..]&lt;/code&gt; slice 全部元素&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;x[a..b]&lt;/code&gt;   右索引元算不包含,第 a 到 b 个元素 slice&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;x[..b]&lt;/code&gt;    右索引元算不包含,第 0 到 b 个元素 slice&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;x[a..=b]&lt;/code&gt;  右索引元算包含,第 a 到 b 个元素 slice&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;x[..=b]&lt;/code&gt;   右索引元算包含,第 0 到 b 个元素 slice&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;s.x&lt;/code&gt; 命名字段访问,如果 x 不是类型 S 的一部分,可能会尝试Deref.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;s.0&lt;/code&gt; 编号字段访问,用于元组类型 S&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-references--pointers引用和指针&quot;&gt;2. References &amp;amp; Pointers(引用和指针)&lt;/h2&gt;

&lt;p&gt;授予对未拥有的内存的访问权限. 另请参阅泛型和约束部分.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;S&lt;/code&gt; 共享引用
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;[S]&lt;/code&gt; 特殊 slice 引用(包含地址,长度)&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;str&lt;/code&gt; 特殊 string slice 引用(包含地址,长度)&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;mut S&lt;/code&gt; 允许可变性的独占引用 (同 &amp;amp;mut [S], &amp;amp;mut dyn S, … )&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;dyn T&lt;/code&gt; 特殊 Trait object 引用包含(address,vtable)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;s&lt;/code&gt; 共享borrow (e.g., address, len, vtable, … of this s, like 0x1234)
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;mut s&lt;/code&gt; 独占借用可变&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;raw const s&lt;/code&gt; 通过w/o引用创建原始指针,  &lt;code class=&quot;highlighter-rouge&quot;&gt;c.ptr:addr_of!()&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;raw mut s&lt;/code&gt; 同上,可变. 原始指针,需要未对齐的压缩字段&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ref s&lt;/code&gt; 通过引用绑定, 使绑定引用类型
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let ref r = s&lt;/code&gt; 效果相同 &lt;code class=&quot;highlighter-rouge&quot;&gt;let r = &amp;amp;s&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let S {ref mut x } = s&lt;/code&gt; 可变绑定(let x = &amp;amp;mut s.x), 简写的析构&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*r&lt;/code&gt; 取引用值
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*r = s&lt;/code&gt; 如果 r 是可变引用,move or copy s 到目标memory&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;s = *r&lt;/code&gt; 如果r可以Copy,复制r&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;s = *r&lt;/code&gt; 如果r不可以Copy,错误&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;s = *my_box&lt;/code&gt; Box特殊用例,如果Box内容不能Copy,move Box的内容出来&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&#x27;a&lt;/code&gt; 静态分析中流的生命周期参数持续时间
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&#x27;a S&lt;/code&gt; 只接受一个带有 s 的地址, 地址存在生命周期比 ‘a 更长&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&#x27;a mut S&lt;/code&gt; 同上,但是可变&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;struct S&amp;lt;&#x27;a&amp;gt; {}&lt;/code&gt; S的地址生命周期是 ‘a, 创建 S 决定 ‘a 生命周期长短&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;trait T&amp;lt;&#x27;a&amp;gt; {}&lt;/code&gt; S impl T ,S 决定 ‘a 生命周期长短&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fn f&amp;lt;&#x27;a&amp;gt;(t: &amp;amp;&#x27;a T)&lt;/code&gt; 调用者决定 ‘a 生命周期长短&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&#x27;static&lt;/code&gt; 持续整个程序执行的特殊生命周期&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-functions--behavior-函数和行为&quot;&gt;3. Functions &amp;amp; Behavior (函数和行为)&lt;/h2&gt;

&lt;p&gt;定义代码单元及其抽象&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;trait T {}&lt;/code&gt; 定义一个 trait； 其他人可以 implement&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;trait T:R {}&lt;/code&gt; T 是子 trait, S 是父级 trait, S 必须 impl R trait 之后才能 impl T trait&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;impl S {}&lt;/code&gt; 实现 S 的方法&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;impl T for S {}&lt;/code&gt; S type 实现 T trait 方法&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;impl !T for S {}&lt;/code&gt; 禁用 T trait 的默认实现&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fn f() {}&lt;/code&gt; 定义函数,如果在 impl 内部则是实现方法&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fn f() -&amp;gt; S {}&lt;/code&gt; 返回值 Type S&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fn f(&amp;amp;self) {}&lt;/code&gt; 在 impl 内部定义方法&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;const fn f() {}&lt;/code&gt; 常量函数,在编译时使用&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;async fn f() {}&lt;/code&gt; Async 函数变体, f 函数 返回 impl Future&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;async fn f() -&amp;gt; S {}&lt;/code&gt; 同上 返回 impl Future&amp;lt;Output=S&amp;gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;async { x }&lt;/code&gt; 在函数内部使用, { x } 返回 impl Future&amp;lt;Output=X&amp;gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fn() -&amp;gt; S&lt;/code&gt; 函数指针,比包内存保存的地址&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Fn() -&amp;gt; S&lt;/code&gt; Callable Trait, 被闭包 impl&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;|| {}&lt;/code&gt; 闭包 borrow 捕捉变量
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;|x| {}&lt;/code&gt; 闭包参数 x&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;|x| x + x&lt;/code&gt; 闭包返回简单表达式&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;move |x| x + y&lt;/code&gt; 闭包对其捕获的所有权； 即 y 转移到闭包。&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;return || true&lt;/code&gt; 闭包有时候看其来像 or, 这里 return 的是闭包&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe&lt;/code&gt; 如果你喜欢周五晚上调试错误代码； 请使用不安全代码
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe fn f() {}&lt;/code&gt; Means “calling can cause UB, ↓ YOU must check requirements”&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe trait T {}&lt;/code&gt; Means “careless impl. of T can cause UB; implementor must check”&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe { f(); }&lt;/code&gt; Guarantees to compiler “I have checked requirements, trust me”&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe impl T for S {}&lt;/code&gt; Guarantees S is well-behaved w.r.t T; people may use T on S safely&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-control-flow&quot;&gt;4. Control Flow&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;while x {}&lt;/code&gt; 如果 x 是 true 一直执行&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;loop {}&lt;/code&gt; loop 直到 break, Can yield value with break x&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;for x in iter {}&lt;/code&gt; 语法糖 loop over iterators&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;if x {} else {}&lt;/code&gt; 条件分支&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&#x27;label: loop {}&lt;/code&gt; Loop label, 多见嵌套 loop&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;break&lt;/code&gt; beak exit a loop
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;break x&lt;/code&gt; 跳出loop with x 值&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;break &#x27;label&lt;/code&gt; 跳出 ‘label 的 loop&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;break &#x27;label x&lt;/code&gt;  跳出 ‘label loop with x 值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;continue&lt;/code&gt; 继续&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;continue &#x27;lable&lt;/code&gt; 继续 ‘lable loop&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;x?&lt;/code&gt; Result 结果错误处理&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;x.await&lt;/code&gt; async 内部使用,直到 Future or Stream x Ready&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;return x&lt;/code&gt; 提前返回值&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;f()&lt;/code&gt; 函数闭包调用&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;x.f()&lt;/code&gt; 方法调用&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;X::f(x)&lt;/code&gt; 除非 impl Copy for X {},否则只能被调用一次&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;X::f(&amp;amp;x)&lt;/code&gt; 方法调用&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;X::f(&amp;amp;mut x)&lt;/code&gt; 方法调用&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S::f(&amp;amp;x)&lt;/code&gt; Same as x.f() if X derefs to S, i.e., x.f() finds methods of S&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;T::f(&amp;amp;x)&lt;/code&gt; Same as x.f() if X impl T, i.e., x.f() finds methods of T if in scope&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;X::f()&lt;/code&gt; 调用关联函数&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;X as T&amp;gt;::f()&lt;/code&gt; 调用 trait T::f() X的实现&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5-organizing-code-组织代码&quot;&gt;5. Organizing Code 组织代码&lt;/h2&gt;

&lt;p&gt;将项目分割成更小的单元并最小化依赖性&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mod m {}&lt;/code&gt;    定义 mod, 从 {} 中获取 mod 定义代码&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mod m;&lt;/code&gt;    定义 mod, 获取定义内容 &lt;code class=&quot;highlighter-rouge&quot;&gt;m.rs&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;m/mod.rs&lt;/code&gt; 文件&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a::b&lt;/code&gt;    Namespace 路径&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;::b&lt;/code&gt;    搜索 b 相对于 crate root️&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;crate::b&lt;/code&gt;    搜索 b 相对于 crate root️&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;self::b&lt;/code&gt;    搜索 b 相对于当前 module&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;super::b&lt;/code&gt;    搜索 b 相对于当前 parent&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;use a::b;&lt;/code&gt;    直接使用.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;use a::{b, c};&lt;/code&gt;    简写 a::b a::c.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;use a::b as x;&lt;/code&gt;    重命名.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;use a::b as _;&lt;/code&gt;    将 b 匿名带入作用域，对于名称冲突的特征很有用&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;use a::*;&lt;/code&gt;    把所有的东西都带进来，只有在 a 是一些prelude&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pub use a::b;&lt;/code&gt;    将 a::b 带入范围并从此处导出&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pub T&lt;/code&gt;    导出
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pub(crate) T&lt;/code&gt;    Visible at most 1 in current crate.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pub(super) T&lt;/code&gt;    Visible at most 1 in parent.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pub(self) T&lt;/code&gt;    Visible at most 1 in current module (default, same as no pub).&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;pub(in a::b) T&lt;/code&gt;    Visible at most1 in ancestor a::b.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;extern crate a;&lt;/code&gt;    Declare dependency on external crate; just use a::b in ‘18.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;extern &quot;C&quot; {}&lt;/code&gt;    Declare external dependencies and ABI from FFI.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;extern &quot;C&quot; fn f() {}&lt;/code&gt;    Define function to be exported with ABI (e.g., “C”) to FFI.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;1 Items in child modules always have access to any item, regardless if pub or not.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;6-type-aliases-and-casts-类型别名和类型转换&quot;&gt;6. Type Aliases and Casts (类型别名和类型转换)&lt;/h2&gt;

&lt;p&gt;类型的简写名称，以及将一种类型转换为另一种类型的方法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;type T = S;&lt;/code&gt; 类型重命名(alias)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Self&lt;/code&gt; Alias implementing Type e.g. fn new() -&amp;gt; Self&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;self&lt;/code&gt; 在方法中出现 &lt;code class=&quot;highlighter-rouge&quot;&gt;fn f(self) {}&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;fn f(self: Self) {}&lt;/code&gt;等效
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;self&lt;/code&gt; 引用 borrow 等效于 fn f(self: Self) {}&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;mut self&lt;/code&gt; 引用可变 borrow 等效于 &lt;code class=&quot;highlighter-rouge&quot;&gt;fn f(self: &amp;amp;mut Self) {}&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;self: Box&amp;lt;Self&amp;gt;&lt;/code&gt; 任意自类型，为智能指针添加方法 &lt;code class=&quot;highlighter-rouge&quot;&gt;my_box.f_of_self()&lt;/code&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S as T&lt;/code&gt; 消除歧义 type S as Trait T eg &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;S as T&amp;gt;::f()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S as R&lt;/code&gt; 导入 use, 导入 S 重命名为 R, eg &lt;code class=&quot;highlighter-rouge&quot;&gt;use a::S as R&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;x as u32&lt;/code&gt; 原始类型转换&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;7-macros--attributes-宏和属性&quot;&gt;7. Macros &amp;amp; Attributes 宏和属性&lt;/h2&gt;

&lt;p&gt;在实际编译发生之前扩展代码生成结构&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;m!()&lt;/code&gt; 宏调用 also &lt;code class=&quot;highlighter-rouge&quot;&gt;m!{},m![]&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;#[attr]&lt;/code&gt; 外部属性,注解一下的item&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;#![attr]&lt;/code&gt; 内部属性,注解上面,周围的item&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;宏的内部&quot;&gt;宏的内部&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$x:ty&lt;/code&gt; 宏捕捉&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$x&lt;/code&gt; 宏替换, eg 捕捉 上一个例子 &lt;code class=&quot;highlighter-rouge&quot;&gt;$x:ty&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$(x),*&lt;/code&gt; 宏重复&amp;gt;=0次&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$(x),?&lt;/code&gt; 宏重复0 or 1次&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$(x),+&lt;/code&gt; 宏重复&amp;gt;=1次&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$(x)&amp;lt;&amp;lt;+&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;lt;&lt;/code&gt; 和 上面例子 &lt;code class=&quot;highlighter-rouge&quot;&gt;,&lt;/code&gt; 一样都是分割符&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;8-pattern-matching&quot;&gt;8. Pattern Matching&lt;/h2&gt;

&lt;p&gt;在 match 或 let 表达式或函数参数中找到的构造&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;match m {}&lt;/code&gt; 开始模式匹配&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let S(x) = get();&lt;/code&gt; let 析构&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let S { x } = s;&lt;/code&gt; x 绑定到 s.x&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let (_,b,_) = abc;&lt;/code&gt; b 绑定到 abc.1&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let (a,..) = abc;&lt;/code&gt; a 绑定到 abc.0 丢弃之后数据&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let (.., a, b) = (1,2);&lt;/code&gt; a b 绑定到最后两个元素,丢弃之前数据&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let Some(x) = get();&lt;/code&gt; 🛑 模式匹配被拒绝, 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;if let&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;if let Some(x) = get() {}&lt;/code&gt; x 被匹配到 enum 成员值, 语法糖&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;while let Some(x) = get() {}&lt;/code&gt; 一直执行 get() 如果模式匹配&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fn f(S {x} :S&lt;/code&gt; 函数参数析构, 在 f(s) 中 x 绑定到s.x&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;匹配表达式中的模式匹配 arms. 这些 arms 的左侧也可以在 let 表达式中找到&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;E::A =&amp;gt; {}&lt;/code&gt; 匹配枚举变量 A&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;E::B ( .. ) =&amp;gt; {}&lt;/code&gt; 匹配枚举 tuple 变量 B, 通配符任何索引&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;E::B { .. } =&amp;gt; {}&lt;/code&gt; 匹配枚举 struct 变量 B, 通配符任何索引&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S { x: 0, y: 1 } =&amp;gt; {}&lt;/code&gt; 匹配枚举 struct, s.x == 0 &amp;amp;&amp;amp; s.y == 1&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S { x: a, y: b } =&amp;gt; {}&lt;/code&gt; 匹配枚举 struct, 绑定 s.x 到 a,绑定 s.y 到 b&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S { x, y } =&amp;gt; {}&lt;/code&gt; 上面例子的简写&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S { .. } =&amp;gt; {}&lt;/code&gt; 匹配 struct 任意值&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;D =&amp;gt; {}&lt;/code&gt; 匹配枚举D&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_ =&amp;gt; {}&lt;/code&gt; 匹配余下的其他值&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0 | 1 =&amp;gt; {}&lt;/code&gt; 模式替代，或模式
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;E::A | E::Z&lt;/code&gt; 同上,枚举&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;E::C {x} | E::D {x}&lt;/code&gt; 同上,struct x值&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;(a, 0) =&amp;gt; {}&lt;/code&gt; 模式匹配,a = s.0 s.1 == 0&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[a, 0] =&amp;gt; {}&lt;/code&gt; 模式匹配,a = s[0]  s[1] == 0
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[1, ..] =&amp;gt; {}&lt;/code&gt; 模式匹配 Array s[0] == 1&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[1, .., 5] =&amp;gt; {}&lt;/code&gt; 模式匹配 Array 首元素 == 1 尾元素 == 5&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;[1, x @ .., 5] =&amp;gt; {}&lt;/code&gt; Same, but also bind x to slice representing middle (c. next entry)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;x @ 1..=5 =&amp;gt; {}&lt;/code&gt; Bind matched to x; pattern binding, here x would be 1, 2, … or 5
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Err(x @ Error {..}) =&amp;gt; {}&lt;/code&gt; Also works nested, here x binds to Error, esp. useful with if below&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S { x } if x &amp;gt; 10 =&amp;gt; {}&lt;/code&gt; Pattern match guards, condition must be true as well to match&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;9-generics--constraints&quot;&gt;9. Generics &amp;amp; Constraints&lt;/h2&gt;

&lt;p&gt;泛型与类型构造函数、特征和函数相结合，为您的用户提供更大的灵活性&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S&amp;lt;T&amp;gt;&lt;/code&gt; 泛型, T是泛型参数&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S&amp;lt;T: R&amp;gt;&lt;/code&gt; 泛型,参数T trait bound R, R必须是trait
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;T: R, P: S&lt;/code&gt;  泛型参数 T 绑定 trait R , 泛型参数 P 绑定 trait S&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;T: R, S&lt;/code&gt; 🛑 错误写法&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;T: R + S&lt;/code&gt;   泛型参数 T 绑定 trait R 和 S&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;T: R + &#x27;a&lt;/code&gt;  泛型参数 T 绑定 trait R 和 满足 ‘a 生命周期&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;T: ?Sized&lt;/code&gt;  泛型参数 T 禁止绑定 Sized trait&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;T: &#x27;a&lt;/code&gt;   生命周期绑定 ‘a&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;T: &#x27;static&lt;/code&gt; Same; does esp. not mean value t will 🛑 live ‘static, only that it could.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&#x27;b: &#x27;a&lt;/code&gt; ‘b 生命周期 必须和 ‘a生命周期相同&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S&amp;lt;const N: usize&amp;gt;&lt;/code&gt; Generic const bound; ? user of type S can provide constant value N.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S&amp;lt;10&amp;gt;&lt;/code&gt; Where used, const bounds can be provided as primitive values.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S&amp;lt;{5+5}&amp;gt;&lt;/code&gt; Expressions must be put in curly brackets.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S&amp;lt;T&amp;gt; where T: R&lt;/code&gt;  语法糖 &lt;code class=&quot;highlighter-rouge&quot;&gt;S&amp;lt;T: R&amp;gt;&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S&amp;lt;T&amp;gt; where u8: R&amp;lt;T&amp;gt;&lt;/code&gt; where 也可以限制其他的类型.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S&amp;lt;T = R&amp;gt;&lt;/code&gt; 泛型参数 T 默认类型 R Default type parameter BK for associated type.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S&amp;lt;&#x27;_&amp;gt;&lt;/code&gt; Inferred anonymous lifetime; asks compiler to ‘figure it out’ if obvious.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S&amp;lt;_&amp;gt;&lt;/code&gt; 匿名类型 eg  &lt;code class=&quot;highlighter-rouge&quot;&gt;let x: Vec&amp;lt;_&amp;gt; = iter.collect()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;S::&amp;lt;T&amp;gt;&lt;/code&gt; 调用函数消除未知 eg &lt;code class=&quot;highlighter-rouge&quot;&gt;f::&amp;lt;u32&amp;gt;()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;trait T&amp;lt;X&amp;gt; {}&lt;/code&gt; 泛型trait X. Can have multiple impl T for S (one per X).&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;trait T { type X; }&lt;/code&gt; Defines associated type BK  RFC X. Only one impl T for S possible.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;type X = R;&lt;/code&gt; Set associated type within impl T for S { type X = R; }.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;impl&amp;lt;T&amp;gt; S&amp;lt;T&amp;gt; {}&lt;/code&gt; 实现方法 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 必须在类型之前写出来，以使类型 &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; 代表泛型。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;impl S&amp;lt;T&amp;gt; {}&lt;/code&gt; 实现方法  &lt;code class=&quot;highlighter-rouge&quot;&gt;S&amp;lt;T&amp;gt;&lt;/code&gt;, T 是具体类型 (e.g., &lt;code class=&quot;highlighter-rouge&quot;&gt;S&amp;lt;u32&amp;gt;&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fn f() -&amp;gt; impl T&lt;/code&gt; 返回结果必须实现trait T.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fn f(x: &amp;amp;impl T)&lt;/code&gt; Trait bound, 参数x 类型必须实现 T trait, 类似于 &lt;code class=&quot;highlighter-rouge&quot;&gt;fn f&amp;lt;S:T&amp;gt;(x: &amp;amp;S)&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fn f(x: &amp;amp;dyn T)&lt;/code&gt; 标记动态分配, f 不会是单态.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fn f() where Self: R;&lt;/code&gt; In trait T {}, make f accessible only on types known to also impl R.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fn f() where Self: Sized;&lt;/code&gt; Using Sized can opt f out of dyn T trait object vtable, enabling trait obj.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fn f() where Self: R {}&lt;/code&gt; Other R useful w. dflt. methods (non dflt. would need be impl’ed anyway).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;10-higher-ranked-items&quot;&gt;10. Higher-Ranked Items&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;for&amp;lt;&#x27;a&amp;gt;&lt;/code&gt;    Marker for higher-ranked bounds
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;trait T: for&amp;lt;&#x27;a&amp;gt; R&amp;lt;&#x27;a&amp;gt; {}&lt;/code&gt;    Any S that impl T would also have to fulfill R for any lifetime.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fn(&amp;amp;&#x27;a u8)&lt;/code&gt;    Fn. ptr. type holding fn callable with specific lifetime &lt;code class=&quot;highlighter-rouge&quot;&gt;&#x27;a&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;for&amp;lt;&#x27;a&amp;gt; fn(&amp;amp;&#x27;a u8)&lt;/code&gt;    Higher-ranked  holding fn callable with any lt.; subtype of above.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fn(&amp;amp;&#x27;_ u8)&lt;/code&gt;    Same; automatically expanded to type &lt;code class=&quot;highlighter-rouge&quot;&gt;for&amp;lt;&#x27;a&amp;gt; fn(&amp;amp;&#x27;a u8)&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;fn(&amp;amp;u8)&lt;/code&gt;    Same; automatically expanded to type &lt;code class=&quot;highlighter-rouge&quot;&gt;for&amp;lt;&#x27;a&amp;gt; fn(&amp;amp;&#x27;a u8)&lt;/code&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dyn for&amp;lt;&#x27;a&amp;gt; Fn(&amp;amp;&#x27;a u8)&lt;/code&gt;    Higher-ranked (trait-object) type, works like fn above.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dyn Fn(&amp;amp;&#x27;_ u8)&lt;/code&gt;    Same; automatically expanded to type &lt;code class=&quot;highlighter-rouge&quot;&gt;dyn for&amp;lt;&#x27;a&amp;gt; Fn(&amp;amp;&#x27;a u8)&lt;/code&gt;.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;dyn Fn(&amp;amp;u8)&lt;/code&gt;    Same; automatically expanded to type &lt;code class=&quot;highlighter-rouge&quot;&gt;dyn for&amp;lt;&#x27;a&amp;gt; Fn(&amp;amp;&#x27;a u8)&lt;/code&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Yes, the &lt;code class=&quot;highlighter-rouge&quot;&gt;for&amp;lt;&amp;gt;&lt;/code&gt; is part of the type, which is why you write &lt;code class=&quot;highlighter-rouge&quot;&gt;impl T for for&amp;lt;&#x27;a&amp;gt; fn(&amp;amp;&#x27;a u8)&lt;/code&gt; below.&lt;/p&gt;

&lt;h3 id=&quot;implementing-traits-explanation&quot;&gt;Implementing TraitsExplanation&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;impl&amp;lt;&#x27;a&amp;gt; T for fn(&amp;amp;&#x27;a u8) {}&lt;/code&gt;    For fn. pointer, where call accepts specific lt. &lt;code class=&quot;highlighter-rouge&quot;&gt;&#x27;a&lt;/code&gt;, impl trait &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;impl T for for&amp;lt;&#x27;a&amp;gt; fn(&amp;amp;&#x27;a u8) {}&lt;/code&gt;    For fn. pointer, where call accepts any lt., impl trait &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;impl T for fn(&amp;amp;u8) {}&lt;/code&gt;    Same, short version.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;11-string-字符串&quot;&gt;11. String 字符串&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;...&quot;&lt;/code&gt;    String literal, UTF-8, will interpret &lt;code class=&quot;highlighter-rouge&quot;&gt;\n&lt;/code&gt; as line break &lt;code class=&quot;highlighter-rouge&quot;&gt;0xA&lt;/code&gt;, …&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;r&quot;...&quot;&lt;/code&gt;    原始字符串 不转义 &lt;code class=&quot;highlighter-rouge&quot;&gt;\n&lt;/code&gt;, …&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;r#&quot;...&quot;#&lt;/code&gt;    Raw string literal, UTF-8, but can also contain &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;&lt;/code&gt;. Number of &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; can vary.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;b&quot;...&quot;&lt;/code&gt;    Byte 字符串字面值;  ASCII &lt;code class=&quot;highlighter-rouge&quot;&gt;[u8]&lt;/code&gt;, 不是字符串类型.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;br&quot;...&quot;&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;br#&quot;...&quot;#&lt;/code&gt;    原始 byte 字符串字面值, ASCII &lt;code class=&quot;highlighter-rouge&quot;&gt;[u8]&lt;/code&gt;, combination of the above.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&#x27;🦀&#x27;&lt;/code&gt;    固定 4 byte unicode ‘char’&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;b&#x27;x&#x27;&lt;/code&gt;    ASCII byte 字面值.&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;The End&lt;/h2&gt;




&lt;p&gt;线上交流工具: 在你的terminal中输入  &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh $用户@mojotv.cn&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在你的terminal中输入  &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh mojotv.cn hn&lt;/code&gt; 查看最新 hacknews&lt;/p&gt;



            
        &lt;/article&gt;
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b5165d749dbc867f7dea9e8273b02cbe</guid>
<title>构建项目统一依赖</title>
<link>https://toutiao.io/k/f79afkf</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、概述&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了统一管理项目的依赖库，我们现在的做法基本都是自定义一个config.gradle文件，把所有的依赖都放在这里边，让每个module去引用，但是这样对于项目的拓展不够灵活，而且一些大项目这个文件可能要一二百行代码，也便于维护，下边我们来说说 如何管理我们的配置依赖以及如何管理我们的庞大的build.gradle(配置 product flavor ，格式化apk文件命名以及路径，动态生成版本号，如果 jenkins 还需要配置一些独立的逻辑那么这个文件会越来越长)文件。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、知识点介绍&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在说解决方案之前先说下用到的知识点吧，
1、Kotlin DSL：Kotlin 1.3.20 发布之后，并在多平台项目中提供了对Kotlin DSL构建脚本的支持。由于现在Kotlin是Android官方推荐语言，因此使用Kotlin构建Gradle脚本有利于整个项目开发语言的统一，不需要另外学习Groovy的语法&lt;br/&gt;2、buildSrc：运行 Gradle 时会检查项目中是否存在一个名为 buildSrc 的目录，执行编译buildSrc是在所有的build.gradle编译之前执行，所以可以把项目的配置文件放在这里统一管理，有module的每一个gradle文件去调用。&lt;br/&gt;3、Composing builds：buildSrc有一个弊端就是由于是被所有module公有引用的 所以编译会比较慢，而Composing builds可以用自定义 plugin + includeBuild插件的形式 让每一个module选择性依赖，从而提高了编译效率，这也是现在普遍选择Composing builds 的原因之一吧，而且做插件开发 也用到Composing builds。&lt;br/&gt;可以根据项目大小等实际情况选择使用buildSrc还是Composing builds&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、buildSrc方式&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、项目根目录下新建一个名为 buildSrc 的文件夹&lt;br/&gt;2、在 buildSrc 文件夹里创建名为 build.gradle.kts 的文件&lt;br/&gt;文件内容：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;plugins {&lt;br/&gt;    `kotlin-dsl`&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;repositories {&lt;br/&gt;    jcenter()&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、buildSrc下新建目录src\main\kotlin&lt;br/&gt;4、把setting.gradle 重命名为 setting.gradle.kts       所有的Kotlin DSL 文件，都是以.kts 为文件名后缀   然后修改文件里面的内容：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;include (&lt;span&gt;&quot;:app&quot;&lt;/span&gt;)&lt;br/&gt;rootProject.buildFileName = &lt;span&gt;&quot;build.gradle.kts&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把原本的 “:” 改成了 “()” 这也是Kotlin DSL和Groovy语法的差别之一&lt;br/&gt;5、把build.gradle 重命名为 build.gradle.kts&lt;br/&gt;修改内容&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;buildscript {&lt;br/&gt;    val kotlin_version = &lt;span&gt;&quot;1.3.61&quot;&lt;/span&gt; &lt;span&gt;// #1&lt;/span&gt;&lt;br/&gt;    repositories {&lt;br/&gt;        google()&lt;br/&gt;        jcenter()&lt;br/&gt;    }&lt;br/&gt;    dependencies {&lt;br/&gt;        classpath(&lt;span&gt;&quot;com.android.tools.build:gradle:4.0.0-beta01&quot;&lt;/span&gt;)  &lt;span&gt;// #2&lt;/span&gt;&lt;br/&gt;        classpath(&lt;span&gt;&quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// &lt;span&gt;NOTE:&lt;/span&gt; Do not place your application dependencies here; they belong&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// in the individual module build.gradle files&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;allprojects {&lt;br/&gt;    repositories {&lt;br/&gt;        google()&lt;br/&gt;        jcenter()&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;tasks.register(&lt;span&gt;&quot;clean&quot;&lt;/span&gt;, Delete::&lt;span&gt;&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;{  &lt;span&gt;// #3&lt;/span&gt;&lt;br/&gt;    delete(rootProject.buildDir)&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里主要修改的就是三点，我已经在代码中标识出来了：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ext改成 val，val是Kotlin不可变变量的关键字
classpath 的 单引号 改为 双引号
task 同样需要改成 Kotlin 的语法&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6、在src/main/kotlin目录下创建依赖文件
官方推荐我们使用这个文件夹来管理整个项目的依赖，也就是说，我们可以在这个路劲定义多个和依赖相关的类。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那可以根据项目情况创建多个依赖文件给module的build.gradle文件引用， 创建Dependencies.kt文件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;object Apps {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; val compileSdk = &lt;span&gt;29&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; val minSdk = &lt;span&gt;21&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; val targetSdk = &lt;span&gt;29&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; val versionCode = &lt;span&gt;1&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; val versionName = &lt;span&gt;&quot;1.0.0&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;object Versions {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; val gradle = &lt;span&gt;&quot;3.5.3&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; val kotlin = &lt;span&gt;&quot;1.3.61&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; val appcompat = &lt;span&gt;&quot;1.0.2&quot;&lt;/span&gt;&lt;br/&gt;    &lt;br/&gt;    &lt;span&gt;/* test */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; val junit = &lt;span&gt;&quot;4.12&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;object Libs {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; val kotlin = &lt;span&gt;&quot;org.jetbrains.kotlin:kotlin-stdlib-jdk7:${Versions.kotlin}&quot;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; val appcompat = &lt;span&gt;&quot;androidx.appcompat:appcompat:${Versions.appcompat}&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;object TestLibs {&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; val junit = &lt;span&gt;&quot;junit:junit:${Versions.junit}&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后我们就可以在App的build.gradle.kts里面用上这些定义的常量了&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7、修改App的build.gradle文件&lt;br/&gt;更名为build.gradle.kts&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;// 省略代码&lt;/span&gt;&lt;br/&gt;android {&lt;br/&gt;    compileSdkVersion(Apps.compileSdk)&lt;br/&gt;&lt;br/&gt;    defaultConfig {&lt;br/&gt;        applicationId = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt;        minSdkVersion(Apps.minSdk)&lt;br/&gt;        targetSdkVersion(Apps.targetSdk)&lt;br/&gt;        versionCode = Apps.versionCode&lt;br/&gt;        versionName = Apps.versionName&lt;br/&gt;    }&lt;br/&gt; &lt;span&gt;// 省略代码&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;dependencies {&lt;br/&gt;    &lt;span&gt;// android supports&lt;/span&gt;&lt;br/&gt;    implementation(Libs.appcompat)&lt;br/&gt;    &lt;span&gt;// test&lt;/span&gt;&lt;br/&gt;    testImplementation(TestLibs.junit)&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;小结&lt;/strong&gt;：&lt;br/&gt;如果项目有多个Modlue，而且依赖关系也很复杂，那么我们可以在buildSrc/src/main/kotlin 目录下多定义几个kt文件，用于管理不同的依赖。这里就不展开了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、Composing builds方式&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这种方式主要是通过自定义 plugin + includeBuild的方式来实现的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、我们新建一个 module，命名为 version ，并将上边的方式二的 buildSrc 的代码转移过来&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;DependencyVersionPlugin&lt;/span&gt; : &lt;span&gt;Plugin&lt;/span&gt;&amp;lt;&lt;span&gt;Project&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;override fun &lt;span&gt;apply&lt;/span&gt;&lt;span&gt;(project: Project)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;这里不写插件用不到可以忽略 插件名字随便起&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、在 version 的 build.gradle 文件加入&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;gradlePlugin {&lt;br/&gt;    plugins {&lt;br/&gt;        version {&lt;br/&gt;            id = &lt;span&gt;&#x27;com.test.version&#x27;&lt;/span&gt;&lt;br/&gt;            implementationClass = &lt;span&gt;&#x27;com.test.version.DependencyVersionPlugin&#x27;&lt;/span&gt;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、&lt;strong&gt;在 settings.gradle 加入 includeBuild(&quot;version&quot;)&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;includeBuild(&lt;span&gt;&quot;version&quot;&lt;/span&gt;)&lt;br/&gt;&lt;br/&gt;rootProject.name=&lt;span&gt;&#x27;VersionControlDemo&#x27;&lt;/span&gt;&lt;br/&gt;include &lt;span&gt;&#x27;:app&#x27;&lt;/span&gt;&lt;br/&gt;include &lt;span&gt;&#x27;:lib&#x27;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、接下来在需要引用的 module 中引入该插件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;plugins {&lt;br/&gt;    id &lt;span&gt;&quot;com.test.version&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后在android{}dependencies{}等里边就可以引用了，方式同buildSrc。&lt;br/&gt;另外像构建的product flavor 多渠道打包也可以单独写个kt文件去配置&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过这两种方式这么一优化我们的build.gradle 文件看着整洁多了，更便于我们去管理依赖了，当然这些方式并不适合所有的项目，看自己的项目情况而选择吧，如果需要写插件推荐用Composing builds方式（像字节码插装插件不需要打包上传可以module里引用插件调试、apt插件）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有什么问题欢迎留言沟通讨论。&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/yyLvy204xWibYjicfPdsyeYIoQ6FKZic3kJP6Uu6pHAQKnICS1f8wMJCbjJy5qhqo2FpgiaGEpyd16vhF1UTeib499A/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>fbfcec2647d48099f2d93c8cfe7ad612</guid>
<title>密码安全与会话安全</title>
<link>https://toutiao.io/k/76axohz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;entry-content&quot; itemprop=&quot;articleBody&quot;&gt;&amp;#13;
&lt;p&gt;对于登录大家并不陌生，访问系统几乎都需要登录。因为系统也不知道是谁在访问，所以需要你告诉系统你是谁，还需要证明你真的是你，如何证明？给系统展示你的密码，因为密码只有你才拥有，你有这个密码，你就能证明你真的是你，这就是一个登录。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/08/1-password-session-security-1.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/08/1-password-session-security-1.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看似简单的几个步骤，但里面涉及的安全问题却有很多。&lt;/p&gt;
&lt;h3&gt;密码存储安全&lt;/h3&gt;
&lt;p&gt;首先我们看关于密码存储安全的问题。系统服务器需要存储用户密码，才能在用户登录时验证密码的正确性，但存储就会有泄露的风险，比如数据库被偷，服务器被入侵，内部员工泄露数据，被撞库等风险。因此我们需要认真地考虑如何安全存储用户密码。 &lt;/p&gt;
&lt;p&gt;我认为作为一名软件开发工程师， 严禁明文存储密码是common sense。 那该如何解决不能明文存储密码的问题？也许看官你会说，md5 ？ 没错，md5 可以。那么md5属于什么？它是一种单向散列算法，单向散列算法主要就是通过算法生成一个摘要，来解决密码不能明文化问题。 比如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;md5(123456) = e10adc3949ba59abbe56e057f20f883e&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这样虽然能解决密码不明文化，但是它还是会存在安全问题。因为现代计算机的计算能力实在太强了，一秒可以计算十亿次 ，可以通过穷举对比的方式破解密码。这也就是所谓的&lt;strong&gt;彩虹表攻击&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;解决被彩虹表攻击的问题对密码也有一定的要求，比如要求密码的复杂度，需要不同类型的字符进行组合，在生成摘要时加点盐来防止穷举破解密码。但这就安全了吗？还不够。一次算法远远不够满足安全要求，如md5（md5（md5（password+salt））），现在往往采用自适应的方式来存储密码，可以设置重复计算一万次，盐使用随机生成的16+位字符串。&lt;/p&gt;
&lt;p&gt;这种方式虽然性能不会很好，但对于密码生成摘要存储来说，性能不好往往是好事，毕竟用户注册或修改密码只是一次操作，用户是可以接受的，但对于黑客来说，这是致命的，黑客从原来的一秒产生几百万甚至上千万的md5值，变成了一秒只能产生一个，黑客想要破解一个密码，从现代的计算机算力来看，需要上千年的时间。目前推荐的使用密码存储算法已不再推荐md5了，推荐采用&lt;strong&gt;Bcrypt Scrypt pdkdf2&lt;/strong&gt;算法。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/08/2-password-session-security.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/08/2-password-session-security-768x100.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（很多可以通过MD5/SHA值进行反向查询，都是已经存储了大量的彩虹表）&lt;/p&gt;
&lt;h3&gt;密码传输安全&lt;/h3&gt;
&lt;p&gt;解决了密码存储安全，再来看密码传输安全。有人会说使用https就能解决网络传输的安全问题，但这还是不够。浏览器到认证服务器之间请求可能会经过一层或多层gateway，如nginx，zuul，spring cloud gateway等。很多系统都是在gateway处安装证书设置https协议，浏览器到gateway处是加密传输的，但gateway到认证服务器还是http协议。&lt;/p&gt;
&lt;p&gt;攻击人可以在这条链路上窃取明文密码，那全链路https不就可以解决问题了？还不够，这些gateway内部都可能会接触到明文密码，都有密码泄露的风险，有些gateway不是我们负责的，无法保证他人会不会开个后门拿出明文密码，或者安全意识较低的程序员打印日志不小心把明文密码打印出来。那如何解决这个问题？我们可以采用浏览器传输密码之前就对密码先加密的方法。&lt;/p&gt;
&lt;p&gt;加密方式分为对称加密与非对称加密。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对称加密：加密与解密用的是同一个密钥。如DES，AES非对称加密：加密与解密用的是不同的密钥，一个叫公钥，一个叫私钥，公钥加密的数据只能由对应的私钥才能解，如RSA。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果采用对称加密方式，需要浏览器在调登录api之前，先获取认证服务器的密钥，拿到密钥后对密码进行加密传输，经过的gateway都只能获取密文，密码到了认证服务器，认证服务器再通过密钥对密文进行解密，获取到密码明文，就可以进行密码验证。但有一个安全问题，浏览器获取密钥也会经过gateway，如果gateway把密钥也打印到了日志中，密文也打印到了日志中，那攻击人同样可以通过日志获取明文密码。&lt;/p&gt;
&lt;p&gt;既然对称加密不可取，我们来看看非对称加密。浏览器登录前经过gateway获取认证服务器的公钥，使用公钥进行加密，最终密文到认证服务器，再通过私钥解密拿到明文密码进行密码认证。这种方式gateway只能拿到公钥和密文，无法解密，就算打印到日志中，攻击人无法拿到明文密码了。&lt;/p&gt;
&lt;p&gt;但这样就安全了吗？&lt;/p&gt;
&lt;p&gt;如果攻击人拿gateway中的密文直接去调认证服务器中的登录api，认证服务器一样可以通过私钥进行解密，并登录成功。所以我们还需要加一些限制：保证密文有过期时间，并且是只能使用一次。&lt;/p&gt;
&lt;p&gt;浏览器获取认证服务器公钥时，携带用户名到认证服务器，认证服务器生成随机数并与用户名关联，随机数只保存5分钟，随机数与公钥一起返回给浏览器。浏览器使用随机数加密码通过公钥一起加密调登录api，认证服务器通过私钥解密，获取到明文密码与随机数，验证随机数的有效性与合法性，都正常就进行正常登录，比较完随机数后立刻删除随机数，如不正常拒绝登录。&lt;/p&gt;
&lt;p&gt;攻击人就算获取到了密码密文，公钥，随机数，也只能在5分钟之内赶在gateway正常请求登录之前，发起登录攻击，但这个难度太大。 还有就是认证服务器保证客户端是gateway或可信的服务发起的请求，认证服务器可以对客户端做白名单限制，方式有很多种，在这就不一一赘述了。&lt;/p&gt;
&lt;p&gt;但现在就安全了吗？还真不一定。如果攻击人攻破了gateway，在浏览器请求认证服务器获取公钥时，gateway返回攻击人颁发的公钥，待用户输入完账号密码后，浏览器虽然进行了加密，数据到了gateway，攻击人再通过自己的私钥进行解密拿到明文密码，再通过明文密码在登录页进行正常的登录，同样可以登录成功。因此浏览器也需要做安全验证，验证公钥的合法性。&lt;/p&gt;
&lt;p&gt;认证服务器可以采用CA机构颁发的公钥，认证服务器与浏览器都相信CA机构（做安全总得相信点东西，如果什么都不信任就没法做安全了，有永无止境的安全问题），通过CA机构的方式验证公钥的合法性来避免中间人篡改公钥的问题（讲得不是很清楚，比如CA机构是个啥，为什么CA机构可信？这里面可聊的话题太多，有兴趣可以查看《密码学与网络安全》等书籍或一起探讨研究）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/08/3-password-session-security-1.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/08/3-password-session-security-1-768x287.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那密码安全了吗？还是远远不够。比如黑客知道了你密码的长度，可以不断地调登录或修改密码的接口来试错，总会试出来正确的密码，因此需要对任何会验证密码合法性的接口都需要加频率限制。如登录连续错了5次锁5分钟，再错5次锁半小时，防止黑客试出密码。但这种方式也有问题。如竞争对手公司不断地使用用户的账号和错误的密码去登录，导致用户的账号一直处于被锁状态，正常用户也没法使用，这就违背了安全中的可用性。那就需要加ip限制和验证码机制了。为了用户的体验性，可以做成第一次登录用户可以正常登录，错误之后，就需要使用验证码的方式登录，超过5次锁定账号，同一ip登录错误次数过多，将ip加入黑名单中。&lt;/p&gt;
&lt;h3&gt;无密码安全&lt;/h3&gt;
&lt;p&gt;密码有很多安全问题，复杂密码对于用户来说也挺麻烦的，那采用无密码技术。没有密码是不是就安全了呢？虽然现在可以采用指纹登录与刷脸登录，但新的安全问题也随之而来。密码是需要私密性的，但指纹可以从照片中获取，美国国防部某个官员因在拍照时露出了大拇指，随后就有了这个大拇指的清晰指纹图（拍照的时候不要剪刀手或点赞了，最好指纹对准自己吧，手动狗头）。&lt;/p&gt;
&lt;p&gt;还有就是存在不确定性，刷脸登录时，如果灯光太暗或太亮，脸部受伤了，化妆了，那登录能保证成功吗？脸部相似的人，登录时能保证区分开来吗？如果不能就违背了账号唯一性，日后审计也是个问题。还有一个问题就是不可修改。当密码泄露了可以修改密码，但你的指纹已经作为登录凭据了，换个手指头就好了，当十个手指头都用过了，那是不是该用脚指头了？当然无密码肯定是比有密码使用上更方便快捷，随着技术的发展，这些问题也都会解决，只是也会有更多的安全问题。&lt;/p&gt;
&lt;p&gt;我们再来看会话安全（密码安全还有各种各样的问题，篇幅有限，不再聊了）。&lt;/p&gt;
&lt;h3&gt;会话标识存储安全&lt;/h3&gt;
&lt;p&gt;登录完成后，用户不可能每一次操作都需要输入密码。因此系统需要记录用户的登录状态，又称会话状态。常见的做法是系统保存session。session存入用户信息，生成随机数sessionId，将sessionId返回浏览器，并存入浏览器的cookie中，下一次用户访问系统，携带cookie，系统通过cookie找到session，就可以知道用户是谁。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/08/4-password-session-security-1.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/08/4-password-session-security-1-768x283.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于集群服务，用户首次登陆，访问的A服务器，A服务器存入session，下次访问到了B服务器，B服务没有session，认为用户没有登陆，提示用户需登陆，这是一个bug。我们将每台服务器都识别到有session就可以解决这个问题了。session存入redis，登陆时往redis存session，之后都从redis取session。或者每台服务器都有session，每台服务器的session同步也能解决这个问题。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/08/5-password-session-security-1.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/08/5-password-session-security-1-768x317.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不管采用哪种方式，都有一个安全风险，sessionId给出去了，不论sessionId是随机数生成还是加密算出来的字符串，黑客并不关心，黑客只关心这个字符串代表了用户的会话状态。黑客也不需要拿到密码只需要拿到这个字符串，就可以模拟用户进行诈骗，转账，发表非法政治评论等非法活动。&lt;/p&gt;
&lt;p&gt;保护sessionId不被非法利用与保护密码同等重要。大多数情况下sessionId存储在cookie中，我们先了解cookie。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/08/66-password-session-security.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/08/66-password-session-security-768x68.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这是登录okta后生成的其中一个cookie，有name，value，domain，path，Expires/Max-Age，Httponly，Secure等属性，这里重点介绍其中几个。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Domain：cookie对于哪个域有效。这个cookie的域是thoughtworks.okta.com，则只有访问thoughtworks.okta.com下的api，浏览器才会将该cookie发送至后端服务器。这个值可以包含子域，如设置domain为okta.com时，访问thoughtworks.okta.com也会带上该cookie。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HttpOnly：当值为true时，告诉浏览器不能通过js访问到该cookie，只有在发送请求到后端时，才会携带该cookie。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Secure：当值为true时，告诉浏览器，只有访问协议问https的api时，才会携带该cookie。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Expires/Max-Age：cookie有两种，本地cookie与session cookie。如果设置了cookie的过期时间则为本地cookie，不设置为session cookie。session cookie的特点是没有具体的过期时间，随着浏览器关闭而清除。本地cookie即使浏览器关闭也不会清除，而是到了时间自动清除。这也是为什么关闭浏览器后再次打开浏览器有些系统需要重新登录，而有些不需要的原因。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;知道cookie的几个特性后我们再来看看攻击人常用的几种攻击方式：XSS攻击，CSRF攻击。&lt;/p&gt;
&lt;h3&gt;会话标识传输安全&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;XSS攻击&lt;/strong&gt;叫做跨站脚本攻击，指用户的输入拼接了正常的html+js+css，变成了带有攻击性的html+js+css。浏览器可能无法识别具有攻击性的html+js+css，按照正常的逻辑执行代码，这可能会导致攻击人偷走cookie（XSS还有其他的危害，但这里仅讨论与会话标识相关）。如果黑客在html中插入隐藏的form表单，通过document.cookie()获取到浏览器中cookie，作为参数并自动发送post请求到攻击人的后端api中，攻击人就可以拿到用户的cookie，也就可以拿到sessionId了。这种方式可以通过设置cookie的HttpOnly为true来防止js获取cookie值。从而避免通过XSS攻击获取sessionId。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CSRF攻击&lt;/strong&gt;叫做跨站请求伪造。XSS攻击是指本网站的代码执行攻击脚本造成了对本网站的影响。CSRF攻击则是用户打开了其他网站，浏览器执行了其他网站的攻击脚本，却对本网站造成了伤害。举个例子，当我在浏览器中登录了某银行的网站，进行了转账操作，浏览器调用了&lt;code&gt;https://www.xxx.com/transfertoBankId=123456&amp;amp;money=100&lt;/code&gt;，我的账户少了100块，收到短信扣了100块。这时来了一封邮件，标题为你想得到力量吗？内容是一个链接，我点击这个链接，看到url是&lt;code&gt;www.yyy.com/index.htm&lt;/code&gt;，立马又收到一个短信，我账号又少了1000块，我刷新下页面，又少1000块。打开页面查看源码，发现有个隐藏的标签，&lt;code&gt;src=https://www.xxx.com/transfertoBankId=123456&amp;amp;money=1000&lt;/code&gt;。也就意味着每次刷新页面，浏览器都会执行一次&lt;code&gt;https://www.xxx.com/transfer?toBankId=123456&amp;amp;money=1000 GET&lt;/code&gt;请求。&lt;/p&gt;
&lt;p&gt;大多数浏览器有同源策略（协议\主机\端口组成源），其中一个限制是同源的网页才会共享cookie。但浏览器对html标签有白名单，img就是其中之一，通过img标签的src就可以发送get 请求，因访问的是xxx(银行)的域名，携带了cookie，银行认为是合法请求，转账成功。因img是get请求，那把转账等高危操作改成post接口不就可以了? 也不行，因为form表单的post请求也在白名单中。&lt;/p&gt;
&lt;p&gt;CSRF攻击之所以成功，是因为攻击人可以完全伪造用户的请求，那让攻击人无法伪造就可以解决这个问题了。在转账时，要求用户再次输入密码或输入验证码，就可以解决CSRF攻击。转账操作可以这么做，发表评论这类的操作，每次都要求用户输入密码或验证码用户体验就很很差了。&lt;/p&gt;
&lt;p&gt;还有&lt;strong&gt;Referer check&lt;/strong&gt;，浏览器发送请求时，携带Referer header，值为网站url中的域名，异常转账时，虽然调用的&lt;code&gt;www.xxx.com&lt;/code&gt; 的api，但referer 值为&lt;code&gt;www.yyy.com&lt;/code&gt;。在服务端只要验证Referer值就可以判断这是不是一个CSRF攻击。这种方式也有问题，就是完全相信了第三方（浏览器）。对于低版本的浏览器已经有办法可以篡改Referer值，高版本的浏览器目前无法篡改，如用户使用低版本的浏览器，Referer check将无法保证安全性。&lt;/p&gt;
&lt;p&gt;那还有什么办法可以解决CSRF攻击的问题? 我们来看下okta是如何做到解决这个问题的。我们登陆okta成功后，打开网页源代码查看html，搜索token可以看到&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/08/6-password-session-security.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/08/6-password-session-security-768x129.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在span中保存了一个token值 我们再创建一个tab页&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/08/7-password-session-security.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/08/7-password-session-security-768x241.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;打开浏览器的f12，查看网络请求，可以看到request header中有x-okta-xcrftoken这个header。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/08/8-password-session-security.png&quot;&gt;&lt;img src=&quot;https://insights.thoughtworks.cn/wp-content/uploads/2021/08/8-password-session-security-768x190.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这就是为了解决CSRF攻击的方式：CSRF Token方式.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;csrf token&lt;/strong&gt;工作原理就是在用户登录成功后，服务端生成token并保存一段时间，返回给浏览器，浏览器保存在html标签中。当用户操作访问后端api时，将该token放入request header中。后端验证该token 的合法性即可判断是否是CSRF攻击。这种方式能生效的重点在于攻击人无法拿到目标网站的html。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最近在思考一个问题，就是如果黑客同时发起XSS攻击和CSRF攻击，这种方式是不是也失效了？黑客通过XSS攻击，获取到了CSRF token，攻击人立马发送钓鱼邮件给目标用户，目标用户点击了链接，网站打开时，先从黑客处获取CSRF Token，并携带CSRF Token发起了CSRF攻击，还有个前提是浏览器版本太低没有Referer，那不就可以攻击成功了？（我杞人忧天了吗？） cookie+session有这么多安全需要考虑，那不要cookie+session不就没这么多问题吗?现在流行的jwt就可以做到无session的登录认证，但jwt也有各种各样的安全问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下回再聊jwt与单点登录中的安全。&lt;/p&gt;
&amp;#13;
&lt;/div&gt;&amp;#13;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>09b7b1614111201641c2ecb94abae4f0</guid>
<title>理解 L1 和 L2 正则化的正确姿势</title>
<link>https://toutiao.io/k/jzxzwx9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;a class=&quot;weui-flex original_primary_card appmsg_card_context appmsg_card_active&quot; href=&quot;#&quot; id=&quot;copyright_info&quot;&gt;
                                
                                &lt;div class=&quot;weui-flex__item&quot; role=&quot;option&quot;&gt;
                                    &lt;strong class=&quot;original_primary_nickname&quot;&gt;SimpleAI&lt;/strong&gt;
                                                                            &lt;span class=&quot;weui-hidden_abs&quot;&gt;.&lt;/span&gt;
                                        &lt;p class=&quot;original_primary_desc&quot;&gt;人工智能、机器学习、深度学习还是遥不可及？来这里看看吧~&lt;/p&gt;
                                                                    &lt;/div&gt;
                                &lt;p class=&quot;weui-flex__ft&quot;/&gt;
                            &lt;/a&gt;
                        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>