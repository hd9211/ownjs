<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>e8a0e5a8c2a3deb852f16e6f1b3f6c0a</guid>
<title>盘点 7 月份 yyds 的开源项目</title>
<link>https://toutiao.io/k/i4jzqp3</link>
<content:encoded>&lt;div&gt;&lt;div&gt;

                

                
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8834df75db98b679c32aff68cf562f2d</guid>
<title>计算机网络：TCP 协议原理总结</title>
<link>https://toutiao.io/k/2cf32un</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;post-body&quot;&gt;
  &lt;p&gt;本文总结 TCP 协议的原理，包括：&lt;/p&gt;



&lt;p&gt;&lt;span class=&quot;marked&quot;&gt;
本文笔记目的，内容较多。
TCP 协议非常复杂，
读完本文需要许多耐心
&lt;/span&gt;。&lt;/p&gt;
      &lt;h3 id=&quot;网络是不可靠的&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          网络是不可靠的 &lt;a href=&quot;#网络是不可靠的&quot; class=&quot;heading-anchor&quot;&gt;¶&lt;/a&gt;
        
        &lt;/span&gt;
      &lt;/h3&gt;

&lt;p&gt;&lt;span class=&quot;marked&quot; id=&quot;root-of-evil&quot;&gt;
计算机网络是不可靠的，存在 &lt;strong&gt;丢包&lt;/strong&gt;、&lt;strong&gt;乱序&lt;/strong&gt;、&lt;strong&gt;延时&lt;/strong&gt;
&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;这是众多 TCP 协议机制的设计出发点，万恶之源，将贯穿全文。&lt;/p&gt;
    
      &lt;h3 id=&quot;tcp-概念和特点&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          TCP 概念和特点 &lt;a href=&quot;#tcp-概念和特点&quot; class=&quot;heading-anchor&quot;&gt;¶&lt;/a&gt;
        
        &lt;/span&gt;
      &lt;/h3&gt;

&lt;p&gt;TCP 协议全称 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE&quot; target=&quot;_blank&quot;&gt;传输控制协议&lt;/a&gt;，
是一种 &lt;strong&gt;面向连接的&lt;/strong&gt;、&lt;strong&gt;可靠的&lt;/strong&gt;、&lt;strong&gt;面向字节流的&lt;/strong&gt; 传输层通信协议。&lt;/p&gt;

&lt;p&gt;TCP 在 &lt;a href=&quot;https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F#TCP/IP%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B&quot; target=&quot;_blank&quot;&gt;TCP/IP 协议模型&lt;/a&gt;
中位于传输层。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-1.1.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-1.1.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 1.1 - TCP 位于 TCP/IP 分层中的传输层
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;TCP/IP 模型中各层数据包结构的关系如下图。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-1.2.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-1.2.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 1.2 - TCP/IP 模型中各层数据包结构的关系
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;TCP 协议的主要特点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;面向连接&lt;/strong&gt;，一对一通信。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;可靠交付&lt;/strong&gt;：保序、不重复、不丢失。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;全双工通信&lt;/strong&gt;：双方均可收发。&lt;/li&gt;
  &lt;li&gt;和上层应用进程的交互方式是 &lt;strong&gt;面向字节流的&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;TCP 和上层应用进程的交互方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;发送方可以发送不同大小的数据块到发送缓存。&lt;/li&gt;
  &lt;li&gt;先会对发送缓存内的数据分段，打包成 TCP 数据包再发送。&lt;/li&gt;
  &lt;li&gt;在接收一侧，数据包会先进入接收缓存区。&lt;/li&gt;
  &lt;li&gt;当一定数量的数据包全部到达，重排、组装，以数据流方式吐给接收方。&lt;/li&gt;
&lt;/ol&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-1.3.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-1.3.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 1.3 - TCP 和应用程序的交互方式
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;虽然 TCP 是面向字节流的，但是 TCP 所处理的数据单元却是面向报文段的，
也就是本文所说的数据包。&lt;/p&gt;

&lt;p&gt;将看到，短短 &lt;strong&gt;可靠交付&lt;/strong&gt; 四字背后并不简单。&lt;/p&gt;
    
      &lt;h3 id=&quot;可靠传输的基础机制&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          可靠传输的基础机制 &lt;a href=&quot;#可靠传输的基础机制&quot; class=&quot;heading-anchor&quot;&gt;¶&lt;/a&gt;
        
        &lt;/span&gt;
      &lt;/h3&gt;

&lt;p&gt;若不止考虑 TCP 协议本身的实现，如何设计可靠的网络通信？&lt;/p&gt;

&lt;p&gt;首先，由于 &lt;a href=&quot;#root-of-evil&quot;&gt;丢包的可能性&lt;/a&gt;，要实现可靠通信：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;发送方要知道对方接收成功，因此需要接收方回复确认 即 ACK。&lt;/li&gt;
  &lt;li&gt;如果丢包发生，发送方需要重传。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一种触发重传的方式是，超时重传
（也有其他触发方法，见后续 &lt;a href=&quot;#tcp-重传机制&quot;&gt;TCP 重传机制&lt;/a&gt; ）。&lt;/p&gt;

&lt;p&gt;此外，无论往返中哪个包丢失或延迟，
&lt;span class=&quot;marked&quot;&gt;
发送方认为对方没有收到，就会重传
&lt;/span&gt;。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-2.1.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-2.1.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 2.1 - 确认和超时重传机制的几种情况
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;网络延时发生时，重传可能会导致重复：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;接收方会丢弃收到的重复数据包，但是仍然回复确认。&lt;/li&gt;
  &lt;li&gt;发送方会丢弃收到的重复确认包。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;其次，对于如何发送确认包和重传包，有两种方式。&lt;/p&gt;
    
      &lt;h5 id=&quot;一问一答的方式&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          一问一答的方式
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;也叫做 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%87%AA%E5%8A%A8%E9%87%8D%E4%BC%A0%E8%AF%B7%E6%B1%82#%E5%81%9C%E6%AD%A2%E5%B9%B6%E7%AD%89%E5%BE%85ARQ%E5%8D%8F%E8%AE%AE%EF%BC%88stop-and-wait%EF%BC%89&quot; target=&quot;_blank&quot;&gt;停止并等待 ARQ 协议&lt;/a&gt;，
是指
&lt;span class=&quot;marked&quot;&gt;
发送方等到接收方的确认包后，再发下一个数据包
&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;类似乒乓方式，具体来说：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果时限内收到对方确认，才发送下一个数据包。&lt;/li&gt;
  &lt;li&gt;否则，重传当前数据包。&lt;/li&gt;
&lt;/ol&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-2.2.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-2.2.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 2.2 - 一问一答的方式
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;可以看到这种方式下，发送方大部分时间在等待，效率非常低。&lt;/p&gt;
    
      &lt;h5 id=&quot;流水线传输的方式&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          流水线传输的方式
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;叫做 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E8%87%AA%E5%8A%A8%E9%87%8D%E4%BC%A0%E8%AF%B7%E6%B1%82#%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE%EF%BC%88Continuous_ARQ%EF%BC%89&quot; target=&quot;_blank&quot;&gt;连续 ARQ 协议&lt;/a&gt; ,
是指
&lt;span class=&quot;marked&quot;&gt;
发送方会连续发送一组数据包，同时等待这些数据包的确认
&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;具体来说：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;发送方发送一批数据包。&lt;/li&gt;
  &lt;li&gt;同步地接收对方的确认包。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;简单来说，
&lt;span class=&quot;marked&quot;&gt;
发送方不闲着，一边发送，一边等回复
&lt;/span&gt;。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-2.3.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-2.3.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 2.3 - 流水线传输的方式
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;可以看到这种方式相对一问一答的方式，效率要高。&lt;/p&gt;

&lt;p&gt;&lt;span id=&quot;retransmit-methods&quot;&gt;
如果发生丢包或延时，需要重传，有两种方式&lt;/span&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;span id=&quot;go-back-n-retransmit&quot;&gt;&lt;strong&gt;回退 N 重传&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

    &lt;p&gt;发送方每发送一个数据包，都会发起一个定时器。&lt;/p&gt;

    &lt;p&gt;一旦一个某个定时器触发，就会重传。&lt;/p&gt;

    &lt;p&gt;发送指针回退到未拿到确认的数据包处，以实现重传。&lt;/p&gt;

    &lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-2.4.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-2.4.jpg&quot; alt=&quot;&quot;/&gt;
    
     
    &lt;figcaption&gt;图 2.4 - 回退 N 重传的方式
       
    &lt;/figcaption&gt;
     
   
 &lt;/figure&gt;
    &lt;p/&gt;

    &lt;p&gt;可以看到，此方法下，
&lt;span class=&quot;marked&quot;&gt;会重传后面所有的数据包&lt;/span&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;span id=&quot;selective-retransmit&quot;&gt;&lt;strong&gt;选择重传&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

    &lt;p&gt;同样，每发送一个数据包，都会发起一个定时器。&lt;/p&gt;

    &lt;p&gt;不同点仅在于， 只重传未拿到确认的数据包，不回退发送指针。&lt;/p&gt;

    &lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-2.5.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-2.5.jpg&quot; alt=&quot;&quot;/&gt;
    
     
    &lt;figcaption&gt;图 2.5 - 选择重传的方式
       
    &lt;/figcaption&gt;
     
   
 &lt;/figure&gt;
    &lt;p/&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;综合以上，得出的结论是，不考虑 TCP 协议的具体实现的话，
要实现可靠的网络通信，需要依赖确认和重传机制，
并且一个好的办法是采用流水线传输的方式。&lt;/p&gt;

&lt;p&gt;而流水线传输方式，正是下一个部分 TCP 协议中的
&lt;a href=&quot;#滑动窗口机制&quot;&gt;滑动窗口机制&lt;/a&gt; 的引子。&lt;/p&gt;
    
      &lt;h3 id=&quot;tcp-滑动窗口机制&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          TCP 滑动窗口机制 &lt;a href=&quot;#tcp-滑动窗口机制&quot; class=&quot;heading-anchor&quot;&gt;¶&lt;/a&gt;
        
        &lt;/span&gt;
      &lt;/h3&gt;

&lt;p&gt;&lt;span class=&quot;marked&quot;&gt;
滑动窗口机制是 TCP 协议的精髓所在，它是 TCP 协议设计的基本框架
&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;滑动窗口机制就是 &lt;a href=&quot;#流水线传输的方式&quot;&gt;流水线传输方式&lt;/a&gt; 在 TCP 协议中的细化设计，
发送方一边连续地发送数据包，一边等待接收方的确认。&lt;/p&gt;

&lt;p&gt;滑动窗口分为两种：&lt;a href=&quot;#发送窗口&quot;&gt;发送窗口&lt;/a&gt; 和 &lt;a href=&quot;#接收窗口&quot;&gt;接收窗口&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;由于 TCP 是全双工的，
&lt;span class=&quot;marked&quot;&gt;
所以通信的每一端都会同时维护两种窗口
&lt;/span&gt;。&lt;/p&gt;
    
      &lt;h5 id=&quot;数据包序号&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          数据包序号
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;在 &lt;a href=&quot;#可靠传输的基础机制&quot;&gt;可靠传输的基础机制&lt;/a&gt; 中，
接收的数据包可能是重复的、乱序的，因此 TCP 会对每一个数据包进行唯一标号，
叫做数据包的序号。&lt;/p&gt;

&lt;p&gt;数据包的序号是 &lt;a href=&quot;#tcp-协议头&quot;&gt;TCP 协议头&lt;/a&gt; 中的一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;32&lt;/code&gt; 比特大小的整数字段。&lt;/p&gt;

&lt;p&gt;每次发送一个包，这个序号就会增加一。&lt;/p&gt;

&lt;p&gt;TCP 是全双工的，两个通信端各自维护自己的序号。&lt;/p&gt;

&lt;p&gt;因为 &lt;a href=&quot;#root-of-evil&quot;&gt;网络延时不可控&lt;/a&gt;，
如果两次连接建立时差很短、或者连接重建后老连接的数据包延迟到达，
会造成序号冲突。&lt;/p&gt;

&lt;p&gt;所以，序号并非由固定数字初始化。可以综合时间、随机数来生成等。&lt;/p&gt;
    
      &lt;h5 id=&quot;确认号和累计确认&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          确认号和累计确认
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;在 TCP 中，一个用以确认的回复包，会有确认号。&lt;/p&gt;

&lt;p&gt;如果一个数据包同时也是一个确认包，那么它也会有确认号。&lt;/p&gt;

&lt;p&gt;一个序号为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SEQ&lt;/code&gt; 的数据包，其确认包的确认号会是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SEQ+1&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;同样，确认号也是 &lt;a href=&quot;#tcp-协议头&quot;&gt;TCP 协议头&lt;/a&gt; 中的一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;32&lt;/code&gt; 比特大小的整数字段。&lt;/p&gt;

&lt;p&gt;可以理解为，接收方已收到序号为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SEQ&lt;/code&gt; 的数据包，期待发送方下一次给 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SEQ+1&lt;/code&gt; 的包。&lt;/p&gt;

&lt;p&gt;更广义的理解是， &lt;span class=&quot;marked&quot;&gt;
确认号是接收方期望对方发送的下一个包的序号
&lt;/span&gt; 。&lt;/p&gt;

&lt;p&gt;下图中，发送方连续发送一组包，如果中间有丢包，
接收方则期待序号最小的丢失的包。当重传成功后，
接收方仍然期待下一个未拿到的数据包：&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-3.1.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-3.1.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 3.1 - 接收方的确认号
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;&lt;span class=&quot;marked&quot;&gt;
接收方所期待的是序号最小的没拿到的数据包
&lt;/span&gt; 。&lt;/p&gt;

&lt;p&gt;这种确认号的机制，即可实现累计确认机制：&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;marked&quot;&gt;
接收方确认了标号为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SEQ&lt;/code&gt; 的数据包，
即代表确认了所有小于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SEQ&lt;/code&gt; 的数据包，
此时接收方给的确认号是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SEQ+1&lt;/code&gt;
&lt;/span&gt; 。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-3.2.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-3.2.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 3.2 - 累计确认机制
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;累计确认其实是一种批量确认的机制，以减少确认包的数量。&lt;/p&gt;

&lt;p&gt;此外，如果接收方恰好需要发送数据，确认号可以直接标在数据包上，即捎带确认。&lt;/p&gt;

&lt;p&gt;一个问题是，如何控制累计确认的时机？&lt;/p&gt;

&lt;p&gt;&lt;span id=&quot;tcp-nagle&quot;&gt;
TCP 协议中的 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%B4%8D%E6%A0%BC%E7%AE%97%E6%B3%95&quot; target=&quot;_blank&quot;&gt;Nagle 算法&lt;/a&gt;
给出的办法是 &lt;a href=&quot;https://zh.wikipedia.org/wiki/TCP%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4&quot; target=&quot;_blank&quot;&gt;延迟确认&lt;/a&gt;。
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;其大概的原理是，未确认的包达到一定量、或者达到一个时间阈值，才回复一次确认。&lt;/p&gt;

&lt;p&gt;所以说，
&lt;span class=&quot;marked&quot;&gt;
在默认的 TCP 协议中，确认不是立即回复的，而是延迟的
&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;不过，接收方的延迟确认不应该过分延迟，否则会造成发送方的重传，浪费网络资源。&lt;/p&gt;

&lt;p&gt;可以设置 &lt;a href=&quot;https://man7.org/linux/man-pages/man7/tcp.7.html&quot; target=&quot;_blank&quot;&gt;TCP_NODELAY 选项&lt;/a&gt; 来禁用 Nagle 算法。&lt;/p&gt;

&lt;p&gt;TCP 的累计确认机制，是累计确认和延迟确认两个策略的综合。&lt;/p&gt;

&lt;p&gt;此外，TCP 协议还有另外一种确认机制，叫做 &lt;a href=&quot;#选择确认机制&quot;&gt;选择确认机制&lt;/a&gt; ，将会后面讲到。&lt;/p&gt;
    
      &lt;h5 id=&quot;发送机制&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          发送机制
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;已经讲过，TCP 协议默认的 &lt;a href=&quot;#tcp-nagle&quot;&gt;Nagle 算法&lt;/a&gt; 采用了延迟确认的方法。&lt;/p&gt;

&lt;p&gt;对应的，发送的时机如何确定？&lt;/p&gt;

&lt;p&gt;办法是类似的，大概是，未发送的包达到一定量、或者达到一个时间阈值，才发送一次。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-3.2.1.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-3.2.1.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 3.2.1 - Nagle 算法的发送机制
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;TCP 的发送机制，是累计发送和延迟发送两个策略的综合。&lt;/p&gt;

&lt;p&gt;同样可以设置 &lt;a href=&quot;https://man7.org/linux/man-pages/man7/tcp.7.html&quot; target=&quot;_blank&quot;&gt;TCP_NODELAY 选项&lt;/a&gt;
来关闭延迟发送的行为。&lt;/p&gt;
    
      &lt;h5 id=&quot;发送窗口&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          发送窗口
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;发送窗口的示意图如下，当收到对方的累计确认后，则向右滑动。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-3.3.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-3.3.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 3.3 - 发送窗口
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;注意的是 &lt;a href=&quot;#窗口大小&quot;&gt;窗口大小&lt;/a&gt; 是有限的（稍后将讨论它的受限情况），
&lt;span class=&quot;marked&quot; id=&quot;sender-window-limitation&quot;&gt;
发送方只能发送窗口内的数据包
&lt;/span&gt;。&lt;/p&gt;
    
      &lt;h5 id=&quot;接收窗口&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          接收窗口
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;接收窗口的示意图如下，当回复对方确认后，则向右滑动。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-3.4.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-3.4.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 3.4 - 发送窗口
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;仍需注意 &lt;a href=&quot;#窗口大小&quot;&gt;窗口大小&lt;/a&gt; 是有限的（稍后将讨论它的受限情况），
&lt;span class=&quot;marked&quot;&gt;
接收方只能接收窗口内的数据包
&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;由于 &lt;a href=&quot;#root-of-evil&quot;&gt;网络数据包是乱序的&lt;/a&gt; ，
所以接收后的数据包会按照序号重新排序，才可以交付给应用程序。&lt;/p&gt;
    
      &lt;h5 id=&quot;窗口大小&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          窗口大小
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;&lt;span class=&quot;marked&quot;&gt;
窗口的大小是受限的，也是动态的
&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;窗口大小是 &lt;a href=&quot;#tcp-协议头&quot;&gt;TCP 协议头&lt;/a&gt; 中的一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;16&lt;/code&gt; 比特大小的整数字段。&lt;/p&gt;

&lt;p&gt;首先，显然
&lt;span class=&quot;marked&quot;&gt;
接收窗口受限于接收缓存区的大小，
发送窗口受限于发送缓存区的大小
&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;其次指出，
&lt;span class=&quot;marked&quot; id=&quot;sender-window-limitation-1&quot;&gt;
发送窗口大小也受限于接收窗口大小
&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;这其实比较容易理解，发送方是生产者，接收方是消费者，
如果生产速度快而消费速度慢，则会导致接收方来不及接收。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-3.5.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-3.5.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 3.5 - 生产者和消费者
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;所以，&lt;a href=&quot;#sender-window-limitation&quot;&gt;发送方只能发送窗口内的数据包&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;其实，这就是 &lt;a href=&quot;#tcp-流量控制机制&quot; target=&quot;_blank&quot;&gt;流量控制机制&lt;/a&gt; ：
&lt;span class=&quot;marked&quot;&gt;
由接收方控制的、调节发送方生产速度的机制
&lt;/span&gt;，
其具体的实现方式，就是在回复时设置 &lt;a href=&quot;#tcp-协议头&quot;&gt;TCP 协议头&lt;/a&gt; 中的窗口大小字段。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;marked&quot;&gt;
窗口的大小也是动态变化的，
因为两端接收和发送能力是动态变化的
&lt;/span&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;接收能力的变化导致窗口大小的变化，即后面所讲的 &lt;a href=&quot;#tcp-流量控制机制&quot;&gt;TCP 流量控制机制&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;发送能力的变化导致窗口大小的变化，即后面所讲的 &lt;a href=&quot;#tcp-拥塞控制机制&quot;&gt;TCP 拥塞控制机制&lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;可以看到，滑动窗口的大小是一个贯穿式的重要概念。&lt;/p&gt;

&lt;p&gt;但是，如果窗口要缩小，窗口的前沿是不可以向前收缩的。&lt;/p&gt;

&lt;p&gt;窗口收缩的方法则是，慢慢地，随着已发送的数据包得到确认，
保持窗口前沿不动，前移窗口后沿。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-3.6.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-3.6.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 3.6 - 窗口前沿不可以收缩
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;因此，
&lt;span class=&quot;marked&quot;&gt;
发送窗口也并不总和接收窗口一样大
&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;窗口大小的初始化，是在 &lt;a href=&quot;#连接建立和释放&quot;&gt;连接建立&lt;/a&gt; 过程中两端协商确定的，
在后续的传输阶段，它会因主动或被动的原因而动态变化。&lt;/p&gt;
    
      &lt;h5 id=&quot;选择确认机制&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          选择确认机制
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;和前面所讲的 &lt;a href=&quot;#确认号和累计确认&quot;&gt;累计确认机制&lt;/a&gt; 一样，
都是 TCP 协议中用来控制如何回复确认包的机制。&lt;/p&gt;

&lt;p&gt;因为网络丢包、延时、乱序的不确定性，序号大的包可能先到达。&lt;/p&gt;

&lt;p&gt;如果仅采用累计确认机制，发送方并不知道大号的包传输成功了，
它只会执行 &lt;a href=&quot;#go-back-n-retransmit&quot;&gt;回退 N 重传&lt;/a&gt; ，
将后面的所有包重传。&lt;/p&gt;

&lt;p&gt;下图中，如果接收方的回复包丢失或延迟、
或发送方的速率较快，就会导致短时间内多次无效重传。
接收方则不得不丢弃重复数据。
造成信道资源浪费。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-3.7.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-3.7.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 3.7 - 累计确认机制的无必要重传
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;选择确认机制，简记作 SACK，是指
&lt;span class=&quot;marked&quot;&gt;
接收方在回复确认包 ACK 的同时，
告诉对方已收到数据包的序号区间
&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;比如，在回复对方 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACK=10&lt;/code&gt; 的时候，同时回复 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SACK=20,39&lt;/code&gt; ，
这表示接收方已经收到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;20~39&lt;/code&gt; 序号的数据包。
发送方只需要重传 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;10~19&lt;/code&gt; 就可以了。&lt;/p&gt;

&lt;p&gt;下图中同样的场景，可以看到开启选择确认机制，
可以一定程度上优化无意义的重传。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-3.8.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-3.8.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 3.8 - 选择确认机制
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;如果接收方采用了选择确认机制，
那么发送方就可以采用前面所讲的 &lt;a href=&quot;#selective-retransmit&quot;&gt;选择重传&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;所以，选择确认机制是搭配选择重传机制一块使用的。&lt;/p&gt;

&lt;p&gt;这个机制是可选的，需要两端都支持，在 &lt;a href=&quot;#tcp-连接建立和释放&quot;&gt;TCP 连接建立&lt;/a&gt; 阶段，
两端协商确定是否采用此机制。&lt;/p&gt;
    
      &lt;h3 id=&quot;tcp-重传机制&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          TCP 重传机制 &lt;a href=&quot;#tcp-重传机制&quot; class=&quot;heading-anchor&quot;&gt;¶&lt;/a&gt;
        
        &lt;/span&gt;
      &lt;/h3&gt;

&lt;p&gt;重传机制是 TCP 协议中比较复杂的部分。&lt;/p&gt;

&lt;p&gt;其触发方式有两种：&lt;a href=&quot;#超时重传和超时计算&quot;&gt;超时重传&lt;/a&gt; 和 &lt;a href=&quot;#快速重传机制&quot;&gt;快速重传&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;其具体实施方式又有两种，前面所讲的 &lt;a href=&quot;#retransmit-methods&quot;&gt;回退 N 重传&lt;/a&gt; 和 &lt;a href=&quot;#retransmit-methods&quot;&gt;选择重传&lt;/a&gt; 。&lt;/p&gt;
    
      &lt;h5 id=&quot;超时重传和超时计算&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          超时重传和超时计算
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;前面 &lt;a href=&quot;#可靠传输的基础机制&quot;&gt;可靠传输的基础机制&lt;/a&gt; 有讲到超时重传，
&lt;span class=&quot;marked&quot;&gt;
TCP 协议每发送一个数据包，就对这个数据包设置一次计时器
&lt;/span&gt;，超时即触发重传。&lt;/p&gt;

&lt;p&gt;超时重传中的一个问题是：超时的时间是多少呢？&lt;/p&gt;

&lt;p&gt;这是 TCP 协议中又一个复杂的问题。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果超时重传时间设置太短，会引起不必要的重传。&lt;/li&gt;
  &lt;li&gt;如果设置太长，会使得网络空闲时间增大，降低传输效率。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;TCP 采用一种自适应算法，具体地，是一种加权平均的方法。&lt;/p&gt;

&lt;p&gt;首先，记录每个数据包发出去后到收到确认包的时间差，叫做往返时间 RTT 。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-4.1.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-4.1.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 4.1 - 往返时间的方差可能会很大
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;具体的，假设加权平均后的数据叫做 $T$ ，其计算方式：&lt;/p&gt;&lt;p&gt;

\[{T}_{n} = (1 - \alpha) \times {T}_{n-1} + \alpha \times {RTT}_{n}\]

&lt;/p&gt;&lt;p&gt;其中 $ 0 \leq \alpha &amp;lt; 0$ 。&lt;/p&gt;

&lt;p&gt;这个计算式的意思是，一部分权重考虑实时数据，另一部分权重考虑历史沉淀。&lt;/p&gt;

&lt;p&gt;可以知道，$\alpha$ 越大，新数据的贡献越大，$T$ 跟随 $RTT$ 的就越快。
反之，$\alpha$ 越小，新数据的贡献越小，$T$ 跟随 $RTT$ 的就越慢。&lt;/p&gt;

&lt;p&gt;按这个计算式迭代下去，历史数据的权重会越来越小，$T$ 会跟随实时数据的趋势。&lt;/p&gt;

&lt;p&gt;同时，由于综合了历史数据，又可以消除毛刺。&lt;/p&gt;
    
      &lt;h5 id=&quot;快速重传机制&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          快速重传机制
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;TCP 的另一种重传机制，是快速重传机制，它不再以超时作为触发标准，
而是观察确认包的情况。&lt;/p&gt;

&lt;p&gt;具体来说，
&lt;span class=&quot;marked&quot;&gt;
如果收到同一个数据包的多次确认，立即发起重传
&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;一般取 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;3&lt;/code&gt; 次作为阈值，常叫做 3ACK 方法。&lt;/p&gt;

&lt;p&gt;快速重传机制的作用在于，将有可能在超时触发之前，提前发起重传。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-4.2.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-4.2.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 4.2 - 收到同一个数据包的 3 次确认即发起重传
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;细节地，
因为每发送一个数据包，就会对这个包设置一次定时器，
所以，快速重传触发后不会造成超时重传的重新触发。&lt;/p&gt;
    
      &lt;h3 id=&quot;tcp-流量控制机制&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          TCP 流量控制机制 &lt;a href=&quot;#tcp-流量控制机制&quot; class=&quot;heading-anchor&quot;&gt;¶&lt;/a&gt;
        
        &lt;/span&gt;
      &lt;/h3&gt;

&lt;p&gt;前面 &lt;a href=&quot;#窗口大小&quot;&gt;窗口大小&lt;/a&gt; 部分已经提及，
如果数据发送过快，接收方就会来不及接收。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;marked&quot;&gt;
流量控制，就是接收方调控对方的发送速度不要太快的机制
&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#sender-window-limitation-1&quot;&gt;发送窗口的大小受限于接收窗口&lt;/a&gt; ，
接收方在回复时通过设置 &lt;a href=&quot;#tcp-协议头&quot;&gt;TCP 协议头&lt;/a&gt; 中的窗口大小字段，
来限制发送方的发送窗口大小。&lt;/p&gt;

&lt;p&gt;需要注意的是，
&lt;span class=&quot;marked&quot;&gt;
流量控制过程是动态的
&lt;/span&gt; 。&lt;/p&gt;

&lt;p&gt;&lt;span id=&quot;window-size-scalable-reason&quot;&gt;
其原因在于，两端的发送和接收数据的能力是动态变化的
&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;以接收方为例，
哪怕我们假设缓存区的大小未发生变化，上层应用程序读取数据数据的能力也是动态变化的。&lt;/p&gt;

&lt;p&gt;比如，接收方应用程序因为负载升高，无法及时读取缓存区数据，
导致已回复数据包大量积压，从而挤压接收窗口的大小。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-5.1.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-5.1.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 5.1 - 接收窗口缩小的示例
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;
    
      &lt;h5 id=&quot;零窗口死锁问题&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          零窗口死锁问题
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;一个特殊的场景是，如果接收方的窗口变为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; ，发送方的窗口也会被限制到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;此时，发送方窗口是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; ，无法发送新数据包。而接收方在等待数据包到来，
也不会回复任何确认包，即使接收方的窗口已经可以变大，也没办法告知对方。&lt;/p&gt;

&lt;p&gt;这样，两端都在等待，造成零窗口死锁问题。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-5.2.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-5.2.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 5.2 - 零窗口死锁问题
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;在 TCP 协议中，打破死锁的方法，是采用 持续计时器机制。&lt;/p&gt;

&lt;p&gt;具体来说，发送方收到零窗口通知时，启动计时器，
当计时器超时，就发送一个
&lt;span class=&quot;marked&quot;&gt;仅携带一个字节数据的探测数据包
&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;如此，接收方就可以回复确认包，如果此时接收方的窗口可以恢复，
双方就回到正常轨道。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-5.3.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-5.3.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 5.3 - 持续计时器解决零窗口死锁问题
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;一个细节是，在发送探测数据包时，持续定时器会重新开始计时。 也就是说，
&lt;span class=&quot;marked&quot;&gt;
发送方会周期性地进行窗口探测，这样可以应对探测数据包丢失的情况
&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;如果接收方拿到探测数据包后，
仍坚持零窗口，
那么发送方的计时器就重新计时。
如此往复一定次数后仍无法恢复，则关闭连接。&lt;/p&gt;
    
      &lt;h5 id=&quot;糊涂窗口综合征&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          糊涂窗口综合征
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%B3%8A%E6%B6%82%E7%AA%97%E5%8F%A3%E7%BB%BC%E5%90%88%E7%97%87&quot; target=&quot;_blank&quot;&gt;糊涂窗口综合征&lt;/a&gt;
的通俗理解是，
&lt;span class=&quot;marked&quot;&gt;
双方处理速度不一致，会导致通信演化为小包通信的问题
&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;如果接收方的处理速度跟不上发送方的生产速度，
最终接收方的数据积压在缓存区来不及拿走，接收窗口宣告为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt; ，
此时发送方停止发送。&lt;/p&gt;

&lt;p&gt;一旦接收方的应用进程处理了一个字节，接收窗口变为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; ，
发送方就可以发送一个字节。&lt;/p&gt;

&lt;p&gt;如果发送方总是足够快地填充接收方的窗口，
这个过程会不断循环下去，导致每次通信的数据包都只有一个字节，
显然降低了通信效率。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-5.4.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-5.4.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 5.4 - 糊涂窗口综合征
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;此问题的解决措施有多种，其中包括 Nagle 算法的
&lt;a href=&quot;#确认号和累计确认&quot;&gt;累计与延迟确认&lt;/a&gt; 和 &lt;a href=&quot;#发送机制&quot;&gt;累计与延迟发送&lt;/a&gt; 。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;接收方 过一定时间 或 累计一定数量的包 后再确认。&lt;/li&gt;
  &lt;li&gt;发送方 过一定时间 或 累计一定数量的包 后再发送。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;此外，还有一种关键的措施，就是 &lt;span class=&quot;marked&quot;&gt;延迟宣告窗口&lt;/span&gt; 。&lt;/p&gt;

&lt;p&gt;大概意思是，接收方的窗口稍稍变大时，不要急于告知对方，
而是达到一定阈值才告知对方，如此发送方就会等接收方窗口足够大时将数据包一并发送，
从而解决小包传输问题。&lt;/p&gt;

&lt;p&gt;或者是，接收方的窗口变的足够小的时候，直接宣告窗口关闭，阻止发送方再发数据。
直到接收窗口可以变的足够大，再恢复大包传输。&lt;/p&gt;

&lt;p&gt;下图是延迟宣告窗口的一种推演过程。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-5.5.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-5.5.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 5.5 - 延迟宣告窗口 - 解决糊涂窗口综合征
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;可以看出，
&lt;span class=&quot;marked&quot;&gt;
窗口探测实际是探测一个足够大的窗口，而不是完全非零的窗口
&lt;/span&gt; 。&lt;/p&gt;
    
      &lt;h3 id=&quot;tcp-拥塞控制机制&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          TCP 拥塞控制机制 &lt;a href=&quot;#tcp-拥塞控制机制&quot; class=&quot;heading-anchor&quot;&gt;¶&lt;/a&gt;
        
        &lt;/span&gt;
      &lt;/h3&gt;

&lt;p&gt;网络拥塞是指，对网络中某种资源的总需求量大于总可用量的情况。&lt;/p&gt;

&lt;p&gt;直接的理解就是，
&lt;span class=&quot;marked&quot;&gt;
要传输的数据量超过网络负荷
&lt;/span&gt; 。&lt;/p&gt;

&lt;p&gt;在网络拥塞的情况下，TCP 协议的重传机制反而会加剧拥塞情况。&lt;/p&gt;

&lt;p&gt;虽然网络拥塞是一个全局的、宏观的问题，
但是 TCP 协议对网络拥塞的缓解措施，是从个体角度出发的。&lt;/p&gt;

&lt;p&gt;简而言之，TCP 协议的拥塞控制的办法是，
&lt;span class=&quot;marked&quot;&gt;
发送方主动减少发送量
&lt;/span&gt; 。&lt;/p&gt;

&lt;p&gt;拥塞控制和 &lt;a href=&quot;#tcp-流量控制机制&quot;&gt;流量控制&lt;/a&gt; 是不同的事情：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;拥塞控制是发送方主动减少数据传输，解决的宏观网络的超负荷问题的机制。&lt;/li&gt;
  &lt;li&gt;流量控制是接收方调控发送方数据传输量，以平衡生产消费速度的机制。&lt;/li&gt;
&lt;/ul&gt;
    
      &lt;h5 id=&quot;网络拥塞的判断&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          网络拥塞的判断
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;拥塞判断的方法有许多种，这里主要说明两种。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;marked&quot;&gt;
这两种就是 TCP 协议中重传机制的两种触发方式
&lt;/span&gt;。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;超时标准&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;前面 &lt;a href=&quot;#超时重传和超时计算&quot;&gt;超时重传和超时计算&lt;/a&gt; 部分有讲，
TCP 协议每发送一个数据包，就会对它设置一次计时器。&lt;/p&gt;

    &lt;p&gt;当超时发生时，意味着数据包丢失、或延迟，此时网络可能发生拥塞。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;3ACK 标准&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;前面 &lt;a href=&quot;#快速重传机制&quot;&gt;快速重传机制&lt;/a&gt; 部分有讲，
如果收到同一个数据包的多次确认，意味着数据包丢失、或延迟，
此时网络可能发生拥塞。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
    
      &lt;h5 id=&quot;拥塞窗口算法&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          拥塞窗口算法
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;TCP 协议仍然基于滑动窗口的机制，进行拥塞控制。&lt;/p&gt;

&lt;p&gt;发送方会维护一个拥塞窗口 CWND ，此窗口范围内的数据才允许被发送。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;marked&quot;&gt;
因此实际的发送窗口的大小是：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Min(对方接收窗口大小，自身拥塞窗口大小)&lt;/code&gt;
&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;拥塞窗口算法就是如何调整拥塞窗口大小的办法。&lt;/p&gt;

&lt;p&gt;它主要有四个策略：慢开始、拥塞避免、快重传、快恢复。&lt;/p&gt;

&lt;p&gt;虽然有四个策略，但是它们其实是 &lt;a href=&quot;#拥塞控制算法总览&quot;&gt;一套算法&lt;/a&gt;。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-6.1.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-6.1.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 6.1 - 拥塞控制算法图示
        - 图片来自 &lt;a href=&quot;https://www.bilibili.com/video/BV1yE411G7Ma?p=38&amp;amp;spm_id_from=pageDriver&quot; target=&quot;_blank&quot;&gt;计算机网络（谢希仁第七版）-方老师&lt;/a&gt; 
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;首先，「快重传」就是前面所讲的 &lt;a href=&quot;#快速重传机制&quot;&gt;快速重传&lt;/a&gt; ，
也就是说，
&lt;span class=&quot;marked&quot;&gt;
如果遭遇 3ACK ，就立即发起重传
&lt;/span&gt;。&lt;/p&gt;
    
      &lt;h5 id=&quot;慢开始&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          慢开始
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;发送方每收到一个对新数据包（就是不包括重传包）的确认，
就让拥塞窗口增一。&lt;/p&gt;

&lt;p&gt;虽然叫做慢开始，但是其实并不慢，
&lt;span class=&quot;marked&quot;&gt;
拥塞窗口是倍增的
&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;简而言之，如果没有遭遇超时 或 3ACK，
拥塞窗口就扩大一倍。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-6.2.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-6.2.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 6.2 - 拥塞控制 - 慢开始策略
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;
    
      &lt;h5 id=&quot;拥塞避免&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          拥塞避免
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;慢开始的增长速度是非常快的，
发送量越大，就离拥塞越近。&lt;/p&gt;

&lt;p&gt;所以有一个门限值 ssthresh 的概念。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;marked&quot;&gt;
拥塞窗口倍增到门限值后，就改为线性增长，比如每次增大一
&lt;/span&gt; 。&lt;/p&gt;

&lt;p&gt;其后，线性增大拥塞窗口的过程，就是拥塞避免阶段。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;marked&quot;&gt;
慢开始和拥塞避免，都是在探测拥塞边缘 &lt;/span&gt;：
一开始疯狂试探，到达门限值后，慢慢试探。&lt;/p&gt;
    
      &lt;h5 id=&quot;拥塞控制的惩罚&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          拥塞控制的惩罚
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;如果出现 &lt;a href=&quot;#网络拥塞的判断&quot;&gt;拥塞的征兆&lt;/a&gt;，拥塞窗口的大小会受到惩罚，让它减小。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;超时条件&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;超时未确认，意味着发生丢包或者较大延迟，所以处罚更为严厉。&lt;/p&gt;

    &lt;p&gt;拥塞窗口打回初始值 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt; ，
门限值改为当前拥塞窗口大小的一半。&lt;/p&gt;

    &lt;p&gt;&lt;span class=&quot;marked&quot;&gt;
总而言之，从新进入慢启动
&lt;/span&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;3ACK 条件&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;收到 3 个相同的确认包，意味着发生少许延迟，所以处罚相对柔和。&lt;/p&gt;

    &lt;p&gt;同样，慢启动的门限值减半。&lt;/p&gt;

    &lt;p&gt;不同的是，此时不必要从新进入慢启动，
而是减少一些拥塞窗口的值，跳过慢启动，直接重新进入拥塞避免阶段。&lt;/p&gt;

    &lt;p&gt;减少到多少呢？减少到最新门限值大小，也就是从新进入拥塞避免。&lt;/p&gt;

    &lt;p&gt;&lt;span class=&quot;marked&quot;&gt;
这种直接跳过慢启动，直接进入拥塞避免的方式，就叫做 快恢复
&lt;/span&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
    
      &lt;h5 id=&quot;拥塞控制算法总览&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          拥塞控制算法总览
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-6.3.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-6.3.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 6.3 - 拥塞控制算法总览
        - 图片来自 &lt;a href=&quot;https://www.bilibili.com/video/BV1yE411G7Ma?p=38&amp;amp;spm_id_from=pageDriver&quot; target=&quot;_blank&quot;&gt;计算机网络（谢希仁第七版）-方老师&lt;/a&gt; 
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;总结如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;慢开始阶段，倍增到门限值，激进探测拥塞边缘。&lt;/li&gt;
  &lt;li&gt;到达门限值，进入拥塞避免，线性增加，小心探测拥塞边缘。&lt;/li&gt;
  &lt;li&gt;遭遇超时，惩罚严厉，从新进入慢开始。&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;遭遇 3ACK，惩罚柔和，快恢复，门限减半，直接进入拥塞避免。&lt;/p&gt;

    &lt;p&gt;同时，3ACK 时，立即重传，即 快重传。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
    
      &lt;h3 id=&quot;tcp-连接建立和释放&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          TCP 连接建立和释放 &lt;a href=&quot;#tcp-连接建立和释放&quot; class=&quot;heading-anchor&quot;&gt;¶&lt;/a&gt;
        
        &lt;/span&gt;
      &lt;/h3&gt;

&lt;p&gt;TCP 的三次握手和四次握手，已经是老生常谈了。&lt;/p&gt;
    
      &lt;h5 id=&quot;连接建立---三次握手&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          连接建立 - 三次握手
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;首先，TCP 连接建立过程要解决的问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;span class=&quot;marked&quot;&gt;确定双方都可以正常收发 TCP 数据包&lt;/span&gt;。&lt;/li&gt;
  &lt;li&gt;双方协商一些参数和可选项（例如前面所讲的 &lt;a href=&quot;#选择确认机制&quot;&gt;选择确认&lt;/a&gt; 、&lt;a href=&quot;#窗口大小&quot;&gt;窗口大小&lt;/a&gt; 等），
&lt;span class=&quot;marked&quot;&gt;尤其是交换初始序号&lt;/span&gt;。&lt;/li&gt;
  &lt;li&gt;对资源进行分配，比如缓存区、端口号。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;span id=&quot;three-handshakes&quot;&gt;
下面是 TCP 协议三次握手建立连接的过程示意图&lt;/span&gt;，其中&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYN&lt;/code&gt;（synchronous） 是同步标志位 ，表示开始传输数据的意思。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACK&lt;/code&gt;（acknowledgement） 是确认标志位，表示是否启用确认机制。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ack&lt;/code&gt;（小写）是前面所说的 &lt;a href=&quot;#确认号和累计确认&quot;&gt;确认号&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;seq&lt;/code&gt; 是前面所说的 &lt;a href=&quot;#数据包序号&quot;&gt;序号&lt;/a&gt; 。&lt;/li&gt;
&lt;/ol&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-7.1.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-7.1.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 7.1 - TCP 协议三次握手过程
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;具体过程的描述如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;客户端发送一个 TCP 数据包，主动发起连接&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;设置 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYN=1&lt;/code&gt; 标志位，表示发起连接，想要传输数据。&lt;/p&gt;

    &lt;p&gt;客户端初始化自己的数据包序号 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;seq=x&lt;/code&gt; ，一同发送给对方。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;服务端收到对方的连接请求，回复对方确认包&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;设置回复标志位 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACK=1&lt;/code&gt; ，表示确认。&lt;/p&gt;

    &lt;p&gt;根据 &lt;a href=&quot;#确认号和累计确认&quot;&gt;确认号的规则&lt;/a&gt;，
同时设 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ack=x+1&lt;/code&gt; 表示期待对方下一次发过来的数据包序号为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;x+1&lt;/code&gt;。&lt;/p&gt;

    &lt;p&gt;因为 TCP 是全双工的，服务端也会设置 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYN=1&lt;/code&gt; ，
并初始化自己的数据包序号 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;seq=y&lt;/code&gt; ，捎带回复给客户端。&lt;/p&gt;

    &lt;p&gt;此时，服务端可以确定：
&lt;span class=&quot;marked&quot;&gt;
客户端可以发送 TCP 数据包，自身可以接收 TCP 数据包
&lt;/span&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;span id=&quot;handshake-no-2&quot;&gt;&lt;strong&gt;客户端收到对方的确认包，并回复对方确认&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;

    &lt;p&gt;同样，设置回复标志位 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACK=1&lt;/code&gt;，表示确认。&lt;/p&gt;

    &lt;p&gt;对方的序号是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;y&lt;/code&gt; ，
回复对方 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ack=y+1&lt;/code&gt; 表示期待对方下一次发来的数据包序号为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;y+1&lt;/code&gt; 。&lt;/p&gt;

    &lt;p&gt;同时，自身的数据包序号需要自增 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;seq=x+1&lt;/code&gt; 。&lt;/p&gt;

    &lt;p&gt;自己发送上一个数据包，对方收到了，并且收到了对方回复。&lt;/p&gt;

    &lt;p&gt;所以客户端可以确定：
&lt;span class=&quot;marked&quot;&gt;
服务端可以正常收发 TCP 数据包，
自身也可以正常收发 TCP 数据包
&lt;/span&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;span id=&quot;handshake-no-3&quot;&gt;&lt;strong&gt;服务端收到客户端的确认，三次握手结束&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;

    &lt;p&gt;此时服务端可以进一步确定：&lt;/p&gt;

    &lt;p&gt;&lt;span class=&quot;marked&quot;&gt;
客户端端可以正常接收 TCP 数据包，
自身也可以正常发送 TCP 数据包
&lt;/span&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;三次握手结束后，双方都可以确定对方是可以正常收发 TCP 数据的。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-7.2.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-7.2.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 7.2 - 三次握手过程中双方逐步确定收发能力正常
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;
    
      &lt;h5 id=&quot;三次握手的必要性&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          三次握手的必要性
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;一个经常出现的问题是：
&lt;span class=&quot;marked&quot;&gt;
两次握手可以吗？
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;当然是不可以的，可以分几个方面解释：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;三次握手是为了确定双方的收发能力&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;如果缺少最后一次 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACK&lt;/code&gt; 的话，服务端就无法知道客户端是否可以接收 TCP 数据，
也无法知道自己的发送是否成功，就无法做到可靠传输。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;序号同步的确定性&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;如果缺少最后一次 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACK&lt;/code&gt; 的话，服务端就无法确定对方有无收到自己的初始序号。&lt;/p&gt;

    &lt;p&gt;前面讲到，数据包的序号是 TCP 滑动窗口机制的基本字段，它如果是不可靠的，
后续的确认机制、重传机制等都无从谈起。&lt;/p&gt;

    &lt;p&gt;网络是不可靠的，存在丢包，所以连接建立时，
双方都必须确定初始序号交到了对方手中。&lt;/p&gt;

    &lt;p&gt;&lt;span class=&quot;marked&quot;&gt;
三次握手过程，也是可靠地交换初始序号的过程
&lt;/span&gt;。&lt;/p&gt;

    &lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-7.3.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-7.3.jpg&quot; alt=&quot;&quot;/&gt;
    
     
    &lt;figcaption&gt;图 7.3 - 三次握手也是可靠地交换初始序号的过程
       
    &lt;/figcaption&gt;
     
   
 &lt;/figure&gt;
    &lt;p/&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;历史失效连接请求的乱序问题&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;网络中，数据传输可能存在延迟、乱序。&lt;/p&gt;

    &lt;p&gt;如果一个老的失效的连接请求，延迟到达服务端，倘若缺少第三次握手，
服务端会建立一条新连接，直接进入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ESTABLISHED&lt;/code&gt; 状态。&lt;/p&gt;

    &lt;p&gt;客户端收到服务端的回复包时，可以根据序号是否过期判断是否是失效连接。&lt;/p&gt;

    &lt;p&gt;在三次握手的情况下，客户端就进一步可以发送 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RST&lt;/code&gt; 标志，终止连接。&lt;/p&gt;

    &lt;p&gt;如果不是历史失效连接，客户端则发送 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACK&lt;/code&gt; 标志，正常建立连接。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
    
      &lt;h5 id=&quot;三次握手中丢包的情况&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          三次握手中丢包的情况
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;另一个常见的问题是：
&lt;span class=&quot;marked&quot;&gt;
如果第三次 ACK 丢包呢？
&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;无论哪一次通信发生丢包或延迟，都出发 TCP 的 &lt;a href=&quot;#tcp-重传机制&quot;&gt;重传机制&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;简单说，再发一次，如果达到一定次数，则放弃连接。&lt;/p&gt;

&lt;p&gt;对于第三次 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACK&lt;/code&gt; 丢包的情况，重试一定次数后，服务端会关闭连接，回收资源。&lt;/p&gt;

&lt;p&gt;不过，服务端单方面关闭连接，客户端并不知晓，它认为连接已经建立。&lt;/p&gt;

&lt;p&gt;如果客户端向服务端发送数据，会被服务端打回 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RST&lt;/code&gt; 报文，
借此客户端可知道连接失效。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-7.3.1.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-7.3.1.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 7.3.1 - 第三次 ACK 包丢失的最坏情况
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;
    
      &lt;h5 id=&quot;数据传输的开始时机&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          数据传输的开始时机
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;上面的 &lt;a href=&quot;#three-handshakes&quot;&gt;三次握手图示&lt;/a&gt; 中，一个细节是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;客户端在两次握手之后就进入了 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ESTABLISHED&lt;/code&gt; 状态。&lt;/li&gt;
  &lt;li&gt;服务端则是在三次握手之后才进入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ESTABLISHED&lt;/code&gt; 状态。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其原因在于， 在 &lt;a href=&quot;#handshake-no-2&quot;&gt;第二次握手&lt;/a&gt; 后，
&lt;span class=&quot;marked&quot;&gt;
客户端已经可以确定双方都可以正常收发数据包
&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;所以，客户端可以提前进入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ESTABLISHED&lt;/code&gt; 状态，分配端口，开始通信。&lt;/p&gt;

&lt;p&gt;因此，
&lt;span class=&quot;marked&quot;&gt;
第三次 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACK&lt;/code&gt; 是可以捎带客户端的数据一并发送的
&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;服务端直到 &lt;a href=&quot;#handshake-no-3&quot;&gt;第三次握手&lt;/a&gt; 成功之后，才可以确定双方都正常，
所以它会稍晚进入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ESTABLISHED&lt;/code&gt;。&lt;/p&gt;
    
      &lt;h5 id=&quot;连接关闭---四次挥手&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          连接关闭 - 四次挥手
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;TCP 的连接释放过程，需要注意两个点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;TCP 是全双工的。&lt;/li&gt;
  &lt;li&gt;双方都可以主动释放连接。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;释放连接的过程有一个重要的目的：&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;marked&quot;&gt;
双方都要确定地知道对方不再发送数据了，连接才正式关闭
&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;假设客户端主动关闭，下面是 TCP 协议四次挥手释放连接的过程示意图。&lt;/p&gt;

&lt;p&gt;其中 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FIN&lt;/code&gt;（finish）是结束数据传输的标志位。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-7.4.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-7.4.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 7.4 - TCP 协议四次挥手过程
       
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;具体过程的描述如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;客户端发送 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FIN&lt;/code&gt; 数据包，不再发送数据&lt;/strong&gt;。&lt;/p&gt;

    &lt;p&gt;设置 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FIN=1&lt;/code&gt; 标志位，表示想要关闭连接，不再发送数据。&lt;/p&gt;

    &lt;p&gt;&lt;span class=&quot;marked&quot;&gt;
但是，此时服务端还可以继续发送数据
&lt;/span&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;服务端收到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FIN&lt;/code&gt; 数据包，回复确认&lt;/strong&gt; 。&lt;/p&gt;

    &lt;p&gt;服务端对于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FIN&lt;/code&gt; 包也会进行确认。&lt;/p&gt;

    &lt;p&gt;&lt;span class=&quot;marked&quot;&gt;
此时服务端明确知道，客户端不再发送数据了
&lt;/span&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;服务端传输完剩余数据&lt;/strong&gt; 。&lt;/p&gt;

    &lt;p&gt;&lt;span class=&quot;marked&quot;&gt;由于 TCP 是全双工的&lt;/span&gt;，
连接关闭由客户端主动发起，并不意味着服务端的数据已传输完。&lt;/p&gt;

    &lt;p&gt;服务端需要把剩余数据传输完毕。&lt;/p&gt;

    &lt;p&gt;&lt;span class=&quot;marked&quot;&gt;
此时服务端知道，双方都不再发送数据了。
&lt;/span&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;服务端发送 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FIN&lt;/code&gt; 数据包，不再发送数据包&lt;/strong&gt; 。&lt;/p&gt;

    &lt;p&gt;同样，设置 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FIN=1&lt;/code&gt; 标志位，表示服务端不再发送数据。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;客户端收到对方 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FIN&lt;/code&gt; 包后，回复确认&lt;/strong&gt; 。&lt;/p&gt;

    &lt;p&gt;任何一方结束数据发送，都要确保对方是知道的，就需要对方确认。&lt;/p&gt;

    &lt;p&gt;此时客户端知道，双方都不再发送数据了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;客户端等待 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2MSL&lt;/code&gt; 时间等待后，四次挥手结束，释放所有资源&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;再次明确，
&lt;span class=&quot;marked&quot;&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FIN&lt;/code&gt; 标志位的意思是，不再发送数据
&lt;/span&gt;。&lt;/p&gt;
    
      &lt;h5 id=&quot;挥手四次的必要性&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          挥手四次的必要性
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;双方都必须对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FIN&lt;/code&gt; 包做确认，
这样对方才可以确定地知道自己不再发送数据。&lt;/p&gt;

&lt;p&gt;TCP 连接的建立需要三次握手，是因为，
&lt;span class=&quot;marked&quot;&gt;
第二次握手过程服务端将设置 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;SYN&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACK&lt;/code&gt; 合并为一个数据包发送，所以是三次
&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;而对于释放连接的情况，
&lt;span class=&quot;marked&quot;&gt;
无法将第二次和第三次合并&lt;/span&gt;，
因为中间还要传输数据，
所以是四次。&lt;/p&gt;

&lt;p&gt;如果任何一个确认包发生丢包或延迟，主动设置 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FIN&lt;/code&gt; 的一方会触发重传。&lt;/p&gt;
    
      &lt;h5 id=&quot;等待-2msl-时间的原因&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          等待 2MSL 时间的原因
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;首先，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MSL&lt;/code&gt; 是指报文在网络中最大生存时间。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2MSL&lt;/code&gt; 就是两倍的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MSL&lt;/code&gt; ，也被叫做 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TIME_WAIT&lt;/code&gt; 时间，
在 linux 中常被设置为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2*60s&lt;/code&gt; 。&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;marked&quot;&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2MSL&lt;/code&gt; 的值一定需要大于重传超时阈值
&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;为何要等待这么长时间呢？&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;如果最后一次 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACK&lt;/code&gt; 丢包呢？&lt;/p&gt;

    &lt;p&gt;前面有说过，任何一方的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FIN&lt;/code&gt; 包丢失后，如果超时未收到对方确认，
就会触发重传。&lt;/p&gt;

    &lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-7.5.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-7.5.jpg&quot; alt=&quot;&quot;/&gt;
    
     
    &lt;figcaption&gt;图 7.5 - 最后一次 ACK 丢失，会导致服务端重传 FIN 包
       
    &lt;/figcaption&gt;
     
   
 &lt;/figure&gt;
    &lt;p/&gt;

    &lt;p&gt;如果客户端在一定时间内未收到服务端的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FIN&lt;/code&gt; 包重传，说明对方已经收到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACK&lt;/code&gt; 。&lt;/p&gt;

    &lt;p&gt;否则，如果收到服务端的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FIN&lt;/code&gt; 包重传，自然回复 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACK&lt;/code&gt;。&lt;/p&gt;

    &lt;p&gt;一次 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACK&lt;/code&gt; 包的发送时间，再算上重传 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FIN&lt;/code&gt; 的时间，所以叫做 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2MSL&lt;/code&gt; 。&lt;/p&gt;

    &lt;p&gt;不过，无论如何，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;2MSL&lt;/code&gt; 时间至少要比重传超时阈值长。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;防止新老连接数据包混乱&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;如果立即释放端口资源，此端口可能被一个新连接立即使用。&lt;/p&gt;

    &lt;p&gt;如此的话，假设网络中存在老数据包的延迟，那么老数据包会被新连接接收，造成混乱。&lt;/p&gt;

    &lt;p&gt;所以，&lt;span class=&quot;marked&quot;&gt;
等待一定时间，使得网络中潜在的、可能延迟传输的数据包悉数殆尽，
才不会影响到后面的连接&lt;/span&gt;。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;综合来看，还是因为网络是不可靠的。&lt;/p&gt;
    
      &lt;h5 id=&quot;tcp-连接的有限状态机&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          TCP 连接的有限状态机
        
        &lt;/span&gt;
      &lt;/h5&gt;

&lt;p&gt;综合连接建立和连接关闭的过程，整个 TCP 连接的状态机图示如下。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-8.1.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-8.1.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 8.1 - TCP 有限状态机
        - 图片来自 &lt;a target=&quot;_blank&quot;&gt;网络&lt;/a&gt; 
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;

&lt;p&gt;两个常见的问题:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TIME_WAIT&lt;/code&gt; 非常多的情况&lt;/p&gt;

    &lt;p&gt;已经知道，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TIME_WAIT&lt;/code&gt; 是主动关闭连接一方，发送完最后一次 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ACK&lt;/code&gt;
数据包后进入的状态。&lt;/p&gt;

    &lt;p&gt;并且 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TIME_WAIT&lt;/code&gt; 的时间默认是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;120s&lt;/code&gt; 。&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TIME_WAIT&lt;/code&gt; 非常多，说明
&lt;span class=&quot;marked&quot;&gt;
连接建立的并发数比较大，端口来不及回收&lt;/span&gt;。&lt;/p&gt;

    &lt;p&gt;比如，对于高并发的 TCP 短连接，例如
未开启 &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP_persistent_connection&quot; target=&quot;_blank&quot;&gt;keep-alive 选项&lt;/a&gt;
的 HTTP 短连接。&lt;/p&gt;

    &lt;p&gt;补充，&lt;a href=&quot;https://www.zhihu.com/question/24338653&quot; target=&quot;_blank&quot;&gt;HTTP 协议中是服务端主动关闭连接&lt;/a&gt; 。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CLOSE_WAIT&lt;/code&gt; 非常多的情况&lt;/p&gt;

    &lt;p&gt;已经知道，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CLOSE_WAIT&lt;/code&gt; 是被动关闭连接的一方，传输最后的剩余数据的状态。&lt;/p&gt;

    &lt;p&gt;它是当服务端收到对方 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FIN&lt;/code&gt; 包时，&lt;strong&gt;主动进入&lt;/strong&gt;的一个状态。&lt;/p&gt;

    &lt;p&gt;所以，一般地，是由于应用程序未调用或太忙未来得及调用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;close&lt;/code&gt; 关闭连接导致。&lt;/p&gt;

    &lt;p&gt;比如程序编写遗忘连接关闭调用代码，或者负载过高，未及时执行关闭连接，
 导致 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CLOSE_WAIT&lt;/code&gt; 状态的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;socket&lt;/code&gt; 积压。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;
    
      &lt;h3 id=&quot;tcp-协议头&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          TCP 协议头 &lt;a href=&quot;#tcp-协议头&quot; class=&quot;heading-anchor&quot;&gt;¶&lt;/a&gt;
        
        &lt;/span&gt;
      &lt;/h3&gt;

&lt;p&gt;TCP 的协议头部总共有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;20&lt;/code&gt; 个字节。&lt;/p&gt;

&lt;p&gt;下面是 TCP 协议头的栏位示意图，其中大部分字段已经在上面讲到。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-9.1.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-9.1.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 9.1 - TCP 协议头
        - 图片来自 &lt;a target=&quot;_blank&quot;&gt;网络&lt;/a&gt; 
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;
    
      &lt;h3 id=&quot;概念图谱总览&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          概念图谱总览 &lt;a href=&quot;#概念图谱总览&quot; class=&quot;heading-anchor&quot;&gt;¶&lt;/a&gt;
        
        &lt;/span&gt;
      &lt;/h3&gt;

&lt;p&gt;最后，对本文的知识做一个树状图梳理。&lt;/p&gt;

&lt;figure&gt; 
  &lt;img class=&quot;post-img lazyload max-width-100&quot; src=&quot;/assets/images/posts/network-tcp/tcp-10.1.jpg-small.svg&quot; data-src=&quot;/assets/images/posts/network-tcp/tcp-10.1.jpg&quot; alt=&quot;&quot;/&gt;
    
     
       &lt;figcaption&gt;图 10.1 - TCP 总结图谱
        - 图片来自 &lt;a target=&quot;_blank&quot;&gt;网络&lt;/a&gt; 
       &lt;/figcaption&gt;
     
   
    &lt;/figure&gt;
&lt;p/&gt;
    
      &lt;h3 id=&quot;结语&quot;&gt;
        &lt;span class=&quot;heading-text&quot;&gt;
        
          结语 &lt;a href=&quot;#结语&quot; class=&quot;heading-anchor&quot;&gt;¶&lt;/a&gt;
        
        &lt;/span&gt;
      &lt;/h3&gt;

&lt;p&gt;纵观全文，TCP 协议的众多机制源于，万恶之源：网络是不可靠的，丢包、乱序、延时。&lt;/p&gt;

&lt;p&gt;（完）&lt;/p&gt;
  &lt;/div&gt;


&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>778a2cf9a6f9cecd3dfb44d54b89e095</guid>
<title>保姆级教学，22 张图揭开 ThreadLocal</title>
<link>https://toutiao.io/k/098z7ei</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;前言&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图解方式来通关&lt;span&gt;ThreadLocal&lt;/span&gt;，同时希望你们有一定的&lt;span&gt;ＪＶＭ &lt;/span&gt;基础，这样食用起来会更香。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相信大伙对&lt;span&gt; ThreadLocal &lt;/span&gt;并不陌生，工作中常用，同时也是面试高频题，但是大部分人对&lt;span&gt; ThreadLocal &lt;/span&gt; 的理解可能只是&lt;span&gt;「线程的本地变量，Map结构」&lt;/span&gt;，看完本文让大伙真正理解&lt;span&gt;ThreadLocal&lt;/span&gt;，给大伙工作带来帮助，也让面试有更多的谈资。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;内容大纲&lt;/h1&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7989756722151088&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx2KH6Jw6EVHactic9cibX6mAD8gKoko6icEXfpsAU82wyGHXfeJzsuOXvHInXrXg38d4nGyEcjGzVlw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;781&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Java对象引用级别&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在聊&lt;span&gt; ThreadLocal &lt;/span&gt;前，先做前置知识铺垫，谈谈&lt;span&gt;Java对象引用级别。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了使程序能更灵活地控制对象生命周期，从 &lt;span&gt;JDK1.2&lt;/span&gt; 版本开始，&lt;span&gt;JDK&lt;/span&gt;把对象的引用级别由高到低分为&lt;span&gt;强引用、软引用、弱引用、虚引用&lt;/span&gt;四种级别。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5044843049327354&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx2KH6Jw6EVHactic9cibX6mAxSZaianqlNynviczfW5rpQJsicSjAGkjPDibSSUjYP9ibMfasuXicPG8RRtg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;892&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;强引用 StrongReference&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;强引用&lt;/span&gt;是我们最常见的对象，它属于&lt;span&gt;不可回收资源&lt;/span&gt;，垃圾回收器（&lt;span&gt;后面简称G C）&lt;/span&gt;绝对不会回收它，即使是内存不足，&lt;span&gt;J V M&lt;/span&gt;宁愿抛出&lt;span&gt; OutOfMemoryErrorM&lt;/span&gt; 异常，使程序终止，也不会来回收&lt;span&gt;强引用&lt;/span&gt;对象。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.39611650485436894&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx2KH6Jw6EVHactic9cibX6mANXZhU9iag1RNcBricw55iaQQdsMMyf2BDEYNib21eMGH8jWjCDITxM3Pvg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1030&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;软引用 SoftReference&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果对象是&lt;span&gt;软引用&lt;/span&gt;，那它的性质属于&lt;span&gt;可有可无，&lt;/span&gt;因为&lt;span&gt;内存空间充足&lt;/span&gt;的情况下，&lt;span&gt;G C&lt;/span&gt;不会回收它，但是&lt;span&gt;内存空间紧张&lt;/span&gt;，&lt;span&gt;G C&lt;/span&gt;发现它&lt;span&gt;仅有软引用&lt;/span&gt;，就会回收该对象，所以&lt;span&gt;软引用&lt;/span&gt;对象适合作为&lt;span&gt;内存敏感的缓存对象&lt;/span&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3960591133004926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx2KH6Jw6EVHactic9cibX6mATcG7iboLJqN2Xiaiajn0Fq70KVBibeGV1JDaXFW8vaZDQ6weP20wJXolJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2030&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有对象仅被 &lt;span&gt;SoftReference&lt;/span&gt; 引用，它才是&lt;span&gt;软引用级别对象&lt;/span&gt;，因为对象可以在&lt;span&gt;多处&lt;/span&gt;被引用，所以&lt;span&gt; SoftReference&lt;/span&gt; 引用的对象，它可能在&lt;span&gt;其他处&lt;/span&gt;被强引用了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;弱引用 WeakReference&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;弱引用&lt;/span&gt;对象相对&lt;span&gt;软引用&lt;/span&gt;对象具有&lt;span&gt;更短暂的生命周期&lt;/span&gt;，只要 &lt;span&gt;G C&lt;/span&gt; 发现它&lt;span&gt;仅有弱引用&lt;/span&gt;，不管内存空间是否充足，都会回收它，不过 &lt;span&gt;G C &lt;/span&gt;是一个&lt;span&gt;优先级很低&lt;/span&gt;的线程，因此不一定会很快发现那些&lt;span&gt;仅有弱引用的对象。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3960591133004926&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx2KH6Jw6EVHactic9cibX6mARyCWZfChFTw8YYIvsdhH9FbjXiah7ckY6mDlrg1h4L8HTIZicBfOkLzQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2030&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有对象仅被 &lt;span&gt;WeakReference&lt;/span&gt; 引用，它才是&lt;span&gt;弱引用级别对象&lt;/span&gt;，因为对象可以在&lt;span&gt;多处&lt;/span&gt;被引用，所以&lt;span&gt; WeakReference&lt;/span&gt; 引用的对象，它可能在&lt;span&gt;其他处&lt;/span&gt;被强引用了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;虚引用 PhantomReference&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顾名思义，&lt;span&gt;虚引用&lt;/span&gt;形同虚设，与其他几种引用不同，&lt;span&gt;虚引用&lt;/span&gt;不会决定对象的生命周期。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果一个对象&lt;span&gt;仅有虚引用&lt;/span&gt;，那它就和没有任何引用一样，任何时候都可能被&lt;span&gt; G C &lt;/span&gt;回收。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5422116527942925&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx2KH6Jw6EVHactic9cibX6mAKtJ24Tyekh9FAP7sNuhJW0CLbzw9RUbESaXuo1rcicO3ROSV9rdUm4g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1682&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读到这里会不会感觉&lt;span&gt;虚引用&lt;/span&gt;和&lt;span&gt;弱引用&lt;/span&gt;没区别？它们的区别如下&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;SoftReference、WeakReference引用的对象没被回收时，可以使用get方法获取真实对象地址&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;PhantomReference使用get方法永远返回null&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单说就是&lt;span&gt;「无法通过虚引用来获取对象的真实地址」&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java中&lt;span&gt;SoftReference、WeakReference、PhantomReference&lt;/span&gt;，可以理解为&lt;span&gt;对象引用级别包装类&lt;/span&gt;，在项目中使用对应的包装类，赋予对象引用级别。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虚引用图中，出现了&lt;span&gt;ReferenceQueue（引用队列）&lt;/span&gt;，引用队列是配合对象引用级别包装类（&lt;span&gt;SoftReference、WeakReference、PhantomReference&lt;/span&gt;）使用，当&lt;span&gt;对象引用级别包装类&lt;/span&gt;所指向的对象，被垃圾回收后，该&lt;span&gt;对象引用级别包装类&lt;/span&gt;被追加到引用队列，&lt;span&gt;因此可以通过引用队列做 G C 相关统计或额外数据清理等操作。&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6120556414219475&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx2KH6Jw6EVHactic9cibX6mAuqLAib67B2y3iar8c1ulMYMWsjBiaZEXlhMvFcib7jQjbKMrEmqgia2DUIg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1294&quot;/&gt;&lt;/figure&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ThreadLocal&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ThreadLocal&lt;/span&gt;很多地方叫线程本地变量，也有些地方叫线程本地存储，其实意思差不多。ThreadLocal为变量在每个线程中都创建了一个副本，每个线程可以访问自己内部的副本变量。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5960264900662252&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx2KH6Jw6EVHactic9cibX6mAj4GdRgKD3SZqIEhKzw9563NZFG6AUYoZxxx8N1ChFUib7uc71YmlHEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;906&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;ThreadLocal是什么&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Thread&lt;/span&gt;类声明了&lt;span&gt;成员变量threadLocals&lt;/span&gt;，&lt;span&gt;threadLocals&lt;/span&gt;才是真正的线程本地变量，因此每个&lt;span&gt; Thread &lt;/span&gt;都有自己的线程本地变量，所以线程本地变量拥有&lt;span&gt;线程隔离特性&lt;/span&gt;，也就是天生的&lt;span&gt;线程安全&lt;/span&gt;。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.48502994011976047&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx2KH6Jw6EVHactic9cibX6mAaenL8Msc4KTeBemfApapUydTZ0ySFxpxvBAq22e75u658MhJ6rTsLw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1002&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上图可以看到&lt;span&gt; threadLocals &lt;/span&gt;成员变量类是 &lt;span&gt;ThreadLocal.ThreadLocalMap&lt;/span&gt;，即是  &lt;span&gt; ThreadLocal &lt;/span&gt;提供的&lt;span&gt;内部类&lt;/span&gt;，因此 &lt;span&gt; Thread&lt;/span&gt; 线程本地变量的创建、新增、获取、删除实现核心，必然是围绕 &lt;span&gt;threadLocals&lt;/span&gt;，所以开发者也是围绕 &lt;span&gt;threadLocals&lt;/span&gt; 实现功能，为了后续重复使用，还会对代码实现进行封装复用，而 &lt;span&gt;ThreadLocal&lt;/span&gt; 就是线程本地变量工具类，由&lt;span&gt; J D K &lt;/span&gt;提供，线程本地变量的功能都已经实现好了，开箱即用，造福广大开发人员。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;ThreadLocal&lt;/span&gt;常用的方法&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;set：为当前线程设置变量，当前ThreadLocal作为索引&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;get：获取当前线程变量，当前ThreadLocal作为索引&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;initialValue（钩子方法需要子类实现）：赖加载形式初始化线程本地变量，执行get时，发现线程本地变量为null，就会执行initialValue的内容&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;remove：清空当前线程的ThreadLocal索引与映射的元素&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.526919682259488&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx2KH6Jw6EVHactic9cibX6mAEDaqWrzl68hic3OibIXgN9PlM20cSrAib7mXg6bxl2RRA4WCib5MJE2oicA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1133&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个&lt;span&gt; Threa&lt;/span&gt;可以拥有多个&lt;span&gt; ThreadLocal键值对（存储在ThreadLocalMap结构）&lt;/span&gt;，又因为&lt;span&gt; ThreadLocalMap &lt;/span&gt;依赖当前&lt;span&gt;Thread&lt;/span&gt;，&lt;span&gt;Thread&lt;/span&gt;销毁时&lt;span&gt; ThreadLocalMap &lt;/span&gt;也会随之销毁，所以&lt;span&gt; ThreadLocalMap &lt;/span&gt;的生命周期与&lt;span&gt; Thread &lt;/span&gt;绑定。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5332749562171629&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx2KH6Jw6EVHactic9cibX6mAFZ1IGGK96fRORSiaPia59oV63rw1NuXb7Kqgy9yaDK0C9KrJ3rMtSKjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1142&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在总结出&lt;span&gt;「本地线程变量的作用域，属于当前线程整个范围，一个线程可以跨越多个方法使用本地线程变量」&lt;/span&gt;，当你希望&lt;span&gt;某些变量&lt;/span&gt;在某 &lt;span&gt;Thread &lt;/span&gt;的多个方法中共享 并保证线程安全，那就大胆的使用&lt;span&gt;ThreadLocal&lt;/span&gt;（&lt;span&gt;ps：一定要想清楚，是某个变量被Thread生命周期内多个方法共享，还是多个Thread共享这个变量！）。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;ThreadLocal源码&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来看看User类实现的线程本地变量代码&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.1344165435745939&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx2KH6Jw6EVHactic9cibX6mAPaicLwRJpzKkuicwQQdhSUshQcuBD2x7ghpYkeRxpgMBXTVSdAFBF52g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1354&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;方法也不多，分别是&lt;span&gt;initialValue、get、set、remove&lt;/span&gt;，接下来这些方法源码进行解析。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;ThreadLocalMap结构&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了后面的源码解析体验更好，有必要介绍下&lt;span&gt;ThreadLocalMap&lt;/span&gt;，顾名思义，它是&lt;span&gt; Map &lt;/span&gt;结构，但是本文主要内容不是&lt;span&gt;Map&lt;/span&gt;，所以上一图，快速过一下这块内容。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.49577167019027485&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx2KH6Jw6EVHactic9cibX6mArTDOpkJZJPXo1o0gFogA6OtJqicSiahdoxLGb6dEMww5CoVHpz4bJ6Bw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1892&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上图，相信大伙对&lt;span&gt; ThreadLocalMap &lt;/span&gt;结构已经非常清晰，不知有没有细心的小伙伴发现&lt;span&gt; ThreadLocal &lt;/span&gt;竟被&lt;span&gt;弱引用&lt;/span&gt;持有？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;为什么ThreadLocal会被弱引用？&lt;/span&gt;这块疑惑后面会给大伙安排的明明白白，最后上一张&lt;span&gt; ThreadLocalMap &lt;/span&gt;源码图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.0239234449760766&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx2KH6Jw6EVHactic9cibX6mAAev8gcCHzdaYXiabCUHsjVzgRwUTC6eEywdgDltjtjVBD8jlUAgw9jA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1254&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;get 获取变量&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6829971181556196&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx2KH6Jw6EVHactic9cibX6mAxZagHtibhSsAoSxIBPg3xLiblKcuqqHb8lXk9iagFwjBmyPJbnoNGtrUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1388&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;步骤如下&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;获取当前线程&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;获取当前线程的本地变量&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程本地变量没有被创建，执行setInitialValue方法进行初始化，并返回value值&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程本地变量存在，ThreadLocal计算成索引从 本地线程变量 获取Entry，如果Entry为null，执行setInitialValue方法进行初始化，并返回value值，否则通过Entry获取value返回&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;initialValue方法&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.615979381443299&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx2KH6Jw6EVHactic9cibX6mAWoojAzS8ltZibcDkY2NBYl5WEIA5wM96msZf331iatc0fdRLMZjHvxqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1552&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;步骤如下&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;通过get方法触发&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;执行初始化，获取到value&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;获取当前线程&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;获取当前线程本地变量&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;如果当前线程本地变量存在 ，ThreadLocal计算成索引设置映射的value，否则创建线程本地变量再做后续的设置操作&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;返回value值&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;set 设置变量&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5642965204236006&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx2KH6Jw6EVHactic9cibX6mAibOibPvFdkGgHUUAwyTOsfdGBhiaKhXTkH9GzHo3SVSQAd6TicY5Yd8bXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1322&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;步骤如下&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;获取当前线程&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;获取线程本地变量&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;本地变量不为空，当前ThreadLocal为索引设置映射的value，否则创建线程本地变量再做后续的设置操作&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;remove 清除变量&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8835489833641405&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx2KH6Jw6EVHactic9cibX6mAVDbUj1liaziauvFiawpWVJZ7acnsBV8icCJFGINAxtYhJYzTG0MQz1ln9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1082&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;步骤如下&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;获取Entry数组&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;当前ThreadLocal计算出索引&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;根据索引获取Entry元素（若是第一次没有命中，就循环直到null）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;清除Entry元素&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小结&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;源码十分简单，核心就三样&lt;span&gt;ThreadLocal线程本地变量工具类（同时作为索引）、Entry基本元素（由弱引用包装类ThreadLocal与value组成），Entry数组容器&lt;/span&gt;，到这里流程很清晰了，&lt;span&gt;ThreadLocal&lt;/span&gt;计算出数组索引，用&lt;span&gt; ThreadLocal &lt;/span&gt;与&lt;span&gt; value &lt;/span&gt;构建出&lt;span&gt; Entry &lt;/span&gt;元素，最终放入&lt;span&gt; Entry &lt;/span&gt;容器中，相信大伙都能写出来。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5284621920135939&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx2KH6Jw6EVHactic9cibX6mAKkBfEBoaicYhnktxFlgibPhSRX2kwTLnyHBvOicEGCtg4k0Veu4Imsj3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1177&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;为何采用弱引用&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为什么&lt;span&gt; Entry &lt;/span&gt;中对&lt;span&gt; ThreadLocal &lt;/span&gt;使用弱引用？反问一句，如果使用强引用，会发生什么事情？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7572078907435509&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx2KH6Jw6EVHactic9cibX6mAGjbcvuV3ialcwFTfH1CpcZ9USlI2PyGsQ5UULvFBJHeKc5ZY76wvfkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1318&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图的代码作用仅仅只是是为了让大伙去理解为什么使用弱引用，一般开发中不会出现这样的代码（&lt;span&gt;真出现了，这程序员怕是要拉去祭天&lt;/span&gt;）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回到正题，我们快速对代码进行解析，首先&lt;span&gt; ThreadContextTest &lt;/span&gt;持有私有的静态变量&lt;span&gt; ThreadLocal&lt;/span&gt;，且&lt;span&gt; ThreadContextTest &lt;/span&gt;禁止&lt;span&gt;实例化&lt;/span&gt;，接着执行静态方法&lt;span&gt; run &lt;/span&gt;触发静态块为&lt;span&gt; ThreadLocal &lt;/span&gt;设置User变量 并消除&lt;span&gt; ThreadLocal &lt;/span&gt;强引用，此时当前线程的本地变量拥有了&lt;span&gt;Entry元素。&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;问题来了，要如何获取到&lt;span&gt; Entry&lt;/span&gt; 元素，按正常流程，&lt;span&gt;ThreadLocal&lt;/span&gt;执行&lt;span&gt; get &lt;/span&gt;方法，&lt;span&gt;get&lt;/span&gt;会使用当前&lt;span&gt; ThreadLocal &lt;/span&gt;计算出索引，最终获取到&lt;span&gt;Entry元素&lt;/span&gt;，可是现在的问题如同下图。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.35658914728682173&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx2KH6Jw6EVHactic9cibX6mAIUskYG0QfJ5BW4UQ83s2rMRDqhnI8GBxFOemermxqKiac7JcNLDPibwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1032&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;我们不知道 key 是什么，如何去获取映射的value&lt;/span&gt;，同样的道理，都没有入口去获取到&lt;span&gt;ThreadContextTest.ThreadLoca&lt;/span&gt;，自然没办法获取映射的&lt;span&gt;Entry元素&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设计中采用&lt;span&gt;Map&lt;/span&gt;结构存储数据，却不能通过&lt;span&gt;key&lt;/span&gt;去获取&lt;span&gt;value&lt;/span&gt;，这设计明显不合理，又因&lt;span&gt;key、value&lt;/span&gt;值是强引用，导致&lt;span&gt; G C &lt;/span&gt;无法回收，造成内存溢出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以针对这种不合理的设计场景&lt;span&gt; J D K &lt;/span&gt;做了优化，对&lt;span&gt; Entry &lt;/span&gt;中的&lt;span&gt; ThreadLocal &lt;/span&gt;使用弱引用，当&lt;span&gt; G C &lt;/span&gt;发现它仅有弱引用的时候，会进行回收。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5539383561643836&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/23OQmC1ia8nx2KH6Jw6EVHactic9cibX6mA6fQsn4ojxrq8K2Tt3qDibD6yah6MW3QXfSicibEic6gGEiaPnp34eh5EUicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1168&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;span/&gt;&lt;span&gt;remove背后的意义&lt;/span&gt;&lt;span/&gt;&lt;span&gt; &lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还没结束，上面留了个小尾巴，大伙都知道&lt;span&gt; Entry &lt;/span&gt;中对&lt;span&gt; ThreadLocal &lt;/span&gt;使用弱引用，但value是强引用，如果出现上面提到的不合理场景，value值无法清理，最终内存溢出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实&lt;span&gt;value&lt;/span&gt;作为&lt;span&gt;强引用&lt;/span&gt;设计属于合理，如果用&lt;span&gt;软或弱引用&lt;/span&gt;，就出大问题了，程序跑着跑着突然get到了一个null，估计都得骂娘了，所以为解决内存溢出问题 &lt;span&gt;J D K&lt;/span&gt;提供&lt;span&gt;remove&lt;/span&gt;方法，使开发人员可以选择手动清理整个&lt;span&gt;Entry元素&lt;/span&gt;，防止内存溢出。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还记的之前说过吗？线程本地变量的生命周期与&lt;span&gt;线程绑定&lt;/span&gt;，一般线程的生命周期比较短，线程结束时，线程本地变量自然就销毁了，&lt;span&gt;软引用&lt;/span&gt;与&lt;span&gt; remove &lt;/span&gt;会不会有点多余了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务瞬息万变，大部分情况来说线程的生命周期比较短，但也业务场景会导致线程的生命周期&lt;span&gt;较长&lt;/span&gt;，甚至可能线程&lt;span&gt;无限循环&lt;/span&gt;执行，这些是你没办法预料到的，数量一旦上来很容易内存溢出，所以个人建议使用完之后及时清理ThreadLocal，理由如下&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;生命周期较长的线程场景&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;无限循环线程的场景&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;线程池场景（因为线程池可以复用线程，而且公司使用的框架可能会定制化线程池，你不能保证他会在线程池内帮你remove）&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;唠叨唠叨&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先祝大伙新年快乐，万事如意！！！博主两周肝一篇，虽然周期有点长，但是质量有保证，码文不易，如果觉得本文对您有帮助，欢迎分享给你的朋友，也给阿星点个「点赞+收藏」，这对阿星非常重要，谢谢您们，给各位小姐姐小哥哥们抱拳了，我们下次见！&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;关于我&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;公众号 : 「程序猿阿星」 专注技术原理、源码，通过图解方式输出技术，这里将会分享操作系统、计算机网络、Java、分布式、数据库等精品原创文章，期待你的关注。&lt;/p&gt;&lt;span&gt;- END -&lt;/span&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b5b10748a833ae19ed98caa05c8571d4</guid>
<title>MySQL 那些常见的错误设计规范</title>
<link>https://toutiao.io/k/oaezq98</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot; usegifprops=&quot;[object Object]&quot;&gt;&lt;p&gt;依托于互联网的发达，我们可以随时随地利用一些等车或坐地铁的碎片时间学习以及了解资讯。同时发达的互联网也方便人们能够快速分享自己的知识，与相同爱好和需求的朋友们一起共同讨论。&lt;/p&gt;&lt;p&gt;但是过于方便的分享也让知识变得五花八门，很容易让人接收到错误的信息。这些错误最多的都是因为技术发展迅速，而且没有空闲时间去及时更新已经发布的内容所导致。为了避免给后面学习的人造成误解，我们今天来看一看 MySQL 设计规范中几个常见的错误例子。&lt;/p&gt;&lt;h2&gt;主键的设计&lt;/h2&gt;&lt;p&gt;&lt;b&gt;错误的设计规范：主键建议使用自增 ID 值，不要使用 UUID，MD5，HASH，字符串作为主键&lt;/b&gt;&lt;/p&gt;&lt;p&gt;这个设计规范在很多文章中都能看到，自增主键的优点有占用空间小，有序，使用起来简单等优点。&lt;/p&gt;&lt;p&gt;下面先来看看自增主键的缺点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;自增值由于在服务器端产生，需要有一把自增的 AI 锁保护，若这时有大量的插入请求，就可能存在自增引起的性能瓶颈，所以存在并发性能问题；&lt;/li&gt;&lt;li&gt;自增值做主键，只能在当前实例中保证唯一，&lt;b&gt;不能保证全局唯一，这就导致无法在分布式架构中使用；&lt;/b&gt;&lt;/li&gt;&lt;li&gt;公开数据值，容易引发安全问题，如果我们的商品 ID 是自增主键的话，用户可以通过修改 ID 值来获取商品，严重的情况下可以知道我们数据库中一共存了多少商品。&lt;/li&gt;&lt;li&gt;MGR（MySQL Group Replication） 可能引起的性能问题；&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;因为自增值是在 MySQL 服务端产生的值，需要有一把自增的 AI 锁保护，若这时有大量的插入请求，就可能存在自增引起的性能瓶颈。比如在 MySQL 数据库中，参数 innodb_autoinc_lock_mode 用于控制自增锁持有的时间。虽然，我们可以调整参数 innodb_autoinc_lock_mode 获得自增的最大性能，但是由于其还存在其它问题。因此，&lt;b&gt;在并发场景中，更推荐 UUID 做主键或业务自定义生成主键。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;我们可以直接在 MySQ L使用 UUID() 函数来获取 UUID 的值。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;MySQL&amp;gt; select UUID();
+--------------------------------------+
| UUID()                               |
+--------------------------------------+
| 23ebaa88-ce89-11eb-b431-0242ac110002 |
+--------------------------------------+
1 row in set (0.00 sec)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;b&gt;需要特别注意的是，在存储时间时，UUID 是根据时间位逆序存储&lt;/b&gt;，也就是低时间低位存放在最前面，高时间位在最后，即 UUID 的前 4 个字节会随着时间的变化而不断“随机”变化，并非单调递增。而非随机值在插入时会产生离散 IO，从而产生性能瓶颈。这也是 UUID 对比自增值最大的弊端。&lt;/p&gt;&lt;p&gt;为了解决这个问题，MySQL 8.0 推出了函数 UUID_TO_BIN，它可以把 UUID 字符串：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;通过参数将时间高位放在最前，解决了 UUID 插入时乱序问题；&lt;/li&gt;&lt;li&gt;去掉了无用的字符串&quot;-&quot;，精简存储空间；&lt;/li&gt;&lt;li&gt;将字符串其转换为二进制值存储，空间最终从之前的 36 个字节缩短为了 16 字节。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;下面我们将之前的 UUID 字符串 23ebaa88-ce89-11eb-b431-0242ac110002 通过函数 UUID_TO_BIN 进行转换，得到二进制值如下所示：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;MySQL&amp;gt; SELECT UUID_TO_BIN(&#x27;23ebaa88-ce89-11eb-b431-0242ac110002&#x27;,TRUE) as UUID_BIN;
+------------------------------------+
| UUID_BIN                           |
+------------------------------------+
| 0x11EBCE8923EBAA88B4310242AC110002 |
+------------------------------------+
1 row in set (0.01 sec)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;除此之外，MySQL 8.0 也提供了函数 BIN_TO_UUID，支持将二进制值反转为 UUID 字符串。&lt;/p&gt;&lt;p&gt;虽然 MySQL 8.0 版本之前没有函数 UUID_TO_BIN/BIN_TO_UUID，还是可以通过自定义函数的方式解决。应用层的话可以根据自己的编程语言编写相应的函数。&lt;/p&gt;&lt;p&gt;当然，很多同学也担心 UUID 的性能和存储占用的空间问题，这里我也做了相关的插入性能测试，结果如下表所示：&lt;/p&gt;&lt;table data-draft-node=&quot;block&quot; data-draft-type=&quot;table&quot; data-size=&quot;normal&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th/&gt;&lt;th&gt;时间（秒）&lt;/th&gt;&lt;th&gt;表大小（G）&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;自增ID&lt;/td&gt;&lt;td&gt;2712&lt;/td&gt;&lt;td&gt;240&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;UUID&lt;/td&gt;&lt;td&gt;3396&lt;/td&gt;&lt;td&gt;250&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;排序UUID&lt;/td&gt;&lt;td&gt;2624&lt;/td&gt;&lt;td&gt;243&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可以看到，MySQL 8.0 提供的排序 UUID 性能最好，甚至比自增 ID 还要好。此外，由于 UUID_TO_BIN 转换为的结果是16 字节，仅比自增 ID 增加 8 个字节，最后存储占用的空间也仅比自增大了 3G。&lt;/p&gt;&lt;p&gt;而且由于 UUID 能保证全局唯一，因此使用 UUID 的收益远远大于自增 ID。可能你已经习惯了用自增做主键，但是在并发场景下，更推荐 UUID 这样的全局唯一值做主键。&lt;/p&gt;&lt;p&gt;当然了，UUID虽好，但是在分布式场景下，主键还需要加入一些额外的信息，这样才能保证后续二级索引的查询效率，推荐根据业务自定义生成主键。但是在并发量和数据量没那么大的情况下，还是推荐使用自增 UUID 的。大家更不要以为 UUID 不能当主键了。&lt;/p&gt;&lt;h2&gt;金融字段的设计&lt;/h2&gt;&lt;p&gt;&lt;b&gt;错误的设计规范：同财务相关的金额类数据必须使用 decimal 类型&lt;/b&gt;由于 float 和 double 都是非精准的浮点数类型，而 decimal 是精准的浮点数类型。所以一般在设计用户余额，商品价格等金融类字段一般都是使用 decimal 类型，可以精确到分。&lt;/p&gt;&lt;p&gt;但是在海量互联网业务的设计标准中，并不推荐用 DECIMAL 类型，而是更推荐将 DECIMAL 转化为整型类型。也就是说，金融类型更推荐使用用分单位存储，而不是用元单位存储。如1元在数据库中用整型类型 100 存储。&lt;/p&gt;&lt;p&gt;下面是 bigint 类型的优点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;decimal 是通过二进制实现的一种编码方式，计算效率不如 bigint&lt;/li&gt;&lt;li&gt;使用 bigint 的话，字段是定长字段，存储高效，而 decimal 根据定义的宽度决定，在数据设计中，定长存储性能更好&lt;/li&gt;&lt;li&gt;使用 bigint 存储分为单位的金额，也可以存储千兆级别的金额，完全够用&lt;/li&gt;&lt;/ul&gt;&lt;h2&gt;枚举字段的使用&lt;/h2&gt;&lt;p&gt;&lt;b&gt;错误的设计规范：避免使用 ENUM 类型&lt;/b&gt;&lt;/p&gt;&lt;p&gt;在以前开发项目中，遇到用户性别，商品是否上架，评论是否隐藏等字段的时候，都是简单的将字段设计为 tinyint，然后在字段里备注 0 为什么状态，1 为什么状态。&lt;/p&gt;&lt;p&gt;这样设计的问题也比较明显：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;表达不清：这个表可能是其他同事设计的，你印象不是特别深的话，每次都需要去看字段注释，甚至有时候在编码的时候需要去数据库确认字段含义&lt;/li&gt;&lt;li&gt;脏数据：虽然在应用层可以通过代码限制插入的数值，但是还是可以通过sql和可视化工具修改值&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这种固定选项值的字段，推荐使用 ENUM 枚举字符串类型，外加 SQL_MODE 的严格模式&lt;/p&gt;&lt;blockquote&gt;在MySQL 8.0.16 以后的版本，可以直接使用check约束机制，不需要使用enum枚举字段类型&lt;/blockquote&gt;&lt;p&gt;而且我们一般在定义枚举值的时候使用&quot;Y&quot;,&quot;N&quot;等单个字符，并不会占用很多空间。但是如果选项值不固定的情况，随着业务发展可能会增加，才不推荐使用枚举字段。&lt;/p&gt;&lt;h2&gt;&lt;br/&gt;索引个数限制&lt;/h2&gt;&lt;p&gt;&lt;b&gt;错误的设计规范：限制每张表上的索引数量，一张表的索引不能超过 5 个&lt;/b&gt;&lt;/p&gt;&lt;p&gt;MySQL 单表的索引没有个数限制，业务查询有具体需要，创建即可，不要迷信个数限制&lt;/p&gt;&lt;h2&gt;&lt;br/&gt;子查询的使用&lt;/h2&gt;&lt;p&gt;&lt;b&gt;错误的设计规范：避免使用子查询&lt;/b&gt;&lt;/p&gt;&lt;p&gt;其实这个规范对老版本的 MySQL 来说是对的，因为之前版本的 MySQL 数据库对子查询优化有限，所以很多 OLTP 业务场合下，我们都要求在线业务尽可能不用子查询。&lt;/p&gt;&lt;p&gt;然而，MySQL 8.0 版本中，子查询的优化得到大幅提升，所以在新版本的MySQL中可以放心的使用子查询。&lt;/p&gt;&lt;p&gt;子查询相比 JOIN 更易于人类理解，比如我们现在想查看2020年没有发过文章的同学的数量&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;SELECT COUNT(*)
FROM user
WHERE id not in (
    SELECT user_id
    from blog
    where publish_time &amp;gt;= &quot;2020-01-01&quot; AND  publish_time &amp;lt;= &quot;2020-12-31&quot;
)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到，子查询的逻辑非常清晰：通过 not IN 查询文章表的用户有哪些。&lt;/p&gt;&lt;p&gt;如果用 left join 写&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;SELECT count(*)
FROM user LEFT JOIN blog
ON user.id = blog.user_id and blog.publish_time &amp;gt;= &quot;2020-01-01&quot; and blog.publish_time &amp;lt;= &quot;2020-12-31&quot;
where blog.user_id is NULL;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以发现，虽然 LEFT JOIN 也能完成上述需求，但不容易理解。&lt;/p&gt;&lt;p&gt;我们使用 explain查看两条 sql 的执行计划，发现都是一样的&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-6757645b2fd196137c0240045baee6d2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;308&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-6757645b2fd196137c0240045baee6d2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1280&quot; data-rawheight=&quot;308&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-6757645b2fd196137c0240045baee6d2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-6757645b2fd196137c0240045baee6d2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;通过上图可以很明显看到，不论是子查询还是 LEFT JOIN，最终都被转换成了left hash Join，所以上述两条 SQL 的执行时间是一样的。即，在 MySQL 8.0 中，优化器会自动地将 IN 子查询优化，优化为最佳的 JOIN 执行计划，这样一来，会显著的提升性能。&lt;/p&gt;&lt;h2&gt;&lt;br/&gt;总结&lt;/h2&gt;&lt;p&gt;阅读完前面的内容相信大家对 MySQL 已经有了新的认知，这些常见的错误可以总结为以下几点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;UUID 也可以当主键，自增 UUID 比自增主键性能更好，多占用的空间也可忽略不计&lt;/li&gt;&lt;li&gt;金融字段除了 decimal，也可以试试 bigint，存储分为单位的数据&lt;/li&gt;&lt;li&gt;对于固定选项值的字段，MySQL8 以前推荐使用枚举字段，MySQL8 以后使用check函数约束，不要使用 0，1，2 表示&lt;/li&gt;&lt;li&gt;一张表的索引个数并没有限制不能超过5个，可以根据业务情况添加和删除&lt;/li&gt;&lt;li&gt;MySQL8 对子查询有了优化，可以放心使用。 &lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;推荐阅读：&lt;/b&gt;&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/652/MySQL%2520%25E4%25B8%25AD%25E5%25AD%2598%25E5%2582%25A8%25E6%2597%25B6%25E9%2597%25B4%25E7%259A%2584%25E6%259C%2580%25E4%25BD%25B3%25E5%25AE%259E%25E8%25B7%25B5.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic1.zhimg.com/v2-c930bdf5e4303330e0c3d9b7dfb313b8_180x120.jpg&quot; data-image-width=&quot;685&quot; data-image-height=&quot;350&quot; class=&quot;LinkCard old LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;MySQL 中存储时间的最佳实践&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.upyun.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic1.zhimg.com/v2-c930bdf5e4303330e0c3d9b7dfb313b8_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/640/%25E5%25AE%259E%25E6%2593%258D%25E7%25AC%2594%25E8%25AE%25B0%25EF%25BC%259A%25E4%25B8%25BA%2520NSQ%2520%25E9%2585%258D%25E7%25BD%25AE%25E7%259B%2591%25E6%258E%25A7%25E6%259C%258D%25E5%258A%25A1%25E7%259A%2584%25E5%25BF%2583%25E8%25B7%25AF%25E5%258E%2586%25E7%25A8%258B.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic4.zhimg.com/v2-f18a6f76571f135e62db962fa4b73587_180x120.jpg&quot; data-image-width=&quot;1011&quot; data-image-height=&quot;593&quot; class=&quot;LinkCard old LinkCard--hasImage&quot;&gt;&lt;span class=&quot;LinkCard-backdrop&quot;/&gt;&lt;span class=&quot;LinkCard-content&quot;&gt;&lt;span class=&quot;LinkCard-text&quot;&gt;&lt;span class=&quot;LinkCard-title&quot; data-text=&quot;true&quot;&gt;实操笔记：为 NSQ 配置监控服务的心路历程&lt;/span&gt;&lt;span class=&quot;LinkCard-meta&quot;&gt;&lt;span&gt;​&lt;svg class=&quot;Zi Zi--InsertLink&quot; fill=&quot;currentColor&quot; viewbox=&quot;0 0 24 24&quot;&gt;&lt;path d=&quot;M13.414 4.222a4.5 4.5 0 1 1 6.364 6.364l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005a2.5 2.5 0 1 0-3.536-3.536l-3.005 3.005a.5.5 0 0 1-.707 0l-.707-.707a.5.5 0 0 1 0-.707l3.005-3.005zm-6.187 6.187a.5.5 0 0 1 .638-.058l.07.058.706.707a.5.5 0 0 1 .058.638l-.058.07-3.005 3.004a2.5 2.5 0 0 0 3.405 3.658l.13-.122 3.006-3.005a.5.5 0 0 1 .638-.058l.069.058.707.707a.5.5 0 0 1 .058.638l-.058.069-3.005 3.005a4.5 4.5 0 0 1-6.524-6.196l.16-.168 3.005-3.005zm8.132-3.182a.25.25 0 0 1 .353 0l1.061 1.06a.25.25 0 0 1 0 .354l-8.132 8.132a.25.25 0 0 1-.353 0l-1.061-1.06a.25.25 0 0 1 0-.354l8.132-8.132z&quot;/&gt;&lt;/svg&gt;&lt;/span&gt;www.upyun.com&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-imageCell&quot;&gt;&lt;img class=&quot;LinkCard-image LinkCard-image--horizontal&quot; alt=&quot;图标&quot; src=&quot;https://pic4.zhimg.com/v2-f18a6f76571f135e62db962fa4b73587_180x120.jpg&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>a6f218c14063e9527de7966e9ecbe797</guid>
<title>iOS 程序员所有的资源</title>
<link>https://toutiao.io/k/sif3l68</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;logged-out env-production page-responsive&quot; id=&quot;readabilityBody&quot;&gt;
    

    

  &lt;p id=&quot;start-of-content&quot; class=&quot;show-on-focus&quot;/&gt;





    


    

  &lt;include-fragment class=&quot;js-notification-shelf-include-fragment&quot; data-base-src=&quot;https://github.com/notifications/beta/shelf&quot;/&gt;




  &lt;div class=&quot;application-main &quot; data-commit-hovercards-enabled=&quot;&quot; data-discussion-hovercards-enabled=&quot;&quot; data-issue-and-pr-hovercards-enabled=&quot;&quot;&gt;
        &lt;div itemscope=&quot;&quot; itemtype=&quot;http://schema.org/SoftwareSourceCode&quot; class=&quot;&quot;&gt;
    &lt;main id=&quot;js-repo-pjax-container&quot; data-pjax-container=&quot;&quot;&gt;
      

        




  


  &lt;div class=&quot;hx_page-header-bg pt-3 hide-full-screen mb-5&quot;&gt;

      
          &lt;div class=&quot;d-block d-md-none mb-2 px-3 px-md-4 px-lg-5&quot;&gt;
      &lt;p class=&quot;f4 mb-3&quot;&gt;
        对市面上几乎所有和 iOS 开发相关的资源文档进行重新整理、融合和补充，更适合国内开发者。
      &lt;/p&gt;
    
    
  &lt;/div&gt;

        

  &lt;nav data-pjax=&quot;#js-repo-pjax-container&quot; aria-label=&quot;Repository&quot; data-view-component=&quot;true&quot; class=&quot;js-repo-nav js-sidenav-container-pjax js-responsive-underlinenav overflow-hidden UnderlineNav px-3 px-md-4 px-lg-5&quot;&gt;

    
      
&lt;/nav&gt;

  &lt;/div&gt;


&lt;div class=&quot;container-xl clearfix new-discussion-timeline px-3 px-md-4 px-lg-5&quot;&gt;
  &lt;div id=&quot;repo-content-pjax-container&quot; class=&quot;repository-content &quot;&gt;

    
      
      &lt;div&gt;
  &lt;p class=&quot;d-none d-lg-block mt-6 mr-3 Popover top-0 right-0 color-shadow-medium col-3&quot;&gt;
    
  &lt;/p&gt;

  &lt;div data-view-component=&quot;true&quot; class=&quot;gutter-condensed gutter-lg flex-column flex-md-row d-flex&quot;&gt;

  &lt;div data-view-component=&quot;true&quot; class=&quot;flex-shrink-0 col-12 col-md-9 mb-4 mb-md-0&quot;&gt;      
      &lt;div class=&quot;file-navigation mb-3 d-flex flex-items-start&quot;&gt;
  



  

  &lt;p class=&quot;flex-auto&quot;/&gt;

  &lt;include-fragment data-test-selector=&quot;overview-actions-fragment&quot; src=&quot;/uzi-yyds-code/IOS-programmer-all-resources/overview_actions/main&quot;/&gt;


    &lt;span class=&quot;d-none d-md-flex ml-2&quot;&gt;

          
&lt;get-repo&gt;
  &lt;details class=&quot;position-relative details-overlay details-reset&quot; data-action=&quot;toggle:get-repo#onDetailsToggle&quot;&gt;
    &lt;summary class=&quot;btn btn-primary&quot; data-hydro-click=&quot;{&amp;quot;event_type&amp;quot;:&amp;quot;repository.click&amp;quot;,&amp;quot;payload&amp;quot;:{&amp;quot;repository_id&amp;quot;:389027326,&amp;quot;target&amp;quot;:&amp;quot;CLONE_OR_DOWNLOAD_BUTTON&amp;quot;,&amp;quot;originating_url&amp;quot;:&amp;quot;https://github.com/uzi-yyds-code/IOS-programmer-all-resources?hmsr=toutiao.io&amp;amp;utm_campaign=toutiao.io&amp;amp;utm_medium=toutiao.io&amp;amp;utm_source=toutiao.io&amp;quot;,&amp;quot;user_id&amp;quot;:null}}&quot; data-hydro-click-hmac=&quot;9986a97b3e29cde1cf6ca342a2fefee4871689711575354b92fcea0adb6cb31b&quot;&gt;
      &lt;svg class=&quot;octicon octicon-download mr-1&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.47 10.78a.75.75 0 001.06 0l3.75-3.75a.75.75 0 00-1.06-1.06L8.75 8.44V1.75a.75.75 0 00-1.5 0v6.69L4.78 5.97a.75.75 0 00-1.06 1.06l3.75 3.75zM3.75 13a.75.75 0 000 1.5h8.5a.75.75 0 000-1.5h-8.5z&quot;/&gt;&lt;/svg&gt;
      Code
      &lt;span class=&quot;dropdown-caret&quot;/&gt;
&lt;/summary&gt;    &lt;div class=&quot;position-relative&quot;&gt;
      &lt;div class=&quot;dropdown-menu dropdown-menu-sw p-0&quot;&gt;
          &lt;div data-target=&quot;get-repo.modal&quot;&gt;
            &lt;div class=&quot;border-bottom p-3&quot;&gt;
              &lt;a class=&quot;Link--muted float-right tooltipped tooltipped-s&quot; href=&quot;https://docs.github.com/articles/which-remote-url-should-i-use&quot; target=&quot;_blank&quot; aria-label=&quot;Which remote URL should I use?&quot;&gt;
  &lt;svg aria-hidden=&quot;true&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; data-view-component=&quot;true&quot; class=&quot;octicon octicon-question&quot;&gt;
    &lt;path fill-rule=&quot;evenodd&quot; d=&quot;M8 1.5a6.5 6.5 0 100 13 6.5 6.5 0 000-13zM0 8a8 8 0 1116 0A8 8 0 010 8zm9 3a1 1 0 11-2 0 1 1 0 012 0zM6.92 6.085c.081-.16.19-.299.34-.398.145-.097.371-.187.74-.187.28 0 .553.087.738.225A.613.613 0 019 6.25c0 .177-.04.264-.077.318a.956.956 0 01-.277.245c-.076.051-.158.1-.258.161l-.007.004a7.728 7.728 0 00-.313.195 2.416 2.416 0 00-.692.661.75.75 0 001.248.832.956.956 0 01.276-.245 6.3 6.3 0 01.26-.16l.006-.004c.093-.057.204-.123.313-.195.222-.149.487-.355.692-.662.214-.32.329-.702.329-1.15 0-.76-.36-1.348-.863-1.725A2.76 2.76 0 008 4c-.631 0-1.155.16-1.572.438-.413.276-.68.638-.849.977a.75.75 0 101.342.67z&quot;/&gt;
&lt;/svg&gt;
&lt;/a&gt;



&lt;tab-container&gt;

  

  &lt;div role=&quot;tabpanel&quot;&gt;
    

    &lt;p class=&quot;mt-2 mb-0 f6 color-text-secondary&quot;&gt;
        Use Git or checkout with SVN using the web URL.
    &lt;/p&gt;
  &lt;/div&gt;


  
&lt;/tab-container&gt;

            &lt;/div&gt;
            
          &lt;/div&gt;

        

        

        &lt;div class=&quot;p-3&quot; data-targets=&quot;get-repo.platforms&quot; data-platform=&quot;xcode&quot; hidden=&quot;&quot;&gt;
          &lt;h4 class=&quot;lh-condensed mb-3&quot;&gt;Launching Xcode&lt;span class=&quot;AnimatedEllipsis&quot;/&gt;&lt;/h4&gt;
          &lt;p class=&quot;color-text-secondary&quot;&gt;If nothing happens, &lt;a href=&quot;https://developer.apple.com/xcode/&quot;&gt;download Xcode&lt;/a&gt; and try again.&lt;/p&gt;
          &lt;button data-action=&quot;click:get-repo#onDetailsToggle&quot; type=&quot;button&quot; data-view-component=&quot;true&quot; class=&quot;btn-link&quot;&gt;
  
  Go back
  

&lt;/button&gt;
        &lt;/div&gt;

        &lt;div class=&quot;p-3 &quot; data-targets=&quot;get-repo.platforms&quot; data-target=&quot;new-codespace.loadingVscode prefetch-pane.loadingVscode&quot; data-platform=&quot;vscode&quot; hidden=&quot;&quot;&gt;
  &lt;poll-include-fragment data-target=&quot;get-repo.vscodePoller new-codespace.vscodePoller prefetch-pane.vscodePoller&quot;&gt;
    &lt;h4 class=&quot;lh-condensed mb-3&quot;&gt;Launching Visual Studio Code&lt;span class=&quot;AnimatedEllipsis&quot; data-hide-on-error=&quot;&quot;/&gt;&lt;/h4&gt;
    &lt;p class=&quot;color-text-secondary&quot; data-hide-on-error=&quot;&quot;&gt;Your codespace will open once ready.&lt;/p&gt;
    &lt;p class=&quot;color-text-secondary&quot; data-show-on-error=&quot;&quot; hidden=&quot;&quot;&gt;There was a problem preparing your codespace, please try again.&lt;/p&gt;
  &lt;/poll-include-fragment&gt;
&lt;/div&gt;

      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/details&gt;
&lt;/get-repo&gt;


      
    &lt;/span&gt;
&lt;/div&gt;

      


&lt;div class=&quot;Box mb-3&quot;&gt;
  
  &lt;h2 id=&quot;files&quot; class=&quot;sr-only&quot;&gt;Files&lt;/h2&gt;
  


    &lt;a class=&quot;d-none js-permalink-shortcut&quot; data-hotkey=&quot;y&quot; href=&quot;/uzi-yyds-code/IOS-programmer-all-resources/tree/b93d1c7d357d8bee40464207fcb2f41c55d4278f&quot;&gt;Permalink&lt;/a&gt;

  &lt;div data-view-component=&quot;true&quot; class=&quot;include-fragment-error flash flash-error flash-full py-2&quot;&gt;
  &lt;svg aria-hidden=&quot;true&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; data-view-component=&quot;true&quot; class=&quot;octicon octicon-alert&quot;&gt;
    &lt;path fill-rule=&quot;evenodd&quot; d=&quot;M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z&quot;/&gt;
&lt;/svg&gt;&lt;p&gt;
  
    Failed to load latest commit information.


  
&lt;/p&gt;&lt;/div&gt;  &lt;div class=&quot;js-details-container Details&quot;&gt;
    &lt;div role=&quot;grid&quot; aria-labelledby=&quot;files&quot; class=&quot;Details-content--hidden-not-important js-navigation-container js-active-navigation-container d-md-block&quot; data-pjax=&quot;&quot;&gt;
      &lt;div class=&quot;sr-only&quot; role=&quot;row&quot;&gt;
        &lt;p role=&quot;columnheader&quot;&gt;Type&lt;/p&gt;
        &lt;p role=&quot;columnheader&quot;&gt;Name&lt;/p&gt;
        &lt;p role=&quot;columnheader&quot; class=&quot;d-none d-md-block&quot;&gt;Latest commit message&lt;/p&gt;
        &lt;p role=&quot;columnheader&quot;&gt;Commit time&lt;/p&gt;
      &lt;/div&gt;

        
        
    &lt;/div&gt;
    &lt;p class=&quot;Details-content--shown Box-footer d-md-none p-0&quot;&gt;
      &lt;button type=&quot;button&quot; class=&quot;d-block btn-link js-details-target width-full px-3 py-2&quot; aria-expanded=&quot;false&quot;&gt;
        View code
      &lt;/button&gt;
    &lt;/p&gt;
  &lt;/div&gt;




&lt;/div&gt;

    &lt;readme-toc&gt;

    &lt;div id=&quot;readme&quot; class=&quot;Box md js-code-block-container Box--responsive&quot;&gt;

      

        &lt;div data-target=&quot;readme-toc.content&quot; class=&quot;Box-body px-5 pb-5&quot;&gt;
          &lt;article class=&quot;markdown-body entry-content container-lg&quot; itemprop=&quot;text&quot;&gt;&lt;h1&gt;&lt;a id=&quot;user-content-ios-programmer-all-resources&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#ios-programmer-all-resources&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;IOS-programmer-all-resources&lt;/h1&gt;
&lt;p&gt;对市面上几乎所有和 iOS 开发相关的资源文档进行重新整理、融合和补充，更适合国内开发者。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;您的 &lt;strong&gt;✩ Star&lt;/strong&gt; 是我们持续维护的最大动力！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由于内容比较长，GitHub项目首页文档显示不完整，完整版加QQ群：1001906160&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://camo.githubusercontent.com/ea0548aa19ab9cd9e2cf24dd18cbd7f26beee89f2541ef11a107f3ef7f89ff8c/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31383637313932302d646565323361313135333761306436642e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/ea0548aa19ab9cd9e2cf24dd18cbd7f26beee89f2541ef11a107f3ef7f89ff8c/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f31383637313932302d646565323361313135333761306436642e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430&quot; alt=&quot;image.png&quot; data-canonical-src=&quot;https://upload-images.jianshu.io/upload_images/18671920-dee23a11537a0d6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文档内容包含了数十套教程、数千个框架、不计其数的工具、网站、资料等等，目前总计 4600+，涵盖了和 iOS 学习、日常工作中相关的方方面面，不管是 iOS 新手、还是老手，都是值得收藏的一个资源文档。&lt;/p&gt;
&lt;p&gt;对于初学者来说，可以先款速浏览一下该文档，先对 iOS 整个生态提前有个完整的印象，打开眼界，对于今后的学习、工作能节省很多时间，少走一些弯路。&lt;/p&gt;
&lt;p&gt;对于老手，本文对内容排版也做了优化，便于查找，对于 github 开源项目，也将 Star 标注出来，以便于筛选，对于支持 Swift 项目也做了相应标记。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;更新时间&lt;/th&gt;
&lt;th&gt;涵盖资源数&lt;/th&gt;
&lt;th&gt;Github 地址&lt;/th&gt;
&lt;th&gt;PDF下载&lt;/th&gt;
&lt;th&gt;带目录 HTML 地址&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;2020-06-01&lt;/td&gt;
&lt;td&gt;4628&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/kechengsou/awesome-ios&quot;&gt;下载&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://github.com/kechengsou/awesome-ios/releases&quot;&gt;下载&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://www.kcsou.com/awesome/docs/ios/index.htm&quot; rel=&quot;nofollow&quot;&gt;访问&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr/&gt;
&lt;h2&gt;&lt;a id=&quot;user-content-目录&quot; class=&quot;anchor&quot; aria-hidden=&quot;true&quot; href=&quot;#目录&quot;&gt;&lt;svg class=&quot;octicon octicon-link&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; aria-hidden=&quot;true&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M7.775 3.275a.75.75 0 001.06 1.06l1.25-1.25a2 2 0 112.83 2.83l-2.5 2.5a2 2 0 01-2.83 0 .75.75 0 00-1.06 1.06 3.5 3.5 0 004.95 0l2.5-2.5a3.5 3.5 0 00-4.95-4.95l-1.25 1.25zm-4.69 9.64a2 2 0 010-2.83l2.5-2.5a2 2 0 012.83 0 .75.75 0 001.06-1.06 3.5 3.5 0 00-4.95 0l-2.5 2.5a3.5 3.5 0 004.95 4.95l1.25-1.25a.75.75 0 00-1.06-1.06l-1.25 1.25a2 2 0 01-2.83 0z&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/kechengsou/awesome-ios/blob/master/README.md?hmsr=toutiao.io&amp;amp;utm_campaign=toutiao.io&amp;amp;utm_medium=toutiao.io&amp;amp;utm_source=toutiao.io#%E7%9B%AE%E5%BD%95&quot;/&gt;目录&lt;/h2&gt;

&lt;/article&gt;
        &lt;/div&gt;
    &lt;/div&gt;

  &lt;/readme-toc&gt;


&lt;/div&gt;

    &lt;div data-view-component=&quot;true&quot; class=&quot;flex-shrink-0 col-12 col-md-3&quot;&gt;      

      &lt;div class=&quot;BorderGrid BorderGrid--spacious&quot; data-pjax=&quot;&quot;&gt;
        &lt;div class=&quot;BorderGrid-row hide-sm hide-md&quot;&gt;
          &lt;div class=&quot;BorderGrid-cell&quot;&gt;
              &lt;h2 class=&quot;mb-3 h4&quot;&gt;About&lt;/h2&gt;

    &lt;p class=&quot;f4 mt-3&quot;&gt;
      对市面上几乎所有和 iOS 开发相关的资源文档进行重新整理、融合和补充，更适合国内开发者。
    &lt;/p&gt;


  &lt;h3 class=&quot;sr-only&quot;&gt;Resources&lt;/h3&gt;
  


  &lt;include-fragment aria-label=&quot;Loading...&quot; src=&quot;/uzi-yyds-code/IOS-programmer-all-resources/hovercards/citation/sidebar_partial?commit=b93d1c7d357d8bee40464207fcb2f41c55d4278f&quot;&gt;
  &lt;/include-fragment&gt;

          &lt;/div&gt;
        &lt;/div&gt;
          
          
          
      &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;



  &lt;/div&gt;
&lt;/div&gt;


    &lt;/main&gt;
  &lt;/div&gt;

  &lt;/div&gt;

          




  &lt;div id=&quot;ajax-error-message&quot; class=&quot;ajax-error-message flash flash-error&quot; hidden=&quot;&quot;&gt;
    &lt;svg aria-hidden=&quot;true&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; data-view-component=&quot;true&quot; class=&quot;octicon octicon-alert&quot;&gt;
    &lt;path fill-rule=&quot;evenodd&quot; d=&quot;M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z&quot;/&gt;
&lt;/svg&gt;
    &lt;button type=&quot;button&quot; class=&quot;flash-close js-ajax-error-dismiss&quot; aria-label=&quot;Dismiss error&quot;&gt;
      &lt;svg aria-hidden=&quot;true&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; data-view-component=&quot;true&quot; class=&quot;octicon octicon-x&quot;&gt;
    &lt;path fill-rule=&quot;evenodd&quot; d=&quot;M3.72 3.72a.75.75 0 011.06 0L8 6.94l3.22-3.22a.75.75 0 111.06 1.06L9.06 8l3.22 3.22a.75.75 0 11-1.06 1.06L8 9.06l-3.22 3.22a.75.75 0 01-1.06-1.06L6.94 8 3.72 4.78a.75.75 0 010-1.06z&quot;/&gt;
&lt;/svg&gt;
    &lt;/button&gt;&lt;p&gt;
    You can’t perform that action at this time.
  &lt;/p&gt;&lt;/div&gt;

  &lt;div class=&quot;js-stale-session-flash flash flash-warn flash-banner&quot; hidden=&quot;&quot;&gt;
    &lt;svg aria-hidden=&quot;true&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; data-view-component=&quot;true&quot; class=&quot;octicon octicon-alert&quot;&gt;
    &lt;path fill-rule=&quot;evenodd&quot; d=&quot;M8.22 1.754a.25.25 0 00-.44 0L1.698 13.132a.25.25 0 00.22.368h12.164a.25.25 0 00.22-.368L8.22 1.754zm-1.763-.707c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0114.082 15H1.918a1.75 1.75 0 01-1.543-2.575L6.457 1.047zM9 11a1 1 0 11-2 0 1 1 0 012 0zm-.25-5.25a.75.75 0 00-1.5 0v2.5a.75.75 0 001.5 0v-2.5z&quot;/&gt;
&lt;/svg&gt;
    &lt;span class=&quot;js-stale-session-flash-signed-in&quot; hidden=&quot;&quot;&gt;You signed in with another tab or window. &lt;a href=&quot;&quot;&gt;Reload&lt;/a&gt; to refresh your session.&lt;/span&gt;
    &lt;span class=&quot;js-stale-session-flash-signed-out&quot; hidden=&quot;&quot;&gt;You signed out in another tab or window. &lt;a href=&quot;&quot;&gt;Reload&lt;/a&gt; to refresh your session.&lt;/span&gt;
  &lt;/div&gt;
    &lt;template id=&quot;site-details-dialog&quot;&gt;
  &lt;details class=&quot;details-reset details-overlay details-overlay-dark lh-default color-text-primary hx_rsm&quot; open=&quot;&quot;&gt;
    &lt;summary role=&quot;button&quot; aria-label=&quot;Close dialog&quot;/&gt;
    &lt;details-dialog class=&quot;Box Box--overlay d-flex flex-column anim-fade-in fast hx_rsm-dialog hx_rsm-modal&quot;&gt;
      &lt;button class=&quot;Box-btn-octicon m-0 btn-octicon position-absolute right-0 top-0&quot; type=&quot;button&quot; aria-label=&quot;Close dialog&quot; data-close-dialog=&quot;&quot;&gt;
        &lt;svg aria-hidden=&quot;true&quot; viewbox=&quot;0 0 16 16&quot; version=&quot;1.1&quot; data-view-component=&quot;true&quot; class=&quot;octicon octicon-x&quot;&gt;
    &lt;path fill-rule=&quot;evenodd&quot; d=&quot;M3.72 3.72a.75.75 0 011.06 0L8 6.94l3.22-3.22a.75.75 0 111.06 1.06L9.06 8l3.22 3.22a.75.75 0 11-1.06 1.06L8 9.06l-3.22 3.22a.75.75 0 01-1.06-1.06L6.94 8 3.72 4.78a.75.75 0 010-1.06z&quot;/&gt;
&lt;/svg&gt;
      &lt;/button&gt;
      &lt;p class=&quot;octocat-spinner my-6 js-details-dialog-spinner&quot;/&gt;
    &lt;/details-dialog&gt;
  &lt;/details&gt;
&lt;/template&gt;

    

    &lt;template id=&quot;snippet-clipboard-copy-button&quot;&gt;
  
&lt;/template&gt;



  

  &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>