<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>5b0e8a7ddf5d1415b510d84e6af07d77</guid>
<title>57 张图，13 个实验，干死 MySQL 锁</title>
<link>https://toutiao.io/k/huoy9s9</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你好，我是yes。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前段时间写了一篇&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkxNTE3NjQ3MA==&amp;amp;mid=2247490365&amp;amp;idx=1&amp;amp;sn=5e96739ce949eaa9fd8435834494cfc6&amp;amp;chksm=c1627644f615ff5248b4221480b3bb6df42cdf076c86dc228a062d99d6035127d61e9ae8ffb7&amp;amp;scene=21#wechat_redirect&quot; textvalue=&quot;关于 MySQL 锁的文章&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;关于 MySQL 锁的文章&lt;/a&gt;，一些小伙伴们在阅读之后产生了一些疑问，这些问题还挺有代表性的，所以在这里做个实验，来用事实探究一番。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那篇文章提到了记录锁（Record Locks），顾名思义锁的是记录，&lt;span&gt;作用在索引上的记录&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;锁是作用在索引上这句话可能不太好理解，并且对于在可重复读和读提交两个隔离级别下，关于是否命中二级索引的锁之间的阻塞也不太清晰。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这句话读着可能有点拗口，没事，我来给你看几个实验，对这一切就异常清晰了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实验的 MySQL 版本为：5.7.26。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;实验一：隔离级别为读提交，锁定非索引列的实验&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先建个非常简单的表，只有主键索引，没有二级索引。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;`yes`&lt;/span&gt; (&lt;br/&gt;  &lt;span&gt;`id`&lt;/span&gt; &lt;span&gt;bigint&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; AUTO_INCREMENT,&lt;br/&gt;  &lt;span&gt;`name`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;45&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`address`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;45&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;  PRIMARY &lt;span&gt;KEY&lt;/span&gt; (&lt;span&gt;`id`&lt;/span&gt;)&lt;br/&gt;) &lt;span&gt;ENGINE&lt;/span&gt;=&lt;span&gt;InnoDB&lt;/span&gt; AUTO_INCREMENT=&lt;span&gt;4&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;CHARSET&lt;/span&gt;=utf8mb4&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;隔离级别如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3463855421686747&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGobrIcUL2nOF0f5w41iaWQVJVPJPKpm0QlkiaOJRUSZZon1WmaO3nrg7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;332&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关闭自动提交事务：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2711864406779661&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGfbN93Zv3icNUOohC77KwLFF3uInKNtfXHXBDM3WcPuLCticnb1v2eOEw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;354&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;已经准备好的数据：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5906976744186047&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGLqKFUgVE94M67fYHgZiaYhSkNxNhXUM0We4I2d2AcH7ZaZvPYWecibUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;215&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，发起事务 A，执行如下语句，&lt;span&gt;且事务未提交&lt;/span&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.26247288503253796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDG6mJETeXeV17aO8xWXUKW2TZXDbJNVHz3tANBzNclbuSzPSoNcfibTicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;461&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着，再发起事务 B，执行如下语句：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.08971553610503283&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDG8gU1hg4MebAdFFSHazQWjwLalhjXiaKiaTObh1oS4libnFu0mYfibSDWfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;457&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你可能以为事务 B 不会被阻塞，因为事务 B 锁的是&lt;code&gt;name=xx&lt;/code&gt;和事务A锁&lt;code&gt;name=yes&lt;/code&gt;讲道理相互之间没有冲突，但是从结果来看，事务 B 被阻塞了，调用&lt;code&gt;select * from innodb_lock_waits;&lt;/code&gt;看下谁等谁&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1865203761755486&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDG1uQUoyKD77UdYDiblialbiaI5sedupBq2VDron09FYfadaXxicibnRRIgdg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;638&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，事务6517(B)在等待事务6516(A)。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，调用 &lt;code&gt;SELECT * FROM innodb_locks;&lt;/code&gt; 查看相关锁的信息&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.19056603773584907&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGrhibmwI6fvV1wsX7TI4ZcExy6xqXBF4ibTalPaZcKKLVxZsXYbNLDVuQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1060&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;锁的类型就是行级锁，此时的锁为 X 锁，&lt;span&gt;锁的索引就是主键索引&lt;/span&gt;，这个结果表明的意思是事务 B（6517）想要 id 为 1 的记录锁，但是这个记录此时被事务A（6516）占有。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是的，这里的 1 其实不是指第一个记录的意思，是 id 为 1 的记录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能有人疑惑， 为啥 lock_data 为 1 ？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;（我没看过源码，个人推断如下：）执行 &lt;code&gt;select ... for update&lt;/code&gt; ，由于 name 字段没有索引，索引事务 A、B 只能加锁到主键索引上，此时需要搜索 name 为 yes 的记录，但是又没有索引，只能全表扫描，恰巧扫描第一条记录就符合要求了，于是上锁，然后接着往后扫描，后面不符合条件所以没有上锁。此时事务 B 加锁，过程和事务 A 一样需要从第一条记录开始扫描上锁，但此时第一条记录已经被事务 A 锁了，所以第一条记录就冲突了，而第一条记录的 id 就是为 1，因此 lock_data 为 1。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现在，我把事务 A 提交，则事务 B 里面能立马得到结果。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2159090909090909&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGrxuLgGSvV59gwmkUzROBQkJUaQsjZLkRmsbaJ6jfOOn31WjEUYTzcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;440&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面这个实验可以得知，如果查询条件上锁，但是没有对应的二级索引可以命中，那么锁就会锁到主键(聚簇)索引上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而聚簇索引的非叶子节点只有主键的信息，没有 name 的信息，所以只能按顺序的全表扫描，加锁符合条件的记录，&lt;span&gt;但是在扫描过程中遇到已经被加锁的记录就会被阻塞，即使这个记录不是目标记录&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看下面这个实验，你就清晰了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个实验其实就是把事务 A、B的语句执行的顺序换了一下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，新起一个事务 C，先执行如下语句，锁的是id为2的记录：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.28322440087145967&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGTXBnkzmvr94q1Qsic1ia0WAqXfzPVXOXINiccnibrqRA1Mux8qgMBCb0wA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;459&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后，再起一个事务 D，执行：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.07036247334754797&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGibrib1iczsiaz8vmRLyQJjcgDnMsJibTjXZkvknpQq1uYAR42wDR9gKia5OA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;469&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时同样被阻塞了，但是查看下锁信息你会发现：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.13307984790874525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGYD6qNACFIby1aLaiankLt2k2LB8HLTxpeN2uzBIpYLibA2DnKZC9upiaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;789&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;lock_data 变为 id 为 2 的记录了，也就是说事务 C 扫描了 id 为 1 的记录之后，发现不符合条件，就释放了，（不然 lock_data  的值应该为 1）然后继续扫描 id 为 2 的记录，符合条件，于是上锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而事务 D 也扫描了 id 为 1 的记录，符合条件，于是上锁，然后接着向后扫描到  id 为 2 的记录，但是此时已经被事务C 加锁了，于是被阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这结果也符合了我上面的推断。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再继续实验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次来试试 update 的，此时新起事务 E ：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24731182795698925&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGic7wic7ycZG4X2mEvGicgcW18ADeb7BKNaH9Pibe0sMOWY2XPccw0Ok1pw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;465&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再起一个事务 F ：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.14761904761904762&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDG41dDlO0BhIOic6Edpib2uGLOXdS8wcsUhPMZKBwOglLugf7ibMswj2SZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;420&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并没有发生阻塞，这其实是符合我们预期的。但从中我们可以得知，&lt;span&gt;在读提交级别下，即使没有索引，update 的全表扫描并不是和&lt;code&gt;select ... for update&lt;/code&gt;那样全表按顺先加锁再判断条件，而是先找到符合的记录，然后再上锁&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再继续实验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，把上面的事务都提交之后，再新起一个事务 G 执行以下语句，且不提交事务：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24948453608247423&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGgdw5480kMyQDB2sznJM1V65eCiawlMJeQibM7rwViaxgKicSVLsZMqyoaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;485&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着，再起一个事务 H 执行以下语句：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.06951026856240126&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGJY2HIvqibE8jPAHVzYnSWGKYdLTEInibSRJqxkHLyrfdxg8OGHDFCDIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;633&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，事务 H 没有被阻塞，丝滑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说明在读提交级别下，锁的只是已经存在的记录，对于插入还是防不住的，即使插入的 name 是 yes，也一样不会被阻塞。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.11974789915966387&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGG0iaSFweDQ5dodM7KCKKianmalbzaexnsGS91VTUlHrrKhbmP1w4ggQw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/figure&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;实验二：隔离级别为可重复读，锁定非索引列的实验&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;隔离级别为可重复读：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3475783475783476&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGT4BzxdLUp5xhia8Wg4VY0qUtNnNzDhJ16xrt3bVGWQDF8cPLIfFxy7w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;351&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是之前的数据：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5906976744186047&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGLqKFUgVE94M67fYHgZiaYhSkNxNhXUM0We4I2d2AcH7ZaZvPYWecibUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;215&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时，发起事务 A，执行如下语句，&lt;span&gt;且事务未提交&lt;/span&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.26247288503253796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGZvBmDqpiaqaqOibZWxHSMv55Csq6iaND65Rok9GYL5f17q4cSWWCAuOCQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;461&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着，再发起事务 B，执行如下语句：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.08971553610503283&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDG8gU1hg4MebAdFFSHazQWjwLalhjXiaKiaTObh1oS4libnFu0mYfibSDWfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;457&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;意料之中的结果，即事务 B 被阻塞，锁信息如下，还是 id 为 1 的记录出了锁冲突。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.19750889679715303&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGB46yFmVbicWJWZI4ccpWTaWcTuTvviaRdEicgLDIsXCgDj9bEglVV0PhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;562&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时提交事务A、B，然后再新起一个事务 C：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.27232142857142855&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGTMXqtWtprcgEicZAeqseH9t0vxuP5gib8ynuhvoIp6uyASibfmeqlWDWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;448&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后再新起一个事务 D：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.06639004149377593&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDG2Xn3hJ7MbVjHNotwyT9Vdib2utBdR1muMmV7wproGDHA5MuFYbyIfUg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;482&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，事务 C、D 就是和 A、B 来个反顺序执行，&lt;span&gt;重点来了&lt;/span&gt;，此时的锁信息如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2257495590828924&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGGlNrCDyjOFd5C1ASUibnyuFmuvS7KYkLU5cLErZC3EqgGkdgfYjeIHQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;567&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，冲突的还是 id 为 1 的这条记录，那说明事务 C 在全表扫描，从第一条开始遍历，&lt;span&gt;即使访问到了不符合条件的记录，加锁之后在事务提交之前就不会释放&lt;/span&gt;！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;这里就和读已提交有差别了&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再继续实验，此时提交事务A、B、C、D之后，再新起一个事务 E：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.26247288503253796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDG6mJETeXeV17aO8xWXUKW2TZXDbJNVHz3tANBzNclbuSzPSoNcfibTicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;461&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着，再起事务 F 执行如下语句：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.09624796084828711&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGial1z4wBuDtBzicgPYBs5ofTXzwCibN2G4uGSyBdVm3SiaJqhKACpJLjWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;613&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，事务 F 被阻塞了，此时再看下锁的一些信息：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.11590524534686972&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGQ5hXaEvxib5a9BLRvtJdicuCRcdg0K0Lfj0ZTumw6Z361MFnRkwasGdQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1182&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;起冲突的 lock_data 是最大记录(supremum)，这个记录之前的文章提过的，MySQL页默认有最大和最小两条记录，不存储数据，作用类似于链表的 dummy  节点。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.45480631276901007&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDG4Yo31icV8FWO9yMZ5BEzIzSttSBmFFVmwicJTa1IkO6NQyMXzxck4ghg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;697&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从这个结果来看，这个最大记录也被事务 F 锁了，这个表的 ID 是自增的，所以此时的插入记录，刚好要插入到最后面，这样就发生了冲突。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这其实有点出乎我的意料，我以为事务 F 插入应该是被事务 E 加的&lt;span&gt;间隙锁&lt;/span&gt;给挡了才对。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候，我又做了个实验，我先造了一条 id 为 6 的记录，此时表内的数据如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5089285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGW5AK2jIkkKgFicIZazP07ibs2FqU2c3zcBF7yfBJsW6DhHAK9iafGib9Wg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;336&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样再起一个事务执行，且未提交：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24369747899159663&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGmjzIeXibGP1aDNOuypxiaFycI76sYgia7MqmumZp8IHbnG4ib6GD6LwiaYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着，我再起一个事务执行插入，但是指明了插入的 id 是 4 ，这样这条记录会将插入到记录 id 为 6 的前面。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.03206106870229008&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGmF4wq2AicpWBhdTlaicLCJIhVnTscESZCUGPzLlAstq8AL9JSibVdXZ9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;655&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时被阻塞了，查看锁信息：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.12158590308370044&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGnW7XCicIkCgBYVpnSL5eIoK9HmlOiaHK7olGqP8NfU4cCTlZvaqrP08w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1135&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到截图的 X,GAP 没，结果显示插入的事务需要记录锁+间隙锁，但是被前一个事务占用的 id 为 6 的记录锁给阻塞了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这涉及到我的盲区了，上面的插入还只要记录锁，这时候的插入就又要申请间隙锁了？但是也不是因为间隙被阻塞啊？我之后再找个时间研究下，如果有大佬知道，&lt;span&gt;请评论区指导我下&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再继续实验，清理下数据，还原到初始状态：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5906976744186047&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDG50iaibOSb5DibbswiaEVImWDWczKrzEVYn4kLCX5cwnmjz6eIHns2S6ZYg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;215&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动一个事务 G 执行：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1543778801843318&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGS9Oiap3t16w1NRqKuwolUoh3Tsea3iaRjspyhJuNRlrMQW3VmDFWVWVg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;434&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着再启动一个事务 H 执行：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.06320541760722348&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGsybNcydxiaPoBCJeHtyyUZiaylaXnyiajyd8hRD4c6oRZQAoCkQLUqNNA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;443&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时发生了阻塞，看下锁的信息：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.13528748590755355&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGCOibTZWK6p0NiaybiconCNW2YY04a1OagbHhh6saiaZAI9KJNaxs2V9cPQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;887&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，可重复读级别下 update 的加锁与读提交不太一样，加锁的 lock_data 是 1，说明事务 G 扫描的 id 为 1 的记录之后没有释放锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果把事务G、H 的&lt;span&gt;启动顺序反过来&lt;/span&gt;，也就是先执行 H 的语句再执行 G 的语句，结果也是一样的，同样加锁的 lock_data 是 1，这说明&lt;span&gt;可重复读的 update 不是先判断条件是否符合再上锁，而是先上锁再判断条件是否符合&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;update 都会被阻塞，最终结论就是：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;span&gt;可重复读级别&lt;/span&gt;下，加锁非索引列导致的全表记录上锁会使得所有插入和修改都会被阻塞。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结一下：&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时把读者问题列上：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6812903225806451&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGLCDl20tsmoBKGlRicpicPfotM3scjzEibVfRj8iaibtUgJXy1b0KWzHEb3w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;775&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;留言的回答语境是在可重复读级别下，现在我再来总结回答下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在读提交级别下&lt;/span&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果&lt;span&gt;锁定的列为非索引列&lt;/span&gt;，加锁都是加到主键索引上的，&lt;code&gt;select ..for update&lt;/code&gt;的加锁的顺序是从前往后全表扫描的顺序，遍历的记录先上锁，上锁之后发现不满足条件，则释放锁，然后继续往后遍历，直到全表扫描结束。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;insert 都不会被阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 update 其它字段值，其实也是找记录，如果找到的记录已经被上锁了，那么就会阻塞，如果找到的记录没有被锁则不会被阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;在可重复读级别下&lt;/span&gt;：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果&lt;span&gt;锁定的列为非索引列&lt;/span&gt;，加锁都是加到主键索引上的，&lt;code&gt;select ..for update&lt;/code&gt;的加锁的顺序是从前往后全表扫描的顺序，遍历的记录先上锁，上锁之后发现不满足条件，则&lt;span&gt;不会&lt;/span&gt;释放锁，然后继续往后遍历，直到全表扫描结束。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以只要有一个全表扫描的加锁，则 insert 的时候就会被阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而 update 其它字段值，其实也是找记录，如果找到的记录已经被上锁了，那么就会阻塞，如果找到的记录没有被锁则不会被阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;与之相关的还有一个问题：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6401709401709401&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGb0XxNQicHvgRBw7GOufCJUbq0CqSrMFN3NM7SLPURYGB5kJficzFmicpw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1170&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;图里已经有答案了，包括前面的截图也可以看到所有的 lock_type 都是 RECORD ，也就是行级锁。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;实验三：隔离级别为读提交，锁定索引列的实验&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;此时在 name 列建立索引&lt;/span&gt;。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt; &lt;span&gt;`yes`&lt;/span&gt; (&lt;br/&gt;  &lt;span&gt;`id`&lt;/span&gt; &lt;span&gt;bigint&lt;/span&gt;(&lt;span&gt;20&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; AUTO_INCREMENT,&lt;br/&gt;  &lt;span&gt;`name`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;45&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;`address`&lt;/span&gt; &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;45&lt;/span&gt;) &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;,&lt;br/&gt;  PRIMARY &lt;span&gt;KEY&lt;/span&gt; (&lt;span&gt;`id`&lt;/span&gt;),&lt;br/&gt;  &lt;span&gt;KEY&lt;/span&gt; &lt;span&gt;`idx_name`&lt;/span&gt; (&lt;span&gt;`name`&lt;/span&gt;)&lt;br/&gt;) &lt;span&gt;ENGINE&lt;/span&gt;=&lt;span&gt;InnoDB&lt;/span&gt; AUTO_INCREMENT=&lt;span&gt;4&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;CHARSET&lt;/span&gt;=utf8mb4&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样准备数据如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5906976744186047&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGLqKFUgVE94M67fYHgZiaYhSkNxNhXUM0We4I2d2AcH7ZaZvPYWecibUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;215&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;发起事务 A，执行如下语句，&lt;span&gt;且事务未提交&lt;/span&gt;：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.26247288503253796&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDG6mJETeXeV17aO8xWXUKW2TZXDbJNVHz3tANBzNclbuSzPSoNcfibTicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;461&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着发起事务 B，执行如下语句：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2708803611738149&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGBqvKmUmEgtlDb4gKmHqqMz2k1jtrf9x0vk8tjdsxJXgSxEWDnBWvDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;443&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，不会被阻塞，丝滑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个结果符合认知，因为此时 name 已经有索引了，在读提交级别下，只会在 name 索引上加相关记录的锁，而不会加全表行锁，因此事务 A、B 之间不会被阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时再起一个事务 C，执行如下语句：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1228813559322034&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGQgSAP6hZs8bBIm06cCGcCoicvib0YctVaLlLia50FBbK5maj0Ou72abWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;472&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，发生了阻塞，此时查看锁信息：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.13498312710911137&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGzt5s15jTGOP2hKBiauyGDaJARbttSN8ZCZBkDRU5sibn6402Sk58ypyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;889&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，&lt;span&gt;锁的索引确实变成了 idx_name，lock_data 显示锁的是 yes 这个记录，id 为 1&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从结果看：&lt;span&gt;在可以命中二级索引的情况下，锁的是对应的二级索引&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们继续做实验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;将上面所有事务提交之后&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动事务 C 执行以下语句，且未提交事务：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24285714285714285&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGtUXlDzSIT0uG8XCmic9Xsxic3feEp8c4zNfmunQYX1jIMFo6kabSprJQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;490&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着，事务 D 执行以下语句：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.0631911532385466&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGic9dZOmr0ENMGgHvbCRZHaA8yicsbeGOibGX4xUZDQ43ZJA4Tf2FnMAkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;633&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;并不会发生阻塞，丝滑地插入了数据。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.10721649484536082&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGhgWXRAWcmibDslF9p1ibpTvzMWDcldhCAXoFBNzRQGuPIia1nlz98Zh1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;485&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行 name 一样的插入，也不会阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以在读提交级别下，对插入都不会产生阻塞。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于 update 我就不实验了，和实验一的差别就是加锁索引换成了 name 的索引，其他表现一致。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;实验四：隔离级别为可重复读，锁定索引列的实验&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样准备数据如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5906976744186047&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGLqKFUgVE94M67fYHgZiaYhSkNxNhXUM0We4I2d2AcH7ZaZvPYWecibUw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;215&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在可重复读级别下，事务A执行：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24843423799582465&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDG7T8dODLiaDRLEsL3XaPlIGJkZC21aN4HYGoIkFcypllVwuj0SbDQDvw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;479&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着，事务 B 执行：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.09193548387096774&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGDKmhAgcfAmnKv8yWksiaAxZ6vejXSqXCI6KnjegRCb8P6sKHPsdHtxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;620&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时发生了阻塞，查看锁信息：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.11835506519558676&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGbicsryf8bgElIicyKMJYMhIfbHUkOpCicuricMtyqkzgGjexYhVK9RlbWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;997&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是预期之内的阻塞，因为按照 name 为索引，yes这条记录是排在最后的(字母序)，为了防止幻读，可重读隔离级别下会在对应记录前后加入间隙锁，而新的记录的插入恰巧需要排 yes 这条记录的后面。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5927189988623436&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGFjw9hRSFLwD2xhZJgTictxqhRUhbYcGJRic2FB9vmHyyPGpGrkK8LfyQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;879&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是从截图结果来看此时lock_mode是记录锁，且 lock_data 是 supremum，这又涉及到我的盲区了，难道是最后的记录插入比较特殊？所以不是因为间隙锁被阻塞，而是被最大记录行锁阻塞？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时把事务A、B都提交了 ，然后我们再执行事务 C：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24193548387096775&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGdnxreuMVX0bEay9hsP14WPKUrr2Eicn0uMkO5gTm2ELuOfkVuibBynMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;496&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接着再执行事务 D：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.08223684210526316&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGNpCicFk7881p6la6th4pVz3Tk05QYxSP1AqmDvXKYW2XO7ZNht5oZZQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;608&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时的插入不会被阻塞，因为事务 C 锁的是记录 yes 左右的间隙和 yes 本身，而&lt;span&gt;事务B提交了&lt;/span&gt;，因此事务D插入的不是被锁定的位置。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5043227665706052&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDG7dI5mxx4DRGtZOCdiciaCC4z5JW3chZFn8ibYnm7zTdJYWejPfLl3yO4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1041&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果此时事务 C 接着再执行：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.07415254237288135&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGxeV5iaZ4DEwe6EWYIia1aldnPtEibJddFuZh2UiaR67l3UwXuIZyrYQPSA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;472&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;则会被阻塞，我们看下锁的信息：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.10861423220973783&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nF1ibJ88LlfyVRfCib57XiaWDGiaib9lXymCh75nfzsHE8Q53wbwo4DSWWZpwew3vsxKKEjZmLNdXS3EsQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1068&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，此时被阻塞的锁是记录锁+间隙锁（next-key lock），这符合我们的认知和上面的图，因为要插入的数据在 yes 和公众号：yes的练级攻略之间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;update我就不实验了，不是全表扫描，只会根据索引加锁扫描到的记录。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在命中索引列的前提下，&lt;span&gt;只会在索引列上加锁&lt;/span&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果此时在&lt;span&gt;读已提交级别&lt;/span&gt;下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;select..for update和update&lt;/code&gt;的所查找的记录本身会被加上记录锁，因此这个位置的插入会被阻塞，其他位置的插入则没有影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果此时在&lt;span&gt;可重复读级别&lt;/span&gt;下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;select..for update和update&lt;/code&gt;的所查找的记录在索引位置前后会被加间隙锁，记录本身加记录锁，因此这些位置的插入会被阻塞，其他位置的插入则没有影响。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;最后&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分了四个实验大类，一个做了十三个实验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是挺有收获的，惊喜就是发现了细节盲区，之后研究一下再出一篇文章。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从实验来看，这里再做个概念性的总结：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;锁是作用在索引上的，因此如果能命中二级索引就在二级索引上加锁，不然就得&lt;span&gt;被迫&lt;/span&gt;在聚簇索引上加锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;被迫&lt;/span&gt;在聚簇索引上加锁，会导致全表扫描式的加锁。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;在可重复读下，不论命中哪个索引，不论是select..for update还是update，只要被扫描到的记录，都会被加锁，不论是否符合条件&lt;/span&gt;，在事务提交之后才会释放。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在读提交下，select..for update表现出来的结果是扫描到的记录先加锁，再判断条件，不符合就立马释放，不需要等到事务提交，而 update 的扫描是先判断是否符合条件，符合了才上锁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;声明：以上实验是基于 MySQL 5.7.26 版本，存储引擎为 InnoDB 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些实验我之前花了三个工作日晚上做的，由于时间是零散的，导致中间实验出错，&lt;span&gt;期间设置事务隔离级别语句有问题，导致我在错误的前提下做实验，实验结果不断地冲击我的认知&lt;/span&gt;，我整个人都快搞崩溃了....&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后周六花了一天的时间重新理了一下，&lt;span&gt;实验图很多，可能看了后面就忘了前面，建议结合着结论来回看，这样对结论会有更深刻的认识&lt;/span&gt;，但是有些实验结论我是根据实验现象来推断的，我没有去找相关的官网说明，如有错误，恳请指正，如有疑惑还请自行实验，可以在评论区交流一番。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;推荐阅读&lt;/strong&gt;：&lt;/p&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkxNTE3NjQ3MA==&amp;amp;mid=2247490736&amp;amp;idx=1&amp;amp;sn=a366e049fdda871ef149fe5aa0a201a3&amp;amp;chksm=c16271c9f615f8df5da9df31db885aefcfd2742384da8fb1e0267bfc63dcc6ec1913520ce15f&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;这波中间件特意的优化，无用？？？&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkxNTE3NjQ3MA==&amp;amp;mid=2247490692&amp;amp;idx=1&amp;amp;sn=aeebde78c3f0c55ef6c737ab3a99d194&amp;amp;chksm=c16271fdf615f8ebd5a298ad8d72ad502b0089f733f6619fabb9ab2b4c8d55df0c4b78a06cc1&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;Math.abs 竟然返回了负数？？&lt;/a&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkxNTE3NjQ3MA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/eSdk75TK4nEf5LN3Y4UErfNUkiaMseJPkdXA4xPD6Uicl8EqAJAEKVIKalU19xS41TO3aPmHK5bqbzGTwu3z92Kg/0?wx_fmt=png&quot; data-nickname=&quot;yes的练级攻略&quot; data-alias=&quot;yes_java&quot; data-signature=&quot;用接地气的话来分享一些后端技术或写一些想写的。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是yes，从一点点到亿点点，我们下篇见~&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>22429bb9f0fc5ebf4f5c09457e723904</guid>
<title>CodeReview 的本质分析</title>
<link>https://toutiao.io/k/crunecb</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;背景&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;代码评审（CodeReview，简称CR）作为很多研发团队的标准化部分被广泛使用。听到有很多工程师在代码评审时有这样一些疑问：&lt;/p&gt;&lt;p&gt;1、代码评审要达到哪些目标？&lt;/p&gt;&lt;p&gt;2、哪些方面是我应该评审的？哪些不是？&lt;/p&gt;&lt;p&gt;3、别人有没有认真的评审我的代码？如何让别人评审代码更容易？&lt;/p&gt;&lt;p&gt;今天咱们一起使用3W方法来透过问题看本质。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;What&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;先来看看两个看似不相关的概念：什么是CI和CD。&lt;/p&gt;&lt;p&gt;Continuous Integration：持续集成，简称CI，是软件开发周期的一种实践，把代码仓库（Gitlab或者Github）、构建工具（如Jenkins）和测试工具（SonarQube）集成在一起，频繁的将代码合并到主干然后自动进行构建和测试。简单来说就是代码编写到提交到主干的过程。&lt;/p&gt;&lt;p&gt;Continuous Delivery：持续交付，简称CD，是在CI的基础进行了扩展，在CI环节完成了软件构建和测试工作并形成了新的版本，那么接下来就要进行交付，而这里的交付并不是交付到生产环境，而是类生产环境（STAGING），我们可以理解为灰度环境或者预发环境，进而接受部分真实流量的测试。简单来说就是主干上的代码到生产发布中间的自动化检查部分。&lt;/p&gt;&lt;p&gt;CD还有另外一个名字：Continuous Deployment：持续部署，它是在持续交付的基础上打通最后一公里的工作，就是把手动部署到生产环境的方式升级为自动部署。谷歌的一些开源代码就是采用这种方式部署的，第一次自己的代码被采纳的时候，对他们的自动化能力还是挺震撼的。&lt;/p&gt;&lt;p&gt;咱们先来说CI的意义价值(以下为我同事的总结，内容是借的)：&lt;/p&gt;&lt;p&gt;1&amp;gt; “快速失败”，在对产品进行自动化验证，并快速响应&lt;/p&gt;&lt;p&gt;2&amp;gt;减少风险，降低成本&lt;/p&gt;&lt;p&gt;3&amp;gt;将重复性的手工流程自动化，让工程师更加专注于代码&lt;/p&gt;&lt;p&gt;4&amp;gt;提高项目的能见度，方便团队成员了解项目的进度和成熟度&lt;/p&gt;&lt;p&gt;5&amp;gt;增强开发人员对软件产品的信心，帮助建立更好的工程师文化&lt;/p&gt;&lt;p&gt;CodeReview是CI的一个环节。自然要以CI的意义价值作为目标。控制的方法是设置一个卡点，只有评审通过的代码才能合并到主干还是分支上(取决于使用的是基于主干开发还是分支开发)。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Why&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;CI的原则是尽量使用自动化，CodeReview则是强烈需要人工介入的部分。为什么这么做呢？&lt;/p&gt;&lt;p&gt;1&amp;gt;避免设计理解偏差&lt;/p&gt;&lt;p&gt;经常有这种体会：自己作为设计者觉得已经将方案给开发人员传达的很明白了。并且开发人员自己也说明白了。但是让开发人员来复述，却多少会发现和自己想的不同。&lt;/p&gt;&lt;p&gt;下面密密麻麻的都是我为了一个总代码不算单测不超过500行的小优化做的，从整体到部分，自己觉得用活动图几乎覆盖了每一行代码：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.46808510638297873&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicFPQQW5JXfQVCIb9lGSSj58m0W3LUEWicplVNEAAO5KqQXwKgRQLhTIFMgciaPOgT7JfHqrpxwrYlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1598&quot;/&gt;&lt;/p&gt;&lt;p&gt;连最简单的接口，源码几乎可以照抄旁边的的Service接口，还有下面的活动图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8138424821002387&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicFPQQW5JXfQVCIb9lGSSj59ib3jPBuiankbRdSnrWIpYO6MIDcdcibia9vRR7v3bl2hib2Wo4POrrNjwA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;838&quot;/&gt;&lt;/p&gt;&lt;p&gt;也很有可能最终看到代码和自己想的不一致。而且实际中概率很高。完美的诠释了帕累托图的本意：二八原则。80%的都不一致。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.6090014064697609&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/2tk5ianItRlicFPQQW5JXfQVCIb9lGSSj5tVIVXhOBdGKGoYqicsricCGCkFlExjU75BEvZ7SibTtYjG3Pv7jj2sJdw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;711&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;2&amp;gt;知识传播&lt;/p&gt;&lt;p&gt;发现不一致，code review中间沟通，探讨的过程是相互学习的过程。我非常喜欢这一过程。但是鉴于每到code review，我的表情都非常凝重。好吧，看起来不只是凝重，所以估计被我review的同学看不出来我是欢喜的。&lt;/p&gt;&lt;p&gt;、&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.1508333333333334&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRlicFPQQW5JXfQVCIb9lGSSj5w41GQjlmReWicFfLC1D0Ro12sUsiavic5cmoFKNia2bZxMIkm7AWYQ3dfQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1200&quot;/&gt;&lt;/p&gt;&lt;p&gt;3&amp;gt;检查逻辑正确性&lt;/p&gt;&lt;p&gt;一旦线上出了问题，后悔、不甘……付出的代价和对应的精力不只是十几倍的差别。线上出现小问题，我一般反而特别急于下班，能早回就早回了。不是逃避，而是在哪里脑子都在思考、反思。不如回家躺床上思考精力更集中一些。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;How&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;1&amp;gt;找对人&lt;/p&gt;&lt;p&gt;结对编程这个名词流行好多年了。但是现代对代码质量要求、线上稳定性要求都很高的这几年，优势才慢慢体现出来。因为结对编程，这两个人对代码逻辑都是了解的。找个不了解的人做code review，要不就发现不了问题。发现了也多半是技术性或者风格性的问题。而真正重要的逻辑问题往往发现不了。&lt;/p&gt;&lt;p&gt;这里提示一点哈，不知道会不会有同学对结对编程还停留在一个人写代码，另外一个人要在旁边盯着这个层面。设计、代码都是双方一起交流沟通过，评审过的就可以啦！&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7710843373493976&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/2tk5ianItRl9sAibpJswicjq0v6FDo8fRsCicIu0XyibN7hU3YlY2HkyhcbDLQABGcIQTot12LkqFGUWIT21OWOYsIA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;996&quot;/&gt;&lt;/p&gt;&lt;p&gt;2&amp;gt;用对法&lt;/p&gt;&lt;p&gt;code review的同学一定要有checklist，避免遗漏重要检查点。下面是我整理的checklist：&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;注意文件是否有因为测试而进行的注释&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;注意单测覆盖率是否增加或者持平&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;是否缺少必要的注释&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用velocity模板：vm、xml和properties三者需要同时修改&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;一次代码提交不允许提交多个功能，单个功能可拆分成多个子功能分别提交&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;修改范围必须是本次功能涉及的范围，其他不允许修改，哪怕删除一个空行&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;除非新类或者类的所有功能全部进行了修改，否则不允许整个类全局format&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;所有的代码修改必须有单测，如果原来没有覆盖到这个分支或者对修改没有相应的断言必须补充，哪怕修改的是日志打印。日志打印可通过将打印日志加到单测类注释中手动对比实现，注释必须提交&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;façade的POJO必须序列化&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;3&amp;gt;讲原则&lt;/p&gt;&lt;p&gt;上面checklist中很多内容比如先和其他人约定好。比如：一次代码提交不允许提交多个功能，单个功能可拆分成多个子功能分别提交。约定好的就只能照做。否则别人写完再提出来，code review和被review的同学都不舒服。情绪控制不好，反而容易写出糟糕的代码或者犯错。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;往期推荐&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>719a3505cb57e4d5847322499095a467</guid>
<title>手写 HashMap，快手面试官直呼内行</title>
<link>https://toutiao.io/k/421o1co</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;手写HashMap？这么狠，面试都卷到这种程度了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一次见到这个面试题，是在某个不方便透露姓名的Offer收割机大佬的文章：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.47115384615384615&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfMic105bWtNmv1mruXzt0pYvRWpibzfYmZd4L4xabKusKiaVuKLq0CZe2x32GQt0Apw6rM9YpzPj7hQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;728&quot;/&gt;&lt;figcaption&gt;手写HashMap,快手一面卒&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这……我当时就麻了，我们都知道HashMap的数据结构是数组+链表+红黑树，这是要手撕红黑树的节奏吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后来，整理了一些面经，发现这道题在快手的面试出现还比较频繁，分析这道题应该在快手的面试题库。那既然频繁出，肯定不能是手撕红黑树——我觉得面试官也多半撕不出来，不撕红黑树，那这道题还有点救，慢慢往下看。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;认识哈希表&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HashMap其实是数据结构中的哈希表在Java里的实现。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;哈希表本质&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哈希表也叫散列表，我们先来看看哈希表的定义：&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;哈希表是根据关键码的值而直接进行访问的数据结构。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就像有人到公司找老三，前台小姐姐拿手一指，那个墙角的工位就是。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单说来说，哈希表由两个要素构成：&lt;code&gt;桶数组&lt;/code&gt;和&lt;code&gt;散列函数&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;桶数组&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可能知道，有一类基础的数据结构&lt;code&gt;线性表&lt;/code&gt;，而线性表又分两种，&lt;code&gt;数组&lt;/code&gt;和&lt;code&gt;链表&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哈希表数据结构里，存储元素的数据结构就是数组，数组里的每个单元都可以想象成一个&lt;code&gt;桶&lt;/code&gt;（Bucket）。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假如给若干个程序员分配工位：&lt;code&gt;蛋蛋&lt;/code&gt;、&lt;code&gt;熊大&lt;/code&gt;、&lt;code&gt;牛儿&lt;/code&gt;、&lt;code&gt;张三&lt;/code&gt;，我们观察到，这些名字比较有特色，最后一个字都是数字，我们可以把它提取出来作为&lt;code&gt;关键码&lt;/code&gt;，这些一来，就可以把他们分配到对应编号的工位，没分配到的工位就让它先空着。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.133056133056133&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfMic105bWtNmv1mruXzt0pY3wGCHTGotkOaJtxibhpMQicQeFSdWEFOGrZ19vta5L1zuFTXyn2pO9Jw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;481&quot;/&gt;&lt;figcaption&gt;元素映射&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么在这种情况下，我们查找/插入/删除的时间复杂度是多少呢？很明显，都是&lt;code&gt;O(1)&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但咱们也不是葫芦娃，名字不能都叫一二三四五六七之类的，假如来的新人叫&lt;code&gt;南宫大牛&lt;/code&gt;，那我们怎么分配他呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就引入了我们的第二个关键要素——&lt;code&gt;散列函数&lt;/code&gt;。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;散列函数&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要在元素和&lt;code&gt;桶数组&lt;/code&gt;对应位置建立一种映射映射关系，这种映射关系就是&lt;code&gt;散列函数&lt;/code&gt;，也可以叫哈希函数。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例如，我们一堆无规律的名字&lt;code&gt;诸葛钢铁&lt;/code&gt;、&lt;code&gt;刘华强&lt;/code&gt;、&lt;code&gt;王司徒&lt;/code&gt;、&lt;code&gt;张全蛋&lt;/code&gt;……我们就需要通过散列函数，算出这些名字应该分配到哪一号工位。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.956989247311828&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfMic105bWtNmv1mruXzt0pYMouUSe7hkWAVZk4fdEmrNkeof0c6Ufvk4kcIwIKCVO478a7H0CngLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;651&quot;/&gt;&lt;figcaption&gt;散列函数&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;散列函数构造&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;散列函数也叫&lt;code&gt;哈希函数&lt;/code&gt;，假如我们数据元素的&lt;code&gt;key&lt;/code&gt;是整数或者可以转换为一个整数，可以通过这些常见方法来获取映射地址。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;直接定址法&lt;/p&gt;&lt;p&gt;直接根据&lt;code&gt;key&lt;/code&gt;来映射到对应的数组位置，例如1232放到下标1232的位置。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;数字分析法&lt;/p&gt;&lt;p&gt;取&lt;code&gt;key&lt;/code&gt;的某些数字（例如十位和百位）作为映射的位置&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;平方取中法&lt;/p&gt;&lt;p&gt;取&lt;code&gt;key&lt;/code&gt;平方的中间几位作为映射的位置&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;折叠法&lt;/p&gt;&lt;p&gt;将&lt;code&gt;key&lt;/code&gt;分割成位数相同的几段，然后把它们的叠加和作为映射的位置&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;除留余数法&lt;/p&gt;&lt;p&gt;H（key)=key%p（p&amp;lt;=N）,关键字除以一个不大于哈希表长度的正整数p，所得余数为哈希地址，&lt;strong&gt;这是应用最广泛的散列函数构造方法&lt;/strong&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.4551863041289023&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfMic105bWtNmv1mruXzt0pY1mficQS8dzpOUk7icuzL2FAsBibs2TDSkpxrKHVuib0LZQHZjusYjbicqtQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;993&quot;/&gt;&lt;figcaption&gt;散列函数构造&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java里，Object类里提供了一个默认的hashCode()方法，它返回的是一个32位int形整数，其实也就是对象在内存里的存储地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，这个整数肯定是要经过处理的，上面几种方法里&lt;code&gt;直接定址法&lt;/code&gt;可以排除，因为我们不可能建那么大的桶数组。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而且我们最后计算出来的散列地址，尽可能要在桶数组长度范围之内，所以我们选择&lt;code&gt;除留取余法&lt;/code&gt;。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;哈希冲突&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理想的情况，是每个数据元素经过哈希函数的计算，落在它独属的桶数组的位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是现实通常不如人意，我们的空间是有限的，设计再好的哈希函数也不能完全避免哈希冲突。所谓的哈希冲突，就是不同的key经过哈希函数计算，落到了同一个下标。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.48056537102473496&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfMic105bWtNmv1mruXzt0pY9KcMRVryqZuQ9N7toicHSDibSyyeQfHA4NAruMHX9u55RFW5yzugvSXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1132&quot;/&gt;&lt;figcaption&gt;哈希冲突&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;既然有了冲突，就得想办法解决冲突，常见的解决哈希冲突的办法有：&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;链地址法&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也叫拉链法，看起来，像在桶数组上再拉一个链表出来，把发生哈希冲突的元素放到一个链表里，查找的时候，从前往后遍历链表，找到对应的&lt;code&gt;key&lt;/code&gt;就行了。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7430555555555556&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfMic105bWtNmv1mruXzt0pYIzfSpREs9icE27RETqTcicbjkOTFY031YJBCj95yKicjKAeaYicER3713g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;figcaption&gt;链地址法&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;开放地址法&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;开放地址法，简单来说就是给冲突的元素再在桶数组里找到一个空闲的位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;找到空闲位置的方法有很多种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线行探查法: 从冲突的位置开始，依次判断下一个位置是否空闲，直至找到空闲位置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;平方探查法:  从冲突的位置x开始，第一次增加&lt;code&gt;1^2&lt;/code&gt;个位置，第二次增加&lt;code&gt;2^2&lt;/code&gt;...，直至找到空闲的位置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;双散列函数探查法&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;……&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.7891566265060241&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfMic105bWtNmv1mruXzt0pYib5biabG2wqsrSO34vs2LHnVkLFMExibF0Hcx30e1Un5q5riadBQTI9XkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;830&quot;/&gt;&lt;figcaption&gt;开放地址法&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;再哈希法&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构造多个哈希函数，发生冲突时，更换哈希函数，直至找到空闲位置。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;建立公共溢出区&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;建立公共溢出区，把发生冲突的数据元素存储到公共溢出区。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很明显，接下来我们解决冲突，会使用&lt;strong&gt;链地址法&lt;/strong&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，哈希表的介绍就到这，相信你已经对哈希表的本质有了深刻的理解，接下来，进入coding时间。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;HashMap实现&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们实现的简单的HashMap命名为&lt;code&gt;ThirdHashMap&lt;/code&gt;，先确定整体的设计：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;散列函数：hashCode()+除留余数法&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;冲突解决：链地址法&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;整体结构如下：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.3393829401088929&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfMic105bWtNmv1mruXzt0pYoBViaWA1fvHvEG8dMHuRfylz08p1saMd61ZWyYzDfk9krDyj2dmyPJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1102&quot;/&gt;&lt;figcaption&gt;自定义HashMap整体结构&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;内部节点类&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要定义一个节点来作为具体数据的载体，它不仅要承载键值对，同样还得作为单链表的节点：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;/**&lt;br/&gt;     * 节点类&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; &amp;lt;K&amp;gt;&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; &amp;lt;V&amp;gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&amp;lt;&lt;span&gt;K&lt;/span&gt;, &lt;span&gt;V&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//键值对&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; K key;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; V value;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;//链表，后继&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;private&lt;/span&gt; Node&amp;lt;K, V&amp;gt; next;&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;(K key, V value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.key = key;&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.value = value;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;Node&lt;/span&gt;&lt;span&gt;(K key, V value, Node&amp;lt;K, V&amp;gt; next)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.key = key;&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.value = value;&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.next = next;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;成员变量&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要有四个成员变量，其中桶数组作为装载数据元素的结构：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;//默认容量&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; DEFAULT_CAPACITY = &lt;span&gt;16&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;//负载因子&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;final&lt;/span&gt; &lt;span&gt;float&lt;/span&gt; LOAD_FACTOR = &lt;span&gt;0.75f&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;//HashMap的大小&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size;&lt;br/&gt;    &lt;span&gt;//桶数组&lt;/span&gt;&lt;br/&gt;    Node&amp;lt;K, V&amp;gt;[] buckets;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;构造方法&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;构造方法有两个，无参构造方法，桶数组默认容量，有参指定桶数组容量。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;/**&lt;br/&gt;     * 无参构造器，设置桶数组默认容量&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ThirdHashMap&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        buckets = &lt;span&gt;new&lt;/span&gt; Node[DEFAULT_CAPACITY];&lt;br/&gt;        size = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 有参构造器，指定桶数组容量&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; capacity&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ThirdHashMap&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; capacity)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        buckets = &lt;span&gt;new&lt;/span&gt; Node[capacity];&lt;br/&gt;        size = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;散列函数&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;散列函数，就是我们前面说的hashCode()和数组长度取余。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;/**&lt;br/&gt;     * 哈希函数，获取地址&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; key&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getIndex&lt;/span&gt;&lt;span&gt;(K key, &lt;span&gt;int&lt;/span&gt; length)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//获取hash code&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; hashCode = key.hashCode();&lt;br/&gt;        &lt;span&gt;//和桶数组长度取余&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; index = hashCode % length;&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Math.abs(index);&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;put方法&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我用了一个putval方法来完成实际的逻辑，这是因为扩容也会用到这个方法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大概的逻辑：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;获取元素插入位置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当前位置为空，直接插入&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;位置不为空，发生冲突，遍历链表&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果元素key和节点相同，覆盖，否则新建节点插入链表头部&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;/**&lt;br/&gt;     * put方法&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; key&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; value&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;put&lt;/span&gt;&lt;span&gt;(K key, V value)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//判断是否需要进行扩容&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (size &amp;gt;= buckets.length * LOAD_FACTOR) resize();&lt;br/&gt;        putVal(key, value, buckets);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 将元素存入指定的node数组&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; key&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; value&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; table&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;putVal&lt;/span&gt;&lt;span&gt;(K key, V value, Node&amp;lt;K, V&amp;gt;[] table)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//获取位置&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; index = getIndex(key, table.length);&lt;br/&gt;        Node node = table[index];&lt;br/&gt;        &lt;span&gt;//插入的位置为空&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (node == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            table[index] = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(key, value);&lt;br/&gt;            size++;&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//插入位置不为空，说明发生冲突，使用链地址法,遍历链表&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (node != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;//如果key相同，就覆盖掉&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((node.key.hashCode() == key.hashCode())&lt;br/&gt;                    &amp;amp;&amp;amp; (node.key == key || node.key.equals(key))) {&lt;br/&gt;                node.value = value;&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            node = node.next;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//当前key不在链表中，插入链表头部&lt;/span&gt;&lt;br/&gt;        Node newNode = &lt;span&gt;new&lt;/span&gt; Node(key, value, table[index]);&lt;br/&gt;        table[index] = newNode;&lt;br/&gt;        size++;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;扩容方法&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;扩容的大概过程：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;创建两倍容量的新数组&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;将当前桶数组的元素重新散列到新的数组&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;新数组置为map的桶数组&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;/**&lt;br/&gt;     * 扩容&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;resize&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//创建一个两倍容量的桶数组&lt;/span&gt;&lt;br/&gt;        Node&amp;lt;K, V&amp;gt;[] newBuckets = &lt;span&gt;new&lt;/span&gt; Node[buckets.length * &lt;span&gt;2&lt;/span&gt;];&lt;br/&gt;        &lt;span&gt;//将当前元素重新散列到新的桶数组&lt;/span&gt;&lt;br/&gt;        rehash(newBuckets);&lt;br/&gt;        buckets = newBuckets;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 重新散列当前元素&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; newBuckets&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;rehash&lt;/span&gt;&lt;span&gt;(Node&amp;lt;K, V&amp;gt;[] newBuckets)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//map大小重新计算&lt;/span&gt;&lt;br/&gt;        size = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;//将旧的桶数组的元素全部刷到新的桶数组里&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; buckets.length; i++) {&lt;br/&gt;            &lt;span&gt;//为空，跳过&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (buckets[i] == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;continue&lt;/span&gt;;&lt;br/&gt;            }&lt;br/&gt;            Node&amp;lt;K, V&amp;gt; node = buckets[i];&lt;br/&gt;            &lt;span&gt;while&lt;/span&gt; (node != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;//将元素放入新数组&lt;/span&gt;&lt;br/&gt;                putVal(node.key, node.value, newBuckets);&lt;br/&gt;                node = node.next;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;get方法&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;get方法就比较简单，通过散列函数获取地址，这里我省去了有没有成链表的判断，直接查找链表。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;/**&lt;br/&gt;     * 获取元素&lt;br/&gt;     *&lt;br/&gt;     * &lt;span&gt;@param&lt;/span&gt; key&lt;br/&gt;     * &lt;span&gt;@return&lt;/span&gt;&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; V &lt;span&gt;get&lt;/span&gt;&lt;span&gt;(K key)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//获取key对应的地址&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; index = getIndex(key, buckets.length);&lt;br/&gt;        &lt;span&gt;if&lt;/span&gt; (buckets[index] == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;        Node&amp;lt;K, V&amp;gt; node = buckets[index];&lt;br/&gt;        &lt;span&gt;//查找链表&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;while&lt;/span&gt; (node != &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; ((node.key.hashCode() == key.hashCode())&lt;br/&gt;                    &amp;amp;&amp;amp; (node.key == key || node.key.equals(key))) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; node.value;&lt;br/&gt;            }&lt;br/&gt;            node = node.next;&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;完整代码：&lt;/strong&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;5.103496503496504&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWfMic105bWtNmv1mruXzt0pYoVlvBnZEckMjVfttQIgR8cMsUSsicwkcuGtc5JGtFsQZF9nhsa0wldA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1430&quot;/&gt;&lt;figcaption&gt;完整代码&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;测试&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;测试代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;    &lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;test0&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ThirdHashMap map = &lt;span&gt;new&lt;/span&gt; ThirdHashMap();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++) {&lt;br/&gt;            map.put(&lt;span&gt;&quot;刘华强&quot;&lt;/span&gt; + i, &lt;span&gt;&quot;你这瓜保熟吗？&quot;&lt;/span&gt; + i);&lt;br/&gt;        }&lt;br/&gt;        System.out.println(map.size());&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;100&lt;/span&gt;; i++) {&lt;br/&gt;            System.out.println(map.get(&lt;span&gt;&quot;刘华强&quot;&lt;/span&gt; + i));&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Test&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;void&lt;/span&gt; &lt;span&gt;test1&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;        ThirdHashMap map = &lt;span&gt;new&lt;/span&gt; ThirdHashMap();&lt;br/&gt;        map.put(&lt;span&gt;&quot;刘华强1&quot;&lt;/span&gt;,&lt;span&gt;&quot;哥们，你这瓜保熟吗？&quot;&lt;/span&gt;);&lt;br/&gt;        map.put(&lt;span&gt;&quot;刘华强1&quot;&lt;/span&gt;,&lt;span&gt;&quot;你这瓜熟我肯定要啊！&quot;&lt;/span&gt;);&lt;br/&gt;        System.out.println(map.get(&lt;span&gt;&quot;刘华强1&quot;&lt;/span&gt;));&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家可以自行跑一下看看结果。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h1&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，到这，我们一个简单的HashMap就实现了，这下，面试快手再也不怕手写HashMap了。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;快手面试官：真的吗？我不信。我就要你手写个红黑树版的……&lt;/p&gt;&lt;/blockquote&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWfMic105bWtNmv1mruXzt0pYZPMhxO2UAqFnXBpOh1AtqpVVDiakFX4EeVpMXFictjiboxZlHvkbPqm9w/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然了，我们也发现，HashMap的O(1)时间复杂度操作是在冲突比较少的情况下，简单的哈希取余肯定不是最优的散列函数；冲突之后，链表拉的太长，同样影响性能；我们的扩容和put其实也存在线程安全的问题……&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是，现实里我们不用考虑那么多，因为李老爷已经帮我们写好了，我们只管调用就完了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下一篇，会以面试对线的形式来走进李老爷操刀的HashMap！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;点赞&lt;/strong&gt;&lt;/span&gt;、&lt;span&gt;&lt;strong&gt;关注&lt;/strong&gt;&lt;/span&gt;不迷路，咱们下期见！&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[1].《数据结构与算法》&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[2].构造哈希函数方法：(https://zhuanlan.zhihu.com/p/31441081)&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;[3].ACM金牌选手讲解LeetCode算法《哈希》：https://www.cnblogs.com/yizhibianchengxiong/p/15112210.html&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzkwODE5ODM0Ng==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWdFLJg0sAOqwHB1mb24icMADUgxm1qZQft5aN3H37NAmQnOvpGB7J9JVHxC6NSiacxbBP1DYdhIAeyA/0?wx_fmt=png&quot; data-nickname=&quot;三分恶&quot; data-alias=&quot;Fighter3FullStack&quot; data-signature=&quot;一个号称能文能武，技术水平和外形匹配的Java程序员。基础、实战、原理、面试，这里都有，关注我，我们一起进步！&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最近建了一个技术交流群，里面大厂大佬云集，技术、面试、生活聊的热火朝天，我还会不定期分享精品技术资料，添加微信&lt;/span&gt;&lt;span&gt;&lt;strong&gt;ThirdFighter&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;，拉你入群。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-backh=&quot;512&quot; data-backw=&quot;512&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWedCUuwibYJXwr9JSKric9UR2YKhNPVJaiaSUXhKh77gibClibfex2RqLNjh4MqtoLN7qFkczibvmrdvMng/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;512&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;推荐阅读：&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b3e482e9ae74daa94e8d0d5025e3477c</guid>
<title>加密的艺术</title>
<link>https://toutiao.io/k/bdlv3fu</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-hnrfcf&quot; options=&quot;[object Object]&quot;&gt;&lt;p data-pid=&quot;M_rebXY-&quot;&gt;加密算法最早诞生在什么时候？计算机出现之后吗？不，早在公元前 7 世纪，古希腊人就已经在使用加密算法了。他们使用一根叫 scytale 的棍子来传递加密信息，加密时先绕棍子卷一张纸条，把信息沿棒水平方向写，写一个字旋转一下，直到写完。解下来后，纸条上的文字消息杂乱无章，这就是密文。将它绕在另一个同等尺寸的棒子上后，就能看到原始的消息。如果不知道棍子的粗细，就无法解密里面的内容。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-008737be6815e40a2e6ce300f7b64b0a_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;293&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-008737be6815e40a2e6ce300f7b64b0a_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;293&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-008737be6815e40a2e6ce300f7b64b0a_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-008737be6815e40a2e6ce300f7b64b0a_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;KFMGgtGl&quot;&gt;加密方式发展到今天，相比 scytale 的简单原理已经有了无法想象的巨大发展，我们现在基于更复杂的数学过程，即更为复杂的算法来进行加密。许多使用现代手段创建的成熟密码系统基本被认为是不可破解的。一个不可被破解的加密方式到底有多复杂？下面我们就来领略一下。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;什么是加密？&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;yBr6352O&quot;&gt;我们通常所说的加密是指使用密钥将纯文本转换为难以理解的序列的方法，通常由两个基本部分构成：算法和密钥。&lt;/p&gt;&lt;p data-pid=&quot;P3yrzlrN&quot;&gt;算法是将普通的文本（或者可以理解的信息）与一串数字（密钥）的结合，产生不可理解的密文的步骤，密钥是用来对数据进行编码和解码的一种算法。加密可以描述为一种方法，通过该方法，明文和密钥通过密码算法，产生秘密文本。&lt;/p&gt;&lt;p data-pid=&quot;guvXCwhE&quot;&gt;在期望的情况下，加密文本的内容只有拥有对应密钥的用户才能访问。除了文本消息，现代加密还可以应用于其他电子传输信息，例如语音消息、图像文件或程序代码等。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-752ee7531ed2739855c7a47c3ee3daf2_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;269&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-752ee7531ed2739855c7a47c3ee3daf2_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;269&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-752ee7531ed2739855c7a47c3ee3daf2_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-752ee7531ed2739855c7a47c3ee3daf2_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;h2&gt;&lt;b&gt;加密方式分类&lt;/b&gt;&lt;/h2&gt;&lt;p data-pid=&quot;uUlsYbwF&quot;&gt;在现代，我们主要用到对称加密（私人密钥加密）和非对称加密（公开密钥加密）两种加密方式。&lt;/p&gt;&lt;p data-pid=&quot;oTn23J0p&quot;&gt;&lt;b&gt;对称加密方法&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;Fh_7aIYe&quot;&gt;对称加密起源于凯撒密码等古老的加密方法。其主要原理是文件加密和解密使用相同的密钥。如果两个通信方想要交换加密数据，则发送方和接收方都需要拥有相同密钥的副本，同时还需要找到一种秘密传输共享密钥的方法。为了保护加密信息不被第三方访问，密钥是保密的，密钥的长度也决定了该加密算法的安全性。&lt;/p&gt;&lt;p data-pid=&quot;N0gdtpPb&quot;&gt;对称加密算法使用起来简单快捷，密钥较短，且破译困难。众所周知的对称加密方法包括比较典型的数据加密标准（DES）及其高级加密标准（AES）。&lt;/p&gt;&lt;p data-pid=&quot;2DSpjRy2&quot;&gt;&lt;b&gt;数据加密标准（DES）&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;hAisiiBf&quot;&gt;DES 是一种对称加密方法，由 IBM 在 1970 年代开发，并于 1977 年由美国国家标准与技术研究院（NIST）标准化。按照当时的标准，DES 是一种安全的计算机辅助加密方法，是现代密码学的基础。密钥长 64 位，但实际上只有 56 位参与运算（第 8、16、24、32、40、48、56、64 位是校验位，使得每个密钥都有奇数个 1），在如今基本上已经过时了。当今的技术，使用蛮力攻击可以在短短几个小时内破解出 DES 密钥。&lt;/p&gt;&lt;p data-pid=&quot;ICm92K5r&quot;&gt;该算法由排列和替换组成，整个过程需要 16 轮，其原理结构图如下：&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a37cfddb1b0b721ed2b0e84bd1dcab8f_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;351&quot; data-rawheight=&quot;447&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;351&quot; data-rawheight=&quot;447&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic4.zhimg.com/v2-a37cfddb1b0b721ed2b0e84bd1dcab8f_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;BTCiFq2G&quot;&gt;首先是初始置换 ，64 位的块被分成 32 位的块；创建了左半块 L0 和右半块 R0。然后经过 16 轮相同的操作（此处为函数 f ）将数据与密钥组合。16 轮过后，左右两块重新组合，经过最后的置换，得到密文。DES 加密密文的解密遵循相同的方案，但顺序相反。&lt;/p&gt;&lt;p data-pid=&quot;gjcmNEdW&quot;&gt;DES 的主要缺点是 56 位的密钥长度相对较小，无法承受当今计算能力可用的蛮力攻击。DES 的一种变体是 Triple-DES ( 3DES ) ，其中加密方法在三个连续轮次中执行。但是 3DES 的有效密钥长度仍然只有 112 位，仍低于当今 128 位的最低标准。因此，DES 已在很大程度上被取代。AES（Advanced Encryption Standard） 算法接替了 DES，它也是一种对称加密方法。&lt;/p&gt;&lt;p data-pid=&quot;7Y4KKfut&quot;&gt;&lt;b&gt;高级加密标准（AES）&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;kRU5MVKM&quot;&gt;到了 90 年代，很明显最常用的加密标准 DES 已经落伍了，需要一个新的加密标准来替代。于是，AES 诞生了，由于其具有更高的安全性、灵活性，它也是美国联邦政府采用的一种区块加密标准。&lt;/p&gt;&lt;p data-pid=&quot;WwxxErUH&quot;&gt;AES 也是将加密后的明文分成块，所以与 DES 一样是基于块加密的。该标准支持 128、192 和 256 位密钥。但 AES 使用的不是 64 位的块，而是使用大很多的 128 位块，这些块在连续几轮中使用代换-置换网络（Substitution-Permutation Network，SPN）进行加密。加密过程大致分为四个步骤：&lt;/p&gt;&lt;p data-pid=&quot;D95rggD3&quot;&gt;&lt;b&gt;1、KeyExpansion 密钥扩展：&lt;/b&gt;AES 和 DES 一样，对每个加密循环使用一个新的轮密钥。在这个过程中，输出密钥的长度也被扩展，生成映射所需数量的 128 位轮密钥。每个轮密钥都基于扩展输出密钥的一部分。所需的轮密钥数等于轮数（R），包括关键轮，加上初始轮的轮密钥（密钥数 = R + 1）。&lt;/p&gt;&lt;p data-pid=&quot;UDzX7jUo&quot;&gt;&lt;b&gt;2、Initial round 初始轮：&lt;/b&gt;在初始轮中，将 128 位的输入块转移到二维表（Array）中，并使用按位异或 XOR（AddRoundKey）链接到第一轮密钥。该表由四行四列组成。每个单元包含要加密的块的一个字节（8 位）。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-93fa93ace8e5e0b17199d90428a125a1_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;398&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-93fa93ace8e5e0b17199d90428a125a1_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;398&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-93fa93ace8e5e0b17199d90428a125a1_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-93fa93ace8e5e0b17199d90428a125a1_b.jpg&quot;/&gt;&lt;figcaption&gt;在 AddRoundKey 中，将每个状态中的字节与该回合密钥做异或&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;ZHxpTQGL&quot;&gt;&lt;b&gt;3、加密轮数：&lt;/b&gt;加密轮数取决于使用的密钥长度：AES128 为 10 轮，AES192 为 12 轮，AES256 为 14 轮。每轮加密使用以下操作：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;r3gKJBZ9&quot;&gt;&lt;b&gt;SubBytes（字节替代）&lt;/b&gt; &lt;b&gt;:&lt;/b&gt; 一个非线性替换步骤，其中根据查找表将每个字节替换为另一个字节。&lt;/li&gt;&lt;li data-pid=&quot;MPRa_vXj&quot;&gt;&lt;b&gt;ShiftRows（行移位）：&lt;/b&gt;一个转置步骤，其中状态的最后三行循环移位一定数量的步骤。&lt;/li&gt;&lt;li data-pid=&quot;egC4ylo1&quot;&gt;&lt;b&gt;MixColumns（列混淆）：&lt;/b&gt;一种线性混合操作，它对状态的列进行操作，将每列中的四个字节组合在一起。&lt;/li&gt;&lt;li data-pid=&quot;ULzg693Q&quot;&gt;&lt;b&gt;AddRoundKey（轮密钥加）：&lt;/b&gt;在每轮加密结束时，发生另一个 AddRoundKey。就像初始轮一样，基于数据块与当前轮次密钥的异或链接。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;Yy02Zdnr&quot;&gt;&lt;b&gt;4. 密钥轮：&lt;/b&gt;密钥轮是最后的加密轮。与前几轮不同的是，它不包括 MixColumns 转换，因此只包括 SubBytes、ShiftRows 和 AddRoundKey 操作。最后一轮的结果得到密文。&lt;/p&gt;&lt;p data-pid=&quot;GmzHzMJy&quot;&gt;由于其本身的算法，AES 已通过了高水平的安全性认证。对于至少 128 位的密钥长度，蛮力攻击是很低效的。除此之外，AES 还用作 WPA2、SSH 和 IPSec 的加密标准。该算法还用于加密压缩文件存档，例如 7-Zip 或 RAR。&lt;/p&gt;&lt;p data-pid=&quot;A1JZJELY&quot;&gt;以上两种对称加密方法都是依托于对称加密的算法，而对称加密算法则分以下两大类：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;NHwxtVx2&quot;&gt;流密码：也叫序列密码，每次加密都通过密钥生成一个密钥流，解密也是使用同一个密钥流，明文与同样长度的密钥流进行异或运算得到密文，密文与同样的密钥流进行异或运算得到明文。&lt;/li&gt;&lt;li data-pid=&quot;Bj7sV4-m&quot;&gt;块密码：也叫分组密码，它把加密和解密序列分成了一个个分组，最后把每一块序列合并到一起，形成明文或者密文。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;PjYcCsMY&quot;&gt;&lt;b&gt;非对称加密方法&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;8Ixb1tZv&quot;&gt;相对于对称加密加密通信的双方需使用相同的密钥来说，非对称加密的通信双方会为每个页面都生成一个密钥对。通信中的每个参与者都有两把钥匙可供使用：一把公钥和一把私匙。为了能够加密信息，每一方都必须事先声明他们的公钥，这被称为公钥算法。这就是非对称密码系统的优势：与对称加密方法相反，密钥永远不会离开其所有者的视线。&lt;/p&gt;&lt;p data-pid=&quot;cj8jr9pJ&quot;&gt;下面我们通过一个简单例子来了解非对称加密。。假设用户 A 想向用户 B 发送一条加密消息，为此 A 需要 B 的公钥，而 B 的公钥允许 A 加密只有 B 的私钥才能解密的消息。这样除了 B，就在没有其他人没有人能够阅读该消息，包括 A 也无法解密。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-3d47535018b422ef5108fa122a017834_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;270&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-3d47535018b422ef5108fa122a017834_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;270&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-3d47535018b422ef5108fa122a017834_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-3d47535018b422ef5108fa122a017834_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;f98u9rHX&quot;&gt;这么做的优点是任何人都可以使用用户 B 的公钥加密消息，然后只能 B 的密钥解密。由于仅交换公钥，因此无需创建防篡改的安全通道，因为能解密的只有 B。&lt;/p&gt;&lt;p data-pid=&quot;jdfc2rWx&quot;&gt;非对称加密最通用的加密算法是 Rivest、Shamir、Adleman （RSA）和 ECC。&lt;/p&gt;&lt;p data-pid=&quot;khPyojlJ&quot;&gt;&lt;b&gt;Rivest、Shamir、Adleman （RSA）&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;NdPYSutO&quot;&gt;1977 年，数学家 Rivest、Shamir 和 Adleman 提出了一种非对称加密算法，并以发明人的名字命名 —— RSA。RSA 是目前普遍认为最安全、最优秀的公钥方法之一。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-f249b9f798d8785d129374490985bec5_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;341&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-f249b9f798d8785d129374490985bec5_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;341&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-f249b9f798d8785d129374490985bec5_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-f249b9f798d8785d129374490985bec5_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p data-pid=&quot;xOouo9O4&quot;&gt;RSA 使用一种基于大素数相乘的算法。如果将质数 14,629 和 30,491 相乘，可以得到结果为 446,052,839。这个数只有四个可能的除数：其中两个是 1 和它本身，另外两个是相乘前的原始素数。如果将前两个除数排除（因为每个数字都可以被 1 和它本身整除），那么将得到 14,629 和 30,491 的初始值。&lt;/p&gt;&lt;p data-pid=&quot;a5A10DoH&quot;&gt;以上就是 RSA 密钥生成的基础。公钥和私钥都代表两对数字：&lt;/p&gt;&lt;p data-pid=&quot;VpBI7iw9&quot;&gt;N  即两个随机选择的非常大素数 p 和 q 的乘积 N = pxq，以及计算 N 的欧拉函数 φ(N) = (p-1)(q-1)。&lt;/p&gt;&lt;p data-pid=&quot;JqlCQ4ME&quot;&gt;要生成公钥，则需要 e，e 是一个根据一些限制（条件是 1&amp;lt; e &amp;lt; φ(N)，且 e 与 φ(N) 互质）随机选择的数字。&lt;/p&gt;&lt;p data-pid=&quot;7tw63h-y&quot;&gt;要生成私钥，则需要计算 e 对于 φ(N) 的模反元素 d。所谓“模反元素”就是指有一个整数 d，可以使得 ed 被 φ(N) 除的余数为 1。满足 (ed) modφ(N) = 1  ，即 ed = kφ(N) +1，k≥1  是一个任意的整数；所以，若知道 e 和 φ(N) ，则很容易计算出 d。&lt;/p&gt;&lt;p data-pid=&quot;nQU6dPua&quot;&gt;然而只根据 N  和 e（注意：不是 p 和 q）要计算出 d 是不可能的。因此，任何人都可对明文进行加密，但是只有授权用户（知道 d）才可对密文解密。&lt;/p&gt;&lt;p data-pid=&quot;0JfCcnIv&quot;&gt;RSA 算法的保密强度随其密钥的长度增加而增强。但是，密钥越长，其加解密所耗用的时间也越长。因此，要根据所保护信息的敏感程度与攻击者破解所要花费的代价值不值得以及系统所要求的反应时间来综合考虑。&lt;/p&gt;&lt;p data-pid=&quot;BE055D8W&quot;&gt;目前互联网中最常用的 SSL/TLS 协议就是基于 RSA 算法。如果想要使用特定公钥加密的信息只能使用附属于该公匙的私钥进行解密。经客户端验证公钥可以与私钥进行匹配，才会建立安全连接。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-838c30242d9650a32a9fa0329f32ec39_b.jpg&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;238&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-838c30242d9650a32a9fa0329f32ec39_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;512&quot; data-rawheight=&quot;238&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-838c30242d9650a32a9fa0329f32ec39_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-838c30242d9650a32a9fa0329f32ec39_b.jpg&quot;/&gt;&lt;figcaption&gt; 一些主流 SSL 证书加密算法均为 RSA 算法&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-pid=&quot;NUUzcFWA&quot;&gt;&lt;b&gt;ECC&lt;/b&gt;&lt;/p&gt;&lt;p data-pid=&quot;NakkkFRF&quot;&gt;在上图中我们还可以看到非对称加密的另一种算法 ECC，即椭圆加密算法。其数学基础是利用椭圆曲线上的有理点构成 Abel 加法群上椭圆离散对数的计算困难性。ECC 的主要优势是在某些情况下比其他的方法（比如 RSA）使用更小的密钥，提供相当或更高等级的安全。&lt;/p&gt;&lt;p data-pid=&quot;YWV_mdOp&quot;&gt;回到非对称加密本身。这种加密算法除去“无需创建防篡改的安全通道”这一有点外，也有一个不可忽视的缺点：无法确认通信伙伴的身份。也就是说在非对称加密中，B 不能确定加密的消息确实来自 A，理论上第三个用户 C 可以使用 B 的公钥来加密并传递消息。此外，A 也不能确定公钥是否真的属于 B，公钥可能是由 C 创建并传达给 A 的，这样可以拦截 A 发给 B 的消息。&lt;/p&gt;&lt;p data-pid=&quot;Ymynd_Cy&quot;&gt;因此使用非对称加密，需要一种机制以便用户可以测试其通信伙伴的身份验证。&lt;/p&gt;&lt;p data-pid=&quot;XFSTbKQo&quot;&gt;目前我们使用数字证书和签名来解决这个问题：&lt;/p&gt;&lt;ul&gt;&lt;li data-pid=&quot;7naea1nR&quot;&gt;数字证书：为了确保非对称加密方法的安全，通信伙伴可以通过官方认证机构确认其公钥的真实性。例如，通过 HTTPS 的 TLS/SSL 加密数据传输。&lt;/li&gt;&lt;li data-pid=&quot;p9cA2yCL&quot;&gt;数字签名：虽然数字证书可用于验证公钥，但数字签名可用于识别加密消息的发送者。私钥用于生成签名，然后接收方使用发送方的公钥验证该签名。&lt;/li&gt;&lt;/ul&gt;&lt;p data-pid=&quot;GOldvJ4b&quot;&gt;以上就是我们目前主要用到的加密方式啦，但是加密方式不仅仅如此，随着互联网的不断发展，肯定会越来越复杂，尽管它们涉及了很多数学知识，了解起来非常枯燥，但是正是这些枯燥的数学让我们的信息越来越安全。&lt;/p&gt;&lt;p data-pid=&quot;MPpI0FL4&quot;&gt;&lt;b&gt;推荐阅读：&lt;/b&gt;&lt;/p&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/660/%25E5%2585%25A8%25E7%25AB%2599%2520HTTPS%2520%25E5%25B0%25B1%25E4%25B8%2580%25E5%25AE%259A%25E5%25AE%2589%25E5%2585%25A8%25E4%25BA%2586%25E5%2590%2597%25EF%25BC%259F.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic4.zhimg.com/v2-1be0aea561d44f47592c3fa761603057_180x120.jpg&quot; data-image-width=&quot;669&quot; data-image-height=&quot;352&quot; data-text=&quot;全站 HTTPS 就一定安全了吗？&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;a target=&quot;_blank&quot; href=&quot;https://link.zhihu.com/?target=https%3A//www.upyun.com/tech/article/601/%25E7%25BD%2591%25E9%25AA%2597%25E6%25AC%25BA%25E8%25AF%2588%25EF%25BC%259F%25E7%25BD%2591%25E7%25BB%259C%25E8%25A3%25B8%25E5%25A5%2594%25EF%25BC%259F%25E9%2583%25BD%25E6%2598%25AF%25E5%259B%25A0%25E4%25B8%25BA%2520HTTP%25EF%25BC%259F.html&quot; data-draft-node=&quot;block&quot; data-draft-type=&quot;link-card&quot; data-image=&quot;https://pic1.zhimg.com/v2-cc1800074d285ca87132d2ee9f798f28_120x160.jpg&quot; data-image-width=&quot;466&quot; data-image-height=&quot;601&quot; data-text=&quot;网骗欺诈？网络裸奔？都是因为 HTTP？&quot; class=&quot;LinkCard new&quot;&gt;&lt;span class=&quot;LinkCard-contents&quot;&gt;&lt;span class=&quot;LinkCard-title loading&quot; data-text=&quot;true&quot;/&gt;&lt;span class=&quot;LinkCard-desc loading&quot;/&gt;&lt;/span&gt;&lt;span class=&quot;LinkCard-image LinkCard-image--default&quot;/&gt;&lt;/a&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>1afdab2edfb49f552cacfb8e0a6857ca</guid>
<title>Bytehound：一个更强大的 Linux 内存分析工具</title>
<link>https://toutiao.io/k/gn6nepc</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText css-hnrfcf&quot; options=&quot;[object Object]&quot;&gt;&lt;p data-pid=&quot;DOa5HFpr&quot;&gt;【导语】：更强大的 Linux 内存分析工具。&lt;/p&gt;
&lt;h3&gt;简介&lt;/h3&gt;
&lt;p data-pid=&quot;W_J2r5uE&quot;&gt;Bytehound 是 Linux 的内存分析工具。它能够显示内存变化曲线、占用详情、完整的堆栈记录等信息，有助于解决内存泄漏等问题。详细功能如下：&lt;/p&gt;
&lt;ul&gt;&lt;li data-pid=&quot;rNPRMWq2&quot;&gt;&lt;p data-pid=&quot;rYHoOhzc&quot;&gt;可用于分析内存泄漏，精确地查看内存消耗的地方，识别临时分配的内存并检测内存碎片&lt;/p&gt;
&lt;/li&gt;
&lt;li data-pid=&quot;VH1bZD5n&quot;&gt;&lt;p data-pid=&quot;U7lOk4P-&quot;&gt;收集每个申请和释放内存的操作的信息，跟踪完整的堆栈信息&lt;/p&gt;
&lt;/li&gt;
&lt;li data-pid=&quot;hn1JM7S5&quot;&gt;&lt;p data-pid=&quot;d6eQLOZs&quot;&gt;可以动态剔除临时分配的内存，可以在很长一段时间内进行分析&lt;/p&gt;
&lt;/li&gt;
&lt;li data-pid=&quot;hABA_yVf&quot;&gt;&lt;p data-pid=&quot;R_ig4MBi&quot;&gt;使用定制的堆栈信息展示实现，这使得它比其他类似工具更高效，在某些情况下可能快几个数量级&lt;/p&gt;
&lt;/li&gt;
&lt;li data-pid=&quot;3E_QfR9i&quot;&gt;&lt;p data-pid=&quot;XDLLByWY&quot;&gt;可以将采集到的数据导出为各种不同的格式：可以将数据导出为 JSON、Heaptrack（可以使用 Heaptrack GUI 进行分析）和火焰图&lt;/p&gt;
&lt;/li&gt;
&lt;li data-pid=&quot;SAqxjSZ7&quot;&gt;&lt;p data-pid=&quot;cZSECYog&quot;&gt;拥有基于 Web 的 GUI，可用于分析&lt;/p&gt;
&lt;/li&gt;
&lt;li data-pid=&quot;z4U9OMn1&quot;&gt;&lt;p data-pid=&quot;-eDhjagC&quot;&gt;可以将分析数据动态地流式传输到另一台机器，而不是将其保存在本地，这对于在内存受限的系统上进行分析非常有用&lt;/p&gt;
&lt;/li&gt;
&lt;li data-pid=&quot;u4nJPNfv&quot;&gt;&lt;p data-pid=&quot;hypriINN&quot;&gt;支持 AMD64、ARM、AArch64 和 MIPS64 架构（其中 MIPS64 需要一个内核补丁 perf_event_open）&lt;/p&gt;
&lt;/li&gt;
&lt;li data-pid=&quot;1FbytJZO&quot;&gt;&lt;p data-pid=&quot;MV43KhZ4&quot;&gt;支持对使用 jemalloc 作为分配器的应用程序进行分析（仅适用于基于 AMD64 架构的 jemallocator）&lt;/p&gt;
&lt;/li&gt;
&lt;li data-pid=&quot;ba8OBC-N&quot;&gt;&lt;p data-pid=&quot;bEoA0fgy&quot;&gt;支持基于 Rhai 的嵌入式 DSL，允许进行编程和自动数据分析&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-cda0e10f377e67fdcb636dd2d1aa35b0_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;377&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-cda0e10f377e67fdcb636dd2d1aa35b0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;377&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-cda0e10f377e67fdcb636dd2d1aa35b0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-cda0e10f377e67fdcb636dd2d1aa35b0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-d921e2123148f5bba3af615fb4db5839_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;768&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-d921e2123148f5bba3af615fb4db5839_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1024&quot; data-rawheight=&quot;768&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-d921e2123148f5bba3af615fb4db5839_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-d921e2123148f5bba3af615fb4db5839_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-65a0d628e285f2268962207db4f78172_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;996&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-65a0d628e285f2268962207db4f78172_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;996&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-65a0d628e285f2268962207db4f78172_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-65a0d628e285f2268962207db4f78172_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-fc0b36f520bde2b7e7b36b5ace0070c0_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;899&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-fc0b36f520bde2b7e7b36b5ace0070c0_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;899&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-fc0b36f520bde2b7e7b36b5ace0070c0_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-fc0b36f520bde2b7e7b36b5ace0070c0_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p data-pid=&quot;jgfEE2on&quot;&gt;项目地址是：&lt;/p&gt;
&lt;p data-pid=&quot;bK8NqxWA&quot;&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/koute/bytehound&quot; class=&quot; external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;&lt;span class=&quot;invisible&quot;&gt;https://&lt;/span&gt;&lt;span class=&quot;visible&quot;&gt;github.com/koute/byteho&lt;/span&gt;&lt;span class=&quot;invisible&quot;&gt;und&lt;/span&gt;&lt;span class=&quot;ellipsis&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;安装&lt;/h3&gt;
&lt;ol&gt;&lt;li data-pid=&quot;PYLp0a-V&quot;&gt;安装 GCC，Rust 和 Yarn，目的是为了构建 GUI&lt;/li&gt;
&lt;li data-pid=&quot;ghHG5o9o&quot;&gt;构建&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;$ cargo build --release -p bytehound-preload
$ cargo build --release -p bytehound-cli&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;&lt;li data-pid=&quot;Mo0EAq3f&quot;&gt;从 target/release/libbytehound.so 或 target/release/bytehound 下获取二进制文件&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;用法&lt;/h3&gt;
&lt;h4&gt;基本用法&lt;/h4&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;$ export MEMORY_PROFILER_LOG=warn
$ LD_PRELOAD=./libbytehound.so ./your_application
$ ./bytehound server memory-profiling_*.dat&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p data-pid=&quot;WwEd1f4D&quot;&gt;然后打开浏览器访问 &lt;a href=&quot;https://link.zhihu.com/?target=http%3A//localhost%3A8080%25E3%2580%2582&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;http://localhost:8080。&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;打开 debug 日志&lt;/h4&gt;
&lt;p data-pid=&quot;UqmIY-XZ&quot;&gt;出于性能原因，默认情况下分析器在编译时禁用了大部分调试日志。如果要启用 debug 日志，需要使用 debug-logs 功能进行重新编译构建：&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;$ cd preload
$ cargo build --release --features debug-logs&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3&gt;环境变量&lt;/h3&gt;
&lt;p data-pid=&quot;JA6rn57Q&quot;&gt;Bytehound 分析器是通过很多的环境变量来控制它的行为的，以下是常用的一些环境变量。&lt;/p&gt;
&lt;h4&gt;MEMORY_PROFILER_OUTPUT&lt;/h4&gt;
&lt;p data-pid=&quot;AqGMPkn7&quot;&gt;默认值：memory-profiling_%e_%t_%p.dat，表示数据将写入的文件的路径，支持占位符，这些占位符将在运行时替换为以下内容：%p -&amp;gt; 进程的PID %t -&amp;gt; UNIX 纪元以来的秒数 %e -&amp;gt; 可执行文件的名称 %n -&amp;gt; 自动递增计数器（0、1、..、9、10 等）&lt;/p&gt;
&lt;h4&gt;MEMORY_PROFILER_LOG&lt;/h4&gt;
&lt;p data-pid=&quot;RMQWYROR&quot;&gt;要使用的日志级别；可能的值：trace、debug、info、warn、error&lt;/p&gt;
&lt;h4&gt;MEMORY_PROFILER_LOGFILE&lt;/h4&gt;
&lt;p data-pid=&quot;W3aGvCq2&quot;&gt;日志将写入的文件的路径；如果未设置，日志将被发送到 stderr，并且支持类似于 MEMORY_PROFILER_OUTPUT（除了%n）的占位符。&lt;/p&gt;
&lt;h4&gt;MEMORY_PROFILER_CULL_TEMPORARY_ALLOCATIONS&lt;/h4&gt;
&lt;p data-pid=&quot;34L1KODa&quot;&gt;默认值：0，当设置为 1 时，将剔除临时分配并从输出中省略它们。如果只关心内存泄漏或想要在几天内进行长期分析，可以设置为 1。&lt;/p&gt;
&lt;h4&gt;MEMORY_PROFILER_PRECISE_TIMESTAMPS&lt;/h4&gt;
&lt;p data-pid=&quot;K_68R69a&quot;&gt;默认值：0，决定何时为每个事件收集时间戳，或者只为事件块收集时间戳。启用后，时间戳将更加精确，但会增加 CPU 使用率。
&lt;code&gt;开源前哨&lt;/code&gt; 日常分享热门、有趣和实用的开源项目。参与维护 10万+ Star 的开源技术资源库，包括：Python、Java、C/C++、Go、JS、CSS、Node.js、PHP、.NET 等。&lt;/p&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>