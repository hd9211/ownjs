<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>b95302d2b9660aaf9f65b06564461666</guid>
<title>Nacos 配置中心模块详解</title>
<link>https://toutiao.io/k/5vic46a</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;配置中心&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;业务上的配置，功能开关，服务治理上对弱依赖的降级，甚至数据库的密码等，都可能用到动态配置中心。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在没有专门的配置中心组件时，我们使用硬编码、或配置文件、或数据库、缓存等方式来解决问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;硬编码修改配置时需要重新编译打包，配置文件需要重启应用，数据库受限于性能，缓存丧失了及时性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能都不完美，但能从中总结出配置中心的需求，相对来说还是比较明确：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;能够存储、获取并监听配置（必须）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置变更时能及时推送给监听者（必须）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有一个可视化的查看变更配置的控制台（必须）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置变更可灰度执行（加分）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;配置变更可回滚（加分）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;目前使用最多的配置中心可能是携程开源的Apollo，还有Spring Cloud Config、阿里开源的Nacos、百度的Disconf等。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Nacos配置中心&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Nacos&lt;/code&gt;是&lt;code&gt;Naming and Configuration Service&lt;/code&gt;的缩写，从名字上能看出它重点关注的两个领域是&lt;code&gt;Naming&lt;/code&gt;即注册中心和&lt;code&gt;Configuration&lt;/code&gt;配置中心。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文讲解nacos的配置中心的架构设计和实现原理，基于&lt;code&gt;2.0.0&lt;/code&gt;版本（注：2.0.0版本与1.x版本区别较大）&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Nacos调试环境搭建&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;先从github上clone代码（网速比较慢，加上--depth=1参数）&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;git &lt;span&gt;clone&lt;/span&gt; --depth=1 https://github.com/alibaba/nacos.git&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;导入IDE，看代码，调试更方便&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;启动Server端：运行console模块下的Nacos.main()，这个类扫描的路径最广，能启动所有的模块&lt;/section&gt;&lt;/li&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;JVM参数可带上&lt;code&gt;-Dnacos.standalone=true -Dnacos.functionMode=config&lt;/code&gt;，指定单机模式，且只启动config模块&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;--spring.config.additional-location=nacos/distribution/conf&lt;/code&gt;，程序参数指定配置文件目录&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;正常启动，console打印出Ncos控制台地址，进入Nacos控制台，输入用户名密码（默认均为nacos）即可登录&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3281710914454277&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0Th4bNgnKdILZqyIgdfs0rlZqVdqVOpic1OgbJjUcAZjH4J1xPc19ia7CjDwtLFLICKEFoEgOtkPrIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2712&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用client进行测试，example模块下有configExample可进行config的测试，为了不动源代码，可copy一份configExample进行修改测试&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;Nacos配置模型&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;namespace + group + dataId  唯一确定一个配置&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;namespace：与client绑定，一个clinet对应到一个namespace，可用来隔离环境或区分租户&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;group：分组，区分业务&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;dataId：配置的id&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9133448873483535&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0Th4bNgnKdILZqyIgdfs0rlXA8ZxAWplFM5aicZjRjcJ1P6MNIqDJ9Fdd3K7f89tBDGueIoyicADFGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;577&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;客户端启动流程&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3384615384615385&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0Th4bNgnKdILZqyIgdfs0rlGOibOCeoSficnyC3m1j1CVguQ4W2XFsGsZC45agIibAZ7Czf8zWyT9A5w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1495&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;参数准备时，如果配置了nacos服务端地址，则直接使用；如果配置了endpoint，则从endpoint中获取nacos服务端地址，这样有个好处是服务端地址变更，扩缩容都无需重启client，更详细可参考&lt;code&gt;https://nacos.io/en-us/blog/namespace-endpoint-best-practices.html&lt;/code&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在客户端第一次与服务端交互时创建GRPC连接，随机挑选一台server建立连接，后续都使用该连接，请求失败都会有重试，针对请求级别也有限流；重试失败或者服务端主动断开连接，则会重新挑选一台server进行建链&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;请求模型&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从gRPC的proto文件能看出请求与返回的定义比较统一&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;message Metadata {&lt;br/&gt;  string &lt;span&gt;type&lt;/span&gt; = 3;&lt;br/&gt;  string clientIp = 8;&lt;br/&gt;  map&amp;lt;string, string&amp;gt; headers = 7;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;message Payload {&lt;br/&gt;  Metadata metadata = 2;&lt;br/&gt;  google.protobuf.Any body = 3;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;service Request {&lt;br/&gt;  // Sends a commonRequest&lt;br/&gt;  rpc request (Payload) returns (Payload) {&lt;br/&gt;  }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;type是请求/返回类的类名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;clientIp是客户端ip&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;headers是携带的header信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Playload中的body以json格式编码&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;com.alibaba.nacos.api.config.ConfigService&lt;/code&gt;中可以找到所有配置中心能使用的接口&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4870775347912525&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0Th4bNgnKdILZqyIgdfs0rlcEniblugEMngamzBV10oqpsFlqgW85hHyAUFE3Sbib9dKsH3YVFDj8Qg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1006&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重点关注这几个接口：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;getConfig：读取配置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;publishConfig：发布配置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;publishConfigCas：原子的发布配置，若有被其他线程变更则发布失败，类似java中的CAS&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;removeConfig：删除配置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;addListener：监听配置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;removeListener：移除配置的监听&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;变更推送&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6675302245250432&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0Th4bNgnKdILZqyIgdfs0rlKmONibUaPpDHvr5XXicJh5jlAzZwEIYuib3mp6PU19c3jrKyDMTNmvJow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1158&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;采取推拉结合的方式，既保证时效性，又保证数据一致性&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;数据存储&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Nacos配置中心的数据存储支持内嵌的&lt;code&gt;derby&lt;/code&gt;数据库，也支持外部数据库&lt;code&gt;mysql&lt;/code&gt;，内嵌数据库主要是为了单机测试时使用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其中上文提及的&lt;code&gt;publishConfigCas&lt;/code&gt;的实现是利用了数据库&lt;code&gt;update ${table} set ${xx}=${zz} where md5=${old_md5}&lt;/code&gt;来实现，如果已经这条数据被变更，则这次publish会失败。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;灰度和回滚&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5203665987780041&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0Th4bNgnKdILZqyIgdfs0rlibnvIP1UvhicQulIkIy4xB0C9JnzTs07wOZyNExrXmmEh7AibAM1gsWJg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1964&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当勾选灰度发布时可填写灰度的ip进行推送，不在灰度列表内的ip则不会接受到变更推送，并且灰度和正式是区分开的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5350966429298067&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0Th4bNgnKdILZqyIgdfs0rlZGbPDrYibWl6E4k9QRFciaA8lYTgn7icVwNKYy9AzziaVQP32zLPzYqdeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1966&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4091381100726895&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/xacdaKuBM0Th4bNgnKdILZqyIgdfs0rltlvmicTtbgdjLiazCBrziaBUbhZyfzkcIlkWqxbrEdVXBStWReicfibzttQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1926&quot;/&gt;灰度的实现是记录下了每次的发布，回滚到指定版本即可。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;结语&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文从背景出发，结合Nacos配置中心的各个重要模块进行了一一解释，能够从整体上对Nacos的配置中心有一个把握。期望后续能对Nacos注册中心进行分析介绍。&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;搜索关注微信公众号&quot;捉虫大师&quot;，后端技术分享，架构设计、性能优化、源码阅读、问题排查、踩坑实践。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/xacdaKuBM0Th4bNgnKdILZqyIgdfs0rlNicicQQMFxzbiaz36WkKG1uKSwJ5AkKHgvBv5d7CcZgjlRg676jbbHjCg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/figure&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b0674b990c2064076ab63647f13f0b66</guid>
<title>没源码怎么排查问题？Arthas 暴力内存搜索对象解决</title>
<link>https://toutiao.io/k/yg6hxci</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section&gt;&lt;h2&gt;背景&lt;/h2&gt;&lt;p&gt;公司某个规则引擎系统，主要用来做一些费用计算和业务逻辑核验的功能。不过由于一些&lt;strong&gt;不可描述的历史原因&lt;/strong&gt;，导致该系统&lt;strong&gt;没有文档也没有源码&lt;/strong&gt;，就连配置方式都是靠口口相传。&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mgU4gUcibuexTjNZmrvdfKsqQppgJtmo56dW0EMYiayqxzcBIzfhgcTmz20YLR6SaFGSXwu9OBSOUkjXInMxrphg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot;/&gt;&lt;/p&gt;&lt;p&gt;虽然这个系统比较老，但毕竟是商业产品，功能上还是比较完善好用的。该系统在接入业务系统的算费和核验规则后，很快就上线了。&lt;/p&gt;&lt;p&gt;不过上线后，会偶发的出现接口耗时过长的问题。正常情况下，该服务响应耗时也就 20ms 以下。但出现问题时，服务的耗时会增加到几十秒，每次出现长耗时的时间点也不固定。而且在长耗时期间，所有到达该服务的请求都会出现长耗时，并不只是个别请求才会受影响。&lt;/p&gt;&lt;p&gt;理论上这种问题测试之类的环境应该也有；但由于测试环境重启很频繁，偶发的长耗时可能认为是在重启，就一直没人留意。&lt;/p&gt;&lt;p&gt;虽然啥都没有，但问题还是得解决啊，时不时的几十秒长耗时……这谁顶得住。抱着试试看的心态，还是先研究一下。&lt;/p&gt;&lt;h2&gt;排查经过&lt;/h2&gt;&lt;p&gt;这种偶发长耗时的问题，排查起来是比较麻烦的。无法稳定复现，也没有规律，就算弄个其他环境模拟也不是很好办；再加上这个系统没文档没源码，更没人懂它的结构和流程，查起来就更费劲了。&lt;/p&gt;&lt;h3&gt;看监控&lt;/h3&gt;&lt;p&gt;在查看了监控历史之后，发现每次出现长耗时的时候，CPU &amp;amp; 磁盘 IO 的利用率会升高，但也没高的很离谱。CPU 高的时候不过也才 五六十，而磁盘就更低了，只是稍微有一点波动而已，这点波动会带来几十秒的耗时，可有点说不过去。&lt;/p&gt;&lt;h3&gt;看日志&lt;/h3&gt;&lt;p&gt;CPU 那块只是稍微有点高，但也不能说明什么问题，还是得找到根本原因。于是我又翻了下那个系统的日志，看看能不能找到什么线索。&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mgU4gUcibuexTjNZmrvdfKsqQppgJtmo5MicTt8wfN68hBA3LsXpCpiaoiayw9Tqc6pRxAaMunGFBlDBcRmwdenSlg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;卡时间，看日志，折腾了半小时，终于在日志上看到一个关键线索：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;2020-04-08 10:12:35.897 INFO  [com.马赛克.rules.res.execution] (default-threads - 65) 规则集 /ansNcreckonRuleApp/1.0/ansncreckonrule/61.0 已在 58 秒后解析完毕。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;58 秒……这行日志的时间点，和我们实际发生耗时的时间点是可以匹配上的，在这个58 秒范围内，确实有大量的请求耗时，而且都是小于 58 秒或略大于 58 秒的。&lt;img data-ratio=&quot;0.42285041224970554&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mgU4gUcibuexTjNZmrvdfKsqQppgJtmo5USnQ6EZuiaqDq2hsicTH9K0vqe6kE2bHQZzvNm94G09EtbvHkcoy4MmA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;4245&quot;/&gt;除了这个耗时的打印之外，GC 日志也有点可疑。&lt;strong&gt;每次出现这个耗时日志之前，都会有一次 GC 活动日志&lt;/strong&gt;，不过暂停时间并不长：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;2021-06-07T17:36:44.755+0800: [GC2021-06-07T17:36:44.756+0800: [DefNew: 879616K-&amp;gt;17034K(3531079K), 0.0472190 secs] 3549012K-&amp;gt;2686430K(10467840K), 0.0473160 secs] [Times: user=0.05 sys=0.00, real=0.2 secs]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;更奇怪的是……不是每次 GC 之后，都会有耗时日志&lt;/strong&gt;&lt;/p&gt;&lt;h3&gt;GC 问题&lt;/h3&gt;&lt;p&gt;仔细查看 gc 日志后发现，每次慢响应之前不久，都会有一次 GC，不过不是 FULL GC，而且每次暂停时间也不长，远不及请求的耗时时间。而且 GC 过程中的 CPU 利用率并不高，从数据上看还是比较正常的。&lt;/p&gt;&lt;p&gt;好现在有（一丁点）线索了：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;长耗时期间，CPU 利用率有增加&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;长耗时期间有日志打印，在加载某个东西，时长是可以匹配的&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;每次长耗时之前，有 GC 活动&lt;/p&gt;&lt;h3&gt;猜测可能的原因&lt;/h3&gt;&lt;p&gt;毕竟没有源码，也没人懂，想手撕代码都没机会，只能靠猜了……&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;从以上几个线索来看，GC 活动之后出现 CPU 利用率增加，然后打印了一行加载日志，时间还可以和该系统的长耗时请求对应上。&lt;/p&gt;&lt;p&gt;而且每次耗时日志之前不久的地方，都会有一次 GC 活动，那么说明这个资源加载的时机和 GC 有关系，GC 会影响资源加载……&lt;/p&gt;&lt;p&gt;想到这里，也大概猜到原因了。很可能是用弱引用(Weak Reference)来维护了这个资源缓存，当 GC 后弱引用的资源被回收，所以需要重新加载（弱引用的详细解释以及测试结果可以参考《Java 中的强引用/软引用/弱引用/虚引用以及 GC 策略》）。&lt;/p&gt;&lt;p&gt;那既然可能是这个原因，如果我找到这个弱引用维护资源缓存的地方，给他改成强引用就能解决问题了！虽然没有源码，但还是可以反编译啊，反编译之后改一下缓存那块的代码，问题不大。&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mgU4gUcibuexTjNZmrvdfKsqQppgJtmo5lGI8dPaL9s6FpMmcOiafia30Ajq0lETG0sHBcZZ4MNVp9mCmichF6mzqA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;690&quot;/&gt;&lt;/p&gt;&lt;h3&gt;定位资源加载点&lt;/h3&gt;&lt;p&gt;终于找到了可能的原因，可是有一个问题……我怎么知道这行耗时日志在哪打印的？在哪个类里？我连这个服务是用的什么 Web 容器都不知道。&lt;/p&gt;&lt;p&gt;没办法，上 Arthas 吧，不过肯定不能在生产环境直接测。于是我又新整了一套临时测试环境，用于排查这个问题。&lt;/p&gt;&lt;p&gt;幸好日志里有个 loggerName 前缀&lt;code&gt;com.马赛克.rules.res.execution&lt;/code&gt;，通过 Arthas 的 &lt;code&gt;trace&lt;/code&gt; 功能，可以用通配符的形式来 &lt;code&gt;trace&lt;/code&gt; 这个包名下的所有类：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;# trace 该包名下的所有类，所有方法，只显示耗时大于 1000ms 的方法&lt;br/&gt;# 由于这个输出结果可能会比较多，所以 &amp;gt; 输出到文件，并且后台运行&lt;br/&gt;&lt;br/&gt;trace com.马赛克.rules.res.* * &#x27;#cost &amp;gt; 1000&#x27; &amp;gt; /app/slow_trace.log &amp;amp;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;trace&lt;/code&gt; 命令执行了十几秒才返回，一共影响了 169 个类和 1617 个方法，可见通配符匹配多危险……要是生产这样玩我可能会被拉出去祭天。&lt;img data-ratio=&quot;0.9405940594059405&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mgU4gUcibuexTjNZmrvdfKsqQppgJtmo50sq9GUYD06kia2iawPPrr0XnOPQBLB9jibbZuNOxrCQGTfgfFcXLRejyw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;707&quot;/&gt;&lt;/p&gt;&lt;p&gt;结合前面描述的情况，GC 后会有这个耗时问题，那现在来手动触发一次 GC，&lt;/p&gt;&lt;p&gt;利用 Arthas 的 &lt;code&gt;vmtool&lt;/code&gt; 可以直接 forceGC（利用 jmap 或者其他的手段也可以）：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;vmtool --action forceGc&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;forceGC 后，重新测试该系统接口&lt;/p&gt;&lt;p&gt;和上面的情况一样，果然又出现了长耗时，请求返回后打印了相同的耗时日志，只是和生产环境的相比时间更长了（因为我用了 arthas trace 增强）&lt;/p&gt;&lt;pre&gt;&lt;code&gt;2020-04-08 12:30:35.897 INFO  [com.马赛克.rules.res.execution] (default-threads - 65) 规则集 /ansNcreckonRuleApp/1.0/ansncreckonrule/61.0 已在 70 秒后解析完毕。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同时 Arthas &lt;code&gt;trace&lt;/code&gt; 日志写入的那个文件中，也有了内容（链路实在太长，没法贴代码，只能截图了）：&lt;img data-ratio=&quot;0.6246973365617433&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mgU4gUcibuexTjNZmrvdfKsqQppgJtmo5SgiaodLdicaaXxRIWkg6ttkqwcof7HeEe49trm3vfREV0EvoicVHD4D3A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2478&quot;/&gt;这个 &lt;code&gt;trace&lt;/code&gt; 日志一千多行，此处删减了部分内容。&lt;/p&gt;&lt;p&gt;Arthas 的 &lt;code&gt;trace&lt;/code&gt; 命令不会进行全链路跟踪，所以这里的&lt;strong&gt;一次 trace 结果&lt;/strong&gt;只是当前路径。但已经不错了，问题范围又再一次缩小。&lt;/p&gt;&lt;p&gt;从上图可以看到&lt;code&gt;IlrRulesetProvider:getRuleset&lt;/code&gt;这个方法是主要耗时点，那就先来看看这个方法里是个什么玩法。&lt;/p&gt;&lt;p&gt;为了简单，这里临时用 Arthas 的 &lt;code&gt;jad&lt;/code&gt; 命令，直接反编译这个类，看看里面的逻辑：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;jad ilog.rules.res.xu.ruleset.internal.IlrRulesetProvider&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码有点多，这里删减一些，只保留关键部分：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;public final XURulesetImpl getRuleset(IlrXURulesetArchiveInformation archive, IlrXUContext xuCtx, boolean waitParsing, Listener listener) throws IlrRulesetArchiveInformationNotFoundException, IlrRulesetCreationException, IlrRulesetAlreadyParsingException, IlrRulesetCacheException, XUException {&lt;br/&gt;        String canonicalPath = archive.getCanonicalPath().toString();&lt;br/&gt;        this.logger.finest(&quot;IlrRulesetProvider.getRuleset &quot; + canonicalPath + &quot; &quot; + waitParsing);&lt;br/&gt;        if (!archive.getProperties().isShareable()) {&lt;br/&gt;            return this.factory.createRuleset(archive, xuCtx);&lt;br/&gt;        } else {&lt;br/&gt;            ClassLoader cl = archive.getXOMClassLoader();&lt;br/&gt;&lt;br/&gt;            XURulesetImpl ruleset;&lt;br/&gt;            while(true) {&lt;br/&gt;                synchronized(this.parsingRulesets) {&lt;br/&gt;&lt;br/&gt;                    // 字面意思是，从缓存中获取规则集，有的话直接 return 了&lt;br/&gt;                    ruleset = (XURulesetImpl)this.getCache().getRuleset(canonicalPath, cl);&lt;br/&gt;                    if (ruleset != null) {&lt;br/&gt;                        return ruleset;&lt;br/&gt;                    }&lt;br/&gt;&lt;br/&gt;                    // 第一个加载的线程，将当前资源添加到 parsingRulesets 同时跳出 while&lt;br/&gt;                    if (!this.parsingRulesets.contains(archive)) {&lt;br/&gt;                        this.parsingRulesets.add(archive);&lt;br/&gt;                        break;&lt;br/&gt;                    }&lt;br/&gt;&lt;br/&gt;                    if (!waitParsing) {&lt;br/&gt;                        throw new IlrRulesetAlreadyParsingException(&quot;XU.ERROR.10406&quot;, (String[])null);&lt;br/&gt;                    }&lt;br/&gt;&lt;br/&gt;                    // 这里的 wait……应该是防止并发访问，当其他线程也进入该代码块时 wait 等待第一个线程加载完成唤醒&lt;br/&gt;                    try {&lt;br/&gt;                        this.parsingRulesets.wait();&lt;br/&gt;                    } catch (InterruptedException var20) {&lt;br/&gt;                        throw new IlrRulesetCreationException(&quot;XU.ERROR.10009&quot;, (String[])null, var20);&lt;br/&gt;                    }&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;&lt;br/&gt;            if (!this.useWorkManager(archive)) {&lt;br/&gt;                this.logger.finest(&quot;IlrRulesetProvider.getRuleset doesn&#x27;t use the workmanager &quot; + this.workManager, (Object[])null, xuCtx);&lt;br/&gt;&lt;br/&gt;                XURulesetImpl var9;&lt;br/&gt;                try {&lt;br/&gt;                    // 创建资源&lt;br/&gt;                    ruleset = this.factory.createRuleset(archive, xuCtx);&lt;br/&gt;&lt;br/&gt;                    // 创建完成，添加到缓存&lt;br/&gt;                    this.getCache().addRuleset(ruleset);&lt;br/&gt;                    var9 = ruleset;&lt;br/&gt;                } finally {&lt;br/&gt;                    this.parsingStopped(archive);&lt;br/&gt;                }&lt;br/&gt;&lt;br/&gt;                return var9;&lt;br/&gt;            } &lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;虽然删减了很多，但看代码还是有点不清晰，毕竟反编译的代码阅读干扰有点大，这里简单解释下上面的代码逻辑：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;先从缓存容器中获取资源&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;如果取不到就执行创建逻辑&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;创建完成，再次添加到缓存&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;在加载时若已有其他线程也执行加载，会主动 wait 等待第一个创建完成的线程唤醒&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;再结合我们上面的猜测：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;很可能是该系统用弱引用(Weak Reference)来维护了这个资源缓存，当 GC 后该资源被回收，所以需要重新加载&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;那问题就在这个缓存容器上了！只要看看这个 cache 就能知道，肯定有弱引用的代码！&lt;img data-ratio=&quot;0.9692832764505119&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mgU4gUcibuexTjNZmrvdfKsqQppgJtmo5RTapfM73QibWSVjOUQJeBWzn7XRTcgJH13kn9BDRicpuehGn5JFkGjqA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1172&quot;/&gt;&lt;/p&gt;&lt;h3&gt;反编译找代码&lt;/h3&gt;&lt;p&gt;&lt;code&gt;jad&lt;/code&gt; 反编译在终端里看代码还是太折腾了，不如在 IDE 里直观，所以还是得把代码拉下来分析，不然找个关联类都费劲。&lt;/p&gt;&lt;p&gt;这个系统下有很多 Jar 包，得先找到这些相关的类在哪个 Jar 里，利用 Arthas 的 &lt;code&gt;sc&lt;/code&gt; 命令，也非常简单：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;sc 查看JVM已加载的类信息&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;sc -d ilog.rules.res.xu.ruleset.internal.IlrRulesetProvider&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt; class-info        ilog.rules.res.xu.ruleset.internal.IlrRulesetProvider&lt;br/&gt;&lt;br/&gt; # 这里是我们关心的信息，该 class 所在的 jar &lt;br/&gt; code-source       /content/jrules-res-xu-JBOSS61EAP.rar/ra.jar&lt;br/&gt; name              ilog.rules.res.xu.ruleset.internal.IlrRulesetProvider&lt;br/&gt; isInterface       false&lt;br/&gt; isEnum            false&lt;br/&gt; isAnonymousClass  false&lt;br/&gt; isArray           false&lt;br/&gt; isLocalClass      false&lt;br/&gt; isMemberClass     false&lt;br/&gt; isPrimitive       false&lt;br/&gt; isSynthetic       false&lt;br/&gt; simple-name       IlrRulesetProvider&lt;br/&gt; modifier          final,public&lt;br/&gt; annotation&lt;br/&gt; interfaces        com.ibm.rules.res.xu.ruleset.internal.RulesetParsingWork$Listener&lt;br/&gt; super-class       +-java.lang.Object&lt;br/&gt; class-loader      +-ModuleClassLoader for Module &quot;deployment.jrules-res-xu-JBOSS61EAP.rar:main&quot; from Service Module Loader&lt;br/&gt;                     +-sun.misc.Launcher$AppClassLoader@2d74e4b3&lt;br/&gt;                       +-sun.misc.Launcher$ExtClassLoader@5552bb15&lt;br/&gt; classLoaderHash   2d022d73                             &lt;br/&gt;&lt;br/&gt;Affect(row-cnt:1) cost in 79 ms.&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;找到这个 ra.jar 后，把这个 jar 拖到 IDE 里反编译，不过这个 class 还有些关联的 class 不在这个 ra.jar 中。还是同样的办法，找到关联的 class，然后 &lt;code&gt;sc -d&lt;/code&gt;找到所在的 jar 位置，复制到本地 ide 反编译&lt;/p&gt;&lt;p&gt;反复折腾了几次后，终于把有关联的 4 个 jar 包都弄回本地了，现在可以在 IDE 里开开心心的看代码了。&lt;/p&gt;&lt;h3&gt;分析缓存容器的机制&lt;/h3&gt;&lt;p&gt;首先是上面那个 &lt;code&gt;createCache&lt;/code&gt; 方法，经过分析后得知，cache 的实现类为 &lt;code&gt;IlrRulesetCacheImpl&lt;/code&gt;，这个类需要关心的只有两个方法，getRuleset 和 addRuleset：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;public void addRuleset(IlrXURuleset executableRuleset) {&lt;br/&gt;    synchronized(this.syncObject) {&lt;br/&gt;        //...&lt;br/&gt;        this.entries.add(new IlrRulesetCacheEntry(executableRuleset, this.maxIdleTimeOutSupport));&lt;br/&gt;        //...&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public IlrXURuleset getRuleset(String canonicalRulesetPath, ClassLoader xomClassLoader) {&lt;br/&gt;    // ...&lt;br/&gt;&lt;br/&gt;    List&amp;lt;IlrRulesetCacheEntry&amp;gt; cache = this.entries;&lt;br/&gt;    synchronized(this.syncObject) {&lt;br/&gt;        Iterator iterator = cache.iterator();&lt;br/&gt;&lt;br/&gt;        while(iterator.hasNext()) {&lt;br/&gt;            IlrRulesetCacheEntry entry = (IlrRulesetCacheEntry)iterator.next();&lt;br/&gt;            IlrXURuleset ruleset = (IlrXURuleset)entry.rulesetReference.get();&lt;br/&gt;            if (ruleset == null) {&lt;br/&gt;                iterator.remove();&lt;br/&gt;            } else if (entry.canonicalRulesetPath.equals(canonicalRulesetPath) &amp;amp;&amp;amp; (entry.xomClassLoader == xomClassLoader || entry.xomClassLoader != null &amp;amp;&amp;amp; entry.xomClassLoader.getParent() == xomClassLoader)) {&lt;br/&gt;                return ruleset;&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;    // ...&lt;br/&gt;    return null;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看完这两个方法之后，很明显了， &lt;code&gt;entries&lt;/code&gt; 才是关键的数据存储集合，看看它是怎么个玩法：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;protected transient List&amp;lt;IlrRulesetCacheEntry&amp;gt; entries = new ArrayList();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;竟然只是个 ArrayList，继续看看 &lt;code&gt;IlrRulesetCacheEntry&lt;/code&gt;这个类：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;public class IlrRulesetCacheEntry {&lt;br/&gt;    protected String canonicalRulesetPath = null;&lt;br/&gt;    protected ClassLoader xomClassLoader = null;&lt;br/&gt;    protected IlrReference&amp;lt;IlrXURuleset&amp;gt; rulesetReference = null;&lt;br/&gt;&lt;br/&gt;    public IlrRulesetCacheEntry(IlrXURuleset executableRuleset, boolean maxIdleTimeOutSupport) {&lt;br/&gt;        this.canonicalRulesetPath = executableRuleset.getCanonicalRulesetPath();&lt;br/&gt;        this.xomClassLoader = executableRuleset.getXOMClassLoader();&lt;br/&gt;        long maxIdleTime = executableRuleset.getRulesetArchiveProperties().getMaxIdleTime();&lt;br/&gt;&lt;br/&gt;        // 注意这里是关键，根据 maxIdleTime 的值选择强引用和弱引用&lt;br/&gt;        if (maxIdleTime != 0L &amp;amp;&amp;amp; (!maxIdleTimeOutSupport || maxIdleTime == -1L)) {&lt;br/&gt;            this.rulesetReference = new IlrWeakReference(executableRuleset);&lt;br/&gt;        } else {&lt;br/&gt;            this.rulesetReference = new IlrStrongReference(executableRuleset);&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;代码已经很直白了，根据 maxIdleTime 的不同使用不同的引用策略，不等于 0 就弱引用，等于 0 就强引用；不过还是得看下这俩 Reference 类的代码：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;// 弱引用，继承 WeakReference&lt;br/&gt;public class IlrWeakReference&amp;lt;T&amp;gt; extends WeakReference&amp;lt;T&amp;gt; implements IlrReference&amp;lt;T&amp;gt; {&lt;br/&gt;    public IlrWeakReference(T t) {&lt;br/&gt;        super(t);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 强引用&lt;br/&gt;public class IlrStrongReference&amp;lt;T&amp;gt; implements IlrReference&amp;lt;T&amp;gt; {&lt;br/&gt;    private T target;&lt;br/&gt;&lt;br/&gt;    IlrStrongReference(T target) {&lt;br/&gt;        this.target = target;&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    public T get() {&lt;br/&gt;        return this.target;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这俩类并没有什么特别的地方，和类名的意思相同；IlrWeakReference 继承于 WeakReference，那就是弱引用，当发生 GC 时，引用的对象会被删除。&lt;/p&gt;&lt;p&gt;虽然找到了这个弱引用的地方，但还是需要验证一下，是不是真的使用了这个弱引用&lt;/p&gt;&lt;h3&gt;验证是否使用了弱引用&lt;/h3&gt;&lt;p&gt;这里使用 Arthas 的 &lt;code&gt;vmtool&lt;/code&gt; 命令，来看看缓存中的实时对象：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;watch - 方法执行数据观测&lt;/p&gt;&lt;/blockquote&gt;&lt;pre&gt;&lt;code&gt;vmtool --action getInstances --className ilog.rules.res.xu.ruleset.cache.internal.IlrRulesetCacheImpl --express &#x27;instances[0].entries.get(0)&#x27;&lt;br/&gt;@IlrRulesetCacheEntry[&lt;br/&gt;    canonicalRulesetPath=@String[/ansNcreckonRuleApp/1.0/ansncreckonrule/1.0],&lt;br/&gt;    xomClassLoader=@XOMClassLoader[com.ibm.rules.res.persistence.internal.XOMClassLoader@18794875],&lt;br/&gt;&lt;br/&gt; # 这里可以看到，rulesetRef 的实例是 IlrWeakReference&lt;br/&gt;rulesetReference=@IlrWeakReference[ilog.rules.res.xu.ruleset.cache.internal.IlrWeakReference@dbd2972],&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从结果上看，石锤了就是弱引用。&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mgU4gUcibuexTjNZmrvdfKsqQppgJtmo5Q2iaicKySDjc2TumIR6Ft4OW9SFiaGkVta59szdgOm6z9icpgVF4Q7FzHQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot;/&gt;但引起弱引用的毕竟是 maxIdleTime，还是需要找到 maxIdleTime 的源头……&lt;/p&gt;&lt;h3&gt;寻找 maxIdleTime&lt;/h3&gt;&lt;p&gt;在 &lt;code&gt;IlrRulesetCacheEntry&lt;/code&gt; 的构造方法里可以看到，maxIdleTime 是从 &lt;code&gt;IlrRulesetArchiveProperties&lt;/code&gt; 里获取的：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;long maxIdleTime = executableRuleset.getRulesetArchiveProperties().getMaxIdleTime();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;那就继续看看 &lt;code&gt;IlrRulesetArchiveProperties&lt;/code&gt;这个类：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;public long getMaxIdleTime() {&lt;br/&gt;&lt;br/&gt;    // 从 properties 里获取 key 为 ruleset.maxIdleTime 的 value&lt;br/&gt;    String result = this.get(&quot;ruleset.maxIdleTime&quot;);&lt;br/&gt;    return result == null ? -1L : Long.valueOf(result);&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public String get(Object key) {&lt;br/&gt;    String result = (String)this.properties.get(key);&lt;br/&gt;    return result == null &amp;amp;&amp;amp; this.defaults != null ? (String)this.defaults.get(key) : result;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;getMaxIdleTime 返回的默认值是 -1，也就是说如果没配置这个 maxIdleTime 值，默认也会使用弱引用策略。&lt;/p&gt;&lt;p&gt;到目前为止，问题算是已经精确的定位到了，弱引用的缓存策略导致被 GC 时资源缓存被清空，重新加载资源导致了长耗时。&lt;/p&gt;&lt;p&gt;可是这系统没源码没文档，我上哪改这个 maxIdleTime 去……&lt;/p&gt;&lt;p&gt;不过来都来了，都已经看到 IlrRulesetArchiveProperties 这个类了，不如先看看这个类里到底配置了哪些值，有没有 maxIdleTime&lt;/p&gt;&lt;pre&gt;&lt;code&gt;vmtool --action getInstances --className com.ibm.rules.res.xu.ruleset.internal.CRERulesetImpl --express &#x27;instances[0].getRulesetArchiveProperties()&#x27;&lt;br/&gt;&lt;br/&gt;@IlrRulesetArchivePropertiesImpl[&lt;br/&gt;    @String[ruleset.engine]:@String[cre],&lt;br/&gt;    @String[ruleset.status]:@String[enabled],&lt;br/&gt;    @String[ruleset.bom.enabled]:@String[true],&lt;br/&gt;    @String[ruleset.managedxom.uris]:@String[resuri://ans-nc-xom.zip/54.0,resuri://ruleapp-core-model-1.5.2.jar/2.0],&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从结果上可以看到，properties 里并没有 maxIdleTime 属性，和我们上面的结论是可以匹配的。没有配置 maxIdleTime 属性，默认 -1，所以使用弱引用&lt;/p&gt;&lt;h3&gt;寻找 maxIdleTime 的配置方法&lt;/h3&gt;&lt;p&gt;反编译的代码虽然看不到注释，但从类名还是可以猜一下的，IlrRulesetArchiveProperties 这个类名应该是“规则集归档属性”的意思。&lt;/p&gt;&lt;p&gt;虽然我不懂这个系统的业务规则，但有人懂啊！于是我找来了负责这个系统配置的老哥，找他给我解释了下这个系统的各种概念。&lt;img data-ratio=&quot;0.825&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mgU4gUcibuexTjNZmrvdfKsqQppgJtmo5kDw1OwTyLBz4jfYTdciaDSlcutVALRWY1u8mPRXXyLqs5sXMCxict6vQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;老哥也很友好，直接给我画了一张图&lt;img data-ratio=&quot;0.4716312056737589&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mgU4gUcibuexTjNZmrvdfKsqQppgJtmo5sic23uWCzRibrFn7xR3EABGdFYzVeF99e3lvSKmicFDL2mY4qbjl7GI4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;4230&quot;/&gt;这个规则引擎系统，有一个 App 的概念，就是 saas 平台里常说的那个应用的意思；每个 App 下面可以创建多个规则集，就是图上这个 RuleSet，每个 RuleSet 就是我们的业务规则，比如费用计算公式或者逻辑核验规则，同时每个 RuleSet 还会记录多个每次变更的历史版本。&lt;/p&gt;&lt;p&gt;看到这张图，我也明白了个七七八八，上面定位的 IlrRulesetArchiveProperties 不就是规则集的属性？这个产品有个控制台，应该有这个属性配置的地方吧，不然弄这么个类干啥？规则集都是控制台创建的，那规则集属性应该也可以配置！&lt;img data-ratio=&quot;0.5423611111111111&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mgU4gUcibuexTjNZmrvdfKsqQppgJtmo5iaNo2qyp63DG0qmhQF0PS1SsXK0c7DnKqxxpoRc8c33fdILicjFDbuLA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2880&quot;/&gt;&lt;/p&gt;&lt;p&gt;如我所料，控制台的规则集上果然有个属性的概念，而且还可以添加属性。&lt;/p&gt;&lt;p&gt;最重要的是，控制台上&lt;code&gt;ruleset.bom.enabled&lt;/code&gt;这个属性，我上面用 arthas &lt;code&gt;vmtool&lt;/code&gt; 看的时候也有，那就可以证明这里的配置，应该就是配置 IlrRulesetArchiveProperties 这个类的；只要是给这个规则集加上 maxIdleTime 是不是就可以使用强引用了？&lt;/p&gt;&lt;p&gt;然后我小心翼翼的点击了那个添加属性的按钮……&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.3782252989301447&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/mgU4gUcibuexTjNZmrvdfKsqQppgJtmo5tXzY1xGc8F8kXa4TKd5JeHOINhFVdmdDksQemAz2CojeWIVOD3PZ1Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1589&quot;/&gt;果然有 maxIdleTime 这个选项，选择 maxIdleTime 之后，给它配置为 0。&lt;/p&gt;&lt;h3&gt;验证结果&lt;/h3&gt;&lt;p&gt;配置完了，还是重启验证一下是不是生效，谁知道这个系统支不支持热刷新呢，改动之后还是重启验证比较稳妥。&lt;/p&gt;&lt;p&gt;先验证该规则集的 properties：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;vmtool --action getInstances --className com.ibm.rules.res.xu.ruleset.internal.CRERulesetImpl --express &#x27;instances[0].getRulesetArchiveProperties()&#x27;&lt;br/&gt;@IlrRulesetArchivePropertiesImpl[&lt;br/&gt;# 新增配置&lt;br/&gt;    @String[ruleset.maxIdleTime]:@String[0],&lt;br/&gt;    @String[ruleset.engine]:@String[cre],&lt;br/&gt;    @String[ruleset.status]:@String[enabled],&lt;br/&gt;    @String[ruleset.bom.enabled]:@String[true],&lt;br/&gt;    @String[ruleset.managedxom.uris]:@String[resuri://ans-nc-xom.zip/54.0,resuri://ruleapp-core-model-1.5.2.jar/2.0],&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从上面可以看到，我们新增的配置，已经生效了，规则集上已经有了这个 maxIdleTime。&lt;/p&gt;&lt;p&gt;再来看看缓存里的引用，是不是已经变成了强引用：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;vmtool --action getInstances --className ilog.rules.res.xu.ruleset.cache.internal.IlrRulesetCacheImpl --express &#x27;instances[0].entries.get(0).rulesetReference&#x27;&lt;br/&gt;&lt;br/&gt;# 这里是强引用&lt;br/&gt;@IlrStrongReference[&lt;br/&gt;    target=@CRERulesetImpl[com.ibm.rules.res.xu.ruleset.internal.CRERulesetImpl@28160472],&lt;br/&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在增加了 maxIdleTime 之后，规则集的缓存就变成了强引用，强引用下就不会再出现因为 GC 被回收的情况了！&lt;/p&gt;&lt;p&gt;用 vmtool 来一遍 fullgc，试试看还会不会重新加载：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;vmtool --action forceGc&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行了十几遍，也没出出现长耗时问题，问题应该是解决了。&lt;/p&gt;&lt;p&gt;接着把这个配置同步到测试环境，跑了三天，我时不时还上去手动 forceGc 一下，没有再出现过这个长耗时的问题了。&lt;/p&gt;&lt;h3&gt;为什么不是每次 GC 后都会出现耗时&lt;/h3&gt;&lt;p&gt;本文开头就提到，每次长耗时之前不久都会有一次 GC 活动，但并不是每次 GC 后都会有一次长耗时。&lt;/p&gt;&lt;p&gt;弱引用维护的对象，并不是说在 GC 时就会被清空；只是在 GC 时，&lt;strong&gt;如果弱引用的对象已经没有其他引用了，才会被回收&lt;/strong&gt;，比如下面这个例子里：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Map&amp;lt;String,Object&amp;gt; dataMap = new HashMap&amp;lt;&amp;gt;();&lt;br/&gt;WeakReference ref = new WeakReference(dataMap);&lt;br/&gt;System.gc();&lt;br/&gt;System.out.println(ref.get());&lt;br/&gt;dataMap = null;&lt;br/&gt;System.gc();&lt;br/&gt;System.out.println(ref.get());&lt;br/&gt;&lt;br/&gt;//output&lt;br/&gt;{}&lt;br/&gt;null&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;第一次 gc 时，ref 里的数据不会被清空，而第二次 gc 前弱引用的数据，已经没有其他任何引用了，此时会被清空。&lt;/p&gt;&lt;p&gt;结合这个系统的问题来看，虽然规则集那里使用弱引用缓存，但如果在 GC 时，调用方还持有规则集对象没有释放，那么这个弱引用的规则集缓存也一样不会清空；所以才会出现这个&lt;strong&gt;不是每次 GC 都会导致重新加载， 但每次重新加载却都是因为 GC 的问题&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;但我认为没有必要继续跟下去了，持有规则集对象的地方在哪，和这个耗时问题关系并不是很大；修改为强引用之后，就不会再有 GC 回收该对象的情况，那还在意谁持有干嘛呢（其实是我懒，没文档还没源码，找问题找的我头都要秃了）&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/mgU4gUcibuexTjNZmrvdfKsqQppgJtmo5BApm6bfsWN7wwNtmCOQ7Id2sWfeNHrEg1icibomsAFIwbibIQFpXjO9Xw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;960&quot;/&gt;&lt;/p&gt;&lt;h2&gt;写在后面&lt;/h2&gt;&lt;p&gt;本来以为需要先反编译，然后修改代码重新打包才能搞定的问题，最后竟然一行代码都没改就解决了，有点小惊喜……&lt;/p&gt;&lt;p&gt;不过这个规则引擎的设计思路还是挺好的，为了节省内存，使用可配置的缓存策略，只是默认使用弱引用来维护规则集太保守了。于大多数服务端场景来说，不差它这点释放的内存，给多少用多少就行，释放了反而会引发更大的问题，重新加载导致的耗时才是最不能接受的。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>73bbe53d8e3e59dad841ec664703d345</guid>
<title>微信小程序基础架构浅析</title>
<link>https://toutiao.io/k/yzi0j3y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.1575&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/j3gficicyOvasIjZpiaTNIPReJVWEJf7UGpmokI3LL4NbQDb8fO48fYROmYPXUhXFN8IdDqPcI1gA6OfSLsQHxB4w/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;作者：billgong，腾讯IEG前端开发工程师。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;微信小程序，简称小程序，英文 mini program。是一种不需要下载安装即可在微信中使用的应用，用户扫描小程序码或搜索小程序即可打开，触手可及，用完即走，不用关心是否安装太多应用的问题。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;小程序技术演进&lt;/span&gt;&lt;/h3&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;内部开放微信原生能力&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;img data-ratio=&quot;0.242728184553661&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvatjGkmbI89QF7J6dubLYj06LRDGlIF0uIAX7ic70kcZnBPLicE3b9Nqy3xTmKDYQ5Kbia2OWKXULGhfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;997&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;使用 WeixinJSBridge 预览图片&lt;/span&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此类 API 最初是提供给腾讯内部一些业务使用，很多外部开发者发现了之后，依葫芦画瓢地使用了，逐渐成为微信中网页开发的事实标准。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;JS-SDK 发布&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2015 年初，微信发布了一整套网页开发工具包，称之为 JS-SDK，开放了拍摄、录音、语音识别、二维码、地图、支付、分享、卡券等几十个 API。让所有开发者都可以使用到微信的原生能力。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img data-ratio=&quot;0.242728184553661&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvatjGkmbI89QF7J6dubLYj06LRDGlIF0uIAX7ic70kcZnBPLicE3b9Nqy3xTmKDYQ5Kbia2OWKXULGhfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;997&quot;/&gt;&lt;span&gt;使用 JS-SDK 调用图片预览组件&lt;/span&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JS-SDK 解决了移动网页使用微信能力不足的问题，通过暴露微信的接口使得 Web 开发者能够拥有更多的能力，然而在更多的能力之外，JS-SDK 的模式并没有解决使用移动网页遇到的体验不良的问题。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;JS-SDK 的不足&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户在访问网页的时候，在浏览器开始显示之前都会有一个白屏的过程，在移动端，受限于设备性能和网络速度，白屏会更加明显。除了白屏，影响 Web 体验的问题还有缺少操作的反馈，主要表现在两个方面：页面切换的生硬和点击的迟滞感。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.657&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatjGkmbI89QF7J6dubLYj06xNdzMEwrLUribgQicDUFv56dIE01o7vf96sDA9JQYP67JgLoz5jKe9iaA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot;/&gt;&lt;figcaption&gt;加载白屏，切换不流畅&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外一些开发者会使用 JS-SDK 做一些，比如假红包，伪造的官方活动等。并利用 JS-SDK 的分享能力变相的去裂变分享到各个群或者朋友圈，由于 JS-SDK 是根据域名来赋予 api 权限的，运营人员封了一个域名后，他们立马用别的域名又继续做坏，要知道注册一个新的域名的成本是很低的。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5944444444444444&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/j3gficicyOvatjGkmbI89QF7J6dubLYj06Qic3sacUkrNgATJGcWnYTo8chZuhHqcSxD13ciaVuNALS1axWaYXZl4A/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么小程序是通过怎样的设计来改进 JS-SDK 的体验和管控上的不足？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;小程序双线程架构&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;具体实现上小程序采用了类 web + 离线包的形式。开发上与 web 类似，门槛较低，开发效率较高。&lt;strong&gt;离线下载和页面预渲染功能&lt;/strong&gt;增强了用户体验，提升了加载速度，解决了 JS-SDK 加载白屏的问题 1。小程序提供了云端更新离线包的功能，可动态更新页面，相对于 app 的更新和发布更为灵活。此外，小程序在离线包的基础上对&lt;strong&gt;切换动画进行优化&lt;/strong&gt;，降低了切换页面导致的迟滞感，缓解了切换不流畅的问题 2。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img data-ratio=&quot;0.3772455089820359&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvatjGkmbI89QF7J6dubLYj06icfgRPfhia5VVbLGCOXJuiaIhQ3cSrz6oQxHheAJib58pQksRGbXfZicp6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1002&quot;/&gt;&lt;span&gt;小程序web+离线包模式&lt;/span&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小程序在架构方面最大的特点是采用了双线程的开发模式，隔离了 JS 逻辑和 UI 渲染。小程序的渲染层和逻辑层分别由 2 个线程管理：渲染层的界面使用了 WebView 进行渲染，逻辑层采用 JsCore 线程运行 JS 脚本。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;逻辑层&lt;/strong&gt;：创建一个单独的线程去执行 JavaScript，在这个环境下执行的都是有关小程序业务逻辑的代码；&lt;strong&gt;&lt;br/&gt;渲染层&lt;/strong&gt;：界面渲染相关的任务全都在 WebView 线程里执行，通过逻辑层代码去控制渲染哪些界面。一个小程序存在多个界面，所以渲染层存在多个 WebView 线程；&lt;strong&gt;&lt;br/&gt;通信&lt;/strong&gt;：这两个线程的通信会经由微信客户端（下文中也会采用 Native 来代指微信客户端）做中转，逻辑层发送网络请求也经由 Native 转发，小程序的通信模型下图所示。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img data-ratio=&quot;0.644&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvatjGkmbI89QF7J6dubLYj06OReSDiaaxkyxfRZn035qCIkxp05bKcFVweh3OkAoPepYoaJxOqTFiaEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1000&quot;/&gt;小程序双线程架构&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JS 逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的 DOM API 和 BOM API，无法操作页面元素，能达到管控的目的，但也限制了开发者的权限：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;不允许开发者把页面跳转到其他在线网页&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不允许开发者直接访问 DOM&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;不允许开发者随意使用 window 上的某些未知的可能有危险的 API&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的逻辑层与 UI 层的隔离，加上小程序的审核和举报机制，使得微信加强对小程序的管控，解决了问题 3。但这也使得开发者无法灵活的进行页面渲染。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;小程序页面渲染&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面已经说了逻辑层无法操作 DOM 变更，那小程序是如何进行页面的渲染呢？小程序基于数据驱动的架构模式，基于 Virtual Dom（React 引入，真实 DOM 的一种 JS 描述方式）的概念，业务侧只需要改变数据即可引起界面变化。其中渲染层提供了带有数据绑定语法的 WXML，逻辑层提供了&lt;span&gt;setData&lt;/span&gt; 等等 API，开发者需要进行界面变化时，只需要通过在逻辑层执行 &lt;span&gt;setData&lt;/span&gt; 把变化的数据通过 Native 层传递到渲染层，小程序会进行 Dom Diff（DOM 结构对比并进行最小化变更的算法）等流程，最后把正确的结果更新在 Dom 树上。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img data-ratio=&quot;0.48951048951048953&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvatjGkmbI89QF7J6dubLYj06uGiabrY2nKjehDU33W6O9bsfbUSAHyKGgypr2mMYAA4rZOmF9736sRQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1001&quot;/&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;figcaption&gt;小程序Virtual DOM渲染&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;完整的通信流程大致如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;逻辑层调用宿主环境的 &lt;span&gt;setData&lt;/span&gt; 方法。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;逻辑层将待传输数据转换成字符串，并拼接到特定的 JS 脚本，最后将数据传输到渲染层。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;渲染层接收到后，WebView JS 线程会对脚本进行编译，得到待更新数据后进入渲染队列，等待 WebView 线程空闲时进行页面渲染。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;WebView 线程开始执行渲染时，待更新数据会合并到视图层保留的原始 data 数据，并将新数据套用在 WXML 片段中得到新的虚拟节点树。经过新虚拟节点树与当前节点树的 diff 对比，将差异部分更新到 UI 视图。同时将新的节点树替换旧节点树，用于下一次重渲染。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;小程序方案与 React Native 对比&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么小程序与现有的混合开发技术类型的异同点在哪？尤其是与 React Native 的区别，小程序技术架构为什么没有使用 React Native?&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;混合开发技术类型&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;现有的混合开发类型，基于 UI 渲染的分类来看，主要有两类：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;基于 WebView UI 的基础方案。市面上主流，例如微信 JS-SDK，通过 JSBridge 完成 H5 和 Native 的双向通讯，从而赋予 H5 一定的原生能力。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;基于 Native UI 的方案，例如 React-Native、Weex、Flutter 等。在赋予 H5 原生 API 能力的基础上，进一步通过 JSBridge 将 JS 解析成虚拟 DOM 传递到 Native，并使用原生渲染。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小程序也属于类型 1，本次我们主要以类型 2 中的 React Native 作为对比分析。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;React Native 技术架构&lt;/span&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;框架&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;React Native 框架主要有三层：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;JS 层：该层提供了各种供开发者使用的组件以及一些工具库（事件分发等）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;C++层：主要处理 java/OC 与 JS 的通信（JSBridge）以及执行 JavaScript（JS 脚本引擎）。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Native 层（Object C/Java 层）：主要包括 UI 渲染器、网络通信等工具库。根据不同操作系统有不同的实现。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;UI 渲染&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;React Native 基于 react 框架(Virtual Dom)来进行 UI 渲染，具体的流程大致如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;首先 JS 层通过 JSX 编写的 Virtual Dom 来构建 Component&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;Native 层将其转成真实 DOM 插入到原生 App 的页面中。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;当有变更，通过 diff 算法生成差异对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最终由 Native 层将差异对象应用到原生 App 的页面元素上。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;通信&lt;/span&gt;&lt;/h5&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;React Native 基于 JSCore 实现 js 与 java/oc 交互，具体流程大致如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;把 JSX 代码解析成 javaScript 代码&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;读取 JS 文件，并利用利用 JS 脚本引擎执行&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;返回一个数组，数组中会描述 OC/Java 对象，描述对象属性和所需要执行的方法，这样就能让这个对象设置属性，并且调用方法。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;figcaption&gt;&lt;img data-ratio=&quot;0.4777777777777778&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/j3gficicyOvatjGkmbI89QF7J6dubLYj068VE7jicezMM9b0JWElZWKGxzReUox6raicGtghcWFKtTS6g2SBtGT1PQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;630&quot;/&gt;&lt;span&gt;Reactive Native架构&lt;/span&gt;&lt;br/&gt;&lt;/figcaption&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;React Native 优缺点&lt;/span&gt;&lt;/h4&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;优势&lt;/span&gt;&lt;/h5&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;原生渲染，性能更好，用户体验较好；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;React 生态较好，对前端开发友好；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;hybrid 技术跨平台开发，成本及难度低于原生；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可热更新，能够方便迭代。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h5 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;劣势&lt;/span&gt;&lt;/h5&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;支持的样式是 CSS 的子集，会满足不了 Web 开发者日渐增长的需求；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;现有能力下还存在的一些不稳定问题，比如性能、Bug 等；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;把渲染工作全都交由客户端原生渲染，会有更接近原生的体验，但实际上一些简单的界面元素使用 Web 技术渲染完全能胜任；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;React Native 之前爆出了一个开源协议问题（Facebook BSD+Patents ，大致内容是使用基于 Facebook BSD+Patents 协议的开源项目的开发者，未来要是因为专利问题与 Facebook 产生纠纷，那么 Facebook 将有权停止你使用该开源项目），这对于之后也是存在隐患的。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;小程序不选择 React Native 原因&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;据小程序开发人员告知的原因如下：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;React Native 只支持 CSS 的子集，作为一个开放的生态，需要告知开发者哪些 CSS 属性能用，哪些不能用，这样的开发体验较差；（&lt;strong&gt;对应上面的劣势 1&lt;/strong&gt;）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;React Native 本身存在一些问题，这些依赖 RN 的修复，同时这样就变成太过依赖客户端发版本去解决开发者那边的 Bug，修复周期太长。（&lt;strong&gt;对应上面的劣势 2&lt;/strong&gt;）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;React Native 前阵子还搞出了一个开源协议问题，来说也是存在隐患的。（&lt;strong&gt;对应上面的劣势 4&lt;/strong&gt;）&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;小程序与 React Native 相同点&lt;/span&gt;&lt;/h4&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;都具有 hybrid 技术的优点：接近原生的体验，跨平台开发&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;使用 Web 相关技术框架来编写业务代码，React Native 为 React 框架，小程序为小程序开发框架。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;各自实现了跨语言通讯方案完成 Native(Java/Objective-c/…)端与 JavaScript(小程序中为渲染层和逻辑层)的通讯&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;小程序与 React Native 不同点&lt;/span&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;小程序使用浏览器内核 WebView 来渲染界面(小部分原生组件由客户端参与渲染)，界面主要由成熟的 Web 技术渲染，辅之大量的接口提供丰富的客户端原生能力，而 React Native 是客户端原生渲染。理论上 React Native 相对于 WebView 的性能更好，但小程序的类 web 开发对开发来说入门相对简单，像是一种开发效率与性能的双刃剑。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;小程序开发注意事项&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于上面的架构分析，我们在开发中需要注意是：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;避免使用操作操作 DOM 的 npm 包。由于逻辑层和渲染层隔离，逻辑层无法操作 DOM/BOM API，所以需要使用 DOM/BOM API 相关的 npm 包和库中不可使用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;避免频繁调用&lt;code&gt;setData&lt;/code&gt;。由于&lt;code&gt;setData&lt;/code&gt;中的数据不仅需要通过 Native 层传递到渲染层，通过 DOM diff 算法等渲染成最终页面，所以需要尽量减少&lt;code&gt;setData&lt;/code&gt;的使用以避免性能问题。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;避免&lt;code&gt;setData&lt;/code&gt;传递大量的新数据。数据的传输会经历跨线程传输和脚本编译的过程，当数据量过大，会增加脚本编译的执行时间，占用 WebView JS 线程，从而影响到最终的渲染性能。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;参考文档&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/&quot; data-linktype=&quot;2&quot;&gt;小程序官方文档&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://caseylu.gitee.io/2020/08/27/40-xiao-cheng-xu-yuan-li-ji-rn-yu-flutter-de-dui-bi/&quot; data-linktype=&quot;2&quot;&gt;小程序原理及 RN 与 Flutter 的对比&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1533232&quot; data-linktype=&quot;2&quot;&gt;React-Native 与小程序的底层框架比较&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://www.xuanbiyijue.com/2021/03/13/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%EF%BC%88%E5%BA%94%E8%AF%A5%E6%98%AF%E5%85%A8%E7%BD%91%E6%9C%80%E5%85%A8%E4%BA%86%EF%BC%89/&quot; data-linktype=&quot;2&quot;&gt;多端小程序原理分析&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://developers.weixin.qq.com/community/develop/article/doc/000a4c1620c188f3adf7db9ab5b413&quot; data-linktype=&quot;2&quot;&gt;小程序架构设计(一)&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;a href=&quot;https://developers.weixin.qq.com/community/develop/article/doc/000c8eba1ec3b8c7ce287954c53c13&quot; data-linktype=&quot;2&quot;&gt;小程序架构设计(二)&lt;/a&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;腾讯程序员视频号&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;最新视频欢迎点赞&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section class=&quot;channels_iframe_wrp&quot;&gt;&lt;mpvideosnap class=&quot;js_uneditable custom_select_card channels_iframe&quot; data-pluginname=&quot;videosnap&quot; data-id=&quot;export/UzFfAgtgekIEAQAAAAAAHiYAS8lMOQAAAAstQy6ubaLX4KHWvLEZgBPE46MEDxUtNZ__zNPgMIuTNtFzNmOmXHNudWdXNE15&quot; data-url=&quot;https://findermp.video.qq.com/251/20304/stodownload?encfilekey=RBfjicXSHKCOONJnTbRmmlD8cOQPXE48ibKMm7ZIkvCFhC69YcAEavsOlfKdWOiaq72MoxB7yM5dVUN1r1MIoX8PEJic1Vric8yEPN2v9FVCQktTnBNDY1r5Qjx5icN1X7WEu8yUzBdcN9nDjSiapyNInAxRVW8JEMHXXnic58vGG5G8FjM&amp;amp;adaptivelytrans=0&amp;amp;bizid=1023&amp;amp;dotrans=0&amp;amp;hy=SH&amp;amp;idx=1&amp;amp;m=058210299e44e3a290cf292b07b190d5&amp;amp;token=x5Y29zUxcibBiaGHtmXXicGxu57acwcpDHUyZTa5HdmYwkyW3pesXBFHrKMcbUEt6V2&quot; data-headimgurl=&quot;http://wx.qlogo.cn/finderhead/I7awtksbibjQe7RZAy84xEecUymmic8cw4v7Y2zbnVDuo/0&quot; data-username=&quot;v2_060000231003b20faec8c6e08e1ac1d4cf06ea31b07760a16cba92d83444bd9a5d9d55ffaede@finder&quot; data-nickname=&quot;腾讯程序员&quot; data-desc=&quot;据说99%的人都不知道的搜索技巧，大幅提升搜索效率。 #搜索 #效率&quot; data-nonceid=&quot;42573460435425242&quot; data-type=&quot;video&quot;/&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5d7c4498cfd3866fab6042b4a4f54f82</guid>
<title>云原生究竟是什么</title>
<link>https://toutiao.io/k/mjupr57</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p&gt;要理解什么是云原生，就要从云原生的名字说起，云原生的英文名是cloud native, 很显然，其含义就包含云和原生两部分。云就是说应用是运行在云上，而非本地。原生，就是说应用要以最适合云的方式去运行，而不是仅仅从本地迁移到应用上。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;那么，什么样的应用才是适合云的呢？其实就是能最大化利用云的能力，发挥云的优势。&lt;/p&gt;&lt;p&gt;而云计算的核心优势，其实无非就是将更多的资源集中管理，统一调配，也就更方便按需灵活配置资源，提高资源利用率。&lt;/p&gt;&lt;p&gt;类比一下，相信很多人用过storm等流式框架，它们的优势是什么呢？其中一个重要的因素就是可以将一个复杂的流程拆解成若干个子节点，每个节点可以根据其需求配置不同的并发度，并发需求高的节点可以获得更多资源。这样，资源利用率也就提升了。&lt;/p&gt;&lt;p&gt;对微服务来说，也是类似，将不同功能拆分成不同的服务，就可以单独对更小粒度的功能单独做扩缩容。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;值得注意的是，拆分不仅包含拆分不同的业务，也包括将业务代码、三方软件（第三方库）、非功能特性（高可用、安全、可观测性等三类代码进行分离。&lt;/p&gt;&lt;p&gt;单纯业务的拆分，实际上从软件开发的非常早期的阶段就在进行了。而伴随着云原生概念兴起的趋势，正是将云应用中的非业务代码部分进行最大化的剥离，从而让云设施接管应用中原有的大量非功能特性（如弹性、韧性、安全、可观测性、灰度等），也就是所谓的service mesh.&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由于云上的资源和应用并不是强绑定的，为了能更方便的利用资源，我们需要一种更通用的运行形势，让应用可以和运行环境有一定程度的解耦。这就是容器技术。容器提供了一种逻辑打包机制，以这种机制打包的应用可以脱离其实际运行的环境。利用这种脱离，不管目标环境是私有数据中心、公有云，还是开发者的个人笔记本电脑，您都可以轻松、一致地部署基于容器的应用。容器化使开发者和 IT 运营团队的关注点泾渭分明 - 开发者专注于应用逻辑和依赖项，而 IT 运营团队可以专注于部署和管理，不必为具体的软件版本和应用特有的配置等应用细节分心。&lt;/p&gt;&lt;p&gt;另一方面，服务更小粒度的拆分之后，系统本身的复杂度显然会有所提升，比如本地调用变成了网络请求，调用链也无法通过代码结构体现。因此，运维上需要更加智能化和自动化，要保障单个服务更强的稳定性；同时需要一个强大的监控系统，要能够分析出各个微服务之间的依赖关系，还要快速检测出系统中的异常。&lt;/p&gt;&lt;p&gt;同时，在单个服务规模更小，且监控数据很完善的前提下，我们有可能去更频繁的去部署，甚至每次更改之后直接部署到生产环境。如果部署有问题，我们可以通过监控及时的发现，从而将损失控制在更小的程度。而小规模的部署，也让我们更容易去定位问题或者回滚。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;从上边的分析中，我们可以整理出和云原生相关的一些关键词，比如服务化、弹性、可观测、韧性、自动化等等，这些关键词可以被总结成4类，即微服务、DevOps、持续交付和容器化。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;这4类的关键特征如下：&lt;/p&gt;&lt;p&gt;微服务：可被独立部署、更新、重启、scale&lt;/p&gt;&lt;p&gt;DevOps:  自动化、快速、开发运维协同&lt;/p&gt;&lt;p&gt;持续交付：频繁发布、快速反馈&lt;/p&gt;&lt;p&gt;容器化：逻辑打包机制&lt;/p&gt;&lt;p&gt;上边讲了很多理论上的知识，那么，要采用云原生的话，有什么具体的执行路径呢？可以从以下几个方面考虑：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;业务服务的拆分：这是软件开发中非常基础的一件事，拆分需要满足SOLID原则等基础的设计原则。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;完善的监控体系:  包括log, trace, metric, alert几个维度的信息都要收集起来，其中log侧重于记录代码运行过程中的信息，trace主要用于追踪同一请求在不同服务下的流转，metric是针对系统运行状况的监控，alert则是针对异常状态的报警。业界也已经有了很多开源的实现，比如prometheus, jaeger等等&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;容器及容器编排：这一部分基本就是 docker和k8s&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;中间件mesh化：即业务应用中只保留很薄的一层client, 中间件的主要逻辑放在在mesh层&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;DevOps和持续交付：这个主要是开发流程、和开发运维协作上的很多流程的事。在云环境下，我们更推崇小批量、频繁发布、快速反馈的模式。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我是流沙，希望通过这篇文章，可以让大家更清晰的理解云原生究竟是什么。其实，云原生说起来很简单，就是采用各种方式去更好的利用云上的资源。而具体说起来，它又是一套非常庞大的体系，涵盖了从开发到运维的方方面面。欢迎大家关注我的公众号(Mobility),  知乎账号 (https://www.zhihu.com/people/hobermallow) ，或者个人网站 (lichuanyang.top), 我会在后续的文章里逐渐展开讲讲云原生的方方面面。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>284e86781884d95b2c584438ddba8d44</guid>
<title>分享两个在开发中需注意的小点</title>
<link>https://toutiao.io/k/wf7tswe</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;文章目录：&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;不要使用 + 和 fmt.Sprintf 操作字符串&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要使用 &lt;code&gt;+&lt;/code&gt; 和 &lt;code&gt;fmt.Sprintf&lt;/code&gt; 操作字符串，虽然很方便，但是真的很慢！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们要使用 &lt;code&gt;bytes.NewBufferString&lt;/code&gt; 进行处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基准测试如下：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;+&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func BenchmarkStringOperation1(b *testing.B)  {&lt;br/&gt; b.ResetTimer()&lt;br/&gt; str := &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := 0; i &amp;lt; b.N; i++ {&lt;br/&gt;  str += &lt;span&gt;&quot;golang&quot;&lt;/span&gt;&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 输出&lt;br/&gt;goos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: demo/stringoperation&lt;br/&gt;cpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHz&lt;br/&gt;BenchmarkStringOperation1&lt;br/&gt;BenchmarkStringOperation1-12       353318     114135 ns/op&lt;br/&gt;PASS&lt;br/&gt;&lt;br/&gt;Process finished with the &lt;span&gt;exit&lt;/span&gt; code 0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;fmt.Sprintf&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func BenchmarkStringOperation2(b *testing.B)  {&lt;br/&gt; b.ResetTimer()&lt;br/&gt; str := &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := 0; i &amp;lt; b.N; i++ {&lt;br/&gt;  str = fmt.Sprintf(&lt;span&gt;&quot;%s%s&quot;&lt;/span&gt;, str, &lt;span&gt;&quot;golang&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 输出&lt;br/&gt;goos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: demo/stringoperation&lt;br/&gt;cpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHz&lt;br/&gt;BenchmarkStringOperation2&lt;br/&gt;BenchmarkStringOperation2-12       280140     214098 ns/op&lt;br/&gt;PASS&lt;br/&gt;&lt;br/&gt;Process finished with the &lt;span&gt;exit&lt;/span&gt; code 0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;bytes.NewBufferString&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func BenchmarkStringOperation3(b *testing.B)  {&lt;br/&gt; b.ResetTimer()&lt;br/&gt; strBuf := bytes.NewBufferString(&lt;span&gt;&quot;&quot;&lt;/span&gt;)&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := 0; i &amp;lt; b.N; i++ {&lt;br/&gt;  strBuf.WriteString(&lt;span&gt;&quot;golang&quot;&lt;/span&gt;)&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 输出&lt;br/&gt;goos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: demo/stringoperation&lt;br/&gt;cpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHz&lt;br/&gt;BenchmarkStringOperation3&lt;br/&gt;BenchmarkStringOperation3-12     161292136          8.582 ns/op&lt;br/&gt;PASS&lt;br/&gt;&lt;br/&gt;Process finished with the &lt;span&gt;exit&lt;/span&gt; code 0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;对于固定字段的键值对，不要使用 map[string]interface{}&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于固定字段的键值对，不要使用 &lt;code&gt;map[string]interface{}&lt;/code&gt;!&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们要使用&lt;code&gt;临时 Struct&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基准测试如下：&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;map[string]interface{}&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func BenchmarkStructOperation1(b *testing.B) {&lt;br/&gt; b.ResetTimer()&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := 0; i &amp;lt; b.N; i++ {&lt;br/&gt;  var demo = map[string]interface{}{}&lt;br/&gt;  demo[&lt;span&gt;&quot;Name&quot;&lt;/span&gt;] = &lt;span&gt;&quot;Tom&quot;&lt;/span&gt;&lt;br/&gt;  demo[&lt;span&gt;&quot;Age&quot;&lt;/span&gt;] = 30&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 输出&lt;br/&gt;goos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: demo/structoperation&lt;br/&gt;cpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHz&lt;br/&gt;BenchmarkStructOperation1&lt;br/&gt;BenchmarkStructOperation1-12     43300134         27.97 ns/op&lt;br/&gt;PASS&lt;br/&gt;&lt;br/&gt;Process finished with the &lt;span&gt;exit&lt;/span&gt; code 0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;临时 Struct&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;func BenchmarkStructOperation2(b *testing.B) {&lt;br/&gt; b.ResetTimer()&lt;br/&gt; &lt;span&gt;for&lt;/span&gt; i := 0; i &amp;lt; b.N; i++ {&lt;br/&gt;  var demo struct {&lt;br/&gt;   Name string&lt;br/&gt;   Age  int&lt;br/&gt;  }&lt;br/&gt;  demo.Name = &lt;span&gt;&quot;Tom&quot;&lt;/span&gt;&lt;br/&gt;  demo.Age = 30&lt;br/&gt; }&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;// 输出&lt;br/&gt;oos: darwin&lt;br/&gt;goarch: amd64&lt;br/&gt;pkg: demo/structoperation&lt;br/&gt;cpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHz&lt;br/&gt;BenchmarkStructOperation2&lt;br/&gt;BenchmarkStructOperation2-12     1000000000          0.2388 ns/op&lt;br/&gt;PASS&lt;br/&gt;&lt;br/&gt;Process finished with the &lt;span&gt;exit&lt;/span&gt; code 0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;小结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;你有类似这样的注意点吗，欢迎留言~&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面推荐阅读的这几篇文章也是关于开发中需要知道的小技术点，更多技术细节和代码讨论，可以加入到我的星球。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;推荐阅读&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.5493333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/go9jpG3BuhSP7wibS4BHtlu4hduFYq8VbSAgRic8ib6hdd6qTRGxYSic7UFF9yPyGd4pGUw1XicibFRlGHBe9RJ09Smw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;750&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MjM5NDM4MDIwNw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/go9jpG3BuhQHrM0sshKxdaibyDNjXooZvnwwy0yRjdhlXrtVUkJSvQib4Ppwib1v5HucaRc8WPtgvhPBicMeiadAv9Q/0?wx_fmt=png&quot; data-nickname=&quot;新亮笔记&quot; data-alias=&quot;XinLiangTalk&quot; data-signature=&quot;程序猿的打怪升级之路。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;/&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>