<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>a99e2d67a4c9cb374f07f87917779344</guid>
<title>让 JWT 来保护你的接口服务</title>
<link>https://toutiao.io/k/70kuvcy</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家好，我是大尧。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以前写过一篇关于接口服务规范的文章，&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU5NjA3MjQ5MA==&amp;amp;mid=2247485324&amp;amp;idx=1&amp;amp;sn=b8329a86e1ac4abb540af191b471d613&amp;amp;chksm=fe6906c9c91e8fdf04fa83a0d2c1f9cc7aee054bc1fe061e254da238b3bd7dd2ae2b544efe63&amp;amp;token=1337536302&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;原文在此&lt;/a&gt;，里面关于安全性问题重点讲述了通过&lt;code&gt;appid&lt;/code&gt;，&lt;code&gt;appkey&lt;/code&gt;，&lt;code&gt;timestamp&lt;/code&gt;，&lt;code&gt;nonce&lt;/code&gt;以及&lt;code&gt;sign&lt;/code&gt;来获取&lt;code&gt;token&lt;/code&gt;，使用&lt;code&gt;token&lt;/code&gt;来保障接口服务的安全。今天我们来讲述一种更加便捷的方式，使用&lt;code&gt;jwt&lt;/code&gt;来生成token。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一、JWT是什么&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;JSON Web Token&lt;/code&gt;（&lt;code&gt;JWT&lt;/code&gt;） 定义了一种紧凑且自包含的方式，用于在各方之间作为 JSON 对象安全地传输信息。该信息可以被验证和信任，因为它是经过数字签名的。&lt;code&gt;JWT&lt;/code&gt;可以设置有效期。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;JWT&lt;/code&gt;是一个很长的字符串，包含了&lt;code&gt;Header&lt;/code&gt;，&lt;code&gt;Playload&lt;/code&gt;和&lt;code&gt;Signature&lt;/code&gt;三部分内容，中间用&lt;code&gt;.&lt;/code&gt;进行分隔。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Headers&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Headers&lt;/code&gt;部分描述的是&lt;code&gt;JWT&lt;/code&gt;的基本信息，一般会包含签名算法和令牌类型，数据如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;    &lt;span&gt;&quot;alg&quot;&lt;/span&gt;: &lt;span&gt;&quot;RS256&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;typ&quot;&lt;/span&gt;: &lt;span&gt;&quot;JWT&quot;&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Playload&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Playload&lt;/code&gt;就是存放有效信息的地方，&lt;code&gt;JWT&lt;/code&gt;规定了以下7个字段，建议但不强制使用：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;iss: jwt签发者&lt;br/&gt;sub: jwt所面向的用户&lt;br/&gt;aud: 接收jwt的一方&lt;br/&gt;exp: jwt的过期时间，这个过期时间必须要大于签发时间&lt;br/&gt;nbf: 定义在什么时间之前，该jwt都是不可用的&lt;br/&gt;iat: jwt的签发时间&lt;br/&gt;jti: jwt的唯一身份标识，主要用来作为一次性token&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，我们还可以自定义内容&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;{&lt;br/&gt;    &lt;span&gt;&quot;name&quot;&lt;/span&gt;:&lt;span&gt;&quot;Java旅途&quot;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&quot;age&quot;&lt;/span&gt;:&lt;span&gt;18&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;Signature&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;Signature&lt;/code&gt;是将&lt;code&gt;JWT&lt;/code&gt;的前面两部分进行加密后的字符串，将&lt;code&gt;Headers&lt;/code&gt;和&lt;code&gt;Playload&lt;/code&gt;进行&lt;code&gt;base64&lt;/code&gt;编码后使用&lt;code&gt;Headers&lt;/code&gt;中规定的加密算法和密钥进行加密，得到&lt;code&gt;JWT&lt;/code&gt;的第三部分。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;二、JWT生成和解析token&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在应用服务中引入&lt;code&gt;JWT&lt;/code&gt;的依赖&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;io.jsonwebtoken&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;jjwt&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&amp;lt;&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;0.9.0&lt;span&gt;&amp;lt;/&lt;span&gt;version&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根据&lt;code&gt;JWT&lt;/code&gt;的定义生成一个使用&lt;code&gt;RSA&lt;/code&gt;算法加密的，有效期为&lt;code&gt;30分钟&lt;/code&gt;的token&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String &lt;span&gt;createToken&lt;/span&gt;&lt;span&gt;(User user)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Jwts.builder()&lt;br/&gt;        .claim(&lt;span&gt;&quot;name&quot;&lt;/span&gt;,user.getName())&lt;br/&gt;        .claim(&lt;span&gt;&quot;age&quot;&lt;/span&gt;,user.getAge())&lt;br/&gt;        &lt;span&gt;// rsa加密&lt;/span&gt;&lt;br/&gt;        .signWith(SignatureAlgorithm.RS256, RsaUtil.getPrivateKey(PRIVATE_KEY))&lt;br/&gt;        &lt;span&gt;// 有效期30分钟&lt;/span&gt;&lt;br/&gt;        .setExpiration(DateTime.now().plusSeconds(&lt;span&gt;30&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt;).toDate())&lt;br/&gt;        .compact();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;登录接口验证通过后，调用&lt;code&gt;JWT&lt;/code&gt;生成带有用户标识的token响应给用户，在接下来的请求中，头部携带&lt;code&gt;token&lt;/code&gt;进行验签，验签通过后，正常访问应用服务。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Claims &lt;span&gt;parseToken&lt;/span&gt;&lt;span&gt;(String token)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception&lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; Jwts&lt;br/&gt;        .parser()&lt;br/&gt;        .setSigningKey(RsaUtil.getPublicKey(PUBLIC_KEY))&lt;br/&gt;        .parseClaimsJws(token)&lt;br/&gt;        .getBody();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;三、token续签问题&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面讲述了关于&lt;code&gt;JWT&lt;/code&gt;验证的过程，现在我们考虑这样一个问题，客户端携带&lt;code&gt;token&lt;/code&gt;访问下单接口，&lt;code&gt;token&lt;/code&gt;验签通过，客户端下单成功，返回下单结果，然后客户端带着&lt;code&gt;token&lt;/code&gt;调用支付接口进行支付，验签的时候发现token失效了，这时候应该怎么办？只能告诉用户&lt;code&gt;token&lt;/code&gt;失效，然后让用户重新登录获取&lt;code&gt;token&lt;/code&gt;？这种体验是非常不好的，&lt;code&gt;oauth2&lt;/code&gt;在这方面做的比较好，除了签发&lt;code&gt;token&lt;/code&gt;，还会签发&lt;code&gt;refresh_token&lt;/code&gt;，当&lt;code&gt;token&lt;/code&gt;过期后，会去调用&lt;code&gt;refresh_token&lt;/code&gt;重新获取&lt;code&gt;token&lt;/code&gt;，如果&lt;code&gt;refresh_token&lt;/code&gt;也过期了，那么再提示用户去登录。现在我们模拟&lt;code&gt;oauth2&lt;/code&gt;的实现方式来完成&lt;code&gt;JWT&lt;/code&gt;的&lt;code&gt;refresh_token&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;思路大概就是用户登录成功后，签发&lt;code&gt;token&lt;/code&gt;的同时，生成一个加密串作为&lt;code&gt;refresh_token&lt;/code&gt;，&lt;code&gt;refresh_token&lt;/code&gt;存放在&lt;code&gt;redis&lt;/code&gt;中，设置合理的过期时间（一般会将&lt;code&gt;refresh_token&lt;/code&gt;的过期时间设置的比较久一点）。然后将&lt;code&gt;token&lt;/code&gt;和&lt;code&gt;refresh_token&lt;/code&gt;响应给客户端。伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@PostMapping&lt;/span&gt;(&lt;span&gt;&quot;getToken&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; ResultBean &lt;span&gt;getToken&lt;/span&gt;&lt;span&gt;(@RequestBody LoingUser user)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    ResultBean resultBean = &lt;span&gt;new&lt;/span&gt; ResultBean();&lt;br/&gt;    &lt;span&gt;// 用户信息校验失败，响应错误&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(!user){&lt;br/&gt;        resultBean.fillCode(&lt;span&gt;401&lt;/span&gt;,&lt;span&gt;&quot;账户密码不正确&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; resultBean;&lt;br/&gt;    }&lt;br/&gt;    String token = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    String refresh_token = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        &lt;span&gt;// jwt 生成的token&lt;/span&gt;&lt;br/&gt;        token = JwtUtil.createToken(user);&lt;br/&gt;        &lt;span&gt;// 刷新token&lt;/span&gt;&lt;br/&gt;        refresh_token = Md5Utils.hash(System.currentTimeMillis()+&lt;span&gt;&quot;&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;// refresh_token过期时间为24小时&lt;/span&gt;&lt;br/&gt;        redisUtils.set(&lt;span&gt;&quot;refresh_token:&quot;&lt;/span&gt;+refresh_token,token,&lt;span&gt;30&lt;/span&gt;*&lt;span&gt;24&lt;/span&gt;*&lt;span&gt;60&lt;/span&gt;*&lt;span&gt;60&lt;/span&gt;);&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        e.printStackTrace();&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    Map&amp;lt;String,Object&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;    map.put(&lt;span&gt;&quot;access_token&quot;&lt;/span&gt;,token);&lt;br/&gt;    map.put(&lt;span&gt;&quot;refresh_token&quot;&lt;/span&gt;,refresh_token);&lt;br/&gt;    map.put(&lt;span&gt;&quot;expires_in&quot;&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;*&lt;span&gt;60&lt;/span&gt;*&lt;span&gt;60&lt;/span&gt;);&lt;br/&gt;    resultBean.fillInfo(map);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; resultBean;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;客户端调用接口时，在请求头中携带&lt;code&gt;token&lt;/code&gt;，在拦截器中拦截请求，验证&lt;code&gt;token&lt;/code&gt;的有效性，如果验证&lt;code&gt;token&lt;/code&gt;失败，则去redis中判断是否是&lt;code&gt;refresh_token&lt;/code&gt;的请求，如果&lt;code&gt;refresh_token&lt;/code&gt;验证也失败，则给客户端响应鉴权异常，提示客户端重新登录，伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;HttpHeaders headers = request.getHeaders();&lt;br/&gt;&lt;span&gt;// 请求头中获取令牌&lt;/span&gt;&lt;br/&gt;String token = headers.getFirst(&lt;span&gt;&quot;Authorization&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// 判断请求头中是否有令牌&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (StringUtils.isEmpty(token)) {&lt;br/&gt;    resultBean.fillCode(&lt;span&gt;401&lt;/span&gt;,&lt;span&gt;&quot;鉴权失败，请携带有效token&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; resultBean;&lt;br/&gt;}&lt;br/&gt;&lt;span&gt;if&lt;/span&gt;(!token.contains(&lt;span&gt;&quot;Bearer&quot;&lt;/span&gt;)){&lt;br/&gt;    resultBean.fillCode(&lt;span&gt;401&lt;/span&gt;,&lt;span&gt;&quot;鉴权失败，请携带有效token&quot;&lt;/span&gt;);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; resultBean;&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;token = token.replace(&lt;span&gt;&quot;Bearer &quot;&lt;/span&gt;,&lt;span&gt;&quot;&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;// 如果请求头中有令牌则解析令牌&lt;/span&gt;&lt;br/&gt;&lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;    Claims claims = TokenUtil.parseToken(token).getBody();&lt;br/&gt;} &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;    e.printStackTrace();&lt;br/&gt;    String refreshToken = redisUtils.get(&lt;span&gt;&quot;refresh_token:&quot;&lt;/span&gt; + token)+&lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt;(StringUtils.isBlank(refreshToken) || &lt;span&gt;&quot;null&quot;&lt;/span&gt;.equals(refreshToken)){&lt;br/&gt;        resultBean.fillCode(&lt;span&gt;403&lt;/span&gt;,&lt;span&gt;&quot;refresh_token已过期，请重新获取token&quot;&lt;/span&gt;);&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; resultbean;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;refresh_token&lt;/code&gt;来换取&lt;code&gt;token&lt;/code&gt;的伪代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;@PostMapping&lt;/span&gt;(&lt;span&gt;&quot;refreshToken&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; Result &lt;span&gt;refreshToken&lt;/span&gt;&lt;span&gt;(String token)&lt;/span&gt;&lt;/span&gt;{&lt;br/&gt;&lt;br/&gt;    ResultBean resultBean = &lt;span&gt;new&lt;/span&gt; ResultBean();&lt;br/&gt;    String refreshToken = redisUtils.get(TokenConstants.REFRESHTOKEN + token)+&lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;    String access_token = &lt;span&gt;null&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;try&lt;/span&gt; {&lt;br/&gt;        Claims claims = JwtUtil.parseToken(refreshToken);&lt;br/&gt;        String username = claims.get(&lt;span&gt;&quot;username&quot;&lt;/span&gt;)+&lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;        String password = claims.get(&lt;span&gt;&quot;password&quot;&lt;/span&gt;)+&lt;span&gt;&quot;&quot;&lt;/span&gt;;&lt;br/&gt;        LoginUser loginUser = &lt;span&gt;new&lt;/span&gt; LoginUser();&lt;br/&gt;        loginUser.setUsername(username);&lt;br/&gt;        loginUser.setPassword(password);&lt;br/&gt;        access_token = JwtUtil.createToken(loginUser);&lt;br/&gt;    } &lt;span&gt;catch&lt;/span&gt; (Exception e) {&lt;br/&gt;        e.printStackTrace();&lt;br/&gt;    }&lt;br/&gt;    Map&amp;lt;String,Object&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;();&lt;br/&gt;    map.put(&lt;span&gt;&quot;access_token&quot;&lt;/span&gt;,access_token);&lt;br/&gt;    map.put(&lt;span&gt;&quot;refresh_token&quot;&lt;/span&gt;,token);&lt;br/&gt;    map.put(&lt;span&gt;&quot;expires_in&quot;&lt;/span&gt;,&lt;span&gt;30&lt;/span&gt;*&lt;span&gt;60&lt;/span&gt;);&lt;br/&gt;    resultBean.fillInfo(map);&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; resultBean;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面的分析，我们简单的实现了&lt;code&gt;token&lt;/code&gt;的签发，验签以及续签问题，&lt;code&gt;JWT&lt;/code&gt;作为一个轻量级的鉴权框架，使用起来非常方便，但是也会存在一些问题，&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;JWT&lt;/code&gt;的&lt;code&gt;Playload&lt;/code&gt;部分只是经过base64编码，这样我们的信息其实就完全暴露了，一般不要将敏感信息存放在&lt;code&gt;JWT&lt;/code&gt;中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;JWT&lt;/code&gt;生成的&lt;code&gt;token&lt;/code&gt;比较长，每次在请求头中携带&lt;code&gt;token&lt;/code&gt;，导致请求偷会比较大，有一定的性能问题。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;code&gt;JWT&lt;/code&gt;生成后，服务端无法废弃，只能等待&lt;code&gt;JWT&lt;/code&gt;主动过期。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面这段是我网上看到的一段关于&lt;code&gt;JWT&lt;/code&gt;比较适用的场景:&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如，用户注册后发一封邮件让其激活账户，通常邮件中需要有一个链接，这个链接需要具备以下的特性：能够标识用户，该链接具有时效性（通常只允许几小时之内激活），不能被篡改以激活其他可能的账户，一次性的。这种场景就适合使用&lt;code&gt;JWT&lt;/code&gt;。&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>cdf3c20b2d130443264550d9dd505610</guid>
<title>实战篇：断点续传？文件秒传？手撸大文件上传</title>
<link>https://toutiao.io/k/6r8vmz2</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI5MDg2NjEzNA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpMAn4Ha81WVBfsKnC9ficVemZff27LiaSoKX83JqwnNmrNhb4D4oAjW7wiaDwtkLTTCRs1A1hanfNu9g/0?wx_fmt=png&quot; data-nickname=&quot;阿Q说代码&quot; data-alias=&quot;AQ_Shuo&quot; data-signature=&quot;专注于后端技术栈分享：文章风格多变、配图通俗易懂、故事生动有趣&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;各位看官大家好，今天给大家分享的又是一篇实战文章，希望大家能够喜欢。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;开味菜&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近接到一个新的需求，需要上传&lt;code&gt;2G&lt;/code&gt;左右的视频文件，用测试环境的&lt;code&gt;OSS&lt;/code&gt;试了一下，上传需要十几分钟，再考虑到公司的资源问题，果断放弃该方案。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一提到大文件上传，我最先想到的就是各种网盘了，现在大家都喜欢将自己收藏的&lt;strong&gt;「小电影」&lt;/strong&gt;上传到网盘进行保存。网盘一般都支持断点续传和文件秒传功能，减少了网络波动和网络带宽对文件的限制，大大提高了用户体验，让人爱不释手。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到这，大家先来了解一下这几个概念：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「文件分块」&lt;/strong&gt;：将大文件拆分成小文件，将小文件上传\下载，最后再将小文件组装成大文件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「断点续传」&lt;/strong&gt;：在文件分块的基础上，将每个小文件采用单独的线程进行上传\下载，如果碰到网络故障，可以从已经上传\下载的部分开始继续上传\下载未完成的部分，而没有必要从头开始上传\下载；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;「文件秒传」&lt;/strong&gt;：资源服务器中已经存在该文件，其他人上传时直接返回该文件的URI。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;RandomAccessFile&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;平时我们都会使用&lt;code&gt;FileInputStream&lt;/code&gt;，&lt;code&gt;FileOutputStream&lt;/code&gt;，&lt;code&gt;FileReader&lt;/code&gt;以及&lt;code&gt;FileWriter&lt;/code&gt;等&lt;code&gt;IO&lt;/code&gt;流来读取文件，今天我们来了解一下&lt;code&gt;RandomAccessFile&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它是一个直接继承&lt;code&gt;Object&lt;/code&gt;的独立的类，底层实现中它实现的是&lt;code&gt;DataInput&lt;/code&gt;和&lt;code&gt;DataOutput&lt;/code&gt;接口。该类支持随机读取文件，随机访问文件类似于文件系统中存储的大字节数组。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的实现基于&lt;strong&gt;「文件指针」&lt;/strong&gt;（一种游标或者指向隐含数组的索引），文件指针可以通过&lt;code&gt;getFilePointer&lt;/code&gt;方法读取，也可以通过&lt;code&gt;seek&lt;/code&gt;方法设置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;输入时从文件指针开始读取字节，并使文件指针超过读取的字节，如果写入超过隐含数组当前结尾的输出操作会导致扩展数组。该类有四种模式可供选择：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;r：以只读方式打开文件，如果执行写入操作会抛出&lt;code&gt;IOException&lt;/code&gt;;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;rw：以读、写方式打开文件，如果文件不存在，则尝试创建文件；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;rws：以读、写方式打开文件，要求对文件内容或元数据的每次更新都同步写入底层存储设备；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;rwd：以读、写方式打开文件，要求对文件内容的每次更新都同步写入底层存储设备；&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;code&gt;rw&lt;/code&gt;模式下，默认是使用&lt;code&gt;buffer&lt;/code&gt;的，只有&lt;code&gt;cache&lt;/code&gt;满的或者使用&lt;code&gt;RandomAccessFile.close()&lt;/code&gt;关闭流的时候才真正的写到文件。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;API&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、&lt;code&gt;void seek(long pos)&lt;/code&gt;：设置下一次读取或写入时的文件指针偏移量，通俗点说就是指定下次读文件数据的位置。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;偏移量可以设置在文件末尾之外，只有在偏移量设置超出文件末尾后，才能通过写入更改文件长度；&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、&lt;code&gt;native long getFilePointer()&lt;/code&gt;：返回当前文件的光标位置；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、&lt;code&gt;native long length()&lt;/code&gt;：返回当前文件的长度；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、&lt;strong&gt;「读」&lt;/strong&gt;方法&lt;img data-ratio=&quot;0.9660766961651918&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpOc8TK6ekyGK7MyLvibJK7G8H3QD0L04uavy2kA8RUYWdhf6Kibu7DKbfennHlPZJKpGBRy5MShhd0A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;678&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5、&lt;strong&gt;「写」&lt;/strong&gt;方法&lt;img data-ratio=&quot;0.9503649635036496&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpOc8TK6ekyGK7MyLvibJK7G8VdfQ5M1PR5xdB9KibOvhmiaCSQ0zYykfaUrAxUkicunicicyRib5ArDnvocA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;685&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6、&lt;code&gt;readFully(byte[] b)&lt;/code&gt;：这个方法的作用就是将文本中的内容填满这个缓冲区b。如果缓冲b不能被填满，那么读取流的过程将被阻塞，如果发现是流的结尾，那么会抛出异常；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7、&lt;code&gt;FileChannel getChannel()&lt;/code&gt;：返回与此文件关联的唯一&lt;code&gt;FileChannel&lt;/code&gt;对象；&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;8、&lt;code&gt;int skipBytes(int n)&lt;/code&gt;：试图跳过n个字节的输入，丢弃跳过的字节；&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;&lt;code&gt;RandomAccessFile&lt;/code&gt;的绝大多数功能，已经被&lt;code&gt;JDK1.4&lt;/code&gt;的NIO的&lt;strong&gt;「内存映射」&lt;/strong&gt;文件取代了，即把文件映射到内存后再操作，省去了频繁磁盘&lt;code&gt;io&lt;/code&gt;。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;主菜&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总结经验，砥砺前行：之前的实战文章中过多的粘贴了源码，影响了各位小伙伴的阅读感受。经过大佬的点拨，以后将展示部分关键代码，供各位赏析，源码可在&lt;strong&gt;「后台」&lt;/strong&gt;获取。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;文件分块&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文件分块需要在前端进行处理，可以利用强大的&lt;code&gt;js&lt;/code&gt;库或者现成的组件进行分块处理。需要确定分块的大小和分块的数量，然后为每一个分块指定一个索引值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了防止上传文件的分块与其它文件混淆，采用文件的&lt;code&gt;md5&lt;/code&gt;值来进行区分，该值也可以用来校验服务器上是否存在该文件以及文件的上传状态。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;如果文件存在，直接返回文件地址；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果文件不存在，但是有上传状态，即部分分块上传成功，则返回未上传的分块索引数组；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;如果文件不存在，且上传状态为空，则所有分块均需要上传。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;fileRederInstance.readAsBinaryString(file);&lt;br/&gt;fileRederInstance.addEventListener(&lt;span&gt;&quot;load&quot;&lt;/span&gt;, (e) =&amp;gt; {&lt;br/&gt;    &lt;span&gt;let&lt;/span&gt; fileBolb = e.target.result;&lt;br/&gt;    fileMD5 = md5(fileBolb);&lt;br/&gt;    &lt;span&gt;const&lt;/span&gt; formData = &lt;span&gt;new&lt;/span&gt; FormData();&lt;br/&gt;    formData.append(&lt;span&gt;&quot;md5&quot;&lt;/span&gt;, fileMD5);&lt;br/&gt;    axios&lt;br/&gt;        .post(http + &lt;span&gt;&quot;/fileUpload/checkFileMd5&quot;&lt;/span&gt;, formData)&lt;br/&gt;        .then(&lt;span&gt;(&lt;span&gt;res&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (res.data.message == &lt;span&gt;&quot;文件已存在&quot;&lt;/span&gt;) {&lt;br/&gt;                &lt;span&gt;//文件已存在不走后面分片了，直接返回文件地址到前台页面&lt;/span&gt;&lt;br/&gt;                success &amp;amp;&amp;amp; success(res);&lt;br/&gt;            } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;                &lt;span&gt;//文件不存在存在两种情况，一种是返回data：null代表未上传过 一种是data:[xx，xx] 还有哪几片未上传&lt;/span&gt;&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (!res.data.data) {&lt;br/&gt;                    &lt;span&gt;//还有几片未上传情况，断点续传&lt;/span&gt;&lt;br/&gt;                    chunkArr = res.data.data;&lt;br/&gt;                }&lt;br/&gt;                readChunkMD5();&lt;br/&gt;            }&lt;br/&gt;        })&lt;br/&gt;        .catch(&lt;span&gt;(&lt;span&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; {});&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在调用上传接口前，通过&lt;code&gt;slice&lt;/code&gt;方法来取出索引在文件中对应位置的分块。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;const&lt;/span&gt; getChunkInfo = (file, currentChunk, chunkSize) =&amp;gt; {&lt;br/&gt;       &lt;span&gt;//获取对应下标下的文件片段&lt;/span&gt;&lt;br/&gt;       let start = currentChunk * chunkSize;&lt;br/&gt;       let end = Math.min(file.size, start + chunkSize);&lt;br/&gt;       &lt;span&gt;//对文件分块&lt;/span&gt;&lt;br/&gt;       let chunk = file.slice(start, end);&lt;br/&gt;       &lt;span&gt;return&lt;/span&gt; { start, end, chunk };&lt;br/&gt;   };&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;之后调用上传接口完成上传。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;断点续传、文件秒传&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后端基于&lt;code&gt;spring boot&lt;/code&gt;开发，使用&lt;code&gt;redis&lt;/code&gt;来存储上传文件的状态和上传文件的地址。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果文件完整上传，返回文件路径；部分上传则返回未上传的分块数组；如果未上传过返回提示信息。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;在上传分块时会产生两个文件，一个是文件主体，一个是临时文件。临时文件可以看做是一个数组文件，为每一个分块分配一个值为127的字节。&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;校验MD5值时会用到两个值：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;文件上传状态：只要该文件上传过就不为空，如果完整上传则为&lt;code&gt;true&lt;/code&gt;，部分上传返回&lt;code&gt;false&lt;/code&gt;；&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;文件上传地址：如果文件完整上传，返回文件路径；部分上传返回临时文件路径。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * 校验文件的MD5&lt;br/&gt; **/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; Result &lt;span&gt;checkFileMd5&lt;/span&gt;&lt;span&gt;(String md5)&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; IOException &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;//文件是否上传状态：只要该文件上传过该值一定存在&lt;/span&gt;&lt;br/&gt;    Object processingObj = stringRedisTemplate.opsForHash().get(UploadConstants.FILE_UPLOAD_STATUS, md5);&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (processingObj == &lt;span&gt;null&lt;/span&gt;) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Result.ok(&lt;span&gt;&quot;该文件没有上传过&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;boolean&lt;/span&gt; processing = Boolean.parseBoolean(processingObj.toString());&lt;br/&gt;    &lt;span&gt;//完整文件上传完成时为文件的路径，如果未完成返回临时文件路径（临时文件相当于数组，为每个分块分配一个值为127的字节）&lt;/span&gt;&lt;br/&gt;    String value = stringRedisTemplate.opsForValue().get(UploadConstants.FILE_MD5_KEY + md5);&lt;br/&gt;    &lt;span&gt;//完整文件上传完成是true，未完成返回false&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (processing) {&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Result.ok(value,&lt;span&gt;&quot;文件已存在&quot;&lt;/span&gt;);&lt;br/&gt;    } &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;        File confFile = &lt;span&gt;new&lt;/span&gt; File(value);&lt;br/&gt;        &lt;span&gt;byte&lt;/span&gt;[] completeList = FileUtils.readFileToByteArray(confFile);&lt;br/&gt;        List&amp;lt;Integer&amp;gt; missChunkList = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; completeList.length; i++) {&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (completeList[i] != Byte.MAX_VALUE) {&lt;br/&gt;                &lt;span&gt;//用空格补齐&lt;/span&gt;&lt;br/&gt;                missChunkList.add(i);&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;return&lt;/span&gt; Result.ok(missChunkList,&lt;span&gt;&quot;该文件上传了一部分&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到这，你肯定会问：当这个文件的所有分块上传完成之后，该怎么得到完整的文件呢？接下来我们就说一下分块合并的问题。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;分块上传、文件合并&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上边我们提到了利用文件的&lt;code&gt;md5&lt;/code&gt;值来维护分块和文件的关系，因此我们会将具有相同&lt;code&gt;md5&lt;/code&gt;值的分块进行合并，由于每个分块都有自己的索引值，所以我们会将分块按索引像插入数组一样分别插入文件中，形成完整的文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;分块上传时，要和前端的分块大小、分块数量、当前分块索引等对应好，以备文件合并时使用，此处我们采用的是&lt;strong&gt;「磁盘映射」&lt;/strong&gt;的方式来合并文件。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;//读操作和写操作都是允许的&lt;/span&gt;&lt;br/&gt;RandomAccessFile tempRaf = &lt;span&gt;new&lt;/span&gt; RandomAccessFile(tmpFile, &lt;span&gt;&quot;rw&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;//它返回的就是nio通信中的file的唯一channel&lt;/span&gt;&lt;br/&gt;FileChannel fileChannel = tempRaf.getChannel();&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//写入该分片数据   分片大小 * 第几块分片获取偏移量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;long&lt;/span&gt; offset = CHUNK_SIZE * multipartFileDTO.getChunk();&lt;br/&gt;&lt;span&gt;//分片文件大小&lt;/span&gt;&lt;br/&gt;&lt;span&gt;byte&lt;/span&gt;[] fileData = multipartFileDTO.getFile().getBytes();&lt;br/&gt;&lt;span&gt;//将文件的区域直接映射到内存&lt;/span&gt;&lt;br/&gt;MappedByteBuffer mappedByteBuffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, offset, fileData.length);&lt;br/&gt;mappedByteBuffer.put(fileData);&lt;br/&gt;&lt;span&gt;// 释放&lt;/span&gt;&lt;br/&gt;FileMD5Util.freedMappedByteBuffer(mappedByteBuffer);&lt;br/&gt;fileChannel.close();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;每当完成一次分块的上传，还需要去检查文件的上传进度，看文件是否上传完成。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;RandomAccessFile accessConfFile = &lt;span&gt;new&lt;/span&gt; RandomAccessFile(confFile, &lt;span&gt;&quot;rw&quot;&lt;/span&gt;);&lt;br/&gt;&lt;span&gt;//把该分段标记为 true 表示完成&lt;/span&gt;&lt;br/&gt;accessConfFile.setLength(multipartFileDTO.getChunks());&lt;br/&gt;accessConfFile.seek(multipartFileDTO.getChunk());&lt;br/&gt;accessConfFile.write(Byte.MAX_VALUE);&lt;br/&gt;&lt;br/&gt;&lt;span&gt;//completeList 检查是否全部完成,如果数组里是否全部都是(全部分片都成功上传)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;byte&lt;/span&gt;[] completeList = FileUtils.readFileToByteArray(confFile);&lt;br/&gt;&lt;span&gt;byte&lt;/span&gt; isComplete = Byte.MAX_VALUE;&lt;br/&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; completeList.length &amp;amp;&amp;amp; isComplete == Byte.MAX_VALUE; i++) {&lt;br/&gt;    &lt;span&gt;//与运算, 如果有部分没有完成则 isComplete 不是 Byte.MAX_VALUE&lt;/span&gt;&lt;br/&gt;    isComplete = (&lt;span&gt;byte&lt;/span&gt;) (isComplete &amp;amp; completeList[i]);&lt;br/&gt;}&lt;br/&gt;accessConfFile.close();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;然后更新文件的上传进度到&lt;code&gt;Redis&lt;/code&gt;中。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//更新redis中的状态：如果是true的话证明是已经该大文件全部上传完成&lt;/span&gt;&lt;br/&gt;&lt;span&gt;if&lt;/span&gt; (isComplete == Byte.MAX_VALUE) {&lt;br/&gt;    stringRedisTemplate.opsForHash().put(UploadConstants.FILE_UPLOAD_STATUS, multipartFileDTO.getMd5(), &lt;span&gt;&quot;true&quot;&lt;/span&gt;);&lt;br/&gt;    stringRedisTemplate.opsForValue().set(UploadConstants.FILE_MD5_KEY + multipartFileDTO.getMd5(), uploadDirPath + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + fileName);&lt;br/&gt;} &lt;span&gt;else&lt;/span&gt; {&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!stringRedisTemplate.opsForHash().hasKey(UploadConstants.FILE_UPLOAD_STATUS, multipartFileDTO.getMd5())) {&lt;br/&gt;        stringRedisTemplate.opsForHash().put(UploadConstants.FILE_UPLOAD_STATUS, multipartFileDTO.getMd5(), &lt;span&gt;&quot;false&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;    &lt;span&gt;if&lt;/span&gt; (!stringRedisTemplate.hasKey(UploadConstants.FILE_MD5_KEY + multipartFileDTO.getMd5())) {&lt;br/&gt;        stringRedisTemplate.opsForValue().set(UploadConstants.FILE_MD5_KEY + multipartFileDTO.getMd5(), uploadDirPath + &lt;span&gt;&quot;/&quot;&lt;/span&gt; + fileName + &lt;span&gt;&quot;.conf&quot;&lt;/span&gt;);&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;回复&lt;code&gt;break&lt;/code&gt;可获取完整源码呦！&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上就是今天的全部内容了，如果你有不同的意见或者更好的&lt;code&gt;idea&lt;/code&gt;，欢迎联系阿Q，添加阿Q可以加入技术交流群参与讨论呦！&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzI5MDg2NjEzNA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/55HPQyguvpMAn4Ha81WVBfsKnC9ficVemZff27LiaSoKX83JqwnNmrNhb4D4oAjW7wiaDwtkLTTCRs1A1hanfNu9g/0?wx_fmt=png&quot; data-nickname=&quot;阿Q说代码&quot; data-alias=&quot;AQ_Shuo&quot; data-signature=&quot;专注于后端技术栈分享：文章风格多变、配图通俗易懂、故事生动有趣&quot; data-from=&quot;1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b4bb93335055e3aa8844e3c6ff6914e8</guid>
<title>InnoDB 是如何存数据的？yyds</title>
<link>https://toutiao.io/k/8urc6ku</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;hi，大家好，我是苏三，又跟大家见面了。&lt;/span&gt;&lt;/h2&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;前言&lt;/span&gt;&lt;br/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你使用过mysql数据库，对它的存储引擎：&lt;code&gt;innodb&lt;/code&gt;，一定不会感到陌生。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;众所周知，在mysql5以前，默认的存储引擎是：myslam。但mysql5之后，默认的存储引擎已经变成了：innodb，它是我们建表的首选存储引擎。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，问题来了：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;innodb底层是如何存储数据的？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;表中有哪些隐藏列？&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户记录之间是如何关联起来的？&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你想知道上面三个问题的答案，那么，请继续往下面看。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文主要包含如下内容：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.8496993987975952&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDER9lbESUVq7L6u9ftCRzaTrmE79a3u4JxhFsUvWUb5iaGuxqpjJoJeq8RHiaf72Qyc7vtcdoDElzjw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;998&quot;/&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;1.磁盘or内存？&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.1 磁盘&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据对系统来说是非常重要的东西，比如：用户的身份证、手机号、银行号、会员过期时间、积分等等。一旦丢失，会对用户造成很大的影响。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了，如何才能保证这些重要的数据不丢呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;答案：把数据存在磁盘上。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然有人会说，如果磁盘坏了怎么办？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那就需要备份，或者做主从了。。。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，打住，这不是今天的重点。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;言归正传。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家都知道，从磁盘上读写数据，至少需要两次IO请求才能完成。一次是读IO，另一次是写IO。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而IO请求是比较耗时的操作，如果频繁的进行IO请求势必会影响数据库的性能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如何才能解决数据库的性能问题呢？&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;1.2 内存&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把数据存在寄存器？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，操作系统从寄存器中读取数据是最快的，因为它离CPU最近。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是寄存器有个非常致命的问题是：它只能存储非常少量的数据，设计它的目的主要是用来暂存指令和地址，并非存储大量用户数据的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这样看来，只能把数据存在内存中了。&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为内存同样能满足我们，快速读取和写入数据的需求，而且性能是非常可观的，只是比较寄存器稍稍慢了一丢丢而已。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过有个让人讨厌的地方是，内存相对于磁盘来说，是更加昂贵的资源。通常情况下，500G或者1T的磁盘，是很常见的。但你有听说过有500G的内存吗？别人会以为你疯了。内存大小讨论的数量级一般是16G或32G。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内存可以存储一些用户数据，但无法存储所有的用户数据，因为如果数据量太大了，它可能还是存不下。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，即使用户数据能刚好存在内存，以后万一有一天，数据库服务器或者部署节点挂了，或者重启了，数据不就丢了？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么做，才能不会因为异常情况，而丢数据。同时，又能保证数据的读写速度呢？&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;2.数据页&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以把一批数据放在一起。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;写操作时，先将数据写到内存的某个批次中，然后再将该批次的数据一次性刷到磁盘上。如下图所示：&lt;img data-ratio=&quot;0.8502304147465438&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDER9lbESUVq7L6u9ftCRzaTDpI6oIkz39HTMTYMriascsR9lOUVuOVGpLHpllpfFcFOiaJKqZkbmL7g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;868&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;读操作时，从磁盘上一次读一批数据，然后加载到内存当中，以后就在内存中操作。如下图所示：&lt;img data-ratio=&quot;0.8022727272727272&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDER9lbESUVq7L6u9ftCRzaTBwXKnlhniafxnXXvcfz4Erutjxaicj6rkYCicx2zvgBic130771ib62s8rg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;880&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将内存中的数据刷到磁盘，或者将磁盘中的数据加载到内存，都是以批次为单位，这个批次就是我们常说的：&lt;code&gt;数据页&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然innodb中存在多种不同类型的页，数据页只是其中一种，我们在这里重点介绍一下数据页。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么问题来了，什么是数据页？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据页主要是用来存储表中记录的，它在磁盘中是用双向链表相连的，方便查找，能够非常快速得从一个数据页，定位到另一个数据页。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，由于我们表中的数据比较多，在磁盘中可能存放在多个数据页当中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有一天，我们要根据某个条件查询数据时，需要从一个数据页找到另一个数据页，这时候的双向链表就派上大用场了。磁盘中各数据页的整体结构如下图所示：&lt;img data-ratio=&quot;1.5654205607476634&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDER9lbESUVq7L6u9ftCRzaTrqmQSib5Pv6G7FUlkuAA2fSaMD1GTTD8ZyM7TeUUOmvkmLDMYlibiaqXg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;428&quot;/&gt;通常情况下，单个数据页默认的大小是&lt;code&gt;16kb&lt;/code&gt;。当然，我们也可以通过参数：&lt;code&gt;innodb_page_size&lt;/code&gt;，来重新设置大小。不过，一般情况下，用它的默认值就够了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好吧，数据页的整体结构已经搞明白了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，单个数据页包含哪些内容呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.607843137254902&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDER9lbESUVq7L6u9ftCRzaTuicGNp08dpZUgJVaZ28dZt4XHrsD5O2IQpE7t730ib4otYjbicOTuaePQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;408&quot;/&gt;从上图中可以看出，数据页主要包含如下几个部分：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;文件头部&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;页头部&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最大和最小记录&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;用户记录&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;空闲空间&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;页目录&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;文件尾部&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;3.用户记录&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于新申请的数据页，用户记录是空的。当插入数据时，innodb会将一部分&lt;code&gt;空闲空间&lt;/code&gt;分配给用户记录。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用户记录是innodb的重中之重，我们平时保存到数据库中的数据，就存储在它里面。那么，它里面又包含哪些内容呢？你不好奇吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实在innodb支持的数据行格式有四种：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;compact行格式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;redundant行格式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;dynamic行格式&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;compressed行格式&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们以compact行格式为例：&lt;img data-ratio=&quot;0.22176308539944903&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDER9lbESUVq7L6u9ftCRzaTWR8QYayp9b3bhGCkRUhDMyfUkXbagFia4qJGZZTzULPFCTMSf8OFRhA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1452&quot;/&gt;一条用户记录主要包含三部分内容：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;记录额外信息，它包含了变长字段、null值列表和记录头信息。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;隐藏列，它包含了行id、事务id和回滚点。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;真正的数据列，包含真正的用户数据，可以有很多列。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面让我们一起了解一下这些内容。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.1 额外信息&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;额外信息并非真正的用户数据，它是为了辅助存数据用的。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1.1 变长字段列表&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有些数据如果直接存会有问题，比如：如果某个字段是varchar或text类型，它的长度不固定，可以根据存入数据的长度不同，而随之变化。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不在一个地方记录数据真正的长度，innodb很可能不知道要分配多少空间。假如都按某个固定长度分配空间，但实际数据又没占多少空间，岂不是会浪费？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以，需要在变长字段中记录某个变长字段占用的字节数，方便按需分配空间。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1.2 null值列表&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库中有些字段的值允许为null，如果把每个字段的null值，都保存到用户记录中，显然有些浪费存储空间。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有没有办法只简单的标记一下，不存储实际的null值呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案：将为null的字段保存到null值列表。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在列表中用二进制的值1，表示该字段允许为null，用0表示不允许为null。它只占用了1位，就能表示某个字符是否为null，确实可以节省很多存储空间。&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;3.1.3 记录头信息&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记录头信息用于描述一些特殊的属性。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.21900161030595813&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDER9lbESUVq7L6u9ftCRzaTsFNKxYEMAjLkCarV0smyTfcRCqP11xdcaBA11ySIuz2v2qIOp57Dicg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1242&quot;/&gt;它主要包含：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;deleted_flag：即删除标记，用于标记该记录是否被删除了。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;min_rec_flag：即最小目录标记，它是非叶子节点中的最小目录标记。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;n_owned：即拥有的记录数，记录该组索引记录的条数。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;heap_no：即堆上的位置，它表示当前记录在堆上的位置。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;record_type：即记录类型，其中：0表示普通记录，1表示非叶子节点，2表示Infrimum记录， 3表示Supremum记录。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;next_record：即下一条记录的位置。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.2 隐藏列&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数据库在保存一条用户记录时，会自动创建一些隐藏列。如下图所示：&lt;img data-ratio=&quot;0.4148471615720524&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDER9lbESUVq7L6u9ftCRzaT9JJTf5zsLLmjOduicsWlCibbW0OEWHz87pzDzoJItibjuWCu3b0yzsubA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;458&quot;/&gt;目前innodb自动创建的隐藏列有三种：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;db_row_id，即行id，它是一条记录的唯一标识。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;db_trx_id，即事务id，它是事务的唯一标识。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;db_roll_ptr，即回滚点，它用于事务回滚。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果表中有主键，则用主键做行id，无需额外创建。如果表中没有主键，假如有不为null的unique唯一键，则用它做为行id，同样无需额外创建。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果表中既没有主键，又没有唯一键，则数据库会自动创建行id。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说在innodb中，隐藏列中&lt;code&gt;事务id&lt;/code&gt;和&lt;code&gt;回滚点&lt;/code&gt;是一定会被创建的，但行id要根据实际情况决定。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.3 真正数据列&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;真正的数据列中存储了用户的真实数据，它可以包含很多列的数据。这个比较简单，没有什么好多说的。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;3.4 用户记录是如何相连的？&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面介绍的内容，大家对一条用户记录是如何存储的，应该有了一定的认识。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但问题来了，一条用户记录和另一条用户记录是如何相连的，innodb是怎么知道，某条记录的下一条记录是谁？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;答案是：用前面提到过的， 记录额外信息 》 记录头信息 》下一条记录的位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.9116022099447514&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDER9lbESUVq7L6u9ftCRzaTGZ7pAQLNneVSVRwDmXR2icQBftNCKHVqd4wROSaJQJJT3AVbkX7srFA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1086&quot;/&gt;多条用户记录之间通过&lt;code&gt;下一条记录的位置&lt;/code&gt;，组成了一个单向链表。这样就能从前往后，找到所有的记录了。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;4.最大和最小记录&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面可以得知，在一个数据页当中，如果存在多条用户记录，它们是通过&lt;code&gt;下一条记录的位置&lt;/code&gt;相连的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不过有个问题：如果才能快速找到最大的记录和最小的记录呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就需要在保存用户记录的同时，也保存最大和最小记录了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最大记录保存到Supremum记录中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最小记录保存在Infimum记录中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在保存用户记录时，数据库会自动创建两条额外的记录：Supremum 和 Infimum。它们之间的关系，如下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.5045871559633028&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDER9lbESUVq7L6u9ftCRzaTum4U3w1utKO16lVa3QKMDlCS1bEibG3icjmeBxZDRuWGma7jbudm81Jg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;654&quot;/&gt;从图中可以看出用户数据是从最小记录开始，通过下一条记录的位置，从小到大，一步步查找，最后找到最大记录为止。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;5.页目录&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面可以看出，如果我们要查询某条记录的话，数据库会从最小记录开始，一条条查找所有记录。如果中途找到了，则直接返回该记录。如果一直找到最大记录，还没有找到想要的记录，则返回空。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;咋一看，没有问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果仔细想想。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;效率会不会有点低？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这不是要对整页用户数据进行扫描吗？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有没有更高效的方法？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就需要使用&lt;code&gt;页目录&lt;/code&gt;了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说白了，就是把一页用户记录分为若干组，每一组的最大记录都保存到一个地方，这个地方就是&lt;code&gt;页目录&lt;/code&gt;。每一组的最大记录叫做&lt;code&gt;槽&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由此可见，页目录是有多个槽组成的。所下图所示：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6590909090909091&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDER9lbESUVq7L6u9ftCRzaTLECzMXJSzZGusugGkiaFpyj5zLXEdp64jYmSLdbtyRQUoBwBzZzI9cA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;968&quot;/&gt;假设一页的数据分为4组，这样在页目录中，就对应了4个槽，每个槽中都保存了该组数据的最大值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样就能通过二分查找，比较槽中的记录跟需要找到的记录的大小。如果用户需要查找的记录，小于当前槽中的记录，则向上查找上一个槽。如果用户需要查找的记录，大于当前槽中的记录，则向下查找下一个槽。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如此一来，就能通过二分查找，快速的定位需要查找的记录了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;so easy&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;6.文件头部和尾部&lt;/span&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;6.1 文件头部&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过前面介绍的行记录中&lt;code&gt;下一条记录的位置&lt;/code&gt;和&lt;code&gt;页目录&lt;/code&gt;，innodb能非常快速的定位某一条记录。但有个前提条件，就是用户记录必须在同一个数据页当中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果用户记录非常多，在第一个数据页找不到我们想要的数据，需要到另外一页找该怎么办呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时就需要使用&lt;code&gt;文件头部&lt;/code&gt;了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它里面包含了多个信息，但我只列出了其中4个最关键的信息：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;页号&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;上一页页号&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;下一页页号&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;页类型&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顾名思义，innodb是通过页号、上一页页号和下一页页号来串联不同数据页的。如下图所示：&lt;img data-ratio=&quot;1.5045454545454546&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDER9lbESUVq7L6u9ftCRzaTRordc1Srg47FYLnjhHEIXg0a0Bj1SibDHRYiawMI7N5lNNcp35cvszSg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;440&quot;/&gt;不同的数据页之间，通过上一页页号和下一页页号构成了双向链表。这样就能从前向后，一页页查找所有的数据了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，页类型也是一个非常重要的字段，它包含了多种类型，其中比较出名的有：数据页、索引页（目录项页）、溢出页、undo日志页等。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;6.2 文件尾部&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我之前提过，数据库的数据是以数据页为单位，加载到内存中，如果数据有更新的话，需要刷新到磁盘上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但如果某一天比较倒霉，程序在刷新到磁盘的过程中，出现了异常，比如：进程被kill掉了，或者服务器被重启了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这时候数据可能只刷新了一部分，如何判断上次刷盘的数据是完整的呢？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这就需要用到&lt;code&gt;文件尾部&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它里面记录了页面的&lt;code&gt;校验和&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在数据刷新到磁盘之前，会先计算一个页面的校验和。后面如果数据有更新的话，会计算一个新值。文件头部中也会记录这个校验和，由于文件头部在前面，会先被刷新到磁盘上。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来，刷新用户记录到磁盘的时候，假设刷新了一部分，恰好程序出现异常了。这时，文件尾部的校验和，还是一个旧值。数据库会去校验，文件尾部的校验和，不等于文件头部的新值，说明该数据页的数据是不完整的。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;7.页头部&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过上面介绍的内容，数据页之间能够轻松访问了，但剩下还有个比较重要的问题，就是记录的状态信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如一页数据到底保存了多条记录，或者页目录到底使用了多个槽等。这些信息是实时统计，还是事先统计好了，保存到某个地方？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了性能考虑，上面的这些统计数据，当然是先统计好，保存到一个地方。后面需要用到该数据时，再读取出来会更好。这个保存统计数据的地方，就是&lt;code&gt;页头部&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然页头部不仅仅只保存：槽的数量、记录条数等信息。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它还记录了：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;已删除记录所占的字节数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最后插入记录的位置&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;最大事务id&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;索引id&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;索引层级&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实还有很多，在这里就不一一列举了，有兴趣的朋友可以找我私聊。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;多个数据页之间通过&lt;code&gt;页号&lt;/code&gt;构成了双向链表。而每一个数据页的行数据之间，又通过&lt;code&gt;下一条记录的位置&lt;/code&gt;构成了单项链表。整体架构图如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.561525129982669&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/uL371281oDER9lbESUVq7L6u9ftCRzaTtRWdBL3V9p9UOMy1Pqk1vf2Vy4nxK4ia07d1oZZdxS4kjSzgAUDVcog/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1154&quot;/&gt;好了，本文内容先到这里。如果小伙伴们有任何疑问的话，欢迎找我私聊。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顺便预告一下，在innodb的存储结构中，还有一个非常重要的内容没讲，它就是：&lt;code&gt;索引&lt;/code&gt;。敬请期待，我们下期见。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;参考：《mysql是怎样运行的》&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;最后说一句(求关注，别白嫖我)&lt;/span&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果这篇文章对您有所帮助，或者有所启发的话，帮忙关注一下，您的支持是我坚持写作最大的动力。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;加群交流，可以添加下面微信，群里有很多技术大牛喔。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.0048309178743962&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/uL371281oDE9vvfu1eb0KdQmjCiceE3xr7JF0cvK0z4UwCNyKO4UsMg5Urfro5qzoU2NWfgthCjwENmLxK6Nxyw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;414&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;求一键三连：点赞、转发、在看。&lt;/p&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzUxODkzNTQ3Nw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/uL371281oDHlDcdbjNJic1yCwAu2dmJ9AunIQh9DXdm5JE7v9libnPgJQicoaGs9Eiaee2kPeFGWJxsPkZ9zCQbrIw/0?wx_fmt=png&quot; data-nickname=&quot;苏三说技术&quot; data-alias=&quot;susanSayJava&quot; data-signature=&quot;作者就职于知名互联网公司，掘金月度优秀作者，从事开发、架构和部分管理工作。实战经验丰富，对jdk、spring、springboot、springcloud、mybatis等开源框架源码有一定研究，欢迎关注，和我一起交流。&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e442518ca77a9ddb1f17ebef82974531</guid>
<title>理想的团队成员</title>
<link>https://toutiao.io/k/ps0j3xm</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;长按二维码向我转账&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;人生如梦，一樽还酹江月&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;受苹果公司新规定影响，微信 iOS 版的赞赏功能被关闭，可通过二维码转账支持公众号。&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>af4430075bf825f647a8ff1ff53698aa</guid>
<title>只需五步，实现数据分析闭环</title>
<link>https://toutiao.io/k/u089rci</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;p class=&quot;original_area_primary&quot;&gt;
                                                                                                &lt;/p&gt;

                    
                                            &lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.22777777777777777&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/yAyQKzCbAHbRTx8jw3canPvNKdX8GlKHyDruMI6SkicNUz21NqEggyN2RYWp81jf1dFEDHaXOYWrzHyRN5X5ibIg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;8&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;来源：接地气学堂&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;很多做数据的同学，光看着自己写报告，看不到自己的建议被落地，常心怀缺憾。觉得不能像产品/运营那样，打造一个数据分析的闭环，能力也没法提升。其实这是一种误解。今天结合一个具体案例，看看数据分析的闭环，究竟如何打造。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;00&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;问题场景&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;某餐厅，其所在的商场原本可免费停车，从本月起改为收费停车，而且停车费相当贵。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;餐厅店长纠结：停车费是否会影响收入。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;问：该如何做分析？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;不及格的分析&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里最容易范的错误，就是列了一堆数据&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;l 昨天收入10000&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;l 前天收入12000&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;l 环比增长20%&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;l ……&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是不及格的回答。仅仅罗列了数字，没有任何结论。因为问题是：“停车费是否会影响收入”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以分析的最终结论，至少应该是：“会/不会”。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注意，只回答会/不会，仍不是完整的答案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果是会影响，那到底是影响一点点，还是能直接把店干垮了？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果是不会影响，那为什么停车场收费以后“感觉”客人少了？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5606758832565284&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3GgYOFNajet867LhoAvBEr8ibAWfQa7QCcmccmKiavtYvhVUzlE11xNrt7dDQicWgVNMv7icbtUiaVj9oOnmyWUnsmg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;651&quot;/&gt;&lt;span&gt;                           &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些疑问需要进一步的回答。一个完整的分析，不应该只陈述结论，而且应该附上数据论证过程。这是数据方法与其他方法的最大区别。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;02&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;从不及格到完整&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;即使不做数据分析，大家也能随口而出：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“开车的才几个人，没啥影响”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“开车人的人好多，好大影响”&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“你看门口人没少啊？！”&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;听听都有理，但是完全无法用数据验证，因此也就是纯嘴炮级别的讨论。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要完整地分析，需要用数据论据支撑论点。比如论证：不会影响收入&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那么需要证据如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1、收费前/后总收入没有变化（最直接证据）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、收费前/后收入结构没有变化（并非某些人少了，某些多了，总和不变）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、收费后的波动，是非停车场因素导致的（比如自然波动、促销影响）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、其他影响消失后，收费后波动也消失，和收费前一致&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;这四条是可以通过统计下面信息来验证的：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;l 总收入数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;l 会员/非会员贡献收入比例&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;l 剔除下雨/促销等异常日期后剩余日期收入&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;249&quot; data-ratio=&quot;0.4598639455782313&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3GgYOFNajet867LhoAvBEr8ibAWfQa7QCpf88Ya4Qib9xqXHUFhgiamkeeTzf5sWbqWSc2IWTcrhbUwwMIQSl5Kcw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;735&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果所有论证都成立，就能推出结论了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注意，有可能收费带来的是长期影响，有可能需要多观察几周才能看到更明显的规律，所以结论也是可以分短期、中期、长期推出的。因此在给结论的时候，最好给出监控指标，避免后续无法追踪长期效果。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是这样还没形成闭环。因为即使到这一步，输出的还是个结论而已。结论对不对，需要时间来检验。结论有没有用，需要落实到业务上才能见成效，因此还要继续往前推。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;03&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;从完整到闭环&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;注意，同样的数据结论，有可能在落实到业务的时候，出现完全不同的声音。比如已经在上一阶段落实了：停车收费会影响会员用户消费人数，板上钉钉了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;该咋办呢？可能有完全不同四种声音：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;A说：找物业协调一些免费停车票不就好了，谁停车给谁&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;B说：老会员跑了，新会员补上不就好了，该给新会员补贴&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;C说：老会员跑了就该捞老会员，该给老会员补贴&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;D说：人家就是一时生气，过几天都回来了，不纠结！&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;四个声音相互矛盾，无论如何，最后肯定只采纳一个意见。另外三种很有可能永远都没有机会检验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;此时数据分析师该咋办？答：用MECE法，把各种意见都梳理出来，然后先设好监控指标。之后无论哪个意见被执行，都能监控其走势，检验分析是否正确（如下图）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5192069392812887&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3GgYOFNajet867LhoAvBEr8ibAWfQa7QCywJzPj351ME9Wan78lrCZ8Cqeytg9riazPbg4QHpIyBCdYLNVEmqVgg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;807&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;经过检验以后，正确的认识被保留，问题结束，闭环完成。不正确的认识，可能需要好几轮测试才能淘汰掉，逐步逼近正确。这里可能需要耗费大量的时间，特别是很多产品/运营迭代很慢的企业，一晃几年都有可能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里也有可能消耗大量的成本，特别是业务上无视数据，固执己见，不撞南墙不回头，甚至撞得满头血都不回头的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;行动迟缓、无视数据、刚愎自用，都会导致业务失败。但注意，这些是业务本身犯的错误。如果数据分析能在多轮迭代中，成功预知到这些错误结果。那么数据分析已经实现了分析闭环，并且提升了自身能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;要特别注意一个问题，就是在提假设阶段，只给预判，不给预判逻辑。在总结阶段，只看大结果，不看过程。这种不顾细节的做法，跟算命瞎猜没啥区别，也经不起反复实验的检验。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;很多人喜欢事后诸葛亮，说：我早就料到了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果：&lt;/span&gt;&lt;span&gt;在事前没有预判字据，只有事后嘴炮；&lt;/span&gt;&lt;span&gt;结果的发生逻辑，和预判逻辑不同。&lt;/span&gt;&lt;span&gt;是不能证明“我早就料到了”的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5296551724137931&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3GgYOFNajet867LhoAvBEr8ibAWfQa7QCUywXMiahZV2mH6eTJL4szYkVibqJ7qTmPkibEsgkHwrU5ro3xCS0LgYeQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;725&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;section mpa-from-tpl=&quot;t&quot;&gt;&lt;p&gt;&lt;span&gt;1、用数据量化问题&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2、形成分析假设&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3、落实业务行动&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4、监控问题走势&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5、总结分析经验&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;完成这五步，就完成了数据分析闭环。&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5349794238683128&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/3GgYOFNajet867LhoAvBEr8ibAWfQa7QCIEskUUiazmtmnQA1UgnInWD4N6xE4JHo2DOLMiayk2eKiaPnXDjNepibzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;729&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;聪明的同学们已经注意到了，数据分析的闭环，是不需要经过业务同意就能建立起来的。因为在第三步，已经通过MECE方法，对每种可能性建立了监控指标，并做出了预判，因此无论业务选哪条路，都能检验数据分析的准确性。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;相比之下，运营和产品就被动得多，很多基层的运营/产品就是领导的传声筒，除了忠实完成老板交办任务外，没有自己的想法——有也没有用，老板一句不同意，就能把万丈豪情打成粉末。相比之数据分析，真是惨太多了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果每次数据分析做出的预判都很准的话，就是所谓：知其所以胜，知其所以败，这就是数据分析的最高境界了。说明分析师本人已经抓住了一个业务的核心规律。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然，不准也没关系，特别是新手刚起步的时候，能做好前两步已经很好了。这一点需要长时间的锻炼与积累才能实现。同学们一起加油哦。&lt;/span&gt;&lt;/p&gt;&lt;section data-mpa-template=&quot;t&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;扫码加入数据分析社群&lt;/span&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;64&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/b96CibCt70iaajvl7fD4ZCicMcjhXMp1v6UibM134tIsO1j5yqHyNhh9arj090oAL7zGhRJRq6cFqFOlDZMleLl4pw/640?wx_fmt=png&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/yAyQKzCbAHa08rsLVYQNgODXgtOicRZm6FXG3qHmRwAjXP6C0g9YS3ZCib5uIqm9ALb71icyJwJgiafZWmFphHOaxQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>