<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>3993bbe28ee4164e43abb808086c8393</guid>
<title>30 岁的程序员出路在哪里？| 码农周刊第 321 期</title>
<link>https://toutiao.io/k/qdeuemt</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;body class=&quot;issue&quot; id=&quot;readabilityBody&quot;&gt;
        &lt;h1&gt;30 岁的程序员出路在哪里？| 码农周刊第 321 期&lt;/h1&gt;
        &lt;h2&gt;码农周刊第321期（2020-10-15）&lt;/h2&gt;
        &lt;p&gt;☞ &lt;a href=&quot;https://weekly.manong.io/bounce?nid=321&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3210&quot; target=&quot;_blank&quot;&gt;薪资翻番如何实现？程序员的涨薪秘诀&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;a href=&quot;https://weekly.manong.io/bounce?nid=321&amp;amp;aid=19568&amp;amp;url=https%3A%2F%2Fvip.manong.io%2F%3F3210&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_321.png&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&amp;#13;
&lt;small&gt;&lt;a href=&quot;https://weekly.manong.io/bounce?nid=321&amp;amp;aid=19185&amp;amp;url=https%3A%2F%2Fjinshuju.net%2Ff%2FV7DxN9&quot; target=&quot;_blank&quot;&gt;商务合作&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
        
        &lt;h3 id=&quot;程序设计&quot;&gt;程序设计&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;最佳实践&lt;/p&gt;
        
        &lt;p&gt;偏好模型在贝壳的应用&lt;/p&gt;
        
        &lt;p&gt;实战经验&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;VIP会员专区&quot;&gt;VIP会员专区&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;工作地点：成都 | 薪资：15-30K | 简历投递邮箱：xiexiaofang@huobi.com&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;共包含 9 种英伟达开发的图像及视频合成方法&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;以 DDD 思想为基础，融合中台核心要素，赋能中台建设。&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;开箱即用的中后台前端/设计解决方案&lt;/p&gt;
        &lt;h3 id=&quot;工具资料&quot;&gt;工具资料&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;详细介绍&amp;#13;
&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;一步步教你&lt;/p&gt;
        
        &lt;p&gt;细致讲解&lt;/p&gt;
        
        &lt;p&gt;无废话&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;适合入门&lt;/p&gt;
        
        &lt;p&gt;多维度看问题&lt;/p&gt;
        
        &lt;p&gt;&lt;a href=&quot;https://github.com/streamnative/mop&quot; target=&quot;_blank&quot;&gt;GitHub 地址&lt;/a&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;h3 id=&quot;编程语言&quot;&gt;编程语言&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;「码农周刊 VIP 会员专属邮件周报」每周五发送，自订购之日算起，全年 52 期。&lt;/p&gt;
        
        &lt;p&gt;通俗易懂&lt;/p&gt;
        
        &lt;p&gt;适合新手&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;详细介绍&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;完备分析&lt;/p&gt;
        
        &lt;p&gt;结合代码&lt;/p&gt;
        
        &lt;p&gt;代码示例&lt;/p&gt;
        
        &lt;p&gt;通俗易懂&lt;/p&gt;
        
        &lt;p&gt;经验分享&lt;/p&gt;
        
        &lt;p&gt;详解&lt;/p&gt;
        
        &lt;p&gt;细致分析&lt;/p&gt;
        &lt;h3 id=&quot;每周独家号推荐&quot;&gt;每周独家号推荐&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;一线互联网工程师，分享Linux C++ Go Python等后端开发技术。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 444675 即可&lt;/p&gt;
        
        &lt;p&gt;老年程序猿，工作15年以上。以前极其不擅长写作，最近决定对着弱点迎难而上，写写原创的经验、心得。&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 426740 即可&lt;/p&gt;
        
        &lt;p&gt;分享一些在 ThinkJS 项目开发过程中总结的一些经验以及问题&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 253319 即可&lt;/p&gt;
        
        &lt;p&gt;专注互联网金融&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 26661 即可&lt;/p&gt;
        
        &lt;p&gt;主要是分享作为一个机器学习算法工程师的工作学习生活方面的内容，包括Python编程、机器学习和深度学习算法知识，偶尔可能分享一些计算机基础方面的知识，以及一些练习项目等&lt;br/&gt;订阅方法：使用&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;，发现 &amp;gt; 搜索 1584 即可&lt;/p&gt;
        &lt;h3 id=&quot;每周一书&quot;&gt;每周一书&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;本书介绍了 Kotlin 的基本语法、常用类型、面向对象编程以及一些高阶的知识。欢迎到&lt;a href=&quot;http://toutiao.io/download?ref=v4.1.0&quot; target=&quot;_blank&quot;&gt;开发者头条客户端&lt;/a&gt;兑换阅读。&lt;/p&gt;
        &lt;h3 id=&quot;编程之外&quot;&gt;编程之外&lt;/h3&gt;
        &lt;p/&gt;
        
        &lt;p&gt;天无绝程序员之路&lt;/p&gt;
        
        &lt;p&gt;供参考&lt;/p&gt;
        
        &lt;p&gt;经验之谈&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://img.toutiao.io/ads/vip_3041.jpeg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
        &lt;p&gt;
        &lt;/p&gt;
        
        
        
        
        &lt;div class=&quot;qrcode&quot;&gt;
  &lt;img src=&quot;https://img.toutiao.io/ads/vip_qrcode.png&quot; alt=&quot;Qrcode 258&quot;/&gt;&lt;span&gt;加入码农周刊VIP会员&lt;/span&gt;
&lt;/div&gt;
    &lt;/body&gt;
&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>b74e831ca09a7f78b0599f1dc6dd4fc4</guid>
<title>带你快速了解：限流中的漏桶和令牌桶算法</title>
<link>https://toutiao.io/k/okvzhvz</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在前文 《限流熔断是什么，怎么做，不做行不行？》中针对 “限流” 动作，有提到流量控制其内部对应着两种常用的限流算法。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其分别对应漏桶算法和令牌桶算法。因此会有的读者会好奇，这都是些啥？&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更进一步的了解 WHY，本文来快速探索一下，看看限流下的一些 “算法” 们到底有何作用，是为何成为流量控制的基石的？&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-croporisrc=&quot;https://mmbiz.qlogo.cn/mmbiz_jpg/KVl0giak5ib4jqlMnOS2IsicxFQwSooDnoFPGvkvqScQ9g9VlCgFoZsfjLcd7mGeTAPOSSvjEoxKnAxreOib2qvdgQ/0?wx_fmt=jpeg&quot; data-cropx1=&quot;0&quot; data-cropx2=&quot;640&quot; data-cropy1=&quot;0&quot; data-cropy2=&quot;544.8327137546469&quot; data-ratio=&quot;0.8515625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4jqlMnOS2IsicxFQwSooDnoFHYsysRHIshoYyYdib6kgtDz4iaT8Qib2BkLHIWYtfLsq4HHXqNvUOn9GA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;640&quot;/&gt;&lt;figcaption&gt;图片来自网络&lt;/figcaption&gt;&lt;/figure&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;前言&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理论上每一个对外/内提供功能的资源点，都需要进行一定的流量控制，否则在业务的持续迭代中，是有可能出现突发性流量的场景（就像年初所带来的一些行业突发转变，导致业务流量突然暴增）：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5609418282548476&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4jqlMnOS2IsicxFQwSooDnoFvGa1KPN1a9fvz08Q6PcovclFJGibAMIicYTMXXVn7AiajANszTM54sbFw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1444&quot;/&gt;&lt;figcaption&gt;突发流量&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;若没有进行限流，就会出现一些奇奇怪怪的问题点，实则就是系统无法承受这波流量，逐渐崩溃，走向系统假死。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;现实场景&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最常见的现实场景就是日常随处可见的排插、插座，其内置的保险丝，也被称为电流保险丝，其主要是起过载保护作用，保险丝会在电流异常升高到一定的高度和热度的时候，自身熔断切断电流，从而起到保护电路安全运行的作用。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此真实世界中有许多与软件工程中的限流熔断的场景有异曲同工之处，也是为了控制量，超量就切断。你也可以想想现实生活中是否有遇到其他类似的例子呢？&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.69&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4jqlMnOS2IsicxFQwSooDnoFlJeemHiaRF3kTKPEaUtQibVVwJGqiaEmDG0cgBHHhFgichpMo09c6dSdVA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1000&quot;/&gt;&lt;figcaption&gt;保险丝（图来自网络）&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;漏桶算法（Leaky Bucket）&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;漏桶算法（Leaky Bucket）是网络中流量整形（Traffic Shaping）或速率限制（Rate Limiting）时常用的一种算法，它的主要目的是控制数据注入到网络的速率，平滑网络上的突发流量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;漏桶算法通过其算法调控了流量访问，使得突发流量可以被整形，去毛刺，变成一个相对缓和，以便为网络提供一个稳定的流量。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;漏桶算法的存储桶主要由三个参数定义，分别是：桶的容量、水从桶中流出的速率、桶的初始充满度。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其核心理念就如字面意思：一个会漏水的桶。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5293333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4jqlMnOS2IsicxFQwSooDnoFQNT2icJ1Y6fgrFxa50FULiaDAb5XVO30ibDyrTicuHBqLIZO0WIXVpUZpw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1500&quot;/&gt;&lt;figcaption&gt;图片来自 geeksforgeeks&lt;/figcaption&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Bursty Flow&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，水龙头代表着突发流量（Bursty Flow）。当网络中存在突发流量，且无任何调控时，就会出现像 Bursty Data 处类似的场景。主机以 12 Mbps 的速率发送数据，时间持续 2s，总计 24 Mbits 数据。随后主机暂停发送 5s，然后再以 2 Mbps 的速率发送数据 3s，最终总共发送了 6 Mbits 的数据。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此主机在 10s 内总共发送了 30 Mbits 的数据。但这里存在一个问题，就是数据的发送并不是平滑的，存在一个较大的波峰。若所有流量都是如此的传输方式，将会 “旱的旱死涝的涝死”，对系统并不是特别的友好。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Fixed Flow&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了解决 Bursty Flow 场景的问题。漏桶（Leaky Bucket）出现了，漏桶具有固定的流出速率、固定的容量大小。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上图中，漏桶在相同的 10s 内以 3 Mbps 的速率持续发送数据来平滑流量。若水（流量）来的过猛，但水流（漏水）不够快时，其最终结果就是导致水直接溢出，呈现出来就是拒绝请求/排队等待的表现。另外当 Buckets 空时，是会出现一次性倒入达到 Bucket 容量限制的水的可能性，此时也可能会出现波峰。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;简单来讲就是，一个漏桶，水流进来，但漏桶只有固定的流速来流出水，若容量满即拒绝，否则将持续保持流量流出。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;令牌桶算法&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;令牌桶算法也是网络中流量整形或速率限制时常用的一种算法，它的主要目的是控制发送到网络上的数据的数目，并允许突发数据的发送。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;令牌桶算法会以一个恒定的速率向桶里放入令牌，如果有新的请求进来希望进行处理，则必须要先从桶内拿到一个可用的令牌，才能继续被处理。若桶内无令牌可取时，则拒绝请求/排队等待。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5293333333333333&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/KVl0giak5ib4jqlMnOS2IsicxFQwSooDnoFqgZzzjHLaryT1JpYibUya7nOjW3acVX24V16GgUEH9q1vUWT3zSv0icA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1500&quot;/&gt;&lt;figcaption&gt;图片来自 gateoverflow&lt;/figcaption&gt;&lt;/figure&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;每 1/r 秒新增一个 token 到 buckets 中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;buckets 中最多可容纳 b 个令牌。如果桶已满，将丢弃这个新增的 token（也就是不需要新的 token）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当主机传输 n bytes packets 時，buckets 中如果有 n 个令牌，则取到所需令牌，成功传输 n bytes。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当可用的 token 小于 n bytes 时，不会从 buckets 中取到任何 token，本次请求将被拒绝/排队等待。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;漏桶 vs 令牌桶&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;漏桶算法和令牌桶算法本质上都是为了做流量整形（Traffic Shaping）或速率限制（Rate Limiting），避免系统因为大流量而被打崩，但两者核心差异在于限流的方向是相反的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;令牌桶限制的是流量的平均流入速率，并且允许一定程度的突然性流量，最大速率为桶的容量和生成 token 的速率。而漏桶限制的是流量的流出速率，是相对固定的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因此也会相对的带来一个问题，在某些场景中，漏桶算法并不能有效的使用网络资源，因为漏桶的漏出速率是相对固定的，所以在网络情况比较好，没有拥塞的状态下，漏桶依然是限制住的，并没有办法放开量。而令牌桶算法则不同，其能够是限制平均速率的同时支持一定程度的突发流量。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总结&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在软件系统中，限流常常所代表的就是流量整形、速率限制，是一个非常常见的调控手段。一般我们会将其在初期集成到统一框架、网关、Mesh 中去。因此建议接触业务的同学，都要对这一块进行考量，便于后续的快速使用/接入，毕竟业务的流量爆发总是来的比较突然，甚至可能是恶意攻击。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而本文所提到的漏桶，令牌桶都是非常常见的手段，虽然两者独立出来分析了。但从软件开发的角度来讲，你认为两者是否可以融合，结合其优势呢？&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9a91298708ce9179e20ba8d877d36298</guid>
<title>Service Mesh 的关键：边车模式 (sidecar)；又要开车了</title>
<link>https://toutiao.io/k/vys6n4c</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-backh=&quot;174&quot; data-backw=&quot;365&quot; data-ratio=&quot;0.4767123287671233&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/cvQbJDZsKLp6wejHtKTRbqqQyt0wMk9K1wNtuwRqQTJAPOJ1KiaqSeSRbIJRTicVicKpDKRndBodY2DBNN20tvWwA/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;365&quot;/&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;不羡鸳鸯不羡仙，一行代码调半天。原创：小姐姐味道（微信公众号ID：xjjdog），欢迎分享，转载请保留出处。&lt;/p&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;哎，又堵车了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;记性好的同学，一定记得我们那辆&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzA4MTc4NTUxNQ==&amp;amp;mid=2650520945&amp;amp;idx=1&amp;amp;sn=6796dd303bece439d47966b8349439f2&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;敞快明亮的JMC&lt;/a&gt; 。拥有一辆JMC，任嘶吼的狂风穿过车窗打在脸上，是一件无比畅快的事情。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这次的车不一样。有点高级。开的猛的时候，狂风能够掀掉头盔。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5604203152364273&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLp5kia6WbsmCVvGg192jQLiaPQLqIueiaMNpsL9fsRdTHmDM7lLyARBdbiaV1QOmR8HKib9sIV9OIf2doA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1142&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;仔细观察上面的这辆车，它有三个轮子。其中左边多出来的轮子和座位，就叫做边车。它是可拆卸的，加上之后，就可以带人兜风了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;边车模式（sidecar），就像是梅超风对于陈玄风，莫邪对于干将。由于和比较前沿的&lt;code&gt;ServiceMesh&lt;/code&gt;概念息息相关，所以很容易让人望而却步。你到网上去随便一搜，都是晦涩难懂的概念。要了解下一代微服务，提前布局，需要啃一些枯燥的知识。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.83&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLp5kia6WbsmCVvGg192jQLiaPzQQdCtu4dlHUKFUHRoOnShmOaiaZJrn83Wc4FlNNUAouxW2oDicJ4elA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;随着我的介绍，你会发现&lt;code&gt;sidecar&lt;/code&gt;模式，是一个高度抽象的模式。但是不要着急，这辆车形状怪异的交通工具，我们依然能够驾驭。它的概念很简单，只不过有很多使用限制。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;一步步升级&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意：下面都是边车模式，只不过有的边车实在是简陋。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&amp;lt;1&amp;gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家都知道，微服务是复杂的，引入了一系列的问题，服务治理显得尤关重要。比如日志收集、服务监控、服务治理等。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5397301349325337&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLp5kia6WbsmCVvGg192jQLiaPEwOicMibFx4zsJ9FaaH6HxY1oBngntrKdg2bLN3Cm6WIICO7ic7ZqDw4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;667&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如上面这张图，我们在一个Linux服务器上，部署了四个进程。其中，web服务是最主要的进程，其他进程只是作为一些附加功能部署上去的。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实，这三个圆圈，就是边车的功能。只要把它给挂载上，上面的服务就拥有了这些功能。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但对于这三个组件的配置，是相当复杂的。我们需要很多重复的工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&amp;lt;2&amp;gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5397301349325337&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLp5kia6WbsmCVvGg192jQLiaPmbD8PDKtCX0m5kcJCGAFfjcIZk34RYkMCfJrQYJ4w77q7CG2GHUT5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;667&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面这张图，通过将Web应用与我们的辅助应用打包在一块，进一步增强了 &lt;strong&gt;不可变性&lt;/strong&gt;。拥有了容器的加持，我们就能够靠约定来简化打包和发布操作。比如，上面的各个组件就可以通过localhost直接通信。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但可惜的是，我们的这些辅助程序，都是作为docker容器里的&lt;code&gt;进程&lt;/code&gt;去启动的，这种 &lt;strong&gt;富容器模式&lt;/strong&gt; 有诸多缺陷，不符合不可变基础设施的理念，所以并不值得推荐。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&amp;lt;3&amp;gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;k8s&lt;/code&gt;的&lt;code&gt;Pod&lt;/code&gt;，在容器的基础上，进一步抽象。一个Pod中可以包含多个容器。如下图，基础服务和Web服务可以分别独自构建，最后以Pod作为载体，搭上便车就可以了。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5397301349325337&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLp5kia6WbsmCVvGg192jQLiaPRbWT9DibXCgiceFqxhygDMoV4J6gfFic4WfN6nPUbLo3ujlwUXAg1MV4Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;667&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了更加显著的看到这个过程，下面这张图以日志收集为例，介绍了两个pod，相同日志收集docker容器的拓扑图。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5022488755622189&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLp5kia6WbsmCVvGg192jQLiaPLrc9tzD3RBia5jhf5j7GtoO5DggxnrmWiaCUIMzicEPicuoBzId1Jq2Qng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;667&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从上面的演进过程我们可以看到。边车，就是辅助或者基础程序而已。但如何方便的管理这些附加的程序，我们有不同的组织方式。只有高度的抽象层次，才能进行方便的组装与设计。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&amp;lt;4&amp;gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到此为止，我们可以看一下&lt;code&gt;ServiceMesh&lt;/code&gt;经典的两张图了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们把Web应用（业务服务），抽象成&lt;code&gt;绿色的方块&lt;/code&gt;。然后把辅助组件（sidecar），抽象成&lt;code&gt;蓝色方块&lt;/code&gt;。在一个相对简单的环境中，我们的部署方式如下所示。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6314655172413793&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLp5kia6WbsmCVvGg192jQLiaPEyNCGpib1OqBjiaTwUBianvDmgIpVg5zeHKOicUjrye0nED82tO5v0FkwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;464&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于辅助组件并不能单独存在，所以它们都依附在绿色的服务上面。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们抽调服务集群的血肉（Web服务），只留下它的筋骨（sidecar），就可以获得下面这张图，这就是&lt;code&gt;ServiceMesh&lt;/code&gt;。可以看到里面的连接线条是非常复杂的，人工不可能完成，只能依靠平台去管理。&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.829683698296837&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/cvQbJDZsKLp5kia6WbsmCVvGg192jQLiaPjiaAmafb7v34bJja8Uhm8yAlPAA3Wz9DUjlLwY0jHbPrlkickKSgAwDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;411&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;任何东西只要一上规模了，就体现了它的复杂度。这还仅仅是只有36个服务节点的拓扑图。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不要小看这一个小小的蓝色方块。它不仅仅可以是一个辅助程序，而且可以成为基础设施。现在典型的service mesh，分为`数据平面`和`控制平面`，大多数落地的企业使用proxy方式实现了数据平面，对控制平面的实现有限。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像比较流行的&lt;code&gt;Istio&lt;/code&gt;，通过负载均衡、服务间的身份验证、监控等方法，它可以轻松地创建一个已经部署了服务的网络，而服务的代码只需很少更改甚至无需更改。通过在整个环境中部署一个特殊的 &lt;code&gt;sidecar代理&lt;/code&gt;，为服务添加 Istio 的支持，而代理会拦截微服务之间的所有网络通信，然后使用其控制平面的功能来配置和管理 Istio。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们看下它官方的功能描述：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;为 HTTP、gRPC、WebSocket 和 TCP 流量自动负载均衡。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;通过丰富的路由规则、重试、故障转移和故障注入对流量行为进行细粒度控制。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可插拔的策略层和配置 API，支持访问控制、速率限制和配额。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;集群内（包括集群的入口和出口）所有流量的自动化度量、日志记录和追踪。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;在具有强大的基于身份验证和授权的集群中实现安全的服务间通信。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以说，ServiceMesh将业务属性剥离了出去，只剩下一张大网，涵盖了所有运维和基础服务的工作。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要用它，不能说是没有代价的。其中有两点比较重要：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;网络包通过层层的代理和转发（Ambassador模式），效率会降低，排错会变困难。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;需要按照这个网格的规范进行改造，也就是写一堆适配器（Adapter模式）。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;SpringCloud的Sidecar&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说到适配器，就不禁想起了SpringCloud的Sidecar。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java里要说玩新概念，怎么能少的了Spring家族？SpringCloud同样有一个sidecar的组件，它的&lt;code&gt;maven&lt;/code&gt;坐标如下。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;&amp;lt;&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;span&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;&amp;lt;&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;spring-cloud-netflix-sidecar&lt;span&gt;&amp;lt;/&lt;span&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&amp;lt;/&lt;span&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它做的事情，更加像一个适配器。它能把一个普通的php或者nodejs服务，伪装成一个正常的SpringCloud服务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过简单的配置，我们就可以让一些其他语言开发的Web应用，加入到SpringCloud体系中来。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它的使用比较简单，在此不过多介绍。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;End&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到，我们今天的这辆车，虽然简陋，但是很高级，甚至和最前沿的ServiceMesh挂钩了。在这里，我实在是佩服计算机界的名词创造能力和抽象能力。一个简单的生产者消费者，玩出了响应式编程；一个简单的边车模式，玩出了ServicemMesh。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然这个东西比较新，但比起什么中台概念来，能够落地不务虚，是更加有技术说服力的。因为中台搞不死程序员，但会搞死公司。 &lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;未来还会有什么奇形怪状的交通工具呢？这是个未知数。请搭上&lt;code&gt;xjjdog&lt;/code&gt;的轻便列车，一块探索吧。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;p&gt;作者简介：&lt;strong&gt;小姐姐味道&lt;/strong&gt;  (xjjdog)，一个不允许程序员走弯路的公众号。聚焦基础架构和Linux。十年架构，日百亿流量，与你探讨高并发世界，给你不一样的味道。我的个人微信xjjdog0，欢迎添加好友，进一步交流。&lt;/p&gt;&lt;/blockquote&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>aca345b7edaacaccd0fdbb0dddac29a4</guid>
<title>如何优化前端性能？</title>
<link>https://toutiao.io/k/fagglng</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naKsz7mQbgaZCrLXC1msVGubPYDib0dVuU1iaS2dziccfVMicEOeLorEHB2EHlaJpqYgVON3iccEHvRzKmA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot;/&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section donone=&quot;shifuMouseDownCard(&#x27;shifu_c_008&#x27;)&quot; label=&quot;Copyright Reserved by PLAYHUDONG.&quot;&gt;&lt;p&gt;&lt;span&gt;阿里妹导读：&lt;/span&gt;&lt;span/&gt;&lt;span&gt;随着前端的范畴逐渐扩大，深度逐渐下沉，富前端必然带来的一个问题就是性能。特别是在大型复杂项目中，重前端业务可能因为一个小小的数据依赖，导致整个页面卡顿甚至崩溃。&lt;span&gt;本文&lt;/span&gt;基于Quick BI（数据可视化分析平台）历年架构变迁中性能的排查、解决和总结出的“个性”问题，尝试总结整个前端层面相对“共性”的问题，提供一些前端性能解&lt;span&gt;决&lt;/span&gt;思路。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;文末福利：超全学习资料，免费领。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;一  引发性能问题原因？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;引发性能问题的原因通常不是单方面缘由，特别是大型系统迭代多年后，长期积劳成疾造成，所以我们要必要分析找到症结所在，并按瓶颈优先级逐个击破，拿我们项目为例，大概分几个方面：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1  资源包过大&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过Chrome DevTools的Network标签，我们可以拿到页面实际拉取的资源大小（如下图）：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2587904360056259&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcuMWnzCVUAw6KdvlPcdMMt6zXyRRv5WgeU8m37kPDZds58V9jH0CibqlkX6sItgBLt10d3iacibWZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;711&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;经过前端高速发展，近几年项目更新迭代，前端构建产物也在急剧增大，因为要业务先行，很多同学引入库和编码过程并没有考虑性能问题，导致构建的包增至几十MB，这样带来两个显著的问题：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;弱(普通)网络下，首屏资源下载耗时长&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;资源解压解析执行慢&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于第一个问题，基本上会影响所有移动端用户，并且会耗费大量不必要的用户带宽，对客户是一个经济上的隐式损失和体验损失。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于第二个问题，会影响所有用户，用户可能因为等待时间过长而放弃使用。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;下图展示了延迟与用户反应：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.42341220423412207&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcuMWnzCVUAw6KdvlPcdMMMfiamSqh6uNADnjibNziaN1GrFXK03KKiafBl9r4qhQMicCcxqO7ETaWtBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;803&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2  代码耗时长&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在代码执行层面，项目迭代中引发的性能问题普遍是因为开发人员编码质量导致，大概以下几个缘由：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;不必要的数据流监听&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;此场景在hooks+redux的场景下会更容易出现，如下代码：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; FooComponent = &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;()&lt;/span&gt; =&amp;gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; data = useSelector(&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;state&lt;/span&gt; =&amp;gt;&lt;/span&gt; state.fullData);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;  &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;code-snippet__tag&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__name&quot;&gt;Bar&lt;/span&gt; &lt;span class=&quot;code-snippet__attr&quot;&gt;baz&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;{data.bar.baz}&lt;/span&gt; /&amp;gt;&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;假设fullData是频繁变更的大对象，虽然FooComponent仅依赖其.bar.baz属性，fullData每次变更也会导致Foo重新渲染。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;双刃剑cloneDeep&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;相信很多同学在项目中都有cloneDeep的经历，或多或少，特别是迭代多年的项目，其中难免有mutable型数据处理逻辑或业务层面依赖，需要用到cloneDeep，但此方法本身存在很大性能陷阱，如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; a = {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;a&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; { a } = b;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;saveData(_.cloneDeep(a)); &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上方代码正常迭代中是没有问题的，但假设哪天 &lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt; 需要扩展一个属性，保存一个ReactNode的引用，那么执行到b.tsx时，浏览器可能直接崩溃！&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Hooks之Memo&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;hooks的发布，给react开发带来了更高的自由度，同时也带来了容易忽略的质量问题，由于不再有类中明码标价的生命周期概念，组件状态需要开发人员自由控制，所以开发过程中务必懂得react对hooks组件的渲染机制，如下代码可优化的地方：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ruby&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;const Foo = () =&amp;gt; { &lt;span class=&quot;code-snippet__regexp&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;. Foo可用React.memo，避免无props变更时渲染&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    const result = calc(); &lt;span class=&quot;code-snippet__regexp&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;2&lt;/span&gt;. 组件内不可使用直接执行的逻辑，需要用useEffect等封装&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; &amp;lt;Bar result={result} /&amp;gt;; &lt;span class=&quot;code-snippet__regexp&quot;&gt;//&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt;.render处可用React.useMemo，仅对必要的数据依赖作渲染&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Immutable Deep Set&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在使用数据流的过程中，很大程度我们会依赖lodash/fp的函数来实现immutable变更，但fp.defaultsDeep系列函数有个弊端，其实现逻辑相当于对原对象作深度克隆后执行fp.set，可能带来一些性能问题，并且导致原对象所有层级属性都被变更，如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; a = { &lt;span class=&quot;code-snippet__attr&quot;&gt;b&lt;/span&gt;: { &lt;span class=&quot;code-snippet__attr&quot;&gt;c&lt;/span&gt;: { &lt;span class=&quot;code-snippet__attr&quot;&gt;d&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;123&lt;/span&gt; }, &lt;span class=&quot;code-snippet__attr&quot;&gt;c2&lt;/span&gt;: { &lt;span class=&quot;code-snippet__attr&quot;&gt;d2&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;321&lt;/span&gt; } } };&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; merged = fp.defaultsDeep({ &lt;span class=&quot;code-snippet__attr&quot;&gt;b&lt;/span&gt;: { &lt;span class=&quot;code-snippet__attr&quot;&gt;c3&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt; } }, a);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;console&lt;/span&gt;.log(merged.b.c === a.b.c); &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3  排查路径&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于这些问题来源，通过Chrome DevTools的Performance火焰图，我们可以很清晰地了解整个页面加载和渲染流程各个环节的耗时和卡顿点（如下图）：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5337209302325582&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcuMWnzCVUAw6KdvlPcdMMtHktLN5Oo2cibB0mb9tDrOoqYFx5QvHQnPJHFclzRo3onWDo7vDQAqQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;860&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当我们锁定一个耗时较长的环节，就可以再通过矩阵树图往下深入（下图），找到具体耗时较长的函数。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5360623781676414&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcuMWnzCVUAw6KdvlPcdMMkVwhcBlZRTx8IC9KUaSMoL24UWBZ1YxctRS6RtZtB83WjMpDT29aQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;513&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;诚然，通常我们不会直接找到某个单点函数占用耗时非常长，而基本是每个N毫秒函数叠加执行成百上千次导致卡顿。所以这块结合react调试插件的Profile可以很好地帮助定位渲染问题所在：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4336399474375821&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcuMWnzCVUAw6KdvlPcdMMkIOYQmSjQjsa7wJfCuZkGundb5qEkWfypYhRqxYJ3zmGaTaqaG2e7A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;761&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如图react组件被渲染的次数以及其渲染时长一目了然。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二  如何解决性能问题？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;1  资源包分析&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;作为一名有性能sense的开发者，有必要对自己构建的产物内容保持敏感，这里我们使用到webpack提供的stats来作产物分析。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;首先执行 &lt;/span&gt;&lt;span&gt;webpack --profile --json &amp;gt; ./build/stats.json&lt;/span&gt;&lt;span&gt; 得到 webpack的包依赖分析数据，接着使用 &lt;/span&gt;&lt;span&gt;webpack-bundle-analyzer ./build/stats.json&lt;/span&gt;&lt;span&gt; 即可在浏览器看到一张构建大图（不同项目产物不同，下图仅作举例）：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5219638242894057&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcuMWnzCVUAw6KdvlPcdMMtAGJHDRN8emOmIj5gaSoeb1cEZDjJcWjH2I6yEstbFHrICoL1ey0kw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;774&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;当然，还有一种直观的方式，可以采用Chrome的Coverage功能来辅助判定哪些代码被使用（如下图）：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9741496598639455&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKcuMWnzCVUAw6KdvlPcdMMaJvviawrtliasWtfYhfaH0cryfnhyiaZnaugDGTXrXpSnu02fKnLAIXgQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;735&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;红色表示未执行过的代码&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;最佳构建方式&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通常来讲，我们组织构建包的基本思路是：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;按entry入口构建。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;一个或多个共享包供多entry使用。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;而基于复杂业务场景的思路是：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;webpack 4中提供了新的插件 &lt;/span&gt;&lt;span&gt;splitChunks&lt;/span&gt;&lt;span&gt; 来解决代码分离优化的问题，它的默认配置如下：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;properties&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__meta&quot;&gt;module.exports&lt;/span&gt; = &lt;span class=&quot;code-snippet__string&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;//...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;optimization&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;splitChunks&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;chunks&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;async&#x27;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;minSize&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;20000,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;minRemainingSize&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;0,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;maxSize&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;0,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;minChunks&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;1,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;maxAsyncRequests&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;30,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;maxInitialRequests&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;30,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;automaticNameDelimiter&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;~&#x27;,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;enforceSizeThreshold&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;50000,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;cacheGroups&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__attr&quot;&gt;defaultVendors&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__attr&quot;&gt;test&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;/[\\/]node_modules[\\/]/,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__attr&quot;&gt;priority&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;-10&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__attr&quot;&gt;},&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__attr&quot;&gt;default&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;{&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__attr&quot;&gt;minChunks&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;2,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__attr&quot;&gt;priority&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;-20,&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    &lt;span class=&quot;code-snippet__attr&quot;&gt;reuseExistingChunk&lt;/span&gt;: &lt;span class=&quot;code-snippet__string&quot;&gt;true&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;                }&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__attr&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__attr&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;};&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;根据上述配置，其分离chunk的依据有以下几点：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;理论上webpack默认的代码分离配置已经是最佳方式，但如果项目复杂或耦合程度较深，仍然需要我们根据实际构建产物大图情况，调整我们的chunk split配置。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;解决TreeShaking失效&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;blockquote&gt;&lt;section&gt;&lt;span/&gt;&lt;span&gt;“你项目中有60%以上的代码并没有被使用到！”&lt;/span&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;treeshaking的初衷便是解决上面一句话中的问题，将未使用的代码移除。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;webpack默认生产模式下会开启treeshaking，通过上述的构建配置，理论上应该达到一种效果“没有被使用到的代码不应该被打入包中”，而现实是“你认为没有被使用的代码，全部被打入Initial包中”，这个问题通常会在复杂项目中出现，其缘由就是代码副作用（code effects）。由于webpack无法判定某些代码是否“需要产生副作用”，所以会将此类代码打入包中（如下图）：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-croporisrc=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naKsz7mQbgaZCrLXC1msVGubHW0kNgzibHnShQic0ia9FwibTFAeS4fNnR2L1LZuTCebv6VjMDxUhPuKAg/640?wx_fmt=png&quot; data-cropx1=&quot;248.8235294117647&quot; data-cropx2=&quot;705&quot; data-cropy1=&quot;126.85121107266436&quot; data-cropy2=&quot;598.8840830449826&quot; data-ratio=&quot;1.0350109409190371&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naKsz7mQbgaZCrLXC1msVGubKfXeFLwQDBVo2zxHd4cUPokHozAQrYKSKqeQgdPk3L1PVJadL6Xsxw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;457&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;所以，你需要明确知道你的代码是否有副作用，通过这句话判定：“关于‘&lt;span&gt;副作用&lt;/span&gt;’的定义是，在导入时会执行特殊行为的代码（修改全局对象、立即执行的代码等），而不是仅仅暴露一个 export 或多个 export。举例说明，例如 polyfill，它影响全局作用域，并且通常不提供 export。”&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对此，解决方法就是告诉webpack我的代码没有副作用，没有被引入的情况下可以直接移除，告知的方式即：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;模块规范&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由此，要使得构建产物达到最佳效果，我们在编码过程中约定了以下几点模块规范：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;2  Mutable数据&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基本上通过Performance和React插件提供的调试能力，我们基本可以定位问题所在。但对于mutable型的数据变更，我这里也结合实践给出一些非标准调试方式：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;冻结定位法&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;众所周知，数据流思想的产生缘由之一就是避免mutable数据无法追溯的问题（因为你无法知道是哪段代码改了数据），而很多项目中避免不了mutable数据更改，此方法就是为了解决一个棘手的mutable数据变更问题而想出的方法，这里我暂时命名为“冻结定位法”，因为原理就是使用冻结方式定位mutable变更问题，使用相当tricky：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;constob j= {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__attr&quot;&gt;prop&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;42&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;Object&lt;/span&gt;.freeze(obj);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;obj.prop=&lt;span class=&quot;code-snippet__number&quot;&gt;33&lt;/span&gt;; &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;Mutable追溯&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;此方法也是为了解决mutable变更引发数据不确定性变更问题，用于实现排查的几个目的：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;属性在什么地方被读取。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;属性在什么地方被变更。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;属性对应的访问链路是什么。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如下示例，对于一个对象的深度变更或访问，使用 &lt;/span&gt;&lt;span&gt;watchObject&lt;/span&gt;&lt;span&gt; 之后，不管在哪里设置其属性的任何层级，都可以输出变更相关的信息（stack内容、变更内容等）：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;swift&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;const a = { b: { &lt;span class=&quot;code-snippet__built_in&quot;&gt;c&lt;/span&gt;: { d: &lt;span class=&quot;code-snippet__number&quot;&gt;123&lt;/span&gt; } } };&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;watchObject(a);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;const &lt;span class=&quot;code-snippet__built_in&quot;&gt;c&lt;/span&gt; =a.b.&lt;span class=&quot;code-snippet__built_in&quot;&gt;c&lt;/span&gt;;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;c&lt;/span&gt;.d =&lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;watchObject&lt;/span&gt;&lt;span&gt; 的原理即对一个对象进行深度 &lt;/span&gt;&lt;span&gt;Proxy&lt;/span&gt;&lt;span&gt; 封装，从而拦截get/set权限，详细可参考: &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;https://gist.github.com/wilsoncook/68d0b540a0fea24495d83fc284da9f4b&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;避免Mutable&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通常像react这种技术栈，都会配套使用相应的数据流方案，其与mutable是天然对立的，所以在编码过程中应该尽可能避免mutable数据，或者将两者从设计上分离（不同store），否则出现不可预料问题且难以调试&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;3  计算&amp;amp;渲染&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;最小化数据依赖&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在项目组件爆炸式增长的情况下，数据流store内容层级也逐渐变深，很多组件依赖某个属性触发渲染，这个依赖项需要尽可能在设计时遵循最小化原则，避免像上方所述，依赖一个大的属性导致频繁渲染。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;合理利用缓存&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;（1）计算结果&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;在一些必要的cpu密集型计算逻辑中，务必采用 &lt;/span&gt;&lt;span&gt;WeakMap&lt;/span&gt;&lt;span&gt; 等缓存机制，存储当前计算终态结果或中间状态。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;（2）组件状态&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于像hooks型组件，有必要遵循以下两个原则：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;避免cpu密集型函数&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;某些工具类函数，其复杂度跟随入参的量级上升，而另外一些本身就会耗费大量cpu时间。针对这类型的工具，要尽量避免使用，若无法避免，也可通过 “控制入参内容（白名单）” 及 “异步线程（webworker等）”方式做到严控。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;比如针对 &lt;/span&gt;&lt;span&gt;_.cloneDeep&lt;/span&gt;&lt;span&gt; ，若无法避免，则要控制其入参属性中不得有引用之类的大型数据。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;另外像最上面描述的immutable数据深度merge的问题，也应该尽可能控制入参，或者也可参考使用自研的immutable实现&lt;span&gt;：&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;https://gist.github.com/wilsoncook/fcc830e5fa87afbf876696bf7a7f6bb1&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; a = { &lt;span class=&quot;code-snippet__attr&quot;&gt;b&lt;/span&gt;: { &lt;span class=&quot;code-snippet__attr&quot;&gt;c&lt;/span&gt;: { &lt;span class=&quot;code-snippet__attr&quot;&gt;d&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;123&lt;/span&gt; }, &lt;span class=&quot;code-snippet__attr&quot;&gt;c2&lt;/span&gt;: { &lt;span class=&quot;code-snippet__attr&quot;&gt;d2&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;321&lt;/span&gt; } } };&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;const&lt;/span&gt; merged = immutableDefaultsDeep(a, { &lt;span class=&quot;code-snippet__attr&quot;&gt;b&lt;/span&gt;: { &lt;span class=&quot;code-snippet__attr&quot;&gt;c3&lt;/span&gt;: &lt;span class=&quot;code-snippet__number&quot;&gt;3&lt;/span&gt; } });&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;console&lt;/span&gt;.log(merged === a); &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__built_in&quot;&gt;console&lt;/span&gt;.log(merged.b.c === a.b.c); &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;三  写在最后&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;以上，总结了Quick BI性能优化过程中的部分心得和经验，性能是每个开发者不可绕过的话题，我们的每段代码，都对标着产品的健康度。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;&lt;img data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;20&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLQbZm5RRBKZU73do88AfZkrvDDfjeXBDQgvwdhgGYoffhiaZMnDELmjk2eoUlDv5RJrEAel0jDUSg/640?wx_fmt=png&quot;/&gt;  福利来了  &lt;img data-ratio=&quot;1&quot; data-type=&quot;png&quot; data-w=&quot;20&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naLQbZm5RRBKZU73do88AfZkrvDDfjeXBDQgvwdhgGYoffhiaZMnDELmjk2eoUlDv5RJrEAel0jDUSg/640?wx_fmt=png&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;span&gt;超全学习资料免费领&lt;/span&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;开发者如何自我提升？如何拓展自身技能，补齐技术短板？阿里巴巴有哪些技术沉淀，如何学习借鉴？阿里技术免费开放&lt;span&gt;超全开发者学习资料&lt;/span&gt;，含上百本阿里系技术电子书、&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;各&lt;/span&gt;&lt;span&gt;技术&lt;/span&gt;&lt;span&gt;大会资料合集、知识图谱、面试宝典等，助力所有开发者共同学习进步！&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;识别下方二维码加&lt;/span&gt;&lt;/span&gt;&lt;span&gt;「阿里妹」微信好友，回复 “资料大全” 立即领取吧~&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naKcuMWnzCVUAw6KdvlPcdMMMboIziaXPtwOQCAKdnvVeia5EFLibNLQxicpe6LfPb3iagTUIy2ic1Qd02Cw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;img class=&quot;__bg_gif&quot; data-ratio=&quot;1&quot; data-type=&quot;gif&quot; data-w=&quot;400&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/Z6bicxIx5naLWBBEcl44aIic1Mthe1nZiaramW5s4e8WwyCYYbTzu6uPBpgI6sxNXNymEnOYKpJpcrItUia7lS64mA/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;section data-brushtype=&quot;text&quot;&gt;&lt;span&gt;戳我，学前端开发。&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>8dd672c31960c7af12ec535836f19326</guid>
<title>用 Python 绘制地理图</title>
<link>https://toutiao.io/k/f1d73bn</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;&lt;span&gt;当您的数据包含地理信息时，丰富的地图可视化可以为您理解数据和解释分析结果的最终用户提供重要价值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.9485714285714286&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_jpg/X5F1ZlNQYgWyhWSzaAhicA4icvXOAZDyFFdElqp8O8EyMia18c3ffqykW41kOHY909ZLKwgia6uibUU0ZjsCFNzefQQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;875&quot;/&gt;&lt;/p&gt;&lt;h3&gt;Plotly&lt;/h3&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;37&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;Plotly是一个著名的库，用于在Python中创建交互式绘图和仪表板。&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/em&gt;安装Plotly&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.09022556390977443&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/X5F1ZlNQYgWyhWSzaAhicA4icvXOAZDyFFKZKx1pUArKZsgq8Ks6wNzicjhpZKJ5aaM3B7hlh4b7u9tI1iaibfGnaFA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;931&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;在命令提示符中运行这两个命令，以&lt;/span&gt;&lt;span&gt;在我们的本地计算机上&lt;/span&gt;&lt;span&gt;安装 &lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;plotly&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt; 和 &lt;/span&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;cufflinks &lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;span&gt;及其所有软件包。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;Choropleth&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;地图&lt;/strong&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;Choropleth地图是流行的主题地图，用于通过各种阴影图案或预定地理区域（即国家/地区）上的符号表示统计数据。&lt;/span&gt;&lt;span&gt;它们擅长利用数据轻松表示整个区域所需测量的可变性。&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;Choropleth地图是如何工作的？&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;Choropleth Maps显示与数据变量相关的彩色，阴影或图案化的划分的地理区域或区域。&lt;/span&gt;&lt;span&gt;这提供了一种可视化地理区域内值的方法，该值可以显示所显示位置的变化或模式。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;在Python中使用Choropleth&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;在这里，我们将使用 &lt;/span&gt;&lt;span&gt; 2014年全球不同国家/地区的电力消耗&lt;/span&gt;&lt;/span&gt;数据集&lt;span&gt;。（https://github.com/ahmadbinshafiq/Geographical-Plotting---Python/blob/master/2014_World_Power_Consumption）&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;好的，让我们开始吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;导入库&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.16181229773462782&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/X5F1ZlNQYgWyhWSzaAhicA4icvXOAZDyFFFLiaj2fgpmFYXAphzjjwm1avPsOhPnxLF5ncqNwW0e7BD1yc52sYYibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;927&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;在这里，  &lt;/span&gt;&lt;/span&gt;&lt;em&gt;&lt;span&gt;&lt;span&gt;init_notebook_mode（connected = True）&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span&gt;&lt;span&gt; 将Javascript连接到我们的笔记本。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;创建/解释我们的DataFrame&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.07991360691144708&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/X5F1ZlNQYgWyhWSzaAhicA4icvXOAZDyFFLphqQmokSzYUjvEo8kCSTXCrsLyYZOlgOZpTj0ibVyVwvM9MY9mkichg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;926&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.19101123595505617&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/X5F1ZlNQYgWyhWSzaAhicA4icvXOAZDyFF90JaiaV3VbtFcKPq80LQgh5DNDUVUI17eROnrrciccVndbrvnXYfKnMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;801&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这里，我们有3列，并且所有列都有219个非空条目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.06989247311827956&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/X5F1ZlNQYgWyhWSzaAhicA4icvXOAZDyFFNjUxzzmAk7NMy8YzgiczcPXUabCXg2oN8gIp22qNrmL2bNyWB2Xfo6Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;930&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.22400990099009901&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/X5F1ZlNQYgWyhWSzaAhicA4icvXOAZDyFFn9ENc4ibEAGN57bx1ibdaam95ic7Ut3KTPuHaFNCjtGxv2su7kJ5PgLXw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;808&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;将我们的数据编译成字典&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.247557003257329&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/X5F1ZlNQYgWyhWSzaAhicA4icvXOAZDyFFBsrEJ4k37qjut2ib1bdsGEg4CuOTg4ia9byicjckwB4M7vXn1EFyL8gEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;921&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;type =&#x27;choropleth&#x27;&lt;/em&gt;&lt;span&gt;：定义地图的类型，即这种情况下的choropleth。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;colorscale =&#x27;Viridis&#x27;&lt;/em&gt;&lt;span&gt;：显示一个颜色图（f&lt;/span&gt;&lt;em&gt;或更多颜色比例，请参阅 &lt;/em&gt;&lt;em&gt;此处&lt;/em&gt;&lt;em&gt;）。&lt;/em&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;location = df [&#x27;Country&#x27;]&lt;/em&gt;&lt;span&gt;&lt;span&gt;：添加所有国家&lt;/span&gt;&lt;em&gt;&lt;span&gt;/地区&lt;/span&gt;&lt;/em&gt;&lt;span&gt;的列表。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;locationmode =&#x27;国家名称&#x27;&lt;/em&gt;&lt;span&gt;：因为我们在数据集中有国家名称，所以我们将位置模式设置为&#x27;国家名称&#x27;。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;z&lt;/em&gt;&lt;span&gt;：显示每个状态的功耗的整数值列表。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;text = df [&#x27;Country&#x27;]&lt;/em&gt;&lt;span&gt;&lt;span&gt;：将鼠标悬停在地图上的每个状态元素时显示一个文本。&lt;/span&gt;&lt;span&gt;在这种情况下，它是国家本身的名称。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;&lt;em&gt;colorbar = {&#x27;title&#x27;：&#x27;Power KWH&#x27;}&lt;/em&gt;&lt;span&gt;&lt;span&gt;：包含有关右侧栏信息的字典。&lt;/span&gt;&lt;span&gt;在这里，颜色栏包含侧边栏的标题。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.11974110032362459&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/X5F1ZlNQYgWyhWSzaAhicA4icvXOAZDyFF0XteXtl5ZGgKpibnfHFiaoBic8Gt2YJEnUvQ3bDOcUIRexvRghEaxQDPw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;927&quot;/&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;布局&lt;/em&gt;&lt;em&gt; -&lt;/em&gt;&lt;span&gt;&lt;span&gt;一个Geo对象，可用于控制&lt;/span&gt;&lt;span&gt; 在其上绘制数据&lt;/span&gt;&lt;span&gt;的基础&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;地图&lt;/strong&gt;&lt;span&gt;&lt;span&gt;的外观 &lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;这是一本嵌套的字典，其中包含有关地图/绘图外观的所有相关信息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;生成图/图&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.08396124865446716&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/X5F1ZlNQYgWyhWSzaAhicA4icvXOAZDyFFFFsgYyqDJDToKh17M0BMkJtQT283q3sdZ14miaibMAohpp244SicPpoKg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;929&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5283333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_gif/X5F1ZlNQYgWyhWSzaAhicA4icvXOAZDyFFjbTWrJaAYnd6KDB7AEXJTswv0kniaXrQ6UgiaiaaWlgZdtwRiazq9fniaUQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;span&gt;生成了“ 2014年世界电力消耗”的choropleth地图，从上面可以看到，当每个国家/地区悬停在地图上的每个元素上时，都会显示其名称和电力消耗（以kWh为单位）。&lt;/span&gt;&lt;span&gt;数据在一个特定区域中越集中，地图上的颜色阴影越深。&lt;/span&gt;&lt;span&gt;“中国”的耗电量最大，因此其颜色最深。&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;密度图&lt;/span&gt;&lt;/h3&gt;&lt;p&gt; &lt;/p&gt;&lt;p&gt;&lt;span&gt;密度映射只是一种显示点或线可能集中在给定区域中的方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;在Python中使用密度图&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;在这里，我们将使用世界范围 &lt;/span&gt;&lt;span&gt; 的地震及其震级&lt;/span&gt;&lt;/span&gt;数据集&lt;span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;好的，让我们开始吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;导入库&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.08971553610503283&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/X5F1ZlNQYgWyhWSzaAhicA4icvXOAZDyFFwibBtn6jS4Via6uReBCYicZbKyaIZqsbY6RyV2U9OIqgvRtcNpgsKHJYw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;914&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;创建/解释我们的DataFrame&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.12573099415204678&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/X5F1ZlNQYgWyhWSzaAhicA4icvXOAZDyFFjcibBGBjib0ictUWvpPdQmTU9NyqgpDRPZxwEYKZibiamYq71YhkXkaK9hw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;684&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.513986013986014&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/X5F1ZlNQYgWyhWSzaAhicA4icvXOAZDyFFqMTmXuC61G98FibfJspI0Yw2lhIppyDTo64WxiaibSaZM91MHK3a7U9hQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;286&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在这里，我们有4列，并且所有列都有23412个非空条目。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.06524064171122995&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/X5F1ZlNQYgWyhWSzaAhicA4icvXOAZDyFFTAOIw1EOWwGrluh427Bzibt4JSPNvdsJFEzdXEsbMsJULoLKkZNjWnA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;935&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5214521452145214&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/X5F1ZlNQYgWyhWSzaAhicA4icvXOAZDyFF8Ky2VbH6libAhNLMtRzVcZB4Cibp5Y8RIBcOFokA5pe2iaKKOsBicUWR8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;303&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;绘制数据&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.13885898815931108&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/X5F1ZlNQYgWyhWSzaAhicA4icvXOAZDyFFEibVjJ9g2r6PtVwia8HsZWweiaOypCmNz134EBnWSbeC7bNwIOxrDia4KQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;929&quot;/&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;lat =&#x27;Latitude&#x27;&lt;/em&gt;&lt;span&gt;&lt;span&gt;：获取数据框的&lt;/span&gt;&lt;em&gt;&lt;span&gt;“纬度”&lt;/span&gt;&lt;/em&gt;&lt;span&gt;列。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;lon =&#x27;Longitude&#x27;&lt;/em&gt;&lt;span&gt;：获取数据框的经度列。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;z&lt;/em&gt;&lt;span&gt;：显示地震震级的整数列表。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;radius = 10&lt;/em&gt;&lt;span&gt;：设置每个点的影响半径。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;center = dict（lat = 0，lon = 180）&lt;/em&gt;&lt;span&gt;：设置字典中地图的中心点。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;zoom = 0&lt;/em&gt;&lt;span&gt;：设置地图缩放级别。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;mapbox_style =&#x27;stamen-terrain&#x27;&lt;/em&gt;&lt;span&gt;&lt;span&gt;：设置基本地图样式。&lt;/span&gt;&lt;span&gt;在这里，“雄蕊地形”是基本地图样式。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;em&gt;fig.show（）&lt;/em&gt;&lt;span&gt;：显示地图。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;地图&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4488697524219591&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/sz_mmbiz_png/X5F1ZlNQYgWyhWSzaAhicA4icvXOAZDyFF8hPVYY5NMFOUq4Kmp4FFsQ2e2ItdDibV68fushaerI49Q5kbZls3L0w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;929&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们已经绘制了“地震及其烈度”的密度图，从上面我们可以看到，它覆盖了遭受地震破坏的所有领土，并且还显示了当我们将&lt;/span&gt;&lt;strong&gt;鼠标悬停 &lt;/strong&gt;&lt;span&gt;&lt;span&gt;在上方&lt;/span&gt;&lt;span&gt;时每个区域的地震烈度。&lt;/span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;由于数据格式多种多样，有时使用plotly进行地理绘图可能会遇到一些挑战，因此请参考该 &lt;/span&gt;备忘单，&lt;span&gt; 了解所有类型的plotly plot语法。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>