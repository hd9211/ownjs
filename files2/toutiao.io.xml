<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>72806cfa33253887239c761c7d38f57d</guid>
<title>这几款 JVM 故障诊断处理工具你还不会？</title>
<link>https://toutiao.io/k/dux0ogl</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;前言&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前几天中午正在和同事最近聊股市较好，这几天每天都可以喝点肉汤，心里还是挺高兴的；正在这个时候收到了线上告警邮件和运维同学的消息，“你们有服务挂了！”，心里一紧，立马打开电脑看来下线上cat监控大盘，发现很多服务都在报错，根据cat上的监控日志很快发现了其中一个服务内存溢出导致其他调用服务也有问题，竟然已经定位到了出问题的服务，那就简单了，没有是重启解决不了的问题，重启之后很快服务都恢复正常了。几分钟之后又报错了，同样也是这个服务内存溢出，经过排查后发现该服务的堆内存被改小了，好家伙，运维同学不讲武德，搞偷袭，趁我没反应过来调了内存，内存调整回去之后服务就恢复了正常。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事后把线上的快照文件拖了下来分析，发现本身这个项目的代码也有些问题，本文就整理了一下JVM常用的分析工具。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;命令行工具&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在安装完JDK之后在JAVA_HOME/bin目录下JDK已经提供了很多命令行的工具&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.06375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3L6TRz9Y0UdvzxE2DGJosqxbc4qu9pJCWZejq6WtqCssK83AEK3UMrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可能我们最常用的就是&lt;code&gt;java&lt;/code&gt;、&lt;code&gt;javac&lt;/code&gt;这两个命令，除了这两个命令之外还有提供很多其他的实用工具，本文主要来一起学习对JVM监控诊断工具&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;虚拟机进程状况工具（jps）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该工具的功能比较单一，与linux中的ps功能类似，用来列出正在运行的虚拟机进程，并显示出运行的主类和进程号&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命令格式：&lt;code&gt;jps [option] [hostid]&lt;/code&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;如果需要查看远程机器的jvm进程需要填写&lt;code&gt;hostid&lt;/code&gt;，并且需要使用RMI，比如：&lt;code&gt;rmi://192.168.2.128:12345&lt;/code&gt;&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的选项：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-q&lt;/code&gt; : 只显示出虚拟机的进程id（lvmid），省略主类名&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-m&lt;/code&gt; : 输出启动时传递给主类的参数&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-l&lt;/code&gt; : 显示出主类的全名，包括jar包路径&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-v&lt;/code&gt; : 输出虚拟机进程启动时的JVM参数&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23290203327171904&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3zIQRpQAtZibR8uPLX3MU1OoibCvIQQZLFLia31ermSkeW8icYvYdPLLPnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;541&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;虚拟机统计信息监控工具（jstat）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于监控虚拟机运行状态信息的命令行工具，可以提供内存，垃圾收集等运行时的数据&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命令格式：&lt;code&gt;jstat [option vmid] [interval [s|ms] [count]]&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;interval表示间隔多久时间查询一次，count表示查询多少次，比如：每个两秒查询一次进程52412的垃圾收集情况，共查询5次&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;jstat -gc 52412 2s 5&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.10375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3OObJnsw4ho5Gam75mB4vIA1kMeuFBLmdoHYajmf15ibYh1iaPz1GkZxA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的选项：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-class&lt;/code&gt;: 监控类装载，卸载次数和总空间以及加载类的耗时&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-gc&lt;/code&gt;: 监控java堆的情况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-gcutil&lt;/code&gt;: 主要输出各个空间使用的百分比&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-gcnew&lt;/code&gt;: 主要是监控新生代的GC状况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-gcold&lt;/code&gt;: 监控老年代的GC状况&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-compiler&lt;/code&gt;: 输出JIT编译器编译过的方法和耗时信息&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;查看堆空间的使用百分比: &lt;code&gt;jstat -gcutil 52412 2s 5&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.16973684210526316&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN39ticu2fcOAGShUKaqFQzmIfZtLAgGceHoruTjg6AOZibahyoIT9bwPJA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;760&quot;/&gt;&lt;/figure&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;java配置信息工具（jinfo）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过&lt;code&gt;jinfo&lt;/code&gt;实时的查看和调整虚拟机的各项参数；可以通过&lt;code&gt;jps -v&lt;/code&gt;查看虚拟机启动时候指定的参数信息，如果需要查看未显示指定的参数默认值也可以通过&lt;code&gt;jinfo -flag&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;jinfo -flag CMSInitiatingOccupancyFraction 52412&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.08875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3HcQOFibOt6HbrdaIeRvEVMhicicPAfgichnqbgRCQSAjQes4J6ZtURl3Rw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jinfo除了可以查看参数以外，还可以在运行时修改一些允许被修改的参数&lt;/p&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;Java内存映像工具（jmap）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;jmap用于生成JVM堆的快照文件，除了使用jmap工具，我们通常也会在配置JVM的启动参数 &lt;code&gt;-XX:+HeapDumpOnOutOfMemoryError&lt;/code&gt; 让JVM在发送内存溢出之后自动生成dump文件。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命令格式：&lt;code&gt;jmap [option] vmid&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如生成java堆的快照文件&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;jmap -dump:live,format=b,file=/Users/huaan9527/Desktop/heap.hprof 59950&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的选项：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-F&lt;/code&gt;: 当虚拟机对-dump选项没有响应时可用选择使用这个参数强制生成快照&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-histo&lt;/code&gt;: 显示出堆中对象统计信息。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;堆栈跟踪工具（jstack）&lt;/span&gt;&lt;span/&gt;&lt;/h4&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;用于生成JVM当前线程的快照信息。通常用于查询什么原因导致线程长时间的停顿，比如：线程死循环，死锁，等待网络/IO&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;命令格式：&lt;code&gt;jstack [option] vmid&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的选项：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-F&lt;/code&gt;: 当请求不被响应时强制输出&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-l&lt;/code&gt;: 除了显示堆栈外，还需要显示锁的信息&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;code&gt;-m&lt;/code&gt;: 如果调用到本地方法，显示出C/C++的堆栈&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;VisualVM 可视化工具&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VisualVM是目前JDK自带的功能最强的运行监视和故障处理程序，在VisualVM之前，JDK也提供了一款可视化工具JConsole，由于JConsole的所有功能在VisualVM都有，所以可视化工具大家几乎都选择使用VisualVM。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;VisualVM本身是基于Netbean开发的，所以具备了插件扩展功能，安装插件之后上面介绍的所有命令行的工具的功能都可以在VisualVM中使用。可以在在JAVA_HOME/bin目录下执行&lt;code&gt;jvisualvm&lt;/code&gt;启动。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;插件安装
默认情况VisualVM提供的功能很少，需要我们在菜单栏-&amp;gt;工具-&amp;gt;插件里面安装插件，我这是全部插件都安装了&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.59875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3QGVcxoRL0D1EaoyiaI5tEqpBEGL0yXhmHe2NfcKJtyvic20C2RRhJP1g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;功能演示&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.46981627296587924&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3UEXOHP6iauXffDAODBG85QP4PqKosiajOGz9GVXUib8x6c9HDJed2DxVw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;762&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;显示出当前本机所有的JVM进程，这里显示的内容和前面说的命令行&lt;code&gt;jps&lt;/code&gt;显示的内容一样&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6975&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3ZZs5Y4qialznXKtKIj1MibSTrqWycDS8UYoiaadvzqXOn2IR9DOiaWc0Ww/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当前虚拟机启动信息的展示，比如：JVM启动参数、系统参数&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.66&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3IuCCtJENo62LdUe0eVNAlVESYFVCQGKQjJib0TPxwcpWVLIuuCj6ia8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个页面相当于命令jstat的功能，显示出了CPU, 内存，线程，类装载当前处于什么情况&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;生成dump文件可以在应用程序窗口右键菜单中选择，也可以在这个页面点击右上角的&lt;code&gt;堆dump&lt;/code&gt;&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;Visual GC
此页主要展示了GC相关的信息，这是在性能调优时常用的页面之一&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3525&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3uMn8Ciaga5rTDzRsjfjMa36O6GGgez4Cuj1EozA2VjwHnEiczK8EfxjA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以写个程序来观看下这个截图各个内存区域的变化情况，为了让图的效果明显需要修改JVM的启动参数&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;-Xmx100m -Xms100m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/Users/huaan9527/Desktop&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public static void main(String[] args) {&lt;br/&gt;    List&amp;lt;DataTest&amp;gt; datas = new ArrayList&amp;lt;&amp;gt;();&lt;br/&gt;&lt;br/&gt;    IntStream.range(0, 10000).forEach(index -&amp;gt; {&lt;br/&gt;        datas.add(new DataTest());&lt;br/&gt;&lt;br/&gt;        try {&lt;br/&gt;            Thread.sleep(50);&lt;br/&gt;        } catch (InterruptedException e) {&lt;br/&gt;            e.printStackTrace();&lt;br/&gt;        }&lt;br/&gt;    });&lt;br/&gt;&lt;br/&gt;    System.gc();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;static class DataTest {&lt;br/&gt;    byte[] bytes = new byte[1024];&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5325&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3TJRzV0hnQgqJyXvS7icdAw8Rdh0wDAeaY3evvibsq9kEloJF3VNYLxOw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程
本页的功能相当于命令行工具&lt;code&gt;jstack&lt;/code&gt;，主要是用于检查什么原因导致线程长时间等待，我们写程序来演示下等待外部资源、锁等待、死循环这几种请求&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「等待外部资源」&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public static void main(String[] args) throws IOException {&lt;br/&gt;    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));&lt;br/&gt;    System.out.println(reader.readLine());&lt;br/&gt;    try {&lt;br/&gt;        Thread.sleep(1000000);&lt;br/&gt;    } catch (InterruptedException e) {&lt;br/&gt;        e.printStackTrace();&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;选中main线程，右侧会看到当前线程运行到了readBytes，等待键盘输入&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.395&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN30YP4cEJicbw4ibpa7HpHV68d8qiaExhstP9l0eMdQmrltjZJrwS7Is9JQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们在控制台输入之后再次查看main线程的状态，此时进入了TIME_WAIT状态&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.24375&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3vF9IMG5fFrYAq5GkB0ta3yLZlHrm7ccRfCqU7VDHEz9hRVQJLsZKMg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「锁等待」&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public static void main(String[] args) throws IOException, InterruptedException {&lt;br/&gt;    Thread thread = createLockThread(new Object());&lt;br/&gt;    thread.join();&lt;br/&gt;}&lt;br/&gt;&lt;br/&gt;public static Thread createLockThread(final Object lock) {&lt;br/&gt;    Thread lockThread = new Thread(() -&amp;gt; {&lt;br/&gt;        synchronized (lock) {&lt;br/&gt;            try {&lt;br/&gt;                lock.wait();&lt;br/&gt;            } catch (InterruptedException e) {&lt;br/&gt;                e.printStackTrace();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;    }, &lt;span&gt;&quot;lockThread&quot;&lt;/span&gt;);&lt;br/&gt;    lockThread.start();&lt;br/&gt;    &lt;span&gt;return&lt;/span&gt; lockThread;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.34125&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3TktpB0w3QcrBiadrLic8Jz2wErvo24dZRtXCCNc9os2CQJJrESuofvfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;lockThread线程在等待lock对象的notify方法被调用，此时处于WAITING状态，在被唤醒之前是不会再分配执行时间&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「死循环」&lt;/strong&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;public static void main(String[] args) throws IOException, InterruptedException {&lt;br/&gt;    &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;) ;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.25625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/ggRgNal7zG9kicVo0UGe8hmEJFxcQSRN3LDibRDrJ6XM9pYXlHdpupiauyXORbYfdsDOsDzuACnEia4uURESibn4aWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;800&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程一直处于运行状态，从堆栈追踪里可以看出代码一直停留在了191行，在空循环上用尽分配的执行时间&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;总结&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本篇介绍了命令行工具和可视化工具，下篇实战演示下如何通过这些工具对&lt;strong&gt;「Idea运行速度调优」&lt;/strong&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;写到最后&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;文中或许会存在或多或少的不足、错误之处，有建议或者意见也非常欢迎大家给我留言。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后，&lt;strong&gt;「白嫖不好，创作不易」&lt;/strong&gt;，希望朋友们可以&lt;strong&gt;「点赞」&lt;/strong&gt;，因为这些就是我分享的全部动力来源🙏&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>20ee1157d866bed603d03131c7cca4e6</guid>
<title>面试官问：“在项目中用过多线程吗？” 你就把这个案例讲给他听</title>
<link>https://toutiao.io/k/tgp1ua8</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在面试当中，有时候会问到&lt;strong&gt;你在项目中用过多线程么？&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于普通的应届生或者工作时间不长的初级开发  ？？？—— crud仔流下了没有技术的眼泪。&lt;/p&gt;&lt;img data-ratio=&quot;1&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJjUTFMSmfLCYF8L6PlhgCQYp5sGBCIzm5HAVwv8sllu19YibQa32zfMg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;300&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;博主这里整理了项目中用到了多线程的一个简单的实例，希望能对你有所启发。&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;多线程开发实例&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;应用背景&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;应用的背景非常简单，博主做的项目是一个审核类的项目，审核的数据需要推送给第三方监管系统，这只是一个很简单的对接，但是存在一个问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们需要推送的数据大概三十万条，但是第三方监管提供的接口只支持单条推送（别问为什么不支持批量，问就是没&lt;span&gt;讨&lt;/span&gt;撕&lt;span&gt;论&lt;/span&gt;比&lt;span&gt;好&lt;/span&gt;过）。可以估算一下，三十万条数据，一条数据按3秒算，大概需要250（为什么恰好会是这个数）个小时。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以就考虑到引入多线程来进行并发操作，降低数据推送的时间，提高数据推送的实时性。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2850595783684693&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJoeKuibMZJrNYKWXOCuhKl5cib1GVQWTfibHN2qAozc2jkSM9X0OriaicicwQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1091&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;业务示例&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;设计要点&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;防止重复&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们推送给第三方的数据肯定是不能重复推送的，必须要有一个机制保证各个线程推送数据的隔离。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有两个思路：&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;将所有数据取到集合（内存）中，然后进行切割，每个线程推送不同段的数据&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;li&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;/li&gt;&lt;ol class=&quot;list-paddingleft-2&quot; start=&quot;2&quot;&gt;&lt;li&gt;&lt;section&gt;利用 数据库分页的方式，每个线程取 [start,limit] 区间的数据推送，我们需要保证start的一致性&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里采用了第二种方式，因为考虑到可能数据量后续会继续增加，把所有数据都加载到内存中，可能会有比较大的内存占用。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;失败机制&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们还得考虑到线程推送数据失败的情况。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果是自己的系统，我们可以把多线程调用的方法抽出来加一个事务，一个线程异常，整体回滚。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;但是是和第三方的对接，我们都没法做事务的，所以，我们采用了直接在数据库记录失败状态的方法，可以在后面用其它方式处理失败的数据。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;&lt;span/&gt;线程池选择&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在实际使用中，我们肯定是要用到线程池来管理线程，关于线程池，我们常用 ThreadPoolExecutor提供的线程池服务，SpringBoot中同样也提供了线程池异步的方式，虽然SprignBoot异步可能更方便一点，但是使用ThreadPoolExecutor更加直观地控制线程池，所以我们直接使用ThreadPoolExecutor构造方法创建线程池。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大概的技术设计示意图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4625322997416021&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJ5Ndqibz0WmpUMk6xZmaO0wo6pO34Sode5OnXrQ0m7O6R1QbAjs1NhaQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;774&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;设计示意图&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;核心代码&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面叭叭了一堆，到了show you code的环节了。我将项目里的代码抽取出来，简化出了一个示例。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;核心代码如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;/**&lt;br/&gt; * &lt;span&gt;@Author&lt;/span&gt; 三分恶&lt;br/&gt; * &lt;span&gt;@Date&lt;/span&gt; 2021/3/5&lt;br/&gt; * &lt;span&gt;@Description&lt;/span&gt;&lt;br/&gt; */&lt;/span&gt;&lt;br/&gt;&lt;span&gt;@Service&lt;/span&gt;&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PushProcessServiceImpl&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;PushProcessService&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; PushUtil pushUtil;&lt;br/&gt;    &lt;span&gt;@Autowired&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; PushProcessMapper pushProcessMapper;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Logger logger = LoggerFactory.getLogger(PushProcessServiceImpl&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;//每个线程每次查询的条数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Integer LIMIT = &lt;span&gt;5000&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;//起的线程数&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Integer THREAD_NUM = &lt;span&gt;5&lt;/span&gt;;&lt;br/&gt;    &lt;span&gt;//创建线程池&lt;/span&gt;&lt;br/&gt;    ThreadPoolExecutor pool = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(THREAD_NUM, THREAD_NUM * &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, TimeUnit.SECONDS, &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&amp;gt;(&lt;span&gt;100&lt;/span&gt;));&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;pushData&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; ExecutionException, InterruptedException &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;//计数器，需要保证线程安全&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;//未推送数据总数&lt;/span&gt;&lt;br/&gt;        Integer total = pushProcessMapper.countPushRecordsByState(&lt;span&gt;0&lt;/span&gt;);&lt;br/&gt;        logger.info(&lt;span&gt;&quot;未推送数据条数：{}&quot;&lt;/span&gt;, total);&lt;br/&gt;        &lt;span&gt;//计算需要多少轮&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; num = total / (LIMIT * THREAD_NUM) + &lt;span&gt;1&lt;/span&gt;;&lt;br/&gt;        logger.info(&lt;span&gt;&quot;要经过的轮数:{}&quot;&lt;/span&gt;, num);&lt;br/&gt;        &lt;span&gt;//统计总共推送成功的数据条数&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; totalSuccessCount = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;        &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; num; i++) {&lt;br/&gt;            &lt;span&gt;//接收线程返回结果&lt;/span&gt;&lt;br/&gt;            List&amp;lt;Future&amp;lt;Integer&amp;gt;&amp;gt; futureList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;32&lt;/span&gt;);&lt;br/&gt;            &lt;span&gt;//起THREAD_NUM个线程并行查询更新库，加锁&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; THREAD_NUM; j++) {&lt;br/&gt;                &lt;span&gt;synchronized&lt;/span&gt; (PushProcessServiceImpl&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;                    &lt;span&gt;int&lt;/span&gt; start = count * LIMIT;&lt;br/&gt;                    count++;&lt;br/&gt;                    &lt;span&gt;//提交线程，用数据起始位置标识线程&lt;/span&gt;&lt;br/&gt;                    Future&amp;lt;Integer&amp;gt; future = pool.submit(&lt;span&gt;new&lt;/span&gt; PushDataTask(start, LIMIT, start));&lt;br/&gt;                    &lt;span&gt;//先不取值，防止阻塞,放进集合&lt;/span&gt;&lt;br/&gt;                    futureList.add(future);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            &lt;span&gt;//统计本轮推送成功数据&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (Future f : futureList) {&lt;br/&gt;                totalSuccessCount = totalSuccessCount + (&lt;span&gt;int&lt;/span&gt;) f.get();&lt;br/&gt;            }&lt;br/&gt;        }&lt;br/&gt;        &lt;span&gt;//更新推送标志&lt;/span&gt;&lt;br/&gt;        pushProcessMapper.updateAllState(&lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;        logger.info(&lt;span&gt;&quot;推送数据完成，需推送数据:{},推送成功：{}&quot;&lt;/span&gt;, total, totalSuccessCount);&lt;br/&gt;    }&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;/**&lt;br/&gt;     * 推送数据线程类&lt;br/&gt;     */&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PushDataTask&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Callable&lt;/span&gt;&amp;lt;&lt;span&gt;Integer&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; start;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; limit;&lt;br/&gt;        &lt;span&gt;int&lt;/span&gt; threadNo;   &lt;span&gt;//线程编号&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;        PushDataTask(&lt;span&gt;int&lt;/span&gt; start, &lt;span&gt;int&lt;/span&gt; limit, &lt;span&gt;int&lt;/span&gt; threadNo) {&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.start = start;&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.limit = limit;&lt;br/&gt;            &lt;span&gt;this&lt;/span&gt;.threadNo = threadNo;&lt;br/&gt;        }&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;@Override&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&lt;span&gt;public&lt;/span&gt; Integer &lt;span&gt;call&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;span&gt;throws&lt;/span&gt; Exception &lt;/span&gt;{&lt;br/&gt;            &lt;span&gt;int&lt;/span&gt; count = &lt;span&gt;0&lt;/span&gt;;&lt;br/&gt;            &lt;span&gt;//推送的数据&lt;/span&gt;&lt;br/&gt;            List&amp;lt;PushProcess&amp;gt; pushProcessList = pushProcessMapper.findPushRecordsByStateLimit(&lt;span&gt;0&lt;/span&gt;, start, limit);&lt;br/&gt;            &lt;span&gt;if&lt;/span&gt; (CollectionUtils.isEmpty(pushProcessList)) {&lt;br/&gt;                &lt;span&gt;return&lt;/span&gt; count;&lt;br/&gt;            }&lt;br/&gt;            logger.info(&lt;span&gt;&quot;线程{}开始推送数据&quot;&lt;/span&gt;, threadNo);&lt;br/&gt;            &lt;span&gt;for&lt;/span&gt; (PushProcess process : pushProcessList) {&lt;br/&gt;                &lt;span&gt;boolean&lt;/span&gt; isSuccess = pushUtil.sendRecord(process);&lt;br/&gt;                &lt;span&gt;if&lt;/span&gt; (isSuccess) {   &lt;span&gt;//推送成功&lt;/span&gt;&lt;br/&gt;                    &lt;span&gt;//更新推送标识&lt;/span&gt;&lt;br/&gt;                    pushProcessMapper.updateFlagById(process.getId(), &lt;span&gt;1&lt;/span&gt;);&lt;br/&gt;                    count++;&lt;br/&gt;                } &lt;span&gt;else&lt;/span&gt; {  &lt;span&gt;//推送失败&lt;/span&gt;&lt;br/&gt;                    pushProcessMapper.updateFlagById(process.getId(), &lt;span&gt;2&lt;/span&gt;);&lt;br/&gt;                }&lt;br/&gt;            }&lt;br/&gt;            logger.info(&lt;span&gt;&quot;线程{}推送成功{}条&quot;&lt;/span&gt;, threadNo, count);&lt;br/&gt;            &lt;span&gt;return&lt;/span&gt; count;&lt;br/&gt;        }&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;代码很长，我们简单说一下关键的地方：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;线程创建：线程内部类选择了实现Callable接口，这样方便获取线程任务执行的结果，在示例里用于统计线程推送成功的数量&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt; &lt;span&gt;&lt;span&gt;class&lt;/span&gt; &lt;span&gt;PushDataTask&lt;/span&gt; &lt;span&gt;implements&lt;/span&gt; &lt;span&gt;Callable&lt;/span&gt;&amp;lt;&lt;span&gt;Integer&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用 ThreadPoolExecutor 创建线程池，&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;//创建线程池&lt;/span&gt;&lt;br/&gt;      ThreadPoolExecutor pool = &lt;span&gt;new&lt;/span&gt; ThreadPoolExecutor(THREAD_NUM, THREAD_NUM * &lt;span&gt;2&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, TimeUnit.SECONDS, &lt;span&gt;new&lt;/span&gt; LinkedBlockingQueue&amp;lt;&amp;gt;(&lt;span&gt;100&lt;/span&gt;));&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要构造参数如下：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;-  corePoolSize：线程核心参数选择了5&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;- maximumPoolSize：最大线程数选择了核心线程数2倍数&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;- keepAliveTime：非核心闲置线程存活时间直接置为0&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;- unit：非核心线程保持存活的时间选择了 TimeUnit.SECONDS 秒&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;- workQueue：线程池等待队列，使用 容量初始为100的 LinkedBlockingQueue阻塞队列&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里还有没写出来的线程池拒绝策略，采用了默认AbortPolicy：直接丢弃任务，抛出异常。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;使用 synchronized 来保证线程安全，保证计数器的增加是有序的&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;  &lt;span&gt;synchronized&lt;/span&gt; (PushProcessServiceImpl&lt;span&gt;.&lt;span&gt;class&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;List&amp;lt;Future&amp;lt;Integer&amp;gt;&amp;gt; futureList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;(&lt;span&gt;32&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，主要的代码和简单的解析就到这里了。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于这个简单的demo，这里只是简单地做推送数据处理。考虑一下，这个实例是不是可以用在你项目的某些地方。例如监管系统的数据校验、审计系统的数据统计、电商系统的数据分析等等，只要是有大量数据处理的地方，都可以把这个例子结合到你的项目里，这样你就有了多线程开发的经验。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;完整代码仓库地址在文章底部👇👇&lt;/strong&gt;&lt;/p&gt;&lt;h1 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;对线面试官&lt;/span&gt;&lt;span/&gt;&lt;/h1&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;面试官：小伙子，不错，你这个整挺好。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;老三：那是自然。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面试官：呦，小伙子，挺自信，那我得好好考考你。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;老三：放马过来，但考无妨。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;img data-ratio=&quot;0.9817813765182186&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJplnicOJE2fe1ibB8MLlpJxFQJhx3CBhqdeXd2OIuicJTPuVwkST3VkeLA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;494&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：先从最简单的开始，说说什么是线程吧&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要说线程，必先说进程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进程是程序的⼀次执⾏过程，是系统运⾏程序的基本单位，因此进程是动态的。系统运⾏⼀个程序即是⼀个进程从创建，运⾏到消亡的过程。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程与进程相似，但线程是⼀个⽐进程更⼩的执⾏单位。⼀个进程在其执⾏的过程中可以产⽣多个线程。与进程不同的是同类的多个线程共享进程的堆和⽅法区资源，但每个线程有⾃⼰的程序计数器、虚拟机栈和本地⽅法栈，所以系统在产⽣⼀个线程，或是在各个线程之间作切换⼯作时，负担要⽐进程⼩得多，也正因为如此，线程也被称为轻量级进程。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：说说Java里怎么创建线程吧&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Java里创建线程主要有三种方式：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;继承 Thread类：Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。启动线程的唯一方法就是通过 Thread 类的 start()实例方法。start()方法是一个 native 方法，它将启动一个新线程，并执行 run()方法。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;实现 Runnable接口：如果自己的类已经 extends 另一个类，就无法直接 extends Thread，此时，可以实现一个Runnable 接口。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;实现 Callable接口：实现Callable接口，重写call()方法，可以返回一个 Future类型的返回值。我在上面的例子里就是用到了这种方式。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：说说线程的生命周期和状态&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Java中，线程共有六种状态：&lt;/p&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;状态&lt;/th&gt;&lt;th&gt;说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;NEW&lt;/td&gt;&lt;td&gt;初始状态：线程被创建，但还没有调用start()方法&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;RUNNABLE&lt;/td&gt;&lt;td&gt;运行状态：Java线程将操作系统中的就绪和运行两种状态笼统的称作“运行”&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;BLOCKED&lt;/td&gt;&lt;td&gt;阻塞状态：表示线程阻塞于锁&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;WAITING&lt;/td&gt;&lt;td&gt;等待状态：表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作（通知或中断）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TIME_WAITING&lt;/td&gt;&lt;td&gt;超时等待状态：该状态不同于 WAITIND，它是可以在指定的时间自行返回的&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TERMINATED&lt;/td&gt;&lt;td&gt;终止状态：表示当前线程已经执行完毕&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程在自身的生命周期中， 并不是固定地处于某个状态，而是随着代码的执行在不同的状态之间进行切换，Java线程状态变化如图示：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6393688955672426&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJwMXbeLwuiar3nicJXFSHGzgnzpP9d2NNGKUYbcS8fibkFeOTmNpzEQ5dQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1331&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;Java线程状态变化&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：我看你提到了线程阻塞，那你再说说线程死锁吧&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程死锁描述的是这样⼀种情况：多个线程同时被阻塞，它们中的⼀个或者全部都在等待某个资源被释放。由于线程被⽆限期地阻塞，因此程序不可能正常终⽌。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对⽅的资源，所以这两个线程就会互相等待⽽进⼊死锁状态。&lt;/p&gt;&lt;img data-ratio=&quot;0.6206896551724138&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJvsVBVbkFS5uejiao5Q2nbCe7vygjTchP3PviaNSMDPJjZYfjXvBiarD5g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;667&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;产生死锁必须满足四个条件：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;互斥条件：该资源任意⼀个时刻只由⼀个线程占⽤。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;请求与保持条件：⼀个进程因请求资源⽽阻塞时，对已获得的资源保持不放。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;不剥夺条件:线程已获得的资源在末使⽤完之前不能被其他线程强⾏剥夺，只有⾃⼰使⽤完毕后才释放资源。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;循环等待条件:若⼲进程之间形成⼀种头尾相接的循环等待资源关系。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：怎么避免死锁呢？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我上⾯说了产⽣死锁的四个必要条件，为了避免死锁，我们只要破坏产⽣死锁的四个条件中的其中⼀个就可以了。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;破坏互斥条件 ：这个条件我们没有办法破坏，因为我们⽤锁本来就是想让他们互斥的（临界资源需要互斥访问）。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;破坏请求与保持条件 ：⼀次性申请所有的资源。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;破坏不剥夺条件 ：占⽤部分资源的线程进⼀步申请其他资源时，如果申请不到，可以主动释放它占有的资源。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;破坏循环等待条件 ：靠按序申请资源来预防。按某⼀顺序申请资源，释放资源则反序释放。破坏循环等待条件。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：我看你的例子里用到了synchronized，说说 synchronized的用法吧&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「synchronized」&lt;/strong&gt; 关键字最主要的三种使⽤⽅式：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「1.&lt;strong&gt;「修饰实例⽅法」&lt;/strong&gt;:」&lt;/strong&gt; 作⽤于当前对象实例加锁，进⼊同步代码前要获得 当前对象实例的锁&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;method&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「2.&lt;strong&gt;「修饰静态⽅法」&lt;/strong&gt;:」&lt;/strong&gt; 也就是给当前类加锁，会作⽤于类的所有对象实例 ，进⼊同步代码前要获得当前 &lt;strong&gt;「class」&lt;/strong&gt; 的锁。因为静态成员不属于任何⼀个实例对象，是类成员（ &lt;em&gt;static&lt;/em&gt; 表明这是该类的⼀个静态资源，不管 &lt;em&gt;new&lt;/em&gt; 了多少个对象，只有⼀份）。所以，如果⼀个线程 A 调⽤⼀个实例对象的⾮静态 synchronized ⽅法，⽽线程 B 需要调⽤这个实例对象所属类的静态 synchronized ⽅法，是允许的，不会发⽣互斥现象，因为访问静态 &lt;strong&gt;「synchronized」&lt;/strong&gt; ⽅法占⽤的锁是当前类的锁，⽽访问⾮静态 &lt;strong&gt;「synchronized」&lt;/strong&gt; ⽅法占⽤的锁是当前实例对象锁。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;synchronized&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; staic &lt;span&gt;method&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**3.**修饰代码块 ：指定加锁对象，对给定对象/类加锁。synchronized(this|object) 表示进⼊同步代码库前要获得给定对象的锁。synchronized(类.class) 表示进⼊同步代码前要获得 当前 &lt;strong&gt;「class」&lt;/strong&gt; 的锁&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;synchronized&lt;/span&gt;(&lt;span&gt;this&lt;/span&gt;) {&lt;br/&gt; &lt;span&gt;//业务代码&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在我的例子里使用synchronized修饰代码块，给PushProcessServiceImpl类加锁，进⼊同步代码前要获得 当前 &lt;strong&gt;「class」&lt;/strong&gt; 的锁，防止PushProcessServiceImpl类的对象在控制层调用推送数据的方法。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：除了使用synchronized，还有什么办法来加锁吗？详细说一下&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以使用juc包提供的锁。Lock接口主要相关的类和接口如下。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3722044728434505&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJG4J44V9sDaKDh0FFLj48icG9E2fHqaJ4zST9FIbqC0Tl4hqvqrE8gMQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;626&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306162316895&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Lock中的主要方法：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;lock：用来获取锁，如果锁被其他线程获取，进入等待状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;lockInterruptibly：通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tryLock：tryLock方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;tryLock（long，TimeUnit）：与tryLock类似，只不过是有等待时间，在等待时间内获取到锁返回true，超时返回false。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;unlock：释放锁。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其它接口和类：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ReetrantLock（可重入锁）：实现了Lock接口，可重入锁，内部定义了公平锁与非公平锁。可以完成synchronized 所能完成的所有工作。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;ReadWriteLock（读写锁）：&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;&lt;span&gt;interface&lt;/span&gt; &lt;span&gt;ReadWriteLock&lt;/span&gt; &lt;/span&gt;{  &lt;br/&gt;    &lt;span&gt;Lock &lt;span&gt;readLock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;       &lt;span&gt;//获取读锁  &lt;/span&gt;&lt;br/&gt;    &lt;span&gt;Lock &lt;span&gt;writeLock&lt;/span&gt;&lt;span&gt;()&lt;/span&gt;&lt;/span&gt;;      &lt;span&gt;//获取写锁  &lt;/span&gt;&lt;br/&gt;}  &lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分成2个锁来分配给线程，从而使得多个线程可以同时进行读操作。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ReetrantReadWriteLock（可重入读写锁）：ReetrantReadWriteLock同样支持公平性选择，支持重进入，锁降级。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：说说synchronized和Lock的区别&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;section data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;类别&lt;/th&gt;&lt;th&gt;synchronized&lt;/th&gt;&lt;th&gt;Lock&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;存在层次&lt;/td&gt;&lt;td&gt;Java的关键字，在jvm层面上&lt;/td&gt;&lt;td&gt;是一个接口，api级别&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;锁的释放&lt;/td&gt;&lt;td&gt;1、以获取锁的线程执行完同步代码，释放锁 2、线程执行发生异常，jvm会让线程释放锁&lt;/td&gt;&lt;td&gt;在finally中必须释放锁，不然容易造成线程死锁&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;锁的获取&lt;/td&gt;&lt;td&gt;假设A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待&lt;/td&gt;&lt;td&gt;分情况而定，Lock有多个锁获取的方式，具体下面会说道，大致就是可以尝试获得锁，线程可以不用一直等待&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;锁状态&lt;/td&gt;&lt;td&gt;无法判断&lt;/td&gt;&lt;td&gt;可以判断&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;锁类型&lt;/td&gt;&lt;td&gt;可重入 不可中断 非公平&lt;/td&gt;&lt;td&gt;可重入 可判断 可公平（两者皆可）&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;性能&lt;/td&gt;&lt;td&gt;少量同步&lt;/td&gt;&lt;td&gt;大量同步&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：你提到了synchronized基于jvm层面，对这个有了解吗？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;synchronized是利用java提供的原⼦性内置锁（&lt;strong&gt;「monitor」&lt;/strong&gt; 对象），每个对象中都内置了⼀个 ObjectMonitor 对象。这种内置的并且使⽤者看不到的锁也被称为监视器锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;big&gt;同步语句块&lt;/big&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「synchronized」&lt;/strong&gt; 同步语句块的实现使⽤的是 &lt;strong&gt;「monitorenter」&lt;/strong&gt; 和 &lt;strong&gt;「monitorexit」&lt;/strong&gt; 指令，其中&lt;strong&gt;「monitorenter」&lt;/strong&gt; 指令指向同步代码块的开始位置&lt;strong&gt;「monitorexit」&lt;/strong&gt; 指令则指明同步代码块的结束位置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执⾏monitorenter指令时会尝试获取内置锁，如果对象没有被锁定或者已经获得了锁，锁的计数器+1。此时其他竞争锁的线程则会进⼊等待队列中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执⾏monitorexit指令时则会把计数器-1，当计数器值为0时，则锁释放，处于等待队列中的线程再继续竞争锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;big&gt; &lt;strong&gt;「synchronized 修饰⽅法」&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;synchronized 修饰的⽅法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是ACC_SYNCHRONIZED 标识，该标识指明了该⽅法是⼀个同步⽅法。JVM 通过该ACC_SYNCHRONIZED 访问标志来辨别⼀个⽅法是否声明为同步⽅法，从⽽执⾏相应的同步调⽤。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然，二者细节略有不同，但本质上都是获取原子性内置锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再深入一点，synchronized实际上有两个队列waitSet和entryList。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当多个线程进⼊同步代码块时，⾸先进⼊entryList&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;有⼀个线程获取到monitor锁后，就赋值给当前线程，并且计数器+1&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果线程调⽤wait⽅法，将释放锁，当前线程置为null，计数器-1，同时进⼊waitSet等待被唤醒，调⽤notify或者notifyAll之后⼜会进⼊entryList竞争锁&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;如果线程执⾏完毕，同样释放锁，计数器-1，当前线程置为null&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;img data-ratio=&quot;0.3701171875&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJCQqkRia6AlWJCCkCiac1TAlGzgu2ShHRVnQmfG4c7q50pe9fEqa7Cuwg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1024&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;synchronized的优化能说一说吗？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从JDK1.6版本之后，synchronized本身也在不断优化锁的机制，有些情况下他并不会是⼀个很重量级的锁。优化机制包括⾃适应锁、⾃旋锁、锁消除、锁粗化、偏向锁、轻量级锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;锁的状态从低到⾼依次为⽆锁**-&amp;gt;&lt;strong&gt;「偏向锁」&lt;/strong&gt;-&amp;gt;&lt;strong&gt;「轻量级锁」&lt;/strong&gt;-&amp;gt;**重量级锁，升级的过程就是从低到⾼。&lt;/p&gt;&lt;img data-ratio=&quot;0.08827785817655572&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJPvVAdbIhia0cc5ddicbLAWRLP9h8UzSw9w4iaa1zkellSYGwU1WPOrTAA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;691&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「自旋锁」&lt;/strong&gt;：由于⼤部分时候，锁被占⽤的时间很短，共享变量的锁定时间也很短，所有没有必要挂起线程，⽤户态和内核态的来回上下⽂切换严重影响性能。⾃旋的概念就是让线程执⾏⼀个忙循环，可以理解为就是啥也不⼲，防⽌从⽤户态转⼊内核态，⾃旋锁可以通过设置-XX:+UseSpining来开启，⾃旋的默认次数是10次，可以使⽤-XX:PreBlockSpin设置。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「自适应锁」&lt;/strong&gt;：自适应锁就是自适应的自旋锁，自旋锁的时间不是固定时间，而是由前⼀次在同⼀个锁上的⾃旋时间和锁的持有者状态来决定。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「锁消除」&lt;/strong&gt;：锁消除指的是JVM检测到⼀些同步的代码块，完全不存在数据竞争的场景，也就是不需要加锁，就会进⾏锁消除。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「锁粗化」&lt;/strong&gt;：锁粗化指的是有很多操作都是对同⼀个对象进⾏加锁，就会把锁的同步范围扩展到整个操作序列之外。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「偏向锁」&lt;/strong&gt;：当线程访问同步块获取锁时，会在对象头和栈帧中的锁记录⾥存储偏向锁的线程ID，之后这个线程再次进⼊同步块时都不需要CAS来加锁和解锁了，偏向锁会永远偏向第⼀个获得锁的线程，如果后续没有其他线程获得过这个锁，持有锁的线程就永远不需要进⾏同步，反之，当有其他线程竞争偏向锁时，持有偏向锁的线程就会释放偏向锁。可以⽤过设置-XX:+UseBiasedLocking开启偏向锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「轻量级锁」&lt;/strong&gt;：JVM的对象的对象头中包含有⼀些锁的标志位，代码进⼊同步块的时候，JVM将会使⽤CAS⽅式来尝试获取锁，如果更新成功则会把对象头中的状态位标记为轻量级锁，如果更新失败，当前线程就尝试⾃旋来获得锁。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;锁升级的过程非常复杂，简单点说，偏向锁就是通过对象头的偏向线程ID来对⽐，甚⾄都不需要CAS了，⽽轻量级锁主要就是通过CAS修改对象头锁记录和⾃旋来实现，重量级锁则是除了拥有锁的线程其他全部阻塞。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6295566502463055&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJiaFD7Ewdg0khfoiceO25NMrR1XWVmxiaapjd2BE5iaDCRGWO2caUliaUiaDg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1015&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306142412015&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：说一下CAS&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAS（Compare And Swap/Set）比较并交换，CAS 算法的过程是这样：它包含 3 个参数CAS(V,E,N)。V 表示要更新的变量(内存值)，E 表示预期值(旧的)，N 表示新值。当且仅当 V 值等于 E 值时，才会将 V 的值设为 N，如果 V 值和 E 值不同，则说明已经有其他线程做了更新，则当前线程什么都不做。最后，CAS 返回当前 V 的真实值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAS是一种乐观锁，它总是认为自己可以成功完成操作。当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;java.util.concurrent.atomic 包下的类大多是使用 CAS 操作来实现的 (AtomicInteger,AtomicBoolean,AtomicLong)。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：CAS会导致什么问题？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;ABA 问题：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。从 Java1.5 开始 JDK 的 atomic 包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot; start=&quot;2&quot;&gt;&lt;li&gt;&lt;section&gt;循环时间长开销大：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源，效率低于 synchronized。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot; start=&quot;3&quot;&gt;&lt;li&gt;&lt;section&gt;只能保证一个共享变量的原子操作：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：能说一下说下ReentrantLock原理吗&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReentrantLock 是基于 Lock 实现的可重入锁，所有的 Lock 都是基于 AQS 实现的，AQS 和 Condition 各自维护不同的对象，在使用 Lock 和 Condition 时，其实就是两个队列的互相移动。它所提供的共享锁、互斥锁都是基于对 state 的操作。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：能说一下AQS吗&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AbstractQueuedSynchronizer，抽象的队列式的同步器，AQS 定义了一套多线程访问共享资源的同步器框架，许多同步类实现都依赖于它，如常用的&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ReentrantLock/Semaphore/CountDownLatch。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「AQS」&lt;/strong&gt; 核⼼思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占⽤，那么就需要⼀套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 &lt;strong&gt;「AQS」&lt;/strong&gt; 是⽤ &lt;strong&gt;「CLH」&lt;/strong&gt; 队列锁实现的，即将暂时获取不到锁的线程加⼊到队列中。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看个 AQS原理图：&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4160777385159011&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJmGic1XKMoG5Z3fN861cmupUyv3Z0cSb1nwicuSKj745fTUdTlvu5hn6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1132&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306144734263&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AQS 使⽤⼀个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队⼯作。AQS 使⽤ CAS 对该同步状态进⾏原⼦操作实现对其值的修改。&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;volatile&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; state;&lt;span&gt;//共享变量，使⽤volatile修饰保证线程可⻅性&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;状态信息通过 protected 类型的 getState，setState，compareAndSetState 进⾏操作&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;//返回同步状态的当前值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; &lt;span&gt;getState&lt;/span&gt;&lt;span&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; state; }&lt;br/&gt;&lt;span&gt;// 设置同步状态的值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; &lt;span&gt;setState&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; newState)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; state = newState; }&lt;br/&gt;&lt;span&gt;//原⼦地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; &lt;span&gt;compareAndSetState&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; expect, &lt;span&gt;int&lt;/span&gt; update)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt; &lt;span&gt;return&lt;/span&gt; unsafe.compareAndSwapInt(&lt;span&gt;this&lt;/span&gt;, stateOffset, expect, update);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;尝试加锁的时候通过CAS(CompareAndSwap)修改值，如果成功设置为1，并且把当前线程ID赋值，则代表加锁成功，⼀旦获取到锁，其他的线程将会被阻塞进⼊阻塞队列⾃旋，获得锁的线程释放锁的时候将会唤醒阻塞队列中的线程，释放锁的时候则会把state重新置为0，同时当前线程ID置为空。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.436308926780341&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJeSTAsNxmibRjUoOdxmKgItEMhuxaQGPvrgRuzox1eSOS69YJOIt0zWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;997&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306145019137&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：能说一下Semaphore/CountDownLatch/CyclicBarrier吗&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;Semaphore(信号量)&lt;/strong&gt;-允许多个线程同时访问：synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;CountDownLatch(倒计时器)&lt;/strong&gt;：CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;strong&gt;CyclicBarrier(循环栅栏)&lt;/strong&gt;：CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;volatile原理知道吗？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;相⽐synchronized的加锁⽅式来解决共享变量的内存可⻅性问题，volatile就是更轻量的选择，他没有上下⽂切换的额外开销成本。使⽤volatile声明的变量，可以确保值被更新的时候对其他线程⽴刻可⻅。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;volatile使⽤&lt;strong&gt;内存屏障&lt;/strong&gt;来保证不会发⽣指令重排，解决了内存可⻅性的问题。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们知道，线程都是从主内存中读取共享变量到⼯作内存来操作，完成之后再把结果写会主内存，但是这样就会带来可⻅性问题。举个例⼦，假设现在我们是两级缓存的双核CPU架构，包含L1、L2两级缓存。&lt;/p&gt;&lt;img data-ratio=&quot;0.8811524609843937&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJp6C8HJnZuXTJhuyHtqPJ5plQKskBqhibvrR5Ukpib0HQj34ibc9ialicuibA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;833&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，如果X变量⽤volatile修饰的话，当线程A再次读取变量X的话，CPU就会根据缓存⼀致性协议强制线程A重新从主内存加载最新的值到⾃⼰的⼯作内存，⽽不是直接⽤缓存中的值。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;再来说&lt;strong&gt;内存屏障&lt;/strong&gt;的问题，volatile修饰之后会加⼊不同的内存屏障来保证可⻅性的问题能正确执⾏。这⾥写的屏障基于书中提供的内容，但是实际上由于CPU架构不同，重排序的策略不同，提供的内存屏障也不⼀样，⽐如x86平台上，只有StoreLoad⼀种内存屏障。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;StoreStore屏障，保证上⾯的普通写不和volatile写发⽣重排序&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;StoreLoad屏障，保证volatile写与后⾯可能的volatile读写不发⽣重排序&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LoadLoad屏障，禁⽌volatile读与后⾯的普通读重排序&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LoadStore屏障，禁⽌volatile读和后⾯的普通写重排序&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;img data-ratio=&quot;1.159322033898305&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJXJHlLMQzpAEEw4TAosJ9ccLDurob0zCLQpFMLjqeFtzwQTjICzicib6w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;590&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：说说你对Java内存模型（JMM）的理解，为什么要用JMM&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本身随着CPU和内存的发展速度差异的问题，导致CPU的速度远快于内存，所以现在的CPU加⼊了⾼速缓存，⾼速缓存⼀般可以分为L1、L2、L3三级缓存。基于上⾯的例⼦我们知道了这导致了缓存⼀致性的问题，所以加⼊了缓存⼀致性协议，同时导致了内存可⻅性的问题，⽽编译器和CPU的重排序导致了原⼦性和有序性的问题，JMM内存模型正是对多线程操作下的⼀系列规范约束，通过JMM我们才屏蔽了不同硬件和操作系统内存的访问差异，这样保证了Java程序在不同的平台下达到⼀致的内存访问效果，同时也是保证在⾼效并发的时候程序能够正确执⾏。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7018121911037891&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJ00th6hBgy6hxkpJBuIzIRDMJSxHrOADPx9XRC986581P9mY8QMDqlw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;607&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306150619637&lt;/figcaption&gt;&lt;/figure&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：看你用到了线程池，能说说为什么吗&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;提高线程的利用率，降低资源的消耗。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;提高响应速度，线程的创建时间为T1，执行时间T2，销毁时间T3，用线程池可以免去T1和T3的时间。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;便于统一管理线程对象&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;可控制最大并发数&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：能说一下线程池的核心参数吗？&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;来看一ThreadPoolExecutor的构造方法：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span&gt;(&lt;span&gt;int&lt;/span&gt; corePoolSize,&lt;br/&gt;                         &lt;span&gt;int&lt;/span&gt; maximumPoolSize,&lt;br/&gt;                         &lt;span&gt;long&lt;/span&gt; keepAliveTime,&lt;br/&gt;                         TimeUnit unit,&lt;br/&gt;                        BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,&lt;br/&gt;                        ThreadFactory threadFactory,&lt;br/&gt;                        RejectedExecutionHandler handler)&lt;/span&gt; &lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;核⼼线程数corePoolSize  :此值是用来初始化线程池中核心线程数，当线程池中线程池数&amp;lt; &lt;code&gt;corePoolSize&lt;/code&gt;时，系统默认是添加一个任务才创建一个线程池。可以通过调用&lt;code&gt;prestartAllCoreThreads&lt;/code&gt;方法一次性的启动&lt;code&gt;corePoolSize&lt;/code&gt;个数的线程。当线程数 = corePoolSize时，新任务会追加到workQueue中。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;允许的最大线程数maximumPoolSize:&lt;code&gt;maximumPoolSize&lt;/code&gt;表示允许的最大线程数 = (非核心线程数+核心线程数)，当&lt;code&gt;BlockingQueue&lt;/code&gt;也满了，但线程池中总线程数 &amp;lt; &lt;code&gt;maximumPoolSize&lt;/code&gt;时候就会再次创建新的线程。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;活跃时间keepAliveTime：非核心线程 =(maximumPoolSize - corePoolSize ) ,非核心线程闲置下来不干活最多存活时间。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;保持存活时间unit：线程池中非核心线程保持存活的时间&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;等待队列workQueue：线程池 等待队列，维护着等待执行的&lt;code&gt;Runnable&lt;/code&gt;对象。当运行当线程数= corePoolSize时，新的任务会被添加到&lt;code&gt;workQueue&lt;/code&gt;中，如果&lt;code&gt;workQueue&lt;/code&gt;也满了则尝试用非核心线程执行任务&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;线程工厂 threadFactory：创建一个新线程时使用的工厂，可以用来设定线程名、是否为daemon线程等等。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;拒绝策略RejectedExecutionHandler：&lt;code&gt;corePoolSize&lt;/code&gt;、&lt;code&gt;workQueue&lt;/code&gt;、&lt;code&gt;maximumPoolSize&lt;/code&gt;都不可用的时候执行的 饱和策略。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：完整说一下线程池的工作流程&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当调用 execute() 方法添加一个任务时，线程池会做如下判断：&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;a) 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;b) 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;c) 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;d) 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会根据拒绝策略来对应处理。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot; start=&quot;3&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当一个线程完成任务时，它会从队列中取下一个任务来执行。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;img data-ratio=&quot;0.5403788634097707&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJiabKkQuSUuAtzSXDvoGSaaYvVTbzPLyVvc3ibLpnIbknKcdHwEOAlCQg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1003&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：拒绝策略有哪些&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;主要有4种拒绝策略：&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;AbortPolicy：直接丢弃任务，抛出异常，这是默认策略&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;CallerRunsPolicy：只⽤调⽤者所在的线程来处理任务&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执⾏当前任务&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DiscardPolicy：直接丢弃任务，也不抛出异常&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：说一下你的核心线程数是怎么选的&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程在Java中属于稀缺资源，线程池不是越大越好也不是越小越好。任务分为计算密集型、IO密集型、混合型。&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;计算密集型一般推荐线程池不要过大，一般是CPU数 + 1，+1是因为可能存在&lt;strong&gt;「页缺失」&lt;/strong&gt;(就是可能存在有些数据在硬盘中需要多来一个线程将数据读入内存)。如果线程池数太大，可能会频繁的 进行线程上下文切换跟任务调度。获得当前CPU核心数代码如下：&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;Runtime.getRuntime().availableProcessors();&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot; start=&quot;2&quot;&gt;&lt;li&gt;&lt;section&gt;IO密集型：线程数适当大一点，机器的Cpu核心数*2。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;混合型：如果密集型站大头则拆分的必要性不大，如果IO型占据不少有必要，Mark 下。&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：说一下有哪些常见阻塞队列&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;ArrayBlockingQueue ：由数组结构组成的有界阻塞队列。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;DelayQueue：使用优先级队列实现的无界阻塞队列。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;SynchronousQueue：不存储元素的阻塞队列。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedTransferQueue：由链表结构组成的无界阻塞队列。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;LinkedBlockingDeque：由链表结构组成的双向阻塞队列&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;面试官：说一下有哪几种常见的线程池吧&lt;/span&gt;&lt;span/&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面我们直接用到了ThreadPoolExecutor的构造方法创建线程池，还有另一种方式，通过Executors 创建线程。&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;需要注意的是，阿里巴巴Java开发手册强制禁止使用Executors创建线程&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2937608318890815&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJ6Sf9ictaJYLZLV5nyqVTj2TlD5qhgic9FGOwsBRNyDmvZDsnibxM5ohicg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1154&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306153832125&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比较典型常见的四种线程池包括：&lt;code&gt;newFixedThreadPool&lt;/code&gt;、 &lt;code&gt;newSingleThreadExecutor&lt;/code&gt; 、 &lt;code&gt;newCachedThreadPool&lt;/code&gt;、&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;newScheduledThreadPool&lt;/code&gt;。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;FixedThreadPool&lt;/strong&gt;&lt;/p&gt;&lt;ol data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;定长的线程池，有核心线程，核心线程的即为最大的线程数量，没有非核心线程。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;&lt;p&gt;使用的&lt;strong&gt;「无界」&lt;/strong&gt;的等待队列是&lt;code&gt;LinkedBlockingQueue&lt;/code&gt;。使用时候有堵满等待队列的风险。&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.17851500789889416&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJj8iaqmShUicGYeYhblGRG5NAfqTicVTkyKvGXicVrVrxmVrxTM6nhLdtZw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;633&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306161851855&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;SingleThreadPool&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;只有一条线程来执行任务，适用于有顺序的任务的应用场景，也是用的&lt;strong&gt;「无」&lt;/strong&gt;界等待队列&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.2006079027355623&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJCjQtia7UaYsRicWAZiaCjxKvXk4DciaS2yG8xicYdWnAZ4w6eoda9ceKj6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;658&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306161915934&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt; CachedThreadPool&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可缓存的线程池，该线程池中没有核心线程，非核心线程的数量为Integer.max_value，就是无限大，当有需要时创建线程来执行任务，没有需要时回收线程，适用于耗时少，任务量大的情况。任务队列用的是SynchronousQueue如果生产多快消费慢，则会导致创建很多线程需注意。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1841704718417047&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJRt6IRxgXUn7u7Ov5eRVDY18lI2yuCd0DhPF5c51rKVibEUUJ5WpxumA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;657&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306161950237&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt; ScheduledThreadPoolExecutor&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;「周期性」&lt;/strong&gt;执行任务的线程池，按照某种特定的计划执行线程中的任务，有核心线程，但也有非核心线程，非核心线程的大小也为无限大。适用于执行周期性的任务。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看构造函数：调用的还是&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;构造函数，区别不同点在于任务队列是用的DelayedWorkQueue。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.1598173515981735&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/PMZOEonJxWc9yZXvkT8ia6cWWtAvo4OgJWjOgicNxoqp79nVPJxq6UzYbSJWfmNHr8nhRGXCjNhcm3LnLIJJb8Xw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;657&quot;/&gt;&lt;figcaption&gt;&lt;span/&gt;image-20210306162020463&lt;/figcaption&gt;&lt;/figure&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;面试官：这些题都能回答出来，很好，小伙子，很有精神！&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;老三：谢谢。那面试官老师，你看这一轮面试……&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;面试官：虽然你答的很好，但你的项目数据量只有十万级，不符合我们的要求。所以，面试不能让你过。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;老三上去就是一个左刺拳，再接一个右正蹬……&lt;/p&gt;&lt;br data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;big&gt;&lt;strong&gt;代码地址：https://gitee.com/fighter3/thread-demo.git&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;❝&lt;/span&gt;&lt;p&gt;好了，通过本文，相信你对多线程的应用和原理都有了一定的了解。文章开头提到的crud仔就是博主本人了，技术水平有限，难免错漏，欢迎指出，谢谢！&lt;/p&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;br/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;big&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;【1】：[使用多线程查询百万条用户数据将汉字转化成拼音](https://juejin.cn/post/6844903665564647437)&lt;br/&gt;&lt;br/&gt;【2】：[讲真 这次绝对让你轻松学习线程池](https://mp.weixin.qq.com/s/dTMH1TdxiCKy5yotQ7u7cA)&lt;br/&gt;&lt;br/&gt;【3】：[SpringBoot学习笔记（十七：异步调用）](https://blog.csdn.net/sinat_40770656/article/details/107351205?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161495963016780274184752%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;amp;request_id=161495963016780274184752&amp;amp;biz_id=0&amp;amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-1-107351205.pc_v2_rank_blog_default&amp;amp;utm_term=%E5%BC%82%E6%AD%A5)&lt;br/&gt;&lt;br/&gt;【4】：JavaGuide编著《JavaGuide面试突击版》&lt;br/&gt;&lt;br/&gt;【5】：艾小仙编著 《我想进大厂面试总结》&lt;br/&gt;&lt;br/&gt;【6】：佚名编著 《Java核心知识点整理》&lt;br/&gt;&lt;br/&gt;【7】：[Java并发基础知识，我用思维导图整理好了](https://blog.csdn.net/sinat_40770656/article/details/113612422)&lt;br/&gt;&lt;br/&gt;【8】：[并发编程的锁机制：synchronized和lock ](https://juejin.cn/post/6844903542440869896#heading-11)&lt;br/&gt;&lt;br/&gt;【9】：[详解synchronized与Lock的区别与使用](https://blog.csdn.net/u012403290/article/details/64910926)&lt;br/&gt;&lt;br/&gt;【10】：bugstack小傅哥编著《Java面经手册》&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;往期精选:&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247484838&amp;amp;idx=1&amp;amp;sn=01306c236ab7dc1bd744f07c2eb3ef69&amp;amp;chksm=c0cced03f7bb6415d36b294d7d3db382fad79e04be56c9424645547c16756f63c82f31a3d270&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;这些不可不知的JVM知识，我都用思维导图整理好了&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247485058&amp;amp;idx=1&amp;amp;sn=7e4273c31e97f2be4ec25c2c16577488&amp;amp;chksm=c0ccee27f7bb6731a9b749c2a8658541461b1054dafe057f5d1eec06f2738eeb963ec8abbea1&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;MySQL索引从基础到原理，看这一篇就够了&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a target=&quot;_blank&quot; href=&quot;http://mp.weixin.qq.com/s?__biz=MzkwODE5ODM0Ng==&amp;amp;mid=2247484269&amp;amp;idx=1&amp;amp;sn=4ed9f127f859fc6c06c4d6a28b68fbf2&amp;amp;chksm=c0ccebc8f7bb62deff86a8a13d32e31760aa86da15b94a3bb6d0f2946af4c32425dc34dfb56d&amp;amp;scene=21#wechat_redirect&quot; data-itemshowtype=&quot;0&quot; tab=&quot;innerlink&quot; data-linktype=&quot;2&quot;&gt;这些并发基础知识，我都用思维导图整理好了&lt;/a&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5daed062f927e6435ab95bf182f02b29</guid>
<title>从技术专家到技术管理，我对管理的思考</title>
<link>https://toutiao.io/k/r5kgujp</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;h2 data-lake-id=&quot;c59d3ce6d8f3de38bc41f0ddf54f9231&quot;&gt;前言&lt;/h2&gt;&lt;p data-lake-id=&quot;af3634f9a47f9d77c40232118fb35431&quot;&gt;工作第七个年头，我从技术专家，变成了一名技术管理者。最近一直在忙碌中思考如何成为一名优秀的技术管理者。这篇文章，主要会从两个观点和维度，来谈谈自己的一些认知和思考总结。&lt;span data-mce-style=&quot;font-size: 10px&quot;/&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;8f2d278849f8aaa34c20d8cf8062c66a&quot;&gt;&lt;/p&gt;&lt;h2 data-lake-id=&quot;40b9e41847e55b8d4e1b3b023302ce0e&quot;&gt;观点&lt;/h2&gt;&lt;p data-lake-id=&quot;5b8334f08a8247b7564621261e23f7ab&quot;&gt;首先，从工程师到技术管理的转变，有两个观点要明确：&lt;/p&gt;&lt;p data-lake-id=&quot;e2d8767d6bcdfda62e182f65392ffc66&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span data-mce-style=&quot;font-size: 10px&quot;&gt;1）技术Leader是团队最好的工程师之一；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;f2da4fbfc10ea20dd0e497a3fdc9f56e&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;span data-mce-style=&quot;font-size: 10px&quot;&gt;2）技术Leader是为团队服务，解决团队的问题；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;dda379e68872bf2ec7b133d94eefafc7&quot;&gt;&lt;span&gt;工程师只需要对自己负责，而管理者需要对团队负责。&lt;/span&gt;&lt;span&gt;这两个身份所立足的核心点是一样的，首先要有符合要求的专业性，专业性越强越能够给他人带来信任感；其次是良好的沟通能力。但是这两件事在管理者和工程师身上的要求和方向却有很大的差异。&lt;/span&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;daf8d4ab8a1fd2ab2c5a66b8e7710085&quot;&gt;&lt;span&gt;专业性&lt;/span&gt;&lt;/h3&gt;&lt;p data-lake-id=&quot;8c38524d3ed4bb5c6f0b7fa0ed3739b6&quot;&gt;&lt;span&gt;     对于工程师来说，所谓的专业性单纯的指技术领域的专业性，因为工程师的核心产出主要依赖于其技术领域的造诣，主要的要求是对自己的产出负责，所以需要不停的钻研自己需要依赖的技术，打磨自己使用的工具，不断提升自己能做的事情的边界，不断的提升自己的深度；&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;9641e0e95cae78d8bc10b47dfae46f64&quot;&gt;&lt;span&gt;对于管理者来说，所谓的专业性则更加偏向于如何提升团队产出，所以核心的要求会和工程师有所变化，我个人认为可以拆解到以下几方面：&lt;/span&gt;&lt;/p&gt;&lt;ul data-lake-id=&quot;44f581f6d7cbfb60d5cf135d9733c193&quot; start=&quot;1&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;团队建设&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：核心包括招聘和团队层次搭建，团队和个人最直接的区别就是人数，团队是一个组织，对于管理者来说，首先需要的就是把这个组织建立起来，一个人的组织很难比10个人的组织产出高；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;设定目标&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：当团队已经搭建起来之后，最重要的事情就是要做什么了，如果团队的目标是错误的，那很可能导致整个团队负向产出，所以目标一定要对。在这一点上是最体现管理者的“专业性”的，方向走对了，整个团队事半功倍，整个团队都会信服管理者，反之，则全是管理者一个人的责任。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;提升效率&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：一般我们直观能想到的就是招更好的人提升效率，但站在管理者的角度还要考虑是否能在工具或流程上改造，是否能靠提升团队分工情况来改善效率等。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;树立榜样&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：&lt;/span&gt;管理者是团队的模仿对象，是团队的行为标杆，将自身的能力、行为分享和传达给团队，建立积极的竞争氛围。竞争能够高效激发员工的潜力，要让团队中员工处理良性竞争状态，给团队创造“危机意识”。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 data-lake-id=&quot;582e6e65ed96c968061f42c62070c0a4&quot;&gt;&lt;span&gt;职业性&lt;/span&gt;&lt;/h3&gt;&lt;p data-lake-id=&quot;7269550dd666ace24d32984db19d4b62&quot;&gt;&lt;span&gt;对于工程师来说，核心的沟通方一般是团队内部和产品，沟通的要求主要是能和产品沟通清楚需求，能讲明白自己的技术方案即可。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;584bd55824a5a682718e668958c37a2c&quot;&gt;&lt;span&gt;对于团队管理来说，核心的沟通方都是其他团队，管理者需要帮团队解决的一个大问题就是外部资源依赖问题，所以对沟通的要求要高很多，如何能说服其他团队提供资源解决自己的问题是管理者需要解决的核心工作之一。&lt;/span&gt;&lt;span data-mce-style=&quot;font-size: 10px&quot;&gt;你推进的不再是一个简单的、自闭环的事。你需要对上沟通，跨团队沟通，以及对下沟通，开始需要学习各种技能，更多的掌握业务，站在用户角度，然后再来思考如何通过系统来满足需求。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;584bd55824a5a682718e668958c37a2c&quot;&gt;&lt;span data-mce-style=&quot;font-size: 10px&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;e9d443b7a027bc82214a2f69ea675b43&quot;&gt;&lt;/p&gt;&lt;h2 data-lake-id=&quot;27d9eb02e9f9e9841111ab839d8e611c&quot;&gt;维度&lt;/h2&gt;&lt;h3 data-lake-id=&quot;a7f02a83be67ff42355179341ee11d2d&quot;&gt;团队维度&lt;/h3&gt;&lt;p data-lake-id=&quot;c54fbdcd3de056a1e2b620331c09527f&quot;&gt;&lt;span/&gt;从团队维度来讲，从一名工程师到技术管理的转变，我总结了四个方面：&lt;/p&gt;&lt;h4 data-lake-id=&quot;77ed77b111085a02c8009a414f1c5b0d&quot;&gt;1、躬身入局&lt;/h4&gt;&lt;p data-lake-id=&quot;f0ef8e2f712a1c0a3964465a1f8f153d&quot;&gt;如果只是以工程师的角度去工作，可能只会关注项目里面的某些点，容易陷入思维定势，不太容易去思考全局。因此在最开始应该学会“躬身入局”，了解团队工作中的重要节点，而不是高高在上。工程师和技术管理只是职责上不同，而非职级或者“阶级”上的区分。&lt;/p&gt;&lt;h4 data-lake-id=&quot;0b7e2ddf968b095371ea0186a0f46bad&quot;&gt;2、抓大放小&lt;/h4&gt;&lt;p data-lake-id=&quot;69e4d6d96d977350f4d77f8ec2cde27e&quot;&gt;团队要做的事情，从复杂程度以及数量多寡来说，肯定远远超过个人。因此要学会分辨那些是重要紧急的事项，从全局角度考虑，可以适当的做“局部牺牲”来保证整体拿到更好的结果。&lt;/p&gt;&lt;h4 data-lake-id=&quot;d03f7208c6c181b5424a74ca99693490&quot;&gt;3、向下赋能&lt;/h4&gt;&lt;p data-lake-id=&quot;43e6bc147cdf3682113f453e68aaec1a&quot;&gt;&lt;span data-mce-style=&quot;font-size: 10px&quot;&gt;个人的时间和精力都是有限的，&lt;/span&gt;从工程师到技术管理，&lt;span data-mce-style=&quot;font-size: 10px&quot;&gt;很多时候时间不再是自己的。尝试去&lt;/span&gt;相信团队里面的每个同学，给他们机会去做一些超过之前职责和能力的事情，当然过程中要及时给予指导和过程把控，相信他们能拿到更好的结果。&lt;/p&gt;&lt;h4 data-lake-id=&quot;7a8015eb4583869ba3e5fd2c3c27e1f7&quot;&gt;4、持续学习&lt;br/&gt;&lt;/h4&gt;&lt;p data-lake-id=&quot;fe9939db6c761d62fe14a468984da890&quot;&gt;作为技术出身的管理者，要时刻保持对新技术的学习，并在可能的范围之内承担一定的开发&amp;amp;测试工作或者说要对团队内技术项目足够深入，在成员遇到问题时要能给出解决方案或者思路。&lt;/p&gt;&lt;p data-lake-id=&quot;17b9fc245d6e67143a08abb074ac1c4e&quot;&gt;&lt;span data-mce-style=&quot;font-size: 10px&quot;&gt;保持耐性，有服务和指导以及培养团队的的意识，提升整个团队的实力。技术管理者要能规划和提出团队的目标，明确团队前进的方向，并确保大家能够不偏离轨道，不断纠正，直到达到目标。&lt;/span&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;17b9fc245d6e67143a08abb074ac1c4e&quot;&gt;&lt;span data-mce-style=&quot;font-size: 10px&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3 data-lake-id=&quot;a5b1d117be8845df5ae97a882966bd21&quot;&gt;个人维度&lt;/h3&gt;&lt;h4 data-lake-id=&quot;5b1caf8796e87a80d15ebe35677c3f78&quot;&gt;1、持续学习&lt;/h4&gt;&lt;p data-lake-id=&quot;46705897c7ea0c922b7dc80dba878926&quot;&gt;技术Leader必须是团队最好的工程师之一，要能够基于自己的技术能力&amp;amp;业务认知做决策。要确保技术成长的速度，&lt;span data-mce-style=&quot;font-size: 10px&quot;&gt;通过现象看出背后的原因或原理，要能成为问题终结者。&lt;/span&gt;&lt;/p&gt;&lt;h4 data-lake-id=&quot;10ccd978a8ee82305faffc5a020edc87&quot;&gt;2、目标明确&lt;/h4&gt;&lt;p data-lake-id=&quot;dd1e107dc12d7571c28c4a74373d6a65&quot;&gt;工程师更多是面向技术，是一个很小的圆；成为技术管理者后，需要调整自己的认知边界，成为更大的圆，及时补齐不同方面的能力缺失。&lt;/p&gt;&lt;ul data-lake-id=&quot;19f80dc8ef98a32f19cf5daba461a606&quot; lake-indent=&quot;0&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;业务&lt;/strong&gt;：从单一功能模块设计、单一系统设计到思考业务发展趋势、结合现阶段公司情况能比较清晰认识到现阶段、中短期、中长期、长期业务的形态和该做的事情。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;团队&lt;/strong&gt;：首先要有能力打造团队(招聘、教化、引导)，然后思考团队目标是什么、团队面临的职责或使命是什么。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;规划&lt;/strong&gt;：认清做好规划是为了落地去实现它而不是为了PPT，需要具备一定的规划能力，这其中包含了对上对下的目标明确、资源协调争取、对外沟通合作等。&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;对上对下&lt;/strong&gt;：对上，明确公司业务战略方向，及时对齐目标，及时同步进展；对下，及时沟通了解个性了解述求、协调资源给与帮助。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h4 data-lake-id=&quot;ca70dd28aeeae59523efbce9e02a8031&quot;&gt;3、保持思考&lt;/h4&gt;&lt;p data-lake-id=&quot;57f883033b72f711af1c175971975c90&quot;&gt;当你作为一个技术管理者，需要保证一定的思考时间，转换埋头执行的工作方式。需要从单点模式的思考，快速过度到一个项目甚至更高维度的业务层级。这是一个“点-线-面”的过程，需要保持耐心。&lt;/p&gt;&lt;h4 data-lake-id=&quot;1915e6f9e47ae550be573d8689f9c329&quot;&gt;4、适当放手&lt;/h4&gt;&lt;p data-lake-id=&quot;7580b3010625bc238954b901fee38d35&quot;&gt;学会抓大放小，结果导向。精力有限很难面面俱到，学会放手让有能力的人去具体落地，自己做好跟进识别业务核心、把控方案设计、codereview等工作。&lt;/p&gt;&lt;p data-lake-id=&quot;c31547fc9ec678828e3e191fa91e3b95&quot;&gt;&lt;/p&gt;&lt;p data-lake-id=&quot;5fbb517257a28e30ea61bc289260d500&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>9c1dc4845b178637eddcd355d6fd336a</guid>
<title>下一代微服务 Service Mesh 原理及实践</title>
<link>https://toutiao.io/k/hxrinvv</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;微服务架构痛点&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;业务关注服务之间通信&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;会导致业务迭代速度变慢&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;微服务架构1.0&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.643&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmiajLDjc9MPXicibQiaAOrKpKhktXkwo2z5AvyvtbGM2G3zPx7EM1rAZHIA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2000&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;网关层1个、业务逻辑层多个、数据访问层多个、DB/Cache多个，注册中心、配置中心&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;微服务2.0架构-服务网格&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3867735470941884&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm04yhHth8b2E02ib2USEvHaksgazdibxTMQGWicTTrqD0cJOpTt1nDl4JA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1996&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;基础设施升级困难&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;影响基础设施团队的交付能力和交付速度&lt;br/&gt;因为应用程序通过jar包方式引入通信组件&lt;br/&gt;通信组件升级需要应用程序配合jar包版本升级&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.35850956696878145&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmuVcXnTB12CTiaZVfCDZD4XLTEMxuT7JD9dsQsD6yJdN6kH40neXsRpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1986&quot;/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;多编程语言之间&#x27;通信&#x27;问题&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;业务每种语言一套基础设施 成本大&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5065065065065065&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm0nkAfvnwft5wCfvspwQt3ia7UKuvn1duiatSHBlazZEfeb7yV48BwNjw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1998&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;微服务架构演进&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6202404809619239&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm82tn8Emsn1QQJ8Gd8oVkUOgNrjGbk5Qo8eibwrgticTdSEsUjF7XP53A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1996&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务网格定义&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.1494949494949495&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmdp8dbUuibwWlMgXtcKZMYHfjoGxouD6aP5llbqrpE6d5Ph50Vo4MOrw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1980&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务网格架构&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3587939698492462&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm7ldtRY15MtRTHt4CFvCK0B7hlXA1NwmU6rsPIDRLmw4y7AxXl6av9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1990&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;带来的问题-链路会变长&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;性能里面的RT 平均响应延迟会变高&lt;br/&gt;但本机之间即应用程序放到本机的sidecar损耗不会超过1毫秒&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;开源框架&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;最早版本linkerd&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5393145161290323&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmhqnkic7NVOkx4vic78f0T6Bb5sQCA0OdszPgw7ohciaEuHbPrjke1Q6bg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1984&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;应用程序和sidecar之间通讯用tcp或http1.1以上都可以；两者需要保持长连接&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;istio&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5272177419354839&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmV5BVAcx02mtLnoX8k72PeIgfZ2fy57ybnMcrh18FCtchUETXwkNPqg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1984&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;控制中心&lt;br/&gt;1、控制proxy之间通讯&lt;br/&gt;2、负载均衡&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;数据收集服务：&lt;br/&gt;&lt;br/&gt;proxy之间通讯完之后 要上报一些mertics信息 （耗时、请求次数）&lt;br/&gt;全部同步上报&lt;br/&gt;集中式 不靠谱&lt;br/&gt;它的性能影响proxy本身的性能&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;做鉴权安全相关的&lt;br/&gt;proxy之间权限鉴权比如TLS、SSL&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;sofa mesh&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;蚂蚁金服开源&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;架构&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5371485943775101&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmjb27vgyKDnVKosFmXPicLTPtNPaV3PeVibd8PCFnj6VRrdQOlTQhib0uw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1992&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、将istio中的proxy重写&lt;br/&gt;isotio proxy是用c++写的&lt;br/&gt;sofa用go重写&lt;br/&gt;2、istio数据收集节点是集中式的 sofa是分布式的即每个proxy中都有一个mixer&lt;br/&gt;3、目前还没有公司大规模在用 社区不活跃 建议使用istio&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;新浪weibo mesh&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5542046605876393&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm2AcJ10hv8sSMFHW5pnNv802fibw4icNZfxAkIlpdK3h0lh5IxypAqxGA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1974&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务网格做什么&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5557809330628803&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmfqEgE9Iyuic9SDnQGfJF5lU2C32bibIZTfuB65QWzXxFAicbSdPL9xbmw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1972&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;如何选型&lt;br/&gt;&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.0440456769983686&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmoCLMeFcSWr3p7LHdyDm1sZbb56h6HF5y3u4oLH6RZeIrfVwCLWbmGg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1226&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、业务升级代价太高 要让业务的升级成本降低到0 要兼容所有rpc用法 所以自研&lt;br/&gt;2、期望的是业务方只需要将rpc jar包换成这个rpc mesh jar包就行了&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;自研思路&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6939655172413793&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmbQfriaJyu4Rc3C2ibSQicXoEww4Ple3YtpZ12M5c4MIQtQDc3akNFH2mA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1856&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、要兼容传统(物理机、虚拟机)和云&lt;br/&gt;2、控制中心包括服务管理平台和数据收集中心&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;架构设计&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.624750499001996&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm6YibfraG2mpo9wpNsAs4fQVaxH903whNVe2ssxQUYIAbkiaamplfmqBg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2004&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、数据收集中心：&lt;br/&gt;a、Metric:收集耗时、响应情况&lt;br/&gt;b、Trace:分布式请求跟踪系统APM&lt;br/&gt;c、Alarm：报警功能&lt;br/&gt;2、Protocol&lt;br/&gt;a、RPC:兼容老的RPC协议&lt;br/&gt;b、mesh包括通讯协议(http1.1和2.0)和数据协议(protobuff)&lt;br/&gt;&lt;br/&gt;（注：http1.0不支持 因为是短连接;http1.1和http2.0支持keep alive长连接;tpc是长连接;连接还在 server短可以直接推送消息给client）&lt;br/&gt;&lt;br/&gt;2、sidecar之间的健康检查没有通过注册中心而是本身&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;总体流程&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5563380281690141&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmrSJdXxcYt152vciaR2Ob4vQiagxHDFXu7AK2qTtD6qbiadr6oXczw4Y3Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1988&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;用户发起一个熔断服务B的指令&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6687179487179488&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm2TJRQWtdicfY7JJaRtb3QRUad370WicLSQK8RDpLUWLb53ialyPKNqRQQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1950&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、服务管理平台、控制中心、数据收集中心都是现成的服务（之前文章介绍过）那么自研Service Mesh只需要实现proxy就可以了&lt;br/&gt;2、之前Service和Proxy是一个进程&lt;br/&gt;现在需要修改成2个独立的进程即可&lt;br/&gt;3、将二者放到同一个pod中&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;如果sidecar挂了对整体是否有影响?&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;没有影响。&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4915514592933948&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmha1K9PrBecoN7mhbfYdUAa1bledkmlrEMYdwwf9lWovsiaYndOL5I9w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1302&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;sidecar挂掉 pod如何处理？&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;如果sidecar挂掉了 就会被监控到 直接把当前pod杀死就行了 k8s会自动重启一个pod&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;2个应用程序放在同一个物理机上架构怎样？&lt;/code&gt;&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5741758241758241&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmVVtyS2E1ZDIlJRdTiceHsjug11thSR3uOZQtjtbuzwg9uPqM5wn3ldw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;728&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;漂移&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、日志漂移&lt;br/&gt;&lt;br/&gt;服务器1上有服务1生成日志1&lt;br/&gt;如果服务器1上面的服务1挂了&lt;br/&gt;在服务器2上启动服务2生成日志2 &lt;br/&gt;如果日志1和日志2有强依赖关系 &lt;br/&gt;那么必须得在服务器1上启动服务1继续在日志1的基础上生成日志&lt;br/&gt;&lt;br/&gt;2、重试漂移&lt;br/&gt;pod如果挂了 再次重启 那么ip就会改变&lt;br/&gt;重试漂移到云上任何节点都没有关系&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;完整流程图&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;这个完整的流程图涵盖了&lt;br/&gt;DNS、CDN、Nginx、FastDFS（或Ceph）、&lt;br/&gt;LVS、ServiceMash、数据收集中心、&lt;br/&gt;注册中心、控制中心、网关、业务逻辑层、&lt;br/&gt;数据访问层、存储层等数据交互过程&lt;br/&gt;&lt;br/&gt;价值不菲 想要的话 &lt;br/&gt;可以添加我微信15900411193&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;调用链路&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3782696177062374&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmgLOSWZMwhkiaN5VeySCQn6QUbjIibuHr4MOWQGibSzNlhfuqibGBpyUHCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1988&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、做协议解析的目的是兼容老的协议&lt;br/&gt;客户端发出请求后 在客户端service和服务方service要做协议解析&lt;br/&gt;如果都是mesh协议 是不需要协议解析的、协议封装也不需要&lt;br/&gt;2、客户端一定要做序列化、反序列化 这和通讯没啥关系 就是一个数据包&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;调用方时序图&lt;/h2&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;1.1094017094017095&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmo2ZqydDFr5mLALib7TFtOxoFyrW4put3x8MzSwP5TpsW6bgLplp3umw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1170&quot;/&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务方时序图&lt;br/&gt;&lt;/h2&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;1.4110671936758894&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmA6dmticzO1uAO4jXEy5NC7T1wPfmuNmr99yWrOibPd2ic5iaXDKwB1E8xQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1012&quot;/&gt;&lt;/figure&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;缓存管理 多个Map:&lt;br/&gt;服务方提供哪些函数调用 通过扫描jar包 反射机制 获取服务提供的类名和方法名&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;协议设计&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;数据协议&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、Protocol Buffer&lt;br/&gt;2、分割符、版本号、Mesh消息构成&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.19497487437185929&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmk1YhLJzQ3xd5E9GbDmX1anKKgIqD6tuiaNG4EQIV52TrWIHF4yXApEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1990&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、一次传输协议中有版本号 &lt;br/&gt;比如 版本号1表示rpc协议 &lt;br/&gt;版本号2表示mesh协议&lt;br/&gt;通过版本号可以区分兼容老协议还是新协议&lt;br/&gt;2、多个数据包之间通过头和尾分割符分开&lt;br/&gt;3、分割符占5个字节&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;Mesh通讯协议&lt;span/&gt;&lt;/h3&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、TCP长连接&lt;br/&gt;2、Http1.1或2.0&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;混合云部署&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、调用方&lt;br/&gt;a、SideCar+Service(Mesh)&lt;br/&gt;b、Service(RPC)&lt;br/&gt;2、服务方&lt;br/&gt;a、SideCar+Service(Mesh)&lt;br/&gt;b、Service(RPC)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;访问流程&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3229689067201605&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm20ht2oGM3KHs0CDYics7JXYjRJrPIEYplfbpOYS7zhQ9tgAIXzD1kFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1994&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、在服务启动的时候 mesh服务或普通的RPC服务都会去注册中心注册 此时就知道了该节点的服务类型&lt;br/&gt;2、调用方下拉服务信息 也就知道了提供方服务类型 然后选择不同的协议去调用&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;小细节&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;1、熔断放在mesh里面做 不需要业务方参与&lt;br/&gt;2、下游重试次数是一样的 是服务粒度 非接口粒度&lt;br/&gt;3、proxy(mesh)之间做健康检测 是分布式的 一旦发现自己的上游或下游出现了问题 就更新本地的路由表&lt;br/&gt;4、负载均衡算法:Random、RR、Hash(主要用一致性&lt;span&gt;hash&lt;/span&gt;来做)&lt;br/&gt;（RR：(循环负载)&lt;br/&gt;第一次请求路由到第一个节点，&lt;br/&gt;第二次请求路由到第二个节点，&lt;br/&gt;第三次请求路由到第三个节点，&lt;br/&gt;第四次请求路由到第一个节点&lt;br/&gt;....）&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;架构未来&lt;/h2&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;2平台1中心1趋势&lt;br/&gt;&lt;br/&gt;service mesh平台与业务解耦&lt;br/&gt;容器云弹性平台&lt;br/&gt;服务治理平台(控制中心、注册中心、数据收集中心)&lt;br/&gt;人工智能(AI)&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务管理平台的调用关系-数据收集存储方法&lt;/h2&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;服务方-调用方角度&lt;span/&gt;&lt;br/&gt;&lt;/h3&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.4020100502512563&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rmnp3gibme5rHX7cQxzrJojyic7S72CvWH0Vr24WpDC8RGicKCuQYm2ogaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1990&quot;/&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;服务方:1分钟500万条记录&lt;br/&gt;调用方:50万&lt;br/&gt;共550万&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;存储方案&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;方案1&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5426278836509528&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm0a7lakm422lTyImtA59Vo4GP3nsFjib63vAQQq6uuheS5AhqicIbW6rQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1994&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;方案二&lt;/code&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;重复数据提取出来作为元数据&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.46598984771573604&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5Rm1ficWMZOiaX1GReepHV0qKPibWuE9zpYfhicnJ1a3EhXurnibZ7iaG6jRwWg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1970&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;方案三&lt;/code&gt;&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;code&gt;实际调用流量仅为方案1的1/10&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.295959595959596&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/wsYmlkqrXhPjFQ636VYHtdr2JOsWy5RmMekAzNGwEOiarZTiakpzeibcXlV36Cen0DhAcna6ictLUKddPVBeE4iaVfw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1980&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;、&lt;/p&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>02e5fd532da882780023fcd1400677c3</guid>
<title>2021 技术展望 | 走向未来的实时生成技术</title>
<link>https://toutiao.io/k/fyysozx</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    
                    
                    
                    &lt;section data-role=&quot;outer&quot; label=&quot;Powered by 135editor.com&quot;&gt;&lt;section data-id=&quot;97593&quot; data-tools=&quot;135编辑器&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;img data-ratio=&quot;1.2173913043478262&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEciagUfdyeF7fl6ukCHoDGhVhBh7lXTUQjb9RB9yUXdaI7w6QTR2qEapYicGVn4elicdQI3yB1ricQhA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;23&quot; data-width=&quot;100%&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-autoskip=&quot;1&quot;&gt;&lt;p&gt;线上会议、在线教育、电商直播等多个场景的兴起，也使得实时互动技术从幕后走到台前，得到了更多人的关注。编解码、网络传输、计算机视觉等 RTE 相关的一系列技术也正焕发出更强的生命力。2021 年，在深度学习、5G 等技术的加持下，RTE 会进一步催生哪些可能？&lt;br/&gt;&lt;br/&gt;声网Agora 开发者社区联合 InfoQ 共同策划，邀请了声网Agora 开发者社区中的多位技术专家，从视频传输、计算机视觉、编解码标准发展、WebRTC、机器学习、音频技术等角度，共同撰写「2021 实时互动技术展望系列」，一窥技术新趋势。&lt;strong&gt;&lt;span&gt;本&lt;/span&gt;&lt;span&gt;文作者，&lt;/span&gt;&lt;span&gt;宋利，上海交通大学教授，声网Agora 开发者社区 MVP。&lt;/span&gt;&lt;span&gt;本文首发于 InfoQ，由声网 Agora 开发者社区 与 InfoQ 联合策划，并由 InfoQ 审校。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section data-role=&quot;paragraph&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;疫情爆发至今一年多的时间里，很多行业在疫情期间都备受打击，然而也有一些行业“因祸得福”，快速增长，包括在线教育、在线诊疗、在家办公、在线买菜、在线直播等。这些在线业务行业，均要大量应用音视频直播技术，在音视频直播技术的背后有两项关键技术在支撑：实时通信技术（Real-time Communication）与实时渲染技术（Real-time Rendering）。目前二者正在与实时生成技术相结合，为我们带来更好的实时沟通体验。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading0&quot; data-type=&quot;heading&quot; top=&quot;1007&quot;&gt;&lt;span&gt;RTC 技术与实时渲染技术&lt;/span&gt;&lt;/h2&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;RTC（Real-time Communications），实时通信，是一个正在兴起的风口行业，其强调“实时”即 Real-time，延迟在毫秒级别，支持强互动，最典型的应用就是直播连麦和实时音视频通信。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;提到直播，还有一个重要的技术叫做 CDN：内容分发网络，简单地说就是将网站/应用的图片、音频、视频等素材提前传输到距离用户更近的 CDN 节点上（在物理层面就是电信机房里的服务器），当用户访问时就可以就近快速下载、减少等待。现在有一些平台通过 CDN 来实现直播，然而 CDN 的技术机制理论上会有 5-10 秒的延迟，在浏览图片、短视频等素材来说用户感知不明显，对于不需要实时强互动的直播，比如体育赛事网络直播、演唱会网络直播、新闻现场直播，延迟在 5-10 秒之间则是可以接受的。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;而像前文提到的办公、教育、社交、医疗、娱乐这些直播应该对互动有非常高的要求，5-10 秒的延迟是无法忍受的，一方面画面会存在延时、卡顿、模糊、杂音、回声等常见问题；另一方面，实时互动根本没法用，游戏或直播中的连麦，远程医疗医患对话，直播小班课老师学生间的答疑，需要讨论的视频会议……理论上都要做到跟移动电话一样低延时、高接通和强互动，否则不只是体验不行，而是没法用。正是因为此，视频会议、社交直播、小班课、游戏开黑等互动要求高的场景，RTC 技术基本上已成为唯一选择。国内的 RTC 服务供应商包括声网、腾讯云、阿里云等。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;span&gt;RTC 技术比较复杂，不只是需要专门的网络节点，同时对网络架构、通信协议、软件算法和应用机构都有特殊要求。一个完整的实时音视频系统包括&lt;/span&gt;以&lt;span&gt;下几个部分：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.33754512635379064&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEciagUfdyeF7fl6ukCHoDGhWDKTsxupnHxNycaZn2UACc8jpTIQY7lmoYBE8QnGADqbibicLcQz186Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;此外 RTC 对数据传输的及时性的要求通常要高于可靠性的要求。如发送端采集的一帧编码数据丢失了，对于接收播放端可能并没有太大的影响，接收播放端可以利用收到的前面和后面的帧，通过补帧等技术，实现同样好的用户体验，再如一帧音频数据丢失了，接收端可以用 NetEQ 等技术，根据收到的前面和后面的数据，用算法填上这一帧的数据，而不会降低用户体验。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;实时渲染（Real-time Rendering）主要用于实时图像生成与分析处理，负责渲染直播画面、直播特效等等，如美颜、动画表情互动、礼物特效，提供更加个性化、人性化的使用体验。实时渲染关注的是交互性和实时性，一般制作的场景需要进行优化以提高画面计算速度并减少延时。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;实时渲染技术随着计算机图形学的发展在持续进步。2000 年之后，3D 图像渲染 GPU 已经成为台式机标配，CGI 开始无处不在，预渲染的图形在科学上几乎是真实照片级的。这时期的工作主要集中在集成更复杂的多阶段的图像生成。纹理映射也已经发展为一个复杂的多阶段过程，使用着色器（shader）将纹理渲染、反射技术等多种算法集成到一个渲染引擎中的操作并不少见。2009 年电影《阿凡达》运用动作捕捉技术为角色生成动画，能够将动画直接叠加到实时拍摄的图像上，真正实现了高质量的实时渲染。软件方面 OpenGL 也开始成熟。不久前英伟达发布的 DLSS 2.0（Deep learning super sampling），根据官方宣传，可以保证渲染程序在较低分辨率下对游戏画面进行实时光线追踪，而 DLSS 2.0 则会将渲染后的画面进行 4 倍超采样，从而保证细节与帧率的兼顾，标志着实时渲染技术有了新的突破。&lt;/span&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading1&quot; data-type=&quot;heading&quot; top=&quot;2270&quot;&gt;&lt;span&gt;实时生成技术进展&lt;/span&gt;&lt;/h2&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;近年来，随着互联网的迅猛发展和智能移动设备快速普及每时每刻都有大量的图像被生产、编辑和传播，越来多任务需要算法具备成图像生成能力，现有的直播渲染技术已经不能满足观众需求，实时生成画面+实时传输通信是未来趋势。与此同时，深度学习在语音识别、自然语言处理计算机视觉等许多领域都取得了巨大的成功，由层叠神经元组计算模型——深度神经网络，拥有比传统算法更加强大的特征提取及表示能力。因此人们开始研究其在生成模型上的应用。深度模型通过训练样本去估计数据集的概率分布，接着便可以利用这个生成新的数据或者操纵原有的数据。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;基于生成对抗网络 GAN（Generative Adversarial Networks, GANs）图像生成研究目前收到了广泛关注。GAN 是由 Goodfellow 等人在 2014 年提出。这个深度生成模型背后的思想是博弈论，训练的过程可以被视作二元零和博弈。GAN 包含两个组成部分，生成器（generator）和判别器（discriminator），两者均由多层感知机组成。在训练过程中，生成器 G 旨在生成尽可能逼真的图像数据去骗过判别器 D，而判别器则努力去分辨真实的样本和生成器输出的假样本。可以证明，该对抗训练过程最终将收敛到理论上的唯一解，在这种情况下，生成器生成的数据和真实数据将无法区分。训练完成后，生成器便可以从噪声中随机采样，生成训练数据集中不存在的新本。相比于传统模型例如玻尔兹曼机，GAN 不再需要复杂的马尔科夫链，只使用反向传播即可。同时大量实验 表明，GAN 可以生成更加锐利、逼真的图像，因此其在图像生成领域得到了广泛的应用。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;近期一些 GAN 领域的工作实现了实时的图像生成功能，如实时的人脸驱动。Siarohin 等人提出了一阶运动模型，包含关键点检测器、密集运动场估计网络和运动迁移网络。关键点检测器通过无监督的训练，对源图像和目标图像分别提取关键点，接着密集运动场估计网络利用两幅图像的关键点信息估计出稀疏间运动信息，接着根据局部仿射变换去估计出密集的运动场，最后迁移网络接受目标图像作为输入，将编码器的特征基于此前得到的运动场进行扭曲，再送入解码器，获最后重现图像。这种方法实现的实时人脸驱动效果如下。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.3333333333333333&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/YO07vjlZVBEciagUfdyeF7fl6ukCHoDGhArVUEJeUzdJAvSB9ESRiayhnic4iaiapjEPlgmL8icdolvs8MWvq5IRmWXw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;还有一些插件借助相似的方法，可以在 ZOOM 视频会议中实现实时换脸。下图 ZOOM 会议中的马斯克并非马斯克本人，而是换脸得到的。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.76&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/YO07vjlZVBEciagUfdyeF7fl6ukCHoDGhB3B41qRmUUAaIbFyPTvP3kbbag2hkzACjNib7xUH7IbWnkibNNA57mmg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;近期，NVIDIA 推出一款 Cloud-AI 视频流平台——Maxine，它可以在视频通话中，提供高清画质、噪音消除、目光校正，以及实时转录、翻译等功能，并且支持电脑、平板、手机等多种类型的设备，用于解决当前视频通话存在的各种问题。Maxine 增加了消除伪影的功能，可以使得画面更清晰，能过滤掉常见的背景噪音，如敲击键盘、主机运行的嗡嗡声、家里吸尘器的声音，还提供了实时翻译、转录字幕的功能。最重要的是借助视频压缩技术，可以有效减少数据传输的带宽。Maxine 通过把带宽问题变成计算问题，可以将传输所需带宽减少到 H.264 视频压缩标准所需带宽的十分之一，极大地增加视频的流畅度。Maxine 采用的 AI 视频压缩技术的核心在于它不是对整个屏幕的像素进行流式处理，而是分析通话中每个人的面部关键点，然后在另一端的视频中重新设置人脸的动画，如此一来便可以大幅降低的数据的传输量，同时还可以保证视频传输的质量。在面对面互动体验方面，Maxine 还增加了动画头像交互和虚拟助手功能。动画头像交互允许视频通话者根据喜好选择动画虚拟头像 ，这些头像虽不是真实的，但可以通过交互者的声音和情绪基调自动驱动。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5627615062761506&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEciagUfdyeF7fl6ukCHoDGhqdAWwnbaRutPvFLia8D0gQwVSrVdFCWl3y4U6HYcsnQPyHHnlBth3Zg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;478&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5615866388308977&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEciagUfdyeF7fl6ukCHoDGhhjgZFibI5YhibiakjcOF474WbzmBmGdiab2dnSw4t5nQdYvBqjKliaJnuGQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;479&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;FaceBook 也使用深度生成模型以极小的带宽（小于 10kbits/s）提取并传输人脸特征点，然后在用户接收端设备上自动重建人脸，进而实现视频通话。他们设计的网络大小仅仅为 3MB，可以在 iPhone8 上运行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.6225961538461539&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEciagUfdyeF7fl6ukCHoDGhib806npcZC23GibLbiaIiaUibqCJM6gAl80bXrp4honyho3ZUlib7F3ET6SA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;416&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;h2 data-id=&quot;heading2&quot; data-type=&quot;heading&quot; top=&quot;3879&quot;&gt;&lt;span&gt;RT2C&lt;/span&gt;&lt;/h2&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;实时通信未来的发展趋势是与实时生成相结合，实现实时创作与连接（RT2C，Real-time Creation and Connection），其中创作部分包括生成和渲染，连接部分包括传输通信与社交网络。这将极大拓展媒体传播场景，提供更高品质的内容，让媒体制作更加便捷和多样化，提供更新颖、更人性化的观看效果和使用体验，更加吸引观众，拓展市场。一个典型应用是虚实结合的自由视角直播技术。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;自由视角直播是指用户应该能够自由地选择观看直播的视角。传统的直播只为观众提供固定的一个视角，用户只能随着导播镜头被动地去观看。现有的一些多链路直播也只是事先在场景周围固定几个摄像机，然后提供这几个摄像机的观看视角，不是真正的“自由视角”。自由视角直播是让用户可以平滑无缝、自由地选择观看角度，通过遥控器或者手势滑动视窗，充分避免遮挡影响，实现 720°的无缝观看，不错过每一个精彩细节。同时提供一些上帝视角俯视全场，便于观众随时了解全场整体态势，也提供一些运动员或演员的跟踪视角、放大视角，让观众能随时跟踪自己喜欢的运动员或演员的表现。让观众仿佛在现场自由穿梭，随意欣赏表演或比赛，关注自己最在意的细节。使得人对真实世界的视觉感知同时具备了沉浸感、立体感、空间感，还解决了一般的立体视频内容不丰富、交互不自然的问题。与此同时还可以进行 AR 场景增强，在直播的视频流中渲染入一些现场并不存在的特效景象，让电视前的观众有亦真亦幻的视觉感受。比如在大型表演直播中添加虚拟的人物、景象或动态效果，与真实的演员进行互动；在比赛现场的场间休息中渲染一些大型的吉祥物投影或者啦啦队表演。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;自由视角生成首先需要做摄像机自动定标，这方面已经有很多研究。视角生成领域相关技术大致可以分为三种：基于模型的绘制、基于图像的绘制和基于景深图像的绘制。基于模型的绘制主要指通过对场景进行三维建模，在获取场景纹理信息后，使用计算机图形学方法做旋转平移得到新视角图像。基于图像的绘制主要指直接利用参考图像来生成新视角，离散采样然后通过插值合成新视角的图像。基于景深的绘制在图像上加入了场景深度，用于辅助绘制新视角的图像。其中基于景深的绘制是比较流行的方法。通过这些方法可以实现自由视角和上帝视角的生成。而跟踪视角的生成需要借助视频检测与追踪技术，从不同摄像机中识别和检测人物，并且保证任何时刻都至少有一台摄像机能跟踪到观众选择跟踪的人物。视频追踪方面目前已经有很多成熟的方法可以用，包括一些搭建 RNN 网络来进行的追踪的研究，通过学习新的距离度量方法来进行滤波的限制玻尔兹曼机进行的追踪研究等等。下图展示了一种自由视角生成的解决方案。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.41386554621848737&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEciagUfdyeF7fl6ukCHoDGhWEKPMR0KZOWYOv1AeMFCdfb943biaUDcPs8FTnlkBFbHZbJTePiaxIiag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;476&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;神经渲染也是获取新视角的重要方法。有些神经渲染方法会在图像融合阶段用一个神经网络来学习输入参考视角之间的一个混合权重，好处是可以更充分学习对每一个输入视角。有些神经渲染方法不仅学习输入参考视角的混合权重，还要学习场景本身的几何结构、表面材质等属性，并且在一个可微的图形学渲染器中生成出新的视角。还有些神经渲染方法学习一个体素网格模型，用一个固定分辨率的体素网格来记录和更新从输入学到的特征，后续再通过一个渲染网络生成新视角。近年提出的神经渲染方法 NeRF，直接从空间位置和视角（5 维输入）映射到颜色和不透明度（4 维输出)来进行体渲染，首先构建一个场景的稀疏模型，然后对系数模型中的采样点进行积分，用神经网络学习采样点与虚拟视角之间的关系，在静态场景上取得了很好的效果，如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.38935574229691877&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEciagUfdyeF7fl6ukCHoDGhwTxmAMcNTZ69Ha1SgoIIKvlvBpYQttMjJBUK6dtiahTUibRDJLX1hpjQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;714&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;然而 NeRF 只能处理静态场景，并且需要大量时间和数据去训练模型。NeRF 的改进方法 Deformable NeRF 可以处理动态场景的神经渲染方法，而且可以在手机端运行，效果如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.4&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/YO07vjlZVBEciagUfdyeF7fl6ukCHoDGhGHmEjRh6Y8K8XzO3gsGN0JToKpPaTp3tgHOicm6ICibs0mMjyb9ibWTJQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;600&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;AR 场景增强的相关技术已经在大型晚会中得到了较多的应用。一般来讲，需要事先在线下构建好虚拟模型及其动态效果，对场地构建 3D 模型和坐标，进行三维注册，在直播时将模型和动态效果渲染入视频流，嵌入场地的特定位置，然后呈现出来。现在对于大型场景的建模可以借助激光雷达完成。由于计算量巨大，需要借助边缘计算的方法，提高响应速度，降低延迟。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;在传输部分，自由视角技术除了可以采用更大带宽、更低延迟的网络进行传输外，还可以采用硬件编解码、CDN 网络优化等方法进一步提高实时性。随着 5G 网络带来的增强带宽、海量连接、低延时高可靠特性，以及 VR/AR 技术的快速发展，上述技术路线正在逐渐落实。湖南电视台与华为联合制作的节目《舞蹈风暴》借助时空凝结设备，360 度立体呈现了舞者表演中的每一个旋转翻腾，用“风暴时刻”定格每一个精彩瞬间，让舞蹈之美在节目中得以具象呈现，带来了赏心悦目的视觉体验。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.44404332129963897&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEciagUfdyeF7fl6ukCHoDGh6qDQT6grKvRG9IFfqiakymvc1xcE5rAHpJCtrHvX5ticyBMPVeYxCjOg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;Intel True View 也为我们带来了良好的自由视体验。在橄榄球比赛这样激动人心的直播中，Intel True View 同样可以让电视机前的观众随意地选择自己想要的观看视角，紧盯自己最关注的细节，打破了传统直播视角固定的缺陷，增强了互动性。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5288808664259927&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/YO07vjlZVBEciagUfdyeF7fl6ukCHoDGh6h94roZT5gXw4XuKJPsEGS7ibibq6Xj8KDpES47sKPNsR4BAZTh8YEcA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;总结，本文对 RTC 技术做了介绍，并简述了实时渲染技术的发展历史，然后介绍了实时图像与视频生成领域的相关研究工作与最新进展，最后提出 RTC 技术将朝着实时生成与传输 RT2C 方向发展。&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;参考资料&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;1.CSDN. 实时通信 RTC 技术栈之：视频编解码[EB/OL].&lt;/span&gt;&lt;span&gt;https://blog.csdn.net/netease_im/article/details/83513473&lt;/span&gt;&lt;span&gt;. 2018.10.29&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;2.知乎. LiveMe FE 李承均：RTC 技术的入门和实践[EB/OL].&lt;/span&gt;&lt;span&gt;https://zhuanlan.zhihu.com/p/168118142&lt;/span&gt;&lt;span&gt;. 2020.08.05&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;3.知乎. 走过半个多世纪，计算机图形学的发展历程告诉你 5 毛钱的电影特效究竟多难[EB/OL].&lt;/span&gt;&lt;span&gt;https://zhuanlan.zhihu.com/p/121620580&lt;/span&gt;&lt;span&gt;. 2020.03.31&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;4.Siarohin A, Lathuilière S, Tulyakov S, et al. First order motion model for image animation [C]// Conference on Neural Information Processing Systems (NeurIPS), 2019.12&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;5.Wang T C, Mallya A, Liu M Y. One-Shot Free-View Neural Talking-Head Synthesis for Video Conferencing[J]. arXiv preprint arXiv:2011.15126, 2020.&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;6.Oquab M, Stock P, Gafni O, et al. Low Bandwidth Video-Chat Compression using Deep Generative Models[J]. arXiv preprint arXiv:2012.00328, 2020.&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;7.Mildenhall B, Srinivasan P P, Tancik M, et al. Nerf: Representing scenes as neural radiance fields for view synthesis[J]. arXiv preprint arXiv:2003.08934, 2020.&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;8.Park K, Sinha U, Barron J T, et al. Deformable Neural Radiance Fields[J]. arXiv preprint arXiv:2011.12948, 2020.&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;9.网易号. 惊艳之举！湖南广电联手华为再掀“舞蹈风暴”[EB/OL].&lt;/span&gt;&lt;span&gt;http://mp.163.com/article/FR186L0G0517BTJ6.html&lt;/span&gt;&lt;span&gt;. 2020.11.09&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;10.Youtube. It’s called True View | Intel[EB/OL].&lt;/span&gt;&lt;span&gt;https://www.youtube.com/watch?v=Q6dY01q5j7M&lt;/span&gt;&lt;span&gt;. 2020.09.03&lt;/span&gt;&lt;/p&gt;&lt;p data-type=&quot;paragraph&quot;&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.3037037037037037&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/YO07vjlZVBEHqOZjJmEPvV8JHfEDRRkq4aQIgGKpLLGE7KUcBVJVMhkRibEKbYLzKkOYzMbia7B90GEslXrkCYUg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>