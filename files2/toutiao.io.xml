<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>ce2c83d4ba2ee7618bec3c90ae4921e0</guid>
<title>10+ 条 Go 官方谚语，你知道几条？</title>
<link>https://toutiao.io/k/t267uv1</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-track=&quot;1&quot;&gt;&lt;span&gt;作为一个 Go 语言开发工程师，总是在入门、深入、撕提案时能够听到各种带有 Go 特色的话语，例如：少即是多（less is more），非常有趣。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;2&quot;&gt;&lt;span&gt;今天带来了 Go 语言之父 Rob Pike 在 2015 年分享的主题《Go Proverbs》，它在该主题中讲了的 10+ 条 Go 谚语，希望大家可以用上。&lt;/span&gt;&lt;/p&gt;&lt;p data-track=&quot;3&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;核心理念&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;是：简单、诗意、简洁（Simple, Poetic, Pithy）。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;ol class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不要通过共享内存来通信，通过通信来共享内存（Don&#x27;t communicate by sharing memory, share memory by communicating）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;并发不是并行（Concurrency is not parallelism）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;通道是协调的，互斥是串行的（Channels orchestrate; mutexes serialize）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;接口越大，抽象性越弱（The bigger the interface, the weaker the abstraction）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;让零值变得有用（Make the zero value useful）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;interface{} 什么也没说（interface{} says nothing）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Gofmt 的风格没有人喜欢，但 Gofmt 却是大家的最爱（Gofmt&#x27;s style is&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;no one&#x27;s favorite, yet gofmt is everyone&#x27;s favorite）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;复制一点总比依赖一点好（A little copying is better than a little dependency）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Syscall 必须始终用 build 标签来保护（Syscall must always be guarded with build tags）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Cgo 必须始终用构建标签来保护（Cgo must always be guarded with build tags）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;Cgo 不是 Go（Cgo is not Go）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;使用 unsafe 包没有任何保证（With the unsafe package there are no guarantees）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;清晰的比聪明的好（Clear is better than clever）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;反射从来不是清晰的（Reflection is never clear）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;错误就是价值（Errors are values）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不要只是检查错误，要优雅地处理它们（Don&#x27;t just check errors, handle them gracefully）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;设计架构，命名组件，记录细节（Design the architecture, name the components, document the details）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;文档是为用户准备的（Documentation is for users）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;不要使用恐慌（Don&#x27;t panic）。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;section&gt;&lt;span&gt;Rob Pike 在演讲中所涉及到的这 18 条谚语，是他常年在计算机软件领域开发和设计 Go 时所积累下来的经验。（希望能够对你有所帮助）&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;END&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;br/&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA4ODg0NDkzOA==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbC53rq7PQziczkzCA4pIPx8Xdx2r0a6FgQWEicTOgFNY1KlJD3jSKQKlTiavwTUgHS1HMXza2RYApkDw/0?wx_fmt=png&quot; data-nickname=&quot;GoCN&quot; data-alias=&quot;golangchina&quot; data-signature=&quot;最具规模和生命力的 Go 开发者社区&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;span&gt;-猜你想看-&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;想要了解Go更多内容，欢迎扫描下方👇 关注 公众号，回复关键词 [实战群]  ,就有机会进群和我们进行交流~&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5763688760806917&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/vbERicIdYZbDrrBk1KBPqY1QNI320ZK2IIycDa77FcDQAeAFJRVb240xr8biceh23auy7ZpPibEYXPNOnmfsEewkw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;694&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;分享、在看与点赞，至少我要拥有一个叭~&lt;br/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img __bg_gif&quot; data-ratio=&quot;0.2106667&quot; data-type=&quot;gif&quot; data-w=&quot;750&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/vbERicIdYZbB79dKphkWU3rVKFiaZGWHEic0qXJ8QAeF6XRTLwTCEgUxxiamV13wPv9kMtaqrOtsrVibdHzvYiaxCwgA/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;img data-ratio=&quot;0.696&quot; data-type=&quot;gif&quot; data-w=&quot;500&quot; class=&quot;__bg_gif&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/vbERicIdYZbB79dKphkWU3rVKFiaZGWHEicOoCY9eHaUhZY0vkZibusOg9ibjGibicfyjHiaWfkN9QOiclK2DnfLh4KYTLA/640?wx_fmt=gif&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>e96ca66efcbad62d42ed671744356375</guid>
<title>Camel入门及原理分析</title>
<link>https://toutiao.io/k/tf5fz0a</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Camel最核心的功能就是提供路由引擎。你可以自己定义路由规则，包括从哪里接收消息，怎么处理消息，发给哪个目标。最关键的是你去集成各种系统而不用关心怎么转换数据格式，也不用关心通讯协议是什么。Camel的组件有去实现不同协议和数据类型的API，开箱即用，现在已经支持超过8&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;种的协议和数据类型。&lt;/span&gt;&lt;span&gt;Apache ServiceMix 和 ActiveMQ 已经使用 Camel 作为进行企业&lt;/span&gt;&lt;span&gt;级&lt;/span&gt;&lt;span&gt;集成的一种方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有的人说Camel是一个轻量级的ESB（&lt;/span&gt;&lt;span&gt;Enterprise Service Bus&lt;/span&gt;&lt;span&gt;），因为它有路由功能、转换功能、监控功能、编排功能等等，但是它并没有容器和可靠的消息总线，所以其实它并不能算是一个ESB服务。但是它可以部署到Open&lt;/span&gt;&lt;span&gt;-ESB&lt;/span&gt;&lt;span&gt;上，比如Service&lt;/span&gt;&lt;span&gt;Mix&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Domain-Specific Language (DSL)&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;DSL的目的是让开发人员关注功能集成的过程而不是工具本身。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;Java DSL&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__title&quot;&gt;from&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;file:data/inbox&quot;&lt;/span&gt;&lt;/span&gt;).&lt;span class=&quot;code-snippet__title&quot;&gt;to&lt;/span&gt;(&lt;span class=&quot;code-snippet__params&quot;&gt;&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;jms:queue:order&quot;&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Spring DSL&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;route&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; uri&lt;/span&gt;=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;file:data/inbox&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;to uri=&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;jms:queue:order&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&amp;lt;/route&amp;gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;Scala DSL&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;file:data/inbox&quot;&lt;/span&gt; -&amp;gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;jms:queue:order&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面这个例子可以很简单的将某个文件夹的文件发送到JMS消息队列里。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;简单的配置&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;file:data/inbox?recursive=true&amp;amp;include=*.txt&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;这句话表示循环从文件夹下面读取txt文件。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Camel有内建的类型转换机制，包含了1&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;&lt;span&gt;多种转换器，比如从字节数组转换成字符串，你不用配置转换器。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;拷贝文件的需求&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;shape type=&quot;#_x0000_t75&quot; filled=&quot;f&quot;&gt;&lt;imagedata title=&quot;image1&quot;/&gt;&lt;/shape&gt;&lt;img data-ratio=&quot;0.39338235294117646&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ol23aUXIU7OzH8dUxa4U3zcoMM3IQkzGE6TvibszXU9UfgoIExFCicUgicmic5szwIz4Hgic6SpE7QKuHKQiaNqEmWzg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;544&quot;/&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;将data/&lt;/span&gt;&lt;span&gt;inbox&lt;/span&gt;&lt;span&gt;拷贝到data&lt;/span&gt;&lt;span&gt;/outbox&lt;/span&gt;&lt;span&gt;下，noop&lt;/span&gt;&lt;span&gt;=true&lt;/span&gt;&lt;span&gt;，表示保留源文件，如果不加则表示移动文件到指定目录，原文件夹的文件会不在。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;消息模型&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Camel有2个抽象出来的消息模型。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;org.apache.camel.Message&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;基础的消息实体类，包含携带和路由的数据。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;org.apache.camel.Exchange&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;为交换的消息抽象出来的类，包含了“in”和“out”2个对象。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Exchange跟普通的“请求-响应”模式不太一样。Exchange支持“&lt;/span&gt;&lt;span&gt;InOnly&lt;/span&gt;&lt;span&gt;”、“InOut”两种模式。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“&lt;/span&gt;&lt;span&gt;InOnly&lt;/span&gt;&lt;span&gt;”-只支持单方向的发送消息&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;“InOut”-请求-响应式的发送消息&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Exchange内部的结构如下图所示：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;1.1491935483870968&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ol23aUXIU7OzH8dUxa4U3zcoMM3IQkzG3g7aLRUZpMRLicNRERglRCLhfgfibia040EBsoBvrIXme2umVkTCOrlYA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;248&quot;/&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有了上面的基础概念，我们可以开始看看Camel的架构。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.4602888086642599&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ol23aUXIU7OzH8dUxa4U3zcoMM3IQkzG0kFGru0sGAxAlGAOmey5XmNGbYjMUib8EQ9iabn4d2w9d5lFqqW4ZicIw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;554&quot;/&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Camel由p&lt;/span&gt;&lt;span&gt;rocessor&lt;/span&gt;&lt;span&gt;、component、route三部分组成，而CamelContext又包含了这三部分。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;R&lt;/span&gt;&lt;span&gt;oute决定了路由的规则，通过Camel的DSL（Doman-specific&lt;/span&gt;&lt;span&gt; languages&lt;/span&gt;&lt;span&gt;）定义路由规则。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Porcessor用来转换和处理消息，在DSL中也有对应的关键字来指定processor。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Component用来拓展跟其他系统的连接。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;Endpoint&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Endpoint相当于是一个借口的切入点，Endpoint&lt;/span&gt;&lt;span&gt; URI&lt;/span&gt;&lt;span&gt;的格式如下：&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.4110169491525424&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ol23aUXIU7OzH8dUxa4U3zcoMM3IQkzGFOqfbibbJt8Gt998pY1ib9mlGwywjQGBFGpQVpgjdvD62esQ0vFWNOIQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;236&quot;/&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;生产者和消费者&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;前面说到Endpoint已经指定好消息接收的uri，消息接收后可以通过processor加工处理，也可以发给下游。那消息的来源是哪里？这里就涉及生产者和消费者的概念了。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;生产者发送消息到指定的Endpoint&lt;/span&gt;&lt;span&gt; uri&lt;/span&gt;&lt;span&gt;，再由&lt;/span&gt;&lt;span&gt;route&lt;/span&gt;&lt;span&gt;指定后续的处理，这个后续处理的角色我们就叫Consumer。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;有了以上的理解，我们可以回过头来看前面拷贝文件的代码示例。&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img data-ratio=&quot;0.4599236641221374&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Ol23aUXIU7OzH8dUxa4U3zcoMM3IQkzGJIleZ9dasVEJc7jESR0Zx8DjPMcmWumB0qBMxTb8AVBurZHImaiavfA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;524&quot;/&gt;&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这里的U&lt;/span&gt;&lt;span&gt;RI&lt;/span&gt;&lt;span&gt;是“file:&lt;/span&gt;&lt;span&gt;/data/inbox?noop=true&lt;/span&gt;&lt;span&gt;”,表示routes从/&lt;/span&gt;&lt;span&gt;data/inbox&lt;/span&gt;&lt;span&gt;路径监听文件消息，这个时候如果你放一个文件到这个目录下你就相当于生产者，camel接收到这个文件后没有调用processor做中间的加工，而是直接通过to将消息发送到“data&lt;/span&gt;&lt;span&gt;/outbox&lt;/span&gt;&lt;span&gt;”路径，这里的消息就是你放进去的文件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;精选推荐：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;578&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;578&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Ol23aUXIU7PwUiboz6yDJLEEDkBY81gYxBLIedbtEJnDAsJXuiaSKfB7uhwtm6DcRV1Z0JkEicyZp23EefI4cBPnA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;*本文为IT技术栈原创文章，独家版权归于本平台，受到原创保护。任何渠道的转载请后台留言联系授权，侵权必究。&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>56e88cde56b85469cf21036375c2047a</guid>
<title>爱奇艺内容中台之数据中心的设计与实现</title>
<link>https://toutiao.io/k/yief2yo</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;h3 data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;互联网技术发展至今，当业务复杂度比较高的时候，采用微服务化是一个有效的手段，但是随着服务的拆分，数据管理工作变得极具挑战。数据中心(OLTP)通过对数据的统一收集和管理，一方面可以建立数据之间的联系，从而带来更大的价值；另一方面还可以提供强大的数据阅览、数据分析、挖掘数据等能力，进而为企业创造价值收益。数据中心(OLTP)不仅可以为不同业务线屏蔽技术难点，还可以降低业务逻辑开发的复杂度，使得开发同学能够专注于业务逻辑的开发。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;利用数据中心(OLTP)整合不同业务线的数据，解决数据孤岛问题已经是各个互联网企业的必用手段。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;本文将分享爱奇艺内容中台数据中心(OLTP)的设计与实现。&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;   &lt;span&gt;方案设计与实现&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;之前各个业务线自己维护自己的数据和接口，这样既不利于第三方的接入，也浪费了人力进行重复建设，为了解决诸多类似问题，我们进行了如下设计。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;  2.1 方案设计目标  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;首先我们梳理了目前系统存在的各种亟待解决的问题：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1．数据孤岛：无法全面的看到内容运营的所有数据&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2．重复建设：各业务团队均需具备同样能力的服务建设&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3．对接复杂：各业务团队接口规范不统一，增加对接难度&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4．耦合严重：各业务团队因需要共享数据，导致服务严重互相依赖&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5．开发繁琐：各业务团队需要考虑自研数据中心(OLTP)的技术痛点和难点，无法做到专人做专事，即业务开发只关注自身&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了满足业务长远的发展，我们还制定了一些需要达到的目标：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;1．支持百亿级数据的存储&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;2．支持高QPS的读、写请求&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;3．统一的字段变化消息通知&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;4．极少的运维成本，页面操作添加字段&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;5．通用的查询与保存能力，避免个性化需求带来的额外开发成本&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;  2.2 业务架构图  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;基于以上的目标我们设计了内容中台数据中心的业务架构，如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.8872549019607843&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;408&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvuA8iaDc3HLqWgicYUSnrDVB98UlxfYr76XX6ibLjMlH5OmEXiamh3BbqSMqbPJ5c9sSX853K47Xjyzpw/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图1数据中心(OLTP)业务架构图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据写入方统一将数据写到数据中心(OLTP)，然后数据中心(OLTP)统一对外广播字段的变化，其它业务方监听自身关心的字段变化。同一个业务方既可以是写入方也可以是读取方。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;  2.3 数据一致性方案  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;由于数据中心(OLTP)将数据分别存储到了MongoDB和ES，这样就引入了数据一致性的问题。为了解决这个问题我们调研了业内的一些方案最终选定了最终一致性的方案。具体设计如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.2811387900355873&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;562&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvuA8iaDc3HLqWgicYUSnrDVB9SK5vrAbQYf107sDgVzd6SvribicvUDGQJtLAgSYYxeUh9bndNSN5FvBg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图2数据一致性方案设计图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了避免脏数据的产生，我们设计字段权限控制，字段有归属的业务方，非归属的业务方没有权限写入该字段。由于实际使用场景中，我们大量使用ES查询数据，所以我们设计了MongoDB字段与ES字段的映射，业务方只需要分别创建MongoDB和ES的字段元数据，并建立好两者之间的映射关系。在投递数据的时候只需要投递一份原始数据，我们即可保存到MongoDB和ES中。为了避免ES中字段的相互覆盖问题，我们采取的方案是查询MongoDB中的最新数据并根据映射关系转化为ES结构，然后将ES中对应的文档进行整体覆盖。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;  2.4 数据高可用方案  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;数据中心(OLTP)存储着业务的关键数据，其重要性不言而喻，所以一定要保证服务的高可用，所以我们设计了高可用的方案，具体如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.44041450777202074&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;965&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvuA8iaDc3HLqWgicYUSnrDVB9c6FiaYJNTqQYnO8XVDJamiab9544I48bWLFPfHwJzicTU7U1u4238OGYg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图3数据高可用方案设计图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方案中为了支持海量数据存储采用了分布式文件的存储能力。分片MongoDB集群采用同城多地部署，达到同城多活的效果，以提升集群的容灾能力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了避免单点问题，我们设计了实时数据备份，利用服务配置化双写能力，将数据写入备份集群。代码层面设计数据库切换开关，以支持主集群不可用后，可以方便的切换至备份集群，从而达到数据高可用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;为了满足数据报表等大数据处理需求我们规划了离线数仓，充分利用MongoDB的备用集群能力。在日常使用中，备用集群可以为大数据平台和离线数仓提供数据支撑。离线数仓可以通过指定时间读取备用集群数据，如将9时、12时、18时共3份快照（可根据业务自身的特征自定义快照时间）进行备份。可依据离线数仓数据来恢复指定时间点的数据。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;  2.5 海量数据存储方案  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;随着互联网的高速发展，很多业务场景的数据量都达到了上亿的级别甚至更多，这就涉及到了海量数据的存储问题。由于我们的业务场景也达到了上亿的级别，所以我们设计了海量数据存储方案。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;DB层面：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;DB层面使用分布式文件存储的DB，详见2.4中MongoDB的分片集群，支持横向扩展，可以支撑大数据量存储，且性能仅受限于单分片collection的数据量级。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;ES层面：&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;ES在创建index时需要指定索引的分片个数，一旦创建后不可修改，所以我们在创建索引时需要评估好该索引的数据量级与增长趋势。当索引单分片的数据量级过大，会导致性能急剧下降，此时我们可以使用ES的reIndex API进行索引重建，但该操作会最大程度占用ESserver端的服务资源，导致影响正常业务。为了解决此类问题我们可以利用ES的别名Alias + 分库分表的思路，设计出支持不受数据量级限制的ES索引。ES的别名下可挂载多个真实的索引名，而我们按照一定的规则对索引数据进行拆分，将数据写入到拆分后的真实索引中，而真实索引挂在在同一个别名下，这样可以做到读业务方无感知的效果。但是ES的别名并不具备写入能力（别名下多个索引时），所以我们需要自己执行路由规则，进行索引拆分和写入。具体设计方案如下图：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.35756056808688386&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1197&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvuA8iaDc3HLqWgicYUSnrDVB9288AJmh8WicXuibeoiaSVZS1p45Jx8vyH39yxrzZftTLaWfm47Lu62BEA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图4ES索引拆分写入与查询流程图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;02&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;   &lt;span&gt;最佳实践&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;h4&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h4&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;  3.1 标准化、通用化消息通知  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;为了解决各业务团队因需要共享数据，导致服务严重互相依赖的问题，我们设计了标准化、通用化的消息通知机制。用户只需要引入数据中心(OLTP) SDK ，并做简单的配置，便可监听到指定字段发生变化时的消息，以触发自身的业务逻辑。数据中心(OLTP)消息通知 SDK 设计图如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1.1537290715372908&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;657&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/unymlvueOvuA8iaDc3HLqWgicYUSnrDVB9kpLDbCBicNQ6gVTjw108Xa1g8kWfva1RSlibNRHJGd5q5YKicVeITmCPA/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图5 消息通知SDK设计图&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当数据中心(OLTP)的字段发生变化时，会向RMQ 消息队列投放相关信息；SDK根据业务方配置信息会订阅 RMQ 消息队列，并根据用户的订阅配置，过滤掉用户不关心的消息。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;SDK设计的关键点：&lt;/span&gt;&lt;/strong&gt;&lt;span/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一、将RMQ封装起来，降低业务方的复杂度；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;二、轻服务端重客户端，将消息的过滤与去重放到SDK,降低服务端的压力；&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;三、消息的过滤可以支持到二级字段维度，更精确的过滤掉业务方不需要的消息，减少客户端的压力。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;h4&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;  3.2 技术难点  &lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;&lt;p&gt;&lt;span&gt;在数据中心(OLTP)的应用实践当中我们遇到了一些技术挑战，经过研究我们进行了很好的解决：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;数据库乐观锁锁粒度控制&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;数据中心(OLTP)一张表中的字段都有归属的业务方，如果我们用一个version作为乐观锁控制，那A业务方在保存a字段时，B业务方就无法保存b字段，会导致服务性能的急剧下降，这不是我们期望的结果。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;我们期望A业务方保存归属字段时，B业务方不受影响，做到业务隔离。而A业务方乐观锁只控制A业务方并发保存时的数据一致性。所以我们的乐观锁version可以以业务方维度设计，可以做到锁隔离和锁粒度的控制，进而提升保存性能。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;ES批量写入&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;作为数据中心(OLTP)，避免不了业务方批量写入数据的场景。&lt;/span&gt;&lt;span&gt;而此时我们可以利用ES的Bulk API，来提升ES的写入性能。&lt;/span&gt;&lt;span&gt;经验证ES的Bulk API比单条数据写入index API性能高几十倍（针对大数据量写入）。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Bulk API官网地址：&lt;/span&gt;&lt;span&gt;https://www.elastic.co/guide/en/elasticsearch/reference/7.6/docs-bulk.html#docs-bulk&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;ES之深度分页查询&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;ES在分页查询时，为避免深度翻页对server端带来的压力，故默认控制检索深度不能超过1万条。&lt;/span&gt;&lt;span&gt;如果我们需要实时查询深度分页数据时，可以使用Search After API进行查询；&lt;/span&gt;&lt;span&gt;如果我们需要快速查询深度分页数据，可以使用Scroll API进行查询。&lt;/span&gt;&lt;span&gt;经验&lt;/span&gt;证&lt;span&gt;性能远大于深度翻页，且无深度限制。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;业务方维度控制&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;由于数据中心(OLTP)需要跟多个业务方交互，为了避免某个业务方流量异常影响其它业务方，我们设计了业务方维度的分布式限速，从而达到业务方之间的隔离。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;03&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h2&gt;&lt;strong&gt;&lt;span&gt;   效果与展望&lt;/span&gt;&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;/p&gt;&lt;ul class=&quot;list-paddingleft-1&quot;&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;数据中心(OLTP)上线后，可以看到内容运营的所有数据，解决了数据孤岛问题；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;各写入方只需要按规范将数据投递给数据中心(OLTP)即可对外提供数据，解决了重复建设的问题；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;查询业务方只需要对接数据中心(OLTP)即可获取所需的所有内容运营数据，解决了对接复杂的问题；&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;各业务团队统一从数据中心(OLTP)获取需要的数据，不再需要跟数据写入方交互，解决了业务系统耦合严重的问题。&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;目前数据中心(OLTP)已对接26个业务方，部署物理隔离的独立集群4套，流量较大的集群，读QPS超过2K，写入QPS超过500，最大的表数据量已达2.5亿。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;当然数据中心(OLTP)还需要持续建设，为了数据的高可用我们设计了主备集群，但这样也带来了主备集群间的数据一致性问题——数据中心的数据量会越来越大。为了看到整个数据的全貌，传统的技术已经无法解决，我们目前正在打通此系统与&lt;/span&gt;&lt;span&gt;离线数据平台(OLAP)平台的通&lt;/span&gt;&lt;span&gt;路，借助实时数仓与离线数仓的技术，全面赋能业务需要。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;strong&gt;推荐阅读：&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section class=&quot;mp_profile_iframe_wrp&quot;&gt;&lt;mpprofile class=&quot;js_uneditable custom_select_card mp_profile_iframe&quot; data-pluginname=&quot;mpprofile&quot; data-id=&quot;MzA5Njk3Njc5Mw==&quot; data-headimg=&quot;http://mmbiz.qpic.cn/mmbiz_png/zKQJJopg9UNNc0BBpMTTMakQVZHWAndEgicgysue8cQdH1Fv6acUo1BIaEbdXC9PNjgAmZVH2CoRW3AnOiaWoyJg/0?wx_fmt=png&quot; data-nickname=&quot;HelloTech&quot; data-alias=&quot;HelloTech&quot; data-signature=&quot;专注于大数据和微服务架构实践，分享来自技术人的一手干货文章，从入门到深入，通过夯实的技术积累和丰富的一线实战经验，充分利用碎片化时间，为你带来最有料的技术分享~&quot; data-from=&quot;0&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;em&gt;！&lt;strong&gt;关注不迷路~ 各种福利、资源定期分享&lt;/strong&gt;！&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;🧐&lt;strong&gt;分享、点赞、在看&lt;/strong&gt;，给个&lt;strong&gt;3连击&lt;/strong&gt;呗！&lt;strong&gt;👇&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>4095c9529aedce805331d5b2e89e9705</guid>
<title>PyTorch 常用 Tricks 总结</title>
<link>https://toutiao.io/k/ar8uj9y</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;span&gt;作者：z.defying&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;转载自：Datawhale&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.562962962962963&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1080&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/4lN1XOZshfdiblrib1GyxibXR1hM1wxmX040ruxuVic9ULDaJlicxSibqyjqnsPcE2LuBiaTAJKM0GIJw1SFWuwVjdxWw/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;blockquote data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;80&quot; data-source-title=&quot;&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;目录：&lt;/span&gt;&lt;p&gt;1 指定GPU编号&lt;/p&gt;&lt;p&gt;2 查看模型每层输出详情&lt;/p&gt;&lt;p&gt;3 梯度裁剪&lt;/p&gt;&lt;p&gt;4 扩展单张图片维度&lt;/p&gt;&lt;p&gt;5 独热编码&lt;/p&gt;&lt;p&gt;6 防止验证模型时爆显存&lt;/p&gt;&lt;p&gt;7 学习率衰减&lt;/p&gt;&lt;p&gt;8 冻结某些层的参数&lt;/p&gt;&lt;p&gt;9 对不同层使用不同学习率&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;1. 指定GPU编号&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;设置当前使用的GPU设备仅为0号设备，设备名称为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;/gpu:0&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &quot;0&quot;&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;设置当前使用的GPU设备为0, 1号两个设备，名称依次为 &lt;/span&gt;&lt;code&gt;&lt;span&gt;/gpu:0&lt;/span&gt;&lt;/code&gt;&lt;span&gt;、&lt;/span&gt;&lt;code&gt;&lt;span&gt;/gpu:1&lt;/span&gt;&lt;/code&gt;&lt;span&gt;： &lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;os.environ[&quot;CUDA_VISIBLE_DEVICES&quot;] = &quot;0,1&quot;&lt;/span&gt;&lt;/code&gt;&lt;span&gt; ，根据顺序表示优先使用0号设备,然后使用1号设备。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;指定GPU的命令需要放在和神经网络相关的一系列操作的前面。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;2. 查看模型每层输出详情&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Keras有一个简洁的API来查看模型的每一层输出尺寸，这在调试网络时非常有用。现在在PyTorch中也可以实现这个功能。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;使用很简单，如下用法：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;javascript&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; torchsummary &lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; summary&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;summary(your_model, input_size=(channels, H, W))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;input_size&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;是根据你自己的网络模型的输入尺寸进行设置。&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://github.com/sksq96/pytorch-summary&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;3. 梯度裁剪（Gradient Clipping）&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import torch.nn as nn&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;outputs = model(data)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;loss= loss_fn(outputs, target)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;optimizer.zero_grad()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;loss.backward()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;nn.utils.clip_grad_norm_(model.parameters(), max_norm=20, norm_type=2)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;optimizer.step()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;nn.utils.clip_grad_norm_&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;的参数：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;知乎用户 @不椭的椭圆 提出：&lt;span&gt;&lt;span&gt;梯度裁剪在某些任务上会额外消耗大量的计算时间。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;4. 扩展单张图片维度&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为在训练时的数据维度一般都是 (batch_size, c, h, w)，而在测试时只输入一张图片，所以需要扩展维度，扩展维度有多个方法：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import cv2&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import torch&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;image = cv2.imread(img_path)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;image = torch.tensor(image)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(image.size())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;img = image.view(1, *image.size())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(img.size())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# output:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# torch.Size([h, w, c])&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# torch.Size([1, h, w, c])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;或&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;python&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; cv2&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; numpy &lt;span class=&quot;code-snippet__keyword&quot;&gt;as&lt;/span&gt; np&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;image = cv2.imread(img_path)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(image.shape)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;img = image[np.newaxis, :, :, :]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(img.shape)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# output:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# (h, w, c)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# (1, h, w, c)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;或（感谢知乎用户 @coldleaf 的补充）&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;makefile&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import cv2&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;import torch&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;image = cv2.imread(img_path)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;image = torch.tensor(image)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(image.size())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;img = image.unsqueeze(dim=0)  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(img.size())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;img = img.squeeze(dim=0)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(img.size())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# output:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# torch.Size([(h, w, c)])&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# torch.Size([1, h, w, c])&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# torch.Size([h, w, c])&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;tensor.unsqueeze(dim)&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：扩展维度，dim指定扩展哪个维度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;code&gt;&lt;span&gt;tensor.squeeze(dim)&lt;/span&gt;&lt;/code&gt;&lt;span&gt;：去除dim指定的且size为1的维度，维度大于1时，squeeze()不起作用，不指定dim时，去除所有size为1的维度。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;5. 独热编码&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在PyTorch中使用交叉熵损失函数的时候会自动把label转化成onehot，所以不用手动转化，而使用MSE需要手动转化成onehot编码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;python&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; torch&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;class_num = &lt;span class=&quot;code-snippet__number&quot;&gt;8&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;batch_size = &lt;span class=&quot;code-snippet__number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;one_hot(label)&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    将一维列表转换为独热编码&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &quot;&quot;&quot;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    label = label.resize_(batch_size, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    m_zeros = torch.zeros(batch_size, class_num)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    onehot = m_zeros.scatter_(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;, label, &lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;)  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; onehot.numpy()  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;label = torch.LongTensor(batch_size).random_() % class_num  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;print(one_hot(label))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# output:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;[[&lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;1.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; [&lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;1.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; [&lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;1.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt; [&lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;1.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0.&lt;/span&gt;]]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;https://discuss.pytorch.org/t/convert-int-into-one-hot-format/507/3&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;6. 防止验证模型时爆显存&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;验证模型时不需要求导，即不需要梯度计算，关闭autograd，可以提高速度，节约内存。如果不关闭可能会爆显存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;python&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;with&lt;/span&gt; torch.no_grad():&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;pass&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;感谢知乎用户 @zhaz 的提醒&lt;span&gt;，我把 &lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;torch.cuda.empty_cache()&lt;/span&gt;&lt;/code&gt;&lt;span&gt; 的使用原因更新一下。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这是原回答：&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;span&gt;Pytorch 训练时无用的临时变量可能会越来越多，导致 out of memory ，可以使用下面语句来清理这些不需要的变量。&lt;/span&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;官网上的解释为：&lt;/span&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;span&gt;Releases all unoccupied cached memory currently held by the caching allocator so that those can be used in other GPU application and visible innvidia-smi.torch.cuda.empty_cache()&lt;/span&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;意思就是PyTorch的缓存分配器会事先分配一些固定的显存，即使实际上tensors并没有使用完这些显存，这些显存也不能被其他应用使用。这个分配过程由第一次CUDA内存访问触发的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;而&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;torch.cuda.empty_cache()&lt;/span&gt;&lt;/code&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;的作用就是释放缓存分配器当前持有的且未占用的缓存显存，以便这些显存可以被其他GPU应用程序中使用，并且通过&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;code&gt;&lt;span&gt;nvidia-smi&lt;/span&gt;&lt;/code&gt;&lt;span&gt;命令可见。注意使用此命令不会释放tensors占用的显存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;对于不用的数据变量，Pytorch 可以自动进行回收从而释放相应的显存。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;更详细的优化可以查看：&lt;br data-filtered=&quot;filtered&quot;/&gt;优化显存使用：&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/span&gt;&lt;span&gt;https://blog.csdn.net/qq_28660035/article/details/80688427&lt;/span&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;span&gt;显存利用问题：&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/span&gt;&lt;span&gt;https://oldpan.me/archives/pytorch-gpu-memory-usage-track&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;7. 学习率衰减&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;python&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; torch.optim &lt;span class=&quot;code-snippet__keyword&quot;&gt;as&lt;/span&gt; optim&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;from&lt;/span&gt; torch.optim &lt;span class=&quot;code-snippet__keyword&quot;&gt;import&lt;/span&gt; lr_scheduler&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 训练前的初始化&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;optimizer = optim.Adam(net.parameters(), lr=&lt;span class=&quot;code-snippet__number&quot;&gt;0.001&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;scheduler = lr_scheduler.StepLR(optimizer, &lt;span class=&quot;code-snippet__number&quot;&gt;10&lt;/span&gt;, &lt;span class=&quot;code-snippet__number&quot;&gt;0.1&lt;/span&gt;)  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 训练过程中&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; n &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; n_epoch:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    scheduler.step()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ...&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;8. 冻结某些层的参数&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;参考：Pytorch 冻结预训练模型的某一层&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/span&gt;&lt;span&gt;https://www.zhihu.com/question/311095447/answer/589307812&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;在加载预训练模型的时候，我们有时想冻结前面几层，使其参数在训练过程中不发生变化。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们需要先知道每一层的名字，通过如下代码打印：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;net = Network()  &lt;span class=&quot;code-snippet__meta&quot;&gt;# 获取自定义网络结构&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; name, &lt;span class=&quot;code-snippet__keyword&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; net.named_parameters():&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    print(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;name: {0},\t grad: {1}&#x27;&lt;/span&gt;.format(name, &lt;span class=&quot;code-snippet__keyword&quot;&gt;value&lt;/span&gt;.requires_grad))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;假设前几层信息如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;cnn.VGG_16.convolution1_1.weight&lt;/span&gt;,   &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;grad&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;cnn.VGG_16.convolution1_1.bias&lt;/span&gt;,   &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;grad&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;cnn.VGG_16.convolution1_2.weight&lt;/span&gt;,   &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;grad&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;cnn.VGG_16.convolution1_2.bias&lt;/span&gt;,   &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;grad&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;cnn.VGG_16.convolution2_1.weight&lt;/span&gt;,   &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;grad&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;cnn.VGG_16.convolution2_1.bias&lt;/span&gt;,   &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;grad&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;cnn.VGG_16.convolution2_2.weight&lt;/span&gt;,   &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;grad&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;cnn.VGG_16.convolution2_2.bias&lt;/span&gt;,   &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;grad&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;后面的True表示该层的参数可训练，然后我们定义一个要冻结的层的列表：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;nginx&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attribute&quot;&gt;no_grad&lt;/span&gt; = [&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;cnn.VGG_16.convolution1_1.weight&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;cnn.VGG_16.convolution1_1.bias&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;cnn.VGG_16.convolution1_2.weight&#x27;&lt;/span&gt;,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;cnn.VGG_16.convolution1_2.bias&#x27;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;冻结方法如下：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;cs&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;net = Net.CTPN()  &lt;span class=&quot;code-snippet__meta&quot;&gt;# 获取网络结构&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; name, &lt;span class=&quot;code-snippet__keyword&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; net.named_parameters():&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; name &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; no_grad:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;value&lt;/span&gt;.requires_grad = False&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;value&lt;/span&gt;.requires_grad = True&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;冻结后我们再打印每层的信息：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;css&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;cnn.VGG_16.convolution1_1.weight&lt;/span&gt;,   &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;grad&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;False&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;cnn.VGG_16.convolution1_1.bias&lt;/span&gt;,   &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;grad&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;False&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;cnn.VGG_16.convolution1_2.weight&lt;/span&gt;,   &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;grad&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;False&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;cnn.VGG_16.convolution1_2.bias&lt;/span&gt;,   &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;grad&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;False&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;cnn.VGG_16.convolution2_1.weight&lt;/span&gt;,   &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;grad&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;cnn.VGG_16.convolution2_1.bias&lt;/span&gt;,   &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;grad&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;cnn.VGG_16.convolution2_2.weight&lt;/span&gt;,   &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;grad&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__selector-tag&quot;&gt;name&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;cnn.VGG_16.convolution2_2.bias&lt;/span&gt;,   &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;grad&lt;/span&gt;: &lt;span class=&quot;code-snippet__selector-tag&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;可以看到前两层的weight和bias的requires_grad都为False，表示它们不可训练。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后在定义优化器时，只对requires_grad为True的层的参数进行更新。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;ini&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__attr&quot;&gt;optimizer&lt;/span&gt; = optim.Adam(filter(lambda p: p.requires_grad, net.parameters()), lr=&lt;span class=&quot;code-snippet__number&quot;&gt;0.01&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/pre&gt;&lt;h3&gt;&lt;strong&gt;&lt;span&gt;9. 对不同层使用不同学习率&lt;/span&gt;&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们对模型的不同层使用不同的学习率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还是使用这个模型作为例子：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;net = Network()  &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; name, value &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; net.named_parameters():&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;name: {}&#x27;&lt;/span&gt;.format(name))&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 输出：&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# name: cnn.VGG_16.convolution1_1.weight&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# name: cnn.VGG_16.convolution1_1.bias&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# name: cnn.VGG_16.convolution1_2.weight&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# name: cnn.VGG_16.convolution1_2.bias&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# name: cnn.VGG_16.convolution2_1.weight&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# name: cnn.VGG_16.convolution2_1.bias&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# name: cnn.VGG_16.convolution2_2.weight&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# name: cnn.VGG_16.convolution2_2.bias&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;对 convolution1 和 convolution2 设置不同的学习率，首先将它们分开，即放到不同的列表里：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;conv1_params = []&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;conv2_params = []&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; name, parms &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; net.named_parameters():&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;convolution1&quot;&lt;/span&gt; &lt;span class=&quot;code-snippet__keyword&quot;&gt;in&lt;/span&gt; name:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        conv1_params += [parms]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;else&lt;/span&gt;:&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        conv2_params += [parms]&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;# 然后在优化器中进行如下操作：&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;optimizer = optim.Adam(&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    [&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        {&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;params&quot;&lt;/span&gt;: conv1_params, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;lr&#x27;&lt;/span&gt;: 0.01},&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        {&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;params&quot;&lt;/span&gt;: conv2_params, &lt;span class=&quot;code-snippet__string&quot;&gt;&#x27;lr&#x27;&lt;/span&gt;: 0.001},&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    ],&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    weight_decay=1e-3,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;/section&gt;&lt;pre&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/pre&gt;&lt;p&gt;&lt;span&gt;我们将模型划分为两部分，存放到一个列表里，每部分就对应上面的一个字典，在字典里设置不同的学习率。当这两部分有相同的其他参数时，就将该参数放到列表外面作为全局参数，如上面的`weight_decay`。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;也可以在列表外设置一个全局学习率，当各部分字典里设置了局部学习率时，就使用该学习率，否则就使用列表外的全局学习率。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/hN1l83J6Ph9yhTLzOamqiatY1c5KevJq5vdDicE3PHyAibHmlghpyZFLdgYKaKMlOqHicgzvcol2g5KThMM7kUO5Xw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;430&quot;/&gt;&lt;/p&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>f1ef2e7ae763c7dfe0bbc662ef77adbe</guid>
<title>RocketMQ 5.0: 存储计算分离新思路</title>
<link>https://toutiao.io/k/ju1gfga</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content                                                                     &quot; id=&quot;js_content&quot;&gt;
            &lt;p&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-galleryid=&quot;&quot; data-ratio=&quot;0.625&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;1024&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/Z6bicxIx5naLvgXTzRAjN8pDiaNqib6oqib9ocrPM2nazG4nEbiaVDzBfmd3BKJfbl6Kia6r6Cf8dVRJa8v660Qzj9CQ/640?wx_fmt=jpeg&quot;/&gt;&lt;/p&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Apache RocketMQ 自 2012 年开源以来，因其架构简单、业务功能丰富、具备极强的可扩展性等特点被广泛采用。RocketMQ 在阿里巴巴集团内部有着数千台的集群规模，每天十万亿消息流转的规模。在阿里云上，RocketMQ 的商业化产品也以弹性云服务的形式为全球数万个用户提供企业级的消息解决方案，被广泛应用于互联网、大数据、移动互联网、物联网等领域的业务场景，成为了业务开发的首选消息中间件。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;尽管消息中间件 RocketMQ 在阿里巴巴和开源社区已经走过了十多个年头，但在云原生浩浩荡荡的浪潮下&lt;/span&gt;&lt;span&gt;，我们开始对 RocketMQ 的架构有了一些新的思考。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;痛点与困局&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;阿里巴巴有大规模实践 RocketMQ 的生产经验，自 RocketMQ 从 2016 年对外商业化以来，一直延续跟集团消息中间件相同的架构为云上的客户提供全托管的消息服务，发展至今，消息队列 RocketMQ 在云上已经具备相当大的业务规模。随着业务的发展，这套极简的分布式架构在云原生环境下逐渐显露出了一些不足，比如，运维成本增加、效率降低。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.0709987966305656&quot; data-type=&quot;png&quot; data-w=&quot;831&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJnngbClwBdsKDxwSbicOfR3fYZA5351Qu0ZMTxmK73hIKaMfbdu6AySzfriayVlNwONruxoboficucA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;集团消息中间件通过存储计算一体化的部署架构，为集团电商业务提供了高性能、低延迟、低成本的消息服务。随着云的进化，云开始变得更加弹性，网络环境更加复杂，云原生时代对效率也有了更高的要求，我们也迎来了对云上消息架构进行云原生化改造的契机。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上图是目前RocketMQ在云上部署的一个简化版架构（仅包含最核心的组件），这套部署架构近年来在云上遇到的主要痛点有以下几点：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;富客户端形态&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;RocketMQ 的用户需要借助官方提供的 SDK 使用云上的服务，这是一个比较重量级的富客户端，提供了诸如顺序消费、广播消费、消费者负载均衡、消息缓存、消息重试、位点管理、推拉结合、流控、诊断、故障转移、异常节点隔离等一系列企业级特性。RocketMQ 的富客户端极大地降低了集团内客户的接入成本，一站式助力集团客户构建高韧性、高性能的消息驱动应用，但云上的富客户端有一些不足：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;02&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;计算存储一体化&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;Broker 是 RocketMQ 最核心的节点，承担了服务端所有的计算和存储逻辑，其核心能力为：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;计算存储一体化的 Broker 具备以下优点：部署结构简单、开源用户可以开箱即用；部署节点少，低成本支持集团双十一万亿级的消息规模；数据就近处理，无中间环节，性能高，延迟低。但一体化的 Broker 在云环境也有其局限性：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;03&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;客户端与Broker直连&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;span/&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;RocketMQ 当前的用户通过客户端直接与 Broker 进行通信，链路是最短化的，运维简单、延迟低，但这样的设计无法很灵活地适配网络极其复杂的云环境，网络上有经典网络、VPC 网络、公网，部署环境上有 OXS 区、售卖区，为客户暴露每一个 Broker 节点带来了运维上的负担：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;基于这个大背景，阿里云消息团队对 RocketMQ 在云上进行了云原生架构升级专项，实践存储计算分离的新架构，同时引入基于gRPC 的全新多语言解决方案&lt;/span&gt;&lt;span&gt;，来加速消息中间件的云原生化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;存算分离新思路&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;如何在云上实践存算分离，如何探索出一个适合 RocketMQ 三位一体的新架构，是 RocketMQ 进行云原生架构升级主要考虑的点，这里面有很多现实因素的考量：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于第一个问题，实践的结果已经告诉我们架构简单的优异性，但在云上遇到的痛点又告诉我们存算分离势在必行，可见存储与计算要不要分离，并不是一个非此即彼的选择，架构上的选择是否能都要呢？对于这个问题，我们的解法是存储计算需要做到可分可合：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;对于第二个问题，在阿里云上有多个自研的不同协议标准的消息服务，如何通过单一架构支持多产品形态至关重要，将 RocketMQ 的核心业务消息的能力无缝复制到多个产品，放大业务价值。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;总而言之，架构层面的核心理念是以存储计算架构分离为切入点，进一步探索单一架构多产品形态，以降低消息子产品的重复建设，最终也需要实现存储与计算可分可合的部署形态，同时满足云上的运维灵活性以及开源、集团等部署简单、高性能的需求。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;01&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;存储计算分离架构&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;RocketMQ 5.0 在架构上的第一个升级便是存储计算分离改造，通过引入无状态的 Proxy 集群来承担计算职责，原Broker 节点会逐步演化为以存储为核心的有状态集群，同时会重新研发一批多语言的瘦客户端来解决富客户端带来的诸多问题。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.8784596871239471&quot; data-type=&quot;png&quot; data-w=&quot;831&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJnngbClwBdsKDxwSbicOfR3aiavPLVXdfQ4ev3sb1tQiaMu0wgwW4JT0icibeQ7S2JGicZstAYd3ZGuLPg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;上图是一个存储计算分离架构的简图，图中借用了 Service Mesh 关于控制和数据面的划分思想以及 xDS 的概念来描述，架构中各个组件的职责分别为：&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;存储计算分离带来的额外成本主要是延迟和成本。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;简而言之，在云上环境，云服务形态的 RocketMQ 非常适合存储计算分离架构。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;02&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;存储计算合并架构&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;但从本质来讲，存储计算分离与就近计算和就近存储的理念是冲突的。存储计算一体化的架构在云上带来了困扰，本质还是因为云上是一个多租户的环境，存储计算一体化在多租户的场景下灵活性不够。但很多场景往往都是小规格单租户，其实更适合存储计算一体化。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;为了云外云内都能统一技术方案，我们更加期望的一种机构是存储与计算可分可合的部署形态，分开部署是计算节点完全无状态，运维迭代极其简单，合并部署时更原架构体验保持一致。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;但无论采用什么样的部署架构，存储和计算的分离都是一种良好的模块化设计方式，在编程层面的分开是必须要进行的。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.44765342960288806&quot; data-type=&quot;png&quot; data-w=&quot;831&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJnngbClwBdsKDxwSbicOfR3PcPawz81jSezm0YNUyzTsylrLptbeSvuSNQia649ffholEwxztojHwA/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如上图所示，左边是云上一个分离部署的形态，右边是合并部署的形态，合并部署时计算节点可以作为存储节点的SideCar，采用网格的思想进行部署，也可以将计算和存储揉进同一个进程进行部署。实际上，我们在实践的过程中，通过对代码进行充分设计，Proxy 节点可以通过构造器构造出「Local」和「Cluster」部署两种形态，分别对应合并部署和分离部署的两种架构形态。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;03&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;strong&gt;单一架构多产品形态&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span/&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;《云原生时代消息中间件的演进路线》一&lt;/span&gt;&lt;span&gt;文中提到，阿里云消息团队目前有业界最丰富的消息产品矩阵，包括消息队列 RocketMQ、消息队列 Kafka、微消息队列 MQTT、消息队列 AMQP、消息服务 MNS、事件总线EventBridge。丰富的产品矩阵是团队多年来践行多样性和标准化演进路线的结果，所有的消息子产品目前都构建在RocketMQ 存储内核之上，非常具备统一架构的前提。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;0.5415162454873647&quot; data-type=&quot;png&quot; data-w=&quot;831&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJnngbClwBdsKDxwSbicOfR3TPteUJDWWiborMib99dH7lKL5dRL3e3RteR8UiazvPcuHlibASAJwTbaag/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;通过单一的存储计算分离架构，支持多产品的业务形态，是云原生消息探索的一个重要方向。这种单一架构多产品形态会带来诸多好处，比如计算节点共建，通过模型抽象支持多业务模型，多通信协议，释放重复建设的人力。通过存储节点并池，各产品打通内部存储节点，形成资源池合并，统一运维和管控，有助于降低成本、提高效率，加速存储创新，孵化消息中台。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages wxw-img&quot; data-ratio=&quot;1.184115523465704&quot; data-type=&quot;png&quot; data-w=&quot;831&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/Z6bicxIx5naJnngbClwBdsKDxwSbicOfR3d27We7XSlxqnMEiaIDAXTvsGkL7ywDhpIpMkt4kNlFiaeZhib7251Vicpg/640?wx_fmt=png&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;如上图所示，单一架构多产品形态的核心先统一存储和计算，并进一步统一管控和运维，真正做到一套架构支撑多个云产品。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;h1&gt;&lt;strong&gt;&lt;span/&gt;&lt;/strong&gt;&lt;br/&gt;&lt;/h1&gt;&lt;p&gt;&lt;span&gt;目前，阿里云消息队列 RocketMQ 实践存储计算彻底分离的架构还处于第一个过渡阶段，未来的路还很长，我们会投入至少 1 年的时间在公有云环境全面落地存储计算分离架构，让消息服务更弹性、更云原生，让团队提高效率，加速业务创新。&lt;/span&gt;&lt;span&gt;我们期望新的架构能稳定服务于未来至少 5 年的业务增长，同时，存算可分可合的部署架构也能够非常好地支撑不同规模开源用户的个性化需求，让 Apache RocketMQ 开源社区能够整体收益于存算计算可分可合架构的新形态。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;RocketMQ从诞生第一天起就在GitHub上开发的开源项目，也是中国第一个非Hadoop生态的Apache顶级项目。它统一了阿里集团内部所有业务线的消息中间件，伴随着中国互联网发展数次迭代。《十万亿条消息背后的故事》记录了RocketMQ从诞生、开源到发展至今背后鲜为人知的故事。通过「开源人说」的娓娓道来，让我们一起来了解分布式消息中间件Apache RocketMQ背后的人与事！点击观看《十万亿条消息背后的故事》&lt;/span&gt;&lt;span&gt;https://developer.aliyun.com/live/249109&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt; &lt;/span&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;span/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;❖&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;svg viewbox=&quot;0 0 1 1&quot;/&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;section powered-by=&quot;xiumi.us&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;《开源人说》为阿里云开发者社区与InfoQ 联合出品的一档精品开源视频栏目。栏目围绕四大开源领域：云原生、操作系统、数据库、大数据&amp;amp;AI，介绍优秀的开源软件背后的故事，记录传播技术人追求极致和开放共享的精神。&lt;/span&gt;&lt;/section&gt;&lt;section&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;点击阅读原文了解《开源人说》！&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
          &lt;/div&gt;

          

          



           
                                
                    
        &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>