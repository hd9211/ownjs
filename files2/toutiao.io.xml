<?xml version="1.0" encoding="UTF-8"?>
        <rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/">
            <channel>
            <title>开发者头条</title>
            <link>http://toutiao.io/</link>
            <description></description>
<item>
<guid>93d053f1562c3d16e3356acb74f59b36</guid>
<title>Docker 镜像瘦身</title>
<link>https://toutiao.io/k/t92f0ah</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;p&gt;Docker 是一个用于开发，交付和运行应用程序的开发平台。它能够将应用程序和基础架构分开，保证开发，测试， 部署的环境完全一致，从而达到快速交付的目的。但是在实际项目中，会对项目中的模块或者服务进行细分， 导致部署的镜像过多（50+ 个），过大（打包压缩后的镜像达 50G+），这给部署带来了不小的隐患，特别是私有化部署（通过移动介质拷贝镜像进行部署）。本文从多篇镜像瘦身的文章入手，并进行实践验证，结合&lt;span&gt;官方的Dockerfile最佳实践&lt;sup&gt;[1]&lt;/sup&gt;&lt;/span&gt; 总结了镜像压缩的4种方法和日常实践的多个技巧。&lt;/p&gt;&lt;h2&gt;镜像构建&lt;/h2&gt;&lt;h3&gt;构建方式&lt;/h3&gt;&lt;p&gt;镜像构建的方式有两种，一种是通过 &lt;code&gt;docker build&lt;/code&gt; 执行 Dockerfile 里的指令来构建镜像，另一种是通过 &lt;code&gt;docker commit&lt;/code&gt; 将存在的容器打包成镜像。通常我们都是使用第一种方式来构建容器，二者的区别就像批处理和单步执行一样。&lt;/p&gt;&lt;h3&gt;体积分析&lt;/h3&gt;&lt;p&gt;Docker镜像是由很多镜像层（Layers）组成的（最多127层）， Dockerfile 中的每条指定都会创建镜像层，不过&lt;strong&gt;只有 &lt;code&gt;RUN&lt;/code&gt;, &lt;code&gt;COPY&lt;/code&gt;, &lt;code&gt;ADD&lt;/code&gt; 会使镜像的体积增加&lt;/strong&gt;。这个可以通过命令 &lt;code&gt;docker history image_id&lt;/code&gt; 来查看每一层的大小。这里我们以官方的 &lt;span&gt;alpine:3.12&lt;sup&gt;[2]&lt;/sup&gt;&lt;/span&gt; 为例看看它的镜像层情况。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;dockerfile&quot;&gt;&lt;code&gt;&lt;span&gt;FROM&lt;/span&gt; scratch&lt;br/&gt;&lt;span&gt;ADD&lt;/span&gt; alpine-minirootfs-&lt;span&gt;3&lt;/span&gt;.&lt;span&gt;12&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;-x86_64.tar.gz /&lt;br/&gt;&lt;span&gt;CMD&lt;/span&gt; [&lt;span&gt;&quot;/bin/sh&quot;&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.0849762066621346&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bDCibGAYVPCxbjV3DvkW6y2z9rEBuDUkyPTdjcNP7a5oqEARTgxQYWUAiaicPK1Xh2GR0Jmpib1caibw2clkL0wicu1w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1471&quot; title=&quot;null&quot;/&gt;对比 Dockerfile 和镜像历史层数发现 &lt;code&gt;ADD&lt;/code&gt; 命令层占据了 5.57M 大小，而 &lt;code&gt;CMD&lt;/code&gt; 命令层并不占空间。&lt;/p&gt;&lt;p&gt;镜像的层就像 &lt;code&gt;Git&lt;/code&gt; 的每一次提交 &lt;code&gt;Commit&lt;/code&gt;, 用于保存镜像的上一个版本和当前版本之间的差异。所以当我们使用 &lt;code&gt;docker pull&lt;/code&gt; 命令从公有或私有的 Hub 上拉取镜像时，它只会下载我们尚未拥有的层。这是一种非常高效的共享镜像的方式，但是有时会被错误使用，比如反复提交。&lt;img data-ratio=&quot;0.3433734939759036&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bDCibGAYVPCxbjV3DvkW6y2z9rEBuDUkyhPabhhoRZY9dctKhy0UoGEuRPuPESbpmqQRE5fCgABSbibkj8g7Wx4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1494&quot; title=&quot;null&quot;/&gt;从上图看出，基础镜像 alpine:3.12 占据了 5.57M 大小，idps_sm.tar.gz 文件占据了 4.52M。但是命令 &lt;code&gt;RUN rm -f ./idps_sm.tar.gz&lt;/code&gt; 并没有降低镜像大小， 镜像大小由一个基础镜像和两次 &lt;code&gt;ADD&lt;/code&gt; 文件构成。&lt;/p&gt;&lt;h3&gt;瘦身方法&lt;/h3&gt;&lt;p&gt;了解了镜像构建中体积增大的原因，那么就可以对症下药：&lt;strong&gt;精简层数&lt;/strong&gt;或&lt;strong&gt;精简每一层大小&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;精简层数的方法有如下几种：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;   •&lt;/span&gt;RUN指令合并&lt;/span&gt;&lt;span&gt;&lt;span&gt;   •&lt;/span&gt;多阶段构建&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;     •&lt;/span&gt;精简每一层的方法有如下几种：&lt;/span&gt;&lt;span&gt;&lt;span&gt;         •  使用合适的基础镜像（首选 alpine）&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;         • &lt;/span&gt;&lt;span&gt; 删除 RUN 的缓存文件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h2&gt;镜像瘦身&lt;/h2&gt;&lt;p&gt;关于镜像瘦身这块的实际操作以打包 redis 镜像为例，在打包之前我们先拉取官方 redis 的镜像， 发现标签为6的镜像大小为 104M， 标签为 6-alpine 的镜像大小为 31.5M。打包的流程如下:&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;选择基础镜像，更新软件源，安装打包工具&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;下载源码并进行打包安装&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;清理不需要的安装文件&lt;/span&gt;&lt;/p&gt;&lt;p&gt;按照上述的流程，我们编写如下的&lt;span&gt;Dockerfile&lt;sup&gt;[3]&lt;/sup&gt;&lt;/span&gt;，该镜像使用命令 &lt;code&gt;docker build --no-cache -t optimize/redis:multiline -f redis_multiline .&lt;/code&gt; 打包后镜像大小为 441M。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;dockerfile&quot;&gt;&lt;code&gt;&lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;ubuntu&lt;/span&gt;&lt;span&gt;:focal&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;ENV&lt;/span&gt; REDIS_VERSION=&lt;span&gt;6&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;.&lt;span&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ENV&lt;/span&gt; REDIS_URL=http://download.redis.io/releases/redis-&lt;span&gt;$REDIS_VERSION&lt;/span&gt;.tar.gz&lt;br/&gt;&lt;br/&gt;# &lt;span&gt;update&lt;/span&gt; &lt;span&gt;source&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; tools&lt;br/&gt;RUN sed -i &lt;span&gt;&quot;s/archive.ubuntu.com/mirrors.aliyun.com/g; s/security.ubuntu.com/mirrors.aliyun.com/g&quot;&lt;/span&gt; /etc/apt/sources.&lt;span&gt;list&lt;/span&gt; &lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt; apt update &lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt; apt install -y curl make gcc&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# download source code and install redis&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt; curl -L &lt;span&gt;$REDIS_URL&lt;/span&gt; | tar xzv&lt;br/&gt;&lt;span&gt;WORKDIR&lt;/span&gt; redis-&lt;span&gt;$REDIS_VERSION&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt; make&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt; make install&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# clean up&lt;/span&gt;&lt;br/&gt;RUN rm  -rf &lt;span&gt;/var/lib/apt/lists/&lt;/span&gt;* &lt;br/&gt;&lt;br/&gt;&lt;span&gt;CMD&lt;/span&gt; [&lt;span&gt;&quot;redis-server&quot;&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h3&gt;RUN指令合并&lt;/h3&gt;&lt;p&gt;指令合并是最简单也是最方便的降低镜像层数的方式。该操作节省空间的原理是在同一层中清理“缓存”和工具软件。还是打包 redis 的需要，指令合并的&lt;span&gt;Dockerfile&lt;sup&gt;[4]&lt;/sup&gt;&lt;/span&gt;如下，打包后的镜像大小为 292M。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;dockerfile&quot;&gt;&lt;code&gt;&lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;ubuntu&lt;/span&gt;&lt;span&gt;:focal&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;ENV&lt;/span&gt; REDIS_VERSION=&lt;span&gt;6&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;.&lt;span&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ENV&lt;/span&gt; REDIS_URL=http://download.redis.io/releases/redis-&lt;span&gt;$REDIS_VERSION&lt;/span&gt;.tar.gz&lt;br/&gt;&lt;br/&gt;# &lt;span&gt;update&lt;/span&gt; &lt;span&gt;source&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; tools&lt;br/&gt;RUN sed -i &lt;span&gt;&quot;s/archive.ubuntu.com/mirrors.aliyun.com/g; s/security.ubuntu.com/mirrors.aliyun.com/g&quot;&lt;/span&gt; /etc/apt/sources.&lt;span&gt;list&lt;/span&gt; &amp;amp;&amp;amp;\&lt;br/&gt;    &lt;span&gt;apt&lt;/span&gt; update &amp;amp;&amp;amp;\&lt;br/&gt;    &lt;span&gt;apt&lt;/span&gt; install -y curl make gcc &amp;amp;&amp;amp;\&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# download source code and install redis&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;curl&lt;/span&gt; -L &lt;span&gt;$REDIS_URL&lt;/span&gt; | tar xzv &amp;amp;&amp;amp;\&lt;br/&gt;    &lt;span&gt;cd&lt;/span&gt; redis-&lt;span&gt;$REDIS_VERSION&lt;/span&gt; &amp;amp;&amp;amp;\&lt;br/&gt;    &lt;span&gt;make&lt;/span&gt; &amp;amp;&amp;amp;\&lt;br/&gt;    &lt;span&gt;make&lt;/span&gt; install &amp;amp;&amp;amp;\&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# clean up&lt;/span&gt;&lt;br/&gt;    apt remove -y --&lt;span&gt;auto&lt;/span&gt;-remove curl make gcc &amp;amp;&amp;amp;\&lt;br/&gt;    &lt;span&gt;apt&lt;/span&gt; clean &amp;amp;&amp;amp;\&lt;br/&gt;    rm  -rf &lt;span&gt;/var/lib/apt/lists/&lt;/span&gt;* &lt;br/&gt;&lt;br/&gt;&lt;span&gt;CMD&lt;/span&gt; [&lt;span&gt;&quot;redis-server&quot;&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;使用 &lt;code&gt;docker history &lt;/code&gt;分析 optimize/redis:multiline 和 optimize/redis:singleline 镜像，得到如下情况：&lt;img data-ratio=&quot;0.6377952755905512&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bDCibGAYVPCxbjV3DvkW6y2z9rEBuDUkySK0CKFsTot5zMh9M4Mynaic4eGlKPxLuvdXHBmx9QwxPdREb8eCTcag/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1524&quot; title=&quot;null&quot;/&gt;分析上图发现，镜像 optimize/redis:multiline 中清理数据的几层并没有降低镜像的大小，这就是上面说的共享镜像层带来的问题。所以指令合并的方法是通过在同一层中将缓存和不用的工具软件清理掉，以达到减小镜像体积的目的。&lt;/p&gt;&lt;h3&gt;多阶段构建&lt;/h3&gt;&lt;p&gt;多阶段构建方法是官方打包镜像的最佳实践，它是将精简层数做到极致的方法。通俗点讲它是将打包镜像分成两个阶段，一个阶段用于开发，打包，该阶段包含构建应用程序所需的所有内容；一个用于生产运行，该阶段只包含你的应用程序以及运行它所需的内容。这被称为“建造者模式”。两个阶段的关系有点像JDK和JRE的关系。使用多阶段构建肯定会降低镜像大小，但是瘦身的粒度和编程语言有关系，对编译型语言效果比较好，因为它去掉了编译环境中多余的依赖，直接使用编译后的二进制文件或jar包。而对于解释型语言效果就不那么明显了。&lt;/p&gt;&lt;p&gt;依然还是上面打包 redis 镜像的需求，使用多阶段构建的 &lt;span&gt;Dockerfile&lt;sup&gt;[5]&lt;/sup&gt;&lt;/span&gt;，打包后的进行大小为135M。&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;dockerfile&quot;&gt;&lt;code&gt;&lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;ubuntu&lt;/span&gt;&lt;span&gt;:focal&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;build&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;ENV&lt;/span&gt; REDIS_VERSION=&lt;span&gt;6&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;.&lt;span&gt;5&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ENV&lt;/span&gt; REDIS_URL=http://download.redis.io/releases/redis-&lt;span&gt;$REDIS_VERSION&lt;/span&gt;.tar.gz&lt;br/&gt;&lt;br/&gt;# &lt;span&gt;update&lt;/span&gt; &lt;span&gt;source&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;install&lt;/span&gt; tools&lt;br/&gt;RUN sed -i &lt;span&gt;&quot;s/archive.ubuntu.com/mirrors.aliyun.com/g; s/security.ubuntu.com/mirrors.aliyun.com/g&quot;&lt;/span&gt; /etc/apt/sources.&lt;span&gt;list&lt;/span&gt; &amp;amp;&amp;amp;\&lt;br/&gt;    &lt;span&gt;apt&lt;/span&gt; update &amp;amp;&amp;amp;\&lt;br/&gt;    &lt;span&gt;apt&lt;/span&gt; install -y curl make gcc &amp;amp;&amp;amp;\&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# download source code and install redis&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;curl&lt;/span&gt; -L &lt;span&gt;$REDIS_URL&lt;/span&gt; | tar xzv &amp;amp;&amp;amp;\&lt;br/&gt;    &lt;span&gt;cd&lt;/span&gt; redis-&lt;span&gt;$REDIS_VERSION&lt;/span&gt; &amp;amp;&amp;amp;\&lt;br/&gt;    &lt;span&gt;make&lt;/span&gt; &amp;amp;&amp;amp;\&lt;br/&gt;    &lt;span&gt;make&lt;/span&gt; install&lt;br/&gt;&lt;br/&gt;&lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;ubuntu&lt;/span&gt;&lt;span&gt;:focal&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# copy&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ENV&lt;/span&gt; REDIS_VERSION=&lt;span&gt;6&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;.&lt;span&gt;5&lt;/span&gt;&lt;br/&gt;COPY --from=build /usr/&lt;span&gt;local&lt;/span&gt;/bin/redis* /usr/&lt;span&gt;local&lt;/span&gt;/bin/&lt;br/&gt;&lt;br/&gt;&lt;span&gt;CMD&lt;/span&gt; [&lt;span&gt;&quot;redis-server&quot;&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;相比 optimize/redis:singleline 改动有以下三点：&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;第一行多了As build, 为后面的COPY做准备&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;第一阶段中没有了清理操作，因为第一阶段构建的镜像只有编译的目标文件（二进制文件或jar包）有用，其它的都无用&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;第二阶段直接从第一阶段拷贝目标文件&lt;/span&gt;&lt;/p&gt;&lt;p&gt;同样的，使用 &lt;code&gt;docker history&lt;/code&gt; 查看镜像体积情况：&lt;img data-ratio=&quot;0.5051880674448768&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/bDCibGAYVPCxbjV3DvkW6y2z9rEBuDUkyUZPmJPSyS2QyialtIrTYBibnd12ej2l6OmOBtkBj0iaggQFsmp5xYmRsg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1542&quot; title=&quot;null&quot;/&gt;&lt;/p&gt;&lt;p&gt;比较我们使用多阶段构建的镜像和官方提供 redis:6（无法和 redis:6-alpine 相比，因为 redis:6 和 ubuntu:focal 都是基于 debain 的镜像），发现二者有 30M 的空间。研究 redis:6 的 &lt;span&gt;Dockerfile&lt;sup&gt;[6]&lt;/sup&gt;&lt;/span&gt; 发现如下&quot;骚操作&quot;:&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;serverMd5=&lt;span&gt;&quot;&lt;span&gt;$(md5sum /usr/local/bin/redis-server | cut -d&#x27; &#x27; -f1)&lt;/span&gt;&quot;&lt;/span&gt;; &lt;span&gt;export&lt;/span&gt; serverMd5; \&lt;br/&gt;find /usr/&lt;span&gt;local&lt;/span&gt;/bin/redis* -maxdepth 0 \&lt;br/&gt;        -type f -&lt;span&gt;not&lt;/span&gt; -name redis-server \&lt;br/&gt;        -&lt;span&gt;exec&lt;/span&gt; sh -eux -c &lt;span&gt;&#x27; \&lt;/span&gt;&lt;br/&gt;            &lt;span&gt;md5&lt;/span&gt;=&lt;span&gt;&quot;$(md5sum &quot;&lt;/span&gt;&lt;span&gt;$1&lt;/span&gt;&lt;span&gt;&quot; | cut -d&quot;&lt;/span&gt; &lt;span&gt;&quot; -f1)&quot;&lt;/span&gt;; \&lt;br/&gt;            &lt;span&gt;test&lt;/span&gt; &lt;span&gt;&quot;&lt;span&gt;$md5&lt;/span&gt;&quot;&lt;/span&gt; = &lt;span&gt;&quot;&lt;span&gt;$serverMd5&lt;/span&gt;&quot;&lt;/span&gt;; \&lt;br/&gt;        &lt;span&gt;&#x27; -- &#x27;&lt;/span&gt;{}&lt;span&gt;&#x27; &#x27;&lt;/span&gt;;&lt;span&gt;&#x27; \&lt;/span&gt;&lt;br/&gt;        -&lt;span&gt;exec&lt;/span&gt; ln -svfT &lt;span&gt;&#x27;redis-server&#x27;&lt;/span&gt; &lt;span&gt;&#x27;{}&#x27;&lt;/span&gt; &lt;span&gt;&#x27;;&#x27;&lt;/span&gt; \&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;编译 redis 的源码发现二进制文件 redis-server 和 redis-check-aof(aof持久化), redis-check-rdb（rdb持久化）, redis-sentinel（redis哨兵）是相同的文件，大小为 11M。官方镜像通过上面的脚本将后三个通过 ln 来生成。&lt;/p&gt;&lt;h3&gt;使用合适的基础镜像&lt;/h3&gt;&lt;p&gt;基础镜像，推荐使用 Alpine。Alpine 是一个高度精简又包含了基本工具的轻量级 Linux 发行版，基础镜像只有 4.41M，各开发语言和框架都有基于 Alpine 制作的基础镜像，强烈推荐使用它。进阶可以尝试使用scratch和busybox镜像进行基础镜像的构建。从官方镜像 redis:6（104M） 和 redis:6-alpine（31.5M） 就可以看出 alpine 的镜像只有基于debian镜像的 1/3。&lt;/p&gt;&lt;p&gt;使用 Alpine镜像有个注意点，就是它是基于 muslc的（glibc的替代标准库），这两个库实现了相同的内核接口。其中 glibc 更常见，速度更快，而 muslic 使用较少的空间，侧重于安全性。在编译应用程序时，大部分都是针对特定的 libc 进行编译的。如果我们要将它们与另一个 libc 一起使用，则必须重新编译它们。换句话说，基于 Alpine 基础镜像构建容器可能会导致非预期的行为，因为标准 C 库是不一样的。不过，这种情况比较难碰到，即使碰到也有&lt;span&gt;解决方法&lt;sup&gt;[7]&lt;/sup&gt;&lt;/span&gt;。&lt;/p&gt;&lt;h3&gt;删除RUN的缓存文件&lt;/h3&gt;&lt;p&gt;linux中大部分包管理软件都需要更新源，该操作会带来一些缓存文件，这里记录了常用的清理方法。&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;基于debian的镜像&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span&gt;# 换国内源，并更新&lt;/span&gt;&lt;br/&gt;sed -i “s&lt;span&gt;/deb.debian.org/mirrors.aliyun.com/g&lt;/span&gt;” /etc/apt/sources.list &amp;amp;&amp;amp; apt update&lt;br/&gt;&lt;span&gt;# --no-install-recommends 很有用&lt;/span&gt;&lt;br/&gt;apt &lt;span&gt;install&lt;/span&gt; -y &lt;span&gt;--no-install-recommends a b c &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/*&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;   •&lt;/span&gt;alpine镜像&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span&gt;# 换国内源，并更新&lt;/span&gt;&lt;br/&gt;&lt;span&gt;sed&lt;/span&gt; -i &lt;span&gt;&#x27;s/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g&#x27;&lt;/span&gt; /etc/apk/repositories&lt;br/&gt;&lt;span&gt;# --no-cache 表示不缓存&lt;/span&gt;&lt;br/&gt;apk add --&lt;span&gt;no&lt;/span&gt;-cache a b c &amp;amp;&amp;amp; rm -rf &lt;span&gt;/var/cache/apk/&lt;/span&gt;*&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;  •&lt;/span&gt;centos镜像&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span&gt;# 换国内源并更新&lt;/span&gt;&lt;br/&gt;&lt;span&gt;curl&lt;/span&gt; -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo &amp;amp;&amp;amp; yum makecache&lt;br/&gt;yum &lt;span&gt;install&lt;/span&gt; -y a b &lt;span&gt;c&lt;/span&gt;  &amp;amp;&amp;amp; yum clean al&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;Dockfile实践&lt;/h2&gt;&lt;h3&gt;最佳实践点&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;编写.dockerignore文件&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;一个容器只运行单个应用&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;基础镜像和生产镜像的标签不要使用latest&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;设置WORKDIR和CMD&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;使用ENTRYPOINT，并用exec启动命令（可选）&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;相比ADD，优先使用COPY&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;设置默认的环境变量，映射端口和数据卷&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;使用LABEL设置镜像元数据&lt;/span&gt;&lt;span&gt;&lt;span&gt;•&lt;/span&gt;添加HEALTHCHECK&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;多阶段构建样例&lt;/h3&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;dockerfile&quot;&gt;&lt;code&gt;&lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;golang&lt;/span&gt;&lt;span&gt;:1.11-alpine&lt;/span&gt; &lt;span&gt;AS&lt;/span&gt; &lt;span&gt;build&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 安装项目所需工具&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# Run `docker build --no-cache .` to update dependencies&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt; apk add --&lt;span&gt;no&lt;/span&gt;-cache git&lt;br/&gt;RUN go &lt;span&gt;get&lt;/span&gt; github.com/golang/dep/cmd/dep&lt;br/&gt;&lt;br/&gt;# 安装项目的依赖库（&lt;span&gt;GO&lt;/span&gt;使用 &lt;span&gt;Gopkg&lt;/span&gt;&lt;span&gt;.toml&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; &lt;span&gt;Gopkg&lt;/span&gt;&lt;span&gt;.lock&lt;/span&gt;）&lt;br/&gt;&lt;span&gt;# These layers are only re-built when Gopkg files are updated&lt;/span&gt;&lt;br/&gt;COPY Gopkg.lock Gopkg.toml &lt;span&gt;/go/src/project/&lt;/span&gt;&lt;br/&gt;WORKDIR &lt;span&gt;/go/src/project/&lt;/span&gt;&lt;br/&gt;# &lt;span&gt;Install&lt;/span&gt; &lt;span&gt;library&lt;/span&gt; dependencies&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt; dep ensure -vendor-only&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 拷贝项目并进行构建&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# This layer is rebuilt when a file changes in the project directory&lt;/span&gt;&lt;br/&gt;COPY . &lt;span&gt;/go/src/project/&lt;/span&gt;&lt;br/&gt;&lt;span&gt;RUN&lt;/span&gt; go build -o /bin/project&lt;br/&gt;&lt;br/&gt;&lt;span&gt;# 精简的生成环境&lt;/span&gt;&lt;br/&gt;&lt;span&gt;FROM&lt;/span&gt; scratch&lt;br/&gt;COPY --&lt;span&gt;from&lt;/span&gt;=build /bin/project /bin/project&lt;br/&gt;&lt;span&gt;ENTRYPOINT&lt;/span&gt; [&lt;span&gt;&quot;/bin/project&quot;&lt;/span&gt;]&lt;br/&gt;&lt;span&gt;CMD&lt;/span&gt; [&lt;span&gt;&quot;--help&quot;&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;h2&gt;常见问题&lt;/h2&gt;&lt;h3&gt;alpine基础镜像使用&lt;/h3&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;解决glic问题&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre data-lang=&quot;bash&quot;&gt;&lt;code&gt;&lt;span&gt;ENV&lt;/span&gt; ALPINE_GLIBC_VERSION=&lt;span&gt;&quot;2.31-r0&quot;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;ENV&lt;/span&gt; LANG=C.UTF-&lt;span&gt;8&lt;/span&gt;&lt;br/&gt;&lt;br/&gt;RUN &lt;span&gt;set&lt;/span&gt; -x \&lt;br/&gt;    &amp;amp;&amp;amp; sed -i &lt;span&gt;&#x27;s/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g&#x27;&lt;/span&gt; /etc/apk/repositories \&lt;br/&gt;    &amp;amp;&amp;amp; apk add --&lt;span&gt;no&lt;/span&gt;-cache wget \&lt;br/&gt;    &amp;amp;&amp;amp; wget -q -O &lt;span&gt;/etc/apk/keys/sgerrand.rsa.pub https:/&lt;/span&gt;/alpine-pkgs.sgerrand.com/sgerrand.rsa.pub \&lt;br/&gt;    &amp;amp;&amp;amp; wget -O &lt;span&gt;https:&lt;/span&gt;/&lt;span&gt;/github.com/sgerrand&lt;/span&gt;&lt;span&gt;/alpine-pkg-glibc/releases&lt;/span&gt;&lt;span&gt;/download/&lt;/span&gt;$ALPINE_GLIBC_VERSION/glibc-$ALPINE_GLIBC_VERSION.apk \&lt;br/&gt;    &amp;amp;&amp;amp; wget -O &lt;span&gt;https:&lt;/span&gt;/&lt;span&gt;/github.com/sgerrand&lt;/span&gt;&lt;span&gt;/alpine-pkg-glibc/releases&lt;/span&gt;&lt;span&gt;/download/&lt;/span&gt;$ALPINE_GLIBC_VERSION/glibc-$ALPINE_GLIBC_VERSION.apk \&lt;br/&gt;    &amp;amp;&amp;amp; wget -O &lt;span&gt;https:&lt;/span&gt;/&lt;span&gt;/github.com/sgerrand&lt;/span&gt;&lt;span&gt;/alpine-pkg-glibc/releases&lt;/span&gt;&lt;span&gt;/download/&lt;/span&gt;$ALPINE_GLIBC_VERSION/glibc-bin-$ALPINE_GLIBC_VERSION.apk \&lt;br/&gt;    &amp;amp;&amp;amp; wget -O &lt;span&gt;https:&lt;/span&gt;/&lt;span&gt;/github.com/sgerrand&lt;/span&gt;&lt;span&gt;/alpine-pkg-glibc/releases&lt;/span&gt;&lt;span&gt;/download/&lt;/span&gt;$ALPINE_GLIBC_VERSION/glibc-i18n-$ALPINE_GLIBC_VERSION.apk \&lt;br/&gt;    &amp;amp;&amp;amp; apk add --&lt;span&gt;no&lt;/span&gt;-cache glibc-$ALPINE_GLIBC_VERSION.apk  \&lt;br/&gt;                    glibc-bin-&lt;span&gt;$ALPINE_GLIBC_VERSION&lt;/span&gt;.apk \&lt;br/&gt;                    glibc-i18n-&lt;span&gt;$ALPINE_GLIBC_VERSION&lt;/span&gt;.apk \&lt;br/&gt;    &amp;amp;&amp;amp; /usr/glibc-compat/bin/localedef --force --inputfile POSIX --charmap UTF-8 &lt;span&gt;&quot;&lt;span&gt;$LANG&lt;/span&gt;&quot;&lt;/span&gt; || &lt;span&gt;true&lt;/span&gt; \&lt;br/&gt;    &amp;amp;&amp;amp; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;export LANG=&lt;span&gt;$LANG&lt;/span&gt;&quot;&lt;/span&gt; &amp;amp;gt; /etc/profile.d/locale.sh \&lt;br/&gt;    &amp;amp;&amp;amp; apk &lt;span&gt;del&lt;/span&gt; glibc-i18n \&lt;br/&gt;    &amp;amp;&amp;amp; rm glibc-&lt;span&gt;$ALPINE_GLIBC_VERSION&lt;/span&gt;.apk glibc-bin-&lt;span&gt;$ALPINE_GLIBC_VERSION&lt;/span&gt;.apk glibc-i18n-&lt;span&gt;$ALPINE_GLIBC_VERSION&lt;/span&gt;.apk&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;&lt;h2&gt;参考文献&lt;/h2&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;1.&lt;/span&gt;&lt;span&gt;Dockerfile最佳实践&lt;sup&gt;[8]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;2.&lt;/span&gt;&lt;span&gt;docker多阶段构建&lt;sup&gt;[9]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;3.&lt;/span&gt;&lt;span&gt;三个技巧，将 Docker 镜像体积减小 90%&lt;sup&gt;[10]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;4.&lt;/span&gt;&lt;span&gt;精简Docker镜像的五种通用方法&lt;sup&gt;[11]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;5.&lt;/span&gt;&lt;span&gt;优化Dockerfile最佳实践&lt;sup&gt;[12]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;6.&lt;/span&gt;&lt;span&gt;alpine3.12镜像&lt;sup&gt;[13]&lt;/sup&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;h3&gt;References&lt;/h3&gt;&lt;p&gt;&lt;code&gt;[1]&lt;/code&gt; 官方的Dockerfile最佳实践: &lt;em&gt;https://docs.docker.com/develop/develop-images/dockerfile_best-practices/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[2]&lt;/code&gt; alpine:3.12: &lt;em&gt;https://github.com/alpinelinux/docker-alpine/blob/90788e211ec6d5df183d79d6cb02e068b258d198/x86_64/Dockerfile&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[3]&lt;/code&gt; Dockerfile: &lt;em&gt;https://blog.haojunyu.com/atts/redis_multiline&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[4]&lt;/code&gt; Dockerfile: &lt;em&gt;https://blog.haojunyu.com/atts/redis_singleline&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[5]&lt;/code&gt; Dockerfile: &lt;em&gt;https://blog.haojunyu.com/atts/redis_multistage&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[6]&lt;/code&gt; Dockerfile: &lt;em&gt;https://blog.haojunyu.com/atts/redis_official_buster&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[7]&lt;/code&gt; 解决方法: &lt;em&gt;#alpine基础镜像使用&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[8]&lt;/code&gt; Dockerfile最佳实践: &lt;em&gt;https://docs.docker.com/develop/develop-images/dockerfile_best-practices/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[9]&lt;/code&gt; docker多阶段构建: &lt;em&gt;https://docs.docker.com/develop/develop-images/multistage-build/&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[10]&lt;/code&gt; 三个技巧，将 Docker 镜像体积减小 90%: &lt;em&gt;https://www.infoq.cn/article/3-simple-tricks-for-smaller-docker-images&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[11]&lt;/code&gt; 精简Docker镜像的五种通用方法: &lt;em&gt;https://zhuanlan.zhihu.com/p/42815689&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[12]&lt;/code&gt; 优化Dockerfile最佳实践: &lt;em&gt;https://blog.csdn.net/xyz_dream/article/details/89741751?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&lt;/em&gt;&lt;br/&gt;&lt;code&gt;[13]&lt;/code&gt; alpine3.12镜像: &lt;em&gt;https://github.com/alpinelinux/docker-alpine/blob/90788e211ec6d5df183d79d6cb02e068b258d198/x86_64/Dockerfile&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>5584e3d4a6d16695cd32e7f7eb811a54</guid>
<title>分布式任务调度系统之任务编排及工作流实现原理与 Golang 实践</title>
<link>https://toutiao.io/k/cpo3wsw</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section&gt;&lt;strong&gt;&lt;span&gt;I.内容提要&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;hr/&gt;&lt;section&gt;&lt;span&gt;定时调度系统（定时任务、定时执行）算是工作中经常依赖的中间件系统，简单使用操作系统的 crontab，或基于 Quartz，xxl-job 来搭建任务调度平台，行业有很多优秀的开源产品和中间件。&lt;/span&gt;&lt;span&gt;了解其工作和设计原理，有助于我们完善或定制一套适合公司业务场景的任务调度中间件，之前写了两篇文章介绍了调度负载均衡和定时延时任务的内容，可以参考。&lt;/span&gt;&lt;br/&gt;&lt;/section&gt;&lt;section&gt;&lt;span&gt;今天我们探讨另一话题，对调度任务的&lt;/span&gt;&lt;span&gt;&lt;strong&gt;依赖关系及编排&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;展开分析，实现一套&lt;/span&gt;&lt;span&gt;工作流&lt;/span&gt;&lt;span&gt;，来满足任务间的复杂依赖的场景。本章内容提要：&lt;/span&gt;&lt;/section&gt;&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;&lt;span&gt;任务调度依赖 &amp;amp; 工作流&lt;/span&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;图相关知识&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;span&gt;golang 并发相关&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;section&gt;&lt;strong&gt;&lt;span&gt;II.任务调度依赖&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;什么是任务依赖？&lt;/span&gt;&lt;span&gt;比如 “&lt;span&gt;任务 a&lt;/span&gt;” 执行的前提是 “&lt;span&gt;任务 b&lt;/span&gt;” 先执行完成，“&lt;/span&gt;&lt;span&gt;任务b&lt;/span&gt;&lt;span&gt;” 又依赖于 “&lt;span&gt;任务 c&lt;/span&gt;” 先执行，那么就形成如下依赖关系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.36123348017621143&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd942pyNZBeib49zhWia23HomyX4DKnia7gcxtnWmRTqeoJcvWraMaedicqYHWHTlRxAWq4TNg4E4ceSYQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;227&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个还比较简单，如果复杂点的如下图所示，形成一个工作流，Azkaban 大数据调度器就实现了工作流模式调度依赖，这是一个典型的图应用案例。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9347079037800687&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd942pyNZBeib49zhWia23HomyH4eha8y4M7qcSibzoHItySiaOuGFuJfDTOb7x33PyibcsLicUXWUicE7X8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;291&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;III.图数据结构&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;提到图数据结构，大部分人既熟悉又陌生，因为大学基本都学过，但一般工作场景都不会用到，这里就先简单回顾一下图相关的知识。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;图 graph&lt;/span&gt;&lt;span&gt; ，图中的元素称为&lt;/span&gt;&lt;span&gt;顶点 vertex&lt;/span&gt;&lt;span&gt;。图中任一顶点可以与其他顶点建立连线关系，叫做&lt;/span&gt;&lt;span&gt;边 edge&lt;/span&gt;&lt;span&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.6433566433566433&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd942pyNZBeib49zhWia23HomySGNuj7RLF0X67qTiahibvNfTHjeR4xwgPsnv6yiaiceNvSNAS5tDAHMf8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;286&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上面图叫 “&lt;span&gt;无向图&lt;/span&gt;”，如果边有 “方向” ，那么就是 “&lt;span&gt;有向图&lt;/span&gt;” 了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.7426160337552743&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd942pyNZBeib49zhWia23Homy9ibSfyTMibocEMd8C6d41ebxsrQBPiaEziaWVrdX3RgiafDIqmRcE7Vpu4w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;237&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;无向图中，顶点有几条边就叫几&lt;/span&gt;&lt;span&gt;度&lt;/span&gt;&lt;span&gt;；有向图中，顶点有&lt;span&gt;入度&lt;/span&gt;，表示有多少边指向此顶点，顶点的&lt;span&gt;出度&lt;/span&gt;表示该顶点有多少边指向 “&lt;span&gt;远方&lt;/span&gt;” 。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上图中 a 指向 b，b 指向 d，d 又指向 a， a、b、d 之间形成一个环，如果将顶点比作调度的任务，那么任务 a 完成必须依赖任务 b，任务 b 又依赖任务 d，任务 d 又依赖任务 a，那么最终肯定无法完成，因此调度问题使用的是&lt;span&gt;有向无环图 （DAG）&lt;/span&gt;，比如我们最早那张图。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9347079037800687&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd942pyNZBeib49zhWia23HomyH4eha8y4M7qcSibzoHItySiaOuGFuJfDTOb7x33PyibcsLicUXWUicE7X8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;291&quot;/&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;了解了图的基本概念，那么图结构如何用代码表示出来？这里涉及到图的两种存储方式：&lt;span&gt;邻接矩阵、邻接表&lt;/span&gt;。&lt;br/&gt;邻接矩阵底层为&lt;/span&gt;&lt;span&gt;二维数据&lt;/span&gt;&lt;span&gt;，如果有一条边顶点为 x 和 y，对无向图来说，对应的数据 Array[x][y] 和 Array[y][x] 标记为 1；对有向图 x-&amp;gt;y ，只将 Array[x][y] 标记为 1 即可，下图为使用邻接矩阵表示的无向图和有向图。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5584415584415584&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbdiburicibjibT7WQwoSPRB8hsLV0bsPerPsz8ZiaicYiaWPID2zzibqlicZCSPsdsibX0h9AialhiaQoqQbMT1S7g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;385&quot;/&gt;&lt;/section&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5792349726775956&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbdiburicibjibT7WQwoSPRB8hsLVyOvzyGtswic8zzF7pLWUiax1R4Xe0rr8tIJbbTZiaiay1Fic1zODjZ2ibIdA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;366&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;对于无向图来说，邻接矩阵沿着红色对角线两边是对称的，如果图的顶点连线比较少，这种叫&lt;/span&gt;&lt;span&gt;稀疏图&lt;/span&gt;&lt;span&gt;，将存储大量的 0 ，浪费存储空间，这时候可以选择使用邻接表表示，相对稀疏图的叫&lt;/span&gt;&lt;span&gt;稠密图&lt;/span&gt;&lt;span&gt;，使用邻接矩阵可以更好地查询连通性，其原理也是&lt;/span&gt;&lt;span&gt;用空间换时间&lt;/span&gt;&lt;span&gt;。下图为使用邻接表表示的无向图和有向图。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.29381443298969073&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbdiburicibjibT7WQwoSPRB8hsLV8dibSib5Jw57LEoic00ZTsHqpl04vaLMjsLOk0dAKAOrQwR560Z7bJ8fw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;776&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;strong/&gt;&lt;/p&gt;&lt;section&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.2793522267206478&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbdiburicibjibT7WQwoSPRB8hsLVWEiaNUWKN4RCn9fzIJNMAWkzUlib0C9C1Bx66XQgH7vIZPASAO4qD7eQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;741&quot;/&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;最后说下图的遍历，和遍历树一样分为&lt;span&gt;广度优先 BFS&lt;/span&gt; 和 &lt;span&gt;深度优先 DFS&lt;/span&gt;，但图如果存在成环的情况，访问的节点要做记录，同时可用辅助队列存放待访问的邻接节点。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;拓扑排序&lt;/span&gt;&lt;span&gt;，对有向无环图的顶点进行遍历，将所有顶点形成一个线性序列，可以用数组（切片）或链表存储，如下图。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.30514096185737977&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbdiburicibjibT7WQwoSPRB8hsLVretA6EtVfsGpZLq1Idzia682icYA77gv6whvucKiaLILXrDbxqdWg5LJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;603&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;IV.golang 代码实现&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;回顾了图的相关知识，那么回到最开始的任务依赖工作流中，将每个任务看成图的顶点，任务 a 依赖 任务 b，使用一条有向线从 a 指向 b，最后将所有任务顶点连线形成一个图，这个图是一个有向无环图 DAG，对 DAG 进行拓扑排序，形成一个任务执行链表，反向执行即可解决依赖问题。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.9347079037800687&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd942pyNZBeib49zhWia23HomyH4eha8y4M7qcSibzoHItySiaOuGFuJfDTOb7x33PyibcsLicUXWUicE7X8w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;291&quot;/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;首先定义一个图结构体，这里使用邻接矩阵方式存储，图的顶点结构体存储 Key 和 Value 代表任务的相关执行信息。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; DAG &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Vertexs []*Vertex&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;type&lt;/span&gt; Vertex &lt;span class=&quot;code-snippet__keyword&quot;&gt;struct&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Key      &lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Value    &lt;span class=&quot;code-snippet__keyword&quot;&gt;interface&lt;/span&gt;{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Parents  []*Vertex&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    Children []*Vertex&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;为图添加顶点和添加边，这里是有向图，from 代表边的起始顶点， to 代表边的终止顶点。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(dag *DAG)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;AddVertex&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(v *Vertex)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    dag.Vertexs = &lt;span class=&quot;code-snippet__built_in&quot;&gt;append&lt;/span&gt;(dag.Vertexs, v)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__params&quot;&gt;(dag *DAG)&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;AddEdge&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(from, to *Vertex)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    from.Children = &lt;span class=&quot;code-snippet__built_in&quot;&gt;append&lt;/span&gt;(from.Children, to) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    to.Parents = &lt;span class=&quot;code-snippet__built_in&quot;&gt;append&lt;/span&gt;(to.Parents, from)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;建立 a - i 所有顶点，再对每个顶点&lt;span&gt;连线&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; dag = &amp;amp;DAG{}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;va := &amp;amp;Vertex{Key: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;a&quot;&lt;/span&gt;, Value: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;1&quot;&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;vb := &amp;amp;Vertex{Key: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;b&quot;&lt;/span&gt;, Value: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;2&quot;&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;vc := &amp;amp;Vertex{Key: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;c&quot;&lt;/span&gt;, Value: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;3&quot;&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;vd := &amp;amp;Vertex{Key: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;d&quot;&lt;/span&gt;, Value: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;4&quot;&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;ve := &amp;amp;Vertex{Key: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;e&quot;&lt;/span&gt;, Value: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;5&quot;&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;vf := &amp;amp;Vertex{Key: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;f&quot;&lt;/span&gt;, Value: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;6&quot;&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;vg := &amp;amp;Vertex{Key: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;g&quot;&lt;/span&gt;, Value: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;7&quot;&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;vh := &amp;amp;Vertex{Key: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;h&quot;&lt;/span&gt;, Value: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;8&quot;&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;vi := &amp;amp;Vertex{Key: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;i&quot;&lt;/span&gt;, Value: &lt;span class=&quot;code-snippet__string&quot;&gt;&quot;9&quot;&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;dag.AddEdge(va, vb)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;dag.AddEdge(va, vc)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;dag.AddEdge(va, vd)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;dag.AddEdge(vb, ve)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;dag.AddEdge(vb, vh)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;dag.AddEdge(vb, vf)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;dag.AddEdge(vc, vf)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;dag.AddEdge(vc, vg)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;dag.AddEdge(vd, vg)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;dag.AddEdge(vh, vi)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;dag.AddEdge(ve, vi)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;dag.AddEdge(vf, vi)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;dag.AddEdge(vg, vi)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;对该图进行广度优先遍历，通过引入队列来减少时间复杂度，遍历后生成一个包含所有顶点的 slice 。&lt;/span&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;104&quot; data-source-title=&quot;&quot;&gt;&lt;ol class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;选择起始节点入队列&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;&lt;span&gt;节点出队列&lt;/span&gt;&lt;/p&gt;&lt;/section&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;2.1 &lt;span&gt;队列空了，说明遍历完毕返回&lt;br/&gt;&lt;/span&gt;&lt;span&gt;       2.2 已访问跳过，未访问顶点放入输出 slice 中&lt;/span&gt;&lt;/p&gt;&lt;section&gt;2.3 &lt;span&gt;将节点的所有未访问邻接节点 Children 放入队列&lt;/span&gt;&lt;/section&gt;&lt;p&gt;   3. 重复执行 2 &lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;注意 slice 加入顺序，因为执行要从 i 到 a 的顺序，所以将每次遍历后的元素放到 slice 第一个位置。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;BFS&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(root *Vertex)&lt;/span&gt; []*&lt;span class=&quot;code-snippet__title&quot;&gt;Vertex&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    q := queue.New()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    q.Add(root)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    visited := &lt;span class=&quot;code-snippet__built_in&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;]*Vertex)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    all := &lt;span class=&quot;code-snippet__built_in&quot;&gt;make&lt;/span&gt;([]*Vertex, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; q.Length() &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        qSize := q.Length()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; qSize; i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            currVert := q.Remove().(*Vertex)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; _, ok := visited[currVert.Key]; ok {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            visited[currVert.Key] = currVert&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            all = &lt;span class=&quot;code-snippet__built_in&quot;&gt;append&lt;/span&gt;([]*Vertex{currVert}, all...)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; _, val := &lt;span class=&quot;code-snippet__keyword&quot;&gt;range&lt;/span&gt; currVert.Children {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; _, ok := visited[val.Key]; !ok {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    q.Add(val) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; all&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;最后就是对所有任务进行执行，这里假定每个任务执行需要 5 秒，然后输出执行结果。&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;doTasks&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(vertexs []*Vertex)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; _, v := &lt;span class=&quot;code-snippet__keyword&quot;&gt;range&lt;/span&gt; vertexs {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        time.Sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt; * time.Second)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        fmt.Printf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;do %v, result is %v \n&quot;&lt;/span&gt;, v.Key, v.Value)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.15841584158415842&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbdiburicibjibT7WQwoSPRB8hsLV1bYewIalo2KHGG38MIeKqtt9tAqpdOKdVkXZnu8FWlTpZcvgSaXyHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;606&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过执行测试用例，可以看到执行按上述生成的 slice 顺序，从左向右逐个执行，满足任务依赖关系。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8380281690140845&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd942pyNZBeib49zhWia23HomyT6x3jMPbGXA87pQkk2WwxX9YurE6GxXudStBsFMxz1ibic09Yv0r1VXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;284&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;strong/&gt;&lt;span&gt;但这里有个问题就是执行时间过长，因为每一个都是串行执行，9 个任务要执行 45 秒。那么并行不就解决了？但任务有依赖关系又如何并行呢？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5983772819472617&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd942pyNZBeib49zhWia23Homy8MJSRqbichf8rQFFyz1O7T6P9h1OXiaWSIicpyGibgothyDNdnYEafpXCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;493&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过这个图即可一目了然明白了，&lt;span&gt;分层执行&lt;/span&gt;，上层任务依赖下层，但每一层的任务相互独立可以并发执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;首先在 BFS 遍历生成顶点的时候，需要生成双层切片：&lt;/span&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;42&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;[0] [] { i } &lt;/p&gt;&lt;p&gt;[1] [] { h, e, f, g } &lt;/p&gt;&lt;p&gt;[2] [] { b, c, d } &lt;/p&gt;&lt;p&gt;[3] [] { a }&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;BFSNew&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(root *Vertex)&lt;/span&gt; [][]*&lt;span class=&quot;code-snippet__title&quot;&gt;Vertex&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    q := queue.New()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    q.Add(root)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    visited := &lt;span class=&quot;code-snippet__built_in&quot;&gt;make&lt;/span&gt;(&lt;span class=&quot;code-snippet__keyword&quot;&gt;map&lt;/span&gt;[&lt;span class=&quot;code-snippet__keyword&quot;&gt;string&lt;/span&gt;]*Vertex)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    all := &lt;span class=&quot;code-snippet__built_in&quot;&gt;make&lt;/span&gt;([][]*Vertex, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; q.Length() &amp;gt; &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt; { &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        qSize := q.Length()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        tmp := &lt;span class=&quot;code-snippet__built_in&quot;&gt;make&lt;/span&gt;([]*Vertex, &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;code-snippet__number&quot;&gt;0&lt;/span&gt;; i &amp;lt; qSize; i++ {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            currVert := q.Remove().(*Vertex)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; _, ok := visited[currVert.Key]; ok {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;continue&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            visited[currVert.Key] = currVert&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            tmp = &lt;span class=&quot;code-snippet__built_in&quot;&gt;append&lt;/span&gt;(tmp, currVert)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; _, val := &lt;span class=&quot;code-snippet__keyword&quot;&gt;range&lt;/span&gt; currVert.Children {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                &lt;span class=&quot;code-snippet__keyword&quot;&gt;if&lt;/span&gt; _, ok := visited[val.Key]; !ok {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    q.Add(val) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        all = &lt;span class=&quot;code-snippet__built_in&quot;&gt;append&lt;/span&gt;([][]*Vertex{tmp}, all...)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }   &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;return&lt;/span&gt; all &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;同时执行时候按每一层并发执行。这里通过 sync.WaitGroup 保障并发同步等待&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;section class=&quot;code-snippet__fix code-snippet__js&quot;&gt;&lt;pre class=&quot;code-snippet__js&quot; data-lang=&quot;go&quot;&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; _, layer := &lt;span class=&quot;code-snippet__keyword&quot;&gt;range&lt;/span&gt; all {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        fmt.Println(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;------------------&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        doTasksNew(layer)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;/&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;&lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;code-snippet__title&quot;&gt;doTasksNew&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(vertexs []*Vertex)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;var&lt;/span&gt; wg sync.WaitGroup&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    &lt;span class=&quot;code-snippet__keyword&quot;&gt;for&lt;/span&gt; _, v := &lt;span class=&quot;code-snippet__keyword&quot;&gt;range&lt;/span&gt; vertexs {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        wg.Add(&lt;span class=&quot;code-snippet__number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        &lt;span class=&quot;code-snippet__keyword&quot;&gt;go&lt;/span&gt; &lt;span class=&quot;code-snippet__function&quot;&gt;&lt;span class=&quot;code-snippet__keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;code-snippet__params&quot;&gt;(v *Vertex)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            &lt;span class=&quot;code-snippet__keyword&quot;&gt;defer&lt;/span&gt; wg.Done()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            time.Sleep(&lt;span class=&quot;code-snippet__number&quot;&gt;5&lt;/span&gt; * time.Second)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            fmt.Printf(&lt;span class=&quot;code-snippet__string&quot;&gt;&quot;do %v, result is %v \n&quot;&lt;/span&gt;, v.Key, v.Value)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }(v) &lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    wg.Wait()&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;上述代码注意，遍&lt;/span&gt;&lt;span&gt;历变量被并发调度必须进行&lt;/span&gt;&lt;span&gt;绑定&lt;/span&gt;，如果按下面这样写将会有问题。&lt;/span&gt;&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;52&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;p&gt;for _, v := range vertexs {
 &lt;/p&gt;&lt;p&gt;  go func() {&lt;/p&gt;&lt;p&gt;          //...            &lt;/p&gt;&lt;p&gt;          fmt.Printf(v)
        &lt;/p&gt;&lt;p&gt;   }()&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;span&gt;这是因为 for k, v := rang xx  语句中，每次循环变量 k 和 v 是重新赋值，并非生成新的变量，如果循环中启动协程并引用变量 k 和 v 很可能在循环结束时才开启协程执行，这时所有协程中的变量 k 和 v 都是同一个变量，输出内容也会完全相同。所以这里将 v 加入函数参数中，因为 go 函数都是值传递，会重新绑定到新的变量中。&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;通过并发改造后，执行时间只有 20 秒了，大大提高了任务执行的效率。&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.8369829683698297&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd942pyNZBeib49zhWia23Homy39w7VooMoVRZ43aIgfKWO0JrdPia8B3O7IH3tFUWHicwZY6qCcfRtuDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;411&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过本章内容，我们实现了任务调度的工作流模式，&lt;span&gt;文章相关代码请关注公众号  &lt;strong&gt;&lt;span&gt;技术岁月&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/strong&gt;，发送关键字 &lt;/span&gt;&lt;span&gt;&lt;strong&gt;任务编排&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;span&gt;获取，欢迎大家点赞、分享、转发。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/p&gt;&lt;section&gt;&lt;span&gt;&lt;span/&gt;&lt;/span&gt;&lt;/section&gt;&lt;p&gt;&lt;img data-type=&quot;png&quot; data-ratio=&quot;1&quot; data-w=&quot;258&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/zZCzuY9fbd8xnrzVoibMJU5ANalBUqBzuW7mZnCWFhYC94LpYATpCpIU9nDJiaDvqcf3PzctAFK61PgxWic8S5Axg/640?wx_fmt=png&quot;/&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>6b0241622c8dd3496a849a0f3a08058d</guid>
<title>来了解一下 K8S 的 Operator 模式</title>
<link>https://toutiao.io/k/rdqdv6v</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;rich_media_content &quot; id=&quot;js_content&quot;&gt;
                    

                    

                    
                    
                    &lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面的文章介绍了 Kubernetes 自带的管理有状态应用的控制器 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUzNTY5MzU2MA==&amp;amp;mid=2247486737&amp;amp;idx=1&amp;amp;sn=e7d0689fa74b108bae734515837c68e1&amp;amp;chksm=fa80dc86cdf755909f2f29ee8cb9dce930b95a837cb045be5c9700a9000743c9cb7f8eed6731&amp;amp;token=480855145&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;StatefulSet&lt;/a&gt; ，它能够完成应用的拓扑顺序状态管理 （比如，重启时按照顺序重建 Pod）以及结合 PVC 完成应用的存储状态管理。不过在 Kubernetes 生态中还有一种更灵活、编程友好的解决方案 -- Operator， 它能让使用者根据自己应用的特性定义应用对象和管理对象的控制器。&lt;/p&gt;&lt;blockquote class=&quot;js_blockquote_wrap&quot; data-type=&quot;2&quot; data-url=&quot;&quot; data-author-name=&quot;&quot; data-content-utf8-length=&quot;53&quot; data-source-title=&quot;&quot;&gt;&lt;section class=&quot;js_blockquote_digest&quot;&gt;&lt;section&gt;&lt;strong&gt;这篇文章都是一些概念性的文字描述，阅读起来比较轻松，后面会再专门写怎么编码自己实现一个Operator。&lt;/strong&gt;&lt;/section&gt;&lt;/section&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么是Operator&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Operator 概念是由 CoreOS 的工程师于2016年提出的，它让工程师可以根据应用独有的领域逻辑为应用编写自定义的控制器。这句话说的有点虚空，我们通过一个简单的例子理解一下 Operator 。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;假设有一个连接数据库的 Java Web程序。你想将其部署到您的k8s集群。理想情况下，你会希望用 Deployment 部署应用然后暴露给 Service，对于应用服务的后端则是使用 StatuflSet 部署数据库。所以需要完成两部分的部署才能把整个应用服务部署完成：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;无状态部分：Java Web 应用。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;有状态部分：数据库。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上面的例子中，我们可以应用我们对应用程序与数据库之间的关系的了解，创建一个控制器，该控制器将以某种特定方式运行时执行某些操作。比如备份、更新、数据还原这些任务该如何完成取决于应用程序本身和业务限制（领域知识）。这些与应用强相关的操作就是 Kubernetes Operator要做的：代替原本需要由SRE（Site Reliability Engineers）和运维工程师来完成操作的执行。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;自定义资源和控制器&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Operator 模型基于 Kubernetes 中的两个概念结合而成：自定义资源和自定义控制器。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;自定义资源&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 Kubernetes中，资源是 Kubernetes API中的一个端点，用于存储一堆特定类型的API对象。它允许我们通过向集群添加更多种类的对象来扩展Kubernetes。添加新种类的对象之后，我们可以像其他任何内置对象一样，使用 kubectl 来访问我们自定义的 API 对象。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以 Pod 或 Deployment 为例。编写清单时，必须在 YAML 文件中指定一种类型（是 Pod 还是 Deployment）。自定义资源就是不由 Kubernetes 原生提供的资源对象。&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span/&gt;&lt;span&gt;自定义控制器&lt;/span&gt;&lt;span/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Kubernetes 的所有控制器，都有一个控制循环，负责监控集群中特定资源的更改，并确保特定资源在集群里的当前状态与控制器自身定义的期望状态保持一致。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举例来说有一个 Deployment 控制器管控值集群里的一组 Pod ，当你 Kill 掉一个 Pod 。控制器发现定义中期望的Pod数量与当前的数量不匹配，它就会马上创建一个 Pod 让当前状态与期望状态匹配。控制器这种让关联资源的当前状态向期望状态迈进的过程叫做调谐（reconcile）。&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5295629820051414&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/z4pQ0O5h0f5CZyzIGHmNkU4wLRquicGNmMGBbO5ibdXWdLBovicWmLz765FG9YPliaWYr5fibT8HagkOIMtMssWzyCA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;778&quot;/&gt;&lt;figcaption&gt;图片&lt;/figcaption&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么，像 Deployment 这样的内置控制器也叫做 Operator 吗？其实不是，因为这些控制器不是特定于特定的应用程序的，而是内置类型资源的上游控制器。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;什么时候应该用 Operator&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;重要的是要知道所有的 Operator 都是控制器，但并非所有的控制器都是 Operator。对于被视作 Operator 的控制器，它必须知道应用程序的业务逻辑，才能代表用户（SRE / Ops工程师）执行自动化任务。&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;当需要封装有状态的应用程序业务逻辑（使用Kubernetes API控制所有内容）时，都可以使用 Operator 。这使围绕 Kubernetes 生态系统内置的应用程序的自动化成为可能。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;每当需要创建工具来监视应用程序的更改并在发生某些事情时执行某些SRE / Ops任务时，都应使用 Operator。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;span&gt;关于 Operator 的使用建议&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;K8S内置控制器用于群集本身，而 Operator 是用于部署有状态应用程序的控制器。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建 Operator 时，请遵循以下最佳模式实践：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;要站在巨人的肩膀上--利用内置资源种类在它们的基础上创建你自定义的资源种类。&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;确保控制器不需要其他外部代码即可正常工作，只需运行kubectl install即可部署你定义的控制器。&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当你准备好为特定应用程序创建自定义资源，该资源可以与自定义控制器进行协调，从而可以扩展 Kubernetes 的正常行为时，就是时候开始使用 Operator了。&lt;/p&gt;&lt;/section&gt;&lt;p&gt;&lt;/p&gt;
                &lt;/div&gt;

                

                



                
                &lt;div class=&quot;reward_qrcode_area reward_area tc&quot; id=&quot;js_reward_qrcode&quot;&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;Long-press QR code to transfer me a reward&lt;/p&gt;
                                                                &lt;p class=&quot;reward_tips&quot;&gt;点在看支持我的创作&lt;/p&gt;
                                &lt;span class=&quot;reward_qrcode_img_wrp&quot;&gt;&lt;img class=&quot;reward_qrcode_img&quot; id=&quot;js_reward_qrcode_img&quot;/&gt;&lt;/span&gt;
                                &lt;p class=&quot;tips_global&quot;&gt;As required by Apple&#x27;s new policy, the Reward feature has been disabled on Weixin for iOS. You can still reward an Official Account by transferring money via QR code.&lt;/p&gt;
                            &lt;/div&gt;
                                                                            
                              
            &lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>afce2883ab861a1b98284e2d19022ba7</guid>
<title>《HelloGitHub》第 58 期</title>
<link>https://toutiao.io/k/4f2rzse</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot; data-mpa-powered-by=&quot;yiban.io&quot;&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.42567567567567566&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efvSCTD1HicQ3yfmDjWbbcZjRIxGFzx11QM50bdFCT5sdPJDApWk8XczA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;888&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HelloGitHub 分享 GitHub 上有趣、入门级的开源项目。欢迎大家：&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本月刊是&lt;span&gt;每月 28 号&lt;/span&gt;更新，再见月刊就是年后了。HelloGitHub 提前祝大家：&lt;strong&gt;新年快乐！&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;下面便是第 58 期的内容啦，希望大家喜欢~&lt;/p&gt;&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p&gt;C# 项目&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、EverythingToolbar：把搜索和启动应用等功能整合到 Windows taskbar 的工具。效果如下图：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1.0025641025641026&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efZobh02MPo1Z6nasHgsJ0WN2ibgWplM2EcNfVMqGchXTVOks5xZW6plQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;780&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5619047619047619&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6ef0aTzJqEW6UbveBakSt0KpxoeB6Efe5yM1gshYrbrQ5qnN04vRy1e0g/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;C++ 项目&lt;br/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、ChordNova：一款开源免费的和弦生成工具。我不懂乐理，但单从这个软件的界面就感受到了专业，因为有很多乐理的名词😅&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6eft3S5ic7GB7deiaCx10La2XD9dGFO3xkeGXEP7mIzNec4zt47wgguyPyA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5619047619047619&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efECe7boTS6DlmMcc7iayQGtvk7uZUnLQWdAML6slO1lA86HlyKqazMdg/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;span/&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;Go 项目&lt;br/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、containers-the-hard-way：用 Go 实现迷你 Docker，包含 Docker 核心功能的开源项目。该项目仅用 Linux 系统接口实现了类似容器的功能，这些能够帮助你更好地了解容器的工作方式。如果你想更深入地理解容器，就参考本项目写一个迷你 Docker 吧&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.7017841971112999&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efkeFPS40ZSTlKPlwGgYtSCkGQFHfxDdMXKrE8Zr202U4JkH3yfrZRng/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1177&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efTHI03EoaFwyXFe0g8OBVCGOd5dibcAgjgZ59Tz1c4R23L18Va7Zly0Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、vegeta：基于 Go 语言的 HTTP 压测工具。目前市面上的压测工具已经很多了，但是今天推荐的这款惊艳到我点是下面这条命令执行后的效果（vegeta+jaggr+jplot），让我们一起来感受下吧&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&#x27;GET http://localhost:8080&#x27;&lt;/span&gt; | \&lt;br/&gt;    vegeta attack -rate 5000 -duration 10m | vegeta encode | \&lt;br/&gt;    jaggr @count=rps \&lt;br/&gt;          hist\[100,200,300,400,500\]:code \&lt;br/&gt;          p25,p50,p95:latency \&lt;br/&gt;          sum:bytes_in \&lt;br/&gt;          sum:bytes_out | \&lt;br/&gt;    jplot rps+code.hist.100+code.hist.200+code.hist.300+code.hist.400+code.hist.500 \&lt;br/&gt;          latency.p95+latency.p50+latency.p25 \&lt;br/&gt;          bytes_in.sum+bytes_out.sum&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.6237623762376238&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efGW21NhwgBslugcgiaryqiblCibokic6CMwNWYsre7NKnM9mmItsZ7FYwbg/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;2020&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6ef3575SJ8IlOl1x5sa6Abic3yFicxJsZqOx9t2oenZnnHpLYsWpINw6DBA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5、delve：一款 Go 语言的调试工具。如果你还在像我一样用 &lt;code&gt;fmt.Println&lt;/code&gt; 调试 go 的代码，就试试这个工具吧。万星的开源项目可不是开玩笑的，它上手简单并且支持多种方式调用，助你快速找到 Bug&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.28828125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efiavG05OjH86ORq9orkgPRnatMmLF5FVfgAlykuCIUiatPt0rWQ2iaeDcg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efLM2icEzBbmTricwTc5JHg9uyF6dLSX7orF9ToHN8Too59WficM2D9lZnQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6、rqlite：用 Go 实现的基于 SQLite 轻量级、分布式关系数据库。如果你对分布式数据库的原理及实现感兴趣的话，这个项目真的是你入门这方面的不二之选，这个项目用 SQLite 作为存储引擎，让你可以把更多的精力放在理解分布式的知识上，尝试阅读下这个项目的文档，相信你会对它感兴趣的。设计图如下：&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.717948717948718&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efxHibXAY8iaSiahbkKMibyD8JZC6iauqJVRBzokwdfpYLA4g4FDNCpLRyaog/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1248&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efNwWzJEwyj5AYsPJm6HEj1S1aBiaSSrb1NicuxK6cB14sfF1bnyK82exA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;Java 项目&lt;br/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;7、JustAuth：帮你搞定第三方登陆的 Java 开源组件。使用简单、接入方便，帮你随心所欲地接入第三方登陆，让登陆变得简单。目前已经支持十多个平台，还在持续扩充中&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.61796875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efJ35DmqN2j9XNjp6Jkkdc5SfpXURe2P1qNCYXyMwMlZrYvdCY2c0xibw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efiag6HQQB6NLHUwRVLLY4XSCCUSGOMK28CNYYoFCahS6ic01W6ttL0ctg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;8、java-design-patterns：设计模式 Java 的最佳实践，出自开源社区大佬们之手。作为有梦想和追求的 Java 程序员，当然需要会一些设计模式啦。这个项目虽然是英文的但是先看代码和图，尝试理解含义那么英文描述也就能猜得八九不离十了。不要让英语作为你不努力的借口，努力变强吧！&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efcI5NnZEV2RhnhNjaWGsSfXj1nDPECK9HR1sDiclB9mWvMnATEJC4PDA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;9、apollo：携程开源的分布式配置中心。开箱即用理念发挥到极致，比如：服务器部分基于 Spring Boot 和 Spring Cloud 开发，运行方便无需额外的 Tomcat 应用容器。并且具备配置修改后即时生效、规范的权限、流程治理等特性，适用于微服务配置管理场景&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.73359375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6ef1D4m4aaS4ibkogRA5kBKibibzXe6fC5QgoSdNicYbfDldIgLJktHFUeaibw/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efl0y7x0zrCM1TWcWwN53RPfsHsibU6n6icmmYkpbkiahKaEZaZXg5HjzJw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;10、Logi-KafkaManager：功能强大的 Kafka 集群监控和运维管理平台。强大到我一度以为它是付费的，如果你的公司用 Kafka 的话，可以试试主导把这个项目在公司内部用起来，那你离升职和加薪就不远了&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.571875&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efgCtHQicKFCAm4v1bmpSdfmPQMJ0mjDAGCr2xCSAwHAvYqBu1icibqVWlw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efoeaiarqVic5UCZxLHNj6o4pQFhsXr6lnrOI4MfJzhyOWCDtibFwEuB3BQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;11、Anki-Android：高效学习神器 Anki 安卓客户端。Anki 是一个帮助学习的记忆卡片软件，卡片正面是问题背面是答案，然后根据记忆公式帮你复习和记牢。下载地址 如果下载后不会用的话，本文点赞过 100 我出一份小白教程给大家上手这个神器&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.57890625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efxb8GRxEB90L5P2HVr7autcibgerwLrtn1VzGDXr8LpRYpKv9D0Op2bQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efLVicNWDP8GgTPqs78kYibYv4OyGxKicibrnV9NQMhXOZCia2OsKMay1rqpQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;JavaScript 项目&lt;br/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;12、cloudbase-framework：腾讯开源的云原生一体化部署工具。一键将项目部署上云，不限制框架和语言&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.48125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efm1VJiaiaeKJ2VnEbBCQLmtFQ8icxNvzgwfKamTXPrJWgWAsuXExcwUmSw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efdMge7zXKRWibYTdK4oevcJugx5vmozCYx6HXLmTd10FrEZvFWxQ0Jzw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;13、newbee-mall-vue3-app：基于 Vue 3.0 技术栈的电商网站前端开源项目。它麻雀虽小五脏俱全，包含模块：首页、类型分类、搜索、地址管理、登录注册等等，该有的基本上都有涉及到。对新手友好，在熟悉 Vue 3.x 的朋友也可以来看看&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.27109375&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efojPxaUnQtKmaich9aCU88vIZViaIOicOzk5kVc83R9nD31GjrDmljicBFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efIsXO3LFyELakkNyuUfh8C9zFVu0ZETXECKXjwE2jXXHzS8zZodR0IA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;14、X6：AntV 旗下的图编辑引擎。提供了开箱即用的交互组件和简单易用的节点定制能力，从而能够快速完成流程图、DAG 图、ER 图等图应用。示例代码：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;import&lt;/span&gt; { Graph } &lt;span&gt;from&lt;/span&gt; &lt;span&gt;&#x27;@antv/x6&#x27;&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;&lt;span&gt;const&lt;/span&gt; graph = &lt;span&gt;new&lt;/span&gt; Graph({&lt;br/&gt;  &lt;span&gt;container&lt;/span&gt;: &lt;span&gt;document&lt;/span&gt;.getElementById(&lt;span&gt;&#x27;container&#x27;&lt;/span&gt;),&lt;br/&gt;  &lt;span&gt;width&lt;/span&gt;: &lt;span&gt;800&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;height&lt;/span&gt;: &lt;span&gt;600&lt;/span&gt;,&lt;br/&gt;  &lt;span&gt;background&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;color&lt;/span&gt;: &lt;span&gt;&#x27;#fffbe6&#x27;&lt;/span&gt;, &lt;span&gt;// 设置画布背景颜色&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;  &lt;span&gt;grid&lt;/span&gt;: {&lt;br/&gt;    &lt;span&gt;size&lt;/span&gt;: &lt;span&gt;10&lt;/span&gt;,      &lt;span&gt;// 网格大小 10px&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;visible&lt;/span&gt;: &lt;span&gt;true&lt;/span&gt;, &lt;span&gt;// 渲染网格背景&lt;/span&gt;&lt;br/&gt;  },&lt;br/&gt;});&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efkdrNl20P01tL7f07OAeictWEH2hOkwjspibbhIWSeuMXvOtT6RGZLYHw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efgZPzHghqJOb0wmBODUfjKoqABAk3b34dz1Bf7zmkQ4zkGIkmDs12sw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;15、hearthstone-battlegrounds-tools：暴雪炉石传说游戏的记牌插件。不懂编程的小伙伴拿去用就好了，支持 Windows 和 macOS 系统。开发者的话，这是一整套完整的 Electronjs 开发流程，从多个渲染进程的管理、不同平台的差异化处理、版本的控制与发布等方面都做了细致的封装，学起来吧。功能上她还具有以下特性：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;🌴 当天战绩统计，历史战绩查询&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;🎉 统计你所使用过的英雄，自动计算每个英雄的平均排名、选择率&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;🙈 选择英雄时展示可选英雄的大数据选择率、平均排名等&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;🃏 对局信息记录，记录对局过的对手阵容&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;✈️ 一键拔线（可怕）&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;等等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5625&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efytEeV8eibahGvsSAN4cdv39FcI1BrMyQkWFnUbdddicFiay7zoiakzYKOQ/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efKUylDcDGRMun81Zh8lzYUcp6C8Vmib37H47gAQw1bJDGMj0VVyfnGvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;16、Multiavatar：生成人物头像的 JS 库。支持随机生成一个好看、独特、多文化的头像&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.5476477683956574&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efA9FSujpbDiafnSvDXt1fBzGicv5fMd8vhjzSTUGh7E4CZCIZbzRDdfXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;829&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efvKSLT0Vnso1MuQmRRx6coIx3ckWF0YiabNqYfib8VFmiaScDDRU6pRpXQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;PHP 项目&lt;br/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;17、mochat：一套开源的企业微信开发框架和管理系统。基于 PHP 开发的前后端分离、功能强大的企业微信管理平台&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages js_insertlocalimg&quot; data-ratio=&quot;0.28203125&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efwIyNFeZTDlAiahWQkjVuqkjKGyvx9y4zxRzlZ7KSfF7lunrUlBSAxZA/640?wx_fmt=jpeg&quot; data-type=&quot;jpeg&quot; data-w=&quot;1280&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efu8dNs7KHXB9PWFFyCBjRicH13tC6cAmwu4XWtfpfoDibnaJPVAfGGvpw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;18、easy-sms：短信发送 PHP 组件。特点：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;支持目前市面多家服务商&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;一套写法兼容所有平台&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;简单配置即可灵活增减服务商&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;内置多种服务商轮询策略、支持自定义轮询策略&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;等等&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;use&lt;/span&gt; &lt;span&gt;Overtrue&lt;/span&gt;\&lt;span&gt;EasySms&lt;/span&gt;\&lt;span&gt;EasySms&lt;/span&gt;;&lt;br/&gt;&lt;br/&gt;$config = [&lt;br/&gt;    &lt;span&gt;// HTTP 请求的超时时间（秒）&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&#x27;timeout&#x27;&lt;/span&gt; =&amp;gt; &lt;span&gt;5.0&lt;/span&gt;,&lt;br/&gt;&lt;br/&gt;    &lt;span&gt;// 默认发送配置&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&#x27;default&#x27;&lt;/span&gt; =&amp;gt; [&lt;br/&gt;        &lt;span&gt;// 网关调用策略，默认：顺序调用&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&#x27;strategy&#x27;&lt;/span&gt; =&amp;gt; \Overtrue\EasySms\Strategies\OrderStrategy::class,&lt;br/&gt;&lt;br/&gt;        &lt;span&gt;// 默认可用的发送网关&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;&#x27;gateways&#x27;&lt;/span&gt; =&amp;gt; [&lt;br/&gt;            &lt;span&gt;&#x27;yunpian&#x27;&lt;/span&gt;, &lt;span&gt;&#x27;aliyun&#x27;&lt;/span&gt;,&lt;br/&gt;        ],&lt;br/&gt;    ],&lt;br/&gt;    &lt;span&gt;// 可用的网关配置&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;&#x27;gateways&#x27;&lt;/span&gt; =&amp;gt; [&lt;br/&gt;        &lt;span&gt;&#x27;errorlog&#x27;&lt;/span&gt; =&amp;gt; [&lt;br/&gt;            &lt;span&gt;&#x27;file&#x27;&lt;/span&gt; =&amp;gt; &lt;span&gt;&#x27;/tmp/easy-sms.log&#x27;&lt;/span&gt;,&lt;br/&gt;        ],&lt;br/&gt;        &lt;span&gt;&#x27;yunpian&#x27;&lt;/span&gt; =&amp;gt; [&lt;br/&gt;            &lt;span&gt;&#x27;api_key&#x27;&lt;/span&gt; =&amp;gt; &lt;span&gt;&#x27;824f0ff2f71cab52936axxxxxxxxxx&#x27;&lt;/span&gt;,&lt;br/&gt;        ],&lt;br/&gt;        &lt;span&gt;&#x27;aliyun&#x27;&lt;/span&gt; =&amp;gt; [&lt;br/&gt;            &lt;span&gt;&#x27;access_key_id&#x27;&lt;/span&gt; =&amp;gt; &lt;span&gt;&#x27;&#x27;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&#x27;access_key_secret&#x27;&lt;/span&gt; =&amp;gt; &lt;span&gt;&#x27;&#x27;&lt;/span&gt;,&lt;br/&gt;            &lt;span&gt;&#x27;sign_name&#x27;&lt;/span&gt; =&amp;gt; &lt;span&gt;&#x27;&#x27;&lt;/span&gt;,&lt;br/&gt;        ],&lt;br/&gt;        &lt;span&gt;//...&lt;/span&gt;&lt;br/&gt;    ],&lt;br/&gt;];&lt;br/&gt;&lt;br/&gt;$easySms = &lt;span&gt;new&lt;/span&gt; EasySms($config);&lt;br/&gt;&lt;br/&gt;$easySms-&amp;gt;send(&lt;span&gt;13188888888&lt;/span&gt;, [&lt;br/&gt;    &lt;span&gt;&#x27;content&#x27;&lt;/span&gt;  =&amp;gt; &lt;span&gt;&#x27;您的验证码为: 6379&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&#x27;template&#x27;&lt;/span&gt; =&amp;gt; &lt;span&gt;&#x27;SMS_001&#x27;&lt;/span&gt;,&lt;br/&gt;    &lt;span&gt;&#x27;data&#x27;&lt;/span&gt; =&amp;gt; [&lt;br/&gt;        &lt;span&gt;&#x27;code&#x27;&lt;/span&gt; =&amp;gt; &lt;span&gt;6379&lt;/span&gt;&lt;br/&gt;    ],&lt;br/&gt;]);&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efR4RMumDuRkzeS7FMJWiccaub9QgzUjmnlogVpqlG7VFXxVJN2tVhK6g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/h3&gt;&lt;p&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;Python 项目&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;19、Zappa：Python 无服务框架，功能即服务（serverless）。你知道 serverless 是什么吗？不懂的老铁扣 1 🤝 我摊牌了我不懂这个玩意儿。直到我看到了 Zappa 这个项目，然后我的脑海里就几个字：甩手掌柜。用它开发完功能，几个命令打包上传到云服务平台，然后就不用管啦！不仅程序员喜欢它，老板也喜欢因为能够降低服务器成本（省钱）。来感受下“知识”的力量吧&lt;/p&gt;&lt;p&gt;&lt;img class=&quot;rich_pages&quot; data-ratio=&quot;0.5444444444444444&quot; data-s=&quot;300,640&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6ef96RE20QTGAMN7j3vRQ2nbMwzJLibG1wGyTQPCXpfFAPw3yFzafY3qow/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;720&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efqaWe3DWX92z4BMbxqwIEfyqUwDLWrTHqzibSibgwY0M6Uemer9GMJZ5A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;20、streamlit：能够快速地把数据制作成可视化、交互页面的 Python 框架。分分钟让你的数据变成图表，并且该项目提供免费的共享服务平台帮你的项目上线，方便数据的共享和讨论&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5625&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efyL1NVmzzXicNH1ShKRezO79xqrNh2ZMdiaibSRFl24NEK5I9RRtbXX4Qw/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1920&quot;/&gt;&lt;/figure&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6ef9sJ8TicnW2iaGKiaNSxtq3Q2MHjhicBFDUDiaZWicvQZYnKTyPWvNBEGQl7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;21、lastversion：帮你找到库或者软件最新版本的 Python 工具。它可以避开不同项目作者使用的不同风格的版本号，获取一个项目的最新版本号，下载或安装它们。本项目可用于 build system，比如自动更新脚本。支持从这些网站搜索：GitHub、GitLab、PyPI 等，确保版本最新和稳定&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;&lt;span&gt;# 获取最新的 Linux 版本号和最新的 Wordpress 版本号&lt;/span&gt;&lt;br/&gt;lastversion linux&lt;br/&gt;&lt;span&gt;# 作者的版本标签：v5.10&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 本项目提供的版本标签：5.10&lt;/span&gt;&lt;br/&gt;lastversion wordpress&lt;br/&gt;&lt;span&gt;# 作者的版本标签：5.6&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 本项目提供的版本标签：5.6&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.23582766439909297&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_gif/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efiaEI6KianG7SEH1tG0PwNK8EWMwiaxp3vT29UUwzEul6vUg76uSgbfGbQ/640?wx_fmt=gif&quot; data-type=&quot;gif&quot; data-w=&quot;1323&quot;/&gt;&lt;/figure&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6eftXdgC3KwmnRzXPDrm8ugGj3g6RYzh5k17CkLzKxxZVMqknicfShTsNg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;22、xonsh：支持 Python 赋能的 shell。如果你不会编写 shell 脚本，但是会 Python。那通过这个项目可以让你混用 shell 命令和 Python 语法，高效快速地完成你想要的功能&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.6283687943262412&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6ef1qpIyXHeLb1rg6L14JfLHvCzKIK7mJ2WmxsxibHoV5Oxohp08uxntvQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1410&quot;/&gt;&lt;/figure&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efr04t5ZtVJk8icIy36B2MpC3JzUJzibIicBKAIdGib75OT5eKjraHcAGQDQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;Ruby 项目&lt;br/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;23、spree：基于 Ruby on Rails 实现的大而全的电子商城开源项目。功能齐全项目结构清晰：&lt;/p&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot; class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;&lt;section&gt;spree_api：REST API 接口&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;spree_frontend：移动优先，可自定义的店面&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;spree_backend：功能丰富的管理面板&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;spree_cmd：开发人员的命令行工具&lt;/section&gt;&lt;/li&gt;&lt;li&gt;&lt;section&gt;spree_core：数据层、服务和邮件、基本组件&lt;/section&gt;&lt;/li&gt;&lt;/ul&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5714285714285714&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efD7KHl5fjtnqe9uNYVfjaib7nUhUM7n1IbyeAWqcwcVLaQrIHmld8yMA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1400&quot;/&gt;&lt;/figure&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efp7oyy4hLMiamlwS2sqzy9N8JxIoKIONlmD0oWuj7wLKtC9y57AQ3eEQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/section&gt;&lt;section data-tool=&quot;mdnice编辑器&quot; data-website=&quot;https://www.mdnice.com&quot;&gt;&lt;span/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;Swift 项目&lt;br/&gt;&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;24、mas：Mac App Store 命令行版&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.30666666666666664&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efOgAXxjHOM6Yw4CWlXia2WkuRTBo50vjDKRjibzpibGw4CuHfZwbEF0Nfg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;900&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6eff0HSFMZ1l30gU8ia2D4iaeiad2oGs7CGb5YlkAn9gibfuSy0xoR0Uk4wXg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;25、Moya：基于 Alamofire 的轻量级 Swift 网络层框架。它提供了网络抽象层，使用起来足够简单，能够方便地与 RXSwift、PromiseKit、ObjectMapper 结合，轻松地应对常见的开发任务。同时也非常全面，应对复杂任务也同样容易。最后 Moya 有一个很棒的社区，贡献者们提供了很多实用的扩展&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;provider = &lt;span&gt;MoyaProvider&lt;/span&gt;&amp;lt;&lt;span&gt;GitHub&lt;/span&gt;&amp;gt;()&lt;br/&gt;provider.request(.zen) { result &lt;span&gt;in&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;switch&lt;/span&gt; result {&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;let&lt;/span&gt; .success(moyaResponse):&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; data = moyaResponse.data&lt;br/&gt;        &lt;span&gt;let&lt;/span&gt; statusCode = moyaResponse.statusCode&lt;br/&gt;        &lt;span&gt;// do something with the response data or statusCode&lt;/span&gt;&lt;br/&gt;    &lt;span&gt;case&lt;/span&gt; &lt;span&gt;let&lt;/span&gt; .failure(error):&lt;br/&gt;        &lt;span&gt;// this means there was a network failure - either the request&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// wasn&#x27;t sent (connectivity), or no response was received (server&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// timed out).  If the server responds with a 4xx or 5xx error, that&lt;/span&gt;&lt;br/&gt;        &lt;span&gt;// will be sent as a &quot;.success&quot;-ful response.&lt;/span&gt;&lt;br/&gt;    }&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7635869565217391&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efzMkbrmckgKpfyecsYIcHL3H5e2ddJmUoKrSQ2BmOshsDdu0ygpaVFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1472&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efArSyvMtOhjuKInlHSFicHA6ia8o53ict3J268icnXxSCibLSXbRElA8zmkg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;26、MTMR：自定义 TouchBar 的应用。你问我体验如何？我没钱买带 TouchBar 的电脑啊，你装上我看看就行了&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3869582194455291&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efYwrNnEUfBiavUNfmv9syshJvQFIYEU5XFbhia1abStblYuHwUFzQvSWw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2561&quot;/&gt;&lt;/figure&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6eftibU3m3nkBaWeKicNSfTNKp8IiavVdicSibdSBzCS7CNjpIPZE6JFrLrh9Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/h3&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;其它&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;27、game-programmer：游戏程序员的学习路径图。一位游戏开发大神开源的项目，希望能够帮助向往游戏开发的你 or 你的孩子，走上游戏开发这条“不归路”&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.4895977808599168&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efyp015Gcny1xoYY4JJ03xUYs45ePaQNeRGjxZs2Ck5sibLed8icRoopkA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1442&quot;/&gt;&lt;/figure&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efPUw6niaziaWCbY9puYtK8W0rgX5PCUwayEKw2WCiaEhTib5R2KSE22sTpg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;28、theia：Eclipse 开源的 IDE 工具。我岁数大了，用惯了一个 IDE 就不想换了，喜欢尝鲜的小伙伴可以去把玩一下。看介绍像是一个拥抱开源，与 VS Code 功能相近的开发工具&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.7073825503355705&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efo849icvGhiaicFXYib1wibgsbu5O2lOajrrx3GOiascOGQh2kJcAL4X7yOGw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;2980&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efJzIyHhr3wgkOCN3CLeXXtmT3LXiabI2saaYgaLqjE3BkFmub3KzsTEA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;29、luarocks：Lua 包管理工具。支持三大平台，安装和使用如下：&lt;/p&gt;&lt;pre data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;$ wget https://luarocks.org/releases/luarocks-3.5.0.tar.gz&lt;br/&gt;$ tar zxpf luarocks-3.5.0.tar.gz&lt;br/&gt;$ &lt;span&gt;cd&lt;/span&gt; luarocks-3.5.0&lt;br/&gt;$ ./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; sudo make install&lt;br/&gt;$ sudo luarocks install luasocket&lt;br/&gt;$ lua&lt;br/&gt;Lua 5.3.5 Copyright (C) 1994-2018 Lua.org, PUC-Rio&lt;br/&gt;&amp;gt; require &lt;span&gt;&quot;socket&quot;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efN7BpUT4aB2Spl1EJJ87zkTMybXnxe5vUuRusCxN2icKNsNIlOLwwUFQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;30、Ad-papers：计算广告相关论文、学习资料和业界分享集合&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efKga6LVoNDjDHaKujHJzV4uJEm2sFwfXOY9ZPrzzFyFrRuS58YwC28w/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;31、awesome-seo：有关 Google SEO 和流量变现资料的项目。该项目是作者学习 SEO 过程中整理的权威资料，推荐给有个人网站的小伙伴们&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5666666666666667&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6eflobgYPnhGeHBpcg9YdniaiarQibc0ylLzYCQUVzyOHYzhap9LQgNOyX2g/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;690&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efKB7PMy6n4A518LwJTNufRX4WTSSsAAaO5kbIRrpiad3t3R5bzPZfPCw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;32、makeaplan_public：使用 Flutter 和 Go 开发的「制定计划 APP」。帮助用户记录和追踪自己的计划，辅助用户完成自己的目标。手机端用的是 Flutter 后端用 Go 实现，服务器和客户端通过 ProtoBuffer+grpc 进行通信。可作为学习 Flutter 和 Go 的实战项目&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.3471563981042654&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efozwrhI5r41utPDibrMYibaOdKVtQQfKOfHOnLkVvJs5tHpwn2E6VAU9A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1688&quot;/&gt;&lt;/figure&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efCH81eGpEiael4u9qUF4O1h1yyElAsgQ4NvgRhCEicuicagHzI1X3lHx7Q/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;33、free-font：免费可商用的字体集合。这个项目收录的都是免费可商用的字体，并且仔细地标记出了商用时是否需要获取授权等细节&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efxZXxD0WmvkupbgBsApNpYG0a3hswWU8z5TnYlY3tiby1ibos5TBEIo8A/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;开源书籍&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;34、DeepLearning-500-questions：《深度学习 500 问》AI 工程师面试知识点的书籍。内容涵盖深度学习的知识点及各大公司常见的笔试题&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6eficADm7ZwpTHQKMlzUmeDNwTAX3XCic6zNicHpSsooKuc1puSUrwS18mXA/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;机器学习&lt;/h3&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;35、nanodet：移动端的轻量级 Anchor-Free 目标检测模型。具有体积小（1.8 MB）、速度快（10.23 ms）、便于训练（硬件要求低）、部署简单（安卓示例）等优点&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.18623962040332148&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efaicPTOctGvzCCPMyGaSMqngYdE1gGrhSWm109MEMhbSBIKB5MnPORLQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;1686&quot;/&gt;&lt;/figure&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efcciaoffZnOIYibPvz4Y1aia9LRwwIsZgP8w11LepD5cFSVEyPJnQhtbaw/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;长按识别二维码，可直达项目&lt;/span&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;36、DeepMoji：通过深度学习把自然语言转化成 emoji 表情的项目。用机器学习来了解文字表达的情感，最后返回几个感情相近的 emoji 表情。该项目有趣且易于学习，包含机器学习项目该有的所有内容：示例、模型、数据、测试、源码等&lt;/p&gt;&lt;figure data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img data-ratio=&quot;0.49635036496350365&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6efSfmPEOmLXougFuFkAZnSekVPqicN40oYFpHYL93FMbr7lt2f6328JfQ/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;685&quot;/&gt;&lt;/figure&gt;&lt;img data-ratio=&quot;0.5619047619047619&quot; data-src=&quot;https://mmbiz.qpic.cn/mmbiz_png/xBgIbW1vdNOofwib9ytc5NXib5BLibNh6ef2iaEaa0wibckPTSzTVzqJJ955wXIZAicDxmJu02xIY9CSicV3w0s2Cm7Dg/640?wx_fmt=png&quot; data-type=&quot;png&quot; data-w=&quot;945&quot;/&gt;&lt;/section&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
<item>
<guid>34a98d5f16652ebc93fd02121924051f</guid>
<title>一篇长文帮你彻底搞懂 React 的调度机制原理</title>
<link>https://toutiao.io/k/xeziv6t</link>
<content:encoded>&lt;div&gt;&lt;div&gt;&lt;div class=&quot;RichText ztext Post-RichText&quot;&gt;&lt;p&gt;&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/neroneroffy/react-source-code-debug&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;点击&lt;/a&gt;&lt;/b&gt;进入React源码调试仓库。&lt;/p&gt;&lt;p&gt;Scheduler作为一个独立的包，可以独自承担起任务调度的职责，你只需要将任务和任务的优先级交给它，它就可以帮你管理任务，安排任务的执行。这就是React和Scheduler配合工作的模式。&lt;/p&gt;&lt;p&gt;对于多个任务，它会先执行优先级高的。聚焦到单个任务的执行上，会被Scheduler有节制地去执行。换句话说，线程只有一个，它不会一直占用着线程去执行任务。而是执行一会，中断一下，如此往复。用这样的模式，来避免一直占用有限的资源执行耗时较长的任务，解决用户操作时页面卡顿的问题，实现更快的响应。&lt;/p&gt;&lt;p&gt;我们可以从中梳理出Scheduler中两个重要的行为：&lt;b&gt;多个任务的管理&lt;/b&gt;、&lt;b&gt;单个任务的执行控制&lt;/b&gt;。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;基本概念&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;为了实现上述的两个行为，它引入两个概念：&lt;b&gt;任务优先级&lt;/b&gt; 、 &lt;b&gt;时间片&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;任务优先级让任务按照自身的紧急程度排序，这样可以让优先级最高的任务最先被执行到。&lt;/p&gt;&lt;p&gt;时间片规定的是单个任务在这一帧内最大的执行时间，任务一旦执行时间超过时间片，则会被打断，有节制地执行任务。这样可以保证页面不会因为任务连续执行的时间过长而产生卡顿。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;原理概述&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;基于任务优先级和时间片的概念，Scheduler围绕着它的核心目标 - 任务调度，衍生出了两大核心功能：任务队列管理 和 时间片下任务的中断和恢复。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;任务队列管理&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;任务队列管理对应了Scheduler的多任务管理这一行为。在Scheduler内部，把任务分成了两种：未过期的和已过期的，分别用两个队列存储，前者存到timerQueue中，后者存到taskQueue中。&lt;/p&gt;&lt;p&gt;&lt;b&gt;如何区分任务是否过期？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;用任务的开始时间（startTime）和当前时间（currentTime）作比较。开始时间大于当前时间，说明未过期，放到timerQueue；开始时间小于等于当前时间，说明已过期，放到taskQueue。&lt;/p&gt;&lt;p&gt;&lt;b&gt;不同队列中的任务如何排序？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;当任务一个个入队的时候，自然要对它们进行排序，保证紧急的任务排在前面，所以排序的依据就是任务的紧急程度。而taskQueue和timerQueue中任务紧急程度的判定标准是有区别的。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;taskQueue中，依据任务的过期时间（expirationTime）排序，过期时间越早，说明越紧急，过期时间小的排在前面。过期时间根据任务优先级计算得出，优先级越高，过期时间越早。&lt;/li&gt;&lt;li&gt;timerQueue中，依据任务的开始时间（startTime）排序，开始时间越早，说明会越早开始，开始时间小的排在前面。任务进来的时候，开始时间默认是当前时间，如果进入调度的时候传了延迟时间，开始时间则是当前时间与延迟时间的和。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;b&gt;任务入队两个队列，之后呢？&lt;/b&gt;&lt;/p&gt;&lt;p&gt;如果放到了taskQueue，那么立即调度一个函数去循环taskQueue，挨个执行里面的任务。&lt;/p&gt;&lt;p&gt;如果放到了timerQueue，那么说明它里面的任务都不会立即执行，那就等到了timerQueue里面排在第一个任务的开始时间，看这个任务是否过期，如果是，则把任务从timerQueue中拿出来放入taskQueue，调度一个函数去循环它，执行掉里面的任务；否则过一会继续检查这第一个任务是否过期。&lt;/p&gt;&lt;p&gt;任务队列管理相对于单个任务的执行，是宏观层面的概念，它利用任务的优先级去管理任务队列中的任务顺序，始终让最紧急的任务被优先处理。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;单个任务的中断以及恢复&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;单个任务的中断以及恢复对应了Scheduler的单个任务执行控制这一行为。在循环taskQueue执行每一个任务时，如果某个任务执行时间过长，达到了时间片限制的时间，那么该任务必须中断，以便于让位给更重要的事情（如浏览器绘制），等事情完成，再恢复执行任务。&lt;/p&gt;&lt;p&gt;例如这个&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/neroneroffy/react-source-code-debug/blob/master/src/components/SchedulerTask/index.js&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;例子&lt;/a&gt;，点击按钮渲染140000个DOM节点，为的是让React通过scheduler调度一个耗时较长的更新任务。同时拖动方块，这是为了模拟用户交互。更新任务会占用线程去执行任务，用户交互要也要占用线程去响应页面，这就决定了它们两个是互斥的关系。在React的concurrent模式下，通过Scheduler调度的更新任务遇到用户交互之后，会是下面动图里的效果。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-db5accfed035f901031252dee0b33872_b.gif&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;925&quot; data-rawheight=&quot;609&quot; data-thumbnail=&quot;https://pic3.zhimg.com/v2-db5accfed035f901031252dee0b33872_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic3.zhimg.com/v2-db5accfed035f901031252dee0b33872_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;925&quot; data-rawheight=&quot;609&quot; data-thumbnail=&quot;https://pic3.zhimg.com/v2-db5accfed035f901031252dee0b33872_b.jpg&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic3.zhimg.com/v2-db5accfed035f901031252dee0b33872_r.jpg&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-db5accfed035f901031252dee0b33872_b.gif&quot;/&gt;&lt;/figure&gt;&lt;p&gt;执行React任务和页面响应交互这两件事情是互斥的，但因为Scheduler可以利用时间片中断React任务，然后让出线程给浏览器去绘制，所以一开始在fiber树的构建阶段，拖动方块会得到及时的反馈。但是后面卡了一下，这是因为fiber树构建完成，进入了同步的commit阶段，导致交互卡顿。分析页面的渲染过程可以非常直观地看到通过时间片的控制。主线程被让出去进行页面的绘制（Painting和Rendering，绿色和紫色的部分）。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-76f89f5292d98e47611ab8a09005f934_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1866&quot; data-rawheight=&quot;682&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic1.zhimg.com/v2-76f89f5292d98e47611ab8a09005f934_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;1866&quot; data-rawheight=&quot;682&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic1.zhimg.com/v2-76f89f5292d98e47611ab8a09005f934_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-76f89f5292d98e47611ab8a09005f934_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;Scheduler要实现这样的调度效果需要两个角色：&lt;b&gt;任务的调度者、任务的执行者&lt;/b&gt;。调度者调度一个执行者，执行者去循环taskQueue，逐个执行任务。当某个任务的执行时间比较长，执行者会根据时间片中断任务执行，然后告诉调度者：我现在正执行的这个任务被中断了，还有一部分没完成，但现在必须让位给更重要的事情，你再调度一个执行者吧，好让这个任务能在之后被继续执行完（任务的恢复）。于是，调度者知道了任务还没完成，需要继续做，它会再调度一个执行者去继续完成这个任务。&lt;/p&gt;&lt;p&gt;通过执行者和调度者的配合，可以实现任务的中断和恢复。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;原理小结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Scheduler管理着taskQueue和timerQueue两个队列，它会定期将timerQueue中的过期任务放到taskQueue中，然后让调度者通知执行者循环taskQueue执行掉每一个任务。执行者控制着每个任务的执行，一旦某个任务的执行时间超出时间片的限制。就会被中断，然后当前的执行者退场，退场之前会通知调度者再去调度一个新的执行者继续完成这个任务，新的执行者在执行任务时依旧会根据时间片中断任务，然后退场，重复这一过程，直到当前这个任务彻底完成后，将任务从taskQueue出队。taskQueue中每一个任务都被这样处理，最终完成所有任务，这就是Scheduler的完整工作流程。&lt;/p&gt;&lt;p&gt;这里面有一个关键点，就是执行者如何知道这个任务到底完成没完成呢？这是另一个话题了，也就是判断任务的完成状态。在讲解执行者执行任务的细节时会重点突出。&lt;/p&gt;&lt;p&gt;以上是Scheduler原理的概述，下面开始是对React和Scheduler联合工作机制的详细解读。涉及React与Scheduler的连接、调度入口、任务优先级、任务过期时间、任务中断和恢复、判断任务的完成状态等内容。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;详细流程&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在开始之前，我们先看一下React和Scheduler它们二者构成的一个系统的示意图。&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-3d9864adb3e59077b681a2685a740e61_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2526&quot; data-rawheight=&quot;4007&quot; class=&quot;origin_image zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-3d9864adb3e59077b681a2685a740e61_r.jpg&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;2526&quot; data-rawheight=&quot;4007&quot; class=&quot;origin_image zh-lightbox-thumb lazy&quot; data-original=&quot;https://pic2.zhimg.com/v2-3d9864adb3e59077b681a2685a740e61_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-3d9864adb3e59077b681a2685a740e61_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p&gt;整个系统分为三部分：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;产生任务的地方：React&lt;/li&gt;&lt;li&gt;React和Scheduler交流的翻译者：SchedulerWithReactIntegration&lt;/li&gt;&lt;li&gt;任务的调度者：Scheduler&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;React中通过下面的代码，让fiber树的构建任务进入调度流程：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;nx&quot;&gt;scheduleCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;schedulerPriorityLevel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;performConcurrentWorkOnRoot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;任务通过翻译者交给Scheduler，Scheduler进行真正的任务调度，那么为什么需要一个翻译者的角色呢？&lt;/p&gt;&lt;h2&gt;&lt;b&gt;React与Scheduler的连接&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Scheduler帮助React调度各种任务，但是本质上它们是两个完全不耦合的东西，二者各自都有自己的优先级机制，那么这时就需要有一个中间角色将它们连接起来。&lt;/p&gt;&lt;p&gt;实际上，在react-reconciler中提供了这样一个文件专门去做这样的工作，它就是&lt;code&gt;SchedulerWithReactIntegration.old(new).js&lt;/code&gt;。它将二者的优先级翻译了一下，让React和Scheduler能读懂对方。另外，封装了一些Scheduler中的函数供React使用。&lt;/p&gt;&lt;p&gt;在执行React任务的重要文件&lt;code&gt;ReactFiberWorkLoop.js&lt;/code&gt;中，关于Scheduler的内容都是从&lt;code&gt;SchedulerWithReactIntegration.old(new).js&lt;/code&gt;导入的。它可以理解成是React和Scheduler之间的桥梁。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// ReactFiberWorkLoop.js
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;scheduleCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;cancelCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;getCurrentPriorityLevel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;runWithPriority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;shouldYield&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;requestPaint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;NoPriority&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;NoSchedulerPriority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;ImmediatePriority&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ImmediateSchedulerPriority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;UserBlockingPriority&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;UserBlockingSchedulerPriority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;NormalPriority&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;NormalSchedulerPriority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;flushSyncCallbackQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;scheduleSyncCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;./SchedulerWithReactIntegration.old&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;SchedulerWithReactIntegration.old(new).js&lt;/code&gt;通过封装Scheduler的内容，对React提供两种调度入口函数：&lt;code&gt;scheduleCallback&lt;/code&gt; 和 &lt;code&gt;scheduleSyncCallback&lt;/code&gt;。任务通过调度入口函数进入调度流程。&lt;/p&gt;&lt;p&gt;例如，fiber树的构建任务在concurrent模式下通过&lt;code&gt;scheduleCallback&lt;/code&gt;完成调度，在同步渲染模式下由&lt;code&gt;scheduleSyncCallback&lt;/code&gt;完成。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// concurrentMode
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// 将本次更新任务的优先级转化为调度优先级
&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// schedulerPriorityLevel为调度优先级
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;schedulerPriorityLevel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;lanePriorityToSchedulerPriority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;newCallbackPriority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// concurrent模式
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;nx&quot;&gt;scheduleCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;schedulerPriorityLevel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;performConcurrentWorkOnRoot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 同步渲染模式
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;nx&quot;&gt;scheduleSyncCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;performSyncWorkOnRoot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它们两个其实都是对Scheduler中scheduleCallback的封装，只不过传入的优先级不同而已，前者是传递的是已经本次更新的lane计算得出的调度优先级，后者传递的是最高级别的优先级。另外的区别是，前者直接将任务交给Scheduler，而后者先将任务放到SchedulerWithReactIntegration.old(new).js自己的同步队列中，再将执行同步队列的函数交给Scheduler，以最高优先级进行调度，由于传入了最高优先级，意味着它将会是立即过期的任务，会立即执行掉它，这样能够保证在下一次事件循环中执行掉任务。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;scheduleCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;reactPriorityLevel&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ReactPriorityLevel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;SchedulerCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;SchedulerCallbackOptions&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 将react的优先级翻译成Scheduler的优先级
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;priorityLevel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;reactPriorityToSchedulerPriority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;reactPriorityLevel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 调用Scheduler的scheduleCallback，传入优先级进行调度
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Scheduler_scheduleCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;priorityLevel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;scheduleSyncCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;SchedulerCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;syncQueue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;syncQueue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 以最高优先级去调度刷新syncQueue的函数
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;nx&quot;&gt;immediateQueueCallbackNode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;Scheduler_scheduleCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;Scheduler_ImmediatePriority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;flushSyncCallbackQueueImpl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;syncQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;fakeCallbackNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;Scheduler中的优先级&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;说到优先级，我们来看一下Scheduler自己的优先级级别，它为任务定义了以下几种级别的优先级：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kr&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;NoPriority&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 没有任何优先级
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;kr&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ImmediatePriority&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 立即执行的优先级，级别最高
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;kr&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;UserBlockingPriority&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 用户阻塞级别的优先级
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;kr&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;NormalPriority&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 正常的优先级
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;kr&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;LowPriority&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 较低的优先级
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;kr&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IdlePriority&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 优先级最低，表示任务可以闲置
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;任务优先级的作用已经提到过，它是计算任务过期时间的重要依据，事关过期任务在taskQueue中的排序。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 不同优先级对应的不同的任务过期时间间隔
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IMMEDIATE_PRIORITY_TIMEOUT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;USER_BLOCKING_PRIORITY_TIMEOUT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;250&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;NORMAL_PRIORITY_TIMEOUT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;LOW_PRIORITY_TIMEOUT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Never times out
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IDLE_PRIORITY_TIMEOUT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;maxSigned31BitInt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 计算过期时间（scheduleCallback函数中的内容）
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;priorityLevel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ImmediatePriority&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;timeout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IMMEDIATE_PRIORITY_TIMEOUT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;UserBlockingPriority&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;timeout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;USER_BLOCKING_PRIORITY_TIMEOUT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IdlePriority&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;timeout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IDLE_PRIORITY_TIMEOUT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;LowPriority&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;timeout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;LOW_PRIORITY_TIMEOUT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;NormalPriority&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;timeout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;NORMAL_PRIORITY_TIMEOUT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// startTime可暂且认为是当前时间
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;expirationTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可见，过期时间是任务开始时间加上timeout，而这个timeout则是通过任务优先级计算得出。&lt;/p&gt;&lt;blockquote&gt; React中更全面的优先级讲解在我写的这一篇文章中：&lt;b&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/343754137&quot; class=&quot;internal&quot;&gt;React中的优先级&lt;/a&gt;&lt;/b&gt;&lt;br/&gt; &lt;/blockquote&gt;&lt;h2&gt;&lt;b&gt;调度入口 - scheduleCallback&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;通过上面的梳理，我们知道Scheduler中的scheduleCallback是调度流程开始的关键点。在进入这个调度入口之前，我们先来认识一下Scheduler中的任务是什么形式：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;newTask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;taskIdCounter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 任务函数
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 任务优先级
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;nx&quot;&gt;priorityLevel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 任务开始的时间
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;nx&quot;&gt;startTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 任务的过期时间
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;nx&quot;&gt;expirationTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 在小顶堆队列中排序的依据
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;nx&quot;&gt;sortIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&lt;li&gt;callback：真正的任务函数，重点，也就是外部传入的任务函数，例如构建fiber树的任务函数：performConcurrentWorkOnRoot&lt;/li&gt;&lt;li&gt;priorityLevel：任务优先级，参与计算任务过期时间&lt;/li&gt;&lt;li&gt;startTime：表示任务开始的时间，影响它在timerQueue中的排序&lt;/li&gt;&lt;li&gt;expirationTime：表示任务何时过期，影响它在taskQueue中的排序&lt;/li&gt;&lt;li&gt;sortIndex：在小顶堆队列中排序的依据，在区分好任务是过期或非过期之后，sortIndex会被赋值为expirationTime或startTime，为两个小顶堆的队列（taskQueue,timerQueue）提供排序依据&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;真正的重点是&lt;b&gt;callback&lt;/b&gt;，作为任务函数，它的执行结果会影响到任务完成状态的判断，后面我们会讲到，暂时先无需关注。现在我们先来看看&lt;code&gt;scheduleCallback&lt;/code&gt;做的事情：&lt;b&gt;它负责生成调度任务、根据任务是否过期将任务放入timerQueue或taskQueue，然后触发调度行为，让任务进入调度&lt;/b&gt;。完整代码如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;unstable_scheduleCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;priorityLevel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 获取当前时间，它是计算任务开始时间、过期时间和判断任务是否过期的依据
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getCurrentTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 确定任务开始时间
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;startTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 从options中尝试获取delay，也就是推迟时间
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;options&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;object&#x27;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;options&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;delay&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;delay&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;number&#x27;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;delay&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 如果有delay，那么任务开始时间就是当前时间加上delay
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;nx&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;delay&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 没有delay，任务开始时间就是当前时间，也就是任务需要立刻开始
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;nx&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 计算timeout
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;priorityLevel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ImmediatePriority&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;timeout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IMMEDIATE_PRIORITY_TIMEOUT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// -1
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;UserBlockingPriority&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;timeout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;USER_BLOCKING_PRIORITY_TIMEOUT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 250
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IdlePriority&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;timeout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;IDLE_PRIORITY_TIMEOUT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 1073741823 ms
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;LowPriority&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;timeout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;LOW_PRIORITY_TIMEOUT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 10000
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;NormalPriority&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;timeout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;NORMAL_PRIORITY_TIMEOUT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 5000
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 计算任务的过期时间，任务开始时间 + timeout
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;c1&quot;&gt;// 若是立即执行的优先级（ImmediatePriority），
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;c1&quot;&gt;// 它的过期时间是startTime - 1，意味着立刻就过期
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;expirationTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 创建调度任务
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;newTask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;taskIdCounter&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 真正的任务函数，重点
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 任务优先级
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;nx&quot;&gt;priorityLevel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 任务开始的时间，表示任务何时才能执行
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;nx&quot;&gt;startTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 任务的过期时间
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;nx&quot;&gt;expirationTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 在小顶堆队列中排序的依据
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;nx&quot;&gt;sortIndex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 下面的if...else判断各自分支的含义是：
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;
  &lt;span class=&quot;c1&quot;&gt;// 如果任务未过期，则将 newTask 放入timerQueue， 调用requestHostTimeout，
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;c1&quot;&gt;// 目的是在timerQueue中排在最前面的任务的开始时间的时间点检查任务是否过期，
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;c1&quot;&gt;// 过期则立刻将任务加入taskQueue，开始调度
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;
  &lt;span class=&quot;c1&quot;&gt;// 如果任务已过期，则将 newTask 放入taskQueue，调用requestHostCallback，
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;c1&quot;&gt;// 开始调度执行taskQueue中的任务
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 任务未过期，以开始时间作为timerQueue排序的依据
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;nx&quot;&gt;newTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sortIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;startTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;timerQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;newTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;newTask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;timerQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 如果现在taskQueue中没有任务，并且当前的任务是timerQueue中排名最靠前的那一个
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;c1&quot;&gt;// 那么需要检查timerQueue中有没有需要放到taskQueue中的任务，这一步通过调用
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;c1&quot;&gt;// requestHostTimeout实现
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isHostTimeoutScheduled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 因为即将调度一个requestHostTimeout，所以如果之前已经调度了，那么取消掉
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;        &lt;span class=&quot;nx&quot;&gt;cancelHostTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;isHostTimeoutScheduled&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 调用requestHostTimeout实现任务的转移，开启调度
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;nx&quot;&gt;requestHostTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;handleTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 任务已经过期，以过期时间作为taskQueue排序的依据
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;nx&quot;&gt;newTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sortIndex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;expirationTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;newTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 开始执行任务，使用flushWork去执行taskQueue
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isHostCallbackScheduled&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isPerformingWork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;isHostCallbackScheduled&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;requestHostCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;flushWork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;newTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个过程中的重点是任务过期与否的处理。&lt;/p&gt;&lt;p&gt;针对未过期任务，会放入timerQueue，并按照开始时间排列，然后调用&lt;code&gt;requestHostTimeout&lt;/code&gt;，为的是等一会，等到了timerQueue中那个应该最早开始的任务（排在第一个的任务）的开始时间，再去检查它是否过期，如果它过期则放到taskQueue中，这样任务就可以被执行了，否则继续等。这个过程通过&lt;code&gt;handleTimeout&lt;/code&gt;完成。&lt;/p&gt;&lt;p&gt;&lt;code&gt;handleTimeout&lt;/code&gt;的职责是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;调用&lt;code&gt;advanceTimers&lt;/code&gt;，检查timerQueue队列中过期的任务，放到taskQueue中。&lt;/li&gt;&lt;li&gt;检查是否已经开始调度，如尚未调度，检查taskQueue中是否已经有任务： &lt;/li&gt;&lt;ul&gt;&lt;li&gt;如果有，而且现在是空闲的，说明之前的advanceTimers已经将过期任务放到了taskQueue，那么现在立即开始调度，执行任务&lt;/li&gt;&lt;li&gt;如果没有，而且现在是空闲的，说明之前的advanceTimers并没有检查到timerQueue中有过期任务，那么再次调用&lt;code&gt;requestHostTimeout&lt;/code&gt;重复这一过程。&lt;/li&gt;&lt;/ul&gt;&lt;/ul&gt;&lt;p&gt;总之，要把timerQueue中的任务全部都转移到taskQueue中执行掉才行。&lt;/p&gt;&lt;p&gt;针对已过期任务，在将它放入taskQueue之后，调用&lt;code&gt;requestHostCallback&lt;/code&gt;，让调度者调度一个执行者去执行任务，也就意味着调度流程开始。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;开始调度-找出调度者和执行者&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Scheduler通过调用&lt;code&gt;requestHostCallback&lt;/code&gt;让任务进入调度流程，回顾上面scheduleCallback最终调用requestHostCallback执行任务的地方：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isHostCallbackScheduled&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isPerformingWork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;isHostCallbackScheduled&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 开始进行调度
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;nx&quot;&gt;requestHostCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;flushWork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它既然把&lt;code&gt;flushWork&lt;/code&gt;作为入参，那么任务的&lt;b&gt;执行者&lt;/b&gt;本质上调用的就是&lt;code&gt;flushWork&lt;/code&gt;，我们先不管执行者是如何执行任务的，先关注它是如何被调度的，需要先找出&lt;b&gt;调度者&lt;/b&gt;，这需要看一下&lt;code&gt;requestHostCallback&lt;/code&gt;的实现：&lt;/p&gt;&lt;p&gt;Scheduler区分了浏览器环境和非浏览器环境，为&lt;code&gt;requestHostCallback&lt;/code&gt;做了两套不同的实现。在非浏览器环境下，使用setTimeout实现.&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;  &lt;span class=&quot;nx&quot;&gt;requestHostCallback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_callback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;requestHostCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;_callback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;setTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;_flushCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在浏览器环境，用MessageChannel实现，关于MessageChannel的&lt;b&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN/docs/Web/API/MessageChannel&quot; class=&quot; wrap external&quot; target=&quot;_blank&quot; rel=&quot;nofollow noreferrer&quot;&gt;介绍&lt;/a&gt;&lt;/b&gt;就不再赘述。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;  &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;channel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;MessageChannel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;port&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;port2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;channel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;port1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;onmessage&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;performWorkUntilDeadline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;


  &lt;span class=&quot;nx&quot;&gt;requestHostCallback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;scheduledHostCallback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;isMessageLoopRunning&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;isMessageLoopRunning&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;postMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;之所以有两种实现，是因为非浏览器环境不存在屏幕刷新率，没有帧的概念，也就不会有时间片，这与在浏览器环境下执行任务有本质区别，因为非浏览器环境基本不胡有用户交互，所以该场景下不判断任务执行时间是否超出了时间片限制，而浏览器环境任务的执行会有时间片的限制。除了这一点之外，虽然两种环境下实现方式不一样，但是做的事情大致相同。&lt;/p&gt;&lt;p&gt;先看非浏览器环境，它将入参（执行任务的函数）存储到内部的变量&lt;code&gt;_callback&lt;/code&gt;上，然后调度&lt;code&gt;_flushCallback&lt;/code&gt;去执行这个此变量_callback，taskQueue被清空。&lt;/p&gt;&lt;p&gt;再看浏览器环境，它将入参（执行任务的函数）存到内部的变量&lt;code&gt;scheduledHostCallback&lt;/code&gt;上，然后通过MessageChannel的port去发送一个消息，让&lt;code&gt;channel.port1&lt;/code&gt;的监听函数&lt;code&gt;performWorkUntilDeadline&lt;/code&gt;得以执行。&lt;code&gt;performWorkUntilDeadline&lt;/code&gt;内部会执行掉&lt;code&gt;scheduledHostCallback&lt;/code&gt;，最后taskQueue被清空。&lt;/p&gt;&lt;p&gt;通过上面的描述，可以很清楚得找出调度者：非浏览器环境是&lt;b&gt;setTimeout&lt;/b&gt;，浏览器环境是&lt;b&gt;port.postMessage&lt;/b&gt;。而两个环境的执行者也显而易见，前者是&lt;code&gt;_flushCallback&lt;/code&gt;，后者是&lt;code&gt;performWorkUntilDeadline&lt;/code&gt;，执行者做的事情都是去调用实际的任务执行函数。&lt;/p&gt;&lt;p&gt;因为本文围绕Scheduler的时间片调度行为展开，所以主要探讨浏览器环境下的调度行为，performWorkUntilDeadline涉及到调用任务执行函数去执行任务，这个过程中会涉及&lt;b&gt;任务的中断和恢复&lt;/b&gt;、&lt;b&gt;任务完成状态的判断&lt;/b&gt;，接下来的内容将重点对这两点进行讲解。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;任务执行 - 从performWorkUntilDeadline说起&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;在文章开头的原理概述中提到过&lt;code&gt;performWorkUntilDeadline&lt;/code&gt;作为执行者，它的作用是按照时间片的限制去中断任务，并通知调度者再次调度一个新的执行者去继续任务。按照这种认知去看它的实现，会很清晰。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;  &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;performWorkUntilDeadline&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;scheduledHostCallback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 获取当前时间
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;getCurrentTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

      &lt;span class=&quot;c1&quot;&gt;// 计算deadline，deadline会参与到
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;c1&quot;&gt;// shouldYieldToHost（根据时间片去限制任务执行）的计算中
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;nx&quot;&gt;deadline&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;yieldInterval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// hasTimeRemaining表示任务是否还有剩余时间，
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;c1&quot;&gt;// 它和时间片一起限制任务的执行。如果没有时间，
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;c1&quot;&gt;// 或者任务的执行时间超出时间片限制了，那么中断任务。
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;
      &lt;span class=&quot;c1&quot;&gt;// 它的默认为true，表示一直有剩余时间
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;c1&quot;&gt;// 因为MessageChannel的port在postMessage，
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;c1&quot;&gt;// 是比setTimeout还靠前执行的宏任务，这意味着
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;c1&quot;&gt;// 在这一帧开始时，总是会有剩余时间
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;c1&quot;&gt;// 所以现在中断任务只看时间片的了
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hasTimeRemaining&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// scheduledHostCallback去执行任务的函数，
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;        &lt;span class=&quot;c1&quot;&gt;// 当任务因为时间片被打断时，它会返回true，表示
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;        &lt;span class=&quot;c1&quot;&gt;// 还有任务，所以会再让调度者调度一个执行者
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;        &lt;span class=&quot;c1&quot;&gt;// 继续执行任务
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;        &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hasMoreWork&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;scheduledHostCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
          &lt;span class=&quot;nx&quot;&gt;hasTimeRemaining&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
          &lt;span class=&quot;nx&quot;&gt;currentTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hasMoreWork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;// 如果没有任务了，停止调度
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;          &lt;span class=&quot;nx&quot;&gt;isMessageLoopRunning&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;nx&quot;&gt;scheduledHostCallback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;// 如果还有任务，继续让调度者调度执行者，便于继续
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;          &lt;span class=&quot;c1&quot;&gt;// 完成任务
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;          &lt;span class=&quot;nx&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;postMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;postMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;isMessageLoopRunning&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;needsPaint&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;performWorkUntilDeadline&lt;/code&gt;内部调用的是&lt;code&gt;scheduledHostCallback&lt;/code&gt;，它早在开始调度的时候就被&lt;code&gt;requestHostCallback&lt;/code&gt;赋值为了&lt;code&gt;flushWork&lt;/code&gt;，具体可以翻到上面回顾一下&lt;code&gt;requestHostCallback&lt;/code&gt;的实现。&lt;/p&gt;&lt;p&gt;&lt;code&gt;flushWork&lt;/code&gt;作为真正去执行任务的函数，它会循环taskQueue，逐一调用里面的任务函数。我们看一下&lt;code&gt;flushWork&lt;/code&gt;具体做了什么。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;flushWork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hasTimeRemaining&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;initialTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;workLoop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hasTimeRemaining&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;initialTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;它调用了&lt;code&gt;workLoop&lt;/code&gt;，并将其调用的结果return了出去。那么现在任务执行的核心内容看来就在&lt;code&gt;workLoop&lt;/code&gt;中了。&lt;code&gt;workLoop&lt;/code&gt;的调用使得任务最终被执行。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;任务中断和恢复&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;要理解&lt;code&gt;workLoop&lt;/code&gt;，需要回顾Scheduler的功能之一：通过时间片限制任务的执行时间。那么既然任务的执行被限制了，它肯定有可能是尚未完成的，如果未完成被中断，那么需要将它恢复。&lt;/p&gt;&lt;p&gt;所以时间片下的任务执行具备下面的重要特点：&lt;b&gt;会被中断，也会被恢复。&lt;/b&gt;&lt;/p&gt;&lt;p&gt;不难推测出，&lt;code&gt;workLoop&lt;/code&gt;作为实际执行任务的函数，它做的事情肯定与任务的中断恢复有关。我们先看一下它的结构：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;workLoop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hasTimeRemaining&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;initialTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 获取taskQueue中排在最前面的任务
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;nx&quot;&gt;currentTask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;currentTask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;currentTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;expirationTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hasTimeRemaining&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;shouldYieldToHost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
       &lt;span class=&quot;c1&quot;&gt;// break掉while循环
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;       &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 执行任务
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 任务执行完毕，从队列中删除
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;nx&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 获取下一个任务，继续循环
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;nx&quot;&gt;currentTask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;


  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;currentTask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 如果currentTask不为空，说明是时间片的限制导致了任务中断
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;c1&quot;&gt;// return 一个 true告诉外部，此时任务还未执行完，还有任务，
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;c1&quot;&gt;// 翻译成英文就是hasMoreWork
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 如果currentTask为空，说明taskQueue队列中的任务已经都
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;c1&quot;&gt;// 执行完了，然后从timerQueue中找任务，调用requestHostTimeout
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;c1&quot;&gt;// 去把task放到taskQueue中，到时会再次发起调度，但是这次，
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;c1&quot;&gt;// 会先return false，告诉外部当前的taskQueue已经清空，
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;c1&quot;&gt;// 先停止执行任务，也就是终止任务调度
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;
    &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;firstTimer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;timerQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;firstTimer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;requestHostTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;handleTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;firstTimer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;workLoop中可以分为两大部分：循环taskQueue执行任务 和 任务状态的判断。&lt;/p&gt;&lt;p&gt;&lt;b&gt;循环taskQueue执行任务&lt;/b&gt;&lt;/p&gt;&lt;p&gt;暂且不管任务如何执行，只关注任务如何被时间片限制，workLoop中：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;currentTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;expirationTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hasTimeRemaining&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;shouldYieldToHost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
   &lt;span class=&quot;c1&quot;&gt;// break掉while循环
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;   &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;currentTask就是当前正在执行的任务，它中止的判断条件是：任务并未过期，但已经没有剩余时间了（由于hasTimeRemaining一直为true，这与MessageChannel作为宏任务的执行时机有关，我们忽略这个判断条件，只看时间片），或者应该让出执行权给主线程（时间片的限制），也就是说currentTask执行得好好的，可是时间不允许，那只能先break掉本次while循环，使得本次循环下面currentTask执行的逻辑都不能被执行到（&lt;b&gt;此处是中断任务的关键&lt;/b&gt;）。但是被break的只是while循环，while下部还是会判断currentTask的状态。&lt;/p&gt;&lt;p&gt;由于它只是被中止了，所以currentTask不可能是null，那么会return一个true告诉外部还没完事呢（&lt;b&gt;此处是恢复任务的关键&lt;/b&gt;），否则说明全部的任务都已经执行完了，taskQueue已经被清空了，return一个false好让外部&lt;b&gt;终止本次调度&lt;/b&gt;。而workLoop的执行结果会被flushWork return出去，flushWork实际上是&lt;code&gt;scheduledHostCallback&lt;/code&gt;，当&lt;code&gt;performWorkUntilDeadline&lt;/code&gt;检测到&lt;code&gt;scheduledHostCallback&lt;/code&gt;的返回值（hasMoreWork）为false时，就会停止调度。&lt;/p&gt;&lt;p&gt;回顾&lt;code&gt;performWorkUntilDeadline&lt;/code&gt;中的行为，可以很清晰地将任务中断恢复的机制串联起来：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;  &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;performWorkUntilDeadline&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

    &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hasTimeRemaining&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// scheduledHostCallback去执行任务的函数，
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;c1&quot;&gt;// 当任务因为时间片被打断时，它会返回true，表示
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;c1&quot;&gt;// 还有任务，所以会再让调度者调度一个执行者
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;c1&quot;&gt;// 继续执行任务
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;hasMoreWork&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;scheduledHostCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;hasTimeRemaining&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;currentTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hasMoreWork&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 如果没有任务了，停止调度
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;nx&quot;&gt;isMessageLoopRunning&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;scheduledHostCallback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 如果还有任务，继续让调度者调度执行者，便于继续
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;c1&quot;&gt;// 完成任务
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;nx&quot;&gt;port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;postMessage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当任务被打断之后，&lt;code&gt;performWorkUntilDeadline&lt;/code&gt;会再让调度者调用一个执行者，继续执行这个任务，直到任务完成。但是这里有一个重点是如何判断该任务是否完成呢？这就需要研究&lt;code&gt;workLoop&lt;/code&gt;中执行任务的那部分逻辑。&lt;/p&gt;&lt;h3&gt;&lt;b&gt;判断单个任务的完成状态&lt;/b&gt;&lt;/h3&gt;&lt;p&gt;任务的中断恢复是一个重复的过程，该过程会一直重复到任务完成。所以判断任务是否完成非常重要，而任务未完成则会&lt;b&gt;重复执行任务函数&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;我们可以用递归函数做类比，如果没到递归边界，就重复调用自己。这个递归边界，就是任务完成的标志。因为递归函数所处理的任务就是它本身，可以很方便地把任务完成作为递归边界去结束任务，但是Scheduler中的&lt;code&gt;workLoop&lt;/code&gt;与递归不同的是，它只是一个执行任务的，这个任务并不是它自己产生的，而是外部的（比如它去执行React的工作循环渲染fiber树），它可以做到重复执行任务函数，但边界（即任务是否完成）却无法像递归那样直接获取，只能依赖任务函数的返回值去判断。即：&lt;b&gt;若任务函数返回值为函数，那么就说明当前任务尚未完成，需要继续调用任务函数，否则任务完成&lt;/b&gt;。&lt;code&gt;workLoop&lt;/code&gt;就是通过这样的办法&lt;b&gt;判断单个任务的完成状态&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;在真正讲解&lt;code&gt;workLoop&lt;/code&gt;中的执行任务的逻辑之前，我们用一个例子来理解一下判断任务完成状态的核心。&lt;/p&gt;&lt;p&gt;有一个任务calculate，负责把currentResult每次加1，一直到3为止。当没到3的时候，calculate不是去调用它自身，而是将自身return出去，一旦到了3，return的是null。这样外部才可以知道calculate是否已经完成了任务。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentResult&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;calculate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;currentResult&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;currentResult&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;calculate&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上面是任务，接下来我们模拟一下调度，去执行calculate。但执行应该是基于时间片的，为了观察效果，只用setInterval去模拟因为时间片中止恢复任务的机制（相当粗糙的模拟，只需明白这是时间片的模拟即可，重点关注任务完成状态的判断），1秒执行它一次，即一次只完成全部任务的三分之一。&lt;/p&gt;&lt;p&gt;另外Scheduler中有两个队列去管理任务，我们暂且只用一个队列（taskQueue）存储任务。除此之外还需要三个角色：把任务加入调度的函数（调度入口scheduleCallback）、开始调度的函数（requestHostCallback）、执行任务的函数（workLoop，关键逻辑所在）。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentResult&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;calculate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;currentResult&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;currentResult&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;calculate&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 存放任务的队列
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;taskQueue&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 存放模拟时间片的定时器
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;interval&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 调度入口----------------------------------------
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;scheduleCallback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 创建一个专属于调度器的任务
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;taskItem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;priority&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 向队列中添加任务
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;nx&quot;&gt;taskQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;push&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskItem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 优先级影响到任务在队列中的排序，将优先级最高的任务排在最前面
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;nx&quot;&gt;taskQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;priority&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;priority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 开始执行任务，调度开始
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;nx&quot;&gt;requestHostCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;workLoop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 开始调度-----------------------------------------
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;requestHostCallback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;cb&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;interval&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;setInterval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 执行任务-----------------------------------------
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;workLoop&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 从队列中取出任务
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentTask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;taskQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 获取真正的任务函数，即calculate
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;taskCallback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 判断任务函数否是函数，若是，执行它，将返回值更新到currentTask的callback中
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;c1&quot;&gt;// 所以，taskCallback是上一阶段执行的返回值，若它是函数类型，则说明上一次执行返回了函数
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;c1&quot;&gt;// 类型，说明任务尚未完成，本次继续执行这个函数，否则说明任务完成。
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;taskCallback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;function&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;currentTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;taskCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;正在执行任务，当前的currentResult 是&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 任务完成。将当前的这个任务从taskQueue中移除，并清除定时器
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;        &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;&#x27;任务完成，最终的 currentResult 是&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentResult&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;taskQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;shift&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;clearInterval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;interval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 把calculate加入调度，也就意味着调度开始
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;nx&quot;&gt;scheduleCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;calculate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最终的执行结果如下：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-text&quot;&gt;正在执行任务，当前的currentResult 是 1
正在执行任务，当前的currentResult 是 2
正在执行任务，当前的currentResult 是 3
任务完成，最终的 currentResult 是 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可见，如果没有加到3，那么calculate会return它自己，&lt;b&gt;workLoop若判断返回值为function，说明任务还未完成，它就会继续调用任务函数去完成任务&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;这个例子只保留了workLoop中判断任务完成状态的逻辑，其余的地方并不完善，要以真正的的workLoop为准，现在让我们贴出它的全部代码，完整地看一下真正的实现：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;workLoop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hasTimeRemaining&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;initialTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;initialTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 开始执行前检查一下timerQueue中的过期任务，
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;c1&quot;&gt;// 放到taskQueue中
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;nx&quot;&gt;advanceTimers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;currentTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// 获取taskQueue中最紧急的任务
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;nx&quot;&gt;currentTask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 循环taskQueue，执行任务
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;currentTask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;enableSchedulerDebugging&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;isSchedulerPaused&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;currentTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;expirationTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hasTimeRemaining&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;shouldYieldToHost&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 时间片的限制，中断任务
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 执行任务 ---------------------------------------------------
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;c1&quot;&gt;// 获取任务的执行函数，这个callback就是React传给Scheduler
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;c1&quot;&gt;// 的任务。例如：performConcurrentWorkOnRoot
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;function&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 如果执行函数为function，说明还有任务可做，调用它
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;nx&quot;&gt;currentTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 获取任务的优先级
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;nx&quot;&gt;currentPriorityLevel&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;priorityLevel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 任务是否过期
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;didUserCallbackTimeout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;expirationTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 获取任务函数的执行结果
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;continuationCallback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;didUserCallbackTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;continuationCallback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;function&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 检查callback的执行结果返回的是不是函数，如果返回的是函数，则将这个函数作为当前任务新的回调。
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;        &lt;span class=&quot;c1&quot;&gt;// concurrent模式下，callback是performConcurrentWorkOnRoot，其内部根据当前调度的任务
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;        &lt;span class=&quot;c1&quot;&gt;// 是否相同，来决定是否返回自身，如果相同，则说明还有任务没做完，返回自身，其作为新的callback
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;        &lt;span class=&quot;c1&quot;&gt;// 被放到当前的task上。while循环完成一次之后，检查shouldYieldToHost，如果需要让出执行权，
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;        &lt;span class=&quot;c1&quot;&gt;// 则中断循环，走到下方，判断currentTask不为null，返回true，说明还有任务，回到performWorkUntilDeadline
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;        &lt;span class=&quot;c1&quot;&gt;// 中，判断还有任务，继续port.postMessage(null)，调用监听函数performWorkUntilDeadline（执行者），
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;        &lt;span class=&quot;c1&quot;&gt;// 继续调用workLoop行任务
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;
        &lt;span class=&quot;c1&quot;&gt;// 将返回值继续赋值给currentTask.callback，为得是下一次能够继续执行callback，
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;        &lt;span class=&quot;c1&quot;&gt;// 获取它的返回值，继续判断任务是否完成。
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;        &lt;span class=&quot;nx&quot;&gt;currentTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;continuationCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;currentTask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;nx&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;advanceTimers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;currentTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 从taskQueue中继续获取任务，如果上一个任务未完成，那么它将不会
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;c1&quot;&gt;// 被从队列剔除，所以获取到的currentTask还是上一个任务，会继续
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;c1&quot;&gt;// 去执行它
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;nx&quot;&gt;currentTask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// return 的结果会作为 performWorkUntilDeadline
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;c1&quot;&gt;// 中判断是否还需要再次发起调度的依据
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;currentTask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 若任务完成，去timerQueue中找需要最早开始执行的那个任务
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;c1&quot;&gt;// 调度requestHostTimeout，目的是等到了它的开始事件时把它
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;c1&quot;&gt;// 放到taskQueue中，再次调度
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;firstTimer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;timerQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;firstTimer&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;nx&quot;&gt;requestHostTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;handleTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;firstTimer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;startTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;所以，&lt;b&gt;workLoop是通过判断任务函数的返回值去识别任务的完成状态的&lt;/b&gt;。&lt;/p&gt;&lt;p&gt;总结一下判断任务完成状态与任务执行的整体关系：当开始调度后，调度者调度执行者去执行任务，实际上是执行任务上的callback（也就是任务函数）。如果执行者判断callback返回值为一个function，说明未完成，那么会将返回的这个function再次赋值给任务的callback，由于任务还未完成，所以并不会被剔除出taskQueue，currentTask获取到的还是它，while循环到下一次还是会继续执行这个任务，直到任务完成出队，才会继续下一个。&lt;/p&gt;&lt;p&gt;另外有一个点需要提一下，就是构建fiber树的任务函数：&lt;code&gt;performConcurrentWorkOnRoot&lt;/code&gt;，它接受的参数是fiberRoot。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;performConcurrentWorkOnRoot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在workLoop中它会被这样调用（callback即为&lt;code&gt;performConcurrentWorkOnRoot&lt;/code&gt;）：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;didUserCallbackTimeout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;expirationTime&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;continuationCallback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;didUserCallbackTimeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;didUserCallbackTimeout&lt;/code&gt;明显是boolean类型的值，并不是fiberRoot，但performConcurrentWorkOnRoot却能正常调用。这是因为在开始调度，以及后续的return自身的时候，都在bind的时候将root传进去了。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;c1&quot;&gt;// 调度的时候
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;nx&quot;&gt;scheduleCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;schedulerPriorityLevel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nx&quot;&gt;performConcurrentWorkOnRoot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 其内部return自身的时候
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;performConcurrentWorkOnRoot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callbackNode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;originalCallbackNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;performConcurrentWorkOnRoot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这样的话，再给它传参数调用它，那这个参数只能作为后续的参数被接收到，&lt;code&gt;performConcurrentWorkOnRoot&lt;/code&gt;中接收到的第一个参数还是bind时传入的那个root，这个特点与bind的实现有关。可以跑一下下面的这个简单例子：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;runTest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;root&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nx&quot;&gt;runTest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()(&lt;/span&gt;&lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 结果：root false
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上，是Scheduler执行任务时的两大核心逻辑：任务的中断与恢复 &amp;amp; 任务完成状态的判断。它们协同合作，若任务未完成就中断了任务，那么调度的新执行者会恢复执行该任务，直到它完成。到此，Scheduler的核心部分已经写完了，下面是取消调度的逻辑。&lt;/p&gt;&lt;h2&gt;&lt;b&gt;取消调度&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;通过上面的内容我们知道，任务执行实际上是执行的任务的callback，当callback是function的时候去执行它，当它为null的时候会发生什么？当前的任务会被剔除出taskQueue，让我们再来看一下workLoop函数：&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;workLoop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;hasTimeRemaining&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;initialTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

  &lt;span class=&quot;c1&quot;&gt;// 获取taskQueue中最紧急的任务
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;  &lt;span class=&quot;nx&quot;&gt;currentTask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;currentTask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentTask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#x27;function&#x27;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 执行任务
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 如果callback为null，将任务出队
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;      &lt;span class=&quot;nx&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;currentTask&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;peek&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;taskQueue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;所以取消调度的关键就是将当前这个任务的callback设置为null。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;unstable_cancelCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

  &lt;span class=&quot;nx&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callback&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为什么设置callback为null就能取消任务调度呢？因为在workLoop中，如果callback是null会被移出taskQueue，所以当前的这个任务就不会再被执行了。它取消的是当前任务的执行，while循环还会继续执行下一个任务。&lt;/p&gt;&lt;p&gt;取消任务在React的场景是什么呢？当一个更新任务正在进行的时候，突然有高优先级任务进来了，那么就要取消掉这个正在进行的任务，这只是众多场景中的一种。&lt;/p&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-js&quot;&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;ensureRootIsScheduled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;FiberRoot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;currentTime&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;number&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;existingCallbackNode&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!==&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;existingCallbackPriority&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;callbackPriority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;existingCallbackPriority&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;===&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;newCallbackPriority&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 取消掉原有的任务
&lt;/span&gt;&lt;span class=&quot;c1&quot;/&gt;    &lt;span class=&quot;nx&quot;&gt;cancelCallback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;existingCallbackNode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2&gt;&lt;b&gt;总结&lt;/b&gt;&lt;/h2&gt;&lt;p&gt;Scheduler用任务优先级去实现多任务的管理，优先解决高优任务，用任务的持续调度来解决时间片造成的单个任务中断恢复问题。任务函数的执行结果为是否应该结束当前任务的调度提供参考，另外，在有限的时间片内完成任务的一部分，也为浏览器响应交互与完成任务提供了保障。&lt;/p&gt;&lt;p&gt;欢迎扫码关注公众号，发现更多技术文章&lt;/p&gt;&lt;figure data-size=&quot;normal&quot;&gt;&lt;noscript&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-87a343e0f483ccf1cfe6a34d13eab65e_b.jpg&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;200&quot; data-rawheight=&quot;200&quot; class=&quot;content_image&quot;/&gt;&lt;/noscript&gt;&lt;img src=&quot;&quot; data-caption=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;200&quot; data-rawheight=&quot;200&quot; class=&quot;content_image lazy&quot; data-actualsrc=&quot;https://pic3.zhimg.com/v2-87a343e0f483ccf1cfe6a34d13eab65e_b.jpg&quot;/&gt;&lt;/figure&gt;&lt;p/&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</content:encoded>
</item>
</channel></rss>